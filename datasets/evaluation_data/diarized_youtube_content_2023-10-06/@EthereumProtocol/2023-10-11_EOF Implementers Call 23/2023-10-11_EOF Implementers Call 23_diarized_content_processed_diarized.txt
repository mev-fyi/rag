00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:03.730 - 00:00:20.960, Speaker B: Hey everyone, welcome to the EOF implementers call number 23. Let's just go ahead and get started with client updates really fast and then we can get into the open questions that Andre summarized. So does any client want to share what they've been up to the last few weeks?
00:00:26.650 - 00:00:27.750, Speaker C: Denkun.
00:00:31.460 - 00:00:32.210, Speaker A: All.
00:00:35.340 - 00:00:39.000, Speaker B: I assume most people are thinking about Dinkun.
00:00:47.760 - 00:01:16.390, Speaker D: We also don't have much in the vm one related to EOF, but one thing. We implemented grade four instruction, but haven't tested it thoroughly yet because we first need to implement blocked transactions support, and then grade four transactions are extending those. So we are blocked by that a bit. But construction itself is very similar to grade three, so it's not much complexity there.
00:01:17.240 - 00:01:21.024, Speaker B: Sorry, could you say again why it's blocked on blob transaction?
00:01:21.152 - 00:01:32.810, Speaker D: It's just create four transactions are extending blob transactions and adding new fields there. So we first need to support blob transactions and then extend those.
00:01:34.240 - 00:01:40.190, Speaker C: Why would you blob transactions require blobs, don't they? So we can't extend that.
00:01:43.440 - 00:01:43.948, Speaker A: Right?
00:01:44.034 - 00:01:56.742, Speaker B: I don't think a blob transaction can be included without minimum one. Blob transactions.
00:01:56.886 - 00:01:57.242, Speaker A: Yeah.
00:01:57.296 - 00:02:20.740, Speaker B: So blob transactions, I wouldn't think of them as the next progression of transactions. It's actually a very specialized transaction type specifically for roll ups, and it doesn't support any contract creation behavior. So I think that if you're doing this create for transaction, it should just be an extension of the 1559 transaction without a blobs field.
00:02:23.110 - 00:02:34.360, Speaker D: Does this mean then that we either use create four or blobs in transaction and we can't use both?
00:02:39.210 - 00:03:32.726, Speaker B: It's, I think, one of the original design goals. Maybe not design goal, but a thought with blob transactions is that creating contracts and including blobs is not a very relevant use case. And yeah, we just didn't want to support it because of the additional testing surface it requires. Because as you know, whenever you have these things, you have to test both how things behave with a knit code, how things behave if you call code. And so the idea was just, let's make it so that it's not possible to create with blob transactions. And I think with create four, we probably also are happy with that. Because the thing is, if we add create four to blob transactions, then we also have to do it for 1559 transactions.
00:03:32.726 - 00:03:44.880, Speaker B: Because blob transactions are extremely specialized. And yeah, it's not really the transaction type that will become like the majority used transaction type.
00:03:47.170 - 00:03:48.560, Speaker D: Yeah, it makes sense.
00:03:50.130 - 00:04:01.060, Speaker C: So there's a corner case where they would both be creating a blob and wanting to do create for in a transaction. Do we just prohibit that? You can't post a blob and do a create for.
00:04:03.990 - 00:04:18.070, Speaker B: Does create four add additional fields to the transaction type? Is that the thing? And then it uses that stuff? Yeah. What happens if you call create four from a legacy transaction type? It just fails.
00:04:26.170 - 00:04:51.700, Speaker C: I would hope it would. See, I think create four needs integration with the protocol, and I think notionally create four is the idea of how we do it. But I think the specs of how we're doing it are going to change dramatically when it actually gets implemented. I think it works better in an SSZ world where we have an SSZ transaction where you magically add whatever other pieces you need and take out what you don't. But I don't think we're there.
00:04:54.310 - 00:04:55.060, Speaker A: Interesting.
00:05:05.770 - 00:05:23.850, Speaker B: Okay. Yeah, maybe something to further discuss, but yeah, as of right now, Bob, transactions are super specialized. I would not extend it with the create four fields. I would do that for the 1559 transaction.
00:05:26.130 - 00:05:26.880, Speaker A: Great.
00:05:27.330 - 00:05:35.520, Speaker B: That's probably all the updates do we want to jump into? Well, I guess anything from Viper's side in the last couple of weeks.
00:05:40.710 - 00:05:53.080, Speaker A: Hey, I just joined the call. Nothing new. But yeah, it looks like Andre put together this list of open questions, so maybe we should just talk about those.
00:05:55.690 - 00:06:00.070, Speaker B: Yeah, let's do it. Andre, do you want to jump into the questions you posted?
00:06:01.210 - 00:07:09.120, Speaker D: Yeah, there's much new, nothing new, and we've discussed this over past meetings, and I don't think there's much new from our side regarding. So for the first one, I have one thought. So this is Charles'idea to not do deploy time validation of first level subcontainers and then avoid doing it grade three execution. So for me, this seems like some kind of inconsistency or like creating the context dependent behavior of grade three, because some grade threes then will not do this runtime validation, but some will still have to do it because grade three can be nested one, not at the first level. So if unit code contains another grade three, then it will have to do the validation still. So that's my current thinking about this.
00:07:09.890 - 00:07:44.458, Speaker C: My hang up on this is there are some validations that will fail when it's as a subcontainer, but when it's inflated with auxiliary data, it'll pass. So if you're appending data, that data operation is referring to the immediate mode one, that one would fail. So it's possible to have contracts that could become legal when create three, but that wouldn't be legal within the subcontainer. So I think it's cleaner just to not validate anything that's in the subcontainer and take the runtime hit. We're charging gas for it anyway.
00:07:44.624 - 00:07:51.980, Speaker D: Yeah, this applies to deployed code only. As I understand Charles's idea, it's about validating init code.
00:07:54.770 - 00:08:22.200, Speaker C: Similarly, I don't think we should validate until we're actually about to instantiate the contract, because the validation could change. What if you append enough data such that the data read operation succeeds in the immediate mode? Or what if you don't append enough? It could change. What's in the container can be invalid, but you add enough auxiliary data, suddenly it is valid. So that's the problem I see there.
00:08:26.410 - 00:08:48.400, Speaker A: That's interesting. I think my idea about validating the init code is just the code itself, not like it just basically caches the step that you're going to do every single time at runtime. But I think I actually don't understand the new create semantics as well as other people in this call.
00:08:51.170 - 00:09:18.390, Speaker C: I would think that would be a client optimization that they could do. They could do a pre validation. But if we were to have some things that could validate partially and different things, we only have one level of validation right now, either the whole contract as it is as valid or it isn't. And to do that efficiently, we would need to introduce another form of validation where everything except for from the data load and operation is validated.
00:09:23.630 - 00:09:50.420, Speaker A: I think there's some kind of benefit to having typed in it code. So instead of just saying we're going to load some data from some data section and deploy it to say this section is definitely init code and it's going to function as a knit code and we're going to hopefully call deploy on it at some point.
00:09:51.190 - 00:10:05.930, Speaker C: Right, but we don't have a mode where you validate just the code sections. And besides, data load n is one of those codes we would need to validate and would then need to validate. It would need a reference legal spot in the data section.
00:10:14.940 - 00:10:19.752, Speaker A: Is that like a nested data section? So it's like a data section in the init code? Is that what you're saying?
00:10:19.806 - 00:10:24.220, Speaker C: Yeah, it would be a nested data section. It would be within the container.
00:10:26.880 - 00:10:36.400, Speaker A: Why can init code has a data section?
00:10:38.740 - 00:11:23.390, Speaker C: So init code is its own EOF container, and then the deployed contract is its own EOF container. Within that, if you click on my create f one, there's a visual in that which for createf, by the way, I want to kind of withdraw it. There's issues with it. But if you look at the factory contract. Let me go ahead and share. Make this smaller so it's not going to blow everyone's screen up. Here we go.
00:11:23.390 - 00:12:09.468, Speaker C: So here's your factory contract, which is this whole thing is the container, including both code and data sections you call create three. You reference a container within it. So this entire container contains anit code and possibly data. And the one underneath it, actually the one that we're deploying, is too deep. And if you go even deeper, the deployer itself would have its own wrapper contract that you would in it. This is just the fallout of how create three is defined. So the data section you would refer to, your entire init code would be one entire container, and it would deploy another contract inside of it.
00:12:09.468 - 00:13:41.860, Speaker C: It's just the nature of how a knit code was defined to work inside of Ethereum and how people are going to expect it. So it's like the weird intersection of how we want subcontainers to work and how a knit code is defined to work. So every factory contract is going to have at least two nested layers of subcontracts. I think whoever was working on solidity gone through this a few months ago. Have you been saying some stuff, Charles, or have you been on mute the whole.
00:13:42.010 - 00:14:11.710, Speaker A: No, I'm just listening. Yeah. So, I mean, I think that this thing in your diagram called child contract, init code can be validated, but maybe I'm still missing something.
00:14:19.410 - 00:14:20.160, Speaker C: It.
00:14:21.750 - 00:14:51.230, Speaker D: Yeah, I think that is true, because this data load and validation problem is only a problem because we append the auxiliary data to data section, and this is for the container that has been deployed. But this child contract in it code is in it code container. It's another container. And even if it has data load, then the data section won't be changed. So theoretically we could kind of cache.
00:14:54.050 - 00:15:09.620, Speaker C: But then we would need to have two separate validation modes, because when we validate this container in and of itself and execute it, we would not validate this one because we're validating this container as a container, and then we wouldn't validate this one.
00:15:11.270 - 00:15:13.614, Speaker D: It's just first level validation.
00:15:13.742 - 00:15:27.400, Speaker C: And first level in which context? Because then we have this one where we'd have to do the init code. When we come in at the beginning of a transaction, the actual contract that gets deployed doesn't validate this first level. That's in.
00:15:29.310 - 00:15:43.760, Speaker D: Yeah, that is true. So it seems that it's difficult even to distinguish which level we are at when we're executing. So I'm suspecting it's not impossible. In the end.
00:15:54.790 - 00:16:07.990, Speaker C: I think it's either full validation all the way to the bottom or top level validation only are the only two solutions that will survive as an attack surface.
00:16:30.650 - 00:16:42.170, Speaker A: Yeah, I'm looking at the mega spec and there's these references to init code mode, but it's not really defined.
00:16:47.230 - 00:16:49.180, Speaker C: I think that's a runtime change.
00:16:52.110 - 00:16:52.426, Speaker A: And.
00:16:52.448 - 00:16:54.430, Speaker C: That has to do with return contract.
00:17:07.280 - 00:17:11.710, Speaker D: Unit code mode is execution of container given to create three.
00:17:12.720 - 00:17:21.090, Speaker C: Yes. And we turn on return contract, and we turn off return and stop.
00:17:54.410 - 00:18:18.250, Speaker A: Maybe I need to think about this more, but it kind of seems tractable. Right. Especially because data and code is now separated. So now you can be like, oh, well, we know all the code that could possibly be deployed out of this contract, even nested contracts.
00:18:20.830 - 00:18:32.430, Speaker C: But we don't know if it's valid because we would then require, because of data load n. Some of those init codes would need to be deployed with extended code section. With extended data sections to become valid.
00:18:37.510 - 00:18:43.650, Speaker D: Yeah, we kind of don't know which containers will be given to create three and which will be given to return contract.
00:18:47.770 - 00:19:12.990, Speaker A: Yeah. Um, it's interesting that the returned contract is always like a nested container because it could actually be a pointer to a section in the factory contract.
00:19:17.400 - 00:19:22.170, Speaker D: It should be a container because we deploy entire container with data section and everything.
00:19:23.100 - 00:19:40.268, Speaker A: Yeah. I'm saying here where child contract, init code is inside of the factory contract. I'm wondering if this problem gets fixed, if the child contract gets unnested, how.
00:19:40.274 - 00:19:47.170, Speaker C: Do I go into edit mode? Yeah. So we pull child contract to the same side as the init code.
00:19:48.020 - 00:19:48.770, Speaker A: Yeah.
00:20:06.600 - 00:20:09.910, Speaker C: Sign into hackmd so I can edit it.
00:20:11.880 - 00:20:12.790, Speaker A: All right.
00:20:17.260 - 00:20:20.490, Speaker C: Can I edit my stuff now? Here we go.
00:20:44.130 - 00:20:44.880, Speaker A: It.
00:20:47.490 - 00:20:58.210, Speaker D: I think that would mean that init code at the point of return contract is referencing a container that is outside of the current container, which is weird.
00:21:00.870 - 00:21:03.060, Speaker C: But it's because you're executing it in an it code.
00:21:03.430 - 00:21:04.226, Speaker A: Right.
00:21:04.408 - 00:21:10.230, Speaker C: But how would that work for the deployer? How would that work for a top level deployer, though? Because you'd have to contain.
00:21:11.850 - 00:21:12.166, Speaker A: Yeah.
00:21:12.188 - 00:21:13.800, Speaker C: You would still have to contain it.
00:21:14.250 - 00:21:18.120, Speaker A: Yeah. You can't have like a deployer of a deployer. Of a deployer or something like this.
00:21:20.090 - 00:21:53.900, Speaker C: The deployer is the knit code, and it couldn't have pure code. It would have to have child code. So I think these nested containers are just what we have to deal with. So when you do it from a top level transaction, you can't append data. You have to bring it in with all the data you want, which is fine because you control the transaction. It's just the case of these factory contracts where you need to append data to deal with things like immutable values.
00:21:54.320 - 00:22:06.796, Speaker A: Yeah, right. But I mean, this child contract in it code container is not actually like a regular container, right? It can only be run in init code mode.
00:22:06.828 - 00:22:13.236, Speaker C: Actually, it still has access to every other operation. It could do everything else, but it.
00:22:13.258 - 00:22:32.410, Speaker A: Can'T do return or stop. So if you know that child contract init code has like a flag that marks it as init code, then you can validate its child code sections. I think. Yeah, I mean, again, I'm not as close to the implementation as a lot of people.
00:22:32.480 - 00:22:53.570, Speaker C: Here's, I think these init code mode errors are tagged as runtime, not validation errors. You can have return contract anywhere. It's just when you're executing it, if you're not in init code mode, it becomes an invalid operation. So it's not a validation error.
00:22:57.590 - 00:23:03.800, Speaker A: Is that a, is that a desired property?
00:23:05.130 - 00:23:20.250, Speaker C: It's simpler. It makes it easy to validate, because you validate every code on the same standards. It's just at runtime, you do the return contract, you check, am I in it code mode? If so, you would return the contract.
00:23:21.150 - 00:23:23.870, Speaker A: It is a little bit simpler.
00:23:25.170 - 00:23:32.000, Speaker C: The reason we need return contract is so we can give auxiliary data to the subcontract, which may have been passed in from the parent.
00:23:32.690 - 00:23:51.786, Speaker A: Right, I see that. By the way. Sorry, the oxid is passing from the parent in memory.
00:23:51.978 - 00:24:08.790, Speaker C: Yeah. So let's say our factory contract is a pool, and we have our two ERC 20 contracts. We pass those two data as call data, not as call data, as auxiliary data. This executes. It pulls the auxiliary data and passes the auxiliary data again to the actual deployed pool contract.
00:24:09.290 - 00:24:15.130, Speaker A: Yeah, I think a spec wording could be clarified a little bit to say that Oxdata is coming from memory.
00:24:16.030 - 00:24:51.490, Speaker C: It's not coming from memory, it's coming from the actual data section return contract. So when we're in the child contract init code, that contract would have been manipulated to add the extra data to the data section. So factory contract calls this, we have aux data. We rewrite this with the Aux data included in the data section. So it executes this, it pulls data from its data section and passes that in as aux data. In a child contract.
00:24:53.350 - 00:24:55.800, Speaker D: Yeah, but Oxdata is from memory actually.
00:24:58.170 - 00:25:05.830, Speaker C: Right. So you'd have to take it from your data section, load it into memory, and then in the return data contract, return that memory section.
00:25:06.170 - 00:25:13.578, Speaker A: Sure. So return contract. These Aux data offset and aux data size are referring to something in memory, right?
00:25:13.744 - 00:25:14.460, Speaker C: Yes.
00:25:15.550 - 00:25:30.850, Speaker A: I think the spec can be clarified with that's because it could be pointing to some data section.
00:26:01.230 - 00:26:02.570, Speaker C: Don't have an ethereum.
00:26:20.080 - 00:26:33.280, Speaker A: Conversation is kind of illustrating for me is that maybe init code mode is different enough to warrant slightly different validation rules.
00:26:35.300 - 00:26:44.336, Speaker C: I don't feel it is. Unless we would need to put a flag in the container to say this is in a knit code container, and that's how we would need to signal it.
00:26:44.518 - 00:26:46.820, Speaker A: Yes, I mean, I think that's good anyways.
00:26:47.240 - 00:27:17.260, Speaker C: And then we would have two separate validation checks. And right now we only have one set of validation checks that every container must pass. And I think that's more problematic place to introduce bugs than if we have that flag at runtime where you run your operation. You see, you're not in init code mode, which the clients already have in a nit code mode set up to handle. So you see, you're in a knit code mode and this operation is invalid because you're not in a nit code mode.
00:27:18.320 - 00:27:35.750, Speaker A: Yeah, and I thought that the point of EOF is to make code more safe, so it kind of doesn't align with that goal, because now we're introducing instructions that are mode dependent whether they're valid or not.
00:27:37.160 - 00:27:57.592, Speaker C: So the safety also comes in an engineering perspective. I don't think splitting it a two init code, two validation modes is warranted for this small of a change. For me to support multiple validation modes, I would want some better return. There's runtime safety and there's engineering safety.
00:27:57.736 - 00:28:21.010, Speaker A: What multiple validation modes buys us is that we can validate in it code at deploy time, not at runtime, which I think pays off in the end, because paying the cost of validating code from the factory every time you want to run a deploy operation can add up.
00:28:24.520 - 00:28:28.180, Speaker C: But that cost is built into the cost of the create operation.
00:28:29.240 - 00:28:35.384, Speaker A: We've added a nit code, so it's a cost that's borne by users, right?
00:28:35.422 - 00:28:38.628, Speaker C: So it's paid for, it's appropriately billed and handled.
00:28:38.804 - 00:28:46.904, Speaker A: I'm saying that if we maybe have different validation for init code, then users don't have to bear that cost.
00:28:47.102 - 00:29:00.248, Speaker C: But we still have the problem that to validate a nested container, we would have to have different rules for data load n to deal with whether or not enough data is being passed in or not. We still couldn't validate it until runtime.
00:29:00.344 - 00:29:11.680, Speaker A: Actually, because I don't understand, it seems like data load n is okay even in init code mode.
00:29:12.680 - 00:29:23.460, Speaker C: It's not the init code mode, it's validating it because it might be pointing to data. Let me find validation rules. Code validation.
00:29:32.630 - 00:29:52.060, Speaker A: Embedded in it container may have data load and instructions referring to data in oxdata part, that is when. So this is like when you call return contract, right?
00:29:53.710 - 00:29:56.762, Speaker C: Right. And return contract is then we can validate it.
00:29:56.896 - 00:30:03.760, Speaker A: So this is after init code runs and during return contract execution, right?
00:30:04.290 - 00:30:21.190, Speaker C: Right. In the child contract and potentially the init code contract.
00:30:23.290 - 00:30:25.538, Speaker A: Why does it apply in the init code contract?
00:30:25.714 - 00:30:28.950, Speaker C: Because the init code contract can also have auxiliary data applied.
00:30:33.770 - 00:30:37.590, Speaker A: Because itself is like being returned from return contract.
00:30:39.370 - 00:30:59.756, Speaker C: No, because it's being called create three. Contains the auxiliary data. Create three pops, value salt, data offset, data size. And what's data offset?
00:30:59.788 - 00:31:00.480, Speaker A: Dude?
00:31:06.180 - 00:31:08.850, Speaker C: Is the aux data passed through without.
00:31:10.340 - 00:31:25.460, Speaker D: Not necessarily data offset and data sets is just input to create three execution and can be passed through, can be modified and passed through, or whatever.
00:31:26.310 - 00:31:34.946, Speaker C: Yeah, but we have to concatenate the data section here as part of the execution. That's in return data contract.
00:31:35.058 - 00:32:13.902, Speaker A: Yeah, I'm thinking quickly here, but can't we have a special rule for data load n inside init mode? In it code mode, which is like, we only need to do data load n validation or something, because by the time that we get to return contract, we already have a lot of data. We already have a lot of information about the deployed code. The only thing we don't know is the size of the aux data that's passed. So when you call return contract, you can just validate that oxdata offset and aux data lane are like inbound.
00:32:13.966 - 00:32:18.440, Speaker C: That sounds like a client optimization, not something we should write into the spec. That's my take on it.
00:32:22.810 - 00:32:44.860, Speaker A: Well, client optimization, yeah, I think my position is that it kind of is a client optimization, but if it can improve the gas schedule for users, then that is also good for the entire network, right?
00:32:45.470 - 00:33:35.910, Speaker C: Yeah, but I think the risk of introducing this level of complexity into the spec is not worth the gas savings. It's going to result in a fork more likely than the amount of savings we're going to get damaged from the fork is going to be more than the gas savings we'll get from the end user on a net cost basis. Multiplying the impact by the likelihood, should we table this as unresolved and look at some of the other open issues to see if we can resolve some of those?
00:33:36.360 - 00:33:49.850, Speaker A: Yeah, I think we're kind of all on the same page, and I think the only question is if the benefit is worth the trade off or if there's some way of thinking about it that makes it easier to reason about.
00:33:50.540 - 00:34:09.520, Speaker C: Yeah. So one is unresolved to a create three variant that adds address parameters to get a nit code from a container of another account. So Andre, what was this specifically?
00:34:12.580 - 00:34:27.270, Speaker D: Yeah, it was Charles'idea. Also, my take on this is that is also like addition that we could live without. And I wouldn't add it into the first version, probably.
00:34:27.880 - 00:34:30.740, Speaker C: Okay. Because we could create makeup.
00:34:31.400 - 00:34:31.972, Speaker D: Go ahead.
00:34:32.026 - 00:34:38.730, Speaker A: Nice to have. My concern is that pushing any features out makes it very difficult to get them in later.
00:34:42.390 - 00:34:52.600, Speaker C: Unless they're breaking changes, I think we can bring them in. And I don't think a create copy operation, which is kind of what this is, would be a breaking change.
00:34:52.970 - 00:34:57.640, Speaker A: It took us like three years to get M copy in.
00:35:00.330 - 00:35:26.630, Speaker C: Yeah, it didn't get the right attention in all core devs. True. So create three is bubble. I don't think there's opposition to it other than size. I don't think there's a standards spec concern for it. So resolve that as space available.
00:35:27.480 - 00:35:39.230, Speaker A: Yeah, the other thing is to have create three. Just always take an address perimeter.
00:35:40.210 - 00:35:52.450, Speaker C: But then how would we get the contract loaded in initially? I think that was one of the proposals to have all contracts just be copied with memory sets. But how do you see the first one to get out there? How do you just drop contracts in the locations?
00:35:57.430 - 00:36:02.040, Speaker A: To get the current behavior of create three? You would just call create three with like address.
00:36:02.970 - 00:36:22.870, Speaker C: Right, but it's pointing to an address of an existing contract. How do we get that first contract onto the chain? So this wouldn't be a replacement for create three, it'd be a new thing.
00:36:24.920 - 00:36:28.020, Speaker A: I mean, how does create three get contracts on chain?
00:36:29.400 - 00:36:42.250, Speaker C: So you can take an entire EOF container in a contract creation transaction and execute that. That's how the spec is currently written that represents this situation.
00:36:46.240 - 00:36:57.308, Speaker A: Then the create message call or the create transaction won't run in the first place. It.
00:36:57.394 - 00:37:12.260, Speaker C: So what's going to wind up deploying at the address is the factory contract, and during init code, it runs the code from this container. But that's not the code at the address, it's the code at the init code. It's just the weird way init code works in Ethereum right now, even before EOF.
00:37:12.600 - 00:37:22.950, Speaker A: Wait, I thought that the way you deploy contracts in UF is to use create for extra transaction type.
00:37:24.040 - 00:37:48.930, Speaker C: Create for is how you would do it in something like a smart contract wallet, where you would need to specify the contract outside of the contract you're deploying. So right now, the way it's specified, only eoas can deploy contracts and create four is how smart contract wallets would create contracts, which has its own set of issues that I'd like to discuss in due time.
00:37:51.460 - 00:38:05.270, Speaker A: Um, so I must be missing something again, which is like, how do contracts like right now to deploy contracts, you just send them to the create address, right?
00:38:06.920 - 00:38:47.650, Speaker C: Right. You would do a 1559 transaction, and the input data would be the entire EOF container. And so the client would see that it's an EOF container that we're running, and it would validate the container. It would start executing operation zero. But the code does not exist yet until we get return contract. And at that point, all of the contract storage that has been set is part of the construction. And that contract data, that's done by return contract data, if it's invalidated, those get put in the new account address, and during a nit code, it executes as though it's in the address of the contract that's going to be created without any of its code.
00:38:48.100 - 00:38:55.888, Speaker A: Right. So, I mean, there's no create three yet, right? All there is is create, sorry, return contract in this initial creation transaction.
00:38:56.064 - 00:39:01.220, Speaker C: So without create three, the only way to create EOF contract is just through a create transaction.
00:39:02.060 - 00:39:08.250, Speaker A: Right, sorry, what's the problem then?
00:39:09.980 - 00:39:14.670, Speaker C: I'm not sure you were the one expressing the problem. I was explaining in the spec.
00:39:16.480 - 00:39:21.630, Speaker A: I mean, what's the problem with adding an address argument to create three?
00:39:23.440 - 00:40:06.750, Speaker C: So that's an entirely different form of create. Adding address to create three is changing to create three to always copy existing contracts that are out there. How do we get that first contract out there without create three? And we would have to rely on contract create transactions to copy what's out there. It wouldn't be a very good factory because you just have subcontracts that do nothing, and then we're separating out into separate addresses. I mean, we could do it that way. It's just not self contained. And then how would you get the address into the factory contract? You'd need to do some append stuff.
00:40:06.750 - 00:40:13.310, Speaker C: It would require multiple transactions to deploy a contract, a factory contract, whereas this requires only one.
00:40:16.740 - 00:40:29.090, Speaker A: Sorry, I don't get it to get the same semantics as the current create three. You just add address to the stack. Right.
00:40:33.970 - 00:41:00.570, Speaker C: But you don't have the same semantics because you'd have to deploy a stub contract for your factory, this little child contract in it code. This would need to be pre deployed. First is a create transaction that does nothing. And then in this factory contract, you would create three and reference that at a separate address that's already out there. It would make factory contracts not self contained, which I would argue it's a security risk.
00:41:02.910 - 00:41:07.740, Speaker A: I don't understand why they have to be not self contained. Why can't they reference themselves?
00:41:11.280 - 00:41:16.370, Speaker D: They don't know the address for deployment. Right.
00:41:17.620 - 00:42:07.460, Speaker C: You could get it through an opcode, but then it would be referencing its top level self, not the thing that it's deploying inside of it. The factory is different from the pool. You'd only be referencing the factory. You could create factories of factories, but you could never have the pool. You'd have the factory code as part of the pool. Can we move on to non create and come back to create as a group later? Because there are some other issues that aren't related to create. Charles, I didn't hear that.
00:42:07.830 - 00:42:09.170, Speaker A: Yeah, I said sure.
00:42:09.320 - 00:42:32.010, Speaker C: Okay, so I'm going to withdraw create f. My reason for that has to do with, you can't get an address over the init code in the way it's structured, so we can just, three is done. Four jump fi. I think the current situation is it's on the bubble because of too much to ship.
00:42:33.790 - 00:42:35.340, Speaker D: Yeah, I think so too.
00:42:36.670 - 00:42:41.886, Speaker C: Okay, swap mn similarly. Go ahead.
00:42:42.068 - 00:42:50.800, Speaker D: Yeah, same, it's like addition. That may be nice, but again, I'm against stating anything not strictly needed.
00:42:51.570 - 00:43:18.680, Speaker C: Okay, so liked just too big. Liked, swapped mn, liked, just too big. Return data load, I think. Similarly useful, just too big. And exe data copy. So like four through seven are all good in principle, just too big of space. Okay.
00:43:18.680 - 00:43:24.310, Speaker C: Gas costs, which gas costs are missing.
00:43:24.470 - 00:43:46.080, Speaker D: Yeah. I didn't make a list of all of them, but at least I remember. Return data contract, for example. Currently in my implementation, it is cost zero, because return is zero, but it does the appending, which is non constant operation. Even so, it might be even dynamic cost. So I'm not sure.
00:43:48.230 - 00:43:51.860, Speaker C: Okay, so I think we just go ahead.
00:43:52.790 - 00:44:25.790, Speaker A: I think that, I don't know, the suggestions made by Viper are kind of useful. Like without jump fi and return data load, we get code size regressions. And I think swap mn is basically like, if we're going to do eip six, six, three then swap mn should be in there, because I think it's actually more useful than the other stack operations.
00:44:31.630 - 00:44:51.090, Speaker C: So, I mean, I don't disagree that it's valuable, and it would make things a lot better for Viper. The concern is we're going to have an even larger spec, and if we have too much data, I'm afraid the core devs are going to say EOF is not worth it. Let's just stick with legacy forever. And the more stuff we pipe, the higher that risk.
00:44:51.590 - 00:45:03.140, Speaker A: Why is jump f important? I mean, why is jump f and, like, swap n and dupe n? Why are these instructions going in?
00:45:05.430 - 00:45:23.386, Speaker C: I mean, you're right. We probably could shave them out to make it easier to get through. It's just horse trading. Yeah. I'm not sure why those made it and those didn't, because those were initially thought of in the first pass of this. There's got to be some make it in, some don't know that. I don't know.
00:45:23.386 - 00:45:24.700, Speaker C: That could claim it's fair.
00:45:28.470 - 00:45:58.800, Speaker A: Right. Well, I mean, on the issue of fairness, pretty much all of the feedback was requested on UF, and I've been consistently giving feedback, but none of the suggestions have actually made it in. And so, yeah, I mean, talking about putting them in the future. So I failed to see how going through the same process is going to.
00:45:59.890 - 00:46:38.010, Speaker C: So my thought is we would tag these for Osaka, these non breaking changes as a group. So jump fi, swap mn, return data, load ext data, copy those, if they pass community muster, would be going as a group in Osaka. Because we've already got a huge testing surface, and it's actually an argument for pulling some stuff out. If we need to reduce the size, that's not essential to it. Like, we could pull out 663 to reduce the size. There's a valid argument there to make it more palatable to all cordeds.
00:46:42.030 - 00:46:52.480, Speaker A: Right. Well, I think these should at least be on the same footing as the eips that they're providing kind of feedback for.
00:46:53.170 - 00:47:11.602, Speaker C: Yeah. Another issue is like, six. Six three is an EIP that existed for years. So I think that's another swap mn. It's useful for Viper, but I don't think that the way solidity maps its variables, it's as useful to them. So I think that's why it didn't come in years ago.
00:47:11.656 - 00:47:14.902, Speaker A: I think it's actually useful for everybody. Right.
00:47:14.956 - 00:47:27.546, Speaker C: It can be. It can be useful for everybody, but I think that's why Viper didn't propose solidity, didn't propose it any earlier because their model didn't depend on it, whereas Viper's model does. So I think that's why it didn't show up years ago.
00:47:27.728 - 00:47:36.620, Speaker A: I don't think Viper's model depends on it. I think that the argument is that if we're going to have these stack scheduling instructions, then swap mn is like, I mean.
00:47:40.830 - 00:48:11.880, Speaker C: So I think there's multiple scheduling, there's multiple steps and we're trying to skip steps. First we need to get an EOF container deployed that can do backwards compatible changes. But if we put every possible thing we want in the future, we'll never get it. As it stands, we have to put every possible breaking change in to get acceptance from all core devs, and that's what's driving its size. So that's why I think there's resistance to non breaking changes, because we can add those non breaking changes later, but these breaking changes have to happen now.
00:48:12.570 - 00:48:20.010, Speaker A: Well, if I'm understanding this argument correctly, then we should be considering shaving more things out of uf.
00:48:20.510 - 00:48:27.710, Speaker C: Yeah, just what I proposed. Yeah, that's what's needed to get it past all core devs. We just shave off what's there to the bare minimum.
00:48:28.690 - 00:48:44.020, Speaker A: But I think that the initial proposal should probably contain more things that, I mean, if that's the strategy, then the initial proposal should contain more things and maybe some things get shaved off later.
00:48:44.630 - 00:49:18.446, Speaker C: Right. So there's what's necessary for breaking, what's necessary to replicate current behavior and what could add value. And I think the add value stuff, I think by default should go into Osaka and it's the stuff that's needed to replicate current behavior. That is the stuff that's at risk is the stuff that is where most of the discussion comes in. I think there's some of that stuff in that category that we shouldn't shave out, that we could, that is needed to replicate current behavior. Such as those are just the categories I'm putting them in. I mean, if we were to go through this exercise, those are the things we would need to do.
00:49:18.446 - 00:49:39.774, Speaker C: The operations, for example, the data operations, would replicate current behavior. Not strictly necessarily for the container. We could evolve it compatibly with the data, but we would be losing functionality. That wouldn't be at parity. So like, the data operations are existing behavior swap mn. We've never had that before. So that would be new behavior.
00:49:39.774 - 00:49:48.710, Speaker C: So that would be class three. If class one is required, class two replicates current behavior and class three is new behavior.
00:49:51.210 - 00:49:58.490, Speaker A: Right. So maybe we should go through and do that for all existing things, possibly.
00:50:03.310 - 00:50:21.138, Speaker C: It, I think part of it is we need to get a temperature check for all core devs outside of this call to see how concerned they are about the size and how they feel about adding four through seven, and if they actually want us to shave stuff down. We're talking hypotheticals here. I think at a certain point we.
00:50:21.144 - 00:50:35.350, Speaker A: Need to get creature check at least four and six. Basically, I looked at the spec and I looked at how we need to implement things, and it causes code size regressions.
00:50:36.810 - 00:51:10.640, Speaker C: Okay, so that's an argument for bringing them in and removing them to class two, but at a certain point we have to shut the door. There's lots of things we could always do. At some point we have to shut the door and ship something. So that's another one of my concerns of spending long meetings arguing over fairness, is we just need to get something out there so we can go through this exercise, but we can't spend forever doing.
00:51:19.500 - 00:51:20.250, Speaker A: It.
00:51:29.850 - 00:51:38.950, Speaker C: We didn't even talk about the minor nice to haves. I think those are based on the discussions about size all off the table.
00:51:41.710 - 00:51:44.730, Speaker D: Some of them reduce, actually, I think complexity.
00:51:45.390 - 00:51:48.970, Speaker C: Okay, and which ones reduce?
00:51:54.460 - 00:52:28.550, Speaker D: Well, like 10.3. This is maybe having discussed this before on dvd. So this is instead of max stack height, requiring the exact max stack height that is calculated during validation, it can mean the upper bound. So we allow any value below. And this will simplify testing. At least that's the motivation for this, because in tests we can just put max value in the header and then not care about it. Then writing the test is easier than.
00:52:28.550 - 00:52:38.340, Speaker D: Well, in spec wise it's just one line change from equal to less than or equal.
00:52:38.680 - 00:52:43.110, Speaker C: So could that be an attack vector where everyone sets max tax size to 1024?
00:52:43.480 - 00:52:55.406, Speaker D: I don't think, because it only affects, I guess, call f stack overflow.
00:52:55.438 - 00:52:56.020, Speaker C: Check.
00:52:57.110 - 00:53:05.590, Speaker D: So if you put max everywhere, you only reduce the possible max. Call stack depth. Call f stack depth.
00:53:06.330 - 00:53:18.250, Speaker C: Okay, so on that theme, also reading through this ten one looks like a breaking change. We would need to do that now or never to forbid unreachable sections.
00:53:18.670 - 00:53:19.420, Speaker D: Yeah.
00:53:21.550 - 00:53:33.360, Speaker C: Ten two, make data section optional. I'd call that type two. It's breaking, and it's nice to have. So if it's not present, it's implied zero.
00:53:35.410 - 00:53:36.160, Speaker A: Yeah.
00:53:39.830 - 00:54:16.926, Speaker D: Well this one actually, I think simplifies a bit the parsing and validation, maybe because motivation for this is, it was made mandatory at the point when we didn't have subcontainers, and it was argued that having data section mandatory makes parsing simpler. But now we have container sections that are not mandatory, that are optional. So it's like a mess. Data section is mandatory but can be zero. Container sections are optional and cannot be zero.
00:54:17.108 - 00:54:33.140, Speaker C: Okay, so that was my next question. If it's optional, zero is an invalid container. That's good. So I think that's a type one change. Create four. I need to read through this and parse it real quick.
00:54:36.910 - 00:54:50.974, Speaker D: This is something to do from the spec, I guess, just limits in the number and or the size of init containers or the transaction. It's a question to the spec of the new transaction type.
00:54:51.172 - 00:55:09.274, Speaker C: Didn't Shanghai put in a transaction in it? Code limit? That's twice the code. Yeah, Shanghai. So would that be the same value?
00:55:09.392 - 00:55:17.130, Speaker D: I guess this applies, yes, but also the number of them. Do we have a limit on the number of unit codes in a transaction?
00:55:20.270 - 00:56:13.466, Speaker C: I promised an idea about create four. One of my concerns about accessing by index is that this won't translate well to user operations. So if I have a user operation that's creating a contract, and I have index one, and five people come in with a user operation, creating a transaction at index one. There's only one index one in the bundled transaction. If I were to make a change to create four, I would want to have it reference it by hash of the container. So you can have it anywhere, you can reorder it and it's going to grab it by hash from the transaction, so it identifies it without position. So you can take these five different bundled user operations that are creating small contracts, put them together and you can just order it in any way because they're all going to reference their needed init code by hash.
00:56:13.466 - 00:57:17.360, Speaker C: But then we would need to have some definition in the user operation to specify these things that would need to be pulled out and put them in transaction objects. So it would require changes to 4337 because we need to pull stuff out of the transaction or we would need to allow create forward reference because user transactions come into runtime. Yeah, this kind of breaks stuff with 4337. I think this is a bigger meta discussion that's just as impactful as what Viper needs to make their code efficient because the user operations are the same level of code introspection that you would see from creating your own bytecode. That's my concern with grateful. I see we're two minutes over time. Probably should end the discussion here.
00:57:22.360 - 00:57:37.816, Speaker B: Yeah, probably good. Seems like we covered a lot of ground. Just wanted to mention we have one more of these calls also before we're trying to present on all cord devs. I think the all core devs we were looking at was October twelveth, if we remember.
00:57:37.998 - 00:57:38.730, Speaker C: Yeah.
00:57:39.500 - 00:57:40.196, Speaker B: Sweet.
00:57:40.308 - 00:57:40.970, Speaker C: Yeah.
00:57:41.740 - 00:58:16.310, Speaker B: It would be good to talk a bit asynchronously in the next two weeks and try and resolve these things so that on the next call in two weeks time from now, we have a pretty good idea. Not too many open questions, and we can maybe just talk a little bit about maybe reducing scope slightly for what is presented on all core devs or just, like, strategize a bit about how to present to all core devs. And then that will give one week for, I assume, the epsilon team to prepare to present it.
00:58:16.680 - 00:58:22.410, Speaker C: Okay, so the first item is going to be all core dev strategy, and then we can go back into these.
00:58:23.500 - 00:58:24.504, Speaker B: Yeah, I think next week.
00:58:24.542 - 00:58:26.490, Speaker C: That's probably the.
00:58:30.300 - 00:58:36.312, Speaker B: Cool, but, yeah, I guess. Thanks a lot, guys. We'll see you in the EVM channel.
00:58:36.366 - 00:58:37.412, Speaker D: On Discord in the meantime.
00:58:37.476 - 00:58:41.130, Speaker B: Otherwise, talk again. Two weeks. Have a good rest of your day.
00:58:42.860 - 00:58:43.510, Speaker A: Rick. Thanks.
