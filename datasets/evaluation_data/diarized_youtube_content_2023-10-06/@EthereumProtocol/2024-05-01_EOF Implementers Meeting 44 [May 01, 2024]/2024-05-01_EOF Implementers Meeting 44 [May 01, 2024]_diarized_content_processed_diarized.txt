00:00:00.800 - 00:00:27.554, Speaker A: All right, going to start. EOF implementers, call number 44. Probably going to be short one this week. A lot of the Epsilon team is out. It's May Day in Europe, it's an important holiday there and a non holiday in North America. So first I'll start with client updates. In the process of writing tests basis, found a few implementation bugs and fix those to our mega EOF branch.
00:00:27.554 - 00:01:02.014, Speaker A: I also took a test run of EVM one and Geth through it. I don't see any Geth people on the call. I think there's one test case that I wrote that EVM one has issues with and it might be because they're doing the verification at a different part of it. So the test case might not be terribly appropriate. Has to do with init code overflows. Geth is it got some pretty good progress. They are not done implementing ext calls and they're not done implementing creates and that's most of the tests have written so.
00:01:02.014 - 00:01:18.374, Speaker A: But the other ones that I can see for the most part, there's like an off by one error and a gas calculation error on one of them. But those are, those are, you know, typical and easy to fix. Not surprising this point. So I think they're doing, they're pretty good with their progress. Eamon, you got some information for Nethermind?
00:01:22.254 - 00:01:24.754, Speaker B: You mean like the branch or what.
00:01:26.454 - 00:01:30.834, Speaker A: The. How is, how's EOf going in Nethermind doing client page?
00:01:32.414 - 00:01:43.714, Speaker B: It's a little bit off track, like a little bit late because we were focusing on eips for the Devnet and we're just getting back to it again this week, so.
00:01:44.134 - 00:01:53.374, Speaker A: Okay, does Nethermind have a, do you support execution, test specs per chance?
00:01:54.634 - 00:01:55.698, Speaker B: Execution.
00:01:55.866 - 00:01:58.494, Speaker A: The pytests. Do you have a runner for the pytest?
00:01:58.994 - 00:02:00.134, Speaker B: I think, yeah.
00:02:00.514 - 00:02:07.534, Speaker A: Okay, so I'll probably ping you when you get a little further along to share your branch.
00:02:09.594 - 00:02:20.454, Speaker B: Okay. And we have a t eight, nice branch that is getting implemented as well. So hopefully soon we get, we'll be up to date with everything.
00:02:21.034 - 00:02:27.214, Speaker A: Okay, cool. Hugo, anything new from EVM one?
00:02:33.274 - 00:02:51.374, Speaker C: No, nothing from my side. I've just been working on some small changes related to the tests that are exported from EVM one to the, to the Ethereum test suite.
00:02:52.394 - 00:03:05.494, Speaker A: Okay, cool. Next on the agenda, compiler updates. Viper's not here. Why Viper's here? Solidity is not here. Charles, get anything on from Viper for updates?
00:03:06.184 - 00:03:32.634, Speaker C: No. I have been hearing murmuring of when are the compilers going to implement this? And I was wondering how important is it is it just for like, what do you call this? Like shims? People want to be able to test it end to end from source code? Or is it more like it makes it easier to write tests?
00:03:35.174 - 00:04:35.544, Speaker A: So the big ask is coming from the verkle team. They want real world examples to see how much bigger or smaller does EOf make it. What are the code traces look like? Because they're concerned that it might implement vertical. My thought is that it's going to be about the same impact that legacy is going to have, but they want hard coded data, so that's where a lot of the push is coming from. But also getting compiler support. Also, I think is another important shelling point in moving this forward because we can produce actual code and people can start seeing what the impacts are and it makes it feel like the spec is that much more solidified if other tools are generating to it makes it more, feel like it won't, you know, move around. So that's, those are, those are two of the, two of the, two of the things contributing to the request for compilers, for implementations.
00:04:39.964 - 00:05:31.254, Speaker C: Yeah, I think that the code size is going to be roughly similar, although solidity for the Shanghai fork they implemented with EIP 663 and we did not. I think it's not the way EOF is spec now. It's not strictly better in terms of. Okay, it would be strictly better if there were global code sections instead of subroutine sections. And.
00:05:33.754 - 00:05:37.866, Speaker A: So could the compiler just target one code section instead of multiple code sections?
00:05:38.050 - 00:06:01.604, Speaker C: No, I mean, that's like one reason I've been asking for all these changes to the analysis. And I've spoken with Pavel briefly about the feasibility of it. And I mean, this was months ago and he said it's fine, like it could be done either way. But then I never saw any movement on it. And the reason you can't is because of the stack validation rules.
00:06:07.664 - 00:06:10.644, Speaker A: What was your asks from Powell what didn't move forward?
00:06:12.044 - 00:06:15.624, Speaker C: He said he'd look into it and then I think it just kind of fizzled out.
00:06:16.604 - 00:06:17.504, Speaker A: Okay.
00:06:19.124 - 00:06:21.704, Speaker C: Probably, probably there's, probably.
00:06:22.084 - 00:06:22.984, Speaker A: Go ahead.
00:06:23.284 - 00:06:37.984, Speaker C: Yeah, I don't know, maybe there's other priorities or. I mean, I think that a global code section is, is important for, for EOF. That's one of the reasons I think, that I mentioned on ACD that I think the spec is like not perfect, but.
00:06:40.684 - 00:06:45.104, Speaker A: So global code section means there's only one code section in subroutine within it somehow.
00:06:45.524 - 00:06:56.784, Speaker C: Yeah, yeah. EIP 20 315 style subroutines and there's like a very long Ethereum magician's thread on this from like 2021, which I've read half of.
00:06:57.324 - 00:07:08.094, Speaker A: Right. I soon recall that solidity didn't like it. They thought there were some code size regressions and solidity saying they wouldn't implement it was, was critical to having it pulled from Berlin.
00:07:10.314 - 00:07:21.694, Speaker C: I think that with, I think that it's better than UF code sections.
00:07:22.634 - 00:07:23.514, Speaker A: Okay.
00:07:23.674 - 00:07:42.174, Speaker C: In terms of code size, I think like the spec, I mean, the specific, the specific design might have some weaknesses, but I think that style where the code section is global is like strictly better in terms of code size.
00:07:43.474 - 00:07:44.282, Speaker A: Okay.
00:07:44.418 - 00:07:47.934, Speaker C: Because you don't need to make a gas code size trade off.
00:07:48.674 - 00:07:54.694, Speaker A: Right. Right. There's no. Well, is there, is there a jump test equivalent for subroutine start?
00:07:56.934 - 00:07:59.834, Speaker C: I don't remember how the EIP works.
00:08:00.254 - 00:08:19.594, Speaker A: But it's going to be less than three bytes, which is the typical. Yeah, it's at least two bytes for new code section because that's the extra size info in the header and then another four. So it's six. It's a six byte overhead on subroutines right there.
00:08:21.314 - 00:09:05.464, Speaker C: Yeah. I'm not concerned about the subroutine header overhead, although that's like also kind of fixed by like variable length items in the header spec. But I'm more concerned about code sharing. So there's like a lot less you can do when you're forced to, like share code by putting it in subroutines instead of just having shared code sections that you can jump in and out of. Although the, the changes that were made to jump fi improve that a lot.
00:09:06.644 - 00:09:10.384, Speaker A: Jump f, not jump fi, because we don't have jump fi yet.
00:09:12.124 - 00:09:12.864, Speaker C: Right.
00:09:14.824 - 00:09:15.724, Speaker A: Okay.
00:09:18.904 - 00:09:19.296, Speaker C: All right.
00:09:19.320 - 00:09:39.692, Speaker A: Yeah. The ipson team isn't here to discuss some of those issues. I mean, if we're going to stick with our product delivery date, we unfortunately don't have time to do that. But if that opens, if that door opens, then we might be able to have another discussion. That's, yeah. So we'll see what the status is in the next few weeks.
00:09:39.888 - 00:10:04.344, Speaker C: Yeah, I mean, another thing is like, I've gotten this consistently over like, the last two years where like, you know, I'm like, can this be changed? And then the first thing that comes up is like, we're close, too close to delivery date. And then like, but like, delivery is always like, or like, freezing is always actually a long way off.
00:10:04.964 - 00:10:16.984, Speaker A: Well, we were trying to get this in for Cancun before we rebooted, and then Cancun was supposed to ship six months before it did. I agree with the frustration that we're always in freeze mode and we can't ship and that's really hurting the process.
00:10:17.764 - 00:10:49.114, Speaker C: Right. And that's actually one reason why on the last ACD call I was like, it would be really cool if we could like have an l two or some kind of testnet for this where we can actually test and evolve the spec instead of always having it be in freeze mode and like the, you know, pushback from ACD over like whether the spec is too big or too small or too frozen or not frozen enough, you know.
00:10:50.814 - 00:10:51.550, Speaker A: Yeah.
00:10:51.702 - 00:10:57.514, Speaker C: If there were like some semi production environment where we could actually evolve the spec, I think it would be really good.
00:11:01.554 - 00:11:23.774, Speaker A: Yeah. The problem is getting a shelling point for what the final spec is and. Yeah, yeah, I mean, now that we, now that there's a couple of implementations on our clients, we could set up l two s. I don't know how op base is going, but once we get a geth implementation mainline or even in a standard fork, it'll be a lot easier to do an op geth.
00:11:27.394 - 00:11:34.724, Speaker C: It doesn't. Excuse me. Yeah, I think test net is the first step. And then like l two.
00:11:37.544 - 00:11:38.324, Speaker A: Yeah.
00:11:38.744 - 00:12:06.224, Speaker C: Actually I'm not sure if you even need a testnet. Like EOF is just EVM, right? Like you don't actually need the protocol in order to like use it. I think the thing about l two is it like proves to people that like it's actually viable in an economically, what is this called production environment.
00:12:06.924 - 00:12:40.784, Speaker A: Right. It actually is in shipping code, which changes people's minds a lot. And also, so we do have, we do, I do think we need some bit of testing that for interop, for the create mode transaction, not like the sort of interop testing required for the, like the engine API and peer to peer stuff where what happens in production, you know, there's lots of failure modes. There is no failure mode. It works or it doesn't. So that does simplify it. But I think for people to interact with it and, you know, spawn ideas and get people to see it working in action, I think will, you know, help a lot.
00:12:42.084 - 00:12:55.894, Speaker C: I also think that the design of Uf should be different depending on if it's before or after vertical, because if it's after vertical, then the data sections like almost actually don't make sense.
00:13:01.954 - 00:13:24.874, Speaker A: Well, I mean, we still need an immutable data section. You know, solidity is going to be rewriting their code to put the data in. And the data for immutability is not just about cost savings, although that is a big issue. It also is about the auditor comfort of it being in the code and unchangeable.
00:13:27.094 - 00:13:29.342, Speaker C: In the front end code or in the bytecode.
00:13:29.518 - 00:13:30.674, Speaker A: In the bytecode.
00:13:33.574 - 00:13:43.034, Speaker C: I don't know. I mean, just because you see immutable in solidity or viper code, doesn't mean that it's stored in code in bytecode.
00:13:43.334 - 00:14:15.514, Speaker A: But if we take away data, then there's no way to store it in bytecode. And in the contract, then you would just store it in storage, which can be mutated. And if you put, you use delegate call in your code, that opens up the door to having your storage mutated with a bad reference of a delegate call. And then you have to do an audit. Make sure all your delegate calls and all your delegates are set up properly to not mess with your storage. It's just, it solves a whole lot more problems just having the code that, the immutable data in the code in a truly immutable section, and not just hope that any of your delegate calls don't happen to change it.
00:14:17.974 - 00:14:38.324, Speaker C: Another simpler. Yeah, I mean, I don't think the alternative design has been considered where we add an immutable memory region, which would be like, maybe annoying for some people, because like we already have, you know, call data storage, training storage, whatever, but.
00:14:40.184 - 00:14:47.284, Speaker A: We already have code data, and if we were to add an immutable data section, we'd have to figure out some way to store it and some way to signal it that it's read only in the tree.
00:14:48.984 - 00:14:54.564, Speaker C: Yeah, I just don't think that design has been considered, really?
00:14:55.624 - 00:15:15.094, Speaker A: Yeah, it hasn't been deeply considered. It has been implemented with real, a real alternative. The problem there is that starts getting into more deeper, fundamental changes of the eVm. We're focusing on one at a time right now. That's just the container format. If we start messing with memory, then the arguments that this is no longer EVM actually become quite valid.
00:15:24.774 - 00:15:31.954, Speaker C: I don't know. I mean, like, in some sense, the data section is the new region, right?
00:15:32.774 - 00:15:40.274, Speaker A: Right. And it parallels the existing region of code and the existing EVM. So it's a lot more like EVM than adding a fourth class of memory.
00:15:41.854 - 00:15:44.714, Speaker C: Yeah, kind.
00:15:46.934 - 00:15:50.754, Speaker A: I mean, it is the fourth class of memory, but it parallels a lot of what's written and done.
00:15:51.374 - 00:16:06.662, Speaker C: Yeah. Right. Because there's some design trade offs. I think Vitalik is right, that create copy of code is simpler than EOF create probably is.
00:16:06.718 - 00:16:25.514, Speaker A: And that, that's one of the reasons that's one of the things taking TX create out opens up space for us to explore that it's not essential for the first rev. And that's why when I took it out, I made no promises that it was coming back in the future. I, I myself am not promising that sex is coming back as is. I even recently just pulled the code out of BesU.
00:16:25.934 - 00:16:43.794, Speaker C: Yeah. So all I'm saying is that before, depending on whether it lands before or after Verkle, like, the design could and should be considered differently. Like, we should spend at least like one or two meetings, like hashing it out.
00:16:45.794 - 00:16:46.654, Speaker A: Okay.
00:16:49.154 - 00:17:05.014, Speaker C: But yeah, or maybe even, maybe even not that long, maybe half a meeting or 15 minutes or. Yeah, I think that it should be like in the considerations section of the EIP.
00:17:05.794 - 00:17:15.486, Speaker A: Okay. Write a note for that for the next meeting or two so we can discuss when Ipsilon's here and get their full opinion on it.
00:17:15.630 - 00:17:30.954, Speaker C: Yeah, sure. And I think, I mean, also from the perspective of all core devs, like, I think they would like to see that, you know, the design before and after Verkle, how it's been, how it's been considered.
00:17:31.614 - 00:18:17.540, Speaker A: Yeah. Okay, so spec updates, we're not going to have any spec update issues. What's pending is the create transaction. Instead of a regular state change, adding in a container size EIP 7620 return data, zero padding. I know Epsilon was against changing opcodes and putting, would prefer putting new opcodes in place, which solidity and Viper were like, let's just change it. Kind of interesting. Exe with value cost, they updated some of their numbers on that and increased the calls.
00:18:17.540 - 00:18:49.404, Speaker A: Min retained gas. Yeah, so there's, these are, all the advocates for this are not here. So, um, I guess we'll push these all off to next week. Um. Yes, Charles?
00:18:49.704 - 00:19:25.564, Speaker C: Uh, yeah, no, I'm just thinking about this data section thing now. And um, if you change it to like a set data store that's only available in init code, then that maybe solves some of the validation issues with Uf Creek as well, since I don't remember the spec exactly. But there's something where like you can provide less data than the container expects.
00:19:26.264 - 00:20:05.234, Speaker A: Right? So a return contract takes memory region of bytes, and it depends on the existing data section. So that's kind of what you would get with set data. There would be a region of data that is hard coded in the factory, and then stuff that you would want to read would have to come after that section. So there's like stuff that is set prior to the constructor that will never change and stuff that is set inside the constructor. And as a language designer, that has some interesting implications that immutable is truly immutable outside the constructor, because I know in Java you can turn off all your safety checks and final means nothing if you have the right privileges.
00:20:05.534 - 00:20:25.792, Speaker C: Yeah. Right. Yeah. So instead of returning a memory region, you use set data and get data. And I think that might be kind of a more abstract design, and that.
00:20:25.808 - 00:20:33.164, Speaker A: Would be useful for the copy instead of txcreate. If there was a copy create, you can take the data and you could reset it.
00:20:33.864 - 00:20:35.084, Speaker C: Yeah, exactly.
00:20:40.704 - 00:20:43.844, Speaker A: Okay. That's something that's designed to consider when we talk about.
00:20:46.074 - 00:21:08.054, Speaker C: Yeah, and then you don't need return contract at all. You just ban get data and set data in, or actually, you just ban set data in runtime code, and then it's like actually just part of code validation.
00:21:08.794 - 00:21:22.714, Speaker A: Right. Well, I mean, so that would be using copy create in lieu of EOF create. So you wouldn't have a true self contained factory container either.
00:21:24.094 - 00:21:25.154, Speaker C: That's right.
00:21:25.534 - 00:21:51.094, Speaker A: So return contract is used for Uf create, you wouldn't use return contract for TX create because Tx create really points to external init code because that's, you know, copy contract. You would need to provide your own init code that's outside the contract, which breaks some design promises you could.
00:21:51.794 - 00:22:05.214, Speaker C: I think copy contract should like, should like work on containers with init code in them.
00:22:07.754 - 00:22:14.174, Speaker A: But then how do we get those init code containers deployed? Everything that's stored in a contract right now starts out in runtime mode.
00:22:14.874 - 00:22:20.974, Speaker C: Yeah. I think the way Vitalik was describing it is like you deploy these using legacy transactions.
00:22:22.034 - 00:22:41.114, Speaker A: So we'd have some code that is arbitrarily init code and some code that's arbitrarily runtime code. How would we validate that? Yeah, my thought is if we had a copy create, you would provide your own init code, and instead of doing return contract, you would end up with a copy contract.
00:22:42.934 - 00:22:50.634, Speaker C: I don't think you want to be running create copy contract with random init code.
00:22:51.894 - 00:22:52.634, Speaker A: Right.
00:22:53.014 - 00:22:58.614, Speaker C: It should be validated and like coupled strongly with the contract.
00:23:00.314 - 00:23:06.574, Speaker A: Another thing is you could point to, I think, that you're copying and you could specify one of the subcontainers.
00:23:07.234 - 00:23:07.642, Speaker C: Yeah.
00:23:07.698 - 00:23:22.294, Speaker A: So you deploy something with runtime code, and the only thing the runtime code does is it reverts saying, hey, I'm not real runtime code, I'm just holding a NIC code. And your copy container would point to an address and you'd point to a subcontainer number and that's how you can run it.
00:23:24.404 - 00:23:32.124, Speaker C: Yeah. I mean, at that point we can actually just have a container type, which is the point of having a container format.
00:23:32.244 - 00:23:38.864, Speaker A: Right. And you could evolve it and you could have everything but the data section be shared and only store the data section with each contract.
00:23:39.764 - 00:23:40.996, Speaker C: Yes, exactly.
00:23:41.140 - 00:23:46.304, Speaker A: Which is elevating the data section to that fourth type of memory. So I think we can get there.
00:23:48.584 - 00:23:49.364, Speaker C: Yeah.
00:23:53.824 - 00:23:56.924, Speaker A: I think just doing it in one step is going to be a bit too much for the community.
00:23:57.784 - 00:24:06.844, Speaker C: Yeah. Because once the code can be shared, that's like, actually a huge performance benefit because like, most contracts are actually copies of each other.
00:24:07.424 - 00:24:19.274, Speaker A: Right. And it has huge just in time implementation considerations. If everyone's running the same, the same pair contract for Uniswap, you just implement it once and you can identify easily.
00:24:22.054 - 00:24:22.834, Speaker C: Yeah.
00:24:30.734 - 00:24:39.074, Speaker A: Okay. Well, I don't think we're going to get anyone who's looking to learn about eof on this call by this point. Surely they would have called in.
00:24:43.714 - 00:24:58.490, Speaker C: Okay. Yeah. I just think that there may be some benefits to the Vitalik's create copy of idea and I think it deserves some time to investigate it.
00:24:58.522 - 00:25:05.520, Speaker A: Right. I think we need to get the. And some of the client devs in the same room to discuss it. And we'll have that opportunity shortly.
00:25:05.682 - 00:25:06.784, Speaker C: Yeah. Okay.
00:25:11.044 - 00:25:19.504, Speaker A: It probably won't ship for Prague. It's probably going to ship Amsterdam. If Verkel's insistent that Osaka be Verkel and Verkel only.
00:25:20.484 - 00:25:26.944, Speaker C: Yeah, well, if it. If uf ships pre verkel, then it doesn't matter. The current design is like, good. I think.
00:25:27.404 - 00:25:39.504, Speaker A: Okay. Because I think this is something that could totally be layered on the design without having to reboot the way things because we're adding opcodes and maybe a little bit different handling, but yeah.
00:25:41.524 - 00:25:47.344, Speaker C: Well, we would have permanent. We would have to permanently handle the UF create workflow.
00:25:50.044 - 00:25:57.304, Speaker A: Right. I mean, we need to handle that anyway. Unless we're going to redesign how we're bringing stuff onto the container and onto the chain. In general.
00:26:05.024 - 00:26:19.764, Speaker C: I think deploying EOF, like blueprints, I guess there, through legacy transactions is like totally fine, actually. Right. They need to get validated.
00:26:20.304 - 00:26:38.028, Speaker A: They need to get validated. So there's two steps. Because then we'd also change the developer flow workflow to use EOF. They'd have need to first deploy the contract on the blueprint. That doesn't do any NICO. Then they need to do a separate contract call to actually make it live so that's another downside of this is it would increase the end user friction and would.
00:26:38.116 - 00:26:55.624, Speaker C: Well, that's actually, that's actually how Viper does it. Right. Now, that is the way factories are implemented in Viper. Now you deploy the blueprint and then everything else basically copies the code and runs the NIC code.
00:26:56.034 - 00:26:59.294, Speaker A: Right. But that's not. Is that the only way to get stuff out in Viper?
00:27:00.314 - 00:27:01.134, Speaker C: Yeah.
00:27:01.754 - 00:27:05.778, Speaker A: Okay. Because I know you can do that in solidity, but it's not the only way to get stuff out in solidity.
00:27:05.946 - 00:27:11.894, Speaker C: Yeah, it's the standard way to deploy these factory things.
00:27:12.794 - 00:27:16.614, Speaker A: Okay, but what about non factory? What about plain old non factory?
00:27:17.994 - 00:27:20.774, Speaker C: Oh, then you just do the regular way.
00:27:21.294 - 00:27:30.074, Speaker A: Right. And that's where some of the, some of the developers, I mean, the pros, you're going to be using factories and some of the casuals are not going to be using the factories too, so.
00:27:31.694 - 00:28:32.994, Speaker C: Oh, I see. What you're saying is that there's like no way to get u of code on chain besides with these factory things, right? Maybe. Yeah. One way to do it is like when you deploy code, the code goes into a registry somewhere. So, like when you do it the regular way, it also becomes a factory contract. But, yeah, let's sleep on it.
00:28:33.614 - 00:28:49.934, Speaker A: Yeah. Okay, it. Any other questions, comments before I close off the recording? All right, everyone gets 26 minutes back. Thank you.
00:28:50.754 - 00:28:51.914, Speaker C: Thanks, everyone. Thanks, Daniel.
