00:03:11.824 - 00:03:58.400, Speaker A: Good morning everyone. Welcome to Acde number 186. A bunch of things to talk about today. I think the most important thing is making sure everyone is aligned on the Defnet zero specs. I believe they're now frozen, but there's been some EL discussion on the CL call last week and then a couple tweaks since the last call. So yeah, just want to make sure we're all on the same page about the scope for Devnet zero so teams can continue working on that then. 3074, I think Nethermine had some behavior that they wanted to clarify and then there were a bunch of proposals for tweaks to the eips.
00:03:58.400 - 00:04:58.306, Speaker A: So I think we should discuss those probably in the context of future devnets rather than changing the Devnet zero spec. And then after that there's a bunch of other eips that people have wanted to propose for Pectra. It might make sense to go over them, but also just to hear from client teams how we want to proceed given we still have a lot of stuff to implement. So we might not want to commit to even more stuff right now. Then if we have time to get to this. There were some questions in the agenda about how we want to think through the l one l two, governance separation and how things like rips and eips should interact and whatnot. So yeah, we can leave this for the end, but I guess just to kick it off, the teams want to give a quick update with regards to where they are on Devnet zero.
00:04:58.306 - 00:05:52.514, Speaker A: I know we have the implementation tracker, but yeah, any team want to share sort of where they're at now? Any blockers that they have or. Yeah, floor is yours. So I can start on Nethermind side. I think we can say that we are almost ready for Devnet because we have all drafts implementation of all eips and we are right now polishing them, writing some tests. But of course there are some things that are easier to test on Devnet. So there might be hiccups, but it's better to try sooner than later. Nice.
00:05:52.514 - 00:06:27.386, Speaker A: Any other team? Yeah, basically you can go. Similar situation we have everything in progress. 25, 37 is done. 6110 and 7002 are done pending some revision to adopt the 7685 mechanism to wrap them up. So that's the same status as last week from the consensus layer and I think that's about it. Auth and Auth call are in progress. Sweet.
00:06:27.386 - 00:07:27.434, Speaker A: So we are anticipating participating with all that stuff in Devnet zero. Very cool. Anyone from guest? Aragon? Other teams? Well, for Aragon we started looking at most of the eips, but. And we've implemented the BLS precompiles one, but I'm not sure because that will be ready for Devnet zero because it's far from being complete, the implementation. And also we're in the middle of a big change. We are switching internally to the Aragon three branch, which has been in the works for, well, for years now. Yeah.
00:07:27.434 - 00:07:59.846, Speaker A: So we might get slowed down because of that, but it's a big move for us. Got it. And I guess your expectation is that Petra will ship on Aragon three? Basically, yeah, that's right. Got it. Sweet. Anyone from Geth? Yeah, we're in pretty good shape. We have 6110, 7002 implemented using requests.
00:07:59.846 - 00:08:20.056, Speaker A: 25 37 is merged. I'm not sure, marius, if the subgroup checks were merged yet, but we have those updated. And 3074 is still in progress. But in general, we're days away from being ready for Devnet zero. Nice. 21 35 is also ready. Right.
00:08:20.056 - 00:08:43.667, Speaker A: 29 35 is also ready. Sweet. I don't know if anyone from Ethereum J's as well. Yeah, I think most of the things already. We just need to integrate 785 and we should be good to go. Awesome. Yeah, I guess.
00:08:43.667 - 00:09:13.200, Speaker A: Yeah, maybe. Let's talk about 7685, given that seems to be a common thing across different teams. Matt, so I know you followed up with all of the teams over the past couple weeks. Oh, antonio, we can do the subgroup stuff after if that's what your hand is for. Let's do the message bus. Do you have a feeling for like. Yeah.
00:09:13.200 - 00:10:43.568, Speaker A: Whether everyone is on board with this? Is there any team that basically had concerns or issues? It seemed like most people, most teams were on board. If anyone has complaints or questions, maybe we can surface those now. Okay, so any objections to the generalized message bus? If not, then I think this is something that makes sense to include as part of definite zero, given it a relatively small change and sort of is pretty fundamental to how we build a bunch of VIP's. We don't want to have like a version that doesn't use it. I know you had some PRS 26111, 110, and 702 that based on this, I believe those have already been merged, right? That's correct. Okay, so then, yeah, given that, like, effectively the spec already uses this, we can just add the CIP to the list that's included in Petra and part of Devnet zero and continue with the prs. Continue with 6110 and 702 based on the latest prs.
00:10:43.568 - 00:11:13.936, Speaker A: Does that sound good to everyone? Okay, no objections. And yeah, I missed rest and the updates before. I don't know if there's anyone from rest who wants to give a quick update. Okay. If not, we can move on. Antonio, you. Oh, Mario.
00:11:13.936 - 00:11:41.132, Speaker A: Yeah, yeah, I just wanted to give a quick update on tests. Is that okay or. Yeah. So yeah, we have a very good set of tests for the BLS comprehensive compile and also for 6110. Those are basically done. And I think 7002 tests will be done probably today. If everything goes fine, remaining is the 29 35.
00:11:41.132 - 00:12:07.340, Speaker A: We don't have tests for that, but I think they will be done this or next week probably. And when that is done we will make a release with all the fixtures so that teams can consume them and also verify any box before Devnet. Nice. Thank you. Yeah. Antonio, you had your hand up, I believe, about the BLS VIP. Sure, yeah, exactly.
00:12:07.340 - 00:12:47.948, Speaker A: Thanks, Tim. I just want to make people aware that basically the 25 27 has been stable for years, but there's been a kind of addition that is non trivial in the last week. So basically we now require subgroup checks for all the operations but add so in case people want to update their implementation, this is the right time to do it. And there is a bunch of test vectors that has been added as well that cover all the corner cases, including these subgroup checks that are mandatory. Now just this announcement, I don't have anything else. Thanks. Yeah, and I think we had your last commit in the spec for Devnet zero.
00:12:47.948 - 00:13:44.144, Speaker A: But if you have a chance, can you just put the pr, the commit in the chat so everybody can reference it? Sure, I'll do it right now. Thank you very much. Sweet. So, ok, there's some comments in the chat about when Devnet zero with different dates. I don't know if it actually makes that much sense to set a date here if the earliest is going to be sometime next week, but I think we can probably coordinate this offline as client implementations start to be ready and maybe have a bit more of a discussion on having more clients join next week. Yeah, I don't know. Does anyone see a strong need to like set a target date right now? It seems like we can just keep working on the implementations and launch it whenever it's ready.
00:13:44.144 - 00:14:33.820, Speaker A: Okay, I have one. Yes. In the chat. Okay, let's do that then. And I think, yeah, also based on like Mario's comments earlier, like once we have test vectors as well for more of the eips, then it's valuable for clients to actually run through those, make sure that we're passing everything and not just launch a devnet where we find bugs that the static tests could have caught. Anything else on Devnet zero? Oh, shall we? Yeah. You want to talk about the bugs? Yeah.
00:14:33.820 - 00:15:01.814, Speaker A: So just before this call dusting, he found the test factory error of the consolidation. So we will fix it. And I think the error is just in the test vectors. So we will cut a new release soon to address it. And also we will include the peer desk. New test. Nice.
00:15:01.814 - 00:15:22.442, Speaker A: And also extra electra test. Thank you. Awesome. Thanks. To be clear, the specs themselves should not change. It's really just the tests for all those things, right? Yes. No substantive change to the electra part.
00:15:22.442 - 00:16:16.570, Speaker A: Got it. Okay. Anything else on devnet zero? Can we get an El test release or at least fill test before Devnet? So Mario said they're planning a release for next week, but targeting BlS 6110-702-2935 I think that's everything on the El side. Mario, will the release from next week basically target all the eips from Devnet zeros, or is there? Oh, I guess maybe auth call is not included. Yeah, maybe. Probably auth call is going to be. But the ones that we are trying to aim for the release are the ones that are like absolutely necessary.
00:16:16.570 - 00:16:48.708, Speaker A: For example, the 7002 and 6110, they have changes to the header. So for the exception of 3074, as long as we don't call the opcode, the test will work. Yeah. Okay, so we'll try to get test vectors for everything but auth call next week and then we can add test factor should 3074 after. Yeah, exactly. Cool. Sweet.
00:16:48.708 - 00:17:44.974, Speaker A: Anything else on Devnet zero? Okay, so 3074, there was a comment by Nethermine about clarifying some behavior and then a bunch of requests for changes from different developers. So I think it makes sense to first address the Nethermind concern and then we can maybe go over the other sort of proposals for it. Who was it from? Nethermind? It was me. Yes please. So I think I have mis said it in the GitHub issue. It's basically delegate call before oath call, not the other way around. So apologies for that.
00:17:44.974 - 00:19:21.734, Speaker A: And so basically the idea was that currently auth call only works for the authorized invoker, and the invoker cannot be some kind of a proxy contract that can delegate the authorization to another implementation. So we were, I was thinking that this will prevent certain use cases from emerging, and maybe we should look at it in a different perspective. There are some suggestions to do it in another way. So instead of allowing delegate auth call after delegate call, I think Lightclient told me that he's thinking about an approach where we initialize the invoker contract inside the frame of the EOA liteclient, if you care to elaborate. I've sent this around in a couple of places, but I guess the TLDR is one idea that I'm thinking about is to possibly change the behavior of auth call so that instead of just modifying the message sender so in the next frame, you call exactly the target that the EOA wanted to call, you actually call into some target code that was signed over in Auth, similar to the EOA. I think there's a lot more ability to reuse existing smart account code in this type of format. So it's something I want to look into.
00:19:21.734 - 00:20:21.670, Speaker A: I generally feel okay about allowing delegate call in 3074 in this format, or just allowing it in the currently specified format. But I'm not sure that there's going to be much change in 3074 for the next month or so as we're working on Devnet zero. I would just like these conversations to continue happening and maybe have some sort of concrete proposal of change one month's time. Yeah. So there's a comment by Anzgar saying, you know, this feels like a rather big change, I guess, talking about big changes to 374. Does it make sense to cover the other proposals and sort of see where we stand after that, or do people have comments or thoughts? Okay, have a plus one for the other proposals. So the other one, who was the first one that posted about this on the chat? So, Derek, I don't know if you're on the call.
00:20:21.670 - 00:20:58.404, Speaker A: Derek Chang. That, yes. Do you want to talk to talk through? Yeah, your proposal? Sure. Yeah. So the proposal was actually first proposed by anchor from Kotomy, you know, which I think, you know, who I think is also here, but basically, like, the idea is that. So basically right now it seems that there are two different needs when it comes to the nonce parts of the auth message. So basically one group of people wants a in political way to revoke nonce messages.
00:20:58.404 - 00:21:51.570, Speaker A: So in particular, I think they want to be able to revoke auth messages in a way that is independent of the invoker implementation. So I think the concern here is that if the invoker is buggy or Malaysia's, there should still be a way for the user to revoke messages. And then there's like another group of people who have a lot of problem with the fact that by including the nonce into the auth message, every time you send a transaction from your eoa, you are revoking all outstanding auth messages. So the issue here is that. So for example, for my company, Zerodeville, so we are building a counter abstraction based embedded wallet. Some of the most popular use cases involve longstanding authorizations. So for example, session keys.
00:21:51.570 - 00:22:44.364, Speaker A: The idea that you can attach a temporary key to your smart accounts and then basically have other people send transactions for you. If we were to implement that on top of 3074, that would depend on a long leaf of message. And really any other use cases, such as for example, attaching a passkey to your smart accounts, that will also depend on that. So the fact that every time you send a message from your UA, you're killing all long live auth messages, I think will be a really, really big issue for these, I guess, smart account use cases. So the proposal that Anker and I wanted to propose, it's essentially. So I think I would probably send a, put a link here, but basically I'll just put a link in the chat before I. Right here.
00:22:44.364 - 00:23:25.204, Speaker A: Yeah. So basically this is the idea. And then you can see my reply to this message right below this message. So basically the TLDR is that we change the nonce parts of the spec, sorry, like the nonce part of the OS message to two things, which is nonce manager address and nonce manager Nonce. So the nonce managed, the nonce manager can be any address. So it can be a EoA or it can be a smart account. Right, so, sorry, like a UA or a smart contract.
00:23:25.204 - 00:24:26.824, Speaker A: So the most basic way to use this would be to set announced manager to your own UA, in which case you get the exact same behavior as today, in which like if you send a transaction from your UA, you are revoking all messages. But this also gives you the ability to essentially use another contract or another UA or another contract as your nonce manager. For example, I think one very powerful way to do this is to use a counterfactually deployed contract as your nonce manager. This counterfactually and deterministically deployed contracts will be essentially owned by your eOa. So you don't actually have to deploy this contract to have a nonce manager. So you can specify this contract address as your nonce manager. And then when you actually need to revoke a message, you actually deploy these contracts and you increment its nonce in order to revoke messages.
00:24:26.824 - 00:25:18.512, Speaker A: But this means that first of all, you don't have to pay any cost to have a nonce manager, but then secondly, it gives you the ability to both revoke auth messages out of protocol, but just independency of invokers. But also it doesn't mess with the fact that you can just use your ELA without accidentally revoking all outstanding auth messages. Basically, this is a proposal to meet both needs once the need to be able to revoke auth messages independently of invokers. The second need, that is the ability to use your eoas without externally revoking all outstanding auto metrics. That's a TLDR. Got it. Thanks Ansgar.
00:25:18.512 - 00:26:21.744, Speaker A: I believe you have a response to that. I mean, I think it's an interesting proposal, but the way I think about 3074 is our goal was really to basically, because the nature of invokers is so unusual, because you can't just have arbitrary invokers, but every individual invoker has to be manually whitelisted by the wallet, which means we only end up with, every wallet will only end up supporting two, three, four community wide big standardized invokers. And because of that, we have much better trust guarantees about these invokers. And so it makes a lot of sense to try to delegate a lot of special purpose logic to the realm of the invoker. So for example, in this case, you can get the exact same behavior by just making the kind of the in protocol nonce checks slightly more permissive. So you could, for example, basically it is very similar functionality where basically you just, in protocol, instead of always enforcing the nonce restriction, you can basically make it optional. You can say if you sign up with the zero nonce, basically it means now the nonce is non binding.
00:26:21.744 - 00:27:40.922, Speaker A: And then we could, instead of this having being an enshrined part of 3074, it could just be an ESC. So there's an ESC for, if invokers want, they can opt into a nonce manager pattern. And then we could basically just on the social layer and force that, hey, wallets should only whitelist invokers that follow this non manager pattern if we think it's a useful pattern, right? And because again, like wallets will only, there will be like three or four really, really popular kind of ecosystem wide invokers, like a batching invoker, like whatever, right? So we can just basically pick whatever community standard we like. The big advantage of this is that instead of having to make a hasty choice now, which constrains functionality forever and is very, very busy opinionated about a choice, we delegated to the ERC layer, where we basically then can take the proper time for the next one, two, three years, figure out what the best patterns they are and then all come together around those features. So I personally be very, very strongly opposed to enshrining special purpose functionality like that directly into the opcode itself, but just making sure I understand. So like, are you proposing that we just remove nonce altogether from the auth message? Or you could. So, yeah, to press that out.
00:27:40.922 - 00:28:11.964, Speaker A: So basically what you could do is you could say that, you say if the nonce is zero, basically it's not binding in the message. If it's not zero, it's binding. What that means is that by default the signer can choose right. What would they sign over? So your wallet could basically say, hey, I always make my, my auth message is revocable. I make the non revocable. It could be setting, we can figure out should this be in this setting, exposed to the user? Is this insecure? If it's exposed to the users, do we want, do we not want it? We could figure this out in proper time. We wouldn't have to make the decision now.
00:28:11.964 - 00:28:48.774, Speaker A: And what that also means is that the invoker now could, on top of that, add restrictions. Basically I could write an invoker that says, hey, my signatures always have to be revocable because it can impose some validity conditions on that non sphere. So that way, basically we could just, the protocol itself is unopinionated about it. And then it is up for the later on the community standardization process to figure out what rules we should enforce. We can end up in the exact same world with invokers that enforce the exact same rules, but we don't have to make that decision once forever in protocol and enshrined and hard to change in the future. But instead we make it on the ERC side. But we have much more flexibility.
00:28:48.774 - 00:29:27.134, Speaker A: And just to make sure I understand. So the changes that this would make to 3074s effectively make that one field optional when you do an initial signature. And we hope that there's like a set of best practices that emerge around, just like either requiring data, disclosing it pretty clearly when, when it's not revocable. Is that correct? Yes. And I would, by the way, propose the same thing for the chain id as well. Make it optional. Got it, Dano.
00:29:27.134 - 00:30:09.524, Speaker A: So if we make the notes optional, we make eternal authorizations possible. And that's where my big concern is, unrevocable eternal authorizations. Because we'll always have buggy code, we'll have supply chain errors, we'll have user error. I still want some mechanism such that if there is an internal authorization that can be provoked in setting the notes to zero, you know, if there's a way to create a permanent one, that's kind of the problem. That's what I'm looking for, is some way to revoke these. And I agree with Ansgar in that putting the parameters into a smart contracting opcode is way too early. So, yes, I don't like that proposal either, Richard.
00:30:09.524 - 00:31:29.158, Speaker A: Yeah, just wanted to what making optional means, because it's interesting making a parameter optional. Here we have multiple parts in the auth call, and there's the commit part where it becomes more optional if you move it there, which I think was the ERC part. But also here, if you want to keep still on the outside, the same compatibility, where we say, we would want that account nonce could be this global revoke, then we would also need a way to access the nonce, the account nonce, which is currently not possible as an opcode. So basically the question would be, should we then push a nonce opcode, which again increases the complexity? Or do we say everything else is just another step that potentially, then if you go the extreme argumentation route, could be bugged and not be called. Yeah, Ansgar. Yeah, just briefly on the panel, because if you still have the option, at least on personal, then you can always physically still accept access your own nonce. And then for other contracts, you could basically, because you can just have arbitrary logic, right? You can basically just have, yes, they cannot currently access their own nonce, but you could just have any other replay protection mechanism.
00:31:29.158 - 00:32:53.994, Speaker A: Instead, they can just manually write to storage and it has the same effect. Ok. And there was a bunch more comments in the chat, but including one by Mira saying, you know, should we have like a specific breakout room to flesh this out? I sort of am leaning towards so, like, it feels unlikely that we agree on the large design change at EIP right now. And I think there are some, there's a concern that if we send this back to breakout rooms, we just keep iterating on it forever and then end up not shipping something in this fork, which is not great. So, yeah. Do people feel like a breakout room potentially next week, and then seeing if we want to make that recurring for a while would be valuable. I think we probably want some solution or final spec for this in the next month or two if we're going to actually ship it in Pectora, assuming it's like a relatively simple change.
00:32:53.994 - 00:33:40.150, Speaker A: And overall, the CIP is not a huge one, but yeah. Does that make sense to people? Okay, no objections, I guess maybe if people want to coordinate in the chat here or on the discord to find a time. Yeah, I think basically discussing the topic of revocation, we didn't even get into chain id today, but based on Anzagar's comments, maybe we can use a common mechanism for all of that. Yeah. Okay. So Matt will set up a breakout room where we can discuss this further. We'll keep, I guess, maybe back to the original concern.
00:33:40.150 - 00:34:43.354, Speaker A: On the Nethermind side, does it make sense to make that change with regards to delegate call for Devnet Zero? My sense is no, we should just keep the spec as is for Devnet Zero, and then when we have a consensus on the updated spec, we can just move the whole thing. Does that seem reasonable to people? So yes, Ahmad Devnet Zero has 3074, but we would not change it from the current spec. And yeah, there's a comment about, like, fully removing 3074 from Devnet Zero. I would lean against it because it still seems like teams are in favor of doing it and it's more a question of how rather than if. But yeah, if a month from now, we realize that there is no path forward and no one is happy about it, we can always remove it then. Okay. So.
00:34:43.354 - 00:35:47.066, Speaker A: Oh, siri, I see you have your heads up. Is this about 374? Yes. The suggestion was that we would discuss additional stakeholders who did not get a chance to voice their concerns about 3074 in general, and perhaps consensus was formed prematurely before polling in deficient community members. So I think there are some people on the call that have concerns about 3074 being kind of bad in principle and something that would slow us down on the path to full account abstraction. You know, that it's essentially a pledge that doesn't give us things like key rotation. Look, I think we have basically discussed this for like, the past four months on this call on and off. And I know there's a ton of ETH magicians thread.
00:35:47.066 - 00:36:37.380, Speaker A: I know there's other proposals. I know there's like some effectively, like, tetra step that we get out of this if we move to a, like, full, say, 437 world. My sense is that despite all of that, client teams still seem pretty in favor. And it does seem like the most, I don't know, the proposal with the most consensus in the short term that we could actually improve the state of eoas in the next fork. So I guess unless there's like, something new that came up and like, yeah, I would the client team shouldn't be the only ones that make this decision. This is something that affects everybody. And, you know, we should hear from other stakeholders.
00:36:37.380 - 00:37:43.394, Speaker A: Unless we want to say that basically we're handing over governance, the client teams, which I don't feel is a decision we ever made explicitly, it's quite unsafe, in my opinion. So if we don't want to veer into the realm of making contentious hard forks with everything that entails, I think it would be better to try to get a feel for what other stakeholders, how they view this proposal. I mean, I think this proposal was first brought by, like, not like, I mean, non client team developers requested this for this fork. And again, we had a bunch of conversations about this. It's fair that, like, some people disagree and look, I agree that we should, you know, we should get broader input in that. But, yeah, I'm, I'm not, I'm not convinced that there's that much value in, like, rehashing the whole debate again. But yeah.
00:37:43.394 - 00:38:11.256, Speaker A: Yeah. Martin, is this. I don't think it's about rehashing the arguments. I mean, some of the arguments maybe some people have not heard. It's just feeling out whether we do have consensus. Because, you know, this is, again, something that affects everyone. And there's a trade off here to be made between improving things on a short term basis with something that does have potential UX improvements but also has potential us drawbacks depending on how you implemented.
00:38:11.256 - 00:39:14.144, Speaker A: Also on other levels of the stack, like wallets, whether you're whitelisting or you want, you're not whitelisting. So I think, I feel like it's important for us to at least, and for the client teams to at least understand how other parts of the ecosystem are viewing this. And if it's true that, you know, there is actually consensus, then that's one thing. But if it's just something that's convenient and easy to implement, but maybe it gets us stuck on a local maxima and delays us in getting ux improvements that are more sustainable long term and improve the UX for everybody, maybe that's the trade off that we want to discuss because, you know, ultimately, this is a value judgment on what you want to prioritize. So I feel like we should at least hear other people out. Yeah, Martin, please. Yeah.
00:39:14.144 - 00:40:26.380, Speaker A: Yeah. So I think, well, I have probably been one of the voices who have been critical about, or at least raised some concerns about 3074 still. I do think progress is important, and I really don't want to stop this progress. And essentially kind of try to heckle or reverse that decision. I think I would say we should go forward with 3074, but I still wanted to bring the perspective that it brings smart contract developers in a, well, challenging perspective or position because clearly we want long term account abstraction with things that key, key rotation. And the question has always been, is there a path to upgrade EOS to do that or is the manual transition necessary? And with 3074, kind of the answer lies in between. It is partially doing this migration of eoas, but not fully so kind of for smart contract teams it's just 3074 without commitment to 5003 puts them in a hard place.
00:40:26.380 - 00:41:31.524, Speaker A: And I heard that from, obviously I talked to Saif, but also to the other smart contract teams because, well, now it's not clear, should we try to convince users to give up the UAEs and move to a smart contract? Or is there actually a pass to stay on this eoa and fully upgrade it? So I would say, or my wish would be that there is a commitment to one of those two passes. So essentially saying either yes, we say we want to upgrade UA's and there will be, whether it can be directly included in this fork or in a future one, but at least there's a commitment to, yeah, let's say 5300. Well, that would be great also if there's a commitment. Okay, this will not happen. Well then that would also be an answer. And then, you know, okay, well then you can use 30 74 at least to make it very efficient to batch or to do a large transaction and move all your funds over to a smart contract. I mean, that's also something to work with.
00:41:31.524 - 00:41:51.072, Speaker A: But uncertainty is quite challenging. Thanks. Yeah, and I think that's, that's very fair. Like um. Yeah, like whether 3074 has a path towards full smart contract wallets. Yeah. Is an important question to, to, yeah.
00:41:51.072 - 00:42:30.414, Speaker A: To determine. And I will say, yeah, like we did consider, you know, 5806 early on this year and had a bunch of conversations about that. So, yeah, there is a tension between rehashing all those conversations versus moving forward with something that actually improves ux today. Anzgar. Yeah, I just wanted to largely echo and agree with what Martin just said. I think some of the concerns here from the code side is more on the process side. Debated this for quite a long time.
00:42:30.414 - 00:43:46.778, Speaker A: I think a lot of the concerns came only after the decision was finally made, which of course is not how that should be. At the same time, I understand that the governance process is not, even though it's open, it's not always super legible for people who don't, as part of their full time work, pay attention to it selectively. So I feel like it's important that we kind of find there's some sort of compromise here. And I think actually, because we've had precedent, right, of changes that are kind of preliminarily accepted into a fork, and then relatively close to the fork, we make a final goal, no goal, no go poll, and potentially pull it back out, which is always not that hard to do. So I personally would propose that we basically spend the time between now and when we would have to make a final decision. The default would be that it is assumed that 3074 is in, because we did accept it after all, but that basically now there's a responsibility for us to really spend the time sketch out a concrete plan that includes a proper kind of long term transition path, including, I don't think it makes sense to consider ERP, like 50 three for pector, but I think, for example, committing to shipping it as soon as possible afterwards or something, or some general upgrade path. So basically on that side, and then also separately, just basically having a very kind of reliable path for compatibility, even in the meantime between 3074 and 437 in place.
00:43:46.778 - 00:44:51.400, Speaker A: And I think basically we should have the understanding that 3074 will be pulled out unless we make enough progress there that by the time we make that decision, everyone is happy about the path forward. And I feel like that seems like a reasonable compromise to me, marginal to everyone, I think. I agree. Yeah. Vitalik? Yeah. Just like one side point in terms of this idea of agreeing on a path forward beyond spectra, one other side of this that's worth keeping in mind is basically signaling ahead of time what kind of guarantees and invariants are going to exist versus are not going to exist. And so there's possibly value in doing some kind of signaling similar to how we deprecated self destruct, but like, for example, deprecating the idea that if an address has no code, then it's non transferable.
00:44:51.400 - 00:45:44.934, Speaker A: Or like similar kinds of things that are used by like for either soul bound token people or other kinds of applications. Like, I feel like there's like some small number of applications that rely on certain invariants that exist today that are definitely not going to exist in a smart contract world. And this is one other of those like two or three hard works out things that's also worth thinking about pretty far ahead of time. Yeah, I think that's actually a really good point. Especially something like if we did 503 and for whatever reason we can't include it in this fork. And that changes effectively the invariant on an EOA. We can then have just an informational Eip in this fork saying, as of Osaka, you can't assume that an EOA stays an EOA.
00:45:44.934 - 00:46:36.194, Speaker A: And this is also good just in terms of giving people time to deal with this behavior. So if, for example, we decide in like two, three months that we want to do 503, and then we ship that two, three months after that, it feels like a really quick timeline to change something that's been a pretty strong invariant for like, yeah, over five years, almost ten years at this point. So I guess clearly we're not going to come up with a final spec now. Like, client said he would organize a breakout room on this. Where should people go to just like basically help schedule the time for this breakout. I'll post it on all core devs discord. Cool.
00:46:36.194 - 00:47:13.934, Speaker A: Yeah, I think it makes sense to have it there. And I think, yeah, we'll definitely open a GitHub issue. No, I'm. As soon as we have a rough time, and I think for anyone who thinks, who has a different perspective or concerns about 3074, it makes sense to bring them up there. Yeah. So anything else on study IP? Okay, yeah, thanks, everyone. I appreciate people coming and sharing their thoughts on this.
00:47:13.934 - 00:48:28.402, Speaker A: And again, yeah, for Devnet zero, let's just leave it as is. And hopefully in the next month or month and a half, we can have sort of a v, two of the eip that we can then change all at once. Next up, there were a bunch of proposals that people also wanted to get included in Pektra. I've listed a few on the agenda, but two more that weren't posted in the agenda. But I know we've been discussing your, obviously EOF, and then Ethan had a bunch of SSD related eips that he, he posted in the east magicians thread. I guess given that we have already like six or seven eips in Pektra, the client teams have not implemented those. Does any like, client team feel comfortable including more stuff yet? If not, how do people think we should proceed with regards to, like, signaling what we might include in this fork? Do we think there's any chance we can include anything more? Yeah.
00:48:28.402 - 00:49:48.124, Speaker A: How do people feel about that? Kind of depends on what we're going to include. Like, for definite zero, we're like, we're definitely not including anything more. Yeah. For Petra, if we were to include UF, then the focus does definitely full. If we were not to include UF, maybe we could include something more, but even then I would be kind of against it. Got it. Any other teams have thoughts on this? Well, not speaking as one of the execution client teams, but there are still some potentially unresolved security concerns regards to AIP 3074, and it is possible that they will be resolved on the Devnet one way or another, but it's possible that the ones that we kind of flagged as potential issues are not the only ones.
00:49:48.124 - 00:50:48.638, Speaker A: And it's been three years since the last audits. Quite a few things have changed. So there is potential interactions that we may not have fully taken into account and seems be a little bit safer if we do more work just to validate that it's going to be, you know, safely interacting with everything else. I think they're probably the best. The best approach is one getting to expect that people think is reasonable. Once we have that, I think we can consider whether or not we want to have an audit. I don't want like an audit to be like a reason we just used to delay making a decision.
00:50:48.638 - 00:52:04.794, Speaker A: If people actually understand the risks and are comfortable with them. Not that we should never do them, but historically there's probably like a 50 50 hit rate as to whether these are actually quite valuable and provide us new information on something or just something we do to effectively get more confirmation on adverse delay kind of the process. So I definitely wouldn't want to commit to like imposing this extra requirement on this EIP until we have one and final spec and two, like a reasonable concern to think that there's something about this spec that's like unique in that it requires an audit, whereas like, by default the ips don't get a full audit before they go in. And I guess, yeah, back to just a broader inclusion point. So there was a comment in the chat on 7212, which is like a relatively small change, and it feels like there are a bunch of relatively small changes that are being proposed. So 503 is one, 7623 the call. Data repricing is one.
00:52:04.794 - 00:53:46.302, Speaker A: Are there changes that teams would like to CFI to sort of signal a shortlist for stuff that's being considered for Petra? Do people want to just leave the scope as is, move forward on the implementations and then revisit this in a few weeks? Yes, Ahmad. So a personal opinion is to include 7212 or a similar widely supported elliptic curve to actually improve account abstraction for the users. If we keep like, instead of trying to say that EOA will stop account abstraction from proving, we should actually try to improve account abstraction. So people actually try to move to that and 7212 does exactly that. It improves how account abstraction could deal with the user's keys and allow things like passkeys and fingerprint authentication and our fingerprint signing, et cetera, biometric signing, a lot of other possibly key holding devices like cubikey, et cetera. So these things, I believe that including something like that will actually do improve account abstraction in a meaningful way. Thanks.
00:53:46.302 - 00:54:44.598, Speaker A: Any. I know base two was like in favor of 7212, but yeah. Any other thoughts from climb teams on this? Aragorn is also in favor of, I think the. Go ahead, Marius, you can do it. Yeah, I think one question that we had was, is r1 the right curve to be adding as a precompile? I am under the understanding that there is another curve that is starting to gain adoption and that people are migrating towards. I feel like if we're going to add a precompile, it would be better to add the pre compile that people are moving towards right now rather than the precompile that's on the way down. But this is something that is like a bit outside of my expertise.
00:54:44.598 - 00:55:50.516, Speaker A: So I'm not sure if anyone specific. Op ed rising curve do you have in mind? I have heard that people are looking at moving towards Ed 25519 as an alternative, but I don't really know what the status of that is in hardware. Yeah, I don't either. I definitely know that 2519 is super popular in just cryptographic applications in general, just because it's a very fast curve and it has addition equations that don't have any subconditions, which makes it like simpler and side channels safer. But yeah, hardware support, it depends. Um, maybe we, this, this gets into a bigger rabbit hole of like just how general might it make sense to make an elliptic curve pre compile, but might be worth taking offline? Um, Ansgar, is this on the same topic? Yeah, I just wanted to very quickly mention and just flag for people that they're aware. So seven to twelve happens to be the only, the first and so far only ip that has been shipped to L2.
00:55:50.516 - 00:56:51.304, Speaker A: So there's quite a few L2s already that have this life in production, which of course does not, you know, have to force our hand at all on mainnet decisions. But at least it's something we should, we should take into account. So keeping in sync with features that are shipped on L2, I think should at least be a small reason to what's doing it. Yeah, I guess based on all this I would lean towards just making 7212 CFI. So we have it as like part of our short list, not committing to implement it, you know, in the fork yet, and definitely not in Devnet zero. Yeah. Anyone against that? Okay.
00:56:51.304 - 00:57:42.740, Speaker A: And I guess, yeah. Are there any other of the proposed eips that like client teams would like to sort of CFI so that we can consider it for the next devnets once we're a bit farther on these implementations? Yeah, I also like 7623. This is the call data. The call data replacing. Yeah, it's not like it's super easy implementation, but also it makes kind of intuitive sense for me to cap the amount of call data that can be put in the block. In the block size. Right now the maximum block size is 7.4
00:57:42.740 - 00:58:23.878, Speaker A: megabytes. Right. Uncompressed because we snappy compress all the time. It's way less. Something like two or three megabytes. But if we are, when we're moving to what's the pier does and putting more blobs on the chain, it's just a nice insurance to have a tighter cap on the maximum size of blobs that we need to send. Okay.
00:58:23.878 - 00:59:35.154, Speaker A: Anyone else in favor of CFI? 7623 are strongly opposed. I think if we ever want to rise gas limit, this CIP might be required, for example, because CL clients have ten megabytes limit or we have to change this limit and the CIP will makes make things better here. So, yeah, I think it is good ap. Okay, any other thoughts on 763? Yeah, I guess it would probably make sense to CFI this one as well. No, we've been talking about it for like several calls and people were generally supportive. But again, it's like a question of bandwidth and. Yeah, yeah.
00:59:35.154 - 01:00:19.104, Speaker A: Richard has a question about this around data, whether data around how this would increase average gas costs. Tony had a ton of data on this. I don't know if he's on. I think he's on the call, but what's like. Yeah, what's the best place for people to sort of see all your analyses? Yeah, so I put a lot of posts on ethresearch. I think they're free so far. And in the one that is directly about the eap, there is also this GitHub page linked where you can input addresses or functions and check if they would be affected by the increase or not.
01:00:19.104 - 01:00:53.314, Speaker A: Nice. Yeah. If you can post this in the chat here for easy reference, that'd be great. Yeah, I will directly look it up and post it. And then Anzgar is a question to chat around. Like if we have broad support for it, why not included immediately? I think given all the stuff we still have to implement, I'm cautious of adding more things in an ad hoc way where if over the next three calls we just add a little thing. A little thing.
01:00:53.314 - 01:02:08.464, Speaker A: Every call we end up in a spot where we can't actually commit to a bigger thing to add to Petra because we just added a bunch of small things. I feel like it's better to just identify the things we'd want to add after devnet zero. Actually get Devnet zero done, see how things are for something like eoF, see how things are for 3074, and then decide like, okay, do we want to add like two small eips, one big eip, and have that conversation when we actually have more context? Does that make sense? Okay, aside from, from these 272-12-7623 anything else client teams feel strongly about? Were we going to talk about the SS zero? I don't know if Ethan is on the call. He posted an update on Eat magicians. I'm not sure if he could make the call to talk about them. I don't see him. But there's 100 people here, so maybe I missed him.
01:02:08.464 - 01:03:05.862, Speaker A: This is SSC on the exhibition there, right? Yes. So let me, I'll post his comment in the chat here. Vitalik, did you have thoughts on them? Let me read through the comments and come back in a minute or two. Cool. And yeah, worst case, we can always discuss this on the, on the next call. Any other, any other eips people feel strongly about? I feel strongly about not including SSE on the execution layer in sector. I think for that we would need to write or audit new libraries for the SSE formats.
01:03:05.862 - 01:03:58.774, Speaker A: We would think about the hashing overhead and stuff and that would really make it, make it hard to. And SSE education of the execution layer should happen in a future form. Yeah. Just to add to this, so I've been evaluating SSD libraries after we discussed that in Taipei, and I'm talking about the Golang SSE libraries and there's one I still need to look at, but none of them is really workable with at the moment. Which is why if I'm correct, we decided to drop the topic for the previous fork. Got it. Anything else? Isse? Yeah, I just looked at that quickly.
01:03:58.774 - 01:05:05.214, Speaker A: Is there an eIp yet for ssefi and receipts? I know there's been a bunch of work for transactions, right? But I'm pretty sure there is. Yeah. I think it's very close to the transaction Eip, right? Yeah, because receipts I think are also super high value. And one of the reasons why is basically because receipts are the one place where you get, where currently we can have these like indivisible, potentially like many megabyte hashes take place. And that actually causes a whole bunch of like pain and extra security auditing overhead for, for roll ups, which admittedly can be solved by, by a layer too. But like, there's basically a lot of receipt hashing applications that are needlessly for x two inefficient at the moment that could be approved a lot. So I think there's like, there's significant value beyond the inherent goodness of cleanups to think about it.
01:05:05.214 - 01:05:41.984, Speaker A: Okay. One other thing I think is worth getting an update on is EOF. So I asked, I know there's a meta eip that's in progress. I think we still need to get it merged. But yeah, I know there's been a lot of work on that in the past couple weeks. There's been some work done into like looking at the interactions with Verkle. I don't know if someone from the EOF camp wants to give a quick update there so people can get up to speed.
01:05:41.984 - 01:06:18.994, Speaker A: Yeah, I'll take it. So yeah, we've got, we're starting to write execution spec tests. We have specific facilities added in there to test the OS. Base, EVM one and ref have reported they've finished their implementations. Geth is making really good progress, and the difficult parts are the parts we expect. The validation has a lot of corner cases. The tests cover very well, and the operations themselves really aren't terribly difficult once you get well compared to the validation.
01:06:18.994 - 01:07:03.502, Speaker A: But it's achievable within a single handful of months for a single engineer. So that's Rhett's report from it. I know that Guillaume from Verkle has been speaking with Daniel from solidity. When it comes to cutting features from EOF, my big question is we can't cut so much that solidity and Viper won't support it in their compilers. That for me is the point where it becomes viable and non viable. So Guillaume's working with Daniel to see what that point really is, because they're the ones most interested in reducing the scope and reducing the risk in EOF. I'm comfortable with where it's at now, but I accept that other people aren't comfortable with it.
01:07:03.502 - 01:07:42.634, Speaker A: And I think that's the right approach to figure out what the customers really want out of it and what the real minimum standards are. So that's a brief update of the OS. Thank you. Anyone else want to share thoughts or updates? Okay. Oh, actually, sorry. Yeah, I just want to give some more details. Yeah, so it's true, I've been talking about the topic with Daniel to try to reduce the scope a little bit.
01:07:42.634 - 01:08:42.373, Speaker A: It turns out that, yeah, it's going to be hard to cut the scope, or at least the pushback that has been given by Anzgar especially, is that, yes, we could reduce the scope, but then that means the second version of EOF would have to be fairly small or fairly yet hard to justify by itself, and therefore the fear, at least. I mean, Ansgar can give the argument himself, I guess, but that would mean that. Yeah, if we have a reduced copy of, that means that's the only thing we deliver for the next five years, and that pretty much kills the whole point. So, yeah, we're still trying to find a sweet spot, but it's not going to be very easy to not ship all of it in one go. Got it. Yeah. Is there any way to.
01:08:42.373 - 01:09:12.714, Speaker A: Please. Go ahead. Sorry to jump in, but is there any way to ship, like. Because the problem is like, we're trying to like, upgrade the train while it's running. Right? Is there any way to, like, ship experimental versions of EOf that can be iterated on that run in like, a sidecar? We. We discussed something like this, like, on l two s a few years ago, and this was before, like the rip process was. Was a thing.
01:09:12.714 - 01:10:32.796, Speaker A: I think the concerns from then where, one, there's probably some of the EOF work that we want l one client teams and testing teams and security teams to actually thoroughly review. And so there's a significant part that it makes sensor l one to own two is basically l two's shipping and deprecating a version of EOF leaves them with the depth forever. And that's not something they were super keen on. And then three is if we have something like Devnets or whatnot, then it's hard to get enough support from tooling and languages and whatnot. So sure, we could launch an EOf V one five devnet, but like, will solidity and Viper and all that support it, that seems unlikely. What if it's like neither? What if it's like an l two that, you know, well, some set of responsible parties set up that is kind of like a Devnet in that it's supposed to be torn down at some time, but it's also not mainnet. So the risk is like, if.
01:10:32.796 - 01:10:52.700, Speaker A: Yeah, either there's, either that chain has no value or it has value. If it has no value, the incentive for tooling to support it feels very low. Maybe that's changed. Like maybe there's more tooling providers today. But if there's value it's like yeah, people's eats can get stuck. Yeah. Why couldn't it have value? Right.
01:10:52.700 - 01:11:54.734, Speaker A: So yeah, so if you have value on it and then you have a deprecated version of EOF and. Or like a conflicting version of EOF and stuff like that, you end up in this case where you have actual funds that are stuck potentially in something. And I don't think anyone just wanted to take on that complexity. I mean if the, I think the issue that I've seen repeatedly in discussions about UF is that. Well it's like not perfect, which I actually agree. And if the, if the, if the goal, if the bar is that we need some system that is perfect, or at least like very long term, like the nature of these things is that sometimes you don't actually know until they're in production. So I don't know if the, the bar that this must be perfect before you ship it bar is very realistic.
01:11:54.734 - 01:12:36.306, Speaker A: Yeah, let's do Guillaume. Yeah. So just to give some like share more information from, talk with Daniel and try to answer some of those concerns. Basically the compilers, what they want to. There's an EOF version that's not the compiler support EOF, but they support the former version. And in order to keep maintaining this, to be able to produce testnets and try to do some testing. And by the way, this is a problem we have for vertical too, because we would like to understand how Verkle and EOF interact.
01:12:36.306 - 01:13:08.794, Speaker A: But there's no way to test this at this time. What the compilers want is to have EOS scheduled. Yeah. I think we should schedule it for sure. I don't think it will come to anybody as a surprise that I think we should schedule for Amsterdam. But in any case, compilers, if you want EOF to make progress on the tooling so that you can actually test it, you need to schedule it. That has been made very clear by compiler people.
01:13:08.794 - 01:13:43.236, Speaker A: Yeah, yeah, I'm pretty aware of what compilers want. So I think that. Yeah, if we can have some kind of middle ground, it might be very helpful for everybody who's working on it. Yeah, I know that. Yeah. Andgar and Vitalik have like a thread in the chat about potentially simplified version. Yeah.
01:13:43.236 - 01:14:32.004, Speaker A: Either of you want to give some context of that? Yeah, I think the idea was just to say that there's two different types of small Uf we could ship. There's a small uf that would basically be incompatible with the big UF. And so it would require us to then ship a separate version of UF later on if we wanted to. All the features of big UFO. That is the downside that then forever and ever now layer one has to support basically raw contracts, UFP one and UFB two, because all of them exist. Whereas if we can basically slim down the scope of Uf by just removing features that can be later on added to the existing version without breaking things, for example, we could initially just not ship a specific opcode, and then we later on add the opcode. That usually does not require a new version bump.
01:14:32.004 - 01:15:10.726, Speaker A: That makes much more sense, because then we can ship small UF now and still by later on adding the remaining features, we would not need a new version. So that variant of small Uf actually, I think is promising. But is it so easy to add a new opcode to UF? Because you need to kind of, you need to make sure that. Yeah, you just add a new opcode the same way we add new opcodes today. Right. An Eof. Right.
01:15:10.726 - 01:16:24.044, Speaker A: And because we have validation. Yeah, because we have validation, we have greater security that that space is there and unused. We won't run into nasty side effects like when we're trying to add relative jumps into the legacy code that, by the way, you could put jump test in a push zero, in a push 32, and things suddenly change. You do need a version bump, because otherwise it won't pass validation. It'll pass multiple levels of validation. You don't have to encode the version in the byte stream, but you would have different versions of validation, at least for us, complexity wise, what would basically mean? Because you would have to write new validation that basically copy most of the validation algorithm. Right.
01:16:24.044 - 01:16:50.344, Speaker A: But there's a difference. I don't know, it can be. Oh, sorry, you sort of broke up. Yeah, it's not a, it's not a version bump, but it wouldn't be a version bump. That would make the complexity similar, at least in our implementation. Got it. Anzgar.
01:16:50.344 - 01:17:37.704, Speaker A: Yeah, I feel like you were also starting to say this, but I just want to point out that there is still a difference in the complexity, because it might be the same complexity to, for like implementing and adding these extra features later on. But in terms of long term support. Right. If you think ten years from now, in one world, the client needs to support three different types of bytecode that it could encounter in the VM. And in the other version it only needs to support two different types of bytecodes. And because the kind of the validation on deployment rules you only have to do if you replay the old history, and I think there are all these ideas already that clients in the future might not be just out of the box support, replaying the entire history, and you might need to have like older versions of the clients for that and everything. It basically means in one world you can slim down the rules and forget about these old rules, and the other version you have to support them forever.
01:17:37.704 - 01:18:15.880, Speaker A: So I do think it still makes a big difference, I guess. Yeah. This also feels like something we're obviously not going to fully specify on this call. There are bi weekly, if not weekly, EOF calls, so I think it probably makes sense to continue the conversation there. And then again, as we get ready to consider stuff, add the backdrop beyond what's already there. Yeah, hopefully we can make some progress on all those issues for EOF. Yeah.
01:18:15.880 - 01:19:23.544, Speaker A: Any final comments, questions, concerns about EOf going back to this sidecar thing that I'm hung up on. I don't know. I think that l two s might be interested in doing it if there was a guarantee that under certain conditions it would be merged into Mainnet. Because I think the issue is nobody wants to be left holding the bag, Mainnet doesn't want to implement it and then have to change it later. L two doesn't want to implement it and then just have it be turned into a abandoned or whatever. So if there were some way, and I, maybe this is going to be important, like going in the future because of what is it called? Like l one, ossification. So I think if there is some way to like kind of increasingly escalate the stakes involved with it, instead of it being like all of a sudden all or nothing, maybe that's another way to do it.
01:19:23.544 - 01:20:04.640, Speaker A: Yeah, that is the last thing we had on the agenda. So let's do the comments by Ipsalon and then we can move over to that general topic around like l one and l two, governance and feature deployment. Yeah, Epsilon. Yeah. Maybe this wasn't made clear in today's updates, but on yesterday's UF call we did mostly agree to simplify the creation question. In the chat there were some discussions about EOF create and TX create. EOF create is for creating new contracts within an existing contract.
01:20:04.640 - 01:21:00.794, Speaker A: So like factory contracts and TX create is the external transaction creation process. The TX create is the more complicated one and we agreed to go with like a legacy approach, which we don't think is the final ideal case. But the design we have is actually forward compatible. It doesn't require a new transaction type, it doesn't require a lot of complexity. It is rather simple, but it's forward compatible with introducing TX create and a specific transaction type in the future. And I think this was the most contentious item in terms of complexity and it seems we have removed this. So I think we would be curious to learn maybe on the next UF call, which is every Wednesday, we would be curious to learn what other blocking complexity exists.
01:21:00.794 - 01:22:18.812, Speaker A: Thanks. Okay, so there, yeah, can someone pose the agenda to the next EOF call in the chat here or on the all core devs discord so people can know where to go for those? Okay, last topic on the agenda. So this, yeah, we've covered this a bunch of times sort of indirectly today, but l one versus l two processes, I guess, you know, the question is around how should we think about ethereum l one's roadmap, given that we want rollups to play larger and larger role, can rollups actually ship stuff before? What's the process we can use for something like that? It might make sense for Carl and or onsguard to start by sharing their thoughts on that, given they've been running the roll calls for the past couple of months. And yeah, we can take it from there. Yeah, I can. I don't know whether Carlos. I can definitely say something.
01:22:18.812 - 01:23:11.588, Speaker A: So basically we've had kind of the roll call as like a kind of an experimental forum for a while now, for half a year, over half year already, and the kind of accompanying IP process. The way to think about it really is to. I think there are basically three different dimensions here. There's the research side, there's the governance side, and then the client implementation side. So on the research side I think we basically, we still have an open question of long term, do we want to stick with EVM equivalents or not? There have been like a lot of arguments on both sides of this front, but a lot of it hinges on this question. So basically there are all these ideas like in the future we could have an enshrined ZKeVM on Mainnet and then you could have basically enshrined rollouts that, that natively are verified and everything. All of this only works if you have fully equivalent L2s that follow the exact same rules as layer one.
01:23:11.588 - 01:24:00.304, Speaker A: In that scenario, we don't really have to talk about this topic much. Then we maybe should just talk about how can we have L2 s be more present on orchardv so that we can maybe govern the EVM together more kind of effectively. But if of course we decide that it's fine that if L2s over time depart from Mainnet EVM, then the question stays. That becomes how can we basically enable them to do that more? And there specifically, that's again the governance and the client side. And so basically on the governance side I think it's more the question about L2 in the past have been very reluctant to ship features where they basically have the worry that Mainnet might either never ship them, which is still kind of fine, or ship them in a slightly different and incompatible way. I think this is usually what they're the most afraid of. Right, because then that kind of bifurcates the ecosystem a lot.
01:24:00.304 - 01:24:31.934, Speaker A: And I feel like for that we really over time need to just make a decision on layer one. To what extent we are willing to take this into account in our decision making. Of course, L2 make decisions before layer one makes them. So to what extent are we willing to basically be bound by L2 decisions? The nice thing is that with the r1 pre compile we have the first candidate where we can just very practically debate all of this. So if they next call, we want to talk about whether to include the r1 precompile or not. We have a lot of these practical questions to answer. The L2 have already shifted.
01:24:31.934 - 01:25:07.116, Speaker A: We have given them a separate, if you remember this from a couple months ago, we've given them a separate free compile range. So now L2 have shipped the r1 pre compile at a L2 specific address. Do we want to take over that address? Do we want to not take over that address? Would we even want to maybe say modify the opcode, the pre compiled behavior or are we willing to say, no, it's finalized in L2. We're also going to take it as is and basically ship the same version. So I think basically just exercise going through this exercise of figuring out to what extent we are willing to basically be somewhat bound by L2 governance on the layer one side. I think this would be very helpful for guiding L2s. And then the third one is, that's also a really interesting one.
01:25:07.116 - 01:26:16.690, Speaker A: So far, even though there has been some interest for L2s to basically start diverging more, the main worry they have is that a lot of L2s, of course, also run layer one clients out of the box as clients for their own chains, as well, client developers here so far El client developers mostly have focused on the l one feature set. And so the question is how can we start enabling chains that don't quite follow layer one? The layer one feature set basically have to still use these same clients more. So I think in the past there's been quite a bit of debate, like some clients are more open to also like say supporting their two specific features out of the box. So for example, implementing and supporting ips. I know for example from Geth that there's a bit more skepticism and hesitation about supporting features that are not actually intended for Mainnet. And if that's not the right path, we could also talk about more standards for extensibility of clients. But basically we need to find a path forward where actually practically in software and client software these features can be supported.
01:26:16.690 - 01:27:09.874, Speaker A: Otherwise it's, it's just a nonstarter. So basically, I think so far our lessons from six months of roll call, these are the three topics research. Do you want to diverge from EVM equivalence governance? How does layer one interact with the decisions L2 makes on EVM changes? And then on the client side, if L2 want to actually ship features beyond layer one, how does that actually then end up in code? And I don't know. Carl, do you have anything? Does it match your impression? Yeah, I think that's a pretty good summary of where we are. Thanks. Yeah, that was great, Peter. So one thing I wanted to react to was basically how we should approach when L2 ships certain features and whether we should pick those features up or not.
01:27:09.874 - 01:28:26.274, Speaker A: I think there's a, I wouldn't necessarily call it dangerous precedent, but there's an interesting thing there that if we commit to L2 introducing something, and then we'll just pick whatever they introduced. I think we kind of run the risk of L2 just yoloing in certain things which they want and then they can just point to it. Basically one of the dangers is that feature that they ship might be appropriate for them, but might be not completely appropriate in general for everybody. And then the question is, well, since some big important layer to shift it, are we going to basically have everybody use something that's not really appropriate for them? Just because, I don't know, optimism rolled with it first. The other problem that I see is what happens, for example, with precompiles. What happens if you have two L2s which use the same address for different precompiles? I mean, how do you solve that? Because then you cannot actually follow what L2s are doing. And thirdly, I think it kind of.
01:28:26.274 - 01:29:01.554, Speaker A: I'm not entirely sure we want to end up in a place where basically L2s get to dictate that while we shipped it, it works. So you have to roll with it. So I think it's because of these things. I think I would be kind of cautious against going down the path of saying that, well, L2 x shipped it, so we should ship it. Yeah. And I don't think anyone proposed that specifically. But I agree this would be like a huge, huge risk.
01:29:01.554 - 01:29:56.254, Speaker A: Yes, I agree it's a huge risk, but I also don't think it's anything anyone's trying to do. I don't think the L2 s are trying to ship some weird feature that no one's going to want or whatever. And there's no proposal that whatever ships on L2 has to be shipped on layer one. I don't think that's a realistic concern yet and I think we'd have to address if we ever got there. I don't think this is a way of L2s co opting and trying to take over layer one governance. I think this is just L2 is trying to have their own sensible standards for this happening. And then to your second point about shipping pre compiles at the same address, that's one of the things we want to help prevent with rips and roll call is like how do we prevent these kinds of things from happening? Because that would suck for everyone involved.
01:29:56.254 - 01:30:49.914, Speaker A: And so it's like part of what rips are trying to achieve. So I definitely agree that. I don't think there's a danger of L2 necessarily wanting to co op layer one governance or do anything super mean or. And obviously if they were to deploy something wonky, then obviously there would be no, not even a guarantee layer one wouldn't follow them. I think the dangers are at least the things that I see as potential problems are more in the nuances, in the details, one as a L2. The idea, the reason why people like L2s is because they are two s can experiment. They can really go very fast and they can, I wouldn't say break things, but the guarantees are a bit different.
01:30:49.914 - 01:31:39.524, Speaker A: But this kind of also means that L2s will probably. But once they have a solution for their problem, they're going to roll with it. They will not wait for 100 people to agree whether that solution is the perfect or not for everybody. They will just go with the perfect solution for their specific problem and I think that's the best. And nastier corner case, where, for example, you have optimism, who ships a solution for some quirky problem which isn't perfectly optimal for everybody else. But then, okay, what do you do? So that's the issue. And I think L2 will be actually incentivized to just roll whatever they want with the nuances they want, and then just say that, well, we can't really change it, so you just have to roll with it.
01:31:39.524 - 01:32:56.294, Speaker A: I think my biggest concern is what happens if roll ups just die and walk away. And we have to keep maintaining the feature because they once needed it, but now they've either completely vanished or they have changed their stack to use some different proving mechanism or whatever. And there's a lot of precedent for this, where like people came and proposed features and pre compiled for exactly their use case, and then their use case didn't really work out, or they completely died, or they moved on to the next thing and we are stuck making maintaining the BN curves. So yeah, I wouldn't like to be in a situation in this situation. Thanks. We're already a bit past time, so let's do Pooja and Ansgar and then wrap up. Thank you, Tim.
01:32:56.294 - 01:33:39.860, Speaker A: I know this is not the best place to discuss the process part, but I'm thankful to Ansgar that he brought up the significant element, which is governance here. I'm really interested to understand a little bit more about it. Maybe in short of time, we may not be able to do it here right now, but it would be very interesting to learn about. How do we want to see. I want to congratulate proposal 7212 to be considered for inclusion being CFI, but it is Rip and we are like, when we talk about upgrade, we talk about EIp. So there are some, some details which we may want to iron out. I'll be happy to hear the venue where we can perhaps discuss it with the roll up teams.
01:33:39.860 - 01:34:10.374, Speaker A: Generally for eips. We discuss it in EIp Ip meeting. But is it something that we should be joining? Rip calls? Yeah, I don't know that we have a great answer right now beyond like ACD and rip calls. Yeah. But yeah, I guess we can discuss this async more. Anskar. Yeah, I just want to briefly respond to what Peter said.
01:34:10.374 - 01:34:57.822, Speaker A: And I just want to say because, because I think the impression has always been that Beetus can just experiment and go more wild. I think in practice, what we've seen is that most of them decided to not do this, or even, or at least maybe started doing this. And then over time mostly stop. So now they are really following mostly layer one specs. And I think at least given that, you know, like the roll up centric roadmap or something where we kind of all decided this is the best way for the ethereum ecosystem to go, I think we at least o L2, clear communication about, clear guidance and communication about like the best path forward here. Like, I don't think we necessarily have to be willing to, say, constrain our own decision set or anything. It's more about clearly saying, hey, if you want to, over time, deviate from their one features, these are the ways in which you can do it.
01:34:57.822 - 01:35:38.608, Speaker A: These are the ways that you won't be able to do it. For example, maybe it means you'll have to completely fork away and you have to run to write your own client, maintain your own client. You have to maintain your own basically virtual machine and everything. I just feel like in the past this has not been very relevant because L2 s have been mostly focused on just getting the basic roll up stuff ready, like the fault proofs, and basically just learning how to walk. But now that L2s are mature, they are starting to be more ambitious beyond the constraints of layer one in terms of throughput, in terms of additional features. So these topics, these questions become more urgent. And I do think basically we owe them some guidance.
01:35:38.608 - 01:36:13.194, Speaker A: So I don't have any specific proposals or anything. I just think it's important that we have these conversations and that we figure out a path forward. And just saying they could just keep experimenting. This is not the right approach because right now they're basically not able to experiment because they don't see a way to do it. So I think at least giving Nick, making it clear from our side what the scope would be or what the design space would be for them to operate in, I think is very important. Thank you. Okay, I think we can wrap up here.
01:36:13.194 - 01:36:41.464, Speaker A: Yeah, there's a lot of threads to follow up on async. Yeah. Already a bit over time. Any final comments or things people think we should address? Okay, sweet. Well, yeah, thanks, everyone. Yeah, I'll post a recap about all this on the R and D discord. And there's already a poll up for the time for the account abstraction 3074 breakout room.
01:36:41.464 - 02:05:18.284, Speaker A: Yeah, talk to you all soon. Thank you. Thanks. Sa sa sa sa.
