00:00:11.690 - 00:01:11.166, Speaker A: We're talking about now is the, is the Ethereum light client protocol. So, just to give an introduction to why clients are needed, I guess the important thing here is that we are dealing with distributed consensus, and we're dealing with a system where every full node has to process every single transaction. So right now with something like bitcoin, it's relatively fine. One transaction a second, anyone can do it. Although you do need to download about 20gb of stuff of stuff by now, which is a problem now with something like Ethereum. In some ways our protocol is more efficient, in some ways it's less efficient because we have to store a bunch more stuff. But if usage gets to any significant point, if you imagine we have something like 1000 transactions a second, then the amount of resources that it will take to run a full node on the network is 100 to 200 megabytes per hour just processing transactions, assuming 10% of those transactions increase the state, which is about accurate.
00:01:11.166 - 00:01:23.800, Speaker A: For bitcoin, that's a gigabyte of hard disk space every two or four days. Thousand gas a transaction, that's a million gas a second. I believe that's pretty much 100% about what go Ethereum can do right now, if not more.
00:01:24.570 - 00:01:28.460, Speaker B: Yeah, we will have just in time compilation at that point.
00:01:28.990 - 00:01:29.740, Speaker A: Sure.
00:01:33.950 - 00:02:32.140, Speaker B: So ultimately, it's kind of important that for decentralized applications, we have a strategy for using these things on mobile devices. The general idea is to replace so many massively multi user applications, the things we tend to use the web for, that these devices are going to be super important for actually providing people with what they want. So we have two problems. The first is, given that a light client knows very little about the blockchain, because it stores very little, probably only their headers. How does it find out about events that are going on in the blockchain that the decentralized application might be interested in? The second is, assuming that it now knows about these events. Perhaps it's a transaction, perhaps it's a particular execution and a particular contract. How does it be certain that this information is actually true?
00:02:32.770 - 00:03:25.850, Speaker A: So, just to give an introduction to the fundamental theory behind white clients, everything is based on this wonderful construction invented by Ralph Merkel in the 1970s. Merkel trees. So the idea behind a Merkel tree is you arrange data in a kind of tree structure where you have all the little nodes, keys and values at the bottom, and then you take a few nodes to make a hash of them, and then that's the next level, and then you take a few hashes and make a hash of those, and it all sort of bubbles up until you have a single root hash at the top. And you can think of the root hash as kind of representing the entire tree. So there's no way to change anything whatsoever about the tree without creating changes that eventually propagate up the tree and ultimately lead to a change in the root. So if the root is inside the header, then once you've validated the header, you've sort of implicitly validated the entire tree. So ideally with my clients is you only download the block header chain by default.
00:03:25.850 - 00:04:25.094, Speaker A: And if you need data, then you just fetch whatever data you want. And once you have that specific set of data, you can just validate it by just making sure that the hashes match all the way up. So basic idea is that you can think of a proof of something as being the subset of tree nodes that are involved in accessing or processing it. So if you want a proof that some particular account has some particular state, then you take the nodes in the tree that you need to sort of go all the way down to that particular thing. And that set of nodes basically is the proof. So the way you create a proof is literally this is how it's actually implemented in the python client. Right now, if you want to prove some particular part of an account, you just grab it, but you record all the tree nodes that you accessed.
00:04:25.094 - 00:05:12.682, Speaker A: And the way you verify the proof is that you just run the same standard algorithm, but using the proof as your database. So the nice thing is that with the way the protocol is designed, you say a lot of this stuff you just sort of get automatically, because everything is based on these reverse hash lookups. And if you assume that the hashes that you need actually already exist, then you could just reuse the exact same code. And it's just a matter of which hashes do you need or which little nodes do you need to download to make sure you have everything. So in ethereum we have three merkel trees, we have a state tree. State tree records, account balances, storage, a little merkel tree for each account code in 1.1, maybe we'll consider events.
00:05:12.682 - 00:06:18.870, Speaker A: So a way for contracts to sort of do events and events that only get propagated processed in the future, and then those events have to be stored in the state or in the meantime, transaction tree just stores all the transactions in a block. So the receipt tree, that's pretty important, and we'll talk more about that later. But the idea is that it sort of stores specific results that are related to processing each individual transaction. So what do we care about proven? Or what do we care about light nodes being able to securely access account balance, account nons, account code, account storage data, whether or not a transaction has been included. So one thing I know, I was asked a couple of days ago is how does a node even, or how does the Javascript even know that a particular transaction was processed so they can start sending off another transaction. And this is something that the log client should be able to figure out from the blockchain. Also, potentially, if your log client wants to start actually probabilistically validating that a block was produced correctly, they can do that.
00:06:18.870 - 00:07:00.078, Speaker A: And finally, a thing that Gav will probably talk more about, which is logs. So account data, we already talked about that, prove existence. So if you want to fetch account data, you just sort of prove an existence of a node in the tree. So transaction state transition, what it is, is the more complicated thing. But basically if you want to prove that a particular transaction was processed or correctly, then you take some of this data from the receipt tree. So the receipt tree contains an intermediate state route. After processing every transaction, take the intermediate state route, you take the transaction and you make sure that if you just run the transaction on top of the previous intermediate state route, you get back the new intermediate state route.
00:07:00.078 - 00:07:18.540, Speaker A: And why is this stuff necessary? Basically? So one reason is that if you want a somewhat stronger assurance that things are being done correctly, and if you don't necessarily trust the majority hash power, once proof of stake comes along, and you can't just rely on difficulty as a sort of proxy for security, might become even more important.
00:07:18.990 - 00:08:57.314, Speaker B: And finally, Alex, so one of the things that we want to provide with DAPPs is the ability to effectively not think about the blockchain, not have to think necessarily about transactions, and not have to think particularly about state, the idea is to provide an abstraction mechanism for the blockchain for what the blockchain provides. And this abstraction mechanism that the sort of interface it provides becomes something that we're a bit more familiar with, the notion of the sort of virtual machine, as the virtual machine executes, it's useful because it's not in an environment that you have direct access to, you have to do it in terms of transactions. It's useful to be able to put things like checkpoints in to see if a particular contract that you're interested in is a particular point in its execution. Such a point, for example, might be that it has received a payment, that a payment has been sent from one of your accounts, or that one of the orders that you might have put on an exchange, for instance, has actually executed. So this is kind of like the I o, more the o from the blockchain and the I into the rest of the DAP, but the I O between blockchain and the DAP as a whole, the Javascript portion that's actually executing locally in the browser. Now originally we had this idea of messages, so like transactions, messages are things that can actually go and execute contracts, but messages can also be the things that messages execute. Transactions, of course, always come from an external entity and they're cryptographically signed.
00:08:57.314 - 00:09:41.958, Speaker B: And we have the idea of message tracking. So message watching, whereby the Javascript, the local portion of the DAP, could watch out for changes on the blockchain that involved a particular message, and it might also have filtered it by what the input to the message was. Now this turned out to be less than ideal, and so we sort of evolved this notion of a log. Now the log is like a breakpoint or a record. It allows a message, a contract, to point out to an interface that a particular thing has happened. Logs can include a topic or many topics, and these sort of identify the type of entry. Logs also implicitly include the address of the contract that created the log.
00:09:41.958 - 00:10:39.430, Speaker B: And finally, logs can also include data, just arbitrary, unformatted binary data. And of course this data can mean whatever the contract wants it to mean. The difference between the topics and the data is that the topics are indexed, so topics can be watched out for by the Javascript front end by the rest of the DAP. The reason that we have logs at all is so that we can very efficiently index them and filter them when dapps require that. Now, because the light client is an important part of the eventual protocol, it's important to get this interface in now so we can work out exactly how light clients will be able to work out efficiently whether any of these log entries on the blockchain have actually fired, whether they're there, whether new records have come along that we're interested in. And the way that we do this, as Vitalik mentioned before, is transaction receipts.
00:10:41.710 - 00:11:24.680, Speaker A: So first of all, just to describe how logs are implemented, there is an opcode. And this sort of bitcoiny term for what the log opcode does is proof of publication. So it just proves that something, it sort of publishes an event in the blockchain by just connecting it with a hash tree to a state, to a rooted block header. Log opcode has up to six arguments, so first of all, it has two arguments to grab a slice of memory that it keeps as data. Then a log can have up to four topics. And implicitly, a log always has a sort of argument. The address of the contract that created the log and the data structure that'll have a log is stored is this RLP address topics and data.
00:11:24.680 - 00:11:59.074, Speaker A: So receipts. So how the transaction receipt looks is that the med state is like the state root after processing that particular transaction gas used is a counter of how much gas was used after processing the transaction. Bloom filter. We'll talk about that a bit later. And logs. So that's just the encoded RLP list of each log, where each log is encoded like this. And in the block header, we have the end state to match the intermediate states gas used at the end.
00:11:59.074 - 00:12:28.966, Speaker A: And we have a sort of block wide bloom filter. So each bloom filter is 64 bytes. So the way bloom filters work, just if you're not clear, it's a sort of mechanism where you can put keys into the bloom filter. And the bloom filter is this really compact structure where you can then check other values again. Once you've put a subset of keys into the bloom filter, you can check some new value against the bloom filter. And the bloom filter either returns. No, this key is definitely not in the bloom filter.
00:12:28.966 - 00:13:16.746, Speaker A: Or maybe this key maybe is in the bloom filter. And the reason why it's maybe is because it's a sort of lots of compression where all the keys are, in a sense, hashed and packed together, so you're losing some data. So the point is that the way the protocol works is you search the blockchain for bloom filters that are matching some particular topic that you're sort of watching for. If you find the block that matches what you want, you check every transaction. You see which transaction, or which transactions have a bloom filter that matches that particular topics. And then once you find transactions, you would actually ask for the mergal proof going down to the logs, which would tell you whether or not logs are actually there, and if logs were there, what the actual content of the logs is.
00:13:16.848 - 00:13:48.594, Speaker B: So the minor thing that has been missed from this particular list is that we can search the header for blooms that tell us that a particular block may contain a transaction that has a log that we're interested in. Following that, we can actually request the transaction receipt block and search in that block for the bloom filters. So the blooms are also, for each transaction, actually put in that block before we actually go ahead and search for the log entries themselves. So it's a little more efficient before, well, search block.
00:13:48.642 - 00:14:10.822, Speaker A: Search for search blockchain for blocks, search block for transaction. Search transaction. Well, I guess one oxycler, but oh well. So basic roadmap is that the client that we're going to have for 1.0 is archive node. Simplest thing to implement that stores everything. Then after that what he wants to get into is he wants to move from archive node to what we're calling full node.
00:14:10.822 - 00:14:54.810, Speaker A: So full nodes store the entire state, but they only store recent history. So you can imagine they store the state roots going back maybe a week, and then they just store some more block headers going back maybe a month or two, and they store transactions going back that far as well. And then if they want to grab ancient history, then they would just maintain some block headers. And basically they would use the light node protocol to ask for ancient history. And so full nodes are actually much closer to light nodes than the earth archive nodes in some sense. And then light nodes will just download blockheaders by default. We are expecting it will take quite a while for the full, sort of like client technology to get rolled out just because it involves a whole bunch of these various prerequisites.
00:14:56.830 - 00:14:57.580, Speaker B: Yeah.
00:14:58.750 - 00:15:01.450, Speaker A: So how does this work from a networking standpoint?
00:15:05.330 - 00:16:16.766, Speaker B: What's important is that when a light client wants to operate, it does not have to request a proof, which are necessarily things that are customized for the requester from some of the node. If that were the case, then effectively light clients would be literally clients and the nodes that they come from, the archived nodes, or maybe the full nodes would be servers. And that's not an especially nice way of doing it. It sort of reduces the decentrality of the network as an alternative to the ask for the proof mechanism, which may still be necessary for some particular things, depending on whether the state tree is well distributed and well stored by the network, is to store the various portions of things like headers, blocks and transaction receipts on the DHT itself. So these are naturally things that are identified by the hash. They're actually identified by probably the same hash within the blockchain itself. And the idea is that light clients themselves are a contributor to this DHT.
00:16:16.766 - 00:16:40.330, Speaker B: So they do their own bid in terms of storing maybe some transaction receipts, some blocks and some headers that they can obviously, should the chance happen that they need it, they can use themselves, but that they can, in a bittorrent like tip for tap fashion exchange with other light clients in order to provide information across the network without having this reliance upon archive or maybe full nodes.
00:16:42.130 - 00:17:34.378, Speaker A: The idea is that once again it actually sort of works nicely from an implementation standpoint, is that all you're doing is that instead of grabbing nodes from a database, you're just grabbing nodes from this DHT. So you can think of it as like using the Internet as a sort of extra hard drive. And this can be used for reading the state, it can be used for processing watches, potentially for ballistic validation. So as far as what we want to have is we want to store everything that light nodes are going to be storing by themselves in this kind of specialized DHD. We don't necessarily want to mix it with swarm just because it's better to have, first of all, it's better to have the different protocols be separate. I think people should be able to use Ethereum even if they don't care about whisper and swarm. They should be able to use swarm if they don't care about whisper and so forth.
00:17:34.378 - 00:18:29.646, Speaker A: And there's a possibility of making a sort of tit for tat protocol where light nodes can sort of ask each other, give each other proofs. And that helps incentivize nodes to actually store things so long term, like clients and proof of stake, there are potential tricks that it's obviously going to have more info load than proof of work, because with proof of stake, you actually need to validate that people have stake. There's this option of sort of artificially discretizing the protocol. So you would have these sort of checkpoints that are far away from each other and each checkpoint. And the idea is that each checkpoint would be signed by a very large number of nodes, and then you would see that, hey, this very, very large set of signers has validated this next checkpoint, and then you sort of go from there. Proof provision not incentivized. I mean, sit for tad protocol sort of does it.
00:18:29.646 - 00:18:44.270, Speaker A: Putting it on a DHD sort of solves the problem. Is there some better solution? Will we need to have some better solution? Hard to say. Like clients in Ethereum 2.0 depends entirely on what Ethereum 2.0 is going to look like. Anything else you want to add?
00:18:44.340 - 00:18:45.142, Speaker B: No, that's about.
00:18:45.236 - 00:18:46.980, Speaker A: All right, any questions?
