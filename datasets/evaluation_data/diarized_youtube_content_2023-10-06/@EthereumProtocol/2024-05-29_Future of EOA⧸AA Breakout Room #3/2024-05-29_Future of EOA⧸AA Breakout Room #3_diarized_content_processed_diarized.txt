00:00:03.920 - 00:01:00.090, Speaker A: Hey, good morning, everyone. Welcome to our third aa breakout. We've had a bunch happen since the last one, and hopefully we can take the time today to figure out how to move forward on the spec. So the two main things basically, I think is worth like an upgrade on is one the pr that was made to 7702 based on some conversation between l one client teams. And then there was a workshop in Berlin last week. And yeah, I think Ansgar has a quick recap of that. And then out of those things, I think there's still a couple of questions on the spec, which is will naturally discuss, and hopefully we can get to some next steps based on all of this.
00:01:00.090 - 00:01:09.774, Speaker A: But I guess maybe to kick us off light clients, do you want to give just a bit of context on your pr and how that sort of led to the discussions in Berlin?
00:01:14.034 - 00:02:12.154, Speaker B: Sure. Yeah. The PR has kind of accumulated over the past few weeks of many different conversations with some different stakeholders. First, we talked with some l one client teams at the interop to sort of gauge what types of restrictions they felt were going to be necessary. And that sort of led to a lot of the restrictions from the original proposal, adding the optional chain id, adding the optional nonce into the signature scheme. And then in Berlin, we sort of talked about these restrictions again with some of the present wallet developers, and it seemed like there was general agreement that the restrictions in place make sense. And we talked about some of the other open questions, and it felt like the two things, two good takeaways and Ansgar can confirm.
00:02:12.154 - 00:03:21.594, Speaker B: But two takeaways from the meeting in Berlin was that we probably would not have a flag to persist to the code because we have open questions still on actual EOA migration. And the second big takeaway was we need to do more research into allowing storage for the EOAS. Obviously, it's something that people would like to see, and it allows for us to use the smart contract wallet implementations mostly out of the box as they are today. But there are a handful of issues. The two notable ones are storage, key collisions between wall implementations. So concerns with the application layer, and then there's some protocol concerns. We recently added a retroactive EIP, which was 7610, and that sort of disallows this behavior of having an account in the state tri that's empty other than its storage.
00:03:21.594 - 00:03:28.674, Speaker B: So those are two areas we're continuing to look into. I'm happy to discuss further later in this call.
00:03:30.174 - 00:03:35.714, Speaker A: Thank you. And, yeah. Andra, do you want to give a quick recap of your Berlin notes?
00:03:38.294 - 00:04:29.094, Speaker C: Yeah, sure. So basically in Berlin, we also just talked about all the different dimensions of the open questions around the AP. We basically came down on exactly the version of this open pr of mats. Of course, not all of those are necessarily have full agreement by people yet, but at least in terms of majority support. So that was specifically. So on the one hand, the question was, how do you specify the target of the code that runs in your account? And so the idea for now is that you specify the address, not the code. You also sign off the address, not the code, and you don't run in a code, as Matt was saying, repo protection chain id, none is optional for now.
00:04:29.094 - 00:05:21.788, Speaker C: No storage restrictions. And we decided that for now, we would not feel comfortable launching with something that looks like a permanent upgrade, like right from the beginning. I mean, obviously the detail to be figured out is whether we already have this kind of, like, in the transaction, and we just for now, enforce it to not be set so that it's easier to upgrade in the future. We don't need a new transaction type, a new signature type. But that's the detailed question. So basically, the idea would at least not allow for direct and permanent upgrading yet. And then other than the storage pattern, which indeed, as Matt was saying, is like a big open question, I think the one other thing that did come out of this meeting was that we realized that it would be really important to start also working on the, like some sort of wallet guidance document.
00:05:21.788 - 00:05:33.044, Speaker C: Because I think that even, just like, we had someone from ledger there, for example, and even just talking about, like, in practice, how would this be? So should this be supported by Ledger, for example?
00:05:33.084 - 00:05:33.236, Speaker A: Right.
00:05:33.260 - 00:05:52.774, Speaker C: Like, that clarified a lot of questions and concerns. And so learning from 50 59, where I think we kind of under specified how wallets should behave with this new functionality, I think it would be really good to kind of start outlining very clear rules of, like, what, how wallets are supposed to interact with this. Yeah, I think that that's kind of the summary.
00:05:55.674 - 00:06:33.274, Speaker A: Okay, thank you. Anyone else have anything to add? I know there were a bunch of other people that burden meetup. Okay, so I guess in that case, yeah, it might make sense to just go through basically the two. Yeah, maybe. Yeah, going through, like, the different open questions. So, like, on the replay protection, it does seem like we're set on the restrictions. Storage still feels like the biggest question.
00:06:33.274 - 00:06:45.694, Speaker A: So I guess, yeah, maybe let's open the floor to this. How do people feel about storage? Joav, you have a comment?
00:06:46.474 - 00:07:28.444, Speaker D: Yeah, I just finished writing about it. So regarding storage, the discussion was whether there's a way to make it safe so that we don't have to ban a store. And we agree that if we had a standout that prevents collisions, if a standout where each implementation uses its own storage base, instead of starting from zero, it could be made safe. The problem was that it's hard and required assembly code. And that's something that I've been asking the solidity team for a long time. So the update is just that. I just got off a call with, just a weekly call with the solidity team.
00:07:28.444 - 00:07:56.374, Speaker D: They understand the issue and they made it a priority to. To find a way, to find a way for contracts to control their storage layout before. And they understand that it has to happen before Prague 47702. So we should get them feedback, we should work with them now to agree on what it should look like in solidity, but I think it will enable Esto in the EOA.
00:08:00.654 - 00:08:08.558, Speaker A: Thanks. Anyone else? Yeah, Anzor.
00:08:08.606 - 00:08:09.194, Speaker E: So.
00:08:11.494 - 00:08:13.846, Speaker A: Does the Oscar. Yeah.
00:08:13.870 - 00:08:59.704, Speaker C: Just very briefly say that, like, part of the design philosophy behind 7702 was to try to be as compatible with the existing 437 smart account ecosystem as possible. And so to the extent that storage collisions are a concern that is already present in that world, I think the idea would be to just try to avoid ending up with two separate tech stacks, and so to leave it up to that ecosystem to figure that out, like, with approaches like the one just presented by Johan. Of course, to the extent that concerns are beyond this equivalence point, they are still valid and we might have to address them. But basically, if it's just the concern around storage collisions, I think will really be best to try to leave it up to the 437 ecosystem.
00:09:03.724 - 00:10:25.184, Speaker E: Yeah, so from my end. So we have been discussing last couple of days this, this topic quite, quite heavily in geth, and from what I heard also from Matt, this seems to be the general consensus that it is usually kind of unsafe for users to sign, like, any kind of, like, conflicting authorizations for code that could run within their EOA. So it's only really ever going to be safe to sign, like, a specific and very well audited proxy. And so it feels like maybe we should just only allow, like, that one proxy, and that would also kind of remove the possibility to have storage conflicts for the time being. And we can worry about storage conflicts later when we actually do allow more than one specific proxy to run within the context of the account. And I think that would also allow way more time, for example, the contract development ecosystem, to migrate to these ideas of, like, declaring the storage slots, because it's kind of a topic that's very new now. So yeah, just maybe something to consider.
00:10:26.524 - 00:10:29.504, Speaker A: Thanks, Conrad.
00:10:31.404 - 00:11:17.164, Speaker F: Following up from what Anska was saying, so we, I can send the PR kind of context afterwards, but we have a modular account which is like a reference implementation. And kind of a few weeks back, we just quickly tried porting over to using an external storage contract, and essentially it took like an hour and already like 50 lines of code have changed to pull that over. So the effort there was pretty minimal. Like, I understand that there could be some security implications in terms of formal verification and stuff like that that we should also consider, but purely in terms of pulling over an existing four, three, seven accounts, to use an external storage contract, in my opinion, and based on this, PR is pretty minimal effort. Yeah.
00:11:19.824 - 00:11:21.444, Speaker A: Thanks, Ahmad.
00:11:25.584 - 00:12:39.244, Speaker G: So I just want to comment about the specifying a proxy implementation and only allowing to sign a single authorization. So like about this, in my opinion, the same problem exists with like, even if the proxy contract, you have only a single proxy contract, the proxy contract still calls delegate call, and when you use storage sales in the smart account implementation or smart wallet implementation, then it would use the same storage sales of the UA. So regardless if you use a single proxy implementation or multiple proxy implementation, the same issue still exists. And this also exists for smart contract accounts. And I don't see why the restriction should, like, any restriction should be applied in this manner. Of course, I do agree that auditing the proxy contract and from the wallets before approving them is something that should be done, but restricting the wallets to a single proxy implementation is not something that I would support.
00:12:44.184 - 00:12:45.044, Speaker A: Felix.
00:12:46.304 - 00:14:29.694, Speaker E: Yeah, I can just quickly react to this and just say that I think it's more like the difference with this proposal of only allowing specific proxy for now is also that, like for example, changing the destination of the proxy, or like migrating to a different wallet type or whatever would involve an on chain action, which is very explicit. And so it would, for example, also allow you to, if you wanted to switch from one kind of wallet type to another wallet type, which can act on your behalf, you could do that by, for example, first, like initially, you would point a proxy to one specific wallet implementation, which would set up its storage slots the way it wants to do it. And then when you want to switch to a different wallet, you'd have to deploy some kind of temporary migration contract that switches the storage around, and then you could go to where it clears it or whatever, and then you could, with another transaction, switch the proxy again to like the new wallet implementation you want to use or things like that. Whereas with this like authorizations approach, it's like you would be free to accidentally, for example, sign multiple conflicting authorizations for different wallets to run within your account. And if you're unlucky, these, since they can be basically, these authorization authorizations could potentially be used by anyone to run code in the context of your account. It means they, it's just like much more risky, basically, I think to allow, because it has this danger of not just like, it's not an explicit on chain action to change, like which code is the designated code to run.
00:14:34.194 - 00:14:36.554, Speaker A: Ahmad, is your hands up again?
00:14:36.674 - 00:15:19.794, Speaker G: Yeah, just one comment about that is I would have the wallet, let's check the storage cells before having them approve a certain implementation. And if they find that these storage cells have value, they can do a transaction that clears them before authorizing the different implementation or something like that. Of course, this is just theoretical. I just don't want to restrict the design space for the wallet implementers. For whatever reason. It does not make sense to restrict the design space just for this reason. That's my.
00:15:20.814 - 00:15:56.774, Speaker D: Yeah, so I also, I also don't think we should restrict the design space if we can standardize storage. But regarding a transaction that clears the storage, that wouldn't be practical for wallets because they would need to trace since especially with vehicle you have no way to enumerate the storage. So you would have to go through all the transactions and not just for this eOa, but every transaction because it can be a different eoa using 7702 to change storage lots. So you would need to trace every transaction that ever touched this eoa and trace the storage loss that were written.
00:15:57.114 - 00:16:10.394, Speaker G: No. So you don't need to clear all storage. You need to only clear the storage that your specific implementation uses. So like in that way with mapping.
00:16:10.434 - 00:16:30.924, Speaker D: It becomes impossible because it's catch up with something. So for example, it could be a signal, like in the, in the case that I like to point out with safe. So safe has a mapping of owners and if you have one written in some high slot, you don't know whether it's a shadow or whether it's going to end up an additional owner in your account.
00:16:31.624 - 00:16:34.484, Speaker G: Yep, yep, yep, yep. You're right, you're right.
00:16:47.524 - 00:17:40.406, Speaker A: Okay. I'm not quite sure where we've landed here is. Yeah, I guess. Yeah, sorry, I'm trying to think through like do we think it makes sense to remove the store capability and. Yeah, yeah, I guess so. One way to think about this as well is if we think there's a risk around allowing it. This is slightly more work on the protocol side, but we could also fit the EIP with the storage like estor not enabled, and then potentially in the future hard fork activate it.
00:17:40.406 - 00:17:44.954, Speaker A: One risk around this is just in the meantime the ecosystem sort of develops around this.
00:17:45.534 - 00:18:17.194, Speaker G: Yeah, aman so I would not prevent a store, instead I would allow a store and then at the end of the transaction clear the storage slots that were written. The reason is to keep compatibility as high as possible for all the smart contracts that are using S load s store, possibly even for counters or something like that. And then like, yeah, so I would not prevent the whole opcode, and so.
00:18:17.234 - 00:18:20.494, Speaker A: Basically s store would act kind of like t store does.
00:18:21.594 - 00:18:22.374, Speaker G: Yes.
00:18:22.914 - 00:18:23.586, Speaker A: Okay.
00:18:23.690 - 00:19:09.688, Speaker D: Yeah, so let's, I mean, I don't think we should, it seems that we shouldn't ban the opcode, but I definitely wouldn't want to make it behave like this store, because the developer of the contract was not aware that this storage actually becomes ephemeral. And it could have interesting unintended consequences where parts of the transaction modify the storage in other contracts, and part of them didn't. For example, suppose you are setting the threshold for your safe implementation, but now the threshold goes back or you change signs. So if it's distall, let's just use this store and ban a store. But I don't think we should change.
00:19:09.736 - 00:19:12.764, Speaker A: Yeah, change the semantics. Got it. Asgard.
00:19:15.384 - 00:20:21.394, Speaker C: Yeah, I just wanted to say that, yeah, not on this temporary point, but if we basically were to decide to ban storage, I think we have to, to understand that this will likely set the standard around how these systems work, including existing smart accounts. So that I think that will push the ecosystem to external storage contract patterns, and that will be a very sticky default, given that before we can unblock storage, a big portion of UA's would already start using this. And then a migration of a contract that already does use an external storage is kind of infeasible because you'd have to copy over all the distinct storage, which is super expensive. So we really basically set long lasting defaults here. And I mean, I personally think that there might be even a world where external storage contracts might be the safest pattern also for normal smart accounts, because then you never have to think about conflicting storage access. But of course it's more expensive. So I think either way, it would be really important that whatever choice we make, the smart account ecosystem feels confident that it is the right long term solution.
00:20:21.394 - 00:20:24.574, Speaker C: Otherwise, I think we're just really in a bad place.
00:20:26.714 - 00:20:35.122, Speaker A: Got it. You up? No, no, I guess.
00:20:35.218 - 00:20:38.974, Speaker D: No, it's. I left it, I left my hand raised simply. Sorry.
00:20:39.354 - 00:21:28.310, Speaker A: Got it. Ankur. Yeah, so this is just something which I kind of thought on the flight. Please let me know if this doesn't make sense, but what if we allow the user to specify additional contract, which let's say we call the storage contract while signing. So assuming that we sign the address or the code, apart from that, we allow the user to also specify a storage contract address at the time of signature. And what would happen in the transaction is that whatever s stores or s loads are being done, it happens in this particular storage contract, and if the user, for whatever reason, wants to switch to another implementation, they just produce a new signature and invalidate the last one. So this could potentially allow different implementations to use different storage slots while the contract code doesn't really change.
00:21:28.310 - 00:21:43.134, Speaker A: And if you really just want to switch to another implementation, you also just like do a switch to another storage contract as well. Interesting. Um, yeah, I let you draw, and then if anyone has thoughts on this.
00:21:45.834 - 00:22:54.264, Speaker H: I I'm not sure about this external storage. What I'm saying about using storage in account, it is not how much it affect the smart accounts, because smart accounts do use their own storage. The question that I don't think we ask enough is how much it changes the implementation for existing EOAS. Consider all the EOA accounts that never intended to use these new features, but through an upgrade to their wallet, now have some feature, a very strong one imposed on them, that allows changing storage, changing behavior. I'm not sure. I think this is where the storage recognition came from, how it will alter existing eras, not how it will help for those who opt in for that. Because for an sea you opt in, you sign for an account, and you know that it works like a contract, or at least your wallet knows.
00:22:58.184 - 00:23:14.364, Speaker A: Thanks. Okay, so yeah, and yeah, there's a column Bileskar saying that the storage contract defined in the transaction would be forward compatible. Anran, did you want to comment on this?
00:23:15.464 - 00:24:22.824, Speaker F: Yeah, this is actually kind of related to the comment just now, but kind of generally, for me, the biggest problem with just allowing a store right now in 7702 is potentially blocking the way towards permanent migration, even if that's not included in 7702 right now. I think most people would agree that eventually the goal would be to upgrade existing eras to smart accounts. But one problem is if you can in 7702 now set storage, even if most accounts adhere to some namespace storage, if you just use a single account that doesn't set, for example, storage one or something like that. Then in the future, if you want to permanently upgrade, it might become unsafe to use your EOA because it already has storage. There might be unexpected behavior if you upgrade to a specific contract. Obviously there are best practices we can do around this, but I guess my fear is that we, I guess I missed something right now and that kind of blocks the permanent upgrade path for UA's in the future.
00:24:28.484 - 00:25:06.654, Speaker A: Got it. Okay. And then Yoav says he held the same opinion. He agreed to add namespace storage. And then I kind says that allowing storage isn't going to block migration. Um, I guess, yeah, it, it sounds clear to me how we make the call on this at this point. Like, it does seem like, um.
00:25:06.654 - 00:25:26.234, Speaker A: Yeah, if like, solidity allows us to deal with the name space storage issue. Yeah. And I guess, yeah, maybe like client. Do you want to explain how you think, like, even if we have storage, we can, we can do my migrations?
00:25:29.494 - 00:26:20.844, Speaker B: Yeah. I mean, I just don't see these as problems that are specific to 7702. We're talking about the same thing in circles. But this is simply a problem that we have today with smart accounts, and we have to come up with a solution, solidity, if they are able to support a better storage mapping scheme, this is the right step in that solution. There are other possible solutions that have been discussed, like having some sort of external storage account. But you know, at the end of the day, like, if it's okay at the protocol level, then I think it's something that we can do. Nice.
00:26:20.844 - 00:26:37.494, Speaker B: This is just my opinion. I know that some client teams, other client teams, other client developers feel a bit differently, but I see allowing storage today going to impact our ability to do an EOMp migration in the future.
00:26:44.314 - 00:27:23.874, Speaker A: Okay, so I guess, yeah. Does anyone feel strongly we shouldn't move forward with no storage restrictions for now so that we can actually get started on the implementations and then potentially continue discussing the issue offline? It does feel like there's probably like, yeah, on the wallet side, this is probably not going to get resolved in the next five minutes of conversation. So if we're going to sidestep solving the storage issue for now, do we have to decide the mechanism for clearing it.
00:27:28.084 - 00:27:30.984, Speaker B: In protocol or by the application.
00:27:33.684 - 00:27:34.864, Speaker A: In protocol?
00:27:35.844 - 00:27:40.544, Speaker E: It's only really possible in protocol. Yeah, but even then with Virko is not possible.
00:27:41.444 - 00:27:43.704, Speaker B: Why would we clear in protocol.
00:27:45.404 - 00:27:45.716, Speaker C: Or.
00:27:45.740 - 00:27:47.264, Speaker B: What would the mechanism be?
00:27:48.364 - 00:28:05.794, Speaker A: So, yeah. So to elaborate on Anscar's question, I'm looking at two different approaches. One where we no op s store ops that we encounter while processing this transaction, as opposed to allowing and then re clearing it at the end of the transaction.
00:28:07.414 - 00:28:18.494, Speaker B: I'm not talking about either of those, I'm just talking about allowing SDOr to work as it would work under a regular contract account. So updating the storage, try.
00:28:23.674 - 00:28:50.834, Speaker A: Okay, so again, the question by Sachin, if we allow storage in the OA, will this result in storage conflict when the OA uses different implementations with different transactions?
00:28:56.374 - 00:29:13.754, Speaker B: Yeah, I mean, this is again the same thing that we've been discussing, but it's also equivalent to the problem that we have today where if you're using nosis safe and then you switch to another smart contract wallet, you have a conflict, a potential conflict of storage elements.
00:29:20.574 - 00:29:40.934, Speaker A: Okay, so that's, yeah, let's move forward with storage for now and again. Yeah, keep discussing async and then like that, you have the proxy pattern. Is this basically, this is independent of storage, right? Like even if.
00:29:41.394 - 00:31:00.992, Speaker B: Yeah, I wouldn't say it's perfectly independent of storage because I think there is a distinction between the problem of allowing multiple implementations of code interacting with the storage of the same account. In 7702, it's possible to, like Felix said, delegate to code off chain. And this is something that, it's kind of possible you could create a system that allows you to do this off chain delegation thing in a smart contract world, but no one does it because it's very roundabout and feels weird. But under 7702 it's a lot more natural to have your seed phrase in multiple EOA wallets and have them have their own proxies or their own wallet implementations that they sign over. And so I think that in the 7702 cases, it's more likely that we will end up in a situation where the user has signed or the user has delegated to multiple pieces of code interacting with the storage. Whereas for smart contract calls today it's a bit less likely because we don't, we don't have this off chain delegation mechanism. Typically you change the proxy target in your account.
00:31:00.992 - 00:31:48.240, Speaker B: This is a very clear process. This is something you're interacting with on chain and you have to send a transaction. So that leads into this proxy discussion. There are numerous things to discuss about it, but one way to bring 7702 in line with how EOA wallets are. Sorry? Yeah, bring 7702 in line with how the smart contract wallets are working with delegation is to have one proxy contract that is allowed in protocol. And I think that Felix was the first to propose this. But suppose in this hypothetical world we come up with a proxy smart contract.
00:31:48.240 - 00:32:35.006, Speaker B: I've come up with some sort of example to give you a rough idea of what I would be thinking about. But suppose we have this one proxy contract. It's deployed on chain, and in 7702 we say that you can only delegate to the address of this proxy contract that we have decided upon, and this is future compatible if we want to later allow people to delegate to other pieces of code. But in the beginning we start with this more fixed restriction saying you can only delegate to this proxy code. Now you don't really have the situation that we could have today with 7702 where I have my EoA seed in multiple wallets. Those wallets are using different proxies or different wallet implementations. In this world they would have all signed the exact same 702 message.
00:32:35.006 - 00:33:26.008, Speaker B: And it's really just the on chain storage that affects what code implementation is running. So I think this addresses that, that issue of having off chain delegation with 7702, as well as trying to minimize the number of floating around authorizations that a user might have. You can always look on chain to see what delegate target of the proxy is, and then you can understand what code will be executing in that account. So that's just the idea. I think Anskar is saying he doesn't like the one the enshrined in protocol version. I'm curious what other people think. I'm also generally very hesitant to enshrine a specific smart contract in the protocol, but it is an option.
00:33:26.008 - 00:33:29.884, Speaker B: I do think that it addresses some of the concerns that we have around storage.
00:33:40.724 - 00:33:41.464, Speaker E: Deb.
00:33:43.884 - 00:34:44.504, Speaker A: Hey, yeah, so I was seeing Anzar saying he doesn't like one proxy contract because you'd rather let wallets keep the whitelisting on that. And I've been a big proponent of trust the wallets to be safe, but I think that this could actually be a bit of a foot gun, because a user could have srps in multiple wallet implementations. They might not be aware of 7702 signatures that other wallets had signed, and so you could have conflicting 7702 messages floating around which would expose that user to this kind of bundler griefing attack that we're talking about. There'd be very little a wallet developer could do about it. So this isn't ensuring that wallets are making safe decisions. This is about making sure that it's even possible to have safety for the user and the user ops they assign. There's a question, what's an srps? Oh my gosh secret recovery phrase.
00:34:44.504 - 00:35:05.104, Speaker A: We started adopting it instead of seed phrase because seed phrase was not communicating. The need to hide and keep secrets. The private keys to normal users is a user research thing. Obviously. I don't mean to use that term in this group, but it is a force of habit. Thanks, Asgard.
00:35:06.564 - 00:36:09.054, Speaker C: Yeah, I would just say I'm open to this idea of this kind of client proxy, but I think if we actually lean this way, then there's at least a case to be made to look into a bit more. Whether we can just more fundamentally change 7702 to basically account for this, because it seems overkill to have this general purpose delegation mechanism and then restrict it to a single delegation target. I mean, of course, if we very clearly expect in the future to completely remove this restriction, that would be different thing. But to me it's not obvious that we would, it seems like we would probably stick with this forever, and then at that point it might be better to just directly have that behavior enshrined at a more fundamental level at the EAP with the only counter argument that I can see is that this way, basically it kind of maybe most closely matches the pattern of existing smart accounts, but it still seems like because also, for example, there's extra cost involved because now you have to first load that proxy, contract anew in every transaction, and then you have to basically load the target. So it makes everything more expensive as well.
00:36:12.514 - 00:38:06.044, Speaker B: Yeah, I think maybe zooming out a little bit to understand why is this even proposed? What exactly is the solving like, what is the fundamental problem that we're trying to address with the enshrined proxy proposal? And to me it's about putting on chain in a standardized way what code is executing in the context of the account. And so if we think about it more from this direction, we can think what is the right, what are the other, what are alternatives? What would the right way to do this would be because we're sort of constrained in many ways with what we can do in the protocol today. And that's especially true when it comes to modifying the account structure in the state. Try, because I think the right way, a better way to do this would to have the auth tuple update a field in the user's account that could say this contract has delegated to this code and it would only hydrate the code in that account in certain scenarios like 7702 transaction. And that way if you have your seed, your SRP in multiple different wallets, that wallet can see on chain that you've already delegated to some different code and it will minimize the chances of you having many of these signed delegate messages. There would need to be some replay protection in there so that you can't just keep updating the code you delegated to. But I think that that's the nice thing and we've sort of circumvented that a bit with this enshrined proxy by instead of having it on chain, what code you're going to execute, we just decide for everybody.
00:38:06.044 - 00:38:32.604, Speaker B: This is the proxy code that your account will execute. So you can't sign multiple 7702 messages from different wallets. You can only sign one and then the target is in the account storage. With that said, I don't know if anyone has other ideas about how we could address the problem of mini wallets with your seed phrase not seeing what you've delegated to.
00:38:35.204 - 00:38:36.104, Speaker A: Andrew.
00:38:37.244 - 00:38:48.704, Speaker I: Yeah, I'm just thinking if we need to extend the account scheme to include this new field authorized code or whatnot, we can do it with Verkle.
00:38:51.564 - 00:38:52.464, Speaker A: How so?
00:38:54.044 - 00:39:11.064, Speaker B: Well, Verkle has a number of storage elements that's loaded with the account header. Right, right. I think that it's going to be much easier to put stuff into those storage slots and give meaning to them. Not storage slots, they're like protocol slots.
00:39:14.764 - 00:39:15.164, Speaker A: Yeah.
00:39:15.204 - 00:39:26.864, Speaker I: So velcro will be a big revamp of everything, so it's probably rather easy to change that bit as well. To add this new feature.
00:39:36.994 - 00:40:44.676, Speaker A: Togard has a question about a partially enshrined contract. I'm not sure what partially enshrined is. A very bare bones implementation, a proxy that's like barely even a proxy, but that still allows like arbitrarily customizable code to be added in and the transaction type. So you would first hit the enshrined contract and then the enshrined contract would just do a handful of safety checks, but then it would call into the EOA's authorized code as defined in the transaction. Just an idea. And there's two ideas by Vitalik. One is having the code at address, plus one being the EOS backup code, and then having 702 temporary flip on the backup code and then add an EOF version for this account.
00:40:44.676 - 00:42:30.464, Speaker A: 7702 code is at address X and both of which are, I guess, bigger design changes vip. Yeah, I don't know. Any thoughts? Comments? Like, it does seem, I guess like there are still like some quite significant design questions to discuss and I guess I'm trying to figure out what's the right way to square this with actually wanting this to ship in an x fork so that users get the benefit from it for, I guess, the wallet folks on the call who aren't as familiar with the L1 development process. Like if we want to actually ship this to the next hard fork, we probably need to get started working on it in the next couple weeks. Yeah, so I guess I'm trying to balance like how much do we want to explore this design space and what's the best way to do that? Is there like a minimal version of this vip we can start working on so that there's at least a chance it gets into the next hard fork and that we don't basically end up with a design when we're ready to start shipping things. I don't know if maybe anyone on the L1 team has an idea for what's the right next step from here to keep this moving forward, but also make sure we get to explore the potential changes to the specific.
00:42:38.674 - 00:43:25.644, Speaker B: I think my very biased thought is to pretty much merge the pr as it is. So that's without the storage restrictions, it's without an enshrined proxy, and it has the optional revocation mechanisms. And we go from there because I think ultimately the client teams are probably going to implement this and have comments and questions. And in general, the wallet teams probably want the most permissive systems possible and the client teams are going to want less permissive systems. So it's just we need to spend some time working on it and seeing what we can, what kind of compromise we can get to.
00:43:27.864 - 00:43:29.524, Speaker A: Okay, Andrew?
00:43:30.544 - 00:44:01.154, Speaker I: Yeah, one, I am in favor of merging BR 8561. Just one small technical comment. We need probably to distinguish between null nonce and zero nonce. And I suggest, well, one way to do it is just to encode known nonce as an empty RLP list. Because. Because zero nonce will be encoded as an empty string. Just a technicality.
00:44:07.454 - 00:45:23.624, Speaker A: Yeah, I assume we can make that change. Okay, so yeah, let's move forward with the print. We can discuss that on awkward devs next week, but it seems extremely likely that teams will just want to implement that and add it to devnet one. And then is it worth basically scheduling another one of these breakouts either two or four weeks from now so that once teams have started working on it, we can potentially. Yeah. Have another deeper conversation and also have all the conversations on like the storage and the potential spec change happen in parallel? Yeah, my sense is like, there'll probably be more to discuss than like, you know, what we can do in like 510 minutes on awkward devs so, yeah, do people feel like two weeks, four weeks from now? Makes sense for breakout? And then Ansgar is asking for weekly. Does anyone want to do weekly? So one.
00:45:23.624 - 00:45:45.340, Speaker A: Okay, yeah, I guess one small challenge with weekly, it's not a huge deal, but there is, like, the roll call at this time every few weeks. But, yeah, I would. Yeah, I guess. Okay, so maybe let's do this. Let's do bi weekly, and then we also have awkward evs for. Yeah, yeah. L1 el teams to, like, discuss this.
00:45:45.340 - 00:46:08.784, Speaker A: So, yeah, let's start with bi weekly and see if we need more. I'll just do this time two weeks from now. So June 12. I think by then, what we can do is figure out the. Yeah, figure out. Oh, sorry. The protocol calendar is wrong.
00:46:08.784 - 00:46:31.890, Speaker A: Okay, so roll call is two weeks from now, but then. Okay. Because there's, like, a lot of spec changes now. Let's do another call before next Thursday's all core devs. So, like, a week from now, see how things go on. All cordevs. And, yeah, take it from there to potentially have, like, another call two weeks or a week after that if there's more changes.
00:46:31.890 - 00:46:51.414, Speaker A: But if people feel like a week from now. Yeah, we'll have more stuff to discuss. If not, we can also do three weeks. So, yeah. Any strong preference?
00:46:54.854 - 00:46:55.326, Speaker C: It's not.
00:46:55.350 - 00:47:24.690, Speaker A: Okay, I'll just pull on the. Okay, next week, then. Bi weekly seems reasonable. Okay, let's do that. Ansgar, we still have, like, ten minutes here, so is there anything else that people wanted to discuss that we didn't get to today? Yeah, Elias? Yes. Yeah, thanks. I had one question that I asked on the.
00:47:24.690 - 00:47:48.742, Speaker A: On the EIP, which was about using ketchak as a way to. I don't know. There was a ketchak magic on the transaction type, and I suggested that using ketchik was detrimental to zkvms. And I was wondering why we need a ketchak in there. Which use of ketch hack do you have in mind? Let me get it. But I think in the transaction, it's.
00:47:48.758 - 00:47:50.554, Speaker B: For computing the sigh hash.
00:47:51.894 - 00:48:21.214, Speaker A: I see. I mean, I feel like that's, like, a broader issue. Right. Because right now, basically, all of the transaction types use catch act for computing the sigh hash. And so if we want to move past that, then it feels like it makes the most sense to do that as part of the broader move toward SSE ing the transaction. The transaction list, but. Okay.
00:48:22.914 - 00:48:24.814, Speaker B: Yeah, I agree with that.
00:48:26.314 - 00:49:16.024, Speaker A: Yeah. I mean, I guess, like, one fair critique would be that, like, if someone wants to pull ahead the SSE features in their like ckvm L2 because that like reduces their vulnerability to catch ecdas. Then they'll have like incompatible 7702 formats. And so 7702 on every chain would not be something that exists. But I mean, I feel like ultimately that sort of thing is inevitable. And like eventually we're going to get to a world where like, if he wants to do things on, quote, every chain, then like, not every chain is even going to be a chain that supports SECP. Aman.
00:49:18.604 - 00:49:52.944, Speaker G: Yeah, my comment here is about something else. I just wanted to propose that the wallet developers gather and agree on an arc format for the proxy that they want to whitelist on the wallet side instead of enshrining that and protocol. I'm still leaning towards maximum flexibility when it comes to the implementation of the contract.
00:49:57.684 - 00:49:59.464, Speaker A: Thanks, Ansgar.
00:50:01.084 - 00:50:33.754, Speaker C: Yeah, so I mentioned in my summary in the beginning the kind of the desire to also start work on basically like a documentary with best practices and recommendations and possibly even things we kind of want to enforce on the social layer and around wallet behavior. And I'm just wondering what would be the best format to start making progress on this? I know that we have these all wallet devs calls. Is that, would that be a good place? Is there a different place? Like, I just, I just, I just worry that basically if you start too late, it might, it might just take time to figure these things out. Out.
00:50:39.734 - 00:51:32.504, Speaker A: Can we have this as an ERC as well? It's kind of weird. I don't know if there's any wallet specific ercs. Um, yeah, I guess it's maybe like we can start working on the best practices and then we can figure out where we store it long term. Um, so I guess that for. Okay, so for next week's call, um, the three things that would be nice is one, if we want to explore these different spec changes that Vitalik proposed to, having the ERC proxy that people sort of, uh, yeah. Can, can agree on. And then three, uh, getting some progress on the best practices document.
00:51:32.504 - 00:51:53.504, Speaker A: Anything else people feel we need to get done before next week. Okay. And anything else, uh, anyone wants to discuss before we wrap up? Great.
00:51:53.544 - 00:51:53.776, Speaker D: Sweet.
00:51:53.800 - 00:52:25.388, Speaker A: Well, yeah, thanks everyone. I'll post the recording of who will be working on the best practice talk. And I guess same question for the ERC. Like, I think if people Onsgar will be working on the best practice docs on the ERC. Matt had a draft. Does anyone from the wallet side wants. Okay, want to help? Okay.
00:52:25.388 - 00:52:50.804, Speaker A: Richard wants to help. Okay. And then I guess the best channel. So we have, like, eth magicians for the EIP, but we also have the. Do we have an AA channel? Yeah, we have the future EOA channel in the R and D discord. So we can use that as well to coordinate. Yeah.
00:52:50.804 - 00:53:05.804, Speaker A: Great. Anything else? Okay, thanks, everyone. Talk to you all soon.
00:53:08.464 - 00:53:09.096, Speaker G: Thank you.
00:53:09.160 - 00:53:09.424, Speaker E: See ya.
