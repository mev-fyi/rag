00:00:03.680 - 00:00:44.374, Speaker A: Okay, welcome everyone to the sequencing and pre conformation call number twelve. Today is demo day. We have four different teams doing four different demos. I guess before we get started, I just want to give a little bit of a progress update since last time. One piece of exciting news is that there's two new base roll ups on my radar. Number one is a japanese team called Int Max. They're building a really, really interesting ZK rollup that is specialized for payments, where the on chain overhead is five bytes per transaction.
00:00:44.374 - 00:01:54.300, Speaker A: So it's very, very small on chain overhead, and they're building it as a base roll up. And then there's another base roll up from the Tyco team called Gwyneth, and I'm not sure if it'll be run as two parallel chains or if one will update the other, but exciting nonetheless. Another update is that we now have a repo on the Ethereum GitHub organization. So it's Ethereum preconce. The role of this repo is basically to host the credibly neutral code, in particular the registration contract, where we really want everyone to agree on one canonical registration contract, which is maximally credibly neutral. So if you do want to work on the registration contract and you're not part of the registration contract telegram group, do get in touch with me, I guess since last call we've had sequencing day at EFCC. A lot of people have been talking about pre confirmations.
00:01:54.300 - 00:02:33.410, Speaker A: I feel like the word is really starting to spread out and people are getting comfortable with the concepts. And in addition to doing the education and spreading the word, I think there's been a lot of actual development on testnets. There's a new testnet, the Helde testnet, which is dedicated to pre confirmations and proposal commitments. And today is where we'll see a lot of these proofs of concepts live. So without further ado, let's start with the very first demo from the Gataka team. Kubi and Lorenzo, the floor is yours.
00:02:34.830 - 00:02:37.090, Speaker B: Cool. Can everyone hear me all right?
00:02:38.470 - 00:02:39.254, Speaker A: Yes.
00:02:39.422 - 00:02:40.342, Speaker B: Okay, nice.
00:02:40.446 - 00:02:43.210, Speaker C: I'm just gonna share my screen share.
00:02:51.160 - 00:03:25.004, Speaker B: Okay, perfect. So, hi, Kubi and Lorenzo here from Gattaca. So we mainly focus on infrastructure around pre conformation. So we're not actually building a pre conformation protocol itself. And I guess we have been sprinting towards various improvements since Zubalin. So we're just gonna talk just very briefly about what we've built and then actually run through the demo just to set the scene a bit second. Yeah.
00:03:25.004 - 00:04:33.772, Speaker B: Okay, so if you guys remember back from Zubalin, the main focus there was on inclusion pre conformations, which was a very good sort of foundation to work towards actual l two execution pre conformations. And the main milestone there really was that there was some consensus that was reached across different teams to basically make some changes to the existing PBS stack. So across proposal to the relay to builders to actually enable inclusion pre conformations, l one pre conformations for that matter, in Zoom. And this was actually like an important sort of stepping stone stone to work towards the next stage. And then just this is a quick refresher is the notion basically that l one proposers can opt into being pre confers and the proposal can either be the pre conferred themselves directly. So for example, the bold protocol enables that. But also there's this notion that these proposals can delegate the right to be or to issue pre confirmations on behalf of them.
00:04:33.772 - 00:05:59.800, Speaker B: But no matter whether the pre confer is the proposal themselves, or a delegated pre conferred through a gateway, there's basically this notion of a look ahead where even if not every proposal has actually opted in to being a pre confer, essentially the proposal is next in line, has exclusive rights to issue pre conformations during these GAAP proposals. So just as a quick refresher and then what we have actually built now on Helder to get to l two execution pre confirmation is the following. And so basically you have a pre conformation RPC router, and this is also open source. And the idea is basically that the users or wallets can directly request pre confirmations through this RPC endpoints. And the router RPC is responsible for by looking at the look ahead, basically identifying who is the right elected gateway or could be proposed directly. But essentially who's the entity that can issue pre confirmations based on the look ahead and essentially make sure that these can be issues. And whenever there's a transition, then switch to the right pre conference accordingly.
00:05:59.800 - 00:07:02.218, Speaker B: And the way we got everything to work on Helder specifically without requiring any changes on existing wallets. So we actually use Metamask here. Oh, okay, I think that was a mistake then. Yeah. So we basically will be able to respond to current RPC calls that, well, it's already used in order to give the user the same experience that they are already used to, without actually requiring any changes on the wallet front, which is actually quite nice because that will help a lot with adoption. And so like some of the standard, like RPC calls, like you send raw transaction, get transaction receipt, transaction count, are basically exposed to via the RPC and then redirected to the router, the gateway. And this is important because the gateway actually maintains states and advances state.
00:07:02.218 - 00:08:28.924, Speaker B: And so the gateway can actually return the exact correct data at any point, even though the data might not actually be on chain yet, which is important, especially given you have gaps across multiple proposals. But even when you have single proposals or multiple proposals in sequence, you don't want to be constrained to the twelve second block time. And so what the gateway essentially does is it can respond and issue pre confirmations really, really quickly. So when we are running our demo, we had pre confirmation responses in the realm of 20 milliseconds or so, which is really, really fast, and then can also provide answers in regards to specific questions on, like what the state is, or getting transaction receipts and all those kind of things, which is quite nice. And here we also somewhat separated the role of a gateway from the act of actually maintaining states, just so that the gateway potentially can actually also be operated by entities just like the relay, for example, that actually don't need to maintain all the state and everything. And we'll also open source a version of the gateway that actually that we're working on. And so the idea is, basically, I said before, you have this notion of a schedule, and for that specific point in time, a specific gateway can issue pre confirmation and maintain state.
00:08:28.924 - 00:09:05.770, Speaker B: And as the pre conformations are being issued and the number of transactions reaches a certain threshold, the gateway can then basically create dispatches and then post them onto the l one. And these can be viewed as l two blocks, so to speak, and can be included in l one transaction actually then enforced when it's actually time for the gateway to, or that specific proposal to build the l one block. But in the interim, again, they can make that state available. I think there was a question somewhere.
00:09:10.200 - 00:09:14.420, Speaker A: The question was, do you guys support l one pre comps as well?
00:09:15.040 - 00:09:57.810, Speaker B: Just inclusion, not execution. So in theory, you can provide execution pre comps for l one as well. But that definitely, it puts a lot more constraints. And the sequencing itself, it changes significantly because there's already a status quo on the l one, and certain kinds of returns that are expected because of the mev auction. And so if you change that and do everything, like on a first come, first base surface, that will massively change the rewards, if that makes sense.
00:10:00.280 - 00:10:02.608, Speaker D: That makes sense, yeah.
00:10:02.744 - 00:10:07.420, Speaker B: Cool. So now we're going to actually show you how this works in practice.
00:10:12.080 - 00:10:16.420, Speaker E: All right. Hi, guys. Can you all see the metamask? Everything?
00:10:17.440 - 00:10:25.782, Speaker A: Yes. Would you mind clicking hide on the zoom message that's in the center? Thank you.
00:10:25.966 - 00:10:38.690, Speaker E: So here we have the gateway that's running, and then from metamask, I already set up the RPC. So that is going to be routed to the gateway.
00:10:46.230 - 00:10:46.798, Speaker C: Yeah.
00:10:46.894 - 00:11:28.544, Speaker E: So now the gateway has. Okay, that was too fast. But so basically the. There you go. So this is kind of the, what we think the UX could look like. So the user sends the transactions, and then for a certain amount of time, the explorer still shows it, because the explorer is connected to the gateway, so it receives this pre conf state ahead of time, and then it shows us pre confirmed. And on the gateway side, we received the transaction, and then we sent it to the sequencer for execution.
00:11:28.544 - 00:12:26.630, Speaker E: And if you see the timestamp 493. So we. Yeah, it took around 22 milliseconds to be sequenced, and then it's ready to be queried by the, by the wallets or the explorer. And then what happens is that we create these l two batches, which are, right now there was just one transaction, so we created a block with a single transactions, and then that's going to end up on chain. So after a while, when that's landed on chain, this pre confirmation was so snow, which means that now the l two block containing this transaction has landed in an l one block. So essentially, now this block enjoys the same kind of l one guarantees. Yeah, that's more or less the demo.
00:12:30.090 - 00:12:38.510, Speaker A: Okay. Super cool. Very, very low latency. I like that. Are there any questions from the audience on the demo?
00:12:42.150 - 00:12:53.030, Speaker D: Is it relatively general purpose? I know you guys were doing it on Taicho there. I believe that, but I would assume it's relatively general purpose to apply that to any of the different l two frameworks.
00:12:53.190 - 00:13:08.310, Speaker B: Yeah, exactly. Yeah. So for this demo, now we work with Tyco, but we actually also work with a bunch of other teams. Yeah, this is trying to be as agnostic to the l two s as possible.
00:13:10.050 - 00:13:11.430, Speaker D: That makes sense. Thanks.
00:13:20.650 - 00:13:31.310, Speaker A: I am curious about the integration with metamask. Can you talk about how that was done? Did you use a snap, or did you mock the blocks or something like that?
00:13:32.750 - 00:14:01.980, Speaker B: So this demo now mocks the blocks. So I think we discussed this before. We essentially built this in such a way that the gateway is responsible to make state available to whoever needs or wants to have access to state until it actually lands on the other one. So you actually have this nice and smooth transition. Although we also spoke with Metamask and currently experimenting with developing a snapdez to have some better ux changes there.
00:14:12.720 - 00:14:19.380, Speaker A: And what are the main next steps in terms of getting towards production? And mainnet.
00:14:20.520 - 00:14:55.110, Speaker B: Yeah. So from our perspective, we need to solidify some of this infra, and we're also going to open source a version of the gateway as well. So for now we only open sourced RPC, but we also want to make a gateway version available. And then most of the work is actually around. So working with the teams that are working on the registration contract, so we integrate the look ahead that's implemented there and also things around slashing and things like that. So we integrate that properly because this is currently and this demo also not enforced.
00:15:07.460 - 00:15:19.440, Speaker A: Okay, fantastic. Thank you so much, Kubi and Lorenzo. Next up we have the bolt team, who will be talking about l one preconfirmations.
00:15:20.460 - 00:15:29.070, Speaker F: Yep, let me share my screen. All right. Can everyone see that?
00:15:29.930 - 00:15:30.750, Speaker C: Yep.
00:15:31.490 - 00:16:19.932, Speaker F: Cool. So, yeah, in this presentation, we also mainly wanted to give an update since our last presentation and our last status at Zuberlin. So let's start with what's new. So obviously we've deployed on Helder alongside an initial registry for proposer discovery. So that's the same registry that Kuvi was talking about. We've also deployed a minimal bolt RPC, which actually also does kind of the same functionality as the gateway in the sense that it provides a translation layer between what language wallets speak and what language the pre conf API speak. In a sense of it also takes a look at the look ahead to proxy requests.
00:16:19.932 - 00:17:11.370, Speaker F: So that's also similar functionality. On top of that, we've been working on local fallback block building. So as you know, we do precons on l one, and we are compatible with PBS. So in the case that PBS fails to deliver a valid block, the sidecar will actually build a local block that adheres to all of the commitments so that there's no liveness faults or safety faults that come from a failure downstream in the PBS pipeline. We also added support for blob transactions. So type three transactions and bundles so you can think flashbots bundles with relative atomicity guarantees, but alongside, you get a pre confirmation. And we've updated our commitments API, which you can find at the link here.
00:17:11.370 - 00:17:58.926, Speaker F: I will share the slides in the telegram right after. So, yeah, let's get straight into the demo, actually. So for our demo, we've decided to do an ETH transfer with an l one inclusion precomps, showing a possible way to also integrate with metamask. We did not go the route of mocking the receipt, and so we took a different approach, and now we send a signature request to Metamask and then send the transaction actually to our RPC. So let's go over that right now. I will send some ETH to a random wallet request, a signature from metamask, and then we get an instant confirmation. Let me just.
00:17:58.926 - 00:18:31.630, Speaker F: It's not as quick as the Gattaca one. You can see it's got them 132 milliseconds, so not as fast. And it will provide a link to the to be proposed slot. So now we'll quickly wait for it to be actually included so that we can show it was successful. Sorry, this is not easy. Okay. Okay, there we go.
00:18:31.630 - 00:19:27.422, Speaker F: So we got a blog scout link showing that the transaction was actually confirmed, and then we can go to Dora the explorer and actually see that the block was built by chainmount, build by bolt, sorry, with the bolt builder. So that was the quick demo. And in terms of what actually goes on under hood, we thought it'd be useful to show an excerpt of all of the logs. So the first thing is that the wallet sends a request, an inclusion request, to the sidecar. The sidecar will then read from the look ahead and proxy the request to the correct proposer sidecar. It reads this RPC endpoint from the on chain registry and then sends the request to that side core. The saccar will then validate the transaction, so it will validate the base fee, the nonce and the balance.
00:19:27.422 - 00:20:27.790, Speaker F: And as soon as it passes the execution state validation, it will respond with a commitment. It will also turn these commitments into the constraints and send them to Mvboost, which will in turn send to the relay and the builder. The builder will then store them, and as soon as it is time to start bidding, we'll actually create a multiproof for it for the constraint proofs, and send that block with the proofs to the relay. The relay will also verify these proofs to make sure that the bid is actually eligible for the auction. Then as soon as MevBoost or the modified Mevboost receives the get header with proofs request, it will forward that to the relay, and the relay will deliver the bid with the proofs. In turn, Boltboost or MavBoost will also verify those proofs to make sure once again that they're all valid. And once that's done, it will return it to the beacon client ready to be signed and broadcast.
00:20:27.790 - 00:21:31.276, Speaker F: So yeah, that was a quick demo in terms of next steps for us, kind of divided into research and development. So on the research side, we're really looking a bit deeper into all of the potential use cases and also potential economic modeling and a bit of forecasting like, what would this benefit proposers who choose to run this? What do penalties look like? So, slashing and freezing, these are problems that are being widely discussed as well. Fair exchange is an interesting one. Currently we use the RPC, the Bolt RPC, which sits in the middle as sort of a timestamping oracle, which can timestamp requests and responses and make sure that these responses actually happen in time. And in case a user is not happy, they can go to the RPC and request some evidence of misbehavior. And we're also exploring other commitment types. So bolt in general is a proposal commitment protocol, which inclusion precons are a very good example of.
00:21:31.276 - 00:22:22.790, Speaker F: But there are potentially others that are very interesting. We want to move to Holeski by the end of September, but before that on Helder, we first want to finalize a couple of things. So the commit boost integration, we want to make sure that's very streamlined, provides easy ways for validators to run these sidecars through Commitboost, also integrate their signing manager for extra security. We want to collaborate on the registry implementation, which is not finalized yet. There are a lot of open questions there. And also obviously it's a topic that needs a lot of scrutiny because security depends on it. Then we want to finalize the constraints API, which is how the bolt protocol interacts with the PBS pipeline to communicate constraints and verify proofs.
00:22:22.790 - 00:22:54.180, Speaker F: There is also a discussion going on on GitHub in the link there. And then finally, yes, we want to move to Holosky by the end of September with a more streamlined MVP that implements things that come closer to an actual production, deployment of proposal commitments and inclusion precautions on L1. So that was it. Thank you. If anyone has any questions, I think we have time. Okay, no questions.
00:22:54.920 - 00:23:14.460, Speaker D: I have one. I saw you guys added bundle support. How is the bundle support working? Are you guys like essentially simulating the bundles and then essentially you're guaranteeing Adam? And at the time there were questions made, but the atomicity could be broken by a later request. Is that kind of how it's done or how are the bundles support done?
00:23:15.120 - 00:23:52.160, Speaker F: Yeah, so we provide atomicity. Not in the sense that actually, yeah, I made a bad analogy. So in the sense of flash wallets, you get atomicity on execution as well. We just provide a guarantee that your bundle will, if it's included, it will all be included in the same order. But one of the transactions could actually fail because we don't provide you with execution guarantees, we only provide you with inclusion guarantees. So it is strictly just an extension of inclusion prepost. And yeah, the execution guarantees are not implemented, so that was a mistake on my part.
00:23:52.460 - 00:23:58.440, Speaker D: Oh, that makes complete sense. That's kind of somewhat of the guarantees. You get round shared sequencers then in bundles.
00:23:58.900 - 00:24:00.120, Speaker F: Got it. Okay.
00:24:07.940 - 00:24:14.720, Speaker A: Did I understand correctly that the pre confirmation notification happens at the app layer, not at the wallet layer?
00:24:15.370 - 00:25:07.970, Speaker F: Yes. So in contrast to the previous demo, we couldn't get the mocking working. So for now we use sort of like a more of an intent structure where we request a full signature from metamask and then actually forward the full sign transaction to our RPC using send raw transaction. And then we use that response to create this pop up that you saw on the front end. But since the signature is requested from metamask and not actually sent through the metamask RPC, we don't get a confirmation inside of a metamask. And we are also thinking about how we can potentially improve that, because the UX is obviously not great and metamask actually gives you a warning when you try to sign transactions, which makes sense. So we're also looking at snaps and various other options.
00:25:16.920 - 00:25:21.380, Speaker A: Are you guys also looking into l two pre conformations or mostly focusing on l one?
00:25:23.280 - 00:25:55.530, Speaker F: Mostly focusing on l one. Right now in the research, there is some overlap, which I think is great because we can tackle the problems for both l one and l two at the same time, or at least the ones that overlap. Where we do overlap is like some other protocols might rely on forcing inclusion of a sequenced batch, and that can be done through Bolt, but we are not focusing on the actual sequencing and pre confirming of L two transactions.
00:26:02.840 - 00:26:07.060, Speaker A: And can you briefly talk about the other commitment types that you guys are looking into?
00:26:08.520 - 00:27:01.460, Speaker F: Yeah, so I think one that I find interesting is sort of a block space claim type of commitment, where you can get some sort of block space reserved for you in advance, even though you don't necessarily know what you're going to put in it yet. So this can be useful for protocols that want to offer things like gas futures and stuff like that. We've just started doing some research on that, so it's not there. Obviously, the fair exchange problem is very much more outspoken in that situation, because the user gets a signed commitment for a sort of block space claim, but then actually has to deliver that payload. So it's similar to the PBS fair exchange problem. So it's kind of a, a more difficult commitment type, but we're definitely interested in figuring it out.
00:27:07.360 - 00:27:13.660, Speaker A: Okay, thank you so much. Any other questions from the audience before we move on to the next demo.
00:27:20.040 - 00:27:20.854, Speaker F: Cool.
00:27:21.032 - 00:27:32.810, Speaker A: Thank you very much, Jonas. Thank you so much. Next up we have the switchboard team from nevermind.
00:27:32.970 - 00:27:33.950, Speaker C: Can you hear me?
00:27:34.410 - 00:27:35.230, Speaker A: Yes.
00:27:35.850 - 00:28:02.442, Speaker C: Okay, cool. Okay, so this is the Taiko preconfirmation demo in held your testnet. We are switchboard, a subsidiary of Nethermind, focusing on pre conformation research and engineering. Next slide please. So this work is in collaboration with and funded by Taiko of previous slide. Yes. And so huge shout out to Tyco.
00:28:02.442 - 00:28:31.690, Speaker C: Next slide. And huge shout out to the team. Ahmed Anshu, Marcie, Miguel Smotneal Konner for making this all possible. I am Lenoxitany presenting next slide please. So first let me give a design overview of what we are implementing. So, the PLC design, our PoC design works as following. First, we split each twelve second l one slot into three.
00:28:31.690 - 00:29:08.290, Speaker C: For example, four three second sub slots. And at each end of each subs, the pre confer who is elected from the opted in l one proposer will build, sign and publish and title l two block to the network. In other words, they are pre confining the whole l two block. Next, Taiko users will listen to these pre confed l two blocks to know the result of their l two transaction without waiting for the l one inclusion of their transactions. Next slide, please. So, here's a sequence diagram of what I mentioned. So first, the l one proposer will call an l one contract to register as a pre conference of the opt in.
00:29:08.290 - 00:30:03.360, Speaker C: Next contract will have election mechanism to choose who the pre confer for that slot should be. Now next, when the l one proposer, it comes to the l one proposer's turn to actually be elected. What happens is that first, the users will submit l two transactions to the Taiko network, specifically to the typo mempool. Next, l one proposer will fetch these transactions from the Taiko mempool locally, build and sign an l two block, then propagate the signed l two block to the tyco network. Next, the full nodes that are listening to these pre conformed l two blocks will execute the l two block and provide the user the latest preconfed state. Now, this whole iterate round will be iterated several times within one slot. Now, at the end of the slot, the proposer will submit an l two block to the l one.
00:30:03.360 - 00:31:00.530, Speaker C: And then the l one contract will check if it's like the expected elected pre confer and accept it. And then later on, a distributor who's like monitoring the network can look at the pre confed l two block and the l two blocks that were actually submitted at the end of the slot and provide fraud proof if they contradict with each other. Next slide please. So like one of the unique features of our PoC is that implements batch preconfirmations. What I mean by batch is preconfirmation is that we provide pre conformation at a batch level. So here at the l two block level, for example, this is what optimism provides with their two second block times. On the other hand, there's continuous preconfirmations where the pre confer provides preconfirmation at the transaction level in a continuous tree, for example, arbitram provides this.
00:31:00.530 - 00:32:00.880, Speaker C: Next slide please. So why do we batch? So the issue with continuous pre conformation that it is hard to incorporate a pricing mechanism. This is because the pre conference needs to decide to pre confer a transaction just by looking at the single transaction in a tip for a very limited number of transactions. Now, lacking a pricing mechanism is an issue because first the searchers in the network will optimize for colocation network latency because the faster you read the pre confer, the higher chance of inclusion you have. So there will be a latency race. This means that value is not captured by the tip, but it's rather leaking out of the system in terms of these collocation costs or these network costs. Another issue is that searchers might just like choose not to participate in this latent series and just spam the network the l two block with probabilistic arbitrage transactions.
00:32:00.880 - 00:33:04.440, Speaker C: So as a result, this drives up Safi for end users because the l two block will be filled by these transactions. So if you look at the ultra low latency blockchains and roll ups that you see right now, like Arbitrum, Polygon and Solana, they all face this latency risk and these spam issue. So the nice thing about batching is that batching enables pricing via auction within the batch. So by being able to run an auction, this mitigates latency races and spam because the searchers will be incentivized to participate or like express preference in terms of tips rather than like paying for the latency, like reducing the latency or co locating Orlando like just spamming the network. And another nice thing about batching is that opens doors to PBS for these pre confed l two batches or blocks. More on this later. However, we do lose speed of light latency pre conference demos.
00:33:04.440 - 00:33:22.590, Speaker C: So it will be like 2 seconds or 3 kg latency. Next slide please. So that is it for the design part and the reasoning of the design. Next, Marty will present the demo of what we did for Halder.
00:33:23.410 - 00:34:20.984, Speaker G: Yeah, thank you, Lynn. So at the beginning I want to give you a few words about our Abs node, which you can see in this diagram in the center. This is our core component which is responsible for interacting with Tyco clients. So Tyco proposer and Tyco driver. What's more, it has its own dedicated peer to peer network, so ABS nodes can share information about peak confirmations. It also calls l one smart contracts and use MavBoost modified Mavboost forcefully, including blocks. And here, as you can see those labels, this is the flow for the pre conformation.
00:34:20.984 - 00:35:34.370, Speaker G: So first we register as a pre confer. Then we need to take transaction from the l two mempool using taco proposal. Later we commit to these transactions and we share information about confirmations between nodes. And next we want to advance the head of local l two chain and after that we can submit l two block using block to post smart contract. And finally, if until the slot of the pre confer, the block is not included yet, we have to forcefully include it. So we use MavBoost in this case not to be slashed for what we achieved on health network. You can see those highlighted labels.
00:35:34.370 - 00:36:26.890, Speaker G: So the development is in progress and we are able to afford now to provide those free operations. So we were able to take two transactions. We advanced the head of the l two network and we submitted a block. And here is the screenshot of the logs from all those modules I mentioned. And let's look into it. This is first our script to create some l two transactions, free transactions in this case. And next one we have Logstone Tyco proposal.
00:36:26.890 - 00:37:26.700, Speaker G: It just gave us free transactions which we created and those transactions went to ads node. These logs come from the AV's nodes, the main piece of software. And what's interesting here is that we, after taking transactions and advancing the head, we just call this proposed new block smart contract at the bottom. And this, this piece of logs is from Taiko driver. And at the bottom again you can see newer two block inserted. This is what we achieved on the harder. So we are able to have it on chain.
00:37:26.700 - 00:37:42.420, Speaker G: And this is a screenshot from block Explorer where we can see this new block proposed transaction executed. Yeah, that's it.
00:37:44.200 - 00:38:24.892, Speaker C: Okay, thanks. Next I'll give current where we are and like future directions slide. Can you go to the next slide please? Sure. So the current status is for the smart contract. We've implemented an election mechanism based on an optimistic look at submission design. We also implemented the pre conformation disputes for the soda slashing logic. Right now we are actively working on ECDSA to BLS mapping design because the pre conformations will be signed by the ECDSA.
00:38:24.892 - 00:39:05.034, Speaker C: But in the look ahead we have a BLS and how do we map them? It's like the active part we're designing. Furthermore for the AV's node, we are working on implementing the interaction with the existing contracts that we implemented. Also we're implementing the AVSP two pknortheminal for future directions. We are thinking of addressing first addressing the fair exchange problem. So we have some ideas, but it's not implemented yet. We want to improve the election mechanism so we do not rely on an optimistic look at submission. And also, one interesting direction that we're looking into is l two PBS.
00:39:05.034 - 00:39:51.410, Speaker C: So like in the design or like diagram that we've seen so far, the l two preconf blocks are built locally by the l one proposer. But the l one proposer is not like optimized for building these l two blocks. So naturally they would want to outsource cell block building. And how do we do that? One way that we think that makes sense is that we can piggyback the l one PBS pipeline and let the l one PBS pipeline build and preconf l two blocks. Like split the l one slot into like several of these rounds or these sub slots and run the PBS pipeline multiple times to get the pre conformations. So this way you get pricing and you do not introduce any external actors to the system. That's it.
00:39:51.410 - 00:40:29.000, Speaker C: Yeah. Thanks everyone for listening. Oh, not yet. Okay, sorry. Yes, if you're reading, first and foremost, please take a look at our Taiko Poc design doC. It has a lot of the design, the three around the contracts and flashing and lookahead where we did not discuss in this talk and straw manning based pre conformation is a research post that I written more about like the negative externalities of the continuous pre conformation and base pre conformation with multirombus. This about the idea that I talked at the end of PDBack and l one PBS pipeline to provide l two P confirmations.
00:40:29.000 - 00:40:37.690, Speaker C: Okay, that is it. Yes, thanks everyone for listening. And yeah, let me know if you have any questions.
00:40:39.790 - 00:41:09.540, Speaker A: Thank you so much. Very interesting to see three completely different approaches to preconfirmations. One question I have is on arbitrum being continuous, my understanding is that they have 250 milliseconds slot time, so they do batching, but I guess it feels continuous. And so maybe the sweet spot is like somewhere in between where we have these batches, but still very short slot times.
00:41:12.520 - 00:41:14.940, Speaker C: Okay. Yeah. Thanks for the information.
00:41:19.560 - 00:42:21.940, Speaker A: One thought on batching is that if we have 10,000 tps, for example, the overhead of dealing with things on a transaction by transaction basis might be too high. And so batching might be just be necessary for it to be practical. But one thing that you mentioned is on the searchers potentially spamming the chain. The way that I think about it is that the gateway has the last look, and so it will basically be adversarially picked. But if the searchers keep spamming, they will always be losing money because either they're kind of offering a price that the gateway is not willing to sell at, or they're basically sending a stale order that now the gateway can just pick and abuse. And so the way that I think about it is that preconfirmations is really for users that are willing to pay this UX premium. It's not for searchers because they will just get picked by the.
00:42:21.940 - 00:42:23.580, Speaker A: By the gateway.
00:42:26.200 - 00:42:43.250, Speaker C: Yeah, that. Well, yeah, I think that makes. Well, let me think. So. I think so you're saying that the gateway can filter out these failed transactions? Kind of the.
00:42:43.590 - 00:43:16.700, Speaker A: Well, the gateway is only willing to sell the block space at fair value plus epsilon, where epsilon is like the UX premium, let's say. But the searcher is only willing to buy at fair price minus epsilon. So by default, they won't agree on the price. But if they do agree on the price, it's because the searcher sent a request, a pre conformation request, and now the request is stale. And so now they actually are paying fair price plus epsilon. And so they will be losing money as an arbitrager.
00:43:17.480 - 00:43:47.030, Speaker C: Yeah, I guess so. But I do think that these kind of things are kind of happening in these latency blockchains, and then they are spamming. And I guess the issue is whether this spamming results in the user's fee increasing or nothing. And, yeah, as long as that's not happening, maybe this plan is not an issue. Like searches are just missing out on value and not an issue. But, yeah, I'll be interested in what actually happens.
00:43:49.170 - 00:44:10.260, Speaker A: I mean, as Connor wrote in the chat, the sellers of blockspace on platforms like Solana today are unsophisticated. And it's kind of interesting because we're probably going to see, you know, pre confirmation tips happen on Solana before they happen on Ethereum. And so we can reuse a lot of the R and D that Solana will have to go through.
00:44:12.200 - 00:44:17.380, Speaker C: Yeah, completely agree. I think Solana is kind of front running pre conformations or basic pre conformations.
00:44:17.880 - 00:44:25.340, Speaker A: Right. I just had a quick one. Is Mr. Met Boost? Is that a fork? Met boost?
00:44:27.360 - 00:44:32.688, Speaker C: I think it will be a forklift, but we haven't started implementing anything. So yeah.
00:44:32.864 - 00:44:35.264, Speaker H: You'd be curious if there's something advantage.
00:44:35.312 - 00:44:37.032, Speaker A: Wise you get over something like commitboost.
00:44:37.096 - 00:44:38.112, Speaker B: No, I'm kind of showing my own.
00:44:38.136 - 00:44:39.392, Speaker H: Book here, but just would be keen.
00:44:39.416 - 00:44:42.060, Speaker C: To explore that with you guys. Yeah, definitely.
00:44:44.280 - 00:44:45.140, Speaker A: Awesome.
00:44:48.840 - 00:44:58.560, Speaker H: Justin, in your searcher view, do you see searchers waiting near the end of the block to put in their transactions, then after the user ones are pre confirmed?
00:45:01.620 - 00:45:23.420, Speaker A: The way I think about it is that searches are really only relevant. Well, arbitrageurs are only relevant for the very bottom of the block, but that would be outside of the pre conformation cycle. It would be as part of the block building cycle at the very end of the slot. And they would be working with builders just like they, they work with builders today.
00:45:24.240 - 00:45:29.780, Speaker H: And what about ofas, where the user transaction is part of the bundle, for example?
00:45:32.640 - 00:46:20.120, Speaker A: Right. So here I have a new name which I call prices. So we do need to price the pre confirmation tips. And this is something I've talked about that EFCC. And the basic idea is that the user sends their transaction to the gateway and then the gateway shares it with various prices, and then the prices are taking on the mev risk for the gateway. So basically the gateway is always making a profit by giving out a pre confirmation. And then the various searchers are competing against each other to provide the, the smallest pre confirmation tip to the user.
00:46:20.120 - 00:46:52.150, Speaker A: And in addition to that, they would be solvers in the sense that they'd be solving the intent of the user. So yes, there is this per transaction ofa going on which simultaneously solves the user's intent and also prices the pre confirmation tip to be as competitive as possible. And from the perspective of the gateway slash proposer, they're guaranteed that they're making money by giving away this pre confirmation.
00:46:53.850 - 00:47:35.010, Speaker D: So it kind of acts in that sense, kind of like an OFA for it. We're thinking about doing something similar in that sense that actually could be helpful for some of the pre conf projects where we have a superbuilder called Javelin, and we're going to have a gateway for it where users submit their request to this one RPC. And then you have other, you essentially have builders that all compete for it. And because they're all crosswalk transactions where the builder has to generate the second part of it because you can't give every single user mint and burn rates for tokens. So you need to have like a list of builders that can move assets across different chains for this. In this case, they would be able to compete for that. And that was kind of how we were thinking about using an OFA, but they could also compete to get the best pre comp on different markets as well.
00:47:35.010 - 00:47:36.050, Speaker D: So.
00:47:36.350 - 00:47:41.500, Speaker A: Yeah, right. And specifically competing on the pre conf tip.
00:47:42.040 - 00:47:42.780, Speaker D: Yes.
00:47:43.320 - 00:47:44.060, Speaker C: Right.
00:47:46.400 - 00:47:52.500, Speaker H: So in that setting, then that, let's say the searcher wins the OFA, then is there bundled pre conf.
00:48:00.320 - 00:48:18.830, Speaker A: So yeah, the searcher can add their own transactions that help fulfilling the intent of the user. So, yeah, so long as the user's intent is satisfied, the searcher is allowed to insert their transactions as part of the bundle.
00:48:19.570 - 00:48:22.870, Speaker H: Okay, so then the pre comps are for searchers too, it sounds like.
00:48:24.490 - 00:48:50.486, Speaker A: Yes, but then they're not consumers of pre conformations, the sellers of preconfirmations. They provide preconfirmations. Okay, fantastic.
00:48:50.678 - 00:49:11.940, Speaker D: So in that case, the searches are essentially saying, I own x number of block space. I'm going to provide the user the lowest possible. So then they could use something like a block space feature to price it on the pre comp side. So the searchers are basically trying to price the most efficient pre comp. By efficient, I mean lowest price to the user where the searchers still make profit.
00:49:13.000 - 00:49:55.750, Speaker A: Exactly. So the gateway owns the block space, and then they try and allocate it as efficiently as possible. They want to guarantee a profit for themselves, and then they basically open it up to the market of prices. Searchers, solvers, who, as you said, try and provide the best price for users that still gives them an edge. Okay, perfect. Let's move on to the very last demo from Primav. Murat, the floor is yours.
00:49:56.130 - 00:50:30.956, Speaker H: Thanks, Justin. I'm going to go over a very basic system setting. We have a cli demo, Memcmit's live on whole ski, so if you want, you can go hands on and get your own execution pre confirmations. So Memcmit places execution pre confirmations by default. These are on l one. It's kind of a searcher oriented or solver oriented thing. So if you imagine somebody, let's say, using something like metamask or a wallet, essentially, they would go through some sort of process like the one that Justin just highlighted, whether it's an ofa or something else.
00:50:30.956 - 00:51:20.096, Speaker H: And the pricers or the service providers in that case would use something like Mav commit to kind of source these commitments, right? So anyone can join using a bidder node. The wallet itself could, theoretically, but we don't anticipate that to happen. We anticipate more sophisticated actors to do it, and then they can communicate with providers of execution services. This can be l one, l two, and it's agnostic both to the chain and the actor. But essentially this provider is able to make the decision on whether they want to commit to an execution of a transaction or a bundle. So it has kind of bundle or mega bundle support. And if you're looking for inclusion, or you want to kind of delineate your risk between execution and inclusion, you can add the transaction hashes that are allowed to revert in the bid payload.
00:51:20.096 - 00:52:14.218, Speaker H: So what happens is once you send a bid, you receive a commitment from a provider or a set of providers, depending on your setting. And that commitment goes back to the bidder in real time, optimistically, but it also goes to the MAV commit chain, which will then at settlement time check for its, whether it was sent in an acceptable timeframe. And it will also process things like decay if it was not. So the bid is able to decay. And everything here that you see is basically fully invisible to anybody else. They would only see a hash up until the settlement time that comes on after the block for which the pre confirmation is for has been already confirmed on chain. Really what happens is to provide the execution pre confirmation, the provider underneath has to do a series of actions in order to deliver it.
00:52:14.218 - 00:52:48.836, Speaker H: So in the case of Ethereum, what they would do is run kind of a simulated block with this transaction, and you can name that like Ethereum prime or something. And then they would essentially build blocks or try to deliver blocks that conform to some version of this transaction executing. And they would essentially send that over to the proposer. Whether the proposer does it relay does it, blockbuilder does it, doesn't matter. But then that block would make it on chain. And then currently there's an oracle that's implemented that. It's centralized, but it's becoming an AV's.
00:52:48.836 - 00:53:46.138, Speaker H: And we're also working with some proof teams to make this into a full on proof so that there's no centralized dependency. But today this oracle looks at the l one block to see whether the commitment was delivered or nothing, and then rewards or punishes or slashes the providers. So that's generally the setting. What I will now do is show you a brief video of how this works in the CLI. Essentially you're able to specify a bid so in here I'm pasting a bid that I've pre constructed, but you're able to basically specify, excuse me, which time frame that you want this bid to be valid in through setting these decay start and end timestamps. So you can effectively create your own fill or kill order by making the decay end timestamp very soon. Or you can make it at the end of the slot so that you have basically more time for receiving a commitment.
00:53:46.138 - 00:54:30.320, Speaker H: So you have this optionality. And the fair exchange problem is solved in the most kind of economically efficient manner in this way because the chain acts as the coordination agent between the provider and the bidder. So once you send this, you receive a commitment and there's a digest in there so that you can look at it. I think I made this video when I was in Brussels and the only provider at that point was in North America. So as you can see, the speed is a little higher than some of the demos that I've seen. But you can co locate or as more providers are on there that are geographically distributed, you'd be able to get different latencies. But yeah, everything you need for your pre confirmation is in this commitment, including some of the details around decays and whatnot.
00:54:30.320 - 00:55:16.320, Speaker H: And you can receive also multiple commitments from different actors depending on the setting. So if it's an l one, you'll want all of the registered block builders to commit to you. If you have a marketable price on your pre confirmation, this should happen because they're rational actors. But in the case where you don't have a marketable price, you might have situations where some block builders do come in and some do nothing, and then that gives you some information. So again, these are execution pre confirmations. So as soon as you have this commitment, you know that your transaction will be executed by that committing provider, which in most l one cases will be an l one blockbuilder. Now the last thing I want to highlight here is essentially, I'm sorry.
00:55:16.320 - 00:56:01.500, Speaker H: So we recently had some analysis on some of the bids that were done and some of the execution pre comps that were delivered. This post I posted yesterday on the group that you can look at. But essentially there's a number of whole ski blocks in there that are pretty interesting to look at. We're seeing pretty erratic bidding behavior from bidders. This is mostly because, one, there's not much state contention to testnet ETH is easier to come by than Mainnet ETH. But what's really interesting is that there were 807 pre conformations that all added to the block value to some degree. So here we're seeing the distribution between priority fees and pre conf bids in blocks, and it's very interesting to see this distribution.
00:56:01.500 - 00:56:27.780, Speaker H: I think people are experimenting with going 50 50 or going all in on their pre conf bid, depending on their transaction. And our next steps is obviously to bring this to a more closer environment on Mainnet so that we can actually get real data and collect how execution precomps work and state contentious setting. So yeah, that's mostly it.
00:56:30.680 - 00:56:57.682, Speaker A: Amazing. Thank you, Murat. Any questions? I guess Drew has been asking everyone whether or not commitboost is being used. Are you using Commitboost in any way, or do you have plans to use commit boost?
00:56:57.826 - 00:57:22.728, Speaker H: Not on this. The validators that have opted into this are on Holsky, but we do have. We're in touch with the commit boost team and the helder efforts. We have some early efforts on Helder, so as things progress we'll have more on there as well. We're agnostic to boost or maybe I guess Mister Mev Boost. So we're happy to work with all of these. Yeah, we're compatible.
00:57:22.728 - 00:58:21.970, Speaker H: And then we're also thinking of some special modules for something like Commitboost, but that might be a little bit more medium to long term. Also for folks who are interested in doing ofas or are looking at maybe more on the consumer side of things where the OFA could leverage something like Mav commit, please reach out to us. We'd love to collaborate on those. And again, we've developed this chain that has very specific editions around being able to read milliseconds instead of the Ethereum geth, which is second based, which allows you to launch contracts to help a fair exchange problem that some projects are dealing with. Be very interested in working with you and kind of leveraging the map commit chain to solve it for you. And you can have your own contracts on there and use some of the primitives that are available.
00:58:28.830 - 00:58:43.980, Speaker C: I have a question about the final data that you presented. Like who are the bidders in this like testnets? Like I'm interested in like what their intentions are for requiring pre conformations.
00:58:44.800 - 00:59:08.120, Speaker H: Searchers and solvers mostly. Today there are a few researchers, but the majority are searchers and solvers that are kind of testing the network and they have like requirements on how they want the bids expressed, et cetera. So it's helpful for them to go hands on and get familiar with how execution pre comps work on map commit.
00:59:10.180 - 00:59:11.480, Speaker C: I see, thanks.
00:59:12.500 - 00:59:51.600, Speaker H: Yeah, in the l one setting, the bid expression is at least oriented a little bit more around bundles so you can pass, let's say, three transaction hashes, and one of those transactions could be an end user's transaction. Let's say it's a sandwich of some sort. And in that setting, you could also source the pre conformation for the end user, too. So you could run some sort of Ofa, and the winner of the OFA, or even during the bidding process, could use map commit bids to actually get a price on what that should be and deliver it to the end user.
01:00:02.270 - 01:00:22.790, Speaker A: Murat, thanks again. We're just on time at the hour, so we're going to close off the public part of the conversation and open it up to the private part of the conversation, where anyone's welcome to give us an update or ask a question or bring up a topic that's on their mind.
