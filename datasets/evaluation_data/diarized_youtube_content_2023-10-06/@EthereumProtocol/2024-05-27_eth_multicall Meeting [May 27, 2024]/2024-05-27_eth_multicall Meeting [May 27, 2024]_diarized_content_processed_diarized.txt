00:00:01.600 - 00:00:16.854, Speaker A: I had a question, Clary. In your experience, when we get with same hash, is the gas used set to be?
00:00:16.894 - 00:00:17.558, Speaker B: What do you mean?
00:00:17.686 - 00:00:46.684, Speaker A: Is it set in the transactions? So basically I got a hypothesis that gas used would be one of the biggest potential differences. And I would nearly bet that when guests used and all the like transaction parameters related to guests are set, then we would get same hash. And when it is not set, we would always get different hash. Could you take a look at that and check it?
00:00:47.464 - 00:00:59.454, Speaker B: Yeah, I can take a look at it. Is it that because we. Because we decide on that algorithm or how the gas limit is calculated if it's not set, maybe there's some disagreement on how to implement it?
00:01:00.354 - 00:01:02.014, Speaker A: Yeah, I think it is possible.
00:01:05.114 - 00:01:07.690, Speaker B: I don't remember what was the logic, but it was.
00:01:07.842 - 00:01:27.154, Speaker A: The logic was to take from the block whatever amount is set by other transactions and whatever was the rest, divide it equally between the transactions that were participating in the block and not have the guess used set in them.
00:01:28.054 - 00:01:30.114, Speaker B: Yeah. Is that implementing Netherworld?
00:01:30.534 - 00:02:17.956, Speaker A: I think yes. But you have found an issue related to it somehow when it is set to zero. And yes, we haven't handled, I think that as properly as expected, but we'll take a look. So let's begin from our side. We had completed, thanks to Lukash, the basic first iteration, first pair of eyes look through the code. There are a few issues to be closed and basically, yeah, code is more or less good enough. And from the trailer issues, we are still having some return codes issues and basic checks issues that we'll fix soon.
00:02:17.956 - 00:02:53.314, Speaker A: And yeah, that's pretty much us. I think the updated release will be delivered to you guys later today or tomorrow morning. So, yeah, hopefully most of the issues will be fixed by then. I would suggest to prioritize the non validation mode for now so that we could first complete the non validation mode issues, be able to release it if needed, and then focus on the differences in validation model. What do you think?
00:02:57.654 - 00:02:58.914, Speaker C: Sounds good to me.
00:03:01.214 - 00:03:22.584, Speaker B: I don't think I have equal amount of tests for both, since it's easier to test the non validation mode. So I think we have more tests for that. So I don't always have to set up everything. And that's why I think many of the issues that we have in the non validation mode also would happen in the validation mode. But then you also need to set more parameters, so that's why I don't have that many tests for those.
00:03:23.764 - 00:03:54.724, Speaker A: By the way, I wondered, when we return blocks from the non validation mode, I think you most of the time would get more or less complete parameters, like of real, real usage and stuff like that. Maybe it can be helpful somehow because you get basically all the details of a block and all the details of the transactions filled in when you do non validation mode request.
00:03:56.544 - 00:04:03.564, Speaker C: Yes, that's, I believe. Isn't that even spec'd out in the spec that you should return all the properties of the blockader?
00:04:04.424 - 00:04:12.164, Speaker A: Yeah, but it's a little bit like relaxed as you can have stuff set to zero and stuff like that.
00:04:13.504 - 00:04:16.720, Speaker C: Right, but we still return the values that were actually used, right?
00:04:16.792 - 00:04:25.736, Speaker A: Yes, yes, of course. But the use of zero values are allowed in non validation mode and are forbidden in validation mode.
00:04:25.760 - 00:04:26.364, Speaker C: Yeah.
00:04:29.504 - 00:04:40.324, Speaker B: Yeah. I guess I could do validation mode test in a way that I run them first in non validation mode and then I get those parameters and then I set them and explicitly and then run it again.
00:04:46.144 - 00:05:19.424, Speaker A: Yes. Basically after these basic fixes, we are planning to do some performance testing with Kilaris blocks that he sent to us and we'll get the, like, the estimates, I think by the beginning of the next week of how performant or how lucky in performance we are. But currently I am optimistic on the performance. I think there will be no issues. It's entirely in RAM and even not serialized in any way.
00:05:25.644 - 00:05:27.028, Speaker B: Any updates from Sina?
00:05:27.196 - 00:05:54.784, Speaker D: Yeah, I think so. I looked at some issues that were on trailerboard. I think that was last week, and. Yeah, with some fixes, and that's about it really. I got to do a lot more.
00:05:58.004 - 00:06:13.584, Speaker B: Would you have time at some point through those trello fixes? If they would be done, then it would be again easier to compare Nethermin and get to each other because some of those issues are occurring in most of the transactions, so it makes it harder to compare.
00:06:14.004 - 00:06:17.264, Speaker D: Are there new issues or. Which ones are you talking about?
00:06:18.324 - 00:06:20.024, Speaker B: Just the ones with the Trello.
00:06:23.384 - 00:06:29.304, Speaker D: Because I did fix some of the trailer issues, so there's more that needs to be fixed, I guess.
00:06:29.464 - 00:06:33.084, Speaker B: Oh, is there a new version? Maybe? I haven't tried it.
00:06:36.464 - 00:06:41.524, Speaker A: Yeah, it seemed like cine delivered like in the middle of the last week or like.
00:06:41.864 - 00:06:43.920, Speaker D: Yeah, I wrote in the chat that's.
00:06:43.952 - 00:06:50.224, Speaker B: That'S the latest I actually attached. Just the Eoa one is still there. One?
00:06:51.364 - 00:06:59.264, Speaker D: Oh yeah, the Eoa one. Yeah. That's a bit ugly, but yeah.
00:07:01.244 - 00:07:04.344, Speaker C: We're on the latest version of both guests and Nethermind, is that correct?
00:07:07.404 - 00:07:13.734, Speaker B: I haven't checked it. Operate those nodes, probably not on the latest get.
00:07:14.754 - 00:07:17.494, Speaker C: We should make sure we get that done and see if what's left.
00:07:19.394 - 00:07:36.294, Speaker B: Well, I'm running, tell me the test shoes. So I'm not running against that node. So that's why it's just what the interceptor is using. Do Sina still disagree with the AO? I think that's something that we have been discussing for a long time.
00:07:37.794 - 00:07:46.554, Speaker D: No, I mean, yeah, we decided on it and I don't want. No, I'm not challenging it, just I haven't been very motivated to look at that.
00:07:51.774 - 00:07:52.174, Speaker C: Yeah.
00:07:52.214 - 00:08:20.834, Speaker D: Basically what I need to do is add a second flag because, right, so, because we have the, because right now there's either like validation mode or non validation mode. And validation mode is what we use on Mainnet like production. And now here we need like a validation mode that is, has, that, has this exception.
00:08:21.574 - 00:08:23.274, Speaker C: Mostly validation mode.
00:08:23.574 - 00:08:25.302, Speaker D: Mostly validation mode. Exactly.
00:08:25.398 - 00:08:35.804, Speaker B: It has that and then it doesn't check the transactions that if they had a private key correct or they assigned correctly. But I don't know if that's handled somewhere else in the code. So.
00:08:40.104 - 00:08:50.684, Speaker D: Yeah, it's done together with the other checks. So like nonce check and so on. It's in the same place. But yeah, I just need to like kind of separate that with the second flag.
00:08:52.464 - 00:08:57.284, Speaker B: Yeah. Do we have anything else?
00:09:01.324 - 00:09:25.780, Speaker D: Just I did have a question. How many of the blockaded fields are we returning? I guess what I'm wondering is like, we are returning a lot of the block header fields, why not just return the whole thing? I don't know. I don't remember if we discussed this before or like what was it, what was the conclusion there?
00:09:25.852 - 00:09:31.914, Speaker A: What fields don't we return? Because I think we return like everything.
00:09:32.774 - 00:09:37.030, Speaker B: I also thought that we returned the whole block header, but maybe there's something missing.
00:09:37.182 - 00:09:42.994, Speaker D: No, definitely not the bot, the whole block header, I'm pretty sure about that one.
00:09:44.054 - 00:09:48.954, Speaker A: Maybe it's undefined.
00:09:49.894 - 00:09:51.314, Speaker D: Wait, let me, let me.
00:09:54.834 - 00:09:55.266, Speaker C: Let me.
00:09:55.290 - 00:09:57.974, Speaker D: Try to load it. One sec.
00:10:02.074 - 00:10:13.694, Speaker B: But yeah, I think it would be useful to return the whole block header, but I think. Is there some transaction that, some fields that are not really useful, but I would imagine all of them would be useful somewhat.
00:10:14.314 - 00:10:24.164, Speaker C: I mean there's gonna be some that are not useful just because we all, we know exactly what they always are. Like the uncles for example, is always gonna be empty though that's true on Mainnet as well. But Mainnet still has a block header.
00:10:26.104 - 00:10:54.544, Speaker D: The, there is a difficulty. Yeah, transactions, route, receipt route. There's a few fields that we are not really returning and I mean, I get the idea that basically we don't need them. So why return them. But I just want to also put an argument for like having the exact same structure as the header because like it's easier for the parsers.
00:10:55.884 - 00:10:58.344, Speaker C: Yeah, I support, support that for the same reason.
00:11:00.684 - 00:11:04.704, Speaker B: That'S uncle has. And do we reach out to plume filter? I think that's one.
00:11:06.644 - 00:11:07.584, Speaker D: Which one?
00:11:08.004 - 00:11:09.740, Speaker B: Plume filter. Are you returning that?
00:11:09.772 - 00:11:59.184, Speaker D: Oh yeah, also not, that's also not being returned. And I think this might actually help with the block hash debugging as well. It would necessitate though as small change, like in that case I think we would, or we should move the call results somehow out of it or I don't know how to structure it so that like the header fields are one object and, and then the other results are like kind of separate.
00:12:00.044 - 00:12:25.584, Speaker C: I think most parser go out of the limb and assume that most parsers are agnostic to excess fields. Like if there's extra fields that they don't recognize, they're going to parse anyway. So you can take the payload, give it to your block header parser and it will parse it even though it's got this extra transactions results field. And then you can give that same payload to your transaction result processor which will ignore all the block header fields.
00:12:29.284 - 00:12:35.552, Speaker D: Oh yeah. Yeah. Then yeah, I guess assuming we don't.
00:12:35.568 - 00:12:38.404, Speaker C: Have any collisions, which I don't think we do.
00:12:40.224 - 00:12:55.244, Speaker D: No, I think, I believe the extra field that we have is calls which would entail the call results as well as logs and things like this.
00:13:01.924 - 00:13:04.424, Speaker B: Any of those which are missing and useful.
00:13:05.004 - 00:13:12.504, Speaker A: Yeah, the difference will be, at least on our side, quite, quite the big thing.
00:13:13.884 - 00:13:28.910, Speaker D: Oh yeah. Well, but you are creating the header already, right, to compute the hash. So this would, in theory, this should remove a step to convert the header that we get to.
00:13:28.982 - 00:13:40.394, Speaker A: Yeah. But I wonder if we have same like same amount of stuff in block header and in between Geth and Nethermind as this is just publicly shared.
00:13:40.774 - 00:14:11.854, Speaker C: Yeah, just looking at that code, you have a bunch of things in there that you don't actually, that are optional and you don't need. For example, the, or a step is only applies to certain types of blocks and won't apply to Mainnet, Ethereum and similarly the, I saw a couple others in there that just like they're extra things that aren't actually part of the block header, they're just extra things that Nethermind includes. And because they're optional, you can just ignore them and leave them out. I think the only ones that we need to add that are non optional are pretty small set.
00:14:13.154 - 00:14:21.064, Speaker A: Yeah, but basically probably we still will have like separate structure for it because this may get different.
00:14:21.644 - 00:14:28.904, Speaker D: I mean, I assume it was structured for the mainnet header types, right. It should be exactly the same as every other client.
00:14:29.764 - 00:14:38.024, Speaker C: Yeah, you should be able to just use this data structure and there will be things that are set to null in your code, which the code already handles.
00:14:39.244 - 00:14:57.574, Speaker A: Yeah, but the question would be about serialization if it is done same way for RPC and non RPC. But yeah, we will figure that out. So if you would add more fields, probably just. Yeah, add them. We'll add them too.
00:15:01.594 - 00:15:04.374, Speaker E: Sorry, was over. But what fields do we need to add?
00:15:04.914 - 00:15:26.144, Speaker A: So geth wants to have same block headers as are putted onto the actual blockchain. So there are potentially extra fields that are currently not in the spec. So probably we'll need to either add some or just return the same block headers we put onto the chain.
00:15:29.044 - 00:15:39.104, Speaker C: They use API compatibility. So if someone has a library that can process block headers, they can use that same library to process the return result from and e simulate.
00:15:41.224 - 00:15:42.044, Speaker E: Hmm.
00:15:44.544 - 00:16:02.764, Speaker D: It's not a strong opinion from my side, it's just that an observation that basically we are adding already most, we're returning most of the fields. Then why not just go the extra mile and return the exact object that gets. Get blocked by hash or get blocked by number.
00:16:03.904 - 00:16:06.204, Speaker E: Yeah, we can do that. Should be easy.
00:16:06.734 - 00:16:07.554, Speaker C: Yep.
00:16:07.894 - 00:16:14.914, Speaker B: What are we missing? Is the blob is one. This is extranet mixed one order.
00:16:19.054 - 00:16:39.330, Speaker C: The state route, the receipts route. I think we're not returning those right now. Right. The bloom filter that may be up and are returning the uncles. I might have left the uncles out. So turn that.
00:16:39.362 - 00:16:41.694, Speaker B: Even though Uncle Hash is part.
00:16:42.714 - 00:16:52.614, Speaker D: Yeah, Uncle Hash, Coinbase, stateroot transaction, root receipts, root logs, bloom difficulty. There's also nonce and mix digest.
00:16:54.674 - 00:16:55.574, Speaker B: Extra.
00:16:55.874 - 00:16:59.520, Speaker C: Why do those all still exist? They went away with proof of mistake.
00:16:59.712 - 00:17:02.856, Speaker D: Yeah, but we, we didn't remove them.
00:17:02.960 - 00:17:06.204, Speaker A: They just, the chain is still the same.
00:17:06.584 - 00:17:08.764, Speaker C: They just have fixed values in them now.
00:17:09.104 - 00:17:15.124, Speaker D: Yes, I think mix hash is actually used for rundown.
00:17:17.184 - 00:17:17.964, Speaker C: Yeah.
00:17:19.464 - 00:17:34.334, Speaker D: So I mean, I guess it's a question that whether we should, because here the naming of it is mix hash, like in the JSON encoding. And now in our structure we return prev rundo.
00:17:36.594 - 00:17:59.014, Speaker C: So this is actually kind of convincing me a little bit that maybe we should take this opportunity to return a more correct block header than mainnet returns. Because mainnet is apparently still returning block headers that don't make sense anymore. Like half those fields are deprecated basically, or reused and renamed.
00:18:07.344 - 00:18:09.684, Speaker E: No, not half of them. Like.
00:18:11.664 - 00:18:18.644, Speaker C: A handful. Uncles all the uncle stuff the uncle's root, the difficulty fully stuff the nonce.
00:18:20.744 - 00:18:23.684, Speaker E: Yeah, but they still make sense for the old blocks.
00:18:25.284 - 00:18:28.544, Speaker C: Well, that's true. I guess you can do e simulate against an old block, huh?
00:18:29.044 - 00:18:30.024, Speaker A: Mm hmm.
00:18:31.164 - 00:18:35.464, Speaker C: Yeah. Okay, that's fair. I'm convinced. Back to make it back.
00:18:40.404 - 00:18:52.674, Speaker B: Is this the whole list that we are missing? Yes, I guess for the receive task we are not including the Ethereum transactions there.
00:18:55.694 - 00:18:56.914, Speaker D: Receipts hash.
00:18:59.574 - 00:19:01.034, Speaker B: That include the logs?
00:19:01.534 - 00:19:11.914, Speaker D: That includes the logs, yes. And we are already computing the receipts to compute the block hash. So we could just return that.
00:19:13.734 - 00:19:26.934, Speaker B: Yeah. Well I can add those to spec. Do we all agree on all how those are calculated?
00:19:29.474 - 00:19:38.534, Speaker D: I mean, if we don't agree, it will show up in the block hash difference. So I think this will be, this will be insightful.
00:19:39.474 - 00:19:41.254, Speaker A: Yeah, the more we know the better.
00:19:41.994 - 00:20:01.434, Speaker D: Yeah. So I just want to make sure that we agree on the naming like of mix hash because I think everything else we use the same names. I have to double check.
00:20:03.574 - 00:20:13.194, Speaker C: Is when Geth returns the mix hash, do they return two fields, one called prevrenda, one called mixhash, and they just have the same value, or do return only one of those?
00:20:14.694 - 00:20:19.314, Speaker D: I believe we only returned mixhadish.
00:20:20.134 - 00:20:25.274, Speaker C: And is that including if someone fetches a block from before proof of stake fork?
00:20:27.974 - 00:20:29.594, Speaker D: Yeah, I think the structure.
00:20:31.574 - 00:20:35.286, Speaker C: Sorry, you said you only return Mixhash, you do not return pre Brando.
00:20:35.430 - 00:20:36.314, Speaker D: Exactly.
00:20:36.694 - 00:20:42.634, Speaker C: I see. Okay, so you're saying internally you have it as pre rundown, but in terms of how you communicate with the outside world, it's mix hash. Got it?
00:20:44.254 - 00:20:53.754, Speaker D: Yeah, I double checked. We returned mix hash nonce zero, but yeah, mix hash has the Randall value.
00:20:55.254 - 00:21:02.582, Speaker C: Ok, well this annoys me greatly, but just because I hate technical debt, but I think having a match makes sense.
00:21:02.638 - 00:21:06.834, Speaker B: So mix has the same mixed digest.
00:21:08.074 - 00:21:11.254, Speaker D: Yeah, the JSON encoding is mixed hash.
00:21:13.274 - 00:21:31.494, Speaker A: I have a question. Do we currently have the block header like data structure in the RPC repo we are working with or will we still have our own like simulate block result as a type that we are defining?
00:21:37.174 - 00:21:47.046, Speaker D: The question was if the header is defined already in the specs. Yep, I believe it should be. Yeah. So we can reuse that. That's a good point.
00:21:47.190 - 00:21:48.794, Speaker A: Yeah, that would be great.
00:21:49.494 - 00:21:52.874, Speaker E: And we have it defined as a class in code.
00:21:53.374 - 00:22:01.834, Speaker B: I don't think if you can make a union type that, if you have that header plastic calls. I don't know if you can make that kind of type.
00:22:02.654 - 00:22:22.314, Speaker A: That's the point, to make it not special, to make it as usual as it is used in like all the other parts of Ethereum. Because otherwise if you have a union, it would be not really the same as block header that is used by other parts.
00:22:23.694 - 00:22:30.064, Speaker B: Then we have to separate that block header from the calls, I guess, and modify the structure.
00:22:30.764 - 00:22:32.304, Speaker A: Yeah, probably we shall.
00:22:34.084 - 00:22:38.304, Speaker D: Right, so here's, let me post a link.
00:22:46.404 - 00:22:47.212, Speaker A: Yep.
00:22:47.388 - 00:23:18.286, Speaker D: So it has the block object and the header fields are required. And then there's some additional properties that can be empty, left out empty, and I think those include then the transactions and withdrawals and so on that we can just leave empty. Oh oh oh, I see what you mean by union because we need to add the call results.
00:23:18.470 - 00:23:19.234, Speaker C: Yeah.
00:23:22.004 - 00:23:23.744, Speaker D: I think it should be possible.
00:23:26.084 - 00:23:47.708, Speaker C: There's two options. One, you can just run your payload through two different decoders, assuming your language allows that easily enough. Might not, depending on how you architected things. Or two, if your parser can output an object that says it's one of these two things. Typescript for example, does that really well, but I don't think C sharp has a good way of doing that at.
00:23:47.716 - 00:23:53.834, Speaker B: Least last I checked my question was more about the YAML. I don't think YAML has unions.
00:23:54.934 - 00:24:15.054, Speaker C: Oh, you're talking specifically about the. Yeah, so OpenrPC does, and I believe it's even used in the JSON RPC spec already for ethereum for transaction types.
00:24:15.214 - 00:24:22.714, Speaker D: Yeah, exactly. So we have the signed and signed transaction types and the sign has some extra fields.
00:24:24.614 - 00:24:35.474, Speaker B: Okay, but do we want to make that there's a header object and then we add calls to it? Or do we want to make header object separately from the calls? I think that's the question.
00:24:37.254 - 00:24:56.574, Speaker C: I mean I lean towards, I'm separating them does have the advantage of allowing you to kind of parse them separately. But I would be hesitant just because we're so far along. I'd be hesitant to change our data structure at this point unless someone has a strong opinion.
00:24:58.034 - 00:25:33.214, Speaker A: If we are making it, use the block header from the basic RPC spec, I would suggest to like separate them from the lists of call results that are relevant to them so that you would get like a list of headers and a list of lists of call results. This would basically allow the guys who have the passes for the headers to use them and to pass the simulate call result as it is used currently.
00:25:35.814 - 00:25:46.286, Speaker B: What do we do with the transactions? Is the block object includes the transaction would be also include the non simple transactions there and then in the call results. Then we are having that same array again.
00:25:46.470 - 00:25:51.634, Speaker A: Block header results. The block header won't have the transactions, would it?
00:25:52.574 - 00:26:09.984, Speaker B: The header wouldn't be, but I was wondering if we want to return the block object that has transactions. Yeah, axida shared block, but not the block header.
00:26:10.724 - 00:26:17.424, Speaker D: Yeah, my opinion only returned the header, not the body.
00:26:19.204 - 00:26:32.714, Speaker A: The main reasoning for adding the body can be, for example, faster generation of Genesis blocks. Yeah. Can there be any other reasons to return the complete block body?
00:26:38.174 - 00:26:40.474, Speaker D: I guess not, lukash.
00:26:40.774 - 00:26:54.184, Speaker E: So keep them as one object, and in terms of calls we can easily add them either with the reef type or a custom formatter. Not a big deal.
00:26:58.244 - 00:27:04.548, Speaker C: You're saying it's relatively easy in nethermind to have them kind of intermingled and be able to split them out?
00:27:04.596 - 00:27:05.264, Speaker B: Yep.
00:27:05.884 - 00:27:06.664, Speaker E: Yeah.
00:27:13.044 - 00:27:21.484, Speaker D: I guess the question is, which one is easier for, like ether J's or VM.
00:27:27.144 - 00:28:00.224, Speaker C: For people who are implementing the other side of it? So in typescript and JavaScript it should be relatively easy. I mean, I can't say that for sure, depending on what libraries they're using, but in general, typescript is quite good at handling unions and also handling extraneous data. So you can just run the same thing through two parsers if you need.
00:28:02.564 - 00:28:22.734, Speaker D: I have a slight preference to separating them just out of a purist point of view, but um, fine with either. And hello, uh, new participants, I'm not sure how to pronounce Dhruv.
00:28:23.314 - 00:29:25.784, Speaker F: Yes, uh, hi Sina, thanks for inviting and all the others. So I joined the to contribute to ret client the implementation of ETH simulate and the reference, let's say document an implementation that is done for multiple. I wanted to understand the implementation of traits first of all, and then eventually the implementation of functions. So yeah, I might have some specific queries for me to ask. So the one of the first one is that, let's say, in rust implementation, do we have to have the same, let's say, trait traits to implement as it's implemented already for each call? Or can we do significant changes, let's say, for implementation of state route or the calls? Hello.
00:29:27.844 - 00:29:39.480, Speaker C: So doing your question correctly that you're wondering if the you can start with kind of eth call as the basis for implementing this? Is that what you're asking?
00:29:39.672 - 00:30:45.094, Speaker F: Yes. So, for instance, during the discussion in the same pr, one of the, another good colleague shared reference, let's say create implementation. Let's say you have a root where I can share the link precisely for, for the reference in the chat. So here, let's say we have the structures root with correspondingly RPC endpoint the method that we want to call the parameters, and then subsequently you have state call the execution function calls with state overrides and other details. So my query was, is this, let's say, schema that is defined. Is it okay for me to start the implementation? And if yes, should we I implement this in the like, should I create another, let's say, file, or should I implement it at the same place?
00:30:46.994 - 00:31:02.784, Speaker C: I think I understand this call is for discussing the specification. I think you're looking for the people who manage the rest implementation repro. Does that sound right?
00:31:03.524 - 00:31:04.964, Speaker F: I was not able to hear, sorry.
00:31:05.004 - 00:31:07.424, Speaker C: Mika, what was that?
00:31:08.244 - 00:31:10.340, Speaker F: I was not able to hear your sentence. Could you.
00:31:10.372 - 00:31:18.624, Speaker C: Oh, sorry. Are you looking for the people who implement ref itself, like the paradigm XYZ people?
00:31:20.164 - 00:31:20.548, Speaker F: Yeah.
00:31:20.596 - 00:31:21.424, Speaker C: Is that who your.
00:31:23.004 - 00:31:33.664, Speaker F: Yeah. So it was just regarding also, yeah, just wanted to get feedback. Also, if, let's say implementation is correct based upon specification.
00:31:35.004 - 00:32:20.434, Speaker C: I see. So we can help you with checking, see if the implementation matches the specification. This group is made up of people from Geth Nethermind and a wallet team, and so we can't help you on anything specific to Reth or rust, but for questions about implementation whatnot, more or less the, it's probably going to look a lot in terms of implementation, it'll probably look a lot like Ethcall, which Reth already has. And so you're basically going to do more or less what ethcall does, except for with the caveat that the use, the multiple transactions can run in a row, more or less. And also you may have to generate, do some additional work to generate blocks when those come in.
00:32:21.294 - 00:33:09.584, Speaker F: Okay. And maybe it's the question, next question sounds to be little naive. Do we have to, let's say, create a separate buffer, because for generated execution traces, because they are not being committed now. So for people to understand, like let's say we execute the transactions parallel, we will have to maintain a cache, right, in order to store the intermediate results. Like how does, what are the, let's say various steps. If I have to create a timeline for the implementation, what are the major points that I have to check out in the client agnostic to whether it's mentored in get or in ret?
00:33:10.364 - 00:33:25.704, Speaker C: That probably be a good question for Sina or Oleg, like kind of for you guys. What did, what were the pain points and what were the kind of steps you took to implement this from the ground up? Pro tips for new implementer yeah.
00:33:26.084 - 00:35:05.164, Speaker D: So I would suggest in starting with a fresh implementation, I don't think it's really possible to directly use the whole ETh call code directly. I mean, I have abstracted some of the logic of executing a single call so that it can be used both in each call and multicolored. But for the most part, like, if simulate is more complicated, it has some more logic to do. So. Basically, roughly, the steps that need to be taken are that you need to, based on the input, like you have to sanitize like the block information that you get and kind of prepare some block headers, like the main block header types, fill out some fields and you have to apply the state overrides for each block. And you just like process each box separately and then fill in the, fill in the headers, that header fields, some header fields after the execution. I don't know, it's, I mean, maybe easier if I just share the code with you or.
00:35:06.504 - 00:35:23.314, Speaker E: Yeah, if I can summarize it in one sentence. In ETH call, you execute one transaction. In ETH simulate, you execute multiple blocks, each can containing multiple transactions. So it's more like executing part of a blockchain, not just single transaction.
00:35:24.934 - 00:36:07.614, Speaker A: Yeah, basically, just to add on top of it, you need to know how to create a block and how it is published through the chain. This is the first thing. And the second thing is you need to look at is call API to know how the RPC calls are basically structured so that you'll be able to, for example, connect these two. And after you get these two parts, you need to see how it impacts performance and how you can spawn this in parallel so that it won't impact your main chain block production. So I think these are the three crucial parts to it all.
00:36:09.874 - 00:36:51.038, Speaker F: Thanks indeed. Lukash, Oleg and Mika. Yeah, because it was kind of very complex. I mean, on the side of trait implementation, it was perfect. But later on there were lots of, let's say, questions that arised specifically regarding, okay, we do parallel transaction, how it will affect, like do we have to simulate also the potential contribution of those different simulated transactions on the actual state and other steps. But I will try to work on the feedback. Sina, if you have relevant implementation from your side, you can share the link.
00:36:51.038 - 00:37:01.394, Speaker F: That will be great. And I will reach out to you on the pr with the referring your handle. Thanks.
00:37:02.134 - 00:37:34.382, Speaker D: Yeah. So as for us, for states, basically every transaction that is processed, it will modify the state. And you do keep that modified state to process the next transactions and blocks. Though this is not sister to disk. That's the only difference. But we do need to progress the state as we go along, because the next transactions depend on the state of the previous ones. So.
00:37:34.518 - 00:37:35.954, Speaker A: Yes, same as I'll say.
00:37:37.374 - 00:37:38.794, Speaker F: Okay, let's.
00:37:39.334 - 00:37:50.754, Speaker D: I'm happy to share my branch and my GitHub discord handle in case you have questions.
00:37:53.334 - 00:37:54.514, Speaker F: Perfect. Thanks.
00:38:01.994 - 00:38:08.654, Speaker B: We can also invite you to the telegram group, but you can ask for more of us questions from there.
00:38:10.474 - 00:38:15.574, Speaker F: Sorry Kilari, it was. I was not able to hear.
00:38:16.594 - 00:38:20.130, Speaker B: And we also have telegram group that we can invite you to.
00:38:20.322 - 00:38:21.734, Speaker F: Okay, that will be.
00:38:25.254 - 00:38:30.474, Speaker C: Put your telegram handle in the chat here and someone can add you.
00:38:33.134 - 00:38:38.794, Speaker F: Thanks Amita, Delaria and everyone that's from my side.
00:38:42.174 - 00:39:01.934, Speaker B: So back to the previous thing with the block header. Do we agree on that? We had separate block header instead of merging them all together? Like what mica sucks at. That's the block header field and then that's the calls field. Okay, let's do that then.
00:39:02.234 - 00:39:07.210, Speaker C: I'm fine with using just header instead of block header. People prefer that.
00:39:07.242 - 00:39:07.386, Speaker B: So.
00:39:07.410 - 00:39:08.854, Speaker C: Seen a header above?
00:39:16.534 - 00:39:28.434, Speaker B: I don't know which. Which one is better. Block header is a bit more clear on what it is. And remember what we're calling those calls. Are they just calls?
00:39:31.254 - 00:39:32.954, Speaker D: I believe so, yeah.
00:39:40.734 - 00:39:47.414, Speaker B: Now we had the blockade golf. The return value is coming up.
00:39:48.154 - 00:39:53.534, Speaker D: The input is called something more else. But return value is close.
00:39:54.074 - 00:40:09.874, Speaker B: Yeah. Can we fit everything else in the. So that test goals and header? I guess. Yeah, I think so. May I get modified?
00:40:12.534 - 00:40:37.344, Speaker D: Something I just noticed we do have in our. We have a withdrawals object. We have a withdrawals list in the current spec. But that's part of the body. That's not part of the header. Although I'm checking my code and this is not being used at all. It's kind of empty.
00:40:38.684 - 00:40:40.984, Speaker B: Yeah, I think they're returning empty withdrawals.
00:40:42.484 - 00:40:48.864, Speaker C: Never mind when you get blocked by hash or. Sorry. Get blocked by number, get blocked by hash. Nethermind returns, withdraws, does geth not?
00:40:50.084 - 00:40:52.980, Speaker D: Yes, but they are part of the body, right? They're not part of the header.
00:40:53.052 - 00:41:13.274, Speaker C: Oh yeah. So I guess what we're specifying, we should probably be clear about this. What we're talking about is the shape of the thing returned by get block by hash, which does not match the header itself. Exactly. Such as, you know, the transaction bodies and withdrawals, which are both part of bodies. But they get returned by that.
00:41:15.534 - 00:41:16.794, Speaker D: Right? Yeah.
00:41:18.734 - 00:41:33.754, Speaker B: I think we should match to what the get block matches and not, not to the header itself. Since the current. There's no RPC method of getting the header. Anyway.
00:41:35.814 - 00:41:38.910, Speaker D: There is get header by Hash or get headerbynower.
00:41:39.062 - 00:41:39.806, Speaker B: Really?
00:41:39.990 - 00:41:40.430, Speaker D: Yeah.
00:41:40.502 - 00:41:51.566, Speaker B: Never used it. I guess because getblock header, I don't think. No.
00:41:51.670 - 00:41:54.874, Speaker C: Yeah. Nethermind doesn't support the get header by number.
00:41:56.274 - 00:41:57.534, Speaker D: Oh no. Oh.
00:41:58.034 - 00:42:02.534, Speaker C: I think it might be a new guest thing because I've never heard of it before either.
00:42:03.794 - 00:42:12.014, Speaker D: No, it's not new. It's been there for a while. But maybe it's not standardized. That's strange.
00:42:12.594 - 00:42:14.614, Speaker B: It's because everyone is using catblock.
00:42:15.954 - 00:42:33.534, Speaker D: Yeah. Yes. I mean like the difference is that the, the block has two or three extra fields like the transactions, the withdrawals and one more.
00:42:37.394 - 00:42:37.746, Speaker E: Yeah.
00:42:37.770 - 00:42:56.634, Speaker C: This is, this is making me lean more towards, I know. I flip, flip flopping on this. This is making me lean more towards not changing it because we already have basically get blocked by hash, which returns a header plus some additional fields already. And all we're saying is we'll return one additional field which is the call results.
00:43:04.374 - 00:43:15.074, Speaker D: So just so I understand, you're suggesting we have the header and then we add the calls to that.
00:43:16.024 - 00:43:19.992, Speaker C: That's exactly what we have right now, right. More or less.
00:43:20.128 - 00:43:25.008, Speaker D: Well, it's not the exact field as they have the right leak.
00:43:25.176 - 00:43:26.056, Speaker C: Yeah. So. Sorry.
00:43:26.160 - 00:43:26.760, Speaker F: The.
00:43:26.912 - 00:44:08.874, Speaker C: I wish there's another name for it. The thing that eth get blocked by a number returns. That thing is a block. Most of the fields from the block header plus some things from the block body plus I think some things that are just derived from the two. And so I'm proposing each, simulate as it is now, should return basically the same structure, but along with some other things. So we got the block header plus transactions plus withdrawals, plus one more thing, which is the calls, the call field. And that's basically what we have right now, except we just need to add a few more fields to flesh it out.
00:44:08.874 - 00:44:13.814, Speaker C: I see.
00:44:13.894 - 00:44:17.714, Speaker D: Yeah. Yeah, that's okay.
00:44:18.974 - 00:44:45.874, Speaker C: So essentially our returns all looking the shape of the inner, the array items in our result will be the same shape as eth. Getblockbynumber or getblock by hash. Plus it would have one additional field in each block, which is the calls, which is an array. And it would sit right next to the receipts and the transaction, sorry. Right next to the transactions field, which is also added part of the body.
00:44:48.014 - 00:44:53.474, Speaker D: Oh, and the transactions list is the hashes of the transactions.
00:44:55.254 - 00:44:58.834, Speaker C: Right. Because we don't actually accept the true version.
00:45:01.314 - 00:45:05.294, Speaker D: Yeah. Well, just which one do we want to do?
00:45:08.594 - 00:45:17.694, Speaker C: I feel like since the user gave us all the transactions, are we filling in any of the transaction fields or do we? I think we do, right?
00:45:18.994 - 00:45:20.294, Speaker B: Yeah, we filled them.
00:45:20.914 - 00:45:38.574, Speaker C: Yeah, it does feel like maybe we should return the transaction so we can let the user know what defaults we used. And so that would be the true version of get blocked by hash. So we can include the transaction list, but after filling with defaults.
00:45:42.114 - 00:45:52.914, Speaker D: Right. Only I think the signature will be probably left empty. But yeah, everything else we can return.
00:45:56.854 - 00:46:02.714, Speaker B: Should we return all the transactions then as well? A new object.
00:46:07.974 - 00:46:20.814, Speaker A: So I was wondering, where is this in the ethereum execution APIs repo in the standard one or is it just in geth code?
00:46:24.194 - 00:46:30.734, Speaker D: Please, the link that I shared before, let me find it again.
00:46:48.174 - 00:46:51.314, Speaker A: So this is basically the block object.
00:46:52.134 - 00:47:22.994, Speaker D: The block object, exactly. And it has the transactions field. And now the question is whether we return only the hashes of those transactions or the full body. So I mean just one concern is that the header size is relatively fixed. Like headers are not that big, but transaction bodies, because of the call data, they can get rather big.
00:47:23.774 - 00:47:27.114, Speaker C: You're worried about just the RPC load and burden.
00:47:27.934 - 00:47:29.854, Speaker D: Yeah, that's the only thing I'm worried about.
00:47:29.894 - 00:47:37.954, Speaker C: But otherwise, yeah, I mean I guess presumably that's why the clients currently have a Boolean flag for. Do you really want these?
00:47:39.194 - 00:47:45.694, Speaker E: But why would we? Transaction bodies, they are coming from the call itself, right?
00:47:46.514 - 00:48:00.482, Speaker C: So the user can see what defaults we got filled, they got, their transactions got filled with. I don't know if it's worth it given the size the CNIB brings up, but that would be the advantage for.
00:48:00.498 - 00:48:10.074, Speaker A: The cases when the user fills in like only one or two details. It may be really helpful for him to then be able to call with validate mode on.
00:48:12.334 - 00:48:36.634, Speaker C: Yeah, the, how about this for simulate call v one? Let's just do the hashes and then maybe in a later version we can add a boolean flag for that accepts. Or we can, it's forward compatible. So in theory we could add the boolean flag later that allows the user to specify. And I also want the transaction bodies that you filled in.
00:48:38.014 - 00:48:44.914, Speaker E: We can have it right now because it's the same as get block hashes, right? We'll get block by hash.
00:48:45.694 - 00:49:03.482, Speaker C: Yeah, so this is exactly, exactly the same as get block by hash. Oh, you're saying add the boolean flag right now it's trivial if it's easy for both geth and othermind. I'm fine with adding the boolean flag now. I was trying to avoid changing the API too much, but I'm going to.
00:49:03.488 - 00:49:04.914, Speaker B: Keep changing it all the time.
00:49:06.734 - 00:49:14.154, Speaker C: Yeah, I'm fine if it's easy enough and everybody agrees, which looks like it from the thumbs up. Okay, so let's add a new field. We just need a name for it. Maybe.
00:49:16.654 - 00:49:18.394, Speaker B: Is it the additional properties?
00:49:19.374 - 00:49:22.154, Speaker D: Thinking get block. It's called hydrate.
00:49:23.534 - 00:49:41.220, Speaker C: Yes. Gitlockbuy number has parameters in a tuple, not an object. So there's no actual name for it on the RPC, whereas ours have names for all the properties in each. Simulate v one. So we need a name for it. That's agreed on. So geth internal calls it hydrate.
00:49:41.220 - 00:49:43.744, Speaker C: I don't know if that's very clear to end users though.
00:49:44.364 - 00:49:54.264, Speaker D: No, this was just in the specs. But yeah, I agree. For get block by number it's kind of clear. But in the case of estimulate we have.
00:49:56.044 - 00:49:58.184, Speaker C: Maybe just return transactions.
00:50:08.214 - 00:50:21.274, Speaker A: If you will say that it is false, then users can expect return full transactions are better. I like it much more because otherwise you expect that there will be no transactions at all returned to you.
00:50:21.654 - 00:50:39.094, Speaker C: Yeah, that's fair. Another option would be the inverse, like return transaction hashes only and it would default to true.
00:50:40.394 - 00:50:43.938, Speaker A: The second one was shota this shorter.
00:50:43.986 - 00:50:46.374, Speaker C: I agree. I'm okay with any of those.
00:50:47.794 - 00:50:49.454, Speaker B: Can we return transactions?
00:50:54.254 - 00:51:19.384, Speaker C: Return transactions is a little bit big. I think it's like getting that because we always return a list of transactions. It's just whether we turn just the hashes or return the whole thing. I'm on board with almost any of these names. Not going to hold up anything for you.
00:51:20.764 - 00:51:21.196, Speaker D: Next.
00:51:21.260 - 00:51:24.304, Speaker B: Return full transactions. That'd be good.
00:51:29.484 - 00:52:04.904, Speaker C: That's my favorite of them right now. Anyone want to vote against return full transactions? Going once, going twice. Okay, let's do return full transactions. We want this to sit next. So this will be like. I think we have a spot for these sort of parameters, right? Like these global parameters. So validate mode, I guess, is another one.
00:52:04.904 - 00:52:20.904, Speaker C: So sit next to that. And if true, then we return the filled in transactions again, the same transactions user gave us. We just filled them in with the defaults and we returned them. And if they don't, then we just give them back the list of hashes in the transactions field. Just like get blocked by hash.
00:52:24.844 - 00:52:26.584, Speaker B: Default to false, I guess.
00:52:27.604 - 00:52:45.284, Speaker C: Yes, same as get by hash. Okay, Kalari, you can update the spec with these things we've discussed, right?
00:52:47.224 - 00:52:53.924, Speaker B: Yeah, we just need to agree with that. Is it the header or block or do we make it a union instead?
00:52:56.464 - 00:53:34.064, Speaker C: I think we were leaning towards maybe this is just my head, but I think we were leaning towards not breaking it apart into multiple things. And instead, basically the thing we return is the same as get blocked by hash, plus one extra field for each of the blocks, which is the calls field. As for how we express that in the spec, I'm ok with just saying that it's a union of the whatever it is. The object that get blocked by hash returns, bus calls, property, or if you want to respecify it, that's also fine.
00:53:35.684 - 00:53:43.824, Speaker B: And then with the mixed digest is something that do we just call it Prev rundown, even though it's coming from anywhere in the history?
00:53:44.124 - 00:53:48.304, Speaker C: I think we should call it mixed digest because that is what the get block by hash calls it.
00:53:49.164 - 00:53:53.184, Speaker B: But we have the prev rundown too. Would be. Isn't that the same?
00:53:54.204 - 00:54:20.764, Speaker C: So they are in the same spot in the block header, and depending on whether you ask for a block before the merge or after the merge, mixhash will either contain the mixhash pre merge or it'll contain the prev rendao if it's a post merge block. And so the field name is called Mixhash no matter what. It's just a question of what's in there. If it's a post merge block, it'll be the prev run out value.
00:54:21.264 - 00:54:25.720, Speaker B: But at the moment we are returning the prev rundown, so I guess we would remove that.
00:54:25.912 - 00:54:31.164, Speaker C: Yeah, we should. We should fix that via alignment with the get block by hash.
00:54:32.424 - 00:54:36.712, Speaker B: I think we are good about the prev a long time. And now we are going back with.
00:54:36.728 - 00:54:39.884, Speaker C: The mix hash one.
00:54:45.684 - 00:54:46.464, Speaker B: Yeah.
00:54:50.564 - 00:55:01.384, Speaker C: Okay. So are we all in agreement then on everything? Hopefully. These are very, very minor changes for the various clients. Not going to upset anything.
00:55:04.684 - 00:55:06.212, Speaker A: Famous last words.
00:55:06.388 - 00:55:09.144, Speaker B: Yeah, I think there will be more work from this.
00:55:11.014 - 00:55:19.914, Speaker D: Yeah, I think it should be fine. We can. I can probably try to push something by tomorrow or Wednesday.
00:55:21.134 - 00:55:25.594, Speaker C: Okay. Anything else?
00:55:26.774 - 00:55:28.994, Speaker B: I hope we can freeze the spec someday.
00:55:30.254 - 00:55:31.194, Speaker F: Someday.
00:55:32.174 - 00:55:38.134, Speaker C: We're getting close. Like the clients are back every week. Every week we're getting close.
00:55:39.274 - 00:55:41.374, Speaker A: Let's fix the spec next week.
00:55:44.314 - 00:55:47.934, Speaker B: I can fix it this week already. Modify the spec to this.
00:55:51.794 - 00:55:55.734, Speaker C: Okay. I got another meeting I gotta get to. I will talk to you guys next week.
00:55:56.514 - 00:55:57.746, Speaker A: See you all. Thank you.
00:55:57.810 - 00:55:59.214, Speaker B: See you. Bye.
