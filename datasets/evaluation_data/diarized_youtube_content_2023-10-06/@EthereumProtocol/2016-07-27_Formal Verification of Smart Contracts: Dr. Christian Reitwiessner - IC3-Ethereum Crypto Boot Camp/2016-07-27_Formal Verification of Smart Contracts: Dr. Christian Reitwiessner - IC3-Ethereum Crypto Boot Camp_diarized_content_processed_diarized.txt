00:00:00.250 - 00:00:59.034, Speaker A: You. So this talk is about how we can use formal verification for smart contracts, especially written in solidity and as an introduction. What is the actual problem we're trying to solve? Writing code correctly is very hard. And if we say that, we have to define what correctly means, and that's basically code is correct if it does exactly the same thing as you think it does. So the key goal here is to align your mental model with the machine model. Align what you think it does with what it actually does in the real machine. And what is usually done to get a better safety there, a better probability that this alignment is met is to use tests.
00:00:59.034 - 00:02:01.250, Speaker A: And what tests do is you take your code, you run it on the actual machine, or on a machine that is very, very similar to that, and try it out for several inputs. And before you run the test, you think about what the actual output should be, and then you compare the actual output to what you thought it would be. And if everything matches, then the test pass. And that way you can test desired behaviors. So you can test that a contract does a specific thing, but this is something different from testing that it does not, something you do not want it to do. So it's very hard to check the absence of undecided behavior. So for example, for a token contract, it's very easy to test that when you move a token from a to b, then it actually moves to b.
00:02:01.250 - 00:03:12.490, Speaker A: But what is very hard, or even impossible to test, is that there is no way to somehow move some tokens to be without all the checks you want to be in place. And the reason for this difference is that testing is done only on a finite amount of cases, only on a finite set of inputs. Only these inputs you specified. Yeah. And getting code correct is even more important for Ethereum than for other software projects, because Ethereum is very similar to a traditional web service open to anyone, anyone can use it. So any attacker can lurk in some shady corner and use your web service or your DAP in a way you did not anticipate. And for Ethereum, the source code is often available, which is good, because people can also look at the source code and see whether it does what it says or what the developer says it does.
00:03:12.490 - 00:03:58.726, Speaker A: But it's also bad, because if an attacker finds. So it's easier for an attacker to find a flaw in the source code than in the bytecode. And yeah, we all know one of the prominent examples of this thing is the DAO. So how can formal verification help? Here's a very, very simple and actually shortened example of a token contract. So it's incomplete, of course. And it has a state variable called balances, which stores the balances of the persons, and a transfer function which allows you to move tokens from one account to another account. So this is incomplete.
00:03:58.726 - 00:04:47.148, Speaker A: It doesn't have any access checks. Yeah, and it only checks that the balance of the from account is larger than the amount. And if that is the case, then it subtracts the amount from the from account and adds it to the to account. Yeah. There's an easy bug that can probably be spotted here, which can perhaps be found by testing. But there's another error in this implementation which can probably not be found by testing. Does anyone see the two bugs? Oh yeah, missing selencolong.
00:04:47.148 - 00:05:12.118, Speaker A: I didn't compile it. Sorry about that. But that's not what I meant. Yes, greater than equal to. That's the easy bug that a testing could have found. But then there is another bug, which is. So depending on your use case, this second bug might not be relevant, but you can't be really sure.
00:05:12.118 - 00:05:53.060, Speaker A: This is supposed to be a generic token contract. Exactly. Overflow. So if we transfer a gigantic amount, then we might get an overflow, and some balance counter might overflow get negative, which means that it results in a really big positive number, and that's not what we want. Yeah. So if you only run the test with smaller balances, this overflow cannot be caught. So you have to think about also trying big inputs for the transfer function.
00:05:53.060 - 00:07:18.154, Speaker A: And what formal verification do is it can kind of test a program on all possible inputs and all possible states, not only the ones you supplied. And a simple example of what formal verification can do for you is you can ask whether the transfer function changes the sum of all balances. So what we want a token contract to do is that the transfer function changes individual balances, but the sum of the balances can never be changed in the whole contract. And an overflow in some of these operations would of course change the sum of all balances, and that would be caught by the framework. What happens in general when we talk about formal verification? We provide formal statements like the one on the previous slide that says the sum of all balances is not modified by the function. And then we prove that the code satisfied the statement. This proof can of course be done manually, like a regular math proof.
00:07:18.154 - 00:08:20.290, Speaker A: But since we live in 2016, we can also use automated proofers to solve this task. This is of course, I mean, formal verification has a long history and existing tools. There are existing tools for many languages, for C, we have a tool called pharmacy for Java. There's Krakatoa for Adda, which is a language targeted, specially targeted formal verification. There's spark. The first three languages actually use the same tool, which is called y or y three. And the spin and promela use a different method to a different approach that more addresses concurrent executions and interleaving transactions.
00:08:20.290 - 00:09:20.678, Speaker A: We will focus on the way the first three approaches or the first three items work. And if you use that, then usually you write a program in an existing language. So a program in C or in Java, and you annotate it with pre and post conditions in the comments. So you add your mathematical statements that you want to be proved in the comments, and then the framework takes the program and compiles it into another language, thereby adding these comments, these conditions into the compilation result. And that compilation result is, as I said, often a language called y three. And then there is a verification condition generator that generates the actual tasks to be proven. These are, I mean many hundreds depending on your source code.
00:09:20.678 - 00:10:22.906, Speaker A: And then automated provers are invoked that verify these conditions one by one. Okay, that was a bit dry. Let's see an example. So this is pharmacy code that verifies a routine which computes the winner of an election in the variable called. So it's only a short snippet from a larger program, and the variable called counters contains the actual votes. And in this C function, you see that you have a loop and it loops over the candidates and just finds out the candidate that has the most votes. So it starts with winner being one, and then if it finds a person with more votes, then it updates this winner variable and returns it.
00:10:22.906 - 00:11:31.102, Speaker A: And in the comments you have these annotations I talked about. Most of these comments could be inferred from the. So it looks a bit complicated, I have to admit, but I think most of these comments could be inferred from the source code directly. So for solidity, for example, yeah, this invariant that I is between two and max candidates, that could be inferred from the loop directly. And I'm also not sure whether this invariant is actually necessary. But what you see here is that that's perhaps the most important one. So the whole function ensures that for all the candidates, the number of votes of the result of the winner is at least as large as the number of votes for that candidate, which means the maximum of this counters array is assumed at the index result.
00:11:31.102 - 00:12:30.130, Speaker A: And that's what we want to do. We want to find the winner of the election. And this is what the prover proves, and to help it, you specify these loop invariants. For example, here, this one, this one looks very similar to the one above, and it just says, if we are at step I, then the current winner is at least the maximum of the one we already looked at. And then by induction you can prove the global result. Okay, how does that work in solidity? Here is a simple contract, that kind of, yeah, a very simple contract. That kind of models a crowdfunding contract.
00:12:30.130 - 00:13:21.918, Speaker A: We don't have access control, we have just a variable called shares, which models the amount that is owned by a person. And we actually only have one person, and we're also missing the access control. But the point here is that we want to prove that this withdraw function is safe against reentrant calls. And that was one of the main bugs exploited in the DAO. And what this withdraw function does is it checks if the amount we want to withdraw is less than shares. There's again the same problem, which should be less or equal. And if that's the case, then it subtracts the amount from the shares and forwards this amount of ever to the sender.
00:13:21.918 - 00:14:21.058, Speaker A: And since we use call value here, not send it forwards enough gas to the sender so that the sender can again call withdraw. This implementation is correct because it removes the amount from the shares before it forwards the other. If we move that line to after the throw, then this would be exploitable. Okay, above the contract. We again see annotations here. So that's a condition that will be proved. And what it says is that, okay, if such a condition is above the contract, then it will automatically be applied to all functions within the contract.
00:14:21.058 - 00:16:16.220, Speaker A: And if such a statement is true for all contracts, for all functions within the contract, then anyone calling from outside to anywhere in this contract. So it's not possible to modify the state of the contract, which, okay, how do I explain it? At best, let's perhaps look at the condition first. So it says that the value of the shares variable before the function call, that's what old does, minus the old balance, is equal to the same difference after the function call. This means that the difference between shares and balances between shares and balance, which should be zero, but could also be different, does not change when we call withdraw or when we call any function of the contract. So this means when we get a recursive or a reentrant call because of this call value, then this reentrant call also has to respect this invariant, which means that after this function call here, so we have to assume that the state changed because it could potentially change, but we can assume that it changed in a way that still satisfies this invariant. And we will see that this suffices to show that the invariant is still met after this call value returns. Okay, are you still there? Let's see what actually happens.
00:16:16.220 - 00:17:05.942, Speaker A: Let's copy that source code here and go to browser solidity. So you probably know that that's our browser based development environment for solidity. And I paste this code here and yeah, we recently added this new tab with the tick symbol here, which is used for formal verification. It generates the source code here. I will copy that. You still have to manually copy that to a tool that understands y three, but we will provide some automated integration later. This is the link here, which is also shown in browser solidity.
00:17:05.942 - 00:17:38.374, Speaker A: And we paste that here. And that's some source code which looks similar to the one we had before. It also has withdraw here it has shares, and here it computes shares minus amounts. And now we click on these wheels here and we have to wait for a while. Oh yeah, there it is. Let's do it again. It generates tasks and proves them.
00:17:38.374 - 00:19:16.734, Speaker A: And there are green ticks everywhere, which is a great thing, but what the heck actually happened? What does it say when it has this green tick? So to better understand this, we can right click here and use split and prove. Then it will show us the individual steps it used, or not the individual steps, but the individual conditions it proved. And we see their integer overflow. So that's a great feature because for every arithmetic operation it checks whether there might be an overflow or not. And we cannot have an overflow here because we had this check here, and if we remove the check, it will not verify that condition. And then we have another interflow over here, integer overflow here, which comes from the fact that, so we forward the amount to the sender, so we send out the other, and that's actually an internal code that was auto generated that checks whether we actually have enough balance in our account. And then the interesting things are the post condition, the three post conditions here we only prove one post condition, but it generates three proof tasks because we have conditional execution here.
00:19:16.734 - 00:20:26.760, Speaker A: So depending on which path we end up in, it approves different conditions. If you look at one of them in detail, if you click on one of them here and then click on task view, you see what kind of code it actually generates for the prover. And that's a bit complicated because it includes all the assumptions about integers and sets and maps and so on. But the interesting stuff is usually at the end, which is here. So this is the post condition we had that the difference before the call is equal to the difference after the call. Yeah. And how much time do you still have? Okay, then let's go a bit into detail about, um, how we model this, this reentrant call thing.
00:20:26.760 - 00:21:28.282, Speaker A: Any interaction with an external contract currently still ignores the effect of the state changes in the external contract. Then it only models potential state changes in the current contract. And this is done by calling a function that's called external call. And external call is defined here, and it takes the current account, and it ensures that if the result is false, which means it threw an out of gas exception, for example, then nothing changes, it might change this. So the current account, and it also ensures that the invariant we specified holds. So any modification to the current contract satisfies the invariant. And yeah, that's the only thing it can assume about the current state.
00:21:28.282 - 00:22:58.194, Speaker A: And after this call to external call, this can be modified arbitrarily. Okay, so what are future steps for formal verification in ethereum or solidity in the very near future? So the next two weeks we will try to verify the example implementation of a token contract we use. And yeah, of course we have to model the MSG part of solidity, so MSG sender and we have to model when someone sends the contract, either that it can accept or reject it and so on. Then after that, multi contract conditions, so interactions between contracts that actually update the state of the other contract. And so what has to be said is that this method only allows this alignment between the mental model and the machine model, so it only helps the developer find bugs in their implementation. It does not help finding bugs in the compiler. And for that we need to correlate the actual model, the actual formal model that is created using these conditions, with the formal model that can be created from the bytecode that's also an upcoming task, and then multitransaction conditions.
00:22:58.194 - 00:23:45.618, Speaker A: So for example, conditions that say it will never be possible to get into a state of the contract where it's stuck and you cannot call any functions anymore. That's the basic roadmap for the future. In comparison to languages like C, we are very lucky because in the ethereum virtual machine there's no concurrency. We have a very simple virtual machine, and for now also very simple programs. And the solidity language is, in comparison to C, extremely simple. And so yeah, I hope that formal verification will be very, very useful in that area. Okay, that's it.
00:23:45.618 - 00:23:48.350, Speaker A: Thank you for your attention.
