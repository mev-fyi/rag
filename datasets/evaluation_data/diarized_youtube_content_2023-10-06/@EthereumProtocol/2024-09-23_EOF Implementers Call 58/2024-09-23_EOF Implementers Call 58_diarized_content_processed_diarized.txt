00:00:00.520 - 00:01:01.495, Speaker A: This is EOF implementer call number 58. It is the 18th of September. As far as agenda, some of the items that I think we need to discuss are devnet readiness, tracing support which was mentioned last week two weeks ago has contract is contract ext call return codes and probably finish up with a discussion about the PETRA split which they're going to make a decision about tomorrow and get people's opinions on it. Battery low Ziad can you mute unless you're talking? Thank you. So let's go ahead and start at the top of the agenda. Client updates. I have a PR out for Gethsemane that brings them up to 100% on the state tests and they've been at 100% for the validation tests.
00:01:01.495 - 00:01:26.629, Speaker A: There was a fuzzing finding that was fixed and is also part of that patch too for validation. Basu, there's one test that is failing in the test harness strictly as a test harness issue. That's a zero length EOF validation, so there's no substantive breaks there. Next on my list, Ben Adams. Do you have anything for nethermind?
00:01:26.797 - 00:01:40.585, Speaker B: Yeah, we have 19 tests fail mostly in the container tests every work how we're processing tests so they're easier to work out what's going on and run them individually.
00:01:41.405 - 00:01:58.355, Speaker A: Okay, yeah, I can take a look at that and see what. What's still needing to be fixed there. What, what tests are still broken then what, what tests are still failing?
00:01:59.895 - 00:02:15.965, Speaker B: Where are they? Mostly container combos. A lot of them are complaining about. K section contains return contract. I'm trying to look into what the rules are.
00:02:17.785 - 00:02:38.405, Speaker A: Yeah, yeah, that was. If you get stuck, just ask for questions on the chat room. We've gone through that quite a bit, so we're probably familiar with the breakages you're seeing and how the scenarios and how that might be fixed. Ref Dragon, do you have any updates?
00:02:39.805 - 00:02:43.145, Speaker C: Nothing new basically. Yeah.
00:02:43.965 - 00:02:47.585, Speaker A: Yeah. You've been clear with the frog based state test for a while?
00:02:48.805 - 00:03:03.025, Speaker C: Yeah, I updated revme execution binary. It will now transition. If the Prague state test is basically given, it will activate Prague.
00:03:05.175 - 00:03:06.487, Speaker A: Okay, that's good.
00:03:06.631 - 00:03:07.395, Speaker C: Yeah.
00:03:08.495 - 00:03:16.035, Speaker A: So I haven't run a bulk execution of all the tests in a while, so I should probably do that tomorrow or maybe today while I'm up at the conference.
00:03:17.775 - 00:03:27.915, Speaker B: Just a note on Prague. So we're running as if we're on Prague, but we haven't had the Prague fork merged yet.
00:03:29.665 - 00:03:52.725, Speaker A: So that's a discussion for one of the other items we're going to discuss later whether it's going to be Prague or Prog 2 or Osaka. But whatever that one is, whatever we decide tomorrow in acd, I think we should get all our stuff set to work on. That's. That's one of the hot discussions. Maybe we could just have that discussion now. Let me get ypsilon. Anything on EVM1?
00:03:57.515 - 00:03:59.215, Speaker D: No, I don't think so.
00:03:59.875 - 00:04:42.504, Speaker A: Okay, and do we have anyone from. I don't see anyone from gas. Do we see anyone from Ethereum, JS or Aragon? Nope. Okay, so let me where would my agenda. Where my copy agenda go? So I guess the question should be devnet readiness. Do we feel that we're going to be able to make a devnet in 2 weeks time? I think we're almost there. The only question that I see is whether it's going to be Pectra or Saka or Pectra 2.
00:04:42.504 - 00:05:02.315, Speaker A: Anyone? So let's go ahead and open the floor for the discussion on what people think about the the proposed pectoral split. Feel free to share opinions. You know what, whatever your thoughts about it are.
00:05:07.335 - 00:05:35.055, Speaker C: From red side, we would prefer it's if it is only one fork, but we don't mind if they split into for the naming. To be honest, it's mostly like bike shedding and in the end it would matter a lot. Maybe call it Osaka because that's how we call the next fork. I don't think other than Guillermo Mode there is nobody else opposing that.
00:05:37.835 - 00:05:51.125, Speaker A: Okay, Would moving it out and separating EOF from the other product features cause problems for any of the implementations? How intertwined is this with your implementations?
00:05:55.785 - 00:05:58.405, Speaker B: It isn't at the moment, but it probably will in a week.
00:06:00.785 - 00:06:03.605, Speaker A: I'm sorry, could you repeat that? I had some noise in my background.
00:06:04.025 - 00:06:11.845, Speaker B: It isn't at the moment, but it probably will be in a week or two when Hector merges to our marketing.
00:06:12.705 - 00:06:18.765, Speaker A: Okay. Would it cause undo problems or is it something that can be managed?
00:06:19.385 - 00:06:25.885, Speaker B: I think it can be managed. The only issue is like I sense horrible merge complex.
00:06:27.065 - 00:06:27.925, Speaker A: Okay.
00:06:30.905 - 00:06:48.655, Speaker C: On Arabian sites we already have UF merged so. So there is only one place where we need to enable UF and that's it in transaction creation. Create tick transaction. Yeah, that's the only place where you can enable it.
00:06:49.715 - 00:07:00.935, Speaker A: Okay. So that's good info to be aware of going in tomorrow. So it won't. Won't ruin our day. But there is preference to go as one but not stop the split preference.
00:07:02.555 - 00:07:18.415, Speaker B: Yeah, and I have a problem. What I mean is the complexity will occur because we will be on top of Petra if you see what I mean. Rather than. So it wouldn't matter whether we split or don't split either way.
00:07:18.995 - 00:07:19.771, Speaker A: Okay.
00:07:19.923 - 00:07:25.775, Speaker B: Because I assume EOS is not suddenly going to jump in, in front of the rest of Patriot.
00:07:27.045 - 00:07:37.305, Speaker A: No, not yet. I would be surprised if that happens. 7702 kind of jumped the line, but hey, whatever. Okay.
00:07:37.605 - 00:07:57.825, Speaker B: With, with regards to splitting it, I, I'd be okay with that, but I wouldn't want Petra to. To follow the normal cadence of like, you know, trend B a year after. I want it to come in fairly soon.
00:07:59.165 - 00:08:02.065, Speaker A: Fairly soon. What's your ideal of fairly soon?
00:08:02.525 - 00:08:14.581, Speaker B: I don't know how long the Devnet testing process is, but hopefully under six months, if not sooner. Okay, but entirely.
00:08:14.773 - 00:08:15.165, Speaker A: Yeah.
00:08:15.205 - 00:08:24.955, Speaker B: I don't know how long. How long it goes from Devnet zero to live.
00:08:25.735 - 00:08:32.635, Speaker A: Right. And that aligns with my expectation. I was thinking the number I was thinking was one and two quarters, which is six months.
00:08:35.335 - 00:09:01.151, Speaker C: Just want to say idea, main, basic idea for the split is to speed up the process so we can. Yeah, that's the main reason why we are splitting. So even if the splitting is going to prolong the hard forks, I'm not sure if they. What's the benefit of the split? Maybe it's easier to test, but.
00:09:01.223 - 00:09:07.995, Speaker B: Well, I mean, forks like to grow, so that's, that's the risk.
00:09:09.175 - 00:09:13.161, Speaker A: Yeah, go ahead.
00:09:13.193 - 00:09:18.725, Speaker B: Bring it as soon as. Bring it in as soon as possible because we're all kind of ready, as it were.
00:09:20.825 - 00:09:45.335, Speaker A: Yeah, because there's. There's also pressure to bring the SCP256R1 curve. There's pressure to reprice data, there's pressure to uncouple the blob counts, but that could probably be tied up with a pure dash shipment. There's. There's a lot of things that people. A lot of urgent needs starting to develop for some of these. So if we do split it, I do think it will grow, but the trick is to keep it under control.
00:09:45.335 - 00:10:01.895, Speaker A: Okay. Anything else we want to say about the split before we move on to the other parts of the agenda? Ben, you're off mute. Do you have something?
00:10:03.325 - 00:10:04.065, Speaker B: No.
00:10:04.685 - 00:10:19.385, Speaker A: Okay, if you think of something, drop it in chat and we can discuss it near the end. Eels. Eels is here. We didn't go through them in the client. How are you going with your implementation?
00:10:20.525 - 00:10:35.335, Speaker E: Yeah, so we're basically. We just had all the EIPs implemented. We are passing all the tests and all the latest tests. So yeah, we're good. Actually. The PR is still under review. Though that's the only caveat.
00:10:35.335 - 00:10:42.115, Speaker E: But in terms of coverage, we've we've got everything, the UF tests and the blockchain tests.
00:10:42.855 - 00:10:59.965, Speaker A: Awesome. Wait a couple days before you press merge. Oh, yeah, absolutely. Next on the agenda, we've done client updates about compilers. Charles, do you have anything?
00:11:06.025 - 00:11:15.245, Speaker F: That's a really good question. I don't think we have anything right now. I've been away for a little while, so I'm still getting back up to speed.
00:11:59.525 - 00:12:51.935, Speaker A: All right, and the next is spec updates. So we have three items that I need to discuss. The first one is tracing. How's everyone's. Has anybody been working on their tracing stuff as part of this yet? Okay, so one of the testing features we're going to need, whether it's before or after UF ships, is we're going to need to get high quality fuzz testing. And one of the things that I think is important to get this high quality fuzz testing is we need to have good tracing. I think most of clients have tracing, but I think there's a few fields that need to be added to make sure that we get measure if we're having any fuzz differences.
00:12:51.935 - 00:13:36.455, Speaker A: And the most valuable fuzzing findings we've had have not been ones where the final answer is correct or incorrect. It's where we discover differences within as we get to there that ultimately wind up being the same. But in the middle we find problems when we run the fuzzer and some of those can be rebuilt into viable exploits. We've seen that historically. It's been a few years since we found a good one that could work that way. But those are the sort of things we're finding with fuzzing and why we do trace level fuzzing. So as far as our fuzzing for EOF, I have an EIP here, number 7756, where I'm proposing some changes to the existing standard tracing.
00:13:36.455 - 00:14:35.491, Speaker A: And that's basically adding a few fields, adding the section field, adding the immediate field and adding the function depth. I think that's all that I have added. I think I added explain in the rationale, immediate section of function function depth, depth and also clarifying the PC should be zero within the code section when it's present, not like against the zero index of the container or the zero index of all of the code sections. Now that particular issue is going to have some interaction with Verkal. So that's where, you know, having zero, I guess container might be useful, but that is something that we can you know the right now that the standing is a zero against code section. But this is currently in draft state. Where's the header information? Draft.
00:14:35.491 - 00:15:02.827, Speaker A: So yeah, this is in draft. So anyone has any comments about this, feel free to chime in. This is far from frozen. BASU does have it implemented, but I'm more than happy to adjust it if we think we have. If we need. Think we need to change it. Any comments? Never mind.
00:15:02.827 - 00:15:10.295, Speaker A: Do you have tracing implementation as part of your state test and block tests?
00:15:12.235 - 00:15:18.255, Speaker B: Yes. We do not. We haven't made any changes for you.
00:15:19.475 - 00:15:32.095, Speaker A: Okay. And I know ref has it because I started the patch that got cleaned up and finally submitted. Geth has it too. Does Eels have tracing? I guess is a good question for Guru.
00:15:33.155 - 00:15:42.815, Speaker E: Yeah, Eels does have tracing but we just need to adapt these extra fields to be able to support everything with eof. So we've done that.
00:15:44.275 - 00:16:09.565, Speaker A: Cool. And Mario mentioned the tracing might be useful for T8N. I think there's hacky ways to go at it, but I think yeah, we should probably integrate it in a T8N. Have like a designated output because this is where the real value comes in is also in testing. And the fuzzy solutions I've seen tend to use state tests and block tests as their basis. Powell.
00:16:10.625 - 00:16:48.495, Speaker D: Yeah. Are you going to actually apply it to any funding yet or it's. I think we can get something in this shape if that unblocks some testing. I think that's good idea. I don't specifically like the section but it's not difficult to implement. It just kind of feels inefficient in a way that we don't really split execution into sections.
00:16:51.395 - 00:16:53.335, Speaker A: Can you elaborate on that?
00:16:54.875 - 00:17:46.995, Speaker D: Yeah, if you consider like code sections they're just. Because I just adjusted to each other. You can pretend like the all code sections is like one executable code. The interpreter just goes over that because validation handles of all the like nasty cases. So yeah, if you've considered like how easy M1 things where it is currently in the code it just knows the kind of code pointer that is relative to the first code section. Like the beginning of the first code section and so on. So like to actually compute what the section it is, I would need to have some kind of lookup table.
00:17:46.995 - 00:17:58.677, Speaker D: So it's not complicated. It just seems if you want to produce that all the time. Unless I will just. Yeah, maybe I'll just remember that somewhere.
00:17:58.741 - 00:17:58.933, Speaker A: Okay.
00:17:58.949 - 00:18:02.145, Speaker D: I need to think about it but okay.
00:18:02.565 - 00:18:35.985, Speaker A: Because the reason I put that in is we need to be able to Validate that call lefts and jump Fs are appropriately co located. Now if everyone was not using sections in zero based off of something, we would still get the same signal and everyone would agree because this is designed for differential testing. So yeah, so if we were all zero based off of the code index or the container index and I, you know, if we're going to zero based off of something other than your current code section, I would think we might want to do container index because that's really going to pay off dividends for Verkal.
00:18:41.325 - 00:18:48.615, Speaker D: Yeah, when I started to think about it, I think maybe it's not so bad. Okay.
00:18:48.955 - 00:18:49.355, Speaker B: Yeah.
00:18:49.395 - 00:19:05.095, Speaker D: I think we might try to make a prototype that we have some tracing like for basic EVM and it has been used in this kind of fuzzing.
00:19:05.875 - 00:19:06.579, Speaker A: Okay.
00:19:06.707 - 00:19:19.105, Speaker D: So we can try to set up. Do you use Go even Lab, for example? I think we were integrated there and I guess we can try to kind of modify it.
00:19:19.525 - 00:20:03.355, Speaker A: If you have alternatives, feel free to discuss them in the Eth Magicians or in the Discord chat. I'm not locked into this at all. I'd rather have discussion and change it than have no discussion and no adoption. All right, so next is HAS code IS contract. Does anyone who's been paying attention to AA want to summarize that concern?
00:20:05.305 - 00:21:17.635, Speaker G: Yeah, I can give a quick summary. So on Discord in the future UA channel, there's a discussion where the account abstraction perspective has been described and also there's a response from the proponents of HAS code instruction. So best to go and read through that. But I think as a quick summary that the problem with AA is that with HESCODE or currently with Axco size, there's a pattern or anti pattern that some contracts prevent non EOA accounts from participating in various forms and for various reasons. And you know, the, the existence of such patterns would slow AA adoption. This is the claim. And also on the other hand there was also the claim that the ERC721 case could be better solved with the application of ERC165, which is supports interface.
00:21:17.635 - 00:22:02.725, Speaker G: Yeah. So for the details, refer to the Discord discussion. On the other hand there's, I mean there's a counterargument that actually the AI adoption is slowed down by something else, namely the lack of adoption of smart contract signatures. And also a counterargument that the so to speak, bad patterns would still be possible even without HAS Code. So yeah, I guess just recommend to read through that discussion on Discord for details. But I think there's no no conclusion yet.
00:22:11.345 - 00:22:12.401, Speaker B: That's it.
00:22:12.593 - 00:22:29.895, Speaker A: Okay. Kind of a meta discussion Separate. Assuming that the AA thing doesn't derail this eip, where does this stand with the split? If Pector were split in two, could this be put into the first release of eof?
00:22:34.595 - 00:23:32.735, Speaker G: Hard to say. I think the main reason for having a separate EIP is just to discuss when to have it right. And we have some preference for it not to be shipped in the fork where I mean until the split we were. We didn't like the idea of shipping it in the fork where EOF ships to be able to gather more insights or data and also not to inflate the scope. Now with the split, I think I mean the sort of mixed feelings because the split is partly because of the scope being too large. So I don't know. I guess we still would like it not to be coupled with the rest of the.
00:23:35.325 - 00:23:39.345, Speaker B: It isn't a very large change.
00:23:41.165 - 00:23:58.345, Speaker G: No, I mean we are kind of responding to the ACD complain that there's too many opcodes and too much complexity and with that. But I guess, I mean the split changes the situation a bit.
00:24:01.015 - 00:24:01.567, Speaker A: Okay.
00:24:01.631 - 00:24:04.515, Speaker C: In general. In general I would like to include it.
00:24:06.495 - 00:24:25.995, Speaker B: Yeah, I would too because it mainly because it sort of makes some of the requirements the ERC is impossible so therefore it would may resist adoption of yellow or something.
00:24:44.035 - 00:24:53.495, Speaker A: Mostly open Z because I don't want to look figure out how to spell Zeppelin here. Okay. Anything else that people want to say about has code.
00:24:57.015 - 00:25:21.215, Speaker B: Instead of open z go for ERC 721 5. What was the example again? ERC 721 and ERC 1155-1155.
00:25:22.995 - 00:25:26.575, Speaker G: Are there any other examples of this pattern?
00:25:27.235 - 00:26:02.691, Speaker B: I think so. I mean there's. There's been complaints about the pattern that you. It's not generalizable but yeah, it's a where. Where. Where you're sending it to a smart contract then you call a function on it to see whether the smart contract understands the type. So that you don't send NFTs to smart contracts.
00:26:02.691 - 00:26:03.971, Speaker B: Will they be lost forever?
00:26:04.123 - 00:26:10.175, Speaker G: I mean are there any other examples beyond these two ERCs that have been reported?
00:26:13.485 - 00:26:44.285, Speaker A: No, I haven't heard of any other requirements for differentiating between the two but that's, you know, as been pointed out because they have a particularly weird use case that smart contracts must be willing to accept the token via those APIs and in their absence EOAs can accept them. So if we don't have that then you run the risk of either a locking NFTs and smart contracts that can't send them out or B not being able to share them with EOs.
00:26:45.745 - 00:27:06.725, Speaker B: I think there was one for tokens, but the issue with that is people use them to do what you call it flashlight in the callbacks and they didn't really get catch on the phone.
00:27:11.985 - 00:27:18.725, Speaker A: Defy. I mean, okay, breaking D5, but you know, that's, you know, probably not gonna fly anyway.
00:27:19.465 - 00:27:43.495, Speaker F: I have a dumb question which is you always check if there's code to call, like on ERC721 received, right? But if you just always call it, then it'll just return nil data if it's an E away. And that's how you can kind of tell, I think.
00:27:43.875 - 00:27:48.215, Speaker B: But the GAS optimizers will hate you.
00:27:49.275 - 00:27:55.455, Speaker A: The GAS optimizers will hate you and your fallback might mimic an EOA and then you might be stuck.
00:27:56.755 - 00:28:10.215, Speaker G: I think that's one of the claims of the ERC 165 approach is that we want to be common, I guess.
00:28:12.035 - 00:28:58.875, Speaker F: I mean there's like a strong. I think there's actually consensus among developers I've talked to that like ERC 721 and 1155 are like actually badly designed. So if we're talking about like new, like we don't have to worry that like I don't think we have to worry that like new standards like this are going to be created. I think the concern is only whether we can make ERC721 things that are compatible with the existing standard. And I think that you can. I think if you call on ERC721 received and ever see returns, nothing, then you can like revert.
00:29:00.775 - 00:29:01.519, Speaker E: Or.
00:29:01.687 - 00:29:03.955, Speaker F: Sorry, do what you would if it were an eoa.
00:29:17.585 - 00:29:24.685, Speaker A: How would you phrase it? Provide the same protections and conformed modern practices.
00:29:27.505 - 00:29:35.165, Speaker G: Well, the same protections, like almost same. I don't. Maybe same in practice, but that's something that needs to be investigated.
00:29:36.385 - 00:29:39.845, Speaker A: Maybe. Okay.
00:29:45.005 - 00:30:02.385, Speaker F: Yeah, there's like. You can't tell if on ERC 72 unreceived is like implemented badly, as in it doesn't return data or it returns badly form data or if it's an eoa. But I, I know I kind of think that's actually. Ok.
00:30:09.535 - 00:30:18.687, Speaker A: Okay. Anything else about has code, I don't think we could. Go ahead.
00:30:18.831 - 00:30:37.225, Speaker F: The thing is like normally when you call on ERC17 received you have to like check that the return value is actually valid anyways and if it returns. I need to think about this. Sorry.
00:30:37.385 - 00:30:55.673, Speaker G: Yeah. The problem is The EOA is not going, not going to return anything and still is a valid recipient. So it's indistinguishable from a contract which just has a non reverting fallback function. Returns empty.
00:30:55.849 - 00:31:00.515, Speaker F: Yeah. And I think the AA people are like a big fan of this. Right.
00:31:03.495 - 00:31:10.955, Speaker A: And how common outside of AA is that pattern where your fallback returns a zero link string?
00:31:17.375 - 00:31:32.965, Speaker F: Your fallback should usually return nothing. Like, I don't know, like any fallback I can think of actually doesn't return anything.
00:31:33.825 - 00:32:17.745, Speaker G: Okay. I mean for the AA recipients, I guess the specific fix for that is that such a contract would support ERC 6 165. Right. And it would, it would, you know, you would be able to discriminate such case. So if you add 165 to the equation, it actually makes the problematic contracts even less common. Right. Because you might have a non reverting fallback function but still do the right thing using ERC 665.
00:32:17.745 - 00:32:20.465, Speaker G: Is that correct?
00:32:23.005 - 00:32:30.585, Speaker F: I don't think you can rely on contracts implementing ERC 165.
00:32:33.445 - 00:32:44.355, Speaker G: Well, you would. You would, I guess, have to rely on that. Wait.
00:32:46.095 - 00:32:56.255, Speaker F: Or maybe contracts can implement like is contract. It's a new standard.
00:32:56.335 - 00:32:57.315, Speaker G: Am I contract?
00:33:05.265 - 00:33:05.553, Speaker A: Yeah.
00:33:05.569 - 00:33:11.565, Speaker F: What if we get ready to implement that? Is that the same as having the pass code opcode?
00:33:13.105 - 00:33:19.525, Speaker A: So that wouldn't work with existing AA accounts like smart, like Safe Wallets. So.
00:33:23.585 - 00:33:27.805, Speaker B: That would also fail for era.
00:33:28.905 - 00:34:01.389, Speaker A: Yep. So I think we should probably table this for two weeks. This split is going to give us more insight and hopefully we'll get some resolution on the AA concerns whether we should accept it or pass on it or. And then intents and swab is like kind of on the other end of the spectrum. Hello. Okay, they muted. I don't have host preps, but they muted.
00:34:01.389 - 00:34:39.166, Speaker A: So we're good. But yeah, I don't, I don't. Hopefully we'll get some resolution on this, but we might need to push the issue and make a stand in two weeks and think about it. I think either way we roll it, there's going to be people that are going to be unhappy with the decision. So we just need to make the decision as best and I don't think we can make it today. Last thing I have on my agenda is to discuss ex call return codes. This may be jumping the shark a bit.
00:34:39.166 - 00:35:23.301, Speaker A: Not jumping the shark, jumping the gun a bit. But in the review of the Geth patch, Geth expressed concern about what type one and type two means. It started out from the concern that doesn't map neatly to their implementation, which in and of itself is not a bad thing. But when you look at what returns a return code of one or returns return code of two, it starts to not make sense and feel arbitrary. So I was wondering if we want to consider if we split Pectra, get some more logic behind what a one and a two means from an end user perspective and then back that into our implementations. Peter, you came off mute.
00:35:23.493 - 00:35:39.825, Speaker G: Yeah, I was hoping. Actually for me the distinction is just one is there's still gas and two is all the gas has been consumed. I was. I think we mentioned before.
00:35:40.965 - 00:36:10.205, Speaker A: So that's the idea. But in practice there are all gas consumes. It will come back as a 1. Which the only tests that return a 2 that we have in ESTs and then I can figure out from the code is if your return. If your return data copy calling a legacy goes out of bounds, we fail. And then the other one.
00:36:10.585 - 00:36:15.389, Speaker G: Wait, we're talking about ext call return codes, right?
00:36:15.557 - 00:36:19.505, Speaker A: Yes, yes. And the other one is equally obscure.
00:36:24.245 - 00:36:41.999, Speaker G: I mean two, all gas consumed is for when or when the call is out of gases it calls invalid. Or there's a static. Static call violation.
00:36:42.087 - 00:36:44.927, Speaker A: Data call. That's the other one. Static call violation.
00:36:45.111 - 00:36:46.911, Speaker G: And there's a static call violation.
00:36:46.983 - 00:36:57.983, Speaker A: But the out of gas failures actually come back as one, if I'm reading it correctly. Are you sure we need a test to test it then if that's what's going on.
00:36:58.159 - 00:37:22.085, Speaker G: I think. I think it should be two. I mean if it does out of gas within the KALI code. Right? Not out of gas, out of gas during. I don't know. Memory expansion should probably just unwind the stack some more, I guess. So it's irrelevant but.
00:37:22.085 - 00:37:38.935, Speaker G: Yeah, but I mean the out of gas in the KALI and static coviolation. And I think there was one more, but I cannot remember.
00:37:43.235 - 00:37:43.975, Speaker B: Vi.
00:37:51.635 - 00:38:02.877, Speaker C: I think there is one where we check the stack. I'm not exactly can. Can't remember what the call stack depth.
00:38:02.901 - 00:38:04.265, Speaker G: Is also a one.
00:38:10.645 - 00:38:12.101, Speaker C: Data stack overflow.
00:38:12.133 - 00:38:14.905, Speaker A: I guess with call.
00:38:15.605 - 00:38:45.235, Speaker D: So originally it was supposed to be that the one is for. For like user reverts. So reverts that are kind of programmed in in other contracts and anything else was supposed to be too, but then someone realized that break some. I don't know, make some like kind of. You can extract more information from this.
00:38:45.315 - 00:38:46.043, Speaker A: Yeah.
00:38:46.219 - 00:39:35.165, Speaker D: So we kind of downgraded some light failures also to one and I. It's kind of the same. I think I reported this somewhere, but maybe I didn't in the end. But it's also kind of confusing to me. It's nothing that you can quickly explain to someone else. What's this values mean? And I think it also is much less useful for. For compilers because at least to my understanding, at least Solidity was interested in having information that a call failure comes from, like programmed in revert.
00:39:35.165 - 00:39:47.805, Speaker D: And now we kind of broke this by mixing this together with something else. And I'm not sure this is actually useful for anyone.
00:39:50.055 - 00:40:07.435, Speaker A: And I think that encapsulates my concern and a concern GU is raising is what it was versus what it now has become is you can't explain it easily. And my thought is unless you can explain it in a tweet, then we need to back up and reconsider what we have.
00:40:16.865 - 00:40:27.885, Speaker B: In which case if we. If we don't change it to be more useful, then the question is, does it. Do we flip it back toward match legacy?
00:40:29.465 - 00:41:40.415, Speaker A: Right. So this is something to think about over the next two weeks. I don't think we can have a call for action today, but this, my initial red herring proposal would be if there's no split, we do nothing. And if there's a split and EOF winds up in the second half of the split, we redesign this in something that can be expressed succinctly and cleanly and we go back and reimplement the return values. But that's. That's a red herring, you know, just a prompt discussion. Okay, and the other thing do we want to discuss on this call today? Maybe.
00:41:42.875 - 00:42:06.985, Speaker B: Delegate call versus allowing delegate call for legacy contract versus being able to determine if something was an EOA contract Because there's the weird gap where you could brick proxies by proxying into a legacy contract.
00:42:14.245 - 00:42:48.085, Speaker G: I think this one is easier to work around. What are the conclusion? That this can be better solved by just making a a check in the upgrade logic where the new target is called with called with this ext delegate call and if it fails then it will revert the upgrade.
00:42:49.395 - 00:43:02.815, Speaker A: Testing. Yeah, I forgot to ask Mario about testing before I opened up the floor. Mario said in chat for testing I'm behind on PR reviews and was offline but I'm restarting the reviews today.
00:43:04.475 - 00:43:17.775, Speaker H: Yes, please, please bear up with me. I will try to finish up as many reviews as I can today. If you have anyone that is urgent, just ping me and I will try to prioritize it.
00:43:18.075 - 00:43:34.215, Speaker A: Yep. Okay. And yeah, I think pretty cool with getting Petra 3 DevNet up and running so that's understandable why you're a bit behind on that. Cool. Any other testing updates?
00:43:37.995 - 00:44:39.663, Speaker H: I think just one comment from the 7702 testing that we've been having the last couple of weeks, one of the most interesting things that we found is that many of the clients were not like handling the new transaction type like in the most adequate way. So they were basically rejecting type poor transactions. So I think and this and this was tested using East Test. It's a new command, it's called execute. I think we can do something similar for UF in the future where we execute the UF init containers in the transactions in a live network or in the devnets and we can actually automate this before we get ready for UF to be live on a devnet. So I think we can catch a lot of issues this way because it actually interacts with the JSON rpc. So this will test JSON rpc.
00:44:39.663 - 00:45:16.955, Speaker H: I mean UF contracts coming from the actual RPC JSON RPC endpoints. Yeah, this is just to let you guys know that I will probably work on converting the current container validation tests into the transaction. I already have a PR but it's not ready to merge and also this will at this same converted tests will be run using this new execute command. So yeah, I think that's the only points that I wanted to share.
00:45:18.535 - 00:45:53.961, Speaker A: So I've worked on a previous project where Ethereum equivalence was an issue and a test framework like this is awesome. I think it's going to be great for the ZK systems that are doing their own native implementations are going to run into strange things. So this is awesome. Okay, now that I hijacked the delegate called a legacy return to that. I think the summary was there's workarounds.
00:45:53.993 - 00:46:02.685, Speaker G: For it and call to legacy. Just a nitpick for the notes.
00:46:05.115 - 00:46:28.935, Speaker A: Yeah. Because if you can do a delegate call you can delegate call Legacy all you want. You can't do that in the O was was everything said about ex delegate before I or I cut it off though? Was that the conclusion based on a silence?
00:46:29.305 - 00:46:34.245, Speaker B: Yeah, just keeping it on the on the agenda as an unresolved issue.
00:46:34.865 - 00:47:18.255, Speaker A: Okay, I'll go ahead and see. All right. Anything else that I've forgotten? We got through testing. Wonder if we should move testing up earlier in the discussion. I think we should start with testing from now on. Ben.
00:47:20.155 - 00:47:23.745, Speaker B: Joint fuzzing, you were talking about that previously.
00:47:24.085 - 00:47:24.865, Speaker A: Yes.
00:47:26.445 - 00:47:29.945, Speaker B: Is there anything to discuss or be there?
00:47:31.485 - 00:48:23.055, Speaker A: We found one bug in guess but to get good fuzzing all the validation tests need to pass because the first thing the corpus is filled with is with the existing test cases and they're going to be derivative around those test cases for a while. So that's passing the reference test is I think step one. And then once there, then we. Then we plug in fuzzing. So yeah, as far as the API Nethermine's ready to go. We just need to get the that last bit around containers because the fuzzing will find that pretty quick. Is ES T set up to handle TX fuzzing?
00:48:25.395 - 00:48:26.775, Speaker H: Not. Not yet.
00:48:27.355 - 00:48:36.015, Speaker A: Okay, that's one that would be valuable for fuzzing. And also when we get to execution fuzzing, that would be very valuable.
00:48:40.605 - 00:49:07.401, Speaker C: All right, Dragon, one last buckshot before the end. This is just a IP change. What about renaming types section to something like Stack eo? In my personal opinion, types was very confusing when I started reading it. Just wanted to see what other people think about that.
00:49:07.593 - 00:49:08.905, Speaker A: What was the name you're saying?
00:49:08.985 - 00:49:16.845, Speaker C: Stack Stack IO maybe? Yeah.
00:49:40.675 - 00:49:45.295, Speaker A: Okay. Any other bike shedding requests or should we call a lid for the day?
00:49:46.715 - 00:49:53.175, Speaker F: I agree that types is confusing, but maybe like section spec or something because it might not just be ST.
00:49:59.445 - 00:50:02.285, Speaker A: Section info, was it?
00:50:02.405 - 00:50:04.545, Speaker F: Sure. Section info or section spec.
00:50:11.245 - 00:50:20.785, Speaker C: Okay, precisely should be code section info. But yeah, either way it is better than types.
00:50:23.455 - 00:50:24.955, Speaker A: Or maybe code info.
00:50:25.935 - 00:50:27.475, Speaker G: Signature maybe.
00:50:28.655 - 00:50:29.915, Speaker A: What? What? Peter?
00:50:30.335 - 00:50:31.195, Speaker G: Signature.
00:50:39.335 - 00:50:48.445, Speaker A: My concern with signatures, it might get confused with crypto. Yeah, I know, but it is, it is a better word.
00:50:48.475 - 00:50:50.525, Speaker G: Sounds like we're in a blockchain industry.
00:50:52.025 - 00:50:52.805, Speaker A: Yeah.
00:50:56.505 - 00:51:00.449, Speaker G: I was referring to this, you know, solidity signature kind of. It's not the same thing, but I.
00:51:00.457 - 00:51:02.325, Speaker A: Don'T know, it's abused.
00:51:02.665 - 00:51:03.721, Speaker G: It's abused already.
00:51:03.793 - 00:51:12.377, Speaker A: So yeah, it's overloaded. It's an overloaded phrase, but I think it is one of the better phrases. Okay.
00:51:12.521 - 00:51:20.485, Speaker B: Saying we should sign the code before, check the signature on the code before allowing to validate.
00:51:22.825 - 00:51:31.725, Speaker A: There is a deep rabbit hole. We could do with custom header types and I think a cryptographic signature would be one of them. Header size.
00:51:41.435 - 00:51:48.495, Speaker H: Okay, sorry, I was not suggesting a name. I was, I was. It was just a follow up to my question. Yeah, yeah, sorry.
00:51:49.235 - 00:51:50.055, Speaker A: Okay.
00:51:51.275 - 00:51:52.575, Speaker H: All right, thanks.
00:51:53.155 - 00:52:14.185, Speaker A: So if that's it. Any. Any other requests, any other open floor items? Going once, going twice. Like to thank everyone for participating. These open floor heads are great. I love the conversation. And that's a wave or is that a hand? Dragon wave.
00:52:14.185 - 00:52:20.845, Speaker A: All right, see everyone tomorrow on ACDE acdc.
