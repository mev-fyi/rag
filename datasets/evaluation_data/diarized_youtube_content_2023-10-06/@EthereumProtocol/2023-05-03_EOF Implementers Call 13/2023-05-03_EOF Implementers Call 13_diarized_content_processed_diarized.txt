00:00:00.650 - 00:00:00.862, Speaker A: Okay.
00:00:00.916 - 00:00:16.160, Speaker B: Hi everyone, welcome to the EOF implementers call number 13. It looks like we are a little bit low on people today, but let's go ahead and just get started with some client updates. Does anybody want to share what they've been up to in the last couple of weeks?
00:00:17.170 - 00:00:18.240, Speaker A: I'm in.
00:00:19.570 - 00:00:21.200, Speaker C: Hi, can you hear me?
00:00:22.290 - 00:00:23.134, Speaker B: Yes.
00:00:23.332 - 00:00:23.886, Speaker D: Cool.
00:00:23.988 - 00:00:51.580, Speaker C: Well, from the, from Nethermind's side, we kind of implemented the mega UiF spec. We only left out the part where we should introduce a replacement for delegate call and the other stuff because it's still vague and yeah, we're still waiting for a clarification about it and once it's done we're going to add it.
00:00:54.850 - 00:01:04.570, Speaker B: Great. Thanks for that update. Anyone else? Yeah, go ahead, Daniel.
00:01:05.150 - 00:01:59.982, Speaker A: So basically we implemented tracing based on the immediate arguments. I think we resolved it just after discussion on Discord, that when you're listing immediate arguments, you list all of them, even if it is a giant jump block because it's still going to be smaller than the memory that you're listing in the trace. So there is a new test case that I think we should put out in the validation that basic was actually failing, but all the fuzzing didn't find it has to do with a backward step into a conditional jump. It's kind of weird. I'll post it on the discord, but I think that should be added to people standard test loops to make sure that they don't get burned by this one. And we haven't done the calls or the creates yet, but we've implemented, I think, most everything else on the spec I'll go through again. Haven't written tests for them quite yet, but the tracing is correct.
00:01:59.982 - 00:02:13.410, Speaker A: So they worked in some cases, but we haven't proven them all out or done extensive testing otherwise. But I think I'm going to be putting the EOf on the shelf for a little bit while I get things ready for Cancun.
00:02:15.670 - 00:02:46.040, Speaker B: Okay, cool. Thanks for that update and we'll be on the lookout for that bug that you mentioned on discord or something. Andre, do you happen to have any updates on EVM one? Can anybody hear? Andre, if your mic is going, we cannot hear you.
00:02:46.110 - 00:02:47.240, Speaker E: Can you hear me now?
00:02:47.390 - 00:02:48.730, Speaker B: Yes, hear you now.
00:02:49.280 - 00:03:20.150, Speaker E: Yeah, we don't have much because many people are on holidays, but we did implement data opcodes and grade three is still in progress. We're doing some fixes there and adding unit tests and there was EMC release for Shanghai and EVM one release will be coming soon, but that's not directly related to. I think that's it.
00:03:20.920 - 00:04:00.960, Speaker B: Okay, nice. Thanks a lot. Any client updates I missed? Okay, cool. Compiler updates. Anyone talked to the compiler teams recently? Okay, no worries. It spec updates. Any topics to discuss regarding the specification?
00:04:17.110 - 00:04:38.970, Speaker C: There was a discussion in discord about the call x opcode. The replacements for those delegates call and static call and call. And I want to know what's the idea about it? Is it going to be added or. It was just an ephemeral discussion.
00:04:42.510 - 00:05:06.660, Speaker A: So when I first saw the call x option, we only had the three calls. We were getting rid of call code. But we had call delegate call instead of call. So the idea was to take three opcodes, put them into one opcode with an immediate. And we put all the things into the immediate argument to say what kind of a call it is. So all calls, I mean, I think all clients filter all their call opcodes. The same section of code anyway.
00:05:06.660 - 00:05:31.690, Speaker A: They just come up with different flags. We move those flags into the immediate. So that's where it came from. But the complexity grows when you consider things. If you do the pure flag approach, you get combinations even with just those three arguments that didn't exist before. You could do a delegate static call in case that makes a difference, which it probably shouldn't. Because if it's a static call, you can't.
00:05:31.690 - 00:06:00.178, Speaker A: Well, actually it's pure call. You can't read, you can't write. But static state queries might be interesting. Just that a space is not available. But then when you add other things, like if we want to add non contextual, like what 4337 needs to run its gas pricing through the entry points. When it asks a contract if it wants to pay for gas for this. You're not supposed to use things like the Block height and the gas price.
00:06:00.178 - 00:06:17.090, Speaker A: To figure out if it's acceptable. So you're supposed to take all block context out of it. So we could add a flag for that. And that provides growth for those calls like that. Without growing other operations. The downside is we've gone from four possible combinations of the flags. To eight possible combinations of the flags.
00:06:17.090 - 00:06:41.102, Speaker A: If we add in a no context flag, we got three bits we got to work through. So instead of testing four opcodes. We're now testing eight opcodes. And it could go up if we add another flag, we got to test 16. Or we need to add. In logic that says only these combinations of flags are acceptable. All others are going to result in an exceptional halt when executed.
00:06:41.102 - 00:07:18.380, Speaker A: Until suddenly we decide that they are valid and they don't generate an exception. So, Seth, I'm on a call, please. That's the issue there with going with call x is it provides a potential explosion. While we're saving opcode space, we're significantly increasing the testing surface or the exception surface. So that's my thought. I could go either way on it. I just think the worst thing we can do is to override the f series calls and give them new operations with less arguments in case we decide we're wrong on gas observability and need to restore those.
00:07:18.380 - 00:07:52.902, Speaker A: So either a new series of three call operations that take less gas, or the one with the flags. Well, the other problem with the flag is then we have the value variance. There are some that pass the value and some that don't. So we'd have multiple call depths. Call takes the value argument static and delegate don't. So I think the call x was an interesting idea, but I think the realities of all of the possible implementations make it less palatable. So I'm personally in favor of three new opcodes, but if there's support behind call x, I'd totally be behind it.
00:07:52.902 - 00:07:58.570, Speaker A: But I think the three new opcodes is the most sensible path to victory.
00:08:01.950 - 00:08:04.810, Speaker B: So that means you're kind of against Ropx.
00:08:05.550 - 00:08:07.450, Speaker A: I wouldn't say I'm against it.
00:08:07.600 - 00:08:11.578, Speaker B: I said rop. I meant call x. Yeah, I wouldn't.
00:08:11.594 - 00:08:28.900, Speaker A: Say I'm against it. I think the three calls is the better solution, but it's my number two option, so if people want it, I go for it. I wouldn't fight it at all, but I think in a vacuum I would pick the three new operations option.
00:08:30.790 - 00:08:40.754, Speaker F: I hate to see anything that increases the exception surface. We're trying to reduce it, not increase.
00:08:40.802 - 00:08:43.922, Speaker B: It, increasing the exceptions.
00:08:43.986 - 00:08:51.290, Speaker F: In which case you've got parameters to call X. Dano just explained.
00:08:52.910 - 00:09:10.670, Speaker A: Yeah, so like the call X where if we would reduce to say, instead of these eight combinations, you can only do these four combinations. If you pass in the four combinations you don't approve, we throw an exception which basically turns it into an extended two byte opcode anyway. There's new ways to fail, and really we should fail those of validation, not a runtime.
00:09:14.150 - 00:09:47.290, Speaker B: Yeah, that makes sense. Yeah. I don't know. I'm not super involved in this conversation, but I do like the idea of having some more flexibility with things. But yeah, the flags sound a bit complicated, a bit more than we necessarily need. I do like the idea of having the ability to have a static call but not access environmental variables. So I think that's a pretty important thing that we should consider, I guess.
00:09:47.290 - 00:09:50.960, Speaker B: Whether or not we do it with the call x or not. I don't really have a good.
00:09:51.810 - 00:10:24.642, Speaker A: I don't fall any direction because with the no context calls you might want it static, you might want it non static. I could see people who want non context calls where they could still write to their state values because state would be static. So I could see there's some argument there. So it opens up new possibilities. That's true. If we did do Colex, we would have to put validation rules that say only this set of immediate arguments is acceptable. But then you have the issue of the stack type changes depending upon the number of arguments depending upon the immediate argument.
00:10:24.642 - 00:10:40.240, Speaker A: But then we're just getting into what other cpu systems do. Where you do call. You just go into a different, functionally go into a different operation plane. And you have an entirely new set of 256 opcodes in the call is one way to look at it.
00:10:44.130 - 00:10:44.880, Speaker B: Right?
00:10:45.890 - 00:10:46.446, Speaker A: Yeah.
00:10:46.548 - 00:10:51.150, Speaker F: This would be the only opcode that takes a variable number of arguments.
00:10:52.050 - 00:10:54.062, Speaker C: I think there's other ones.
00:10:54.196 - 00:10:55.470, Speaker B: Is there jump?
00:10:56.210 - 00:10:58.862, Speaker C: Yeah, I think takes a variable.
00:10:59.006 - 00:11:00.990, Speaker B: It does. It's a jump table.
00:11:01.150 - 00:11:04.470, Speaker F: I don't mean that's immediately on the stack.
00:11:06.730 - 00:11:07.480, Speaker B: Okay.
00:11:11.050 - 00:11:39.120, Speaker C: Well again, when we think about it, we are not having an opcode with an immediate. We are having a multibyte opcode. So they are different opcodes. So each one of them has a specific number of items in the stack. It just seems like it has a variable number in the stack. That's how I see it or how I understand it.
00:11:40.530 - 00:11:43.380, Speaker F: What other byte opcodes do we have?
00:11:44.230 - 00:11:45.090, Speaker A: None.
00:11:45.510 - 00:11:50.530, Speaker F: So we're introducing a whole new concept just to spare some opcodes.
00:11:51.830 - 00:11:54.360, Speaker A: I think we'll get there. I don't think we're there yet.
00:11:58.990 - 00:12:41.478, Speaker C: I guess either way, I think this is just the suggestions that I forgot the name of the guy who said it. Sorry. Having two new opcodes seems logical. If we are not expecting for like. If we are not expected to add extra limitations or context for the opcode. At least that's how I understand it. If we are going to add a lot of other contexts, probably call x would make sense.
00:12:41.478 - 00:13:01.120, Speaker C: But if we are only going to have the placements for call and delegate call and static call. Then having three new opcodes is better. Keeping the old opcodes with different behavior sounds like the worst option. So yeah, that's my take on it.
00:13:01.650 - 00:13:37.930, Speaker A: So one thing that crossed my mind. If we do need that new context recall. You could still stack them and still get the same effect as the call with both flags flipped. You would do a static call into a redirect method that would then do a context free call. So now in your frame you'd have both flags set that it can't do static and it can't access context variables. So the frame can have the flags and you just stack your restrictions. Delegate would be the one complication.
00:13:37.930 - 00:14:37.790, Speaker A: Because you can combine a delegate with a static and a delegate with a context free, which. No, you just have to do the delegate last. If those are needed spaces, I think they're solutions. I'm not certain those are needed spaces yet. So yeah, I think everyone here is mostly agreeing with the three new opcodes. What are the numbers? E zero, e one, e two. E-C-D-E-B-A list of op goods.
00:14:37.790 - 00:14:48.590, Speaker A: The e block is empty. Because I'll be honest, I could see people wanting these gas recalls in legacy.
00:14:54.450 - 00:15:00.880, Speaker B: Yeah, the e block looks pretty good.
00:15:13.390 - 00:15:14.042, Speaker A: It.
00:15:14.176 - 00:15:19.020, Speaker B: Although there are still quite a few in the f block that's available.
00:15:19.710 - 00:15:25.020, Speaker A: We could do f block as well. Is there space for three more?
00:15:25.650 - 00:15:28.000, Speaker B: Yeah, it looks like f six, seven, eight.
00:15:30.290 - 00:15:32.080, Speaker A: Let's do f six, seven, eight.
00:15:32.450 - 00:15:48.100, Speaker B: Yeah, that's probably nicer. Okay. Let's tentatively say those three new opcodes. Does that sound good, everyone?
00:15:49.510 - 00:15:53.800, Speaker A: And then what's the order? Call. Delegate call. Static call.
00:15:55.450 - 00:15:56.920, Speaker B: Yeah, that looks good.
00:15:58.250 - 00:16:05.382, Speaker A: And then it leaves f eight, f nine. F. Why was f eight picked for static call?
00:16:05.516 - 00:16:16.990, Speaker B: It's a good question. Yeah, I was just looking at that. Let 214.
00:16:33.990 - 00:16:46.582, Speaker A: Would be call with the binary. Yeah. F nine is just so random. Fa is so random. Let's go. Six, seven, eight. Call.
00:16:46.582 - 00:16:52.520, Speaker A: Delegate call. Static call. And we've what? Call two. Delegate call. Two. Static call two.
00:16:53.310 - 00:17:01.580, Speaker E: There's also create three. Create four and return contract. That should be close in the f range, I guess too.
00:17:03.870 - 00:17:16.640, Speaker A: I think we should have those in the e range because the e range or the b range. The b range seems to be composed of entirely eof related calls. Let me go back to my.
00:17:19.030 - 00:17:20.690, Speaker B: Switch back to evm.
00:17:32.650 - 00:17:37.670, Speaker A: If we have a block that is for eof only, I would want it to go. If those are eof only codes.
00:17:40.570 - 00:17:42.070, Speaker B: Where's my branches?
00:17:43.610 - 00:18:15.284, Speaker A: Eof two or call. Return call. F return up. Jump f. What were three and four? Those I don't have on here. B five is dupen. B six is swap.
00:18:15.284 - 00:19:04.370, Speaker A: N seven, eight, nine. A is data load. I'm looking on the wrong branch. I had b three and b four down before it were there's t store or b three and b four. T store in t load.
00:19:08.550 - 00:19:11.780, Speaker B: Yeah. B three. B four is t load. T store.
00:19:12.090 - 00:19:19.240, Speaker A: Okay, so we got some non eof stuff leaking in.
00:19:22.890 - 00:19:24.540, Speaker B: We can still change it.
00:19:29.870 - 00:19:42.560, Speaker A: I think we should pitch it. Everyone's got the t store implemented, but once we get the reference specs, everyone will get it, right? If we were to move it out of b, where would we move it?
00:19:49.570 - 00:19:50.946, Speaker B: Yeah, that's true.
00:19:51.048 - 00:20:18.330, Speaker A: Because the fives are full, the fours are context ones. Basically. Threes are full. Two is crypto, one is math, zero is math. Six and seven are push. Eight is dupe. Nine is swap.
00:20:18.330 - 00:20:32.640, Speaker A: A is log. Three is six and seven.
00:20:35.410 - 00:20:36.670, Speaker B: Those are empty.
00:20:37.090 - 00:20:52.146, Speaker A: No create. Three is tagged at f six and create. Four is tagged at f seven. Eight. Nine. B eight is call. Nine is delegate call.
00:20:52.146 - 00:20:57.110, Speaker A: And b is static call. So the call twos follow the original calls, which is kind of cute.
00:20:57.610 - 00:20:58.840, Speaker B: That is nice.
00:21:06.830 - 00:21:08.060, Speaker A: Should we do that?
00:21:08.750 - 00:21:10.220, Speaker B: That sounds good to me.
00:21:11.470 - 00:21:16.220, Speaker A: And it leaves Fc open for, I don't know what. Some future thing.
00:21:16.770 - 00:21:48.790, Speaker B: Yeah, okay, let's do that. Anything else on these opcodes? Okay, cool. Other spec questions, updates?
00:21:59.370 - 00:22:47.450, Speaker A: We should probably discuss this when Epsilon comes out, but I wonder if we should get some project plan and deadlines in mind. Not deadlines, but like shipping goals for milestones for people who weren't paying attention. This got moved out of Cancun last Thursday and I would want it to be in the best place to say this is the headliner for Prague. And I think the best way to do that is to have it basically ready to go while Cancun is moving through the testnet cycle. So we can come and say, hey, it's ready, it's tested, it's here. So when the discussion starts up, we can say eof is ready to ship. We've worked with people, we've got compilers working, we've got the test cases.
00:22:47.450 - 00:23:11.730, Speaker A: So we can see who else wants to go on this tour with us. But I don't know how easy that's going to be, what the other roadblocks are, what other teams appetite for work is. But that way we could do Prague as ideally a q one main net ship in 24th.
00:23:15.110 - 00:23:26.020, Speaker B: Yeah, that sounds like a good idea to me. Seems pretty attainable given that we're still, I don't know, five four or five months out. At least from four four four.
00:23:27.430 - 00:23:31.750, Speaker A: Right. Because we're looking at q three or q four for Cancun.
00:23:32.810 - 00:23:39.100, Speaker B: Like right on the edge maybe. Probably more likely to push into q four at this rate.
00:23:40.750 - 00:23:45.450, Speaker A: So we'll start the test net cycle like probably September October?
00:23:46.430 - 00:23:49.086, Speaker B: Yeah, I think that's what I'm thinking right now.
00:23:49.268 - 00:23:58.810, Speaker A: Okay, definitely. That gives us the summer to finalize it and then we could start the testnet cycle in January for Prague if things go well.
00:23:58.980 - 00:23:59.700, Speaker B: Yeah.
00:24:01.830 - 00:24:02.580, Speaker A: Okay.
00:24:03.510 - 00:24:31.050, Speaker B: Yeah, that sounds good to me. Other spec things. How about testing updates?
00:24:37.090 - 00:24:59.300, Speaker E: We've merged several prs in the consensus test and those are all UIF according to December spec, it's targeted at Cancun. So this is still going to change at some point soon. And yeah, no tests yet for all the megaspec new stuff.
00:25:01.370 - 00:25:02.120, Speaker A: Great.
00:25:07.610 - 00:25:09.480, Speaker B: Anything else on testing, guys?
00:25:11.450 - 00:25:35.230, Speaker G: Not from my chat. We still focusing on four year? Four, but I have the question regarding how do you guys see the finalized version of the spec? Yeah, in general, is this a long way to go or how do you guys see this getting finalized?
00:25:39.950 - 00:26:31.210, Speaker A: So we need to have a spec written for the new gas recall operations. What else? What were the other holes? There's a couple of other holes. I think the create three and create four need a spec written and the data op code. So we got three more eips we need to write and I think the rest of them look like they have eips published for them on the mega EOS specification. Yeah, I think that's what we're looking at. And the whole writing the Eips, we just need to get a volunteer and start writing it, I guess.
00:26:35.440 - 00:26:44.590, Speaker B: Yeah. So I'd say it's still another couple of months out from finalizing all the spec things.
00:26:49.460 - 00:27:06.870, Speaker G: Yeah, sorry. And it was just simply a question just to get a sense of how final the tests can be with the current state of the spec. Just to avoid manual rewrites from testing part. Yeah.
00:27:10.840 - 00:27:50.900, Speaker A: Unless we rewrite the container code again, which I hope we don't, you're probably safe writing tests for the ones that we have eips for. I don't see those changing too much. Code validation, static relative jumps functions, static validation, jump f instruction and a limited swap and dube. I really don't see those changing. So those are probably good ones to start working on until we get specs nailed down for grade three, four, call two series and data. Yeah, you probably should not write tests for those quite yet, unless you enjoy rewriting tests.
00:28:04.730 - 00:28:30.400, Speaker C: Since we mentioned change and stuff like this. I have a question, since I'm new here. How do we get notified with spec changes? Is there some hook or do we do it manually? Just keep refreshing GitHub or the eip page every time. Seems counterproductive, to be honest.
00:28:34.390 - 00:29:15.200, Speaker B: Yeah, it's probably not the best. I think this call is probably the fastest way to know about spec changes that are the EVM channel, but it's a little bit harder with so many eaps, usually it's a little bit easier to follow because you have one eip, you can sort of keep an eye on it maybe, whereas this you really need to have a call or someone posting on the evm discord like hey, these things are changing about the spec. It might be nice to have revisions of the spec right now we're kind of basing things off this hackmd in some ways.
00:29:17.730 - 00:29:28.900, Speaker C: Does hackmd allow us to see the changes that happened? Because sometimes I assume that we are up to spec and suddenly I noticed something different.
00:29:30.550 - 00:30:03.550, Speaker B: Yeah, there is a way. I'm trying to look at it right now. How do you do this? I think if you click the three dots in the top right it shows versions and GitHub sync. I'm looking at a node that I own. I think you can do this on anyone's node, but it will show all the edits to the node. And so if you wanted to take a look and see what's been modified, maybe since you last look, that would probably be a good way to do it on hackmd.
00:30:05.570 - 00:30:19.874, Speaker C: Okay, thanks. I guess that's it. I was hoping there would be some bot somewhere that you can subscribe to vip, but sadly it's not here. Thanks for your answer.
00:30:20.072 - 00:30:37.510, Speaker B: Yeah, it's not the greatest, but it's all that we have. Hello Axic, we're kind of wrapping up here. We've gone through the sections, are there any things that you want to share? Client updates, compiler updates, spec updates?
00:30:46.030 - 00:31:53.790, Speaker D: I think there's no real update regarding EOS. We did started to at least implement McOpy, which is I guess not strictly related to EOS. But since EOS will not be in Cancun and M copy was on the last call, we did a bit of work on implementing tests. Then regarding the EOF, I think there's two relevant discussions to be had given, I guess the cancun approved or CFI or whatever Eips. The first discussion is actually the opcode numbers because now there seems to be quite a bit of overlap between all these proposed opcodes and also like the UF opcodes. So maybe there needs to be a proper discussion in allocating these numbers. And on the channel we did had a number of discussions.
00:31:53.790 - 00:32:56.850, Speaker D: Maybe we should just put all the US related codes in the e zero EF range and that would free up some of the zero X range and all that. And the second discussion is with the SSD transaction format. And for four transaction formats in general I think it would be useful to get a confirmation on at least the design direction of the US with the contract blobs or in it code blobs on transactions. And if there is a confirmation on that then it would be nice to get at least that field into the transaction format for SSD transactions, transactions, whatever it's going to be. But I think it would make sense to get that into Cancun and then roll out the rest of the US afterwards.
00:32:59.750 - 00:33:16.890, Speaker B: Okay, yeah, that's definitely something to keep in mind. Right now there's kind of a debate with the 44 four transactions. Like are they actually going to be SSD or not? Yeah, so we have that whole debate raging.
00:33:20.190 - 00:33:32.206, Speaker D: Whether it's SSD or not. There needs to be a new transaction format of 4844. And in order to not keep adding a new transaction format you could just.
00:33:32.228 - 00:33:33.120, Speaker A: Add the net.
00:33:35.250 - 00:34:05.930, Speaker B: Right? Yeah, let's try and figure that out and talk to the four four implementer some. And then about the opcodes. We spent some time talking about how to lay out the opcodes. We were mainly talking about these three call opcodes though. So I don't know if we also wanted those in the e range or if we wanted to keep them in the. What was it, the f range.
00:34:12.110 - 00:34:12.986, Speaker A: It, yeah.
00:34:13.008 - 00:34:24.320, Speaker B: So we were thinking about putting these three gasless call opcodes at f. Did we say six, seven, eight?
00:34:27.830 - 00:34:57.478, Speaker A: It was like eight nine b. Oh, eight nine b because six and seven are create three and create four. So eight would be call, nine would be delegate call. A is already static call. So b would be the new static call. Yeah, and one of the rationales for that, Alex wasn't here for this, was that legacy could use these gasless calls. There's nothing tying it to eof.
00:34:57.478 - 00:35:24.450, Speaker A: It's not like it's a series of immediate args. So I do like the idea of rehoming all the eof stuff into the e series. That takes immediate args and we'd have to move like we were thinking of doing the b series but t store took a couple of spots in the b. But if we start growing backwards from f the e series gets all the eof calls that require immediate arguments. I think that would be some nice design setup.
00:35:28.550 - 00:35:35.480, Speaker D: Yeah, I guess you're correct that call opcodes, they're actually not strictly related to eof. You could just add them anyway.
00:35:36.090 - 00:35:45.580, Speaker A: And the gas golfers will love it because you go from six stack items to two or three stack items, they'll be all over it.
00:35:48.030 - 00:36:22.550, Speaker D: Okay, I will listen to the recording. When I jumped in there was like an argument how good the heck MD is to follow changes. And I know that I proposed that we're just going to keep working the HeCMPs until there's a really strict need for the Eips. But maybe this is the point with the co op codes, maybe we should indeed create like an AIP for them. If nobody else is volunteering. I volunteered to do that this weekend.
00:36:28.650 - 00:36:30.440, Speaker B: Okay, cool. That would be great.
00:36:40.990 - 00:36:59.220, Speaker D: And then I think the only remaining instructions which don't have any IP are the data instructions and the creation. So create three, four and return contract, but at least it reduces the amount of it.
00:37:14.730 - 00:37:19.590, Speaker B: Sounds good. Any other final comments?
00:37:23.770 - 00:37:25.354, Speaker A: Is my audio working?
00:37:25.552 - 00:37:26.842, Speaker B: Yeah, we can hear you.
00:37:26.976 - 00:37:27.370, Speaker A: Cool.
00:37:27.440 - 00:37:49.380, Speaker H: I just had a super quick question. I'm sorry I'm late to this call. Apologies if it was already in the topic of conversation, but high level question is there conversation amongst various EVM compatible roll ups around also adopting the EOF format? Or how do those things typically work?
00:37:52.070 - 00:38:34.030, Speaker B: Right now the conversation seems to mostly be that they don't have the bandwidth to adopt EOF on their own, or to spend time organizing amongst themselves, and so they're waiting for either things to settle down in their world, which from the estimates I've heard is like on the order of like two or three years, to where they could start thinking about not to being 100% EVM compatible and start to maybe create some standard around an L two EVM format. Or we just ship it on mainet l one and they are forced to adopt to stay quote unquote evm equivalent.
00:38:34.770 - 00:38:35.520, Speaker A: Okay.
00:38:39.330 - 00:38:51.240, Speaker H: Does it sound like that's the more likely option? The latter is the more likely option if there's not the bandwidth in the near term to do more custom.
00:38:53.450 - 00:38:53.826, Speaker E: Roll.
00:38:53.858 - 00:38:57.190, Speaker H: Up client work around this. Or am I misunderstanding?
00:38:58.010 - 00:38:59.800, Speaker B: I didn't quite catch that question.
00:39:00.490 - 00:39:02.970, Speaker H: Does it sound like the likely outcome?
00:39:04.430 - 00:39:05.002, Speaker B: I don't know.
00:39:05.056 - 00:39:19.920, Speaker H: The probabilistic outcome here is that they get forced to adopting it to maintain EVM compatibility because veering from EVM compatibility in the near term is less likely because it requires more bandwidth on their side, or.
00:39:23.570 - 00:39:24.590, Speaker A: The opposite.
00:39:25.650 - 00:40:08.000, Speaker B: I think that they'll adopt it if l one adopts it because l one is a really strong shelling point, and if you don't have that l one shelling point, then it becomes very difficult for all of the roll ups to make a decision on the exact spec that they're all going to target and having the bandwidth to do that is difficult. And I think right now, just look at optimistic roll ups. Not all of them even really support fraud proofs, so they're kind of like more focused on supporting fraud proofs before they're focused on adding more features to their EVM. But if Ethereum ships it and it's like in the clients, it's a lot less work for them. They don't need to figure out the exact spec because the core developers already did. It's already implemented. It's easier for them to support.
00:40:08.930 - 00:40:09.646, Speaker A: Okay, cool.
00:40:09.668 - 00:40:12.240, Speaker H: Yeah, that makes sense. I appreciate the context there.
00:40:13.970 - 00:40:22.740, Speaker A: Also, since some of the L two structures are using execution engine for some of their block production, aside from the fraud proofs, they almost get it for free.
00:40:23.190 - 00:40:24.340, Speaker B: Yeah, that's true.
00:40:28.730 - 00:40:30.598, Speaker A: Awesome. Thank you all.
00:40:30.764 - 00:40:33.110, Speaker B: Yeah, thanks for joining.
00:40:33.690 - 00:40:34.006, Speaker A: Yeah.
00:40:34.028 - 00:40:54.510, Speaker B: If there's nothing else, then we can close about 18 minutes early. Okay, let's close. Thanks a lot, guys. Talk to you again in two weeks. We'll be on the lookout for more communication on discord. In the meantime. Cheers.
00:40:55.570 - 00:40:56.650, Speaker D: Thank you. Bye.
