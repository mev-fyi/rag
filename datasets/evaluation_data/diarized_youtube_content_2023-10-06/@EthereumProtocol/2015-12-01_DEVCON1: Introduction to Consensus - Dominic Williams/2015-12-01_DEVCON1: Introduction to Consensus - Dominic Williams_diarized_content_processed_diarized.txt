00:00:19.690 - 00:01:25.320, Speaker A: Hi, my name is Dominic Williams. I founder of just a research project called Definity, which seeks to advance blockchain technology with a particular focus on scalability. In the process of doing that, we look at many different types of distributed algorithm, and in particular, many different types of consensus algorithm. And in the crypto space, we often spend a lot of time talking about blockchains and blockchain like consensus systems. And I think the purpose of my talk is to introduce another form of consensus which has been around for longer, known as byzantine fault tolerant consensus, which is based on message passing. So I'm going to try and do this in 20 minutes, which is kind of challenging, but I wanted just to give you a feel of some of the issues involved and what these kind of consensus protocols look like. So first of all, quickly, it's worth just asking the question.
00:01:25.320 - 00:02:41.674, Speaker A: We already have blockchain, so why bother with complex consensus protocols? And the answer is, they're useful for creating scale out crypto ledgers. That's crypto ledgers that increase their transaction throughput as more nodes join the network. So the objective of the research effort is to try and support the creation of sort of limitless decentralized clouds that can be used in the case of an open, decentralized virtual machine like Ethereum, to run Gmail, Uber, Facebook, Twitter, that kind of thing, Internet of things services layer, and so on. But there are sort of three different kinds of decentralized systems that I'm interested in. One is the open decentralized systems like bitcoin and ethereum, also federated decentralized systems as of the type that banks are currently creating for settlement and clearing. And I also think actually decentralization is a completely new computing paradigm, and we're going to see it within the enterprise. So people are going to create decentralized databases, which highly fault tolerant, because that's the way they're designed.
00:02:41.674 - 00:03:34.414, Speaker A: They are easy to administer because they're symmetric. Every server involved has a similar role. There isn't a kind of master slave arrangement like you see in mysql databases or something like that. And once these decentralized networks can scale, multiparty computation can be introduced to secure the data inside them. So probably you all heard about the hacks that target in America and the Office of Personnel Management. I think in the UK, TalkTalk has just lost a load of customer data. I think we're going to see enterprise decentralized databases, where the data is distributed across a large number of different servers, and you can only access it by running authorized requests which access the data in a certain way.
00:03:34.414 - 00:04:32.926, Speaker A: You can run a query against the data, say, but you can't retrieve all the data from the database. So with a decentralized enterprise database which is using NPC, all of these kind of hacks that you hear about would no longer be possible. So I think more specifically for some system probably in the long term, I think that the scale out kind of systems will use a number of different kinds of consensus system in their overall network architecture. And this is an architecture that I pursue. And you can see at the very top level it's got several layers. You've got a master consensus layer, you've got a scalable validation layer and you got a storage layer. And at the very top level it's got a blockchain, like it's got a blockchain.
00:04:32.926 - 00:05:26.918, Speaker A: It may not use proof of work, it could use something like Casper, it could use something else altogether. But that's only one component of the overall network. We also have this validation layer and we have a storage layer. And these green dots, these represent traditional consensus processes that are being run because for various reasons it's very difficult to create strongly consistent master chain. That is if you have a very large number of nodes, imagine if you had a million nodes in a distributed virtual machine. Be very difficult to have strong consistency at that level. So if the master chain can reorganize itself and drive other changes lower down, we don't want to have weekly consistent, to be composing weekly consistent consensus processes further down.
00:05:26.918 - 00:06:27.560, Speaker A: So consensus really does have a really important role to play in creating these kinds of network. And in this diagram here, these green dots are in fact traditional consensus instances. So what is the sort of bye consensus challenge? Very basically you've got a bunch of nodes that are connected by some kind of network here. I've called them processes. So I'll try and use that non climate change and they all have a value that they want to propose and they've got to agree on this value. The important point is that most of these nodes are correct, which means they follow the protocol, but some of them are faulty and that means they can behave completely arbitrarily, which is what is meant by Byzantine. So what is byzantine consensus? I guess the easiest way to think about it is as a game.
00:06:27.560 - 00:07:20.250, Speaker A: The correct processes run this protocol and try and reach agreement by sending and receiving messages. Meanwhile, the faulty processes, which are controlled by an adversary, try to either prevent consensus being reached or to make correct nodes decide invalid values. That is, think they've reached agreement on something that they haven't. So these faulty notice processes, what can they do? They're byzantine. And what that means is they can adopt arbitrary tactics, they can just decide to crash and fail. They can corrupt data and messages, they can subtly subvert the communications protocol and they can coordinate their actions. So they really can do anything at all, depending on the model that's being used.
00:07:20.250 - 00:07:50.702, Speaker A: The adversary can also do things like control the scheduling of messages. Right. He can impact the network. He may have full information about process states, and he can, during the consensus protocol, he can corrupt correct nodes at will. So just trying to clarify what consensus is. First of all, consensus is agreement. Here we have a network of just four nodes.
00:07:50.702 - 00:08:52.870, Speaker A: The green ones are correct and the red one is faulty. And the green correct nodes all start off wanting to propose different values. And after consensus is run, they've all agreed on the same value, xyz. And that's, I guess, pretty intuitive agreements also validity. Validity in this case means that if all of the nodes start off proposing the same value, then they decide that same value. And there's two forms of this, actually, there's weak validity, which requires that every single process starts off proposing the same value, and the strong validity, which requires that only the correct processes need to start off proposing the same value. But anyway, in this diagram here, all of the processes have started off proposing NMO.
00:08:52.870 - 00:09:23.890, Speaker A: And after consensus, all of the correct processes have decided NMO. Of course, the faulty processes come up with xyz. It could be anything. It's faulty, it can do what it likes, it can behave arbitrarily. So this is an important one. Consensus is also termination. What that means is that for a consensus protocol that it will eventually terminate.
00:09:23.890 - 00:10:16.210, Speaker A: It can't just go on forever. A valid consensus protocol has to terminate. So as you probably guessed, listening so far is there are actually many different models that these consensus protocols are designed to work for. And so here are some of the main ones. First one is network behavior. And generally speaking, consensus protocols are divided into synchronous consensus protocols and partially synchronous consensus protocols and asynchronous protocols. And in synchronous protocols, the network is assumed to deliver messages within some bounded, predictable time.
00:10:16.210 - 00:11:33.320, Speaker A: In asynchronous networks, there are no timing assumptions whatsoever. And this actually is kind of realistic for the Internet, right? You can get arbitrary partitions, a correct node can be ddos, right? And the second one, of course, is the fault type. So this is really oversimplification, but you've probably heard of a consensus algorithm called paxos it's used in like Google, Chubby and possibly zookeeper and things like that. So it's a consensus algorithm, where the only kinds of faults that are handled are crash faults, so it can deal with processes crashing, but it can't deal with them behaving arbitrarily. And of course, the wider set of fault types is byzantine, where processes can behave arbitrarily. So if there's anything just to take from this was useful, it's that obviously, if a consensus protocol is byzantine fault tolerant, it's resistant to a far greater number of faults. Right, arbitrary faults, in fact, and works within a synchronous network.
00:11:33.320 - 00:12:29.736, Speaker A: That's better, because it's not vulnerable to a correct process being ddos or something, or the network just behaving strangely. So just to talk about challenges. But more, I think one of the reasons these kind of protocols are complex is that in fact, of course the state of the network is unknowable. And it's easy to forget that, because you always see a network diagram which shows lots of connected nodes, and some of them are correct and some of them are faulty. But in actual fact, nobody can know what the state of the network is. You can only make inferences about the current state of the network based upon the messages you receive. And that's equally true, actually, for these kind of consensus protocols, as it is for blockchain based consensus protocols, you've got no way of knowing what the overall state of the network is.
00:12:29.736 - 00:13:08.132, Speaker A: You can only make inferences about it based upon the messages you receive. Now you can send messages out to ask questions, and you may or may not get answers, but you can only make inferences. The network is a black box. Another big challenge is equivocation by faulty nodes. And again, this applies to protocols like Casper, although this is again, assuming a traditional consensus protocol. And equivocation simply means that faulty nodes can send two different versions of a message when they're only menaced. One.
00:13:08.132 - 00:14:25.740, Speaker A: So in this case, process one is faulty, and it's telling process two that it's voting ABC, and it's telling process three that it's Voting NMO. And equivocation is a surprisingly powerful tool for an adversary to use, can create all kinds of problems, and there's a result that comes from this, which is that typically to reach consensus, when you receive a message from a process, you need to echo it to all the other processes to make sure that it hasn't been equivocating. And this kind of leads to quadratic message complexity, which basically means that as the number of processes cooperating in consensus increases, the number of messages they send increases with the square of the number of processes. And that's the reason why Satoshi created the proof of work blockchain, because it doesn't have. This problem works in a different way that people try and solve puzzles, and whoever solves the puzzle gets to cast a deciding vote. Right. You don't get strong consistency.
00:14:25.740 - 00:15:11.164, Speaker A: You get a sort of eventual consistency. As the chain gets longer and block gets better and deeper and deeper, it gets more and more likely to be permanent. So that's a limitation of these kind of protocols. The number of messages they have to pass increases with the square of the number of processes involved. And so consequently, they tend to be used within a larger protocol, as we looked at at the beginning. So here's another challenge. This is network asynchrony, and this is actually probably the most profound challenge, I think, which is there's no way of knowing if the network can behave in an asynchronous way, why you haven't received a message.
00:15:11.164 - 00:16:08.836, Speaker A: So in this case, p two is expecting a message from p one, and it hasn't received the message from p one. Okay, so what does p two meta think? Does it continue waiting for the message from p one? So there's a system called ripple, which you're probably all aware of, and they had a consensus protocol which didn't handle a synchrony correctly. And it was adopted by another cryptocurrency called stellar. And it was absolutely plain from the way they described the protocol that it had this issue with the synchrony, that it would just make an assumption that it hadn't got a message because the sender had failed. And as a consequence, they had a fork. So it's very easy to just imagine, well, I haven't received a message. The sender must have failed.
00:16:08.836 - 00:16:52.220, Speaker A: Therefore, I'm going to proceed with the messages I have and assume that some part of the network is faulty, but it can lead to problems. So, of course, an adversary, realizing that the receiver doesn't know what to do, can use this as a tool. He can decide to withhold messages. Right. And there is a kind of profound issue that comes from that. So what is the maximum number of faulty processes that these kind of consensus protocols can handle? There's no easy way to think about it. Perhaps this is the easiest.
00:16:52.220 - 00:18:21.608, Speaker A: There's a thing called a byzantine quorum, and a byzantine quorum is a subset of nodes so chosen that if two different quorums are selected, they will always intersect in at least one correct node. And this means that you can chain operations together and produce some kind of result or inference. And so we can see here are seven nodes and these two quorums intersect. There are two quorums here of five nodes, and you can see they both intersect in one node, even though both of the quorums have selected the two faulty nodes. And anyway, there's a general result, which is the number of faulty nodes must be less than a third. So less than a third of the processes participating in the consensus algorithm must be faulty for the thing to be able to reach a correct result. And the issue there is that one of the issues, one of the things worth thinking about is that if we cannot wait for all of the messages, so let's say there are n processes in the consensus protocol.
00:18:21.608 - 00:19:47.430, Speaker A: In this case there are seven. And we know up to two of them can be faulty, right? Once we've received five messages, five messages, do we wait and see if we can receive another two? To receive all seven? We can't, right? Because the remaining two messages we haven't received may be coming from faulty nodes and the faulty nodes may just decide not to send these messages to make us wait forever. Right? So these kind of protocols need to proceed when they've received two f plus one of the messages, which has another side effect, which is that, of course it may be that the f messages that we didn't wait for, in this case, the two messages we didn't wait for were actually from correct processes and we've received two messages from faulty processes, which means that we can only be sure f plus one messages from those we've collected are from correct processes. And that's why it's kind of complex. So I'm out of time, so you're saved. I was going to try and walk you through an asynchronous protocol, but I'm out of time. But if anyone wants the deck, ping me and you can have it.
00:19:47.430 - 00:19:49.520, Speaker A: Thank you so much, Dominic.
