00:00:00.280 - 00:00:31.688, Speaker A: We have now officially kicked this off. So this is a video that we're going to be not only broadcasting live to all of the participants of the ABS hackathon, we're also recording this. So if you are in the hackathon and you missed it, you'll be able to watch this later. And then we're also going to throw it up on, on YouTube later on as well. So the whole point of this is that we're going to be just introducing AV's development. It's going to be fairly introductory level. So if you've already built something sophisticated, you might not learn a whole lot.
00:00:31.688 - 00:00:53.804, Speaker A: You still might learn a little bit. A little bit. We have the ABS team here, Nima and Sam, and they're going to be giving presentations and I'm going to also be giving a quick presentation on the hello world. So to start things off, I'm going to go ahead and hand it off to Nima, who's going to kind of talk about AV's development and some things that he's working on.
00:00:54.814 - 00:01:55.614, Speaker B: Appreciate it, nether. Yeah, so I'm just going to share my screen real quick here to go over some guides that we have, starting with this. So this will give you a high level sense of what ABS's are and how you can start conceptualizing the development for them. So what you can think of EBS, is they're just apps on top of Ethereum, right? And these apps are operated by a set of operators who effectively have access to the full hardware resources of these operators outside of the EVM. And it just so happens that for the verification of the work that these abses do, there's a specific protocol that they define. And if this verification protocol is not run correctly, then these operators end up losing their stake as a result. And some examples of these are data availability layers, virtual machines keeper networks, oracles, and so on and so on.
00:01:55.614 - 00:02:33.498, Speaker B: But to give you a more concrete sense, we're going to go through a visual guide of how the various different components fit together. Here we give a high level snapshot of what the current ecosystem looks like. So we have the stakers, we have some contracts here, we have some other contracts here. And here we have the off chain components of what the various operators are doing and how dapps, both off chain and on chain, can interact with a guesses. So without further ado, let's dive into who the actors are. So we primarily have three actors, stakers, operators and AbS's. And we're going to jump into who the stakers are.
00:02:33.498 - 00:03:16.574, Speaker B: So you have this role who essentially has some funds, whether it's lscs or native ethnic. And the way that they primarily interact with Eigen layer is deposit funds, withdraw, delegate to an operator and undelegate. And the way this happens is that Eigen layer core protocol has one set of smart contracts. There is strategy manager, delegation manager, and AV's directory. These are important contracts for you to know about, because when you're developing your abs, you will need to know how your ABS contracts interact with these, these core set of contracts. Yeah. So when a staker interacts with Eigen layer, they're specifically interacting with the strategy manager.
00:03:16.574 - 00:04:03.326, Speaker B: And what a strategy manager does is it defines what a strategy is and how it's defined relative to the stake that the stake or deposits and all strategies are, are how assets are modeled in eigen layer. So it's just the type of assets and the amount. And here you can see that the exact interface for that is just an ERC 20 and the amount and similar with the withdrawal. And yeah, this is the function that gets called. This is stuff that you are not going to really go through as a developer. A bit of an abs, but it's important for you to know, as I said, how assets are deposited and how they're handled by the core contracts. Same thing with a delegation manager.
00:04:03.326 - 00:04:41.730, Speaker B: When a staker uses funds to deposit, they need to delegate that fund, undelegate that and withdraw the funds. And they interact with the delegation manager. And again, the interface walks through how this is done. And this is also the contract that operators can use to opt into the protocol. So when an operator ends up registering with Eigen layer, end stakers can delegate to an operator. And we need to know what an operator exactly does. So what operators do are they're the type of user who has some hardware and wants to use this hardware to make money.
00:04:41.730 - 00:05:33.572, Speaker B: And they do this by registering with Eigen layer to enter a job market to perform various services. The important thing to note though, here is that these services want to ensure that the operators are doing the job that they said they would correctly. And if they don't do that, some amount of bond will be taken away. And that's the stake that would eventually get slashed if that happens. So you can think of this as again, these option actors, or the operators here, they interact with their core contracts by calling the ligation manager, who then end up being the source that you check for if an operator is registered to be able to take on your service functionality. And this is the function that they call when they're trying to register. And you can use Eigen layer ClI to end up registering as an operator.
00:05:33.572 - 00:06:29.614, Speaker B: This is important for you as later on when you're registering as an operator yourself on Testnet, perhaps to test your own functionality before onboarding other operators. So you can go go through the end to end flow of actually enabling your service to be tested on whosky. And the same thing happens here for you to become a staker yourself. And then if you have an operator yourself, you can use this flow to end up delegating. This is the function that gets called when a staker wants to delegate to an operator. And you can see this. What's happening here is that staker who has previously deposited funds in delegating layer essentially updates a pointer in the core contracts saying that some operator now has delegated your funds so that they can operate on it.
00:06:29.614 - 00:07:03.604, Speaker B: They can use those funds to secure some services. So what happens after staker deposits funds, operators offer the resources and stakers have delegated funds. Now these operators end up actively validating services, which is the name of the next actor. And what abs's are. Earlier on we said they're just apps. And yeah, these apps are some combination of on chain and off chain code. It accepts operators who are interested in performing the service and rewards them for the service.
00:07:03.604 - 00:08:11.446, Speaker B: Now, what are the on chain components of an ABS? The on chain components of an ABS, the primary entry point for how eigenlayer recognizes an ABS is called the service manager. And this is the function that the core contracts accepts a bunch of calls from. As operators are registering to an AV's, they're registering, the stakes are being updated, et cetera. Service manager is aware of that. So yeah, moving on here. This is just so that the AV's directory is aware of an absurd, essentially registering and for any off chain code to index the registration of the ABS from the ABS directory. And when operator registration is happening is this is the call that gets made register operator to ABS, which the service manager defines so that it can take on that registration from the operator.
00:08:11.446 - 00:09:24.440, Speaker B: And this is a function that is implemented that is specified in the interface for service manager base, which we'll go through in a little bit. As you can see in the option code, you have this operator who makes this registration call to service manager of the EBS contracts, who then checks with the AV's directory whether the operator that tried to register is in fact an operator. So this distinction you can see is there's a set of core contracts, as we said, and some ABS contracts, the primary one being the service manager. But in a little bit we're going to go through how you can expand to have other contracts that provide various different functionality for stake utilities like signature checking, verification and things of that nature. And for option code, we say that it's any code that is not running on an ethereum l one main net contract. And we say that because you can end up running chains as an ABS. So that ends up becoming essentially some code that defines logic for a chain being run.
00:09:24.440 - 00:10:36.380, Speaker B: So technically you could say that that's on chain, but that's not what we refer to it as here. It can be a chain, it can be a coprocessor, it can be a real time data feed in Oracle, it can be anything else. So off chain is just the code that the ABS operators are running, it's the code that developers produced for the operators to run. In terms of how you can think about AV's contracts, these are the three that we mentioned earlier, and this is the other one that I was talking about earlier with the service manager base implementing some basic functionality. And if you look at the repositories later on for Fragon layer, there is a repo that's called middleware. That repo is the one that has all these contracts that are specific to AV's and it covers things like the registry coordinator, stake registry, index registry and a few others. And the thing we want to highlight here is that you don't necessarily need all of the ABS contracts above to design or implement your AV's.
00:10:36.380 - 00:11:56.884, Speaker B: The first three, these ones, the service manager, base, registry coordinator and stake registry, will probably end up being very useful to you because they implement some common operations. But as long as you have implemented the interface for a service manager, that's how you can define how your stake is handled and how the core protocol just recognizes what your ABS is trying to do. But yeah, in this section we're going to cover how these contracts may be useful to you and when an operator opts into your abs, what that means in terms of them helping secure your abs with a specific security profile. Right. So like I mentioned, this is the reference implementation of a base contract that can be used. It's the address by which Eigen layer recognizes your abs and the current functionality that it provides is registration and deregistration conditions for your operators. So yeah, this is interface register and these two are function signatures that we're going to dive into a little bit later, but we can skip over them now.
00:11:56.884 - 00:12:57.026, Speaker B: But if. Yeah, why is the interface concerned with these two yeah, we'll cover that in the next section. So we care about strategies for an ABS, as mentioned earlier, because they're the tokens or the assets that you deposit, or it's how AGNLA recognizes assets, right? So these operators are delegated some of these assets, and with these funds, these operators register with ABS's to secure the operations of these ABS's. But when we say that, what do we exactly mean and how does it happen? So, registration with stake to an AV's happens through the interface of what we call quorums. And quorums is just some grouping or configuration of a specific kind of stakeholder that an ABS has. So when an operator is opting into an ABS, they specify a specific set of quorums. And these quorums are the things that ABS end up defining.
00:12:57.026 - 00:13:43.046, Speaker B: So you can have CBE, native east, or any configuration of the other assets that are currently recognized by eigenlayer. And as the developer of the AV's, this is what you, this is how you can. And defining the security profile that you want to accept from operators. So, moving on. Yeah, the specific definition of this is just a strategy, as we mentioned earlier. And we have a field called the multiplier. And all it is is it gives you as a developer, the preference to weigh a specific asset differently to another asset that you want to specify.
00:13:43.046 - 00:14:39.698, Speaker B: Right? So let's say you have Ste, and the multiplier for that is five. And let's say you have cbes, and the multiplier of that is like three, right? So you give a relative preference for the assets that you want to secure your abs. And here we have a more concrete example of how that looks like. But yeah, you can, you can go through this a little bit later. And, yeah, so the purpose of having a quorum is that ABS can recognize the makeup of its security profile. But now, because of that, there exists this relationship between what the operators are, what their stake is, and how Abs is defined as security they want from these operators via quorums. Right? So we, because this is such a common operation, and this relationship is core to the functionality of an AV's and the contracts, we've ended up creating a few registry contracts that help with the accounting involved in this relationship.
00:14:39.698 - 00:15:39.192, Speaker B: And these are the stake registry and index registry. And if you're using BLS as part of your operations, that's what the BLS APK registry can be used for. And this is something that we can cover in the later sections. But now, since we have a few different registries that help our service manager states both operator and stake state, we need a way to consistently interact with these registries. And that's the point of the coordinator of these registries, which ends up being called the registry coordinator. And the reference implementation of this registry coordinator that we have includes the sacred registry index registry and the BLS APK registry. So the way that this is currently defined, because quorums are such a core concept for how ABS's work, the registry coordinator becomes the primary entry point for handling quorum updates.
00:15:39.192 - 00:16:44.654, Speaker B: And this means pushing these updates to all the registries that is tracking. And because of that, it's the contract that keeps track of quorums which exists and the ones that have initialized. So when you look at the registry coordinator in the middle of a repo, you will see how quorums are specified and things like create quorum or any other sort of common operation that revolves around quorums are defined in the registry coordinator. Moving on. Yes, and because of this, it is also the primary entry point for operators as a registered register from ABS through the quorums as specified here. Yeah, so as we said earlier, operators specify which, which quorums. Out of all the quorums that the ABS has defined, they want to opt into, and with some other parameters such as the operator signature, this function takes up that functionality.
00:16:44.654 - 00:18:00.334, Speaker B: And that's a lot of the basics that you should know if you end up looking at the other contracts like this, like the index registry, the NAT spec comments are very well defined to give you a sense of all the exact parameters that are needed and what they're trying to do. So if you have any questions, feel free to post them in the group chat. But from this point on, I'd like to to give a brief overview of the repo that we put together with a bunch of resources for how you can think about high level concepts around building ABS's and some of the videos and walkthroughs, as well as some development guides like the hello world Abs that Nader is going to go through and the incredible scoring abs that Sam is going to go through. But more specifically, there's also references here in terms of how other projects have defined their contracts and their off chain code, and how their off chain code does what it does to interact with the state that lives on chain. So this is a great resource for everyone to check out for that. And having said all that, I will pass it over to Nader.
00:18:00.874 - 00:18:25.084, Speaker A: Awesome. Thank you so much for that. What we're going to be doing at the end of this by the way is having a q and a. So if you have any questions, note them. And then when we're getting towards the end, you'll have an opportunity for us to answer as many questions as we can with the amount of time that we have. So we're going to go ahead and jump on to the next part of this. I'm going to be presenting now a hello world abs, which is kind of the most simple AV's that you can imagine.
00:18:25.084 - 00:19:03.524, Speaker A: And I'm going to share my screen. All right, so it looks like I am sharing. So that's great. What I'm going to go ahead and show you first is this repo here. And this is in the repo that was shared earlier from Nima. It's one of the different repos within the awesome AV's. So if you have that awesome abs, you'll see that this is part of that.
00:19:03.524 - 00:19:33.532, Speaker A: Or you can just go to the layer labs GitHub and you'll see hello world abs. So this is the, the AV's that we're going to be running here. And I think like when if you've never done anything, it might be a good place to start. Just kind of get to mental model of how this stuff works together. What we're going to do is we're going to walk through the contracts and also the different commands to run this and we're going to run it locally. And this is the design of this. It's very, very simple.
00:19:33.532 - 00:20:28.614, Speaker A: All we're doing is verifying a string message, which is hello world. And from there you can kind of like expand this to do, you know, more complex stuff. I think the presentation that Sam's going to give is going to be, you know, moving more towards what a real world use case would look like. Whereas this is more of just say, okay, I want to understand how to interact with the contracts, what a service might look like, and things like that. So I'm going to go ahead and jump into the code. So this is the hello world AV's and there's quite a bit of code and a lot of different folders and stuff, but in reality there's only four, I would say, files that you really need to worry about to understand what's happening here. The makefile defines all the different tasks or commands that you can run to kind of start this up.
00:20:28.614 - 00:21:52.386, Speaker A: And then we have the actual AV's smart contract which is in the contracts Src folder and it's called hello World Service manager. This service manager has everything that you need to operate this abs so you don't have to jump between 100 files. There's a lot of files, but you really only need to worry about these four. So the contracts are interacting with the Eigen layer contracts, but the specific functionality for this is all here in this hello world. And then we have our off chain stuff, which is a typescript JavaScript project, and we have an index, TS and a create new tasks t's which we're going to walk through all of this right now. The general idea is if you want to start this AV's, we can go here to the makefile and see that we have really these commands here that would be either building and running this yourself or running this from an existing state. The two options you would have here would to be if you wanted to run an AV's yourself, you would build your contracts, you would start anvil, you would then deploy the Eigen layer contracts to your local node.
00:21:52.386 - 00:22:44.248, Speaker A: Then you would deploy your specific AV's contracts to the local network, and then you would register your operator, and then you would run your AV's. We have a single command that basically does all of that with an existing state, and that's what we're going to be running. But if you wanted to run that yourself and do that yourself, you could actually jump into these commands here. And you can kind of see exactly what's going on in these different files here. But if we go to the readme, it outlines exactly what you need to run this abs. There's really only three commands to get started. This starts the local anvil node, which is like your local network, and deploys the chain with some, some pre existing state, which would be as if you kind of walked through and did all that yourself.
00:22:44.248 - 00:23:35.150, Speaker A: Then we make, then we, then we start the operator, which is the off chain service, and then we start sending requests to the service that then verifies the data on chain. And I'm going to jump and answer some of these questions, but I'll just answer r1 quick. Why do we need Anvil? Well, you can either test against like hard hat network locally, or anvil network. It doesn't really matter. We have chosen for foundry as our development environment for a lot of our examples, but it doesn't have to be that way. It might be cool to see someone build an AV's example with Hardhat. You know, you typically are going to test locally on a local network, and then you might deploy to our test network when you're ready to kind of get closer to production, which is whole ski and then you might deploy to main net when you're ready to go live.
00:23:35.150 - 00:24:31.114, Speaker A: So the reason we're using Anvil is just a test network, but you could also use any other test network, I guess. So we want to walk through the code, but before we do that, let's go ahead and actually just start the network. So the command that we're going to do to go ahead and start the network and deploy all of our contracts and everything is this make command, make start chain with contracts deployed. And this does everything that you need to set up Eigen layer locally, which is pretty cool. It's doing a lot under the hood, but it's just like literally you're deploying the Eigen layer contracts. You have your, your actual AV's contracts deployed and everything ready to roll. And then you can just run your service, which is going to be the typescript project.
00:24:31.114 - 00:25:07.494, Speaker A: So we've deployed the contracts and everything like that. So let's jump into the code to understand what's going on. The entry point to this application is this main function. And main just calls this function here. Here you see two things that are going on. It's pretty straightforward. We're first registering our operator with Eigen layer and then we are setting up this monitor new tasks, which is essentially watching for contract events.
00:25:07.494 - 00:25:41.410, Speaker A: Someone asked if this is going to be recorded. Yes, this will be recorded. So the main function is registering. And when a new tasks happens, then we'll be like listening for it in this function here. To understand what's happening with the actual tasks, let's go to the hello World service manager. Here you see a bunch of imports from Eigen layer. I wouldn't worry about diving into all of that right now.
00:25:41.410 - 00:26:27.364, Speaker A: There's really only a couple of functions here. I would say two that we need to really worry about. We're creating a task and then we're responding to a task. So the create new task is us actually having like a custom function within our contract that is kind of specific to this AV's. And what we're doing is just keeping a registry of all the tasks that have been happening and a data structure. So we keep like the task name when the block that was the task was created. And then we keep up with like an index of how many tasks have been created and we just store that in our local state.
00:26:27.364 - 00:27:19.594, Speaker A: And then what happens when a new task is created is that we emit this new task created event and that is what is picked up here in our service. So when a new task is created, we're going to omit the event from our contract. It's going to catch and this listener here, and then we're going to call this sign and respond to task. Okay. So out of everything that we're looking at, the two most important things I think, for you to understand, like with how an AV's work are going to be this sign and respond to task function and how it's handled in the actual smart contract. So let's take a look at that now because this is actually the verification that is happening. So what we're going to be getting in as an argument here is this task, and the task is going to have a name.
00:27:19.594 - 00:27:56.764, Speaker A: So we'll have some like, you know, arbitrary information coming in as an argument here. And then we're going to verify that arbitrary information by calling. Sign and respond to task. Sign and respond to task is this function right here. So sign and respond to task. We create a message and we basically are going to sign that message. And then we call the AV's contract, contract respondtotask, passing in our information along with our signature.
00:27:56.764 - 00:28:44.042, Speaker A: Then we wait for this to succeed. If we go to our hello, world service manager, what we're going to be looking for is this respond to task function and respond to task right here is doing the AV's verification. We're going to have a bunch of checks. This would be your verification, your on chain verification for your custom or whatever your AV's that you're building. You would have your own custom verification that you would do here. But for, for this basic example, we're checking that the operator has met a minimum set of requirements. We are making sure that the task that, that we're passing in hasn't already been recorded and that we haven't already responded to that task.
00:28:44.042 - 00:29:31.284, Speaker A: And if all of those things check out, we then go ahead and update the local list of tasks with the new task and add that we append that to our local data structure. And then we amend a task responded event, and that's about it. And then what you could also do, I guess, is like in this, you know, main function or this monitor new task function, you could also do like a listener for this event as well. But we're not really listening for that event. The only event that we're listening for is new tasks created. So if we want to go ahead and run that, we have the anvil node running. Well, we haven't started our service, so I'm going to go ahead and start the service here.
00:29:31.284 - 00:30:27.826, Speaker A: So this is going to go ahead and I need to go ahead and actually install the dependencies. So we're going to go ahead and call make start operator. This is going to go ahead and register the operator. And we're now listening for new tasks. And if we go to this last file here, this is going to just call an interval where we create a new task every, we had it set up for every 15 seconds, but let's bring in that out into like 5 seconds. So every 5 seconds we're going to create a random name, we're going to create a new task. The task is going to be created here in our contract from this Interval.
00:30:27.826 - 00:31:03.064, Speaker A: So we'll create the task. We have the listener set up here. It's going to then sign and respond to the task. And that's just going to happen every 5 seconds. So that's the general idea. So to test this out, we're going to go ahead and run this last command, which is make spam tasks, which is just going to start this service which creates a new task every 5 seconds. And I'm running into an issue, but let me just see one thing real quick.
00:31:03.064 - 00:32:07.994, Speaker A: It looks like I've added an x somewhere. Let's try that again. All right, so now we're monitoring new tasks. We're creating a new task every 5 seconds, which what we should see here is that a new task gets detected and we're going to sign and respond to the task. As long as everything goes well, we should not see any errors. And now we have a basic, very basic service running. So if you want to go back through that and understand it better by taking your time and reading through that code a little bit more, I definitely recommend checking out the teleworld abs and hopefully between Neiman's presentation, this presentation, and then Sam's presentation, which is going to be a little bit more in depth, you'll have a good understanding around the different moving pieces within an ABS.
00:32:07.994 - 00:32:34.108, Speaker A: And just one quick call out. We have an actual SDK that you can use to more easily interact with the Eigen layer contracts. It's written in go. What we've done in this AV's is we're literally just using ethers or some other. You can use any obviously RPC, uh, connection library to just make calls directly to Eigen layer contracts. Um, but we also have a go SDK if you're, you know, writing go. We're working on getting other SDKs.
00:32:34.108 - 00:32:46.024, Speaker A: We'd like to see typescript, Python and rust as well in the future. But for now, the only SDK we have is go. So with that being said, I'm going to stop sharing my screen and I'm going to hand it off to Sam.
00:32:47.604 - 00:33:00.376, Speaker C: Awesome. Thanks, Nader. All right, so I've got roughly 15 minutes. I'll try to. I mean, this was honestly an awesome introduction. I don't think I can do much better than Nader. Nader is like an expert at this.
00:33:00.376 - 00:33:21.584, Speaker C: He's very eloquent. I'll do my best. I basically wrote incredible screen like roughly a year ago after joining Eigen Layer. And I also kind of, we were, I'm also mostly working on the Eigen SDK and building a bunch of tooling. So definitely if you guys have issues with anything, please, you can reach out and we'll try to help. So let me share my screen.
00:33:23.364 - 00:33:36.140, Speaker A: Yeah, I think one thing to go over might be the signature stuff because I kind of didn't talk about that at all. There's two kind of main ways to do signing, and I think Sam can explain it in a more concrete way than me.
00:33:36.332 - 00:33:37.624, Speaker C: Does this work?
00:33:39.164 - 00:33:39.984, Speaker A: Yes.
00:33:40.404 - 00:34:09.204, Speaker C: Okay, great. All right. Yeah, so this is the incredible scoring AV's repo. So it'll look and feel very similar to hello world. This one is written in Golang instead of typescript, but a lot of the kind of makefile and deployment flows and all of the scripts that you'll see for deploying and starting the anvil chain and loading the already deployed contracts will be very similar. Right. So you'll have the migstart anvil chain.
00:34:09.204 - 00:34:33.286, Speaker C: You can start an aggregator. I'll explain what the aggregator is. So you have all of these commands. So if I switch over to the actual repo here, there's a make file which I like to give help commands like this. If you just type make, you'll see all of the different commands. So you can like play with this and go into depth in different sections. All the contracts, how they're built, how they're deployed, you can have fun with these and look in the makefile what exactly they're running.
00:34:33.286 - 00:35:07.086, Speaker C: Docker. There's a few things CLI for registering your operator, deregistering, depositing all of this stuff, and then actually starting the off chain software is here. So that's that. Now, what exactly is incredible scoring doing? Incredible scoring is basically like the simplest coprocessor that you could ever have. So if we look at the architecture diagram here, there's two the on chain section here you have the Eigen layer contracts and the AV's contracts. AV's contract being incredible screen contracts. So there's a tax generator again like Nader was showing here.
00:35:07.086 - 00:35:53.404, Speaker C: Instead of sending like strings and asking for hello person to be printed, is sending integers and asking for their squared to be credibly submitted back on chain. But the mental model you should have is that this also scales to any kind of crazy computation that is too expensive to compute on Ethereum. So for example, if you can think about some AI co processor, right? So you would basically send a request for, for some input to be passed through some huge LLM models and that would be done credibly. So that's kind of the mental model you should have for incredible squaring. So the task is sent on the contract and then there's an event that's emitted picked up by the Eigen layer operators. The idea here is that there should be more than one as opposed to hello world. They sign on the task.
00:35:53.404 - 00:36:33.854, Speaker C: I'll get into this whole BLS signature signing a little bit that Nader was mentioning, but they each sign using a BLS signature. Well a BM 254 signature which is aggregating using the BLS scheme by the aggregator here. So the aggregator is literally just aggregating a BLS signature. I'll get into this again a little bit in a few minutes. And then once aggregator has a signature that meets the quorum threshold that is asked for. So basically we ask oh okay, I want 80%. When a task is submitted on chain you say I will consider a task completed if it's signed by at least, you know, 80% or 66% or whatever of the signers of the stake that the operators own.
00:36:33.854 - 00:37:11.514, Speaker C: So as soon as you meet the threshold you can send the answer on chain. And then the user, the person who submitted a task will take the output of that LLM, right? Or in this case the output of the square number that's now on, the answer is now on chain and he can use it, pull it in its own contract or whatever. So that's the general idea. There's more detail into what exactly is happening. And there's a UML diagram here that I don't think is worth going into detail. But basically this is exactly what's happening in the Golang code. And then later if you actually want to build an AV's, there's the AV's nodespec compliance.
00:37:11.514 - 00:37:48.224, Speaker C: So there's some requirements for the off chain software that needs to be met so that operators that are running the software kind of have a, a unified experience. And you know, if they're deploying on Kubernetes or whatever, at least they have these endpoints that they know they can rely on and these metrics that they know they can have. So it's kind of to give a unified experience. So we'll only be adding things to here right now. It's pretty simple and it's not super extensive, what we're requiring. Okay, I think that's the gist of it. So I'll try to touch a bit right now upon this BLS signature aggregation before I go more into detail in the code.
00:37:48.224 - 00:39:09.194, Speaker C: Okay, so the idea with the hello world is you have a single operator that is signing off on the responses. So when a string is submitted on chain, then there's a single operator, that operator that natter was running, which just picks up the string and then it sends back hello string to the contract. So the idea with Eigen layer is, Eigen layer is a delegated proof of stake system. So any commitment or any response that is sent on chain is basically the economic security backing that task is only the amount of stake that operator has delegated to it. So the idea of Eigen layers, again, it works as a, you can think of it as a bit of like an optimistic roll up where the stake is shared by all the ABS's. And so the idea is that there needs to be a slashing condition that is encoded in the contract, which if the operator lies, then he can get slashed, right? So basically any answer that I send back to the contract, the point is its guarantee is only good insofar as the amount of money that is backing that claim. And so as a user, as the task generator here, if I send a request and then I say okay, whatever, if one operator signs off on the task, I'm happy, I'll accept the output.
00:39:09.194 - 00:40:10.884, Speaker C: Then maybe an operator with a very small amount of stake can just sign off and lie and send a fake response. So now what we want is we just want a lot of operators to basically we want to aggregate a lot of economic security, right? So we want as many operators as possible to replicate the same computation and sign off on their answer. The problem with ECDSA signatures is that each of them is so 64 bytes, I think the signature for an ECDSA signature. And so if you kind of, if you have 1000 operators, then each of them has like you can just see that the signature becomes really big because it's 264 bytes for each operator. And also when you send it back on chain, then it's like a multisig. So you'll need to verify each of these signatures one after the other. So the idea for BLS signature, which is by the way, the same thing that the beacon chain on Ethereum uses is basically your signatures are an element on elliptic curve and you can add the signatures together.
00:40:10.884 - 00:41:06.326, Speaker C: So it's like literally the group element on the elliptic curve. So if you have a thousand of these signatures that are the 64 bytes each, you can literally just add them and you end up with one aggregated signature which is just 64 bytes, but it actually contains the information of 100 signers. And so the aggregator basically takes these, just aggregates them and sends them on chain. And then there's a way for the contract to verify using a pairing. So if you've seen like there's some, there's pairings being added as precompiled contract on Ethereum. So the ones that were on the chain were only the ones for verifying VM 254 signatures, which is what we're currently using now there's BLS twelve 381, which is another elliptic curve which is being added so that we can verify stuff from, from the beacon chain. Right now all of our tooling is using the BN 254, so that's what we use.
00:41:06.326 - 00:41:39.456, Speaker C: So it can be a bit confusing. But basically it's BLS signatures over the BN 254 curve. It's not BLS signatures over the BLS twelve 381 curve, which is what ethereum uses. So that's most of our AV's you're using like eigenva, incredible squaring. There's nothing stopping from using BLS 1231, especially now that that means soon enough there will be the pretty verifying them. But yeah, that would be another option. So okay, so now the question is when would you want to use ECSA signatures versus BLS? And then it's just a trade off basically of gas costs.
00:41:39.456 - 00:42:12.806, Speaker C: So if you verify one ECDSA signature, you need to do an EC recover opcode which costs 3000 gas. So you know if you have like ten operators, then it's going to cost you 30,000 gas, whereas so a BLS signature you need to use the pairing. So it's one of the pre compiled, I think I forget off the top of my head, but I think it's at least like 100,000 gas like base costs just for verifying the pairing. Right. So you know already that you need to have at least 30 operators before you want to switch to BLS signatures. So basically there's kind of a threshold. I think it's somewhere around 30 to 40 operators.
00:42:12.806 - 00:42:43.634, Speaker C: Or if you have, if your AV's has below that, then it's probably not worth using BLS signatures first of all because they're a lot more complicated. You'll see if you read the code for the verifying the signatures of hello world. Compared to incredible scoring, incredible scoring is way more complicated. Effectively it's using the same tooling that we've built for Eigenva and that we're using there. So it's definitely a lot more involved. So with that being said, I can show some of the code. So again, I'll do a very quick demo like Nader did.
00:42:43.634 - 00:42:49.994, Speaker C: Also I'm not looking at the chat because I'm sharing my entire screen. Nader, if there's questions that we're going.
00:42:49.994 - 00:42:52.214, Speaker A: To take questions after this is over.
00:42:52.594 - 00:42:58.654, Speaker C: Okay, awesome. So then I'll just do how much time do I have? Also I'm pretty much done right, but.
00:43:00.434 - 00:43:08.882, Speaker A: I wouldn't worry about time we have. I mean it's up to you, but I think we have up until 15 minutes after the hour. But depending on your schedule, I'll be.
00:43:08.898 - 00:43:33.950, Speaker C: Quick, I mean this is quick demo. So I'll just, so the same thing here. So here we need to start the aggregator first. I think you can also start the operator. But basically the aggregator here acts both as the aggregator and also as the task generator just because we didn't want to implement another thing. So it's also periodically, I think every 10 seconds or something, sending another, a new number to be squared into the contract. So right now there's no operator running.
00:43:33.950 - 00:44:08.086, Speaker C: So nobody's listening for any number and not answering. So if we start the operator the same way that natter did here. So typically you would want to use the CLI to go register your operator. But in these simple examples we've made it so that when the operator start, it just dynamically registers. So the operator is registering. There's still some cleaning up that we need to do on some of the logs here, but. Okay, so there we go.
00:44:08.086 - 00:44:40.070, Speaker C: So, so you see the threshold reached. Okay, I'll try to stop that someone, but yeah, threshold reach sending aggregated response on chain. So okay, what's happening? Basically you'll see here, let me stop this. Let's stop this. So if we go up, okay, so there we go. So let's say here the operator received a new task. So the quorum threshold percentage, the number to be squared is five and then the quorum numbers.
00:44:40.070 - 00:45:30.574, Speaker C: We can go into detail if you guys have questions, but this is the meta info related to the number that I need to be squared and then the, the operator just goes and squares the number signs off on it using its BN 254 private key and then sends the signed task response to the aggregator. Then first here you'll see this is normal. It says received error from aggregator. Task five not initialize are already completed. This is normal. It's just because the events are basically because we're on anvil chain locally the operator receives the event, signs off, basically computes the square and signs off on it and then sends it to the aggregator faster than the aggregator can create its sort of aggregation structures that it needs to create in order to just even have accounting on which operators have which stake at that block. So the aggregator needs to do a bit of accounting first.
00:45:30.574 - 00:45:51.596, Speaker C: So it needs to build some data structures before it can start aggregating. And the operator, so it sends the response too fast and aggregated just says okay, I'm not ready. So either here the task five not initialized. So the operator just retries a few times in the second. So they're retrying in 2 seconds. Then here, okay, here it fails again. And then after 4 seconds this last try actually works.
00:45:51.596 - 00:46:20.964, Speaker C: Aggregator accepts it and then the aggregator sends the answer on chain. So here there's a single operator. So we've met the threshold and I think the threshold was 100 when we sent the. Yes, it means 100, just means I will accept a signature on chain once 100% of the stake has signed off on the task. So here there's a single operator. So basically just need that operator sign. But there's a docker example where we have two operators running and you can scale that to n.
00:46:20.964 - 00:47:02.750, Speaker C: Then you can play with the threshold saying for example, oh, I'll accept if there's 80% of stakes signing and such things. So that's kind of the gist of it. I don't really want to go into the contracts if there's like questions. We could go into the contracts, but we've, so we've separated it very briefly into a service manager and a task manager. The service manager is the most important thing. It's the contract that Eigen layer knows about. The task manager here is just a separate contract for accounting reason, just to keep basically the semantics different.
00:47:02.750 - 00:47:41.414, Speaker C: Service manager deals with mostly with the slashing logic, whereas the task manager deals with the kind of responses and making sure that the number squared is actually the number squared and keeping track of the task responses and the indexing on chain. So that's mainly it. It's pretty simple. Um, the one thing I wanted to show which um so there's a, I forget what it's called, checks. BLS signature checker. This is the main contract where the, the BLS signature logic is, is encoded. So every time you submit a task to the contract, the contract will.
00:47:41.414 - 00:48:19.830, Speaker C: So you can see here for example in the task manager. Oh this is not the, so the task manager is a BLS signature checker. So basically every AV's that use BLS signatures at least uses the tooling that we've built, which is a lot of the abses. Basically the service manager influences BLS signature checker which has a function. Verify signature or something or check signature. Check signature, yeah, this function right here. And then this is the function that basically verifies that, that the BLS signature is correct.
00:48:19.830 - 00:49:01.134, Speaker C: So this is super involved. It took me a long time in the beginning to actually parse and figure out what's here, so I won't even try to do it right now. All I want to show is that this non signer stake in signature struct is what you need basically is the meta information that the aggregator is aggregating and building in order to convince the contract that the signature is correct. So you need for example APK is the aggregate public key on g two sigma is the signature. Then you have the quorum apk. So for each quorum, as Nemo was talking about earlier, you have different quorums for different tokens. So sometimes you'll want different tokens to the stake of different tokens of different quorums to have met their threshold, each of them.
00:49:01.134 - 00:49:40.274, Speaker C: So that's just even more complexity. And then if there are non signers, you also need to give their pub key such that you can subtract them from the aggregated pub key that is cached on chain. There's just a lot going on. So I think it's one of the better kind of. We were the first to actually implement BLS signatures verification on chain and I think we probably have the most optimized library as far as I know. So this is really really a good playground if you want to learn more about BLS signatures and how they're verified on chain. So definitely do ask questions and go super dive into this as much as you can and ask questions and we'll be happy to help.
00:49:40.274 - 00:49:43.394, Speaker C: I think I'll stop here. Nader.
00:49:45.254 - 00:50:29.204, Speaker A: Awesome, thank you for that. That was really great. I want to know like if anyone has any questions, feel free to drop them in the chat here and maybe we'll get to a few that we haven't, haven't been answered quite yet. But I have a quick question about the incredible squaring myself that I'm not 1000% sure about because it's actually, I remember it was the first abs that I looked at and I'm not that familiar with go. And it was, you know, a lot of code for me to parse. So for the verification of the number, is there any actual like logic in the verification contract to calculate that number? Or is it instead just relying on all of the operators to come to an agreement and then they verify that they've all had the same answer?
00:50:30.884 - 00:50:51.012, Speaker C: Right. So in this case, the slashing condition in the contract would just be like, you can literally square a number easily in solidity. So the slashing condition in this case is just like, oh, if, so if all of these operators have signed off on a number that is not the square, then the slashing condition is just, okay, I'll send the number, I'll actually square it in solidity. I'll prove that.
00:50:51.068 - 00:50:58.342, Speaker A: Okay, so it's going to actually like compare the result off chain to actually doing the work on chain to make sure that it matches, right?
00:50:58.478 - 00:51:36.814, Speaker C: Yeah, exactly. Exactly, yeah. So this is basically always what you want. So that's the difference between objective slashing conditions and then subjective slashing conditions. Subjective is things like oracles or something that you can't, you can't verify on chain because the information was, you know, something like at a specific time, time shot in a different database that the on chain doesn't have access to, as in the case of an oracle that's just pulling data, let's say, from, so you can't kind of go back and be like, oh, this was the actual answer. Whereas for all of the objective slashing conditions. So even for example, like a huge LLM, something that can't be computed on chain, you like, the best way to have an objective slashing condition is you'll create a ZK proof.
00:51:36.814 - 00:52:02.224, Speaker C: So a lot of these AVss are just backed by a ZK fraud proof. So the ZK is more expensive than verifying BLS signatures. So optimistically you'll just verify the BLS signatures and kind of trust the operators. But it's actually, there's actually, it's actually backed by economic security and not just trust based because if they ever lie, you can, you can send submit a ZK fraud proof and prove that they lied and then slash their stakes.
00:52:05.044 - 00:52:13.904, Speaker A: That's actually really helpful. Okay, very cool. We have a question here. May I know the exact part where you might need to write something and go.
00:52:16.784 - 00:52:17.976, Speaker C: Do you want to take this one?
00:52:18.080 - 00:52:55.564, Speaker A: I mean, I guess this is going to be, I mean, that's a very open ended question, because really all of the custom functionality that you are implementing in your AV's is going to be written off chain and it's just going to be verified within that contract. So that's kind of up to you. And it could either be go, it can be typescript, it can be python, it could literally be anything, anything that can run in a service. So just any web service you could think of. So that's going to be completely up to you in terms of the type of, I guess, verification that you're trying to kind of implement in your abs.
00:52:56.664 - 00:52:57.484, Speaker C: Yep.
00:53:02.424 - 00:53:08.244, Speaker A: And if there are any other questions, feel free to drop them in. If not, we might wrap it up in just a minute.
00:53:09.204 - 00:53:43.096, Speaker C: Yeah, I guess. John Doe, to answer your question, you need to think of an AV's as kind of the opposite, I guess. So an AV's developer would be the opposite of what a smart contract engineer would be. So the smart contract engineer is kind of taking the whole Ethereum blockchain as it's like, you know, its DevOps teams and it only has to write code that runs on chain. And AV's, an AV's developer would be the opposite. So it's someone who actually writes like kind of off chain first, and they're thinking about, oh, I'm going to build a bridge, or I'm going to build like some AI model or something. The chain is there to secure that off chain service, that off chain computation.
00:53:43.096 - 00:54:03.484, Speaker C: So basically it's the slashing conditions that are encoded on chain most of the time. Or sometimes if it's a bridge, there's like the finality or the settlement will happen on chain. But it's kind of, you think about it off chain first. It's like you're providing a service that, I mean, you sent sometimes moving also information between blockchains, but it's kind of something off chain happening first as opposed to the other way around.
00:54:06.804 - 00:54:27.796, Speaker A: Okay, cool. I think that that will wrap it up. If you have other questions, feel free to drop them in the hackathon chat. And if you are watching this later on YouTube, feel free to drop them on YouTube. We'll try to try to keep up with any questions that we have there. And thanks everyone for checking this out and we will go ahead and end this now. Thanks, Sam.
00:54:27.796 - 00:54:28.284, Speaker A: Awesome.
