00:00:00.330 - 00:00:35.142, Speaker A: Hello everyone. My name is Amit Kumar and I'm from Altlay. We are building a roll up as service platform with the basic idea that if you believe that there will be 10,000 rollups, we would, we would be the one that makes it easier for you to have 10,000 rollups. So our goal is to make it easier for people to deploy those rollups. Even a marketing person, a BD person, should be able to go and deploy those roll ups. Today we are going to talk about probably this is going to be n minus one talk on fast Findy layer, but there are certain interesting things that we're doing. So we'd like to share what you're doing with this fast fiddy layer called Mac before jumping into it.
00:00:35.142 - 00:01:27.350, Speaker A: There has been quite a bit of debate over the last few months around what settlement really means. But depending on which camp you are in, suddenly there are certain properties that you want from a layer like Ethereum to be called a settlement layer, right? The first thing is, if you are thinking from a roll up perspective, base layer like Ethereum verifies fault proofs. It verifies verity proofs that comes from ZK rollups, right? And you want to resolve those disputes on chain. The second thing is because historically, many of the tokens have been issued on Ethereum, and even today many of them continue to be issued on Ethereum, it kind of becomes like the base liquidity layer for people to use. And because you have most of the liquidity sitting on Ethereum, imagine you have different roll ups or even different l ones. You want to be able to pass through that liquidity. So you want to be able to, let's say, lock some asset or burn some asset, one chain, and then be able to mint a corresponding number of assets on some other roll up or some other chain.
00:01:27.350 - 00:01:58.882, Speaker A: And that happens through Ethereum underneath. And so for many of these use cases and features, you want to be able to ensure that Ethereum provides your finality. That's fast enough for these use cases to be powerful. Unfortunately, Ethereum is not the best network at the moment to provide you finality. Fast finality. So if you look at Ethereum in a more general context, you have the notion of epoch, which lasts for about 6.4 minutes.
00:01:58.882 - 00:02:41.982, Speaker A: And then within each epoch we have about 32 slots. And so even a block that blocks requires two epochs to be finalized or to be considered final. That comes up to about twelve to 13 minutes. So that's not ideal, because if you're thinking about, let's say, from roller perspective, you have this user that sends a transaction to the sequencer. Sequencer orders those transactions and sends them back to the base layer, which is Ethereum for ordering, right? So at that point, once those transactions have been, or those block have been finalized on Ethereum, then the order becomes final. And then there's some executor that can basically take those transactions and then generate the final state commitment and put that back on Ethereum for others to use if they want it. Everything that is in the color.
00:02:41.982 - 00:03:06.226, Speaker A: This basically happens on Ethereum. So you basically have the same problem, which is you have to wait for a long while before you can consider your transaction to be final. The thing that gives you slightly faster finality, or so called finality, is the part which is off chain, which is a sequencer level. So sequencer tells you, hey, here's a transaction. At some point of time in the future, I'll put those transactions on the chain. But this finality is not guaranteed because there's no economic requirement on sequencer. Sequencer can lie.
00:03:06.226 - 00:03:31.550, Speaker A: Sequencer can say, hey, or maybe decide not to put those transactions at any point of time in the future. And so this is slide from, I would say eigenve. So thank you for that. And I think it's a very good summary of what's there. Probably some typo there, which I hoped would have fixed. But anyway, basically this is kind of the design trade of space today. So you can go for this fast confirmation on fast confirmation with sequences.
00:03:31.550 - 00:04:15.214, Speaker A: But transactions haven't really finalized on Ethereum, right? So you do not have any economic guarantee that comes from those sequences. On the other hand, there's a typo, it should go there. And then on the other hand, you have this economic backing that comes from Ethereum as a base layer. But the problem there is that you have to wait and slow and takes time. And the problem with sequencer, even if you somehow trust, let's say, arbitram sequencer or optimism sequencer, you cannot trust the 10,000 role of that out there in the market, right? Because they may appear today, they may disappear, I don't know, next day, right? So you have to have a mechanism where you should be able to have some faith in the finality and has to be fast. And this is where you can combine eigen layer with some sort of network that allows you to have this faster finality. And this is what you're building.
00:04:15.214 - 00:04:50.322, Speaker A: So at a very high level, sorry for this type of thing, but basically. So this is a network of participants that verify the validity of a roll up state. And what I mean by roll up state is basically targeting to app roll ups. But of course it generalizes to any roll ups, which are like arbitrary optimism as well. And these roll ups basically verify that the node operators have followed the state transition function correctly. So here's a very simple high level overview how it works. So you have the sequencer that basically takes transactions, I'm hiding the executed component as well, behind the sequencer.
00:04:50.322 - 00:05:25.742, Speaker A: And they will take the transaction batch and the commitment, they will put that on the Mac network. And then Mac network will basically verify and attest that this roll up state looks correct. Eventually, maybe after a certain delay, they could basically pass that information back to ethereum. So you can still get every benefit that you want to have from ethereum as well. And once you have that, you can basically build a faster interop solution as well, right? Basically you have the roller pay that sends transactions and state commitment to the mark network. Mark network basically verifies and then basically informs the roller b to take the action. So if you wanted to, let's say lock and mint kind of transaction, you could do that through Mac.
00:05:25.742 - 00:06:07.822, Speaker A: But eventually you always have ethereum where you can send transaction after delay. There are three different modes in which you can operate this validity. One is basically the pessimistic mode where the Mac network basically is a full node and they verify every single transaction, they rerun every single transaction. You could imagine optimistic mode, but in slightly better way. But this is not the most interesting bit. Interesting bit, the last bit, which is the variety proof mode where you could say, hey, I have this approver that at the moment producers, let's say approve every 1 hour simply because it's going to be costly. But I could build incremental proofs and those smaller incremental proofs could go back to the Mac, and then eventually after an hour it could aggregate all those smaller proofs and then could send that back to Ethereum.
00:06:07.822 - 00:06:44.542, Speaker A: So you could still get much faster in real time proof that gets verified on Mac. And then a longer larger proof basically goes back. What I mean by larger proof is basically a proof that aggregates a lot more transactions, right? And that goes to Ethereum. You can verify that there we have a version implemented in the optimistic mode with an optimistic role that's written in rust, with an op like framework. And hopefully this is something that you can come and use, hopefully very soon. And the idea is of course to extend that to CK. So with the work that Lagrange guys were doing, you could basically take those ideas and bring that in.
00:06:44.542 - 00:06:55.980, Speaker A: Build a Mac network with lightweight clients that run basically ck proofs. Well, that's it. Thank you very much. And if you have any questions or feedback, please reach out to me on Twitter. Thank you.
