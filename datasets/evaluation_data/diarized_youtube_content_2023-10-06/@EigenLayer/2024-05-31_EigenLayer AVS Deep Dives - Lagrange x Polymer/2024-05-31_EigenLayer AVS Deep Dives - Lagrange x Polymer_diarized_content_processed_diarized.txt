00:00:12.280 - 00:00:43.446, Speaker A: Hey everyone, I'm Nima. I'm the AV's research lead at Eigen Labs. Joined here with the folks from Lagrange, Ismail Kashish. And we have Bo, the co founder of Polymer Labs as well. We're going to walk through an integration of how polymer tech works with Lagrange, just for brief context. Polymer is working on the interoperability hub for Ethereum, using IBC tech and a bunch of other cool stuff. Lagrange working with state proofs and again, taking interoperability from a different angle.
00:00:43.446 - 00:00:55.086, Speaker A: But both of these tech integrated together, I think fundamentally redefines how interoperability is going to be shaped moving forwards. And without further ado, I will give it over to Ismail for intro.
00:00:55.270 - 00:01:51.114, Speaker B: Thank you so much for having us, Nima. So what we work on at Lagrange very much is how we can take zero knowledge proofs, and we can apply these in conjunction, oftentimes with restate security, to be able to provide novel primitives for Ethereum application developers. One of the core things we focus on is our state committee protocol for constructing state proofs for optimistic roll ups. And so, the very interesting thing about this, in this space of interoperability, is that when we think of modular interoperability, state proofs provide a non competitive and a complementary solution in the design of interoperability protocols. And so the work that we've been talking a lot about with polymer, and that we've now completed integration with, really is kind of the first example in the blockchain context of a very modular interoperability stack, where two different pieces are actually coming together to provide a differentiated experience.
00:01:52.274 - 00:02:47.094, Speaker C: Yeah, I can do a quick self intro. So, my name is Bo, I'm a technical co founder at Polymer. We're working on bringing IVC interoperability for roll up to roll up communication. And to Ishmael's point, I would want to add that, at least on a very high level, what I'm seeing is that eigenvalue is essentially building some sort of AWS like construct on top of Ethereum, so that you have various service providers, such as Lagrange, that provide maybe interoperability related services, but also other services as well, that other hackers, infrastructure or otherwise, can consume. And it makes a lot more sense that we're very collaborative on these things, so that we can accelerate how much further we can progress, so that not everyone's rebuilding the same layers of the stack over and over again, which is kind of been challenging for the space as a whole to make progress.
00:02:48.634 - 00:03:04.010, Speaker A: Yeah, absolutely. And we'll get to the details of how what you're talking about actually works in a second. But before we get there, Ismail, do you want to give like a very brief overview of how state committees work as an AV's?
00:03:04.162 - 00:03:56.260, Speaker B: Yeah. So our state committee infrastructure is very easily thought of as a light client for optimistic roles. If you think about this model of the Ethereum sync committee, and you think about how this is used by taking a subset of Ethereum validators to create attestations to Ethereum state that can be used to sync like clients. And you can think about applying that same design principle to alternative committees that attest to other execution spaces that have a very similar design, a very similar architecture, but extend out this well defined paradigm to other places that would want secure representations of state cross chain. So to put that in concrete terms, you can think of a committee that is defined very simply by a recursive relationship. There's an initial committee, then a function, how that committee mutates, where the previous committee signs off on the next committee. And then you can instantiate this for roll ups.
00:03:56.260 - 00:04:17.904, Speaker B: And what this gives you is the ability to have proofs and very succinct proofs of the state of a roll up at a given point in time, backed by a transparent amount of economic security. And by being able to take these proofs, we can verify these in different places that can then consume that state and compose on that state as they design their protocols.
00:04:19.404 - 00:04:25.864, Speaker A: Bo, do you mind giving us a quick rundown of how you guys have been thinking about Eigen layer integration?
00:04:27.244 - 00:04:58.980, Speaker C: Yeah, so currently we're an Eigenva roll up. So we're a consumer of eigenvalue, which is an AV's. We're also consumer lagranges in AV's. So I very much see us as like building on the services that eigenlayer provides. Yeah, so what you guys are seeing here, and you guys can see my cursor, is that we have two chains with opium base. Lagrange has bootstrapped, and AV's state committee for both of these. So this involves a number of nodes that use BLS signatures.
00:04:58.980 - 00:05:50.438, Speaker C: We have this BLS node, Lagrange nodes that are attesting to the execution of these two roll ups. These attestations are then streamed to polymer, and polymer consumes them raw. So these are just plain attestations. In the future, we'll have a Lagrange state committee for polymer as well. And what it allows us to do here is that we'll have this Lagrange node once again, but in this case, we're going to be producing, generating ZK proofs of the polymer execution or attestations via Lagrange and streaming these ZK proofs to other connected chains. So we have this property where we have it becomes an aggregated attestation. Even though this is a single OZK proof, it becomes an aggregated attestation to the state on all these chain that's made possible by Lagrange's design.
00:05:50.438 - 00:06:32.124, Speaker C: And if we jump in even more, zoom in a little bit more into this, what it kind of looks like is that you have some sort of l two data that's being or l two blocks that are being produced. This state that l two blocks are being attested via Lagrange on polymer, and polymer is responsible for IVC compute. And then this is kind of like we have a relay or off chain that will relay some data. Both the Lagrange stick to attestations, the polymer, as well as the actual packet information to be executed on the destination chain. I'll stop there for, and I'll resume back to this high level diagram if Ishmael or Kashish wanted a few words.
00:06:32.624 - 00:07:22.142, Speaker B: Yeah, so one of the things I wanted to mention here that I think that Bo touched on, but I wanted to make even more explicit, is the really exciting thing about the state committee integration with Polymer is it's not just going to be consuming state committee proofs on polymer. We're also going to be instantiating a state committee for polymer. That means that you are able to have these fast finality guarantees of polymer state, and these fast finality guarantees of polymer state verifying state from other roll ups. So it really makes polymer this fundamental central point in this interoperability journey, where all of the state, for all of these roll ups becomes accessible directly through the state committee that's verifying polymer states, be able to take polymer state and economic security.
00:07:22.318 - 00:07:23.062, Speaker C: And.
00:07:23.238 - 00:07:29.434, Speaker B: Yeah, you can take polymer state and security behind polymer state and use that to access state from anywhere.
00:07:30.254 - 00:07:37.438, Speaker A: And I see here that we're also mentioning a ZK coprocessor. Is there anything you want to highlight about that, Ishmael?
00:07:37.566 - 00:08:28.684, Speaker B: Yeah. And so, one of the things that we focus very heavily on at Lagrange, as well as the state committees, is our, is our ZK coprocessor. And so as we start instantiating these state committee for an execution space, and being able to have these secure representations of the block header, we're able to use that as input for ZK coprocessor to be able to compute really batch proofs or any type of expressive computation directly over the state of any space. So you can take, for example, polymer state, and you can use polymer state as an input into Lagrange's processor as well. And you can compute some very interesting moving properties and historical data over polymer states. And I think that's something that we're obviously very, very excited of integrating with and exploring with the polymer team as well, especially given anywhere we can plug in Lagrange infrastructure. And the polymer infrastructure makes me very happy.
00:08:29.384 - 00:08:47.399, Speaker A: Yep, 100%. And in terms of this other ecosystems era that we're seeing, obviously, given the IBC tech that is being used, I'm assuming that it's in the cosmos ecosystem. But in case there's other areas of interest that you guys are pursuing as well. Anything you want to highlight there, Bob?
00:08:47.431 - 00:09:23.444, Speaker C: Yeah, we're primarily focused on Ethereum roll ups for now, but I think there's going to be a bit of the work that we're doing and also the work that a number of other teams are doing for potentially the convergence of multiple ecosystems over IBC. I don't think this is a one team mission. I think this is like a vision that a lot of folks believe in and support. Also, to Ishmael's point, it's kind of describing how you're reading this aggregated state across chains. It's like state section powered by Lagrange and Eigen layer. Cool.
00:09:23.984 - 00:09:41.944, Speaker A: Yeah, that's one of the things that you necessarily didn't think initially when we started building all this on the state section, turned out to be a thing. Right. So really cool to see. Is this diagram or anything similar to it? Can it be found on your website or anywhere?
00:09:42.484 - 00:09:47.404, Speaker C: This is an announcement blog, I think, that's supposed to go out in a few days.
00:09:47.564 - 00:10:05.224, Speaker A: Awesome, great. So by the time people see this, it should be able to be referenced. Well, I think that's sufficient context for us to start getting into details of things a little bit. So I think, bo, you wanted to share some code or some diagrams, right?
00:10:05.624 - 00:10:34.376, Speaker C: Yeah, sure. I can do a quick, high level overview of polymer, just so people have context on what we're actually trying to do here. Let's do it. So we have this protocol internally called virtual IBC, and at a very high level, it does this. So there is a bunch of logic in the IBC transport layer. There's a bunch of logic around how it handles messaging, how it handles authentication and so on. And polymer decouples that.
00:10:34.376 - 00:11:09.734, Speaker C: So we no longer execute that on chain, we execute that on polymer, however, we need to prove this execution. So this is kind of where Lagrange comes in. So like polymer needs to store some verified state of the virtual chain, EVM enabled or otherwise. And let's say this is an EVM L two, and then we use Lagrange's, let's say like IBC. So Lagrange's like client as an IBC live client to prove the state of the virtual chain here. So if I give like a more detailed view, it kind of looks like this. We have some set of smart contracts on the virtual chain.
00:11:09.734 - 00:11:34.904, Speaker C: We have a lite client here, and this would be actually the Lagrange lite client. So this not native, but like Lagrange litecoin would be here. And we would update the state of the Lagrange lite client based on the state committee attestation. So we know what the state of the virtual chain is. And then we'll prove some information about, I would say like IVC messages that were executed on the smart contract against the validated headers by Lagrange.
00:11:38.204 - 00:12:44.814, Speaker B: I think that was very well described, and I think this kind of falls back into something I've heard Beau talk about for I think he was the first person I heard talk about this. So this concept of modular interoperability, the fact that you have basically, what is an assertionist state, a transporter state, that a computational state being three intrinsic components, I believe, of every interoperability protocol, where you think of a messaging protocol today, it takes its own assertion of state, its own transport of state, and it checks a receipt. You think of a bridge, it takes its own assertion of state, its own transport of state, and it checks a transaction. But as we think of the unbundling and the extension of these primitives, what you're able to take is protocols that are able to take external assertions of state, have a standard for transport, and then a standard for computation or checking of something on top of that. And I think when you think of that type of architecture, what you can get to is interoperability protocols that from a sum of the integrations that they have, have a much wider set of features and a much higher posture of security than the generation zero or the generation one protocols. And I think polymer is in my view, one of the first protocols pioneering this.
00:12:46.474 - 00:13:31.178, Speaker C: Thanks for the compliments, Ishmael. I won't claim to have invented any of this. I would say that my observations, my observations were merely observations of how the IBC protocol was designed. IBC protocol came before myself and has been around for a number of years. I think the spec itself dates back to 2019 or earlier than that. But what I will say is that from my perspective, it seems like the industry is moving this direction. Broadly speaking, IBC or not, many different interoperability protocols are modularizing or attempting to modularize so that they can swap in verification layers like Lagrange, and not have to build these themselves, which I think is the right direction to go in.
00:13:31.178 - 00:13:38.214, Speaker C: And also leverage a lot of these verification layers built on top of Eigen layer as absent.
00:13:38.514 - 00:14:06.324, Speaker A: Before we dive into the code, I would like to take a second here, maybe to go through your history of how you came across IBC, especially in contrast to what you were doing before at Uber, doing the server systems, looking at istio, mesh service, all that stuff, and how that translates to what you're thinking about division for what polymer is trying to do, because I think that's super interesting and I would just love to cover that very briefly.
00:14:07.424 - 00:14:37.484, Speaker C: Yeah, I can do a quick tldr. So I spent a lot of time working on distributed systems at scale at various startups, including Uber. When I first came into this industry, I found IBC relatively early on. I think it was appealing to me from an engineering perspective. At the time, I believe it wasn't even launched yet. It was appealing to me from an engineering perspective because it was the only interoperability protocol with an actual specification. I know it's not like a super high part to clear.
00:14:37.484 - 00:15:43.420, Speaker C: It was like I wanted to learn how all this stuff worked and it was only one that had an actual spec that I could read. Not to disparage Polkadot, but I think I looked at XCMP back then and I think there was this one paragraph on it and I couldn't find any code. So I was like, I don't know. I'm not sure if this is real or not. So I think over time, as I like read this specs and learn more about IBC, we became much more bullish on betting on the long term vision for IBC, but also realized that IBC in its current state was a good lower layer protocol. So a lot of the things that you mentioned, Nima, are kind of not like they're built on top of base layer networking primitives. So you have some sort of base layer like TCP IP like transport protocol, and then you have to build all this automation or suite of services on top to make this protocol work better for microservices and work better for microservices at scale to handle service discovery, authentication, and all these other feature related things that aren't just related to the transport of data frames.
00:15:43.420 - 00:16:18.924, Speaker C: So I think there's a gap there that needs to be met. And I think the gap will only increase as a number of L2s or like microservices in this world are built out. So it is a little bit early to be thinking about these things. I think a lot of interoperability protocols are mostly thinking about the perspective of how do we transport data. So like I have some data on one chain, how can I verify on another chain? I think that is a good starting point, but I think we are going to end up in a world where perhaps there's like millions, maybe even billions of tiny roll ups that do specialized things.
00:16:19.704 - 00:17:06.990, Speaker A: Yeah. Part of what I find super fascinating about this is when you're looking at the unbundling and bundling of the different parts of the stack here, how, yes, the crypto infrastructure can evolve in contrast to how the OSI model across the networking stack evolved. And what we're going to end up seeing, um, that now we're building all this in a byzantine environment, whereas like we had distributed systems before, right. We had like things that were like, you know, cross continents, et cetera. But like how do you do that with like when you need consensus of some sort. Right. So I knew, as you said, still, we're still early on, but like the things that we're seeing are definitely promising, I would say, you know, but both of your projects being shiny examples of that.
00:17:06.990 - 00:17:13.244, Speaker A: So I think, yeah, let's dive into the code and see how things actually work.
00:17:14.104 - 00:17:36.404, Speaker C: Yeah, absolutely. Let me show my screen. Cool. So I'm starting here. There's a bunch of definitions here. This is a profile where you define the state committee attestation. We just call it block data here.
00:17:36.404 - 00:18:01.104, Speaker C: It's the data structure returned by Lagrange API. I do want to call out that in here we have a single chain header for now. This is the initial integration. But now Lagrange also supports batches of headers or so like batch l two block data. So I have this commented out comment here is showing that it can be repeated chain headers, so multiple. These can be kind of like framed like a batch at a time. You just connect them together afterwards.
00:18:01.104 - 00:18:43.432, Speaker C: The outer message definition is IBC like. So we have this concept of an IBC client and IBC client state, and then this block data will feed into that IBC client state once verified. So these are, we're connecting IBC abstractions with the Lagrange like client data structures here. So I'm going to move on to other verification works. So when we try to attempt to verify this block data, the most important function in our code, and this is defined on this IBC client. So like if you look at the path here at the bottom of the screen, you'll notice that we have this path. It's in the liteclients folder.
00:18:43.432 - 00:19:16.064, Speaker C: We have a Lagrange like client. This is the implementation of that and a like client. Obviously there's two separate high level functions of a like client, a like client, or in an IVC context. One, the lite client does a verification of the state of the counterparty chain. That's the code that we're going to walk through right now. And as a following step, there's a code to verify that something actually happened, what happened on the chain. So I have verified state within that state, what is the event or IBC message that we want to verify.
00:19:16.064 - 00:20:15.020, Speaker C: So the consensus verification in this case we use the Lagrange, or the way we verify the Lagrange block data is we see that we have a BLS signature scheme that we use so that the attestation committees themselves use BLS signatures. And what we're doing here is we're saying that we want to see that all of the keys or the voters of the block here we're creating this hash. We want to compare. All these voters in this block belong to the current committee. So the security property between Lagrange state committee attestations work similar to IBC client where you bootstrap from a trusted set of validators. So you have this like trusted initial bootstrap of a client and then from there you can link all the committees to one another each. Like Ishmael said earlier in the call, each committee votes on the next committee.
00:20:15.020 - 00:20:50.440, Speaker C: So we want to be sure that the signers of the incoming block, or actually the current committee here. So this is the check that we're doing right here. Once we've done that check, we want to then check that their signatures are valid based on the hash of the block data itself. So here there's two lines of code. One line of code is for the singular header that we've implemented. And I have this commented outline to show that this could be also like batch block data or batch data. So for multiple headers, but we'll just walk through this one for now.
00:20:50.440 - 00:21:25.926, Speaker C: So we're not going to dive into this function implementation, but just know that we're comparing the public keys which we've abstracted from the standards of the block which we compare to the current committee. So we've kind of like made sure that security property is satisfied and then we verify that this aggregated signature is valid based against this commitment hash. And there's some other information here as well where we check that the current committee is aligned with the next committee. So this is a very important check here. I won't walk through all the checks, but I'm just going to highlight a few like these.
00:21:26.070 - 00:21:26.774, Speaker A: Yeah.
00:21:26.934 - 00:22:08.014, Speaker C: Okay. So at this point, once we verify the commit, the state committee commit attestation, then we can say that we can store these validated headers in the polymer chain. So once we have a validated header, I'm going to walk through what we actually validate, what IBC message, how we actually validate the IBC messages within that. Next. So here we have this validation logic where we take, if already verified, client and consensus state. So client state is the overall state of the Lagrange. Client consensus state is either a single or a batch of headers that have been already validated against that client.
00:22:08.014 - 00:23:02.042, Speaker C: And then we have some IVC messages. So someone can post these IVC messages, but they have to be validated against events that were omitted from our IBC dispatcher contract on the chain itself. So the first thing we do here is we check to see if the IBC message which is here, which is here, is actually a receipt. There's actually a log for it within the header. So we've looked for the, so we match the, the IBC message to the receipt first and then we check that this is valid. So in this check what we're doing is we're separately verifying that the transaction is part of the transaction route in the header. And then we separately, then we verify that the transaction receipt is part of the receipt route in the header.
00:23:02.042 - 00:23:20.914, Speaker C: So now at this point we've connected all pieces of information that were validated based on the Lagrange state committee attestation to the actual IVC message or event that we, that we have observed. And that's pretty much it for the high level overview. I'm going to stop sharing my screen now. Got it?
00:23:22.254 - 00:23:29.102, Speaker A: Yeah, thanks, thanks for that. Before I dive into my next thought, Ismail, is there anything you want to highlight here?
00:23:29.238 - 00:24:48.884, Speaker B: Yeah, so what I really like about that demo that Bo just showed is it really is able to show the instantiation of the state committee verification flow within a schema of IBC messages and IBC packets that is amenable to how the transport structure of polymer requires and this is something that we have aspired to do within the state committee design, where you can in fact have multiple paths for verification of a given state proof that ideally allow it to be composed into interoperability solutions like polymer, in ways that don't require a deviation from how those protocols are designed to function, where you can have ideally this abstraction of what is a secure representation of state that is super easy to consume, irrespective of how you would like transport to occur. And obviously, polymer is by design. With IBC, it is what I'd call a structure on transport, but very flexible in the state. It can support as input. And we like that to be able to have our state proofs fit in there as, as one of the places that polymer can derive state from. And so I love the fact that the demo kind of shows, we showed our verification code previously at one point where it's written in our schema, and this is kind of the instantiation of that in polymer schema.
00:24:50.304 - 00:25:40.488, Speaker C: From a consumer perspective of this technology, I would say that it greatly accelerates our integration timelines with different chains. The only other option that you have, if you didn't have the state committee solution would be to verify the settlement logic of the roll up itself, which there is some variance in how that's done. Therefore, you have to build and maintain these clients and these chains, or these l two s are also improving and updating their settlement logic. So you have this, you're always updating your client logic as you go there as well. So this kind of definitely reduces the load that we, the workload that we, that we have on the integration side and also increases the pace of integrations for us. And also like, it creates a permissionless way in the future for any new world to kind of instantiate a state committee for their execution as well.
00:25:40.656 - 00:25:53.684, Speaker A: Yeah, 100%. Can you expand a little bit on now that having those integrations are a lot easier for you, what that means for you or developers consuming this tech going forward?
00:25:54.304 - 00:26:26.644, Speaker C: Yeah, so as long as there's a state committee that can be stood up for a chain, the client template can be reused across all state committees. So like the state committee could be attesting to like, let's say like, like 100 different flavors of rollups and let's say the flavors of ropes increases over time. Palmer no longer needs to, technically no longer needs to maintain 100 different clients that we have to update and maintain. We can just maintain one client for the Lagrange state committee and it would work function roughly the same regardless of how the internals of the roll work.
00:26:27.864 - 00:26:47.088, Speaker A: Yeah, no, with chain abstraction, and I guess again, going back to unbundling of how these different execution environments are coming online, this primitive just becomes more and more powerful to have. So I don't know if my other should you want to say anything about how this is exciting for you guys?
00:26:47.216 - 00:27:46.168, Speaker B: Yeah. What I really find exciting about this is the ability to have new execution spaces that are configured and designed by a developer without requiring permission. Integrations into interoperability protocols. Right now, if I was to instantiate my own roll up, I would have to call up and petition my cross chain providers, my oracle providers, I have to partition and I have to basically try to convince a bunch of other protocols to integrate with my roll up. So I really, I have permissionless ability to create roll up, but I don't have the permissionless ability to create a roll up that has the basic features of a general purpose execution space. And so it's this kind of unfortunate trade off right now where you can't instantiate a roll up and have a clear path to having that roll up supported by interoperability protocols in the space. And so what I love about the state committee is it creates this abstraction for a roll up developer to say, here's my roll up, here's my state committee.
00:27:46.168 - 00:28:32.934, Speaker B: If any of these protocols have ever plugged into a state committee, they can now plug into my roll up. There's no me needing to convince you of my settlement logic, me needing to convince you of why you should support me instead of someone else. It's all permissionless. I think this is a extension of you have permissionless security guarantee, the ability to have to have permissionless restaked avss developed on eigenlayer. And then now you have the ability to apply those and to apply restaking enabled like client to an arbitrary execution space that then can be consumed by a cross chain protocol and proofs from that can be consumed by a crosschain protocol. I think that is this very kind of natural flow and natural progression of where the security is being placed and what that security enables.
00:28:35.444 - 00:28:43.464, Speaker A: With this unlock in place. Are there things downstream of this that you're keen to see come alive?
00:28:45.724 - 00:29:12.244, Speaker B: Yeah, I think you can have very interesting things related to cross roll up orchestration or cross roll up kind of load balancing of transactions similar to chain abstraction. As you start having out of the box interoperability, and when you can start, you can create a move roll up and you can create an EVM roll up and you know, day zero, they can communicate because they've both instantiated a mechanism at inception to be able to have permissionless IBC communication, for example.
00:29:14.624 - 00:30:39.350, Speaker C: Yeah, this whole theme is very exciting to me. Like the theme of permissionless infrastructure, or permissionless decentralized infra, especially like how easy it is to bootstrap certain things on top of Eigen layer AbS's, I think so my view on avss, broadly speaking, is that they're kind of like a storefront to your SaaS services, to some SaaS services. So it's like decentralized SaaS, and then you have some sort of storefront where normally, like, let's say from the security perspective, you would have to bootstrap your own validators, you have to bootstrap your own security. Whereas with this IBM layer, ABS storefront, you can purchase security, you can supply some incentives, and then you can get some stakers that want to provide security to your protocol. But I'm very interested in the long term of ABS is where I feel like it doesn't necessarily just have to be security. You can have infrastructure automation, which is something that we're looking into, where you can have things that can further, I guess, like bolster this theme of permissionless infra with these AV's like storefronts. Otherwise you can just a website, have someone enter their credit card and then pay for some services, and then you act as like the sole operator of these services and executor of whatever that agreement is.
00:30:39.350 - 00:30:45.194, Speaker C: But this is kind of like an on chain decentralized SaaS storefront. I don't know if that's.
00:30:45.294 - 00:31:47.656, Speaker A: Yeah, yeah, no. Having seen companies in the webtoon space scale out of necessity to the limits that they have, whether it's like Uber or Facebook, whatever. A lot of it had to do with how they engineered their services around this microservice infrastructure. You have hundreds if not thousands at some companies. So being able to horizontally or vertically scale each one independently of each other, and being able to, I guess, apply that design pattern securely and permissionlessly. Again, in this context, I think it's very hard to fully grok what this design space will actually enable past the first or second order levels as well. Once we see these systems come alive, you're like, oh, whoa, I didn't even thought like, you know, smashing these two or three different, like, pieces of tech together would enable this other use case.
00:31:47.656 - 00:32:07.634, Speaker A: So I'm also extremely excited to actually see this happen. I think it's about time, right? We've been at it since like, what, 2008? So, yeah, I think. I think we're in a good place. Now, is there anything else you guys want to highlight with either your own tech or the integration or anything else?
00:32:08.014 - 00:32:58.234, Speaker B: No, I think one of the things, I guess the last thing I want to highlight is right now we have state committees instantiated for two roll ups, optimism and base. But we have a very aggressive roadmap over the next two months to try to put state committees on as many roll up execution spaces as possible. And I think it's a priority for us to build out on two fronts, which is build out how to integrate with folks like polymer to make sure the state is useful to somebody and then build out the other side, which is making sure that we have enough state to be useful. And I think the thing we're very excited about is that it has to date the operators in Eigen layer have been very amenable to extending and expanding what they deploy for Lagrange and to be deploying and building out new state committees for new chains. And we're excited to continue to work with them to support more.
00:32:59.584 - 00:33:02.804, Speaker A: Awesome. Bo, any final remarks?
00:33:04.624 - 00:33:08.164, Speaker C: Nothing additional. I think I probably talked too much this video already.
00:33:09.704 - 00:33:21.120, Speaker A: Awesome. Well thanks so much guys for taking the time. Loved getting time to do this and excited for future developments. Keep pushing the boundaries here.
00:33:21.312 - 00:33:23.664, Speaker B: Thanks so much Nima, thanks so much for being here. Bo, with us.
