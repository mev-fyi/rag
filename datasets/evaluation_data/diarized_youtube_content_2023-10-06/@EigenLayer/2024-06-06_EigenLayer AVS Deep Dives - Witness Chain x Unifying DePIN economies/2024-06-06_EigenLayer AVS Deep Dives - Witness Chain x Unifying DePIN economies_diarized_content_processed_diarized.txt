00:00:12.800 - 00:00:40.954, Speaker A: Hi everyone, I'm Nima. I'm the ABS research lead at EigenLabs, where we work with a variety of projects building on top of the eigen layer protocol we have here with us Pao, who's the head of research at witness chain. She will be walking us through what Witnesschain is doing as a deepen platform and their first project, a watchtower network, and how that's designed the use cases, motivations, etcetera. So without further ado. Yeah, please.
00:00:41.934 - 00:01:43.132, Speaker B: Thanks Nima for the introduction. Hello everyone. So today I'm going to introduce the technical framework of Windows chain and demonstrate how to interact with our system. And I'll start with some high level overview of the system design of our deep coordination layer or ensure DCL, and then work through some smart contract interfaces and also explore specific use case of the Watchtower network. So to just give you a bit more context, Windows chain aims to unify the deep end economy by creating a platform where diverse deep inside converge to create shared values. And we know physical infrastructures are a natural fate for decentralization, but they've been taken over by those manipulative companies due to the high capital requirements. But today, thanks to our community and the blockchain platform, more and more deep ins are awakening to their decentralized nature.
00:01:43.132 - 00:02:54.188, Speaker B: But due to the variety of those physical assets and the complexity of dealing with them, one key challenge we identify is to coordinate different parties. And the coordination is crucial not only among those deep ins themselves, but also with other applications in the digital world. So at the core of our solution is building physical trust by establishing consensus on physical states. As you know, people like trust bitcoin or ethereum, because they established the consensus over the balances, some like these digital states. So similarly for deep, it's necessary to establish consensus on the physical states. And we have developed a series of protocols that can reliably verify those physical attributes such as location, bandwidth and competition. So each this protocol represents some research breakthrough in this respective field, and together they serve as the building blocks for developing a deeping application that require physical trust.
00:02:54.188 - 00:03:55.094, Speaker B: So, and this trust are further will be anchored by the economic trust supported by eigolayer. So I'm going to share the screen here for the structure of our deep coordination layer. Yeah, so here's the main architecture of our deep in coordination layer. So on the right hand side, we have categorized four clusters of entities involved in the system. They could be deep in chance, which are the provider layer, where physical infrastructure resides and the state information originates. We have over 20 dpm partners and many avss also sit in this layer. They can use the proofs as needed, for example to incentivize their geo decentralization of their own operators, or to set up some regional constraints based on their applications needs.
00:03:55.094 - 00:04:55.470, Speaker B: And we also have so people can join the system as an application builder. This includes the developers, users, investors, because they can build deep in depth and participate in the financial protocols around these physical assets once they have consensus on the states of these assets. And so as we mentioned, the core of the system is the proof, the set of proofs, so people can also join the system as a proof. System contributors and our system supports pluggable proof of x. That means besides the protocols we already boot, we also allow our community to innovate and extend their validation processes tailored to maybe their specific vehicle assets. So in terms of this layer, there are very diverse ground for the integration and collaboration. I'll give you some examples.
00:04:55.470 - 00:06:18.334, Speaker B: Like one of our partners, Andrina, they're providing the network infrastructure. They're working with us on a new implementation of our proof of backhaul protocol with the DPDK framework as a strategic solution to verify, to have high bandwidth capability in their specific hardware nodes, because so they can implement for backhoe protocol, then bypass the, they can fetch the traffic directly through the network instead of like to bypass the OAS processing time and some other example for the daylight, which is also our partner on the energy infrastructure side. They propose their own protocol to verify the flexibility of adjusting the energy devices. Because the energy devices, they may have different types of capacity and we need to verify. They will also use the prolocation to first make sure that any device is in the same building of the monitor of the other device. And then after that they can use their monitor to further send the data. And the challengers can help verifying the capacity and whether they can just change the states as your request.
00:06:18.334 - 00:07:15.924, Speaker B: And so behind this progress, what we want to do is to set the new standards for how the physical trust is built and maintained. And at the bottom layer, we also have all these operators from eigen layer mainly, and also other community partners. They are entities that actually running the challenger client software. And they will for example register on Eigen layer first as operators and allow those risk takers who delegate to them. And they are the entities that take the responsibility of providing economic security and monitoring activities in those challenges. And our partners can also participate in this layer. For example, Geo Net, they have a bunch of operators like to run our proof of location protocol, provide a very high accurate estimate of the location.
00:07:15.924 - 00:08:26.406, Speaker B: So at this stage our proof of diligence protocol is already live on Mannet together with Eigen Layer's mainnet launch. And these protocols are mainly running by those watchtowers, the operators for monitoring the roll up states and therefore proof of location and bandwidth. We have a version on their testing and we also expected to launch them in the next couple of months on the medinet. And before diving into the details of each proof, I will first discuss our general interfaces provided for different participants to access the system. So here this this diagram depicts the architecture of our deep in coordination layer, smart contract and some of the off chain components and off chain interface. So the smart contract side features three main modules. The first is the challenger coordinator contracts.
00:08:26.406 - 00:09:46.996, Speaker B: This is designed like for each proof you need to provide a standardized way to first to create a proof specification and also coordinate the proof generation and the challenge process. And also you need to specify how we can verify the proof on chain. It can be as simple as the signal track or like include any other complex rules on the chain. And besides contract, each proof also need to develop an off chain part including the proverbial and challenger client to measure the corresponding physical state. For example for the proof of location or bandwidth you may implement the challenger client to send the Internet measurement packets and the response this kind of logic and the second category is the registry contract to maintain the on chain identities of different parties involved in any proof. This could include approvers, challengers, stakers and even those tokenized assets and dipping different dipping chains. So basically any parties you want to have an identity on chain when participating approved to earn incentives or to build your reputation, you need to first register to participate.
00:09:46.996 - 00:10:49.218, Speaker B: And the third category are the basic interface contracts. And at this point we provide a request handler contract as the entry point of all applications to use any proof of x. So the request can contain a sequence of sub requests for different states. If you want to query the location and bandwidth of the SAM prover at the same time, you can just combine them in the same request. So this will facilitate the composability of proofs. You can simply issue a sequence of requests or you can further implement your logic to combine the proofs to further calculate a composer proof to implement a more complex logic. And so this is the basic architecture of our contract site and how the application can use it, where to send the request to and what is ack.
00:10:49.218 - 00:11:45.042, Speaker B: We will provide for different off term parts to run and then I will go through some details of the three protocols we already deployed the proof, diligence, location and bandwidth. So I will go to the website here. So we have some introduction and explanation on our website for different parts of the proofs and the roll up. Watchtower implementing the proof of diligence protocols is currently live. And look at this diagram. So just as a background, why we are going to design this proof of diligence protocol. Because as a key component of the burgeoning L2 economy, the roll ups are currently very essential for enhancing the scalability of those blockchains.
00:11:45.042 - 00:13:05.488, Speaker B: So the key idea, but the key idea behind the optimistic roll up is to conduct all the competitions off chain with only the proof and the updated state maintained on chain. So this system will remain secure unless some fraud dispute arises from the application layer and at which point it can be resolved by a set of like defensive validators in their rollout protocols through some on chain mechanism such as interactive verification games. However, there's a well known vulnerability remains despite the security layer already provided by those defensive validators, because there's no inherent guarantee that these applications will consistently monitor the assertive states. And this critical question then becomes how to ensure the diligence in this normal path when there's no fault? And in other words, who is watching the watchers? So our protocol is designed to solve this problem. We introduced the concept of these watchtowers. They backed by the stakes and economic security and they need to run this proof of diligence protocol. The main idea is watchtowers.
00:13:05.488 - 00:14:19.734, Speaker B: They're incentivized to constantly monitor transactions during normal pass off operation. And they will operate independently and only interact with the existing roll up system if they detect some incorrect state. And to ensure they fulfill their watching responsibility all the time, they must provide this proof of diligence for earning the incentives. And meanwhile, other watchtowers also need to watch the process of this proof of diligence and verify the proofs accordingly. So to go through the diagram here, we have some with windows chain, here the incentives we call the bounties. And we will first initiate some bounties for each L2 chain for monitoring. And then the bounty miners, those watchtowers, they will register first and then upon receiving some event from the L2 contract, those clients will start validating the states by chasing the transactions on the L2 archive node where they will also run an opinion for the proposed block.
00:14:19.734 - 00:15:23.294, Speaker B: And if they find the state, after recomputing the state, they find they're consistent. And they also need to see whether they are self selected as the bounty winner. If it is the case they will go and submit this proof of diligence which is some hash commitment computed from their own transaction chase route. And after that, on the other hand, if they find something like any inconsistent consistent state happens, the watchtower will submit an alert to this alert manager contract in addition to provide a proof of diligence. And on the top we have an aggregator, which currently is a centralized entity to aggregate the proofs by listening on the events of those diligent proof manager contract. And it will compute the winning watchtowers and submit the winner details to the settlement contract. And further the rewards will be distributed based on the current execution.
00:15:23.294 - 00:16:18.614, Speaker B: So this roll up watchtowers are currently the major application of proof of diligence protocol. And at the end I will also go over a very specific application of it which is a transaction chaser API we built to implement anything like l two bridges where you can just be a light client. And beyond this roll up applications, we are also exploring the additional opportunities to use the proof of diligence. So for example, we recently released a paper jointly with Eigen Layer and Princeton University proposing an unconditionally safe flight client protocol for ethereum. So the protocol is developed on top of this proof of diligence protocol to provide a monitoring service for the proof of stake lite clients.
00:16:19.784 - 00:16:30.844, Speaker A: Hey, just a quick note before we move on, can you elaborate on what happens at step five when we interact with the alert manager contract? What does a contract do next?
00:16:31.544 - 00:16:32.564, Speaker B: Which one?
00:16:33.064 - 00:16:37.560, Speaker A: Number five, when we interact with alert manager contract at the bottom.
00:16:37.712 - 00:16:38.264, Speaker B: Yeah.
00:16:38.384 - 00:16:43.280, Speaker A: So what is the contract like? What does it take as input? What does it do with output?
00:16:43.432 - 00:17:46.896, Speaker B: Yeah, yeah. So this alert contract is also the only connecting point to the existing roll up system because they also, the existing roll up scheme also relies on those flow proofs to actually like detect when thumbs, when the assertive state is wrong. So at this point they will, on the one side for our protocol, they will, there will also be some like slashing. It will further connect to the eigen layer slashing mechanism because if they detect the status order like send something wrong, they can further resolve this dispute on chain and determine which one is incorrect, which one is correct. And further they can also connect to the roll up side to inform their defensive validators. So if they want they just subscribe to our service and listen to whether there will be some alert. In the normal past everything is good, the incentives is provided by our bounties.
00:17:46.896 - 00:18:00.936, Speaker B: But when something went wrong, they will just receive the alert and trigger their own dispute pass to ask their defense validators also validators. And then whatever schemes they already implemented.
00:18:01.080 - 00:18:18.374, Speaker A: Right. That makes sense. And just to reiterate, and then drive the point home here, can you go over which components are on chain both l one, which pieces are on LTU, and which pieces here are off chain components being run.
00:18:18.794 - 00:18:51.772, Speaker B: Yeah. So here all the, so here, all these contracts are witness chain contracts. They're not deployed on l two. Yeah. And then all those. So these contracts are just on chain contracts. And for off chain component, those watchtowers, they need to first, whenever they receive this, like the event, when they find there's a new state asserted on chain, they will run their own computation, re execute all the transactions off chain.
00:18:51.772 - 00:19:10.076, Speaker B: And they also run l two archive nodes to fetch these transactions to. So basically they need to first be nao two nodes, and then they will run additional like watching responsibilities. Then they can post anything they have computed back to our contracts.
00:19:10.180 - 00:19:18.104, Speaker A: Right. And top right. When we have an Eigen tower contract that lives on an l two. Right. Where does that live?
00:19:18.724 - 00:19:33.054, Speaker B: So this is, this is basically the reward, how the reward will be distributed in this contract. It can be combined. So it's still the contract of witness chain. We can set the rules of how to dispute the rewards.
00:19:33.474 - 00:19:37.774, Speaker A: Got it. But just curious, where does that contract live?
00:19:38.394 - 00:19:40.534, Speaker B: It's on our minute.
00:19:41.154 - 00:19:48.434, Speaker A: Okay. And the ligation manager in the bottom right is the algorithm contract that's on Ethereum L1. Right?
00:19:48.594 - 00:19:49.610, Speaker B: Yeah. Yes.
00:19:49.762 - 00:19:56.114, Speaker A: Okay, awesome. Yeah. So moving on to, I think you were going to cover the transaction tracer, right?
00:19:57.054 - 00:20:17.748, Speaker B: Yeah. So before that, I will also briefly go over the other two workflow and location. Yeah. And we can just briefly see how they works because we are going to launch them in a couple of months, maybe at that we can do another series of them.
00:20:17.886 - 00:20:18.684, Speaker A: Stewart.
00:20:23.544 - 00:21:14.864, Speaker B: Yeah. So then, so besides proof of diligence, the other two protocols we are actively built is the approval backhoe for testing the bandwidth and the proof of location. But so behind their like motivation, they have different motivation and different physical attributes, but behind that they have, they share very similar framework for the like how to verify the on chain, how to do the off chain monitoring. So we will introduce them together first briefly. The proof backhaul is akin to decentralized speed test. So the system will assess the Internet connectivity and its capability to connect to Internet of those DP nodes. So we also have those challengers.
00:21:14.864 - 00:22:11.816, Speaker B: So we have two basic, there are two entities, prover and challenger. Prover are infrastructure nodes and challengers are eigen layer operators running those off chain components. And the challengers will send small packets to the prover nodes measuring their backhaul bandwidth based on the response rate, which then will be aggregated to verify the proof. And there are three main stages, the challenge, request, setup and execution. So here for the execution, what we can see is. So there we have this general coordinate challenge coordinator for different proof x and whenever they receive some request for this bandwidth, they will send forward the request to both the prover and challenger. And here we will have some logs to implement how to select the set of challengers based on the request of the application and approvers.
00:22:11.816 - 00:23:11.420, Speaker B: Then once they receive, receive the notification the offshore parts, those challengers will send some signed packets. These are just a very small traffic because they will be aggregated before the backhaul link to strong traffic which is enough to saturate the link of this they want to measure. And then once the prover receive enough packets, it will also generate compute the hash of those packets and send it back to the challengers. And these challengers, they will start a timer at the beginning of the challenge and stop it when they receive the response from the approver. So that will give them some measurement of the round trip time of the process and then they just report it to the coordinator. We then we will have some aggregation algorithm like computing the medium. So for robustness something like this.
00:23:11.420 - 00:24:06.734, Speaker B: But the logic is very simple and the off chain part is very lightweight, you can even run it like from your phone. And then for the proof of location it's similar. So the architecture, we have different diagram, but we can see it's very, the logic is very similar here. So the goal of prolocation is to determine the geolocation of DP nodes. But we still need to use Internet measurements like the round trip time, then convert it to the distance because distance is not directly measurable. So we still need to measure the time it takes for those Internet packets to reach the prover nodes. And this method will further utilize some like principle of data transmission speed and Internet geometry for accurate localization.
00:24:06.734 - 00:25:07.720, Speaker B: And the main, the basic method to determine the location is through those triangulation. But in deepening scenarios, we further need to consider the adversary behaviors like how about what if the prover nodes use VPN or they will clue to manipulate the measurements from some challengers so even the distance, how to accurately measure the distance from Internet delay. So these are all the problems we are going to solve. And to tackle these challenges we propose this protocol which consists two phase. So first is the calibration phase where we will utilize some byzantine resistant data inferencing techniques to robustly translate the delay measurements into the actual distance. And the second phase is the actual measurement. And we will also combine those cryptography primitives to bond the uncertainty of the claimed allocation.
00:25:07.720 - 00:26:06.784, Speaker B: But in terms of how to use it, it's similar. We have the coordinator and you can send the request specifying who will be the prover and what is the claim the location. And then the challenger will, the coordinator will select the challenger based on the claim, the location, select a set of nearby servers, they will together send packets, data packets to the prover to ask me the time, then the distance. Then together we'll figure out the uncertainty of your client location. Yeah, so this then after going through the basic principles of how these different protocols work and how we can utilize it. Lastly, I would like to go over some use case of the proof of diligence, what's our networks and the transaction tracer and its APIs. So we're back to this.
00:26:06.784 - 00:27:18.474, Speaker B: So basically the transaction chaser is built to provide fast finality of those l two transactions. So typically if you're running some l two node you want to for example consider the scenario in a bridge for l two l one, or like any two roll up chance. If you want to know, you send a transaction on one chain, how it can monitor the states. Maybe we will use just an RPC server to query the transaction, but there could be various issues such as the rate limiting or the service downtime. So to address this potential problem and also further, we want to incorporate some faster fidelity rule and insurance scheme. We provide this method allowing users to trace the transaction through the responses from multiple watchtowers. So this process enables users to receive those multiple perspectives on the same transaction and they can verify its finality based on the consensus among these watchtowers and further backed by their stakes.
00:27:18.474 - 00:29:00.944, Speaker B: So it's particularly crucial for high value transactions where users may want additional security and they can also customize their security based on the total amount of stakes used to secure this watchtowers. So we offer this transaction tracer API for this purpose and the users or applications can make this API request which are handled by the coordinator. Then it forwards this request to several watchtowers, then aggregates this response to determine the consensus on the transaction state before returning the results to the users. So this then here we provide basic interface for you can directly send API call here and there are some interface for handling the logging the registry. But the main function is this chase and the inputs are simple, you just need to provide the chain id, the transaction hash and a random request id for checking purpose. And the response will include the status? Yeah, the response will include the transaction status indicating whether it is finalized or whether it has been derived directly from an l one block and whether it's safe or unsafe. Users can review the details of this data from each responding watchtowers and each of which will sign their submission to ensure the accountability.
00:29:00.944 - 00:29:26.882, Speaker B: So the Doc also will highlight any consensus reached. So here, this is an example. So there's nothing here. But if we have, if they have any consensus reached among these watchtowers, it will show in this field and allowing users check the transaction status history and timing, like how much time you take from one stage to the other.
00:29:27.058 - 00:29:40.134, Speaker A: So in this consensus field, when we say on status and it's empty, what does that mean exactly? And what are the possible values for what on status could be for the consensus field?
00:29:40.674 - 00:30:28.308, Speaker B: Yeah. So this will depend on like what is the rule you requested from the set of watchtowers you select. For example, you can ask where you will only accept the transaction. If everyone says this is committed. Then at that, of course, you need everyone to be live, can get a valid response, but you will also get the maximum security out of it because anyone, if anyone is wrong, you will not accept it. And at least if someone want to like mislead you on the result of some transaction, it needs to corrupt all the watchtowers, right? Yeah. You can definitely like program your security need like have some trade off the likeness and security.
00:30:28.356 - 00:30:34.980, Speaker A: Is that part of the request parameters that get sent? Because I only saw three and I was wondering if you were to use it.
00:30:35.172 - 00:30:45.110, Speaker B: Yeah, at this stage, we just implanted the simplest one that required everyone to respond. And yeah, I think later we can make it programmable to any other rules.
00:30:45.222 - 00:30:55.874, Speaker A: Makes sense. And going up a little bit for the second field and results where it says safety, what does unsafe imply here?
00:30:56.334 - 00:31:27.354, Speaker B: So the unsafe, so the status here reflects like what is the, if there's, if we have a bunch of watchtowers, but only like several of them respond, we will mark it as unsafe. And unless everyone is respond, or if you set up your security limit and the watchtower reach this threshold, then it will become safe. And also if the security is directly derived from l one blocks, then it's safe.
00:31:27.854 - 00:31:51.644, Speaker A: So I'm guessing when you add more request parameters to specify the type of security you want as a result of that, this safety field will give you a quick indicator of the result of that request being sent as opposed to you having to parse a specific enum from the consensus field later down below.
00:31:52.104 - 00:31:52.936, Speaker B: Yes.
00:31:53.120 - 00:31:54.888, Speaker A: Okay. Makes sense.
00:31:55.016 - 00:31:58.008, Speaker B: So this will contain some details of the consensus.
00:31:58.176 - 00:32:17.902, Speaker A: Yeah, no, this makes a lot of sense. And in terms of the chain id, and I noticed, yeah. Chain id was one of the request parameters above. Yeah. So what is the set of chains that are currently supported?
00:32:18.078 - 00:32:45.938, Speaker B: So currently we've been monitoring the, there are two chains, you can check the website here. So we have a base chain and optimistic chain, but these two are currently on the testnet because, because of some like supporting thing. But we can like quickly to the, to the mainnet.
00:32:46.106 - 00:33:11.464, Speaker A: Got it. Got it. And yeah. So going back to the, the API and the transaction tracer. Yeah. Curious to get a sense of what some of the apps are that have indicated interest in using this API so far and potentially down the road as well.
00:33:12.124 - 00:34:06.172, Speaker B: Yeah. So the very immediate use case we are or this is developed for the bridges. So if you, for any like roll up chains between l one l two or like two l two, if you want to just check the transaction submitted on the other chain, you can directly use this API. And also further, we will incorporate more complex mechanisms like insurance because now like to determine whether some roll up chain is finalized, you need to, you have a challenge period too. I finally confirm its finality that like with this program or security behind it, we can get the faster finality immediately. And then once something from you will get like insured. This is some, this is also some like study we, I've mentioned before.
00:34:06.172 - 00:34:26.380, Speaker B: So. And not only the bridges, we can also implement like client to any chance if they have a large, any proof of stake chain, if they have large set of validators. And like client don't want to just verify the signature of all of them, they can just subscribe this kind of API to check the transaction status.
00:34:26.572 - 00:35:36.954, Speaker A: No, this makes a lot of sense for some of the immediate use cases that come to mind and the impediments that we're seeing right now in history and where more security could definitely be used to offer, as you said, faster finality or um, overall smoother experience for how you're relying on these uh, products to work, whether it's bridges or otherwise. Right? Um, yeah. So moving, moving beyond the immediate use cases a little bit, I'm curious to get your sense of since you know, this is your bread and butter, you've been thinking about this for um, years at this point. Now that you're seeing this sort of protocol come alive, what are some of the perhaps medium to longer term things that you see this design space unlocking. Maybe it's like proof of diligence as a starter, but as you said, there are other protocols that you're working on with location and bandwidth and other proof protocols as well. Maybe it's one of them specifically or it's a combination of them. But zooming out a little bit, having these primitives, what are you personally excited to see?
00:35:37.334 - 00:36:14.140, Speaker B: Yeah, exactly. So we start working on this from a very specific field, from those networking. So that's why our first several protocols around those network attributes. But then we realized that the deep end world is very diverse and there are many different assets. Each asset have different attributes. And like some of attributes, even like different protocol, different assets, they will share some common features. But even the same asset, it can be, it can have like very different aspects we want to measure.
00:36:14.140 - 00:37:02.118, Speaker B: And this is the motivation of like established a physical consensus layer on top of that. And then in terms of this proofs, these proofs will definitely be the building blocks of this layer. So. And we is impossible for a single person to cover all the aspects. So we are to establish a forum which is similar to like 8th research. We're starting like discussing all this interesting problem on Ethereum for those digital consensus for different kind of security concerns. And here in a deep in words, we want to also establish such a forum for different parties to think of and discuss and also find the synergy between different sectors of the deeping and how they can.
00:37:02.118 - 00:37:59.762, Speaker B: Like I also just mentioned some our existing partners, they're actively thinking of these interesting problems like even for our existing protocol, like proof of backhoe, how to extend it to have a new implementation to support a higher bandwidth measurement. And for example for some other devices we have not plate with like energies our partner daylight, they also propose their own proofs for that. And then further, there are a lot of other opportunities. So we've been working on with some ads's for example OpenDB, they want to combine approval location with some storage. So not only want to prove something is like some network devices in a location, but also there should be some file storage, something like attached to the location. So how to bond different attributes together. This is also not a trivial problem.
00:37:59.762 - 00:38:10.894, Speaker B: So I think this will require a lot of innovation, a lot of interesting together to build this coordination layer.
00:38:11.474 - 00:38:26.230, Speaker A: Yeah. Wow, that's super interesting the having a proof that something is stored somewhere physically. Yeah. If I read that. If I. If that's what I heard correctly. Right.
00:38:26.422 - 00:38:38.278, Speaker B: Yes. So location is a like, it's a. It's an attribute but if you want to some, someone is here, it's different from like some file is at this location.
00:38:38.326 - 00:38:39.954, Speaker A: Right, right, yeah.
00:38:40.534 - 00:38:57.226, Speaker B: The single, just for the location. There are a lot of interesting problem to think of and we also have like all these different attributes for energy device, for storage, for computing resources. So it will be great that people can contribute to the.
00:38:57.290 - 00:39:27.464, Speaker A: Yeah, 100%. One of the things that I've been thinking about over the last several years as the problem of misinformation has been more I guess critical to think about. Right. When you end up, this is much more of a consumer setting but when you end up recording something. Right. And that whether it's a video, image, whatever, and that gets geotagged. Right.
00:39:27.464 - 00:39:40.618, Speaker A: You can have a signature on that asset being produced from your phone or whatnot. Sure. But um, how do you actually go about proving that that location is where you said it is? Right.
00:39:40.666 - 00:39:41.010, Speaker B: Yeah.
00:39:41.082 - 00:39:52.314, Speaker A: And if you're reporting some kind of news event or something. Right. Yeah. Like how do you get, how do you trust that it's actually being reported from where it says it's being reported? Right.
00:39:52.434 - 00:40:47.634, Speaker B: So yeah, yeah exactly. This is a very interesting use case and like especially for those journalism, how to prevent news, fake image happens to, if you want to record something, some event happen at the exact location. So we've been thinking sort of this use case a bit. But I think the final answer might be some like combination of the protocols like prolongation trusted hardware. Because like in our current image if you take it from your phone, from camera they will have some metadata about the location. But this can be added, it's editable and one straightforward way is we can replace this one or add additional information of the proof of location. Here it's a certificate for different nodes surrounding you.
00:40:47.634 - 00:41:29.906, Speaker B: They can send those packets to whether you are at best location at a time. But the problem is we still need to further bound the actual image to this kind of certificate. So this may need like additional layer of bounding technique. For example trusted hardware. You need to prevent the images not sent from other server and then before adding the timestamp or getting the signatures. So I would think this is a very interesting problem or applications to build require both the deep inside those physical, the hardware manufacturer they're working on and with the process you're building.
00:41:30.010 - 00:42:16.914, Speaker A: Yeah, yeah. No, I mean that's the whole point of all this, right? You build one primitive and you build another primitive and you build a third primitive and you put them all together and next thing you know you have this use case that wasn't previously possible. To incorporate into. To incorporate into how just information flow in the world happens. Because information flow is possibly, like, you know, information science is like, possibly the most important thing. So if you don't know how to direct it, how to rely on it, then you're just. You end up questioning a lot of things, a lot of digital products, a lot of how people end up consuming info, how society at large ends up essentially getting shaped as these things bubble up.
00:42:16.914 - 00:42:33.534, Speaker A: Right. So, yeah, no, awesome. To see these protocols actually going to production and being used, especially with sound research and theory behind them, it's amazing.
00:42:33.954 - 00:42:34.734, Speaker B: Yeah.
00:42:35.634 - 00:42:46.064, Speaker A: Cool. Well, if there's nothing else you want to go over for now, I think this is a good place to wrap it. Yeah. Any final remarks or anything you want to close off with?
00:42:46.644 - 00:42:56.384, Speaker B: Yeah, I think that's all I want to share today. And just feel free to contact us if you have any questions.
00:42:56.764 - 00:43:05.504, Speaker A: Yeah, we will share the link to a bunch of stuff that you shared here, but in case people want to reach you, how should they do that?
00:43:06.404 - 00:43:18.484, Speaker B: So we have a discord community for this open discussion. And, like, you can also, we have some, like, telegram. Any. Any information, if you want, can follow us.
00:43:19.144 - 00:43:44.762, Speaker A: Yeah, so there's Twitter, there's discord. There's a research forum that you're coming out with. So, yeah, a lot of places to get in touch with the team, which will be linked as part of this post. So thanks so much for taking the time. Yeah, this was amazing and excited to see even more of this and other proof protocols come out and people build on top of them. So, yeah, thanks so much.
00:43:44.938 - 00:43:46.898, Speaker B: Thanks, Nima, for organizing this. Thank you.
00:43:46.946 - 00:43:48.194, Speaker A: Yeah, awesome. Bye.
