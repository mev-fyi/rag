00:00:12.570 - 00:00:27.398, Speaker A: Hi, everyone. Welcome to another episode of the boarding session. Today we're going to talk about you could have invented egg and layer. I'm Kaido, I'm a protocol researcher here at Eggon Layer. Joining me today is Jeff, our smart contract architect to have you here. Jeff. Yeah, pleased to be here.
00:00:27.398 - 00:00:56.798, Speaker A: Also today we're going to talk about three some Kaido, I'm a protocol researcher here at Eigen Layer. Joining me today is Jeff, our smart contract architect. Great to have you here, Jeff. Yeah, pleased to be here. Also today we're going to talk about three subjects. First, we're going to describe why Eigen layer like why we think issue exists, and then from that why think about, okay, what are some requirements we need to hit to build it out. Lastly is once we know what our requirements are, let's build it out.
00:00:56.798 - 00:01:38.010, Speaker A: Without further ado, let's jump into it. All right, let's start with the why. And as we go through the why, we're slowly going to fill in the requirements, what we need to build Dow Eigen layer or to solve this sort of problem. All right, let's start with the thing that we all understand very well, which is the current model, how people build decentralized applications. We currently build decentralized applications this way, and we're going to have a very eth focused idea here. We build out decentralized applications on top of Ethereum. Ethereum provides the underlying security for all these applications.
00:01:38.010 - 00:02:30.774, Speaker A: And these daps, I think are very well known. Just to give out some examples, it could be a Dex, it could be a money market, it could be a yield farm, it could be a roll up, et cetera. However, there are some limitations on what kind of dapps you can build, and those are generally infrastructure related projects. So when an infrastructure project, for example, a bridge wants to build, it cannot tap into Ethereum security. It has to basically bootstrap its own security set to secure its decentralized service. So normally this kind of security is based on a POS system or proof of stake system. And these proof of stake systems, people use this because the other alternatives are proof of work and proof of authority.
00:02:30.774 - 00:03:04.224, Speaker A: And proof of work is too energy intensive. Proof of authority is overly centralized. And when people decide to go on proof of stake, they need to think about, okay, what is the stake? Right? We get the word stake in it, and people generally once again do the logical next step, which is they launch a native token. And we see this all the time with all layer ones, bridges. They're trying to secure different things with each other. However, we realize that actually the stake part is really difficult. For two part.
00:03:04.224 - 00:03:48.180, Speaker A: Stake is a capital problem, meaning you want people to contribute capital, so you want a market structure. Right. And the infrast are basically people who are building the infrastructures. So there's a lack of a platform for the stakers, for the people who can provide capital to find the people who are building this infrastructure. That's the first sort of thing we found, which is we want a platform to connect stakers and infra builders. That's the first thing we identified. Right.
00:03:48.180 - 00:04:12.890, Speaker A: They're builders, their capital providers, stakers. How do we connect the two? The other problem we realize why is this really difficult to build is because native tokens in general are very volatile. Crypto is volatile enough. These new tokens are even more volatile. The other thing is actually very hard to get these tokens. They're not listed on a lot of dexes, they're not listed, a lot of central exchanges. So they have an access problem.
00:04:12.890 - 00:04:33.106, Speaker A: So the second problem is, do you have to. Right, this stake, does it have to be from this native token? Can it be from other tokens? That could be another thing we're trying to solve here. So I would just put it stake with other token. Yeah.
00:04:33.128 - 00:04:54.178, Speaker B: And so to point out both of these address kind of aspects of the same issue, which is if you're an infrastructure developer, you don't necessarily know how to or want to bootstrap your own kind of network by going out and finding all of these stakers yourself and convincing them to use your own token.
00:04:54.194 - 00:05:19.390, Speaker A: Yes. And you don't even know where the stakers sort of are. Right. You have to sort of go to the blind world, and maybe you only can find a subset of them. If there's a place where you can just tell everyone they're in the same spot, that will be the most advantageous. The other thing is you also have to convince these stakers to buy your volatile token. And also it's hard to buy and sell, hard to acquire, to buy them to be part of the security infrastructure of the entire.
00:05:19.390 - 00:05:42.950, Speaker A: There's a lot of bottlenecks here. And the last thing is for these stakers, when they buy your token, they're incurring an opportunity cost of, when they stake into your system, they're incurring opportunity cost of. They just bought ETH and stake. And so this is basically how do we compete with the native yield eth gives you.
00:05:43.100 - 00:05:46.586, Speaker B: Yeah. So if they were staking with ETh instead of your token, they'd be getting.
00:05:46.608 - 00:05:50.780, Speaker A: The eth staking rewards, which is like 4%. Yes.
00:05:51.870 - 00:06:02.106, Speaker B: And in all likelihood, your native token might be more volatile, taking risk on both the price and the yield.
00:06:02.218 - 00:06:02.494, Speaker A: Yes.
00:06:02.532 - 00:06:11.710, Speaker B: And if you want to compete, you need to convince them that your yield is good and your token is. Yeah, your yield is good, stable or looking good.
00:06:11.780 - 00:06:56.216, Speaker A: Exactly. Which is the yield is good part, which makes a lot of the cosmos. And that's the most prominent Pos chains. A lot of them are around 1020, even 30% emission rewards because they want to compete with that native Bo e is giving. So I'm going to just rephrase it into lower opportunity cost. And the last thing is, many times as we become more modular and become more complex in our designs of this blockchain system, a lot of dapps are going to rely on different infrastructures. And the easiest example we can think of adapt.
00:06:56.216 - 00:07:35.956, Speaker A: That's a Dex that can do cross chain swaps. Right. The infrastructure here would be a bridge provider. And because your DAP is not being secured by two things, to attack your system, I do not need to attack Ethereum. I just need to attack the part that has the lowest security, which is infrastructure, and you have a fragmentation security problem to attack your system, I just need to find the weakest link and that become really problematic. So it will be better if we can pool security or in some way to bootstrap the security of the infrastructure from this huge set. So the lower bound of attack is going to be a lot higher strike.
00:07:35.988 - 00:07:37.048, Speaker B: Than your weakest link.
00:07:37.134 - 00:08:17.984, Speaker A: Yes. So let's say, how do we do it? We're going to introduce the concept of restaking here. Basically, you're securing both at the same time with the same stake to pool security instead of fragmenting them. All right? And now we cover, we basically speed run through the intro section of the article. In the actual article, we go much more in depth about why these are the actual problems and why these requirements are set this way. But now we have all these requirements here. We're going to go jump into the building section.
00:08:17.984 - 00:08:34.312, Speaker A: Right? That's, I think, the meat of this whiteboarding session. We're going to think about on a smart contract level, how do we actually achieve each of these goals we set? Okay. Conceptually we realize what this platform is, how do we implement it on Ethereum?
00:08:34.456 - 00:09:17.048, Speaker B: Okay, so let's do a really simple sketch to start out with. So we've got our staker and we're going to have some kind of smart contract pool where stakers can put their tokens in. So stakers need to be able to deposit. They also need to be able to get their tokens back so they will withdraw. And then the last piece of this, conceptually, is that there needs to be some way to slash these funds. The staker kind of misbehaves in some way that the developer has.
00:09:17.214 - 00:09:36.270, Speaker A: I see. So going back here, that means each individual infrastructure developer would just write a contract and whatever they want the stakers to commit to, they would just encode that into the sashing contract. Yes. The EFX. Then you are slash. Exactly. Okay, perfect.
00:09:36.270 - 00:09:42.770, Speaker A: So now we actually implemented the first one. How do we do the second one?
00:09:43.220 - 00:09:44.636, Speaker B: Staking with other tokens.
00:09:44.668 - 00:09:46.156, Speaker A: Yeah, staking with other tokens.
00:09:46.268 - 00:09:49.824, Speaker B: Well, this token pool could be any token.
00:09:49.952 - 00:10:12.572, Speaker A: Yes, because we're on Ethereum, there's like a million different tokens. So actually, because on Ethereum we can actually solve this problem. Right. If you're the infra developer, you can just say, hey, we're going to take USDC. Hey, we're going to take x token, we're going to take y token. It's entirely permissionless for people to use any kind of tokens because you're living on Ethereum. Okay, next one.
00:10:12.572 - 00:10:18.872, Speaker A: How do we lower the opportunity cost for stakers, especially to compete with the native yield?
00:10:19.016 - 00:10:43.990, Speaker B: So luckily there's already a bunch of existing tokens that essentially encapsulate Ethereum's native yield. So these are liquid staking tokens, or LST. So we could just pick an LST as the token that goes into the pool, and then these stakers can continue to get Ethereum's kind of native yield while being in.
00:10:45.560 - 00:10:56.904, Speaker A: What if I don't hold liquid staking token? I'm actually an eth staker myself. Can I still be part of this?
00:10:57.102 - 00:11:18.288, Speaker B: Yeah. So in that case, we could build a system that allows people to use their kind of natively staked eth. And at Eigen layer we have built a system called eigenpods that enable something like this, but it's fairly complex, so I think we should skip over it.
00:11:18.294 - 00:11:30.800, Speaker A: For the sake of. Okay, but it's possible. So it's possible to have native e sort of deposit here, or we can use LST. Either way works, but just egg and pods is just a lot more complicated.
00:11:30.880 - 00:11:39.024, Speaker B: Yeah, it's another intermediary that makes it possible to accomplish basically the same thing, but with native fleet safety.
00:11:39.072 - 00:11:59.260, Speaker A: I see. Okay, so it seems like we got another problem solved with this really simple design so far. Easy peasy. Easy peasy. All right, last part is we see this problem again. Right? Each infrastructure provider needs to build its own token pool and there's going to be a million token pools. I can deposit only into one.
00:11:59.260 - 00:12:05.776, Speaker A: How can we share or do pool security instead of fragmenting them? Once again?
00:12:05.958 - 00:12:22.048, Speaker B: Yeah. So if we notice kind of the depositing and withdrawing is very simple. It should be pretty straightforward how this is going to work with any token pool. The kind of unique part here is the slashing condition.
00:12:22.144 - 00:12:22.596, Speaker A: Right.
00:12:22.698 - 00:12:56.844, Speaker B: So we can split that up into its own kind of abstraction. That is, we could call it perhaps a slasher that defines what it is that gets you slashed. And then if we wanted to, we could add kind of more slashers that all share the same token pool. So in this way we'd be basically combining several kind of pieces of infrastructure that are all supported by the same token.
00:12:56.972 - 00:13:07.028, Speaker A: I see. But that seems a little bit dangerous if any stasher can slash the token pool. Right? So how can the staker choose? I don't want the malicious one to slash me.
00:13:07.114 - 00:13:22.632, Speaker B: Yeah, good point, good point. Yeah. We could add to the token pool that the staker defines kind of what slashers are allowed to slash them.
00:13:22.686 - 00:13:29.160, Speaker A: It's sort of like enrolling, right? Whenever you enroll into a slasher, you're enrolling to that commitment per se.
00:13:29.230 - 00:13:31.000, Speaker B: Yeah, I agree.
00:13:31.070 - 00:13:37.640, Speaker A: That's a good description. Perfect. So now let's just erase this part since we're no longer having the slash.
00:13:37.720 - 00:13:39.644, Speaker B: Yes, we've moved it over.
00:13:39.842 - 00:14:14.872, Speaker A: Perfect. And then we're going to have the slash function on a bunch of different slashers. So just to recap, now the infrastructure developers actually do not need to build out individual token pools anymore because they just need to build out their slashing condition. And the staker would stake into one token pool and enroll into different sashing conditions, as few as they'd like. Yes. And with that you can basically restaking. You can achieve pool security now.
00:14:14.872 - 00:14:33.724, Speaker A: And this simple design, even though it seems very crazy, is actually the minimal viable design for eggnog layer. Right. This achieves all the goals we set out to do. This is not a product yet because it still have a lot of problems itself. But actually we are done with the MVP version of eggleayer. Yeah.
00:14:33.762 - 00:14:35.116, Speaker B: Basic requirements met.
00:14:35.218 - 00:15:16.936, Speaker A: Awesome. In the remaining of the article or the video, what we're going to do is we're going to slowly improve this design to make it into an actual product that people can use and stakers and infrastructure developers can come and become and join this part, join this platform. Okay, now let's try to make egg and layer more of a product. And there's going to be like product questions. We need to solve the very first one. This is similar that all proof of stake protocols run into, which is the people who provide capital or the stakers are different from people who are actually running the software. The stakers doesn't operate.
00:15:16.936 - 00:15:25.330, Speaker A: And to solve that we need a separate entity, but we need to think about how do we actually work those separate entities together.
00:15:26.740 - 00:16:10.408, Speaker B: So yeah, there's plenty of professionals or semi professionals who run software. We term them operators. Ideally we'd have stakers kind of delegate to operators who do the actual operation. But again, we have this problem where really we need a platform to help these two sides meet each other. So we'll introduce another smart contract again on Ethereum that we term the delegation.
00:16:10.504 - 00:16:20.780, Speaker A: Manager because it handles the delegation between delegating the staker's stake to the operators.
00:16:20.860 - 00:16:21.840, Speaker B: Precisely.
00:16:22.580 - 00:16:23.136, Speaker A: Okay.
00:16:23.238 - 00:16:30.508, Speaker B: And the first thing that this is going to need is the ability for a staker to actually delegate to an operator.
00:16:30.604 - 00:16:32.568, Speaker A: Yes. With the veto.
00:16:32.604 - 00:16:35.876, Speaker B: And perhaps we can draw an arrow staker there.
00:16:35.978 - 00:16:44.712, Speaker A: So what happens when the staker delegates to a specific operator to say basically what sort of things you're tracking here.
00:16:44.846 - 00:17:02.984, Speaker B: So here, basically we're taking the stake that we have tracked in the token pool and communicating to the delegation manager how much is staked. So the delegation manager understands how much is delegated to each of these operators.
00:17:03.032 - 00:17:12.800, Speaker A: I see, yeah, that makes a lot of sense. But also because the operator are running the services, does it still make sense for staker to enroll into different slashers?
00:17:13.380 - 00:17:41.992, Speaker B: Not really. Yeah. So we can erase enroll up here and instead think about enrollment happening at the delegation manager level. And while we're at it, people might not want to serve these applications forever. So we can add an exit function that allows operators to disengage from any slashing.
00:17:42.056 - 00:17:48.140, Speaker A: I see. So basically we need to remove this arrow because we're no longer tracking it there.
00:17:48.290 - 00:17:51.624, Speaker B: Good point. And move it down to tier.
00:17:51.752 - 00:18:07.572, Speaker A: Yes, 100%. Perfect. And now I think with this design we sort of separated the role of stakers and operators by introducing the role of the operators and also the delegation manager to facilitate the delegation between the two.
00:18:07.706 - 00:18:14.160, Speaker B: Yeah, we've split up these user groups and provided a way for them to interact with each other in an interactive manner.
00:18:14.240 - 00:18:34.736, Speaker A: Yes. Perfect. And now we achieve the stakers doesn't need to run a bunch of option software. Okay. Now we figure out the separation. There's another problem for the staker. We're only allowed right now to stake one token.
00:18:34.736 - 00:18:41.004, Speaker A: That means if we want to stake another token, we need to launch this entire thing once again. How do we solve that?
00:18:41.042 - 00:19:11.816, Speaker B: Well, that seems easy enough. No. So we have this kind of single token pool. It would be nice if we had just a bunch of token pools that each kind of split out and each manage their own token. And we could combine these with kind of one. You can think of it almost as like a puppeteer. And each one of these token pools is just like a little puppet that.
00:19:11.838 - 00:19:13.720, Speaker A: It keeps track of. I see.
00:19:13.790 - 00:19:25.188, Speaker B: So we could call these the token pools. This can be the token manager, the token pool manager that just kind of takes care of coordinating all of these token pools together inside of the.
00:19:25.374 - 00:20:00.296, Speaker A: I see. So the other way to sort of understand it, correct me if I'm wrong here, is you can also understand the token pools as LP manager, where they instead they deposit the tokens into the token pool. For example, I deposit LST goes into LST token pool and then the token manager tracks how many shares I have over the total shares of all the LST, every deposit in there. Sort of like a liquidity provider LP counting model we're using here for the smart contract side.
00:20:00.398 - 00:20:19.868, Speaker B: Yeah, that's a good description. And using that kind of share based accounting also means that we can handle things like rebasing tokens or tokens where kind of the yield from eth staking perhaps is captured in a variety of ways and unify them all into this.
00:20:20.034 - 00:20:32.828, Speaker A: I see. That also means we need to modify a little bit on the stake and withdraw function. Basically have to say, I mean, it's still stake, but instead of just calling it, we have to pass it in which token we're staking.
00:20:32.924 - 00:20:34.816, Speaker B: Yeah. You want to pass in a little more information?
00:20:34.918 - 00:20:37.268, Speaker A: I see, that's the same for the withdrawal part.
00:20:37.354 - 00:20:38.228, Speaker B: Yeah, of course.
00:20:38.314 - 00:20:41.792, Speaker A: Perfect. And now we can support more tokens.
00:20:41.856 - 00:20:42.932, Speaker B: Any number in fact.
00:20:42.986 - 00:21:08.430, Speaker A: Oh yeah, actually that's absolutely correct. Okay, next up we're going to talk about expanding the infrastructure design you can have under this infrastructure. One thing we didn't really talk about is how does this withdrawal actually work right. In this entire new design. After we added delegation manager and the slashers, the withdrawal is going to first check. Okay, which is the staker delegated to and it's going to check.
00:21:10.320 - 00:21:10.876, Speaker B: What does.
00:21:10.898 - 00:21:58.636, Speaker A: This operator is currently enrolled in and is the enrolled services saying he is slash? There's multiple steps here. So this is a potential problem that could happen. For example, if I'm an operator who's also a staker at the same time, this is an attack I can carry out. This is a time axis, and this is first where I commit something malicious, meaning someone can submit evidence to slashing contract and slash my funds right at the same block or right after it. What I do is I call the withdrawal function, because I submitted so close, before anyone can submit the evidence to slash me, I can actually get my funds out. So at this point, I have zero funds. At this point, I have 100%.
00:21:58.636 - 00:22:29.720, Speaker A: At this point, I have 0%. And somewhere down in the future, someone's going to submit the slashing function, call the slashing. And maybe this is only 500 millisecond. Actually, that's not possible because we have the block time limit. Go with the idea. Even though it's very small, you cannot let this happen. So to prevent this from happening, we have to introduce a concept called unbonding period.
00:22:29.720 - 00:22:32.260, Speaker A: Jeff, you want to explain further?
00:22:32.420 - 00:22:42.316, Speaker B: Yeah. So rather than allowing people to instantaneously withdraw, as in that timeline that you.
00:22:42.338 - 00:22:45.836, Speaker A: Just drew and erased and erased, we.
00:22:45.858 - 00:23:41.464, Speaker B: Will have people queue a withdrawal, and later they will complete the withdrawal. We could talk about queuing and completing withdrawal. And so an unbonding period really just enforces a delay between starting the withdrawal, initiating it, or queuing it and completing it. And so what the process will look like is the staker will start the withdrawal process, queue a withdrawal will decrease the amount that is delegated to the operator, who the staker is delegated to. And later, after the unbonding period, the staker will complete the withdrawal. And at the time when they're completing the withdrawal, we'll check to make sure that enough time has elapsed, and again, that the operator has not been slashed by any of these slashing contracts.
00:23:41.512 - 00:24:00.400, Speaker A: I see. My question here is, when you say the onbounding period, I'm assuming each infrastructure developer would have their own unbonding period. Where is that onbounding period track in this entire thing? And what if I'm operator, I'm being rolled in different infrastructure with different unbonding periods?
00:24:00.480 - 00:24:33.080, Speaker B: Yeah, so, good question. Okay, so we could say, let's say one of these has an unbounded period of five days, another has an unbounded period of six days, and another has an unbounded period of seven days. So when you, as an operator, enroll in each of these, it will look to see if the new slashing contract that you're enrolling in has a longer unbonding period. Because ultimately, what we care about is the longest unbonding period of all of the slashing contracts that you've enrolled.
00:24:33.240 - 00:24:40.688, Speaker A: So basically you would track a variable here, sort of like a mapping between each operator and how long the onboarding period is. Yes.
00:24:40.774 - 00:24:45.724, Speaker B: And the length of it will be the longest of all of the slashing.
00:24:45.772 - 00:24:53.840, Speaker A: Contract that they provide. I see. And that will be updated every time you enroll and every time you exit if you trigger the changing condition.
00:24:53.920 - 00:24:54.356, Speaker B: Absolutely.
00:24:54.458 - 00:24:54.676, Speaker A: Yeah.
00:24:54.698 - 00:25:00.692, Speaker B: So if you were enrolled in all three of these, just to give an example, you have a seven day period.
00:25:00.756 - 00:25:13.228, Speaker A: I see. Okay. So one thing you mentioned at the end is when you complete the withdrawal, you need to check with each slashing contract, is that correct?
00:25:13.394 - 00:25:38.088, Speaker B: Yeah. So because it's this kind of delegated model, when you're withdrawing, you need to check that kind of none of these contracts has slashed the operator that you're delegated. So you could imagine looking up kind of every slashing contract that the operator is enrolled in and calling each one of them and saying, oh, hey, is the operator slashed?
00:25:38.124 - 00:25:38.372, Speaker A: Yes.
00:25:38.426 - 00:25:41.696, Speaker B: No. If they are slashed, then you can't complete the withdrawal.
00:25:41.728 - 00:25:42.404, Speaker A: But they are.
00:25:42.442 - 00:25:50.652, Speaker B: Then if they aren't slashed, then you can complete the withdrawal. But if the operator is slashed, then you're not allowed.
00:25:50.816 - 00:25:59.080, Speaker A: I see. I know you're a pretty big fan of gas optimization. Does this design make you squeeze?
00:25:59.580 - 00:26:17.900, Speaker B: Yeah. So anytime that you're talking about kind of iterating over an array or doing the same thing a bunch of times, it's not necessarily ideal. Also, as a developer, maybe you don't want to handle kind of all of these interactions and you want to just abstract away just the smallest amount of kind of slashing functionality.
00:26:17.980 - 00:26:38.532, Speaker A: Oh, that's interesting. So you're saying the token managering is made for the staker, the delegation manager is made for the operator. Right. Now the slasher is developed by the infrastructure developer, but it has to interact with all these different things instead. If there's like another entity that they just interact with, that will be a lot easier for them to develop.
00:26:38.666 - 00:26:43.492, Speaker B: Yeah. So we could imagine doing something kind of similar to what we did with all these token pools.
00:26:43.556 - 00:26:46.250, Speaker A: Wait, let's actually erase this. Sure.
00:26:46.860 - 00:27:22.452, Speaker B: Yeah, move it out over here. So we could imagine we move kind of these slashers over here and we introduce a new kind of coordinating contract that is the slasher manager. And it really serves to just kind of coordinate all of these slashers together and do these system interactions itself.
00:27:22.586 - 00:27:32.728, Speaker A: I see. So basically the slasher manager will basically, again, track like a mapping. Okay. For this operator, is he slash, yes or no?
00:27:32.814 - 00:27:35.880, Speaker B: Yeah, it basically is just slash.
00:27:37.820 - 00:27:49.276, Speaker A: I see. And that would also mean that when you're doing the withdrawal, you don't need to iterate through all the slasher contacts. You just need to check once with the Sasha manager and you'll be good to go.
00:27:49.378 - 00:27:50.136, Speaker B: Precisely.
00:27:50.248 - 00:28:04.368, Speaker A: Awesome. I think added benefits I see in this is because a lot of stakers are really small players. So if we can cut down gas costs for them as much as we can, we can encourage more people to participate in the system as well.
00:28:04.454 - 00:28:08.004, Speaker B: Absolutely. Ideally, we'd like Eigen layer to be usable by everybody.
00:28:08.122 - 00:28:38.908, Speaker A: Yeah. Awesome. I think that basically concludes our entire product pipeline on how can we make Eigen layer a product that's currently used today? And the diagram you see today is basically Jeff's baby. And this design fits very closely with our current architecture. Some variables, names are different, a lot of it's using as illustrated purposes. The entire idea is close to home. Would you say that's the case?
00:28:38.994 - 00:28:40.284, Speaker B: Yeah, very much.
00:28:40.482 - 00:29:06.960, Speaker A: Awesome. Thank you so much guys, for tuning in for this episode. We're going to spend a little time after this just to walk through some other bonus parts, but now we've actually covered the entire thing. How you could have invented Eigen layer. If you want to learn more, feel free to click on the link below in the description to go on our research forum for more discussion. Thank you very much. Welcome to the bonus section.
00:29:06.960 - 00:29:45.516, Speaker A: The bonus section is titled who's trusting who? The reason why we made this section is because, as you can see, the diagram before was really complicated, a lot of different moving parts, and we talked about it relatively quickly. Do we want to spend a dedicated section just to explain the trust assumption baked in to the entire system? And to get started, just to recap, we have the stakers who are staking tokens, delegating the operators to run these services, and them combined are providing service that the infrastructure developers are building. Cool.
00:29:45.638 - 00:29:49.360, Speaker B: So who's trusting the infrastructure developer?
00:29:49.520 - 00:30:22.956, Speaker A: Okay, let's go that direction. Who's trusting the infrastructure developer? Let's think about it. Okay. What could the infrastructure developer screw up? The simple example, just like code was buggy, the worst case is your code is buggy and it caused a mass slashing event. Very bad. Who will be slashed? So the operator would commit the bug or do something bad, and the operator will be slash. But because the stakers are delegating their stake to operators, the staker will be slashed as well.
00:30:22.956 - 00:31:00.296, Speaker A: There's a very heavy trust assumption on the infrastructure developers to write good code, but that is always very difficult. So in the meantime, we introduce a mutually trusted committee with very limited power. We call it the veto committee. What the veto committee can do is to reverse this accidental or buggy slashing events. So instead of trusting the infrastructure developers for writing good code, all we're trusting is the veto committee. If the bug was messy, veto committee. You can reverse snacking event right now.
00:31:00.296 - 00:31:08.328, Speaker A: Veto committee, you can think of it as a mutually trusted party between all three sides of the table.
00:31:08.504 - 00:31:11.256, Speaker B: Okay, and who's trusting that operator?
00:31:11.288 - 00:31:54.140, Speaker A: It's in this great question. Sure. I would say the operator is the one with the most amount of trust placed in the system. And this is not just with eggon layer, this is with any proof of stake system that people do delegation. So if the state operators is malicious or try to screw other people up, it can cause the staker to lose all the state. At the same time, it can screw the infrastructure developers by providing a really bad service for the infrastructure developer customers. For example, if the infrastructure developer is an oracle, the operator can keep keeping out really bad prices and the oracle itself will be buggy and not useful at all.
00:31:54.140 - 00:32:07.730, Speaker A: So there's a very heavy trust assumption placed on the operators. And once again, this is not just for egg layer. This is a general proof of stake weakness we see.
00:32:08.580 - 00:32:11.552, Speaker B: Okay, what about stakers? Who's trusting them?
00:32:11.686 - 00:32:43.960, Speaker A: This is a great question if you think about this entire thing. In my view, I don't think anyone is trusting the stakers. And the reason why no one's sort of trusting the stakers because their trusts are being replaced, what I call e plus e basically eigen layer, smart contract on top of Ethereum because of this program. Basically they're making these programmable commitments. The operators, infrastructure developer do not need to trust on the stakers. If they commit to what they're doing, then why no one needs to trust the staker because of Egolitar's infrastructure.
