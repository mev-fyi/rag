00:00:00.880 - 00:00:56.026, Speaker A: Hello, my name is Wes Floyd and this talk is about decentralizing your Dao, your web3 projects apps, your secret off chain apps with Eigenlayer. This is specifically about a component in your ecosystem that might be running on a hosted cloud. It might be a somewhat peer to peer service you'd really like to have more decentralized, and how we use shared security with Eigen layer to make that service more valuable for your community. All right, so this is our team with the Devrel folks at Eigen Layer. Please follow us at build on Eigen and we'll be announcing further updates, dev updates, and hackathons on that Twitter channel in the coming weeks and months. This talk will be specifically about your project's roadmap to decentralization. It will cover some architecture examples of how to migrate that backend service to be more decentralized.
00:00:56.026 - 00:01:37.272, Speaker A: We'll have some quick start examples, and also a demo of taking an existing off chain app and making it more decentralized by adding shared security with Eigen layer. This talk will not cover the Eigen token white paper in significant depth, although I do recommend that you take some time to go and read up on the white paper, get familiar with it. There's a really powerful concept called intersubjectivity, which we will use later on. We talk about trust modeling. We'll touch on it briefly, but there's going to be a lot of value from that white paper in the future specifically for these off chain services. All right, so let's talk about your web3 project today. Your web3 project is tremendous.
00:01:37.272 - 00:02:18.894, Speaker A: It's a beautiful, infinite garden. It's decentralized. It's got all the benefits of web3. It's an idealistic, it's an excellent place to run a decentralized app. However, there are parts of your web3 project that are not as decentralized as you might like. Maybe you were busy, maybe you were, you know, you were obviously, you know, pressed for time to get the project put together. And there were a couple services that needed to run in the public cloud, maybe for cell or aws, and they run once a week, and maybe they're adding up the, you know, a value off chain so you can write it on chain.
00:02:18.894 - 00:02:55.354, Speaker A: And they're necessary for the DAO to run properly or for the web project to run correctly, but you really like to be able to make them more decentralized. But there aren't any obvious solutions available yet. This talk is about taking those services and making them more decentralized. And so why should you focus on this. Why is this a problem for your community? Well, philosophically, your web3 project wants these components to be decentralized. They're running in a centralized cloud today, but they should be running in a more decentralized manner. You have to pay for them in fiat.
00:02:55.354 - 00:03:48.614, Speaker A: While you either have a crypto native token or maybe you're going to launch a crypto native token. You want that token to have as much value as possible, and utility, and then the infrastructure, if it's ran by a centralized company, that makes you more reliant on a centralized entity, whereas at the same time you are delivering a roadmap for decentralization to your community. We're finding out that projects that are more decentralized are inherently more valuable. They demand a premium for their community, for their token holders. Regulators in the US, in fact, have recently described more decentralized projects as safer for further publication on the us stock markets. And so in general, it's a, it's a positive step forward for your project. And your customers in general will place a premium on this degree of decentralization.
00:03:48.614 - 00:04:33.860, Speaker A: So the more of these types of services we can decentralize, the better for your team. And so when we talk about decentralization, we're going to talk about it in the context of shared security and then permissionless and innovation. And so we talk about shared security. I'll show a diagram here in just a second to show what we mean. But in terms of permissionless innovation, that means building in the open, on Ethereum, on a platform that anyone can build at any point in time without any requirements for permission from Eigen layer or another entity. We're going to talk about AVSs actively validated services. And this is basically taking your existing service, but adding trust modeling to it, writing proof verifications of it on chain so that it becomes an Eigen layer.
00:04:33.860 - 00:05:07.354, Speaker A: Av's. So what is the problem with the existing security model? In today's world, security exists separately for each individual service. So in this case here we've got my service, my service here I have my own operators. Maybe I'm running an AI service and I've got GPU's that I'm using for my service. And it's all about inference. Each of my operators commits their GPU's as operators. And I have my own folks who, people within our community that commit their capital to stake within those GPU operators.
00:05:07.354 - 00:05:44.742, Speaker A: And this is how my service operates today. There's other services. Someone else has a compute service that they run. Someone else has maybe a wireless Internet access service. And that access point is secured through its own token. And so in the world of Webp today, many of these services, these off chain services, are actually very dispersed and they're using a different capital base and different operator base. The goal of Eigenlayer is to bring together both the capital that's securing those systems, as well as the operators that are securing those systems to allow them to provide services on top.
00:05:44.742 - 00:06:27.296, Speaker A: So each of these services can tap into the operator networks and tap into a shared pool of capital, depending on how much security they need at any given point in time. And in fact, this is the reason for the name of Eigenlayer. Eigen in German means your own. So this is about building your own layer on top of an existing network of operators and capital that want to help secure your off chain service. So we're going to talk about your service and we're going to refer to it as an actively validated service. When we start writing verification of how it's being operated on chain to Ethereum, it'll become an actively validated service. And so from an Ethereum perspective, this is what the world looks like.
00:06:27.296 - 00:06:54.314, Speaker A: This is just the smart contract view of the Eigen layer ecosystem. Over to the right, there's off chain components running as well. But for simplicity sake, we're just going to start with the smart contract view. On top of Ethereum, we have smart contracts for stakers. These are people who bring restaked Ethereum capital into the ecosystem. They delegate them to operators. This could be an individual node operator, this could be an institution.
00:06:54.314 - 00:07:45.282, Speaker A: Any type of individual or organization that wants to run your service would be an operator. And when they decide they want to run your service, they opt into your AV's, your actively validated service, and then they can provide it to consumers. This consumers could be a social media service, it could be the dao that you're servicing in this case, or it could be other avss. Anyone that wants to take advantage of your service in this case is a consumer. And if the service is provided well, the operators and the stakers get rewards. If the service is provided maliciously or with low quality of service, they get slashed some portion of the stake that they have invested in the system. Today's talk is really about bringing your service into Eigen layer.
00:07:45.282 - 00:08:40.038, Speaker A: But I want to give you a bit of a broader perspective of the AV's ecosystem, because you may want to leverage some of these existing services when you're bringing your service to Eigen layer. Or just to give you some perspective on what other folks are building from scratch. You can see that over here under roll up services. There's a lot of folks building AVss to cater to the roll up and l two market bridges, MEV services watchtowers and in fact, Eigen Layer has built its own ABs to show the power of building an AV's, but also to cater to L two rollups as a high quality data availability layer. We'll use ICDA as an example. Architecture for ABS's here in just a minute. There's also folks that have built coprocessors, AI inference, Linux execution environments, trusted execution environments, things that might be useful for your down like proof of location, proof of machine hood.
00:08:40.038 - 00:09:36.548, Speaker A: There's lots of other supplemental services, and the goal is to really build this into software as a service like ecosystem so that the services can be built on top of each other, much like Lego bricks. And so when we talk about shared security, we should say for a brief minute here, why shared security? There's a couple reasons. We talked about how decentralization is valued generally among the web3, and that value is growing over time. Also, there is a lower marginal cost of decentralization, because if we're using shared security, we only need to tap into a portion of that security that's available. So our cost of bootstrapping, that is less than if we went off on our own and started our own network from scratch. But also in that process of tapping the shared security, we can choose the version of decentralization that matters to our project. Our project could say we really need decentralization geographically.
00:09:36.548 - 00:10:13.622, Speaker A: We need someone in South America, we need folks in North America, we need folks in Asia, Africa, Europe. Each of the different continents needs to be operating our service, because that's important for our community. We could also say we could have token aligned decentralization. We really want folks that are within our community that hold our token to be those operators, because we have an additional layer of trust in those folks. And that is what decentralization means to us. It's decentralization within our web3 community. Specifically, Eigen layer also empowers a very powerful primitive, which is called dual staking.
00:10:13.622 - 00:11:08.646, Speaker A: So that as a new project coming into Eigen layer, or tapping into Eigen layer shared security, you do not simply have to stake restake Ethereum, you can also stake your native token. And if you're a new token starting out, and the market cap of that token might be very low, this is a great way to add utility, real utility to your token, so that those people who are running your service here. These operators, they have to stake both your native token and Ethereum. There's a ton of bootstrapping benefits, there's a ton of security benefits here. But it brings back that theme of folks paying for the services in your native token, or in this case staking in the native token rather than in fiat, which is where these off chain services would be running today. Also, we have a large network of operators that are ready to run your service. Over 250 operators on Mainnet today who are ready to run your service.
00:11:08.646 - 00:11:49.404, Speaker A: These are folks who are eager to earn rewards, offer high quality of service, and so if you're looking to bootstrap a network of operators from scratch, this is a massive time saver to have access to all these operators today. All right, so how to get started breaking this process down as simply as possible. Minimum effort, maximum benefit for your community. First, identify the service that you think would be a good candidate to start out with just a simple service that might be running today in the cloud. Then check to see if someone has already built that service or maybe is building the service. On ivanlayer. We talked about the large AV's community.
00:11:49.404 - 00:12:28.840, Speaker A: Those folks are actively building similar things today. You may be able to just reuse it. And then second is think about the trust model. So we'll talk about how to take a system that previously you may have just trusted Vercel or trusted AWS to run your service. One adjustment we'll have to make going into an off chain service that is also an AV's is we'll have to have some mechanism we can use to verify on chain the service is being ran correctly. And then we'll build out this minimum viable AV's, this proof of concept, and we'll get going. So the first point here, check to see if someone is already building this service.
00:12:28.840 - 00:13:32.164, Speaker A: If you go to app eigenlayer XYZ AV's, you can see all the AVss that are available today. You can also go to our awesome AV's repository on GitHub and you'll see a lot of examples of different types of AVss that are being built in the ecosystem today. The second is to identify the trust model required. And in particular for now this means objective provable on chain events. If you take eigenda as an example, eigenda is proving that all of the operators in the ecosystem have stored a portion of those blobs for l two rollups. They've stored the data locally and they've written back signatures, specifically aggregate signatures on chain that prove that they have custodied the data set, a specific portion of the data. Now, in the future, we're going to expand this to inter subjectively agreeable data points, which would be agreement among participants in the ecosystem.
00:13:32.164 - 00:14:32.718, Speaker A: The Eigen token white paper refers to this concept of token forking, which is going to be an ability to say we're going to have some group or consensus within the ecosystem that's going to be able to choose a fork between a given token. This will benefit us a lot in this use case for off chain services, because sometimes it may be obvious that a given service is or is not behaving properly off chain, but it's more difficult to prove that mathematically on chain. So this will be a nice feature in the future. For today's example, we're going to focus specifically on what's shipping with Eigen layer today, which is provable on chain events. And then we'll build the minimum viable AV's. We're going to fork the hello world AV's, and I'll show you guys an example that here in just a second, customize a few on chain contracts around tasks to actually publish that information of what's going on off chain. And then we'll build a lightweight off chain operator daemon.
00:14:32.718 - 00:15:15.888, Speaker A: This would be a component that will actually look into your existing service. It will take some relevant information, it will reuse those existing binaries of your off chain service, and it will write it on chain. And then we'll package that off chain operator service into any degree of sophistication that you like. It could be just as a shell script. Most often it's a series of docker containers, Docker compose scripts, but it could also be Kubernetes cluster images that can be loaded. And so your operators will actually take this package component through here, and they will run this on your behalf in igler. So the first step is to visit our hello world AV's on GitHub.com
00:15:15.888 - 00:15:57.598, Speaker A: fork this project. This is a very lightweight example of what we're going to go through today, which is writing messages from off chain to on chain, and the message signatures that come from the operators associated with it. So it's got a lot of the stitching in the code already available, and then we'll modify this in this example today to show you the demo. So here's an example architecture of what your service would look like specifically integrated with Eigen layer as an off chain AV's. So in this case here we've got the ethereum ecosystem. We've got the Eigen layer contracts that are already deployed. We're going to write your apps contracts, specifically its AV's contracts on chain.
00:15:57.598 - 00:16:47.784, Speaker A: This is going to include some registration information. It's going to register your AV's, it's going to show how operators can register to your AV's. It's going to have some metadata about your AV's, but also some basic task management so that when it communicates with your daemon off chain, your daemon is writing this information back to your ABS contracts on chain for verification. These are the contracts that are going to be used for rewards, payments, slashing in the future and the rest of the mechanisms of the eigen layer ecosystem. But this off chain daemon is the part that we're going to focus on customizing today. That daemon is actually going to interact with your existing binaries, your existing application. And this is again the goal is to use your existing application as directly as possible with minimum amount of rewrite effort so you can get moving quickly.
00:16:47.784 - 00:17:47.442, Speaker A: So we've also built an example of a service to do exactly this, and we're calling it pinception. It is a service to bring ipfs server, specifically pinning files off chain onto an AV's on Eigen layer. And so to give a little bit of background, IPFS is a very popular service. It is a peer to peer service that actually lets you store and pin files. When you're pinning these files, you get crypto guarantees that it is the exact specific file because it creates a hash, a CID, a content identifier for your file, and then it automatically makes that file available across the IPFS network through Lib P two P. It's very powerful and it's used for a lot of existing files today. But there are some challenges when you want to store or pin a service, excuse me, a file on ipfs.
00:17:47.442 - 00:18:53.104, Speaker A: You either have to run your own server or you have to leverage an existing pinning service. Running your own server is challenging because obviously it's not the most decentralized scenario and it requires additional maintenance. The existing services that let you store those pinning services, they are actually running on cloud hosting providers themselves and they do not have crypto incentivized mechanisms to pay for those services yet. So this service is meant to take just the standard ipfs binary, make it decentralized, and add eigenlayer shared security to it so that you get the benefits of peer to peer trustless file sharing as well as shared security so that the operators, in this case they'll be running, actually storing and pinning your service. They'll get the shared security from Igel Air in the operator network. All right, so building out this service we're going to fork from AV's hello World. We're going to use the existing IPFS daemon, talking about using the existing bits, it's called Kubo, which is the go implementation of IPFS server.
00:18:53.104 - 00:19:46.126, Speaker A: We're going to create, we're actually going to write some code that's going to be this lightweight local operator Daemon and we're going to write it in JavaScript because JavaScript is very easy to use and easy for folks to reference. And then we're going to do some minimal task management, off chain services and AV's contracts to manage the request and response for pinning of those files. So again, we'll have our pincer contracts with Ethereum, we'll have a pincer off chain daemon, lightweight JavaScript code, off the shelf componentry here with ipfs, and then we'll orchestrate this with any number of tools that we choose, like Docker composer. All right, time for a demo. So let's jump over to visual studio here. The first file I want to show you is the JavaScript code. This is available on the GitHub repo for you to take a closer look at.
00:19:46.126 - 00:20:19.116, Speaker A: But basically what it is is a series of function calls in JavaScript. They're going to do some things like add an IPFS hash. It's going to interact through the rest API with the local ipfs server. And so it's also going to listen on chain for a new CID event. So in this case there'll be an event that's published through the Pin Septon smart contract. The event name is CID to pin, and when it hears that it actually invokes and says okay, let's store this here off chain. So let's go through a demo and show all the pieces working together.
00:20:19.116 - 00:20:46.524, Speaker A: For this demo, we're going to launch a local anvil chain in our terminal. So first, oops, let's launch that anvil chain. Okay, we got that running there. Great. Then let's go over to the second terminal here and let's load up the contracts. We're going to load this CID emitter contract. This is the off chain pinner, excuse me, the on chain contracts for this pinner service.
00:20:46.524 - 00:21:09.406, Speaker A: So let's send that to our anvil chain. Okay, right into Anvil hard hat. It looks like this was picked up as a transaction. Perfect. Now we're going to run a couple of things. We're going to run a local IPFS daemon here. This is specifically going to be simulating our operator because the operator is running that Kubo node off chain.
00:21:09.406 - 00:21:22.136, Speaker A: So this is actually the Kubo Docker container. You can see here. We're just running the latest kubo version there. So let's run that. Perfect. Okay, so that's running. Let's just check it.
00:21:22.136 - 00:21:52.312, Speaker A: Docker P's. Okay good to go there. Now we're also going to need to have a remote ipfs container because we need to get the file uploaded to a remote container first. This is also very effective to run on a remote system. If you have like an app running in the cloud somewhere, that's a great place to run it. But for demo purposes we're just going to run this locally as well, mostly for speed and convenience here. So this will be our simulated remote container ipfs sim remote.
00:21:52.312 - 00:22:11.732, Speaker A: So let's just check Docker P's. So we've got two containers running now, one for our local operator and one that's simulating our remote ipfs server. Okay, now we're going to move into the operator directory and run this pinner service. So let's do that. Okay. And it's listening on chain right now for this event. Cid two pin.
00:22:11.732 - 00:22:48.196, Speaker A: And it's waiting for someone to emit that event. Alright, so let's emit that event and do some testing. Before we emit that event I want to create an example file. So I'm going to create just a string message here. Hello ipfs. Today is the state and Nashville where we're at this week is amazing because we're here for a few meetings and then we're going to add this to the remote, the simulated remote ipfs server. So we're going to say ipfs add to the local, excuse me, the remote server.
00:22:48.196 - 00:23:07.044, Speaker A: Add that it uploaded it. Excellent. And now we're going to invoke the curl command and we have a unique CID for that file. So it exists in the ipfs remote server. It does not exist on our local machine yet. So let's just test that. Check the remote server.
00:23:07.044 - 00:23:37.554, Speaker A: Show me all the CID files that you have on that remote one. We've got the one we just uploaded there. That one exists and a default one that comes with the docker container. Now let's go check our operator just to see, just to double check to make sure that the operator does not have no, and the operator does not have that new one that we uploaded, AO 384. It just has the default one for its operator. So our operator has not pinned this file. It hasn't heard the message on chain yet.
00:23:37.554 - 00:24:18.684, Speaker A: So now we're going to go to invoking the cast command. Now we're going to invoke the cast command and we are going to send that event emit CID to pin of that specific CID. So we're going to invoke that. This is a user saying I actually want to pin this specific CID and let's go back on chain. It looks like the chain picked up that event over here on an interval chain and then our listener here picked it up as well. So it says we've found this new event for this specific CID. We're sending that to our local operator to pin that IPFS hash was added for this specific pin.
00:24:18.684 - 00:25:13.084, Speaker A: Ok great, now let's go back over here and let's make sure that that file was stored by the local operator. So now we go over here and let's just give us this list of all the local pinned files for this operator. And now we have both the default one that came with the docker container and this new file that we requested. So to take this back to our architecture, we have requested this file to be stored through the contracts. The off chain daemon heard this request, it stored it in our local ipfs Kubo binary and then wrote the response back on chain to the contracts. And so this effective, this connection piece right here, this octane daemon, these contracts become the connective tissue that we have now to pay rewards to this operator. If the operator was malicious and we need a slash in the future, this is the stitching that we need for all that to work properly.
00:25:13.084 - 00:25:42.672, Speaker A: Alright, so that is the end of the demo. And then in terms of next steps, please follow us at build on Eigen. We have a couple different hackathons going on right now. Please take a look at Avs microhacks Eigenlair XYz Yz. We'd love to have you participate. And please also do take a look at the newest white paper that's released because there's a lot of important functionality there around inner subjective proofs that will be helpful for the future. That's all for now.
00:25:42.672 - 00:25:44.104, Speaker A: Thank you so much, have a good day.
