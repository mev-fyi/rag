00:00:11.680 - 00:00:30.870, Speaker A: I'll just use this. Hey, everyone, welcome to the Trident stage, ETh, Denver 2024. I'd like to welcome to the stage Ellie Ben Sasson. He's the co founder and CEO of Starkware. The talk is titled Fry versus KZG. Does field size matter?
00:00:33.720 - 00:01:23.588, Speaker B: You. Thank you. So I'll talk about this topic and the TLDR is that already today, starks dominate the Ethereum scaling scene. And thanks to recent breakthroughs like Circle Starks and Stu, which we just open sourced yesterday, starks are going to become the new gold standard for scaling Ethereum. So yesterday we released the next phase in scaling in validity proof technology. It is Stu, based on the Mersen 31 bit field with an improved Cairo virtual machine based on the mathematical breakthrough of Circle Stark that was published just last week. Joint work by Polygon Zero and Starquare.
00:01:23.588 - 00:02:12.344, Speaker B: I'm going to use the Gcara lookup and mixed degree trace and a lot of other bells and whistles, making it yet again, a pretty darn good prover. And if you think about the landscape today in terms of proving technology for things deployed in production, not just for things that are out there in academic research. So there are roughly three categories of commitment schemes, fry based, which most of the stark systems lie in. Inner product arguments like bulletproofs. And then you have kzgs used by things like plonk rock 16 and a bunch of teams. And over time. I mean, it used to be that KZG dominated almost everything in the ZK and scalability space.
00:02:12.344 - 00:03:02.020, Speaker B: But over time, fry based systems have been emerging. And basically, my point is, I think you'll see this trend of moving more towards Fry based starks as time goes on. And why is this so? So you could consider the efficiency of one of the main bottlenecks in constructing a proof, which is to do a polynomial commitment scheme. And we can do a head to head kind of competition, measuring the number of clock cycles to commit to a word, a word being 32 bits inside a stream of length, roughly one mega word. So two to the 20 words, that's roughly a million words. And now we can measure the load in the commitment scheme per each word. And let's compare Fry and KZG.
00:03:02.020 - 00:03:43.092, Speaker B: So this is based on some comparisons that I already presented in the past, both at stark at home and at the Stanford blockchain conference earlier. I mean, this past summer. So the current status is that if you look at non vectorized instruction sets, so KZG, under the even most ideal algorithms that we know of today, you're going to have to do roughly a cost of word length. So that's 32 divided by the logarithm of the stream. In our case, it's 20. So 32 divided by 20. Number of group operations, each group operations at best.
00:03:43.092 - 00:04:21.910, Speaker B: And you have to do a lot of fancy work. To make that work, you need to do six modular multiplications for doing elliptic curve operation. And each one of those roughly cost 38 to 40 clock cycles. On the other hand, if you look at something like 31 bit fry, you'll see that you pay for the FFT. Roughly one half of the blow up factor times logarithm times 20. In our case, the blow up factor is going to be two. So half times two times 20 equals ten.
00:04:21.910 - 00:05:11.004, Speaker B: And that's the number of clock cycles per word plus blow up factor times hash. So if you use something like Blake, that's going to be 80 clock cycles. You see the most dominating factor here is going to be the hashes, and you have to pay two of them. So, out of the 220 cycles, 160 belong to the hashing. However, if you move to vectorized instruction sets, which are today common in all cpus, then the picture changes pretty drastically, because KZG probably doesn't vectorize all that well. Whereas something like a 31 bit field, fry with an FFT, does vectorize extremely well. And then you get that each modular multiplication on the small field is one third of a clock cycle amortized.
00:05:11.004 - 00:05:56.428, Speaker B: So you get a total of 31 clock cycles versus something that is probably going to be around ten times greater than that. So you have, like, ten times greater efficiency. But the story doesn't end there. Sorry. In practice, when everything is combined, if you look at Frybase system, to best of my knowledge, this is along some of the world records, even though it's like four years old. So we already showed four years ago a construction over a 64 bit field that proves 100,000 rescue hashes in less than 10 seconds on a quad core with 16gb ram. And this was, at the time, 20 times faster than the fastest known KZG based system, Snark.
00:05:56.428 - 00:06:38.780, Speaker B: And we still don't know what is the best proving time for something similar. It would be a good measurement to do head by head. Take your favorite algebraic hashing function and see how long does it take to prove 100,000 iterations of a hash on some simple hardware. It's probably not going to be all that simple anyways. But frybase systems, or starks, have a bunch of other advantages over snarks. They have fastest commitment time, they're agile, in the sense that they work over all finite fields, from binary all the way to large prime fields. They are safest because they have no trusted setup, meaning they are transparent proof systems.
00:06:38.780 - 00:07:28.744, Speaker B: Their security assumptions really revolve only around the existence of some secure hash function. And in particular, they're also post quantum secure. KZG does have advantages, snarks. They have very short proof length under 200 bytes, and they have additive properties which, well, it's a double edged sword. You can use them for doing things like folding and compressing things, but this additiveity is related to things like post quantum insecurity. Now, this theory that says that frybase systems over small fields are going to be better, is not just something that we believe in on the mathematical or back of the envelope side. We're also committing ourselves to it.
00:07:28.744 - 00:08:14.140, Speaker B: So for the past six years, we've been using basically one prover, that is stone, which stands for Stark one. It is our first stark based proving system. And now we're moving slowly towards Stu, which is the second stark prover. And I want to tell you a little bit about this, because it's pretty exciting. So what it's going to give you is much faster proving technology. It's going to reduce the total computation cost, meaning you pay less dollars for proving stuff. And it's going to be seamlessly integrated with Starknet, which means if you start deploying and building in Chiron Starknet tomorrow, you will get all of these benefits without really any modification.
00:08:14.140 - 00:09:11.200, Speaker B: So let's look a little bit under the hood. What is Stu? So, first of all, let's talk about the 31 bit Mersen prime field. So a Mersen prime has the form two to the k minus one, and if you take k to be 31, you get the number two to the 31 minus one. It is a prime number and it has a lot of cool properties to it. I mean, Mersen, the great Mersen, already found it probably a couple of hundred years ago. So moving to 32 bit fields in our world, where all computer devices off the shelf operate in 32 bit instructions in the fastest way, means that you get a lot of benefits. One, the smaller field size, allows you to get your arithmetization better done, because when you have large fields, you need to pack things into big field elements and it's inconvenient.
00:09:11.200 - 00:10:35.990, Speaker B: It fits inside a computer instruction word. And you even have nice modular reductions because two to the 31, which in bitwise representation is just one with a bunch of zeros, happens to equal one. So if you have your 32nd bit turned on you can sort of replace that with the lowest bit turned on, and that's how you do modular. So it's a very simple modular instruction, and there are a lot of nice benefits for doing fast implementations, both on cpus and gpus, for basic field operations such as modular addition and multiplication, for doing ffts or ntts, and for computing things like stark friendly hashes like Poseidon. One example is if you take 232 bit numbers and you just concatenate them together, sorry, 231 bit numbers, what you're looking at is literally equivalent to their sum modulu this prime. So concatenation at least of two such field members does represent the addition of them, and you can do a lot of such tricks. So let me tell you a little bit about this exciting breakthrough joint work by Polygon and Starquare.
00:10:35.990 - 00:11:24.200, Speaker B: Ulri Habak from Polygon, David Levitt and Shah Papini from our team at really, really spectacular result. So circles start, and the circle refers to the good old circle that we all know and love. So let's see how we get there. For starks to work best, they require a group that is of size two to the k. We often talk about an FFT friendly domain, and it turns out that the multiplicative group, usually we take fields and work with their multiplicative groups and find subgroups inside those multiplicative groups. But for that, you have to look at the factorization of the prime minus one. In our case, that would be two to the 31 minus two, and two to the 31 minus two does not have very large factors of two.
00:11:24.200 - 00:12:28.166, Speaker B: In fact, two is the largest power. Two of it divides it, which means you don't have the nice multiplicative groups that you would like. Now, if you go to the degree two extension of Mersen, you already have a very nice FFT friendly group of size two to the 31. However, now you'll be needing to work with basically 62 bit field elements and doing all your operations, and that's a bit inconvenient. We would like to get all the benefits of the Mersen arithmetic, but working only over the Mersen field. So one possible solution is to use some work that we did a few years ago at starkware called elliptic curve starks, which basically replaces the group, the multiplicative group of a finite field, with an elliptic curve group defined over that finite field. The nice thing that there's an abundance of elliptic groups of all sorts and, well, not of all sizes, but there's a pretty large variety of them within the hase whale bound.
00:12:28.166 - 00:13:22.060, Speaker B: So you can find one that has a nice subgroup of size two to the k, which is what you want. However, this would be relatively complicated. The elliptic curves are a little bit more complex than some simpler curves that we all know and love. So enter the circle curve, or circle starks. They operate over the genus zero curve, that is the circle defined over m 31. So what does it look like? You take the good old circle, which is the set of pairs of points such that x squared plus y squared equals one, in our case modulu, the Mersen prime, and there's a bunch of examples of such number, such points on the circle. So 10 minus 10, which in our case equals two to the 31 minus two.
00:13:22.060 - 00:14:44.802, Speaker B: And also, if you take the point that is two to the 15, two to the 15, that thing, if you square each one and sum them up, you get one modulus n prime. So here are a few numbers, a few points on this group, and it turns out that there are exactly, well, there are two to the 31 groups that reside inside, basically that are defined over the Mersen field, meaning that the pairs x and y, both of them belong to the Mersen field and it forms a group. I think actually the group is of half the size, but I'm confusing myself now. So it's at least of size two to the 30, and you have a very nice operation for addition. So that's the Mercen 31 field. There's going to be a talk by Shakar Samoha either later today or tomorrow, and by Ulrihabok I think it's going to be tomorrow at the stark meetup, sharing a lot more details about the math behind it and about looking deeper into Stu, which is already open sourced by now. So what are the implications? This gives you the very fastest prover using new math, and it's going to be crazy efficient.
00:14:44.802 - 00:15:39.100, Speaker B: We believe it's going to be something like 100 times more efficient end to end than the current stone proof. And the current stone prover is among the fastest proving systems end to end for production systems today. So we are extremely excited about the potential of StU to go even further in scaling Ethereum for Starknet. What you need to know is that if you write in Cairo, you'll get all of this goodness for free, because it will just be adapted seamlessly. This will lead to lower fees and to quicker finality. Hopefully we'll start seeing it already, helping us with finality and reducing latency this year in 2024. And another nice thing is that it is open source, written in rust, and the open source is already open today.
00:15:39.100 - 00:16:34.060, Speaker B: So you can just google first two under Starquare and you'll find it under Starquare Libs and you can start hacking or using it. So I'll repeat the TLDR Starks dominate the Ethereum scaling scene already today, with more and more teams moving over to using fry based systems that are safer but also more efficient. And the recent breakthroughs of Circle, Stark and Stu will become the new gold standard for scaling Ethereum, not just at Starknet, probably also Polygon Zero and other teams are going to adapt to them, and then we'll see a lot more in the industry. So this is as good a time as ever. It's the second best time to start looking into Starknet and Cairo. The first best time was probably a year ago, but still, we're early enough in the game so you can take this QR code, follow the links, join the ecosystem. Thank you very much.
00:16:34.060 - 00:16:34.790, Speaker B: Bye.
