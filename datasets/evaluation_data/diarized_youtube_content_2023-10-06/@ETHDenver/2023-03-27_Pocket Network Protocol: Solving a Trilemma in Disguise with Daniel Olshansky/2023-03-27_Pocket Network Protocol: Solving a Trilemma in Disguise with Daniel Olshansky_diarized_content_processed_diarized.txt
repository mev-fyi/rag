00:00:01.690 - 00:00:43.750, Speaker A: All right. Okay, before I start, look, everybody, it's me. I know my hair was almost literally on fire last year, and I said I was going to do something a little more fun this year, but I'm hoping that my mustache will be enough for everybody. So, I'm Olshanski. I'm the protocol lead at pocket, and today I'm going to be telling you about a trilemma we're solving that was actually right in front of our eyes since the very beginning. But before I do, I'm going to define a term that I'm going to be using a lot throughout this presentation, which is RPC. And it's pretty basic.
00:00:43.750 - 00:01:39.610, Speaker A: It's when one machine makes a call to a remote machine that executes a procedure and returns a response. So, RPC, easy as one, two, three. And while I assume that most of the audience knows about Pocket network, I'm going to give a quick rundown of what we do. So, pocket is a multi chain, decentralized RPC protocol. And what does that mean? It simply means that if you're a dap that needs a full node rather than writing your own infrastructure, there's a decentralized cluster of nodes that are incentivized to run it on your behalf and serve data to you. So that's pocket in a nutshell. What am I going to be talking about today? So I'm going to be talking about what's new for Pocket.
00:01:39.610 - 00:02:30.426, Speaker A: I'm going to talk about why we need to decentralize RPCs at all. I'm going to talk about our decentralization approach, and then I'm actually going to go into what we're actually doing about it. So what's new for pocket? Here are some numbers. Last year we were doing just over 2 billion relays a week. Today, we're doing more than 8 billion relays a week, and a number is steadily growing. More importantly, you can see that most of our relays were focused around harmony back then, but now it's distributed across many different chains, including Ethereum, polygon, gnosis, and many others. Next, inflation also went way down.
00:02:30.426 - 00:03:15.820, Speaker A: So pocked is what servicers earn in exchange for providing a service. And while there's a ton to unpack here and a ton to discuss, and our community and our DAO are always involved in these conversations, I think lower inflation really, really helps and shows that we're a healthier, maturing and growing network. And there's obviously a lot more that we can do. Next, I'm going to talk about validator distribution. So last year our 1000 validators had just under 30 million pockets staked. Today that number is almost at 90 million, pocked and increasing. And you can also see that the distribution of our validators has grown as well.
00:03:15.820 - 00:03:21.978, Speaker A: Now this slide I'm not going to.
00:03:21.984 - 00:03:23.646, Speaker B: Have time to jump into, but I.
00:03:23.668 - 00:03:28.362, Speaker A: Think it's just really important to showcase that a lot of the core protocol.
00:03:28.426 - 00:03:33.222, Speaker B: Changes to the one that's live right now actually came from external contributions.
00:03:33.306 - 00:03:38.946, Speaker A: It was ideated, developed by external contributors, and that's actually where a lot of.
00:03:38.968 - 00:03:55.720, Speaker B: The innovation right now is coming from in the current version of the protocol. Okay, so that was a summary of what's new for pocket, but now I'm going to talk about a big question of why even decentralized RPCs at all.
00:03:57.550 - 00:04:04.758, Speaker A: So this is the world we were promised, where there's a bunch of Dapps.
00:04:04.934 - 00:04:13.466, Speaker B: And they're talking to the network, they're requesting data, they're sending transactions, they're requesting proofs and they're doing local state validation.
00:04:13.658 - 00:04:15.470, Speaker A: This is the world we were promised.
00:04:15.890 - 00:05:11.710, Speaker B: And this is what we have, where you have Dapps talking to centralized node providers which run chains on your behalf and you communicate with them via RPC, moving the trust layer up one level. And I know there's a ton of research and a ton of discussion and a ton of work going into light clients right now. And I just want to show that this is not an original idea. In section eight of the bitcoin white paper, Satoshi talked about simple verification, like simple payment verification clients. And that's what like clients are. It was a plan since the very beginning, but what has changed is we're living a multi chain world right now. And rather than just serving data, all these centralized node providers also offer a lot of bells and whistles, a lot of different features on top of actually giving you access to the data underneath.
00:05:11.710 - 00:05:43.830, Speaker B: So that's kind of what we were promised and that's what we got. And now I want to answer the question of why decentralized RPCs at all. It's not about solving data availability. There's a lot of different protocols that do that. And it's not about solving data privacy. There's a lot of different protocols that do that as well. It's about creating an incentive for data redundancy.
00:05:43.830 - 00:06:48.480, Speaker B: It's about creating an incentive to have geographic distribution of the nodes. It's about creating an incentive to have geopolitical distribution of the nodes. And it's about enabling like clients, because where are you going to get your proofs. Where are you going to get your block headers? Who has the incentive to actually serve this data? And we don't just need to serve it, we need to serve it with a high quality of service. And like I said before, the world has changed. It's not just about the onchain data, it's about all those bells and whistles, all those extra features that the full node infrastructure providers offer you on top of the actual chain. So what's our approach to decentralization? Usually when you need to frame a problem, or you need to frame something, you think of rectangles or squares, because that's how you frame things.
00:06:48.480 - 00:07:29.820, Speaker B: But another great way to frame things are triangles. We've got the cap theorem from distributed systems. We've got the scalability trilemma that Vlad Zanfir came up with back in the days. We've got the impossible Trinity from economics. So distributed systems, blockchains, economics. Triangles have always done a great job at framing problems, and now we have the RPC trilemma. Reliability, performance and cost.
00:07:29.820 - 00:08:03.080, Speaker B: Reliability is everything we've learned to love from web3. It's trustless, it's decentralized, it's permissionless, it's reliable. Performance is everything we've learned to love from web two. You have nine nines uptime. You have a high quality of service, it scales elastically and cost well. It needs to be cheap for both sides. And things became much cheaper when we went from a physical world to a digital world back in web one.
00:08:03.080 - 00:09:20.110, Speaker B: So that's how we framed the problem. But then what is our philosophy to actually solving this problem? So we've all heard of progressive decentralization, where you progressively decentralize things bit by bit, step by step, over time. Our approach is programmatic decentralization, where depending on your use case, or depending on how much trust you need or have, it's a spectrum of how decentralized things really need to be. You can make a programmatic decision of how decentralized your data and your RPC and your full node provider really is. So we framed the problem. You kind of know what our approach is to solving it, but what are we actually doing about it? So V zero has been live on mainet for over two years now, and v one is under active R and d right now. And the main goal of V one is basically taking all of our learnings from V zero and moving them on chain.
00:09:20.110 - 00:10:01.474, Speaker B: So here's a high level look as to what's happening in V one. We have four protocol actors. We've got the validators, which take transactions, create blocks, validate state transitions. Pretty basic. We have applications, so they stake pocked, they pain pocked, and they actually get value out of the decentralized network of RPC providers. We have the servicers, which are the ones actually running the full nodes and providing that service to the application. And then we have the Fisher beings, which are the ones that are overlooking the servicers.
00:10:01.474 - 00:11:11.714, Speaker B: They're the ones that are actually grading the quality of service of the servicer, creating a report card, and then that report card determines how big the rewards actually are. Now this is probably going to be the most technical piece of the talk, because one of the most basic primitives of the pocket protocol is the session. And you can think of the session as basically a way to fairly distribute work throughout the network. It's a way for us to pair applications with servicers that are going to serve their RPCs. And it handles a lot of different things, like rate limiting, the amount of pocked that gets inflated, the amount of pocked that gets burnt. And basically it's one of the core foundational parts of the protocol. And while I assume that most of you haven't had time to look through that diagram, one important piece of information is that in order for you to know as an application who is going to be servicing my RPCs, you need access to on chain data.
00:11:11.714 - 00:12:22.220, Speaker B: You need to be able to ask the network who is going to be serving my requests. And while some applications may be able to run a light node, others might not. So even as an application, you still need to make an RPC call to an endpoint to figure out who your servicers are, right? You need an endpoint, or you need an IP address, or you need a host and a port, right? You need a portal, you need a gateway to web3. But what do portals actually do? So as an application, I can delegate trust to a portal, or I can delegate trust to multiple portals, or I can delegate trust to no portals at all. It's up to me. Portals, on the other hand, can dispatch sessions on behalf of applications. They can sign relays on behalf of applications, and they can also offer off chain services.
00:12:22.220 - 00:12:41.950, Speaker B: So those bells and whistles that I was talking about, this new world that we live in, where infrastructure providers offer a lot more than just on chain data, it is something that portals can offer. But you might ask, how can applications delegate trust to a portal?
00:12:44.130 - 00:12:46.274, Speaker A: You've got to put a ring on it.
00:12:46.472 - 00:12:54.826, Speaker B: That is the only way you can delegate trust and take this from a guy whose only ring is the one he got from his undergrad engineering degree.
00:12:54.958 - 00:13:04.360, Speaker A: So I know what I'm talking about. But on a serious note, what do ring signatures actually do?
00:13:05.050 - 00:13:10.506, Speaker B: Basically, you can think of applications, they can send an onchain transaction to say.
00:13:10.608 - 00:13:12.122, Speaker A: I have my private key.
00:13:12.256 - 00:13:23.578, Speaker B: This is a transaction I delegate trust to this portal. Portals have their own private key and they're independent actors. And through the magic of ring signatures.
00:13:23.674 - 00:13:26.622, Speaker A: Which is a cryptographic primitive brought about.
00:13:26.676 - 00:14:28.770, Speaker B: By Monero several years ago, what a servicer can do is validate the signature and it doesn't care who signed it. It could be the application, it could be the portal, it doesn't know and it doesn't care. And the most important thing here is that applications can delegate trust and undelegate trust to the portal at their will. It's simply sending a transaction. One of the things that I really want to hone in on is the power of ring signatures. Rather than needing multiparty computation or threshold signing or all of these more difficult kind of interactive processes, it's completely non interactive and everyone owns their key. So this brings us back to the original diagram with all of the actors, but we have not four, but five protocol actors, because we're adding the portal.
00:14:28.770 - 00:14:58.460, Speaker B: And what this lets us do is decentralize pragmatically. The application can either use trusted RPCs through the portal by delegating them, or they can do it trustlessly by talking directly to the servicers. And the most important piece is that these are not mutually exclusive. As an application, you can do both at the same time.
00:15:01.650 - 00:15:17.066, Speaker A: Okay, that was a lot. So you might ask, but what's in our pocket? There's a lot in our pockets. Our pockets are full. This is our stack.
00:15:17.258 - 00:15:22.242, Speaker B: And I'm not going to go through all of it in detail, but I did want to kind of just point.
00:15:22.296 - 00:15:24.402, Speaker A: Out and discuss that we are doing.
00:15:24.456 - 00:15:26.182, Speaker B: A lot of things in house to.
00:15:26.236 - 00:15:34.546, Speaker A: Optimize for our use case, but we're not reinventing the wheel. For example, we're leveraging things like Lib.
00:15:34.578 - 00:15:37.106, Speaker B: P two p in our networking layer.
00:15:37.298 - 00:15:47.702, Speaker A: We're building on top of all of the research that the Libra teams did on consensus, and then building it ourselves to optimize for the fastest, most performant.
00:15:47.766 - 00:15:56.160, Speaker B: And scalable RPC network possible. There's a lot more, and you can definitely go and check our GitHub if you're interested to learn.
00:15:57.890 - 00:16:00.782, Speaker A: And the last question that I get.
00:16:00.836 - 00:16:04.850, Speaker B: Very often is, why build your own blockchain?
00:16:05.430 - 00:16:17.310, Speaker A: And the reason is that we're building an application specific blockchain for an application specific purpose, and we're trying to remain chain agnostic.
00:16:17.470 - 00:16:33.258, Speaker B: We're trying to be the gateway to a multichain world. We can't be dependent on another chain in order for you to give you access to all of those other chains. We already have a 20,000 node strong network, and we can leverage that by.
00:16:33.344 - 00:16:35.254, Speaker A: Being able to scale our validators.
00:16:35.382 - 00:16:46.590, Speaker B: Right now, using tendermint, we're limited to 1000. With V one, all of our servicers will have the option to be a validator. It gives us the option to have.
00:16:46.660 - 00:16:49.562, Speaker A: Interoperability with many different protocols.
00:16:49.706 - 00:16:57.460, Speaker B: And we're already in conversations with polymer labs and others to potentially have IBC integration in V one.
00:16:57.990 - 00:16:59.714, Speaker A: And there's also a lot of other.
00:16:59.752 - 00:17:06.230, Speaker B: Optionalities such as restaking algorithms and papers being released nowadays.
00:17:07.130 - 00:17:09.074, Speaker A: And one of the other things that's.
00:17:09.122 - 00:17:23.354, Speaker B: Really, really important is by owning our stack, we're able to really build and create a good developer experience. We have really good documentation, we have really good tooling. And I think the fact that we.
00:17:23.392 - 00:17:25.578, Speaker A: Have with every few weeks we have.
00:17:25.584 - 00:17:32.766, Speaker B: A new external contributor, not just being a developer on the network, but contributing to the actual protocol and being able.
00:17:32.788 - 00:17:34.686, Speaker A: To just pick up our documentation, our.
00:17:34.708 - 00:17:55.730, Speaker B: Tooling, and start developing speaks a lot to that. So that's pocket, that's what we're building, it's what we have. And I'll end it by asking the real decentralized RPC network to please stand up tonight.
