00:00:00.170 - 00:00:20.170, Speaker A: Our next speaker is Elena. She's joined us from San Francisco, and she's talking about one of the more interesting things that have happened in the past six months, the advent of the ERC 721 standard, which is sort of an outgrowth of all this wonderful cryptokitty stuff and can do so much more. So thank you, Elena.
00:00:20.330 - 00:00:22.110, Speaker B: Great. All right.
00:00:22.180 - 00:00:36.600, Speaker C: Thank you. And thank you for fixing the AV. A close call. Yeah. So this is a pretty interactive workshop. Just show me some hands. Who knows what cryptokitties are? Awesome.
00:00:36.600 - 00:01:07.094, Speaker C: Who knows what crypto celebrities are? Okay, great. So this is going to be a workshop on how to basically build your own. So if you guys want to follow along, go ahead and start installing things. And now that we have Internet, this is great. If not, then you can just watch me live code. So, to understand what non fungible tokens are, let's understand what fungible ERC 20 tokens are. So these are some of the examples of the existing ERC 20 tokens.
00:01:07.094 - 00:01:28.120, Speaker C: I'm sure you can recognize some of them, and there are many, many more. And so what is ERC 20? ERC 20 is just a standard. It's an interface. And if you abide by the interface and make your contract follow those methods, then it makes it much easier for marketplaces and exchanges and other daps to actually interact with your contract. And so if you wanted to.
00:01:31.610 - 00:01:32.360, Speaker B: Hi.
00:01:34.250 - 00:02:15.560, Speaker C: I guess I'm too short. Okay, so if you wanted to know what ERC 20 is, this is what it looks like. It's a pretty simple, standard interface. Oh, gosh. Okay, so then what is ERC 721? ERC 721, just like ERC 20 is an interface. It's a standard, and it's not set in stone right now, it's still something that's being developed. But if you look at the actual interface as we have it right now, it's also very simple, and it pretty much looks a lot like ERC 20.
00:02:15.560 - 00:02:40.366, Speaker C: So then, now that we know what that means, what exactly is nonfungible? So, non fungible are basically assets that are distinguishable. So think like artwork or land or concert tickets or baseball cards. So, for example, not all land costs the same. Land in Manhattan is much more expensive than somewhere else. Same with concert tickets. Beyonce concert tickets might be more expensive than something else.
00:02:40.468 - 00:02:40.954, Speaker B: Artwork.
00:02:41.002 - 00:03:19.718, Speaker C: There are many paintings in the world, but not all of them cost the same. And so for non fungibles that are collectibles in real life, we have a lot of examples, too. I mean, those Beanie babies on eBay went for $3,000 at some point, Magic, the gathering card, that's the most expensive card right now, is valued at $16,000. Now, obviously, we have non fungibles on the blockchain, too. And so the very first ones were cryptopunks. Cryptopunks basically came into the scene way before ERC 721 was even a standard. They had a very novel way of actually storing all 10,000 cryptopunks in the contract.
00:03:19.718 - 00:03:52.214, Speaker C: There can never be more, there can never be a lot less and proven ownership through a smart contract. And then cryptokitties came on the scene and they pretty much changed kind of the entire game scene. They were the first to actually implement the RC 721 standard. Obviously, they brought a lot of attention to the space. It started a lot of other projects. And so after cryptokitties had a great success, there are a lot of copycats, pun intended, that came after. So ethereum on came after.
00:03:52.214 - 00:04:19.290, Speaker C: They were kind of blamed to be a Ponzi scheme. That's okay. Tulips came after, I think, crypto fighters, many, many, many others. And now we're kind of in this current fad of crypto celebrities. So right now, if you wanted to go purchase crypto celebrity, you can buy Donald Trump. Last time I checked, he was 151 ether. So there's like a lot of money basically in these crypto collectibles.
00:04:19.290 - 00:04:59.078, Speaker C: So what comes next? I don't know. Maybe after this hackathon, the next thing is going to come out from one of you guys, who knows? So I wanted to actually show you how to build it. And we're going to do a very small example of our own ERC 721 token. We're going to be minting colors just like that. I chose colors because you can mint the iD, and then the id actually represents the Hex color id, so we don't have to worry about any storage. And yeah, your browser can just understand what color you just bought. So if you guys are following along, we're going to be using truffle.
00:04:59.078 - 00:05:31.878, Speaker C: Truffle is a very useful tool to actually compile, migrate, deploy, and test your contracts. We're going to be using test RPC as your local node. We're going to be using open Zeppelin to actually inherit some of the implemented contracts. This is really going to speed up our development. So I highly recommend you use them. And then we're going to use web3 and metamask to actually interact with the UI. So if you git clone my repository, all it has actually is just the UI part we're going to be doing everything else right now.
00:05:31.878 - 00:06:08.930, Speaker C: So without further ado, let's go to the terminal. That's not the terminal. That's the terminal. Okay, so one step that I've already done is I did truffle init. So truffle init basically just gives me three directories, which is migrate, test, and contract. And so if I go to my editor here, I have the things that truffle init has given me, contract migrations test, which is empty, and some config files. Okay, so the first thing we're going to want to do is we're going to actually want to create our contract.
00:06:08.930 - 00:06:14.834, Speaker C: So we're going to do ERC 721.
00:06:14.872 - 00:06:16.360, Speaker B: That's all great.
00:06:16.890 - 00:06:27.510, Speaker C: So the first thing that you have to do is basically say, okay, I'm going to use solidity and it's going to be of a particular version.
00:06:29.870 - 00:06:30.620, Speaker B: Great.
00:06:31.230 - 00:07:00.020, Speaker C: So now we're going to do their contract. See colors, ERc 721. And we're going to say that it is ERC token. Sorry, ERC 721 token and ownable. And where am I taking this from? I'm taking this from open zeppelin. So let's import that. So if you do NPM install, you will get open Zeppelin here.
00:07:00.020 - 00:07:39.082, Speaker C: Zeppelin solidity. So we're just going to import zeppelin soliditycontractoken. ERC 721, ERC 720 Onetoken Sol. Okay, that's kind of a mouthful. And then we're going to do pretty much the same for ownable, except it's going to be contract ownership, ownable Sol. And if I make a typo, please let me know. Oh, hey, I made typos by not making semicolons.
00:07:39.146 - 00:07:40.080, Speaker B: Okay, great.
00:07:40.690 - 00:07:51.742, Speaker C: So the first thing we're going to do is we're going to give it a name and symbol. So we're going to say string, constant, public name. See, colors.
00:07:51.886 - 00:07:52.580, Speaker B: Great.
00:07:53.270 - 00:08:22.798, Speaker C: And then let's also give it a symbol. And the symbol is going to be hex because colors are in hex. And now we're ready for a constructor. So we're not actually going to put anything in the constructor. But if you wanted to kind of initialize your contract with certain things, this is where it would go. So it would kind of set the state. Okay, so now that we have name and symbol, technically they're public, so we don't need this, but we're going to go ahead and do it anyway.
00:08:22.798 - 00:09:14.286, Speaker C: So it's going to be public pure, meaning that it's a function that doesn't have access to any dynamic storage and it's going to return a string and we're just going to return a name and similarly we're going to do the same for symbol. Nothing exciting. Okay, so now that we actually wrote some code, let's actually test it because that's kind of the most important part. So in your test directory we're going to make a new test file. We're going to call it colors ERC 721 test Javascript. So this is going to be land of Javascript now. So because we're going to be using truffle, we get a lot of really cool things for free.
00:09:14.286 - 00:09:34.718, Speaker C: So for example, we can do contract definition and we can just load it from something that truffle provides. Artifacts require colors. Eric 721.
00:09:34.904 - 00:09:35.254, Speaker B: Great.
00:09:35.292 - 00:10:22.020, Speaker C: So now we have our contract definition. So truffle gives us mocha, and so they've given us this contract function that basically lets us test contracts very easily and we're going to give it accounts. So accounts here is coming from whatever test network you're going to be using. So by default truffle uses Ganesh test RPC, and so it gives you ten accounts of 100 ether in each account. So we're going to go ahead and use that. So we're going to say that we're going to get an owner, which is the first account, and then we're going to have a contract instance. So right now we just have a contract definition, but we haven't actually deployed it yet.
00:10:22.020 - 00:10:43.020, Speaker C: So let's go ahead and do that. So we're going to say that now our contract instance, so we have to use await. And that's kind of why I made you guys install node v eight because whenever you're interacting with a contract, you kind of have to wait for it to deploy. You have a question?
00:10:49.630 - 00:10:50.720, Speaker B: Thank you.
00:10:52.290 - 00:10:55.360, Speaker C: Is that what you meant? Fantastic, thanks.
00:10:57.330 - 00:10:57.982, Speaker B: Great.
00:10:58.116 - 00:11:00.800, Speaker C: So now we can get this.
00:11:03.590 - 00:11:03.918, Speaker B: We'Re.
00:11:03.934 - 00:11:21.080, Speaker C: Going to make a new version of this here. I'm saying that from owner and because we inherited ownable here, I basically get all those functions for free, so I don't have to worry about who's the owner of the contract because I inherit all those methods from there.
00:11:21.690 - 00:11:23.046, Speaker B: Okay, great.
00:11:23.148 - 00:11:57.006, Speaker C: So now we have our contract instance. Let's actually check who the owner of it is. So owner is owner of contract. Okay. And we say, so let contract owner, let's actually check what the contract owner is so we can say, okay, who's the owner here? And we're going to check that they're the same. So star equal contract owner is indeed owner.
00:11:57.118 - 00:11:57.970, Speaker B: Okay, great.
00:11:58.040 - 00:12:00.340, Speaker C: Now that we have some code, let's actually.
00:12:03.110 - 00:12:09.970, Speaker B: What was that's.
00:12:11.770 - 00:12:13.160, Speaker C: Oh, thank you.
00:12:15.050 - 00:12:16.166, Speaker B: All right, awesome.
00:12:16.268 - 00:12:38.782, Speaker C: Thanks. So, okay, let's see if this works. Okay, awesome. It worked, but our contract is kind of boring right now. It's actually not doing anything. So let's make it do things. Let's actually make it mint things.
00:12:38.782 - 00:13:11.246, Speaker C: And we're going to mint colors, but we have to give it some functionality to do that because just using openzeppelin doesn't give us for free. So let's actually mint things. We're going to make it a public payable and we're going to use a private method that we inherited from Openzeppelin mint. So it's going to take, who's the owner? We're going to say that message sender is the owner. And what is the owner of? He's the owner of the Colorad.
00:13:11.378 - 00:13:12.170, Speaker B: Okay, great.
00:13:12.240 - 00:13:48.200, Speaker C: Now that we have that, let's actually test it. So mint. Okay, let's see. So because here we're using unsigned in 256 in Javascript, there is kind of, there you go. In Javascript, there's no such object. So we actually have to make an object. And so truffle comes with web3, so we can make a new web3 big number which will give us basically non scientific six int.
00:13:48.200 - 00:14:19.150, Speaker C: Okay, so let's say that the token id is one and let's also check the transaction. So let's actually mint it. So I'm going to say that transaction equals the result. So what we're going to do, and what are we going to do? We're going to mint, we're going to mint the token id and we're going to say that it's going to be coming from the owner.
00:14:20.850 - 00:14:21.310, Speaker B: Okay.
00:14:21.380 - 00:14:55.900, Speaker C: And then a couple of things that we can test here. We can test that the transaction has transfer event. So part of the requirement is that every time you mint, you also send out a transfer event. And these are kind of important because these logs are kept on all the nodes and it's a very easy way to kind of get historical information about what happened with your contract. So I think we should definitely test that. So transaction has correct event. It's going to be in a sync function.
00:14:58.270 - 00:14:58.826, Speaker B: Okay.
00:14:58.928 - 00:15:22.420, Speaker C: So we'll assert that transaction logs should be the first log event, should be the transfer event. Okay, let's see if that worked. Okay, it didn't work. Oh, it didn't work because I forgot to save.
00:15:28.790 - 00:15:30.434, Speaker B: Okay, cool. It worked.
00:15:30.552 - 00:15:32.900, Speaker C: So we made a transfer event.
00:15:33.910 - 00:15:34.994, Speaker B: Okay, cool.
00:15:35.112 - 00:16:01.140, Speaker C: So now let's see if the owner is actually the token id owner. So we'll say owner is token or is color id owner. Okay, so we'll say token owner contractinstance owner of and given the token id.
00:16:01.910 - 00:16:03.300, Speaker B: That should be it.
00:16:03.910 - 00:16:09.800, Speaker C: So we'll assert that the token owner, thanks.
00:16:10.810 - 00:16:11.558, Speaker B: Great.
00:16:11.724 - 00:16:13.270, Speaker C: Is actually the owner.
00:16:13.930 - 00:16:22.554, Speaker B: Okay, let's see if this workshop. Great. It works.
00:16:22.752 - 00:16:37.840, Speaker C: Okay, but it's still kind of boring because we kind of are minting tokens for free. Let's actually add a functionality to pay for your tokens. Let's give it kind of a constant starting point. Let's say that the starting price.
00:16:40.530 - 00:16:40.894, Speaker B: Is.
00:16:40.932 - 00:16:43.810, Speaker C: Going to be zero, zero, one ether.
00:16:44.870 - 00:16:45.940, Speaker B: Okay, cool.
00:16:46.310 - 00:17:04.150, Speaker C: So now we're going to require that the value of the message is going to be greater than or equal to price. So right now our test should fail because we're not sending any money when we mint. So let's see if they properly fail.
00:17:04.890 - 00:17:06.082, Speaker B: Great, they failed.
00:17:06.146 - 00:17:35.620, Speaker C: So when we mint the token, let's actually give it some value. Okay, so here, let's say let price equals u web3 big number. So the problem here is that we need to actually represent this number in way. And I don't know about you, but I don't know way off the top of my head. So we're going to use a function called two way. And let's say that equals so two way. We're going to give it one ether basically.
00:17:36.150 - 00:17:37.394, Speaker B: Okay, cool.
00:17:37.592 - 00:17:50.920, Speaker C: So now when we mint, we're going to send not just the quizzes coming from, but also the value. And let's set gas price to zero just so we can test better.
00:17:51.370 - 00:17:54.920, Speaker B: Okay, let's see if it works now.
00:17:58.510 - 00:17:59.306, Speaker C: Awesome.
00:17:59.488 - 00:18:00.266, Speaker B: Cool.
00:18:00.448 - 00:18:39.858, Speaker C: Okay, so that's cool. But it's still kind of boring. Okay, so let's make a functionality where someone can claim your token. So right now you can't mint two of the tokens of the same id, but maybe you can steal a token. So let's say you can claim a token, and let's say that you can only claim it for a price that's bigger than the original price. So how do we do that? Well, first, in order to do that, we have to kind of keep track of all the token ids and all the prices that those token ids correspond to. So let's do a mapping.
00:18:39.858 - 00:18:52.700, Speaker C: So we're going to do a mapping of the token ids to the prices and we're going to call it token to price.
00:18:54.430 - 00:18:55.180, Speaker B: Okay.
00:18:56.990 - 00:18:57.980, Speaker C: Thank you.
00:18:59.390 - 00:19:00.362, Speaker B: Okay, cool.
00:19:00.496 - 00:19:32.520, Speaker C: So when we mint, we're just going to add it. So we're going to say that color id, now it's going to have a default starting point of price. And when we claim, we're going to have to claim it for something more. So let's make a function to figure out what that more is. So let's say get new price. So given the token id, it's going to make it a view and it's going to return a new price.
00:19:35.290 - 00:19:36.040, Speaker B: Okay.
00:19:36.490 - 00:20:04.740, Speaker C: So the way it's going to do that, let's get old price, which we can do through our mapping and let's calculate the new price by saying that the new price equals the old price and let's raise the price by like 50%. So the way we do that is we would actually multiply it by 50 and divide by 100.
00:20:07.110 - 00:20:07.570, Speaker B: Okay.
00:20:07.640 - 00:20:09.220, Speaker C: And then let's return it.
00:20:10.630 - 00:20:11.490, Speaker B: Okay, cool.
00:20:11.560 - 00:20:34.650, Speaker C: Now that we have that, when we claim, we have to say, okay, let's figure out the new price first. Okay. And let's make sure that it's sending the correct amount. So message that value is greater than or equal to new price.
00:20:35.740 - 00:20:36.440, Speaker B: Okay.
00:20:36.590 - 00:21:16.800, Speaker C: Once all that's good, we can use one of the functions from open Zeppelin's implementation for your c 720 token, which is clear and clear approval and transfer. So the first is from whom? So owner of the original owner of color id to the person who is actually making this transaction and what the color id. Okay, so we wrote a lot of code. Let's actually test it now because otherwise it's kind of a black box of what happened. Okay, so let's see. Second person can claim.
00:21:20.420 - 00:21:21.530, Speaker B: You. Okay.
00:21:26.860 - 00:21:38.670, Speaker C: So we're going to say second person is contract instance. Actually, sorry, the second person. So we have a bunch of accounts. It's going to be just a second account.
00:21:39.120 - 00:21:39.532, Speaker B: Okay.
00:21:39.586 - 00:22:05.430, Speaker C: And now we're going to claim. So contract instance, claim. What are we claiming? We're claiming that same, I guess I call it token id. Token id. And we're going to say it's now from the second person and we need value, bigger price. We haven't made that yet. So let's go ahead and make it.
00:22:07.400 - 00:22:07.904, Speaker B: Bigger.
00:22:07.952 - 00:22:25.688, Speaker C: Price equals new web3, big number web3, two, a and let's say now they're going to buy it for one ether because I don't want to do the math.
00:22:25.864 - 00:22:28.332, Speaker B: Okay, cool.
00:22:28.466 - 00:23:17.910, Speaker C: So now that in theory the second person now claimed it, let's actually test that. So let's say that we're going to say who's the new owner now? So let token owner equals await contractinstance. Owner of Tokenid and let's see if those are the same. So token owner is now the owner. Okay, let's see if this works. It probably will fail, but who knows? Who knows? Okay, so it didn't actually work.
00:23:26.520 - 00:23:27.940, Speaker B: Oh, sorry. Awesome.
00:23:28.010 - 00:23:53.012, Speaker C: So it actually logically failed correctly. Thanks. Okay, awesome. So one more thing. So when you actually bin or when you claim, let's say the person sent you a lot more money than was needed. So in theory we want to be good people and we want to give back the money if they overpaid. So let's go ahead and do that.
00:23:53.012 - 00:24:43.730, Speaker C: So let's say that the excess is going to be message value minus price. Okay, does anyone see a problem with this? Anyone? Okay, so the problem with doing something like this is that everything's, well, message value is actually an unsigned int and price is also an unsigned int. So whenever you're doing unsigned int minus something else, you run into a risk of underflow, meaning that one minus two doesn't actually equal negative one because it can't. So it actually equals nine. Nine. So you could potentially deplete your entire contract. So you can either use, that's true, but let's just not assume that.
00:24:43.730 - 00:24:51.160, Speaker C: Let's go ahead. Like whenever you do a subtraction, either use safe math or do an if statement. So let's just go ahead and do that. And you're totally right.
00:24:54.570 - 00:24:55.030, Speaker B: Okay.
00:24:55.100 - 00:24:59.058, Speaker C: So we can only do that when we know that the result is going to be positive.
00:24:59.154 - 00:25:00.246, Speaker B: Okay, cool.
00:25:00.428 - 00:25:06.620, Speaker C: And you can test that because you can get the balance, but we're not going to do that because it's kind of a lot of work.
00:25:08.030 - 00:25:08.490, Speaker B: Great.
00:25:08.560 - 00:25:18.030, Speaker C: We're actually kind of done. Everything's passing. So let's actually deploy this now. So we'll deploy it to our local network.
00:25:20.450 - 00:25:21.054, Speaker B: Sorry, what?
00:25:21.092 - 00:25:23.518, Speaker C: Oh yeah, sorry. We're not actually doing anything with it.
00:25:23.604 - 00:25:24.240, Speaker B: Okay.
00:25:24.850 - 00:25:52.310, Speaker C: Yeah, let's actually give it back, huh? Oh yeah, thanks. Okay, good point. So now when we claim we actually want to update our mapping. Sorry, let me go ahead and finish this. Good catch. Okay, so when we do this, we have a new price. Let's go ahead and update the mapping.
00:25:52.310 - 00:26:03.080, Speaker C: Okay, let me make sure and I can further test this. But let's get to the actual fun part.
00:26:04.330 - 00:26:05.430, Speaker B: Okay, cool.
00:26:05.580 - 00:26:27.722, Speaker C: So let's actually migrate this to our local node. So the way we're going to do that. So truffle gives us a pretty easy way to do this. It already gave us a directory with all our migration files. So we're just going to create another one. It's going to say deploy colors. And it's going to be pretty simple.
00:26:27.722 - 00:27:18.466, Speaker C: So first we're going to once again need kind of our definition. It's going to be artifacts require colors. ERc 721 soul. And this is kind of Javascript stuff. So equals function deployer. So this kind of just tells truffle what exactly to doesn't actually, we haven't set up truffle to actually understand what networks we want to deploy. So let's actually deploy to our local network.
00:27:18.466 - 00:27:24.470, Speaker C: So one of the other requirements is to get test RPC. So if we run test RPC.
00:27:27.630 - 00:27:28.038, Speaker B: I'm.
00:27:28.054 - 00:27:59.938, Speaker C: Going to save this for future reference. So once it starts, it gives you a local host and it's about the port. So let's go ahead and say, okay, we have these networks, we have the development network, it has a host which is home, has a port which is, what was it, 8545. And it's going to map to all network ids. So wildcard here.
00:28:00.024 - 00:28:01.266, Speaker B: Okay, cool.
00:28:01.448 - 00:28:08.840, Speaker C: So if we did that correctly, when we do truffle migrate, we should actually see something migrate here.
00:28:09.850 - 00:28:10.902, Speaker B: Okay, cool.
00:28:11.036 - 00:28:19.980, Speaker C: Our contract was created, so now if we actually did everything correctly, we can actually run our website.
00:28:21.950 - 00:28:22.602, Speaker B: Great.
00:28:22.736 - 00:28:33.600, Speaker C: So when you started test RPC, it gave you that mnemonic. So we're going to go ahead and use it. That wasn't it. Oh no, that was it.
00:28:34.850 - 00:28:35.262, Speaker B: Okay.
00:28:35.316 - 00:29:06.940, Speaker C: We're going to use this mnemonic to actually get our accounts. So that's our mnemonic. You can just make whatever password now we should see. Okay, so now we're rich. We started off with 100 ether, we lost some because we actually deployed the contract and now we can mint our color. Okay, doesn't work as well. In one sec, let me make it not full screen.
00:29:07.550 - 00:29:08.300, Speaker B: Okay.
00:29:09.150 - 00:29:11.100, Speaker C: And now we can mint our color.
00:29:12.510 - 00:29:13.114, Speaker B: Great.
00:29:13.232 - 00:29:18.960, Speaker C: And then maybe I want to mint this one too. And maybe that one.
00:29:20.290 - 00:29:20.990, Speaker B: Okay, cool.
00:29:21.060 - 00:29:26.350, Speaker C: So when I make a new account, okay, so those are still transferring.
00:29:29.010 - 00:29:29.662, Speaker B: Okay.
00:29:29.796 - 00:29:37.140, Speaker C: So when I make a new account, they're going to be gone because it's a different account and this account is going to have this pink color.
00:29:37.670 - 00:29:38.130, Speaker B: Cool.
00:29:38.200 - 00:29:46.760, Speaker C: So if I go back to my previous account, which I have those three colors that I minted and the other one has just that one.
00:29:47.930 - 00:29:49.094, Speaker B: Cool. Okay.
00:29:49.212 - 00:30:05.500, Speaker C: And that's actually kind of it. Like we just created our own ERC 720 on token with a very basic ui. Great, so what now? Awesome.
00:30:10.190 - 00:30:10.746, Speaker B: Cool.
00:30:10.848 - 00:30:49.178, Speaker C: So right now, because these non fungible tokens, it's kind of hard to visualize them. I mean, I use colors for a reason if you wanted to do this in real world. Cryptokitties, for example, they have a centralized sort of mapping of id to image. Crypto celebrities has the same crypto punks is using a completely different thing. So how do you actually see what you just made? And so Opensea is a marketplace for non fungible tokens. If you actually do something as hackathon with non fungible tokens, when you launch it to rinkabee or mainnet, you can actually see your tokens by going to a URL like that. Yeah.
00:30:49.178 - 00:31:23.682, Speaker C: And if you guys have any questions with OpenSea integration, go talk to them. Alex and Devin are over there. Yeah, and that's it. Good luck with the hackathon, guys. Oh, do you have any questions? Yeah, so I don't know if I can make these slides available or not, but yeah, the source code is all there. It's on my GitHub. My GitHub is lean the bean.
00:31:23.682 - 00:31:45.174, Speaker C: And there's two repositories. One is called colors and one is called colors finished. So you might want the finished version. Lean the bean. That's right. Any more questions? Comments? Oh, sorry. Open zeppelin.
00:31:45.222 - 00:31:45.578, Speaker B: Okay.
00:31:45.664 - 00:32:16.160, Speaker C: The question was kind of like, what's the difference between Openzeppelin and truffle? So truffle is kind of a tool to let you compile, migrate, deploy, and test your contracts. Openzeppelin is kind of a really fast way to get a boilerplate. So they already implemented a lot of these standards. They have an implementation of a USC 27 21 and a bunch of others. So it's like a great starting point. Any more questions? All right, thank you so much. Thank.
