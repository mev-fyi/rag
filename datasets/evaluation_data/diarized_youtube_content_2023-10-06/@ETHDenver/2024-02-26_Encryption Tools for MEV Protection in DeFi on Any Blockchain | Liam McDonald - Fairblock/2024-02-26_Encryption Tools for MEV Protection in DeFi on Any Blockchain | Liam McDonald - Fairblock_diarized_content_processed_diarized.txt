00:00:07.450 - 00:00:48.102, Speaker A: How's everyone doing? We alive? Yayo. All right. Great to meet everyone. I am Liam. I'm the head of growth here at Fairblock, and I'm going to be talking today about tools that can be used for bad mev prevention in Defi. Just some things to preface first, maybe I just found out about this talk yesterday. The founder who was supposed to give this talk, his flight got canceled very abruptly due to some septic issues on the plane.
00:00:48.102 - 00:02:16.322, Speaker A: Unfortunately, it's a pretty disturbing way to get your flight canceled, but nonetheless, we are here, and I'm really excited to be sharing what we've been working on with you guys. So the second bit of preface to say is, while Bad MeV prevention is one of the benefits of the solutions that Fairblock offers, it is only a small subset of what we do. We're working on cryptographic solutions to programmable privacy, and the bad MeV prevention side of this is, like I said, just a small bit of the benefits that come from the tool set that we offer. The main point of this presentation is the extent of what's now possible on chain with programmable privacy. And when we talk about programmable privacy, we're not talking about just zero knowledge proofs. We're talking about fhe, we're talking about a number of different cryptographic schemes that can be brought on chain with now what's available today with WASM and other rust based cryptography libraries. So, yeah, with that preface, we are not a competitor to flashbots.
00:02:16.322 - 00:03:42.500, Speaker A: We are very much working in alignment with what they're doing, but more on the cryptographic side of Bad MeV prevention. So we respect them, we love them, they do great work. But we also understand, too, that the design space for Bad MeV prevention is much larger, and what they've worked on so far is just kind of a temporary solution with their centralized server. So, with that as the preface, let's get into it a bit of a itinerary. First, we're going to be starting off with just reviewing the state of MEV, going into what is fair block, an introduction to our architecture, threshold Ibe, applications of IbE in DeFi, such as encrypted intents, sealed bid auctions, and more generalized programmable privacy, some cool things that can be built from this, and what to expect from us in the next year. So let's get into it. So the current state of MeV, so MeV, as we all know, is the value that can be extracted by privileged actors in any system.
00:03:42.500 - 00:04:55.050, Speaker A: This is kind of the famous Hasu quote some traditional forms of MeV include arbitrage, sandwich attacks, liquidations, just in time attacks. Some newer forms of MeV include cross chain arbitrage, sex to Dex arbitrage, and opportunities at the bridge and oracle levels as well. And then in terms of the mitigation techniques that are now available, we have the encryption side of things, which is what we're working on at Fairblock. To also preface too, we're not working on solutions that support good meV. The cryptography tools that we use are really just to prevent some of the opportunities for bad MeV. There's flashbots with MeV Boost and Mev share, and then there's also mitigation techniques at the app design layer, such as frequent batch auctions and Protorev. So with that, that leads us to Fairblock.
00:04:55.050 - 00:06:34.810, Speaker A: What is Fairblock? We are a modular ecosystem of privacy enabled infrastructure and applications. So we deliver programmable privacy to protocols and their applications to protect users from malicious actors and the downsides of on chain transparency. And just to kind of give a bit of color first on why we're building Fairblock, we think that a lack of privacy on chain is one of the bigger deterrents to blockchain adoption. And that's a major reason for why we're not maybe where we want to be in terms of the whole blockchain adoption scheme right now, because most on chain applications are limited in their designs to a global user base because of a lack of privacy. And up until now, most on chain privacy has been materialized into isolated l ones that position privacy more or less as a luxury instead of as a standard. Meaning that if we were to make privacy a standard, we should be delivering it to protocols and their applications so that this privacy can be accessible inside of users favorite ecosystems and applications without having to sacrifice UX. So this is how, in my opinion, we create the foundation to build stickier apps that attract the next billion users.
00:06:34.810 - 00:08:00.220, Speaker A: So with that, I'd like to go over ferryring at first. Ferryring is the foundation of all things that we do at Fairblock. It is essentially a key generation chain that acts as a decryption key, oracle that sends encryption and decryption keys to any blockchain or any application across any ecosystem. This can be done via IBC or a network of relayers that we use called ferryport. And like I mentioned, or sorry, as we are connected to IBC, we are also a cosmos SDK chain as well. So just to kind of go over a bit of the architecture to lay this out and how this works it starts with users encrypting a transaction with a certain on chain condition. This condition could be a certain block height, an asset price, a zero knowledge proof really whatever data point on chain that you want to program your transaction to be decrypted at, this is possible with IBE.
00:08:00.220 - 00:09:14.450, Speaker A: And so once the condition for decryption is selected, the encrypted transaction is then committed on chain, where it sits in the mempool waiting for those conditions to be met, to then be decrypted and executed. Once that condition is met, the ferryring validators are notified via ferryport and work together to construct the private key. They do this by deriving their share of the private key first, which is derived locally. They will then submit it to ferryring. Ferryring once a certain threshold of validators private key shares are met, ferryring then performs a function to construct the derived private key, which is then sent to the destination chain, where the transaction is then decrypted and executed. So, as you guessed it, if you're in tune with the cryptography world, this process is what we call threshold ibe. Ibe, like I said earlier, stands for identity based encryption.
00:09:14.450 - 00:10:58.310, Speaker A: This is what enables us to choose certain conditions on chain that will be used for the decryption of transactions. In the threshold ibe that ferryring runs, we generate a master secret key. We call this the MSK from an API. This API, just as a preface to, will soon be converted into a DKG based approach where all the validators in the chain are working together to derive the master secret key and the public keys that are used. And then once that key is generated, it's then split up amongst the validators in the network and stored locally. And then when every condition for decryption on chain is met, the validator will then generate their private key share and then submit it to ferryring for the derived private key to then be constructed and then sent to the destination chain. So there are a number of applications that threshold Ibe unlocks on chain, but I'm going to focus most of the rest of this presentation on the applications in DeFi, because that's where we want to kind of show the value here is that with bringing Tibe to DeFi applications, we do help these apps and their users mitigate some of the opportunities for bad mev.
00:10:58.310 - 00:12:05.420, Speaker A: And the first one that I'd like to go over is encrypted intents. So these could be limit orders, stop loss orders, really, any kind of programmable privacy or programmable, sorry, yeah, programmable trading available on chain. And so you might ask first, why would you want to encrypt transactions? This could be to keep the size of your order hidden. This could be to retain information asymmetry. This could be to protect any of your trading strategies. The point is that you can really program the decryption of these transactions to meet whatever need you're looking for. So a general flow of what this looks like is a trader will submit an intent, say the intent, or sorry, say the intent is set to decrypt at ether price 4k, for example.
00:12:05.420 - 00:13:04.950, Speaker A: That transaction will then be sent to the app front end. The app front end will then submit that transaction to the chain where it lives in the mem pool, where it'll wait for the conditions to be met on chain. Once that condition is met on chain, ether suddenly reaches 4k, which we're all patiently waiting for. The relayers of ferryport will then request the decryption key from ferry ring. Fairy ring will then generate the decryption keys, send it to the app chain, and then the intent is decrypted and executed. This design is also really important for sealed bid auctions too. This is something that we've all probably been seeing recently with Paradigm's recent post on leaderless auctions.
00:13:04.950 - 00:14:04.570, Speaker A: So the design here would be very similar where the bidder, for example, would submit a bid to decrypt at block height, whatever that block height is, generally the end of the auction or the end of the round. In the auction, that encrypted bid will then live inside of the chain in the mempool where it's gathered alongside all of the other encrypted bids. Once that block height is then reached, ferryport requests the decryption keys from ferryring. Ferryring sends those decryption keys to the chain. The chain then performs a function to decrypt all of the encrypted transactions in the mempool. With logic that is then set to select the winning bid. That winning bid is then decrypted, or, sorry, executed.
00:14:04.570 - 00:15:13.874, Speaker A: And you might ask what are some advantages of this over traditional auction systems? One of them is that there's no collateral needed to guarantee bids are revealed, like in a typical commit reveal scheme. The other one is that there's no risk of censorship based on bid amount. So each of these things are kind of part of what we considered highly in thinking about how Tibe can be used on chain to secure sealed bid auctions. And then just maybe to wrap our heads around the more like meta approach here. This programmable privacy can be brought to any application on chain, and the flow inside of these applications will be similar. It's not just useful in defi, it could be useful in private governance gaming. The list goes on and on.
00:15:13.874 - 00:16:32.570, Speaker A: So in terms of maybe the one nuance here that I hadn't mentioned prior is that there is a initial communication between ferryring and the app chain itself, where ferryring sends a master public key to the application chain. That master public key is then used inside of the process where the user chooses their decryption condition. That decryption condition is basically matched with the MPK in order to become kind of like the public key for that transaction, and then kind of the flow goes on from there as, as we talked about prior. So there are a lot of really cool things to build with programmable privacy on chain. One of these things could be private governance, which we've already built for the Cosmos hub. Like I've said, this could also be encrypted on chain intents as well. This could be randomness generation for on chain gaming, gambling casinos, whatnot.
00:16:32.570 - 00:17:46.050, Speaker A: There's also censorship, resistance, shared sequencing where decryption is enabled at the sequencer layer. There's encrypted mempools, privacy preserving roll ups, private on chain games, and so much more that even we haven't fully thought about just yet, but are actively researching. And like I've kind of alluded to earlier, the design space for applications on chain with programmable privacy is huge. This is what we think is the next big on chain integration that will unlock the design space for the next million apps that will attract the next billion users. So yeah, we are in the business of pushing the boundaries of what we can do here on chain, I think is always important to remember. So that's all for now. If you guys want to scan this QR code, it's our link tree that takes you to our GitHub, our Twitter, all of our docs.
00:17:46.050 - 00:18:36.194, Speaker A: You can find us throughout the week at basically every event. One that we'd like to get a lot of developers at is our workshop with door hacks at Appchain Day, where we can test out these mev resistant auctions with some of our cryptography libraries. We've got our testnet launch scheduled for March 6 right after e Denver. We've got a hackathon with door hacks that's going to be announced soon and many exciting partnerships across the infra and l two landscape that will be announced soon, as well as opportunities for builders to contribute early. So, so that's all I've got today. Thanks, everyone. Thank you for your attention and time.
00:18:36.194 - 00:18:42.160, Speaker A: And we're really excited to see what we'll build with programmable privacy on chain. Thank you.
