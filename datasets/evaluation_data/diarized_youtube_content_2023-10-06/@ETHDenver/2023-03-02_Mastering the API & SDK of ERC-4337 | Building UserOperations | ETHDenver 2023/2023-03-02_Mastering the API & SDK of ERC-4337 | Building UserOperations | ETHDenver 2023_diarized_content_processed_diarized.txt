00:00:00.330 - 00:00:34.790, Speaker A: An account abstracted account is a contract. Contract is the king. What we try to abstract, we abstract validation. We have account expose validation method which allows us different type of validation. As we will see shortly. We abstract execution like execute batch if you want something else, instead of a single transaction. And we have abstract gas payment, so that an account can pay for itself if it likes, but if not, it can use a paymaster contract.
00:00:34.790 - 00:01:00.014, Speaker A: There's a basic component of ERC. Four, three, seven. Maybe I should start with a small question. How many people went into an introduction to 447? Okay, just a few. I'll keep it, I'll continue. We don't have much time for that. So the main component we have is, first of all, there's the account, the contract account.
00:01:00.014 - 00:01:28.070, Speaker A: This is the contract that expose the account. Its address is the address you own and you control it not only by signature, but could be by other methods. The second component is the entry point. This is the main component. We have to orchestrate all the transactions to our account. And as I said, there are paymasters, which are contracts which are responsible for paying for the gas. For transactions.
00:01:28.070 - 00:02:00.334, Speaker A: A user operation is the term we use for a transaction. Whenever you see the term user operation, think of a transaction on steroids. Transaction to our account are called the user operations. And under the hood we have bundlers, which are the block builders, which work with the memory pool. Let's see what it takes. The lifecycle of user operation. I as a user, have an application the application creates.
00:02:00.334 - 00:02:41.520, Speaker A: I want to send a transaction to the network. I use some wallet, wallet, this is the wallet on my device, chrome extension or whatever, and I create a transaction, a user operation, just like normal transaction, it is sent into a mempool. The mempool is a mempool of user operation. It's not a mempool of transaction, but it behaves the same. It is decentralized. Then a bundler, one of the bundlers in the network, just like one of the nodes, pick up this transaction along with other transactions. In order to create a bundle, before it can put this transaction on chain, it needs to validate it.
00:02:41.520 - 00:03:03.240, Speaker A: With normal Ethereum transaction validation is simple. You validate the signature, it's an ECDSSA signature, and you validate that. It has enough gas. But as we said, we abstracted all that. We allow a lot of new things with our transactions. So the validation is done by making a contract call. It's making a simulation call into the entry point.
00:03:03.240 - 00:04:02.406, Speaker A: The simulation call validates the account, the account code itself validate itself. And if there is a paymaster. The paymaster validate that it indeed agrees to pay for this transaction. Once it is validated, it is put into a bundle, a set of transactions that are put together on chain and we execute. When we execute again, the validation is done on chain to validate that indeed the transaction, even when it ran on chain, accepts and pays this bundler, and after it validates, it performed the execution, which is the execution of that transaction, and then it put into the chain just like any other transaction. The outcome of the bundler is an ethereum transaction, because one thing I didn't say is that the whole idea is that we run on Ethereum network. As it is, we couldn't introduce a new type of transaction on chain.
00:04:02.406 - 00:04:44.816, Speaker A: So we introduced a mechanism off chain and a contract entry point, and we submit one transaction on chain, which is an entire bundle of user operations. I want to emphasize the difference between transaction and user operation. This is an account, an EOA account. It is secured, I said, by ECDSA mathematical formula, to calculate the public key from the private key to make sure it is correct. It has a wallet. The wallet can do exactly one thing, approve. It can approve this transaction and submit it on chain.
00:04:44.816 - 00:05:13.656, Speaker A: It is sent to the mempool and then a block builder put it on chain. The mempool is there to make sure that there's no denial of service. Nobody attempt to attack the network. It is distributed all over, so nobody can censor you. The block builder again verify the signature, verify you have enough balance, and add it to a block. With account abstraction we have our account, but account is a contract, so the validation is its code. It can do whatever it likes.
00:05:13.656 - 00:06:19.616, Speaker A: We will give several examples later of what do we mean by validated by code. What can we do? The wallet again, it's a software component, but instead of only approving by ECDSA, it can do many other things. Then we use a mempool equivalent to the standard mempool to put it on, and then bundlers collect it, perform the validation and put it on chain. So in terms of incentives and the network flow, it is quite similar to existing transaction, except for the fact that we can validate it using code. Okay, what is in an account? What is an account contract? Account contract. We provide a basic account, you see, it's a single method called user validate user operation, which receive the user operation and it can validate whatever field they need from it. The simplest thing it can do is validate a signature and validate the non.
00:06:19.616 - 00:07:18.388, Speaker A: So we provide a mechanism that validate the nons call a hook for the application to perform signature validation and if need, and it also told how much it need to pay. If there is no payment, it has to pay for the transaction by itself. So it has to pay in advance for the max possible cost of the transaction. In case of failure, it reports that it failed through the return value. This is the basic account that we inherit. This is an example of a specific account we provide in our repository. You see, we validate the nons, it's simpler, we have nons, we increment it by one and we'll make sure that the user operation contains that nons, which basically replicate the nons mechanism that is used by EOA accounts incremented by one.
00:07:18.388 - 00:07:57.540, Speaker A: You can put another mechanism that will for example allow you parallel transactions. And this is a sample validate signatures which uses open zeppelin signature check, which again simulate a normal transaction. Normal EOA account the execution method of an account the account has to be able to execute. So it's a basic it received a destination value and a call and it executed. It is possible to execute a batch. So also created a method to execute a batch. And again, an account can use other execution mechanism if it likes.
00:07:57.540 - 00:09:05.876, Speaker A: If you want to create a paymaster, a paymaster is a contract that will pay for the transaction. The simplest example of a paymaster is a paymaster that pay by tokens. So when its validation method is called, it validates that the user agrees to pay with tokens, which means the paymaster extract tokens from the user, transfer them to itself. It is called once again after the transaction is completed, so that it can repay the user with the excess amount. Again, this is not the base paymaster, it's a token paymaster, which is a concrete example of a paymaster. Now what can we do? Maybe you should start saying what can we do with that? So I like the basic two example for authentication with account abstraction. Think of it that the ECDSA model is one model fit all is that you have to approve each transaction.
00:09:05.876 - 00:09:43.750, Speaker A: Think about gaming. When you're using a game, you have a single or one or two targets, and it's really annoying to accept and approve each transaction. So you would prefer to have in your account something like a session key, like for this specific destination. For the next half an hour, I don't want to approve anything. The most that will happen if my browser is compromised is one hit into the game. It doesn't interfere with my tokens or with anything else. So session keys is a kind of validation that is used for a very low security mechanism in my account.
00:09:43.750 - 00:10:08.236, Speaker A: I will not use them always for games. Yes. On the other end, think of an account that belongs to a corporate. A corporate account has different signers, different roles like the legal are allowed to vote and allow to execute in a DAO. And I don't know, the CFO is allowed to move money. And there is the accounting department which allows to put out salaries. Each one is different.
00:10:08.236 - 00:10:38.800, Speaker A: So you could have an account with different security mechanism. Again, it is a single account. You can have different mechanism. I wanted to put several example of paymasters here too, but I forgot to put it into the slide. I gave you one example of token paymasters. The other example is what we call a sponsor paymaster. It's not a specific example, but think of an application that you want to pay for the users, for your users.
00:10:38.800 - 00:11:17.376, Speaker A: If a user accesses your account, even deploy its own account, you want to pay for that. It's small money and you want to attach this user to you, so you want to pay for it. You don't send money to the user. You put a paymaster which will allow the user to use your destination specific kind of a paymaster for that. If you want to see other use cases, I put up a link. We spent over an hour just explaining different use cases that you can do back in Bogota. Okay, now, we are all builders and you want to use it.
00:11:17.376 - 00:12:00.380, Speaker A: And the main thing we need to build, we need first, okay, we need to build an account to build a feature into it. But then we also need to add this account, ux to support it. And this is to support this account. So what we did, we created a boilerplate for a browser extension. We call it trampoline because it gives you a jump start into. You have QR code at the end with the link to everything. Trampoline is a sample browser extension created by helper from here for gravit.
00:12:00.380 - 00:12:40.828, Speaker A: It is based on Tallyho. It's a browser extension, but it is tailored for creating an account obstruction with that, if you think of something you want to do with account obstruction, you can. You can add it. Let's say you want to add some different kind of signature check. So yes, you need to take. You create an account. So the best thing you can do, you take a simple account or it's basically base account, and you replace the validate signature function.
00:12:40.828 - 00:13:24.472, Speaker A: Now you have an account that uses a different signature check mechanism, but it is not enough. You need a UX to put this value in. So you take the trampoline within the trampoline you have the account API and you add this ux into the trampoline. The trampoline gives you a way to do some onboarding, like collecting information from the user. Like if you find a clever way to use an email as a signature check, it's great. Here you will collect the user's email or whatever. Then when you handle a transaction, this is what will be called to process a transaction.
00:13:24.472 - 00:13:58.512, Speaker A: And there's also hook for mechanism. Can users only ask for signing? So the account API need to provide several basic methods. It is called during onboarding. The first is create the init code like the constructor call to create your account. Because part of the idea is that you don't need some other mechanism to create the account. The account is created using account abstraction, like with metamask. You don't think of, you never create an account, it is always there, it is never on chain.
00:13:58.512 - 00:14:55.400, Speaker A: But with account obstruction, the first transaction to send usually is the one to create the account contract itself. Yes, it means that the first transaction costs a little more, but other than that it's a normal transaction. So you create the constructor code for the trampoline to know how to use, you need to provide it three more functions. One is to handle the nons, one is of course to create the execution function and a way to create a signature which is parsed by your account. And then during onboarding you have the onboarding component. The onboarding component bring up a custom UI to collect information from the user and at the end bring the hooks to create the account. And if you look, we'll see a transaction in a moment.
00:14:55.400 - 00:16:01.568, Speaker A: But the user send a send transaction, a normal send transaction from its application through web three js or through ethers or directly, it sends a send transaction. This transaction is captured by the wallet, the trampoline wallet. It calls the transaction component. It can display information to the user and then when it completes the transaction continues, it creates a user operation. The account obstruction transaction gets signed and sent on chain. I wanted to bring a demo and it was appalling the status of the Internet, so I recorded one about half an hour ago. Okay, so I start, I open my browser extension, I disable developer mode.
00:16:01.568 - 00:16:50.084, Speaker A: I enable developer mode because it has to be a developer mode and disable metamask because it can't work together with the metamask. It replaces metamask and then I load the folder after I okay, I didn't copy the screen, I started it locally and then I loaded the source into metamask and then it pop ups a screen. It asks me to create an account. This is still the trampoline creates, and then the trampoline opens up. Custom ux. This sample didn't do anything in this custom ux, so it's an empty screen, and then it continue. Now it creates in memory the account.
00:16:50.084 - 00:17:34.930, Speaker A: The account is created, it has an address, and it will update. It doesn't have balance, and it is not deployed on network yet. So I don't have a paymatter. So I switch to another account and I sent some girly into that account. Sorry, I didn't have time to edit it. So we'll have to wait in real time for girly to mine it. Okay, this is my account, and I have a balance.
00:17:34.930 - 00:18:38.950, Speaker A: Now I want to execute some transaction. I could deploy it from here, but I wanted to deploy it as part of a transaction, so I don't have an application here. So I opened ether scan on some well known sample application. This is the greeter of Openzeppelin, and it has a set greeting method. So I connect the trampoline, and here it shows metamask, because this is how etherscan connect to a browser extension think they are all called. Okay, I get a connection request for the application, so I will connect to it again. There is a custom screen that I didn't use in this sample.
00:18:38.950 - 00:19:18.442, Speaker A: I have a better sample that uses fingerprints, but I'm sorry, I didn't have time to put it on chain. This screen. This is my bundler, this shows the transaction that it sent. I ran it locally and in few seconds it will show that the transaction got mined, sent through the bundle. And now if we look, we will be able to see this transaction. This is the transaction. It goes not from my account, it's a transaction from the bundler to the entry point.
00:19:18.442 - 00:19:47.470, Speaker A: And internally it is a transaction that handles the use operation of this account. It starts all over. Okay. They say they don't have much time, so if you have more questions, you're left to come over, approach me and. Okay, thank you.
