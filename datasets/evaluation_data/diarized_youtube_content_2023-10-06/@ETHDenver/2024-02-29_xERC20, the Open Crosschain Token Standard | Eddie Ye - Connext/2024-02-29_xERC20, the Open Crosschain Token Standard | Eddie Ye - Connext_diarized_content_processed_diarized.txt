00:00:00.250 - 00:00:18.876, Speaker A: From Eddie Yee, who leads integrations over at Connect. So, Eddie, take it away. All right, thank you. Thank you. Just going to wait for the slides to pop up. Thank you. Hey, everybody, my name is Eddie.
00:00:18.876 - 00:00:57.490, Speaker A: I'm really excited to be here today to talk to you about a new erc on the scene that I think has the potential to solve a lot of the bridging pains that we face today. We haven't shied away from bridging at all, even after all the exploits and hacks and whatnot. Because realistically, at this point, it's kind of like a basic need in the ecosystem. We need a way to transfer value between all of these different ecosystems and for them to be interoperable with each other. And that's where bridging comes in. But bridging comes with its own set of challenges. So let's just consider some of these challenges and where they come from.
00:00:57.490 - 00:01:50.016, Speaker A: When you bridge a token, you're all aware that you're not actually moving the token from chain to chain. You're giving up your token on the original chain in order to get some representation of a token on another chain. That representation token is a claim on the original token, and bridges facilitate this process of the give and take. And as a token issuer or a chain that wants to bring other tokens into your ecosystem, the first thing you have to do is decide, how do I bridge this token to a chain where it doesn't exist yet? And there are a couple of options. So you could just build your own bridge. If you choose to do that, you're going to be immediately responsible for bridge security, and that is notoriously difficult. So most people, most projects are not going to do that.
00:01:50.016 - 00:02:30.488, Speaker A: Not really a viable option. If you are going to a roll up like optimism or arbitrum, there's actually already a canonical chain that exists there. And it just so happens that that chain underpins the entire security of the system. So as actually the safest bridge. That makes it very common and reasonable for tokens to be bridged through canonical bridges. However, canonical bridges don't exist on every chain, only on those roll ups. So if you're a token issuer and you want to go to all these hot new chains that are out there, you need to figure out something else if you want to go to those other chains.
00:02:30.488 - 00:03:48.212, Speaker A: And in EVM land, the canonical bridges only connect the chain to ethereum. So if you want to go from optimism to arbitrum, say you would have to bridge from optimism back to ethereum, suffer the seven day withdrawal period, and then bridge it to arbitram. And those two hops are relatively expensive because canonical bridges are expensive. So canonical bridges offer this secure option, but you still have to figure out other alternatives for other bridges. So historically, token issuers and projects have basically chosen one of two practical cross chain strategies, the first one being just use multiple bridges, right? So you can use the canonical bridges, you can use a variety of third party bridges, all the bridges, and in theory that should allow you to get your token to all the chains that are out there. And usually the canonical abridged version becomes what we call this adopted version of the token. Because every time a bridge deploys a different representation of your token to a different chain, you end up with millions of these different tokens that all represent the same thing on the origin chain, but are different tokens themselves.
00:03:48.212 - 00:05:10.610, Speaker A: So what you really want is you want there to be one widely adopted version that everybody uses, that all your users hold, all the Dexes list and all the DAP support. So you as a project can either accept that the canonical bridged version usually becomes the adopted version because everybody in the ecosystem considers it the most safe. And so that just naturally converges usage into that canonical version. Or on other chains where there is no canonical version, you can try to endorse one of the bridged versions and try to get everybody to use that version, because it's more convenient when dapps don't have to list like 14 different versions of the same token, and everybody's kind of communicating with the same version of that token. The problem with this is that users who bridge through other bridges that don't mint that endorsed version, they have to get the version that everyone else is using at some point. So that introduces liquidity pools into this conversation, and liquidity pools introduce slippage. So now all other bridges, as part of this last mile delivery step, for you to deliver your users the actual version of the token that they want to use on that chain, there has to be a swap involved between the bridge minted version and that adopted version of the token that everyone else is using.
00:05:10.610 - 00:06:13.744, Speaker A: Obviously that makes cross chain transfers incur slippage oftentimes, and aside from slippage being an additional cost to the user, it actually breaks composability in many cases where you need to know exactly how many tokens you're getting on the destination chain. It's not deterministic when you have slippage in the equation. Furthermore, this model means that because you have pools, you now have to source like a bunch of liquidity to minimize on slippage. And if you're a small project, you're not going to shove enough bridge volume through your token to actually generate enough revenues to incentivize lps to create these deep pools. So you're just simply going to have a difficult time bootstrapping liquidity. If you're a larger project sitting on stacks of vc capital, yeah, you can just throw money and add incentives, and that makes that problem a little easier. But it's a terribly inefficient way to use capital and it simply does not scale.
00:06:13.744 - 00:07:38.540, Speaker A: When you think of what happens in the thousand roll up future with 1000 different assets on 1000 different chains, even that, like throwing money at it, doesn't solve it. So there's one other major issue with this model, and it's that when bridges lock tokens on the original chain, or the home chain as we sometimes refer to it, this home chain is where the original token is deployed. And every time bridges lock that token and mint a different representation on a different chain, it actually fragments that liquidity on that home chain. Because each bridge contract is now custodying a slice of the total canonical collateral on the home chain. So if you want to move like a relatively large amount of tokens back to the home chain through one specific bridge, it's totally possible that that bridge doesn't actually have the canonical assets, the locked collateral on the home chain to unlock for you, which kind of breaks that guarantee of like your tokens are claims that you can claim on the origin chain at any time. So this model with multiple bridges, it introduces slippage, which is an issue, and it really makes things kind of complicated, but it allows you to get to most all the chains out there. The other option is much simpler.
00:07:38.540 - 00:08:23.040, Speaker A: It's basically just vendor lock in. So as a project, you choose one third party bridge, you designate them as like your endorsed bridge, and the minted version of their token becomes the adopted version. You consider that version as the only legit one on every chain that they support. And it makes things easier because that bridge, now there's only one representation, and that bridge owns all of them on every chain. So if you need to go from l two to l two, the bridge can just burn and mint those tokens directly. No need for pools, no need for liquidity. And yeah, that sounds great because there's no slippage, but you're also only able to go to the chains that that bridge supports.
00:08:23.040 - 00:09:36.310, Speaker A: But more importantly, your entire token is tied to the security model of that one third party bridge. And that introduces systemic risk, a classic case study is multichain, where projects knew of the risks of a third party validated bridge, but they had no better alternatives on many other chains that they wanted to go to. So they had their tokens minted through multichain, tied themselves to the any asset system, and when things fell apart, their token is now unbacked and they don't have control over the token, they don't have any recourse. It's done. So you're locking yourself into this proprietary token standard that introduces the systemic risk of the bridge itself, and you are not able to kind of go back from that system. It's very difficult to escape from the walled garden of a proprietary token standard minted by a single bridge, especially if you give it unbounded minting privileges and unbounded flows through their bridge. So obviously this option is not too hot either.
00:09:36.310 - 00:10:22.870, Speaker A: So just as a summary, we have bridges that mint representation tokens on other chains. They're actually free to do that. Like it's a permissionless model. Any bridge can lock your tokens and deploy a representation and then mint your users that representation. And many projects opt for this model where they say, okay, I'm going to accept all these bridge providers, I'm going to allow all these different pathways for my tokens to be bridged, but then it necessitates a single adopted version of that token to be used. Otherwise it's just like fragmented across all these different versions and nobody knows what version is the real one to use. So usually you want to go through some kind of social consensus or project endorsement to designate one version as the one that everyone should use.
00:10:22.870 - 00:11:53.488, Speaker A: That introduces the need for pools, introduces slippage, and all the complexities around having to source liquidity in order to make the UX not completely suck. The other option is that projects have endorsed just one version, just one third party bridge makes things a little easier, but you introduce catastrophic risk. So those are the two main options that have been out there, and projects haven't really had a better alternative until now. Like historically, token bridging has been kind of dicey and the incentives built on these systems are kind of skewed, right? Like bridge providers right now are incentivized to capture as much market share as they possibly can by funneling liquidity into inefficient places, or forcing projects to lock into their proprietary standards, which makes the project have to shoulder all of that risk burden. And we just think that these two options are not great, especially when we're looking forward to 1000 roll up future and considering bridging as like a basic primitive in this space that needs to exist. So with that context set, I can finally talk about ERC 7281. This is colloquially known as X ERC 20 because it's a very, very simple extension on top of the existing ERC 20.
00:11:53.488 - 00:12:44.688, Speaker A: And you'll see what I mean by that. But first, the design goals for this token standard, this open token standard, is to allow tokens received by users from bridges to always be the canonical version. So everyone is always receiving the useful version of the asset, and they don't have to think about what version is everyone else using. Why doesn't this DAP support like AUSDC or XUSDC or whatever? And these tokens should be bridge agnostic, meaning that any bridge that does mint and burn should be able to mint and burn these tokens. It makes it so that it's open in the sense that any bridge can actually adopt this standard. And furthermore, token issuers should be able to control the token. Like when you have a bridge minted token, the bridge deploys that token and they maintain ownership over it.
00:12:44.688 - 00:13:19.224, Speaker A: But the token issuers are the ones who actually should control that token. Bridges should not need liquidity, right? Like slippage and liquidity sourcing. All this is just additional headaches around making bridge Ux acceptable. And that's a huge problem that we think that should just not exist. Cross chain token interactions should be slippage free. That's self explanatory. And then lastly, token issuers should be able to apply their own risk models to each bridge on a per bridge per chain basis and basically set rate limits.
00:13:19.224 - 00:13:59.850, Speaker A: So that way you don't have these unbounded flows. And you always know at a cap, like in the worst case scenario, this is how much you can lose because you've set those rate limits and you've done your dd to decide how much you want to allow bridget submit and burn. That is quite a few design goals. And you might think that it actually would require some complex additions to make like an ERC compatible with all these design goals. But actually it's just like two things. You just add mint and burn, which already exists in a bunch of extensions, and you add the ability for owner to set rate limits. That's it.
00:13:59.850 - 00:14:49.764, Speaker A: This is the entire additional interface that XCRC 20 introduces to ERC 20. Most of these are just getter functions, and there are a couple of important ones, like mint burn set rate limits. If you're a new token, all you have to do is deploy this standard. Like this standard of an ERC 20 with these interfaces, and you basically get all the benefits of those design goals that we had earlier. If you have an existing token, the standard introduces this concept of a lockbox contract, which is essentially just like the wrapped ETH contract. You deposit an existing token, it wraps it, and it gives you a different version of it. So you remember how I said different bridges, they lock the liquidity on the original token into their own bridge contracts.
00:14:49.764 - 00:15:25.140, Speaker A: We really don't want that. We want there to be a shared resource for all bridges to be able to pull from if they need to unlock funds. So that way you don't run into those bottleneck issues and you don't have the custody of your actual tokens living on the bridges themselves. So this lockbox contract is a shared resource across all XCRC 20 bridges that bridge this specific token. And what happens is you basically wrap your existing token through the lockbox. It gives you a XCRC 20 compatible version of the token instead. And that's the version that bridges actually mint and burn.
00:15:25.140 - 00:16:31.540, Speaker A: Part of this includes like a migration path for existing tokens, right? This is how existing tokens are compatible with the standard. So over time, through project endorsement or other social consensus, you can push for people to start using the XRC 20 version, and eventually liquidity will consolidate into this lockbox. This is sort of the ideal end state where everyone starts using the XRC 20 version. It's completely fungible across all different bridges. And what this looks like to users is that they're just sending a cross chain enabled token that is slippage free, and that is the simple migration path for existing tokens. So what this standard enables is an actual pathway to 1000 roll up world with a million different assets, without having to go through liquidity hurdles or subjecting yourself to catastrophic risk vectors of locking yourself into single bridge providers. It is actually compatible with canonical bridge maximalism.
00:16:31.540 - 00:17:38.290, Speaker A: Like you can have canonical bridges mint these tokens, all you have to do is set rate limits for them, just like you would for any other bridge. And in most cases, people will probably set higher rate limits for the canonical bridges because they're safer. And that is totally fine to do that because of the slippage free aspect, enables real chain extraction use cases, and allows for intent systems to give you optimal pricing without having to consider slippage. That is it. If you are a token project and you want to migrate, or you want to adopt this standard, which I highly recommend, there are a bunch of resources on XCRC 20. Com, there's a link to the official ERC that's going through the EIP process. There's a link to a reference implementation of the token built by the DFI Wonderland team, and there's also a link to a telegram group where a bunch of XCRC 20 builders have congregated to discuss the standard, improve on its implementations, and is generally a useful place for Q A.
00:17:38.290 - 00:17:48.910, Speaker A: So shout out to the people in that group right now who are really helping us build toward this better cross chain future. And for the rest of you who are listening, I will see you there.
