00:01:18.600 - 00:02:18.852, Speaker A: Hey everyone, my name is Bo. I'm a co founder at Polymer Labs and I'm here today to talk about ZK Mint, the first ZK friendly tenermint consensus engine. Who here in the audience has heard about IBC? Nice. Who here in the audience has heard about zkps? And who here in the audience has heard about tendermint consensus? Awesome. Also, a special thanks to Raj from our team who couldn't be here today. He had some visa issues and he's the original author of the paper that we'll be releasing soon on the subject. So a little bit about polymer Labs we're building the IBC transport hub to connect all chains via IBC, starting with Ethereum and its ecosystem of roll ups.
00:02:18.852 - 00:03:19.230, Speaker A: We're also core contributors to the open source IBC protocol and are working on making IBC the standard transport layer across all chains. I know some of the previous speakers had mentioned that perhaps bringing IBC to Ethereum was impractical. We're currently working on that, and Polymer hub does just that. We're able to both bring the state layer of IBC and also the transport layer of IBC, including the application layer semantics on top, to Ethereum and its ecosystem. So here are some goals of the talk today. We're going to cover some background context before talking about some of the issues that we encountered in our journey to efficient verification of tendermint consensus in the EVM. We'll also go over some of the intuition behind the security proofs in our soon to be released paper, and also some of the performance measurements associated with our solution.
00:03:19.230 - 00:04:19.810, Speaker A: So what is IBC? IBC is an interoperability protocol. It's currently the most decentralized, permissionless and secure open source interoperability protocol on the market. An interoperability protocol consists of three core functional layers, as depicted in the diagram here. We can see that there is an application layer which is analogous to HTTP and GRPC in the OSI model. We can see that there is a transport layer which is analogous to TCP and UDP in the OSI model, and we can see that there is a state layer which is analogous to the physical network links that connect computers. We're building the IBC transport hub to bring transport layer to all chains. In order to connect IBC to Ethereum, we first need to establish an IBC connection via lite clients as part of the state layer shown here.
00:04:19.810 - 00:05:19.860, Speaker A: This requires on chain verification of tendermint consensus, which is problematic. So does anyone think there are any issues with verifying tendermint consensus in the EVM. Well, the problem is the gas costs for verifying tenermint consensus are just too damn high. In the next slide, we're going to go over some of the main cost drivers for verification. So starting off, the default signature scheme utilized in Tenderman consensus is ED 25519. Unfortunately, there are no verification precompiles for this signature type in the EVM. Additionally, in default tenement consensus, the validator set is supplied as a Merkel route, which means that we end up with a number of Merkle proof operations in order to check for validator inclusion and also validator set hash equivalents.
00:05:19.860 - 00:06:18.510, Speaker A: A non EVM friendly hash function further impacts the performance of these signature checks. Of these Merkle ops, tenement headers are also proto encoded before signing, so this means that we also need to do proto serialization and deserialization to perform signature checks. In summary, with all these challenges, EVM verification of tendermint consensus was previously not feasible. Well, let's embark on a journey together towards efficient verification of tenermint consensus in the EVM. So the first thing we looked at was optimizing the naive tendermint verification algorithm. In the EVM, we changed the signature scheme and hash function. This resulted in the performance gain, but it was ultimately insufficient for practical use.
00:06:18.510 - 00:07:24.390, Speaker A: Threshold signatures are a subset of MPC or multiparty computation that allow for the sharding of a single private key into multiple secret shares to allow for efficient signing via a single signature. When we evaluated this, unfortunately, the p to p communication overhead impacted the key generation and also signing algorithm. Also, there was some implementation complexity due to this approach with key regeneration due to valset changes. Signature aggregation is an approach of combining multiple signatures into one. We looked at BLS m of n signature aggregation for our use case. Unfortunately, there were no BLS m of n verification precompile in the EVM, as well as some implementation complexity requiring equal voting power between signers caused us to drop this approach as well. Ultimately, we ended up arriving on a Zk approach, which appeared to be a cost efficient method of verifying headers and also a viable path forward.
00:07:24.390 - 00:08:33.080, Speaker A: So proving a circuit for tendermint BFT consensus is slow. Some of the reasons for this is that you have a large circuit size due to snark unfriendly hash functions, Merkel proof operations for validator set inclusion and validator set hash equivalents, non native field arithmetic, and also complicated serialization format. So proving a circuit for tenderman BFT consensus is too slow. We need a version of consensus that is efficient to prove in a snark circuit. And although tendermint offers multiple levers to configure the consensus algorithm, we also need this consensus engine to be backwards compatible with existing tendermint lite clients deployed in the wild. So what is the solution here? Well, we need to improvise, adapt, and optimize our headers for each execution target, and by doing so we get zk mint. Zk mint is a multi signature tendermint BFT consensus protocol.
00:08:33.080 - 00:09:20.260, Speaker A: This means that we can be backwards compatible with existing lite clients deployed in the wild, as well as generating new headers specialized for various execution targets such as snarks and EVM. This adaptability makes it the ideal consensus engine for an IBC transport hub like polymer. However, multi signature consensus introduces novel attack vectors. So how can we prove that the new protocol is secure? So there's not enough time to go over all the security proofs in our paper. So we'll try to motivate an intuitive understanding using this diagram here. Tenement consensus is a two step process. We begin with a lock and then a commit on a particular header.
00:09:20.260 - 00:10:47.500, Speaker A: Once a header is locked by two thirds of the honest validator set, then the chain can only ever proceed to this locked header or halt. This means that we're trying to guarantee that a step forward attack will not cause light clients to fork away from the main chain. A step forward attack is defined as an attack where validator set signs a subset of the headers required for the chain to progress, thereby tricking the light clients to advance first without advancing the chain itself? Because, as we can see in the diagram above, once we've locked on the header in the middle, we can no longer proceed to the header above or the header below. Now that we've gone over some of the high level intuition behind the security of the protocol, what were the actual header optimizations that we made in order to make it more efficient to prove and verify in a snark circuit? So we started off by picking a snark and EVM friendly signature scheme. We ended up changing the underlying elliptic curve for EdDSA from curve 25519 to bn one two eight. There are alt bn one two eight pre compiles in the EVM for scalar multiplication and addition. The native field and curve used in the snark construction matters, and the reason for this is because the snark verifier sits on chain and needs to be EVM friendly for optimal gas costs.
00:10:47.500 - 00:11:56.680, Speaker A: For elliptic curve pairing based snarks, the verifier needs to perform a few pairing checks in order to verify a proof. We also selected a snark friendly hash function in MIMC seven. We also replaced a number of the Merkle proof inclusion checks by supplying the full validator set as a private input to the circuit itself. We also removed proto serialization and replaced it with a much simpler serialization scheme inspired by flat buffers. So after all these optimizations, what did the performance numbers look like? Well, with default tenement consensus and a naive approach, we get on chain verification costs of 26 million gas. With some optimizations in the signature scheme used, we can get slightly better numbers with 8 million gas. And ultimately with our snark construction and unoptimized circuit, we can get an onchain verification cost of 300k gas, prover times of around 3 seconds, and a circuit size of around roughly 500,000 gates.
00:11:56.680 - 00:12:42.770, Speaker A: This is a 98% reduction in the gas cost. From naive verification, this equates to roughly six to $10 at today's Ethereum price and network utilization. Obviously, these costs depend on Ethereum price and network congestion. With these perf improvements, it becomes practical to establish a state layer connection to Ethereum. So ZkMin is the first step towards bringing IBC to Ethereum by establishing state layer connectivity. However, state layer connectivity is just the first layer of a working interoperability protocol. What's most important is bringing the IBC transport layer to Ethereum.
00:12:42.770 - 00:13:43.578, Speaker A: So unfortunately, there are an ever growing number of interoperability protocols in the ethereum ecosystem, all of which are inventing new transport layers. The problem with competing transport layer implementations is that they make different interoperability protocols incompatible with one another. A unified transport layer under IBC will make interoperability protocols actually interoperable with one another. Supporting competing transport layers is promoting fragmentation, not interoperability. Promote interoperability instead by building with IBC. So it's easy to confuse interoperability protocols with one another, as many begin to adopt IBC application layer semantics and state layer semantics. Many of the interoperability protocols launching today are focused on application side and state layer side innovations, making them not interoperable with one another.
00:13:43.578 - 00:14:02.120, Speaker A: But you don't want to confuse the application layer of the interoperability stack with the transport layer of the interoperability stack. That would be confusing HTTP for TCP build with IBC instead. Thank you. I'll be available for questions off the stage. Thanks guys.
