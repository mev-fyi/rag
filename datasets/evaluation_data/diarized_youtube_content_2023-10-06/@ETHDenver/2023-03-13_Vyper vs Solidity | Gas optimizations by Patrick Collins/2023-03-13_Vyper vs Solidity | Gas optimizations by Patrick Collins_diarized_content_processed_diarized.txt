00:00:02.090 - 00:00:19.866, Speaker A: Hello. Hello. How are we doing, everybody? What's going on? So I have some QR codes here if anybody wants to follow along. We're going to be doing some pretty cool stuff here today. Before I get started here, who here is a solidity developer? Raise your hand if you're a solidity developer. Okay. A whole bunch of solidity developers.
00:00:19.866 - 00:00:31.030, Speaker A: Not as many as I would expect from a hackathon. What about Viper developers? Almost. No? Oh, okay. Almost one. All right, excellent. Perfect. This is exactly what I wanted.
00:00:31.030 - 00:00:59.834, Speaker A: Okay, cool. So today we're going to be talking about Viper versus solidity in terms of gas optimizations. We're going to learn a lot, and I have 19 minutes to do this talk, and I'm normally used to having 16 hours or more. So for those who do not know, my name is Patrick Collins. I am a smart contract engineer, auditor educator, some of my QR codes up there. I absolutely love web3. I live, breathe, sleep, eat smart contracts.
00:00:59.834 - 00:01:51.502, Speaker A: I have done a video on this before, so if you want to grab that QR code as well, watch the video on this. You can head over there to there, too. But today for this presentation, we're going to just focus on a single subset. Why is Viper oftentimes more gas efficient than solidity? And I know, crazy, right? How could that be possible? Patrick, you've done so many videos teaching solidity. Why are you now telling me that sometimes Viper is better, but I'm giving the disclaimer that I still like both Viper and solidity. I think they're both great languages. However, as developers, we should constantly be asking, is this the best tool for what I'm doing? That's what we need to be asking all the time, is this the best tool? How many people here ask themselves that when they're writing their code? Is this the best tool? I see four liars here.
00:01:51.502 - 00:02:13.240, Speaker A: Excellent. Excellent. All right, cool. So I'm considering myself more of a referee. I'm playing. I'm sure you do. I'm considering myself more of a referee here, but we're going to explore why this is the case and the architectural trade offs that go into this and get you thinking, is this the best tool? Can I make this better? Right, because as web3, that's what we should be constantly thinking.
00:02:13.240 - 00:02:50.050, Speaker A: Here is our combatants. Here are our two contracts that will be doing gas battle against each other. They do essentially the same thing, because at the end of the day, that's what high level languages do. Both solidity and viper compile down to evm op codes. They just do it in their own unique ways. So what does this code actually do? What do these two contracts actually do? Very basically, they have a storage variable named store number. They have an external function that allows you to set store number and a view function to read store number.
00:02:50.050 - 00:03:06.818, Speaker A: I'm doing solidity first. However, the viper code is nearly exactly identical. The syntax looks very similar. Viper and solidity are not so different after all. Yay. It's a great world, but they're very different under the hood, and we're going to see that in a second. So, spoiler alert.
00:03:06.818 - 00:03:36.958, Speaker A: Here are the results of deploying this code. Oh, my goodness. Solidity is much more gas expensive than Viper when it comes to deploying these contracts. How could that be? All I do is solidity. Okay, well, cool. That's just deploying the contracts. Patrick, what about running the contracts? What about reading that storage variable? What about setting that storage variable? How's the gas look there? Well, I hate to break the news to you, Viper is more gas efficient there as well.
00:03:36.958 - 00:04:08.906, Speaker A: So for all of you who did not raise your hand and say, oh, is this the best tool? Did not ask the question, is this the best tool I should be working with? It's time to start asking. Right, but let's go deeper into this. Why is this the case? Why are we all using solidity if Viper is more gas effective here? What's going on? Let's go under the hood. And then, yes, I have some. When I first did this, I did some comparisons, some benchmarks to Huff Yule, solidity and Yule, and some other stuff as well. That's why you see other stuff. But we will not be talking about those today.
00:04:08.906 - 00:04:55.260, Speaker A: So let's explore this. Why does this bar graph exist? How is this possible? Let's talk about gas costs when it comes to contract creation. When we first deploy these two contracts, what is going on under the hood? To make it such that Viper is cheaper, to do so. And to do that, let's do a quick refresher on EVM opcodes and a little refresher on assembly. If you're in remix and you have your solidity code here, when you compile it, there's this little button called bytecode. If you click that, you get this disgusting output that you see on the screen here, which is a whole bunch of opcodes for the AVM, right? It's what makes all of our smart contract stuff work. All right, who is with me so far? Raise your hand, say I.
00:04:55.260 - 00:05:32.150, Speaker A: Who is not with me? Say what? Everybody's with me. All right, great. Excellent. All right, cool. And so these opcodes look something like this, right? There are just all these opcodes and most high level languages break down these opcodes into three different sections, and solidity actually does a great job of breaking them down with this invalid opcode. You can't really see it on the screen here, but they break up these three sections by having this invalid code be kind of this separator. So usually the first chunk of code in your compiled contract is your contract creation code.
00:05:32.150 - 00:05:53.502, Speaker A: It's the code that gets executed when you deploy your contract. And then in the middle there is what we have called the runtime code. This is actually the contract, right. This is all the code that you wrote for the contract. And then we have some metadata and some other stuff. We're going to be ignoring that for this talk here. We're just going to focus on those first top two.
00:05:53.502 - 00:06:59.182, Speaker A: So contract creation, that first lump of code, runtime code, that second lump of code, contract creation is what we're looking at right now. And if we look at these two pieces of code for contract creation across Viper and solidity for these smart contracts that we showed, we see they're very different. What's the first thing that you see here? What's the first difference? You see, like, right away, what do you see? Anybody? What size? Thank you. Excellent. We see solidity has got a bunch more stuff, right? And as gas optimizers, we go, okay, well, if there's a bunch more stuff, that probably means it's doing a bunch more stuff. And to gas optimize, we want it to do less stuff. So is that what's going on? Solidity is just doing more stuff? What is this more stuff that it's doing? And if we look at Viper here, this binary, this bytecode gets put out to these opcodes here, which is relatively simple when it comes to opcodes.
00:06:59.182 - 00:07:46.594, Speaker A: There's this really important opcode in there called code copy, which basically is just saying, hey, take all that runtime code that comes after this contract creation code and stick that on the blockchain for people to do stuff with. And that's all the viper contract creation code is doing. It's saying, take that runtime code, slap that on the blockchain, and then we're done. So what is solidity doing? A lot more stuff. There's a lot more opcodes there. What is solidity doing? Well, if we look at this bottom section, ignore the top section first, that looks really similar to the viper stuff, right? There's that important code copy opcode. There's a whole bunch of push dupe other stuff, but that bottom opcode stuff is basically doing the same thing.
00:07:46.594 - 00:08:25.054, Speaker A: Hey, take that runtime code, slap that onto the blockchain. But what about this top stuff, this lump of code right here? This is all the stuff at the top. What's it doing? Well, if we look at this bottom section, we're going to ignore that top section for now. That's called the free memory pointer. Don't worry, we'll get back to that. But if we look at this bottom section, there's a call value dupe is zero, jump if push dupe, revert. Basically what that is doing is it's saying grab any value, any ETH that is sent with this deployed contract and check if it's zero.
00:08:25.054 - 00:08:49.378, Speaker A: If it is not zero, revert. So when we're deploying our contracts, solidity is actually checking to make sure we didn't accidentally send a whole bunch of ETH with this contract that'll be unrecoverable. Wow, thanks. Solidity compiler looking out for us. Ten year old meme hype. Let's go. So then you might ask, whoa whoa whoa.
00:08:49.378 - 00:09:45.234, Speaker A: I thought we were comparing the same contracts here. Viper, what the heck? Solidity is looking out for us. You're not, you're not doing the work to make sure I'm safe. To which solidity would respond. Well, if you specified a constructor and that at external def init thing, that's a constructor in Viper, if you did that, then we would add that checker for you. Right? So there is a big, big difference in the checker based off of whether or not you have a constructor or not in Viper. So we'll say, okay, fine, viper, you get off on the technicality here, but this is one of the main things, one of the main differences between a lot of the languages in the EVM world, and they all do some type of check to make sure we don't shoot ourselves in the foot, to make sure we don't send a ton of Ethereum when we deploy our smart contract.
00:09:45.234 - 00:10:12.480, Speaker A: Right. We also will do checks on data links, we'll do checks on function selectors. Most of these high level languages will do checks to make sure us developers don't do dumb things, because we often do. Okay, cool. So solidity doing some extra checks. It looks like Viper has those checks as well. It wasn't in that comparison, so great, let's keep going.
00:10:12.480 - 00:10:48.140, Speaker A: Let's talk about the runtime code now, because we saw where a bunch of those opcode differences has come from. It's come from those checks. We still haven't talked about that weird free memory pointer thing that I told you to ignore that we will definitely be coming back to. And we're not going to go too deep into the runtime code here because there's a lot to talk about. So this is the viper runtime code. This is the solidity runtime code. It's even more, but we are going to focus on that free memory pointer because if you download the presentation, you can see these on the different opcodes here.
00:10:48.140 - 00:11:10.722, Speaker A: The solidity runtime code also has this free memory pointer stuff going on. The viper runtime code does not. Free memory pointer stuff. No free memory pointer stuff. Solidity has it both in contract creation and in runtime. Viper doesn't have it anywhere. So what's going on? We found another bunch of opcodes that solidity is using.
00:11:10.722 - 00:11:27.158, Speaker A: That viper is not. And obviously if solidity is doing them, it's spending gas. Who's with me so far? Say I. Who is totally lost? Say I'm totally lost. Okay, I heard a couple of mumbles. They're a little shy about being totally lost. That's okay, you can come back to this video later.
00:11:27.158 - 00:12:10.684, Speaker A: I have more links to the actual code. Feel free to ask questions there. And if I do the rest of this presentation really quick, we'll have time for questions, but glad most of you with me. Okay, great. What is this thing? And actually most solidity contracts will start with exactly this. Push ox 80 Push ox 40 m store what does this do? Why do we have this? To understand this, we need to learn about memory and the stack to learn what this free memory pointer is, what these opcodes are doing here. So a quick refresher, in the eVM, we have memory and we have stack, right? These two wonderful things.
00:12:10.684 - 00:12:53.144, Speaker A: And when we push stuff, we push it onto this stack and it's literally like a stack of pancakes. We push values up, you keep going higher and higher, you push stuff on until you do some type of opcode that pulls them off. So mstore is an opcode that will pull things off the stack and we'll stick it into memory. And in this example, the mstore command says, okay, grab the thing that's at the top of the stack and that's going to be the location of memory. We're going to stick stuff and then what's underneath that? We're going to stick that into that location of memory. So we took OX 80, stuck that in OX 40 because Mstore says, hey, top of the stack location, bottom of the stack data. Great.
00:12:53.144 - 00:13:18.640, Speaker A: And we need both a stack and a memory in the evm, right. Stack is restricted in size. Memory is much bigger. There's a lot more memory we don't have. Unlimited stack memory can sometimes be easier to deal with. And variables, and this is really important, variables are returned in memory, not from the stack. So anytime you return any variable in solidity or viper, you need to return it in memory.
00:13:18.640 - 00:14:03.168, Speaker A: But how do we know where we can put this new stuff in memory in this array? Right? Let's say we have memory with a bunch of stuff in it already. If I put more stuff in memory, am I going to override what's already in there? How do we know? Well, let's see how they approach it, because this is where the gas optimization stuff comes from. Let's see how solidity does it first. So, solidity looks like this, right? So this is memory. You can imagine this is kind of solidity's memory here. The zero X zero and zero X 20, those slots of memory are usually reserved for, like, hashing stuff, but the rest of it is basically free for us to use. And when we do this push, push, and store, we're sticking this ox 80 in there.
00:14:03.168 - 00:14:42.572, Speaker A: And what this is doing is, it's telling solidity. Hey, there is free memory at the OX 80 spot. So this positioned in memory, OX 40, or fake index two, is telling us where the next lump of free memory is, right. This ox 40 is a special spot in memory, in solidity. And if you change where that spot's pointing to, you're changing where solidity is telling you that there's free memory. Right? And we could look at an example like this. So if you see UN 256, two equals two.
00:14:42.572 - 00:15:22.136, Speaker A: Sorry, I know, terrible naming there. We need to create this two variable in memory somewhere, and those are the opcodes associated with doing that. We do a push, push m load M store. We load where the free memory pointer says there's free memory, and then we store our UN 256 two data where the free memory pointer says there's stuff to do. Right? So if this is memory, those opcodes get run, the data gets stuck in there, because that's where the free memory pointer says there's free memory. And then we update the free memory pointer to say, hey, now, free memory is one block down, right? Makes sense. Say I if it makes sense.
00:15:22.136 - 00:15:40.060, Speaker A: Excellent. Okay, cool. But that's a lot of work. Every time I do anything with memory. Well, first off, I got to create a free memory pointer. Then every write to memory I got to read where free memory is first. And then every time I write to memory, I got to update that free memory pointer.
00:15:40.060 - 00:16:15.716, Speaker A: And that's a lot of work. So let's talk about how Viper approaches this. Viper sees all this, and my emoji got messed up there, but Viper sees this and says, that's a lot of work. So Viper says, let's take a different approach, same thing. This is Viper's memory. First, zero x zero and zero X 20 are usually reserved for, like, hashing stuff, but this is that exact same function that we saw in solidity. But in Viper, it has the same un 256 two variable that it needs to store somewhere in memory.
00:16:15.716 - 00:16:47.652, Speaker A: And Viper approaches this a little bit differently. Viper says, wait a minute, I have exactly two variables that I'm going to need to store in memory. I need to store that Un 256 two variable, and then I'm going to need to store my return value in memory as well. So I have two things that I need to store in memory. Both of those are size 32 bytes. Two times 32 is 64. All I need to do is just have 64 bytes of memory and I'm good to go.
00:16:47.652 - 00:17:28.624, Speaker A: I'll just have the first thing go in the zero to 32 and the second thing go into 32 to 64. And I don't need a free memory pointer. And that's exactly what Viper does. Viper says, I'm just going to statically allocate this memory instead. So whenever Viper sees this Un 256 two variable, it's just going to stick it in that ox 40 every single time. It knows that a UN 256 is 32 bytes that fits exactly in our oX 40 slot, and it knows that our return value is also going to be of type Un 256. So we'll stick that in the oX 60, and every single time this function runs, that's exactly where I'm going to put them.
00:17:28.624 - 00:18:15.216, Speaker A: I don't need a free memory pointer because I'm just going to say first variable ox 42nd variable ox 60. That's it. And this is where the main gas optimization differences come from, is the way that they're doing this memory allocation, this memory management. Viper is doing memory allocation statically, whereas solidity is doing it dynamically. Solidity has this free memory pointer that says, okay, I'm always going to keep track of where the next lump of free stuff is. And Viper says, I'm not going to do that. I know that I'm always going to have four variables that I need to stick in memory and I'm just going to stick them in the exact same four slots every single time.
00:18:15.216 - 00:18:46.324, Speaker A: That way, I don't ever have to worry about overriding. So you might be thinking, Huzzah, Viper's better. I'm just going to use Viper. Patrick, you've convinced me. Congratulations. But remember what I said at the beginning of the presentation. Is this tool the best for the job? Constantly be asking this, and when you ask that, you should be thinking, what are the downsides of doing this? Why does solidity not do this? What's the issue here? So let's talk about some downsides.
00:18:46.324 - 00:19:31.508, Speaker A: Viper needs to know how big everything is to put it in memory, right? If it doesn't know how big it is, it can't say, okay, UN 256 goes in spot zero. If the UN 256 could be a UN 2 million, because it would override, right. It needs to know exactly how big each one of these lumps of data is. So what it can't do is actually stick dynamically sized objects in memory. So, for example, in solidity, I can have a function like this function, getarray public returns a UN 256 memory array, return my array, and that's a dynamic array that my array that it's returning could be any size. Solidity can do that. Viper cannot do that.
00:19:31.508 - 00:20:13.584, Speaker A: Viper has what's called bounded dynamic arrays. It can't have these true kind of uncapped size of dynamic arrays. Now, the caveat to this is, in practice, this doesn't really bar Viper from being able to do anything solidity can do. So I put it to you all to see what you like best to encourage you to get out of your comfort zone a little bit, try to see what you like better. And keep this in mind when you're writing solidity code or you're writing your next lump of viper code. And again, the code that I did to test all these, this presentation QR code and then IPFs to this presentation as well. Hopefully you all enjoyed.
00:20:13.584 - 00:20:28.830, Speaker A: I am 17 seconds over now. Thank you so much for listening to my talk. Hopefully you learned something. And best of luck at East Denver. Thank you. Any questions or. No, it, oh, I can't take questions.
00:20:28.830 - 00:20:30.730, Speaker A: Okay.
