00:00:00.170 - 00:00:34.194, Speaker A: There's a lot of shared knowledge we can. So, first of all, who am I? I've been working on Cosmos since 2017. I worked on IBC, which is inner blockchain communication. I wrote the white paper and I invented Cosm WaSM, which is another smart contracting platform, built in WaSM, obviously, and targeting the cosmos. So if you haven't heard of Cosmo, those, it's one of the early projects. It was white paper back in 2016 alongside Polka Dot, the thesis. There was app chain.
00:00:34.194 - 00:01:08.510, Speaker A: A few thesis here which haven't proven. The first is proof of stake. It was one of the first proof of stake, byzantine fault tolerant networks, I think definitely the first one to write it down and maybe the first one to launch it. It's now proven the app chain thesis that we don't have one chain to rule them all and we're competing to be the one major chain. They have many chains that specialize and that connect to each other to launch progress. And that seems in the last few years, people have accepted that thesis as well. And the other one is that interchange communication, inter blockchain communication is key to build that future where there are many app chains.
00:01:08.510 - 00:01:40.934, Speaker A: So we need fast finality with byzantine fault tolerant proof of stake using inter blockchain communication to really have this app chain thesis. And that's Cosmos. IBC is the communication. It's a layer, way beyond bridges. Uses full light client proofs, no multi sigs anywhere. Full light client proofs. Bi directionally, it's very extensible, has a very high level semantics like TCP and HTP, allowing all the plumbing, all the packet networking, very composable.
00:01:40.934 - 00:02:06.382, Speaker A: And on top of it, you can build arbitrary app logic. So you can, on top of that, build a token bridge. You can build cross contract calls, atomic swaps across chains, many, many things, inheriting the security, composability of the base layer. Definitely check it out if you're interested in bridges, anything. Cross chain check IBC. I was at the Interop summit early this week and it seemed like it was the end goal. A lot of bridges are out there looking at IBC as the end goal, where they want to be eventually.
00:02:06.382 - 00:02:37.178, Speaker A: It currently only works on Cosmos soon between Polkadot and Cosmos. And I think they're looking at a few other ecosystems as well. Maybe one day to Ethereum, hopefully. And Cosm. Wasm is a wasm based virtual machine. Started working on 2019 2020, and now it's on over 25 blockchains in the Cosmos and one on polka dot, one parachain. And it's probably the most widespread VM outside of the EVM.
00:02:37.178 - 00:03:01.970, Speaker A: So EVM is everywhere. EVM is king, that's clear. But every other VM, Solana works on Solana, right? EOs has their, for EOs, everyone has their ones. This is probably the only other really multi chain VM outside of the EVM. And we worked hard from day one to make it multi chain and to make it portable so it can plug into other ecosystems. And there's work on bringing to avalanche now as well as composable. And it's really tied around IBC.
00:03:01.970 - 00:03:32.318, Speaker A: So there's ideas in there. So when doing all this, from early days in Cosmos, throughout building cosmosm, there's a lot we learned from Ethereum. I mean, Ethereum is king. Ethereum started the whole project. Smart contracts, they invented that, right? So the developer community, I think, is a key to Ethereum. Why Ethereum was here and every Ethereum killer has failed. Since 2007, there have been like 20 projects that claim to be Ethereum killers, and they never succeed because the developers are key.
00:03:32.318 - 00:03:47.842, Speaker A: The community around Ethereum is amazing. The network, the tooling, the whole environment is amazing. And no one can kill that. Don't care what your tech is, how fast you go, you can't kill it. I think it's a really, really important thing that people should learn from Ethereum. It doesn't matter what you're doing tech wise, you have the community here. And Ethereum is amazing in that way.
00:03:47.842 - 00:04:28.130, Speaker A: I think we have to learn more of that. We're working on it, but we need to learn more. I think also composability, Ethereum allowed this really, really rich composability between contracts, right? Not like this Utxo model, but this really powerful composability between contracts and demonstrated while using these contracts and these complex patterns, the real world usage patterns, what people do with it. What do you do? You make fungible tokens? Do you make dows? How DFI composed. No one knew that in 20, 16, 17. No one knew what would happen, right? Make a token. What else do we do? So these patterns of what people use, how to upgrade contracts that came out of Ethereum, just the experience from Ethereum and classes of attacks as well.
00:04:28.130 - 00:04:55.850, Speaker A: How hackers break contracts, right? No one knew that when they're writing it. So we've learned that in retrospect, from know the good and bad things about what will happen in the real world. So when we were designing, Cosm was, we took a big look at Ethereum. We wanted to build a WASM engine because we thought it was fun, and WaSm was the next VM. And so we targeted rust. That was like our choice. After that, we looked at Ethereum and figured composability is important, but more important than composability is safety.
00:04:55.850 - 00:05:23.214, Speaker A: There's a lot of features in Ethereum that are very powerful but very dangerous. Reentrancy attacks are everywhere. There's overflow errors, there's many different types of errors. It's hard to test it. I mean, I came into solidity in 2017, and you couldn't really test it except by writing the point on a chain and run JavaScript tests. There's no way of really doing clear testing, powerful testing, detailed testing on lots of business cases. I came from backend development.
00:05:23.214 - 00:05:59.118, Speaker A: I understand if you're launching something secure, you need lots of test coverage, analysis on it. And it just seemed like hard to do something as complex as DeFi without having those tools. So when he did this, we thought about this heavily and we tried to make it as easy as possible, right, secure applications. We found all these errors people do because they oversaw one little line and their contract got hacked and tried to make that impossible, or as hard as possible. And the other design we lost was interchange. First, you can't add interchange later. It's really hard to add interchange, an afterthought, because the whole design does not accept it.
00:05:59.118 - 00:06:23.654, Speaker A: Everyone's thinking of synchronicity. So I'm going to just step back a bit and say what we've already gone. So Ethereum has looked at that. Vitalik actually does admire Cosmos on the tech wise, and I think it brought a lot of ideas into Ethereum. I was at Devcon in 2017, they talked about proof of stake Casper. I mean, they were going to launch. It took a few years to launch it, but they did.
00:06:23.654 - 00:06:56.986, Speaker A: And tendermint and Cosmos really pioneered this, right? They pioneered, they brought domainet, they were doing the research for years before that. And this is something that really eventually got into theorem. They realized, hey, proof of work is great, we have it, it works. Now let's launch with very, very practical, but we need to make something better. So they took this idea already, multi chain idea. So there's not one Ethereum chain now we know binance chain, we have arbitrum, we have polygon. Not just the roll ups, but all the other chains that were EVM compatible, that launched Nier, they have EVM compatible chain.
00:06:56.986 - 00:07:32.758, Speaker A: All of these ideas were kind of, we only need one Ethereum. And this over the last few years has really come up that, no, we have a multi chain world. And once we have this multi chain world recently, Ethereum's realizing cross chain is key. Once you have multiple chains, we can't just ignore them and fight. We have to connect them. They're bridges over here, they're roll ups, allowing much stronger proof guarantees, but also bridges between unrelated chains. And this is actually key, right? This is like Ethereum is moving into this now and realizes this is key for the future, that all these different ecosystems interoperate and we can build collaborate over these chains.
00:07:32.758 - 00:07:55.114, Speaker A: However, there's a lot to learn on that. I think we can teach them. Cosmos have worked on that for a long, long time. I like to share a little insights here. The first one is complexity is hard. Like once you have writing four contracts to call each other or call arbitrary ERC 20 tokens is a bit tricky. And handling all the cases, especially when you call into arbitrary external logic.
00:07:55.114 - 00:08:34.350, Speaker A: But when you start doing it over multiple chains with possible timeouts, relayers, synchronicity errors, if you query something, it's not the same as when you execute on it. All kinds of error cases, error handlings. That gets very tricky, especially composing over multiple chains. So already the tools for composability are as difficult to write many contracts together. It's really easy to write a few contracts in solidity. When you try to get these large, large composition of contracts, it's harder and harder with complexity. And then we've interchange contracts that gets even trickier to reason about all the possible states that can happen over multiple blockchains.
00:08:34.350 - 00:09:15.402, Speaker A: So I think we realize that we need to make sure applications can scale in complexity, right? This is like a higher level of complexity. And how do we tame complexity? How do you make it easier? So these are some of the things we've been doing on cosmos, particularly cosmosm, to make it easier to build these large applications, this large composition at this scale. The first one is looking at the needs of complex production apps. You don't start with like, let's make pet shop and crypto zombies really easy. Let's look at what people need to build aave. Right? Like that's our target audience, people building something like that right before they go and cross chain. And the second thing is making standard patterns bulletproof.
00:09:15.402 - 00:09:59.814, Speaker A: I'm kind of surprised, like these proxy libraries, many attacks for many things, like upgradability of contracts is essential, but these kind of like delegate call attacks, it's tricky. There's a lot of trickiness there. So it's almost like we need to standardize and not just in libraries and solidity libraries, but actually in infrastructure you could have GE, have pre compiles, have support for these common patterns the same way we do for IBC. We build them into the blockchain so we don't have to write them in contracts. They're actually built into the standard blockchain as functionality. So I think if you look in the future of Ethereum, maybe they consider these patterns actually as pre compiles or as native functionality in the actually native go or rust code. Finally, I think that testing is essential.
00:09:59.814 - 00:10:40.098, Speaker A: So you have to make sure you can test every level. You can test your business logic, you test your math inside of it, you test the contract itself, you test the contract calling other contracts, then you test the contract calling other contracts on other chains. Right? These are all levels of testing, and they should be easy as possible so people can cover the most use cases possible and run them quickly. And I think that we must have the framework and dependent tooling to make this happen. So the tooling has gotten much, much better the last five, six years on solidity and running testing environments. I think there's a lot more to do, and a lot of it is actually, I think due to the fact that you can't really test it natively, it's its own language, it doesn't come with tooling. There's no solidity outside of Ethereum.
00:10:40.098 - 00:11:25.570, Speaker A: Whereas if you pull another language like rust in there or JavaScript, they have a whole bunch of tooling, whole testing libraries, a whole set of mocks, all this information you can bring. So I'll go look quickly here, I mean, here, center attack vectors, Ethereum, you probably all know these ones. If you're actually developers, you probably had to make sure your contracts do not have issues here. So yeah, reentrancy, the proxy library, call fallback functions, default visibilities, these are all things I pulled them off of. I think open Zeppelin or consensus had a list of the top vulnerabilities to avoid, and these are basically standard ones. So in cosmos, when we designed it, we designed security first. We try to make all of those impossible to happen, right? Like if you execute a message, another contract, it will automatically abort your contract.
00:11:25.570 - 00:11:58.866, Speaker A: There's no way of not catching it unless you explicitly handle the error, and then handle it some other way. Unless you explicitly catch the error, it will just abort your contract. No, reentrancy is possible. We must explicitly list the public messages, not have it private, it's not public as default. It's private by default, unless you make it explicitly public. So it's a little harder for some devs, but it avoids a lot of these errors you can get. And we have removed things like there's no fallback function, you can't do certain things you can do in solidity, but things are often used in attack vectors, we just remove them.
00:11:58.866 - 00:12:46.334, Speaker A: So sometimes it makes it a little harder to build. We said, hey, it makes it easier to build your project in an unsecure way, let's remove it. So you have to spend a little more time building it, but be secure at the end. So there's a lot of design work done in here, and I think as you're looking at new frameworks, new languages to replace solidity, like Viper and other languages, I think this is one important key to try to make it secure by default and testability. So we have lots of testability, as I covered earlier. And finally, as we're going this new world interchange, first I want to say like this, another concept, I see bridges coming out. I was at the summit, the idea of bridges saying tokens make sense, but you're calling another function, I call a contract over here, actually, you make an error back, a lot of these bridges don't even pass it out.
00:12:46.334 - 00:13:51.014, Speaker A: There's like these new axelars doing some calls, but they don't return the error or success. There's no return value of the messages and there's no return value in other block. It might happen ten minutes later, you get the result of what happened here, and maybe you have to roll back the original transaction locally. If it failed over there, how do you handle that? Right? How do you manage to even model that mentally before you write in your contract? So these concepts of the state modeling, when you actually have interchange composition, and you say, okay, I'm not just going to send a token that bounces back, I'm going to go over here and I'm going to trade tokens, then deposit an LP here, and then use LP over here as collateral, right? I'm going to pause an LP and then move them as collateral, right? That's a complex thing. If it fails in the middle, how do you avert it? Where do you stop? How do you restart it? How do you expose it to users? Do you even have the tools to represent what's happening? Do you even have the workflow to represent it, to test it, but to understand it yourself? So I think these are concepts that need to be built into frameworks. It's hard to understand it already. And if your frameworks don't give you the language to express it.
00:13:51.014 - 00:14:21.310, Speaker A: It's very, very hard. So I think as we're moving this new world, especially as Ethereum breaks interchange, I really want it to be done well. I don't want any more bridge hacks. I was just watching those in 2022 and. Sad. So I think learning from these ideas and really learning how to build interchange first, I think you don't have to use Cosmos, keep using Ethereum. But I think learning from how Cosmos is working on these attempts and solving it, I think is great and can bring lots of knowledge back into Ethereum, into roll ups, and into bridges between different Ethereum chains, EVM chains.
00:14:21.310 - 00:14:39.078, Speaker A: So, yeah, that's basically my talk. I want to explain some ideas here and how I see we in the future. I'd like to see this collaboration. I'd like to see more collaboration between Cosmos and Ethereum. That's really, really a key point. I think they've been known little world. I think Cosmos isolated itself a lot too, in its own little tech world.
00:14:39.078 - 00:15:27.566, Speaker A: But with interchange coming out there, I really think these bridges need to be more thought out, and especially the research aspect of it shared between blockchains. And as people work in ewasm and these other engines, like bringing new languages, the security first mentality, like, oh, look, we're actually really targeting extremely complex applications. We're not 2017 anymore. We have really, really complex multichain applications going on here. Really complex composition on single chains, how to make this secure, how to build into a framework that, and talking about building in bridges frameworks, I'd love to see something like IBC built into GE as a primitive. You don't have to worry about it. You don't try to build bridges as contracts, but actually the native code say, hey, here's code to do proofs and send packets trustlessly with like, client proofs across chain is built into a blockchain.
00:15:27.566 - 00:15:46.358, Speaker A: Your contract can just use it now. You don't have to worry about anything else. You can just use it. This does exist on one chain called Ethermint, I think, Kantos. Also, there are Cosmos EVM compatible cosmos chains allow the contracts to actually connect over IBC to other Cosmos chains. It's a whole other fork. It's nothing like geeth.
00:15:46.358 - 00:16:23.430, Speaker A: But I think you can look at these examples of where they're exposing these high level primitives of inter blockchain communication to the EVM. So I think they're great things to look at. And hopefully these ideas get brought in to other EVM chains. And I'd love to see Cosmosm I don't even know it's possible. But as more and more rollups come out, I'd love to see it like an execution environment on some Ethereum roll up and see how we can do that and maybe bridge IBC over it. So if anyone's working in rollups and understands roll ups really well, I'd love to talk with you and see how we can kind of use roll ups and IBC and Cosmos may bridge some roll up to start bridging Ethereum to the cosmos and interchange. Okay.
00:16:23.430 - 00:16:35.334, Speaker A: And here's some websites if you want to check out Cosmosm, check our website out or chat. Cosmos.com is a discord. It's very dev focused. If you're a developer, if you want technical information, there's no when. Moon. We have no chain.
00:16:35.334 - 00:17:22.454, Speaker A: Cosmos is not a chain. We are library in 25 chains. We focus just on core tech here. So if you want to please check this out, check the discord out, and you can learn lots of stuff. You have a question back? There's, should I repeat, I got it. Okay. So what the question was, was, on EVM, you can go to block explorer and verify the contract code where other things like Solana or this, you cannot.
00:17:22.454 - 00:17:52.974, Speaker A: I think that is, that's my biggest obstacle as a developer and because composability is okay, but if I don't know what I'm composing to, that's where this stops. What can you do about. We can do it. So the problem is, we are one small company, very low funding, and we're not getting really much money from these large foundations or blockchains. So we can't do everything, really. Like if someone says, we want to do this, we started doing this ages ago. We have scripts to verify.
00:17:52.974 - 00:18:11.818, Speaker A: You can verify, in fact, etherscan, I love to have etherscan. I love to build ether scan for the cosmos. Etherscan does not automatically verify your code. What ether scan does is you have to upload the code. It verifies that Salana solidity source code is equal to this EVM bytecode. Right. We can do this right now with Cosmos, and we have terminal compilation since 2020.
00:18:11.818 - 00:18:43.626, Speaker A: For ages. We have scripts to do this that you can say, given this rust package, this version of code, this game of rust code, you compile it and it'll give you a hash if that matches the hash on chain. This was a source code, so it has to happen. There's a few different compiler versions in there, so you have to compile the same version of the compiler as you did it. It does work. The problem is that no one has set the tooling on it, the front end tooling where you can upload the code. It will do it for you and it'll stick like ether scan.
00:18:43.626 - 00:18:56.420, Speaker A: We have no UI for it. You can manually verify it. If I tell you in a contract, you can manually verify it. We have no quick verification, no UI for it, no explorers, and I'd love to build that thing, but yes, there's only some of my hands. I'm out of time, but we can talk later. Thank you very much, everyone.
