00:00:00.330 - 00:00:23.022, Speaker A: Okay, awesome. So, once again, thank you very much for the introduction. My name is Martin. I'm a senior research engineer at Quant, and this talk is based on a joint research with my two amazing colleagues, Martin, Ed, and Alex. And we will be talking about bridge hacks. So the very first slide doesn't require too much comments. Throughout 2021 and 2022, bridge hacks costed us $1.75
00:00:23.022 - 00:01:12.990, Speaker A: billion. So if you thought that the flash loan exploits of DeFi were bad, this is, I guess, the definition of pure evil. So let's take a look at what a bridge actually is when users are bridging assets from one chain onto another. It's sort of, kind of magical, right? I have some EtH, and I'm going to Ethereum Mainet, I'm going to somehow send it to the bridge, and suddenly eth shows up on another chain. But that's actually not true. There is no such thing as ETH magically showing up on another chain, because ETH is the main net asset, right? So it cannot just make it over. So what really happens is that when I am bridging assets, I am locking them on Ethereum Mainet, in a smart contract that is called the custodian, or I will be referring to as the custodian.
00:01:12.990 - 00:01:54.286, Speaker A: And then there is some off chain component. It's an active agent that is watching what ETH was locked in the custodian. And then it's talking to another smart contract on a different chain, the target chain, which I will be calling the debt issuer. And this debt issuer is going to issue to me some tokens that are representing the debt that the custodian has towards me. When I want to bridge my assets back, I go to the debt issuer, I burn the debt tokens. Again, the communicator component is watching it, and it will instruct the custodian to release my original assets back to me on the main net. So this is how bridges work.
00:01:54.286 - 00:02:31.450, Speaker A: If you think about the system in general. We are actually talking about two main components here, right? We have a pair of smart contracts. It's the asset custodian on one chain and the debt issuer on the other chain. And then the communicator is nothing else but actually an oracle, right? Because it's watching the state of the world somewhere, and that it's talking to some chain, telling it, hey, this person did something in the world. So this is how we will be thinking about it. All these components can be attacked, as I will show you. I'm going to give you an examples of bridge hacks that happened throughout 2021.
00:02:31.450 - 00:03:09.430, Speaker A: I will be giving you an example of an attack on the debt issuer, on the custodian, on the communicator. Then I will be talking a little bit about a different type of attack that also involves a bridge, but it will actually be an attack on the token interface. And then if I have time, I will play a profit and I will show you an attack that didn't happen yet. But in my opinion, it's just a matter of time before it does. So let's hop into it. First, we will talk about the debt issuer. So, the debt issuer is that smart contract that sits on that other chain, right? And it's issuing the debt tokens that I can later redeem for the original assets.
00:03:09.430 - 00:04:22.382, Speaker A: So if I am an attacker, my main goal would be to convince this debt issuer that it should issue to me debt tokens quite arbitrarily. And one possible route how I can do that would be to convince the debt issuer to bypass the signature verification from the communicator. Because when the communicator instructs the debt issuer that it should issue to me those debt tokens, that instruction is nothing else but a smart contract method call, right? And in this particular hack that I am referencing, this smart contract method call would be accepting some data that who locked their assets on the main chain and how much they locked in, which means how much they should be receiving on these other chain. And what was also present there in that particular hack that I'm referencing was a reference to another smart contract that this debt issuer could use to confirm the authenticity of this instruction. Meaning that this instruction was actually signed by the communicator. So somewhere there in the system, we had this component, this signature verification contract. The debt issuer would say, hey, I just received this message.
00:04:22.382 - 00:05:13.726, Speaker A: Is it really true? Like, was it issued by the valid communicator? And this smart contract would say, yes, it was correctly signed or not. So what the attacker did to exploit such a situation was that they first deployed a fake signature verification contract, which was very simple. It would just say, everything is valid, man, we are good. And then the attacker sent a transaction to the debt issuer, referencing this fake signature verification contract, and the data saying, hey, I should be issued so many and so many debt tokens. And the fake verification contract did exactly what it was made to do. It said, yes, this is valid. And therefore, the debt issuer was able and did issue the attacker a bunch of debt tokens that they would again bridge back to the main net and exit the whole system with lots of, lots of profit.
00:05:13.726 - 00:06:21.938, Speaker A: So this is how you can attack a debt issuer. Let's take a look at the custodian. So the custodian is that smart contract where I am locking the native eth, right? Or some native assets so when I want them to be released back to me, depending on how this whole complex system is developed, the custodian usually expects some kind of a proof that I burnt my debt tokens and will not use them again, right? So the attacker's vector here would be to craft proofs that would pass this verification process by custodian. And in fact, in the hack that I am referencing, there was a bug. There was a flaw in the proof verification process which enabled the attackers to do so. The proof verification process was simply ignoring certain parts of the proof, which allowed the attacker to modify certain bytes in that byte string and produce more and more and more proofs that were valid for releasing assets by the custodian. So if we take a look at the schematic, we have the attacker.
00:06:21.938 - 00:07:37.438, Speaker A: The attacker started by depositing assets into the custodian, which led to the attacker being issued some debt tokens on the alternate chain. Then they would take those debt tokens and they would burn them, which led to the debt issuer providing a valid proof that they burned some debt tokens, right? And so then the attacker took those proofs and submitted them to custodian. That was all honest. But then they took that one proof and started modifying those bytes that were being ignored during the verification process, producing different proofs that were still passing their verification, sending them to the custodian, and exiting with more and more money that actually didn't belong to them. So that's an attack on custodian. Now I want to talk about attacks on the communicator. So that's that like off chain component that has some privileges to instruct the debt issuer to issue debt tokens and to instruct the custodian to release assets back to users, right? So what we want to do in here is to fool the communicator to actually send messages and instructions to these two other elements based on some data that are not true.
00:07:37.438 - 00:08:36.766, Speaker A: So in fact, we are polluting the data source of the oracle, right? Because this is an oracle. And what happened in this very particular attack that I'm going to reference, I actually really like it because it's very clever. We had a communicator that was watching the custodian, right? And when the communicator is watching the custodian, it actually means that the communicator is parsing all the transactions that go to the custodian. And out of those transactions, it's cherry picking the deposit events that are being emitted during the deposit. So what the attacker did here was that they deployed a malicious contract, which made a deposit to the custodian. So that was the transaction that the communicator detected. But on top of just depositing into custodian, it also emitted whole bunch of events that had exactly the same format as the events that the custodian was emitting.
00:08:36.766 - 00:09:05.194, Speaker A: So, same name, same parameters. I deposited Eth without actually depositing it at all. So then the communicator detected this transaction. It parsed out all those deposit events from the transaction, but only one of them was honest. The rest were fake events, and it would just issue whole bunch of tokens based on those fake events. So this was our attack on the communicator. So all the attacks that I have just now referenced, they were just an example of a few.
00:09:05.194 - 00:10:20.338, Speaker A: Throughout the course of the past year, we had many, many more. The one thing that they had in common was that the damaged party there was the bridge, right? It was the assets that were locked in the custodian that eventually ended up with the attacker. What I'm going to talk about now is an attack where the damaged individuals are actually the users of bridges. So, if you are on crypto Twitter, every once in a while, you can see this message, hey, if you have approved ERC 20 tokens to this particular bridge, you should go ahead and immediately revoke your approvals, right? And all these messages, they insinuate that there's something wrong, that that bridge can take away your money, right? But they never tell you what is wrong and why that actually is and how it can even happen. So now I'm going to explain to you how this can actually happen. So, imagine that you are a user, and you want to use a bridge with your ERC 20 tokens. For example, you want to transfer Dai from one network onto another network, right? So what needs to happen for this transfer to work, you first have to go to the bridge or to the token, actually, and approve the bridge so that it is capable of calling the method transfer from and withdraw tokens from your account.
00:10:20.338 - 00:10:51.406, Speaker A: And because gas is expensive, most of front ends these days will ask you to provide an infinite approval for the bridge to be able to withdraw tokens, right? And then you go again and issue another transaction, which will actually instruct the bridge to withdraw those tokens. And it will do that. It will log them in custodian and issue them on a different account. But bridges, they're actually very complex components. They cannot only just bridge assets. That would be a little bit too simple. What they can do is much more.
00:10:51.406 - 00:11:31.946, Speaker A: For example, they can perform some cross chain smart contract calls and various other things. Right. And there are various ways of implementing these additional features. And one of ways is providing the bridge smart contract with kind of a generic method here. I have called it execute that just accepts some byte string, some call data byte string. And what the brate smart contract will do with this byte string, it will parse out what it should be doing. So what smart contract it should be calling, what method in that smart contract it should be calling, and what parameters it should pass into this method call.
00:11:31.946 - 00:12:03.938, Speaker A: So what an attacker can do, they can actually instruct the bridge to talk to your token smart contract. So that would be the dice smart contract to call method transfer from, with your wallet's address, the bridge as the destination. Right. And with the amount of tokens that it should withdraw. So the bridge will do that because it has infinite approval from you to use your tokens. It will just be able to withdraw as many tokens as you own. It will lock them in itself.
00:12:03.938 - 00:12:19.514, Speaker A: Then it will see, oh, yeah, the attacker was actually able to make a valid deposit. I have the tokens, right? They are here. So it will talk to the other chain, and it will issue you the depth tokens on the other chain. You are out of tokens. The attacker has the tokens on the other chain. They can bridge them back. They're gone.
00:12:19.514 - 00:13:03.830, Speaker A: So you can prevent that from happening to you by revoking approvals. Therefore, you see on Twitter those messages that you should be revoking approvals. That's one way how this can happen. There is actually also another way, which I will also talk about, which is based on a feature called permit. So permits are actually not part of the ERC 20 standard, but it's sort of an extension where permit. It's essentially a signed message. It's a message that you have signed with a private key, with your private key, and you have given it to somebody, and they can present this message to any kind of smart contract to prove that they have authorization to spend your tokens.
00:13:03.830 - 00:14:46.082, Speaker A: So the intention how this would be used would look somewhat like that. I give permit to somebody, that somebody, that caller will go to different smart contract and say, hey, I have permit from Martin to spend his tokens. So the smart contract is going to take this permit, it's going to talk to that particular token contract that implements the permit function, and it's going to double check that this permit was properly signed and that it's valid. So it will call function permit which should return true, which should not revert if the permit is valid, and revert if that permit is not valid, or if permit function is not implemented at all. And then if the smart contract sees that the permit is valid, it can redeem the permit for an infinite approval, and then it can use transfer from to withdraw Martin's tokens, right? So this can again be exploited in the connection with bridges if your token that you are trying to bridge is implemented a little bit, unfortunately, because there are tokens that do not implement the permit function, but on the other hand they have non reverting fallback function, right? So fallback function is that catch all function that is getting called when you are trying to invoke a function that is not implemented. So again, assume that you are an honest user. You have bridged your unfortunately implemented token that has this nonreverted followback function through a bridge which allows features where users can deposit tokens via the permit procedure.
00:14:46.082 - 00:15:22.062, Speaker A: So you have provided infinite approval, bridged your tokens into another chain, and now attacker comes and calls this bridge and provides it with a permit. It provides it with a permit that is garbage. It's just like a bunch of bytes. It's not even properly signed, whatever. So this bridge is going to take that permit. It's going to talk to that unfortunately implemented smart contract of the token that has that non reverted fallback function but doesn't implement permit. And it's going to check by calling permit whether this permit is valid.
00:15:22.062 - 00:16:07.902, Speaker A: And guess what? That non reverting fallback function actually does not revert. So it is going to assume that this garbage permit is a valid permit. Then it's going to try to redeem that permit with the token contract for infinite approval. And guess what? That method for redeeming the permit for infinite approval is not implemented. So it's going to go to the fallback which is not going to revert, right? So it's still assuming that everything is good, and then it's going to call transfer from and it's going to withdraw your tokens. So this is how you will again lose and you can save yourself by revoking approvals to the bridges. So all of these attacks happened in the past, sometimes even repeatedly.
00:16:07.902 - 00:16:37.980, Speaker A: Now I will be talking about something that didn't happen in the past. So I said before, that communicator is an oracle, right? It's reading some state of the world from somewhere and it's projecting it on some chain, maybe on that side chain, maybe back on the main net. It doesn't really matter. So in the real world, when we have oracles, usually the state of the real world doesn't change, right. If I crash my car, it's crashed. There is no way to undo it. But when you are reading state of the world from blockchains, you actually have to care about finality, right.
00:16:37.980 - 00:17:25.782, Speaker A: There is always a chance that a longer chain is going to appear and roll something back. That's why when you interact with centralized exchanges and other systems, you have to wait for 612, 32 blocks before that system will do something. So imagine this. I will launch a 51% attack on a source network. You can think about Ethereum, Mainet, but you can also think about a different network with some weaker security guarantees. Then I am going to take a substantial amount of assets and I'm going to lock it in the custodian. That will yield me some debt tokens on the side chain that I'm going to take those tokens from that other chain, I'm going to bridge them back, and the custodian will release back to me the assets that I have deposited, and then I will roll back that first transaction.
00:17:25.782 - 00:17:57.140, Speaker A: I will unwind this 51% attack in a very specific way that cancels that deposit transaction. So the bridge will never have received the assets in the custodian, but it will have released to me the assets that it held. So that can cost a lot of money. Now you can come back to me and say, well, but 51% attack, that's very expensive. According to crypto 51 app, 1 hour of a 51% attack costs $1.5 million. Bridges usually hold much more than that.
00:17:57.140 - 00:18:18.502, Speaker A: And in fact, we have fast bridges where 1 hour is kind of an overkill. You will be done in less than 15 minutes or so. So that's the prophecy. I believe that it will happen one day. In summary, I'm running out of time. So we have identified whole bunch of things that can go wrong with bridges. They are really complex.
00:18:18.502 - 00:18:47.670, Speaker A: I have roughly 20 of them in here. And because I don't have time, I will be happy to talk to you about them in the quant booth that we have upstairs at the location. P 25. It's across the alley from beanbags on the fourth floor. So, yeah, please feel free to drop by quantstep is also hiring. So if you like digging into smart contract or blockchain systems, exploiting them, looking for exploits, please talk to us as well. And yeah, thank you for your attention.
00:18:47.670 - 00:18:49.300, Speaker A: Thank.
