00:00:00.250 - 00:00:31.590, Speaker A: Smart contract wallet. So account abstraction. So this is just a first, a demo of what we did. I wanted to show it live, but I wasn't able to. So you guys are just going to have to watch this. This is kind of like what the experience looks like on a Mac computer. So you know, it's that tab that we're all familiar with and you're basically logged in and you can access us, your account abstraction, wallets and Ethereum and all that nice stuff behind the scenes.
00:00:31.590 - 00:01:13.566, Speaker A: Now everybody loves Face Touch ID. And it's not just web three folk that like Face Touch ID, it's also Apple, Google, Microsoft, they're all shifting towards it. Pass keys is part of the web authentic standard, which is also Face Touch ID. Web two is crazy about it as well. It's not just web three. So let's walk through some of the steps that we had to take to make account abstraction or web authent work with account abstraction. I actually meant to have this slide initially.
00:01:13.566 - 00:01:51.230, Speaker A: So the Face Touch ID like API that you guys saw on the browser is actually a web browser API called Webauthn. The organization that pushes it out is the Fido alliance and I'm not sure if you guys might be familiar with that. But like Apple, Google, Microsoft, they're all part of the Fido alliance. And this is a standard that WTC is pushing out. Now that's also the case with taskys. How this standard works is like this in this diagram over here. Let me just walk you guys through that.
00:01:51.230 - 00:02:22.714, Speaker A: This over here. So there's a relying party or server. You can think of that as adapt server. It's server side, a back end, then there's the user's front end over here. And this is in the browser's context. So you have the Javascript side and then you have the browser, and then finally you have the authenticator. The authenticator most commonly is either your Max hardware secure enclave chip, or if you're using a phone the same thing.
00:02:22.714 - 00:03:35.118, Speaker A: It's the secure mobile enclave that's on your phone and chip. So what happens is Webauthn is really just an API that allows an authenticating relying party server to access the authenticator via submitting a challenge and getting that challenge signed by the key pair which is held on your mobile secure enclave. And then it goes back and you can verify that the signature is correct and yada yada yada, you're done. So how do we throw this into an account extraction implementation? Now taking the same. So I just drew this out. So this is what the first implementation that somebody might typically implement, right, the reliant party server, which is again maybe the wallet server or the wallet back end, sends a challenge. But this challenge, instead of it just being a random string or something of that sort, we instead submit on chain verified attention.
00:03:35.118 - 00:04:30.414, Speaker A: So assume we have a smart contract wallet that's already deployed, right, that's assigned to the hardware enclave. I'm skipping registration here. I'm just talking about pure signing. Typically what we'd submit is a challenge, but what we can instead submit is like saying hey, smart contract, please send my USDC to uniswap or something like that. Or please stake or something like that. That's this on chain verified intention, right? And we'll send this through all the way to the hardware enclave, and the hardware enclave will sign on that with its own public private key pair and give the signed signature back to the railing party and server. This signature though is not compatible with Ethereum.
00:04:30.414 - 00:05:20.658, Speaker A: It's not the SCCP two five six k one curve. It's not compatible with ED 2519 as well, so not compatible with some of the newer l ones or alternative l two s, not compatible with Stocknet, not Zk sync as well. So we can't use this in the raw. What we instead have to do is we have to wrap up there, we have to wrap this transaction so it's a valid Ethereum transaction and then we then submit it and we pay for it on that user's behalf. And we submit it to the user, I mean on behalf of the user. Now with this naive implementation, can anybody spot what is wrong with this implementation? Trusting the server, that is one thing, but it's not the critical thing that's the problem here. That is a problem, but it's not the critical thing that's the problem.
00:05:20.658 - 00:05:56.078, Speaker A: It's about Mev. Does anybody know? Yes sir, it is. That's it. It's a reentrancy or replay attack. So in particular right now all we are signing over here is my intention to send USDC to uniswap. Right? So what that means is that that object, this attested object that comes back is actually representative of my intention. And I can just submit that it can be a replay attack, an attacker can take that and submit that again and again.
00:05:56.078 - 00:06:59.330, Speaker A: But secondly, secondly, it's really simply like a miner can front run me and choose to do it ahead of time before I do, right? So that's the naive implementation, but a proper implementation. So this doesn't work, indicated by the red x as you can see, we need to secure against front running or reenter c attacks. And how we do that is very simple. Just like how nonces are used in transactions today. We just add a nonce onto the smart contract wallet or the account abstraction layer, and then we also use this nonce over here so that each transaction can only be signed once and each transaction can only be used once. Right? So this is a working implementation and that's what we've done, and we'll have an SDK out for you all to try it out down the line. In particular, there are some drawbacks.
00:06:59.330 - 00:08:28.302, Speaker A: This feels nice and seems cool, but what are some of the limitations that we are facing today with face Touch id? Why isn't it all over the world and used by everybody? So the first problem that we've encountered whilst testing this and implementing it and testing of some users is that the first thing is web authentic keys are device specific, right? So it lives on your phone or it lives on your laptop. Meaning just as like how if you lose your laptop in the sea, your metamask key is lost and you have to go back and hunt your seed phrase. The same thing is true with Webauthan, you lose your phone in the sea and you've lost your wallet, right? So yes, there's pass keys, and Apple Microsoft are pushing out pass keys quite strongly in particular, but compatibility. And what pass keys really are is they use either your Apple login or your Google login to copy the hardware enclave key and then share it around in some way or form. And there's some questions about whether that's truly self custodial. And then there are also questions about like. And there are also issues just about compatibility, right? A lot of your mobile devices, especially Android, aren't compatible with huskies today, even in the Apple ecosystem, the older iPhones and all aren't as compatible today.
00:08:28.302 - 00:09:28.974, Speaker A: So if you try to use this in the mainstream flow, you're going to face a lot of issues with device compatibility. Another disadvantage is there are extra costs for on chain verification and signatures and transactions in general. That's true for smart contract wallets or accounts traction in general as well. But it is further exemplified with pass keys, because you're actually verifying a signature, which is a very unique and weird key type, often like not. It's a very unique key type that's being verified here. And finally, this gentleman added previously that server side risk is an issue, and that is true. So web authentic keys are also specific to the application or the relying party server, meaning if there are two different applications or two different wallets, the user actually has two different hardware enclave keys which are kept on the mobile device.
00:09:28.974 - 00:10:42.698, Speaker A: What this means is if that relying party server of that backend goes down, you have the key on your phone, but there's no API to ever retrieve or ever sign or use that key. It's a huge risk, right? So those are some of the drawbacks here. What's next? And what's interesting for us, though, there's a lot of things to be positive about. Pass keys will eventually be popular and hopefully we get and reach that state. But before that, these are some interesting things that we are pursuing, at least at web three off. So can we get webauthent working a little bit better by hacking the authenticator level? So you know how Polygon is launching, like the one phone, the nothing phone, sorry, web three off is working with Polygon and Polygon's ZK chains to in particular try to implement on the authenticator level a more friendly version of pass keys and also make it a little bit more compatible with the browsers. The second thing is, perhaps we can bypass webauthn altogether and not use that standard.
00:10:42.698 - 00:11:38.246, Speaker A: Perhaps we can actually implement these signature verifications and these key type verifications that we get on today's hardware enclaves, like in the protocol level itself, so on chain, implementing the signature verification of the curves which are supported by the hardware enclaves today. And we're also doing that with the Solana foundation and the Solana saga phone. Although I think not many people like Solana here, but they have a phone and that's why we're working with them. So yeah, that's about it. I'm going to take an opportunity to kind of show a little bit more about us, and you guys can reach out to us to find out more about our past key endeavor and our face touch id endeavor. Please feel free to reach out to any of one of these contacts over here. My telegram isn't here, but you can meet me afterwards.
00:11:38.246 - 00:12:08.966, Speaker A: Going to take the last 5 minutes for Q and a, but for Q and A I'm going to show a little bit. I'm from web three off and we do cool stuff like this. We also do lots of account abstraction stuff as well as MPC stuff, and we like to marry both worlds. We provide wallet infrastructure for some of the top wallets in the space today. If you guys are looking for things like really accessible wallets, or to build a wallet, please hit us up. Thank you. Any questions? Questions? Q and a.
00:12:08.966 - 00:12:44.286, Speaker A: Yes sir. So the question was what are we known for, for account abstraction today? I think in particular, we aren't one of the 4337 evangelists. We've done several implementations on different chains, in particular to kind of estimate gas costs and usability acquisition. User acquisition costs of four three seven are still a little bit high, as I'm sure you're aware. $25 on main net. It's ridiculous. Even on stocknet it's like particular per user.
00:12:44.286 - 00:13:09.134, Speaker A: Right. Web three off. Also, we work with a lot of account abstraction sdks. So we announced, I'm not sure if you guys heard of Safe's new SDK announcement. Safe core web three off is bundled in that SDK. We also power biconomy, which is one of the leading accounts fraction sdks use. Keep P zero xpass.
00:13:09.134 - 00:13:39.854, Speaker A: You know, there are only seven out there, and like five of them are integrated with web three off. Yeah, please. Unless anybody else has a question. Yeah, please, go ahead, dude. So we are exploring and we are also working with partners. Yes, sir. Unless you want to go first.
00:13:39.854 - 00:14:32.226, Speaker A: You and the queue. My question, my question was about the, whether 4337 helps with step six on that diagram. It does in that it standardizes a gasless alternative. But at the same time, you also don't have to use that standard. And a lot of them, like for example, gelato network and biconomy, they just ignore it in. I see, I see. On the contraction level, I would need to dig further into that.
00:14:32.226 - 00:15:09.370, Speaker A: In particular, I'm not super familiar with the exact eIp or something. You, sir, you briefly mentioned mpcs. How is it integrated today or in the future? So the question was MPC and how is it integrated with our infrastructure in particular, web three offs. Like every account abstraction or every smart contract wallet needs an EOA in particular. Right. Web three off. EOA is via mpc.
00:15:09.370 - 00:15:48.740, Speaker A: What we do is basically split a user's polypravic key pair up into multiple different parts and then secure it with factors that they already own. So these include their phone, their devices, but also includes their emails, social logins and whatnot. So we combine these multiple factors into a two factor wallet or multi factor wallet powered by MPC. Are there any other questions? We have about like a minute. A couple of minutes left. All right. Okay, thank you, guys.
