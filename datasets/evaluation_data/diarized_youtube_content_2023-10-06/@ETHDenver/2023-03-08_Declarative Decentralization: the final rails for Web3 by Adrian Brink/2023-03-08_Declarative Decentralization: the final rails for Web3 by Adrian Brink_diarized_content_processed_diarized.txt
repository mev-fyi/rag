00:00:00.410 - 00:00:31.960, Speaker A: Ah, all right, perfect. Yeah. Thank you very much. And let's get started because there's only 20 minutes left in this talk. So I'm Adrian, I'm one of the cofounders of Anoma, and today I'm going to talk to you about declarative decentralization, the final rails of web three. And really, the way to think of this is that declarative decentralization, implemented as an anoma allows you to have one architecture for full stack decentralized applications. And I'll go into depth what this means today.
00:00:31.960 - 00:01:03.262, Speaker A: So I want to quickly go a little bit into the background here, because I think most people keep forgetting this, especially if you're in the Dap world. We had generation one and generation one like systems, and I really call this generation scriptable settlement. This is bitcoin and bitcoin like systems. This even includes things like zcash, Monero. They all had roughly the same API that was exposed to application developers. And you could build some applications on it. That's true.
00:01:03.262 - 00:01:48.250, Speaker A: You could build things like colored coins, namecoin, the global bitcoin stock exchange. Like, if you've been around long enough, you remember that in 2014 or so, there was like an unregistered security exchange run out of the US called the Global Bitcoin Stock Exchange, on which you could actually trade tokenized shares. It worked, but it was clunky. Like, none of these applications are composable with each other. You had to fork bitcoin core in c, run your own network in order to make this work. And this pretty directly led to ethereum, or what I would call generation two systems that have programmable settlement. And all of a sudden, you didn't have to worry about running own chain to run colored coins.
00:01:48.250 - 00:02:50.446, Speaker A: You moved colored coins to se, moved things like Namecoin to ens, and you got a whole lot of other fantastic new things that you couldn't be building before. Like you could get daos, you could get solbound tokens, things like nfts. Generally speaking, sort of the level of complexity in terms of what was possible with regards to applications increased by like an order of magnitude, roughly. And so as a result, nowadays you can build dexes, amms, NFT, marketplaces, and so on. Again, this works, but it's still clunky, kind of, because you need to build a lot of backend infrastructure to make a thing like a zero x protocol work or something like OpeNC work, because Ethereum just does a programmable settlement. And I will go into sort of more detail in a bit on. There is probably 80% of the rest of the application that can't currently be handled on Ethereum because generally speaking, all existing applications require at least one centralized component.
00:02:50.446 - 00:03:23.710, Speaker A: Because the modern design pattern of DAPPs is really that users don't have transactions, users have signed messages. Because if you want to, for example, do a trade, I don't have a transaction that's executable on chain. I have a partial state transition that goes from a to b. I don't have a thing that also takes the other side and that's directly executable on chain. So for example, in the case of OpeNC, the way this works is that the user has assigned message. They sent this to the centralized web two server run by the OpenC team in San Francisco. On AWS, that centralized server collects a bunch of these messages.
00:03:23.710 - 00:04:02.650, Speaker A: Different people call this sequencing because or solving it doesn't really matter, or matchmaking. The pattern also applies to things like optimism, for example. It's again the same pattern. Users don't have transactions, they have signed messages, they send them to some centralized web two server that does, some compute over a set of messages. And then the computer settles, sort of the net state changes as a transaction on Ethereum. And I know sort of historically, everyone keeps talking on that. All these systems like near avalanche, Tesla, Solana, whatever, that they're like polka dot cosmos, that they are really generation three or the next generation of blockchains.
00:04:02.650 - 00:04:57.820, Speaker A: I think I hold the very controversial opinion that this is not the case. They're like incremental improvements over Ethereum, because structurally speaking, the kind of applications that you can build on something like avalanche, Nia or Solana are exactly the same things that you can build on Ethereum nowadays with a slightly different consensus, with a slightly different speed. But fundamentally, from a developer's perspective, the APIs that you have access to, the guarantees that your application gets, are exactly the same. I mean, we've had a number of advances, right? We had like advances of civil resistance, moving proof of work to proof of stake. We had scaling solutions like sharding roll ups or just fast single state machines. So there were many improvements over time, but there were sort of incremental improvements that didn't fundamentally change what was possible from an architectural perspective. So I would consider all these systems sort of generation two x, kind of like programmable settlement plus plus.
00:04:57.820 - 00:05:29.686, Speaker A: One of the big insights, though, that for most modern applications, settlement is not sufficient. And so I'll start here with some historic context again on why we ended up in the settlement based world. It's because everyone. This all comes back from bitcoin. It comes from the idea that bitcoin was supposed to be used to buy milk in a store. And if that's the use case, then you have a transaction as a fundamental unit because you have the counterparties that are physically in front of you. You have the thing that you want physically in front of you.
00:05:29.686 - 00:06:16.110, Speaker A: But most applications within blockchain space didn't play out this way. We tried to do global settlement systems that allowed you to trade bitcoin for ETH with someone halfway across the globe. And here settlement is not sufficient because settlement fundamentally means that parties already know who they are and what they want. Most actual applications need counterparty discovery because they need help to find sort of the other side of the trade. Good examples here are Dexs with marketplaces having buyers and sellers, even quadratic public goods funding, project donors and funders falls into this. Dows falls into this category. Any roll up falls into this category, because fundamentally, in these systems, users don't have finalized state transitions that can be settled and executed on chain.
00:06:16.110 - 00:06:56.562, Speaker A: They have partial things that need to be combined with other people's partial intents in order to form a fully fledged state transitions. I just quickly want to go into what are the current approaches to counterparty discovery? There are roughly three approaches to this one. You do it on the blockchain. This is what uniswap and amms do. It's kind of silly and incredibly expensive, but it is the most decentralized way to do counterparty discovery in current systems. I would consider that. I think a lot of people believe that amms are sort of a global optimal design.
00:06:56.562 - 00:07:35.962, Speaker A: They're not. They're local, optimum, created for sort of the constraints within Ethereum. They are not perfect in any sense because they are the most expensive way to do decentralized counterparty discovery within the current systems. You can also do the other thing, which is you run a single operating database. Things become very easy if you just have one server doing all the coordination. This is pretty much what every decentralized, and I'm using air quotes here, deliberately decentralized application does. When you look at something like OpenC optimism, Starknet, Arbitrum, they're all single operator databases.
00:07:35.962 - 00:08:11.350, Speaker A: There's like one web two server. And if that web two server wants to censor you, they can. In some cases, the web two server can also steal all your funds because fraud proofs aren't implemented yet. But so that's the second approach. And this is what most people currently use between like OpenSea, zero x, flashbots, roll up sequencers, ZK provers. These are all trusted third parties that you as a user have to consider in your trust model. The third approach is you can also do an app specific sovereign chain, which is effectively you go back to step one, but you do it on a custom blockchain.
00:08:11.350 - 00:08:56.946, Speaker A: So you pretend like the fundamental scaling limits don't exist because you can dedicate all your throughput to this one thing. Fundamentally it's exactly the same thing, though, because structurally you made no improvements, you made no changes. And one of the big problems here is that, above all, you lose composability between applications. So when you consider what happened when we moved from bitcoin to Ethereum, all of a sudden applications started becoming composable at the settlement layer. So my contract could call onto someone else's contract and I could build applications this way. So we got about an order of magnitude more composability this way. Here, a signed message sent to OpenSea, to arbitrum, or to optimism.
00:08:56.946 - 00:10:01.396, Speaker A: I, as a developer, can't build a new application that leverages existing signed messages or existing intents. So we're losing the composability here, because really, from a user perspective, it doesn't matter which optimistic roll up I'm in, I just care that I'm in. Some that has roughly equivalent security guarantees, like to an actual user, it doesn't matter whether they're an optimism or arbitrum, they just want a fast, cheap, optimistic roll up. This is currently not possible because none of these applications are composable at the intent level. Yeah, and so now I'd like to take the last couple of minutes to go over the evolution of protocols towards generation three architectures that allow you to build full stack decentralized applications. We've called the architecture anoma, a unified architecture for full stack decentralized applications. I have to say this is not to say that anoma is the only thing that can possibly exist.
00:10:01.396 - 00:10:51.684, Speaker A: It's more I would expect that all future blockchains sort of being built from now on will follow a roughly similar design pattern, because it is the design pattern that solves the structural issues that exist within generation two architectures. And it's one architecture that provides intent centricity, composable privacy, decentralized counterparty, discovery, distributed solving, as well as multichain atomic settlement. And the talk is actually titled declarative decentralization, the final rails of web three. And here I'll sort of go into what this actually means and why declarative paradigms are the things that are going to exist in the future. And I'll start with a quick overview of how this currently works. Currently, our systems are fairly imperative when you think of what an Ethereum transaction is. It's an execution trace.
00:10:51.684 - 00:11:47.100, Speaker A: It is a user signs over a function call and an entry point there, and then sort of arbitrary compute happens. A user doesn't sign over a specific state change, so they sign over how to achieve their state change, not exactly what state change they want to achieve. And intents are completely different here. Intents are fundamentally that users sign over what they want to achieve, but don't specify how to do it. And I would argue that this is going to be absolutely necessary for mass adoption of decentralized applications because it is fundamentally safer and more scalable. Like my parents can understand the model that if they sign over a message says I'm trading one bitcoin against 100 e, that's the state change they're authorizing. My parents will never understand how to audit every single opcode that could be possibly involved in their call stack when they sign an Ethereum transaction.
00:11:47.100 - 00:12:38.504, Speaker A: And I mean, there are some other advantages here. Once you switch your mind to this idea of declarative decentralization, you get a lot of advantages. Like you get decentralized counterparty discovery almost for free, because it's very easy to. I have an intent that says I want to trade like one bitcoin against 100 eth. And to me at that point, it doesn't matter whether there's one counterparty, whether there's a pool, whether there's a thousand counterparties across the globe. Because I just specify which state change I cared about, not how to get it. Again, this is kind of where we hit this local optimum with amms in Ethereum, that instead of figuring out how to do decentralized counterparty discovery and declarative decentralization, we figured we can just make one large counterparty, as in the pool is the counterparty, and everyone just interacts with the pool.
00:12:38.504 - 00:13:25.340, Speaker A: Right? The other cool thing is intents are composable. So that if I trade a for b and you trade b for c, someone else two days later can trade c for a, and we can take these three intents that are not individually settled without having to go via a centralized counterparty and just settle them directly. Because as a group they all get fulfilled. Yes. So this is really how this architecture, as a result, looks, with a declarative black box architecture that users really just create intents that specify what specific state changes they care about. This could be I want to be in a roll up, I want to be in a multi sick. This pretty much generalizes to all existing systems, because fundamentally the base unit that people actually have is intents, not transactions.
00:13:25.340 - 00:14:06.180, Speaker A: They submit them to some settlement system or to some execution system. This could be a normal, this could be others. And then the system sort of figures out what is the best path to execute and fulfill and settle the state change, or this intent. And in the end, a user just has to check the updated state. So what's actually in the black box? Because this was the conceptual introduction to why declarative decentralization is going to matter. But what do you actually put into the black box to enable this? And here really on the far left we have counterparty discovery. So here users can issue transparent intents that are either transparent, shielded if you use your knowledge proofs, or private if you use fully homomorphic encryption.
00:14:06.180 - 00:15:04.036, Speaker A: They submit those intents to the intent gossip layer, which is a globally non consistent sort of p to p network. As in different intent nodes can have different views of the network. Because none of these intents are yet consensus critical. These get gossiped around solvers look at this and go, okay, which ones of these are compatible with each other? Which ones are combinable? For example, two NFT traits that match each other are two compatible intents. And the solver would find these and say, okay, let me put them into a transaction and actually settle them on chain. This could also be that there is a roll up sequencer that says, well, these 15 things now pay me enough fees to justify running the roll up computer or running the Zk prover for my Zk roll up, and then takes those the sequencer or the solver takes those 15 intents, computes the ZK proof, submits the updated state route to Ethereum, to Ethereum, or to Anoma actually to some settlement system. Then you have the consensus part.
00:15:04.036 - 00:16:01.068, Speaker A: And here really once the solver has found a solution, they submit this as an encrypted transaction that is not front runnable. Because once you start redesigning protocols from first principles, front running is actually not a difficult problem to solve. You can just use something like Favio to provide programmable threshold decryption and encryption that all transactions are initially encrypted against the shared public key of the network. Then encrypted byte strings are stored into blocks and on the next block, once the ordering has been fully finalized, those transactions are decrypted and then executed. At that point, no one has an unfair information advantage that they can use to front background or sandwich you. Yeah, and in the end, if you want very good privacy guarantees and incredibly cost efficient settlement, you want something like Tiger, which is our unified execution environment that handles transparent shield as well as private state. By the way, all of this is like open source code, and you can just look this up later on on GitHub.com
00:16:01.068 - 00:16:31.140, Speaker A: anoma. One of the cool things here is that Anoma is an architecture. It's not a specific deployment model. You can take Anoma's and architecture and deploy this as an l one. It's a globally decentralized l one run by a global community. You can decide to take Anoma as an architecture and deploy this as a proof of authority chain to run commerce in New York. You can decide to deploy this as an l two to Ethereum or to some other existing settlement layer.
00:16:31.140 - 00:17:19.536, Speaker A: But the nice thing is you still get total composability over all the intents, because you have one global intent pool that connects all these different deployments of one architecture. For the benefit of time, I'm going to quickly skip over these. You get a bunch of novel primitives. You get like Tiger for composable privacy. You get favio for programmable threshold decryption, which actually enables you to do programmable batching on chain. So think something like cowswap, but fully decentralized, where users encrypt their individual intents against the shared public key of the system. Those intents are stored on chain, and only after the application defined batch is over do the validators jointly decrypt all the intents within one batch.
00:17:19.536 - 00:18:07.744, Speaker A: And then solvers, in the same sense that solvers exist in kowsop nowadays, can take those intents, compute an optimal solution, submit this, and then on the application side, the application can enforce a sort of optimality criteria, as in everyone gets the same clearing price in a single batch. Yeah, this is actually the example for this. But the other thing, when Ethereum came out in 2015, we really couldn't spell out all the applications that it would enable, because everyone was like, well, this seems just like bitcoin, but slightly more programmable. Most people didn't yet realize how much more composable Ethereum was going to be. And it's kind of the same thing here with Anoma as an architecture. Anoma is probably going to make things about an order of magnitude more composable than existing things on Ethereum. Not on Ethereum, actually, like existing architectures.
00:18:07.744 - 00:18:36.800, Speaker A: This isn't to shit on existing architectures. It's just like they are going to be new architectural advances. Yeah, you can build contemporary applications here. You can also build a bunch of novel applications. And I'm not going to go through these in depth. I think sort of the most intuitive one is you can build private openc where individual users are completely private even to the solvers that solve the traits. So you can privately trade your NFT for some ETH.
00:18:36.800 - 00:19:26.300, Speaker A: This is currently impossible to be built on existing architectures simply because of how the privacy guarantees are structured in existing architectures. Maybe just like one last comment here is fundamentally the direction we need to be moving into the space is towards homogeneous architectures but heterogeneous security models because not everyone cares about the same security model. Like my parents don't want Ethereum security. My parents want like local village proof of authority chains run by their local authority. And we should just always consider how do we make unified architectures available to people, no matter what security guarantees they actually care about. This leads also to fractal scaling to Tiffany as a new consensus architecture. And yes, thank you very much, this is anoma one architecture for full stack decentralization.
00:19:26.300 - 00:19:33.400, Speaker A: I don't have time for questions, so find me next to the stage.
