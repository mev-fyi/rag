00:00:09.530 - 00:01:40.570, Speaker A: Hello everyone, my name is Imi and I will be presenting EIP 7543 for decimal math. Now, I'm going to make this basic enough for lots of people to get something from this, and hopefully also interesting enough for advanced listeners. An EIP is an ethereum improvement proposal. So this here is an idea on how to improve, in fact, all EVM based systems. Of course, Ethereum is the main one, and we're going to be talking about how to add decimal math, which is very useful and fundamental for a lot of calculations. Applications use cases around the world. In fact, I'm going to be making the case that this improvement, adding decimal math to the EVM, will allow a lot of people to develop much easier and more sophisticated and complex applications.
00:01:40.570 - 00:02:54.900, Speaker A: And that is going to invite several communities, very large industries into the EVM world. So that's represented by the pile of value coming into the EVM. And if we get entire industries coming in and using the EVM, thanks to whatever reason, then that value of course gets reflected in a skyrocketing of all EVM projects. Now I want to start and go to the very depth of what is the EVM. First of all, the EVM Ethereum virtual machine. So the m is a machine, and machines are very useful because we can use them to do tasks for us and do them in parallel. This gives a developer a lot of power.
00:02:54.900 - 00:03:53.830, Speaker A: And machines at their core understand numbers. Everything at its very core in machines is a number. In fact, if you go to and look at blockchain smart contracts that you've probably seen, then this here is a representation of a smart contract. And it's all numbers. Numbers represent data that we want to manipulate, and numbers also represent algorithms, change of data, how the data should be manipulated to get some desired result. And you see these numbers here, some people would think kind of strange numbers because there's also letters in between. You see ACDF, et cetera.
00:03:53.830 - 00:04:28.306, Speaker A: These are in fact numbers with a basis. 16 hexadecimal numbers. Typically we use decimal numbers. Base is ten. That means that there are ten different digits. 012-345-6789 that's the digits available to represent any number in a decimal system. In a hexadecimal system, you have 16 digits available to represent any number that goes from zero to nine.
00:04:28.306 - 00:05:42.410, Speaker A: And then ABCDef. And there's also the binary number system, which uses only two letters to represent any number. Zeros and ones. And in fact, it doesn't matter which system you use, the decimal, the binary, the hex, each number is a number and can be represented in any of these systems, but the representation will be different. And computers at their very core are binary. There's transistors in the chips we use, which essentially have an on and off, that's binary one or zero. That is why at the very core, computers implement everything in binary first, and developers use binary numbers and binary algorithms and procedures to do more complex calculations.
00:05:42.410 - 00:06:09.986, Speaker A: However, there is a problem. For example, 0.1. Here you see 0.1 on the left side base ten. That is 0.1, the number that a lot of people know and enjoy in various situations in life. Whether you're doing finance, 10% is a very often used number.
00:06:09.986 - 00:06:54.578, Speaker A: Whether you're doing science in a lot of situations, one out of ten is crucial number to have. Interestingly, in binary system, if you want to represent that number, you need infinite many digits. That's what this bar across the eleven means. It means that if you want to represent 0.1, decimal, the normal 0.1 in binary, you would have to have 0.1 to infinity, and you would need infinite many digits in binary to exactly represent 0.1.
00:06:54.578 - 00:08:03.640, Speaker A: Such a simple and basic number. Yet in binary, with a finite amount of memory, which is always true any computer use, we only have access to finite amount of resources. We can never represent 0.1 exactly. And that is a problem for anyone wanting to do any kind of application that uses finance, that wants to use numerical math science, to compute the kinds of calculations that myriad of applications use. The solution to this, or the solution proposed in this Eip, is to represent a decimal using two numbers. This is very simple.
00:08:03.640 - 00:08:50.338, Speaker A: Currently, if you're coding a smart contract, you're probably using solidity. Solidity gets compiled to bytecode, and typically you have access to numbers. They live on the stack. That's where you get access to them. That's an area of memory, essentially. And instead of using each number on its own, if we combine them in a certain way, in this way, then we can represent every decimal number exactly. That is c times ten to the power of Q-C-A coefficient, and q the exponent.
00:08:50.338 - 00:09:42.434, Speaker A: If we wanted to represent 0.1, we would have c as one and q as minus one. One times ten to the power of minus one gives 0.1. And in fact, any decimal value that you can think of, any value that you use in any application or that you have encountered, which again, very likely, because we are humans and we use decimal systems because we have ten fingers, makes it easier to count for us any value that you can imagine. 2.456 you can first forget the decimal .2456 can be c, your coefficient.
00:09:42.434 - 00:10:04.506, Speaker A: And then q is a value. To shift the decimal left or right. To represent any decibel value. Exactly. Of course, it depends on how many resources you have. And a very large number would not be representable still. But in fact, with this combination.
00:10:04.506 - 00:10:45.786, Speaker A: The numbers that do exist on the EVM can be very large. 256 bits means very, very large numbers. And both combined to represent a decimal like this. Gives you access exactly to all numbers that you would need in a decimal system. So now this here is the solution and the proposal to add opcodes. Now, what are opcodes? We saw the contract code earlier. A smart contract like this.
00:10:45.786 - 00:11:14.546, Speaker A: Some of this is data, and some of these are commands. And whether something is a command, you can find there's an EVM code's website here. You will see each number corresponds to some command. If it's zero a, it's x. And you can scroll through this. And you'll see that we go till seven. 8910.
00:11:14.546 - 00:11:29.720, Speaker A: Then a zero, a one. These are hexadecimal numbers. That's why you see a's and such. And you see after the a four, there's space. There's nothing starting with Abcde. And then there's some f. F one.
00:11:29.720 - 00:12:08.610, Speaker A: Until ff means self destruct. These are the opcodes. Which are the most basic commands that the EVM, the machine, understands. These are suggestions for new opcodes, d zero to d six. That allow you to work with and manipulate decimal numbers. As we just defined. We have arithmetic adding, negating, multiplying and inversing.
00:12:08.610 - 00:12:35.562, Speaker A: Right? And so with inversing and multiplying together. You can get division. With negation and adding, you can get subtraction. And these work on the decimal values. That is, if you have a value a with its coefficient and its exponent representing a decimal a. And another decimal b. If you put them as inputs.
00:12:35.562 - 00:13:04.642, Speaker A: You're going to get a decimal c as the answer. Again with the two components. The coefficient and the exponential. And you'll notice that most of these opcodes have a precision parameter. Which is the precision that you want to keep in your calculations. And now, additionally to the arithmetic. We're adding three power, more powerful math functions.
00:13:04.642 - 00:13:27.930, Speaker A: The exponential, that's the prototypical growth. The log. The prototypical slow growth. And the sine function. The basic trigonometric functions. All these seven functions, combined with each other. Give all the elementary functions.
00:13:27.930 - 00:14:17.166, Speaker A: All the numerical functions anyone ever uses in numerical code. That is, trigonometry. Rational functions, polynomials. Essentially everything that is used to calculate integrals, differential equations, optimizations. The entire numerical coding world can be sustained and built based on these seven operators. And we do not need more and nor less. How are these exponential, log and sine, by the way, calculated? Perhaps you remember the exponential can be expanded into simpler terms, a polynomial, an infinite one.
00:14:17.166 - 00:15:22.340, Speaker A: But the more steps you make, the more precision you get in your answer. Hence, we have the steps argument, which a developer can choose knowing, and it is deterministically known how many steps you need to have to reach a certain precision. The same goes for the sine, and the log can be done in the same way or more efficiently using continued fractions. This is the same thing. This is just long fractions going infinitely. If you take enough steps of these, you will get the precision that you want. And besides that, from numerical analysis, we know that if you want to have a certain target precision for your end result, and that depends on your application, whether you need four digits or 20 digits, then your intermediary calculations and steps should have at least that many, actually more precision available.
00:15:22.340 - 00:16:29.754, Speaker A: With this, the current EVM, from being like a simple calculator, goes to a scientific type of calculator, and the use cases, and now I'm coming to the value mentioned in the very beginning, are immense. There is an entire trillions of dollars of mathematical finance. Think hedge funds, banks, they have sophisticated financial products, and all of those require numerical coding. Integrals have to be calculated, differential equations have to be solved, all of which currently is very difficult because you have to translate it into binary. Machine learning, of course, a massive subject, often referred to as AI, although I should warn one day the a prefix will be considered an insult. It is intelligence. And intelligence run by a machine allows us to do many things.
00:16:29.754 - 00:17:43.214, Speaker A: And of course, if we could bring machine learning into a trustless environment, imagine you have code that creates images for you, or does governance or anything else that machine learning can do, but do so trustably? You know the source code is exactly as intended, because everything on chain is open source. Same goes for science, digital art, and many, many more examples that anything that requires numerical coding. There was an explosion of developers using things like Python, or nowadays, better alternative Julia, to do the simplest kind of calculations. In finance, if you want to go from a yearly volatility to a daily volatility, you have to take the 16th route. But even taking a simple route, any kind of route, is essentially just a power. Doing all of that currently requires a lot of code. So we could write everything that I am suggesting in solidity.
00:17:43.214 - 00:19:03.290, Speaker A: We could have a solidity library doing all the math, just like I am suggesting, to put into a single opcode. So d six to calculate the sign instead of a lot of bytecode, what is the pro and the con? So what we're doing is we're shifting complexity, we're shifting it from the smart contract developer, the solidity developer to the node. And we are getting rid of overhead of calling a lot of opcodes from a higher language like solidity to do complex mathematical calculations. And in this case we're talking about three fundamental functions of the universe of nature. Exponential, log and sine. These are true in the whole universe needed for any kind of mathematical coding and if available correctly and efficiently as an opcode, would remove also bugs from those that are looking to do mathematical development. The gas.
00:19:03.290 - 00:20:04.830, Speaker A: The good news is it is deterministic. All these algorithms are deterministic, are input dependent, they're complex, but they can still be precisely calculated. And there is a reference implementation for this EIP that does so and currently charges you double the gas, which can be improved. And thinking of why should one not do this, we are asking the question, well, if you have some complex algorithm functionality, should we put all of that as an opcode onto the EVM? That would be cluttering the EVM. It's not what we want to do. There's only 256 spots available for opcodes, so we should be really selective. The EVM, the v in the e is that it is a virtual machine.
00:20:04.830 - 00:20:54.858, Speaker A: Normally opcodes, that is the low level language of coding. Assembly adheres to the restrictions of hardware. And hardware is binary and can do only simple things. But when you have a virtual machine, then you can do complex things. For example, there's opcos for hashing because that is fundamental to smart contracts on these machines. But for the numerical world, what is fundamental is exponential, log and sine. The only con that I can see is perhaps design flaw in the EVM in that it doesn't contain a version tag in the beginning.
00:20:54.858 - 00:21:22.900, Speaker A: That means there could be old contracts that have a certain opcode that didn't exist yet and it would function in an unexpected way. But that is then true and a problem for any new opcode to ever come. So that problem is shared. And besides that, I see no other problems except nothing. Thank you.
