00:00:09.770 - 00:00:36.338, Speaker A: Awesome. All right, hi, everyone, I'm Kaido. Today I'm going to talk about you could have invented Eigen layer. And hello to the friends on YouTube watching this in the future. All right, so first I want to give a quick acronym for this talk, because we're going to, going back in the future, mention this along. You could have invented Eigen layer. The acronyms YCI, YC, YC.
00:00:36.338 - 00:01:03.214, Speaker A: And the last part, we're going to reference this talk as a YC talk. And the reason is, I hope that after you understand what this Eigen layer thing actually is, it's going to show you the endless possibility you can build on it. And this is a YC moment for you. All right, let's get started. First, what is Eigen layer? So I have two options here. A is shrim and b is some diagram. Just show of hand.
00:01:03.214 - 00:01:20.006, Speaker A: Who thinks a is Eigen layer right now? All right, we see a few hands. Awesome. Thank you. All right, who knows what b is or have seen b? Oh, we have a few hands, too. Awesome. So at the end of the talk, hopefully you will understand Eigen layer is both. Right.
00:01:20.006 - 00:01:57.460, Speaker A: Shrim is our great founder and b is our architectural design. So the goal of today's talk, we're going to cover four different points. First, we're going to start from first principle and think about what problem does Eigen layer even want to address. Second, we're going to think about, okay, to address these problems, what are the requirements to solve individual problem? The third thing is going to be, okay, let's build this protocol out to address these requirements. And lastly, let's make it into a product. What's the problem statement? The problem statement is the following. Bootstrapping any decentralized infrastructure is difficult.
00:01:57.460 - 00:02:53.058, Speaker A: Crypto aims to remove intermediaries, and when not possible, we try to increase its security and resiliency. So how do we increase the network security and resiliency? Normally, we use a decentralized network, but building a decentralized network is hard. But why is that? Most decentralized network requires consensus, and consensus mechanisms are difficult. We have a few different flavors of consensus mechanism, proof of authority. Some people may call it a multi sig, meaning just a few authorized people can make changes onto the network. Another one is proof of stake, pioneered by Satoshi with bitcoin. And lastly, that's gained a lot more popularity recently, is proof of stake, or PoS systems to bootstrap any proof of stake system? The stake in proof of stake is really, really hard.
00:02:53.058 - 00:03:33.150, Speaker A: And there's a few reasons for that. So first, what is a stake in a proof of stake network? The goal for stake inside a proof of stake network is to do simple resistance so we know who are the individual nodes to the network and they generally represent some economic value. The first reason why it's difficult, I'm going to run through this really quick and I'm going to go back to it to explain in depth. When each one of these are difficult. The first one is the stakers and the developers. It's very hard to find one another. The second reason is in order for you to contribute to any proof of state networks today, you must be exposed to the extreme volatility of these individual network tokens.
00:03:33.150 - 00:04:32.210, Speaker A: The third thing is if I contribute my economic stake to your specific proof of state network, there's no way I can expose to other yields from other proof of state networks. And the effect of that is if you are a new proof of state network, you must compensate this opportunity cost coming from the staker side. And the lastly is under this design of each individual network having different proof of stakes, they are going to have a fragmentation of security problem. All right, what does each of these mean? The first one is it's difficult to identify where stakers are from a developer point of view. And the reason, the sort of symptom of this is most proof of state networks. Their economic security is closely tied to its fundraising. Meaning most economic security for most new protocols will be provided by its investors.
00:04:32.210 - 00:05:46.460, Speaker A: Is there any way for us to connect the stakers with the developers other than through this fundraising mechanism? The second and third are very much directly tied together for me to contribute to a new proof of stake network security. I might acquire the token for that specific proof of stake network and then I have to stake it and the network will give me rewards in return. Because I'm buying this token, I'm exposed to a lot of price volatility of the token. The network needs to compensate me a lot, generally in the double digit aprs and this sort of goes into this potential scenario, imagining a proof of stake network, your token price drops a little bit, you have weakened security, your TVL decrease as a result, or your activity decrease as a result because people don't trust you as much and because your TVL decrease, your token price drops even more. And then you have a very vicious feedback loop where more less economic security means less economic activity, less economic security, and vice versa. The last part is in the current proof of stake bootstrapping model, security are fragmented. You may have seen this graph from Shiram before.
00:05:46.460 - 00:06:27.858, Speaker A: This is one of the problems. Imagine you are building a decentralized application and you rely on three different other proof of stake networks. One of them is a bridge, one of them is an oracle, and one of them is a coprocessor. Each one of them have about a billion dollar economic security. But your application is built on Ethereum. I should probably add a zero here, because now, yesterday Ethereum surpassed 100 billion economic security in this model to compromise this decentralized application. Even though it's built on Ethereum with 100 billion economic security, it is actually the weakest link of the two of the four, which is $1 billion.
00:06:27.858 - 00:07:06.950, Speaker A: Imagine another world where instead of fragmenting the security, we pull the security into the base layer of Ethereum. So Ethereum has 13 billion economic security. It go through Eigen layer and Eigen layer bootstrap these individual proof of state networks. Now, from a decentralized application developer standpoint, to use each one of these bridges Oracle coprocessors I am under the same security assumption as building on top of Ethereum. So those are the problems. How do we find solutions or what are the requirements to solve them? Just go over one more time. It's hard to connect stakers with developers.
00:07:06.950 - 00:07:46.450, Speaker A: It is hard to acquire the token, and we don't want to always tie a specific network with specific token. We want to compensate users on their opportunity costs or lower the opportunity cost. And lastly, we don't want to fragment security. Instead we want to pull security. So given those individual pain points, what do we need to do? First, we need a platform to connect stakers and developers. What does that platform mean? I'm going to talk about it in a bit. The second part is stakers should be able to provide economic security using any token, not just like the specific network token.
00:07:46.450 - 00:08:28.206, Speaker A: Stakers should have the ability to restake and should contribute to the security of other infrastructures while earning native Ethio. Therefore, when you're bootstrapping a new proof of stake network, your stakers opportunity costs are much lower. And lastly, through this mechanism of restaking eigen layer pool security instead of fragmenting it. All right, those are all words. Let's try to build on MVP. And we have ten more minutes to finish building from an MVP to the end stage of wagon areas. So first, what is a platform between stakers and infrastructure builders? Here I illustrate a very high level idea of what a proof of stake network is.
00:08:28.206 - 00:09:04.582, Speaker A: So you have a few participants, you have the staker, you have the protocol itself, and you have the end user who are consuming services from the proof of stake network. And then lastly you have the developers who are writing the code that runs the protocol. An example would be an oracle. The Oracle developers would write the Oracle protocol. The stakers would contribute stake to the Oracle for its economic security. And lastly, the Oracle protocol promises its end user that its price feed will be accurate and would not be maliciously manipulated easily. Normally these users are just smart contracts.
00:09:04.582 - 00:09:44.950, Speaker A: The other side of the promise is if such promise, the oracle promise made to the end user is broken, then the staker who contributed to the economic security of the underlying network will be slashed. Developers design these commitments. Stakers make these commitments by staking. And lastly, the protocol enforces the slashing of these individual tokens. So actually, if you abstract far enough, all we need to do to build this platform, we just need to satisfy two requirements. The first requirement is the ability to make commitment. And guess what? Ethereum is the best commitment making device.
00:09:44.950 - 00:10:19.426, Speaker A: The second part is enforcing some commitment, sort of similar to running some function. And the best place to do it is Ethereum. You can make a commitment through smart contracts and enforcing a commitment through a function call this is the simplest mvp. We will start with a staker deposits some of its token into a token pool, and inside the token pool there are some commitment logics. What would it look like in practice? It will look like something like this. If you don't understand solidity, don't worry about it. It's very easy to follow.
00:10:19.426 - 00:11:02.682, Speaker A: The first mapping basically tracks how many tokens. You have the stake function to get into the pool. You have the withdrawal function to exit the pool. And lastly you have a slash function, meaning if you misbehave as a staker, you should be slashed. And as you can see, there's some question mark here, meaning whenever you will be slashed, somebody needs to submit a fraud proof or evidence that you've committed things that deviate from the underlying commitment. In the Oracle example, that means you've reported a price feed that significantly deviates from the actual price feed. So we cross out the first requirement we need, which is creating a platform to connect stakers with infrastructure builders.
00:11:02.682 - 00:11:40.982, Speaker A: The next part is contributing economic security using any token. That one is easy, since we're building on Ethereum and we have infinite amount of ERC 20 tokens. The third part is a little bit tricky, but here we're going to take a shortcut. We're going to say, hey, there's a lot of liquid staking tokens out there. If we can take them in as economic security of the underlying proof of stake network, then the stakers of those new proof of stake networks do not need to forego their ETH rewards. So that part is crossed out. We have another mechanism that go through the bypassy liquid staking tokens and that's called native restaking.
00:11:40.982 - 00:12:20.140, Speaker A: It's on our docs page. If you want to learn more about it, take a read. Last part is through restaking I can layer pool security and start fragmenting it. So what does it mean here? So in the previous example we just described is some staker deposits some token into the token pool. But if I want to make another commitment, then I need to deposit another token into another token pool. So each one of these token pool are sort of each one of the commitment or commitment to a single specific proof of state network. So how do we do that? We achieve that by compartmentalizing the slashing function.
00:12:20.140 - 00:13:14.410, Speaker A: What does it mean? So now as a staker I can deposit my token into the token pool. The token pool doesn't have any slashing logic tied to it. However, what the user could do is enroll into let different slashers to slash its stake. So slasher one could hold the logic for Oracle, slasher two could hold the slashing logic for a bridge, slasher three could hold the logic for slashing for a coprocessor. And the possibilities are basically endless here for you to design your specific slashing condition. I'm not going to go through the entire contract, sort of a high level idea, but feel free to take a pause here or take a picture. And with that design we actually cross out all the requirements we need to satisfy the initial problems we came to solve.
00:13:14.410 - 00:13:37.230, Speaker A: We establish a platform. Stakers can contribute economic security using any token. Stakers have the ability to restake and not forego their ETH rewards. Lastly, through restaking Eigen layer pool security and start fragmenting it. And this is the MVP of Eigen layer. It achieves most of the things we came here to achieve. And the rest of the talk will be very, very fast.
00:13:37.230 - 00:14:11.574, Speaker A: Since I only have 20 minutes, I'm going to run through a lot of slides. So if you're online, feel free to take a pause and read through the smart contracts. But in the rest of the talk, what I'm going to focus on is we're going to try to bring this MVP minimum viable protocol into a product where end users and developers, and also a new concept we're going to call operators will be able to participate. The first thing we identify is staker doesn't always want to operate its own thing. Right. That's why a lot of staking companies exist, why Coinbase exists. So we're going to add an operator role into the Eigen layer contract, but it's a little bit messy.
00:14:11.574 - 00:15:00.138, Speaker A: So we're going to compartmentalize and modularize the. Sorry if you're taking picture that might be a little bit too fast. So we basically are tracking a lot of different variables to understand what is the relationship between the stakers and the operators. And the operators are basically the people who are running the underlying infrastructures to secure these different proof of stake networks. So instead of having that big wall of code, the design will simplify to something like this, where we have the delegation manager, which is at the bottom of the screen. And what the delegation manager basically does is it tracks the relationship between a staker and an operator. For example, Kaido used to stake to secure an oracle protocol, but now Kaido is like, no, I don't want to secure it myself.
00:15:00.138 - 00:15:49.530, Speaker A: I'm going to delegate that responsibility to Coinbase, and Coinbase will be able to run that delegation on behalf of me. This is very similar to delegated proof of stake mechanisms. The second thing we're going to do is this only supports one token at a time, but that is very simple to solve because before we have one mapping to track one specific token. So we're going to do is have something very similar to the Uniswap design where you have a token manager and the token manager handles tracking of how much user owns inside different token pool. And you can think of each token pool are holding different tokens. So this one could be staked eth, this one could be CBE, et cetera. I'm going to pass through the contract code here, going to take a quick three second pause for pictures.
00:15:49.530 - 00:16:19.842, Speaker A: Awesome. And this I'm going to spend a little bit more time on, which is expanding the ABS design. I think some sharp audience would already identify some of the problem that exists in the current design, which is the following scenario. Imagine I'm a staker and also running my own operator. I commit some malicious behavior on the first timestamp highlighted here, and then in the next time instant, I'm going to instantly withdraw from Eigen layer. So now my funds are completely off Eigen layer. I cannot be slash anymore.
00:16:19.842 - 00:16:51.840, Speaker A: By the time somebody relays a fraud proof, for example, submitting the evidence to Eigen layer protocol to state that I have done something malicious, it's too late. I am already outside the protocol. So what we need here is when we commit a malicious activity. We cannot withdraw until someone submits a Prof. And this is very similar to the seven day optimistic fraud proof window or the onboarding period for some proof of stake networks. We're not going to change anything here on the design. This is the current design we land on.
00:16:51.840 - 00:17:51.300, Speaker A: Instead, we're just going to add a simple variable called onbonding period. And what onbonding period will do is if I want to withdraw from any single, if I want to withdraw from egging layer, then I need to wait for a specific time frame to give people to submit the specific fraud proof. I'm not going to talk about this here, but this slide gives the idea that now withdrawal is no longer I call one function, I get my money back. Instead I need to queue on withdrawal and I will complete my withdrawal after the onboarding period finishes. The last part is the gas optimization issue. So in the current design, what we sort of run into is there's a lot of different slashers and we need to check with the slashers on the status of different individual operators. And these cross contract calls really add a lot of gas burden on the end staker, especially when small stakers, when they try to stake and withdraw, if the gas costs are really high, it may never be economically viable for them to participate in the system.
00:17:51.300 - 00:18:37.626, Speaker A: And the way we achieve it is by having a slasher manager. Similar to the previous idea, slasher manager tracks the relationship between each single operator and the individual slashing condition the operator is enrolled in. And that's it. This is the design of Eigen layer on a very, very high level. There's some parts of naming convention is different for simplicity and understanding, but this is sort of what, on a high level, what Eigen layer is and what restaking is. Feel free to take a picture because this one, I think is going to be one of the most important slides here in the deck. All right, lastly, this talk is titled why you could have invented Eigen layer.
00:18:37.626 - 00:19:08.530, Speaker A: If you want to reference this talk, call it the YC paper or the YC talk. And that's the end of my talk. Thank you guys so much for your time. It's coast.
