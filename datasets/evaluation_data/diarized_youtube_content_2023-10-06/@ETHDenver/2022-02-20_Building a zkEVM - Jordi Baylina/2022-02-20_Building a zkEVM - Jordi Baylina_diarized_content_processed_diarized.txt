00:00:00.250 - 00:00:15.146, Speaker A: Well, hello, everybody. I'm Jordy Valina. I'm the technical lead at Polygon Hermes. And, well, I'm doing a kind. Every time that I'm going to a conference. I'm just trying to explain a little piece of the ZKVM. And it's actually what we are building right now in Hermes.
00:00:15.146 - 00:00:35.458, Speaker A: The approach, just for the people that don't know what we are doing, we are trying to build a ZK roll up. It's a ZK that's fully compatible with Ethereum. That's of code to code. We are working hard. We are very advanced. We have a proof of concept today. But today, I want to focus in a specific place and a specific point of this ZKVM.
00:00:35.458 - 00:01:13.362, Speaker A: And is that rollups must be decentralized. In Hermes first. And knowing polygon, Hermes, we care a lot to do on decentralization. So we think and we talk and we will think the protocols and the roll ups must be decentralized. The experience we have in Hermes, well, was interesting, was like the first version, we created a decentralized protocol for choosing who's going to be the operator. The operator is the one that's generating the proofs and so on. We created what was called proof of donation, or proof of burn, if you want.
00:01:13.362 - 00:01:57.730, Speaker A: And the idea is that any participant in the chain that wants to generate these proofs, they can buy a slot. And in a canon of an auction. And once you earn this slot, about maybe ten minutes, for example, you can create as many proofs as you want and as you can, and you will receive all the fees on there. This was interesting because actually, it's a decentralized protocol, but had some drawbacks. Okay, here, I'm going to mention some of them. First, is that validators? This is a highly specialized procedure. And by deleters at the end, they become quite centralized.
00:01:57.730 - 00:02:23.654, Speaker A: There are service level risk. Imagine that during ten minutes, even if they buy the blocks, but the operator that earns the slot just falls. So this will affect. Maybe it's not their fault, but in ten minutes, maybe they cannot fix the issue, and this will affect the remaining. The rest of the network. This is the sudistan Drawback. The other is the complexity of the auction.
00:02:23.654 - 00:03:03.734, Speaker A: So this auction, you have to bid. You need to predict how many transactions are going to be. You need to discount that in the price that you are bidding. It becomes the model quite complex. And the other thing is that in the bootstrap process, when generating this proof is not still profitable, then you need to protect somehow the network, the network can be attacked very easily. Somebody just can buy very cheaply these slots and then the network will stop. So these are some of the things that we realized that from the protocol didn't work good.
00:03:03.734 - 00:03:39.182, Speaker A: And we were thinking in little bit what should be this protocol? And it should be also permissionless. It must be efficient, must avoid control of a single party, protection from malicious attacks. So everything needs to be solved. And we came up to a very simple, very simple idea. And this is the one that I want to present here. The idea is, well this is something similar that for example, the optimistic rule apps they are already using. And the idea is to have like two operators or two roles.
00:03:39.182 - 00:04:07.834, Speaker A: One is the aggregation phase and the other is the computing prep phase. The aggregation phase we call it, well sorry, the sequencers, the sequencing phase and an aggregation phase. The sequencers mainly take transactions. Anybody in the network, anybody can be a sequencer. And the idea is that sequencers just collect transactions and they push it on the network. And the provers or the aggregators, they just build the proofs. So we come up with a system that looks like this.
00:04:07.834 - 00:04:31.486, Speaker A: We have an ethereum blockchain and we have two kind of transactions. Transactions from the sequencers and transactions from the aggregators. When the transactions from the sequencers are mined, we already have a state. These transactions, all the transactions are going to be processed. Even if the transaction is invalid. Invalid transaction is going to be a no operation transaction. So we have a deterministic estate.
00:04:31.486 - 00:05:10.394, Speaker A: So once the transactions is mined, we have a deterministic estate. And we have what we call it, we can call it a kind of a finality. We already know this estate is not going to change unless there is a reorgan layer one, of course. But once it's mined in the sequencer mine, these transactions in the blockchain, this state is there. And in the second step, later on, maybe 1 hour later, 2 hours later, or whenever, the aggregators will convert. This implicit estate, it's an estate that is not on chain. It's in a state that is a result of computing, of executing all the transactions.
00:05:10.394 - 00:05:42.902, Speaker A: So anybody can calculate, but not on chain. So actually the aggregators will created a state and put it on chain. And it's at this point where this estate is consolidated. And for example, you can do some exits, but for the normal payments or for normal transactions in layer two. So anybody can just check these intermediary states. This is the very simple idea. Okay, so this is the roles of the sequencers.
00:05:42.902 - 00:07:12.322, Speaker A: And here the most important part, I'm going to jump some slides forward. Okay, the most important part here is how the incentives works. So the thing is that all layer two transactions, all the fees of the layer two transactions go to the sequencer. So the sequencers collect transactions and they become like a miners, they just collect transactions and they know that all the fees of this layer two are going to go to them. In another part, the sequencer, in order to mine the transaction, will have to pay a fee. Well, first it's going to pay the gas fee of Ethereum and it will pay also some matic or some other tokens in order to be able to send these transactions on chain. Then the idea is that the aggregator, the proverb will just collect this fee, okay? So the proverb of course have to pay the transaction fee, the ethereum, the layer one fee, but it will collect this fee, okay, the idea is that from the sequential perspective, the fee, it will be increased while there are a lot of blocks.
00:07:12.322 - 00:08:10.102, Speaker A: So while there are more blocks, there is pending to create the proof this fee is going to be increasing. What the provers, what the aggregators will get is just the average. So the number of pending blocks divided by the total. So the total collected matic or the total collected token divided by the number of locks. So that means that if the network is accumulating pending blocks pending to be processed, the price is going to be higher. So somebody will, at some point it's going to be profitable that the provers or the aggregators will generate the proofs. Okay, here, this model I tried to explain very, quite easy, but this model has a lot of advantages.
00:08:10.102 - 00:09:06.918, Speaker A: The first thing is that the sequencers, for example, this is valid, for example, for roll ups and for validiums, sequencer can put all the data on chain normal roll up or they can just put a hash and maybe a proof of storage somewhere, kind of a validium. And this is part of the sequencer. The second advantage is that it's really fast. The transactions are processed once the sequencer just mine these transactions and okay, another important thing is, well, here I want to finish with that. There is another advantage. It's more kind of, this opens kind of a business model here and it's the aggregators. Now we can have different kind of aggregators.
00:09:06.918 - 00:09:41.158, Speaker A: Who's going to be aggregators? Maybe the wallets, manufacturers, many the changes, maybe the different applications that they are somehow collecting. They will collect the transactions and they will get the fees on that. So this opens like a new market, like kind of measurist kind of aggregate. So just these sequencers will collect on that. And the provers is just first come, first serve. If you have a good service, then you will be able to prove here is a first come, first serve. Maybe here we are thinking maybe to introduce some randomness to be a little bit more fair.
00:09:41.158 - 00:10:07.306, Speaker A: But at the end the money is there, the money is in the chain. And the aggregators, they cannot do anything. They just consolidate a state. But they cannot add transactions, remove transactions or do anything. And we know that if the money is there, somebody will do it. Okay? And they of course they have the incentive to collaborators here. Another thing that you interesting here is for example in the aggregators.
00:10:07.306 - 00:10:48.006, Speaker A: So the aggregators, there is a risk here that the aggregators, that there is a kind of a collision. Imagine that I send the same transaction in one aggregator and in another aggregation aggregator. So this could be for example, a double spend. Of course, the first transaction that come this is going to be processed. But the second transaction that's a double spend is going to be a no operation. So from the system perspective it's going to be no problem. The problem is that the second one, the aggregator, sorry, the sequencer that didn't include this transaction, that's an invalid transaction.
00:10:48.006 - 00:11:26.722, Speaker A: They will not collect the layer two fee. So they have an incentive not to put invalid transactions. And the other thing is that, well, just as the technical detail for pink people here is that how we solve. So the idea is that we include in the transactions, we include the transaction a field that's the sequencer. So the idea is that there is no front running attacks because when I push transaction sequencer, maybe some other sequencer could steal that transaction. So we include a new field that is the sequencer signature. But we want to be compatible.
00:11:26.722 - 00:12:05.454, Speaker A: We want to be ethereum compatible. So the trick here is that instead of including a field that's going to be the sequencer, we are going to use the chain id. So each sequencer will be able to register a specific chain id and then this transaction is not going to be valid if it's mined from another sequencer. So this allows, for example, to solve this. Well, this problem, this, this stealing, this front running attacks. Okay, so this is very much the protocol. It's a proposal.
00:12:05.454 - 00:12:51.010, Speaker A: We are still thinking on that. We published that in the Ethereum research and here is just open for comments and just wanted to present here because I think it's an important, so it's very simple, but it's an important step just to decentralize the roll ups with this system as you can see anybody can be a sequencer and somebody's going to be an aggregator or approver and there is no central party, there is no centralized, there is no censorship resistance. So at the end you can be your own sequencer. So in the worst case you will be a sequencer. You will create your transaction, you will put it on chain and so on. There are other details. For example, signatures.
00:12:51.010 - 00:13:29.500, Speaker A: Sequencers will have like two ways of putting transactions. One is including the signatures, will include a lot of data on the signatures. The other is if you have a lot of transactions in the sequencer you can generate a zero knowledge proof that aggregates all the signatures and with that way you save all the data storage there. Okay, so this is very much, any questions, any comment, any proposal? We are, we are absolutely open and we hope hear from you. That's it. Thank you very much. Thank you.
