00:00:00.650 - 00:01:07.570, Speaker A: Both the hard way and the easy way. A thing to kind of like note, and I'll probably reiterate it a couple of times during the presentation, is that gasless transaction is kind of like the entry point, or I view at least to better UX in web3, mainly just like onboarding folks who have never interacted with web3 before. So we're going to be looking at ways to kind of interact that I forget words right now to implement that within our dapps. A little bit about me my name is Rahat, head of developer relations over at byconomy. I've been a former hip hop artist, been a front end engineer for a few years before going into web3. Was solidity developer for a few different NFT projects and got into Devrel about a little over a year ago now. And yeah, why are we talking about Gasless transactions? So gasless transactions, like I mentioned before again, are the entry point into better UX and web3, right? And a little thing to note about gasless transactions, they're not completely gasless.
00:01:07.570 - 00:02:10.806, Speaker A: They're gasless in the sense that the end user that you're serving within your dapps may not have to pay for gas on transactions that they want to execute. You can whitelist certain functions on your smart contract specifically for that purpose, or for a specific user subbase as well. And again, the main reason for this is because web3 is filled with a lot of UX issues. And this isn't like UI issues, there's plenty of UI issues everywhere. But the whole concept of creating a wallet to going to a centralized exchange, doing some fiat onboarding, making sure you have enough gas to do a transaction for someone who is not native to web3, that's a lot of work to get them to start using your application. So the agenda today, we're going to start off by covering signatures. Signatures will lead into metatransactions, which are what enable you to have those gasless transactions in the first place.
00:02:10.806 - 00:02:52.382, Speaker A: We'll look at an easier way to implement that through improved DX with biconomy. Then we'll explore some deeper UX with account abstraction. So starting off with Ethereum signatures. Ethereum signature is basically just a cryptographical proof that a transaction was created by a key holder. So off chain this would be on your front end. You would sign an object or transaction, some piece of data using your wallet and using your private key. You would cryptographically obfuscate that, and someone on the other end can then verify your public address is attached to that signature, which proves that you are the one who originated that signature.
00:02:52.382 - 00:03:33.918, Speaker A: Now, signatures can be used a couple of different ways. They can be used to give permission to do something, pass data, or prove that you just initiated a specific transaction. So one specific way of implementing signatures, AIP seven one two, this is a standard that you can follow, and this allows for both off chain and on chain verification. We'll touch on that just a little bit more. And ultimately what that leads into is unlocking metatransactions, which are signatures for relayers. Relayers are what are the kind of entity that is going to take a transaction that is signed by some user on your front end. It's going to load it up with a specific amount of gas and execute it on behalf of that person.
00:03:33.918 - 00:04:29.890, Speaker A: So if you kind of look at it like, let's say there's a completely free NFT mint, right? Someone signs a signature on front end, that signature has data specifically about whatever function needs to be actually executed, as well as specifications like the nons, et cetera. That is all sent to some other smart contract using EIP seven one two to forward that. And you can do that using ethers, js, web3 js. There are built in functions for sending those signatures along. And essentially you can have this other entity execute that transaction on your behalf. So let's look at it from the point of view of an ERC 20 token transfer. A few things that you need for an ERC 20 token transfer is a sender address, where is it going? A recipient address, an amount of tokens that you actually want to transfer, and the token contract that this token is associated with.
00:04:29.890 - 00:05:32.148, Speaker A: Just the basic things to make sure this transfer can actually go through. For that transfer to actually become a transaction, you need these three things. A valid digital signature, a correct nonce, and the gas that you need to actually execute that transfer as listed in the previous slide. Now, a potential gas list implementation, when we look at this is rather than just sending the ERC 20 tokens, what if we just sign a message on the front end with the details of that transaction? So the details that were all listed here, we take that, we make sure that the nonce is included in the signature to prevent any signature replace. So whenever you're actually forwarding a signature over to some other entity, to some other smart contract, one thing they can potentially do is take that signature, reuse it over and over again. So having that nonce and checking for that is going to help you prevent the security issue. And we're going to look at an easier way if you don't want to do this, to actually implement this.
00:05:32.148 - 00:06:34.136, Speaker A: So on our smart contract, we're going to use an elliptical curve digital signature algorithm to verify the signature. So the ECDSA Sol is a smart contract that has functions that allow you to verify that someone who has signed specific transactions on their front end, you can go through that, verify their public key, because they use their private key on the front end to actually sign it. And then ultimately a relayer is given your function and executing that function on your behalf and sending you your NFT, your ERC 20, or whatever it is you want to do. So this is a little diagram of how you can visualize this. Again, the user is going to go to their web3 enabled front end, sign the transaction. That transaction gets sent to the relayer, and that transaction is then sent to the blockchain. So doing all this manually is very tedious, very annoying, very hard.
00:06:34.136 - 00:07:30.836, Speaker A: So let's introduce the standard for doing this. ERC 2771 is a contract interface for receiving meta transactions through what's called a trusted forwarder. A trusted forwarder is just going to be a smart contract that does a few things for you. It's going to verify the signature for you, help you protect against signature replays. So you don't have to go in and make sure to do that a lot yourself and forward everything over to the proper relayer to make sure everything is executed. So biconomy relayers have been doing exactly this since 2019. So relayers and paymasters essentially allow you to take some of these gas complexities and abstract it away from the users, right? So what you would be doing on the biconomy dashboard when you are implementing this is essentially creating a gas tank and filling it up, pre filling it up with a certain amount of tokens to pay for gas.
00:07:30.836 - 00:08:12.468, Speaker A: So let's say you're on ethaneet, you would fill it up with eth. If you're on, let's say, polygon, you would fill it up with matic. So whatever the token is that is used to pay for gas, you fill up your gas tank with that. And once the transaction comes through to the relayer, the amount of gas is subtracted from your gas tank. So you do have to make sure you fill enough gas in there on behalf of your users. So this is what I meant by earlier, saying that it's not completely gasless, it's gasless for your users, but you would still have to pay for that on your own. If you want, like a real world example, you can kind of think of that uses gasless transactions is lens protocol.
00:08:12.468 - 00:08:56.388, Speaker A: They do exactly something exactly like this. They have a relayer that essentially takes all the transactions, bundles them together, pays for the gas on your behalf so that you have that sort of like web two experience, but you're still transacting on the blockchain. So a few other things that you can actually do with this are gas payments in non native tokens. So let's say I wanted to pay gas in USDC, I want to pay it in dogecoin, whatever it is. You can have all that set up as well. Using the same forwarder techniques. You can have limits and allow lists, so limits making sure that no one can abuse your gas list functions on the front end, as well as whitelisting and blacklisting addresses as needed.
00:08:56.388 - 00:09:41.956, Speaker A: Again for security and protection from abuse. You also get better gas estimation from biconomy. So biconomy is actually going to estimate all the gas for you. What we do is we make sure that everything is bundled in approximately 10% cheaper than what ether scan estimates might have cost. The way we do this is we're able to kind of stick to that 50% gas, and even if the transaction fails, the bundler will just automatically retry that for you so you don't have to worry about failed transactions. It's going to keep trying until it goes through. So if you want to check out a code example, I actually did a workshop specifically on this a couple of different times throughout this week.
00:09:41.956 - 00:10:18.480, Speaker A: That's bit lehakampiddle that is going to take you through. It has both a front end and a smart contract. Smart contract was written by wonderful folks over at Polygon. And what I did was take that smart contract and build out some gasless functionality around it. What that is, is just like this ERC 20 token where that can be earned by farmers. And rather than having the farmers onboard into web3 pay for gas, we help them out and basically make sure they don't have to do some of those things. So check that out.
00:10:18.480 - 00:11:17.724, Speaker A: It'll give you a little bit more to play around with as well. But coming back to why we started even talking about this, this whole concept of better user experience in web3. So when we talk about doing gasless transactions, we're essentially going in and making sure we're removing one big friction point for anyone who's brand new to web3. My parents, my grandparents are not going to want to figure out how to create a wallet, how to go to an exchange, do fiat on ramping, come to your dap it's just not a good experience for your end users, for your customers who are brand new. And at the end of the day, if you want your customer base to grow, you're going to have to go outside of our little bubble of web3. So the next thing we're going to introduce here is ERC 4337 or account abstraction, which recently went live on Ethereum mainnet, I think it was yesterday or the day before. So there's a smart contract that has been deployed on there to help enable some of this functionality.
00:11:17.724 - 00:12:12.516, Speaker A: But I'm going to show you a quote here from Vitalik. Achieve the key goal of account traction allow users to use smart contract wallets containing arbitrary verification logic instead of eoas as their primary account. So there's two types of wallets that kind of exist. You have your externally owned accounts like your metamask wallets, your mobile wallets or whatever, and then you have smart contract wallets, wallets that are basically given extra functionality using smart contracts. And one of the things that we talked about here is arbitrary verification logic. What exactly is that? If you think about the transactions we talked about before, other than the data that needs to be supplied to execute the actual transaction, you need things like the proper amount of gas, the nonce, et cetera. Once all of these transaction details are met, that's when the transaction actually goes through.
00:12:12.516 - 00:12:54.428, Speaker A: But what this kind of allows you to do is add additional constraints on top of whatever those are. Like, what if you want to take a look in your mempool and see, take a bunch of different transactions, bundle them all into one to save on gas. That's the one thing that you can do here. You can continue to do gasless abstractions as well. You can continue to ERC 20 payments, et cetera, fiat onboarding within your DAP. All of these things kind of like become possible because now when you're adding whatever additional logic you want, there's different things you can play with before actually executing a transaction. So it's a little diagram for account abstraction.
00:12:54.428 - 00:13:40.530, Speaker A: In a nutshell, the main things that we'll look at are key abstraction, gas abstraction and chain abstraction. So the user benefits that come from this is a smoother onboarding for folks who are web two native. You can integrate a sign in with Google, sign in with any social login, and automatically generate a brand new ethereum address for them just based on that sign up from their web two authorization. They don't have to create their own metamask wallet, they don't have to create anything new. So imagine like now you have someone completely new to web3. You created a wallet for them, you have a gasless abstraction for them. They don't need to do anything to start using your application right away.
00:13:40.530 - 00:14:34.512, Speaker A: Next thing on here was integrated fias flows. So adding the ability to pay by credit card, to pay for gas, to pay back credit card, for buying an NFT, all of these things become possible. Because now, again, with those additional constraints, that additional arbitrary logic, you can do whatever you want. This is all based on EIP four three seven, like I mentioned, which is called account abstraction. It's a framework that replicates the functionality of the current transaction mempool to a higher level system, right? So when we look at EVM code, it's used to implement both application and verification logic of a user's wallet. So you can initiate and verify transactions with AA. You're expanding the potential of additional UX designs, allowing users to leverage accounts at a higher level.
00:14:34.512 - 00:15:09.864, Speaker A: The whole point, really, the way I kind of look at it is like you're adding additional logic, giving users the ability to interact with your DAP in the way they feel more comfortable doing. So just giving them that choice. So again, just like kind of going through what we can achieve through account abstraction. Web three, social login was one of the things I mentioned. Fiat on ramping within your DAP, both gasless and paying gas on ERC 20. So the initial way that we looked at doing gasless transactions was through ERC two seven one. You can also achieve that through account abstraction.
00:15:09.864 - 00:15:45.284, Speaker A: You don't need account abstraction to do it, but it is something you can do. And then again, bundling multiple transactions together to save on gas. You can easily implement any of these use cases with our new biconomy SDK, which is specifically an SDK around account abstraction. You can get started at biconomy Gitbook IO. There are a few different tutorials on there. Natterdabit actually recently did a tutorial on how to use this for doing social login within your Dapps and creating the wallets. So definitely take a look at that and those examples.
00:15:45.284 - 00:16:08.540, Speaker A: There will be more workshops, tutorials and examples coming out very shortly as well, so we'd love to open it up for any questions. I know we kind of sped through this a little bit. I wanted to go over some code, but 30 minutes is not really enough time to do that. So would love to open up to any questions folks might have. Cool.
00:16:13.760 - 00:16:30.528, Speaker B: Yeah, great talk. I just had a question around the relayers. Are they all controlled by biconomy is there any risk or security issues? Like if byconomy goes down or gets sanctioned or something, is that a risk that developers would have to take on?
00:16:30.694 - 00:16:53.790, Speaker A: Yeah. So we are on the road to decentralizing that right now. It is centralized. You have everything kind of like put up by biconomy. We are working on putting out a relayer network so that you would be able to have more choices on that. Cool. Awesome.
00:16:53.790 - 00:16:55.260, Speaker A: Thank you all very much for coming to the talk.
