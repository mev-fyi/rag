00:00:05.980 - 00:00:20.944, Speaker A: Almost there. Yes. Cool. Thank you all for coming. My name is Felix. I work with cow protocol, and I'm here to speak to you today about what it takes to become a solver inside the cow protocol. And so this talk is maybe a little bit more on the advanced side.
00:00:20.944 - 00:01:25.476, Speaker A: It's not an insurance to cow protocol or cowswap, but I'll still take 2 minutes in the beginning to get everyone on the same page and explain what cow protocol is to begin with. So very fundamentally, you might have heard about cow protocol by another name, cowswap. And to differentiate the two, cow protocol is really the trading mechanism that underpins the UI, the exchange that we've launched, that is called cowswap. And now if you look at our exchange, you can see it looks very much familiar to uniswap. In fact, it's a UI fork of Uniswap with a small but fundamental difference. The fundamental difference is that we add a very thin batching layer on top of existing amms, which allows us to aggregate multiple trades together and execute them in a single Ethereum transaction. And what this allows us to do is if, for example, I am selling ether for USDC and somebody else is buying ether with USDC, roughly around the same time, we can just trade peer to peer.
00:01:25.476 - 00:02:59.528, Speaker A: We don't have to hit an external market maker, we don't have to hit an Amm. We can save on transaction costs, we can save on price impact on LP fees, and so we can, in the presence of these coincidence of wants, you wanting the opposite good of me in the presence of these cows cow, we can offer structurally better prices than existing Dex aggregators and existing AMM protocols. The batching comes with another nice side effect, and we'll talk a little bit about more how this works, because it's really crucial to this solver infrastructure. It comes with a nice benefit that cowswap in and off itself acts as a meta decks aggregator. So no matter which platform offers you the best prices for your trades currently on chain, Cowswap will make sure that we query prices from one inch, from Paraswap, from matcha, from the different protocols directly, and make sure that you always get the best execution across all these Dex aggregators. At the same time, it takes care of preventing your trade from being value extracted by miners, searchers, frontrunners, arbitrage in the system. So what cowswap does, it guarantees you as a user, it guarantees you a price which is decided based on a competition that I'll talk more about in the next slides, and then the risk of that price not being fulfilled because of maximally extractable value, because of front running or sandwiching is taken care over by that third party that executes the trade for you.
00:02:59.528 - 00:03:27.052, Speaker A: And then last but not least, because you're not actually executing trades yourself, but instead giving us an off chain signature of your limit order. Well, basically yes, an off chain message. You are not paying any gas for the trades that you're doing. You're still paying a fee. The fee is being captured in the sell token. So the token that you're already trying to get rid of. But there's no eth that you have to leak that you have to sell every once in a while when you're making swaps.
00:03:27.052 - 00:04:14.712, Speaker A: And another nice side effect of that is because you're not sending any transactions. Nothing that you're sending can fail. So you don't have failed transaction costs. So this is just a little summary slide of what cowswap does. Let's dive a little bit more into the protocol and see how it's fundamentally different from today's Dexes and Dex aggregators. So if you trade on ethereum or any blockchain, really today, what you're doing is you're sending a layer one transaction where you're telling the miner what exactly you want to do. You want to trade a certain coin for a certain other coin on this specific protocol, and you're passing that signed transaction to the mempool for the miner to fulfill, but in reality to usually try to screw you over as much as they can on cow protocol.
00:04:14.712 - 00:05:00.750, Speaker A: Instead, you are signing an off chain message which looks very much like a limit order, similar to the transaction, which also is a limit order on, for example, Uniswap. But instead of handing it over to the miner, you hand it over to this third party, which in other protocols might be referred to as relayers. But on car protocol it's called a solver. And then that solver can batch together multiple transaction, multiple intents to trade into a single layer one transaction and execute those trades in bulk. And so that can save on execution cost. It can have these nice coincidence of wants where we are trading peer to peer and reduce the amount of fees that we're paying to amms. But it also allows the solver to take care of mev protection and make sure that the miner cannot value extract you.
00:05:00.750 - 00:05:38.904, Speaker A: Now the kind of intuitive question that people ask is like, well okay, if the miner doesn't value extract me, how can I be sure that the solver doesn't value extract me? And so this slide is actually wrong. It's not a single solver that is processing your orders for you. Instead it's a network of solvers. In fact, what solvers are doing is they are competing for your order flow and they are proposing settlements to the protocol. And the protocol picks whatever solver has proposed as the best settlement in terms of global welfare. And we'll talk about what that means. It's basically price improvement for each individual order.
00:05:38.904 - 00:06:43.352, Speaker A: We'll talk about this on another slide. But really the key point to take away here is it is a network of solvers that are competing for your order flow on price. So the best price execution gets the right to execute your order flow on chain. So speaking of solvers, and speaking of the current status quo, what kind of solvers are there on cow protocol today? The very basic ones are what we refer to as single order solvers. So those solvers don't really make any use of the aspect that they can cross retail users with retail users directly, peer to peer. They just take every single order that's in the system and ask one inch zero x, Paraswap, Uniswap directly, balancer directly. How would you settle this order if it was the only one in the batch? And by virtue of having these type of solver, we are already a metadex aggregator because whatever solver from these four sources reports the best price is ahead in the race of getting the right to execute your order flow on your behalf.
00:06:43.352 - 00:07:42.770, Speaker A: Now of course we're called cow protocol, so we really want to make use of these coincidence of wants and look at these batches holistically and try to find overlaps, peer to peer trading opportunities. So a second type of solver that we run is a batched Dex aggregator solver where we still use the APIs or the underlying Dex aggregator protocols, but we look at each of the individual legs that are being taken one by one. Let me give you an example. If I were to sell GNO for USDC and somebody else were willing to buy balancer token with USDC, then on first sight there's no coincidence of once because we're not trading the same token. However, if you ask Zerox, how would you execute that trade? They might sell well, you take GNO to ETH and then ETH to USDC, and for the other trade you take USDC to ETH and then ETH to bell. So if we look at these hops individually, we can actually find a coincidence of once. And that is what the batch decks aggregator solver is doing.
00:07:42.770 - 00:08:52.420, Speaker A: This third type of solver then goes a little bit more into math heavy optimization. Because one aspect of these batches that we solve in cop protocol is that they are not just based on a single token pair. If you look at a batch, it can have many token pairs, many sell and buy tokens in the same auction. And so what you really want to do is you want to lift these two dimensional order books that you are used to from maybe your centralized exchange into a multidimensional space, and try to even find more liquidity by the virtue of ring trades. So, for example, if I were to sell ETh for dai, somebody were to sell dai for cow, and somebody were to sell cow for ETh on a just normal order book exchange, we wouldn't see that there's actually an opportunity for trades. But on cow protocol, we can trade those three orders in a ring and therefore re aggregate fragmented liquidity. And so our mixed integer solver, our mips solver, really just lifts all the limit orders we have into a multidimensional space, sweeps in some Amm liquidity, and tries to find the global optimum for surplus distribution.
00:08:52.420 - 00:09:42.840, Speaker A: In these limit order functions. The MIPS solver is a little bit restricted in the type of amms that it can work with. So it doesn't work well with Uniswap V three or curve. So we have an even more sophisticated math heavy solver that is running a quasilinear optimization problem, and that is able to also model basically arbitrary demand curves, arbitrarily complex amms and off chain protocols. This is just like an overview of the solver landscape today. And what I want to get at is that you don't have to be a math heavy expert or you don't have to be. These might sound a little bit intimidating, but if we look at the distribution of which solver actually wins the race today, we see that the pie is relatively evenly distributed, and that there's a lot of opportunity to grab a slice and grab a piece of cake in that pie.
00:09:42.840 - 00:10:45.192, Speaker A: So, about 40% of the trades currently are solved by zero X, just because we also still have a lot of batches which only have one order in them, however, one. And just catching up quickly. We've recently released a fix that makes them on par with zero x. But we can also see that our MIP and Kwazimoto solver also take account for about 30% of the cake. So there's a lot of opportunity that can be done by virtue of looking at trades holistically and trying to find cows. But even the other solvers, they're hovering somewhere between five and 10%, meaning that if you have some idea of improvement, some idea of how we can just make something we have today a little bit better, chances are you can actually grab a significant chunk of this pie. And so the question really is, why should you run a solver? What is in for you if you decide to take a step and run a solver for the protocol? Well, the first reason is that you will contribute to users getting better prices.
00:10:45.192 - 00:11:45.228, Speaker A: So you might be a user, maybe you're a protocol where you want to enable that. The protocol can trade on cowswap effectively, so you want to achieve better prices for your protocol users, but also if you're not altruistic enough for that, we are also working on an incentive program, which will hopefully come out next week or the week after, where we're going to start to reward cow tokens. So our project, native governance token to the winning solutions of each batch. So a solver can really be a business model. If you have an idea of how to achieve better prices for your users, you can really make it a business model and gain money from that. And for us, why it is really important for cow protocol? Well, of course, we care about our users a lot, but it also makes the underlying game theory and the underlying protocol much more robust against failure and abuse. Currently, most of the solvers are still run by gnosis, the company that our protocol has spun out of.
00:11:45.228 - 00:12:33.656, Speaker A: And so if there's a failure in the gnosis data center, if all solvers that gnosis running goes down, users are not as well protected as they should be. And so we really want a heterogeneous landscape infrastructure of parties running solvers for us. So let's say I've convinced you that it's a good idea to run a solver. What would you have to do? You want to compete in this competition? What are the rules of the game? These rules can change slightly. We're still trying to get the incentives completely right, but I think, by and large, they already give a good idea of what the solver competition actually does. So as an input, you are getting buy, sell, and limit orders across different token pairs from our customers, from our users. And those orders can be fill or kill or partially fillable.
00:12:33.656 - 00:13:22.476, Speaker A: They have an expiry date and they have a limit price. And then you're supposed to find a matching for these limit orders where demand equals supply. Of course, you're allowed to sweep in any external liquidity that you'd like, but basically, there are a few constraints that your matching needs to satisfy. The first one is that we enforce uniform clearing prices across different tokens that are traded in the same batch. The idea is that if I sell USDC for ETH and you sell USDC for ETH, if we're mined in the same block in the same batch, there should be no time priority for one of us. Because really this block happens at one atomic point in time. And the reason why mev exists is because miners can arbitrarily decide, okay, you go first, I go second, this guy goes third.
00:13:22.476 - 00:14:52.548, Speaker A: But we think that this time priority pricing within a block really doesn't make any sense for time discrete blockchains, which why on our protocol you really just have one price per token per batch. The second constraint is something that we call envy freeness, and it goes a little bit along the idea of not being able to censor orders that you might not want to match because you're trying to extract some value from another trader. Just as an example, if I were willing to buy ether at a price of, let's say, $5,000, and somebody else was willing to sell me the ether at $4,000, a solver would not be able to take my order and match it at, let's say, $4,500 because that would leave the person that was willing to sell it jealous and basically envious at the end of this batch because they say, well, if the price is 4500, I'm willing to sell. And so we cannot announce prices that will leave any of the trader jealous for not having been matched. But even if you fulfill all these constraints, there might still be multiple settlements that basically fulfill all the constraints. Then we need a judging criteria, or basically an objective criterion that allows us to maximize some value to decide what is the best solution. And here, I've hinted at this before, but here what we do is we look at the difference between the limit price that the user has announced in their order and the price, the execution price you are offering that user.
00:14:52.548 - 00:15:29.876, Speaker A: So if I was willing to buy ether at $5,000, you got it for me. At $3,500, I make a surplus of $1,500. And so if we sum up that surplus over all different user orders, that is the thing we want to maximize. Now, for completeness, we do discount the execution cost, especially on Ethereum mainnet. It's very expensive to execute routes and transactions. So if you just can get a improvement, it's probably not worthwhile to touch two or three more pools. So we offset that surplus by the gas fees and by the fees that the user is paying us for their order.
00:15:29.876 - 00:16:21.700, Speaker A: But by and large, the thing we want to maximize is the overall surplus across all user orders. So, to summarize, if you're running a solver, what is the input that you're getting and what can you do? We already talked about the type of orders you're getting, basically the sell and buy limit orders. We are also going to give you some idea of baseline liquidity that there is on Ethereum, like Uniswap V, two pools, sushi swap pools, balancer pools. Just in case you have no idea about DFI and about the protocols that are out there, you still have some base liquidity to work with. We then give you a price estimate for all the tokens that are traded inside the batch. And that is needed because we measure the surplus across all orders. But if I'm getting surplus in Dai and somebody else is getting surplus in GNO, we need to kind of, well, normalize that surplus into a common numerair.
00:16:21.700 - 00:17:28.972, Speaker A: And for that we use price estimates, and we can basically make sure that the surplus is measured across solvers in the same unit in ether, for example. We then also pass down a gas price, because as I showed in the slide before, if gas prices are really low, it might make sense to have a more complex execution, touch more external liquidity than if gas prices are really high. And so the solvers need to know what is the current gas price in order to optimize properly. And then we also give the solver a deadline, which is, I think at the moment, roughly 15 seconds. It might go down a little bit, but because we want to run these batches quite frequently, eventually, once per block, we need to make sure that solvers cannot take arbitrarily long time to solve these batches. So then let's take a look at the solver side. And what can a solver do where really lies the competitive advantage that a solver can take? First thing is you can add your own liquidity, and that is really where one inch matcha and ParaSwap currently gain points is, because they have a really good understanding of the overall defile system, they know all the new protocols, they can integrate them and index them.
00:17:28.972 - 00:18:51.060, Speaker A: So they really know a lot about liquidity. But even if you're a protocol that is new to the space, or you might be a Deegan that knows a lot about the ethereum ecosystem, you could, for example, integrate uniswap, e three or curve or some other liquidity, and buy this, try to have more to work with, and then do a better job at step two. Step two is all about the math, basically matching orders between one another, looking what is the axis that I cannot trade peer to peer that I need to go on chain for? And then basically using the liquidity we've added in step one to optimally settle that part. And then the third step, which is not really relevant today, but we are planning to enable it in the near future, is that if you were to win this competition, and if the protocol tells you, okay, go, you have the best solution, then you also need to be capable of actually executing that transaction on chain. And so for this, it's really important that you know what other trades ARe in the mempool, what maybe MeV protection mechanism exists out there using flashbots, using the Eden network. So it's really like these three pillars where a solver can compete. And even if you think you're of an advantage or you're good at one of them, it's probably worthwhile to kickstart a solver and take part in this competition.
00:18:51.060 - 00:20:10.176, Speaker A: Now, let me talk, I have 2 minutes left, so let me talk about the cow protocol architecture, which shows you where you can integrate a solver today. So we have the centralized component at the moment, which is collecting orders for users, and then we have another at the moment, still centralized component, which we call the driver. You could think of it like the auctioneer or the judge, that basically orchestrates the competition. So periodically, this driver will try to get all the orders from the order book, and will ask the fleet of solvers that has registered with him, what is the solution you would give me for that input file that I showed on the previous slide? And so you're getting the input serialize as JSON, and you're expected to give us a result which shows us which traits you want to settle, at what prices, and what are the on chain interactions that are needed for it. And then the driver will rank all the solutions internally, look which ones fulfill the constraints, look at the objective criterion, and settle the best one on chain. And so really, if you want to be a solver today, all you have to do is spin up an HTP instance that takes the instance JSON file, runs your code, and returns the result to our driver. In the future, we want to get rid of the driver component, so we want to have a batch that gets initiated every 30 seconds or so.
00:20:10.176 - 00:20:55.952, Speaker A: So the solvers themselves will get the auction data from our order book. They might even figure out themselves who is submitting, who announced the best solution, and they will then be themselves responsible for settling the transaction on chain. And so I'm unfortunately out of time, but we have a bounty at East Denver that we'd really like you to get involved in for $7,500. We have some more tutorials here from our community member on how to write your own solver. We have a more math heavy tutorial that goes really into the weeds of the optimization problem, and we have some basic ideas of what you could try out to have a good chance at winning the prize. In any case, we have a booth right next here in one of the corners next to the between the one team and the superfluid team. Please reach out to us.
00:20:55.952 - 00:21:04.060, Speaker A: Also on Twitter. We are at math protection, and if you see me around, I'm also more than happy to talk about solver stuff. Thank you very much for your attention.
