00:00:00.250 - 00:00:02.240, Speaker A: Generation contracts. Thank you.
00:00:03.170 - 00:00:50.410, Speaker B: So, hi, everyone. I'm Harry from Oasis protocol, and we're making confidential EVM. So I think first I should start with a little bit of context to show my perspective of how I'm thinking about this. So, with transparent EVM, we have a very basic function. You have the transaction that comes in with the previous state, and all of this is public information. It executes the contract, for example, and then it emits the new state and the events. So I'm starting with this, and then I'll get to what is confidential evms and how is it different and what can we do with it? I think first I'd like to go through a little bit of the history of how we got up to confidential EVM from transparent EVM.
00:00:50.410 - 00:01:59.986, Speaker B: So, yeah, if we start with the ZK protocols on EVM, they exist because of pain points. So these are like deficits in the protocol where you don't have enough transactions per second. So you want to do more transactions or you don't have privacy, so you want to make private transactions. And these were developed initially as roll ups and ZKE privacy protocols that ran on transparent Ethereum. So what we're really doing with the ZK stuff is we're using the zeronoge protocol to emit information. So in the example of a ZK roll up, this would be all of the signatures and the auxiliary information that you can be condensed down into the bare minimum that you need to replicate the chain, which would be like the account index that was the source of the funds, and the account index of the destination of the funds and how many funds were transferred. So likewise with a ZK protocol, the information you're hiding is which of the balances you're spending from.
00:01:59.986 - 00:03:02.770, Speaker B: But I think that the crucial point with zero knowledge in comparison to transparent EVM is that you do have privacy, but only if you're proving the ZK circuit. So for example, with roll ups, if you wanted to add privacy to a roll up, you have to find another privacy system that could work inside the roll up, because the prover of the roll up has all the information. So if we next move on to Zkebm, for example. So with a centralized scheduler, one of the main things that it's doing is to put together a batch of transactions. And really its only job is to prevent sort of read and write conflicts. So you might have a bunch of different contracts that read from the same state. So be that like uniswap price or some sort of Defi protocol, and it serializes the order of the application of the contract.
00:03:02.770 - 00:04:21.514, Speaker B: So that if you have two contracts that modify the same keys, they need to have a consistent view of this so you don't get overlapping conflicts and stuff like that. So the problem though is that with the scheduler, this ends up being a sort of very centralized aspect to it. And if you want privacy, you still have to add an additional layer of privacy to hide that information from the scheduler. But with Zkevm and privacy, I think this is something that's sort of underutilized at the moment. So if you look at being able to provide a ZKevm proof to a ZKevM contract, that as long as you don't do anything with your contract that would cause a storage conflict forever, then you could potentially do as much computation you want in private, give that to the Zkevm sequencer, and then that would go ahead and schedule that with the rest of the transactions. And as much as I like Zkevm, I don't think people are really taking full advantage of the confidentiality aspect that's possible at the moment. But really, I'm trying to get at confidential EVM.
00:04:21.514 - 00:05:10.350, Speaker B: So we have ZK, it can do privacy, it can do roll ups. We also have multiparty computation. So if you want to have a third party that signs something for you or keeps something secret, then really there's only sort of three different options. Either you have something that's private and you provide a proof that shows that you know it, or you have an NPC protocol that keeps it private for you. And that means that, for example, it would only sign a transaction if it was built into the protocol. But they're both quite sort of technically complex. So with both ZK and MPC, you end up with these very specific use cases where to do it quickly and efficiently, you have to minimize the amount of functionality you have.
00:05:10.350 - 00:06:22.994, Speaker B: But if we look at a trusted execution. So this has kind of the benefits of multiplied computation where you can have, for example, a contract that has secrets from everyone else and does delegated signing. And you also have some of the aspects of ZK snarks as well. But without the proving time or without the multiparty communication overhead, means that it's kind of like the sweet spot is confidential trusted enclaves where you can use them as an honest third party. So I think there's like three modalities where with confidential EVM, I'm really saying that this is a slightly different way of attacking problems. So with ZK, there's lots of different novel ways of solving problems that you have to sort of work around the semantics of how it works. With a transparent EVM, you also have the similar kind of problem where you have to figure out, how do I make this into a smart contract? How do I make this sort of fully autonomous and interactive? And I'm looking at the confidential EVM as being a new problem space where there legitimately are very different ways of thinking about this and the ramifications that has on a defi ecosystem.
00:06:22.994 - 00:07:30.606, Speaker B: For example, we do have a confidential EVM in production, and it's been running for the past year or so in Mainnet. And yeah, it's sapphire, so this is our product. But if I wanted to define what confidential EVM is, so really it's something in the middle, it's the trade off, right? So you don't have the proving overheads of ZK circuits, you don't have the overhead of message multiplied computation, but you do have unobservable execution. So you can have any contract that can execute in private, so all of its state is encrypted. You may have end to end encryption between the user's DAP in the browser and the smart contract itself. So unlike with normal EVM, you could have password authentication, so you could put secrets into the contract, get it to operate in private against encrypted data, and then that can emit public events. So it's a new way of thinking about it.
00:07:30.606 - 00:09:37.080, Speaker B: So for example, you could choose the different types of things that you want to be private and you want to be public. And because it's all solidity in EVM, you could do this at runtime. So instead of having like a pre configured circuit that has a, it's not very flexible, you could load in whatever plugin you want that could do queries against its own confidential data and decide in privates, like is your authentication sufficient to use this contract, or maybe releasing audit information in a public event log? And really this comes down to what can we do with this? Where if most of the stuff in the real world is a mix of public and private, we can start thinking about how do we make, what information do we really need to be public, and what information do we really, really need to be private. So, for example, if you're looking at the social graph, and I know there are some messaging systems on Ethereum, there might be, who interacts with the decks? And you could say, specifically, I want all the information to be public, but I don't want people to be able to discover my transaction history, or I don't want people to discover who I'm interacting with. So on a case by case basis, you can decide in your application, do I want to make this public or private? And an example we have here is like account abstraction. So if you have a confidential contract that can have its own secrets, then I could create a bitcoin wallet or an Ethereum wallet from the contract and ask the contract to sign for that. So it's not just about privacy, where if you have a secret that you can't let out, like you don't want to give everyone your private key to your wallet, then this is like a new piece of functionality that you have to avoid people from extracting secrets from it.
00:09:37.080 - 00:10:41.974, Speaker B: An example of the different type of thinking you'd have is if you have two blockchains. So if all of the blockchains that were EVM compatible were also running in trusted execution, then you could have two contracts on different chains that each trust each other's public keys, and they could sign messages for each other. So instead of having a bridge and yet another consensus protocol to verify the block state on both of the chains and shuffle the messages across, you can get rid of that extra piece of infrastructure and just use the users themselves to relay the messages, because it's trustless. So if you have two contracts that can encrypt data for each other and they can sign this, then it's tamper proof, it's verifiably from the correct source. You can enforce things like sequence constraints, and there's nothing the user can do to modify that. But you also cut out a lot of the extra infrastructure that is no longer needed. An example here is like private voting.
00:10:41.974 - 00:11:53.762, Speaker B: So we made a demo to present a couple of days ago to show, well, how can we do something that most people seem think is pretty complex. So there are a lot of different projects that are doing private voting, and we thought we want to have someone be able to make a spicy opinion poll for their Dow. So anybody could come along and use like the Ethereum blockheader storage proof to show that they have an account balance in a specific contract without revealing exactly which account they are, only that they're a member. So if you were to do this with a multi party protocol system, or like a ZK circuit, doing Ethereum storage proofs in a ZK circuit is not trivial. It takes a lot of time to prove you need to implement the ketchak function in zero knowledge. And this could take like a couple of minutes, maybe two minutes to actually create the proof to show that I am an anonymous Dow member, but with just plain solidity, you just verify the storage proof. So there's a lot of code for this, and it's really straightforward to do.
00:11:53.762 - 00:12:53.538, Speaker B: And because it's just solidity, I'd say it's like 15 times quicker than doing the equivalent with ZK, because you can use the standard solidity stack. Another thing is, well, you could also do something similar to ZK roll ups, but with trust execution environments. So if you have a contract that can sign things, that means that it can verify that it gave you something before. So an example I have is like a bitcoin lite client that's running fully in view calls. So that means you don't have to make any storage writes at all. If you have the previous block header that was validated by the light client, it can sign that, and it can also sign, for example, that I have signed 4000 blocks in a row without ever making any writes or storage updates. And then I can give that latest block header to anybody.
00:12:53.538 - 00:13:50.866, Speaker B: And the fact that the contract has seen the previous 4000 blocks means that I don't have to replicate that information. So, similar to ZK roll ups, we're doing computational compression with a proof of authority. But in this case, the proof of authority is like a trustless, decentralized smart contract. But yeah, it's not a free lunch. So if you look at the kind of security problems we had with solidity and EVM, when people were first making contracts, and there's the entire security industry in the blockchain space now, reentrancy was a problem because it was something new that we hadn't thought of. But with confidential EVM, you also have quite a new set of considerations. So if you have the contract that's executing in private, that not even a node operator can see what's going on, it does have these side channels.
00:13:50.866 - 00:15:16.382, Speaker B: So for example, you can see how much gas it consumed, or even though you can't see the content of the message, you can see that the message, the call data input is of this length, or that the gas payer is paying for this, or they're interacting with a specific contract. So yeah, if you look at like electronic engineering, I think you have to start thinking about if I'm doing cryptography in constant time for some kind of high assurance, low level implementation. You do have to start thinking more in that mindset when you're developing confidential contracts, because you have to be protecting against malicious users more than you would do on transparent EVM. For example. So the interesting point is, with confidential EVM, you might not need a lot of this other infrastructure. So if you're trying to keep the user's token balances private, how do you discover what kinds of tokens you have? So with Ethereum like Polygon, you'd go and look at one of the indexes, there'd be something that monitors all the token transfers, but with confidential EVM, you might not be able to have this indexer. So how do you get this information? How do you make it easy for users to use the confidential contracts? And a lot of this comes down to, well, you have to query the contract.
00:15:16.382 - 00:16:08.370, Speaker B: So instead of just having a token, you need a token registry, so you can register the tokens that each user has. Or if you want to iterate through, say, the last transactions or the last set of orders, you have to implement this in the contract, because only the contract can query its internal state and do the lookups for you. And that also means that you also have to be sure that people aren't impersonating you. So for example, on Ethereum, I can simulate a transaction from anybody to any contract, and I can see how that would play out. But with confidential EVM, you obviously don't want someone else pretending to be you. So again, there's a small cascade of subtle differences when designing contracts on confidential EVM that you have to think of. And one of those is authentication.
00:16:08.370 - 00:16:41.040, Speaker B: Do I have a login like I do with Gmail, that I then use this token to look at my emails? But I could also give that to other people, so I could give somebody else a permit to view my data for a limited amount of time. And instead of using message sender authentication, they would have to use alternate schemes that give you finer grain access control. And yeah, that's all I have to say today. So if you have any questions, you can come and talk to us. And thank you very much guys.
00:16:45.730 - 00:16:54.430, Speaker A: Harry, that was great. Give us a couple of minutes and we'll have the next talk ready.
00:16:56.400 - 00:16:57.720, Speaker B: Yeah, it's fantastic.
