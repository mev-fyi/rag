00:00:13.050 - 00:01:03.140, Speaker A: Today we're going to talk about ERC 20 misbehaviors. So how as you know, almost every project in the ecosystem use ERC twenty s and there are a lot of issues that might happen with that. So we're going to try avoid that with this presentation. So I'm Sergi, I work at consensus diligence as a security auditor. So let's dive into ERC 20. I hope everybody knows what that is, but let's just remind it that it's like the most common token standard with the minimalistic functionality. You have only what you need transfers approved to transfer from you, like check balances and the most useful things for you.
00:01:03.140 - 00:02:06.834, Speaker A: But there are different ERC 20 extensions that people are making like ERC 223 or ERC seven seven that has callbacks to receivers, senders, or just random contracts and different other options. How you can do callbacks also like lots of security tokens. The most popular lately was like your C 1400. They allow you to do partitions, lock in part of the funds for vesting, make KYC whitelisting anything. So it's like huge frameworks with many modules and bunch of custom implementations like minimi with history of balances, you can easily clone the token and create a new smart contract with the same balances at some point in history. Some tokens with approved call functionality so you can approve and call some functions that makes transfer from in the same transaction. Some tokens are just controlled by centrally controlled by some authority.
00:02:06.834 - 00:02:38.190, Speaker A: It can be stopped or transferred or anything. So a lot of different custom implementations might be here. Before I dive into intercommon issues. These issues are mostly relevant for projects that are working with different kind of random tokens. Like exchanges, investment funds, they try to invest in different tokens. Sometimes they are whitelisted, sometimes they just do anything. If you're working with your own simple ERC 20, that might not be that dangerous for you.
00:02:38.190 - 00:03:01.622, Speaker A: So the most tricky and interesting attack that I see in ERC 20 is rentrancy. Just to remind what rentrancy is consolidated. Just told a little bit about it. But this is like example for tokens. So you see three functions, transfer from maketrade and token to send. They're located in different contracts. So the attack flow is simple.
00:03:01.622 - 00:03:34.058, Speaker A: It's pretty simple. This is like exchange example. So sender makes a trade by calling maketrade function of the exchange. Inside of it, token transfer is happening. So inside of this token transfer, if this is for example Rc seven seven, there is a callback function to the sender. After that sender can make one more trade by calling make trade function of the exchange. So basically you can make one more trade before first trade is finished.
00:03:34.058 - 00:04:23.662, Speaker A: And you can do it with an alt price, for example, if it's automated pricing or do a lot of things that are not intended to be. There are also different types of rentrancy for tokens, for example, depending on who can do this rentrancy attack. So this is either the sender of the token or receiver or some third party contract like KyC provider or something like that. And the second criteria is when it can be used. It can be used either before or after valid transfer, which is also important because if you're making token transfer as the last line of your function, and it's already made, then rentancy wouldn't really do anything. It's like almost function is almost over. Interesting example of this kind of attack was with Uniswap.
00:04:23.662 - 00:05:00.780, Speaker A: So this is like very famous exchange. You all probably know it's totally automated. Basically the previous example was showing Uniswap attack, but with different function naming, but the id is pretty much the same. So this kind of exchange stores equally eastern tokens in its smart contracts. And it was interesting, it was already live on the main net, so it's kind of hard to migrate to new versions. So this bug is still happening with ERC that allows some kind of rentrancies. Basically ERC seven seven is not supported by Uniswap for that reason.
00:05:00.780 - 00:06:03.950, Speaker A: So because of they don't have rentrancy protection, you can do one more trade inside previous trade with the old price, basically having better and better price over the rentrancy. Then you can make it trade back and just earn free money out of it. So what you do with rentrancy in tokens as in any other place, you just use Openzeppelin's rentrancy guard, which is pretty good right now. You can use non entrant modifier, and after later updates it become more cheaper because recently it was like 10,000 gas for two storage store functions. Now it's got cheaper formula is pretty complex, but it is cheaper. But also you make sure that you only use this non rentrant modifier where rentrancy is not intended. Because with some multisig wallets or voting contracts you can actually want to have the rentrancy.
00:06:03.950 - 00:07:30.618, Speaker A: And also make sure that non rental modifier is called every function that is relevant not only in functions inside of which you can do rentercy, because from the function you can do rentancy and call another function which you might consider it safe, but it's not because it also might change state and make some unintended behavior which lead to random results. Even if you know that, even you make sure that rentrancy is not an issue for some reason, either you add rentrancy protection or something, you still need to understand that when you do the token transfer, it's not enough to just have enough balance and permissions like approvals to do the transfer. Transfer can still fail for many different reasons. For example, your user or even your exchange or anything can be blacklisted or some other KyC reason why you cannot use this token. For example, USDC can blacklist anybody and you need to be prepared for that. Some tokens can be just locked for vesting or for some other reasons. Sometimes tokens can be really gas costly, and if you make multiple transfers in the same functions, it sometimes might also run out of gas.
00:07:30.618 - 00:08:26.490, Speaker A: Even if you limit it to few things, it might still be pretty expensive and lots of tokens are pretty much upgradable. Maybe not tokens, but as you see in this example, controller is like separate contract that approves some transfers and it's usually upgradable by the owner. So what do you need to do to make it safer? You can isolate all of your transfers not to do for loops. Avoid batch transfers. So if you have transfers in a for loop, one of it might fail and it can block all of your pipeline and just maybe block the contract freeze funds. So basically just use pool pattern for all the possible token withdrawal wherever you can do it. One more interesting issue is balance overflow.
00:08:26.490 - 00:09:10.570, Speaker A: So you would usually expect that total supply is not overflowing. And if that happens, if balance is more than you int to 56, that usually means that token is either malicious or broken or both. And this token's price would most likely be worthless. It would be zero. But still, if you're working with lots of different tokens, for example, in this example, you're assigning awards and you have a for loop to you're not making transfers, so you already took care about my previous recommendation. You do not do transfer, but you store balances so people can withdraw them. But sometimes people still do it in a batches like that.
00:09:10.570 - 00:10:04.000, Speaker A: And if one of the token is broken, this line of code will just revert because safe mass ad would revert because of the overflow. And because of that you might just freeze your pipeline. And all these tokens that should be assigned, they are locked forever and might be lost. So this is not a good behavior and possible remediations would be either just ignore safemass and allow overflows. So this is not a traditional advice because we usually advise you to use safe mass and just not allow any overflows. But sometimes it's the easiest choice how to fix it. Or you can sometimes store balances in two uintra variables to allow much bigger values, but that's like a huge cost of doing that.
00:10:04.000 - 00:10:50.070, Speaker A: Also, this was an interesting issue in the past, that sometimes some tokens are just not ERC 20 compliant. So the original implementation should return like every transfer. Transfer from should return, true, but there are some tokens that just doesn't do it. As you can see, the last function is a brown implementation of token transfer. For example, binance token is like that, and there are like hundreds of tokens that also have these implementations. And the thing is how people use it, like usage function that you see here how people use it, it will just revert. That wasn't a problem initially.
00:10:50.070 - 00:11:54.526, Speaker A: That's why we have so many tokens, because before one of the hard forks it was fine, it was always returning true and nobody noticed it. But after one of the hard forks something in EVM changed and now you basically always have false. So yeah, make sure that if you want to work with these kind of tokens, you can check if it's returning value or not and work this out. If not, you can just also ignore it. But should you be aware of it if you're deploying your own token? So sometimes people want to try to do your c seven seven tokens and make something more complex. But you need to also understand that some of the major projects might not just support it because they have bugs that do not approve any kind of rentancy. Also consider making rentrancy protection inside tokens.
00:11:54.526 - 00:12:38.160, Speaker A: So some projects are doing that if they're having too complex code, so they are just having rent receive protection inside. It doesn't really matter if other projects that are using it have this protection or not. Also make sure that gas cost is optimized, because in many different projects people assume that transfers are pretty cheap and they do it in batches still. And if you want these tokens to be traded like this should be major point of your attention. And again, make sure it complies to RC 20. Yeah, if you have any kind of questions, contact us. So yeah, question time.
00:12:38.160 - 00:12:45.340, Speaker A: One, two, three. Cool. Thank you very much.
