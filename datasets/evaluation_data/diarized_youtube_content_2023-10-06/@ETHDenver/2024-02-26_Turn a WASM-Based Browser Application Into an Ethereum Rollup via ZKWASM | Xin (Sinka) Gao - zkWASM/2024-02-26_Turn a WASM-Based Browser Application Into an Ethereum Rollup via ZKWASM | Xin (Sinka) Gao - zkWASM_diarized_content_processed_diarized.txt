00:00:07.930 - 00:01:12.286, Speaker A: Okay, thanks for inviting today I'm going to actually demonstrate a way to build web two applications, especially browser web two applications using CK virtual machine and in particular CK webassembly virtual machine that built by the Daphne's lab. And I was the founder of Daphne's lab and the main contributor of this CK virtual machine. The agenda of this talk is split into five sections. At first place I'm going to introduce a little bit about the webassembly bytecode and then I will going to introduce the way to integration of CK webassembly emulator with browse applications. And then I will demonstrate how to develop a tiny fully on chain game on top of our virtual machine. And by demoing that I'm going to introduce a standard programming model. It's called MVC which perfectly fits our architecture.
00:01:12.286 - 00:02:30.390, Speaker A: And then I will introduce our proving service which is webassembly, CK virtual machine cloud. Okay, let's start. So what is webassembly? Webassembly is an instruction set architecture which is a binary encoding format that can be run by Webassembly virtual machines on any hardware or software that supports this ISA and especially this can be run in browsers. So which leads to our current discussion about how to actually port a webassembly application browsers into a CQ webassembly virtual machine application. And so far the webassembly bytecode is now supported as backend for most of the traditional languages. For example Javascript, C, C, Rust, Swift can all be compiled into Webassembly and it runs in the browser. Okay, so what we can do using Webassembly in the browser, I mark all these orange color titles to be the applications that we are interested at.
00:02:30.390 - 00:04:17.498, Speaker A: So we can build peer to peer applications, especially games in a browser and building music applications, streaming and cache applications in browser. Also scientific visualization and simulations in browser and definitely fed clients for enterprise applications, especially database and database services in browser and outside browser we can use Webassembly to dispute game services and build hybrid native applications on mobile devices and symmetric computation across multiple nodes. For example substrate utilize webassembly virtual machines to build their chain facilities. And how webassembly can be used in browser applications is that modern web browse applications and browsers these days can natively support rendering webassembly. That means we can use webassembly and invalid webassembly in the browser as the main logic and the UI and UI UX remains retaining JavaScript and HTML. So today my main target is trying to demonstrate how to separate the logic of a browser application so that we can replace the logic, the main logic, with webassembly and then run webassembly, our secure webassembly virtual machine, to generate trustless computations in a browser. Okay, before we have introduced about what is webassembly bytecode and how we use that in the browser, now I'm going to introduce a little bit about CK webassembly.
00:04:17.498 - 00:05:01.390, Speaker A: The CK webassembly is a CK virtual machine that supports webassembly bytecode. It has three main functionalities. First, it actually runs webassembly bytecode and generates results. And second, that it generates the same result as other webassembly virtual machines just like the browser did. So that means it generates the same result as the browser did for Webassembly. And third thing, that the CK webassembly virtual machine not only generates the result, but also provides the CK proof which actually proves the correctness of the result of execution of a wasam binary. Okay, and this is a brief of the architecture.
00:05:01.390 - 00:05:58.240, Speaker A: So to integrate a CK virtual machine in a browser application is a little bit subtle. And I'm going to review the classical application architecture of how we build a Web 2.5 application in old school way. So first we can see that the applications run separately outside the blockchain. If you actually run application in the browser and the application triggers on chain data modification, and then this onchain data modification gets assigned and posted to the blockchain. This is a very efficient but less secure way to do applications because all the computation in the application side is not trustless. Right.
00:05:58.240 - 00:07:16.310, Speaker A: It depends on some centralized servers to actually sign the transactions and sign the logic so that it convinced the onchain contract that a certain kind of logic has been carried off chain. Okay, how to make this architecture a little bit more secure? The idea is that we would like to put everything on chain for the first try. Would like to put everything on chain. So after that the architecture will look like this, which we embedded all the logic on chain. That means if you would like to do a complicated UI UX application, you have to sign all the transaction. Every time you modify and play a certain application, for example a game, you move right, move left, every movement you have to sign that, and then you load your transaction to onchain and update the onchain state. The problem of this fully on chain application structure is that it's not very efficient and it actually involves lots of signature, which actually triggers lots of gas cost, which is definitely not fit for certain applications like gaming.
00:07:16.310 - 00:08:36.970, Speaker A: So our application, our solution that we still would like to have an effect of trustless for the on chain application. But we're using the CK technology which actually transforms the logic part not on the blockchain, but in a CK virtual machine. So that in a CK virtual machine, every time we interact with the application, we emulate and prove the result in the CK webassembly virtual machine. And then push the state diff with proof to the blockchain and do the settlement afterward. Afterwards, okay, so regarding this architecture, I'm going to demonstrate how to do that, because at first glance people might think this is too complicated, but actually it is pretty simple if you're using the correct tooling. Okay, I'm going to demonstrate a small card game which runs in our webassembly application sandbox. And here we are going to load a small game which is a very dumb trivial card game.
00:08:36.970 - 00:09:35.156, Speaker A: On the left hand side I'm the player, and on the right hand side is the monster that I'm going to defeat. So just imagine that in our web 2.5 world, this logic is running off chain, right? Untrustless run off chain. And every time we play a card like we strike, it actually decrease the HP of the monster and it's calculated off chain. But what's the difference now is that we not actually only run this in a browser environment, we also run this in a CK webassembly environment, which is the sandbox of this demo. So that if we perform lots of transactions, you see that we are not going to sign every transaction all the time, but every time we click anything and play and click anything, this is run. Sorry, I get killed.
00:09:35.156 - 00:10:33.084, Speaker A: But anyway, this actually finishes a game. So it might involve lots of transactions, but we are not going to sign all the transactions during the play. But what we do is that we have a sequence of user inputs. And because this game can be run in a CK webassembly virtual machine, we can generate a proof for the game. For example, we can submit and generate a proof. So if I click confirm it signed all transaction for me, and then push the execution trace to a proof generator which actually generates the proof of the gameplay to a cloud proof generating service. Okay, so it's actually loading us.
00:10:33.084 - 00:11:53.060, Speaker A: So this is the new tasks that we have just submitted. And this cloud CQ webassembly proving service will generate a proving for our gameplay. And after we get that proved, it might take a few seconds, maybe 10 seconds or 30 seconds to maybe take longer. It depends on the trace and circuit size regarding how much time it will consume. So once we have done a proof, it has been done. Now once we have generated proof, we see that all the inputs actually represent the gameplay that the users have performed on this game. And we generate a CK snark proof which can be used to convince the on chain contracts that this kind of game is executed in our CK Webassembly sandbox and the execution trace and the result and the reward is somehow calculated securely and trustlessly.
00:11:53.060 - 00:13:13.420, Speaker A: So we can use this proof to verify on chain select a chain. Let's see this one. Sorry, maybe I have to connect to my wallet. Okay, so we can actually verify this proof on chain and do some kind of settlement confirm do the settlement and you can somehow automating your settlement contract to decide what kind of reward you are going to give a player after he have finished a long sequence of gameplay. For example, you can design a game which is salg and after 1000 steps of gameplay you can give him some rewards. And this contract demonstrates about how we can coding the callbacks once approved has been accepted. For example, if someone would like to give a token transfer, if someone has finished a very good gameplay, he can write a verify function which actually verifies the proof at this place and then call the side effect function.
00:13:13.420 - 00:14:22.890, Speaker A: And based on the core data that the user has pushed to the blockchain, he can decide what rewards he could pay the player. So these side effect callback functions are the key to actually reward the user or give feedback to the user. And there are several good points of using this architecture. Firstly, you do not have to sign every movement of your gameplay. And the second thing that it's very smooth. And because it's running natively in the browser, that means you can coding a web three, application just like you're coding a web two application you can using JavaScript Rust C c Plus plus and then compile them to the webassembly and put your game straightly on a browser application, WordPress in any kind of cloud service and run the game. Ask the user to play the game, generate a trace and generate a proof.
00:14:22.890 - 00:15:39.442, Speaker A: Because all the execution is performed in a CK virtual machine, there's no security issue, right? And there's a small subtle thing that at the beginning I ask you to log in your wallet and assign an address, which means every time you play a game, you log in with a local generated signature and this signature will be verified every time you push the proof to the onchain verifier, so that no one can actually fake the gameplay and get your rewards. Okay, so this is a complete front end demo about how to use the webassembly virtual machine and embedded your application in the browser. But there's another part, it's about how you actually coding your application, right. The coding application is not just putting the sandbox and adding some code just straight in the browser HTML. Right. You have to coding your game logic in a webassembly. That means you have to pick a language that can be compiled into webassembly bytecode.
00:15:39.442 - 00:16:26.418, Speaker A: The alternatives will be the Javascript, the typescript, the assembly script, definitely, and the CC plus, plus the rust. In this demo we use the rust as our development language. And let's see how the game is developed. By the way, when we're actually developing this demo, we're using architecture called MVC, which somehow separates the view and the model. And what we are interested is that we would like to run the model and the controller in the webassembly virtual machine, but not our view. Right. Because the view is a representation of the model itself and has no point to actually prove the view for the on chain verifier.
00:16:26.418 - 00:17:54.240, Speaker A: So we mainly focus on the model and the controller. Okay, here is how we code in the game. Let's first see the make file, because the make file sketch out the deployment of our gaming. This time we see the first line is the compiling command that actually compiles our full code into a webassembly package, right. So after we compile this, after we compile this, we see that in the package folder we have our target files. It contains the main webassemblies and the type definition of our webassembly and the loading script that we can use to load the webassembly in the browse application. So we copy all these files into our reactor web application.
00:17:54.240 - 00:18:51.624, Speaker A: We copied it here. Okay, we copied it here. And after that we coding the controller using a tool called react. It's pretty simple, you put some buttons and add some on click event handlers for the controller, which gives you some kind of callback. When you actually click this button, click, okay, so when you actually click this button, it, I think it picks a card right here. You click a button, it picks a card. So what does the pick card mean? Because this is a controller, right.
00:18:51.624 - 00:19:22.624, Speaker A: It has to call and interact with our webassembly. So that means this controller will eventually call into our webassembly code. And this pic card looks like this pick card, right. And see this in it as any. And this is the webassembly that we have loaded. This is the webassembly. So the pick card means you somehow get the handle of the webassembly you have just loaded and you play a card while you play a card.
00:19:22.624 - 00:20:17.616, Speaker A: It's pretty easy, right? So now this demonstrates that how we can load and interact with the webassembly image in our browser application. Okay, now the most interesting part is how we coding the webassembly. So how we lay out and coding the webassembly so that it becomes an interesting application for the applications that I am demo at the moment is a simple application, right? It has a global state and some activities that I can perform to actually change the global state. And if actually I win, I can somehow generate a proof and tell the onchain contract that, okay, I have win this game. Please give me the reward. Okay, so let's see how the game is coded. Because all this webassembly has to be run in a CK virtual machine.
00:20:17.616 - 00:21:33.206, Speaker A: We have to specify entry point of the image, and this entry point looks like this. The entry point calls the CK mine. It's just relevant to a main function, but we call the CK mine because the CK virtual machine will run this and generates a proof of this entry function. And besides the core command handler, we have some signature handling stuff which asks the user to actually sign the contract when they have finished a bunch of play. The core feature is that we perform the command in the loop, right? So in the loop we somehow collect the command from the user. That means every time we click a button, the handler will somehow transform the command and transfer the command into the webassembly handler. And the handler will actually catch this command and perform the state transformation internally in our rust code.
00:21:33.206 - 00:22:25.670, Speaker A: So that means, just remember, in the rust code you have a large global state, and the handler actually performs all sorts of commands and change the global state. And every time we somehow change the global state, you still have to render the user based on the global state that you have changed. So that gives another issue that we have to face, which is actually get information back from our webassembly code. So somehow get a global state. And this is pretty straightforward because we can transfer the global state as JSOn to the UIux. You see that? Okay, here is the global state. We have lots of features like how many cards it has, and if I can just play one card, I get another global state.
00:22:25.670 - 00:23:23.180, Speaker A: So the procedure will be I play a card which actually triggers a command and then which invokes a webassembly application. The web assembly application somehow handles the command, performs the command and change the global state. And now the UI UX somehow received the global state back and then render the application again. After several play you reach a global state which is stable and you can say okay, I have finished my gameplay. At that stage there's no signature happening, right? But if you're happy with the gameplay, you can somehow generate approve, just like what I've just done before, I think ten minutes ago. And at this place we somehow signed gameplay and generates a proof from our webassembly cloud. Okay, see there's a new proof generating at the moment.
00:23:23.180 - 00:24:32.750, Speaker A: Okay, that's the whole story of the game development. And after that I'm going to introduce a little bit about our CK Warsam cloud because we have seen that once we have finished the gameplay we need some kind of proving service somehow generating proof for the CK virtual machine. And you can run a CK virtual machine locally, just download our GitHub repo and set up a local server, it's fine. But for the cost effectiveness you might would like to integrate with the on chain stable service so that you can submit your image, a game image to the cloud. And every time you would like to generate a proof, you ask cloud to generate the proof for you. And this is the Webassembly image hosting and proving service. And it's pretty simple to actually uploading an image to the cloud service, which is just a one line code, we call it publish.
00:24:32.750 - 00:25:52.070, Speaker A: It's pretty simple, you download our SDK and connecting with our cloud CK Wortham service and provide the webassembly you have just coded and would like to play in your browser. Specify your private it is recorded. Okay, and then let's run that. So because I have already run this script before, so it will give me an error that this webassembly image has been uploaded already. But if you have not actually uploaded this image, it will give you a webassembly MD five code and you can use this code and inject this code into your configure so that the gameplay can somehow know which image you are regarding to, when you would like to generate a proof. And this is done in the configure file. So just copy that md five to this configure file and you will get this small on chain fully trustless off chain game for web three.
00:25:52.070 - 00:26:01.100, Speaker A: Which means in theoretically you can turn every web applications into web three trustlessly using the webassembly ck virtual machine. Thanks.
