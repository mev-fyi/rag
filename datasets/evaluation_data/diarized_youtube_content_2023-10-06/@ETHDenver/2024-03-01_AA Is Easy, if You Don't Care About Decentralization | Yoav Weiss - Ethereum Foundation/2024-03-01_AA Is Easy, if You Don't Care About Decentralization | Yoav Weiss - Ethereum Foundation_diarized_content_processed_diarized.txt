00:00:00.250 - 00:00:17.280, Speaker A: Hope you're doing well this morning and I wanted to welcome our next speaker. We have Joav Weiss. He's a security researcher with the Ethereum foundation, and his talk is titled AA is easy if you don't care about decentralization. Thank you.
00:00:20.410 - 00:01:00.950, Speaker B: Hi everyone. So many of you probably heard me talk account abstraction before, and usually I talk about use cases, but I often get asked about the complexity of ERC 43 seven and why does it have to be so damn complex? So today I'd like to say a few words about that. Of course, we won't be able to go into the full depth of the protocol, but I want to give you a glimpse. Now, before we start, let me tell you a little story about a monkey. So I have a monkey NFT. I really like it. It's a really nice monkey, but it's worth a lot of money.
00:01:00.950 - 00:02:03.434, Speaker B: So I want to sell it. And I'm asking myself, why do I need Ethereum, this complex blockchain in order to trade my monkey? There's like complex data structures like Merkel trees. We have many staked validators with slashing conditions, and we have a complex DHT protocol for peer to peer communication. We have multiple client architecture. Why do we need all that? Why don't we just use a centralized web server and get it over with? Well, it turns out that the answer is that if we are serious about the monkey being my monkey, then we do need this complexity. If I was okay with trusting some server operator who may decide to take my monkey or to prevent me from selling it to someone, then I wouldn't need a blockchain. But it turns out that we value that.
00:02:03.434 - 00:02:40.082, Speaker B: The community values things like self custody and censorship resistance. So with that, let's talk about accounts. So smart accounts are basically smart contracts that let me implement functionality into my account, my on channel representation. But there's a problem with an EOA. I can communicate with the network, I can transact on the network directly. The EOA pays for the gas. I mean, I just sign a transaction, the EOA pays for the gas and stuff gets executed.
00:02:40.082 - 00:03:38.010, Speaker B: With a smart account, it doesn't work that way. And you need a funded eoa that will sign a transaction to pay for the gas and make a call into the account. And that's a big UX problem because we cannot require users to have both a smart account and an EOA with some ETH and then require them to sign each transaction twice, once for the EOA to pay for the gas and once for the real transaction. That's a ux that's not going to fly and will never be able to get the next billion users. So with that there's the centralized approach, which is what some projects tend to use for smart accounts. And it means that there is a centralized server. The server has a funded eoa that can send a transaction.
00:03:38.010 - 00:04:24.860, Speaker B: I send my transaction, I send my operation to the server, the server wraps it in a meta transaction and puts it on chain for me, pays for the gas, and I compensate it later. Or maybe I do, maybe I don't. Now the problem here is, as I said, it's not really self custody. If I need somebody else's server to interact with my account, is it really my account? I would say not really. If I cannot use the account directly. Maybe it's not really self custodial, it's not really mine, it's only somewhat mine. And some people say that's not a big problem, and in many cases it isn't, until it is.
00:04:24.860 - 00:05:08.550, Speaker B: What happens if the wallet company runs out of money? It goes bust and stops paying its AWS bill. So suddenly the server goes down and I can no longer interact with my account. I'm stuck. Or maybe they get a denial of service attack against the server and also I cannot interact with my account suddenly. Or maybe they work just fine, the server works just fine. But it's about their business model changes to extract mev so they front run every transaction that has value and they are going to win 100% of the time. I have no way to defend myself because they are actually the ones sending my transaction on chain.
00:05:08.550 - 00:05:55.474, Speaker B: And of course they could censor me because someone coerces them to do so. The server is operated by humans, they can be coerced. And there's the issue of privacy because the server knows my ip address so it has my real identity and it sees all of my transactions and maybe it keeps logs and shares them with someone, I don't know. So having a centralized server is not very good for self custody. So let's try to naively solve this problem. One way to do it is they say let's have many servers. What if the wallet company runs multiple servers, not one? Well that doesn't change anything because the servers are still operated by the same entity.
00:05:55.474 - 00:06:47.266, Speaker B: So they would go down together, or they would censor together, or front run me together. So it's like one server. So the next logical step would be let's make it a decentralized and incentivized network of relays and then it's no longer operated by one entity and problem solved. Well, we try that. This is what we did with GSN, with the gas station network, and it does decentralized access. But there's a catch, because what if the account behaves inconsistently? The account could, when in an off chain simulation, the account would appear to be compensating the relay. But when the relay puts it on chain, it actually doesn't compensate because it can detect that it's running on chain by looking at some environment opcodes.
00:06:47.266 - 00:07:39.446, Speaker B: So it decides not to pay. And now the relay gets grift. So we need to protect the relay against griffing. Now how can the relay protect itself? We'll again try some naive approaches. What if the relay keeps a whitelist of known account implementations that don't griff it, and the relay only accepts these account implementations? So that's fine. But then who gets to decide what account implementation is legitimate and says that everything else is not? So it's permissioned in the sense that innovation is now permissioned. So instead, what if we restrict users? We say you can use any account implementation, but you have to sign in with your phone number, so the server can identify you.
00:07:39.446 - 00:08:31.000, Speaker B: And then if you grief the server, they're going to block you. So this brings us back to censorship, because if they can block you for griefing, they can also block you for any other reason. So what if instead we say we don't require usernames and we don't require implementations. Instead we keep reputation for each account that doesn't work because of CBIL, you're going to have CBill attacks. Any attacker can keep spinning up more accounts and keep griefing the server. So what if the server, after simulating and seeing that the transaction pays, it will use flashbots to submit a transaction. It will use flashbots and ask the flashbot relay to only submit the transaction on chain if it ends up paying.
00:08:31.000 - 00:09:23.602, Speaker B: So now the DoS vector moves to flashbot itself, because the attacker is going to send an ongoing, is going to keep sending transactions that behave inconsistently. So they all pass simulation, gets submitted to flashbots, but then flashbots starts, then flashbots ends up not including them, because they don't pay, because they revert instead. So after a while, the flashbot relay that is now doing a lot of unpaid work is going to block this server. Which brings us back to a censorship. So now the entire server gets censored. So without taking all of these things into account, we cannot build a robust and permissionless solution. Either it has to be permissioned, or it's going to be vulnerable and be taken down by someone.
00:09:23.602 - 00:10:50.606, Speaker B: Either way, we don't end up with a censorship resistant solution. So that's what ERC 43 seven aims to solve. ERC 43 seven is account obstruction without account obstruction without compromising decentralization, which means that there are no centralized components, nothing is permissioned in a network, and the account is fully obstructed, which means that account validation involves executing EVM code, and this enables many attacks. It can lead to many denial of service vectors, which we need to address. So the protocol has to take care of all of these requirements, or else if any of these requirements is not met, we're going to end up with a network that can censor users, always no network at all, because it will be attacked. But if we can make it, if we can make the network have all of these properties, then we end up with a robust solution that we can count on and not have any censorship vectors. So how does ERC 437 achieve all that? The first thing we had to do is we had to separate validation from execution.
00:10:50.606 - 00:11:35.378, Speaker B: The transaction has to be structured in a way that we know what part is the validation and what part is the execution. And then we can limit the amount of work. This is really the bare minimum we have to do. We have to limit the amount of work that has to be done in order to validate a transaction. If we don't do that, then if we don't do that, then the server may end up doing an infinite amount of unpaid work and never get to do any paid work. So we can say that even if the transaction is 5 million gas, it can only use two hundred k of a gas for validation. And this limits the amount of potentially unpaid work.
00:11:35.378 - 00:12:23.486, Speaker B: But that's only the start of it. Now, if a transaction is valid in the mempool, it gets propagated in the mempool, which means that every node in the mempool performs some work in order to validate it. Then we need it to also be valid, with high likelihood to be valid on chain, because otherwise, again we get a denial of service vector. So for example, suppose I implement an account that has a check for block number, and it says if the block number is even, I'm going to accept the transaction. If it's OD, I'm going to reject it. Now, during simulation, during an OD block, during an even block, it will be successful. So it will get propagated the mempool.
00:12:23.486 - 00:12:56.738, Speaker B: But then when someone tries to put it on chain in the next block, it's going to fail and not pay. So we needed to prevent that. In order to do that, we had to ban all the environment opcodes during validation. Note that all of these restrictions are only in validation. During execution you can do whatever you want because you're already paying for it. But until you pay for the transaction, you cannot look at something like block number. You don't really need block number in order to validate any signature scheme.
00:12:56.738 - 00:13:52.718, Speaker B: So that's one type of restrictions. Another issue is mass invalidation by flipping a flag in storage. What if I have many accounts that if I have many accounts that all check flag in some singleton contract, and then I send 10,000 transactions to these accounts, but I front run my transactions with one transaction that flips the flag and invalidates all of them. So now, at the cost of a single s store, a single state change, I invalidated 10,000 transactions and I caused every node in the mempool to first have to process these transactions and not get paid for them. In order to prevent that, we needed to limit the storage access. But storage access is useful. You need, for example, to access your keys in order to validate them.
00:13:52.718 - 00:14:49.106, Speaker B: So the account is allowed to access its own storage and its associated storage, which means storage that is associated with the account's hash in other contracts, such as an ERC 20 balance for that account. But it means that two accounts cannot access the same storage slot during validation, which brings up the cost of the attack. To order of n. Now you have to write to n slots to do n s stores in order to invalidate n transactions. Another issue is that the transactions cannot be mutually exclusive, because otherwise I can have many transactions, all of which are valid during propagation. But when you try to include them bundled together in the same block, they invalidate each other. For example, they couldn't invalidate each other because during execution they can actually access anything.
00:14:49.106 - 00:15:38.910, Speaker B: So what if transaction one passes validation and then during its execution it flips a flag in the account of a transaction two. And now transaction two that was formerly valid becomes invalid. So you can send any number of such mutually exclusive transactions, and the block builder will never be able to produce a block. To prevent that, we have to run all validations before any execution. So even if it's going to revert later because of then, it will revert after paying. We have some global entities in the system that sometimes do need to access the same storage slot during transaction. For example, paymasters.
00:15:38.910 - 00:16:27.680, Speaker B: The paymaster pays for the transaction for multiple transactions, multiple accounts, and it needs to access the same slots in this case, we need to have a reputation for it. So if it causes too many invalidations, we're going to throttle it, and it will not cause a lot of unpaid work. But this requires civil resistance, because otherwise someone can keep spinning up more paymasters. If the paymaster needs to access its own storage, it's got like a global storage. It has to be staked. The stake is not slashed in any case, it's just used as a civil resistance mechanism. So I'm going to skip a bit, because we're running out of time now.
00:16:27.680 - 00:17:21.650, Speaker B: Why does it have to be a standard? Why do all the bundlers need to implement, all the bundlers in the mempool need to implement the same restrictions and not come up with their own protection. The answer lies in spam protection. Nodes in the mempool have to protect themselves against spam, against nodes that keep sending them invalid transactions, because this is an unpaid work for them. So if one node considers something to be valid, it propagates it to another node that considers it invalid. It will have to block the first node as a spammer. So if they don't implement exactly the same rules, the network will get fragmented. Different parts of the network, different implementations will block each other and will end up with many small mempools.
00:17:21.650 - 00:18:12.450, Speaker B: Now that's a problem because, that's a problem because having many smaller mempool is much more prone to censorship attacks. It's a smaller group of, I mean, the transaction ends up in a smaller set of nodes. And also it means that we lose the benefit of multiclient architecture. Currently we have many bundler implementations, but if each bundler implementation had its own mempool with different rules, it means that a bargain, one client can censor transactions, and of course we lose some economic security, because bundlers are less profitable. They only see a subset of the transactions. So we have many reasons to have the same rules for everyone. This keeps the mempool more robust.
00:18:12.450 - 00:19:14.892, Speaker B: So the solution here is to have exactly the same implementation, exactly the same rules for all implementations. And we needed to do the same with Ethereum because of the multiclient architecture. So Ethereum has very clear specs for the very clear consensus specs, and we do a lot of testing and fuzzing to cover that. And ERC 47 does the same thing. So just to summarize, since we're running out of time, so account obstruction could be really easy if we didn't care about censorship resistance, which is exactly the same reason we use the blockchain, because we do care about these values. And smart accounts shouldn't have to care about decentralizing about that. They should focus on user value.
00:19:14.892 - 00:19:41.836, Speaker B: So ERC 47 does it for them. As long as you use bundlers that are compliant with the protocol and participate with the Mem pool properly. Right. So I think we're out of time. So thank you. Right. Do you have time for questions or.
00:19:41.836 - 00:19:43.690, Speaker B: No? Okay.
