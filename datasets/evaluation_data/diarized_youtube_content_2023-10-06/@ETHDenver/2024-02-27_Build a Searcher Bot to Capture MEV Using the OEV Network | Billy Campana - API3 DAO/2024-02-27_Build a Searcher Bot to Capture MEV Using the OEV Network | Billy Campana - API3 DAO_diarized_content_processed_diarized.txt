00:00:09.210 - 00:00:35.986, Speaker A: Hello everybody. I am Billy, otherwise known as Billy Jitsu from API three. API three is a first oracle solution for your needs. Stepping through, we offer four services right now. We have a chain API which allows you to bring your off Dane. We have QRNG, which allows you to bring random numbers to your smart contracts. We have dapis, which are price feeds that are pushed on chain.
00:00:35.986 - 00:01:25.960, Speaker A: And our newest product which is OEV network which stands for Oracle extractable value which allows users to bid for the ability to update a price feed. And we're going to dig into that today. Who am I? I am Billy, also known as Billy Jitsu. Quick intro, QR code if you want to follow the socials and the nonsense that I do online, but we'll go in that just a second. So what we're learning today is we're going to show you how to build your own searcher bot for the OEV network. It can be used outside of the OEV network, but we're going to really focus on what it can do on the OEV network. So the workshop breakdown goes as this is where's the current value going right now? What's the meta, how is value being lost to dapps and on chain, the flow of the current meta and then how to build a searcher bot introduction to the OEV network and then samples of the contract and the scripts that you can run a bot with.
00:01:25.960 - 00:02:32.422, Speaker A: So right now, the number one question I get all the time is like what is Oracle extractable value? So let's take a step back of how oracles work. So price is changing on assets all the time, right? So like if you look at Coingecko or if you're looking on an exchange, you'll see that the minute chart is constantly moving up and down, but that doesn't happen on chain because the limitation for us on chain is that every time you make that adjustment it costs a transaction fee. So during a bull run when Guay is up to 200 guay, it costs a lot of money to update its value on chain, right? So consensus has us do this at a certain threshold. So when there's a difference in price like 1%, half a percent, zero point, 25%, then we can then update that price on chain and then you can use it. So Oracle extractable value allows anyone to place a bid to update the price feed at any moment when they need it. So what is the extractable value part of this? Right? So we're going to do a quick example of like there's a liquidal position on Ave at ETH valued at $2,012. Right? And so for simplicity, we're just going to keep ETH at $2,000 and it has a 1% price deviation.
00:02:32.422 - 00:03:19.686, Speaker A: So it updates at $20. So it either update at 2020 or at 1980. So the price of ETH is changing on coin gecko as you're watching it and you're seeing it climb from 2000 to 2005 to 2012, which theoretically you should be able to liquidate that position. And it goes all the way to 2019 and you can't do anything about it because the Oracle has not changed, right? So until it gets to 220, it will not change. Right? And so once we hit that ETH at 220, now the price updates and it becomes a battle between who's going to bribe the validator to run your transaction first. So you have to bid up massive amounts of ETH and then pay that, and then cause that liquidation going into your profits. And then basically all that profit goes to the validator.
00:03:19.686 - 00:04:21.096, Speaker A: Right? So all this is just happening at the current meta right now on Mainet and a few other side chains. So what is ov trying to solve? So how we seem to help with this issue is searchers can bid to update the price feed through the OAV network, right? So we wanted to have that price update for that example for at 2012, right? But we know it wasn't going to update to 2020, so we bid. It's like we would like to update this price feed at 2012. So if we win the bid, we get a signature that allows us to update the price feed, and then we can use that signature and bulk it in a liquidation transaction using something we call a multicall to then let us update the price feed and then run the liquidation on the same call. So now the value is now split back between the DAP and the searcher instead of the validator. So instead of just waiting for it, we can now force that update at 2012. All right, so the focus is the searcher bot.
00:04:21.096 - 00:05:02.660, Speaker A: So what's really needed to build a searcher bot? You can use almost any script here that has like ETh, library, ethers, JS, VM, Python, Rust, web three js. Our examples that we have in the repo uses ethers, JS and JavaScript because that seems to be the most popular. You will need to deploy your own multi call contract, and if you choose to do so, your own liquidation contract to require, because it has an only owner function, you don't have to modify anything in the contract portion. We've already written it for you. So all you have to do to deploy it under your wallet. So here's the quick liquidation flow using the OEV network to see where it works in the place. This is a very high level bird's eye view of how it works, and then we'll get down a little bit deeper.
00:05:02.660 - 00:05:40.240, Speaker A: But first you find an opportunity, and then once you find that opportunity, you got to calculate that price of liquidation. Now we know that that price is, now we want to place a bid on the OEV network saying, okay, that 2012 example, I know that's the liquidation price. I want to bid to update that oracle at 2012. And we bid that in the auction house on the OEV network. We listen and then we won, right? So we said, okay, you're allowed to update that price. And so we get this signature, we bring it back to our local machine and we combine that update of price with our liquidation transaction. We call our multi call contract profit, right? Price updates, we get the liquidation.
00:05:40.240 - 00:06:23.270, Speaker A: So that's a very, very high level flow of it. We're going to dig down a little bit deeper. And so what's happening on the ethereum network, which our network is sepolia testnet etH, and what's happening on a local computer, a little bit more detail than what's happening there. So we're gathering all the user addresses that have a borrowed position and we're saving that locally on our machine. We have a database of information that have all the wallets that have all these positions, right? And then we got to go and use that information and then monitor the health positions of all the positions on the lending DAP. So then we have to call the lending DAP and get all the health factors of all the users that have any positions. Now we have to store that information locally on our machine for all the health factors that are about one 1.1
00:06:23.270 - 00:07:16.196, Speaker A: each one of those factors. Now we're going to calculate the liquidation price and then we're going to place a bid. Also happening on here on this network is we definitely want to deploy our multicall contract. It doesn't have to happen first, it doesn't have to happen second, but it has to happen before you get your bid in. So then it magically does something on the OEV network, which we're going to gut in a little it, and we magically win. And then again, going back, we get that signature, we combine our liquidation tracking transactions that we did mathematically on our local machine, and then we combine that and put that into our multi call contract that happens on the testnet, the proxy price change on the price feed happens on that testnet and then we get our liquidation, we win. So going in a little bit more deeper, this is pretty much the entire flow, right? So again we're basically doing the same thing of getting the addresses, checking the health diagrams, make sure our deployed multi contract is ready to use.
00:07:16.196 - 00:07:55.964, Speaker A: And so now we've had our calculation liquidation price, right. So one thing that we have to do right now for the hackathon is you have to request OEV ETH from the API three team. So that way you can place bids on the OEV network and you will have to deposit ETH into the auction contract in order to play the game. So you have to basically stake your ETH on the auction contract to play the game. Once we have our liquidation price, we set up our bid conditions, which is what price are we wanting to update at what price feed are we wanting to update? What chain do we want to update? And a few other factors that don't really matter for the testnet. Right. Then we place our bid and we have to wait and listen to see if we won that bid.
00:07:55.964 - 00:08:37.448, Speaker A: A bid happens every time there's a change in price, so that could be 1 second, 2 seconds. Whenever there is a fluctuation in the price, the auctioneer is listening for any changes from the outside oracle. So if it goes from 2012 to 2012 and $0.15 there's an auction happening, it's going to check if there's an auction happening, and if there is, and that's the only winner, then you win the bid. Once you win the bid, you receive the auction signature and then we go back to the original flow where then we gather that data. We've done our calculations for the liquidation, we call update the Oracle and then get the liquidation. So what are the details on that? What are the fine details on that? So on the OEV network you only really need to deposit 10% of what you're actually bidding on the auction.
00:08:37.448 - 00:09:05.044, Speaker A: So if you're willing to bid up to one eth for that auction, you only have to place in 0.1 ETH. So you don't have to pull your whole treasury on the OEV network. You don't pay the fee on the OEV network, but you pay it on the chain that you're updating the price feed on. So if you were doing it on main net, you would pay the fee in Eth on main net. If you were doing it on the testnet, you're doing on a sepolia testnet right. So the fee value gets passed from the API three server to the price feed update transaction.
00:09:05.044 - 00:09:49.438, Speaker A: So when you're updating the price feed, that's when you're paying the fee and it goes into the auction house server. Then the DAP then can withdraw the value that you did the update fee into their contract and then they can use the value how they see fit. So this is like a hackathon bounty that we have going on right now. Once the DAP has received the biding fee, what are they going to do with it? Are they going to soften that liquidation for the user? Are they going to reward the stakers for the DAP? Are they going to donate to public goods? Those are the things that we're looking to see what people get creative with to see what that newfound value is. Back to the DAP. A little bit more details, bid details on the OEV network. The address of the transaction is part of the winning signature.
00:09:49.438 - 00:10:08.902, Speaker A: So the way you can't get front run is because you're whitelisted. If you win the bid for that price feed, your address is now whitelisted in that transaction. So it's in the public mem pool and you send that transaction to update the bid. It's the only address that can't update it. So if they try to front run you, it will revert. Right. And then, so you do have to use the multi call contract.
00:10:08.902 - 00:10:44.870, Speaker A: So then you can combine the price feed update and the liquidation function on the single call. If you do the call and update the price feed in a single transaction, you will get front run and then someone also say thanks for the price update and then they get the liquidation. So I am not a big fan of PowerPoint presentations. I'm more about digging into the code. So a quick QR code for everybody that wants to follow along and grab the repo. This is also part of the ETH Denver repo, so all the examples are there. I'm just giving it enough time for anybody that wants to pull out their phones and get the QR code.
00:10:44.870 - 00:11:28.402, Speaker A: Takes you right to our repo, but let's get into the code and make that a little bit bigger and hide that. So this is an example of our search robot. It's basically three functions, but they're three long functions, but basically going based on our flow, it's going to semi make sense. So don't get too nervous. I'm going to guide you through the whole thing. We're going to break down the code piece by piece so we have our first function where we need to fetch the loans, right? So we got to get all the users that have deposited on the lending DAP, right? So I know it looks a little scary and we'll get you through it. So in order to store the addresses in our local machine, you get to choose whatever you want.
00:11:28.402 - 00:11:54.842, Speaker A: We chose SQLite database just to store data, to access it differently. And so we build a function that's going to store all that data. And the only way to get the data from who's deposited is to go to all the past events. Now, there's different ways to go around that. If there is a subgraph deployed for that DAP, you can then refer to the subgraph to get past history events. Unfortunately, we don't have it on testnet sepolia. So we have to manually do it.
00:11:54.842 - 00:12:23.618, Speaker A: Right. So starting from when that was deployed, this block right here specifically, we're going to start from there and go to the current block. So we have to go block by block to listen to all the events and filter out all the depositors. Right. So we don't want you to kill your RPC calls and then do 1000 calls in a second. So we did it on blocks of 500. And so every block of 500, it would gather the data of all the events and then start again in another 500.
00:12:23.618 - 00:12:52.214, Speaker A: But just to save time. And that's not the focus of the hackathon. We've already compiled a list of all the wallets that have already deposited for you, so you can access that at any time. Going down a little bit deeper. Once we've collected all those filters, we basically just filter out to see what the user deposited, the amount they deposited, and the asset that they deposited. Right now we're keeping it really simple and very simplistic. We have a fake token which is called oevt.
00:12:52.214 - 00:13:22.290, Speaker A: Not speculative. We're not dropping a token. It's just a token so people don't get confused. And then the asset being borrowed is in USDC, so it's a stable value. So a very easy single asset, one to look at. So now that we have all the user data, now we have to check against the DAP to see all the health positions, right. And what did they borrow? So now we go through another function and basically looping through of getting the user account data, which is the function you would call on the lending DAP that gives you your health position, the collateral that was given and the deposit.
00:13:22.290 - 00:13:56.850, Speaker A: Right. And it has all the details of what you get in return. The LTV the health factor, it gets very complicated when you start doing multiple assets and they have different loans of values. So we're keeping it really simple with a single asset and single borrow. And then basically in order to get your liquidation price, you get your total debt divided by the total collateral times the loan to value and you'll get your liquidation price of whatever it is at that point. So here we're just doing some calculations to say, okay, this position has 10,000 deposited, 75,000 borrowed. The liquidation price.
00:13:56.850 - 00:14:28.714, Speaker A: If the OEV token goes down like 5%, this would be the liquidation price. So we're doing all the math here and running it through. So now once we have it, we're going to save it to our sqlite database with all the information, the user's address, the health factor, all the collaterals and then the liquidation price. And that just gets stored on our database so we can access it quickly. And then this is just more like cleaning up. We're going to sort it in ascending order based on health factor. So like our highest opportunity is going to go first and then it's going to go lower and lower.
00:14:28.714 - 00:14:56.420, Speaker A: And then we're just making a table again for the hackathon. Those that are doing their own searcher bot are optimizing it. Don't have to do it this way. If you have a back end user on your team or a database pro on your team, you can go a different direction on that. And so we basically just build this table up and then we write all the loans to the database. This is all just databasing and then cleaning it up to a readable format. And then here we just log out the top ten positions that have the most opportunity.
00:14:56.420 - 00:15:37.346, Speaker A: So that pretty much we have this log, a table log of all our positions, all our liquidation positions. We have that all available to us on our database. So we got all the user data and all the opportunities right. So now we want to go ahead and start placing our bids. So we do a little bit of checks and balances first to make sure that those positions haven't changed from the time our bot has got the information to when we want to place our bid. So the first thing we do is we're setting up our auction house contract address on the OEV network and then we're looking through all our loans, we're finding all our loans, what the bid status is, and we have it labeled. Has the bid status been awarded or has it been lost because we don't want to place bids on stuff that we lost on or awarded, right.
00:15:37.346 - 00:16:24.270, Speaker A: And so it'll look up through the database and then basically loop through each one of those positions we have, and we reset the liquidation price every time just to make sure we don't get anything skewed in our loop and reset the percent every time. So every time it goes through the loop, it goes through the user and it resets to nine, nine, nine. And then we look at a liquidation price for each one of our users. So we have ten users, so it might go loop through ten times. And we just look at all the liquidation price to store them as variables and we just check the bids, right. So here we're looking at our listener, we're checking the oracle price to see did the oracle price change at all. Is there any changes or adjustments in our flow? If there is anything that has been outdated or anything, or if there's any labels on there, or if the price oracles has changed, basically expire the bid, cancel the bid.
00:16:24.270 - 00:16:53.190, Speaker A: It's not worth our time for the RPC calls. Right. And so it's just checking and making sure all those balances are going through. Once we get closer to filtering out stuff, we're making sure. Is the oracle up to date? Right. Coin gecko is not the same thing as our oracle price feed, right? So if we have 2012 for our liquidation price and coin Gecko saying 2013 and our oracle is saying 2011, we got to adjust for that. So we have small adjustment factors here in the code in order to make sure that the percentages are within range.
00:16:53.190 - 00:17:36.118, Speaker A: And so once we've done all that math and that balances here, we basically check to see, okay, is it still in a liquidable position? Is it like between 1.1 and 1.0? And is the oracles within range? If it meets all that criteria now we can actually finally place a bid, right, be a good bot and place a bid right where we need it. And so we are now ready to place our bid and then set a liquidation price. And then we have two ways to place a bid, one with expiration time and then one without expiration time. All our demos are with an expiration time because we have a fake mock oracle that we know is going to happen. So you can make it fake after 2 hours, 12 hours, 24 hours, your choice of however you want to do that.
00:17:36.118 - 00:18:17.806, Speaker A: And then once we place our bid, we just update our loan database to make sure, hey, we've now placed a bid, so that status has changed. So the next time the bot goes through again, we know that that user's position has had a bid placed and now we set up some listeners, right? Did we win the bid? Do we have any bids that we win? So we're just looping through all our positions and listening, say, hey, did we get anything? And let's say we get the bid that's awarded. So we're listening to see if the auction house said we've been awarded. And so if we do get awarded, then we save the award details. This is the signature that we need. That's going to allow us to update the price feed on the chain that we're trying to update. So once we have that detailed, we're going to go ahead and update our table.
00:18:17.806 - 00:18:38.474, Speaker A: We have all that we need. So now we know we got to trigger the liquidation, right? I can update the price. I know the positions. Now let's trigger it. So that's what we call this trigger liquidation. That leads us to our pass function trigger liquidation, right? And here we're just going to go through the loans one more time, make sure that we haven't lost any bids because we had multiple bids going out. So maybe we lost some.
00:18:38.474 - 00:19:06.462, Speaker A: So let's filter out all those lost bids that we did and only the ones that we've got awarded. And then we're going to go ahead and get the loans from the health factors that are less than one. We want to make sure that they're still up to date. Sometimes they repay their loan, oh, I'm getting close. Somebody repays their loan in the last second, they have a bot that repays the loan or they add more collateral or anything like that. So we want to make sure their health factor is still one so we're not wasting money. And then we connect it to our liquidator contract.
00:19:06.462 - 00:19:36.942, Speaker A: So you can deploy your own liquidator contract or you can call the contract directly. And so we're going to build up our call, right? And so we know for simplicity that we only have one asset for the reserve and one asset for the collateral, right? So we know that the collateral is the OEv token, so we don't have to fumble or anything. It's straightforward. It's only one asset to play with. And then we know that the reserve is USDC. That's what we got to pay back, right? And then we have the database of our user. So we encode all that up into a single function, which is my liquidation function.
00:19:36.942 - 00:20:15.722, Speaker A: And then we have that all ready to encode. So you have to encode your function and all the details in a multicall so you can fit it all in the array. And then we go ahead and connect our contracts to all the different loans that we have in position. So if we had ten successful bids, we're going to do ten liquidations, and then we just go through the whole mapping and get that all set up. And then now we're finally going to do our multicall, right? So we're calling our liquidator that's connected to the multicall. The first thing we're going to do is we're going to update the price, right? So that's the API three server on the sepolia chain address. If you were doing on an ETH mainet, it would be the address for the updater on ETH Mainet or whatever other chain you use.
00:20:15.722 - 00:20:41.950, Speaker A: And then this is the price update that we wanted to update it to, and then the bidding amount that we bid on there. So this is what we promised to pay if we won the bid. So if we bid one ETH, we have to pay one Eth. If we bid one ETH like we had here, we're paying zero, one Eth. And don't confuse that with the value that has to pass through. The value that you're paying then goes to that smart contract. Also bolt into this transaction is our liquidations, right? So we have all our liquidations that we have on file.
00:20:41.950 - 00:21:38.680, Speaker A: So we bulk all those liquidations with all the addresses, and then we have all the multicall data, all the functions that are encoded for each position, all our strategies that have been set are going into this data feed. And then we're not passing any value, we're not paying any eth to that contract. What we are doing is making sure we pay back the USDC to claim the collateral, right? And so you have to make sure that your liquidator has the USDC in the contract to be able to pay back the loan. And then once we get that all bulked up, we call the multi call and profit, right? So this is a very basic bot to get you up. And so like for those that are looking to do any kind of botting, or maybe this is not out of your league, we have something that's already working for you that you can modify. And so just a quick example, like in the readme docs, we have tons of examples that, tons of examples that kind of give you what the data is going to look like, take you step by step on here. Let me just zoom that out just a little bit.
00:21:38.680 - 00:22:52.600, Speaker A: Let me zoom that out. And that didn't work out too well because of the screen it has a different thing, but it's got a lot of good documentation in there for you to go through. I was able to go through it with a few nontechnical guys, and they were pretty happy with it, so I'm happy with it. Okay, so let me go on to this next session here. So we have bounty prizes for those interested in learning how to do liquidations. So we have a $5,000 prize pool for those that build a modification on a borrow lending DAP to reallocate that newfound value, that liquidation profit. So that value that we sent to the oracle that goes to the DAP, what are they going to do with it? Right? Like I said, are you going to fund public goods? Are you going to do soft liquidations to entice people to borrow more? Go more Djen, are you going to reward stakers? What would you do with that new found value? Right? We also have an ongoing maximum profit, $6,000 for the hackers that really love to do bots is we have an ongoing liquidation going on in an Ave V two fork, and the goal is to liquidate as much as possible.
00:22:52.600 - 00:23:35.592, Speaker A: So those that get as many oev tokens at the end of the hackathon is first place, second place, third place. We also have a special $1,000 price pool for those that keep trying. Right? There could be some killer like mev guys that are excellent at bots, and we don't want you to lose hope in the very beginning because they liquidated like 10,000 or $10 million in the first like 20 minutes. Right? But if you keep showing us and keep talking to the team that hey, we're trying this strategy, we're adjusting this strategy, and you keep adjusting your code to be a little bit more optimistic. We have that special price pool just for you too. And I was a little afraid of the Internet, so I took a screenshot of the fork. So we have a current market happening right now, and you'll see the ongoing position.
00:23:35.592 - 00:24:00.728, Speaker A: So we have $100 million supplied on there. So there's $100 million of USDC on that token, that specific token that is available to be liquidated. As we have an ongoing price feed through the whole hackathon, it's going to be lowering in price. More of those positions that were in that wallet will be liquidable. So there's lots of opportunities. So if you didn't get the first one, you didn't get the second one. There's going to be 1000 wallets that are available to be liquidated.
00:24:00.728 - 00:24:14.032, Speaker A: So give it a shot. Use the bot, maybe you're the first one to use it. Maybe somebody optimize it right off the top. But there's a lot of opportunities. Go through all the wallets. There's a script so you can go through it, so you don't have to use a whole bunch of RPC calls. Access that database.
00:24:14.032 - 00:24:36.040, Speaker A: We're very curious to see how you perform. If you have any questions, definitely join our discord community because in order to get the oev tokens, we're going to have to faucet it to you. So join the discord. I'm going to leave this up right here. This is the QR code for we're going to be on during the event. We'll have our booth, so you can definitely talk to the text. You could follow me, ask me questions.
00:24:36.040 - 00:24:50.384, Speaker A: I'll be here in the corner. I've been told, don't stand in front of the stairs. Stand next to the stairs. So if you have any questions about the bots or anything, you should be good to go. And yeah, I mean, have fun. Experiment. This is like Mev on training wheels, right? You don't have to worry about front running.
00:24:50.384 - 00:24:58.140, Speaker A: It's about experimenting and seeing what you can do with it and then getting started with a good framework. And that's it guys. Good luck. Bye.
