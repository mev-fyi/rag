00:00:00.170 - 00:00:21.086, Speaker A: Got way too many slides. Let's be honest. This is either going to be unintelligible or unfinished. Let's do it. Okay, so context first, last Defcon. This is a continuation of my Devcon talk about the super chain, about the op stack, basically. That talk had a lot of good context and good information.
00:00:21.086 - 00:00:40.214, Speaker A: That's kind of high level, this talk. This talk is that one had tons of nice little images, all that stuff. This one is going to be very in the weeds. There's going to be a lot of detailed information. So I'm going to speak fast, but it's going to be a lot. It's going to be a lot. No fun allowed during this talk.
00:00:40.214 - 00:01:04.366, Speaker A: Let's go, Leroy Jenkins. Okay, so, super chain to the rescue, right? We're going to talk about the superchain, but what is the problem? What's our problem statement? Well, blockchain scalability is insufficient for the decentralized web today. Right. That's, of course, what we're trying to solve. And why is that? Meat congestion. Our arch nemesis. Oh, my God.
00:01:04.366 - 00:01:24.710, Speaker A: Evil. Anyway, blockchains don't scale. Did you know? Right. You're sending transactions, you're trying to tweet, you're posting a tweet. This is not going to work. You're not going to put Twitter on the blockchain if your tweets are costing 1316 to write games, comma. Anyway, okay, this is not new information.
00:01:24.710 - 00:01:55.150, Speaker A: Right? It's literally been the problem since the genesis of the blockchain. The first response to the bitcoin white paper was something we very much need this technology. But the way I understand it, as your proposal, it does not seem to scale. Anyway, it's the inside joke. Okay? 2018, it's been a problem. And it's 2023. That's a problem.
00:01:55.150 - 00:02:41.886, Speaker A: That's too many years of my life. I mean, I wasn't in at 2018, but it's been a lot of years. Okay, but let's just open our minds for a second and let's say this is not actually a problem. What if things were different? What would be possible? What if it was more than just doge memes? What if we actually provided real value to real people and made people happy like those things anyway? What if we could scale to support, literally, the globe? What would be possible? Well, let me tell you this from a developer perspective, just to start, right? This is underappreciated. The EVM is an insane abstraction. It is the ultimate serverless technology. You can literally write your application logic as code.
00:02:41.886 - 00:03:23.210, Speaker A: You don't need to worry about the computers that it's running on because they're gas metered. You can pay for your usage. It's a really nice abstraction, like genuinely a great one. Additionally, when you are building with these smart contracts, they actually compose together. I know that the messages I send from one contract will be received by the other. I don't need to worry about inconsistent databases, corruption, all of that kind of stuff. And additionally, when I deploy my smart contract, like for instance, Hayden deployed Uniswap, he deploys this thing, thousands of people are using it, and he doesn't need to wake up in the middle of the night from DevOps problems.
00:03:23.210 - 00:04:01.558, Speaker A: And he also doesn't need to front the costs and add ads to his website just to pay for the server costs. It's madness anyway. We would literally be able to liberate developers from that as well. This is genuine value add to developers. And when we build things that make developers give value to developers, then we turn ecosystems that are like dying in our web two lockdown universe into a vibrant open source place where people are having fun, people are building great ads. Now I just want to say that this image is actually in reverse because it's a very sad world and sunblock kills. And this is what our sponsor, thank you, sponsor.
00:04:01.558 - 00:04:44.070, Speaker A: Okay. Anyway. No, just kidding. Okay, Twitter, right? I'm going to say something, you're not going to believe it, but literally building a horizontally scalable Twitter that scales to the globe would be a literal hackathon, two day kind of project. It is crazy if we get this abstraction right, because we scale compute, and once we scale compute, everyone can compute. Okay, does it compute? Well, let me tell you, okay, it still can be realized. Like that future, that vision, that thing we're getting to, it's still possible, right? We've been building out e two plasma group working on scalability tech for an incredibly long period of time.
00:04:44.070 - 00:05:19.634, Speaker A: And it has been a massive ecosystem of people, people in this room working on scalability tech. And that has led to abstraction layers that actually work at scaling blockchains, right? And when things are beautifully done, we're getting to a point where we have the abstraction layers. Just like for the network stack, we're building these things out. When things are beautifully done, there's usually a well thought out set of abstraction layers. Highly recommend this podcast. Okay, right, we have ethereum l two. We've got tons of contributors, and it's starting to become clear.
00:05:19.634 - 00:05:36.342, Speaker A: What's becoming clear? Well, congestion versus the super chain. Let's go. All right. That's our word for it. You know, the superchain. Okay, it's more than one chain, right? First off, what is the super chain? Let's get a little picture. Okay.
00:05:36.342 - 00:05:47.082, Speaker A: It's more than one chain, that's for sure. And why is that? Well, it's pretty simple to see as the chain grows. Right. It just becomes impossible to run it on a computer. Simple. All right, done. Okay.
00:05:47.082 - 00:06:20.006, Speaker A: But it's also not multiple chains in the traditional sense because each chain is going to be adding, like, if we do it in a bespoke model where there's just different validators, all that kind of stuff. Every chain you add to the network is adding existential risk as well as it makes it incredibly hard to deploy these chains. We want chains to be spun up in 2 seconds. Like we want literally a chain in my web browser. Actually, 2 seconds is hella long. Like two milliseconds to spin up a chain. Real talk.
00:06:20.006 - 00:06:33.942, Speaker A: Anyway, we need to commoditize chain infrastructure at that point. Then we can auto scale chains and we really see what's happening. So it's not monochain. It's not multichain, it's superchain. Let's go. All right. Super chain properties.
00:06:33.942 - 00:06:50.218, Speaker A: How much time? Okay, I got five. Okay, great. I'm not going to talk about this super in depth. I'll post the slide somewhere. You can read it. But anyway, point being, one l, one, one shared bridge, standard security, standard tech stack. All of these chains.
00:06:50.218 - 00:06:57.614, Speaker A: Well, all these op chains. Let's go. Okay, roughly. Right. Ethereum. Optimism bridge. Lots of chains.
00:06:57.614 - 00:07:12.022, Speaker A: Pretty simple. That's it. You're experts. Okay, op chains. Oh, importantly, when we get to this point, we will be able to deploy to the super chain. We're not going to be deploying to, like this chain or that chain. It'll be years.
00:07:12.022 - 00:07:38.478, Speaker A: But the developer tooling should get good enough that we can abstract away all of this underlying infrastructure just like we went from ec two to Docker to kubernetes, et cetera. All right. Warning, this stuff does not exist yet. If that was not clear, it's coming soon, but to a theater near you. And guess what? You can help, too, because this is us, right? Like, this is the blockchain industry that we're talking about here. Okay? So very happy. Okay.
00:07:38.478 - 00:08:10.570, Speaker A: This is where it's going to get. Going to get gnarly, right? We're going to start off by breaking it into small chunks and composing those chunks together just like these abstraction layers. First abstraction that we're going to talk about is chain derivation. This is how you get the chain. Okay. This is the process by which you derive the chain information, the l two chain. Okay, how does it work? Well, l two chains are actually defined by the derivation function over in l one, over ethereum.
00:08:10.570 - 00:08:44.814, Speaker A: So what does that look like in visual form? Because I like visuals. Well, it means that you take ethereum, you put it in this function, you get out optimism, Main. Net, for instance. Then users submit deposits or transactions to Ethereum. Then, boom, it gets reflected in the red optimism op chain. Additionally, you might send to a sequencer your transaction right there. Now, what does the sequencer do? Sequencer sends it to Ethereum.
00:08:44.814 - 00:09:00.146, Speaker A: And now, boom, you derive it again back to the op chain. So all of this stuff is based on l one. There's no auxiliary data, right. That's very important. It's pretty simple. Okay, I'm going to dispel a myth. It was totally unrelated, but I have to do it.
00:09:00.146 - 00:09:09.450, Speaker A: I hate this myth. This is the myth. Sequencer can forge transactions. This is false. Oh, wait, I spoiled it. Fuck. Anyway, we're not supposed to spoil these things.
00:09:09.450 - 00:09:27.602, Speaker A: Okay, let's look through an example. Right? Alice signs a transaction, sends it over to the sequencer. Sequencer gets the transaction and changes it. Now the transaction has an invalid signature. So the sequencer posts that transaction to. Right. You know, the sequencer is like, I'm going to get the money.
00:09:27.602 - 00:09:44.614, Speaker A: Then in the derivation function, it picks up the fact that it's an invalid signature. And so what does it do? It throws away the transaction. It doesn't affect anything. So the l two chain is untouched. Right? That is an important thing. Myth busted. Let's go.
00:09:44.614 - 00:10:30.274, Speaker A: Okay, important side note, okay, we're going to do this. All roll up derivation functions are just all the roll ups that we have today, right? From optimism to the various forks to everything. They are all just different derivation functions over ethereum. What does that really mean? Well, right, all of them are slightly, slightly different. We derive the red chain, then we derive the blue chain, then we derive the darker blue chain. All of these chains and all of their sequencers are submitting transactions to ethereum, deriving different chains. So are these chains just, are they the same? Know, what is the relationship? It's kind of weird.
00:10:30.274 - 00:10:59.198, Speaker A: They're all just indexes over Ethereum. Very important concept. So if I'm Alice and I want to sync the red chain, then what do I do? I sync ethereum, then boom, I sync the red chain. I derive the red chain. And if I want to sync the blue chain do the same process and the same process for the darker blue. That's why ethereum scales, right? You're only syncing the chains that you need that picture of the computer blowing up. Not a thing.
00:10:59.198 - 00:11:24.118, Speaker A: All right, so that's status quo. But let's go super. Let's go super. Let's get to infinite chains. That's crazy. Okay, well, what if we had a generalized derivation function, one that not only took in the l one, but just a chain config? And by that way, that chain configuration can even be defined on l one in a smart contract. In fact, it should be.
00:11:24.118 - 00:12:07.186, Speaker A: This plus a standard bridge, standard addressing gives us the ability to, based on the configuration, the chain config, derive different chains automatically. Literally, all the possible configurations of the chains can be derived in this counterfactual sense. Okay, what does that kind of mean? It's kind of like a kaleidoscope where as you turn the little wheel, you're seeing a different image of layer one. And you can look deep in, and you start seeing, whoa, it's trippy. It's crazy. This is the crazy complexity that is possible with ethereum, just looking at it in different ways, driving different chains. You got infinite chains here, folks.
00:12:07.186 - 00:12:21.038, Speaker A: Infinite chains, practically infinite. There's finite number of numbers. Anyway, okay. I don't believe in infinity. Okay. Anyway, first concept, right? First concept. We look at that kaleidoscope, and we get infinite chains.
00:12:21.038 - 00:12:57.918, Speaker A: It didn't depict the infinity there, but it's pretty good, right? But each chain is isolated, right? Now, we've got a second key concept that is cross chain messaging. Okay, so what is cross chain messaging? Well, that is the process by which a chain sends a message to another chain. We can kind of look at the analog version of this, where Alice is writing a letter. She just writes a letter. She signs it. She writes the address, the signature, and her message, and then she wants to send it to Bob. So she gives it to Mo, the mail person, and Mo transfers it over, and boom.
00:12:57.918 - 00:13:34.010, Speaker A: Mo checks that it's bob. Sorry. Checks that it's to Bob, and checks that the signature checks out and then reads the message. Okay, so what if I told you those Alice and Bob were actually chains? What if I told you they were chains all along? Okay, really? What happened in the true version of the story is Mo, the mail person, is actually the user, saying, hey, I want to migrate my tokens over. So Alice, the chain. Alice creates a message. You should, Bob, you should definitely change those.
00:13:34.010 - 00:14:12.090, Speaker A: You should create some tokens for Mo is trying to move the tokens over. So Mo then takes that message and relays it over to Bob, the bob chain. And Bob, the bob chain, checks the two, make sure it's for Bob and checks the proof and then reads the message and acts on it. That is the fundamental thing that is happening when we do cross chain messaging. Okay, but there's a little bit more. Right, this is an example, right? We have the red chain over here. We've got the message Alice, or Mo, I guess, relays that message back to Ethereum and the withdrawal is processed.
00:14:12.090 - 00:14:32.994, Speaker A: All right, so additionally. Oh yeah, this one. Okay, so this is how we get messaging between two different chains, two different op chains. We check the two, we check the message and we check the proof. But the proof is very hard to do. Right. The complexity here is all in.
00:14:32.994 - 00:15:29.362, Speaker A: How do you implement this proof system? But let me just give you the intuition for how all proof systems on the superchain in some sense are verified. Okay, so the red chain wants to send a message to the blue chain. What do we do? Well, the blue chain has this message, needs to verify the proof, but does not have access to any of the chain. State of the red chain. What does blue chain do? Well, blue chain knows that it is being rooted into ethereum. So it will actually run the red chain derivation function, which is based on the red chain's address, the red chain's chain id then, because there's a standard derivation function, then it will derive the red chain block by block until it finds the message and then verifies its authenticity and can then act on it. This is really what is happening with all of these proof systems.
00:15:29.362 - 00:16:18.866, Speaker A: Now you might notice a problem though, right? That was so easy. Why is that hard? Well, really, chains fully verifying each other is not scalable. It just ends up looking like one chain that doesn't actually scale. But that's why we have proof systems which take this long, huge bit of compute, and then shrinks it down into a small amount of compute based on either random sampling assumptions or based on economic guarantees. And those two categories are also reflected in our fault proofs versus validity proofs. Right, fault proofs, you prove it by proving nonexistence of counter evidence and a validity proof, you prove it up front. Okay, problem is with fault proof is high latency.
00:16:18.866 - 00:16:50.282, Speaker A: Validity proof is low latency. And guess what? By the way, the op stack, the super chain, it uses all the proofs. Just remember, it's not just fault proofs. Okay, so here's a list of a bunch of different proofs types with various trade offs. Now, I'm not going to go into every one, but TLDR, you have a wide number of proofs to choose from. Some still are a work in progress, and us as an industry must basically create all of these things. Okay, so critically, right, all of these proofs work on every op chain.
00:16:50.282 - 00:17:17.778, Speaker A: All of these chains that you've derived, they can accept any kind of proof, whatever fits the circumstance. Okay, so concept two, recap. We've got infinite chains and chain messaging. Now I'm going to go incredibly fast because I have 2 minutes left and I have like 30 billion more slides. Okay, synchronous messages. You're going to breathe in and just soak in these slides. Okay, watch this.
00:17:17.778 - 00:17:42.606, Speaker A: Whoa. These different chains have different sequencers. There's lots of configurable sequencers. We can experiment with sequencing protocols, but we need these chains to communicate atomically, like splash loans. And the problem is they don't communicate atomically normally because they need to coordinate. Both messages have to happen at the same time. That requires sequencers to work together.
00:17:42.606 - 00:17:58.974, Speaker A: That's shared sequencing. Now the sequencers are working together, sending one message and boom, it hits the chains. All right, we got synchronization now. That was fast. All right, last concept, data availability. It's the final countdown. Okay, notice we still have a bottleneck.
00:17:58.974 - 00:18:34.606, Speaker A: I kind of lied to you. All right, we have infinite chains, but we don't have infinite data, so that becomes our bottleneck. What do we do? Well, we can add one more l one data availability with EIP, four for four, or we can add a plasma protocol throwback. Y'all, I've been telling you it was coming back, but y'all don't believe the headlines are so ridiculous. Anyway, let's go. So you can have chains that are alternative data availability, you hash the alternative data availability kind of chains, and then now you can extend what Ethereum has in terms of its data capacity. Now you get infinite chains and infinite data because the data is coming off chain.
00:18:34.606 - 00:18:57.046, Speaker A: You get to horizontally scale that and boom. Now, I mean, it's not infinite data, right? Of course they're finite number of computers, but come on. Okay, anyway, great. There's a catch. You need data availability challenges. You don't get quite as much security as roll ups, but that's okay. And you can take a look at the slides to understand what I actually meant there.
00:18:57.046 - 00:19:17.118, Speaker A: Okay, plasma and roll ups, those are the two categories, and we're good. That's our final recap. So infinite chains, cross chain messaging, synchronization and infinite data. Kind of infinite kind of infinite chains. Everything's finite. We live in a finite universe, and we have spawned the super chain. And congestion comes through.
00:19:17.118 - 00:19:27.826, Speaker A: Pow. We got that thing taken care of. We realized that vision. Oh, my gosh. More info about how this works at the superchain explainer. Y'all take a look. For sure.
00:19:27.826 - 00:19:54.498, Speaker A: And I'll just say a few more things. This future that we could create where we really scale decentralized compute, atomic compute, it is possible the whole world can use it. And guess what? We will use that to fund public goods, to fund open source software. So we take over the Internet tech not only with decentralized compute, but with open source software at every layer. We're going to build the open source Internet, y'all, and spawn ethers. Phoenix. And that's why we have the optimism collective.
00:19:54.498 - 00:20:07.482, Speaker A: And that's how we basically birth the optimism collective. And by the way, welcome to the collective. You're part of the collective. You'd be like, yo, I think this. And I'm part of the collective. Tell your friends they're part of the collective too. We're collective.
00:20:07.482 - 00:20:22.380, Speaker A: Me and you. And with that ado. Okay, that. Yeah, anyway, that was funny. It.
