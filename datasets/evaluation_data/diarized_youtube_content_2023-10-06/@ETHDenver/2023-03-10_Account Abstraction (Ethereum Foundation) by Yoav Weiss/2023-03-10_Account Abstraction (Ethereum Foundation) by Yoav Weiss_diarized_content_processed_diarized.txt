00:00:01.050 - 00:00:44.260, Speaker A: Hey, everyone. So my name is Joa Vais. I'm a researcher at Ethereum foundation, and I'm on a mission to eliminate eoas or externally on the accounts. So I'm going to talk about how and why. So what is account obstruction? To understand account obstruction, we need to understand what we had until now and what's wrong with. So most accounts today are externally owned accounts, also called EOA. And these accounts have a single key.
00:00:44.260 - 00:01:18.880, Speaker A: They have a single ECDSA key hard coded to the account. You cannot change the key, you cannot have it any other ways. And that's generally a problem because keys get stolen or lost all the time. And if you lose your key or someone gets a hold of it, then you're in trouble. It's also an all or nothing proposition. If you have the key, you can do everything in the account. You have full control, and if you don't have the key, you can't do anything.
00:01:18.880 - 00:02:04.540, Speaker A: There's no granular access control. So basically in security, usually we separate between authentication and authorization, but here we don't have this separation. The authorization is just a boolean. Another issue is gas payment. With an EOA, the gas must be paid out of the account itself. So it's not great for onboarding because you need to transfer ETH into the account in order to start using it. It's also not great for privacy because it's not great for privacy because you need to associate your new account with an existing account by transferring ether into it.
00:02:04.540 - 00:02:56.540, Speaker A: And it's not flexible for Dapps because one operation is one transaction. For example, when you need to perform a trade within ERC 20, you send one transaction for approve and another one for transfer from. And it's impossible to automate any flows because you have to sign any operation in the account. Account obstruction offers an alternative. It offers us a way to create a flexible account, have a flexible account that matches the user's needs. And for different users, it can mean different things for a new user. We would like to just give something similar to a bank account.
00:02:56.540 - 00:03:38.694, Speaker A: When you're using a bank account, using your online banking, you are not worried that if you lose your password, you will lose your bank account. You can always call the bank and they would help you recover it. So we should give them something similar. And we shouldn't expect new users to write down twelve walls on a paper and to keep them safe. Users shouldn't see cryptographic keys because they don't know how to manage them. So we need to add devices to the account. Let's say your mobile device is how you control your account and you can have a backup device.
00:03:38.694 - 00:04:16.738, Speaker A: You shouldn't have to manage keys. For a more sophisticated user, it can mean something different. It can mean having extra features, extra flexibility. For example, you could have access policies saying that from your mobile device you can spend up to $1,000. And if you want to spend like double that, then you can use a two FA. And if you want to spend an unlimited amount, then you should go get your hardware wallet, your ledger or something from your safe. So with the count abstraction you can add this kind of flexibility.
00:04:16.738 - 00:05:02.140, Speaker A: But what's great is that you can have this, that it can evolve with you. You can start as a new user and have something as simple as you like and then later have something as complex as you like, adding features by changing the implementation in place. Another thing it solves is that gas payment becomes flexible. Basically, any contract, anyone can pay for the gas. It doesn't have to come from the account itself. So the account could pay for its own gas, or a third party could do it. For example, adapt could sponsor its user's transaction when the user transacts with a specific contract.
00:05:02.140 - 00:05:59.760, Speaker A: Or the user could pay with ERC 20 tokens and a paymaster will convert it automatically and pay with ether. That's also great for a cross chain because even if you have ether, maybe you want to transact on another chain where you don't have the native currency. It's useful for privacy because you could have a paymaster that helps you pay for the gas when using a new account, so you don't have to associate the new account with an old one. And it's great for dapps. Dapps can have a lot of flexibility when using such accounts. The low hanging fruit is of course batching, so you can have multiple operations in a single transaction. For example this approve and a transfer from flow becomes one transaction.
00:05:59.760 - 00:07:00.560, Speaker A: You can add a lot more things such as session keys, which means if you want to use your account with a game and you don't want to sign a transaction, you don't want to sign every operation in the game while you are using your NFT. For example in this game, then you want to give the key to your browser and the browser will sign on your behalf. But you don't want your browser to be able to transfer your assets. So you could add another key to the account which is generated in your browser and you say that this key is only allowed to transact with the game, it cannot transfer any assets. So then you get much better ux without having to take a risk. And since the operation can be done, we separated the authentication from authorization. So operations can be triggered by anyone who's authorized to do it, not necessarily by the owner.
00:07:00.560 - 00:08:09.208, Speaker A: It allows us to automate certain things, such as recurring payments where someone charges you a monthly fee and you don't need to sign it every time. Or you can check certain criteria, such as to perform a trade, to trade a certain token only when it reaches a certain price, and you don't need to sit at your computer and wait for its price in order to sign a transaction. Instead, you set the conditions in your account and then adapt. Or anyone else actually can trigger your account to perform the trade only if the conditions are met. And why is it called account obstruction? So that's not a great name. The name was given to it by protocol developers, not by users. And what's being obstructed is all the aspects of implementing an account, which means the authentication and the cryptographic signature, the replay protection, the gas payment, it's all hard coded in the protocol, so the protocol needs to be aware of it.
00:08:09.208 - 00:08:47.584, Speaker A: But with account obstruction, the protocol no longer cares. The network doesn't care how it happens, so it's obstructed from the network. It's not obstructed for the user. So for user, it's a concrete functionality, it's not abstract. Therefore I like to call it smart accounts rather than when talking to users. It's a smart account, it's not account abstraction, and the idea of account obstruction is as old as Ethereum itself. Vitalik wrote the first post about it in 2015, a couple of months before Ethereum launched.
00:08:47.584 - 00:10:03.870, Speaker A: And since then, researchers have been working on it for about nine years now, which makes it pretty much the holy grail in Ethereum, and it's been taking very long to figure out how to do it right. In the early days of account obstruction, with some contact wallets, we learned some security lessons that are worth keeping in mind, such as the parity wallet that used to be the most popular one in 2017, and it got hacked and later also completely frozen, costing users a lot of money. So we learned that account obstruction also has downsides. It brings a lot of benefits and is worth doing, but it opens a new kind of risk of a smart contract bugs. So they need to be well audited. Then. In subsequent years, research accelerated, and in particular, the quilt team did a lot of research on protocol level account obstruction, trying to move the ecosystem through a protocol to account obstruction using a protocol change.
00:10:03.870 - 00:10:46.432, Speaker A: We also learned that this is really hard, it's really hard to get consensus on it and to change the protocol. And we have a chicken and egg problem. In order to agree on what account obstruction looks like and understand that it's safe, we need to gain some traction. We need to experiment. But on the other hand, you can't experiment with something that requires a protocol change, because you can't do anything until the protocol supports it. And in parallel, we started seeing some practical approaches. We started seeing wallets that show what account obstruction can do, such as diagnosisafe or argent.
00:10:46.432 - 00:12:09.720, Speaker A: They demonstrated things like social recovery and many other capabilities, but they required a centralized relay in order to pay for the gas. So there was some centralization risk here. In the past two years, we started taking a more practical approach to experimenting with account abstraction, with ERC 43 seven. The idea is to make it an ERC, so you can start experimenting immediately on every EVM chain and not wait for a protocol change. And so, and in the last year, when in the last year we started also seeing some layer tools, in particular ZK roll ups using adding native account abstraction, basically taking the principles from ERC 43 seven, the same kind of maprotection, but apply it at a protocol level. And this started an ecosystem of new wallets that take advantage of this. So what is ERC 43 seven? First of all, it's full account abstraction means we obstruct every aspect of the account.
00:12:09.720 - 00:13:10.680, Speaker A: We abstract authentication, which means you can use any signature scheme you like, not just ECDSA, so you can use, for example, any device that you can use your mobile device that has a secure enclave and sign transactions with your fingerprint, for example. And we abstract authorization so you can authorize any, so you can have any access policies you like. We abstract the replay protection so you don't have to use an incremental nons. And it opens some interesting use cases, in particular when it comes to privacy and multitenant wallets. It abstracts gas payments, so any contract can pay for the gas and you can implement any logic that does it. And of course execution is abstracted, which means that you can have things like batching and things that are specific to assisting certain dapps. You can have them as part of the wallet.
00:13:10.680 - 00:14:49.850, Speaker A: Now all of this stuff was also possible using a smart contract account before we created a standard, but in a centralized way, using centralized relayers. And a key focus of the ERC is on being censorship resistant and fully decentralized, so there are no centralized components in the system. It uses a mem pool, a network of bundlers so there's nothing centralized to be attacked. And this has been like most of the work on this protocol was, around that security in order to make it robust. There are also multiple client implementation, multiple implementations of the bundler written by different projects in different languages, which is a similar strategy to what we do with Ethereum clients. And most importantly, no protocol change, which means that you can start using it immediately on every EVM chain, and then layer twos can start adding it to the protocol level in a way that doesn't break compatibility for wallets. And this week we announced that it's available on Mainet and on thank you.
00:14:49.850 - 00:15:57.520, Speaker A: So we passed an audit with open zeppelin and no critical issues were found. We deployed the contract on Ethereum and on many other networks, both mainnets and testnets, so you can start using it, and there are already bundlers running on these networks, so it's all waiting for you and you can start deploying and using stuff on any network. Now I know of several wallets that are in advanced stages of being built or even audited, so I think we'll see some announcements about that soon. And to make it easier for everyone to start doing cool stuff using this, we also announced a grant round the ESP the Ethereum foundation is running an account obstruction grant round. So if you're building something unique and interesting using ERC 437, you could consider applying for a grant. You have the link here. I will also have it as a QR in the last slide.
00:15:57.520 - 00:16:34.820, Speaker A: And where do we go from here? So this is only the first step. We don't want it to always remain just an ERC. We want to see things being done more efficiently at the protocol level. And we already saw some layer two starting to edit. And on these layer twos we see an emerging ecosystem of wallets with much better usability than we have on other networks. So I think we'll see this trend continuing. We'll see this trend continuing, we'll see more layer twos.
00:16:34.820 - 00:17:54.848, Speaker A: Adding protocol level, account obstruction and the fact that they will all use the same standout means that wallets don't need to worry about it. As a wallet developer, you don't need to think about how you support each network, you implement it once and it works everywhere. And by removing this fragmentation, we allow wallets to focus on having the best usability, the best security, having features for users. So it makes ux better for all of us. Since wallets, they don't need to spend the efforts on fragmentation and can really focus on user value. The end goal is to come full circle, and as I said, we always wanted to have account abstraction at a protocol level, but it was hard to do so now, after gaining enough traction and starting moving layer twos toward the native account obstruction, hopefully at some point we'll be able to move the entire ecosystem, even including Ethereum layer one, although this will take much longer to figure this out. But that would be the end goal.
00:17:54.848 - 00:18:38.800, Speaker A: And I think I'm also out of time. So I leave just a couple of minutes for questions here. And you have the QR here if you want to look at the grant round. Thank you. Do we have time for a couple of questions? Okay, yeah. Okay. So it seems we have a very little time for questions.
00:18:38.800 - 00:19:20.724, Speaker A: So if anyone wanted to ask anything, it. So where exactly is the logic living for the account abstraction? You know that the network will validate that the transaction actually fulfilled. So the logic is in the account itself. The account is a smart contract. It has code. So you implement a contract that has a validate function called validate user op. This function looks at an operation and says whether it's willing to accept it or not.
00:19:20.724 - 00:19:43.240, Speaker A: So you can implement, for example, the signature scheme. Let's say you want to use BLS, you want to use BLS, or you want to use any other form of signing. You can verify it there. You can also verify the replay protection because the nons is obstructed. You verify everything you need in order to decide that you are willing to accept this transaction, and then it gets executed by the protocol.
