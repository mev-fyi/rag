00:00:00.570 - 00:00:29.830, Speaker A: Okay, thank you. Okay, so let's start explaining what is cow protocol? So, cow protocol is a metadex aggregator. What it means is it's a decentralized exchange, but also aggregates liquidity from different sources. For example, uniswap or Susiswap. But additionally it aggregates other aggregators. So. That's right, it's an aggregator of aggregators.
00:00:29.830 - 00:01:09.060, Speaker A: Additionally, it provides to the users meb protection by default. So without thinking, the users will get protection from front running or sandwich attacks. On the left, you see this screenshot of calsop and calsop. Looks like uniswap is a swap interface. But don't be mistaken, because underneath there's some cool architecture. Let's dig a little bit deeper by seeing a simple workflow. So a user place an order.
00:01:09.060 - 00:02:05.640, Speaker A: What is an order? In cow protocol, an order is limit order. So you define a limit price that will be executed at that price or better, and then you have a deadline, so it will execute before that deadline or not at all. But one important change with other dexes is that there's no transaction cost for submitting an order, so it's totally free. This is because it uses metatransactions. So you sign it off chain and then submit it to off chain API. Does this mean that it's free to trade in calswap and in cow protocol? Not at all. You have to pay some fee in sell token, but the difference is that first it's included in the price, and also you only pay if the trade goes through.
00:02:05.640 - 00:03:05.362, Speaker A: So this means that you don't pay for reverted transactions or for expired orders. There's another big change compared to other dexes, and is the existence of these so called solvers. Solvers are external parties that will try to bundle trades together in batches, so they will try to find the best price. And they do so by looking into on chain liquidity, so they can provide the same prices as other exchanges like Uniswap, Sushiswap, and also aggregators like one inch. But it doesn't stop there. There's this other concept of matching orders, peer to peer. So when two users send the order at the same time, and they will be matched in the same block, and it won't be necessary to match against external liquidity.
00:03:05.362 - 00:04:12.530, Speaker A: This is what we call coincidence of wants or for short, cowl, and give a name to this protocol. One other interesting concept is the objective criteria. The objective criteria is just a way we have for ranking these solutions, these batches proposals from these solvers, and decide which one of those is the one maximizing the benefits for the user. So it's an objective criteria and it helps with the competition and creates this symbiotic relationship between the solver and the users. Note how this symbiotic relationship doesn't exist in other exchanges where the one executing is the miner and the miner have the opposite incentive. The miner will try to screw the user by reordering the transaction within a block just to exploit their limit price. So after all the solvers provide their solutions, the best one is chosen and then all the trades are bundled in a patch.
00:04:12.530 - 00:04:46.070, Speaker A: It will be executed on chain. I know it's a lot of information, so bear with me. This is documented very well so it's pretty interesting. If you didn't understand all of it, don't worry, just read the documentation, it'll be clear enough. So what we want to present today is this challenge. We create this hackathon bouti to build a UI or an integration and the price is $7,500. So what we want is to increase the order flow.
00:04:46.070 - 00:05:43.420, Speaker A: The challenge is to build a UI or an integration. With the potential of highly increasing the volume and trades happening in cow protocol, there will be other bounties. So please check out the last slide. So why would you care? Why would you want to build on top of this protocol? First of all, this is a brand new protocol. We have been only around six, like a few months and we have been seeing this rapid growth and it's because of this setup and architecture we can deliver better prices and we have special properties that is tailored to the blockchain. You can see how we are scaling up in this ranking of Dex aggregator. Since we're having only a few months, we believe that this year we will be way on the top.
00:05:43.420 - 00:07:12.920, Speaker A: Also because we are pretty new. I think it's interesting to be part of this fast growing project, fast growing community that by the way, this project was kickstarted by Gnosis and it has spin off last week by both of Nosis Dow and now has its own Dow and its own token. There's 50,000 addresses in this Dow and it raised $10 million. This money will be in the Dow for incentivizing things like order flow. So if you decide to build on top of cow protocol, on top of winning this challenge, this bounty, you can also have a future earnings by asking the DAO to receive some tokens or some money for bringing order flow. So why order flow? Why is this important? One property that this protocol has is that the more volume we have, the more orders we have, the better price that everybody gets. So you make the protocol better by bringing liquidity to it.
00:07:12.920 - 00:08:13.900, Speaker A: Our estimations are that without having our own liquidity, just by using external liquidity, because of our efficiencies, we can get 0.5% price improvement. But how? This is due to the coincidence of want that gives name to our protocol. And this is this phenomenon where two users want to trade at the same time. And since the blockchain is discrete anyways, that there's blocks every few seconds, then there's going to be people trading at the same time opposite orders. So when this happens, and it happens all the time, when this happens, we can get like gas cost savings because it's cheaper to submit a bundle transaction with several trades. Then the cost per trade reduces, so the user needs to pay less gas so they get a fair price.
00:08:13.900 - 00:09:09.706, Speaker A: Also, it's cheaper to settle a trade peer to peer, gas wise, than doing it in an automatic market maker like uniswap. Additionally, if you don't go to uniswap to take this liquidity, you don't have to pay this liquidity fee that normally you would need to pay. So when a trader trades something, they will need to pay this 0.3% per hop, and then the opposite trade will pay another zero, 3% per hop again, and it's compounding. So because you don't have to pay this fees, there you got another benefit of coincidence of ones. And last but not least, it protects user from mev extraction. And how is this possible? Imagine two users trading at the same time.
00:09:09.706 - 00:10:01.642, Speaker A: Their volumes will be canceled to each other and be executed in an atomic transaction. This volume that is canceled doesn't matter that you reorder this transaction within a block, it won't be exploitable, so there's more protection. All this take us to better prices and more peace of mind for the user. Now, zooming in a little bit, let's see, what do you need to do? In order to bring order flow? You will need to approve a token for trading. This is pretty standard for all the dexes, so it's something you had to do only once is sending this transaction to Ethereum for this ERC 20 approval. Once you do this one time thing, you can send any number of orders for free. And the process is the following.
00:10:01.642 - 00:11:15.570, Speaker A: You get a price from an API, then you sign an order, and then you post a signed order. The solvers will be observing these open orders, finding this solution, running these algorithms to find the optimal liquidity paths for the users and then submit this batch that include the execution of these trades. So note how the solvers are the ones paying the ether for the transaction and not the users. However, they get the money back because the users agree on paying a fee, but only if they trade, not if they don't. So continuing zooming in a bit more how do we get a price? One way to do it is just to query this cow protocol API and it's as simple as submitting your intent to trade. You say I want to trade sell. I want to sell ten west for USDC and the endpoint will return the price, the fee and the expiration.
00:11:15.570 - 00:11:56.686, Speaker A: The price is straightforward. The fee is the amount of sell token that you need to pay in order for the protocol to accept your order. And what it calculates is how much cost your order to be settled on chain. And it's assuming that other people will be sharing your cost in the bundle so you will get a cheaper price. Then what we need to do is sign in the order. How do we do that? There's different options for different scenarios. The most common one is the off chain signing.
00:11:56.686 - 00:12:34.618, Speaker A: I was mentioning before this. Using EAP 712, this allows gasless trading for eoas like metamask. This is the approach that cowswap uses. However, there's this other method that is pre signed and is just a smart contract call and allows protocol integrations. So if you decide to, instead of doing a UI to do protocol integration, you would be using this. Then this last method that is smart contract signing is AAP 1271 and allows gasless signing for a smart contract. It's pretty cool.
00:12:34.618 - 00:13:11.560, Speaker A: It's supported by the protocol. However it's not supported currently by the API, but will be soon. So we have to prepare our raw order in order to sign and the raw order will have all the fields that you would expect, like the sell token by token. But then you need to define the price by the sell amount and by amount by the relationship. And what price should you use? It's up to you. If you set the price too high, it's going to be a limit order. It will execute in the future because it cannot be executed given the current market price.
00:13:11.560 - 00:13:51.430, Speaker A: For example, what cowswap does is allows the user to select his slippage, and then we apply this slippage to the price returned by the API I mentioned before. And then you provide the fee amount that was returned in the previous step. So once you have the raw order, you sign it and you sign it by using EP 712. But for convenience. We created these NPM packages that you can use for signing in a simpler way. This part is abstracted. This is how it looks cal swap when you sign an order.
00:13:51.430 - 00:14:29.230, Speaker A: So you'll see this structured data with all the fields of the order. This is how we define the order. Once the user review this information, they can sign it. So next step once you have a raw order signed, is to prepare the signed order that we need to send. So that's trivial because we already have the raw order. So we only have to add the signature that we got in the previous step. Then with this signed order, we post it to the API and the API will return a unique identifier.
00:14:29.230 - 00:15:08.878, Speaker A: This unique identifier will become very handy if you want to check the state of your order. That's the normal thing to do after. So there's two ways you can check the state of an order. The first is just to watch for trade events in the settlement contract. So every time a solver delivers a solution in a batch, there's going to be a settlement with a bunch of trades. Okay, I'm going to wrap it up. So the other way is using the API, and there's a convenient endpoint for that.
00:15:08.878 - 00:15:52.720, Speaker A: Wrapping it up. Cow protocol is a metadex aggregator with some properties it's gasless, you don't pay for reverted transactions. It aggregates any onchain liquidity and is MEB protector and it finds coincidence of want which gives you better prices. Cowsup is its interface and is powered by cow protocol. We're launching this hackathon bouting of 7500 and the goal is to build a UI or integration that increases the volume and trades. I hope this is interesting for you and you decide to build on top if you do. So we have a lot of resources you can use and examples with just snippets of code.
00:15:52.720 - 00:16:06.780, Speaker A: Just scan the QR code on the left. Thank you very much. Happy hacking. You close.
