00:00:00.170 - 00:00:19.920, Speaker A: A grant the past few months for their new domain specific language, noir. And what we did is we took a preexisting project called Battle Zips, rewrote the ZK circuits in the language noir, built a front end around it, and also produced an eight part video series that'll be live soon, along with a live app.
00:00:23.940 - 00:01:16.820, Speaker B: All right, so while we're are talking about essentially building a video game, it's important to note that this is really just meant to be a simple example of what you can do with zero knowledge. Battleships is a really great example of an adversarial, multiparty hidden information game. And that might sound like a bit of a mouthful, but this relationship actually pervades most of our economic interactions. And I'm sure some of you in the audience who have these preconceptions of how they want to use zero knowledge will likely be able to use it. So the point is to take it, and ideally, you will be able to start your noir journey with a lot more speed.
00:01:18.440 - 00:01:54.140, Speaker A: And on that note, let's get into what Noir actually is. So, as mentioned before, noir is a domain specific language created by aztec network for the sole purpose of writing zero knowledge circuits. Now, let's break down that term domain specific language. So, a domain specific language is a language that has a narrow application or a narrow use case. So an example everyone might be familiar with here is CSS. CSS is used solely for styling front end applications in the browser. Another example would be SQL, which is used for querying relational databases.
00:01:54.140 - 00:02:55.472, Speaker A: Similarly, Noir is a language solely used for writing zero knowledge circuits. Now, a question you might have is, why would this be important? Well, for those of us who have done it in depth with zero knowledge cryptography before, we know that there's a lot of underlying math and cryptographic principles that make it a rather complex topic to get started with. So I don't think many of us can say we've graduated from a university with a PhD in cryptography. So DSLs are a way of making the process of creating zero knowledge proofs a lot simpler. It provides a high level interface to be able to create proofs without really needing to pay mind to any of the underlying math or cryptography. So incredibly important for making it so we can get to a point where we focus less on the overhead and the makeup of zero knowledge cryptography and focus more on exciting use cases that it can be applied to. Noir specifically is a language derived from rust, and it inherits similar syntactic structure.
00:02:55.472 - 00:03:39.072, Speaker A: For anyone who might have experience out there in the audience. So for loops, have a similar range spread operator. There's similar types such as structs that make it a familiar experience. And for those who don't have prior experience with Rust, I personally didn't have a ton of experience going into this, but it took me a couple of hours to really get comfortable with the language. So overall, it's not very hard to get started. The cool thing about Noir is that it's proving system agnostic. So what it does is it compiles to an intermediate representation called Acer, and this basically allows you to choose a proving backend of your choice.
00:03:39.072 - 00:04:22.288, Speaker A: Right now, plank is supported as well as Marlin, and there's another ZK library implemented in go called ganaric that is currently in the works of being implemented. But eventually other things like Halo will be put inside. So it's cool that you're able to really choose your proving system of choice and not really have to change the way you interact with the circuit. You'll still be able to use the packages that Aztec provides for generating and verifying proofs. And that being said, it provides a few NPM libraries so you can generate, verify, and test proofs in a typescript context. And it also provides a command line interface called Nargo. And I think this is a good time.
00:04:22.288 - 00:04:58.540, Speaker A: We hop into a bit of a demo here, try and work with this. Yeah. All right, so we'll start off by creating a new noir project. We run the Nargo new command, and we specify a directory name of our choice. So we'll call this Quick demo for bigger. Sorry, it's a little messed up here. We'll go ahead and create the directory.
00:04:58.540 - 00:05:14.320, Speaker A: There we go. Okay, that's a little bit better. More. Okay. Control plus. Yeah, that's what I'm doing. Sorry, it's a little messed up.
00:05:14.320 - 00:05:31.830, Speaker A: Let's go ahead and open the quick demo directory. And now this will pop the project open in vs code. And this is a. See if I can control. Plus this. Yeah. Okay.
00:05:31.830 - 00:06:17.724, Speaker A: This is a very bare bones noir application. So we have a Nargo tomo configuration file. This is for specifying dependencies that might be included in your noir project, as well as metadata that goes along with it. You have a source directory with a very bare bones basic implementation of a circuit hopping in here. So this is where, similar to rust, you have a main function to specify all private public inputs that might be involved in your circuit, as well as return values, which we won't get into detail here. About to generate constraints in noir, you use the constraint keyword. And on the right hand side, you have a Boolean comparison.
00:06:17.724 - 00:06:50.700, Speaker A: Now, what differentiates noir a little bit from other dsls you might have experienced is that we have more flexibility when it comes to generating constraints. So instead of having just a equality comparison, like other languages offer, we also have negation. We have comparison, which I personally think allows a lot more of a familiar experience for traditional developers coming into the ZK space. But now that we've shown that off, let's go back to the original setup and show how we can prove and verify.
00:06:54.240 - 00:06:55.016, Speaker B: Bigger.
00:06:55.128 - 00:06:56.510, Speaker A: Bigger. Okay.
00:07:00.740 - 00:07:01.708, Speaker B: Way bigger.
00:07:01.804 - 00:07:12.770, Speaker A: Okay, let me try. Better. Too much? Two more. Two more. Okay. It's a lot bigger on my screen. I'm sorry about that.
00:07:12.770 - 00:07:57.328, Speaker A: Okay. Is that good? Okay, let's show how we can go ahead and prove and verify prove and verify proofs via command line. So we first want to generate our approver and verifier files. We do this by running Nargo check, and this will generate a proverb tomo and a verifier tomo prover contains all public private inputs as well as return values. We'll go ahead specify y is two, x is three, and then specify y is two. Here in the verifier tomo and verifier is just for all public returns and public inputs. So now that we have those implemented, we will go ahead and run nargo proof and specify an arbitrary file name.
00:07:57.328 - 00:08:37.112, Speaker A: The stick convention will call it p, and this will generate a proofs directory with our p proof file. With this now generated, we can then verify our circuit. So Nargo verify p. We can see the proof is verified and constraint system checks out to true just to show what it would look like if it were an invalid constraint system. If we tried to run Nargo proof here, it would say could not satisfy all constraints. Just because we don't have a lot of time, we're not going to go over everything that Nargo can do. But last important feature is that you can generate a verifier contract through your proof quite easily by running Nargo contract.
00:08:37.112 - 00:08:58.260, Speaker A: This will create a new directory, and you'll be able to find it here. And we'll go more in depth on what verifier contracts can do, how they're structured in the coming slides. But next we'll move on to showing how our circuits are structured for battle zips. Hold up.
00:09:01.650 - 00:10:07.314, Speaker B: So, in order to start a battleship game, essentially each player needs to submit a board proof, and this locks them into their board configuration for the duration of the game. And the board circuit encodes basically the rules of how you can place a ship down on the board in zero knowledge, and it accepts the ship coordinates as inputs, and then it will take those and essentially construct a 100 bit number that is a serialized ten x ten board. So, once we've verified the veracity of the board state, we actually need to export it into the public domain via some sort of commitment. And in the version we have here, it's a little imperfect. We use the Peterson hash, which is readily available. However, it only provides computational binding as a property. It would be pretty trivial for a well endowed threat actor to brute force the actual commitment here.
00:10:07.314 - 00:10:52.594, Speaker B: So what you could do, just off the bat, in fact, some of you in the audience, if you're kind of looking to start playing around with this, this would be a really easy thing to do, is to just add a salt, a private salt. So that would be a private input for the proof that it's hashed with the rest of the hash. So that would provide computational hiding, but we can actually take it one step further. And this is something that isn't quite ready for noir, I think. But in another code base, individually, we contributed to. We actually used the Peterson commitment, which is very close to Peterson hashes, but a little bit different. And commitment schemes, they provide the computational bindingness, but also perfect hiding, which is really important.
00:10:52.594 - 00:11:41.300, Speaker B: So, ideally, you want to be using a commitment scheme, but for now, we are going to be using a Peterson hash. So, essentially, to sum up what the board proof does, it exports a public commitment board commitment, along with a zero knowledge proof that says that this board commitment is a Peterson hash of a valid battleship board. And we can take that commitment and send it to the smart contract, which we can then use for shot proofs later on. So the shot proofs are a lot simpler. Most of the heavy work is in the board proof. It does the same thing where it verifies the pre image of a board is the public commitment. And this is where the smart contracts are very important.
00:11:41.300 - 00:12:42.374, Speaker B: Essentially, you want to have the board proof, output your public commitment, store that in the smart contract, and then for subsequent shot proofs, the smart contract will inject the board commitment without you having the chance to put anything else in. So, this is the way that smart contracts and zero knowledge need to work harmoniously together in order to enable true trustlessness. Basically, we've got the board state bound. Now the circuit is also going to take shot coordinates, coordinate pair, as well as a hit or miss assertion. And this will check in zero knowledge. It'll check whether or not that hit or miss is correct without revealing any information publicly about the board state. And finally, along with the use of shot nullifiers in the smart contract, we basically just look for 17 shot proofs that say that a hits occurred and you know that the game is over.
00:12:42.374 - 00:12:43.400, Speaker B: It's been won.
00:12:46.110 - 00:13:18.180, Speaker A: Awesome. So now going back to the topic of verifier contracts. As mentioned before, noir allows you to generate contracts very easily from preexisting circuits. You can do this either via Nargo or from their typescript libraries diving into the smart contract infrastructure. Just go back to the code base one sec. Make sure that everyone could see it this time. This thing is like five times bigger on my screen than up there.
00:13:18.180 - 00:13:59.582, Speaker A: Okay, so now that we have this open, let's look at the board verifier. So there's a lot of low level assembly code in the verifier contracts we're not really worried about. All that we're really concerned about is this verify function. There it is, this verify function here it takes proof as an argument of types, bytes, call data, and returns a boolean result. Whether it's a valid proof or an invalid proof. You can call verifier contracts directly, which if you want to just directly verify a proof, I guess you could do that. But what's really interesting is when you integrate it into existing smart contract infrastructure.
00:13:59.582 - 00:14:58.454, Speaker A: Looking at the battleship game contract here we have it. So the board verifier is integrated, and we cannot start a new game unless there's a valid board placement. The same with the join game function if you're joining an existing game. And then finally looking at the turn function when we take a shot, you're not able to update game state unless you have a valid proof there. So by integrating smart contract or verifier contracts into preexisting infrastructure, you're able to achieve trustless adversarial multiparty computation in a way that wasn't achievable before moving on to the last part of the project. It was the front end integration of our proofs, and this was definitely one of the most difficult parts, because although there are NPM libraries that support interacting with noir proofs and typescript, they are not browser native. So it took quite a few hacks and tricks to actually get this to work.
00:14:58.454 - 00:15:39.102, Speaker A: So pulling up the front end repository, give me 1 second here. The first thing you have to take sorry, I lost it. The first thing you have to take into consideration is the fact that later versions of React scripts after version five do not support automatic polyfilling. What polyfilling is, is it's a way of taking node native packages and turning them into a browser compatible format where they can be ran there. And you have a few ways of doing this. One thing you could do is you could eject the entire react app running the eject script. But I personally don't like this because it's messy.
00:15:39.102 - 00:16:33.202, Speaker A: It exposes all of your configuration files and also all of your dependencies or all the dependencies that exist inside of the react dependency, and your project just ends up getting very cluttered. So not a way I would personally go, but luckily we don't have to do this all the time. There are a host of libraries that allow you to override configuration without actually ejecting the app. A notable one is react app rewired. Another notable one is Craco, and we ended up going with that. So what you do instead of ejecting your app with one of these libraries is you specify a configuration file where you're able to specify your polyfills, other configuration overrides you might need, and avoid all of the headache of exposing the underlying packages and files you wouldn't necessarily want to expose. The next notable challenge is just running the packages in the first place.
00:16:33.202 - 00:17:15.482, Speaker A: So we have to take the webassembly files for the NPM packages and paste them into the browser. So going to the public directory here you have to have the aztec backend package, the Breedenberg package, and the noir webassembly package. On top of this, you also have to have a bufferized version of your circuit. Acer again, Acer we touched upon before. That's the intermediate representation that noira compiles to, and you also need the bufferized version of the circuit itself. We can see here we have this for board the shot. So a bit of consideration before integrating this into a front end, it could definitely get heavy copying and pasting all these files.
00:17:15.482 - 00:18:15.858, Speaker A: But if people are interested in checking this out on their own, we did make a script in our main repository to auto generate these files and copy them to a subdirectory, so you can just copy and paste them over to your front end. We're going on to where the proofs are actually integrated. Looking at the give me 1 second here, can't see anything. Looking at the build board view, we're going to look at where the board proof is integrated. So we have a start game function which kind of abstracts away from the contract tulls. So what we do here is when we start a game and actually this is for starting a game and joining a game based on whether there's an id in the URL. But you start off by converting these ships, looking at the head of each ship, that is where the ship is first placed on the board, getting the x coordinate from there, the y coordinate, and then the z value, which is orientation, whether it's placed horizontally or vertically on the board.
00:18:15.858 - 00:18:56.474, Speaker A: After that, we pass the board into a boardproof function. We create a hash the board, and we use the Aztec Breedenberg library to generate a Peterson hash in typescript. And there's a lot of other helper functions that it provides as well. We're not going to get into here, but we take that hash, pass it into the ABI for our proof, flatten the board because noir only supports 1d arrays right now. So this is going to be an array of length 15 representing the position of all shipheads. And then we pass the ABI and the name of the proof into a generate proof function. And in here we take two arguments.
00:18:56.474 - 00:19:43.886, Speaker A: We take the proof type which can be either board or shot. We have the input which can either be the boarded ABI or the shot ABI specifying each respective proofs input. We then initialize the noir webassembly package imported here. And then from there we take our circuit files, the circuit itself, transform it from a buffer to a un eight array, and then the same for the acer file. But instead of leaving it as a byte array, we then use a function called Acer from bytes imported from the noir webassembly package. This allows us to get a valid Acer representation for the circuit in the browser. Finally, we pass it into a setup generic prover function.
00:19:43.886 - 00:20:39.458, Speaker A: And we're not going to jump into this because it's quite complicated and it's going to take too long here, but you pass in the circuit there and the explicit size of the circuit, and then it will output a prover on your front end. The next step is to generate a web worker. Now this step isn't critical, but with larger proof sizes in the browser you're going to end up running into a webassembly memory error. So a web worker is a way of executing code off the main worker thread and instead running it in the background so it doesn't disrupt the main execution flow of a JavaScript program. And when you initialize a web worker, you check for an error promise and a result promise for a on message event. So passing in the circuit, or what we pass into the web worker, is the acer representation of the circuit, the input for the circuit, and then the document URL. Just jumping into the worker real quick.
00:20:39.458 - 00:21:44.886, Speaker A: We take what we pass into our message event handler and convert it to hexadecimal. Initialize the aztec back end which is imported up here, and then finally take a function imported from there called computewitnesses. Compute the witness in the browser, pass it back through the event handler, and going back to the loss of file here, going back here, finally get the witness after the promise is resolved, use the prover we generated before to create a proof, and then return it back to the build board view. And then finally we return the ship hash and the proof. And going back to our smart contract function, we apply these to the function parameters, input it to the smart contract, convert the hash to a big number and pass in the proof. And either call, join game or new game respectively based on what you're trying to do. So that's the board circuit, and then for the shot circuit we go to the game view.
00:21:44.886 - 00:22:34.150, Speaker A: And similarly we have a wrapper function here for taking a shot or calling a shot function on the smart contract. So one thing to note real quick is that the first shot is not going to generate a proof. If you think of battleship, you only have a confirmation whether there's a hit or not from the report from the other players. So what we have to do for this, we pass a report back in these secondary shots that follow the first one. So all secondary shots generate a proof, but the first one will not. But for the secondary shots, we go through a prepare shot proof function. We pass in the last or the shot coordinates, which is an array of length two representing the x and y coordinate of the shot, and then a hit attestation whether or not a shot has actually come in contact with ship.
00:22:34.150 - 00:23:46.110, Speaker A: We do similarly to the board proof, convert these ships to a format friendly to the circuit, pass this into our shot proof function, generate a ship hash again, convert the boolean value of hit to a binary value, one for hit, zero for miss, flatten the ship array so it's a 1d array again that can be passed into the circuit, and then finally pass in that 2d shot array. And then finally going back to the shot function again, we then take the proof and the other parameters we need, pass it into the smart contract function, and if everything is valid, then we will update the game state. And that is a overview of the proofs integrated into our front end. One thing I do want to mention, because this is quite complicated, Aztec has been working really hard the past few months. On implementing versions of their NPM packages that are browser native by default. So this might actually not be a concern in the next few days. So if you want to check it out, see how we implemented it, our repos were linked, but you might not have to worry about that anymore.
00:23:46.110 - 00:23:50.800, Speaker A: But yeah, that touches up on our proofs integrated in the front.
00:23:52.450 - 00:24:27.718, Speaker B: Yeah, and also there's a lot of stuff coming out for Noir. Ultraplonk ClI is right around the corner. Browser integration is a little later in March, so lots to be excited about. That'll be huge for recursion. Anyways, hopefully you were able to learn a little bit about Noir and maybe apply a little bit to the hackathon, but it doesn't have to stop at ETH Denver. There's a ton of work that can be done with noir, if you're interested. That includes right now, noir exports EVM verifiers.
00:24:27.718 - 00:25:20.490, Speaker B: So you can use any Ethereum chain, but Solana, Starkware, Cosmos, all the other chains you can think of that aren't EVM could possibly have Noir verifiers integrated. There's a ton of circum projects out there, Macy, dark forest, tons out there that can simply be ported over. Pretty easy project. There's a bunch of cryptographic primitives that have already been built and are in the standard library, super useful, but there are some that are also not there. So you have the ability to work on some of those, which would be standard imports for everyone else using Noir. And if you have strong conviction in your own ideas, you should bring that to noir. If you have a really good idea, they will work with, you should work with them to try to bring it to reality.
00:25:20.490 - 00:26:07.980, Speaker B: So just to really quickly put it up there, we've got a battle zips discord where it's basically just any developer question around zero knowledge. Come in there, ask it, and we'll do our best to figure it out. There is the aztec discord, which is fantastic for getting first party help on noir. It's by far the best place you could seek out debugging tips. And just another mention is if you are interested in zero knowledge in general, one of the absolute best places to be would be the Ethereum foundation privacy and scalability explorations discord, which powers a lot of the ZK space. The end.
00:26:08.510 - 00:26:37.230, Speaker A: Thank you. Yeah, thanks.
00:26:37.840 - 00:26:38.860, Speaker C: I don't know if you got that.
00:26:38.930 - 00:27:12.950, Speaker B: Yeah, I think I got most of it. So the question was essentially, what does it look like when you're interacting with all of this? Sure. So a zero knowledge proof is two sides, the prover and the verifier. And the verifier is what goes on chain. It's important to have that on chain because that lets you decentralize the verification of it. That's kind of like how actually roll ups function so well is because they verify all of that in that one go. And then.
00:27:12.950 - 00:27:41.560, Speaker B: So from the browser or from a CLI, whatever you're using, like, you could hook it up with test scripts, you would generate the proof itself in Javascript. So, again, that looks like the web worker in the browser, but it's very easy on front ends or back. Yep. Do you generate wasm code for the verifier as well?
00:27:42.250 - 00:27:54.010, Speaker A: Wasm code for the verifier? Yeah, it comes from a package that Aztec provides. Which one? It comes from the Bret and package, I believe. Yeah, it's a Bretenberg package.
00:27:54.510 - 00:28:11.676, Speaker B: Yeah. That is wasm that's generating. Don't. So are you asking if the circuit artifacts are. I. I don't think the verifiers are in Webassembly.
00:28:11.868 - 00:28:13.040, Speaker A: I don't think so.
00:28:13.190 - 00:28:26.790, Speaker B: Yeah. So I think that the verifiers are pretty simple when it comes to, like, you could store it in JSon. It's the proving step that is in webassembly. So it's just not heavy enough to really need that.
00:28:30.820 - 00:28:45.190, Speaker C: So I might have it wrong. The verifier, right, lives, like you say, on any chain. Effectively, that's the important part. But this interesting part that noir brings to the party is this intermediate representation so that you can compile down to this thing that can eventually land, like on EVM or.
00:28:45.900 - 00:29:06.110, Speaker B: Yeah, yep. Yeah. I would say that the ACIR is probably a little bit for proving. Yeah. And I think they only have VVM right now, so I think, actually you're probably right. Once you start getting those, the ACIR will be able to just go from any proving system to any chain. So that will be very nice.
00:29:07.920 - 00:29:34.436, Speaker C: One last question. So, is this interactive, where I need my counterparty to be online, or is all of the provable material? So, like, we commit to a hash, and even though I've committed something on chain, I can't actually understand the board state, but I can probe it. So I'm curious, can I also just effectively offline try all these different states? Let's say I can basically find your board. Can I discover it?
00:29:34.538 - 00:29:41.044, Speaker B: So that would be the computational hiding thing we were talking about, the way this is implemented.
00:29:41.092 - 00:29:41.256, Speaker A: Yes.
00:29:41.278 - 00:30:13.070, Speaker B: You could brute force it, period. But that would be, again, very simple. To solve in a basic way, you would just add another input to that hash, which is like a trap door or something like that, and you just make that a private input, and you've basically solved that computationally. And Peterson commitments would be just one step further. But, yeah, you absolutely could do that. And then on the topic of having to be online really quickly, you don't. As long as that data is there when you log back on, it's fine.
00:30:13.640 - 00:30:19.490, Speaker A: I think we're out of time here, so we'll be over to the left hand side of the stage for any more questions, but thank you.
