00:00:00.970 - 00:00:28.120, Speaker A: Okay, good morning. We're just about ready for our second workshop of the day, our pre hackathon workshops. Another reminder for those that didn't hear before, those who have just shown up, we have two stages here. This is the main stage, the ETH stage. Over here we have the way stage. So check your program, check your schedule. We have multiple full workshops on both stages throughout the day.
00:00:28.120 - 00:00:52.406, Speaker A: If you're thirsty, you need some caffeine. Refreshments are right back there. So we just had Haseeb Rabani up here talking about ethers IO. We're going to invite him back up as well. And also Hudson Jameson. Hudson needs no introduction for those longtime Ethereum people. He is a moderator of the Ethereum subreddit.
00:00:52.406 - 00:01:08.020, Speaker A: He works with the Ethereum foundation and is working on a variety of projects. We're going to hear from them about solidity and metamask and a bunch of other cool things that are happening in terms of the coding infrastructure of Ethereum. Come on up.
00:01:10.550 - 00:01:11.250, Speaker B: Hey, everybody.
00:01:11.320 - 00:01:31.160, Speaker C: Good morning. Oh, nice. I get callbacks. Sweet. All right, so what we're going to do this morning is an intro to solidity talk. I'm Hudson Jameson. I have a startup called Oak and Innovations, and I also work for the Ethereum foundation doing various things like the core dev meeting documentation, other fun stuff.
00:01:31.160 - 00:01:56.946, Speaker C: So yeah, I've been working with solidity for a while. My role today for this talk is I'm going to be out in the crowd with you guys, and if you have a question, if you get stuck, raise your hand and I'll come over to you. And if it's a question a lot of people are having, we'll probably just pause and see what the main problem is with everybody. But I'm out there to help you guys. So call me over. Raise your hand if you have a question. During this talk.
00:01:56.946 - 00:02:01.970, Speaker C: I'm now going to introduce Haseeb, come up on stage and show you guys solidity.
00:02:03.990 - 00:02:39.610, Speaker D: Thanks, Hudson. I'm just going to get my laptop set up real quick. Okay, awesome. Hey, everybody, it's me again, but this time I'm back for the second part where I'm going to talk more about smart contracts and solidity. So again, a little bit about blockgeeks real quick. We develop the blockchain engineering talent that will build the applications of the future. And the way we do this is through our online courses, through a curriculum that we developed.
00:02:39.610 - 00:03:29.444, Speaker D: We also have a bunch of free articles and guides online that you may have come across while you were searching for blockchain articles. And we also do a lot of in person workshops like this, where we demonstrate how to actually make use of these tools. So let's get started. So yeah, before we get into solidity, let's just take a second to appreciate what it's actually doing for us. So EVM Ethereum virtual machine is actually the language of smart contracts. So all smart contracts are written in EVM opcodes, but they look very much like machine language, assembly language, so that's why humans can't really code in that. Right.
00:03:29.444 - 00:04:53.710, Speaker D: So that's why we use high level languages. Some of the high level languages available for the EVM are ll or serpent and solidity. So solidity is the most popular one today and the most officially supported. And it has a syntax very similar to JavaScript, so it's pretty easy to pick up. And real quick, what are smart contracts? So, smart contracts, you can think of them as some logic, some code that you deploy to the blockchain, and once you deploy it to the blockchain, it has an address, and anyone can use that address to reference the contract and interact with it. Right, to send messages back and forth to it, right? And the structure of the smart contract is very much like a class, right? So it's not some new sort of paradigm, it just contains fields and methods, and we use a compiler to compile solidity down to EVM opcodes, which is actually what is run on the Ethereum network itself. So some quick examples of smart contracts, you could program a will that is executed at a given time, so you can say, hey, at this time I want 50% of my wealth to go to this account and 50% to go to another account, and you're guaranteed that it will be executed that way.
00:04:53.710 - 00:05:52.928, Speaker D: You can also use smart contracts as an escrow for just engaging in any sort of transaction with anybody. So it can be this place where you temporarily hold your money while you're engaging in a transaction. You can use smart contracts to write multi signature wallets, which you can kind of think of as like joint bank accounts. So you need at least two people's approval to move any money out of the smart contract. You probably heard of initial coin offerings, which are just like really big sort of crowdfunding platforms, but also smart contracts. And you can also use smart contracts to write your own currency and your own coin with its own use cases around it, right? So those are some use cases of smart contracts, and that's why we want to write smart contracts. So again, I had these slides in my last presentation as well, but just to appreciate what part we're working on.
00:05:52.928 - 00:06:39.010, Speaker D: Right, traditional web apps front end backend, front end written in HTML CSS JavaScript backend usually hosted on AWS, written in rails, django, node, whatever. And they communicate using something like jquery to send Ajax messages back and forth. And DAP architecture. Again, front end mostly stays the same. We're still using HTML CSS JavaScript, as we saw in our last workshop with ethers IO, but we interact with a different backend, which is the Ethereum blockchain and more specifically the smart contracts on the Ethereum blockchain. So that's what we're interacting with. And in this workshop we're going to be focusing on that bottom square over there where we're going to write a bit of the back end.
00:06:43.830 - 00:06:44.242, Speaker B: Cool.
00:06:44.296 - 00:07:27.170, Speaker D: Okay, so let's get to some code. And so the cool thing about solidity is that it comes with a lot of great development tools and one of the most popular ones is called remix. And I'm just going to bring it up over here. So it's an in browser ide, right? So it has a text editor, a debugger, a compiler, all in the browser, right? So you don't have to NPM install anything, you don't have to download anything, you just go to a website and you're ready to write smart contracts. So that's pretty cool. And the address of this of remix is just remix. Ethereum.org.
00:07:27.170 - 00:08:58.210, Speaker D: It's going to give it a minute to load. I'm just going to check my Internet connection really quick. Seems a little slow. So another thing about remix, you don't have to use it strictly online. So it's open source. So you can go to their GitHub page and actually just download the code and run it locally, which is probably what I should have done. But let's give this a second.
00:08:58.210 - 00:09:20.760, Speaker D: 1 second. Anything in the console?
00:09:25.020 - 00:09:54.240, Speaker B: No? Cool.
00:09:54.850 - 00:09:57.360, Speaker D: Okay, I just changed the network. Let me try again.
00:10:04.820 - 00:10:21.380, Speaker B: Yeah. Yes, we just use backup. Yeah, might as well.
00:10:46.440 - 00:11:34.110, Speaker D: Okay, nice. So someone kindly donated a locally running instance of remix so we can still explore and see what's happening. So let me just maximize this a bit so we can read it better. Okay, so this is what the remix interface looks like. I'm just going to zoom in a bit. So on the left hand side you see we have like a file Explorer. We can open files from our local hard drive and we can also create new files over here, which we'll look at in a second, right? So that's the left side in the middle we have our text editor, which is where we actually write our solidity code.
00:11:34.110 - 00:11:53.490, Speaker D: And at the bottom of the editor we have a little terminal which prints out interesting information for us about the contract that we're running, and we'll see how to use that in a second. And on the right hand side we have a bunch of tabs. Never, not now.
00:11:56.920 - 00:11:57.524, Speaker B: Cool.
00:11:57.642 - 00:12:52.040, Speaker D: And on the right hand side we have a bunch of tabs. Compile, run, debugger. And I'm not going to go over all of these right now, but I mean, these are probably the three most important ones, right? The debugger, if you want to step through any transactions to see what's actually going on in your code, compile is pretty straightforward, right? You can set autocompile and you can select which contract you want to compile and run. So run is the most interesting one that we're going to be working with. But let's write a smart contract first, right? So I'm going to create a new one and I'm just going to call it Hodor. Okay, so we'll just zoom in a lot and minimize this for now. Cool.
00:12:52.040 - 00:13:41.832, Speaker D: Okay, so the first line you have to declare which solidity version you are using, right? And we're going to be using version zero 419. The carrot sign is to say that anything above this version number is okay as well. And the way we define our contract, or the keyword that we use is just contract and then we give it the name. So I'm going to call mine Hodor and we'll see why in a short second. But yeah, this is how we define our sort of class for the smart contract. And we can also create a special function which is the constructor for the smart contract. And in the constructor we can initialize a bunch of variables and parameters if we like.
00:13:41.832 - 00:14:34.170, Speaker D: And the constructor is only called once when you first deploy the smart contract to the blockchain, right. That is the only time the constructor is invoked to initialize any state required by the smart contract. So over here all we're going to do, I'm going to declare a field, a string field called greeting, right? And I'm going to declare it public so that anyone can access it. So this public keyword actually generates a getter function for this field, for the greeting field without me having to actually explicitly write out a public getter method. Right? So that's what we get by using public over here. And all we're going to do in our constructor, we're going to pass in a greeting and we're just going to set that to our local field.
00:14:38.300 - 00:14:39.050, Speaker B: Cool.
00:14:41.100 - 00:14:53.580, Speaker D: Okay, so we initialized a variable in our constructor. Now let's define some methods for our contract, right? So I'll define a simple setter.
00:14:59.730 - 00:15:00.094, Speaker B: And.
00:15:00.132 - 00:16:13.652, Speaker D: It'S going to take the string greeting as a parameter and we're just going to set greeting to greeting. Okay, so over here we have a really simple smart contract. All it does is take a greeting and then repeat that greeting back to you, right? So, okay, now we have a simple smart contract and we want to deploy this to a test blockchain. So if we go over to the run tab over here in this environment drop down, we can select which blockchain we want to use, right? So from this drop down I have three choices. I have JavaScript VM, which is just an in memory test blockchain, right? So the blockchain exists only inside this browser tab and if I refresh the page then that test blockchain is gone, right? So that's what JavaScript VM is injected. Web three is mostly for metamask, for detecting any web, three instances that are injected to the page. And right now I don't see metamask installed here, so we're not going to go over that.
00:16:13.652 - 00:16:52.364, Speaker D: And web3 provider is just, if you want to point it to your own custom like Ganache instance, for example, you could do that using web3 provider. But all we're going to do over here is because it's quick and simple, we're going to use the JavaScript VM. So we select that and this actually generates five test accounts for us to use inside of this test blockchain. Right? And it comes preloaded with 100 test ether. And we're going to need to use this ether to deploy this Hodor smart contract. So let's see how we would do that. So over here from this drop down, I've selected my Hodor contract.
00:16:52.364 - 00:16:55.170, Speaker D: It's the only one. Okay, what happened?
00:17:01.140 - 00:17:07.300, Speaker B: Oh, that's not good. Hmm.
00:17:09.400 - 00:17:50.544, Speaker D: So, okay, let's try, let's try this again. So we're going to go to run first we're going to let this compile compiler not yet loaded, give it a second JavaScript VM. And now we're going to deploy this, right? So we're going to use this create button over here to create our smart contract inside of our test blockchain, right? But we need to pass it a string greeting first because that was one of the constructor parameters that we require.
00:17:50.592 - 00:17:50.852, Speaker A: Right?
00:17:50.906 - 00:18:36.594, Speaker D: So let's feed this with Hodor and we'll say create. So I click create. And at the bottom over here, it showed me a new instance of my deployed smart contract on the test blockchain, right? So I have two buttons to interact with my smart contract. If I just click greeting, it'll return the greeting that is set in the constructor, which is hodor. And I can also set a new greeting. So when I clicked set greeting, one difference I want to point out is that the colors of these buttons are different. Right.
00:18:36.594 - 00:19:14.626, Speaker D: Why is that? It's because the greeting function doesn't require any gas. It's a read only function. And that's why you don't need to provide any ether to cover any transaction costs. Right? But set greeting, you're actually writing data to the blockchain, right? You're sending this new greeting to be written into the smart contract. So that's why you need to provide transaction gas for that. Right? And we can see that in this terminal towards the bottom of the editor, we can see that the transaction to set greeting was made and it resulted in this transaction over here. Right.
00:19:14.626 - 00:19:56.874, Speaker D: So we can get more details about this by clicking the details button. And it tells us that it was successfully mined and it tells us which address was deploying this smart contract. So we can see it starts with CA 35 and that matches our account that we have selected over here, one of our test accounts, right? CA three ends in seven, three, three C. And that matches this account. And the two account is basically the resulting address of the smart contract. Right? So this is the address of the smart contract that is deployed to my test blockchain. Right.
00:19:56.874 - 00:21:19.438, Speaker D: And I can see how much gas it cost and the breakdown of that cost in terms of the transaction actually sending the contract to the network versus executing the code inside of it. So we also have a resulting transaction hash that was generated by this transaction that we can go check and verify in Etherscan. And we also have this input field, which is basically the compiled EVM bytecode of your smart contract, right? So this is what the EVM bytecode looks like, and it's obviously not very human readable, but this is what is sent to the Ethereum blockchain. And this is how the contract is stored on the blockchain, right, in this bytecode format. And this transaction also contained our input for the new value that we want to set, which was hold the door. So here we have a very simple smart contract that we deployed to a test blockchain inside of our browser and interacted with it using this little cool interface over here and our test accounts and our test ether as well. So I don't actually see metamask in this browser.
00:21:19.438 - 00:21:22.694, Speaker D: So, Hudson, do you want to just cover the metamask part?
00:21:22.892 - 00:21:23.398, Speaker B: Cool.
00:21:23.484 - 00:21:24.120, Speaker D: Awesome.
00:21:26.090 - 00:21:29.526, Speaker B: Hi, everybody. All right, we're going to talk about.
00:21:29.548 - 00:21:41.370, Speaker C: The ultimate solidity building software combo, metamask remix and ether scan. Blockchain explorer. Yeah, somewhat excited. 1 second, I got to get a timer.
00:21:45.320 - 00:21:46.820, Speaker B: All right, I think I got like ten minutes.
00:21:46.890 - 00:22:07.704, Speaker C: I can do it. So let's look at this. So this is etherscan. It's a blockchain explorer. If you were here for the ethers I o talk, you probably got a little bit of. Oh, can you hear me now? Sweet. All right, so anyone who was here for the previous talk saw a little bit of etherscan, but basically it's a blockchain explorer.
00:22:07.704 - 00:22:52.452, Speaker C: So you can look at smart contract code, you can look at transactions, you can look at people who interact with the smart contracts and contracts that interact with other contracts. You can look up your account and see how much ether you have. It has a lot of different cool features. So I'm going to just run through a really simple smart contract called Simplestore, and this is using remix. So the contract just has an unsigned integer that we're going to store, and whenever we store it, an event is going to fire off. You can think of an event as like a log inside of a log that is stored inside of a block that you can reference later as like an error code. There's also going to be a get function that get function has a constant flag.
00:22:52.452 - 00:23:25.764, Speaker C: That flag is deprecated, so look it up later. But basically what that means is it's going to be a call to the blockchain, not a transaction, and it's going to be a read only call. So no gas is going to be used. When we call git, it's going to return the number. When we call set, it's going to set the number. So super easy. So now that we've created this contract, we're going to want to go to create contract over here, and we put in an initial number and a metamask notification comes up.
00:23:25.764 - 00:23:56.400, Speaker C: So here's what metamask does. Ethereum as a blockchain is a closed ecosystem. You have to use the Internet to connect to it, but it's its own separate network. So we need some kind of software bridge between our computer and the Ethereum network. Metamask acts as that bridge. It creates a blockchain account for you, and then it allows you to interact directly with the Ethereum blockchain using third party servers. So it's a very popular tool.
00:23:56.400 - 00:24:28.920, Speaker C: You can use it to exchange ether or to create or interact with contracts. So in this case we're creating a contract and the contract is pulling up the amount of ether that it's going to send, the gas limit and what that's going to cost in US dollars. We're using test ether in this case. So I didn't actually spend money on this. We're going to hit submit. Oh, very good question. So inside of metamask.
00:24:28.920 - 00:24:37.160, Speaker C: No.
00:24:46.120 - 00:24:46.676, Speaker B: Perfect.
00:24:46.778 - 00:24:54.950, Speaker C: I think I got it. Okay, so in metamask it doesn't open.
00:25:01.750 - 00:25:02.450, Speaker B: Either way.
00:25:02.520 - 00:25:05.860, Speaker C: Basically inside of metamask. Oh, perfect. There it went.
00:25:10.880 - 00:25:12.524, Speaker B: Yeah, believe me, it's a really cool tool.
00:25:12.562 - 00:25:14.270, Speaker C: I'm actually wearing the shirt today.
00:25:16.000 - 00:25:17.150, Speaker B: Oh, it's working.
00:25:22.180 - 00:25:50.980, Speaker C: Okay, so I'm going to go ahead and reject this transaction that was from a previous thing. Up at the top left corner of metamask, you can pick your Ethereum network. You have different testnets, the Robston, Testnet, coven and rinkby. You can also connect your local Ethereum node using a localhost RPC connection. You can buy and send ether, you can handle your tokens in here and you can create and secure your accounts. Really, really neat tool. So back to the main presentation.
00:25:50.980 - 00:26:27.280, Speaker C: What we've done is we've created a transaction and in that transaction it tells us what's going to be spent. So we hit submit and it creates a transaction on the Ethereum blockchain that you can look into Etherscan and see all the bytecode data and when it got mined and everything about it. So here's something else. There are transactions to the contract. Those stack up over time. They have a nonce value for each transaction. Etherscan keeps up with those transactions and puts them in order by when they were submitted.
00:26:27.280 - 00:27:13.860, Speaker C: And you can look at the transaction hash to view more information about each transaction. Another cool feature, you can verify your solidity code. So all this nonsense at the bottom, this bytecode and input data, we want to actually look at Etherscan and view our smart contract. So you can paste the smart contract code in here and you can verify it. So now you can view the contract source inside of etherscan. So this is a really good debugging tool because then once you've done a test contract with your test ether, you've submitted with metamask, and now on Etherscan you can just copy and paste the code in. And you have on a website, you can go and look up who's interacting with your contract, how you're interacting with your contract, et cetera.
00:27:13.860 - 00:27:58.816, Speaker C: So now we're going to go ahead and set the number to 100, do another metamask transaction. That's going to be an actual transaction. And because my smart contract source code is in there in Etherscan, I can actually see that the transaction or that the number that I submitted is 100. So that's the end of my very quick tutorial on Metamask, Etherscan and remix. I wanted to point out that there's a lot of tools and integrations for solidity in general. There's a visual studio plugin, Intellij, if you guys are into Vim and emacs, sublime atom. And we also have some tools written by people who are actually attending here.
00:27:58.816 - 00:28:36.120, Speaker C: There's solidity repl and soulgraph by Rain Revere, who I think is going to be around. There's some people from truffle here if you have questions. I believe there's an Ethereum package manager that kind of acts like NPM, and Piper Mariam was one of the people who started that. He'll be around. Embark and truffle are going to be your main frameworks that you're going to want to work with as far as what tools for a full non web based IDE environment with testing and stuff like that. So this presentation is on my website, hudsonjamison.com, under talks.
00:28:36.120 - 00:28:52.016, Speaker C: It's from Devcon three. So if you just do the Devcon three presentation slides, all this is on there and. Yeah, it's on hudsonjameson.com speakingengagements. And everyone should use solidity. It's a really awesome language. We have a little bit of time yet.
00:28:52.016 - 00:28:54.150, Speaker C: Do you want to do questions or you got some stuff?
00:28:56.200 - 00:28:58.548, Speaker B: Oh, do it. Yeah.
00:28:58.634 - 00:29:00.950, Speaker C: Thanks, everybody. Haseeb is going to end it out.
00:29:01.880 - 00:29:21.294, Speaker D: Thank you, Hudson. Yeah, I just want to wrap it up with links to the code sample so you guys can play around with it some more. Just going to bring it up real quick. Okay.
00:29:21.332 - 00:29:21.534, Speaker B: Yeah.
00:29:21.572 - 00:30:03.702, Speaker D: So just to wrap it up, I want to direct you to more code samples at bitlycodingblockchain. Come up and ask me too, if you're having trouble with getting any of that set up. We also have a blockgeeks discount code for our online courses, so there's a 25% discount code for everyone here. It's BGE Denver. When you sign up, you get a seven day free trial, but you'll also get 25% off as well. And our next workshop, the next block geeks workshop is going to be live on our Facebook page on February 22. So we encourage you to come and participate and get your questions answered.
00:30:03.702 - 00:30:11.500, Speaker D: And, yeah, if you have any questions, reach out to myself or Hudson. Thank you.
