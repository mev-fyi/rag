00:00:00.410 - 00:00:40.742, Speaker A: In YouTube previously. And yeah, let's just talk about that. So basically opensepling, if you don't know us yet, we do security for the blockchain space. We published open source library that we maintain with the highest security standards out there. So if you probably have done some solidity in the past, you probably us, right? So cool. Aside from that, in the middle week, Hackathon, we have some bounties for you to take a look to. This is basically using our platform, which is defender and is focused on developer security operations.
00:00:40.742 - 00:01:22.390, Speaker A: So you can use plug whatever project you are making and once you have it done in Defender, you are participating. It's quite easy to set up and we have some templates for using it with serverless, but that is another topic. Okay, so as I mentioned, you may already know us because of the library of contracts, but we also have some other open source efforts. In these open source efforts you will see that we have some other libraries and that's what we are going to talk about today, which is the Merkel Tree library that we just released in past November. And I'm going to tell you about the reasons why we released this library. And a cool story about hacking Merkel trees. Right, cool.
00:01:22.390 - 00:02:02.638, Speaker A: So before starting a quick presentation of myself, my name is Ernesto Garcia. You can find me Twitter with ernesto Ynw, and also I work at Twitter. Sorry, I worked at Google before as an intern. I worked at the Google Cloud and Google Chrome teams, and now I work at opensepling as a smart contract developer. I work at the library. So if you have any question regarding to it, you can find us at our boot and I can answer you any question you have. Okay, so let's get started and let's start by asking this question, which is what is a Merkel tree? So probably some of you already know what is a Merkel tree.
00:02:02.638 - 00:02:45.570, Speaker A: A Merkel tree is basically a data structure that allow us to save information in a compressed way in a smart contract. Right? So you don't need to put all of the information in the smart contract, you just have to put the root hash. And that is enough to verify that some element is part of this merkel tree. Going to the definition is this one. And as you can see, it is a tree. This is very back in which every leaf, of course there are leaves, is labeled with a cryptographic hash of a data block. What does this mean? Maybe you don't know because this is quite complex to grasp at first, but let me tell you how merkel trees work in a very simple way.
00:02:45.570 - 00:03:42.206, Speaker A: So we start with a set of data, which was called a data block in the definition. And let's say we have elements from a to I, like ABCD, including any piece of information. Okay? So by starting with this, we can hash the information that is in that leaf and convert it to a piece of information that we can use for further merging each value. So in this way, we can build up a tree, as you can see, and this tree will have a root estate, in which the root estate is the hash of all the values that were contained in the merkel tree. Of course, not all of the information about the elements in the Merkel tree stay in the root state, especially because the root state is just like an identifier of the information that is in the merkel tree. Right. This is important because by using a root state, that is enough for you to verify information on chain.
00:03:42.206 - 00:04:31.950, Speaker A: And this is because one assumption that we have around hashes, which is that you cannot know the pre image of a hash, which is what you put into a function of a hash, and in order to get something else right, you cannot know it beforehand. That's the way hash works. So talking about hash functions, you will see, or maybe you already know, that a function is basically just a piece of information, or let's call it like a transition function in which you map some values from a domain into a co domain, right. One of the main properties of these hashes is that the inverse operation, which is like mapping from the co domain to the domain, is not possible that easy. Well, it's actually possible. It's just that it's not feasible. It will take ages.
00:04:31.950 - 00:05:13.454, Speaker A: So the idea is that a good hash, it is assumed to have what we call the pretty much knowledge resistance, which is that you don't know what to put in the hash in order to get a desired result on the other side. So to put some graphics on that, this is the way the function work. You put some pre image, you hash it, and you get an image after that. The opposite operation is what is not possible. So we rely on this assumption for multiple operations using hash. And this has something to do with the Merkel tree, because in the Merkel tree, you can start with the data and then build up to the root of the merkel tree. Right.
00:05:13.454 - 00:05:54.458, Speaker A: This is useful because in this way you can prove you have values with just doing a computation that is a log n of the total amount of elements in the Merkel tree. The interesting thing is that you cannot do the opposite. I mean, you cannot start with the root estate and then get the values by, let's say unhashing the root estate. That is not possible. And that is like all of the security around the Merkel tree. Right, cool. Let's talk about proofs, which is basically, now that you know how a Merkel tree works, now you have to publish probably proof on chain using opensplane contracts or any other tooling.
00:05:54.458 - 00:06:31.398, Speaker A: So in order to build a proof, we have to first define what is a proof for a Merkel tree. Right. And a Merkel proof for a Merkel tree works in the following way. So you basically start with a piece of information that you want to prove that is in a Merkel tree. And in this case it's called b. And let's say it's a tuple between address and un to 56. So we take this value, we apply a hash function, and then now that we have this hash value of our original element, we can start building our tree.
00:06:31.398 - 00:07:07.850, Speaker A: How is this done? In the following way. We start with our hash value of b, and then we can get rid of c and d. Why? Because it's not completely related to the piece of information we want to know. So we start by hashing the hash of b and the hash of a, which is part of the proof. Okay. With these two, we get the stir one and now we need the hash of CD, which then we combine and then eventually we get the root state. So that is the way in which we can prove information about information being in a Merkel tree.
00:07:07.850 - 00:07:57.618, Speaker A: And this is amazing because it can be done in login of the total amount of elements, which is quite handy when you are managing a lot of information that you have to put on chain. Okay, so this is the root state, and if you compare it to what's on chain or to what you have put in a smart contract, you can validate that information is correct. So this is basically how they work. And some things to consider is that in order to make a proof, you have to make an array of values. As you can see, these are the values that we needed, starting from b to combine with a and then with CD. So you have a proof that is not the total amount of elements, but is good enough to process on chain. The way you process it is as I mentioned, you take the leaf, you hash it, and then you combine the next hashes.
00:07:57.618 - 00:08:57.442, Speaker A: So you end up having this root. Okay, amazing. So now let's have a look into what a proof like this looks in solidity, because it's quite different, especially when you are working with JavaScript, because you have a library that is creating Merkel proofs or hashes of any function that you want. But maybe the format and the types of these pieces of information don't match directly with whatever is in solidity, right? So we identified that as a problem and a big problem from the developer experience standpoint. So basically we decided to do some research on what are the main pain points around building Merkel trees and verifying on chain. And basically what we notice is that there is a big mismatch between the information that is in the, let's say front end. If you have one and you are using JavaScript, you have to interact with values that are solidity native.
00:08:57.442 - 00:09:55.850, Speaker A: Like for example a bytes 32, which is representing the array of proofs. Well, not proofs or the path to make the Merkel proof, right? So this is not like directly mapped to JavaScript, and this is something that especially beginners don't know exactly how to translate because you have data types in JavaScript and then you have different data types in solidity. So what we figure out is that, number one, developer experience is complex. Number two, there is no connection between the types. I mean there are numbers in JavaScript, but we all have headaches with big number. For example, and how do you convert a big number into a byte 32 in a secure way? That is one question that you might have if you are starting with this. Aside from that, we found out that the interoperability with the tooling that is already used, such as etherjs, is also not quite familiar, especially for this kind of verification process.
00:09:55.850 - 00:11:07.006, Speaker A: And finally, the most important thing, which is the second pre image attack that I'm going to tell you about next. So cool. Right now we know how Merkel trees work. So let's say that we have a piece of information called I, right? The way we prove that it's in the Merkel tree is by hashing this function. And this is what we call the pre image of the initial hash, right? So we take the I value, we hash it into hi and then look at this, we have a second pre image for the next hash. Why? Because we already know what h of ye and h of I is, because that is part of the proof, right? So the problem that comes with this is that someone can actually do something like this, which is taking one of the nodes and use it to prove information that is not actually true, right? You just have to provide this node and the proof or the path to build a fake proof using it. So although in most of the contexts in which this is a problem, it is not actually malleable, because it usually depends on the message that sender.
00:11:07.006 - 00:11:52.382, Speaker A: So you have to figure out a message that sender that for some reason has the same configuration as one of the pre image you have. But still, the risk is, let's call it like at least probably enough to take care of it, right? So we didn't find any contract out there using this mechanism. So this is basically just a theoretic attack. So please don't go and try to figure out how to hack someone using this. Right, but the problem is that, yes, in fact we have a flaw. It's something that is not quite evident for the user, especially when you are just like trying to do an NFT drop or something. You don't care about pre images and things like that.
00:11:52.382 - 00:12:46.322, Speaker A: Right? So based on that, we decided to okay, let's take a look to what is the common process of Merkel distribution for an NFT or an airdrop. And it always looks something like this, right? You have a function, let's call it claim, or let's call it mint, or however you want, that is taking a proof. And this proof is validated using our Merkel proof library that we have in open separate. Right? So, so far so good until this point. But the problem is that, as you can see, in this case, someone can mint 100 tokens because they have a proof that is an actual valid proof. But since the second premash is known, you can actually use these two to mint a ridiculous amount of tokens that is produced by the randomization of the hash function. Right.
00:12:46.322 - 00:13:36.038, Speaker A: So as I said, this is not that useful because you will end up sending the tokens to an address that is unusable. You don't have the private key, but if you think about it, you are like inflating the supply of a system, which is not ideal. And of course we want to avoid that problem. So what happened is that we decided to close the gap between what is going on in Javascript and people that is building Merkel airdrops or NFT drops, and make a whole end to end process easy for developers to use. So this is how we came up with this library. And this library is basically an end to end approach of using and validating Merkel trees. So you can take a look at Openseplinemerkeltree.
00:13:36.038 - 00:14:13.514, Speaker A: It is published on NPM, it's already quite used by the community. And also we have figured out that multiple people find it really easy to use. It's way better than other alternatives, and it's pretty straightforward when you're working with smart contracts. So the way it works is, oh, sorry, some properties first and design decisions we take before creating the library. So number one, we decided that the tree should be shaped as a complete binary tree. This means that the only part that is incomplete of the tree is the last level of the tree. And this is for security reasons.
00:14:13.514 - 00:14:57.546, Speaker A: There are some considerations around unbalanced merkel trees that you may want to avoid. So what we did is, okay, let's just balance this Merkel tree automatically. Whenever you are adding information using the library that's already done, so you don't have to take care about it. Point number two, the leaps are sorted, and this is because the order in which you hash the things matters. So basically people can make mistakes in which they hash values in a different order and they are not able to get a correct proof, or let's call it, they publish a proof that is incorrect on chain and they cannot change it anymore. Okay. The developer experience of that, as I said, was not the best one.
00:14:57.546 - 00:15:47.146, Speaker A: So right now, if you use this library, you will get everything sorted out for you. Point number three is that the leaps are the result of an API encoding, which means that everything that you do in JavaScript is going to be fully compatible with anything you do on solidity. So you have native support between conversion of types, or you can use directly the types that you will use in solidity, such as an address or an integral UN 256. Could be. Also, we are using the Keshe 256 function that is already built in in most of the tooling, and that is also already built in. In Ethereum there is a pre compile for that, so people can just use it. And finally, the leaves are double hashed, and this is to prevent the second premash attack.
00:15:47.146 - 00:16:29.030, Speaker A: And I'm going to explain how this removes that possibility from the scope. So how is this prevented? Basically we take a piece of information and instead of doing one hash, we do two. Why? Because if you hash it twice, it means that there is a fundamental difference between a node that is a leaf and a node that is an intermediary node. Why? Because every leaf is hashed twice. So if you try to use a second premise attack, you will just hash it once and the system will only do it once. Right? So the whole idea is like let's hash it again, so people don't know what the pre image is. That's it.
00:16:29.030 - 00:17:17.062, Speaker A: Okay, it's already built in. It's usually one design decision that developers needs to make before creating system like that. So we decided to just put it built in in the library to how this works. Basically we have the same example that I show you in which you have a piece of information called a, you hash it and then you get a pre image. But the thing is, this pre image is double hashed as you can see. So right now if you take this same example, you will see that the next hash is not going to match because the first hashing in the claim function that you have in solidity will hash it twice. So there will be a mismatch naturally, and this avoids any attack like that.
00:17:17.062 - 00:18:07.400, Speaker A: Let me go back here because I see some people is confused, but as you can see here in line there is no number of lines, but here you can see we are just hashing once. If we hash twice we avoid any premash tag because no preemash is known for a double hash. You see what I mean? There is only known pre image double hash for the leaf values, which are the values that we care about. Okay, going back to this, I hope now this makes more sense. Is it cool? Amazing. So the verification will basically fail because yeah, if you try to hash twice a pre image that is supposed to be hashed once, it's not going to work. That's it.
00:18:07.400 - 00:18:47.400, Speaker A: Cool. So in this case, what we recommend from now on is that instead of just hashing once in your claiming function, you don't have to change anything. But this line, as you can see, the leaf calculation is changed by double hashing. And if you are asking why we're using these bytes, concat, it's just basically to avoid memory because otherwise you have to copy into memory and then copy again. And yeah, this is an easy way, an easy trick to not copy into memory. Cool. So now that we have this leaf, we can use it with the Merkel proof library we have, as we have done before, without any other change, which is nice.
00:18:47.400 - 00:19:42.482, Speaker A: Okay, I already explained this, but you can take pictures if you want. But this is basically the whole idea behind creating a new JavaScript library for this, is that you do not have to mess with this. Nice. And also another feature, and this is an interesting thing to talk about, is that property based testing has been quite hot, I would say in the last couple of years, and we are also trying to integrate that into our development process. So this library was also created and tested with property based test, which is known for many of you as fuzzing probably. And there are some cool libraries out there that you can use to fuss things in JavaScript, which is nice because you always usually fuss everything that is in the smart contract, but you don't do the same with JavaScript. And usually JavaScript is also messy, right? Especially in front ends and data conversions.
00:19:42.482 - 00:20:19.698, Speaker A: There are so many things that can go wrong in that place, so fuzzing in this context is also useful, especially for merkel trees. Cool. So in this context we made the Merkel tree library to match exactly with the Merkel proof library that we have in opensplane contracts. And everything seems so easy since it is designed like that. Here's an example of how you can build a tree. As you can see, step number one is adding values to an array, and each one of these array elements is corresponding to a leaf. So in this case this is only two leaves, three, and that's it.
00:20:19.698 - 00:20:54.240, Speaker A: It's just an example. Number two, you construct a tree using our library and you have to provide the information about the ABI encoding for those values. So as you can see, you don't have to worry about any conversion between data types. It is already built in. And under the hood is using etherjs, which is what you will be using if you are building applications on ethereum. Right. Step number three is calculating the root so you can take this root and put it into a smart contract on chain and use this for validation in the future.
00:20:54.240 - 00:21:37.418, Speaker A: Finally, you just have to write the tree in any file so you can later use it for proving that some element is inside it, especially when you're building front ends. If you already have claimed an airdrop in which they use Merkel tree, you probably will know that the front end has to calculate the Merkel proof for you. So you can then claim your airdrop basically. Nice. As you can see, this is Abi encoded, so it's quite easy. It's the same as if you were working directly with ABIs and using any other tooling such as web3, JS or EtherJs is the same. Cool.
00:21:37.418 - 00:22:22.730, Speaker A: So in order to get approved, let's say that you already built your application. You have the list of the people that is going to be benefit from the airdrop. Now you have to add it to the Merkel tree, loading it from a file. And this is especially designed like this because we notice that multiple people in the space are using usually csv. Why? Because it's the most easiest thing to do, right? Just put everything into a CSV, export it, and let's use, I don't know, any front end that converts that into a Merkel tree. Right? So we made it easy. You can load everything from a JSON file and I'm going to show you at the very end how you can actually parse CSV into JSON.
00:22:22.730 - 00:23:11.180, Speaker A: Nice. Step number two is just iterating through the leaves and get the proof for each one of your leaves. And that's it. So if you have a front end, you can just plug the address of the user here, and you will get the proof for the user so they can submit it on chain. One thing that is also important to note is that this proof that is generated is ready to put into a smart contract. I mean if you use this to generate the proof, then you can go to a smart contract and exactly as it was printed in the console, you can put it in remix or in Etherscan or in the application that you are using, right? So it's immediately useful and you don't need to do any conversion or weird stuff in the middle. It's quite easy.
00:23:11.180 - 00:24:05.370, Speaker A: Nice. This is the example from the solidity perspective. As you can see, it's quite the same as I already showed you before, but it includes some, let's say small differences, which is that number one, we have to save the root state in the constructor. This is for immutability purposes. We want to make sure the root is already there and nobody will change it after it's published. Then we add a function for verifying, and we can put this function inside of any min function or claim function. And what it's doing is basically calculating the leaf in the same way that we did before, and also requiring that the proof is correct, which is this line number four, you can add all of the logic you want after that in a secure way, and that's it, you are ready to go with this Merkel tree configuration.
00:24:05.370 - 00:24:30.466, Speaker A: Important things to note is that there is no second premache attack, so you are safe. I mean you don't even have to think about it because it is already included in the library and it's 100% ABI compatible the way ether JS is. And finally, you have a great developer experience. Just a few lines of code and you're ready to go, which is pretty nice. Cool. Let's do a quick demo. Let's see how much time we have.
00:24:30.466 - 00:25:09.040, Speaker A: I think we have sort of like ten minutes, so I think it's enough for running a quick test. So I'm going to open this repository here, let me make some zoom. Is that okay? Amazing. Thank you. So as you can see, I have a CSV file here that includes the same example in the presentation, right? It includes the types as headers of the CSV, and then the values comma separated. It's quite easy. You can export something like this from Excel or Google spreadsheet, whatever is fine, and it's quite easy to use.
00:25:09.040 - 00:25:50.700, Speaker A: So here I have two scripts. One of these is for building the tree, and the other one is for actually generating the proof. And if we take a look, the build tree should look almost exactly as the example that I showed you before. The only difference is that we are reading from the values CSV and we are converting the CSV into a simple JSON that we can then input into our library for building Merkel trees. So what this is going to do is to separate each line. Let me put each line aside. Okay.
00:25:50.700 - 00:26:36.570, Speaker A: So as you can see, what this is doing is removing any extra space, because for example, this four right here is an empty line, we don't need it. And then we split four lines. So we end up with an array of values in which the first values are the data types equivalent to etherjs, and the rest of the values are just the leaves of the merkel tree. So the way we create a merkel tree is by calling the standard Merkel tree that of function, just mapping the leaves and separating, because they are like comma separated, we have to make them into an array. That's it. Some encoding here, we print the merkel root and then we can use that to put it into a smart contract. Cool.
00:26:36.570 - 00:27:04.242, Speaker A: So let's try it out. I'm going to open my terminal and also some zoom. So is that okay? Yes. Nice. So what we have to do, if you want to check it out, you have some instructions here. You just have to basically populate the CSV and then run this command and you will get the merkel root. Right.
00:27:04.242 - 00:28:00.310, Speaker A: So you can put this into your smart contract and then give proofs to everyone so they can claim their tokens or their nfts. They can do it. Cool. So now that we have this Merkel root, the next thing we have to do is generating approve. Okay, so approve is a way to actually prove that some data is there, but you have to actually provide what data of the tuple you are trying to prove for why? Because we have two values for each leaf, which is the address and an amount. What if we want to generate a proof for an address? So we have to point out to the first element of the leaf, right? That is why we provide a type index which is referring to the first value and then a value which is the, how do you call it? It's not a proof, it's the value that we're looking for the address. In this case.
00:28:00.310 - 00:28:25.886, Speaker A: It will all make sense when I run it. So let's just run it with NPM. Run, generate proof. And as you can see, since each tuple is consistent of two values. Okay, what I'm trying to prove for. Actually I think I need to run with a zero here because this is the type index of the first element, which is the address. Right.
00:28:25.886 - 00:28:36.542, Speaker A: So we want to generate a proof for the address. One, one. And this is the way we do it. Let's see if it works. Yes. So here you go. You have the value and you have the proof.
00:28:36.542 - 00:29:07.494, Speaker A: This proof is just one element because the merkel tree we made is quite simple. But if you want to extend this into multiple things, you can try it out. Just make sure you put different values in here because otherwise there could be a problem in the way we calculate approve. Especially because we don't know exactly which one of the elements you have because they are duplicated. That is something to consider. Okay, so that's basically it. This is the way you can plug everything into your front end in an easy way.
00:29:07.494 - 00:29:31.930, Speaker A: So yeah, let us know any comments and feel free to open issues in the repository. I'm going to be here around for any question you have. So thank you very much. Does anybody have any questions? Rolling.
