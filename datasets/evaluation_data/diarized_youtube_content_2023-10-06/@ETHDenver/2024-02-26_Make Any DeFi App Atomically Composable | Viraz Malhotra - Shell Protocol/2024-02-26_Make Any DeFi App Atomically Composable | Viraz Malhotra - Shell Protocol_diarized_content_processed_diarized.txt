00:00:09.210 - 00:01:13.682, Speaker A: Hi, everyone. My name is Viraz, and I'm a smart contract engineer at Shell Protocol. And today I'm going to be showing you how can we make any DeFi Dap atomically composable. So we're going to talk about what are the current UX issues that exist with the DeFi ecosystem, and then we're going to dive into the code side of things and just dive in, explore the solutions that we can implement to sort of solve those UX problems that we have. So, to start off, first of all, how many of you guys use Defi Dapps very regularly? Just a raise of hands. Okay, so, yeah, this is going to be fun. So this image sort of aptly describes how the current state of DeFi overall looks like right now, where we can see that we still have a bit far in terms of getting to an ideal defi uit state.
00:01:13.682 - 00:01:42.334, Speaker A: So we're still a bit far off from that. And there's a big difference in terms of how we speak about it. And what do we actually see in terms of uits in different defi apps. Right? The ideal vision would somewhat look like this. Besides, please ignore the approval transaction, which is a forever pain that we have already. Which we have. And the second transaction, just focus on that.
00:01:42.334 - 00:02:08.742, Speaker A: So that's the ideal UX state for DeFi should look like where you can do multiple complex operations in just one transaction. For example, let's say if you have wrapped BTC, so you can use that and buy an NFT in just one transaction by doing in multiple operations like you see. But the reality is far from this, because the reality is something like this.
00:02:08.796 - 00:02:09.400, Speaker B: Right.
00:02:11.770 - 00:03:34.046, Speaker A: Where you have to do multiple transactions to achieve this, and which involve multiple approvals, switching between different websites, lot of high gas costs, and of course, Mev risk as well, especially with AMM related operations. And we at Shell have sort of been working towards a solution for this, where we have created a set of smart contracts and differentiated the accounting layer and the business logic layer. So you can basically have a track at improving ux that way where you don't have to put everything inside one contract, and you can break that into two parts and make it more modular. And so you have two different layers. One is the accounting layer, and then you have the business logic layer. And the accounting layer that we have developed is called the ocean, which is an ERC one double five contract, where users can basically interact with that. And the business logic, which does all the computation, can just be a black box for the users, right? So the idea is that users pass in an array of struts to a smart contract method, which in protocol definition we call as interactions.
00:03:34.046 - 00:03:49.922, Speaker A: So interactions are nothing but sort of batch operations that users can use to do these different primitive related operations. For example, swap, like adding or removing liquidity, et cetera.
00:03:49.986 - 00:03:50.358, Speaker B: Right?
00:03:50.444 - 00:05:40.986, Speaker A: And we'll dive more into it as we go along. So this is a short UI snippet that we have from our current DAP, where we have a couple of examples. The first example we have is a multi NFT swap where you can swap multiple NFTs for USDC in just one transaction, right? And again, this shows how composable your DAP can be, where you can minimize user clicks and do everything complex in just one transaction, right? So this is one example where you can swap NFT for an ERC 20, or vice versa. And the other example we have is an lp to lp swap, for example, with different amms. Right? Now, if you have to migrate your liquidity from one pool to another, you have to do multiple transactions, right? But with shell, in a way, you can do all of this in just one transaction because of the composable smart contract architecture that I just talked about. So with composability, we have realized that to gain more user and dev adoption equally, having a composable system gives you power to basically integrate with multiple DeFi protocols without a lot of code complexity, right? And what this does is helps you to create a system which can be a one stop shop for DFI, basically. So a user, for example, a retail user who is sort of just venturing into web three, they don't need to know about multiple protocols or how different protocols work, they can just come to one platform and do all their operations there itself.
00:05:40.986 - 00:07:42.270, Speaker A: And all the behind the scenes stuff can just be a black box for them, right, and which reduces complexity and sort of simplifies the user experience and which in turn would help you help us to get more users in web three in a way, for DFI related use cases, right? So Trump posibility is sort of directly proportional to these omnidified apps where you can, like I said, just do multiple operations with just one interface rather than having trouble in terms of switching to different handling, different tabs, switching to different websites, et cetera, and also reduced gas costs a lot, right? Yeah. So to do all of this, to sort of achieve this vision, we have sort of started working and working on this and developed a set of smart contracts called the adapters, which is nothing but a middleware between the shell contracts and any external defi contract like Uniswap, balancer or curve. So the idea is that behind the scenes, the shell contracts communicate with these adapters, and then these adapters call these external smart contracts, and hence they are able to compute that result and perform any operation, for example, a swap or add in liquidity, et cetera, and then just communicate that back again to the shell contracts. And that's how the cycle works, right, where there's a two way communication between the ocean, which is our accounting layer and the adapter, and then there's a one way communication between the adapter and the external contracts, and that's how the whole user flow works, which we'll dive into more as we sort of go along.
00:07:42.340 - 00:07:42.960, Speaker B: Right.
00:07:46.290 - 00:09:06.870, Speaker A: So the, so this is just a simplified version of the diagram that we, that we spoke about earlier, right? Where there's a user who calls the ocean, and there's a method called as compute do interactions, right? So there's a method in the ocean contract called do interactions, which states in an array of struts. And that strut is called as an interaction, right, like I mentioned earlier. So you pass in an array of different interactions. And interactions can be basically start off the user flow sort of starts off by, first a user locking in their underlying token. It can be an NFT, it can be any ERC 20. So they lock in that ERC 20 token and they get in an ERC one double five token in return of the same value, right? And once they do that, then they pass in the second interaction, which is nothing but the business logic based interaction where they can, let's say, add liquidity or swap tokens, right? And then at the end, once that's the middle interaction, and the last one would be to unwrap the token. So for example, if I want to swap USDC for USGT.
00:09:06.870 - 00:10:05.330, Speaker A: So first I'll wrap USDC, the second interaction will be to swap the USDC, the shell wrapped USDC token with shell wrapped USGT token, which is again the ERC one double five tokens that I spoke about. And the third interaction would be to unwrap the shell USDC token to the underlying USDC token that you get right at the end. So you can basically start off by one token and get the other token back in just one click. So that's the whole idea. And I'll dive into the code base now so you guys can, in case you have your laptop, so you can clone this repository. Anyways, I'll be showing over this presentation, I'll dive into the code, and if you want to follow along better, you can clone this repository and just dive in with me. I'll just dive into the code now.
00:10:05.330 - 00:10:28.430, Speaker A: Yeah. I hope this screen is visible to everyone, or should I? I'll probably make it more.
00:10:36.210 - 00:10:36.718, Speaker B: Yeah.
00:10:36.804 - 00:11:09.720, Speaker A: So the idea is this is what interaction basically looks like. And let me know if you guys need me to show the GitHub link again. So you can search Kauri labs on GitHub, and you will find a GitHub or link. And the first repository that you see, it's called ETh Denver adapter workshop. So you can clone that. This is the link. I'll just keep this link open for a bit so that people can clone the repository if.
00:11:09.720 - 00:11:43.638, Speaker A: Yeah, so it's called crowd. The GitHub organization name is called crowry, and you can just go to that. And the first public repository you'll find would be eat Denver adapter workshop. And you can clone that. And there are like steps in the readme where you can first run yarn, and then I'll just probably go over that once. So you can clone the repository and then you can first install all the dependencies with yarn. Install.
00:11:43.638 - 00:12:22.940, Speaker A: And you can just run forge b to install the foundry related dependencies. And that's it. I'll just dive into the code, and we can go over the tests and the code side of things now. Till this point, just wanted to check in with everyone till this point. Do you guys have any, anyone has any queries that we should go over before I dive into the code? Because it's a workshop, so I'm just making sure if I should. Okay, I'll just dive into the code then.
00:12:43.330 - 00:12:43.838, Speaker B: Yeah.
00:12:43.924 - 00:12:50.782, Speaker A: So this is the starting point, basically, where this is the interaction strut that I was sort of speaking about.
00:12:50.836 - 00:12:51.294, Speaker B: Right.
00:12:51.412 - 00:13:10.614, Speaker A: And the first thing we have is a bytes parameter in the strut that we pass into the ocean, which is called interaction type and address. So this is nothing but just an encoded form of the interaction type, which is an enum and the address of the external business logic contract that you want to interact with.
00:13:10.652 - 00:13:11.286, Speaker B: Right.
00:13:11.468 - 00:13:25.450, Speaker A: Or the ERC 20 token, in case you want to wrap or unwrap. It's the address of the underlying token that you want to wrap or unwrap. Or in case you want to do a business logic operation, the address here is the business logic contract address.
00:13:25.600 - 00:13:26.300, Speaker B: Right.
00:13:28.350 - 00:13:31.054, Speaker A: And these are the interaction types that you can use.
00:13:31.172 - 00:13:31.598, Speaker B: Right.
00:13:31.684 - 00:13:39.786, Speaker A: So we have wrapping of ERC 20 tokens, wrapping of ERC one, double, five tokens and 721 tokens.
00:13:39.818 - 00:13:40.400, Speaker B: Right.
00:13:41.650 - 00:14:22.634, Speaker A: So the ocean is compatible with all these token types. So that's the wrap transaction types, and then the unwrapped types again are the same. And then there are the compute output amount and compute input amount types, which are basically your business logic related interaction types. So compute output is basically just that. You have an input token that you're passing into the ocean and you'll get a specific amount of output token depending on the value of the token that you're providing. Right, and so it's just a buy and sell operation in a way. Right, and now we'll dive into, what's the method that we call on the ocean?
00:14:22.682 - 00:14:23.280, Speaker B: Right.
00:14:28.080 - 00:14:53.420, Speaker A: Yeah, I'll just dive in.
00:15:06.490 - 00:15:06.866, Speaker B: Yeah.
00:15:06.908 - 00:15:49.414, Speaker A: So this is the smart contract method that any user calls on the UI. For example, if you're interacting with the shell app, which is called do multiple interactions. So as you can see, this states in an array of interactions of the interaction struct. And then it has ids, which is just basically the ERC one double five token ids that we use to compute to keep a track of the accounting for the ERC one double five wrap token balances on the smart contract, right? And then the third part is of course the user address that's interacting with the method and which will sort of receive the tokens at the end.
00:15:49.532 - 00:15:50.200, Speaker B: Right.
00:15:51.930 - 00:16:34.454, Speaker A: And then what happens is then this contract will basically call the business logic contract depending on the address that you pass in, in the interaction type and address bytes parameter that I mentioned, which is this. So we basically decode the value that you pass into this argument, and based on that, the address that we get, then basically we call the primitive and the primitive basically then which is the adapter in this case. And the adapter then basically calls the external contract to communicate and then do that operation that the user wants to do.
00:16:34.492 - 00:16:35.174, Speaker B: Right?
00:16:35.372 - 00:17:27.474, Speaker A: So here is the adapter address that I was talking about, which is this, which is called ocean adapter. It's an abstract contract that different adapters basically inherit. So the idea is that you call in the compute multiple interaction, the do multiple interaction method on the ocean, and the ocean basically calls the compute output amount method that you see here where you see two operations, three operations basically happening. So the first one is because in order to deposit the underlying token to the external contracts, we'll need to unwrap the token first, because like I said, when you interact with the ocean at the start, you will need to wrap your underlying token into a shell based into the shell ERC one double five token.
00:17:27.522 - 00:17:27.830, Speaker B: Right?
00:17:27.900 - 00:18:14.438, Speaker A: So once, because the token is wrapped, so you'll need to unwrap it first. So this is what we're doing here. We unwrap the token first, and then we call this primitive compute output method, which basically calls the adapter and calls the adapter specific external contract method. And this method basically communicates with the external contract to do a particular operation, for example, swapping or adding liquidity, et cetera. And then you get a result back from this method, which is the output amount, right? Basically. And then you basically wrap up the output amount again into the ERC one double five form, right? And that's how you are able to do basically wrap. You start off by one token and you end up with another.
00:18:14.438 - 00:19:33.438, Speaker A: So this is the whole process in terms of interacting with the external contract. Now I'm going to dive into this primitive output method, right? So here is an example which we recently sort of shipped, which is a trough two pool adapter where we are interacting with a trough pool having two tokens, right? And in this case, in this example, I'll be taking an example of a USDC USDT pool, right? Yeah. So this is the smart contract method that I was talking about in the previous link. This is the method that's been called. And as you see, what happens here is now the first operation is where we convert the decimals, right? So the idea is that ocean verts, when we wrap tokens, the tokens are wrapped into an 18 decimal form, right? And now when you unwrap it, we'll need to convert the decimal format into the underlying token decimal. So for example, if you are dealing with USDC, right, and the shell version of the USDC token has 18 decimals, but USDC, the underlying token has only six decimals. So you need to convert those values in terms of the decimal of that particular token, right? So this is what happens here.
00:19:33.438 - 00:20:21.294, Speaker A: We get the raw output input amount. And then what we do is because an amm can have three operations, right? It can be a swap, it can be a deposit or a withdrawal. So here we determine what's the compute type, right? And once we do that, once we do that, we basically, based on the compute type, we call in the curve smart contract methods. So either it can be a swap or it can be a user wanting to add liquidity or like removing their liquidity from the trove pool, right? So that's how it works. So first we sort of convert the total decimals, then we sort of determine what's the compute type. And then we call the external smart contract method. And at the end we get the output amount.
00:20:21.294 - 00:20:28.906, Speaker A: And then again we convert the decimals back into the ocean specific decimal amount, which is 18 decimals.
00:20:29.018 - 00:20:29.390, Speaker B: Right.
00:20:29.460 - 00:20:32.334, Speaker A: In case the output token is less than 18 decimals.
00:20:32.382 - 00:20:32.690, Speaker B: Right.
00:20:32.760 - 00:20:36.930, Speaker A: So we convert that back to 18 decimals and we return this output amount.
00:20:37.000 - 00:20:38.340, Speaker B: That's it, right.
00:20:38.790 - 00:20:41.754, Speaker A: And then, like I said, then you just wrap this token.
00:20:41.822 - 00:20:42.294, Speaker B: Right.
00:20:42.412 - 00:21:52.308, Speaker A: So now what I'll do is I'm just going to walk you guys through a test, right? Just give me a second. Does anyone has any queries up till this point? And we can go over and I'll move forward accordingly. Okay, no worries. Yeah, so I'll just show you guys how sort of a test looks like in terms of implementing this and testing, like testing this in the real environment. So we have these, yeah, so we have these four test suits that we have created, right. In terms of testing out these adapters where we can fort the real environment. In this case, because our contracts are deployed on arbitrum.
00:21:52.308 - 00:22:24.280, Speaker A: So we use foundry to fort the arbitrum network and basically run all these smart contract tests for these adapters. And in this case, like I said, the example that we're taking in is USDC and USDT. So there are like three fuz based test scenarios. So we start off by a swap. I'll probably have to watch this.
00:22:24.350 - 00:22:24.824, Speaker B: Okay.
00:22:24.942 - 00:22:37.864, Speaker A: Yeah, so we start off by a swap, a swap test, right, where we've just taken a Boolean argument in terms of which token that we want to swap and the amount that we want to swap.
00:22:37.912 - 00:22:38.510, Speaker B: Right.
00:22:40.240 - 00:22:44.380, Speaker A: And based on that, we set the input and the output address accordingly.
00:22:44.460 - 00:22:45.136, Speaker B: Right.
00:22:45.318 - 00:24:15.140, Speaker A: And now I actually had a to do here because I wanted for us to sort of code the test scenario, but I can probably just rewrite it and just go over the interactions that way. Yeah, I'll probably do that because not a lot of people have their laptops with them. So probably it will be better for me to just get the code back in and then just go over the test code. Just bear with me for a couple of minutes. Sorry, I'm just doing it for a couple of minutes. I'm just getting the code back in. Yeah, thanks for bearing with me here.
00:24:15.140 - 00:24:40.102, Speaker A: So I've added in the missing code that was there and now we'll just dive into the test. Right, so like I said, this is where we start off by sort of creating these interactions and then calling the ocean smart contract, for example, to swap USDC or USDT for the other token with the help of curve.
00:24:40.166 - 00:24:40.874, Speaker B: Right.
00:24:41.072 - 00:25:15.714, Speaker A: So the idea is to have an interaction array of three items right, and the first item, like I said, is basically a wrap ERC 20 interaction. So where we first wrap the token that we have, which is either USDC or USGT, depending on the fuzz input that we get, right? So we do this and as you see, we have a property here which is called specified amount where we pass in the amount of the tokens that we want to sort of swap.
00:25:15.762 - 00:25:16.262, Speaker B: Right?
00:25:16.396 - 00:25:37.822, Speaker A: And metadata, we don't need any metadata here because it's just a wrapping operation. So we just do this, right? And then the second interaction is basically the interaction where we compute output amount interaction, where we define the input token that we want to swap and the output token that we want to get.
00:25:37.876 - 00:25:38.286, Speaker B: Right.
00:25:38.388 - 00:25:41.182, Speaker A: And the amount that we want to swap in for.
00:25:41.236 - 00:25:41.694, Speaker B: Right?
00:25:41.812 - 00:26:42.066, Speaker A: So as you can see here is the compute output interaction that we are passing into the interaction type and address argument that we discussed before. And this is the address of the adapter that I just went over, which is the trough two pool adapter, right? So basically we sort of concatenate both these values and then create and get a bytes 32 result, right? Bytes 32 value which we pass into the strut. And the input token again is the shell wrapped ERC one double five id. And the output token is again the same for the output token, address the specified amount because the ocean has a check where if you pass in the maximum amount, it will automatically just take in the amount of the, of the balance that it has that you want to swap in the previous interaction. So it will automatically just take the amount as this amount that we passed in.
00:26:42.168 - 00:26:42.820, Speaker B: Right?
00:26:43.670 - 00:26:58.754, Speaker A: And now the last interaction is to unwrap that token. So once you do the swap, the last operation that you'll do is to get the shell wrapped ERC 20 token, burn that and then get the underlying token back to the user.
00:26:58.882 - 00:26:59.318, Speaker B: Right?
00:26:59.404 - 00:27:55.290, Speaker A: And that's it. And we just call this do a multiple interaction method. And we are able to see that we have a check here in terms of the decreasing and increasing of the input and the output total balances of the user who call this method. And we have these checks that the balances should have increased and decreased. And based on that we are able to verify that we are able to make these complex operations work in just one transaction, right? And the similar flow is here for deposit interactions as well. The only difference that you'll see is that the output token is basically the output address is basically the curve LP address in this case, because with curve, when you deposit liquidity, you get a LP token back. So this is the address of the LP token that we're using, and we'll be unwrapping the LP token at the end.
00:27:55.360 - 00:27:55.980, Speaker B: Right.
00:27:56.750 - 00:28:01.930, Speaker A: So it's pretty much the same process as in swap. The only difference is the token address that we're using.
00:28:02.000 - 00:28:02.522, Speaker B: Right.
00:28:02.656 - 00:28:21.554, Speaker A: And the other thing is, which is the last part of it is test withdrawal, which is again just the withdrawal side of things, where again the difference is that the input token is the LP token and the output token is either USDC or USDT, depending again on the first input that we get.
00:28:21.672 - 00:28:22.098, Speaker B: Right.
00:28:22.184 - 00:28:46.358, Speaker A: So we can either based on that, we have the test logic in a way handled in a way where it will adjust the address of the output token. And again, the interaction process, again it's the same, you have an array of three items and the input address in this case is the LP token. And the output address is, like I said, is based on the first inputs.
00:28:46.454 - 00:28:46.714, Speaker B: Right.
00:28:46.752 - 00:28:51.930, Speaker A: And again we check balances at the end that these balances should be correct.
00:28:52.080 - 00:28:52.442, Speaker B: Right.
00:28:52.496 - 00:29:19.430, Speaker A: And now I'm just going to run it on my local terminal just to show you guys how the lords of the transaction look like. I'll just probably just increase this.
00:29:32.220 - 00:29:32.970, Speaker B: Yeah.
00:29:45.160 - 00:29:55.156, Speaker A: So it's just compiling and it will run the three test scenarios that we just discussed. And it'll show a lot because with foundry you can just see the test lots.
00:29:55.268 - 00:29:55.930, Speaker B: Right.
00:29:57.420 - 00:30:07.046, Speaker A: It's just taking time to compile. Give me a sec.
00:30:07.088 - 00:30:07.680, Speaker B: Sorry.
00:30:24.830 - 00:30:38.062, Speaker A: Yeah, it's just taking some time to compile and then once we have it, we'll be able to see the test lots, just some warnings and it's just running the test.
00:30:38.116 - 00:30:38.720, Speaker B: Okay.
00:30:40.850 - 00:31:40.244, Speaker A: Let me check this once. Probably have the wrong, probably debug this once. Yeah, I'll probably debug this. But yeah, anyways, the idea is to do these operations basically atomically in that sense that you can do multiple operations, multiple interaction, and compute that, combine them into one. We're looking for more devs to sort of build on shell like create their own adapters which interact with these external deFi protocols. And our team is going to be here at the venue throughout the week. So in case you guys have any queries or wanted to discuss any ideas.
00:31:40.244 - 00:32:29.300, Speaker A: Very happy to discuss that and love to want more people sort of experimenting with the shell contracts. They have been audited recently, released a new version and we released a new version out there, the v three. And yeah, happy to chat around the contract architecture or any use cases that you're excited about in terms of building for the hackathon or in general. And this is our website. You can scan the code and learn more about it and yeah, happy to answer any questions. Thanks. Does anyone have any questions? Thanks, guys.
