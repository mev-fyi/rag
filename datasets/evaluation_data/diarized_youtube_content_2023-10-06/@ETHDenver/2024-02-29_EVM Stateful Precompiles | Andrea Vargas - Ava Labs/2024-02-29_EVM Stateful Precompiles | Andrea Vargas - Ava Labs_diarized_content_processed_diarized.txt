00:03:08.780 - 00:03:53.432, Speaker A: VM stateful pre compiles saying in other words, is just how to enable new functionality at your virtual machine level for your own blockchain to be customized to specific use cases. So before we start, and probably can someone help me with the. Yeah, there we go. Okay, so before we start, it's great to have a common background on what a blockchain. Virtual machines are also a subnet, which is a concept where avalanche you can launch your own chains. And this will be important in the context of stateful precompiles, because in order to have a pre compile, you will need to have your own chain or make the whole network to accept your pre compile. We'll get into that in a minute.
00:03:53.432 - 00:05:06.384, Speaker A: But how we can see blockchains is like a replicated state machine, which means that you start with one state, call it for instance, the different balances that you may have, the different accounts that you have active right now, whatever the state of your blockchain means, and it goes to another state through a state transition function that is being registering your virtual machine. So the virtual machines define this logic on how we are going to transition from one state to another. In the context of blockchain, this is a block. So each time you add a new block, you change from one state to another. So you can think of virtual machines to be some sort like for those that are familiar to object oriented programming, you can think of these as classes and instances. So in the same way that you have objects and classes, in the same way that you have a virtual machine, you can have an instance of that virtual machine which is a blockchain. So let's say you have the EVM which handles all the generic logic of the virtual machine.
00:05:06.384 - 00:06:21.608, Speaker A: And then you have the instance of Ethereum mainet, the instance of the avalanche C chain, and you can have as well subnet EVM, which enables you to create subnets, or your custom chains powered by the EVM. So when we're talking about customizing the EVM, first we need to abstract what the EVM is in the different layers of how blockchain works. So we have the case of Ethereum where you can have the network level or the consensus level, and then we have the execution level. So the execution level is going to tell us what are we going to change? The consensus level is going to make sure every node has the same execution step. So we all have the same state, and at the very top we have the solidity or application layer where we are deploying. As a developer, you mainly interact with this layer, but you can also interact with the different layers behind it. And when we see, for instance, the avalanche blockchain, you can have the peer to peer, the consensus, and as well you have the execution level where you can launch different subnets, each of them having their own execution environment or their own virtual machine.
00:06:21.608 - 00:06:57.364, Speaker A: And on top of that, at the application level can do whatever you want. You can have some evm where you write in solidity, some wasm vm that you can write in rust or whatever. You can have some virtual machine that uses move, or you can even have like custom virtual machines. But for this workshop, we're only focusing in this specific part. So it's not like building an application. What we're doing today, it's just modifying the interpreter of the EVM. So you can have specific functions associated to execution environment, so basic of the EVM.
00:06:57.364 - 00:07:45.560, Speaker A: So in order to go from one state to another state, you can have different kind of interactions. So you can have an external loan account interacting with another external loan account, such as sending just balance of the native token, right. You can have interactions between contracts and contracts calling other contracts as well. The thing is, for this specific case, we will be focusing on contracts. And one thing to have in mind is even though the EVM is turing complete, you cannot do, or it's going to be super hard to start doing complex computations. And it's going to be expensive. So it's easy to create just simple computation, assign some memory storage for creating different tokens, managing balances, that kind of thing.
00:07:45.560 - 00:08:41.770, Speaker A: But when you are trying to create like linear regressions, machine learning models, even more complex computation is going to be hard and it's going to be expensive. So for instance, it's not only the computational thing, it's also when you are building a solidity, you might face some limitations, for instance, the lack of libraries. And this is something we are going to be solving with pre compiles. So for instance, one thing that you can use this for, and something that precompile is activated actually in ethereum for, is for cryptography. It's never good idea to write your own algorithms for cryptography. So one good thing, and something that is already battle tested is probably not out in solidity. So one thing that you can think of how you are going to build your application is not going to the application level, but to the virtual machine level.
00:08:41.770 - 00:09:30.788, Speaker A: The pre compile, you can see it like go code, wrap it in a solidity interface. So this is going to make it even more efficient. Solidity is actually a language that has a lot of flaws and go is a little bit more battle tested, has a lot of libraries. So if we can see the different benefits of why doing this, a lot of has to do with performance. It's performance. You can use existing libraries, which is really nice when you want to create specific things for, let's say zero knowledge proofs. You don't need to go and reinvent the wheel on solidity, but you can just take what it's already built on go and just implement it in your pre compile.
00:09:30.788 - 00:10:23.112, Speaker A: It will give you more security, you will have more advanced functionality, and it's going to be great. So another thing is for interoperability to verify data on communication primitives. This is something that we actually use as the pre compiles to communicate different chains that they are not EVM. So if we have some way to decode and encode data from one chain to another, we will be able to start communicating to chain that doesn't even have the same execution environment such as the EVM. So that is actually what happened with avalanche war messaging, if anyone wants to go deeper into that. But for now, just think of the precompile as this grappler on some go implementation. Something to have in mind as well is that precompiles are not at the bytecode level.
00:10:23.112 - 00:11:09.400, Speaker A: You don't have any bytecode associated to this. You will be modifying the specific code of the virtual machine. So think of it as a shortcut to execute specific functions of your virtual machine. So an important thing is how these work is whenever a pre compile is called, this is deployed some specific address. We will see an example in the next slide, but it gets deployed as a specific address. And whenever this address is being called by any application, the EVM will know it's a precompile and will not load any bytecode. In contrast, if it's not a pre compile, then it loads the bytecode and interprets the bytecode.
00:11:09.400 - 00:11:51.940, Speaker A: So for instance, this is the interface that a pre compiled contract, not a stateful pre compile yet just a pre compiled contract, is going to use. And something also important is that you can customize the gas that is being consumed by this pre compile. Why? Because this doesn't follow the rules of the opcodes kind of charging of the gas as you do with simple applications on solidity. But you can specify how much it's going to cost you to call, let's say a cryptographic function on the EVM. This will make it as well more efficient. And then you have the execution part of it. So this is how, for instance, Shattu 56 looks like it's going to be deployed at this specific address.
00:11:51.940 - 00:12:54.830, Speaker A: This is a reserved address. This is why it looks so weird, because it's not created in a normal way, but they have some space of addresses reserved for these pre compiles, and this is how you interact with it. You just need to import the interface and in order to start interacting, it's just like a normal interaction with any other solidity contract. It just will execute, not in the smart contract itself on solidity, but in the go implementation of it. So how you create one, and this is a go code where you can, I don't know if you can see really clear, but the go code, you actually import some crypto shadow 56 in the project, which is a go library, and you can start implementing over here it is the implementation. So that is how you start doing pre compiles as that just computation. But when we come to stateful pre compiles, this stateful pre compile actually injects a state.
00:12:54.830 - 00:13:43.040, Speaker A: It can actually inject or have some state access to the database that we are working with. So it needs to implement some other structure. The run function has this pre compiled accessible state. This is really important and it is really dangerous as well because you are giving access to the state of the blockchain to your virtual machine. So this is why you need a network upgrade. Each time you want to implement this kind of pre compiles, either you need a network upgrade or you need your own chain. And this is why this starts taking a little bit more adoption once we can start launching our own chains instead of trying to customize a general purpose chain.
00:13:43.040 - 00:15:06.388, Speaker A: So as the other one, this one also has some gas supplied and some remaining gas after the execution of the pre compile. And when we see this element of the pre compile accessible state, you can see that this gets the state database. And this is the part where you will be able to start changing the different key values on your database. So yeah, behind that all that is just key value pairs where each key refers of an address of a contract and the value you're going to be changing and it all hashes in the value side of the key value purse. So what kind of different pre compiles can we see that make sense? Stateful precompiles, because these now is not only computation, but you can also start writing into state. You can say, for instance, I want an allow list for who can transact in my network, making the chain suitable for permission use cases or more private use cases. Instead of blocking or having the allowed list at the application level, you can say like I don't want anyone to deploy, I don't know, a marketplace or an NFT on an institutional chain that doesn't have anything to do.
00:15:06.388 - 00:16:12.244, Speaker A: So you can leave that everyone, like let's say everyone can participate, but not everyone can deploy a contract on the chain. So that way you can restrict how the block space is going to be used for your specific application. Another thing that we can have is native minter. This is really nice when we're trying to build cross chain applications, especially when we are trying to use some native token that represents another native token in another chain or any other token. So for instance, if we are talking about the subnet that wants to use, I don't know, USDC as a native token, as a native gas, you can actually set the native minter of the native token to be the bridge contract. Of course this has some implications on how this is going to you need to make sure that contract is audited and in order to actually mint those tokens natively correctly. Also, another thing that you can do is creating a smart contract or a pre compile that handles all the fee configuration.
00:16:12.244 - 00:17:07.928, Speaker A: And this is great, for instance when you want to, let's say reduce the gas fee or the gas price that you are paying a minimum gas price on each transaction. Before this pre compile you will need to go for a network upgrade. But if you activate this pre compile, you can say that a contract is going to handle it. Of course these contracts will have an admin and you can do it however you want, but this allows you to customize the execution layer of your blockchain without needing to go at an application level. So all this happens and how you configure this kind of pre compiles is on your Genesis block. The Genesis block keeps track of where is this going to be activated. Because some pre compiles could be activated at the very beginning, some others need to be activated as an upgrade.
00:17:07.928 - 00:17:51.048, Speaker A: So if you're going to activate that in the very beginning, you will need a pre compile. You specify the address and you will be able to start interacting with a solidity interface. As I just showed, if you want to go deeper, because this is not like a super long talk to see how you can deploy your own pre compiles. This is actually go code. We have in here an academy that you can check out. So basically we created something that we call the pre compile VM this pre compile VM allows you to only focus into the pre compile part. It abstracts all the complexity of the subnet EVM or the EVM as a whole.
00:17:51.048 - 00:18:50.412, Speaker A: And it will allow you to only deploy this. So basically if you want to see how the steps look like, of course we're not doing it today, but you just need to clone the repo and you create a solidity interface. This solidity interface is how you will be interacting with it from another contract. And this solidity interface is just like as simple as any interface that you have seen in solidity before. But once you have the solidity interface, you can compile that and then you can create, we have this generate pre compile sh that is super helpful for you to create all the boilerplate plate code that you will need in order to generate this precompile. And now you need just to fill out the logic of how your precompile is going to work. There is where you start putting the functions or the libraries from go either the shot to 56 or different cryptographic functions, different kind of logic that you can put there.
00:18:50.412 - 00:19:40.556, Speaker A: I've seen a lot of hackathon projects, including functionalities for serial knowledge proofs. So yeah, you can import there the thing you're going to do. And then you need to specify when you are building a virtual machine, you need to tell these virtual machine what plugins or what pre compiles are you activating. So you just modify one file, set the reservoir you're going to be using to activate, and you complete the module go, which is a file where you specify the address that you're going to deploy to. So you just need to make sure you are not using reserved addresses for another thing. Or you cannot have two pre compiled with the same address associated to them because if not, it's going to fail the build, you just build the virtual machine and start the network. So yeah, that's it.
00:19:40.556 - 00:20:13.850, Speaker A: You can run a network as well. Just test it out, see how it works. And we do have in the academy that I just show someone miss it. Here's the QR. You will find different exercises from doing computational pre compile just to generate different cryptographic functions, up to creating allow list or anything that just start toaching the state of your virtual machine. So thank you so much everyone, and if anyone has any doubt, we can happy to talk after I go step down.
00:20:18.380 - 00:20:55.990, Speaker B: Thank you so much Andrea everyone. If you want to learn more about the topic, don't hesitate to consult the academy. They're here for that and they'll be more than happy to give you more information about the shortcuts on EVM. Thank you so much, Andrea. So now for our next talk, we'll have Murat Agdenis, the founder of Primev, who will join us, and he will be here to present pre confirmations on Mainnet. No. Yeah, there's a mix up.
00:20:57.480 - 00:21:00.210, Speaker A: I'm happy to present my topic. I've got a.
