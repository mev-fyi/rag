00:00:04.210 - 00:00:17.766, Speaker A: Hey. Hello, everyone. Hey. Thank you. So, I'm Janice. I'm from ddub. We are a security company in the blockchain space.
00:00:17.766 - 00:00:50.002, Speaker A: And if you are doing blockchain security, you've probably heard of us already. If you're not doing blockchain security, you probably have not heard of us. Ah, so we've been around for a little while. So if you have heard of us, it's probably because of this little site, Contractlibrary.com, which is something that's been continuously running since mid 2018 or so. So contractlibrary or library ddub.com is this service that has the best decompiler out there.
00:00:50.002 - 00:01:38.180, Speaker A: So it reverse engineers contracts as they are being deployed on Ethereum and other EVM based chains, and it also lets you inspect contract states, transactions, et cetera. Let me blow this up a little bit. Well, okay, network is slow, so maybe not the best for a live demo right now, but within a couple of seconds it's going to show us a contract and we can have a look there. But that's not the topic of today's talk, although I will very briefly go through contract library. You can browse on your own at library dw.com or contractlibrary.com. So since the network is slow, let me get back to my talk and go through the slides again.
00:01:38.180 - 00:02:28.064, Speaker A: Well, network being slow doesn't help for anything. One sec. Let's not have network one secondary it. Okay, sorry about that. It is wired, by the way. It's not the wireless network that's acting up right now. Okay, so we have contract library.
00:02:28.064 - 00:03:08.972, Speaker A: Our core technology is static analysis, meaning trying to produce models of programs of smart contracts, in this case, for all possible program executions. And we write static analysis by writing lots and lots, like thousands and thousands of little rules that look like logic. So we build up concepts such as a loop is bound by this variable, a variable flows to another, we have exit conditions, induction variables, et cetera. We have logic that analyzes smart contracts. That's the core of our technology, including the decompiler. Now, do you care about that? No, but that's what's behind the hood. That's under the hood.
00:03:08.972 - 00:04:04.160, Speaker A: So all of this technology has led to many, many different vulnerability disclosures. We've found many visible bugs out there, and in the past couple of years, we've disclosed about ten different vulnerabilities. Well, we've disclosed many more, but ten vulnerabilities in deployed projects out there. We've gotten bug bounties of over 3 million total by some fairly visible defi services. So these kind of showcase our main analysis technology that's actually also used in our flagship tool, the ddob watchdog, which continuously analyzes and monitors the blockchain. Now, what I'm going to do in this talk is first of all, just give a couple of examples so you can take something home and have kind of a couple of fun examples to remember of code. So those are going to be our solidity EVM traps.
00:04:04.160 - 00:04:43.260, Speaker A: And I have a lot more. So if you want to talk to me afterwards, find me over here in our impromptu Q a location and I can discuss more. And then I'm going to talk a bit about smart contract auditing and how to best prepare your code. So it's actually very well auditable. So EVM traps, here's a very, very simple one that's about the simplest you can get in most object oriented languages. You write this fun, and it's exactly the same thing as writing fun. Well, that's not the case in solidity.
00:04:43.260 - 00:05:19.764, Speaker A: The difference, as many of you know, if you've been developing solidity, is that the first one is an external call. The second one is an internal call. External calls change the message sender. So since the message sender is our main authentication mechanism, to make sure that we are being called only by approved accounts, this has significant security implications. So this is something to be afraid of in solidity. Whenever you say this fun, it's not something innocent, as if you're just calling a local function. So that's something that, you know, you've internalized.
00:05:19.764 - 00:05:52.164, Speaker A: It's in the back of your mind. So it's kind of a standard caveat of solidity development, but it is not what beginners will do, for instance. So that's a trap in solidity. Here's a second one, and in fact, the first one was behind the vulnerability that we've disclosed. But the second one is behind the vulnerability we disclosed, a vulnerability that could possibly have been the largest hack ever of more than a billion dollars in value. So this is what we call phantom functions. That's a term we came up with.
00:05:52.164 - 00:06:45.844, Speaker A: And now this will require your attention a bit, unless you've seen phantom functions before and you know what they are. So here is the vulnerable code. We have two functions, deposit and deposit uses transfer from. And as you may know, if you've done smart contract development or even used smart contracts with transfer from, you need to have given approval to the contract before for a certain amount or infinity, so that it can spend your coin in this case, the underlying coin. So we have a legitimate function, deposit that says transfer from whoever called the function. You use that person's, that party's money and you transfer it to this. And there's nothing wrong with deposit, I can tell you that already.
00:06:45.844 - 00:07:24.976, Speaker A: You have to give it approval before and then you do a transfer from just as the ERC 20 standard intends. The second function is where the bug exists. We have deposit with permit which says, even if you haven't given me approval before, you can give me approval with an off chain signature. That's the signature that you can sign without actually spending gas. You sign off chain and then you submit that signature together with your transfer from. And that permit gives approval so you can spend the money. And you give approval to this contract to do whatever it wants with your money.
00:07:24.976 - 00:08:13.740, Speaker A: And it moves the money from the target to itself. And the bug here, the phantom functions bug, is the following. What's the permit function for west nine? The wrapped ether contract. Well, you're looking at it and it doesn't have the word permit anywhere. So weth nine is a contract that supports a permit just because it has a catch all function, a nameless function to receive ether originally. And when it receives ether, it just deposits it locally. So this contract can accept a call to permit without ever defining a permit.
00:08:13.740 - 00:08:44.590, Speaker A: That's what we call a phantom function. So if we go back to our example, the main idea is that the main element of the attack is that this function is not reverting. The contract accepts a call to permit, doesn't do anything. But let's look at our code again. The first line here is a no op when we're talking about the weth contract, when we're talking about wrapped ether. So calls permit, nothing happens. And then you can transfer from anyone's money to this.
00:08:44.590 - 00:09:38.296, Speaker A: But they haven't given approval, have they? Well, they have if they've ever used the first function. So all the many thousands of accounts that have given approval because they wanted to use deposit, the non buggy function, are now exploitable using deposit with permit. The buggy function that has the permit be a no op. That's the phantom function vulnerability. A phantom function is generally a function that even though it doesn't exist, the contract accepts a call to it without reverting. So now that we saw a couple of caveats, a couple of buggy patterns in solidity, or big threats in solidity, let's go to the main body of the talk and give an idea of advice on writing. Well, auditable code and I could also say correct code or secure code, but maybe that would be too much of a claim.
00:09:38.296 - 00:10:25.308, Speaker A: So I'll just say, well, auditable code. So I first should say that you probably have not heard of our company ddob, but if you've used the blockchain at all, you've definitely used almost certainly, I should say in the past six months, you've almost certainly used code by some company. We've audited. We've audited a lot of top name defi protocols, so we've done a lot of smart contract audits. And this kind of comes as the experience from all these audits. Now, first, before I give advice, let's start with some unpleasant news. The number one unpleasant truth is that auditing will not catch all bugs in your code.
00:10:25.308 - 00:11:08.308, Speaker A: And in fact, auditing is not even the best way to find some kinds of bugs. What kinds of bugs? Anything that has to do with things that humans are bad at, but machines are really good at. Boundary conditions, treating a difference like an absolute number. Auditors may notice those things, but they may also not notice those things at all. Whereas very simple tests will catch those things. Generally, in correctness of programs, there's usually a distinction between security and functional correctness. For functional correctness, meaning for correctness, under normal use, the best way to find bugs is testing.
00:11:08.308 - 00:12:10.312, Speaker A: Test under many, many different scenarios for security tests will not help you too much, because hackers, or malicious hackers, black hat hackers, will try to think of ways to abuse your code. And that's what auditing is best at, to try to think like a hacker and try to come up with ways that a given correct piece of code within the envelope of correctness can be abused to produce weird results. So auditing is best for malicious use, testing is best for normal use. Now, having said this, and let's also get to the second unpleasant truth, and there will be a third one at the very end. Not all audits are equal. You do a smart contract audit with even the best firms out there, including ourselves, there's a wide range in the auditor's confidence. An audit doesn't stop when there's 100% confidence, because there's never going to be 100% confidence.
00:12:10.312 - 00:13:07.548, Speaker A: An audit stops when there is reasonable confidence within a reasonable amount of time that's close to the originally allocated time. So given that, the question is how to best prepare your code so you get the most you can out of someone who is your strongest ally in the security business, that is your smart contract auditor. And there won't be too many surprises here. First of all, we want to cover all the good bases, documentation, comments, good variable names, well tested code, good communication channel, and let's say you've covered all those. What's the number one thing that you can do to help your auditor? And then, of course, this way, help yourself. For me, the biggest difference maker is invariant. That's kind of a standard thing in all of computing.
00:13:07.548 - 00:13:42.068, Speaker A: Our minds are weak. Our minds cannot process instructions at billions per second. And the only way we have to control this complexity is to come up with rules that are never broken. And that's what an invariant is. And there are many, many kinds of invariants. So in all these slides, perhaps more than what I say, more important is the example that I put underneath. So in terms of temporal or state invariants, here are a few examples I would love, when I audit code to see something like this.
00:13:42.068 - 00:14:07.360, Speaker A: We only get here with lock called before. This function is only reachable from methods called by the hub, whatever the hub is. That's very informative. That's a property that I can now question. But also it gives me some confidence that, oh, they've thought of this. These are the scenarios that I care about. I'll check if there are other scenarios, of course.
00:14:07.360 - 00:14:43.500, Speaker A: But now I can form a model much more easily of what the program is trying to do. And of course something standard, like every time you have contracts and they're being audited, the auditor will say, oh, is the balance, is there supposed to be a balance on this contract? Either ETH or token balance? That's a big thing. Or they will say, if there is a balance, it's stealable. So don't do that. That's a standard invariant property. And invariants don't only pertain to temporal or state properties. Obviously we're going to have functional invariants like the logic of a computation.
00:14:43.500 - 00:15:01.908, Speaker A: So here are a couple of examples. Example of functional invariants. Let's start from the bottom one. That's the easiest. If you have a quantity and you know that it's in ten decimal scale, tell me, put it in a comment there. This is an e five scale. I want to know that.
00:15:01.908 - 00:15:32.556, Speaker A: I don't want to have to reverse engineer that and similarly many others. If you do smart encoding, absolutely. Tell your auditor also in this way, you're telling yourself, and you're telling everyone else who will ever read this code, and you're actually making your auditor try to prove you a liar. Try to go there and say, hey, this is not true. You violated that over there. For instance, if this quantity is positive, it means it's an input amount. If it's negative, it means an output amount.
00:15:32.556 - 00:15:53.428, Speaker A: Okay, clever. Okay, let's see if it really holds. If I have an array, it may say some quantity that goes together with an array. When I pass it around, functions is denominated in the last of the tokens in the array. That's very useful. That's the token out. I want to know that, that I have an array and then some amount.
00:15:53.428 - 00:16:17.448, Speaker A: The amount is in, token out. Good. I want to know this property, other properties. There could be structural invariants like how smart contracts in a complex protocol interact. For instance, strategies have to override functions, reinvest and report profit. That's very useful to know. That's something you should write, you should document.
00:16:17.448 - 00:17:00.072, Speaker A: It will help everyone, including yourselves, and it will help establish what correct behavior in the protocol. If a strategy issues rewards, it should override both the reward token function and the reward rate function. The moment you write it, you will find violations, especially, say, in a yield farming protocol that will have 50 different strategies. And then there could be a lot of other things. And I'm not going to go into great detail on this slide because I don't have too much time. But for instance, imagine something as simple as this. Sub until zero x Y, and the behavior is actually either x minus y or Y minus x.
00:17:00.072 - 00:17:18.272, Speaker A: And one of the two is zero, depending on which one is larger. Well, tell me that. That's a great property to know. I have it there and I know it every time I look at sub until zero. And same with liquidity. And this is more complex. That's why I don't want to go into it.
00:17:18.272 - 00:18:00.476, Speaker A: But if you have some amm, for instance, uniswap style, you may have some complex property like this. And it makes sense if you know where the current liquidity tick is. Okay, so to wrap up, we saw a few different invariants that are interesting properties. But what's the number one take home message from all of this? The number one take home message is that you are the owner of your project. As a developer, your auditor is not an owner. Your auditor is on your side. They will spend significant time.
00:18:00.476 - 00:18:40.120, Speaker A: They will become you. They will try to get into your brain for a couple of weeks and think exactly like you do based on your code. They will be your ally, but they're not an owner. So if an auditor tells you, well, here's a potential vulnerability, well, the first wrong reaction would be, oh no, that's not true, or that's not important or this and that. The second wrong reaction is, oh, you're right, that's a vulnerability. And here's the easiest way to fix it. We'll put an if there, and it will exclude just these exact behaviors.
00:18:40.120 - 00:19:39.930, Speaker A: What's the right reaction? The right reaction is, wow, so someone who didn't even write this freaking code thought about something that I hadn't thought of. Where's my mental model wrong? What else did I not consider? How can I generalize from this one vulnerability and find three more that the auditor never even considered? That's how to get the most out of an audit. If you treat every report of an audit as something that will provoke more thought and will make you think a lot more, to find very, very similar issues. So I think that was kind of a quick rundown of my advice pre audit. Thank you again for all the bugs in code that result in bounties, that result in interesting intellectual challenges for us every time we audit code or we find it in the wild. And please check out contract library and ddope. Thank you very much.
00:19:39.930 - 00:19:57.390, Speaker A: It we only have 17 seconds, so I cannot take questions. But like I said, the Q and A, informal Q and a session, will be here and then back there, so come catch me. Thank you.
