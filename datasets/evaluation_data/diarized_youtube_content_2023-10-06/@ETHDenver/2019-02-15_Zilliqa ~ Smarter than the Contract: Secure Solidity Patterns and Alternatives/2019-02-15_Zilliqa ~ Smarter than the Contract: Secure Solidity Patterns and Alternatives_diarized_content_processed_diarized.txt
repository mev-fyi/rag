00:00:18.730 - 00:00:42.214, Speaker A: All right. Hello, everyone. Thanks for having me. So, I'm Edison, and I'm an application lead at. I lead a team of application engineers at Zilliqa, and we built things on top of the blockchain. So Zeldaqa is a public, permissionless blockchain, and it's scalable and secure. And the reason why I'm here is that I came from a long journey.
00:00:42.214 - 00:01:38.170, Speaker A: So I started off with solidity, writing smart contracts on solidity. Then I went on to grad school, and I wrote about permission blockchains in my thesis at CMU. So after grad school, I joined Zuleka as one of the first application engineers. So when you're in a capacity that you are actually writing a lot of these applications for blockchain, you are forced to actually think about security. And this is what I'm here for, is to share some things along the. So, first of all, just a general question is that are we really safe today? So, over the past few years, we have seen some attacks. So in 2016, there's the Dao hack, in which an attacker is able to siphon away $60 million by exploiting a reentrancy bug in a contract following flowing, which in 2017, we have the parity bug, where someone is able to queue a contract, a multisynate wallet, and that result in $200 million worth of if at the point of time, to be frozen.
00:01:38.170 - 00:02:26.054, Speaker A: And we are lucky that in 2018, there hasn't been any major security attacks. But really, is that, are we truly safe, or can we actually take precautions to make ourselves safer? So, in 2018, this is from a research paper that was published, and it says that nearly 34,000 contracts are vulnerable. So that's actually three by 4% of the contracts that are still vulnerable today in 2018. So this is something that we have to think about and really think about things that will make our contract safe, vulnerable. So this is going to be our agenda today. I know some of you in this room might not be a blockchain developer yet, but that's all right. So I'll go through with you some of the intricacies of blockchain development.
00:02:26.054 - 00:03:02.802, Speaker A: What makes it so different from the traditional software development that we are used to? I'll talk about some of the security pitfalls along the way, introduce some tools and also some alternative smart contract platforms. Okay, so, first of all, what makes smart contract programming different? Someone from traditional background. This is how we see the world. You have a server that talks to database, and it is very predictable because many concurrent controls are actually controlled by a database. There's a scheduling system. It makes sure that your transactions come in and you get the output that you want. So it's very easy to be controlled.
00:03:02.802 - 00:03:37.954, Speaker A: But on the blockchain this gets a little bit more involved in a way that your blockchain contains both the wallets and the contracts. Basically, how we think about smart contracts are that the users can talk to other contracts. And that's all right, that's still okay. But the worst of all is that the contracts can talk to other contracts. And later I'll show you an instance where we forgot about this fat, the second point where contracts can talk to other contracts. So this is where some of the bugs actually happened. I'll show you later on.
00:03:37.954 - 00:04:21.786, Speaker A: Okay, so when we think about Ethereum, there's also one more thing, is that Ethereum is an infinite state machine. And by what I mean is that there's a start point, which is the Genesis block, but we really don't see an endpoint. It will just keep on going forever. And within every block it is very impossible for you to determine what is the state of the next block. So in this infinite space you need some kind of a way to think about development in general. So Ethereum nodes agree on a shared world state that is modified over time by transactions, and there is really no end state to this. So what really makes smart contract really hard to program is that it is complex.
00:04:21.786 - 00:04:53.958, Speaker A: A smart contract has to do a few things. It needs to store state. Basically your database is all in the smart contract level. It needs to be able to do computation, multiplication, addition, division, all on the smart contract. And it needs to be able to communicate with other contracts or other users. So for example, if you were to have a crowdfunding campaign and you managed to raise your funds, so you are going to make sure that your smart contracts can transfer the funds over to you. And this is all done on one single contract.
00:04:53.958 - 00:05:44.170, Speaker A: So this piece of code really hard to reason about. And this is why it is a honeypot for attackers to attack. And also, when we think about software development, we are very used to the word that we get whatever things that we want them to do. So as developers ourselves, we are extremely good in telling people what our applications can do, but what we cannot do is to tell people what our applications cannot do. So this is where things get interesting. Because of the way the blockchain is designed, sometimes your transactions might not get through and you can't really control how your transactions are going to be placed on the blockchain. In summary, these are the few things is that contracts have the store states, which is basically data, and it has to be able to communicate with other contracts.
00:05:44.170 - 00:06:14.162, Speaker A: Transactions are not free. We need a way about calculating how gas is being computated so that we can compensate the miners appropriately. And also blockchain is immutable. So once we deploy a smart contract on the blockchain, you cannot change that contract. That's generally the rule of the time. So let's dive into some of the security attacks. So this is the one that is the most interesting, which is the reentrancy attack.
00:06:14.162 - 00:06:50.960, Speaker A: And this happened in the DaO hack. So what happened in here is that there's a reclaim function in the DAO. And what it basically does is that it returns the money back to the user. So as you can tell, in the first line is that it referenced the amount of money that a contributor has contributed to the fund. In the second line, it do a call value, which is an unsafe method, by the way. Please do not use this method to call another to return this address, to return this amount to another user. And finally it resets this balance back to zero.
00:06:50.960 - 00:07:48.580, Speaker A: So what the developers of this contract did not think about is that the address in that second line, is that the one that you are trying to send to. It could be not a user, it could be an address, it can be a smart contract, which is basically the permiss of this bug, because someone managed to call this function through a smart contract, which will allow it to reenter this contract and keep draining the funds in real time. So some of the people say that when you're in 2016, it's like looking at the bank robbery in real time. You can see your money being siphoned away, but there's no way for you to stop this. And secondly, is about this thing called a front running attack. So some of you know this by this term called transaction ordering dependence. So the idea is this, is that you are not able to determine which transactions go first.
00:07:48.580 - 00:08:39.102, Speaker A: How it works in Ethereum is that when you submit a transaction and someone else submit a transaction, the miners have an economic incentive to place the one with a higher gas price above the others. So in this way, some of the transactions might get confirmed before your transaction. So for example, in this contract, call marketplace presume that I want to update a price, then I want to allow it to be sold to Bieber. Someone else can actually put a higher guess cost so that they can buy it before my transaction to update the price of the item gets true. So in this case, he's able to get the item at a cost that is incorrect. So this is the basis of the error. Finally, there's this thing called an uncontrolled resource consumption.
00:08:39.102 - 00:09:41.110, Speaker A: And what it basically does is that if you don't control the size of your array and you grow it arbitrarily, you might reach to a point that the cost of fetching an item from the array might exceed the whole guess limit of the block. And this is very problematic in this case, for example, that if a caller tries to empty this array, need not to strike this lottery, this transaction will never go through. And no one is able to call this contract because this contract for this function itself, it requires a guess amount that is way higher than the gas limit of the block. So this is in fact, doc, is a denial of service attack on a smart contract. And I think that right now, if you use any analyzers or any auditing tools, they will flat this out to you to say that this is vulnerable. So we have seen some of these attacks. So what can you do about it? So here are some things.
00:09:41.110 - 00:10:22.082, Speaker A: So on the first bug just now, instead of using call note value, simply use a safe method like transfer or send. These are basically safe because it has a guest iponed for the next address, which is only sufficient for it to emit an event. So there is no way that an attacker can reenter the contract because there is not enough gas to reenter the preceding contract. So be careful of black holes. So particularly in theorem, there are a few no go addresses. And this might sound stupid, but it happens. So there are 800K worth of ethers in the zero address.
00:10:22.082 - 00:11:17.982, Speaker A: If someone can find a private key to find this zero address, you might be a millionaire, or even in us, where there's like $150,000 worth of contract stuck, worth of iter stuck in the contract itself. And because no one has the private key to the contract address, that Iter is just lost forever and it's just locked up there forever. So if you go to ether scanning, you can still see this on the ether scan. So I think at a minimum, you should do these two checks to make sure that you're not sending your tokens to a zero address or a contract address. Next is that this is a paradigm of thought. It's a thinking process of how you should reason about smart contract security is that you first begin with a precondition. So this means that you should put your required statement, your modifier all at the top and check whether the parameters are valid.
00:11:17.982 - 00:12:27.526, Speaker A: So if they are valid, then you may go on and make the state changes. Finally, then you interact with other smart contracts. So this should be how you think about writing ethereum contracts and any smart contract in general, you should always place communication at the last, because if any contract fail, there's a few reasons to that. One is that you do not know what the contract is going to call, like you're not sure if this guy is malicious or not. You should always assume that you're in an adversarial environment and you need to protect your interest. So the fourth thing is that if you need to return money to people, always favor pull over, push. So in this example on a bet option is that if you win a bid and you basically send this money back to the previous highest bidder, but what you should do instead is that you should place it in a data structure within your contract, such that someone else has to explicitly claim that money back from the contract.
00:12:27.526 - 00:13:10.106, Speaker A: So the second one is a better way to do it. I know it's not a very ideal for developer experience, but it is a safer way to go about returning money back to the user. And some general tips and philosophy along the way is that you should always implement circuit breakers and speed bumps. So what do I mean by circuit breakers? It's basically like a fail switch. If things go wrong, then it will go into this circuit breaker and it can temporarily freeze transactions until you fix the issue. And also speed bumps is that you should have some delays. So maybe introducing some kind of block time, some minimum amount of block before the next transaction can go through is a very good way to think about it.
00:13:10.106 - 00:13:46.100, Speaker A: So these are the two things that you should think about. Simplicity is the ultimate sophistication. So what I mean by this is that keep your contracts simple. Always prefer modular approach to monetic approach. So the monetary approach means that you put all your code into one function and you don't try to make them into different functions. Instead, you should always try to make it into modular function because it is easier to test and it's easier to trace your error message. And this is a bit primitive, but I always found it helpful to draw the state diagram on a piece of paper.
00:13:46.100 - 00:14:38.050, Speaker A: And this is why is that when you draw things, you can see things in a way that your mind don't really think about. So for example, that's this thing called an event ordering about. And basically it is the idea that if you send a few different inputs, there might be different output based on the order of this transaction. So it is the superclass of the transaction order independence that I was talking to you about. And what this bug basically does is that it violates this property of linearizability, which is basically a well known property in concurrent data structures. So think about it this way, is that an operation should always seem to be synchronous. It should always seem to be instantaneous and atomic to an end user, basically.
00:14:38.050 - 00:15:31.526, Speaker A: So one way to think about it in real life example is that imagine you have a computer with two threads and they are trying to count. It's a global counter. So if two of this thread, A and b, increase this counter by one, someone with a bug like this, basically event ordering is that it will report you with a one value of one, because one of the values will precede the other one, and you will overwrite this call instead. A good program will always give you two, because it considers both of these inputs that are coming in simultaneously, and it returns you the correct output of two instead of one. Okay, so enough of theory. So what can you do about it? And fortunately for Ethereum, there's a lot of security tools that you can use. So one of them is that you can actually use visualization to visualize how your state changes over time.
00:15:31.526 - 00:16:00.650, Speaker A: So when we think about bugfinding, it's about you trying to find different path to an error. And if you can't find an error, you can be sure that you are safe. So this is basically a diagram to show you how bugfinding approach works in general. And there's a lot of these automatic code auditing tools like Oente and Mifril. I would suggest that you guys use this tool. You should always use test coverage recently. You can even integrate them with truffle.
00:16:00.650 - 00:16:40.950, Speaker A: We should integrate it nicely with your Travis CI tool. So you should always use this and linked us. If you don't have one on your editor, install it now, because this takes no effort at all. It will just simply show you things that might go wrong. For example, things like unused parameters. So always install a linker on your machine, whether is it solidity or is it JavaScript or is it Python, just install them and you will be able to eliminate 90% of the bugs that happened. Okay? And these are basically the tools that I've explained to you previously.
00:16:40.950 - 00:17:25.622, Speaker A: You can use this tool to actually detect some of these errors. So in the diagram on the right side is this tool called Mayan Maien, and it is a tool that was developed last year. So what it is able to do is that it's able to detect smart contracts with different classes of security flaws, like being greedy or being prodigal or being suicidal. So it is able to detect things like the multistick wallet head in the parity. So if you use some of this tool, you can avoid things that happened in the past. And we can also consider alternative smart contract language. So I'm not sure how many of you in this room are already using Viper, and I think that Viper is really exciting.
00:17:25.622 - 00:18:13.574, Speaker A: Recently there's a formerly verified viper contract, and I'm really excited for the progress, and I really think that it's a general purpose experimental, and because I'm also a python developer, so it seems a lot more intuitive to me as well. And the idea is to build a simple and secure smart contract, and it tries to eliminate many of the bugs that are found on solidity. It is still experimental, it is still beta, so use them with precaution. Another one is smart contract intermediate level language. So as a disclaimer, this is a language that was developed in my company. So we believe that this is quite a good way to think about security of a smart contract. Basically, what happens is that we impose a structure on developers.
00:18:13.574 - 00:18:57.426, Speaker A: So yes, you're not that free to do whatever you want, but we impose a structure such that, for example, things like making sure communication happen at the last of the function is enforced on a language level. So when we do all of these rules, we try to eliminate some of these possible attacks and vulnerabilities that you might face when you're developing your contracts. So it is a principled language that imposes a structure that makes your smart contract less vulnerable. It cleanly separates between computation and communication. So communication will always happen at the last. And this is done on a language level. This language is amenable to formal verification.
00:18:57.426 - 00:19:42.466, Speaker A: We have developed this language hand in hand together with cock, which is proof assistant. And as a disclaimer, this is developed in my company. So take it with a pinch of salt, whether is it the best tool for you or not. Because we are sponsoring this event, we are giving out a bounty of $3,000 for any hackers who is interested to build a cross chain oracle. So we believe that the future is collaborative. So if you are able to build things between Ethereum and going to a centralized oracle and going back to Zilliqa blockchain, we are happy to give you this $3,000 and we'll be happy to guide you along. So if you're interested in this, or if you're interested in Zelda car in general, come and speak to me afterwards.
00:19:42.466 - 00:21:08.992, Speaker A: Thank you. So any questions? Yep, go ahead. The re entrance, the attack came in this one. Just make sure. Where is the question again? Where is the question again? This one? Yeah. So let me explain what, what will go wrong with this? So if, if you're trying to push a funds to a contract, and what if this contract address, what if this address is not a user? It is a smart contract that's making this call. What basically happens is that you are sending if to a contract that is never able to reclaim that if back because the contract might not have the function to actually transfer the if to someone else.
00:21:08.992 - 00:21:51.244, Speaker A: And this results in the ether being locked up forever. So when we think about addresses in Ethereum in general, there's always this difference between a user contract and a user address or a smart contract address. So the problem in this push one is that if you're trying to push if to a contract, it can never retrieve this if back. And this will result in if being frozen forever. So does that clarify your question? Great, thanks. Go ahead. These slides are not public.
00:21:51.244 - 00:22:14.700, Speaker A: Yeah, I'll have to think about it. But yeah, I'll give you my name cut later. So if I make it public, I'll let you know. Any other questions? It. Okay, great. Thank you. Thank.
