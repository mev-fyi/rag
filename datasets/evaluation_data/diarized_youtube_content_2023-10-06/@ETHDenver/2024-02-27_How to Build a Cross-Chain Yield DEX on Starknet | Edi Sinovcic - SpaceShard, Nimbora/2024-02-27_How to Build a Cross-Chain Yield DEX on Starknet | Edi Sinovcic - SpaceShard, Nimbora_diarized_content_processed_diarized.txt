00:00:07.930 - 00:00:32.498, Speaker A: Awesome. So thanks everybody for coming here. Today we are going to talk how to build a cross chain yield decks on Starknet in this case. So brace with me, there will be some technical stuff, but I will try to be as gentle as possible with these kind of things and make it as simple as possible. So a bit about me. I started as a cord dev back in the day. Basically worked on something that's called Zocratis, which is toolbox for ZK snarks on Ethereum.
00:00:32.498 - 00:01:21.766, Speaker A: These were like the old days when the ZK was starting. Then I moved to solidity team, worked there for two and a half years on sourceify, founded a company afterwards called Shardlabs that did basically a bunch of LSD stuff, DFI related and so on, and most recently basically be building tooling, getting from the starknet. And out of that came Nimbora, which will be the topic today. So let's talk about how Webtree works. We all know when we go to some website to use some service, well what happens is we click and it works, it automatically works. And what happens with Webtree is we go to a website, then we connect with a wallet. Maybe we have to change an RPC because it's wrong network, then some stuff, break stuff is not the best.
00:01:21.766 - 00:02:01.778, Speaker A: But when we compare, like the user experience, it's much worse than web three. But still, when we think about it, web two is not synchronous, it's asynchronous. We have a lot of requests on servers, different services and stuff working in the background. But for the user it feels like a synchronous experience. When we think about modular versus monolithic architectures in general, roll ups, shards or whatever, we have two approaches. One is obviously Solana, which is monolithic. So you try to run as big hardware, as big hardware as possible with optimizing everything and stuff like that, that can scale to a point.
00:02:01.778 - 00:02:43.690, Speaker A: There are some limitations like speed of light for propagating information and how much hardware can process. And we have the other approach, which is more Ethereum approach, which is this kind of main chain, which is Ethereum Mainet, and these roll ups basically, which is kind of coprocessors of ethereum that are scaling it. What's the disadvantage with the second approach is you have broken compatibility, basically liquidity is sharded or broken across multiple chains, user experience is broken across multiple chains and so on. So what's the solution? It's quite simple actually. We build a synchronous user experience for the end user in a synchronous world. Some call it chain abstraction. It's kind of magic.
00:02:43.690 - 00:03:06.822, Speaker A: It sounds easy and so on. Well, is it? Let's deep dive. How do we do it? So I want to first introduce you. Like the Bora, the Penguin guardian of the seamless interactions. It's the idea that users should not be explained. All the complexities, how the blockchains work, what wallets are, all the things basically we are trying to push on them. But we should make it simple.
00:03:06.822 - 00:03:26.990, Speaker A: It should be kind of one click experience like you have in web two. Who here used one click checkout in web two? Anytime, like you go to a website, you click on a link and basically you just check out. So you know how it feels. It's like you just click. And that's the magic in web three. You click a button, then you wait for a transaction. Maybe you get Reorg or this and that.
00:03:26.990 - 00:04:05.782, Speaker A: But we have to abstract that if you want to do this. So what Nimbora actually is, is capital efficient l one, l two cross protocol interactions. So imagine a protocol on Mainet that can have user deposits, redeems and external kind of execution on l two s. So this way you can kind of give them the same experience of DfI on l one while they interact. On l two, it's kind of what's the purpose of roll ups, isn't it? The other basic one is ultra efficient, obviously crushing yield strategies. This is more specific, what we can do with this. So imagine you are on Starknet or Zk sync or polygon, ZKvm, and you want to stake with lido or earn some yields on Mainet.
00:04:05.782 - 00:04:53.866, Speaker A: How do you do it? You have to bridge from that chain to Mainet, wait six to 8 hours for the bridge to finalize. Then you have to go to the protocol stake with it, pay $40 in gas if you are lucky, and then you get the assets and maybe bridge back. Well, what if we could automate all of this and do it with your friends? Because if the cost on Mainet is $40, and let's say we have five people, five friends, or five users that want to use this in, let's say, a time frame of 24 hours, well, we can do $40 divided by five, and everybody pays basically just partial as a fee. And this way we improve the user experience. This kind of is called d five pooling. So why we went with Sarkin first is because it's powered by native account obstruction. That means that you don't have any eoas there.
00:04:53.866 - 00:05:31.510, Speaker A: And so on the issue with EOAS obviously is, it's kind of a pseudo permission in Linux, so you basically can do anything with it and so on. And with account obstruction, it's kind of smart accounts, it's more granular, you can do whatever with it and you protect the users from using pseudo all the time. And this way what we did is user comes to stark and ZK sync or some other l two deposits assets from their wallet, which is account obstruction based, which can feel like web two. They don't need to pay the gas fees because you can use Paymaster. They know, don't need to know when this will get executed to l one and so on. They only need to know their local kind of thing. It's one click for them.
00:05:31.510 - 00:06:15.934, Speaker A: So even if they don't have the assets that they want to deposit and earn from, you can swap for them in the background and so on. And obviously that's called one click DFi, swap, deposit, turn all in one click and you can chain as much as you want. How does it actually work? Well, there is a bit of stuff going on in the background, so let's go through it quickly. So as we can see, there's a couple of strategies. We have l two part and then we have at the bottom we have l one part. L one part is just like simple strategies like stake with Lido, deposit I into spark to earn SDI or do like delta neutral leverage or something like that. Then we have obviously the bridge in between, which in this case, in case a starknet is starknet canonical bridge.
00:06:15.934 - 00:06:48.030, Speaker A: We only use canonical bridges because the security of the roll up depends on the security of the bridge and vice versa. Basically the roll up is as secure as a bridge that basically is canonical on it. And basically we use native messaging to transfer messages from l one to l two and back. And then on l two we have this vault based system where we aggregate user deposits and redeems. So let's say there are a couple of us that want to stake with lido. I have one eat, I put it in the vault, you have like two eat, the other guy has three. So basically all that combined is six eat.
00:06:48.030 - 00:07:19.734, Speaker A: And somebody wants to kind of get back his three eat because he earned enough. It's a bull market, it went to moon, so he doesn't care anymore. Well, the only thing we need to do is we match the six e to three. So we have six plus eat, minus three eat. So we have only delta of plus three eat. Now we have to bridge shuttle to l one deposit with lido and get reptileed back, in this case, hail with any transaction. We managed to do this so we can add new strategies, new options and 60 lines of code in solidity, which will be decreased even less in the future.
00:07:19.734 - 00:08:05.430, Speaker A: But if this is not clear to you because it's too complex, don't worry, border, the penguin is here. So for the user it's quite simple. When we look from the user perspective, what the user has to know, what is the user intent? User wants to come to the platform, he has some assets and he wants to earn money on top. In this case, user wants to be exposed to reptest Eid, basically lido staking. And let's say the user doesn't have EId because that's what you need to deposit. Well, we can swap, let's say he's a Wi Fi, basically maxi, we can swap Wi Fi to eat and then deposit into vault eat, and he gets the LP token so he can start earning immediately the fees on top. And for the user it's one click, he doesn't have to do approve and then deposit or swap first.
00:08:05.430 - 00:08:36.894, Speaker A: So basically he would need to do four transactions usually, and now he can do only one. And that's kind of a magic of this, multi calls and one click defi and so on. And for withdrawals is basically the same. But the key caveat here is when you bridge to l one, it takes six to 8 hours. On starknet it takes 30 minutes, on polygon it takes like 24 hours of zk and sync. When you bridge from l one to l two, any of this, it's kind of a matter of minutes. So how do we kind of say to the user, okay, we can give you instant kind of this deposit back, but you have to pay more.
00:08:36.894 - 00:09:20.346, Speaker A: You can do that through liquidity bridges or swapping locally, but if you are not in a rush, you can do it normally. So normal mode operations, when you want to withdraw from the protocol is maximum every 24 hours, usually less. And when you want to do it instantly, because I don't know, you want to take this money, do something with it, you can do it in a matter of minutes. So this way we have best of both worlds. On one side we have like d five pooling, which decreases the cost per user, so users are not exposed to l one kind of gas fees and everything. And on the other hand, you have like a normal crosschains app which gives you the instant experience as fast as possible, but obviously for a fee. So what's next for us? Well, the idea is quite simple, but quite magic.
00:09:20.346 - 00:09:53.754, Speaker A: Any chain, any wallet, any asset, it has to be seamless and one click integrations. Is it d five protocols? Is it buying nfts on other chains? Is it something else? It has to be simple as that. We can scale, obviously, any l one strategy and yields to l two s and vice versa. So potentially, if you are on like, let's say, starknet, you can earn arbitrary yields. If you are on arbitrary, more optimism, you can earn starknet yields and vice versa. Or even l one yields. And then the most interesting part, in my opinion, is we can build novel protocols that have part of a logic and execution on l one and part of l two s.
00:09:53.754 - 00:10:53.600, Speaker A: And this way you kind of can get the best of both worlds, l one, liquidity, composability and so on, and then cheaper transactions at a scale of l two s. And obviously we have an SDK for developers, so they can use this l one, l two, all the asynchronicity basically abstracted from them. So with real layers and vaults, it's kind of integrated and you don't need to think about it. We actually run a hackathon and there were like four different strategies built on top easily, like in a matter of week, which kind of proves this kind of is feasible. It's really interesting to users. So this was a short intro on this, so if you're interested, join our discord, and I'm open for questions if you have some. Thank you.
