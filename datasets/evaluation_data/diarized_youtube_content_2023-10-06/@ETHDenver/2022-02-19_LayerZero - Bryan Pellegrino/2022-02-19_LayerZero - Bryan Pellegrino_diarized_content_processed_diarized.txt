00:00:00.330 - 00:00:41.610, Speaker A: Hey, everybody. Brian Pellegrino from Layer zero. They didn't really give me a topic to talk about today, so I don't have slides or anything else. And I thought rather than giving, like, a generalized pitch, which I've done a thousand times, and you guys can just find online, I would rather spend time talking about what I think are kind of the biggest issues of people building when they're building anything, cross chain or multi chain. So if you guys don't know what zero is, omnichan interoperability protocol. So just working on seamless cross chain, I guess, just to judge the audience. Can I just see a quick show of hands of people who are actually building something? As in, like, deployed a smart contract, part of a project, et cetera.
00:00:41.610 - 00:01:08.866, Speaker A: All right. Like 15%, 20%, something like that, which seems fair. Okay, so I think a couple of things, some obvious, some not so obvious. The first thing that I think is pretty obvious is when people are building right now, like, almost any cross chain solution looks something like this. You have these two chains that are atomic in state. They don't know anything about the rest of the world. They only know everything about themselves.
00:01:08.866 - 00:01:49.914, Speaker A: They need to communicate. And kind of like, the broad solution is somebody's going to throw their own chain or consensus mechanism that sits in the middle. You'll write a transaction from the source over here. This thing in the middle will somehow come to consensus as the validity of that transaction, and then it will write a transaction out. Obvious issue with that is if that consensus mechanism that lives in the middle breaks, it typically has the ability to just arbitrarily write messages to every application on every chain. So you have this entire pool of systemic risk. You saw this with Polynetwork hack and a bunch of the other hacks where the hacker basically made himself the only validator in the network was able to tell all the applications living on the destination chain.
00:01:49.914 - 00:02:47.342, Speaker A: Like, hey, I definitely put $680,000,000 over there. Like, give me $680,000,000 over there. And it has this really kind of broken incentive structure where maybe this structure in the middle, maybe it secures like, $5 billion, but then uniswap opts in, and now it secures $20 billion, and then ave opts in, and now it secures $50 billion. And every new participant opting into that system is making it significantly less secure for every other participant in the system, unless the bond of that one system is growing, like, nonlinearly relative to what's being added, which has just never been the case. So I think one is that structure in that everything lives in one central system of risk. And I think the other thing that I personally think is not thought enough about right now is the fact that everybody in every system right now subscribes to the same set of hyperparameters. So, an example of this is take two very different use cases.
00:02:47.342 - 00:03:46.674, Speaker A: So the first use case is like, you're going to verify on chain B that you own like a copper sword in a game. On chain A, it's not something that maybe needs that high of security and use case number two is you're going to transfer $500 million across chain on chain. These are just very two broadly different actions that are being done here, and yet they both need to opt into the exact same set of security properties. So this can be whether they bypass an optimistic roll up or don't bypass an optimistic roll up. This can be whether you're going to wait five blocks, 35 blocks, or 100 blocks when coming from a source chain against Reorg, a bunch of different things that go into this. But I think it matters what the application is doing, and I think it's really important that in time, all of those decisions move up the stack and live at the application layer. I don't think it's going to make sense long term, for every application, again, to just be like, for the construct that sits in the middle, to set the hyperparameters and everybody opt in or not to that.
00:03:46.674 - 00:04:37.646, Speaker A: I think that's typically going to cause huge fragmentation in terms of what types of applications can subscribe to these different systems. And it forces people to kind of shy to one side or the other. They need to do something that's more secure than what they need or something that's much more worth less secure than what they need. But it's like the only viable solution. And so I think when the way we're framing these problems and the way that we think about these things is really a way to, again, take that decision making away from actually the protocol layer and move it up to the application layer and make something that's more modular. Whether this is consensus mechanism that uses more nodes, less nodes, whether this is right now, we have a huge number of basically consensus mechanisms that do this. Some are fraud proof systems, some are sets of validators.
00:04:37.646 - 00:05:18.100, Speaker A: Some are subsets of validators within Solana or tendermint or whatever that might be. And again, each of these may be appropriate for single applications or a couple, like small groups of applications, but not necessarily appropriate for everything. So I think modularity of choice is something that's hugely important and not at all being discussed right now. And again, I'm happy to sort of dive in later. I didn't want to spend the time just kind of chilling what we're doing, but more talking about the space more broadly. I'm happy to talk about how we are addressing that or how we're thinking about that. But I think it's important to frame the problems differently and to frame the way that applications or contracts are starting to interact with these things.
00:05:18.100 - 00:06:33.580, Speaker A: The other thing, which has definitely changed since, but prior to us kind of talking about our initial approach, I think everybody was strictly focused on value transfer. Like any bridge that you looked at, any communication system you looked at, with the exception of maybe IBC, was strictly value transfer. And I think we really moved that more towards like, hey, value transfer is just a subset of generic messaging. Why do we care about value transfer as a thing? Make a system that's good for all generic messaging systems? And that can be whether this is unified governance across a bunch of chains and casting votes, whether this is the process of just like state synchronization or running a cron, or sharing state, or synchronizing state across a bunch of apps across a bunch of chains, there's a bunch of things that are not strictly value transfer. And I think broadly, the space has moved in that direction where a lot more people are thinking about messaging, a lot more people are thinking about generic primitives as opposed to just this one thing of value transfer. But yeah, I think in general, those are the three things that I think about that are different than the way that most people are thinking about it right now. So I can kind of go into anything from there.
00:06:33.580 - 00:07:50.898, Speaker A: I prefer a Q and a style question. I always mention on any panel, I ask the moderator to be as controversial as possible. So very much value adversarial lines of reasoning. If anybody has questions or wants to start talking about this, I'd like to field anything, and then we can go from there and I'll talk about it. Michael? Yeah, so the question is, chains like Chia have extremely complicated block headers. Like, how do you basically deal with interactions between chains who maybe have different block constructs? I think there's a couple different ways. So the question really comes down to what does a validation mechanism look like? Are you actually taking this header from Chia and needing to validate it in solidity on the EVM? That's one totally different thing where you need to actually take and do this validation of proofing mechanism that's a bunch of things where this is figuring out how to do slice of proof of history and validate on the EVM, or where this is figuring out how to just take an MPT and walk it on another chain.
00:07:50.898 - 00:08:23.460, Speaker A: But then there's obviously like you can pare that down and you could be passing potentially like payloads directly. It really depends on what the validation mechanism looks like in the middle. And I think that itself is one of the more interesting questions in like, okay, getting communication is fine once you're just passing this payload. But the whole problem is how does the validation happen? And people are addressing this with ZK. There's a huge field of research and how that is. So I don't think it necessarily has to matter. Right.
00:08:23.460 - 00:09:08.750, Speaker A: You have this problem of nonlinear growth where let's say you are validating an MPT directly on another chain and you're validating like a Solana proof of history on ethereum or on an EVM system. And then you go to tendermint and then you go to substrate, and then you go to Chia and you go to all these other systems. And on every new proofing mechanism that gets introduced, you have to grow that to every other chain. And so there's like a prospect of potentially taking locally, basically doing the translation there and basically having a universal proofing mechanism. But I even think that is way too complex and probably not needed. It's more just being able to validate the payload itself. And again, it's just this coordination problem.
00:09:08.750 - 00:09:31.080, Speaker A: So I don't think there's a clear answer to it yet. But I do think it's a very interesting question. Anybody else? If somebody has one. If not, I'll just go back to talking about general stuff. All right. If somebody has one, just like flag me down and talk about it. Okay, I'll talk a little bit about what we do.
00:09:31.080 - 00:10:16.926, Speaker A: So again, I kind of describe prod systems are like this middle chain, system, chain here, chain here. People are going to throw their own consensus mechanism in the middle, and that controls everything. That's like the entire validation. And if that breaks, everything breaks. So it's your classic hub and spoke model, where if the consensus mechanism of the hub is broken, like all the spokes are totally wrecked, which is obviously a concern. Right? It's fine now if you're securing a couple hundred million dollars, but when you're talking hundreds of billions of dollars, it needs to be thought through a lot more. Then you have Cosmos, IBC, which is like the total opposite, where you're going to take the complete block history of one chain, you're going to take every one of its block headers and write them sequentially to the other chain and vice versa.
00:10:16.926 - 00:11:07.486, Speaker A: So you're just going to maintain an on chain lite client of each opposing chain directly. And then when you have that, and assuming nobody has misproven any of the blocks that are being stacked in these block headers, then you can just arbitrarily validate a transaction and do the validation directly on chain, which is like amazing. And you would definitely want to do if rights were free, but rights are incredibly expensive on blockchain, so you're like $50 to $100 million per day per chain. You tied pairwise to Ethereum in that manner. So it's just not really a viable solution in the current state. So the approach that we took was a couple of different things. One was we invented this thing called an ultra light node, which is effectively the process of, rather than taking and validating every single block, even if you only care about like two of them, you stream blocks on demand and do ad hoc validation.
00:11:07.486 - 00:11:32.758, Speaker A: But you still have this problem of you have these two chains and they don't know anything about each other and they can't know anything about each other. So you still need to pass that state from one chain to another. System like IBC do this with sets of validators submitting block headers. We basically break this up into two parties. We call them oracles and relayers. But it's a little bit of a misnomer. An oracle is any system that takes a block header and submits to the destination chain.
00:11:32.758 - 00:12:22.762, Speaker A: And a relayer is any system that takes a transaction proof and submits to the destination chain. And those can look like anything, right? So you have bridges today that are like single SGX servers, you have bridges today that are like very small sets of validators. You have bridges today who do a ton of different things. And so this could look as simple as individual servers where an application wants to own that themselves, or as complex as like the complete set of Solana validators acting as the oracle on one side and the complete set of tendermint validators acting as the relayer on the other side. So those can be as distributed as you want or need them to be. But I think the most important thing of an architecture that shifts in that direction is that choice lives at the application layer. So each application opts in to exactly what Oracle they want and exactly what relayer they want.
00:12:22.762 - 00:13:20.798, Speaker A: And while that may not seem that important early on, what it means is that if an application runs their own relayer, even if 100% of the other participants in the network are completely malicious, there is nothing that anybody can do to infect the security of that application unless it's colluding with the person passing the blockheader. So the oracle in this case against themselves, so they're colluding with them against themselves. That's the only way that they will ever have any ability to basically affect their own messaging. And so I think giving that choice at the application layer, what it does is it gives you the ability to either externalize or internalize this risk. For most applications building, they just don't care. They're very content to have Chainlink as their oracle and Coinbase as their relayer, and that's a valid option for them. They're like, okay, I can accept the choice that both Chainlink and Coinbase are not going to be malicious at the same time and colluding and acting against me, and I'm willing to price that risk at X and I'm willing to sort of externalize that.
00:13:20.798 - 00:14:28.286, Speaker A: But then your ave or whoever, some huge application coming in with tons of liquidity, then maybe that's not an acceptable outcome, right? And so then maybe applications who do care, they have the ability to just run one piece of this construct and have complete control over their own security. And what it does is that it creates all of this risk where before we had this kind of central pool of systemic risk, that consensus mechanism breaks, everything's gone, and now you have very narrow shards of application specific risks. So you have some big oracle and they somehow go rogue and they're in collusion with relayer A. Well, only applications accepting messages from exactly that oracle and relayer a get affected at all this very narrow band of risks. So anybody using relayers B through z, anybody relaying their own transactions, anybody using any other oracle, completely unaffected. So you've also at the same time, whereas before, let's say an oracle controlled everything, if that oracle breaks, everything's gone. If this methodology basically makes it so, the cost of attack on that oracle goes up instead of winning everything, the cost to attack it still remains the same, but the payoff is drastically reduced.
00:14:28.286 - 00:15:07.822, Speaker A: So rather than winning everything, you're now winning one 30th or one 300th of total system risk. So it increases the cost of the attack, the effective cost of the attack on an oracle exponentially. It's just like an extremely attractive property to have when you're talking about these sort of validation systems. It makes it so that this bonding mechanism or whatever mechanism your oracle structure we're talking about now uses is much more capital efficient when risk is sharded heavily as opposed to centralized. Okay, they told me I was like super up against the time. So how are we doing for five more minutes on that? I will ask if there are any questions. And again, adversarial lines of reasoning.
00:15:07.822 - 00:15:49.706, Speaker A: Very welcome. None. All right. Okay. Yeah, I think that's one thing that is super interesting. And again, I think you will see a very strong move away from these sort of like central pools of systemic risk because we've seen time and time and time again, whether it's the billions of dollars in hacks or whether it's the fact that none of these systems have more value bonded than they're securing, that it's just like not a reasonable way to approach the problem and it's too capital inefficient to do so that way. So I think you will definitely see things move in that direction.
00:15:49.706 - 00:16:30.906, Speaker A: I think you will see application choice move up the stack heavily. Again, where each application, rather than having, I don't know, bridge A, you have this grid, and bridge a lives here on the trade off of cost and security, and bridge B lives here, and bridge C lives here. You're going to have this Pareto frontier where you can effectively assign your own properties in each application. They're obviously priced accordingly. Right. And you're just paying, you're paying for some measure of risk. And the way that the Ethereum network is very willing to pay for high security and other chains are like, whether willing or not, they're paying less for that security, right.
00:16:30.906 - 00:17:33.020, Speaker A: And so you give application the choice of like, what does this cost? What is the operation that you're trying to accomplish and what are you willing to pay for that risk, and what is the downside risk of that? And so I think, again, moving choice to the application layer is going to play a huge role in defining a system that's modular enough to stand the test of time. And again, I think the highest order goal, at least the highest order goal for us at layer zero is like connect every contract on every chain. That's purely what we're trying to do is just seamless messaging between these. But there's a lot of nuance in what does that actually look like? Because it's easy to say like, oh, you'll have this seamless messaging and that's great, but there's a lot of properties that go into that and sort of like that. Each application either manages or adopts and oftentimes they don't know what they're adopting, and oftentimes they're forced to adopt things that they don't want to. So creating a system that puts control of application layer, I think, is one of our highest order goals. All right, I don't think I have time to run through a full rant on anything else, so I will stop there for the moment.
