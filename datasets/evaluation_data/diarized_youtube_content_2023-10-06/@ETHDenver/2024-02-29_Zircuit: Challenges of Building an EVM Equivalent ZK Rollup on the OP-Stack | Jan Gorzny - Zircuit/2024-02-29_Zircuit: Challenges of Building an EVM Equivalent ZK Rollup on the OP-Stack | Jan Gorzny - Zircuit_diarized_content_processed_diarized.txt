00:01:21.490 - 00:01:34.358, Speaker A: Hello everyone. Presenting this topic is for Zirkit challenges of building an EVM equivalent ZK roll up on the op stack. This is John Gorsny. He's the technical lead for Zirkit. Here you go.
00:01:34.444 - 00:01:55.150, Speaker B: Great. Hi, thanks for the intro. Happy to be here at Eat Denver for my second talk. Maybe you have seen something similar earlier in the week here. Maybe you've seen something similar at Devconnect in Istanbul. Maybe this is all new. Either way, I hope you enjoy it, and I hope you see the at least slight changes that have gone on between previous iterations and this one.
00:01:55.150 - 00:02:41.306, Speaker B: As mentioned, my name is Jan Gorsny. I am a tech lead and co founder at Zirkit, and I'm here to talk to you about what we were doing without saying so much what the end result is. There will be some of that, but really some of the challenges we experienced when we were building this thing which started off on the op stack, which I'll talk about a little bit. Obviously the whole talk won't be about op or anything like that, but it is important to have a good understanding. So before I get going, I realize that the more often I give this talk, the less likely this slide is necessary. But the next slide will introduce zero knowledge roll ups. And I think it's really important to understand both of the systems at the same time, because the essence of the talk is essentially, we're trying to put proofs where proofs don't really belong, and that's a lot of challenges.
00:02:41.306 - 00:03:32.522, Speaker B: But in order to understand where those challenges come from, you need to understand where you're putting them and what you're putting them onto. So what we're starting to put them onto as a starting point because we didn't want to reinvent the wheel, was something called the op stack, which is the code base that optimism currently has for their optimistic roll up. So what is an optimistic roll up? You've seen the last talk. You probably have a rough idea, but essentially it's a layer two network where you have a sequencer. A sequencer produces some blocks, it does some stuff that gets us a nice state output, proposes a state, submits it to the layer one. And if no one says, hey, that's a bad state route, everyone sort of says, yes, that's a good state route, and let's keep going. If someone does say, oh, that's a bad state route, then there are people in the system who are, at least in principle, can come and say, don't use that state route.
00:03:32.522 - 00:03:56.646, Speaker B: That's not valid. Here's some evidence or fraud proof that suggests, actually, that's not a very good state route. And some things will happen. There'll be some reorgs or reversions out of that, and essentially, at the end of the day, you'll get a nice consistency. So essentially, there's this long period of time that says challenge or not challenge, a state route. And otherwise, if no one challenges, we're all good. And that's nice.
00:03:56.646 - 00:04:25.934, Speaker B: It's a very nice system. It's got a good design. The little downside, though, is that you got to wait this long period of time. And so we were looking at this and we thought, well, maybe we can do better for sure. Certainly we're not the only ones to think of this, but what happens if we wanted to take this challenger and this fraud proof system out of this otherwise pretty decent piece of software and put in a zero knowledge proof system? Because we had heard over and over again that the op stack is so modular and it's just ready to do all these things. And we said, well, let's try it. Let's see what will happen.
00:04:25.934 - 00:04:51.910, Speaker B: And what we ended up wanting to build was something that's a zero knowledge roll up. It's pretty straightforward. You've probably seen descriptions of these elsewhere. If not, I'll go over very quickly. But what we want to do is essentially take out that challenger from the last slide and put in this thing called approver. So instead of generating blocks and putting a state route on chain and saying, challenge me if I'm wrong, we're going to say, here it is. And also here's a proof that says this is absolutely correct.
00:04:51.910 - 00:05:19.830, Speaker B: Right. And the idea is to be sure that something is correct as soon as it hits the l one. So if it's not reorged out, you actually have mathematical certainty that no one cheated you. Everything has gone right, and as a result, you don't need to wait a very long period of time. You have a much smaller finality period, whatever that means. I won't go into too many details, and you get this really nice other alternative to an optimistic roll up. And so what we wanted to do was go from this to this on the op stacks.
00:05:19.830 - 00:05:44.162, Speaker B: And what we really wanted to do was do this without necessarily sacrificing and without reinventing all of the risks. So what we did was we did this. It's still ongoing. It's in testnet. I'll talk to you more about that at the end. But essentially we built this thing, and it's called zirkit. And essentially, it's a battle tested combination of all the best stuff that's out there without sacrificing all the compatibility or concerns that developers would have on a zero knowledge rollout.
00:05:44.162 - 00:06:32.918, Speaker B: So in particular, we're going to use all the great tech that other people have built, customize it, make it better, improve it, do all of our cool custom tricks, but then also make sure it's a nice seamless development experience for the end developer and for the users. So we wanted to come up with something that doesn't necessarily make it easier because we've cut corners or because we've traded off the familiar tooling everyone is currently using or on board with. So the end result is Zirket. It's Xernal's rollout that is EVM compatible. And I'll tell you now about how we got to where we got, and in particular how the op stack played a part in this. Essentially, we had been looking at the stack and some other things and doing a whole bunch of research, and we thought there's some really cool ideas out there. There's techniques that people are trying, there's other techniques people aren't trying.
00:06:32.918 - 00:07:18.370, Speaker B: There are approaches that we wanted to try and not necessarily able to convince other people to try it, or we thought it was a really good idea, so we wanted to play around with it. We were doing all this research that why don't we just try to build one of these things? And we did, and then we sort of looked around at what the ecosystem sort of seems to be needing or wanting, maybe. And that was a little bit more of a focus on security, because we honestly believe that security can go a little bit more than just a well engineered product. Right. We can do more to protect users on the system than just be bug free. Obviously, we do want to be bug free, and that's something we're striving for and all of that. But maybe, especially while these systems are centralized or while they're growing, we can do more to protect the users that build on the chain.
00:07:18.370 - 00:08:08.630, Speaker B: And so this is the ideas we sort of combined. And the end result is Zirkit, which is starting off on the op stack building, not necessarily, and definitely not actually on the superchain, but still using the core infrastructure pieces. Okay, so let's go into a little bit more technical about the challenges and the sort of non reinventing the wheel attitude that we had. We did also have a bunch of customizations, which I'll talk to you about. But like I said, there's no point in doing things that's already been done. So we took a look around and we said, okay, what is a zero knowledge roll up? Well, we need some infrastructure and we need some zero knowledge proofs, and we need to be able to glue these together. And so we looked towards the optimism side of things for the infrastructure, because they had a pretty clean code base, it was pretty interesting, they were doing good development, it's all open, it's a very good license, and we get some things very easily and they work reasonably well.
00:08:08.630 - 00:08:58.358, Speaker B: Things like a sequencer, which you need to order transactions, things like batchers and data availability solutions, which you need, not necessarily the ones you need for a zero knowledge rollup, but still something that you need to get started. In addition, you get smart contracts and the forks of geth that you need, which are really nice. I'll talk to you about some of the struggles. But then we also needed a zero knowledge proof system. And while I've got a PhD, and I love doing this by hand, if other people have done some work, we should be inspired and take advantage of it. So we looked around, and people like PSE and others who are open source had nice implementations of particular components or particular parts, but not necessarily the whole picture, or not necessarily the whole optimized picture. So you might look at a particular set of open source circuits for a set of opcodes, and it might be pretty practical and might work, but it might not be the best prover generation time, or it might not be supporting the features that you want or anything like this.
00:08:58.358 - 00:09:30.186, Speaker B: And so we started on these things, but we just certainly didn't finish there. And the rest of the talk is in part to convince you that actually it's not as simple as just forking two repos and saying, we're going to work together. Now, when we're done, we have a zero knowledge rule up. In fact, there's a ton of other work. The ton of work comes on these main areas of challenge. First, the node infrastructure that we get from optimism is not necessarily the one that's ready for primetime. It has a lot of really cool stuff, but it also does some stuff that optimism has decided to do for either good reasons or bad reasons, and isn't necessarily equipped for ZK primetime.
00:09:30.186 - 00:10:00.058, Speaker B: So we'll talk a little bit more. But some of the high level things are things called system transactions. If you look at an optimism block, every block has a system transaction that updates the time of the l one, some gas prices, some other things, and injects it into the l two block so that the l two state can be updated. This is a pretty nice solution there, but when you're in a zero knowledge system, that means you're now proving a bunch of transactions that are effectively just doing things to update your internal state. Can we do better? Can we do differently? The answer may be no. The answer may be yes. Something that we're going to explore and something we're working on.
00:10:00.058 - 00:10:27.850, Speaker B: Certainly we don't necessarily have to follow there exactly. Other things are also great and helpful. The batcher and the DA. You need that every roll up should be publishing data somewhere, but they're not built for zero knowledge roll ups. Your rollups might want to publish data in a way that's more ZK friendly, not the way the optimistic things do. And then we'll talk a little bit more about Geth and some smart contracts later. On the proof side, you have things that are, like I said, existing but not necessarily optimized.
00:10:27.850 - 00:10:49.686, Speaker B: You have individual circuits, but no way to aggregate them. So you might be able to prove them, but maybe not on the hardware you want. So you have to get in there and really change how these things are aggregated or built together, or composed or otherwise engineered in order to make them work. And things like the verifier really want to be optimized so that you do it very quick. And then of course there's a whole bunch of other things. A sequencer and set of ZK circuits is not a roll up. A roll up is much more than that.
00:10:49.686 - 00:11:09.594, Speaker B: It's a whole functioning network. And there's a whole bunch of things that are going on behind the scenes for all of these roll ups that people just generally don't talk about. You need prover pipeline. So unless you have an open place proof marketplace, you need to build that. You need front ends, you need back end support, and a bunch of things. You need documentation and you need testing. One of the things we found was certainly testing is lacking in a lot of these areas.
00:11:09.594 - 00:11:49.374, Speaker B: And then even if they're not, getting them to work on two different stacks is a real pain. So there's a whole bunch of things that you need to do to get from just what's out there to something that you can be proud of on your rollup, because you can't just glue them together and expect it to work. So we'll dive into some of those right now, and as the title says, we're going to talk about the op stack, so I'll pick on them a bit. But honestly, it is a very good starting point and shout out to the team there are doing great stuff. But essentially the main problem with the op infrastructure, although it's open and very nice, is that it's not ready for ZK prime. It is very good at a bunch of other things, namely optimistic roll ups, but not necessarily for ZK. So there's a couple of reasons for this.
00:11:49.374 - 00:12:36.298, Speaker B: I've already talked a little bit about this notion of system level transactions, where you have transactions injected into every layer two block, which now suddenly you have to prove. If things are expensive to prove on zero knowledge systems, you certainly don't want to be doing extra if you don't have to. So a block every 2 seconds, which is what optimism does with a system transaction in every one of those can start adding up. It's not necessarily going to be the biggest cost in your system, but you start thinking, why do they do this? And can you do better? And these are the questions that this project really started to sort of question and try to answer differently. Other things of course, are built without ZK in mind, because they're not a ZK roll up. The batchers don't talk to the verifiers in terms of the data being posted. And is it the right inputs to your circuit? Because if something goes wrong on an optimistic roll up, someone just gets slashed.
00:12:36.298 - 00:12:57.966, Speaker B: You can point the finger and say, that guy didn't do it right. Here is why. Uhoh. Bad. On a zero knowledge system, you actually need these components to talk to each other. So you need to build this engineering or, sorry, engineer this component to make these systems talk to each other in a way that doesn't introduce extra trust and other areas of change. Some of it are engineering and some of it are just different designs.
00:12:57.966 - 00:13:41.406, Speaker B: But some things, like the smart contracts, they're pretty good. The bridge is pretty solid, but the verifier, the logic is very embedded on the fraud proof system or the timeouts into the bridging, not so clean for when you're putting in a zero knowledge proof system. And then there's other things that really sound like a really good idea on paper, like embedding guess dependencies everywhere so that you look like Geth, you act like Geth, you look like the layer one. That sounds really, really good. But then you look at zero knowledge systems and you say, actually what I really want in my geth is not SHA 256 for hashes, because that's expensive. I want to switch it to Poseidon, but only in some areas, because maybe I need to interpret l one blocks with Shaw 256. But write l two blocks with Poseidon, and if that dependency is too tightly coupled, it's going to get very difficult.
00:13:41.406 - 00:14:14.566, Speaker B: Turns out that's at least partially the case, and it's kind of a pain to disentangle that. So there's a whole bunch of things that need to change. On the engineering side, other things, again, not meant for ZK deposit transactions, are the transactions that bring assets from l one, namely ethereum, onto the l two. And in optimism, if you cheat, someone points the finger, you get slashed. That's bad, but that's how the system works. Like bad in the sense that you're not supposed to be doing that, but the system works like that, and it's totally fine. On a zero knowledge system, you can't just invent money out of nowhere.
00:14:14.566 - 00:14:54.470, Speaker B: You need to have a mathematical proof or some other way of checking with DL one that actually this happened because no one can point the finger and effectively take any action with you. Obviously, if someone did that, you could go on their twitter and say, hey, don't do that. But the system would have already gotten away with the action and there's no technical limitations unless there's a social consensus to fix it. So we have to add all of this functionality onto the optimism stack. We have to do things like make sure that the inboxes and outboxes of deposits and corresponding withdrawals. Also understand that extra data needs to come from extra places and extra things need to be changed, and they have to tie all together. So this adds some work, this adds some overhead.
00:14:54.470 - 00:15:21.106, Speaker B: Not necessarily a decade's worth of work, but it's definitely non trivial. The smart contracts, again, these are part of the systems that will need to be changed. They're some of the most important. They're pretty good, but again, not necessarily ready for ZK. They're not necessarily as modular as you want. If you look at how you do withdrawals and optimism, it's a two stage withdrawal where you prove an inclusion and then you finalize it. Or vice, you know, that's nice, but actually you don't need that in a ZK roll up.
00:15:21.106 - 00:15:38.614, Speaker B: You can change it. Despite that, the op stack has built it right into the sort of standard way of doing things. I can't blame them. That's what their system is going to do. But it's not necessarily what ZK people would want. Some of these points are getting a little bit less relevant containing legacy code. They've actually done a lot to clean up that code base.
00:15:38.614 - 00:16:18.494, Speaker B: It's been very good, but there is still a lot of references to sort of v zero, or at least there used to be, where a lot of the contracts are based on the initial deployment of the op stack, which has since been migrated to newer versions. So some of this you can ignore very easily. Some of this you want to engineer out because you want your attack surface to always be as small as possible. And again, this onboarding and offboarding is also missing. So I'm going to try to catch up with my proposed time here and go a little quicker. But beyond the op stack, once you get all the op stack parts in the way that you want them, and you sort of get your optimistic stack in a row, you then have to bring in zero knowledge proofs. And this becomes challenging for another reasons.
00:16:18.494 - 00:17:02.660, Speaker B: There's no one out there, as far as we know, that has a nice open source representation of things that just automatically works out of the box with the op stack. So you have to do things differently, right? If you're using circuits that someone built, they may not be using the same version of the geth. There might not be opcodes that are fully supported. Optimism does a really good job of keeping up with the latest geth updates. Other people building circuits may not necessarily be doing that. So you also have to pay a special attention to yourself to make sure that this happens and it does work. And even if you get all the opcodes you want, as I've mentioned, aggregating things, putting these pieces together, super challenging, super interesting because you can do it in very different ways in order to a, differentiate yourself, but b just perform better or have your requirements met.
00:17:02.660 - 00:17:45.450, Speaker B: I'll pick onto the system transactions one last time here. This is one of the things where the provers actually have a really hard time because you have a system transaction that is a transaction that the system itself is trying to do to itself just to update state in some nice way, but you don't want people paying for that because it's a system update. It's like the op stack telling the op stack, here's the time on l one. That's not something users should be paying for. So you say, okay, I don't charge people for that, or I don't check a signature for that. Either it's free or I'm just going to ignore this. But how do you do that in a circuit? Well, you still have to make one of those changes or find another solution, in which case your circuits now start to look less and less like the EVM you wanted to build at the beginning.
00:17:45.450 - 00:18:15.154, Speaker B: Or you add more and more overhead to sort of skirt this problem. So there's actually a lot of challenges. And these might not be unique to the op stack, and they may not be something we can totally remove in circuit, but it would be really great if we could at least explore different design spaces and maybe be able to reduce the frequency or do it in another unique way. Of course, as I said, sequencers and circuits do not a roll up make prover. Pipelines don't exist. So even if you do have a nice set of circuits, and you do have a nice op stack node, getting them talk to each other takes some time. Take some data.
00:18:15.154 - 00:18:42.354, Speaker B: Provers generally need block traces, which can be fairly large, and then they need to pass this information. You need to control what blocks you're proving. If you have batch proofs, you got to do something differently than if you don't have batch proofs, et cetera, et cetera. And things like documentation and testing also need to be updated so they're consistent, so that at the very least you know what you're doing, but also so your developers know what you're doing. There's a whole bunch of other things we can do in this research space. Cryptographic improvements are always very valuable. We have some, we're going to keep doing some.
00:18:42.354 - 00:19:46.230, Speaker B: We're going to have more. I hope that the next time I give this talk, I can give this very explicit notion of what we've actually been doing for custom stuff, but it's going to range from MSM to aggregation and everything else. And then we can also do things like security. And I'll spend the last two minutes talking about security because we believe that actually one of the really cool things about having your own roll up is to be able to add security to places where you can't otherwise add security because it's not your system. And we in particular believe that if you're running a sequencer with all these special roles anyways, especially before it's decentralized, maybe you can do some good, right. What you could do is add some level of security embedded into the sequencing protocol so that your security of your DAP users isn't just based on their smart contract ability to be non reentrant or don't have bugs in it, and you can involve the sequencer to do something very unique and very cool. So for example, you could have it look at transactions in the mempool, and if something's sort of bad, whatever that means, you could put into quarantine for a little bit, and maybe it'll come back later and maybe it won't.
00:19:46.230 - 00:20:14.594, Speaker B: That's probably not for everyone, and some people might not like that, but the reality is this might save a lot of money, especially as these systems grow and evolve. So I don't know what happened with my slides there because I didn't hit the click. I still have a minute, so I don't know what's going on here, but yeah, that's most of it. I don't see the role. All right. You don't see this, right? Maybe it's the HDMI connection. And we're back.
00:20:14.594 - 00:20:30.746, Speaker B: All right, so in the last minute, sorry, guys, technical difficulties. I must have stepped on something for the roadmap. Zirka's coming along. We've been working up for a while. We are super stoked to have launched our main net, our testnet, at Devconnect, and we're hoping to go mainnet sometime later this year. But for now, check it out. Try around, play around with it.
00:20:30.746 - 00:20:55.346, Speaker B: If you have ideas for research and you want to collaborate, please let us know. If you think we've done something wrong with the op stack and there's easier ways to do something. Also let us know. Interested in all of these directions? I also would like to see what you think security on a roll up should look like, and if there's ways we can help you. So please come check it out. Otherwise, hopefully go live when it's ready. We're not going to go too fast break things, but we do want to go reasonably fast either way.
00:20:55.346 - 00:21:20.600, Speaker B: If you're building a ZK roll up on the op stack, it's not as easy as it looks. It's not just forking something and saying, put a ZK system in there. But research can overcome all of these problems and can actually, at the end of day, get you a really functional, nice roll up, and you can do some really cool stuff with it, and then you can do even more cool stuff with that. It's very unique. The result, at least the first time we've tried this is called Zirkit, and we're happy to have you part of this ecosystem. If you're interested, please reach out here, and we've got some staking things for points. Thanks.
