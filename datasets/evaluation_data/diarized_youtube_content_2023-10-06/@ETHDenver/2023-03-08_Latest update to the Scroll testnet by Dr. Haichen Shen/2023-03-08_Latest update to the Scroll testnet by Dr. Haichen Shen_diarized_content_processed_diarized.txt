00:00:01.930 - 00:01:27.282, Speaker A: From scroll today I'm going to share some of the challenges we encountered when we are building the Zkevm and the Zkrop. And I hope I will have some insight to everyone who want to learn more about scroll and then about Zkevm and how Zkrop works. Okay, so what is scroll building? So scroll is building an EVM equivalent Zkrop to scale Ethereum as a layer two. And then what does EVM equivalent means? That means it will be compatible for all of the EVM codes that has been using to execute all of the transactions on the Ethereum chain. And that means also that indicates that all of the smart contracts that now deploy on the Ethereum layer ones can be seamlessly without modifying any code you can deploy on the scroll as it's like the powerfulness of being EVM equivalent, so that developers doesn't need to rely on any like need to learn a new language or need to use some of the plugins to your compilers to compile your code to different architectures. So before I dive into any technical details, I want to first share some of the principles we believe in when we're building the ZKE, EVM and the Zkrops. So first of all, we believe that all of the blockchain projects, especially like the layer twos, should be developed through a community driven approach.
00:01:27.282 - 00:02:39.754, Speaker A: Now what does that community driven approach means? So for scroll, we are building our circuit, all open source from day one, and we are collaborating with all of our community members to contribute to the same code repo. And we have been collaborating with the privacy scaling exploration team, the PSE team from the Ethernet foundation and from the day one. And also there will be other community members here to join the whole effort to build the ZKE event together. And that means all of the code, the design has been discussed within the community and it has been peer reviewed to guarantee like there's no box and then there'll be a more secure and a better design for the community. We are also using an open source proving system called hello two that's being developed by the zcash. Besides of building with the community, we are also outreach, doing a lot of education to the public by teaching people how to use the hello two to build circuits. We're teaching some of the sessions with the Zero X Park group and then to educate people how to write hello two circuits and also being running some auditing sessions to teach about the architecture of the ZKM.
00:02:39.754 - 00:03:32.234, Speaker A: How should you build Zkemm to make it secure and to make it work. And second, we also believe that building the blockchain layer twos need to have the security first in your mind, and then have a steady release, like not rushing to become the first. I think like all of the row up and the Zkevam, there'll be like a very long run game. It doesn't mean like a first, it doesn't mean anything, I was thinking. So I think we need to guarantee the security, guarantee the reliability, so people will trust the ZK row up will work eventually. So to pay more attention to the security in the scroll, we are paying a lot of attention to the auditing. So we have the auditors to look carefully, probably like multiple auditors, and iteratively looking at our circuits, the bridge contract and other node implementations.
00:03:32.234 - 00:04:20.298, Speaker A: And then internally we also build an in house security team, so that we can review our code internally. So sometimes the internal team will keep reading the code and have different eyes of engineers to look at the code. So to give an example, the Zcash previously find a critical box, and then the bug is founded by the internal team members inside their own teams. That means it's very powerful to have an in house security team to look over your code and then keep iterating, and then over and over again to make sure there will be bug free. And then third things we believe in is the decentralization. So I think a lot of people believe that decentralization may be not important in the layer two, but we don't think so. I think the decentralizing is one of the key characters for the blockchain to be censorship resistant.
00:04:20.298 - 00:05:37.062, Speaker A: And then that also means as layer two in the future will become the execution layer. So I think 90% of execution will be happened on the layer twos. So it's also important to make sure that the layer two will inherit the same guarantee that Ethereum provides as a layer one. So that means also we need to be censorship resistant, and then the decentralization will be an important part of that. So for screw we are committed to decentralize all different layers, including the provers, who is responsible for generating the ZK proofs, as well as like the sequencers, so that you have the validators to validate, and then the different one can propose the blocks and then process the transactions. Okay, so just to reiterate, for the community driven, so these are a subset of the contributors who has been contributed to the ZKE EVM circuit projects, and then half members of Franco and from eastern foundations and from other teams who are very interested in contribute so I think we'll just make it continue going and then have a growing developer community to help us to build the ZKEVM and so just share a bit of our journey to scale the Ethereum. So scroll is founded about almost two years ago and we've been working for almost a year and then until we reached the phase one.
00:05:37.062 - 00:06:28.294, Speaker A: And I believe that we build a ZKE EVM proof of concept that makes sure putting the EVM into the ZK circuit is a practical and is a possible thing to do. And then after a few months we build our first pre alpha testnet. We are running both the layer one and layer twos and to just battle test some of the ZKE EVM initial ideas and then running some approvers to generate proof at the real time to share some of the statistics of our pre alpha testnet. Up to now we have more than a million unique addresses running on our pre alpha testnet. We have process executed more than 16 million total transactions have proofed for more than 1.8 million blocks. And then we also received a lot of developers like deploy contract.
00:06:28.294 - 00:07:14.834, Speaker A: Sounds like there are 60,000 deployed contracts on a Testnet from 36 different addresses. And fast forward to today. On this Monday, February 27 we launched our Alpha testnet. It's on the permissionless testnet on the though for this new testnet we will be running a more complete DKE beam circuit and then we are connecting to the goody to more like having more real battle testing and then having the goody test users to come and test on our testnet. So as like I said, it's been live on the Monday, it's been running like almost a week. We have a ZK proof verified on the goody in the smart contract. It's like being EVM equivalent.
00:07:14.834 - 00:07:54.786, Speaker A: And we also build a bridge between the goody and the scroll. And as of today I check there's more than 12,000 Goody east has been deposited through the bridge from Goody to our scroll testnet. And this is like some screenshot I took like the last night. So we already have more than 130 thousand addresses like been running and we have already, within the first week we already processed more than 400,000 transactions on our layer two. Okay, so that's about our story. So now I'm going to share some of the challenges in building the ZKEVM and the Ck rough. So where are the challenges? You can think about building those things.
00:07:54.786 - 00:08:36.702, Speaker A: So first you need to learn how to write CK circuits. And writing CK circuits is harder than writing some regular normal programs. And then next, after you learn how to write ZK circuits, now you can build ZKE EVM like using the tools and then using all of the recent protocol ZK products, and then the open ZK frameworks. And then last, after having the ZKE, um, then you can build the infrastructure to run the Zkrop, to build a proof, and then to roll up and then to finalize on the layer ones. So first I will explain why writing ZK circuit is hard, although people know writing ZK circuit is hard. But I think that fundamentally there are two reasons. Like the ZK circuit is hard to write.
00:08:36.702 - 00:09:27.790, Speaker A: So when you write a regular program, a normal program, so what do you need to do? Like for example, you want to write a function fool. You only need to think about when you're taking the argument x and y and how to correctly compute the output z. So you only need to write that program like the computation correctly, and then so that you can finish the program. But in the Zk circuit, the logic is different. So you can think like both the inputs and outputs of your original function becomes the input to your Zk circuit. And then what circuit outputs really is that whether this input is a valid or not valid trace, given the definition of your original functions. So that means if you give a valid input like x, y and a full xy, then the circuit should output like it's a valid trace, and then that should last through.
00:09:27.790 - 00:10:13.002, Speaker A: But if you give in a different input like X-Y-A-Z prime, like a random rumble, so the circuit should reject and then you won't be able to generate a valid proof and then being verified by the verifier. So you should think of invalid. So what this entail is that when you're writing the Ck circuits, you need to consider both the correct case and then some incorrect case. And then you need to prevent all of the incorrect case cannot pass through your circuit. That's like why writing the ZK circuits are more tricky than writing your regular program. And then second things like in the Zk circuit, you need to work with the finite field. So what is a finite field? So it's just a field of a field that contains a finite number of elements.
00:10:13.002 - 00:10:48.278, Speaker A: So usually the number is a prime number, so that you can have some properties. That unique property found this prime number. So what does that mean? Like the sample you can think of like it's a modular. So all of that, like a one plus something like a modular, a prime number will become a finite field. So take an example like the finite field that we are using to build the ZKE EVm is from an elliptic curve, Bn 254. And that finite field is a prime number of like a 254 bit value. Now the tricky things like in the EVM, the EVM word has like 256 bit values.
00:10:48.278 - 00:11:42.790, Speaker A: That means the EVM word cannot be natively represented inside a finite field. So in order to represent the EVM word, you need to split into two different numbers. For example, a simple example is that you need to split into a high 128 bit value plus a low 128 bit value to represent an EVM word. So this is something like making, like writing the ZK circuits becomes a little bit more tricky than writing a regular program. Okay, now second, if we know how to write circuits, and then we know those challenges. So what's the challenging thing about writing the ZkeVM? So if we consider EVM, before we consider ZKE EVM, let's take the Zk out and then look at how EVM works. So the EVM is the execution or interpreter that execute your smart contract bytecode like one by one, like sequentially.
00:11:42.790 - 00:12:22.810, Speaker A: And if you look inside the Ethereum virtual machines, it has a few components. First, it has an executor that interpret all of your opcodes and perform some of the computations. And then it also has like a stack and a memory for any transient data to be keeping inside of the Zkem. Sorry, to keep inside the EVM. And then you also need to read the database to read the bytecode database and have a storage space that keep the user account and balance. And also any smart contract storage space will be keeping the storage. And then user will send a bunch of transactions and it will process the transactions one by one sequentially.
00:12:22.810 - 00:13:02.550, Speaker A: Now let's put the EVM back into the ZK. What does that mean? Like how you build a ZK EVM. So you also build a ZKe EVM modularly, like the EVM. So first, if you look at the executors, you'll write an executor circuit, which right now we just call it the EVM circuit. So the EVM circuit is basically similar to what an executor behaves inside the EVM. It just process all of the opcodes in your smart contract step by step. And then each step given like which opcode you are executing, you invoke certain set of constraints to constraint that the completion has been done correctly.
00:13:02.550 - 00:13:58.920, Speaker A: And then for the stack and the memory you have basically have a RAM circuit for any read and write, you'll put those read and write events into your records, like putting to the circuit. And you can constrain that any read after the write at the same message at the same address slot will become the same. And then third, for any bytecodes you load, you need to prove that you are loading the correct bytecode inside your DK circuit. That means you need to recalculate the bytecode hash that will be matched to the bytecode hash you stored inside your state account. For the storage we know like the storage inside the Ethereum is like a Merkel Patricia tree. So for every read and write you will generate a Merkle proof. So that means in the Zeke MPT circuit, which stands for Merko Patricia tree circuit, you need to verify the Merko proof for each read and write to your storage and account balance space.
00:13:58.920 - 00:14:45.190, Speaker A: And then finally, when you process the transactions, you also need to verify that transaction you execute is a valid transaction. That means that you need to verify the transaction hash is correct, and then you need to verify your signature. The ECDSA signature of your transaction is also correct. And then we also know like Ethereum using the catch hack hash function to process to compute the transaction hash. So you will also have an individual catch circuit to verify the catchack is calculated correctly. So there's also a few other circuits inside the Zkevm. And then when you bundle everything together, then you get your Zkevm that can fully verify all of a transaction happen inside the layer two is correctly executed.
00:14:45.190 - 00:15:48.250, Speaker A: Now let's say if we have the Zkevm, how can we build the Zkrop? How do we build the Zkrop infrastructures? So let's also start from some simple example. So in the layer one, the things I guess become more straightforward. So the user just sending the transaction to the sequencer and the sequencer will do some ordering of the transactions in the Mem pool and process the box in the layer one. Although I'm probably oversimplified this, you will have auto consensus layers that do more complicated things, but overall the processing is just having a single sequencers. Now, what happens inside the layer two is first, it's more or less similar to the layer one. So you have a sequencer that have like executors who process all of the transactions. Then the users can submit the transaction directly to your layer two sequencers, but it can also submit any transaction from layer one bridge contract for any deposit or any enforced transactions that will go through the bridge.
00:15:48.250 - 00:16:33.846, Speaker A: In the layer two sequencer, you need to build a watcher to watch any deposit events from your layer one bridge contract. Then if you want to put up like a row up. So that means for a row up, you need to send all of the data, like all of layer two data to be available on the layer one. So anyone else can recover the layer two status by just reading the data from the layer one. That means inside the sequencer you need to have a roll up agent to send in any data like in batches to the row up contract that's located in the layer one. And then if you want to put the Zkevm or for optimist Rob, you will have some fraud proof. So in the Zkevm case you have an actual node called prover.
00:16:33.846 - 00:17:34.038, Speaker A: So that's going to generate like running the ZKevM circuit, generate a proof and then sending that back to the rob to be verified and finalize any batches, any transactions and blocks happened in the layer twos. And why the prover has a separate node is because running the ZK provers is like a very heavy computation workload. So it means you have some dedicated beefy servers running either gpus or very beefy cpus. Or even like in the future they will be having some ZK accelerators, ASiCs to run to generate the proof within a small amount of times. And then inside the scroll we also commit to decentralized, that means then we have a decentralized provers that are going to generate those proofs. But we don't need to have all the provers inside school to compete for each single slot. But you can randomly select a few provers for availability.
00:17:34.038 - 00:18:13.980, Speaker A: And then they want any of them to generate a valid proof within the time limit. Then the layer two can still process and be finalized on the layer ones. And then even more complicated, when you decentralize both the provers and the sequencers, then you need to have a mesh network between the layer two sequencer and the approvers. And for that, actually we are still working on some research ideas. So how to decentralize both of the two sequences and provers. So if you are interested, you can also come and then work with us or just contribute and think about that. We are happy to collaborate with any community members.
00:18:13.980 - 00:18:52.370, Speaker A: Okay, so that's about all of our challenges we have. So what's our next step? And then I think we already have our alpha testnet. And then the next step is go to the main net, have some roadmaps we need to finish before we go to the main net. So first of all to be fully transparent so the ZKE event circuit we're running like in the alpha testnet is not very complete. So I have missing a few tiny things. One is like there are a few uncommon errors in the EVM, we haven't fully constrained. And then we also will add, pre compile support, all the pre compiled contracts in the ZKE event circuit.
00:18:52.370 - 00:19:36.180, Speaker A: And we are already having a lot of things like work in progress. So we just are committed to finish that within the next few weeks. And then we are going to do going to auditing, like we're going to audit the ZKevM circuits, the bridge contracts and the node implementations. And then we'll also apply some of the optimization ideas. We have to further reduce the proof generation time and then the proof generation requirements. And what's beyond the mainnet is like we're going to commit to do like this, trying to decentralize our approvers in the beginning and then decentralize the sequencers and then trying to build like a fully censorship resistant decentralized Zkevm mainnet. Okay, so this is last.
00:19:36.180 - 00:20:00.700, Speaker A: We are happy to have more people to help us contribute to scaling Ethereum. You can join us, you can have the hiring page, and you can also join and play with our pre alpha testnet and enjoy our discord to participate any like, if you have any questions, you can join our discord. We'll have people to support you. All right, thank you. It.
