00:00:00.330 - 00:00:26.230, Speaker A: So yeah, let's give a warm welcome to Carl. All right, good morning, everyone. Today I'm going to be talking about union, a sovereign interoperability layer for the modular stack. First, a little bit about me. I'm Carl Zerox, Kaiser. Carol, give me a follow. Developer by background, mainly systems engineering and founder of Union Labs.
00:00:26.230 - 00:01:20.214, Speaker A: Our vision really is towards a unified, rollup centric future. We see a state machine for every single product out there, fully asynchronously composed. That means interoperability, bridging asset transfers and general message passing going around, but with the same user experience as monolithic stacks. Right now, what we're seeing in the ecosystem is that products that move to the modular stack can do tremendously well. Dydx, moving away from its L1 and instead capturing the full value accrual, led to far better ux, while still enabling users to trade like they used to and to be honest, even more performantly. And obviously with the hype and rise of Celestia, only more is happening in this space. Before we start talking about kind of the modular stack, we first need to go back to what we're doing in web3, really, and what we're trying to build.
00:01:20.214 - 00:02:14.242, Speaker A: Web three is the world computer, after all, the original vision of ethereum, one global state machine, one global computer where code is absolute law, trustless, verifiable, without intermediaries. APR calls are smart contract calls that cannot be intercepted, where nothing can go wrong. And so when you interact with a product, one can basically simply read the code and know in full what is going on. Why was ethereum so successful? Not only because of the fact that it's trustless and secure, but to be honest, truly because of the composability that you have. This is what allowed for the cambrian explosion of products. One can build very simple, small, smart contracts that do ERC 20 taxes and aggregate them into further products while still maintaining those same guarantees as if you're just interacting with a single product composition over duplication. That's what defragments liquidity across the stack.
00:02:14.242 - 00:02:50.334, Speaker A: In the end, we don't want to be reproducing products over and over that require the same liquidity to be functional for the end users. We want to reuse existing liquidity over and over to build new products because products get more performant once we increase the liquidity in them. That's the case for Dexes, that's the case for vaults. In the end, most DFI protocols need a minimum amount of liquidity to function, kind of as an example. This is what I think kind of most magic DFI looks like in the EVM, we all start with ERC 20s. We might put them in different dexes pools with different guarantees, aggregate them in LSTs, probably have an aggregator in front of those dexes. That's another Dex.
00:02:50.334 - 00:03:45.650, Speaker A: And finally, we do some magic defi on top of that with incentives, et cetera. But the real power of the EVM is that all of these protocols can basically be banged out in a couple of weeks, and that new teams can come in and build on top of them without necessarily needing to have a contract with the company that they're building on top or an agreement. You can just start composing everything and build new products. Now, in the modular stack, we have to ask ourselves, can we achieve the same? Does horizontal scalability prevent composition? I think we're all familiar with 2018, when we had the alt EVM rush, where there were new chains being launched, but these chains were just copy clones of Ethereum, really. We didn't see any new products, and we also didn't see interactions between these products. What we see is individual monolithic chains where users bridge in temporarily. Maybe they stick around for a couple of weeks and then hop into the next one, but we don't really see products tied into each other across these different chains.
00:03:45.650 - 00:04:46.866, Speaker A: So what we need to wonder, how can the modular stack outcompete monolithic stacks, right? If we don't really have this composability yet, how are we going to bring it? And finally, how do we prevent isolationism? How do we make sure that all of these decentralized sequencing networks, Das, don't end up with 1000 l two s that all have exactly the same, all have 100 products on top of them, and all need to build their own tribal worlds. So before I'm getting too bearish on the module stacks, there are some great advantages to moving to it. Obviously, shared security brings massive economic security for any application. So we can actually move out of L two s, no longer pay high gas fees, but still benefit from the same security of the L two s. Now, with execution proofs and zk proofs, we get even higher security guarantees. And finally, with data availability and sequencing, we kind of remove the risk of censorship attacks. So moving to the modular stack with your application is actually great, and modular is obviously on the rise.
00:04:46.866 - 00:05:21.826, Speaker A: Trustus, interoperab within the modular stack is on the rise. It's grown tremendously over the last couple of years. This is mainly from the cosmos ecosystem, but also a bit from the celestial ecosystem. And I truly think this is going to boom. And in a few years, my next graph is going to show a thousand more l two s and a thousand more app chains. Now, to kind of tie into the topic of my talk, the sovereign trilemma. As it stands right now in the modular stack, we really cannot build a product that benefits from kind of the modular, horizontally scaled characteristics that's still fully decentralized and interoperable right now.
00:05:21.826 - 00:06:01.630, Speaker A: We kind of have to give one of those away. And most of the time, what we do away with is the decentralization. We accept interoperability through multisix or trusted bridging providers. We do achieve decentralization on our consensus tech through da celestia and proofs, but we lose control over our assets. We lose control over the bridge, because in the end, if you're in l two, obviously you have a settlement contract. But outside of your settlement contract, there exists some type of bridge contract, and that bridge contract is what truly is in control of the assets on your chain. Now, this is obviously what we're looking to solve with union.
00:06:01.630 - 00:06:36.874, Speaker A: As it stands right now, modular truly cannot succeed. What we've gained in security so far on the consensus layer, Da layer, we lose in security on the interoperability. But more than that, we lose it in composability. As it stands right now, asynchronous composability, which is the ability for us to bridge in and out of different chains, send general messages, and basically make calls to other chains, just isn't as good as synchronous. It doesn't have the same security guarantees, it doesn't have the same speed. It fails all the time. It's one of the most horrible UXs out there right now.
00:06:36.874 - 00:07:18.578, Speaker A: What we see is bridges that are run with a single signature relayer, maybe multi signatures, and some better than that, multi party computation. But in the end, we're still offloading our security to some type of intermediary. The real future towards decentralization is consensus verification and state verification. And we're kind of at the cusp right now of getting this in production to go back a bit because everyone always waves the flag, like, be aware of the security risk, et cetera. We're obviously familiar with bridge hacks. Bridge being emptied completely, some hacker gaining access to the contracts, and all of us losing hundreds of millions. Something that we've forgotten in our mission in crypto is actually that we're also at risk of the SEC, of nation state attackers.
00:07:18.578 - 00:08:18.202, Speaker A: In the end, crypto is about laying down a level playing field where no single country. No single companies, no single party has an advantage. As it stands right now, when we want to do asynchronous composability or bridging between app chains, we do need to move out of this pure code Isla space and enter this kind of dirty off chain third party intermediary space where we can be stopped by the SEC, by lazares, or perhaps by the team that runs the multi SEC. One has to wonder, do we want to live in a world where privacy protocols are completely unavailable, where certain products built by perhaps developers from certain countries on sanctioned list are literally unavailable in this merger stack altogether? Or do we need to basically enable anything to be used and have the users decide to take on the risk? I at least went into crypto because I want to take on the risk myself. So we cannot ditch interrupt security itself. That's probably the first basic block that we need to make this vision true. In the synchronous tech code is law.
00:08:18.202 - 00:08:41.726, Speaker A: You read the smart contracts, it just works. In the asynchronous world we use intermediaries, multisix oracles, they're all the same. There's off chain parties running a server that get to decide what happens. And most of the time these are run in the US. In the synchronous world we have atomic execution. We make a call, it's either going to succeed or fail. But there's no intermediate state where your funds are in limbo, not on one chain, not on the other chain.
00:08:41.726 - 00:09:15.166, Speaker A: And now you need to DM the team. What the hell is going on? In the asynchronous world, we have broken states. It's just, to be honest, a horrible experience. And so the synchronous world to me still is truly web3. And with the asynchronous modules teched, we've gone back to web two. And so this is what we're obsessed with at union. How do we make this asynchronous world as good as the synchronous world? How do we get that composability to the same level? How do we prevent crypto from being attacked by nation states? And how do we make that modular future true? Really, the first key is to invert control.
00:09:15.166 - 00:09:47.846, Speaker A: Interoperability is a right, not a privilege. Right now, interoperability is as if the Ethereum foundation were to whitelist every single smart contract. We would never had the cambrian explosion of products if italic had to proofread every single contract out there before it was deployed. And this is what happening with bridging providers, right? Now, you contact them, you wait 16 months, they vet you. If you have enough traction, you might get support. If you lose traction, you're going to lose support, and then you're kicked out of the ecosystem. We need unstoppable systems, systems that cannot be taken down by anyone, not even the team, right.
00:09:47.846 - 00:10:29.326, Speaker A: Because sometimes teams abandon their chain or projects, but the chain itself remains alive with liquidity. We saw with the multichain bridging system that literally the CEO got arrested and somehow that was sufficient for the entire project to go down and literally the smart contracts to become inoperable. And finally, we need to hyperscale, because what we're working towards is a future of 10,000 l two s 1000 app chains. If we're going to go to that future, we cannot be allocating 50% of our block space to interoperability. Right. We need to actually make these system level calls that just function as a core part of a protocol as cheap as possible, because we all want to make sure that we reserve as much block space for our user transactions. I don't want my decks to serve 50% interrupt.
00:10:29.326 - 00:11:08.354, Speaker A: I want my decks to do 100% in trades. And so these are the qualities that we need to look for. And obviously the forefront, permissionless and trustless, allow any team to integrate in this system. Don't have the bridging provider go to teams, do the integration, have teams be able to spin up an L two, or an app chain, make a smart contract call, connect to the interoperability protocol, and be part of the full stack, because that allows you to go to this like 10,000 or 100,000 app chain future. Otherwise, no company could support this. We see some other protocols attempting to do this. They might have pick and choose security models, pay a bit more for higher oracle security.
00:11:08.354 - 00:11:47.950, Speaker A: To me, that also doesn't work. Ssl everywhere, tls everywhere. So with that, interoperability should have the same security everywhere. We saw with tornado cache that their protocol was fundamentally sound, but the real avenue of attack was through the DAO by basically kind of boring low level messages to gain control of the entire protocol. In a world where we have different security in the interrop stack itself, we're of course all going to put the higher security on asset transfers because we're all aware of hacks going to happen. But definitely teams will cheapen out on their general message passing, which leads as an avenue of attack to take control of the protocols as it is right now. Just go with the highest security level.
00:11:47.950 - 00:12:26.198, Speaker A: That also composes the nicest can you imagine a world where if you made a smart contract call to one contract, it had a different security guarantee than to another one, where with one, you had to kind of hop outside of this wilt and have a potential failure or someone change the data that you're sending. But with the other one, it's pure. It would be an absolute pain to write any smart contract on Ethereum. We would have to read through all of them one by one, see what the guarantees are. We couldn't just arbitrarily register new Uniswap Dexes in our aggregator because the guarantees would be different. And so it has to be all at the same level. Now, with kind of all of the guarantees and properties that we want laid out, you really end up on one thing, and that's consensus verification.
00:12:26.198 - 00:13:09.046, Speaker A: With consensus verification, we track individual chains and we rely on the security of the validator set. Instead of relying on these third party intermediaries, we generate proofs. And if you want to scale out these proofs, we generate CKPs, zero knowledge proofs, which enable us to no longer allocate 50% of block space, but instead only zero one. With consensus verification, we inherit the full security set of the underlying chains. You inherit the full security of ethereum without actually needing to pay IgA layer at all. You literally just get it for free by tracking that. And so it's kind of the best we can do with the least gas cost, with the least value necessary to be put into the system, which means that protocols that do consensus verification have the highest value extraction for the own protocol.
00:13:09.046 - 00:13:40.806, Speaker A: For the end user, it means lower fees for your users or higher revenue back into your protocol. And finally, of course, I've said already, permissionlessness leads to hyperscaling. If an interoperable protocol has to decide on which protocols to support, it will fail. It's not going to scale out. We at union have decided to bet on IBC. IBC is a protocol originating from Cosmos, designed to exactly allow this hyperscaling and kind of the app chain future itself. Everyone knows the meme.
00:13:40.806 - 00:14:12.900, Speaker A: There's 14 competing protocols. Let's build a 15th one instead. Union decided to go with the fastest growing protocol and be compatible with that. So what are we doing? First, we're connecting all IBC chains. We're connecting Celestia rollups. We're integrating with ethereum settlement proofs and integrating scroll. We're targeting different EVM chains, all with proper consensus, with proper finality, and basically building out kind of this first layer of a ZKP based powered, standardized intro protocol across everything.
00:14:12.900 - 00:15:01.106, Speaker A: At the moment, our proof generation is about 6 seconds doable on M two MacBook. So we have actually achieved a technological future where it is possible to build such a system. Now, this is not the long term future, because the moment you start generating hundreds of CKPs across the stack, there's only one logical thing to do next, and that's obviously proof aggregation. Singular proof of proof that tracks every single state machine out there, every single L two, every single app chain. This is basically where a now we have a direct connection from every single chain to every single other chain where we can do storage proofs, state proofs, asset transfers, general message passing with the same cost as if you connect it to just one other chain. Literally 10,000 chains has the same overhead as a single chain. The only downside is computation goes up a bit.
00:15:01.106 - 00:15:35.710, Speaker A: But actually, I think that this year we're entering the era where proof aggregation starts becoming feasible as well across the stack. And I think in three years time we're going to do proof aggregation across thousands of chains. This is also the opportunity where we can actually see intents become a reality. Right now, intents are a bit wishywashy, right? Like describe what you want to do, it's done, but there's no protocol actually doing it. But when you have this singular point of interoperability, you can do coincidence of ones matching order flow against each other. You can do just in time liquidity. You basically get a single point where you have a complete overview of all chains, all order flows, and everything that goes on there.
00:15:35.710 - 00:16:15.846, Speaker A: And that's the future of making all blockchains homogenized, where it no longer matters where your product actually lives. Because now blockchains are just basically rented security and order flow providers. And this layer on top is actually where you want access to all of this order flow. That's actually where you want to build your products. So how do we actually solve the interoperability problem? How do we ensure that all chains remain sovereign, but connected, decentralized and hyperskilled? The first one is simple. Ensure that we get those same guarantees as we have in monolithic stacks. Make sure that in the end, we stay in this code, this last space, the next one, standardize across this chimera within the modular stack.
00:16:15.846 - 00:16:48.194, Speaker A: Right now we see different consensus systems, different execution models, different DAs. All of that leads of course, to an explosion of new products and technologies. But in the end, the one thing that needs to be the same everywhere is the interop, because otherwise we can't connect these products. And then we can't homogenize them. Finally, of course, make interoperability extremely fast and decentralized, and ideally allow users to generate their own proofs. In a world where we can generate our own proofs, there is no company that can disappear. There is no offchain centralized compute that can be attacked by nation state attackers.
00:16:48.194 - 00:17:18.494, Speaker A: Make proving an interoperability the same as miners. Allow anyone to just spin up their laptop and start participating, because then you have a system that truly is software, not a service and that cannot be taken down. For me, horizontal scalability is the future. It's the only thing that makes sense to make crypto useful for the wider community and to support any project out there. The monolithic stack is dystopian and it leads to censorship in the end. Already it's hard to get tornado cast transactions into Ethereum. It's already being limited on the protocols that can develop on there.
00:17:18.494 - 00:17:50.780, Speaker A: Light clients and ZKPs enable this horizontal scalable future. And the future is modular. If you guys are interested in the work we do, check us out on Union build at Union build and give me a follow. This is type of stuff we talk about that we're interested in and feel free to reach out to me afterwards if you have any questions or Q A. Thanks Corel, super interesting.
