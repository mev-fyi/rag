00:00:00.330 - 00:00:50.570, Speaker A: How you guys can kind of build on top of it. So what is TCTP today? USDC is like a really cool utility that's spread out across a bunch of different blockchains, but it's not super easy. If you have a bunch of USDC on Ethereum and you want to do something cool on avalanche, not super easy to do. You have to go through either a centralized exchange or do some third party bridge that may or may not be secure, may or may not be fast. So there's a lot of reasons why circle wanted to build a utility like this. So when we started thinking about it, the first thing that we knew we wanted to do is make this 100% native USDC. So a lot of third party bridges use like a wrapped version of a token on the destination chain.
00:00:50.570 - 00:01:40.220, Speaker A: So there's a lot of wrapped versions of USDC floating around, which isn't great. That leads to user confusion, liquidity, fragmentation, things like that. So it's 100% native USDC, meaning we actually burn the USDC on the source chain and mint the new USDC on the destination chain. The next thing is unified liquidity. So we knew USDC sort of has a liquidity fragmentation problem on some blockchains where there's maybe three or four different versions of USDC. So we think CCTP can really be that universal liquidity layer in the middle. So using USDC to kind of bridge across chains and then maybe swap that into a different chain or a different token, there's a lot of different things you can do with it.
00:01:40.220 - 00:02:22.810, Speaker A: We also wanted this to be fast. So some bridges today can take a couple hours, maybe even a couple of days to get your funds due to different security models or different design decisions. We knew we wanted CTP to be on the scale of minutes rather than hours or days. We also wanted this, obviously, to be very interoperable. So we want this to be the same similar interface for developers to work with. Whether you're on an EVM chain like avalanche, or eventually a non EVM chain, something like Solana also wanted this to be many to many. So if you have USDC on Ethereum and you want to move it to Solana, you don't have to go through some other chain.
00:02:22.810 - 00:02:53.250, Speaker A: Any chain that CTP is supported on can move to any other chain that it's supported on. That means in the future, once we support these chains, you could move USDC on Solana over to USDC on arbitrum without having to go through Ethereum or anything like that. And lastly, we wanted this to be extensible. So we know developers like you guys to be able to build on top of it, extending the kind of composability that I'm going to talk about later to build this into your own apps.
00:02:55.210 - 00:02:55.670, Speaker B: Cool.
00:02:55.740 - 00:03:46.420, Speaker A: So diving into kind of how it actually works. So at the highest level, some event happens on a source chain. In this example, Ethereum, Circle's attestation service is listening for these events and signing a message, basically saying yes, Circle says this event happened. The destination chain can eventually basically verify that that message is valid. So once we have that attestation from the attestation service, we provide it to the destination chain. It ensures the validity of the message and knows that this event did actually happen on a different chain. You can see in this model circle, just like it is with USDC, is kind of like a trusted third party in the middle, meaning that the destination smart contracts just have to trust Circle to say this event happened.
00:03:46.420 - 00:04:34.130, Speaker A: So diving in a little bit more into how the USDC transfer actually works and what the transactions look like. So the first thing that happens, as I'm sure a lot of you guys are familiar with, is we have to call approve on the USDC contract. This basically is just approving that. The token messenger contract can pull out some amount of USDC from the user's address into the contract wallet. The next thing is on the token messenger contract on the source chain we call deposit for burn. What this does is pulls that USDC out of the user's address and then burns the USDC. After it does that, it constructs a message that basically says we burned x amount of USDC on x chain.
00:04:34.130 - 00:05:22.370, Speaker A: We now want to mint x amount of USDC on some other chain. Passes that message over to the message transmitter which will construct an overall message and emit an event. Once that event is emitted, you'll take the message hash from that event to our attestation service. So like I mentioned before, this attestation service is listening for these message sent events and signing messages, basically attesting that the event did happen. So once you have the attestation from step three and the message from step two, you can go to the destination chain. You'll call receive message on the destination chain message transmitter contract. What this will do is basically decode the message, then call the token messenger contract which will mint the new USDC.
00:05:22.370 - 00:05:40.540, Speaker A: It'll then lastly transfer the address specified in the original deposit for burn function. Call should also mention that this receive message validates that attestation that we get in step three. Just to ensure that circle is the one that signed it and basically proving that event did happen.
00:05:42.190 - 00:05:42.794, Speaker B: Cool.
00:05:42.912 - 00:06:28.870, Speaker A: So looking at all those steps in sort of a diagram that shows how the contracts, what the interfaces kind of look like. So if we start there on the left on the source chain, we have the user interacting with the token messenger contract, calling deposit for burn. If we go downwards, that's where the USDC gets burned in the fiat token contract, which is USDC. Then we move upwards where we get the message sent event that gets emitted. Then we move to the middle where we have our attestation service, signs a message and returns it to the user. Lastly, on the destination chain, the user brings this message and the signature to receive message and it flows downwards until we mint the new USDC to the user.
00:06:31.050 - 00:06:31.510, Speaker B: Cool.
00:06:31.580 - 00:07:41.070, Speaker A: So now that we know a little bit about how it works with USDC, I'm going to talk a little bit about the kind of composability of CTP and how you guys can build on top of it, and how some of our partners are building on top of it already. So at its core, CTP is kind of a low level interface and utility for developers to extend and build on top of. So that means we expect cross chain messaging platform, bridges, aggregation services, all of these kinds of apps to kind of build on top of and extend CCTP to integrate it with their own existing or new apps. So the first kind of contrived example that I'll show, that's kind of more than just transferring USDC from one chain to another, is a simple example where we have a user holding USDC on Ethereum and he finds some cool new DeFi protocol on avalanche. He says he wants to interact with it. Problem is, he doesn't have any USDC on avalanche. So what he'll do, we can basically facilitate this on CTP using just two on chain transactions.
00:07:41.070 - 00:08:47.750, Speaker A: You can also show it basically as just one transaction to the end user, which is the transaction on the source chain if your kind of app acts as a relayer on the back end, calling the received message for the user. So what this example would look like is this is a similar diagram to what we saw before, except we've got two new boxes in the top, right? So the source chain and the off chain service in the middle. Those look exactly the same as they did before. But now, instead of interacting with the message transmitter contract, we'll actually interact with a new contract that we're calling bridge to defi for this example. So this would be something that you would write that would basically call receive, message on message transmitter, receive this newly minted USDC and then immediately do something with it. In this example, like depositing it to some defi protocol or something like that. So basically it's just an easy way to show like we have one transaction on the source chain and then one transaction on the destination chain that's doing all of the minting for you and depositing it to some protocol.
00:08:47.750 - 00:09:53.878, Speaker A: So what this would look like is just, this is like again a super simple and basic contract. Not what something would actually look like. But as an example, we first call that receive message function on the message transmitter and then we deposit to some protocol. This can also be extended to really anything you want to do on the destination chain. So we've got some really cool partners like wormhole layer zero Axelr that are building some really cool stuff that it's more advanced than this, doing really cool things like starting with native ETh on Ethereum and then bridging over to native avax on avalanche using USDC as like the liquidity layer in the middle that goes across CCTP. Another example that actually doesn't use USDC, that kind of builds on top of the generic message passing layer of CCTP. So basically at its core level, before you even bring USDC into it, CTP is a generic message passing layer.
00:09:53.878 - 00:10:49.590, Speaker A: What that means is you can build contracts on top of it, just like we have with USDC that handle the minting and the burning and the bridging of your asset. So this example, again, a made up example of something where we've got like a play to earn game where you can plant some tree NFT on Ethereum, but to actually harvest the tree, you have to do something on avalanche. So you can kind of facilitate this cross chain process with CTP. So what this would look like, again, similar to the first diagram I showed, we've got the message transmitter contracts stay the same. That's kind of the generic message passing layer. But now instead of like a token messenger and the USDC contract, we've got some custom tree messenger and tree NFT. So what this means is the tree messenger would receive the deposit for burn function, burn the tree.
00:10:49.590 - 00:11:17.750, Speaker A: It would then go up, get bridged across, and when we call receive message on the destination chain, we would mint the new tree NFT. Again, this is a made up example. Like, I know, nfts a big kind of reason for nfts. You can see the history and the owners and things like that. So this obviously burning and minting new nfts doesn't make sense in that example. But just to show we can actually do this with more assets than just USDC.
00:11:20.250 - 00:11:20.710, Speaker B: Cool.
00:11:20.780 - 00:12:08.436, Speaker A: So now I'm going to show a little bit of the developer docs just to walk you guys through what we have so far. So if I open that up, so on our developer docs, if you guys just go to developer circle slash stablecoin slash docs, you can also just Google literally like CCTP docs. And I think it's the first response there on Google. So basically we have some background on CTP, how it works, how you can integrate with it. We've got information on the contracts like our Testnet addresses. Internet is being super slow. So it's not loading, it's not going to load, but Internet is being slow.
00:12:08.436 - 00:13:30.980, Speaker A: But basically we've got contract addresses, information about the contracts themselves, how they work, the interfaces that you'll interact with. And then we've also got a quick start, which is basically we've got some scripts in the GitHub repo that walk you through exactly how to do a basic USDC transfer. So it has a script that'll walk you through all the approve deposit for burn and receive message calls that I talked about before doing all this on Testnet, bridging some USDC over from ethereum to avalanche. We've also got some faqs that help as well. So let me see real quick if I can connect to my phone to show a quick demo of what this looks like on Testnet. If it's being too slow, I'll just skip this and we can hop over to questions, but let's see if this will load. But basically we built a demo app that integrates with CCTP on Testnet that shows an example of how you could bridge USDC over from Ethereum to avalanche.
00:13:30.980 - 00:13:35.860, Speaker A: It's behind our VPN, it's not loading.
00:13:38.680 - 00:13:39.430, Speaker B: Cool.
00:13:39.800 - 00:14:11.004, Speaker A: Okay, so like I mentioned, this is a demo app. We're not going to be releasing anything like this. We're actually going to be relying on partners and developers like you guys to build CTP integrations into your own apps. But this demo can kind of show what it would look like. So for example, we want to go from Avalanche over to Ethereum. We've already got our metamask wallet connected. We can see on avalanche we've got seven USDC.
00:14:11.004 - 00:14:36.776, Speaker A: And if we jump over to Gurley, we've got nine USDC. So at the end of this we'll have ten USDC on Gurley. So if we start off, we just copy our wallet address. We've got the same wallet on both chains. So this is the end destination address that we want to transfer to. Let's say we want to send one USDC. First thing we'll do.
00:14:36.776 - 00:15:16.100, Speaker A: We've already called approve with a high amount earlier, so we'll skip that transaction. So this is actually the deposit for burn transaction happening. So to open up metamask and we'll see, we're calling deposit for burn on our contract. We'll confirm it. So what's happening now is that transaction is getting broadcasted to the network and then circle's attestation service will see the message that get event, see the event that gets emitted from that message and signing the attestation. And then on the back end we're actually calling the circle attestation service to get that attestation. So at this point that's already happened.
00:15:16.100 - 00:15:24.250, Speaker A: It's done. So now we have to switch our network over to Gurley and then call receive message.
00:15:29.360 - 00:15:29.772, Speaker B: Cool.
00:15:29.826 - 00:16:10.584, Speaker A: So we're calling receive message here. We'll confirm it and then pretty soon it'll be done. We'll have our new USDC on Gurley. Like I mentioned before, you can kind of skip this third step of calling receive message for the user by if your app acts as like a relayer on the back end, basically calling receive message for the user because their address doesn't actually have to be the one to call it. So if we look at metamask on Gurley, we've now got ten USDC. So it's super quick, super easy to use. We could transfer it back just as fast if we wanted to, but yeah.
00:16:10.584 - 00:16:38.050, Speaker A: So hopping back to the slides basically to wrap up, like I said, we're live today on Testnet, on Ethereum and avalanche. We hope to launch on Mainnet in the first half of this year and then throughout the year hopefully add additional chains. I think we've announced Solana hopefully will be coming eventually, some other chains as well. So yeah, that's about it. Are there any questions, technical or non technical? Anything really.
00:16:41.350 - 00:16:48.080, Speaker B: Yeah. Thank you.
00:17:06.410 - 00:17:19.640, Speaker A: I was just going to ask if you could go back to the previous slide. Cool, thank you. Yeah, and like I said too literally just Google CTP docs and it's the first.
00:17:21.770 - 00:17:27.882, Speaker B: Oh, one more. Yes.
00:17:28.036 - 00:17:47.598, Speaker A: So there are no native fees built into CTCP, so you're not going to pay circle or anybody else any fees. There will just be the Ethereum gas fee or whatever chain you're interacting with. So one fee on the source chain and one fee on the destination chain, just typical transaction fees.
00:17:47.794 - 00:17:49.494, Speaker C: Yeah. This is a really cool presentation.
00:17:49.542 - 00:17:49.914, Speaker A: Thank you.
00:17:49.952 - 00:17:57.866, Speaker C: I had a question. So let's say that I have a chain that doesn't support this swap, right? Can I consume the messages? So can I make my own receiver.
00:17:57.898 - 00:17:59.194, Speaker A: Contract on that chain?
00:17:59.322 - 00:18:03.150, Speaker C: Even though you can't reburn it, you can just consume USDC.
00:18:06.690 - 00:18:10.080, Speaker A: So you mean for USDC itself or for.
00:18:11.170 - 00:18:22.370, Speaker C: So like, you know how you did the burn then the receive? This chain doesn't have burn or doesn't have USDC at all. But can I just receive by verifying the signature coming from circle?
00:18:22.530 - 00:18:48.080, Speaker A: So basically, our contracts on each chain have supported domains. So for example, right now it would only have Ethereum and avalanche. So if you deployed CCDP yourself and did something like that, it wouldn't really do anything because we wouldn't have the attestation service in the middle and you wouldn't be able to receive that on any chain. But yeah, hopefully we'll be adding a bunch of chains relatively quickly.
00:18:53.280 - 00:18:54.200, Speaker B: Sweet.
00:18:54.360 - 00:19:04.490, Speaker A: All right, thanks, everybody. I guess we've also got a really cool circle booth up there, so if there are any questions later, feel free to come check it out.
