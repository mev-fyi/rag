00:00:01.050 - 00:00:34.070, Speaker A: Welcome to the second half of day one of ETH Denver. Is everybody having fun? All right, awesome. So we have another several hours of workshops before we do the opening ceremonies this evening. As a reminder, we have a second stage over here with additional workshops. And this, of course, is the main ETH stage reach. Our next presenter or presenters are from modular. This is another smart contract security focused presentation.
00:00:34.070 - 00:00:55.840, Speaker A: As you probably know, smart contract security is kind of one of the most important things that we need to collectively get right as an ecosystem. And it's something that's very much up in the air right now and being developed. So it's exciting to watch and exciting to see new services and tools being developed. So with that, I'm going to hand it over to Josh and he'll dig into it.
00:00:57.090 - 00:00:58.000, Speaker B: Thank you.
00:00:58.770 - 00:01:59.902, Speaker C: So welcome, everybody, to an introduction to smart contract and distributed application security, presented by modular and consensus. My name is Josh Hannon and I'm the COO co founder of Modular, and I'm joined today by Jessica Marshall, an engineer at Consensus. And we were going to have will gias present today, but he missed his flight. So we're having Chris Brown, who is the CEO at Modular take over forum. So I just want to start out by saying that blockchain is a new paradigm that requires us to behave differently than before when building these applications. Gone are the days when we can rely on the old Facebook adage of move fast and break things, because we need to be slow and methodical in everything we do, taking care and consideration when building these applications. And we especially can't put ourselves under a lot of pressure to meet strict deadlines when building our projects.
00:01:59.902 - 00:03:04.018, Speaker C: Good thing we're building it a hackathon. So I just want to start out by going over a few aspects of the technology that require us to be so careful when we're building these applications. Because if you compare, like, old web design to like a minute clinic, then you could kind of compare blockchain to an emergency room. Sure, there are some issues that are small, that can be fixed easily, but it's important that we focus on preparing against every possible negative outcome because anything that happened could be catastrophic and is extremely hard to fix. So first thing I want to go over is that all code is public. So this causes a few problems that we have to worry about. First of all, since your code is public, that means that every all star hacker is going to be able to comb through every single line of your code to try to find possible vulnerabilities.
00:03:04.018 - 00:04:14.410, Speaker C: So there's no hiding behind precompiled binaries this time. And this makes it vitally important that we make everything that we write as clearly written as possible so that when other people are reading it and auditing it and testing it, they know exactly how it's supposed to behave so we can prepare against possible vulnerabilities. Another reason that this is a big deal is that we can't have sensitive user information on the blockchain. Sure, it might sound good to you to try to want to put some user data on chain to do some nice data analytics, but that might not sound good to little Johnny over here, whose browser history was just exposed to the world on a public immutable, permanent ledger. So you just have to be careful about that. Next issue I want to talk about is that computation on the Ethereum blockchain is expensive and there's also a limit. So it's important we focus on keeping logic within our contracts relatively simple so that it can't be manipulated by attackers trying to find ways to cause transactions to fail within our smart contracts.
00:04:14.410 - 00:04:56.570, Speaker C: And last but not least, on the blockchain, we have to worry about immutability. All code executes exactly how it was programmed, and barring an unlikely hard fork, actions taken on the blockchain are immutable. So this is how we ensure trustlessness in our code. We program trust into our code so that we can trust it and not each other. In fact, I'm starting to trust smart contracts more than I trust some humans. Smart contracts won't lie to you, smart contracts won't cheat on you, and smart contracts won't post angry tweets at North Korea at 02:00 a.m. On a Tuesday.
00:04:56.570 - 00:05:39.626, Speaker C: I, for one, welcome our eventual global blockchain overlords. But before we get to that point, we need to be the ones doing the building. We need to make sure that all of our applications are hacker proof, script proof, and even tech illiterate granny proof. If our tech literate grandma accidentally posts her Google search for hemorrhoid cream to Facebook, it's not a big deal. We can just delete it. But if she accidentally exposes her public key because of a poorly written smart contract or application, that's a lot bigger deal than the previous situation. And there's not much we can do once the damage has been done.
00:05:39.626 - 00:06:42.030, Speaker C: And unfortunately, her tech savvy grandson Johnny can't help her because he's too busy trying to delete his browser history from the blockchain. So in building these applications, we need to make sure we need to focus on building every application, assuming that everyone is a tech literate granny, ensuring that functions are all called correctly and operations are performed without error, because you never know, somebody might just accidentally take control of your multi signature wallet library and suicide the whole thing. So before we go into specific examples about smart contracts, we're going to talk a little bit about application security. And we've got a few vulnerabilities lined up, or patients in an emergency room that we're going to look at. We're the professors and you're the doctors, and it's exam day, so let's look at some application vulnerabilities. Beijing, Dr. Chris Brown.
00:06:42.030 - 00:06:45.870, Speaker C: We got a patient for you. Application vulnerabilities.
00:06:48.450 - 00:06:49.582, Speaker B: Hey, how's it going?
00:06:49.716 - 00:07:58.070, Speaker D: My name is Christopher Brown, as Josh said. So we're going to talk about super sweet game we developed, or gaming platform that we've developed. And of course, security was our number one priority here. But we need help in looking for what all the vulnerabilities are with this platform that we decided to build for game developers. So in this platform, developers can openly publish their games, and then players can sign up to this application on your website, and they can choose from a variety of games and then spend their ether on virtual goods. So we're totally in the browser here. Nothing wrong with that, right? So we create new wallets in the browser also, no need for a metamask or mist or anything that may be too difficult for the users.
00:07:58.070 - 00:08:23.760, Speaker D: We want to keep it simple. And then with that, we're going to take the wallet keys and we're going to store them into the player's browser to enable micro payments. So, yeah, super sweet setup, right? So let's play the game and let's see if we can diagnose any problems. So we launch our platform and.
00:08:32.970 - 00:08:34.120, Speaker B: Missed a part.
00:08:34.730 - 00:09:06.580, Speaker D: So players come in and they start. You've got developers that put in some new games, and players came into your platform and hadn't had no issues, and everything was going great. Then all of a sudden, a Reddit post comes up and somebody's complained that their entire wallet's been cleared of ether. No big deal. They can't quite put their finger on it. Several random addresses and transaction hashes out there. But then, sure enough, a couple more people come on and they know we were playing on this platform that we developed, and all my ether is gone, too.
00:09:06.580 - 00:09:59.780, Speaker D: Then you got a dozen posts complaining about this new gaming platform and all of their ethers disappeared. So of course we get on there at risk of losing 30 karma and just kind of respond with, everything's fine, nothing's wrong. These people, they must have done something on their end that exposed their wallets. Maybe they've got some malware on their computer or something. Surely it's not us because we paid attention to everything we were doing with this platform. But of course, behind the scenes we're looking at what's going on here, and we've decided that there was problems caused by this new game called Hoddlequest that somebody posted on our platform. What we found through going through the logs and such, that these wallets are actually being emptied within seconds of accessing this hoddlequest game.
00:09:59.780 - 00:10:55.190, Speaker D: So in this game, or let's backtrack, this is kind of more about our platform. So in this platform, what happens is game developers come on, they put a name into the form, then they also post a smart contract address at which their distributed game executes logic, and then they have a URL for the application for this new game. So then our platform takes this information and embeds it in our application in the web browser and makes it available for players while displaying the game's name at the top of the page. So with this information, can anybody kind of diagnose what problems this may cause that would allow somebody to get access to the players wallets?
00:10:56.730 - 00:11:05.990, Speaker B: Any ideas? Yes, sir. Okay, yeah.
00:11:07.020 - 00:11:10.200, Speaker D: Anything else? JavaScript injection.
00:11:10.540 - 00:11:11.000, Speaker B: Yes.
00:11:11.070 - 00:11:23.630, Speaker D: So he mentioned that developer can inject JavaScript code that will, or malicious JavaScript code.
00:11:24.080 - 00:11:29.628, Speaker B: Anything else? Okay, I won't hold too long, because.
00:11:29.714 - 00:12:27.324, Speaker D: Actually that's what we have up here. So the developer, and when he input the name, we didn't scrub the input, and we allowed him to put this malicious script in there, which will now go into the local storage in the player's browser, and it will pull out the private key that we put in the local storage. I know that this has been not this particular attack specifically, but I know we've kind of gotten comfortable with information wallet information in web browsers. And I'll tell you, local storage has never really been appropriate for any sensitive information. It's got its purpose elsewhere, and it's definitely something that we should consider when developing distributed applications. And we're using web browsers as a bridge, so let's kind of go through the security checklist real quick. So always protect private keys and wallets.
00:12:27.324 - 00:13:19.872, Speaker D: Of course, private keys, unless you're using a multi SiG contract, gives you all of the funds, tokens, ether inside of those wallets. Always, of course, protect user information. Nothing new about that on chain and off chain information. The blockchain, of course, has its purpose, right? We use it as a distributed ledger to record information that we would like to convey to all of the participants. But not everything has to be in the blockchain, not every process and function. We just need the specific parts that need to be conveyed in a global ledger. And so considering what goes in and what does not go into the blockchain is important.
00:13:19.872 - 00:14:05.360, Speaker D: Htps, this is standard, right? If you're using a website that's taking any information, anything less than HTTPs is just not appropriate. It's simple to get certificates nowadays, of course, when you're committing code and such, we shouldn't be putting API keys into there. We should make sure our get ignore is up to speed on what we're trying to post and then consider using two factor authentication when it makes sense for your application. So great job. Thank you for answering there. And I will now page Dr. Jessica from consensus.
00:14:07.060 - 00:14:15.830, Speaker E: Hi, everybody. Hi. Ben Siegel, the front row. All right, so I'm going to tell you guys a knock knock joke. Okay, you ready?
00:14:17.800 - 00:14:19.236, Speaker B: Head nods. Ready?
00:14:19.338 - 00:14:19.700, Speaker D: Great.
00:14:19.770 - 00:14:20.148, Speaker B: Okay.
00:14:20.234 - 00:15:05.330, Speaker E: Knock knock, raise condition. So now that we're in the world of smart contract security, for those of you who have even peeked into the solidity documentation, you know that this is a really big problem. For those of you who don't know, a race condition is a problem that arises in any system. But like here, specifically in smart contracts, where you think something's going to happen in a certain order, and then it doesn't happen in that order, and then you have lots of problems. So I'm going to talk about two race conditions in this presentation, one of them being reentrancy, the other being front running. So let's start with reentrancy. You guys remember the Dow? Yeah.
00:15:05.330 - 00:15:53.552, Speaker E: So the Dow hack occurred, as many of you probably know, because of a reentrancy bug. So what is reentrancy? So you got a smart contract. It's written in solidity. You have a function, right? You think it's going to do exactly what you think it's going to do, but then it doesn't. Basically, anytime that your contract calls another contract, an external contract, or really an external function that's untrusted, basically you're letting your baby go, right? Like at that point, you don't know what's going to happen because of that. It's really, really important to do all kinds of internal state changes before calling that external function because you don't know what's going to happen because when you call an external function, you risk control flow takeover, and then it could change your state in all sorts of bad ways. And this can happen inside a function.
00:15:53.552 - 00:15:57.200, Speaker E: It can happen cross function, and it can happen cross contract.
00:15:57.360 - 00:15:57.732, Speaker B: Cool.
00:15:57.786 - 00:16:30.910, Speaker E: We got that. Awesome. All right, so real quick, there's a couple of different ways to send ether around between contracts. There's the transfer method, there's the send method, and then there's the call value method. All of these will send ether from one contract to another, but they've got a couple of differences. Basically, when you do an address transfer, you're forwarding only a certain amount of gas, and it will revert if it fails. So basically, a revert is just when all of your transactions unwind and nothing changes.
00:16:30.910 - 00:16:56.708, Speaker E: The reason it's important that it only forwards 2300 gas is if this external contract hijacks your control flow. It's not going to get very far. Send is kind of similar, but instead of reverting on a failure, it returns false. It's also a little bit of a lower level method. So generally we don't recommend using that. We like transfer. And as for call value, call value, like you're really letting everything go.
00:16:56.708 - 00:17:22.636, Speaker E: It forwards all of the gas that you've sent to that function. So you're basically letting reentrancy have its day. There's a sub method within call value where you can specify how much gas you're going to send, which could be useful if the 2300 gas that transfer allocates for you isn't enough. Awesome, great. So now you know how to send ether and you know about reentrancy. Now we're going to look at a reentrancy attack. Oh, no, don't look at that.
00:17:22.636 - 00:17:49.300, Speaker E: Okay, so real quick, you guys know what a fallback function is. So basically, for those of you who don't know, a fallback function is a function that you put in a smart contract that doesn't have a name. That's why it's called the fallback function, and you can make it payable. So basically, if you send ether to a contract, if it has a fallback function, it'll take that ether. So, sorry, it's kind of small. Hope you guys can see it. Basically, over here, what we've got is a bank contract.
00:17:49.300 - 00:17:57.572, Speaker E: You have your mapping of balances, you have a constructor function that makes the contract happen. You have the option to deposit and to withdraw.
00:17:57.636 - 00:17:57.864, Speaker B: Right?
00:17:57.902 - 00:18:28.480, Speaker E: What could go wrong? So basically, when you deposit, it increments your specific addresses index in the balances. Mapping to whatever you deposited, the withdraw method. Does this thing over here, basically there's an if statement and it says if message sender, that's you call value. So you're sending ether if and you're sending whatever is currently in your bank account. Bank account. So basically what this is saying is if this fails, revert. Right?
00:18:28.550 - 00:18:29.170, Speaker D: Great.
00:18:29.700 - 00:18:53.492, Speaker E: Except we got kind of a problem here, because over here I've got my bank robber contract, and I'm just going to steal all of your funds. So basically what I do in the fallback function, I've decided, I've imported your bank contract code. And basically, if the bank's balance is more than what I'm trying to withdraw, I'm just going to call the withdraw method again. But wait a minute, isn't this supposed to fail?
00:18:53.556 - 00:18:53.736, Speaker D: Right.
00:18:53.758 - 00:19:17.820, Speaker E: It says if it doesn't work, if you don't have your balances, if you don't have that much money in your balance, you shouldn't be able to call that function again. Right. Except down here, you only turn your balance to zero after this lovely loop has taken out all of the funds from the contract. So this is just like a really typical example of a fallback, of a reentrancy attack via fallback.
00:19:17.980 - 00:19:18.400, Speaker D: Great.
00:19:18.470 - 00:19:35.380, Speaker E: Okay, now we got that. The next thing we're going to talk about real quick, front running. So basically what front running is. It's a race condition attack. That can happen because transactions don't have a fixed order in a block, right? So you send your transaction, you wait for it to be mined. In the meantime, it's in a public pool.
00:19:35.460 - 00:19:35.704, Speaker B: Right.
00:19:35.742 - 00:19:59.776, Speaker E: So that transaction is pending with a whole lot of other transactions. That's fine, right? I mean, the miner will get to it eventually. Except if you're doing something like a decentralized exchange. And we know like half of you are going to make decentralized exchanges in this hackathon because 2018 is the year of the decentralized exchange. So because of that, make sure your decentralized exchange is not vulnerable to front running attacks. How do you do that?
00:19:59.798 - 00:19:59.984, Speaker B: Right?
00:20:00.022 - 00:20:31.720, Speaker E: If I send my bid for, I don't know, I want a three Ben token for two Jess token. And someone's like, actually, I'll give you one Jess token for those three Ben token. Or the other way around, they undercut you, you're kind of in trouble. And if someone wants to attack your decentralized exchange, they're just going to undercut everybody in the transaction pool. So a couple of ways to mitigate that, you can do batch auctions or you can do commit reveal schemes where you send the hash of your bid and then reveal that bid later after it's been mined.
00:20:32.060 - 00:20:32.580, Speaker B: Great.
00:20:32.670 - 00:20:43.970, Speaker E: Okay, so now we're all experts. We know all about reentrancy. We know all about front running. We got patient number two. All right, so if you guys have played ether. Not. You're not allowed to answer.
00:20:43.970 - 00:21:24.680, Speaker E: What we have here is a king contract. It has two state variables, an address, the king, and a UN. So an unsigned integer prize value. So the way this starts is someone deploys the king contract and they send a certain amount of ether to it, right? So the deployer message sender becomes the king, and the prize value of the contract becomes whatever they sent to the contract. Now, I want to be king of the castle, but instead of what we did in elementary school, where you knock someone off the top of a hill, you have to send more ether than I did to this account. So basically what happens, right? So Ben Siegel here, sitting in the front row, wants to be king. He doesn't want me to be king anymore.
00:21:24.680 - 00:21:28.472, Speaker E: So he's going to send more ether than I did to this contract.
00:21:28.616 - 00:21:29.020, Speaker D: Right?
00:21:29.090 - 00:21:37.890, Speaker E: It's going to require that the amount of ether that Ben sent is more than the prize value of the contract, or it's going to require that it's me sending it again, but it's not in this case.
00:21:38.260 - 00:21:38.720, Speaker D: Great.
00:21:38.790 - 00:21:52.560, Speaker E: So Ben sent more ether than I did. He's the new king, right? Except not next. What happens is the current king, which is me, gets transferred the existing amount of funds that Ben sent me.
00:21:52.630 - 00:21:52.864, Speaker B: Great.
00:21:52.902 - 00:21:59.364, Speaker E: So I just made money. Hashtag Ponzi scheme. And then the new prize value is what Ben sent to the contract.
00:21:59.492 - 00:21:59.880, Speaker D: Right?
00:21:59.950 - 00:22:20.056, Speaker E: I mean, it's a transfer, so can't really have re entrance attack, can we? Or can we? All right, so if you want to take over this contract, and you never want anyone else to be the king, and you're willing to take the hit and just never earn that new money, what are you going to do? Anybody have an answer? Have you played ether?
00:22:20.088 - 00:22:20.236, Speaker B: Not.
00:22:20.258 - 00:22:39.988, Speaker E: You're not allowed to answer. Anybody? Anybody give you a hint? It's with the transfer function. No. Nobody? Not even Ben Siegel in the front row? No. Oh, it's okay. Ben knows I love him. No.
00:22:39.988 - 00:23:04.460, Speaker E: Oh, you have an answer? He said, I'm going to revert in my fallback function. He's right. That's one of the things I could do. I could make a contract, and I could have that contract become the king and program in that contract's fallback function that whenever anybody tries to send ether to me, I'll revert the transaction.
00:23:05.280 - 00:23:05.964, Speaker B: So great.
00:23:06.002 - 00:23:14.350, Speaker E: That's one way to do it. Now, what might be another way to do that? Same attack, but without using a revert in the fallback function. Anybody?
00:23:16.480 - 00:23:17.532, Speaker B: I'll give you a hint.
00:23:17.596 - 00:23:25.540, Speaker E: It has to do with the fact that transfer only sends 2300 ether or 2300 way gas, rather, not ether. That's a lot of ether.
00:23:27.000 - 00:23:27.750, Speaker B: Anybody?
00:23:28.120 - 00:23:29.910, Speaker E: Now? Yeah.
00:23:33.780 - 00:23:34.432, Speaker B: Exactly.
00:23:34.566 - 00:23:52.808, Speaker E: I could put something in that fallback function other than revert. What? No, I could put something in that fallback function other than revert. That'll just, like. I could be ridiculous and make a recursive function, and it will always error out of gas anyway. So. Thank you. That was great.
00:23:52.808 - 00:24:04.520, Speaker E: None of you are going to have re entrance attacks in your hackathon projects. It's gonna be excellent. All right, so, coming back to the stage, paging Dr. Joshua.
00:24:07.040 - 00:25:04.808, Speaker C: Thank you. So, just to go off, continue on what Jessica was talking about with fallback functions. Just want to have a reminder that, as she said, with the transfer function, they only have access to 2300 gas. So while that's important to focus on in other people's contracts, it's also important that in your own contracts that you don't perform too many calculations in your fallback functions, because they could be manipulated. If there's a loop in there or something like that, they could be manipulated by attackers to cause transactions to fail. But there's another catch to fallback functions, in that there's a way to get around triggering a fallback function. And this is the way an attacker can call a self destruct function within their own contract, which causes their contract to be deleted from the chain and forwards all of that contract's ether to the address that they supply as a parameter.
00:25:04.808 - 00:26:15.056, Speaker C: And in this case, it's your contract. So what does this mean? Free ether? I'd take that any day. But it's important to remember that you should not have any explicit checks in your smart contracts that expect the balance to be a certain value, because you never know, you might be richer than you thought. All right, so we're going to go over one more thing in the EVM that we need to be concerned about, and that's integer arithmetic. The first issue that we need to focus on is when we're doing calculations with integers like division, if we're worried about precision in our calculations, we need to make sure that we're focusing on moving the decimal points to the right places so that we can make the correct position precision calculating percentages or other similar things. Because as most of you know, when we're doing integer division, we only get integers in return and not decimals. Another issue that integer arithmetic in the EVM causes us to have to think about is integer overflow and underflow.
00:26:15.056 - 00:27:26.780, Speaker C: Integer overflow occurs when a computation results in a value that cannot be represented by the number of bits in a certain location. And this is a problem because if we have, say, a 256 bit integer in an addition operation, if we add two numbers together and get a result greater than two to the 256, that will overflow, causing the result to wrap around to zero, which could cause some weird issues in many parts of our smart contracts. And this has been a problem that has caused people to lose lots of ether in a few different hacks in the past. But there's an easy way around this. You can include checks in your function that check for overflow by simply just doing a few checks to make sure that the result is actually greater than the operands. But luckily you don't have to include this clunky thing in your own code because you have libraries to do that for you. There are many options out there to choose from libraries, but it's as simple as including the library in your code and calling functions from that library.
00:27:26.780 - 00:28:22.728, Speaker C: We have a suite of open source libraries that include a basic math library that does overflow and underflow, checking for a variety of different applications and for addition subtraction multiplication division that you can use. But we'll get to that later. So who's ready to save our last patient? You guys would make terrible doctors. So for this example, we have a snippet from a smart contract that deals with a dynamically sized integer array. And we'll have three functions in this example that only the owner can call. So let's look at the code. So bonus codes is our integer array, and in the first function, push bonus code, the owner can push code to the end of the array.
00:28:22.728 - 00:29:18.170, Speaker C: In the second function, pop bonus code, the owner can call it to subtract one from the length field in that array, effectively removing the last entry from that array. And then our third function, modify bonus code. The owner can supply an index to that array within the bounds of the array in order to modify one of the entries in the array. So I want everyone to look at this code for a few moments, and then I'm going to call out the name of each function and have people raise their hands if they think the vulnerability lies within that function. So we'll just give everyone, ten or 15 seconds to look at this. Be careful, the patient's slowly dying. All right, just as a hint, think about what I just talked about, some of the vulnerabilities we just discussed, because that might lead you to the solution.
00:29:18.170 - 00:30:01.290, Speaker C: All right, so everyone, if you think the vulnerability lies in the first function, raise your hand. All right, interesting choice. Second function, pop bonus code. Raise your hand if you think it's in that one. All right, got a little bit more of that time. Now, who thinks that the vulnerability lies in the third function? All right, so we've pretty contested. We got almost even amounts on the second and third functions, but that's good because the vulnerability lies in both functions because this takes two transactions to exploit.
00:30:01.290 - 00:31:19.570, Speaker C: So in this contract, we have this bonus codes array, whose length can unfortunately be decremented below zero because in the pop bonus code function, you subtract one from the length field. But when we check that the length is greater than zero, it's actually greater than or equal to zero. So that would cause the length to underflow and become two to the 256, which then means that in the next function, the owner could call modify bonus code, supplying any arbitrarily high index they want, which, as I'm sure you're realizing, could modify any location in that contract's memory. And if you have other important storage variables in your contract that could be overwritten from this, that could potentially be catastrophic. So to protect against this, you could either require that the length is only greater than zero in the require line in the second function, or you could check for underflow on a subtraction from the length field in the array, or you could do both just to be extra safe. But I would like to thank Doug Hoyt. This was his submission to the underhanded solidity coding contest.
00:31:19.570 - 00:32:37.750, Speaker C: And that's something that you guys should all check out. There's a lot of great examples for some of these vulnerabilities and some other intricate vulnerabilities that are possible in the solidity language. So what did we miss today? The thing is, we don't really know for sure. There could be some small issue that we don't find in our contracts that ends up killing the patient, or in our case, costs us or our users millions of dollars in ether. So the best we can do is to follow all the guidelines laid out in this presentation and in all the other great resources around the Internet and around the world for best practices while building these distributed applications and smart contracts. It's also important to remember that when we're writing our code. We need to test extensively, using great tools like debuggers and code coverage tools to ensure that we're reaching every possible state in our smart contract so we can know that attackers won't be able to find a small space in our contract.
00:32:37.750 - 00:33:49.170, Speaker C: They can sneak in and cause issues. And last but not least, we need to find engineers and teams who are experienced with security to audit our contracts, especially if they are mission critical to get different eyes on them and find vulnerabilities in our code. But I mentioned this before. But there's another way we can ensure the functionality and security of our code, and those are libraries solidity libraries before you sit down to write your code today, it's important to realize that there are many other great engineers out there that have written similar contracts as you that are probably tested and audited and open source that you can easily integrate into your projects. And with solidity libraries, this is easy. It's as simple as including that library in your smart contract, linking to it on chain, and using the functions in the library as if they were in your own contract. We at Modular have a set of open source libraries, over 20 open source libraries that you can integrate into your project easily.
00:33:49.170 - 00:35:07.210, Speaker C: We have solutions for basic math, tokens, linked lists, arrays, and even crowd sales, among many other things, that you can integrate in your project easily. You can just visit our repository, which I'll give you the link to later, to find detailed instructions on how to get started. So I hope now everyone feels a little bit comfortable and feels a little bit better on being safe when you're building your applications. But all that's left is to get out there and build something great. But it's important to remember that this technology is still in its infancy and we're still learning things about blockchain technology, about Ethereum, and about solidity every single day. So it's important to always stay up to date on all the best practices and documentation around the web so that we always know when there are new updates that we can integrate into our coding practice. So one of the best places to find smart contract best practices is consensus's smart contracts best practices documents.
00:35:07.210 - 00:36:02.010, Speaker C: They include examples from vulnerabilities we talked about today, as well as some others that we didn't get to. And you can also join their gitter channel to join a discussion about it. And I've included a link to our Ethereum libraries repository. If you want to get started, there's details instructions on getting those integrated into your project. I'll leave that up there for a second if anyone wants to take pictures of it. But you can also follow us on Twitter and we have a discord channel, which I'll show the link up there next. If you want to join the discussion, we're working on building a secure desktop wallet that is extensible to multiple different applications and solves a lot of the usability problems facing wallets today while still giving users full control of their funds.
00:36:02.010 - 00:36:24.420, Speaker C: So here's a link to our discord and our Twitter if you want to join the discussion. But unfortunately, we weren't able to save Johnny from a lifetime of browser history induced shame. But hopefully if we follow all the guidelines outlined in this presentation, we'll be able to save millions more from a similar fate. Thank you.
00:36:28.090 - 00:36:40.986, Speaker E: And quick plug. All of us, all three of us on stage, plus a couple more from modular, will be walking around throughout the hackathon. If you have questions and you want to ask about this in person, that's all.
00:36:41.168 - 00:37:07.200, Speaker C: Yeah. Later, all the modular guys will have orange shirts on that have our logo on it. Our product is called blossom, so you can find us and ask us any questions if you want to learn anything else or need help with your project. We're always open to answer questions. I don't know how much time we have left right now, but if anyone has any questions about security, then we're happy to answer any. Yeah.
00:37:29.230 - 00:37:29.786, Speaker B: Yeah.
00:37:29.888 - 00:37:36.940, Speaker E: No, you want to answer it? Well, hold on. It's not that you don't want to call external functions, just do everything internally first.
00:37:37.950 - 00:38:00.420, Speaker D: Yeah, and I'll just add on. We verify source code on Etherscan anytime we post a library on chain. So mainnet rank B. Robstein. All of our libraries, they're posted, the source code is there and then Etherscan, the source code is, the bytecode is verified so the functions can be seen as they are.
00:38:03.670 - 00:38:24.440, Speaker C: Our libraries have been used in many different production applications and crowd sales. So this is production tested code that's deployed on all the networks. So immutability, we'll have our addresses on all our libraries on our repository, so you can find those there that you'll be able to use. Anybody else have a question?
00:38:24.970 - 00:38:26.200, Speaker B: Yeah, thank you.
00:38:28.970 - 00:38:29.980, Speaker C: All right, thanks everyone.
