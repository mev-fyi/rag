00:00:00.410 - 00:00:23.626, Speaker A: Thank you so much for stopping by our talk. So is that too loud? It's okay. Cool. Yeah, it's working? Yeah, it's perfect. Cool. So today we'll talk about cross chain EVM calls. And this is a way for us to be able to send a call to Moonbeam's EVM from another chain within Polkadot.
00:00:23.626 - 00:01:08.606, Speaker A: And my name is Kevin Nielsen. I'm a developer relations engineer at Moonbeam, and I'm joined by Stephen Shelton, who's a senior blockchain engineer at Moonbeam. So to kind of orient ourselves a little bit into what's moonbeam and what's Moonbeam's role in a multi chain future, I'll go ahead and talk just a little bit about Moonbeam and give you a bit of background. And to do that, I also want to give you a bit of background about polka dot. So Moonbeam is a layer one blockchain running on top of polka dot. And polka dot work on polka Dot started in about 2016, and they took a pretty divergent approach at the time, which was saying that the future is going to be multichain. So now you hear everybody say that the future is multichain.
00:01:08.606 - 00:01:48.400, Speaker A: But back in 2016, that was a pretty contrarian approach, and so it gave polka dot tons of lead time in order to build up an infrastructure and a blockchain that supports this vision. And that's enabled by the relay chain, which is the layer zero. And there's a lot of networking, connectivity. And Polkadot provides you with a lot of functionality out of the box to make it easier to launch your chain on top of Polkadot. And so Polkadot calls these layer one blockchains parachains, just a fancy name for a layer one blockchain. And the idea is that they all provide some sort of specific functionality. So maybe they provide decentralized identity, smart contracts, various things like that.
00:01:48.400 - 00:02:25.146, Speaker A: But the important thing about Polkadot is that it's not meant to be just an ecosystem of a bunch of separate chains all doing their own thing. The important thing is that they're able to talk to each other if they'd like, and they can send value and they can send messages, so you can do cross chain contract calls and other things. And this is enabled by XCM, and that's what allows the chains to talk to one another. And we'll talk lots more about XCM. So XCM is just Polkadot's version of general message passing. And XCM is kind of available to you if you'd like to use it. You don't have to.
00:02:25.146 - 00:03:10.886, Speaker A: But it is available to you and you can choose to set it up with neighboring chains. And so it allows you to send messages. And we can think of this as kind of like a form of bridging, where bridging tokens is just one aspect that you can do. You can do much more, but if you'd like, you can also send tokens along with your messages. And so where this fits into Moonbeam is that Moonbeam is a hub of tons of different cross chain connections. So that includes connectivity within Polkadot via XCM. We're connected to many other chains within Polkadot, and then we also have a ton of GMP protocol integrations outside of the Polkadot ecosystem.
00:03:10.886 - 00:03:55.602, Speaker A: And that's enabled by teams like Axelar, Hyperlane, layer zero, wormhole, multichain and others. And so this allows you to do things like make a remote cross chain call to Ethereum, or avalanche or Polygon. And then you can also do things that kind of unite both sides of this. And to give you an example, let's say a particular parachain wanted to send a cross chain contract call to Ethereum, for example. But that parachain is not connected to Ethereum. So instead it can use moonbeam as a hub. It can first send a message to moonbeam, and then moonbeam can send a message via a GMP protocol to Ethereum or to that chain.
00:03:55.602 - 00:04:29.886, Speaker A: And another example just within Polkadot is interlay, for example, provides an insured form of bitcoin. And you can then go ahead and use that bitcoin in DFI on moonbeam. And so that works by the interlay. BTC is moved as an XC 20, which is a cross chain asset. And then that can be used in DFI very seamlessly. And the reason that we're so excited about this is because we want to provide users with much better user experiences. So we know that the future is going to be multichain.
00:04:29.886 - 00:05:08.510, Speaker A: We have roll ups, we have app chains, we have L2s. I hear people talking about layer threes. There's so many chains, there's a proliferation. And so we don't envision the genie going back in the bottle. We think that there's going to continue to be a huge number of chains, and we want to work to support that. And so in our minds, do we want users to have an experience where they're bridging from chain to chain, trying to get the native token and then switching their network in metamask? Or do we envision one where they're on a chain like moonbeam. And they're able to interact with many different chains under the hood in a seamless manner.
00:05:08.510 - 00:05:47.318, Speaker A: And with this, they're able to pay for the cross chain transaction on moonbeam. They don't need to go and get another gas token. They're able to do it all under the hood, interacting with many different chains. And to just give a quick example of this, actually within Polkadot, is that Lido has a liquid dot product. And as you may know, you don't have smart contracts that are deployed to the Polkadot relay chain. So instead, Lido deployed their smart contracts onto Moonbeam. And you can take your XC dot, which is a cross chain version of Dot just called XcDOT.
00:05:47.318 - 00:06:17.750, Speaker A: And you can take that and you can stake it in Lido smart contracts. And Lido smart contracts will then take that XC dot, it'll move it up to the Polkadot relay chain, all in a trustless manner, and then it will stake that. And this is one single interaction, one single click. There's quite a lot that's going on behind the scenes, but it's a seamless, very easy experience for the end user. So this is something that's quite powerful. And Stephen's going to tell you a little bit more about XCM.
00:06:19.530 - 00:07:03.166, Speaker B: All right, so we looked at some of the things that XCM can do, and I'll talk a little bit about what exactly XCM is. So at its core, XCm is really just a list of instructions that one chain wants to send to another chain and ask it to perform on its behalf. So these instructions are really granular and they generally don't do anything interesting by themselves. So, as an example, if I asked you to stand up, we wouldn't really accomplish anything. But if I asked you to stand up, take ten paces to the left and then flip the switch, I could get you to turn the light on or off. And so this is kind of how XCM instructions come together to do really interesting things. So one trivial example of this is getting a chain to send tokens to another chain.
00:07:03.166 - 00:08:00.806, Speaker B: But perhaps a more interesting example when we're going to go into today, is asking another chain to do some native functionality on itself, on our behalf, and so on. Moonbeam, one of the things that we have to worry about is that we don't know what a source account looks like. So if we have Alice on polka dot, we really don't know anything about, necessarily about what her account id looks like, how long it is, how it was hashed, or any of the security properties of that, and we can't make any assumptions that it's ethereum compatible. And so what we do to get around this is we take the Blake 256 hash of the multilocation and then truncate that to 20 bytes. And this 20 bytes is then an ethereum compatible account id. And so a multilocation is really just a way to represent some other account relative to us. So in this case, we represent Alice on the polka dot relay chain relative to us.
00:08:00.806 - 00:08:59.714, Speaker B: And we call this a multi location derivative account on Moonbeam. And so here's kind of an example where Alice is going to ask her relay chain to send an XCM to Moonbeam and she's going to ask it to do some call which is encoded as some bytes representing an encoded call. So if she were to do this, send it over to Moonbeam, the first thing we would do is derive this multi location derivative account id for her. And then if everything checks out, we will go ahead and make the call that she requested on her behalf. So it would look as though it came from this derivative account and not from Alice on Polkadot. And so we'll talk a little bit more about a more specific example of using Moonbeam's EVM through XCM. So Moonbeam is connected to other pair chains into the relay chain.
00:08:59.714 - 00:09:42.050, Speaker B: And so it's going to get these XCM messages. And one of the things that it needs to do is make sure that these messages are valid for us. And so the main thing that this really means is that it attaches some way to pay for fees, which we'll take a closer look at later. But if an Xiom instruction checks out and there's a transact call that wants to invoke the EVM, then we'll invoke the EVM and it'll look just like a normal contract call in the EVM at that point. So here's kind of an under the hood look at moonbeam. So we'll see a lot of the same pieces that we would find elsewhere. We have a user who's going to send a ECDSA signed transaction.
00:09:42.050 - 00:10:21.010, Speaker B: It'll go to some RPC service, and this RPC service will be able to put it into a transaction pool which can do some validation on the transaction. If everything looks good, this transaction could be played against the EVM and we could observe some state change. At that point, when we go through XCM, things look a little bit different. So, as we talked about earlier, we don't know much about the signature of the transaction or the account id. So we derive a multi location derivative account id that we talked about. And then we also need to make a couple other changes before it goes into the EVM. And we do this through what we call our palette Ethereum XCM.
00:10:21.010 - 00:10:51.574, Speaker B: But once we've done all this, it can go into the EVM just like a normal transaction would. And we would be able to observe state changes just as before. So some of the other changes that we need to make, because there's no signature, it's possible for two different transactions with the same inputs to produce a hash collision. And so we get around this by just introducing a nonce. In this case it's a global nonce. And so we salt the transaction with a unique number. Also because there's no signature, there's no EC recover.
00:10:51.574 - 00:11:27.682, Speaker B: So there's no way to derive the public key or an account id from the transaction itself. And so what we do is we replace the from in the message sender when it's in the EVM with the multi location derivative account id that we talked about. And then finally we also set the gas price to zero. And the reason for this is because XCM itself has a mechanism for charging for fees. Note that while we do set the gas price to zero, we also do have a normal gas limit. And this is respected in the normal way in the EVM. And so if we were to submit something like this, we could then do a request for get transaction by hash.
00:11:27.682 - 00:11:58.500, Speaker B: There's an example on the right of using curl to do this. And if we were to do this, we might get something that looks a little bit like this. So this looks pretty normal. But what we've done here is we've replaced the nonce with our global nonce. Our from is now the multi location derivative account id representing Alice on Polkadot. And we've replaced our gas fields with zeros, although there is still gas being consumed. And then finally we have set our VR and s to some arbitrary constants because they're entirely unusual in this case.
00:11:58.500 - 00:12:02.522, Speaker B: Go ahead.
00:12:02.656 - 00:12:24.306, Speaker A: Cool. So we're going to show a really cool. We have a demo and just due to the Wifi situation, we took a bunch of screenshots and we wanted to make sure. We're going to take you through step by step exactly what we'd be doing. And it'll be smoother than doing this live. And so what we're going to do is we're going to make a swap on Moonbase alpha. It's a uniswap clone here.
00:12:24.306 - 00:13:11.018, Speaker A: And we're going to trigger this swap via XCM and I'll be walking you through the beginning of the flow and Stephen's going to take you into more detail. So to just kind of start from an overview, we're going to be starting from the Polkadot relay chain. And so let's say Alice has an account on Polkadot. So we're going to build an XCM message there and then we're going to send that XCM to moonbeam. So we'll specify what the destination chain is and then this XCM message will be looked at, it'll be analyzed, and it will eventually dispatch an EVM call. But there's an important step here, and that's that. First, this EVM call is going to be dispatched from a multi location derivative account.
00:13:11.018 - 00:13:48.620, Speaker A: So what the heck is this and why is it important? Well, Polkadot uses a different type of account structure than Ethereum. And for Moonbeam's Ethereum compatibility, it was very important that we used Ethereum accounts. We want to provide a very seamless experience and having an Ethereum account is crucial and critical to this. So we don't assume that Alice has an account on Moonbeam. And so instead we create a derivative account that belongs to Alice. She's the only one that can control it and only via XCM. And so nobody knows the private keys to this account.
00:13:48.620 - 00:14:39.718, Speaker A: It's a special type of account and you can send funds to it and then you can control the funds that are in this account, call various contracts and do anything you'd like. But all these instructions need to come via XDM. So this EVM call will be executed and we're going to have to pre fund the multi location derivative account with whatever funds we want to swap. So we need to make sure that they're already there and we're going to make the swap. And then of course, whatever the outcome of the swap is, the tokens that we get will go to that multi location derivative account and to go through kind of step by step on what we're going to do in the demo, we're first going to get the call data from the uniswap swap. So we'll go ahead and prepare our transaction. We'll go ahead and initiate it and it'll open up in metamask and we'll copy the hex call data.
00:14:39.718 - 00:15:31.422, Speaker A: We won't actually submit the transaction at this point, but what we'll do is we'll take the call data from that call. We're going to make some changes to it to make it more friendly. To our demo. And then what we'll do is we will build a call within the Ethereum XCM palette and the Ethereum XCM palette enables these remote EVM calls. Then what we're going to do is we're going to go and take the encoded call data that we've just built and we've built this on Moonbeam and we're going to take that and we're essentially going to drop it into an XCM message. And we're going to drop it into an XCM message that starts on Polkadot. And so we're going to have to include a bunch of parameters where the message is going, how much gas, which would be in the ethereum XCM call, and we're also going to include a weight and different things like that.
00:15:31.422 - 00:15:39.390, Speaker A: And finally we're going to send it. And once we send it, we'll be able to look at it later and it'll look just like a normal EVM transaction.
00:15:43.340 - 00:16:28.992, Speaker B: All right, well, let's go ahead and jump in. So what we have here is a uniswap deployment on our local testnet, our moonbeam testnet, and we also have a UI along with it. I want to point out real quick that while we're going to do this kind of the long handed way and show all the details, we would expect that a normal product would have a much nicer ux, probably just a one click ux, to pretty much do everything that we're about to do. So what we do here is we want to build up the low level EVM call data. And as kind of a shortcut to that, what we do is start with the uniswap UI. So we have here a swap that we've set up between Dev and Mars tokens. And we're going to start out by starting with metamask.
00:16:28.992 - 00:17:23.972, Speaker B: But rather than send the transaction, we'll click on the hex tab where we can scrape out the call data. So here we have the call data and we're going to dissect it a little bit and replace a couple of things. So we start off by seeing that the function selector maps to swap exact eth for tokens and then there's a few different fields here, we're going to replace a couple of them. So since we're doing this by hand and it might take a while, we'll replace the deadline and we'll also increase the slippage amount just in case the price moves on us. But more importantly, we're going to replace the account id with the multi location derivative account id representing Alice that we talked about earlier. So now that we've done this, we've got our modified call data and this is something that we could send into Moonbeam's EVM. And so what we'll do is we'll go ahead and copy that and we're going to place it inside another layer here.
00:17:23.972 - 00:18:00.080, Speaker B: So we're kind of doing an encapsulation technique where we have the low level call data, EVM call data, and we're going to place it inside kind of a higher level call data. And then we'll eventually go over to Polkadot and send it as an XCM. So what we're looking at here is sort of a crude UI that wraps the low level functionality of moonbeam. And you'll find the same UI exists for most blockchains inside the polkadot ecosystem. And so we're going to use it to build up kind of our second layer here. So what we have is we're requesting a call to the palette Ethereum XCM. And we want to invoke its transact call.
00:18:00.080 - 00:18:38.184, Speaker B: So a palette is in a lot of ways like a smart contract where it is addressable and it has functions that you can call. And so we're setting up a transact call here. And here are the parameters that we're going to send to it. These look a lot like an Ethereum transaction. We've got gas limit, we've got an action which is a call as opposed to a create as well as a value. And then finally our input is the low level EVM call data that we just looked at before. So once we do all this, we build up sort of the second layer, which is our encoded call data representing everything above, basically the Ethereum XCM transact call.
00:18:38.184 - 00:19:09.544, Speaker B: And of course, inside of that is our EVM call data. So now that we've done this, we can take this call data and we can move over to Polkadot. Well, in this case, it's really our testnet version of Polkadot. And so we see the same UI here, except it is a different blockchain. This is now Polkadot. So we have Alice here who wants to invoke the XCM palette and its send function. So what she's going to do is tell the send function where it needs to go.
00:19:09.544 - 00:19:40.412, Speaker B: So we see again another multilocation. And this time the multilocation represents moonbeam itself. So we're now on polka dot and we need a multilocation that represents moonbeam relative to polka dot. And so again, we use a multilocation to do that. So here we've got parachain 1000 inside of our multilocation, which is how we point to moonbeam. So from there we need to fill in the list of instructions that we were talking about earlier. And so in this case, we start out with a withdraw asset instruction.
00:19:40.412 - 00:20:20.892, Speaker B: And what this does is it takes funds held under Alice's control and it moves it into what we call a holding register. And a holding register is really just an XCM thing where we have assets held for the duration of an XCM call. And then, so once we have those funds in the holding register, we can invoke a buy execution instruction. And this is just a way to use those funds in the holding register to pay for fees. And now we get to the important part, which is the transact instruction. And so this transact instruction will tell Moonbeam that it wants to invoke some native functionality on its chain. And then we see here again our encoded bytes that we were just playing with on Ethereum.
00:20:20.892 - 00:21:11.116, Speaker B: So now these encoded bytes are the ones that represent the palette Ethereum XCM call. And of course, again, they have inside of it the EVM call. So this whole thing is being built up into XCM message with the embedded call data and it's going to be shipped over to moonbeam. Finally we see the deposit asset and this is really just a way to refund unspent fees. So if Alice were to do all this and hit submit, what would happen is we take this XCM message, it gets routed over to moonbeam. Moonbeam unpacks it and finds the encoded call data, realizes that it needs to use that to invoke the palette Ethereum XCM palette inside that it finds the EVM data, invokes the EVM with that, which causes a call to the uniswap contract. And finally we see that there's a swap for the tokens that we looked at earlier.
00:21:11.116 - 00:21:52.828, Speaker B: So if we were to do all this and then look at our moonscan explorer here, we would see that we indeed had some tokens transferred. Notice that the from field is Alice's multi location derivative account id. And we also have a zero transaction fee. And so that's just because we set the gas price to zero, although we did respect the gas limit. And finally we could then call gettransaction by hash again and we would get something like this. As before, we've replaced the global nonce, the nonce with our global nonce replace from with our derivative account. And we've set the gas prices to zero.
00:21:52.828 - 00:21:57.900, Speaker B: And again, our vrns constants or our vrns fields are their useless constants.
00:22:02.640 - 00:23:15.430, Speaker A: Cool. So just to conclude, why are we so excited about remote EVM calls? Just to kind of take you on a journey, right? With XCM and kind of interoperability within Polkadot, we've been able to transfer assets between chains for quite some time now. Then we were able to have remote execution of substrate functions. So you could use the substrate API and you can transfer and you can stake and you can do specific functions. But we were really waiting and excited and the engineering team was hard at work in order to build this remote EVM call functionality because it unleashes really unlimited possibilities and it realizes kind of Polkadot's vision of interoperability, that is, to have this union of connected chains which can share features and offer their diverse feature set to other chains. And when we say this, we don't assume that somebody knows about Moonbeam, that they have an account on Moonbeam, that they have any gas or glimmer for funds for gas. And so to this, somebody could kind of think of this optionality as Moonbeam providing an EVM as a service.
00:23:15.430 - 00:23:51.532, Speaker A: And lastly, Moonbeam is very well positioned as kind of a gateway and a bridge hub for accessing all the different Polkadot chains and also connecting to many different ecosystems outside of Polkadot. And so that's something that we're very excited about. And I think we have a couple of minutes left. And so I just wanted to give a shout out to some of our bounties. We have two, and of course, the first one is on remote contract calls. And so you can use XCM to do a remote EVM call. That is certainly an option.
00:23:51.532 - 00:24:35.356, Speaker A: And we also have a couple other options here. You can use any GMP protocol to make a cross chain contract call. So you can use axilar layer zero, hyperlane, you can use any of those wormhole as well. And we leave it up to you whether you want to make the call to or from Moonbeam or Moonbase alpha. So, meaning you can make a call from Moonbeam to ethereum or ethereum to moonbeam. It's totally up to you, and we encourage you to be ambitious and it's best to try something that's challenging rather than perfect a simple cross chain interaction. And the second bounty also follows the trend of improving the end user experience.
00:24:35.356 - 00:25:19.416, Speaker A: And to that end, Moonbeam has a ton of powerful precompiles that offer some really unique and really powerful features. So one is the batch precompile and that allows you to combine transactions into a single call. The classic example here is you're making a swap on a Dex, and rather than doing an approval transaction, waiting for it to be confirmed and then doing a swap transaction, you can instead batch those together into a single atomic call if you'd like. And you can choose whether you want it to be atomic or whether you want it to not be atomic. And maybe one of the calls could succeed and one of them could fail. The next one is the call permit. Precompile, and this allows you to turn any EVM call.
00:25:19.416 - 00:25:46.060, Speaker A: The user can sign it and authorize any EVM call, and then this could be dispatched via a provider like biconomy. And we have a couple ideas here. You can build anything you want, but just to kind of get you thinking, you could build an auction. You could build a dead man switch. There's tons of options. So for both of these, we have first and second place for each of these. So in total, that's up to four prizes.
00:25:46.060 - 00:26:19.118, Speaker A: And first place for each of these is $4,000 bounty. And second place prize for each of these is a $1,000 bounty. We have a booth upstairs, which is underneath the giant red or orange sign that says devtobia. Steven and I will also hang out outside here, outside the talk in case you want to talk about anything further. And I think we do have a couple minutes for questions. So we warmly welcome any. Yeah, yeah, go ahead.
00:26:19.118 - 00:26:35.014, Speaker A: Up in the sweater. I think. What's the best way to get going on the bounties? Yeah, I was just curious about how to get going on the bounties. Sure. For sure. So we have a. Which bounty in particular were you thinking of? The first one.
00:26:35.014 - 00:26:53.506, Speaker A: The first one, sure. So we have this Moon Builders hackathon survival guide. I'll show you a link to it right now, actually. Oh, the Wi Fi situation. Okay. Yeah, it's it. We have it in the discord.
00:26:53.506 - 00:27:12.946, Speaker A: So if you go to the Moonbeam discord or the Moonbeam channel in the ETH, Denver discord. And you can also Google search moon builders hackathon survival guide. But we have a bunch of tutorials there for how to get started using axilar layer zero wormhole. Moonbeam builders hacker survival guide. Yeah, that's right. Okay. Yeah.
00:27:12.946 - 00:27:33.500, Speaker A: Moonbeam moon builders hackathon survival guide. And we have tutorials for how to get started with axilar and all the others. And the best thing is to do is to build, like, send a simple cross chain message just to see how it works. And then to get started on building your dap. And there was another question here.
00:27:35.870 - 00:27:48.122, Speaker B: So the relationship between XCM and connects. So is XCM the way in which Axelr is able to connect with Polkadot chains?
00:27:48.186 - 00:27:49.520, Speaker A: That's not how that works.
00:27:50.050 - 00:28:10.114, Speaker B: No. So those are completely different things. So XCM is separate from the EVM? Completely. We've kind of hooked it up. So we talked about invoking the EVM through XCM, but we also have a way for you to use the XCM from EVM itself. But technically, those are completely separate things, except that we've kind of hooked them up and made them available through our EVM.
00:28:10.242 - 00:28:10.678, Speaker A: Okay.
00:28:10.764 - 00:28:11.542, Speaker B: Does that explain it?
00:28:11.596 - 00:28:23.430, Speaker A: Yeah. Thank you. Sweet. Well, thank you so much for joining us. Really appreciate your time and attention today.
