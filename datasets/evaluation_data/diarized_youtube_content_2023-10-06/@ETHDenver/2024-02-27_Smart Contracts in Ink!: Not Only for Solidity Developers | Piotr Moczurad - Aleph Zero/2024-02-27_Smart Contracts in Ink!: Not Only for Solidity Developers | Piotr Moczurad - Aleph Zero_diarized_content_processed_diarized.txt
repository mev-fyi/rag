00:00:08.010 - 00:00:50.220, Speaker A: Hey everyone, it's great to be back here for one more year. And welcome to the workshop about smart contracts in Inc. Targeted not only at developers coming from solidity, but pretty much at everyone who wants to give writing smart contracts a try. And if you've seen the workshop last year, this year is going to be very different. As you can see, there will be no slides, there will be just me live coding. So the best case scenario is that we're all going to have some fun and learn some ink smart contracts. The worst case scenario is that everything goes wrong and this will be a cautionary tale not to do live coding ever.
00:00:50.220 - 00:01:48.606, Speaker A: But yeah, let's jump right to it. So on the right hand side here, I have a contract that I basically copied over from solidity tutorial documentation and it's this very simple, very simple fungible token, almost an ERC 20, but not quite. It's missing some functionality. And what we're going to try to do, and hopefully we'll succeed, is we're going to take this exact contract and rewrite the same functionality in ink, which is the language that you can use on some of the substrate blockchains. First and foremost on the alf zero blockchain that I have the logo here on my chest. And before we start, you're going to see quite a lot of code. So you might think, why write this much code? Well, there's always a trade off.
00:01:48.606 - 00:02:41.134, Speaker A: And the trade off we are making here is that we are writing code that's perhaps slightly more involved, but a lot safer. So you're going to see some examples of how this actually increases the safety and robustness of our smart contract. So normally what we would do to start is basically, well, we need to install some tooling. So I have this cargo contract installed in a pretty new version. Then I have of course a rust compiler because ink is essentially a DSL, a domain specific language built on top of rust. So I also have rust in the latest stable version. And yeah, that's pretty much all we need to get started.
00:02:41.134 - 00:03:22.922, Speaker A: And normally I would just write cargo contract new and call it probably East Denver. I'm not going to do it because I've done it beforehand, just to save some time on downloading the contract. Now it's all set up and I also removed the comments and some of the tests just to keep it super streamlined, super focused. So we just have the very basics. This is essentially what you get when you're starting out with ink. So the lines starting with the hash signs are not comments as you might be used to from Python or similar languages. These are macros.
00:03:22.922 - 00:04:24.094, Speaker A: That's because the philosophy of ink is why create a separate language if we can just take rust, which is a great modern language and with very safe set of features, and just add some macros so that it's tailored more towards writing code that's going to be executed on chain. So you're going to see that we're in solidity. We write the keyword contract, and then the name here we just write a regular rust module. If you're not familiar with Rust, the module is basically a collection of things, kind of like a namespace from other programming languages. And then we need to put the ink contract macro on top of the module declaration. It just basically sorts out several things for us so that we don't have to write as much code and makes it deployable on chain. Okay, so to start, let's examine what the storage looks like in the solidity contract.
00:04:24.094 - 00:05:28.930, Speaker A: Because, well, in solidity and in ink as well, a contract needs some storage, it needs to store data on chain. So here we have the minter address, which I'm probably going to call owner in our code, because it's like semantically a bit more correct, and then a mapping from an address to basically the amount of tokens that someone has. And this is how we do this very simple fungible token. So let's do just that in ink. Before we start, the way that you declare storage in ink is you basically take a regular rust struct, which is very similar to a class in many object oriented languages, or basically to an object, or a struct in C plus plus, for example. And we need to put the ink storage macro on top, just so that the compiler knows that it needs to figure out the memory layout and how to put it on chain. The storage macro is necessary.
00:05:28.930 - 00:06:20.838, Speaker A: What's important is that the contract can only have a single storage struct. It of course, can use many other structs internally, but the storage needs to be a single struct. Of course, it can be arbitrarily complex. So now we don't need the Boolean value, we're just going to need an owner, which is going to be an account id. You'll notice that I'm not importing the account id, and that's because it's one of the things that the ink contract macro does for us, right? It declares some types and aliases for us to use. And now before I can use the mapping, I'm going to quickly import it and it's not so much an import as bringing some name into the namespace, right? There's no magic happening. Basically.
00:06:20.838 - 00:07:29.274, Speaker A: Now I can just use this name. So I'm just going to say, okay, balances is a mapping, and same as in our solidity contract, it's going to be a mapping from the account address here we are calling it account id to a balance. And what we can do is I can put an unsigned 128 bit integer as the value that's actually going to hold our balances. There's also the balance type you can use, but it comes with some strings attached, so I'm just going to use the unsigned integer type similarly to what we have in solidity. One notable difference is that in solidity by default you have 256 bits for every number. Basically here the max is 128, partially for performance reasons, but if you need more there's libraries, or you can kind of model it as an array of two such numbers, or four u. It's pretty easy to do.
00:07:29.274 - 00:08:29.694, Speaker A: Now, since we've changed our storage of our default contract here, we're going to take a look now at the constructor. The constructor and all of the methods that we call messages are put inside the implementation block here. This is basically the functionality that we attach to the struct here. So the constructor is one such method, and similarly to what you have in solidity with the constructor keyword, you have just a regular method here with the constructor macro. And importantly, a contract needs to have at least one constructor, but can have arbitrarily many, and they don't have to be named in any specific way. But of course you want to choose a name that kind of makes sense, right? Like new or maybe, I don't know, initialize. So we're just going to, oh, if you're not familiar with the syntax of rust functions, basically the fn keyword is how you define a function.
00:08:29.694 - 00:09:13.754, Speaker A: You can make it public, or by default they are kind of restricted to the module you're declaring them in. And here next comes of course, the name of the function, the argument list along with types and the return type here the return type is self. It's actually the same as writing coin here, but self is a bit more generic, so rust developers tend to use this way. And now we need to create our values inside the struct. So let's say that you declare the values with let. The owner is, we need to somehow get the caller of this constructor. So obviously the person who's calling the constructor is the owner of the contract.
00:09:13.754 - 00:09:50.970, Speaker A: Right. They are creating it. So just as we would do message sender in solidity here, we have a slightly different way. We're going to use the magic env method on the class itself and we're going to use the color method. It's going to give us the color of this method, unsurprisingly, and then the balances. What we're going to do is we're going to take the mapping class and create a default mapping, which is going to be the empty mapping. Basically, Rust has this idea that basically you can have default values of stuff.
00:09:50.970 - 00:10:31.522, Speaker A: If you implement the default trait for some type, you can specify what's the default value. Usually for number types, the default value is zero. For collection types, the default value is an empty collection. So for mapping, the default mapping will be an empty one, which is kind of convenient because no one has entered any data yet. Now we need to return the instance of our storage, so maybe let's format it slightly nicer. So the first field is called the owner, and we're going to put the owner here. And the second field is called balances.
00:10:31.522 - 00:11:01.840, Speaker A: And we're going to put our balances here. And now you'll notice that we were repeating ourselves with the name and the value that we put there. So actually there's a shorthand syntax like this. And if the name of the field and the value you're assigning to it match, you can do it like this. It's just a syntactic sugar, but nice. We don't need the default constructor because we kind of already have one. Okay, so we kind of have the storage taken care of.
00:11:01.840 - 00:12:05.540, Speaker A: Now we can probably remove the flip because the default contract is a simple flipper that just flips a boolean value. But we're going to do the mint method. So in order to create a message, so not just any regular function, but a message which is basically a function of your contract that you expose to the outside world that's going to be called by different clients, by the users. You need to create a public function and mark it with the ink message macro. You're probably beginning to see a pattern here of marking different things with the ink something macro instead of get. We're going to have a mint function and yeah, let's see how we can implement it so that it's safe and doesn't fail. Now, for now we're not going to return a boolean, but bear with me.
00:12:05.540 - 00:12:48.066, Speaker A: So the first thing that the, oh, by the way, an ink contract needs to have at least one message, right? It can have more, obviously, but at least one needs to be present, just as at least one constructor needs to be present. Now, the arguments of such a message need to be a self. So this is basically a reference to the contract itself, to its storage, and it needs to be either a reference to self or a mutable reference to self. What that is, we'll see in a minute. But then comes the rest of the argument list. So it's pretty simple. They call it receiver, and that will be an account id.
00:12:48.066 - 00:13:51.960, Speaker A: I'm just in a very dumb way, I'm just kind of rewriting the contract here, and there is going to be an amount, which is you 28. Now, the first thing that we do here on the right in solidity is check if the person calling the mint function is actually the minter or the owner. In our case, it makes sense. If you have a token, you don't want to allow anyone to mint the coin. Obviously, just the admin in this case can mint the coin. So we could repeat what solidity does here with the require in ink. We could write just an assert macro, but that's kind of not the rust way of doing things, because rust likes to, because, well, what the require does is it basically will abort the whole transaction if it fails, right? So we can take a bit more control of how we handle our errors and do it in a more type safe way, I would say so.
00:13:51.960 - 00:14:24.320, Speaker A: First, let's kind of just similarly to what we did before, let's say the color of our message. Again, using the magic method, you might wonder why. Here we are using self dot NF, and in the constructor we were using kind of like the class name NF. This is because in the constructor we didn't have the instance of the contract yet, so we were kind of using this special syntax. And in case of the method that the self is here ready to be used. So we can just make use of that. Okay, we have the color.
00:14:24.320 - 00:15:29.526, Speaker A: You can see by the way that my ide is nicely inferring the types here. I don't need to write them explicitly. This is actually a pretty cool feature. So now rewriting again, basically, if the color is different from our owner, this is, by the way, how we reference the struct fields, just regular dot syntax. If the color is different than the owner, what do we do? Well, one thing we could do, which would be kind of like the solidity way, is just to call like panic here, abort everything, but we're actually going to do something again, more rust like and a bit more type safe and maybe giving you more control over the error handling. We're going to create an error type, okay? So we do that by creating an enum. Enum, you can think of it as basically Rust's flavor of like a variant type.
00:15:29.526 - 00:16:03.454, Speaker A: It can be a type that can take several forms. So in our case, well, let's call it coin error. Okay. And coin error will be one of the following things. Well, let's just write one variant right now. Let's call it unauthorized and just leave it like that. And now I'm going to do a very dirty trick because like I said, the compiler needs to know for stuff that you actually put on chain or like return from the contract, the compiler needs to know what's the memory layout and so on.
00:16:03.454 - 00:16:56.802, Speaker A: So we have a few handy macros that do this for us. But to keep this short, I'm going to show you kind of how you can do it in your code without tons of googling. So we're just going to go to this page, maybe you can see this is the PSP 22 repo of the cardinal cryptography repository, which is the company behind the Aladd zero blockchain. And this is our implementation. Basically PSP 22 is like the substrate equivalent of the ERC 20 token. So what we're going to do is kind of like steal a line of code from here so you can see that there's an error declared and there's some magic macros on the top. So I'm just going to go ahead and copy that as you should.
00:16:56.802 - 00:18:01.618, Speaker A: Probably like reusing is a good thing. Yeah. So what this does is it basically automatically derives certain things for you. So like the debug allows you to print your objects in a user friendly way, partial EQ and EQ basically derive the ability to compare these objects using equality without getting too much into it. This is what we will need. And then this is a handy macro that basically derives the scale encoding of this struct and scale is a system of the substrate blockchains use. It's a system of assigning weights to certain instructions and to certain structs to kind of let the blockchain know how much gas will be consumed when executing certain instructions or putting certain elements on the blockchain.
00:18:01.618 - 00:18:49.430, Speaker A: So once we've done that, we have the coin error, which is already pretty cool because now what we can do is we can say, okay, so this mint method, it doesn't return a boolean, it doesn't return just nothing and just throws an exception, it returns a result that's a special rust type that I'm going to explain in a second. A result basically as a type that can be one of two things, either the happy case or the error case. So in the happy case, we want to pretty much return nothing. Well, the minting went well. We return nothing. Well, nothing in rust is written as two empty parentheses. It's similar to some other languages, like, for example, Haskell.
00:18:49.430 - 00:19:50.828, Speaker A: But in case an error happens, what we're going to do is we're going to return, you've probably guessed it, a coin error. Okay, so coming back to our checking of the owner, if the caller is not an owner, what we want to do is we want to return an error variant of the result that's going to contain a coin error and specifically the unauthorized variant. Right. That's cool. And we're going to come back to that a little later. But this, oh, maybe, actually, maybe I will explain a bit more about the result type. Basically, the result type is also an enum that is going to look something like this, right? It's going to be this or this.
00:19:50.828 - 00:21:01.358, Speaker A: So essentially a type that can take two forms, either an okay with something inside, like the intended result of the computations, or an error with any error message type, or like an exception type that you choose. Of course, these magic letters here are the type parameters, because you can reuse it in various scenarios, supplying different types here. Yeah, so we've got the error case handled. So now we want to, we can actually simplify that later, but now let's move on to actually updating the balances. So what we're going to do is we're going to check what the receiver balance is right now, and we're going to do it by taking our balances mapping and getting what's stored under the receiver key. Right. But as you can see, probably by now, Rusk has a very cautious way of handling errors, and, well, when we're getting something from the mapping, it's entirely possible that this thing we're getting is not inside the mapping.
00:21:01.358 - 00:21:44.538, Speaker A: So instead of just returning a value or exploding essentially, rust uses a very similar concept to our result type. It's called option, and it can be something or it can be nothing. So we're going to handle it in a shorthand way. We can say unwrap, or, which is basically saying, okay, take what's under the receiver key in the mapping. Right. This is exactly the same as solidity does here, but we're going to say if there is no such key. So basically an account that hasn't yet used our contract, we will return zero instead.
00:21:44.538 - 00:22:43.522, Speaker A: Right. Which makes sense. Someone who's not using the contract has a balance of zero, and it actually tracks quite well in the whole bookkeeping analogy here. Now what we're going to do is now we're going to insert, sorry, insert into the balances what we've got previously under the receiver key, obviously, and the value is going to be, well, the receiver balance that we have had previously and the amount. Okay, this makes sense. The magic reference here is just a requirement of the insert method, unless I'm mistaken, which we'll find out soon enough. But assuming I got this right and this all went well, now we can just return the okay type okay variant of our result.
00:22:43.522 - 00:23:51.738, Speaker A: And since we declared that inside the result, we have nothing, we need to put nothing here as well. Okay, now here is another aspect of rust that many of you, coming from very dynamically typed and nimble languages, might find annoying, but it's actually super helpful in writing safe contracts. So basically what Russ is saying here, I have the Rust analyzer here is, Russ is, wait, hold up. You cannot change the balances if you haven't declared that you're going to be changing the storage. Right. This is important because I would say that inadvertently mutating something is like the source of a good portion of the errors that happen in the code. So what we need to do is basically say, okay, so our contract, we need to kind of have a mutable reference to it so that we can, you guessed it, mutate it right now it looks good.
00:23:51.738 - 00:24:58.112, Speaker A: So I think I've talked enough now let's try and compile it. We're going to do cargo contract build cargo, because I think I haven't mentioned, it's basically like a tool for managing the packages in rust and building and doing some auxiliary operations if you're used to solidity. It actually is quite similar to using hard hat, I would say. So, cargo contract build, and we've got a few problems here. Now it says that we don't have a default implementation for coin, which is, well, let's add it. It's basically the new versions of Rust want you to have default implementations for. You can see that we can actually use this error here to do a lot of the work for us.
00:24:58.112 - 00:25:41.852, Speaker A: I can just write default self is going to be just self new. This is maybe not too smart, but good practice to have default versions of your struct. And that's okay, I'll run it again. But you'll see that we have one more error. And this is a linting error, not necessarily a compilation error, but actually super helpful again. So I don't know if anyone in the audience is familiar with the batch overflow hack, but basically what can happen if you're dealing with fixed length numbers like the U 128 here, or actually the solidity counterpart as well, is that it only can store numbers up to a certain length. Right.
00:25:41.852 - 00:26:21.530, Speaker A: If you go over that, it kind of wraps around and you start going from zero up again. And if you're clever, you can leverage it to basically get free tokens if the contract is written without sufficient care. And here is actually kind of what could happen here, right. So if we made the amount here sufficiently large, we could kind of wrap around and actually insert a very small balance for the receiver. So it's super helpful. It's kind of annoying, but also super helpful. That rust, well, actually, cargo contract makes us kind of do checked arithmetics here.
00:26:21.530 - 00:27:37.568, Speaker A: I'm going to do it the faster way. So what we're going to do is basically every number type in rust exposes these checked variants of arithmetic operations, and we're going to do checked add amount. I'm not sure my parentheses are matched. Yeah, now, and since checked add, well, it's basically a safe variant of the arithmetics, right. If you add two numbers and they end up not fitting in the number type that we're operating on, it will return a non like nothing similarly to what you would get from the mapping if there was no key that you're looking for. So instead of using like unwrap or something like that, now we're just going to do it the easy way and just unwrap it and say, if it's too much, just fail the whole contract. Personally, I wouldn't do it in my code, but for the sake of brevity, what I would do actually is basically implement another variant of the error here, call it, I don't know, arithmetic overflow, and basically throw this error here similarly to what we have before.
00:27:37.568 - 00:28:32.788, Speaker A: But it's actually quite educational to also know of the shorthand way that will just fail the whole transaction if this happens. Now, fingers crossed I got this right, and I did. It's amazing. We can already see a few things here. There's a few stages of generating your contract, but what you end up with is this bundle that we're soon going to upload to the chain and kind of play with it internally. This contract bundle is actually the actual binary of the contract, which is in wasm so webassembly and the JSON metadata, which is what instructs all of the callers where to find the methods of your contracts in the binaries and what's the documentation. So what parameters are accepted and so on.
00:28:32.788 - 00:28:57.160, Speaker A: It's very important. Yeah, so coming back to our example, because we're not quite there yet. Now going line by line, now we have the insolidity, we declare an error, insufficient balance. We can actually do the same. We already have an error type, so we can just add to it, add more variants. Right. So let's call it insufficient balance.
00:28:57.160 - 00:29:35.770, Speaker A: And since insolidity it has also the named fields. So let's do the same. It's requested, it's going to be the unsigned int that we used previously and available and is also going to be the unsigned Int. Yeah, so we've got this. So moving on to the next line, let me just get my parentheses right. I think it's here. We're going to need a next ink message that we're going to call send.
00:29:35.770 - 00:30:07.936, Speaker A: Well, since we already see that the send will need to mutate something around the contract storage, we can kind of skip the playing with a compiler and just use the mutable reference again. If we forgot it, the compiler would complain. And this is preventing us from basically changing something by mistake. Right. If you think it's a stupid mistake. Actually it's not. In my experience it happens quite a lot.
00:30:07.936 - 00:30:43.912, Speaker A: So again, we actually have pretty much the same signature receiver account id and the amount u one two eight. And we're going to do the same thing. So we're going to return a result with nothing if everything goes according to plan. So we just have the side effect of mutating the storage and the coin error. Coin error, I don't know why it's not. If something goes wrong. First of all, you can see that my id is complaining that I'm not actually returning any results.
00:30:43.912 - 00:31:20.568, Speaker A: Well, that's okay. I'm just going to put it here, assume the happy case, and we're going to come back to that later. But let's see what happens here in the solidity code. So first we check whether the balance of the sender is more. Well, we check if it's less than the amount, and if it's less then obviously the sender doesn't have enough tokens to send them to anyone. So we need to throw an error. And what we're going to do is we're going to do actually pretty much the same thing.
00:31:20.568 - 00:32:12.280, Speaker A: Let's just get the color real quick. I won't even bother to copy it because it's super quick. Now let's check the balances, right? So I won't copy paste because copy pasting is the root of many problems. If you're like me, sender balance is again we're going to get from the balances, but now we're going to get, oh, sorry, let's call it sender. Sender. We are going to unwrap again just because we don't want any errors here. If the sender is not present in our balances table, it's the same as them having just zero balance.
00:32:12.280 - 00:33:04.130, Speaker A: Okay, now we can do our check. So if, let's do the same. If amount is greater than the sender balance, well, you already know what we do, right? We return an error variant of our result saying it's going to be a coin error, insufficient balance, and well, requested will be amount and available will be, obviously, sorry, sender balance. Yeah, that's pretty cool. I would actually probably write it in a slightly nicer way. In general, you don't need to format rust code by hand. Rust FMT will do that for you.
00:33:04.130 - 00:33:47.220, Speaker A: But just keep it very brief. Okay. So if the sender does not have enough funds to actually make the transfer, obviously we return an error and the clients can decide what to do with this situation. But if everything is okay, then what we need to do, we need to decrease the balance of the sender and increase the balance of the receiver. And if you know about reentrancy, you know that it's better to first decrease the balance of the sender and later increase the balance of the receiver. Otherwise, you could do something similar to the Dow hack that most of you probably will be familiar with. Now.
00:33:47.220 - 00:34:40.770, Speaker A: To do that, we're going to do the same thing we've done previously with the minting self balances. And now we can insert, and it's going to be a very similar code. It's just going to be the sender as the target here and we're going to do the same thing as we've done before. But we're going to take the sender balance and we're going to do checked sub, which is, well, as you can probably guess, the same as checked add, but for subtraction and from the sender balance, we're going to just subtract the amount. And again, we're going to use the hack here with unwrap to basically save some time. Okay, that's pretty cool. We decrease the sender balance.
00:34:40.770 - 00:35:00.060, Speaker A: Let's just save it. My id is not complaining yet. Well, we haven't used the receiver. That's one of the warnings we got. That's very true. Now we need to, well, let's just get the balance of the receiver and this. Actually we can copy over.
00:35:00.060 - 00:35:38.518, Speaker A: We can just do this and it should work just as well. And now we're going to do the same thing. Okay, I'm going to copy from minting here because best if we save time. Okay, I think it looks right. It looks right to me. Let's quickly check if this compiles because we might fail at the linting stage. Who knows? In general, I find it the most convenient for me to compile the code as often as I can just because I like to catch the errors early.
00:35:38.518 - 00:36:32.662, Speaker A: And in general, I would say that this is the philosophy of strongly typed, statically typed languages like rust and ink here, that a little struggle during writing the code during compilation can save you a ton of headache when the code is already deployed. Right. So I actually like that the compiler is shouting at me and this allows me to basically fix my errors before they even hit testnet or let alone mainnet. Now, since we've got this more or less done, the business logic is done. We have one more thing here. We have the events in solidity. So in line eight we have the event and we can do the very similar thing in our rust code.
00:36:32.662 - 00:37:52.480, Speaker A: We're just going to do a public struct as before, and we're also going to do the same name. But importantly, as you've probably guessed, we need to do an ink event macro just so that we tell the compiler that this is going to be sent out as an event. If you're not familiar with events, it's basically your contract's way of communicating with the outside world, like telling the outside clients what's happening, be that wallets, indexers and so on, you can use it to kind of react to what's happening in your or someone else's contract. Now, if we look at the fields, we have the from address to address and the amount. So from is going to be an account id, to is going to be an account id and amount is going to be our number type. Okay, one more thing you can do in ink. Since these events are later ingested by different clients, you can say that, hey, similarly to what you would do in a database, hey, you can say that this field is actually okay to index on and it will speed up the kind of ingestion of the events or querying them.
00:37:52.480 - 00:38:33.866, Speaker A: Importantly, you cannot make a primitive type a topic, which also, I think you'll find it kind of natural if you're, if you have some databases background with indices. Okay, so we have the event struct. That's pretty cool. Now we just need to send it. And we're going to, again, used our magical self env method. By the way, the self env has a few very interesting helper methods that you can use, like the account of the contract itself, the balance you can get, the current timestamp and so on. It's very helpful.
00:38:33.866 - 00:39:15.420, Speaker A: Here we're going to do the emit event macro. Sorry, it's not a macro, it's a method. And we're basically going to use our send event, which is going to be our from is our sender, our to is our receiver, and our amount, well, it's our amount, so we can just write amount. Okay, I think this works quite well. Let's try building it. Yeah, must be my lucky day, because so far, not too many compilation errors. Okay, I think we're more or less ready for this contract to hit the chain because the behavior is the same.
00:39:15.420 - 00:40:01.482, Speaker A: Actually, you'll notice that what we actually do here is quite a bit safer because we, for example, are guarding ourselves against arithmetic overflow. And I once again encourage you to check out the batch overflow hack to see how deadly overflow can be. What we can do right now is make it a little bit more user friendly, since I'm seeing that I got 20 minutes, so let's make it a bit more user friendly. Okay, the first thing I'd like to do is, well, imagine you have a lot of methods. You may think, well, it's super cumbersome to write these result, coin error. If all your methods return this, well, why not use something shorter? And that's exactly what we're going to do. We have the coin error here.
00:40:01.482 - 00:41:02.410, Speaker A: We can declare something that's a type alias in rust. It's basically saying, okay, from here on out I'm going to call this type differently and let's call it coin result. Okay, like this, right? And now instead of writing this here, I can quite conveniently use coin result. And it's going to be the same thing, but with less typing, so profit. Okay, and probably one more thing, and actually an interesting piece of rust syntax, if you haven't seen it before, is this pattern here. Right? Because you'll probably have a lot of messages, a lot of methods that check the owner, and could we somehow extract it to a method of its own that it kind of works almost like a macro. So we can, and you'll notice that we don't have to only put messages in our contracts, we can just put any arbitrary method.
00:41:02.410 - 00:41:41.674, Speaker A: It's not going to be public because we don't want anyone from the outside calling it. It's just our contract that's going to be calling it. It's going to have a reference to just to self, because it's not going to mutate anything, it's just going to check some stuff. And actually it's not even going to have any additional arguments what it is going to return. It's going to return a coin result. And what we're going to do is basically we're going to do this right, if the color similarly figure out who the color is, if the color is not an owner, we return the error. Otherwise we just return an okay.
00:41:41.674 - 00:42:37.482, Speaker A: And now you might think that we are forced to do like if ensure owner, or do some pattern matching. No, we can use a very handy syntax that's going to look like this. If you're used to writing in Javascript, you may recognize this question mark, although here it's a bit more typesafe and a bit different. So what it's going to do is it's going to check the result of this method, and if it is the error variant, it's going to return the error from the whole method. And if it's okay, it's just going to progress, which is pretty cool. It doesn't involve any magic, actually. This could be just rewritten as a very simple pattern match, but what it does is it reduces the number of lines of code we need to write and indentation we need to have here.
00:42:37.482 - 00:43:12.978, Speaker A: So that's pretty cool. Let's see if it compiles and it does. Right. That's great. I wonder if there's some more stuff we can do. Well, we could try to abstract away more pieces of our code, but I think we're good for now. So from more technical things, this is how our cargo tom looks like, which is basically a file where we describe our project and list all of the dependencies.
00:43:12.978 - 00:43:52.078, Speaker A: You'll notice that we're using just a single dependency here. That's the ink language, because it's all nicely packaged as a dependency, and the rest is just rust itself. It's a fairly new version, and this is what introduces all these cool features that you cannot, for example, do a potentially unsafe addition or subtraction. It kind of guards you against that. There's also many more nice features you can read about them at the use Inc. Website, which basically, by the way, I encourage you to check out. Okay, so since we've, let's just compile it once more for good measure.
00:43:52.078 - 00:44:32.430, Speaker A: Okay, so we have the artifacts, we are now ready to deploy our contract. And what I have here is basically the substrate contracts node running. I don't want to use the LF zero testnet right now just because I don't want to put random stuff on the testnet. I could, but I prefer to keep it local just to make it clean for everyone and for myself. And obviously once you deploy a contract to the testnet, it stays there. Right. And the wasm code is public, so that's worth keeping in mind.
00:44:32.430 - 00:45:11.910, Speaker A: So what we're going to do now is we're going to go to the substrate contracts Ui. I'm going to make it a bit larger for everyone to see. You can see that we haven't got any contracts yet, so we're going to add a new contract. Well, we're going to upload new contract code. This is like a developer local instance of the blockchain. So I have access to the developer accounts that already have some funds and pretty much it's ready to use, batteries included. If you wanted to deploy on testnet you would need some sort of like a signer extension like the LS zero signer or PoCa JS extension.
00:45:11.910 - 00:45:36.362, Speaker A: And you would need to create an account. You would need to get some funds from the faucet. It's described in our documentation that I'm going to show you a bit later. The contract name. We're going to call it Denver coin because why not? And I have the coin contract here. I hope I selected the right file. Okay, you can see that it uploaded the contract bundle.
00:45:36.362 - 00:46:17.886, Speaker A: So it's the wasm code and the metadata in JSON. This is how it was able to figure out the names of the methods, the type and types and whatnot. Of course, I've done a very bad thing. I haven't included any doc strings in the code, which normally I would do like mint specified amount or something like that. Basically it's important to write the doc strings here because it's going to end up as the visible API. Well, description of the API that your users have at their disposal. So it's quite important that you tell exactly what the methods are doing.
00:46:17.886 - 00:46:44.426, Speaker A: Okay. We're actually doing two steps at once. Now. I still have some time so I can explain it. A very interesting concept in ink and in substrate is that basically the deployment of a contract is a two step process. First you upload the code to the chain and it just kind of starts living there. And then you can spawn multiple instances of the contract from it.
00:46:44.426 - 00:47:29.814, Speaker A: Just kind of like making pointers to the same code. And it's pretty cool because I don't know, if you're writing a game and have like seven PSP 22 contracts to deploy for the tokens, you don't need to pay for uploading the code seven times. You upload it once and then just instantiate it seven times, which is pretty cool. And yeah, worth keeping in mind we don't have much choice when it comes to the constructor, just the new. Yeah, it's going to just confirm that we've instantiated the code. It's all here. Now, of course you could use the command line, the category contract to interact with the contract, deploy it, and so on.
00:47:29.814 - 00:48:02.946, Speaker A: You could also use polka dot JS, the library. I'm just going to stick to the graphical user interface because I think you've seen enough code already. Yeah, we can choose a method to mint. Okay, let's mint using the owner of the contract so Alice and the receiver will also be Alice. We just want to mint for ourselves. Let's mint like a thousand tokens. I don't know, actually there's quite a lot happening here, but probably no time left to explain it.
00:48:02.946 - 00:48:56.370, Speaker A: But every time you call a contract like that before you call it, this system is actually performing a dry run of your contract first, which allows it to kind of see if it will be successful and estimate the fees that you'll have to pay for instantiating this contract. Fortunately, on the Alice zero blockchain, the fees are negligible, like a fraction of a cent. But still, it's worth keeping in mind and kind of estimating what they will be. If you're seeing this scary looking constant here, you can use the estimation. That's what we get from the dry run. But if you want to customize it, then basically the ref time limit is intuitively how long your call will take to execute. And the proof size limit is again, it's just an intuition how much space it will take on the chain.
00:48:56.370 - 00:49:23.280, Speaker A: Now, since we've got the mint, we can now use the send functionality to send from Alice to Bob. And let's try something weird. Let's try sending more than Alice actually has. And you see that the contract was reverited with the error we specified. So yeah, seems like we've written code that works and quite fast too. Let's just send 100. Okay.
00:49:23.280 - 00:50:19.422, Speaker A: Yeah, that's pretty cool. Seems like it was successful. Now you will notice that we haven't included a check balance function. It's actually one of the things we could do to make our contract a bit more user friendly. Let's make it more so we could actually do a message and let's call it balance off, maybe let's just call it who and it will return our type here. And let's just do, yeah, it's going to be quite simple. We're just going to get this and this should work.
00:50:19.422 - 00:51:33.094, Speaker A: And now we could check what's in our contract and we could actually rewrite this to have self balance of receiver and rewrite it further like this. Yeah, it's a pretty handy shortcut, but we can do one more cool thing. And actually also a recent addition to cargo contract, sorry for jumping back and forth, but of course our contract is deployed under a certain address and we can copy this address to our clipboard and we can do for convenience set it in an NVAR and then we can use the cargo contract storage command passing the contract as an argument. The contract address and the path to this cargo tumble file that contains the info about our contract. And you'll notice that I'm not writing any websocket address or the address of the node of the RPC node. I am not, because by default it's using the local instance that I'm using. So it's pretty cool.
00:51:33.094 - 00:52:14.306, Speaker A: And now you can actually quite conveniently examine the storage of your contract. And this allows you to learn also a bit how the layout of the memory looks like in ink. But you'll see things that make sense. Basically at the root there's our contract struct that has a mapping and the mapping of course has cells stored somewhere else in this kind of sparse layout. And yeah, you'll remember that we've minted a thousand coins to Alice, but then sent a hundred to bob. So it contains appropriate entries. So everything seems to work.
00:52:14.306 - 00:52:53.150, Speaker A: And that's pretty much it. And the contract, I think it's pretty safe. So I think it was worth writing all this code to have something that is pretty bomb proof, at least in my opinion. Now if you want to learn more about the contracts in ink and lsero in general, then I definitely encourage you to visit our homepage lsero.org. You can also do docs lsero.org for documentation, lsero.org developers for the developer portal.
00:52:53.150 - 00:53:32.574, Speaker A: And basically you can take it from there. And I hope that after this I'm going to see some new ink contracts deployed on our testnet and later on our main net we also have this. Actually for builders, this is probably the most important information. We also have this ecosystem funding program where we support basically projects who are building on the LF zero blockchain through grants and tech support. We also have partners who can help you with legal stuff, with branding, marketing, business and so on. So check this out. It's all accessible from the alief zero page.
00:53:32.574 - 00:53:37.290, Speaker A: And yeah, hope to catch you all here at the conference. Thank you so much for listening.
