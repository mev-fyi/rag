00:00:00.250 - 00:00:16.720, Speaker A: All right, next up we have Solana, and we've got Anatoly from the project here to present into the wormhole. So, Anatoly, are you here with me now? I am assuming we're going to see you in just 1 second.
00:00:18.130 - 00:01:03.174, Speaker B: So what I want to demo to you guys is the wormhole bridge that we built between Ethereum and Solana and not us. Actually this team, shortest one, that is, one of our validators, pulled us out. So we'll see if it works. Here's an instance of it. It was actually deployed on Arwe as a web application. It detects that you're running metamask and it connects to Solana Wallet. So here I'm going to try to transfer a zero X token into Solana.
00:01:03.174 - 00:01:50.362, Speaker B: So we're going to try to transfer one token. And the first kind of weird, interesting thing about Solana is that the account for that token needs to exist beforehand. And what that means is that this is part of kind of a nuance of the Solana runtime. So in Ethereum, when you do a store eVM just goes find your location, where to store data. That's unfortunately kind of slow because you are modifying the index and you have to have those indices pre allocated. So what we do in Solana is you actually pre allocate all these indices ahead of time. So I don't know if you guys can see this approved creation.
00:01:50.362 - 00:02:40.154, Speaker B: So that's basically it. Oh yeah. So here's the token we're going to transfer 10 x to metamask confirm. So while this is running, I'm hoping this works, but this does require waiting for Ethereum to confirm it. So in the meantime, when you kind of talk about what's happening in the background, so user has some ERC 20 that they want to transfer to Salana. The first thing that we needed to do was create a destination where this is going to land on the Solana chain. And that's done via deterministic caching.
00:02:40.154 - 00:03:25.870, Speaker B: So that index is created beforehand and you can think of it as a memory location where information is going to be passed through. And we can derive that deterministically from the ERC token type. So it doesn't matter which user kind of creates that thing first, it'll always land in the same spot. So user basically does a transfer. All right, there we go. Does a transfer from their wallet into the bridge. The validator on this side does a mint instruction in a transaction to transfer those tokens to the user's wallet.
00:03:25.870 - 00:04:21.866, Speaker B: So in this particular case, what are these validators? Or who are these people? And how does that work? Where is my Solana? So if you look at Solanabeaach IO, this is a validator website that was built by one of our folks. The validators that run this bridge are actually a subset of the validators that run consensus. And the reason for this is because of how salon is designed. And the number of validators to get to supermajority is pretty large. So to get to 67% for consensus, we need 133 validators. And each one of these validators generates a different etc. 50 519 signature every four in a millisecond.
00:04:21.866 - 00:05:43.754, Speaker B: So for a full block confirmation, what you're dealing with is 133 messages at least. And in the worst case it could be 32 times that, which is unfortunately just kind of too much data for the EVM. So to make this feasible, and to make this work on Ethereum, we pick effectively a subcommittee of these validators, and they observe the Ethereum chain. And when they observe that chain, they don't internally have run any consensus, but they simply sign those messages. And when a subset of them signs that, the supermajority of that committee that contract executes on both sides. So where is my presentation over here? As soon as the user does this action, those validators independently observe it and they sign a message. That message is gossip, and any one of them can collect the supermajority of that acknowledgment and submit it to either side.
00:05:43.754 - 00:07:04.930, Speaker B: So you don't really need to run consensus in the middle here. It's kind of done implicitly, because each contract and each chain can take those requests, which is pretty cool. So to make this more decentralized in the future, we have another project that is working on actually verifying litecoin proofs inside Ethereum. And we don't want to do these proofs in every transaction, because this is going to make this whole system 1000 times more expensive. But what those proofs can do is every two days they can make sure that this validator subset actually matches validators from Solana, given some prerequisite in terms of stake. And the second thing they can do is that my client proof can actually ensure that these validators haven't committed fraud, because the log on Ethereum has to match the log on Solana. So you can technically do full reconciliation of a know every two days and make sure that it, you know, one way to think of it as a kind of an embedded domain specific language that defines the bridge operations between these two networks.
00:07:04.930 - 00:08:18.818, Speaker B: And this works exactly the same way, no matter if the initial transaction is issued on the Solana side or on the Ethereum side. So let's see where we got with our wormhole validators. Perfect. I almost timed that completely. So were you guys able to see that? So that transfer is completed in my wallet on Solana. I should have some tokens. So where's my wallet? Tada.
00:08:18.818 - 00:08:36.680, Speaker B: Look at that. So that's the token address that we created before. This is a deposit address, and I have one Zrx bridge. Zrx. So some to dos, obviously. Here is this interface. Pretty ugly, but it works.
00:08:36.680 - 00:09:46.114, Speaker B: We need to add some token symbols here and kind of start figuring out how do we display this correlation in the explorer? How do we actually demonstrate that this particular address represents zero X on Ethereum? And you can kind of dig through this behavior. So if you look through our explorer, at least given this transaction signature, you can see who actually ran it. And this you can track down to the wormhole program. And this is the program that is run by that bridge, and that program executed these state transitions. So that's basically it working. I'm actually surprised that it works so easily. Cool.
00:09:46.114 - 00:09:53.960, Speaker B: Okay, so what else should we cover?
00:09:55.930 - 00:10:20.270, Speaker C: I think where this can go, and people on the conference are probably interested how they could help build that out. So maybe how we can bridge to Amm on Solana, some assets from Ethereum, like imagine maybe interest bearing tokens from Ava into liquidity pools that we have that are controlled by the market makers on the other side and have cheaper fees.
00:10:23.210 - 00:11:25.260, Speaker B: Yeah, this is one of the cool projects that I'm really kind of looking forward to is basically folks doing something really simple, which is taking aave tokens that are interest bearing and bringing them through to Solana side and then plugging them into a serum decks. And the cool thing about it is that you have a much slower kind of like exchange, if you want to call it that, which is the ave liquidation market, plus the uniswap running on Ethereum, and you have a much faster, cheaper one running on Solana. So you could actually start hedging between both of those. You could issue a transaction into the mempool on Ethereum and cover that position, or potentially losing that transaction rate on Solana, depending on gas prices. So there's opportunities for both bots and for humans to actually take advantage of.
00:11:26.850 - 00:11:44.020, Speaker C: So for people that are not necessarily familiar with Solana ecosystem, serum decks that anatoly is referencing is fully on chain exchange that's running on Solana without any external interaction with limit orders, which is something that we are super proud of.
00:11:50.520 - 00:13:02.470, Speaker B: Yeah. So, yeah, I'm actually kind of surprised that that transaction was successful and pixel, because that was going to be most of my presentation. So, the second part, what we can cover, is folks that want to actually dive into development on Solana. And there's this awesome guide that goes through the Solana memory model. Again, I want to share this link with everyone in the comments. It. So the kind of thing that we saw in that simple presentation was that this program over here.
00:13:02.470 - 00:13:31.580, Speaker B: Dang it. Here it is. Warm. How the Solana model works is that everything in our memory model is an account. So these accounts have to be addressed and pre allocated ahead of. Really. This is kind of like the thing that is hardest for people to get is that when you do a store, you don't get a free index allocation.
00:13:31.580 - 00:14:12.750, Speaker B: And why that's important is because when you're dealing with a single shard giant state machine, those indices grow really large. And if you don't preallocate those spots, you actually end up with a very expensive virtual machine. So programs, like everything else, are accounts. So wormhole is an address, and this is a public key that the wormhole validators had to grind to get a private key. With this public key that starts with WR. This is the closest thing that we have to vanity addresses right now. You actually have to do some super work to get one.
00:14:12.750 - 00:14:45.396, Speaker B: It's kind of funny. And what's weird about the account system is that every account has an owner field. So what is the owner? This isn't actually a human owner. It's not a person. It's another program. So when you load your own smart contract or a program, that account is owned by the loader. And what that means is that the loader is the only thing that can do state transitions in that account.
00:14:45.396 - 00:15:49.024, Speaker B: So, warm itself is a separate program, but lives in an account, and that account is owned by the loader. And only the loader effectively can load programs and set them as executables. But as soon as that new program is loaded, this thing itself can start owning other accounts and therefore do state transitions on them. And this is kind of the core of the security model here. Wait, it's all programmed? Yeah, it always has been that everything in the Solana account system is a program, and every account is owned by another program. And the only few things that have interesting powers are the loader itself, which is the thing that can make things executable, or system program, which is the only thing that can allocate memory. And once you kind of get the hang of it, you can almost think of it as forking in Unix.
00:15:49.024 - 00:16:54.664, Speaker B: So the forking model in Unix, right, is I create my master process. I fork into a sub process and then reduce privileges and then hand ownership over to somebody else. It's similar in that sense that everything in itself starts from a different program. So if you're building in Solana, the second thing you'll notice is that transactions are kind of fat. And that's because transaction itself has to specify all the accounts it's going to read and write ahead of time. And this is again like another kind of pain point for a lot of dust, is that you have to design your program to effectively. We're forcing the developer to do this really hard process of making every state transition in your program effectively stateless.
00:16:54.664 - 00:17:58.080, Speaker B: There's no global memory. If you have global memory, it has to be passed in as an argument to your entry point. So things like token initialize account have to take the target account, the Mint, which is the descriptor of that token, the human owner, which is like a parameter. And it also has to kind of keep track of rent and know exactly how much land portion needs to store to prevent that account from being cleaned up by the state garbage collector. So this is kind of a pain in the butt for devs. But the reason for this is again, is if we see a big pile of transactions and we know exactly which accounts each transaction needs to read and write, we don't need to allocate any dynamic indices. All the indices can be pre allocated ahead of time.
00:17:58.080 - 00:18:47.984, Speaker B: The second part is we can process all the transactions in parallel. So every other transaction that doesn't touch any of these accounts, they can execute in isolation. This is kind of the second cool thing. And this is why we get this kind of massive speed up. So if you go to new Salana surf and you look at the, let's say, transaction rate, we're kind of handling a big pile of DPs at any given moment. And if you want to examine what those blocks are, you can actually kind of. This is a cool new interface one of our validators built.
00:18:47.984 - 00:19:46.640, Speaker B: So you can go look at which programs have been executed in the last 10,000 blocks. Inside of those are a bunch of different calls to different accounts. And because all of these are isolated, they can all execute in parallel. So because of this parallel execution model, we can actually run consensus as a smart contract. Now this isn't exactly a gimmick. What's important about this is that our whole kind of like goal to decentralization is that every two years the amount of parallelism we can do for the same price basically doubles. Because all of these programs can execute in parallel, they can all run on separate cores, they touch separate memory, therefore they can run effectively on separate solid state drives, use separate queues for reading and writing to SSDs, they can use a separate core.
00:19:46.640 - 00:20:35.890, Speaker B: Those things basically drop in price by 50%. That kind of parallel computation is called really easy to scale. It's kind of like a 3d horizontal scaling. And because consensus is one of those things that takes up resources that actually fits natural to run it as a smart contract in the system. Because every time we double capacity, right, double bandwidth, double CPUs, double SSDs, we can double this number of validators for free. It literally means if we have twice as much capacity, we can use twice as much of it on consensus. We can use twice as much of it on market programs and things like that.
00:20:35.890 - 00:21:54.964, Speaker B: So that is basically it. So if folks want to actually dive into the development process, you should check out this guide. And if you look at our githubs work, that's not it. There's an open Zeppelin style Solana program library. So I hope folks can go check this out because this thing contains reference implementations for Amms, which is token swap lending, and as well as some other cool weird things like the brave Themis design, and like a really cool shared memory model between applications that need to store return values between each other. So that basically covers what I wanted to cover during this talk. Cool.
00:21:54.964 - 00:22:09.250, Speaker B: I don't know if we have a way to get questions from folks on Twitch or in the comment section. Yeah, I'm not sure. Anatoli, let me take a quick look.
00:22:22.460 - 00:22:45.740, Speaker A: Well, I guess while he's looking, thanks a lot guys, for your contribution and your support of the event. Hopefully you guys enjoyed as much as we have. I mean, that was really good information. So thank you for sharing all of that. Everybody, again, thank you to Solana for being a presenting sponsor. You guys have been fabulous to work with and we really appreciate everything that you've.
00:22:46.640 - 00:23:03.110, Speaker B: Likewise, if you guys want to start moving tokens through warmhole, please check out the bridge in the docs. It's as cheap and easy and it works in first try once you load the right code.
00:23:04.200 - 00:23:10.470, Speaker A: Excellent, cool. We'll check it out for sure as soon as I get done doing this all day, right?
00:23:11.720 - 00:23:12.484, Speaker B: Take care.
00:23:12.602 - 00:23:15.360, Speaker A: Cool, take care. Thanks guys. Bye.
