00:00:26.380 - 00:01:26.626, Speaker A: Just going to swap the displays. There we go. Okay. It all right. This talk is titled sharing a sequencer is caring about interoperability. I am Ben Fish. I am the CEO and co founder of Espresso Systems.
00:01:26.626 - 00:02:37.818, Speaker A: I am also an assistant professor of computer science at Yale. So roll ups are horizontally scaling Ethereum. Roll ups are this beautiful solution that allows for sharding of computation across different applications. It allows for powerful servers to also help much weaker nodes verify what the state is, which allows for greater decentralization of Ethereum while supporting many, many more applications. It also enables virtual machine diversity so you can add new applications that are not even running the EVM and they can just simply prove their state transitions to the layer one. So roll ups are this wonderful innovation over the last few years that have brought tremendous benefits to the ethereum ecosystem, scalability and virtual machine diversity in particular. But one of the things that rollups do today is they run what are called isolated sequencers, and this has a significant drawback.
00:02:37.818 - 00:03:46.920, Speaker A: The drawback is that interoperability between applications across different roll ups is very limited. Bridging is slow and costly, and this leads to a loss of what we call synchronous composability between applications and liquidity. Fragmentation the value of ethereum is really in its unity, not fragmentation. Seamless interoperability of applications is the promise of trust minimized infrastructure. And what really differentiates web3 from web two? So let's take a little look at what the job of the roll up sequencer is and why roll ups are running isolated sequencers today that hampers interoperability. So the job of the sequencer is to collect transactions from users and periodically summarize the results of executing those transactions and post it to the Ethereum network. This in a ZK rollup would also come with an immediate validity proof, which allows the Ethereum network to verify that the state update is correct.
00:03:46.920 - 00:04:53.094, Speaker A: So it determines roll up blocks and which transactions are included in those roll up blocks and their ordering. A sequencer may also run an auction, sort of naturally gives rise to an auction where builders are bidding to propose the next block. And the sequencer kind of runs an auction among these builders, and that helps it produce the most valuable block it can, which is the same dynamic that happens with leaders or proposers in Ethereum's consensus protocol, now based sequencing, base sequencing, which is the most recent. Let me just base sequencing, which is really the original version of roll ups, is as follows. So l two nodes. Just read the finalized transaction list from the l one. There's no sequencer.
00:04:53.094 - 00:05:29.894, Speaker A: There's no additional sequencer. They just read this user send their transactions directly to the roll up smart contract. And l two nodes read the finalized transaction list from the l one. They execute them and then periodically post what the state transition is, along with perhaps a ZK proof to the layer one. So by using the layer one itself as the sequencer, the advantage is one, it inherits the decentralization and liveness and censorship resistance of the layer one. You're not introducing this external party. And number two, because all these roll ups are then sharing the same sequencer.
00:05:29.894 - 00:06:54.882, Speaker A: In effect, it results in improved interoperability, not only between roll ups, but also between roll ups and layer one applications. And I'll get into in a little bit more detail why that is the case. But before, why is this important? Ultimately, users just want a secure, convenient and low cost experience, right? They don't want to think about necessarily being on one roll up versus another. Satisfying user intents will be most efficient across applications that are deployed to roll ups with the greatest unity, not only with each other, but also with smart contracts on the Ethereum l one. So that's why this is so important. What is enabled by having a common sequencer between not only roll ups, but also the layer one? What is the benefit of this? Well, the way the layer one works is that it always has a proposer that's building the next block, right? It has proposers, and then it has validators, which are attesting and signing on the block proposal and making sure that the network has received it and doesn't forget it. So this elected proposer from the l one, if it's also producing blocks for roll ups, then what it can do is it can promise to users things that it will do synchronously between different roll ups and maybe even the l one itself.
00:06:54.882 - 00:07:45.154, Speaker A: So here's a simple example. A roll up user wants to take advantage of some arbitrage between two amms on different roll ups. So it says, I want my two transactions on roll ups a and b to execute atomically. Now the l one proposer can give this promise to the user that it will execute its transactions on both roll up a and roll up b, or otherwise not included in the l one block. Now this doesn't give the user the same exact protection it has when just atomically taking advantage between arbitrage of two amms that are on the ethereum l one itself, or on the same roll of vm itself. But it's still quite powerful because the promise that the l one proposer gives is slashable. Violating a promise is a slashable offense, and even the user could collect damages.
00:07:45.154 - 00:08:47.110, Speaker A: So promises function almost like an insurance policy. And importantly, the honest proposer can make these promises without any risk, so it can offer very low cost insurance. There's much higher risk without a shared proposer. You can imagine that a builder would try to make the same promise to a user interacting with two different siloed roll up sequencers. But roll up a sequencer or proposer might accept its transaction while the roll up b proposer rejects it. So there's no real way for this external builder to make this promise unless there is a coordination. So proposer promises, or what are also known as pre confirmations, they enable a shared proposer for a bundle of multiple roll ups to do many things, including acting as a liquidity provider, making promises to satisfy arbitrary user, intense atomic execution of several transactions across different roll ups.
00:08:47.110 - 00:09:48.182, Speaker A: They can also provide very fast confirmations of what it has proposed, even with 100 milliseconds latency or less. Even though it takes much longer for Ethereum to finalize what happened, there is some risk that this pre confirmation will eventually be reversed. But again, it can act as like an insurance policy that the proposer gives to a user, which can be checked in very short time. It can also be used to a shared proposer can also be used to coordinate message passing between Zk provable chains. So this is something that polygon aglayer describes. And with improvements in the latency of proving, which may ultimately enable us to do real time proving, even 100 millisecond latency proving, then this could ultimately enable synchronous interactions between l one and l two contracts. So again, violating a promise is a slashable offense.
00:09:48.182 - 00:11:13.750, Speaker A: And if users can collect damages for violations of these promises, then preconfirmations act as a form of insurance. There's many examples of cross domain user intents that we might want to use pre confirmations to satisfy. Some examples are capturing arbitrage, as I already gave an example of maybe finding the cheapest way to execute an asset swap, and that may involve multiple DVI exchanges or liquidity providers across multiple chains, or buying an NFT on one chain with funds from another, but not wanting to first bridge and swap assets, unless you know that the purchase will actually succeed in the end. So this sounds all great, but what is base sequencing missing? Right? Why were external sequencers introduced in the first place? Well, number one, better data compression, which ultimately translates to lower data availability costs. So an external sequencer collects transactions over time and can optimize when it posts them to the Ethereum L one, and also fast. What I will emphasize is low risk pre confirmations. Okay, what we just talked about before with l one proposers giving promises over what might happen, there's always the risk that even if they do nothing wrong, their promise will be violated, because Ethereum could experience a reorg and transactions that they included could be dropped before 15 minutes have elapsed.
00:11:13.750 - 00:11:51.540, Speaker A: Okay. Ultimately, higher risk means that if they're going to give insurance to users, it's going to be higher cost. An external sequencer can preconfirm pure l two transactions that do not depend on any unfinalized l one transactions with virtually no risk at all of being wrong because they have complete autonomy of what they're going to do with the roll up contract. They have an exclusive right to update the l two state. So better data compression and fast, low risk pre confirmations were the real reason why external sequencers were introduced in the first place. The original arbitram paper actually had no external sequencer. These were introduced later.
00:11:51.540 - 00:12:39.522, Speaker A: Now, is there a middle ground? Yes. Base sequencing can have its cake and eat it too, in some sense, too. What we can do is we can introduce an external finality gadget. We call this a fast finality gadget, and we could have l one validators even opt in to participate, say, using eigen layer restaking, as Kaido was just talking about in the last talk. So what does this do? Well, the roll up smart contract on the l one will require, will require transactions to be first approved by the fast finality gadget. So users are sending their transact action still to an l one proposer. The L one proposer produces a superblock for all these roll ups, but it needs to get it approved by the fast finality gadget first.
00:12:39.522 - 00:13:33.090, Speaker A: Right? And then it will be settled on the l one. And so the role of smart contract requires this fast finality gadget, which could be a BFT consensus protocol operated by an opt in set of validators to approve all transactions. And this still maintains l one composability because the l one proposer is still proposing, it's still building the l one and l two blocks together, but it just first needs notarization from this fast finality gadget. What we can achieve here is something what we call conditional finality. The finality of any l two transaction is now conditioned on the finality of the most recent l one block that it depends on. And of course, the security of the fast finality gadget. So this inherits the benefits, the composability of base sequencing, but retains also the benefits of external sequencers that were introduced by rollups.
00:13:33.090 - 00:14:33.750, Speaker A: Now, what else is base sequencing missing, especially now that we're used to roll up sequencers? Well, mev capture for roll ups. So enshrined roll up sequencers have additional revenue beyond the gas fees and roll ups, which come from tips that users are paying for satisfaction of intents, whether they're pre confirmation tips, which generalized order priority fees or standard order priority fees. So vanilla based sequencing is simply not economically aligned with roll ups. And so a solution is to have a mechanism to redistribute sequencing mev that flows to the ethereum l one or whatever is doing this shared sequencing back to roll ups. So we can view shared sequencing as an auction. It gives rise to this auction where proposers are bidding on roll up block bundles. We can auction off the right to update all roll ups, or a subset of roll ups at once to bidders.
00:14:33.750 - 00:15:47.626, Speaker A: Proposers are competing with each other and bidding on the right to produce this superblock. Okay, so the difference between shared sequencing and isolated sequencing is the difference between a shared auction versus isolated auctions. In the picture today, every roll up sequencer essentially auctions off the right on its own to produce the next block on that roll up. Whereas with something like shared sequencing or base sequencing, we have a joint auction where the roll up block spaces are auctioned off altogether, and someone can bid on the right to produce a bundle of all roll ups together. Now, as a shared auction, revenue may be higher than the combined isolated auctions, but how should we share the auction revenue with individual roll ups? Is there a stable mechanism through which roll ups can dynamically participate in this mechanism, such that they're always convinced they're better off running in the joint auction than in isolation? There's many analogies to this. We can look at bands playing at a music festival, right? The festival sells tickets. How is the ticket revenue allocated among the bands? Travel agencies sell tickets, combining flight legs from multiple airlines.
00:15:47.626 - 00:16:54.610, Speaker A: How should the ticket revenue be allocated among airlines? A toy example is, let's say you have two companies, one that manufactures left shoes, one that manufactures right shoes. It's obviously better to sell the shoes as a pair in a store. But then how would you split the revenue between the two different companies so that they're convinced they wouldn't be better off selling left shoes and right shoes on their own? So a solution is what's called a combinatorial auction, where proposers can bid on any combination of roll of bundles that they want to produce, and each bid is for the right to propose this bundle of blocks in a specific slot. Now, for each slot, we would select a partition of roll ups into bundles that maximizes auction revenue, and this can result in even multiple proposers. It wouldn't necessarily be one proposer for all roll ups all the time, and every roll up receives at least its highest bid. In fact, every roll up can even bid on itself, which functions as what's called a reserve price. A reserve price is the minimum price at which a seller is willing to sell a product.
00:16:54.610 - 00:17:47.266, Speaker A: So if a roll up bids high on itself, then it can ensure that it will at least make as much as it would make running on its own, in isolation. If it bids too high, it will be excluded from bundles that are assigned to shared proposers. Now, burning part of this bid can also further disincentivize what's called shill bidding, where they're bidding too high, and that's reducing the efficiency of the overall allocation. And this is similar to what's called a Harbinger tax. But wait, how is this base sequencing? I said that base sequencing gives the right to the l one proposer to produce the next block, not only for the l one, but for all roll ups. So where does this auction come in? Right, what the hell is this auction? What about the l one proposer? Well, this can also be a version of base sequencing. So this is what I call base sequencing 3.0.
00:17:47.266 - 00:18:58.106, Speaker A: So, after running the combinatorial auction, which anyone can participate in, the l one proposer for the Ethereum l one block in the same slot can be given the option to purchase the proposal rights for any bundle it wants at the winning bid price, plus perhaps a premium, because it can produce even more value since it's also producing the l one block together, this price at which it pays for the bundle will always exceed the sum of reserve prices for roll ups within that bundle by design. So what is shared based sequencing, after all, in light of this picture here? Well, it is a marketplace. It is a marketplace through which roll ups can sell block space to shared proposers who create surplus value by satisfying user intents across multiple chains. And for base rollups, that includes the Ethereum l one chain itself. So thank you. We are espresso systems. We are building a shared sequencer and a shared sequencer that also supports base roll ups, too.
00:18:58.106 - 00:19:09.910, Speaker A: Please follow us on Twitter. We are at espresso sys. My Twitter handle is at benafish. And stay tuned for updates. We have a new testnet coming out soon called cappuccino.
