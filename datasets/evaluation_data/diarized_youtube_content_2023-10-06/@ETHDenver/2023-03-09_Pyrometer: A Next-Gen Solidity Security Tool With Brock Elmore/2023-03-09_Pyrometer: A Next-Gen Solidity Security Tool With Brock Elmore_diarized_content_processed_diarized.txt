00:00:00.410 - 00:00:17.802, Speaker A: Hello everyone. Thank you for coming to my talk. I'll be presenting Pyrometer, a next gen solidity security tool. Little bit of intro. I am Brock Elmore. I am the chief architect at Nascent. Nascent's an early stage venture firm.
00:00:17.802 - 00:00:53.918, Speaker A: I am also a public goods fanboy, a foundry core contributor. My Twitter is up there, my GitHub's up there. And let's just jump in to what is pyrometer. So in general, pyrometer is something that measures the heat of something without actually touching the material. And so the analogy here is your contracts may be hot, and you don't want that hotness long term. A hot contract is a buggy contract. So parameter is a solidity security tool.
00:00:53.918 - 00:01:48.042, Speaker A: It'll eventually be language agnostic, so it will be able to work across languages. And it uses something called abstract interpretation, think symbolic execution light. And the demos I have in the slides here are simple by design. And in general, what the tool is trying to be is slither on steroids. I imagine everyone here is familiar with slither, an auditor's best friend, a dev's best friend, and blazing fast with hopefully ide integration. So be able to run this as you're programming at its core, parameter is bound analysis. So what bound analysis is, is when you have variables in your contract, they will change over time throughout the contract.
00:01:48.042 - 00:02:44.622, Speaker A: And so what are those range of values that a function can return that will be passed into another function, and those kinds of questions. And so just a little bit of an example that's really hard to read, I apologize. But you can see that there's a bunch of require statements and a bunch of math at the bottom here. And so if you were to ask any auditor, they would not be able to tell you what the bounds are on the return of this function. But that can be very useful for a number of reasons, for example, for optimizations or determining if there's going to be an unexpected overflow. And so what my tool does, if we go to the next slide, is you can kind of see it on the slides here, but effectively you have some function and it has these inputs. And initially those inputs are between zero and two to 256 minus one.
00:02:44.622 - 00:03:18.460, Speaker A: Right, the max value of a UN 256. And as we step through the program, it updates. So if you have a require y is greater than equal to one. Now that sets the minimum to one and the upper bound is still un 256 max. And as you go through it continually updates. And so you'll get to the mast statements and you start to see where this really comes to its power. And so at the end, you can tell, okay, this is between zero and this 970 some thousand number.
00:03:18.460 - 00:04:01.050, Speaker A: And so this is what is happening at the core of pyrometer is this very interesting range and bound analysis. So what does that do? So it actually allows us to build a ton of analyzers on top of that bound analysis. So you have an access control analyzer, which I'll demonstrate here in a minute. You can build a tank to analyzer. So are you checking all of the inputs of your function? You can have an invariant analyzer. So what are, if I step back here, right? So c is equal to z times y, right? And I have it here concretized to 10,201. But under the hood, it's really just z times y.
00:04:01.050 - 00:05:09.070, Speaker A: And so you can actually build up invariance in terms of other variables and get a sense of what your contract is actually stating. You can do simple things like a reentry analyzer. And I talked about the optimization analyzer a little bit as well. But in this example, you could do unchecked math on the a times b divided by C, purely because it already knows, and it could recommend, hey, you can make this unchecked and save some gas. Also, you can ask it things like, I want to write a particular value to a storage variable, and it'll tell you how you can do that, what inputs are required to reach that state, and you can also ask it, I want to execute this line of code. How can I get to that place? So let's dive into the access control analyzer. So here's a very simple function or contract where you have some variable, like my very secure variable, and this determines whether or not they can steal a billion dollars from your protocol or not.
00:05:09.070 - 00:06:02.202, Speaker A: And you have set VAR, which has the required message center equals owner. But you also have this nested call where inner sneak. It also sets my very secure variable. And so what the tool can do is you can just ask it, hey, how can I write to my very secure variable? And so you can see at the very bottom here, write access of storage variable. Function setvar, if metrics sender is equal to owner is true, and then you have an unrestricted write access of storage variable, my secure variable, via function much sneak. Right? And so a lot of the access control issues that we have today in solidity will start to show their heads a lot sooner as you're developing. And so these are very simple examples.
00:06:02.202 - 00:06:41.998, Speaker A: But as your protocol grows in complexity, this will keep up with that complexity. It can do cross function analysis. It can do cross contract analysis. So if there was an external call here, it would be able to evaluate what's inside that external call and still proceed as you would expect. So also, this is another relatively simple contract here. But let's say you want to check if state one could be set to true. How can that be done? And so you can ask it, hey, I want state one equal to true.
00:06:41.998 - 00:07:55.794, Speaker A: And it will tell you this found storage, right? That could lead to the target value. And you see here, this where statement, right? And so this where statement actually comes from the conditionals inside of your contract. So you see if B is less than three and if D is less than one, and if those both are true, then that variable will be set, and it can very easily tell you this thing in less than a millisecond. Okay, I want to back up real quickly and just talk a little bit about the behind the scenes here. So, there are multiple types in solidity, and each one of them have different ranges. And so one thing you can expect as you start to explore this tool is if you see a unit 128, it will have these bounds, and you have address E, which is the full range. And what's interesting about this method is that if I come back up to, sorry, this one, this is all based on math, but it doesn't have to be.
00:07:55.794 - 00:08:34.830, Speaker A: Right. So if you saw polygon recently had paid out a $2.2 million bounty, and that was because they have an EC recover function that when EC recover, can return the address zero. And they had a transfer with Sig. And so you could transfer unlimited polygon matic from the zero address because of this. And I ran that program through pyrometer, and it instantly showed that the bounds on the from was address zero. Okay, I also want to talk about conditionals, because I think this is really cool.
00:08:34.830 - 00:09:17.386, Speaker A: So if you have an if statement, the way this program works is you enter the function, then you come to a conditional, and what happens behind the scenes is it actually forks the world. It treats it as if in one case it's true and the other it's false. Right? And so in this example world, one is where the true statement is. And so that bounds x between zero and nine. And in the other case that, you know, the bounds are from ten to un 256 max. And so as you go along, regardless of the complexity of your program, you can tell what the bounds are despite any conditionals that you may have. And all of this works on a graph IR.
00:09:17.386 - 00:10:03.406, Speaker A: So this is a little complicated, but it's really cool. So you can actually visualize your solidity program in this graph view. And so this is sort of what's called an SSA form single assignment, basically, and you can explore the control flow graph and how your variables change inside of the program. So let's see. So I'm running pretty quick here, sorry, but the release date is very soon. An alpha version will be out March 15. You can find it@GitHub.com
00:10:03.406 - 00:10:51.722, Speaker A: nascent Xyz nascent is incredible. They really support open source and they allow me to contribute to open source. And thank you. These are my Twitter information. I would love to answer questions on this. There's a whole bunch of things I didn't cover, but yeah, any questions? Yeah, Patrick yeah, so for dependencies, what it does is it actually just acts like anything else. So if you're importing, it'll work like foundry effectively, where it'll read the foundry Toml I plan to integrate foundry and hard hat dependency management.
00:10:51.722 - 00:11:40.140, Speaker A: So as you go through it will basically bring it in and analyze all of the contracts actually in a project. And let's say you have just an interface versus the full contract as a dependency. If you have that contract as a dependency in your source files, anytime you call a function in those contracts, it will be able to evaluate the inside of that function call and apply that back. So if you're doing taint analysis, right, if you have just an interface, it will be the widest bounds because you don't know what that contract is going to do. But if you actually have the contract in your repo, it'll evaluate the inside of that and actually have accurate bounds on the return of that function call. Yeah.
00:11:43.310 - 00:11:48.350, Speaker B: You mentioned that, for example, you can ask the tool when this state will be true or false, right?
00:11:48.420 - 00:11:48.798, Speaker A: Yeah.
00:11:48.884 - 00:11:52.442, Speaker B: How do you make these questions as a developer? How am I going to make these questions?
00:11:52.516 - 00:12:33.200, Speaker A: Honestly, I can do a little demo here, but effectively it's just a Cli. So if I ask it, hopefully not leaking anything. If I save that, I can ask it write query state. This is all it is is it's just cargo run pyrometer. You give it the file, you ask it for a write query, state one. So if I do that, then it tells me found storage value and it gives me the information. D less than one, b less than three.
00:12:33.200 - 00:12:52.610, Speaker A: And I'm still working on the CLI. I can make this larger, but still working on the CLI. I will be opening this up and hope for contributors. So if you are rust aficionados, I would love to have you help. Yeah, Patrick.
00:12:58.340 - 00:13:07.664, Speaker C: It looks like it's doing like solidity analysis to get the bounds, but then you have that part about IR which makes me think, oh, do I have to compile with the via IR flag?
00:13:07.792 - 00:13:31.710, Speaker A: No. So an IR is intermediate representation, and so I have my own intermediate representation. And so this works on solidity right now. Right. And all I have to do to add another language is actually just convert that language into my IR. So I could take Viper and convert it into my IR as opposed to trying to convert it into ulir or something like that.
00:13:36.820 - 00:13:37.184, Speaker B: Yeah.
00:13:37.222 - 00:14:18.140, Speaker A: Does this do any gas ranging, like the difference between hot and cold accesses? Yeah. So one thing I didn't cover in here, and that's very intentional, is for loops. So for loops are very tricky for this kind of analysis. But my plan is, I don't currently do gas analysis, but one trick I can do is in the EVM. It's really interesting because you always know it's going to halt at some point because you have this metering functionality. And so my plan is to actually do some basic gas estimation of what's going to happen inside of your contract. And so with that you can actually put an upper bound on variables based just purely on the gas limit.
00:14:18.140 - 00:14:56.920, Speaker A: So hopefully that answers your question. Yeah, Matt, how does it handle calls if you don't know what's on the other side of that call? Right, so with calls fundamentally, so with raw. Cause you just get bytes back. Right. And so it just treats it as any kind of byte max bound for bytes. But if you have the interface, then it will base it off of the return of the interface. So if it's returning a UN 256, it's going to be zero to Un 256 max.
00:15:03.950 - 00:15:12.830, Speaker D: Well, maybe you mentioned CI or kind of a slither on steroids. What's a good first step for us to integrate into our CI pipelines to get started using the tool?
00:15:12.900 - 00:15:54.998, Speaker A: Yeah, so the plan is pretty much to focus on getting the CLI working correctly and then get a GitHub action. I've never written a GitHub action myself, so if any contributors want to help on that, that'd be an awesome contribution. And then kind of longer term, I want to actually have this. It can basically act as a language server for solidity in general with this added hint stuff with the bound analysis in line. And so that's a little bit longer term. Additionally, longer term, I want to add a query language. So if you recall, there's that simple CLI for accessing.
00:15:54.998 - 00:16:41.546, Speaker A: How do you write to this state. Right. But you can actually abstract this into a query language so that if you want to write your own analyzers, it's just a relatively simple SQL like statement into the program, and that you'll be able to write your own analyzers and we'll be able to grow the overall ecosystem of pyrometer. And also on the future plans is if any of you guys are founder users, this is actually super useful for the fuzzer. So the fuzzer right now, it's basically random number generation. What this does is it's informed random number generation. And we have all these interesting values associated with every step of the program.
00:16:41.546 - 00:16:57.970, Speaker A: And so we'll be able to take those values that are spit out by the bound analysis and use that to more intelligently generate fuzzing. And so foundries should get a major uplift in their fuzzer performance as this gets integrated.
00:17:00.630 - 00:17:01.380, Speaker B: Yeah.
00:17:04.150 - 00:17:11.500, Speaker A: You can just. Sorry.
00:17:12.750 - 00:17:26.538, Speaker E: Yeah, I just had a quick question on the differences back to slither and mythrill. Obviously, slither notoriously spits out a bunch of false positives. So trying to understand, can we expect a ton less false positives, more accurate results?
00:17:26.634 - 00:17:55.030, Speaker A: Yes. So thus far I've not found any false positives. There is an element of the auditor needing to, or the dev needing to understand. Right. So I brought up the polygon example with the EC recover earlier, you would actually have to know currently that transferring from address zero is a bad thing, but it at least tells you right. And so it puts that forefront. And the bound analysis doesn't prescribe very much.
00:17:55.030 - 00:18:09.340, Speaker A: It's the analyzers that are built on top. And so I imagine each analyzer will actually have a different false positive rate, but in general, it'll be much more limited than slither. Cool. Well, that's all the time I have. Thank you very much.
