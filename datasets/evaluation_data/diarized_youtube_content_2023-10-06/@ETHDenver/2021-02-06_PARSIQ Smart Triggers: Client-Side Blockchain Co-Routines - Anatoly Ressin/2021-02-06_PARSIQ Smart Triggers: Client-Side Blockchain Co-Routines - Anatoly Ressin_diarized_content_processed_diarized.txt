00:00:00.330 - 00:00:06.400, Speaker A: Looks like we've got Parsek and Atoli. Are we ready to go? There you are.
00:00:07.890 - 00:01:41.674, Speaker B: So I wanted to present some interesting theoretical things that are the very basis of our technology in Parsec. Because here, what we, what we actually do, we monitor data from blockchains and various sources at real time and allow users to perform data processing. And always, always we are asked, how do we, how do you, how do we process data in real time from such unreliable sources as blockchains? Because there are some problems how to create a properly rating system that need to consume data that even is not final. And we proposed very interesting concepts. And we can speak about the generalized interoperability between system without finality. And so everybody here is asking how to process non final data. But we found how to process them correctly.
00:01:41.674 - 00:02:33.214, Speaker B: And even we proposing such a technology as smart triggers. Smart triggers, they are our brand or trademark. And the real programmatic things, it's a client side blockchain coroutines. But let's go through our concepts. And I would say that we are kind of dealing with the same problems as block native presented. So they are working with the mempool. But we are working not only with a mempool, we are working with that part of the blockchain that is considered not final.
00:02:33.214 - 00:04:02.294, Speaker B: The mempool itself is not final, obviously. But when we are speaking about, for example, proof of work, blockchains or blockchains that have not instant finality, then we have kind of problems how to consume data and how to organize, how to organize calculations on top of it. And here I want to say that by analyzing blockchain behavior, we found very interesting things that maybe even will be compatible with the quantum mechanics. Because in both cases we are working with a mysterious concept of now what means now for blockchains and what means now for quantum mechanics. In blockchains, often we have such a structure. When blocks are stitched together, they are mined by miners. But there are situations when different miners simultaneously can produce a block that are attached to the same parent block.
00:04:02.294 - 00:04:35.140, Speaker B: And we obtain a situation when nobody knows which block will be included in the true history. At this moment, we can say that we are in the superposition. And we have two different realities. In one reality, one transactions are packed. In different reality, other transactions are packed. Maybe those transactions are the very same transactions. But maybe they are in different order.
00:04:35.140 - 00:05:47.580, Speaker B: And nobody actually knows in which order they will be mined. But eventually, thanks to probabilistic nature of miners competition, one of branches fades out and only one branch continues to work. It is really. It's really when one branch is abandoned and other continues as the main history, we can compare it with the collapse of wave functions in quantum mechanics. Yet there is interesting. There is an interesting note that all of those realities could be treated as real. So.
00:05:47.580 - 00:06:57.906, Speaker B: But they are real, but they are mutually exclusive. So here we can say that the problem of reaching consensus, both in quantum mechanics and in blockchains, can be reformulated in the form how to maintain consistent histories, how to have a history that is the same as mine history as your history. And we can agree on them. But it is interesting that different consensus mechanisms, they provide different strategies. How to reach the consensus. The Nakamoto consensus prescribes all honest parties to select longest chain. But even in this situation, there is the problem.
00:06:57.906 - 00:08:13.770, Speaker B: Because the information propagation speed is limited. It is limited by the speed of light and, of course, the speed of communications of our computers. And it means that even if in one space location, one miner absurds one chain as the longest chain, it doesn't mean that the same picture of the world is available to other miners. So it means that miners can continue on different blocks. And even they can create not only single block forks, but they can continue those blocks. And we have interesting picture that those realities can evolve simultaneously and be mutually exclusive. And even in those cases, I want to say that we are dealing not only with chain based blockchains, we are covering blockchains that are as well dag based.
00:08:13.770 - 00:10:08.910, Speaker B: But in every case, we have such situations that, for example, if it's a chain based histories, then we have such a structure of such a structure of different realities that we need to protest simultaneously. And, for example, if we are deck based, in deck based systems, conflicts, conflicting histories can appear as well. Yet, in any case, when we are dealing with events from different systems, we are linearizing these events. And it is an interesting thing that the traditional blockchains could be compared to the Newton's global time. In newtonian physics, where it is believed that there is a global time that works simultaneously in all points in universe and the space is separate. But deck based systems, they could be compared with einsteinian time, where only causality between events forms the flow of the time. But in all of those cases, we have notion of local time, of local time, of the observer who observes, who observes those systems and the sequence of observations.
00:10:08.910 - 00:10:51.710, Speaker B: They are always linear, but they are linear. But we want to say that they are as well, hierarchical. They are hierarchical. Because what we observe, we actually observe conflicts between histories. And we at parsec found a very nice way how to work with these conflicts and be able even to apply stateful computations on top of them. We introduced a notion of weak oracles. Weak oracles and their implementation is hierarchical observables.
00:10:51.710 - 00:12:03.410, Speaker B: First of all, let's define what we call an oracle about the oracle of type t. So we are working with strongly typed streams of events. Oracle of type t we define as a data stream that possibly lacks underlying algorithm. It simply takes data from somewhere, we don't know from where and it delivers those data for us. In most cases this data is taken from the reality and the absence of algorithm is kind of important moment that we cannot rely that there is any algorithm. Of course oracles could be modeled with algorithmic data streams that generate numbers, for example. 12345 but most of observations are taken from reality where no algorithms algorithm is believed to exist.
00:12:03.410 - 00:12:52.558, Speaker B: This is our notion of oracle. And now we define a notion of weak oracle or more specifically nweek oracle where n is integer number. We say that the weak oracle is the same as the normal data stream or normal oracle and it produces stream of items of type t yet it can withdraw up to n items from already generated sequence. Just imagine an oracle that gives you data. 123450 stop. Oh stop. I just made an error.
00:12:52.558 - 00:14:32.020, Speaker B: Let rewind back three items and I will give you new items. This is exactly what happens when you work with blockchains and we just capture this notion into weak oracle. And we say that if we have a weak oracle of type t and finality depth with given five finality depths, then we can state that if n plus k items are generated then first k items are final. So it means that if we are speaking about three week oracle sample, let's speak about three week oracle. This is oracle that have a finality depth that is equal to three. It means that if this oracle produces items one, two, three, it means that at this point he can say, looks like those are not correct items, I will generate over and withdraws all those three items and produces four, two. And then because he didn't return more than three items it means that he can repeat these withdrawals as long as he want.
00:14:32.020 - 00:15:14.622, Speaker B: Even he can return to his original sequence. He can say okay, maybe the original sequence was correct. 1234 and exactly here. And exactly here. When three items above one was generated it means that one is already final. It's already final and one will be never withdrawn by this oracle. And it means that this oracle can continue provide values three, two, 5410 and as you see our oracle is three week oracle.
00:15:14.622 - 00:16:44.570, Speaker B: And it means that his space where to roll back is limited by these ones. It means that three and two are now final, and they are already presented to the external system that can consume them, yet they can consume them if they want real finality. But actually what we allow programmers, we allow programmers to write programs in their normal style on top of those weak oracles. They can consume those numbers in even imperative way and think that they are always in a correct branch. And I want to say that there are several generalizations of weak oracle. So first of all, it is quite simple generalization from fixed depth oracle to geometric oracle that actually can return back to as many steps as he want. But those steps for rolling back, they are covered by the geometric progression.
00:16:44.570 - 00:17:43.070, Speaker B: So the probability of rolling back to k steps is equal to p times q in power k. Where we have a normalizing equation, that sum of all probabilities is equal to one. And the probability p can be calculated from this equation. So our oracle just parameterized by the type t and the base of the geometric sequence. This geometric oracle is perfect for describing proof of work. Blockchains like bitcoin, like current state of Ethereum. I don't remember exact queue parameter for them, but they are described very well with the geometric oracle.
00:17:43.070 - 00:19:26.222, Speaker B: And another type of generalizations is natural oracle when we are working not with discrete time, where we are working with processes that are continuous over time, and the probabilities of rolling back is calculated according to exponential distribution with parameter lambda, those are essentially not blockchains. And even it is a good question where exist systems that can behave like natural oracles. But our hypothesis is that our reality, that our reality, our quantum reality could be described as natural oracle with some parameter lambda, where of course it's a kind of parameter that controls a rollback. And if somebody remembers formula from the school or from the university, we have one divided by lambda. It's a mathematical expectation, mathematical expectation of how long will be our time where branches can be switched. It means that one divided by lambda could be potentially a fundamental constant that constrains quantum superposition time. Of course, if we also consider relativistic effects.
00:19:26.222 - 00:20:27.906, Speaker B: Yet those are very interesting applications of this theory, but they are purely speculative and theoretical. Let quantum physicists evaluate them. We will use our abstractions on top of blockchains. But I want to say that probably you see here that for example, if Oracle produced those numbers and then presented us another numbers, probably it looks like that those numbers is just the same numbers. So we are observing competing branches. So Oracle tried to present us one branch, then another branch. We don't speak about their lens because we do not cover the policy on which Oracle selects the correct branch.
00:20:27.906 - 00:22:33.600, Speaker B: But we say that oracle has some meaning of correct branch that should be presented to consumers and that forms very interesting interpretation of weak oracles like views to a hierarchical multiverse with resource bound branches. So let's imagine our reality like a blockchain where eventually some branches are appearing, but according to some rule they are selected and only one branch is presented and continued. But as well those are purely speculative theory. Let's come back to our computer science things. We found that our formalism generalizes very interesting and important concept from practical programming, specifically ability to switch between ability to switch between branches and forget branches that are not actual. This type of functionality absolutely resembles and models very well promised consolations promised consolations that were proposed by several people, notably this at the library of Bluebird by Pet Cantonov. And a more interesting proposal, more consistent proposal that was proposed by Dominic de Nicola of Google.
00:22:33.600 - 00:24:24.494, Speaker B: He proposed how to incorporate cancellations into the core of the Javascript. So we had a chance that the Javascript itself will be equipped with a very essential primitive how to forget about those branches that are not needed. But TC 39 rejected this proposal. It was a long battle for that. And you can Google about the proposal itself, but we found that our proposal of weak oracles, it is kind of generalization of asynchronous iterators and really they need to be implemented within a language for now, no language for now supports them. So we decided to create our own language that allows to consume Wick oracles to consume wik oracles like they are async iterators. So you just can go through them, you can consume, you can filter, you can map them, you can do everything that you are used to do with normal data streams, yet every stateful variable in your program has a history, and that history is maintained exactly in the form of the hierarchy that corresponds to the hierarchical nature of the source.
00:24:24.494 - 00:25:35.366, Speaker B: So if you consume data from blockchain, it means and you create a calculations on top of non final blockchain part. Then at client side we are propagating non finality to your program and you can think that you are always in a correct branch. It's a very good counterpart for the solidity language. For example, if we treat solidity language like server side language, because blockchains are usually treated as the new back end of the new era applications. And this means that the solidity itself is the server side language. But the client side language that really embraces the same concept of the blockchains and is able to consume even non final part of the blockchains. It's not ready.
00:25:35.366 - 00:27:32.974, Speaker B: Users are forced, programmers are forced to consume those data and even to wait until this data will be finalized to make some things, some notifications or some actions, or they need to create their own mechanisms, how to maintain, how to manage these reorganizations. And we at Parsec believe that this is purely an accidental complexity that should be removed from the programming and even in those, even in those scripts that are written in our language. So language is in very deep infancy. It is available in our portal and you can easily consume blockchain data, perform calculations on top of it. But what we are working now on is the ability to deliver the entire context of the event to the client side. We at Parsec created an ethereum node instrumentation that allows firstly to obtain entire block traces with all the gas point timestamps. Because a lot of programmers, they are asking how they can retrieve data from the past, from the archive node, not at the block start, but somewhere in the block middle.
00:27:32.974 - 00:29:05.770, Speaker B: But we implemented more interesting solution. We implemented an ability to ask any state at any gas point starting from the block beginning. You can easily with our instrumentation of archive node that is actually open source and you can download it, or you can use our API that is available through our starter pack, just see our Parsec channel and you can download, you can access this. And this allows us not only propagate events to the client side, but equip those events with the hierarchical time points at which block, at which transaction at which gas point this event was created. And this allows us to ability to go back to our node and download information that will be decided by the user logic. No block trace on either scan or other traces is able to predict which information you need. Maybe you need, for example, uniswap rate on given pair at given transaction.
00:29:05.770 - 00:30:22.740, Speaker B: We can do it. We can do it. And it means that when you are writing a script within our system, you are feeling yourself like you are in the very same context of the transaction that you are processing, but you are processing them not inside the solidity but outside, and you are processing it by parsic. And actually we are equipping our, our events with those time points. And it allows us to say that we actually implement client sites, blockchain coroutines. Just a couple of words about the form, how we deliver, how we deliver our product. We have a portal that allows you to write scripts in our language or even those who cannot code.
00:30:22.740 - 00:31:30.330, Speaker B: You can create scripts by using our visards, but we are actually targeting developers. We are actually targeting developers and we ask developers to build, to try our technologies and move together with us. So here we have instrumentations of all nodes. We provide such instrumentations that allow us to time travel through the history of all blockchains. It's a bitcoin, it's a full node of Ethereum, and even we have very good indexes about all the smart contracts, their creation time, their creates destructions. And all those things are available through our API and you can consume it. We work with such interesting projects and we are preparing instrumentation of the Salana node.
00:31:30.330 - 00:33:25.440, Speaker B: It will be very interesting because our language very well suited for writing logic for Solana and maybe we will have more deep integration with Solana than with other nodes. Yet most interesting thing for the observability now happens on the Ethereum and we provide an API and if you want you can work on top of our API, but we as well working on the community version. So you don't need use our portal. In any case, just for those who want to rapidly prototype and don't want to host their own nodes, the portal is for you. But for those who want to try our technology on premise, we are creating parsec demon that is connected to all those nodes and you can manage their scripts written in our language and they will constantly monitor all the activity in those blockchains and allow you to express your smart triggers. We call them smart triggers with that notion of weak oracles under the hood. But you actually don't need to understand all those technologies, you just write what you want.
00:33:25.440 - 00:34:58.806, Speaker B: And soon we will provide a standalone administrator application for a while. It is available only through our portal, the similar interface, but it will be as well available through the self hosted node JS application. And just about the language itself, the language is very simple. It resembles link you by Andrews Halesberg from C sharp. That allows you to perform SQL like operations on top of data streams and data collections. But we are proposing those operations on top of weak oracles that are connected to blockchains. So you can easily filter with where condition you can select and you can perform aggregations, you can calculate everything that you want, all the turnovers, different market pressures and what we as well implemented.
00:34:58.806 - 00:36:25.862, Speaker B: We implemented connections with third party APIs that it means that you are not only creating a script that is able to consume blockchain data, you are able to mix data streams, you can easily attach risk scoring data, you can easily attach market data, mix all those things and deliver to every channel that you want. So we have various transports how to deliver those things. For programmatic things, we have a process statement that is very simple. It's not even turing complete. It allows you to create branches, analyze conditions, emit new events downstream, and most powerful things. You can use a state, you can use a state that is protected by our oracle logic. And you will be able to monitor the state either through notifications or through database that maintains the state.
00:36:25.862 - 00:37:20.360, Speaker B: So you will have information about the historical values of those states and the current best state, best known state that corresponds to the current best state of the blockchain. That is actually what I wanted to present. I'm asking you to visit our channel in slack on the east Denver and try to download our starter pack that will allow you to try our API and implement very interesting applications. Let's go together.
00:37:24.730 - 00:37:28.774, Speaker A: Cool. Can everybody hear me okay? Can you hear me?
00:37:28.812 - 00:37:29.446, Speaker B: Yeah.
00:37:29.628 - 00:37:34.670, Speaker A: Thank you so much, man. It was really great to see you. And I actually loved your graphics.
00:37:37.090 - 00:37:37.406, Speaker B: For.
00:37:37.428 - 00:37:44.480, Speaker A: As much work as people put into things. That seemed like a lot of work, but it seemed really authentic. So thank you for that. We really appreciate it.
00:37:45.170 - 00:37:45.660, Speaker B: Thank you.
