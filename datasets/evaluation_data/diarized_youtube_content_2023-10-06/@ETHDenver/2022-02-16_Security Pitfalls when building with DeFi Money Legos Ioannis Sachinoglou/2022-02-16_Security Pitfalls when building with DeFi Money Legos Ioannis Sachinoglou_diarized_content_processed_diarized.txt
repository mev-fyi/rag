00:00:01.530 - 00:00:46.806, Speaker A: Thanks a lot, first of all, for joining this presentation. My name is Janice and I work for send security. I don't know how many of you know sense security. We're smart contract auditors. So the last four years, we had the chance to work with many super interesting projects. And today in this presentation, I want to summarize some of the common pitfalls we see repeating again and again when we audit projects, especially projects which build on top of the so called Defi manilagos. So I have structured this presentation in a way so that even if you get lost at any point, or if I get too technical, you can follow the next slide.
00:00:46.806 - 00:02:04.900, Speaker A: So I hope it's going to be quite interesting. So we all know that the last couple of years, especially, there has been an explosion in the number of protocols. We have protocols for trades, we have protocols for lending, we have protocols for staking all sort of protocols. And interestingly, the protocols are getting more and more complex and our work as auditors, but your work as developers as well, has become more and more difficult. Today, I want to focus on this property of Ethereum, of the smart contract technology, the so called composability, where we can essentially build protocols. I'm going to refer to them as second level protocols, where you essentially create a financial model which relies on interacting on other protocols, for example, trading or lending or whatever. And I want to point out even from this point, that it is really hard and it is really challenging for developers and auditors to really understand the behaviors of all sort of protocols that they want to interact with.
00:02:04.900 - 00:03:00.630, Speaker A: So in my presentations, I will present just eight of these issues that I hope cover a wide range of what we see and what we've seen, and we might continue to see at sense security. So in order to make the presentation a little bit easier to follow, let me give you a more concrete example of such a second level protocol. So let's imagine we want to build an onchain fund, right? So what is a fund is it's essentially a pool of money. So we can store this money in an onchain smart wallet. That's easy. And we have then a manager who creates a fund and manages the assets the fund holds. So the manager tries to increase the value of the fund by interacting with various protocols.
00:03:00.630 - 00:04:09.830, Speaker A: Then we have the users. The users want to participate and invest in a fund, and for that they deposit some value and they get back some shares of the protocol. And of course, they need to know the shares, the price of the shares, right. And the most important feature is that we want to give as little trust as possible to the manager because remember, the manager will be essentially controlling funds and assets that they don't own. So what issues do we see here? The first, and I guess most important issue is that if we want to interact with external contracts, we essentially need to pass at some point make an external call and pass the execution flow to an arbitrary contract which implements an arbitrary logic that we might not be aware of. This is of course quite tricky and raises a lot of security questions. So for that, most protocols we've seen choose to implement these so called adapters.
00:04:09.830 - 00:05:21.058, Speaker A: So what is an adapter? An adapter is just a contract that will be sitting between our fund and the external protocol. So our fund, in order to interact, for example, with Uniswap, needs to go through the Uniswap adapter, make a call to the adapter, and then the adapter will make a call to Uniswap. So this way we have a win win situation in the sense that not only do we limit the number of protocols the manager can interact with, because they can interact with as many protocols as the adapters that are available, but more interestingly, we limit the actions that the managers can perform using these protocols. For example, the Uniswap adapter will implement only specific calls to Uniswap. For example, swap tokens for tokens and nothing else. I want to insist a little bit more on the adapters because as I told you, it's super common pattern. So first of all, as you know, gas fees are really high.
00:05:21.058 - 00:06:42.990, Speaker A: So we don't want to deploy adapters for every fund we create, right? So we want the adapters to be shared among funds. What this means is that the result of interacting with an adapter shouldn't be affected by other entities also interacting with the adapter, right? Because we have multiple funds that will interact with this adapter. So in a way we want the adapter to be stateless. Another really interesting issue that we commonly see is that the logic of the adapter somehow doesn't make clear to the external protocols that the adapter is just representing a fund and it's not itself an entity that makes an investment. To give you an example, imagine that you want your fund to stake on curve. Of course you have to pass through an adapter to do this, right? Because as we said, we don't want to directly call curve. Then we need to make sure that in our adapters logic we show that the fund is the actual staker and not the adapter.
00:06:42.990 - 00:07:54.574, Speaker A: Another really important point is that sometimes people forget that the adapter might end up in a state where it is not expected by the protocol. For example, the adapter might end up holding some funds, and if this is not expected when we implement the protocol, then the adapter might be useless. Or maybe the internal accounting might be wrong. So what is internal accounting? And there are a lot of issues which relate to this. So internal accounting refers essentially to how many tokens a fund holds, right? And how the number of tokens that are held by the fund change when we interact with a protocol. So it is really tempting, and we've seen this many times, that people use the API that the external protocols expose wrongly. For example, it is quite tempting to use the return values that a function call returns to do this internal accounting.
00:07:54.574 - 00:09:11.390, Speaker A: And just to give you a more concrete example, imagine that we want to interact with Uniswap and we want to call swap exact tokens for tokens, for example. And we say okay, then the return value is essentially the tokens we received, right? But unfortunately this is not true, because we might have also tokens that have fees, and Uniswap will only tell us how many tokens it sent to the fund, but not how many tokens the fund actually received. This is quite problematic, especially if we do this again and again. So the internal accounting might end up being quite off for that. People usually implement the logic this way, so that the fund itself is responsible for this internal accounting. And of course, this requires squaring the balance and entails higher gases, because of course this requires to do many reads from storage. So another really interesting issue that we see a lot has to do with trading.
00:09:11.390 - 00:10:21.038, Speaker A: So as we said, the manager always tries to increase the value of the fund, right? And for this, they do trades, many trades. Many trading platforms allow the manager to specify a path to do this trade. So let's imagine that we have a malicious manager who wants to trade USDC for die. You'll know that USDC and die both are stable coins that are pegged to $1. But what happens if the manager creates a malicious token and defines a path that includes this token? It can make it look like it can make the first pair think that the malicious token is worth, for example, 1000 times more than USDC. So if we give 1000 USDC, we will only get back one malicious token. Then, since again the manager controls this token, it can make it look like the malicious token is worth the same as die.
00:10:21.038 - 00:11:23.410, Speaker A: So when we do the next exchange, we have, remember, only one malicious token, we will get only one die back. And of course this is not what we want because we gave $1,000 and we got only $1 back. So there are many ways to mitigate this. Some people have tried to, for example, sanitize the paths and only allow specific tokens. But I think this issue points to the need to be quite for our fund and for our protocols to be quite thorough with how they do the value estimation, or in other words, how to derive the prices of the tokens they want to hold. So value estimation, unfortunately, is also problematic for well established tokens. Things are easy because we have oracles available, so there is not so much room for manipulation.
00:11:23.410 - 00:12:38.190, Speaker A: However, what if we want to hold arbitrary tokens? Many people have tried to rely on deXs, but Dexs decentralized exchanges are also easy to manipulate. So for example, back to the example of USDC and Dai. We might manipulate the pool in such a way, for example with flash loan, so that USDC and dai are not worth the same. Another point, which is a source of a lot of hacks and a lot of issues, has to do with derivative tokens. Derivative tokens are tokens that rely, that get their value from an underlying token. So imagine that we stake ethereum in a protocol and we get back a derivative token which represents the shares of the vault that we staked the ethereum. Usually what happens with these protocols is that they expose a view function where people can query which people can query so that they get the price of the derivative token.
00:12:38.190 - 00:14:13.786, Speaker A: But unfortunately, if the protocol that exposes this function gets hacked, then again, we can manipulate the price and either undervalue or overvalue the assets that we have. We've seen it many times, and unfortunately, since an audit is only limited in the scope, in that case of the onchain fund, we are not able to be sure whether external protocols are safe enough. So what I want to point out here is that we need to be really careful about which tokens we include in our protocol. Of course, it wouldn't be a security talk if I didn't talk about reentrancy, right? So what is reentrancy? We have a reentrancy when an execution is interrupted and another one begins and both complete. So unfortunately there are many reentrancy opportunities when we work with multiple protocols. Just to point you to an example, many standards give opportunities for reentercies. For example, when we transfer an ERC seven to one, or an ERC seven seven, the receiver of the token is allowed to execute an arbitrary logic.
00:14:13.786 - 00:15:18.850, Speaker A: To give you an example, how bad this can get. Imagine that we have a fund, and imagine that we have a contract that holds some shares of this fund, of this fund, and it calls withdraw. Then at some point the fund will give back some tokens and it will make this callback to the contract. The contract now can execute, as I said, arbitrary logic. So what happens if the contract now makes a deposit? If the withdrawal is not completed, then our fund is in a sort of limbo state. And of course, the result of the deposit might be completely unexpected and have detrimental results. Of course, a way to mitigate this is with locking, but unfortunately, locking is not always easy to implement.
00:15:18.850 - 00:16:49.946, Speaker A: So another point that we usually see has to do with redeemability. So, as we said, people participate in the fund and they get some shares, and at some point they want to materialize their shares and get some profits or some losses, unfortunately. But how do we do the redemption? Should we allow users to redeem in a specific token, or should we allow users to redeem using all assets that our fund holds? This is a quite tricky question. For example, what happens if our fund doesn't hold enough of the tokens we want to redeem in? Should we, for example, exchange some other tokens? What should we do? The answer is not clear, and it's a source of many problems. But the most important thing about dimability has to do with the availability for redemption. So there are many actions of the manager that can completely block redeemability. For example, imagine that I am a manager and I get the full value my fund holds, and I use it as a collateral to get a loan.
00:16:49.946 - 00:17:58.120, Speaker A: Then of course, I cannot withdraw, right? Because all the value is used as a collateral. Another case might be that we want to, for example, redeem in a token, which has some peculiarities in its behavior, and that it doesn't allow transfers all the time. And this brings me to the last and maybe most important point. Each protocol is unique, and it's really hard to really know all the behaviors that it can exhibit. And for that, you really need to go down this rabbit hole and fully understand the protocol. Just to give you an example of a really hard protocol to handle, the synthetics protocol and this peculiarity that it has for synthetic tokens when they are exchanged. I don't want to get into more details, but it's quite interesting and we see it really often, people not getting it right.
00:17:58.120 - 00:19:24.026, Speaker A: Another source of peculiarity has to do with the reward tokens that are issued and how they are handled by the fund. But most importantly, sometimes we forget that we interact with protocols that have moving parts which can upgrade, and an upgrade can introduce a new behavior our protocol does not expect. This can be a source of many attacks. So not only do we need to know the protocol when we develop it, but we also need to know the protocol and how it changes over time. So, to sum up, we've talked about how to limit interactions with external protocols, how to do the accounting and the value estimation correctly, and most importantly, how to be prepared to handle unexpected behaviors. Unfortunately, the future looks way more complicated because we have more and more protocol calls coming up. And of course, now we have many layer one and L2 solutions, and there is a requirement for communication between these solutions.
00:19:24.026 - 00:19:29.980, Speaker A: So thanks a lot for your attention, and I'm more than happy to answer some of your questions.
