00:00:13.130 - 00:00:44.540, Speaker A: Hey, everybody, my name is Paul Cowgill and I'm with a project called Taset, and the talk today will be about native mobile Ethereum dapps. Thank you. So for an outline, basically I'll answer why someone would want to build a native mobile Ethereum dap. Talk about a common concern, which is censorship, and then show how you might do that. The building of the native mobile Dap. As I mentioned, I'm Paul Cowgill, that's my Twitter handle. Sort of an ethereum generalist for the last two and a half years.
00:00:44.540 - 00:01:39.580, Speaker A: So why build a native mobile Ethereum daP? Well, basically right now we're building everything for laptops. But if you talk to anyone who's relatively young or anyone globally, they use their phones a lot more than their laptops. I know we use our laptops a lot, the people that are here, but it's sort of self evident that phones are kind of where it's at in terms of mainstream users. There's a lot of talk about progressive web apps as well, and those are great. Right now, it seems like the average mainstream user is much more comfortable downloading a native mobile Dap. And people might use a web based DAP to start, but then if they become a power user, they tend to want to download the app. So if we have an Ethereum DaP, we ought to be providing experiences like that for those power users so they can do it however they would like to.
00:01:39.580 - 00:02:49.262, Speaker A: What are some good situations where native mobile makes sense? If your target user base is those young or global people, if there's a high frequency element to what you're doing. So, like, if you're often interacting with the app and or if there's something that you have to act in real time, you have your phone with you at all times, you don't with your laptop right now, it tends to be things that are lower stakes that you might want to do on your phone. So maybe not buying a $20,000 parcel of decentraland land. But again, lots of people only use their phones and not laptops. So people are getting more and more comfortable with doing even pretty weighty things on their phone. And then of course, if there are any of the features that are core to native mobile that you can't even really do on the web, like camera or gps or biometric auth, or at least that it's much more awkward to do on the web, those make an app a great fit for native mobile as well. And then finally, there's a much better data persistence story on native mobile.
00:02:49.262 - 00:03:52.518, Speaker A: You can definitely put stuff in local storage or use some of the new browser APIs on web, but you don't have quite the same guarantees for when that data is purged. And the sdks for interacting with that data just aren't quite at the same level as with mobile, where offline first data is a very common pattern. So what about censorship? In short, as long as you don't have a private key on the device where that phone is the only way that they can control the funds that that private key controls, you're pretty much good. So two ways to do that are with contract based accounts where the key that's on the device in that app is one of many signers. Or you can use wallet connect as well, where there's a different wallet and you're just having the experience in the app, but using actually a different wallet to authorize know. Consider some of these scenarios. Apple might remove the app if you have built it in React native, which is kind of what I'm pushing for here.
00:03:52.518 - 00:04:30.530, Speaker A: At least it'll work on Android. If Google takes it down, at least it'll work on iOS. And even if you have them in both App Stores for a while, but then it's taken down. The beauty of React native is that it's quite similar to react, which is what most of your web based apps are built in already. So there's tooling like React native web so that you could build it mobile first, but have it work as a web experience as well. And you can also get clever about sharing parts of the components, but maybe not the styling between native mobile and web. So contract based accounts and react native get around a lot of those censorship concerns.
00:04:30.530 - 00:05:32.130, Speaker A: And finally, big tech co companies do change based on the feedback they're getting on a long enough timescale. So I think if we enable a lot of DAP developers to make more and more native mobile dapps, they'll kind of see that they have no choice. But if they want to remain a viable option for how people can download apps, they need to accept more and more dapps. So I think over time, censorship will be less and less of a problem through this channel anyway. Well, so with that addressed, let's talk about how to make it happen. The goal here is a simple uX, but without sacrificing any of the things that are important to us as part of this movement, a couple criteria by which you might evaluate that are one, if you have a native mobile app and it goes away one day, say your project runs out of money and it becomes stale and you're not able to keep upgrading it so that it stays in the App Store. The user should be quite sad, but they shouldn't be totally screwed.
00:05:32.130 - 00:06:43.840, Speaker A: So as long as the contracts are still the same permissionless contracts that your native mobile app is hitting, but you have a contract based account, so there's seamlessly web based experience through which they can do that as well. Then that kind of fits with the ethos we're aiming for here. And also you ought to assume that the user probably isn't crypto native, but still offer options for the purists among us. So if you want to add more and more signing keys to the contract based account with hardware wallets or whatever more advanced config you want, that should be an option, but perhaps buried somewhere a little bit deeper in the settings. Okay, so with those goals in mind, what's needed to do this? Well, I've divided up into the onboarding part, kind of the ongoing UX and mobile specific stuff. I'll go into these in more detail so I won't read them off here, but these are the three major categories here. And at my project taset, we are aiming to make it as simple as possible to do all those things while building on lots of great existing work in the ecosystem as well.
00:06:43.840 - 00:07:45.886, Speaker A: Onboarding to start I think in order to attract the next wave of users, we can't have a two step process where you first have to set up a wallet and then get to use adapt. The setup process for a new wallet needs to be embedded into the app. So the SDK powering this is built with that use case in mind. And what does that look like? So from the tasset SDK, you can import the account package or module or whatever you want to call it, and just create a new burner wallet that's in DAP and use it from there. So not too dissimilar from the way we're buying food with burner wallets at this event. Here's the point where someone might feel sad that there will end up being lots of different accounts, I think in a kind of counterintuitive way that's not actually a bad thing. So again, if you consider mainstream users, they probably don't have another account yet anyway.
00:07:45.886 - 00:09:03.580, Speaker A: So this is the first account, and depending on how heavily they're using this DAP, you can add more and more features so it comes to resemble a proper wallet more and more closely, and this can evolve into their main account. But also, as a crypto native power user it's nice from an OPSEC perspective and an accounting perspective, to not mash everything I do on web3 all into one spot. I do some games related things, and I wouldn't want that intermingled with my DFI activity. You can always stitch that together between multiple accounts after the fact, but it's much harder to disentangle it if it's all happening from one account in the first place. So now what? If you want to upgrade the security? We'll say of that ephemeral account, there ought to be support for contract based accounts as well. So you can basically call account upgrade with the address of that burner ephemeral account, the ENS username you'd like to use, and the type of contract based account that you'd like to upgrade to. So it could be inosis safe, could be argent, could be a bridge, could be ethereum, could be a whole lot of things, and I think it makes sense to provide a sensible default, certainly open to feedback on what that default ought to be, but make it configurable between those different contract based account types as well.
00:09:03.580 - 00:09:57.050, Speaker A: And you can see here from the variable naming that it's creating a create two style contract based account. So it's not actually deployed yet, but you do get to know the address ahead of time. So perhaps in the app, only once the user has accrued enough value that it warrants deploying it. You might consider deploying it then, or if there's another transaction they need to initiate or something like that. And then at some point you do want to deploy that contract based account. So there's another function you call called deploy, and at that point you have a contract on Mainnet where the username has become the subdomain on that DAP's Ens name. Sort of more musing on how this 100 accounts per user thing isn't actually a bad thing, depending on how heavily a user is using them.
00:09:57.050 - 00:11:21.320, Speaker A: Some of those might be upgraded into contract based accounts, some might not, and they can be split into different buckets of life that users use different types of apps for. And I think comparing it with how we use web two is pretty instructive. Here you have different accounts for basically every app you use, and I don't see why it ought to be different in web3. Doing things like investing and doing things like having social apps are quite different experiences, and again, you can always stitch them together after the fact, but having them separate by default is quite nice. If you do want some of those stitching together features, there's always the option of inheriting account recovery settings from your argent wallet, for instance, or adding your primary wallet, be it a contract based wallet or a regular wallet as an additional signer for that DAP wallet, or providing a seamless experience for transferring funds between the user's main wallet and that endap wallet. The other key piece of this onboarding part is letting the user get money as easily as possible. I saw a great talk from El Thea yesterday about how 60 year old users in Oregon used to have to onboard through Coinbase, but they switched over to wire and it's dramatically improved the experience for all their users.
00:11:21.320 - 00:12:12.116, Speaker A: Wire doesn't work in every country. This is not my tweet, but I think we definitely need a thing like this where there's just a single SDK for all of the fiat onramp solutions. Happy to work on this with people, happy to have someone else build this, but definitely going to expose something like this in this SDK. And the nice thing about that is this is one other thing that makes it less awkward to have a new additional account because you don't have that moving funds from your main wallet problem anymore. The second of three buckets for having a great native mobile experience is the ongoing UX piece. One key part of that is having an optimistic style UI. So basically what that means is, yes, as an implementation detail, you're using Ethereum behind the scenes.
00:12:12.116 - 00:13:24.940, Speaker A: And yes, transactions take a while to be confirmed once or seven times, but you can be very clever about how you present that to the user. So if you take for an example, sending an NFT here, you can import contract from the test SDK, get the NFT subtype of that instantiate, basically associate the ABI that's already part of the SDK with this address, and then in a non async fashion, do a contract safe transfer from to build this thing you want to do. But notice that here we're not awaiting it, which is sort of the standard way people tend to do ethereum transactions right now with like ethers or web3. And that's because you might want to do something in the UI exactly at this moment, and not after having awaited it. So after having built the action, you can subscribe to errors or one confirmation or whatever constitutes enough confirmations from your perspective, and then send the transaction. And I also like await. So it might be fair to say, hey, this seems like a little more awkward way of writing it, but I think the benefits outweigh the costs here.
00:13:24.940 - 00:14:16.450, Speaker A: I know that even though with await style you could build an optimistic style UI. I just find that people don't tend to do that. It becomes so tempting to await the first confirmation that that basically ends up being what people do. Another key piece is not having any in order to satisfy that criterion of letting users be sad but not devastated if your app disappears. It's nice if you're using a service like the graph, rather than having your own proprietary backend with like a postgresdb. So beyond just awaiting confirmations directly through a library like ethers abstracted through the tacit SDK if you like, you can also await its presence having been indexed on the graph, and the API here looks essentially the same. So that's just a nice little convenience feature here.
00:14:16.450 - 00:15:27.910, Speaker A: And then of course you can do things like querying for the last 100 events of things that went for sale on a marketplace too. I know that the graph is starting to work on writes in addition to reads too, and will likely support that as well. So if you wanted as a developer consuming this SDK, you could do all your reads and writes through the graph, so that you would lose a bit of that awkwardness of the mismatch in API style between GraphQL and ethers. ENS is a really important piece. You don't want to be throwing addresses in users'faces too much. So out of the box, since we use ethersjs under the hood, you can send it to anyone with an ENS address and then on the receiving side, basically any DAP using this SDK can have whatever Ens top level domain it wants, and the user can have a new subdomain on top of that. And of course metatransactions are very important in some cases, especially when the user is new and hasn't yet been sufficiently motivated to connect their debit card through Google pay through wire or whatever.
00:15:27.910 - 00:16:19.584, Speaker A: So the thing that's different here is this action send for free function. So there's out of the box support for metatransactions rather than standard transactions. Again, depending on your use case that may or may not make sense for different transactions. And then there are the mobile specific features, many. Again, for the user that has never used any Ethereum DAP before, this piece is less important. But in order to make it palatable to those who already have a wallet that they really like using, making it pretty seamless to move funds back and forth with that wallet is something that ought to be supported out of the box. So you can basically pre populate a transaction that you would like to be built in a different app and send that through a deep link.
00:16:19.584 - 00:17:07.704, Speaker A: So also very interested in what people's thoughts are on what the standard ought to look like for this, and this is a major focus of what we're working on. I don't have much to say during this presentation about biometric auth and push notifications, but just to remind you, those are things that are quite cool, that are very specific to native mobile and that you want to support out of the box. But there's nothing too surprising to say about how these work. Basically, you have the private key in a secure enclave and you'll be able to perform transactions using that private key after having biometric auths for some period of time. Yada yada, yada. At this point I've talked about a lot of features and it might be starting to feel like we're boiling the ocean here. Definitely would argue that we're not.
00:17:07.704 - 00:18:20.908, Speaker A: The team is myself so very much trying to avoid extra work wherever possible. So we do use great sdks under the hood as much as possible, and that's one subclass of conversation I'd like to have lots of at ETH Denver great sdks that are good fits for being in some cases exposed directly through this SDK, or perhaps abstracted a bit to offer some of these features in order to make that work. I have felt this pain point with some other JavaScript sdks. It can be tempting if you're mainly considering a browser environment to use a lot of the new browser APIs, but the more you do that, the less isomorphic that JavaScript is. So if you're going to do that, at least maybe make an abstraction layer around that and then hit the browser APIs so that it becomes simpler to swap out those pieces for the native mobile equivalents. Scaling and privacy are two extremely important topics, and I think for this project we're still at the stage where we're keeping an eye on what the community gravitates towards there. Obviously L2 is very important.
00:18:20.908 - 00:19:24.388, Speaker A: ETH two is coming quite soon, and there are lots of great privacy preserving technologies like nightfall, for instance, coming out very open to folks input on what makes sense in a mobile environment here, but kind of too early to say right now. Look for over the next six months some announcements about what we might be doing on this side of things. So to wrap up, this is a super controversial point. I argue about this on Twitter a lot. Dapps do already offer value to me in very tangible ways that I can't do with lots of web two apps, just like a super trivial example, spinning up a multi sig is so cheap and so fast and offers something that there's no way I could have done otherwise. So if that's the case that lots of us at this conference are getting tangible value from Dapps, then the only problem is the way they're packaged. Regular people have some of these same needs, like managing funds as a group.
00:19:24.388 - 00:20:34.996, Speaker A: That's a pretty common social human issue to come across. So if we deliver apps where the users are in a way they can understand, we can see like 100 x thousand x growth. Setting aside the scaling discussion for a moment right now, and so I think by building layers of abstraction like this SDK we're working on, it enables a team that has maybe made a mobile app before, but hasn't gotten too deep into the Ethereum ecosystem, but a very talented web two product team to start delivering value to users using Ethereum during the course of the rest of today and tomorrow. And also, just in an ongoing fashion, actively looking to talk to users who would be interested in using native mobile dapps, and even more importantly, timing wise, talking to developers about what it would take for this to be the right fit for you to build native mobile Dapps with. So again, here's my Twitter handle. Feel free to reach out to me or just find me at the conference. One cool announcement.
00:20:34.996 - 00:20:58.684, Speaker A: We got some funding to build this from the Ethereum foundations. The first told anybody that for the most part. So pretty excited about that. Yeah, thanks. And also have lots of generous support through the Gnosis ecosystem fund and Gitcoin grants. So thanks to all those initiatives. And then here are a bunch of URLs.
00:20:58.684 - 00:21:03.230, Speaker A: Feel free to go to any of these. I know it's kind of overwhelming, or take a picture of it. Good idea.
