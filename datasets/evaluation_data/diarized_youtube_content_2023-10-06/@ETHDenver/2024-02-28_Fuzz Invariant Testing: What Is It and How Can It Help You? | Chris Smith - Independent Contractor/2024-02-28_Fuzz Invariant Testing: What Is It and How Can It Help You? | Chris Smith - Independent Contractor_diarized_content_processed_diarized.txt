00:02:40.410 - 00:03:33.474, Speaker A: All right, how is everyone doing? My name is Chris Smith. I'm going to be talking about invariant fuzz testing how you can use the power of chaos to better secure your smart contracts and your protocols. This is going to be a bit of a technical talk. We'll be going through some code, and it's primarily targeted for people who are responsible for ensuring the security and correctness of smart contract code and protocols. A little bit about who I am. Currently, I'm an independent security researcher and consultant doing traditional audits, invariant security engineering, and reviews and protocol engineering. Previously, I was a protocol engineer with pre in game Makerdao core unit and worked as a smart contract engineer for the launch of MCD with the Maker foundation and was with consensus prior to that.
00:03:33.474 - 00:04:35.314, Speaker A: If you want to follow along, my latest tweet has a link to the code and this presentation, or you can see it on GitHub here at I am Chris Smith, and that link at the bottom. All right, so we're going to be talking about invariant fuzz testing. Invariant testing is a tool that you can use to augment your unit testing, your integration testing, and what you're already doing to secure and test your protocol to make sure things are working correctly. It can also be called invariant testing, as I said, forge invariant testing, or stateful fuzz testing. I'll be talking specifically about how to do this within the foundry forge tool set. And basically, an invariant is a statement about your code or system that should always be true. Invariant testing checks that those statements are true after running a random series of inputs against a random sequence of calls.
00:04:35.314 - 00:05:51.658, Speaker A: So it's the power of kind of unit testing with fuzz testing, but in a stateful way that maintains state between individual test calls. One of the nice things about invariants is that they can be, and probably should be, defined initially in natural language as the rules of the system. You can probably define them from your white paper or your spec before writing any code, and then they can be part of your development and engineering process to build out your code. The randomness that they have both in the inputs that go into the functions and also in the sequence of calls that are maintained throughout the test run, is one of the really powerful things about invariant testing. It can help simulate the adversarial environment that your code is going to experience in the public blockchain, and in a way that your unit and integration test might not, because you may not be thinking of 100 different calls that could happen in a random order that don't make sense to you as a developer because you know what should be happening in your system. But invariant testing will allow you to test all of those edge cases. So I thought to show kind of the power of invariant testing, we would run through code repo.
00:05:51.658 - 00:06:35.622, Speaker A: As I said, I used to work on maker dow code, so I selected the DaI ERC 20 smart contract. I updated it a little bit so it works with 824 and removed some of the safe math stuff. But this is basically the DAI contract that's live on main net. Now, as far as the tests go, I removed some of the extra ones to be a little bit more on point. With this presentation, we're going to be talking about transfers, minting, burning approvals for this invariant test suite. So, for example, this first test here talks about valid transfers. A user can send a balance from one user from themselves to another user.
00:06:35.622 - 00:07:19.526, Speaker A: It has a specific amount calls transfer on the DAI token, and then it asserts that the correct amount was sent and the balance is changed. But it also tests that the total supply didn't change. So, pretty simple, straightforward unit test here for you. As I said, this is testing a very specific sequence of calls, our fuzz tests, our invariant tests are going to test against a random input and random sequence of calls. So let's look at how we can get that suite set up. You'll see we now have this directory here under the test folder. An invariant suite in forge is going to have three parts.
00:07:19.526 - 00:08:04.610, Speaker A: You'll have your regression file, your handler file, and your main invariant file. That's going to be what's in charge of running the invariants for you. Regressions are going to be empty initially. Basically, if you run into a problem where one of your invariants is violated, then forge is going to give you a sequence of calls that will tell you how you got to that violation, and you can use that to create, essentially a unit test here with the random inputs that will backtrack and show you how you ended up in that buggy state. And you can run those to recreate the exact sequence of calls and exact inputs. So we'll put that away for now. Your handler is going to wrap around the contract that you're testing.
00:08:04.610 - 00:08:26.506, Speaker A: So in this case, we're testing the die contract. We have a die handler. Right now, it's just an empty contract. But this is basically where we're going to write the functions that will get called in the random sequence by our invariant test suite. So we'll get more into the meat on that one later. For now, setting up the Dai invariant test file. This is the main test file.
00:08:26.506 - 00:08:59.690, Speaker A: This is the entry point that forge is going to use. We need to generate a new die contract for our test and a new handler contract for our test. A little bit of MCD work here. We want the Dai handler to be able to mint dai when it makes calls. So we're giving it permission to do that by calling rely. These are for the forge test suite to know which contract it's interacting with, what it should be fuzzing, and what selectors it should call. Right now, we don't have any selectors in our handler, so that's going to be empty.
00:08:59.690 - 00:09:45.456, Speaker A: And then I put in a very basic invariant here. This is not a very helpful and probably not even a really valid invariant as far as true invariants go. It's just saying that the die contract is deployed with 18 decimals that's hard coded into the contract. But I wanted something in place here for us to build off of. And so we can look now at how to set up the it the handler a bit more, get to the right commit. So we want to go to our handler. Now.
00:09:45.456 - 00:10:32.560, Speaker A: We're going to start building out our handler a little bit here. As I said, invariant testing is a good way through its randomness, both in the fuzzing inputs and in the sequences, to replicate what's going to happen or what could happen in the live blockchain. From that perspective, we need actors, and in this case, destinations to be our actors in our invariant testing. So we're going to build an array of actors that we can keep track of, and we'll init this contract initially with ten actors. So they're going to be ten users that can either make transactions or receive transactions. They're all going to start with 1000 die. Just for testing purposes.
00:10:32.560 - 00:11:21.868, Speaker A: We have two separate arrays here that we're going to be pulling from. One is the actors that's basically going to become your message senders, and the other are the dsts or destinations. We create a separate array for that because I want to add the address zero into the destinations in case users transfer tokens to address zero or function calls go to address zero. We want that to be part of our recipient class, but we don't want to be making function calls from address zero because if a message sender of address zero shows up in your protocol, we probably have bigger problems on the chain than something that's happening in your protocol. As I said, your dye handler is going to be a wrapper around the DAI contract. That's what this function is doing. So we want to test all of the external state mutating functions in die.
00:11:21.868 - 00:12:01.800, Speaker A: In this case, we're going to start with the transfer function and wrap the die transfer call in this handler function where we're going to use a random actor. As I said, this is going to become your message sender. We'll talk about resetting errors in a second and then it's a transfer. So we're sending from that sender to someone else. And so we're just pulling another random destination from that array here. This is where you start to see some of the forge fuzzing come into play. So the inputs for this function are an actor index, a destination index, and a wad.
00:12:01.800 - 00:12:32.410, Speaker A: If you know Diwanese wads are what we use for amounts. That's just the amount of die that's getting transferred. The actor index is a random input. All of these are random inputs of type Un 256. Forge is going to actually plug a semi random value in. Those values tend towards the edges, so they tend towards zero or towards max un and get fewer values in between. We'll talk a little bit more about that later and why that's important to keep in mind.
00:12:32.410 - 00:13:18.164, Speaker A: But basically, these are our random inputs. We're going to use those to pick random actors with this select destination and use random actor functions. We wrap the actual function, call the die transfer in a try catch, because we don't want to fail every time the protocol actually reverts. And if you look here, you can see that in some cases we actually want to catch an error and allow it, and allow the suite to keep running. So when you run an invariant suite, you're going to define a number of runs and a depth. And the number of runs is the number of times that the whole suite runs. The depth is, I think, the more interesting number because it defines how many function calls occur within that stateful test.
00:13:18.164 - 00:13:57.852, Speaker A: So it's going to maintain state. If you say 100 for your depth, it will maintain state and make 100 random calls from your handler against your protocol and keep track of everything. So we want to make it all the way to 100 unless we hit an unexpected error. In this case, we know that if we're trying to transfer an amount of die that is greater than the user's balance that's doing the transfer, we're going to get this die insufficient balance error. We don't want to stop our test suite if we hit that error, that's expected. That's our code working the right way. So that's all this if die balance of the actor is less than the amount that we're sending.
00:13:57.852 - 00:14:22.884, Speaker A: Add the expected error. That's what this is doing. Expected error here will check if we hit an expected error. And if we didn't, then we're going to throw a revert. And that's when we'll get the sequence from the forge test suite. And that's kind of what we're looking for with these invariant tests, because then we know that we found a problem in our code. As I mentioned, we have these select actors and select destinations.
00:14:22.884 - 00:15:16.970, Speaker A: They're internal functions, they're a helper for how the handler works. One interesting thing here is this bound function. This is part of the cheat codes of the forge test suite. All that's doing is saying, give me the actor index, which was between zero and Max Un 256, and narrow that range down to between zero and the length of our actors array, so that we get a valid index here that we can pull from our actors array. We only had ten actors and eleven destinations, so we don't need max un 256 here. Let me go back and type in proper place with that initial transfer set up. That makes building out the rest of our external functions.
00:15:16.970 - 00:15:53.440, Speaker A: Sorry, they're not showing up here. Here we go. The rest of our external functions for the DAI contract, fairly straightforward, kind of repeating the same pattern. We're selecting random actors, random sources. In the case of a transfer from or an approval and a random amount and a random destination, you can see here we start adding additional errors. So in a transfer from, you need an approval if you don't have the sufficient approval, we want to catch that error and allow it because we know that you're not supposed to be doing what you're doing. It's not an error in the function.
00:15:53.440 - 00:16:39.110, Speaker A: And then the other piece is, I mentioned in our setup that the handler needed authorization. In order to successfully mint, you have to be a permissioned contract on the die contract. If the actor calling the mint function is not permissioned, we expect it to throw a not authorized error here. So like I said, kind of more of the same as far as building out our external functions. Now our handler has seven of the external selectors that we want to be testing here. We add those to our selectors array in the invariance test main file, which is getting passed into the target selectors as part of the fuz selector object. For forge.
00:16:39.110 - 00:17:16.890, Speaker A: These are now the seven functions that it's going to call randomly in a random order in our 100 depth stack. So we might get a transfer, transfer from transfer mint in those calls. And start simulating kind of the churn and the chaos of the public blockchain. Let's talk about now that we have our handler built out, we have our test suite functional. But we didn't have a very interesting invariant. We were just testing that die had 18 decibels, which can't change. It's a constant on the contract.
00:17:16.890 - 00:18:22.606, Speaker A: A more interesting invariant, and one that should hold true for all ERC 20 contracts, is that the sum of all user balances equals the total supply of your token. That is what this invariant now tests. So we grab all of our destination users, we sum their balance of, and we check that against the die total supply. The real power of this testing comes into play, because this rule gets tested after setup, when you run your functions or when you run your tests, and after every single one of those handler calls. So every time the invariant test suite makes a new handler call to a depth, 100 or 1000 or 10,000, it's going to come through and run this invariant test and make sure that this rule holds true. So it becomes something that can never be wrong or never be changed about your protocol. And if you run your invariant test suite many times over a long period of time, you have enough randomness that gets introduced that your system gets tested against.
00:18:22.606 - 00:19:12.254, Speaker A: You can start to say that this is an absolute rule of your code, that the user balances can never exceed the total supply or never be different than the total supply of your token. And that can be a really powerful thing to have alongside your other testing. Let's talk a little bit about the benefits and limitations and how you could take this to the next level with your project. So every approach to security, whether it's unit testing, traditional auditing, integration testing, fork chain testing, they're all going to have limitations. And invariant testing is no different. Some things just don't work well as invariant rules. You need those invariants to be things that are always true, no matter what.
00:19:12.254 - 00:20:28.866, Speaker A: You can program some conditionals into it, but you can't really write good invariants if it's only true after this function calls, this other function sort of thing, or if you have things that are happening outside of your smart contract code, like governance actions, or if you're dealing with upgradable smart contracts, then anyone can change the list of actions that your contract can do, the proxy actions that are getting called, and the invariance wouldn't necessarily hold anymore. But as in addition to your current testing suite and to your current security practices with your code, this can be a really powerful thing. As I said, you can look through your white paper, look through your spec, and start writing these rules before you even start writing the code, and then run them as part of your CI, or run them as nightly jobs to see if you're violating these rules that should never be violated as you're developing your code. One of the other limitations, or not limitations, but things to keep in mind, is the fuzzed inputs that forge is giving you, as I said, tend towards the edges, towards zero, and towards the maximum values. You're not getting true randomness in those values. Most of the time, that's not going to matter, but it's something to keep in mind. How can we take this further? We can build out more invariants, more rules.
00:20:28.866 - 00:21:33.386, Speaker A: There are other things that have to always be true about the DAI contract by itself. There are other things that have to be true about the whole multilateral DAI system. And you could start building integration tests where you have invariants that apply to the DAI contract and invariants that apply to the multilateral DAI system as a whole, and run those against the protocol. If you need randomness, true randomness, or if you need less randomness, you can start to kind of put your finger on the scales to prefer certain actors do certain things, or prefer certain values come through in your functions. And that can add some really powerful ways of checking your invariance and making more successful calls more frequently, which can mutate the state faster in your protocol and maybe get you to more interesting end states. As I said, you can run these on overnight jobs for like, really long depths or multiple runs, and see what you get when you wake up in the morning. So that can be a powerful kind of let your code work for you while you're sleeping type thing.
00:21:33.386 - 00:22:20.200, Speaker A: You can add them to your CI and run them in the cloud so that they're part of your development workflow as you check in your pull requests. And yeah, I think that they are really interesting ways of improving the security of your smart contracts, adding a new tool for your testing environment. And I hope that this helps get you set up and let you run tests, build out your first invariant suite, add it alongside your unit tests. The code, all the code that you saw here on the different branches is available on the GitHub, here on the screen, or at my Twitter, if that's easier for you to type in. You don't have to type so much. So thank you very much.
