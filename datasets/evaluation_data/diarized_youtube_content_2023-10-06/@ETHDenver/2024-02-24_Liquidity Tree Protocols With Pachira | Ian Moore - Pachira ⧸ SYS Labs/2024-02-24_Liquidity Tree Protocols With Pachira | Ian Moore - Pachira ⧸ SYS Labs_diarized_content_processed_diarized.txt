00:00:07.450 - 00:00:41.850, Speaker A: Protocols with Pachera. We're going to talk about the introduction. Next. We're going to cover a preamble, then we're going to talk about the problem we are solving. And that problem is going to be solved using liquidity trees. And then we're going to cover the simulation results followed by the summary. So who am I? I'm Ian Moore, defi PI core developer, which is a Defi analytics python package that I just released or we just released.
00:00:41.850 - 00:01:25.766, Speaker A: I am the liquidity tree co inventor and I share that title with another individual and he goes by an alias. His name's Coyote Doge. Other than his personality and his intellectual acumen, that's all I can tell you about him. So it's me and this guy. I'm a syslabs researcher and then I've been a Syscoin foundation advisor for the last three years. Prior to that I was senior lead data scientist for six years. I was also an adjunct lecturer at the University of Toronto BiOS statistics division for four years.
00:01:25.766 - 00:02:07.190, Speaker A: And on top of that I was a statistician for another five. But I held the adjunct status only faculty position while I was a statistician. So the objectives, first we'll cover the preamble. We're going to talk about what is capital efficiency, and we're going to talk about constant liquidity market makers or concentrated liquidity market makers. We'll define our problem, which we call the stagnant liquidity problem. That's a novel problem that we're defining to bring us into liquidity trees. And then we're going to talk about our simulation results.
00:02:07.190 - 00:02:59.234, Speaker A: So what is capital efficiency? Capital efficiency is basically the total revenue that you realize from your system divided by the total locked value. So a lay example would be say you have a liquidity pool that has $100,000 of capital in it. On a given day, you may have two to $5,000. That move that collects a swap fee of 0.3% so that two to $5,000 is earning revenue. But the question is, what about that other 95 to 98,000 that's just sitting there idle? So that's what's formerly known as lazy liquidity. And then the example I outlined, that's what we call poor capital efficiency.
00:02:59.234 - 00:04:19.440, Speaker A: So this is uniswap v two. So on the left here we have the liquidity frequency distribution of uniswap v one and v two, which is effectively just a uniform distribution. The active liquidity that's being traded here is between pa and pb and lazy liquidity is the liquidity that lies outside that band that's not being traded. So what Uniswap v three did is they virtually extended the liquidity within that system. And then what results is this bell shape curve looks like a normal distribution, or just a bell shape type distribution is denoted by this frequency distribution curve, which is in fact an estimate for the optimal curve. So there are many concentrated liquidity market makers out there right now. So the famous one that we all should know of is uniswap v three.
00:04:19.440 - 00:05:28.370, Speaker A: And there have been many copycat forks that have taken their code and forked it and implemented on their platforms, namely pancake swap, sushi swap, quickswap, apeswap. Then there's been others that not quite uniswap v three, but some slight modifications, such as Kyber elastic, trader Joe v two, orca and radium. So we talked about lazy liquidity. Next, we're going to talk about a term that we have invented which leads us into our protocol, the liquidity tree, which we call stagnant liquidity. So if we let l of p be our optimal liquidity frequency distribution, then our constant liquidity market maker would be defined as lhat because it's trying to achieve to concentrate all the liquidity within the price band. But it will never ever do that. There will always be liquidity that lies outside that price band.
00:05:28.370 - 00:06:32.700, Speaker A: So you have the total liquidity. So we call that liquidity outside the price band stagnant liquidity. It's a new term that we've defined, which is effectively the total liquidity subtracted from. And what we do is we subtract the liquidity within the optimized, within the price band of our optimized liquidity frequency distribution, denoted as lhat here in this integral. So here's, we bring this diagram up. So effectively within the PA to PB, we have our active liquidity, and that curve there is our frequency distribution, or our estimate of our optimal liquidity frequency distribution, and anything outside that stagnant liquidity. So the question is, how do you get at that? So there are many, many, as I covered, many concentrated liquidity market makers that are trying to achieve this.
00:06:32.700 - 00:07:42.480, Speaker A: So no matter what one does to address this lazy liquidity issue, we'll always have a certain amount of stagnant liquidity left over. So how are we going to get at that liquidity? So the problem is, given our estimate of our optimized market maker liquidity frequency, wSUD Lhat? How do we increase the trading volume? We call this problem the stagnant liquidity problem. So, solution, which everyone's focused on, they're just focused on single lps. How do we get concentrate that liquidity within that price band? What we're doing, we're opening up the ideas. We're saying now we're not working with individual lps, working with networks of lps, which we call liquidity trees. So these two ideas, concentrated liquidity market makers and liquidity trees, are not mutually exclusive to one another. They complement each other, which we'll talk about.
00:07:42.480 - 00:08:28.880, Speaker A: And we at syslabs believe this will be the next epoch of DeFi. Much like how the uniswap VT was the first epoch of DeFi, we believe this will be the next. So, like I said, yeah, you can influence both liquidity trees and clmms together. So let's look at the price curve of uniswap v two versus v three. This green curve here represents v two. And with uniswap v two, v three, what we're doing is you're pushing out their life, the curve, and effectively deepening the order book virtually. So we're virtually deepening the market.
00:08:28.880 - 00:09:51.800, Speaker A: Okay, but before we talk about liquidity trees, we need to cover another problem, which we call the CPT, or constant product trading indexing problem, which is effectively take a little bit of liquidity in our pool. Let's say we have 1000 Lp tokens and we have ten tokens, ten lp tokens. We want to know, well, how much is that worth in one asset or the other? If we have an eth die pool, how much is that worth in eth, or how much is that worth in ethereum, we call that index liquidity, denoted by this iy or iwacx for an xy, a dual constant product trading pool, x versus y. So, given that, what we do is we take this index liquidity, which is effectively fully collateralized debt, we place that on the market. So what that in fact creates is a derivative market, which we're calling a child pool. The original market, which we extracted, our collateralized litigation, is what we call parent. So now we have a parent, a child.
00:09:51.800 - 00:10:44.170, Speaker A: This resemblance is the simplest form of what we call an amm net, which we call a simple tree. So geometrically, the two can coexist together. As we can see here, we have uniswap v two. We take our collateralized liquidity, put it on the market as ix, it quickly gets bought up, and now we have another market. Good way of looking at it is for uniswap v two or v two to v three, we're virtually deepening the market with liquidity trees. We're virtually increasing the breadth of the market. So breadth versus depth.
00:10:44.170 - 00:11:22.840, Speaker A: So what effectively we're doing is, I like to think of it as like a grand unified theory of defi. So how does this work? So, on the top here, we have a box. Height is y, the length is x. So x versus y, x times y is our liquidity. We do some trading because of the 0.3% swap fee. Over time, the box will grow, and that's denoted by this blue strip on the outside edge here.
00:11:22.840 - 00:12:06.260, Speaker A: With this simple tree, we have the same effect happening. We have the green box, we have some trading, it grows. But then we take our collateralized liquidity in our child, the child also grows. It too produces additional revenue. So what we've in fact done is increased the market efficiency via another route using liquidity trees. So in short, we've leveraged some of the green, got red, made some extra purple. If we were to reference this simple diagram here.
00:12:06.260 - 00:13:24.098, Speaker A: So, let's extend this idea. We talked about the simple tree. So, for a dual asset constant product trading pool x and y, the maximum number of child pools, if we have our parent x pool and then our children, the maximum number that we can create is five, ixy, ixxiyx and iy. This is what we call a full tree. So, mathematically speaking, liquidity trees can be represented as computational graphs, where the nodes are denoted as dex operations and the arcs are denoted as index liquidity flowing from the parent to the children. So we can take that idea of the full tree and what we've done is we've broken it into these subtrees. The left tree, the right tree, the double tree, equivalent tree, opposing tree, they all have slightly nuanced differences between each other and how they respond according to our simulations.
00:13:24.098 - 00:14:46.054, Speaker A: But for the sake of this conversation, we're just going to talk about the left tree. So here you have our parent, and this graph here is what we call left tree xy, ixy and ixx. That's what we define as a left tree. And we have our uniswap v two pool here, denoted by the green, and our two derivative markets denoted on separate planes. So the question is, if we were to implement a protocol, the question someone might ask is, do we go with liquidity trees or constant liquidity market maker? No, you can implement liquidity trees and constant liquidity market makers together in one n dimensional euclidean space. In this case, it's r three. So, in fact, we're extending the idea, the theory, into multiple dimensions, because we've been thinking and talking about just our two.
00:14:46.054 - 00:15:22.850, Speaker A: Right now, we're expanding our thinking. So here we have the simulated. What we've done is we've taken that IdEA and we simulated it. Here's a few mathematical things we had to do to put this simulator together. We're not going to talk about it in this talk. So, these top two images are the simulations for the child. One of the child, which is eth, I die and I eth eth.
00:15:22.850 - 00:16:04.474, Speaker A: As you can see here, it's highly volatile, not as volatile as a top chart. And the bottom chart is the revenue that we harvested off the tree. The green represents the revenue pulled from the parent. The red and the pink represent the revenue that we pulled from the two derivative children. Without them, we would see less revenue. So we effectively, as I said before, increased the market's efficiency using this concept of dimensionality. So we tabulated the results.
00:16:04.474 - 00:17:04.338, Speaker A: Here in the top line, we have the revenue of our parent, which, for the sake of this simulation, we use real data, starting from on ETH die, or ETH USDC, starting from January 2018 all the way to the end of 2023. And we see that, we see a return of 19.4%. When we implement the tree, it jumps to 26.3%, which is revenue boosts of 35.61%. Now, if we look at it as the individual pools, this first column, we see a revenue from the parent as 19.4%, and then 80.5% from one child and 30.64%.
00:17:04.338 - 00:18:01.750, Speaker A: And that's because anytime you make any kind of changes on the parent, the activity in the children are more exacerbated. And we see that consistently over and over and over again in our simulations. And that's one of the interesting features that liquidity trees do that. And in this simulation, we only use seven and a half percent of index liquidity. So, in summary, we've defined the stagnant liquidity problem. We've addressed that problem using liquidity trees, which is a new DeFi primitive, which we believe is the next epoch of DeFi, utilizes fully collateralized liquidity, and be represented as undirected graphs or algebraically in RN, which we talked about. And the simulations, which we've shown, support our reasoning.
00:18:01.750 - 00:18:50.492, Speaker A: We're going to take all that we're implemented into the Patera token launch. We've taken this new primitive and we've connected it to a governance system to make a trustless, immutable, decentralized, exchange traded fund that's effectively one thing that you can do with liquidity trees. You can do all. This is what we're calling an Amm net. So we've all heard of nets used for AI. So this is the same kind of thinking the way is we're calling them amm nets. That's it for thanks.
