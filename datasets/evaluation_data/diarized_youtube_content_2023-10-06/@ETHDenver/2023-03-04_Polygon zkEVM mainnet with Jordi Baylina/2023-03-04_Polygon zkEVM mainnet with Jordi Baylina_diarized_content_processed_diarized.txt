00:00:00.650 - 00:00:51.638, Speaker A: Hello everybody, I'm Jordy Valina. I'm the technical leak at Polygon ZKBM. So as many of you know, ZKBM is the next chapter of Ethereum scaling. And why was ZKBM a big challenge? Well, in order to understand that, let me explain you a little bit how ZK roll up works from the user perspective. Imagine that you want to do a transaction on a roll up. So what you will do is you will connect with Metamask like you connect to any other chain, and you should be able to do anything that you can do in Mainnet. You will do it in the roll up in the ZKBM.
00:00:51.638 - 00:01:30.058, Speaker A: So the first stage that you will do is you will send this transaction to a sequencer. In this case, at the beginning, it's going to be a centralized sequencer, like most of the rollups right now. This centralized sequencer, it will give you already a trusted state. This estate is final as far as you trust this centralized sequencer. So this is the first stage. The second stage is once in a while, maybe, I don't know, 1 minute, 2 minutes or 3 minutes, the sequencer will send these transactions to layer one. Okay, here is where the data availability will send.
00:01:30.058 - 00:02:03.262, Speaker A: Once these transactions are in layer one and are sequenced, then you will have what we call it a trusted estate. It's a state that anybody can compute because you have the transactions on chain. So if these transactions are processed in a deterministic way, you know exactly what's the current state of the network. And so they are final. They are saved on chain, they are final. But this estate we call, that's an implicit state, it's a virtual state. It's a state that anybody can compute but is not on chain.
00:02:03.262 - 00:03:13.350, Speaker A: Okay? And in the last step, maybe once every half an hour or something like that, it's going to be another transaction that will take all these transactions that are on chain and will generate a proof that these transactions are processed in a specific way. And you will have the state on chain. It's at this point where you will be able to withdraw the funds, for example, from the layer one. Okay? And the big trick here for the ZKBMs is this prover, this prover actually what it needs to do, it needs to create a validity proof or a zero knowledge proof that you are proving that if you go from a specific state route and you apply a set of transactions, you go to this newest state route. But these transactions are standard ethereum transactions. These transactions can be send funds, can be deploy a smart contract can be execute something on the smart contract can be anything. And they have exactly the same format.
00:03:13.350 - 00:03:49.870, Speaker A: They have RRP. Okay? So building circuit here is the biggest challenge part. In the case of the polygon sick ABM, we created an architecture, an architecture that allows us to build that. And it's a multi layer architecture. So we start, we have the, if you want, the basic thing is the polynomials and the polynomial identities. This is very much to understand you. If instead of building a proof we were building electronics, this would be like the transistors, would be like the basic pieces of this, with these polynomials.
00:03:49.870 - 00:04:40.482, Speaker A: We built a processor, a ZK processor, okay. But actually it's a state machine. It's a processor. It's something that can take a program, execute this program, and have a specific state, okay? And we use, and we created also a language for writing this kind of hardware, okay? So we built a processor, and on top of this processor, this processor has his own assembly. So we build the assembly, and we built a program on top of this processor. And that emulates ethereum, that actually this program is taking transactions as an input, and it processes the transactions following exactly the same rules as ethereum. Okay? And in order to do that, well, we had a lot of challenge to solve, because this processor then needs to do 256 bits operations.
00:04:40.482 - 00:05:19.780, Speaker A: It needs to do the EC recover signature verifications. You need to do catch ups, you need to do many things. And this has been the huge work for the last two years. But there is a last challenge once we finish that three, four months ago, the last challenge was about security. And this is what I want to talk very much about. Now, as you can imagine, there is a bunch of lines of code new lines of code new systems. So it's a lot of things that can go wrong.
00:05:19.780 - 00:06:03.906, Speaker A: So this requires a huge review, a huge auditing, and a huge process for that. So for the last three months, mainly what we have been running is running a lot of audits. We run two external audits and one internal audit. More than 26 individuals were working in specific pieces of all the code we run, also an internal audit. We went really deep on that, and we found many things. We found some optimizations and some improvements, has been a huge work on that. Okay.
00:06:03.906 - 00:06:46.014, Speaker A: Some of these things were critical. We had to define even a way to. So the auditors need to learn what are those process to audit all this code. The truth is that auditing this was relative. Okay, I'm continuing here. Do not leave yet. These teams has been running for many things.
00:06:46.014 - 00:07:13.926, Speaker A: We found many things. We had to learn how to do these audits. We created a full process for doing these audits. Actually these auditors created different process, different ways to testing. And I can tell you that these are the best auditors that we can get during this time. Just to see the magnitude of this. I mean, these are the different pieces that the ZKBM has.
00:07:13.926 - 00:07:41.854, Speaker A: The p is like this hardware language where this processor is defined. We have a storage which is like another processor explicitly for working with the sparse mercury here for the storage, how you do the storage. So it's like a full topic in there. We have the ROM. This is the program that's running on top of the processor that needs to be audited and check it. We have the smart contracts, of course we have smart contracts as the roll up that needs to be audited and checked too. And we have all the cryptography side here.
00:07:41.854 - 00:08:12.266, Speaker A: We are using very much starks and flunk in the last stage. And all this process needs to be audited and checked. That's the right way. Besides that, once we finish these audits, we are finishing the last one. So probably in one, two weeks we will start the bug bounty program here. I invite you and any of the developers that are interested in zkbms just to invite you to take a look to review. There are some incentives to do that.
00:08:12.266 - 00:09:08.460, Speaker A: We have a lot of material and documentation to learn that. So if you are interested on that, we'll run this bug bounty program on that. But with all this, the question is, are we ready to launch the main net? Because I mean there is a lot of things on the stake. So let's do kind of a risk analysis. So when we have this DKBM, it's like we need to say, okay, what can go wrong and how critical is that? So in order for that, we split the things that can go wrong in four different things. One thing is something is wrong in the smart contracts. And then the last three things is something goes wrong in the proverb, okay, if we focus in the smart contracts, this is a known technology.
00:09:08.460 - 00:09:43.240, Speaker A: So we ran two outreach of the smart contract. We check on that. We didn't find any measure things in there, but I mean we went deep on that and this is a known technology somehow. Okay, so this would be critical if something is wrong in the smart contract. But here we have a high confidence that the smart contracts are going to be okay. Again, zero warranty, it's impossible. But we have good confidence on that from the audits here we have three things that can go wrong.
00:09:43.240 - 00:10:29.298, Speaker A: What we talk about correctness. Correctness means that you are probing something, that the prover that you send a transaction and the result of the transaction is actually that you steal funds or that your balance account just gets much higher. For example, this would be a correctness problem. This is really critical on this, so that you are executing the opcodes and you are doing what you're supposed to do. Okay. For this, besides running the audits and the bug bounty here, we have a lot of confidence because our system is passing all the ethereum tests. That means that we have all the test suite from Ethereum.
00:10:29.298 - 00:11:11.966, Speaker A: We are taking all the other relevant tests, which is more than 13,000 tests, and we are passing all of them. Okay, this is what give us the warranty that the correctness of the proof is going to be. Okay. Again, not 100% sure, but these tests and these outreach give us enough confidence to launch main net. Okay, the last two things is. One is soundness. Soundness is more tricky.
00:11:11.966 - 00:11:57.838, Speaker A: I would say that this is much easier that a soundness bug is in the proverb, a soundness is when you can. A soundness in the prover means that with the same state and with the same transactions, you can compute two different states. Okay, this would be a typical example of Somnes program. In this case, we are putting a mitigation here that the mitigation is we are going to be at the beginning, we are going to be the only prover that can process that. Actually, this is not really true. We are going to be the only proverb. As far as we are building proofs.
00:11:57.838 - 00:12:52.446, Speaker A: If we accumulate a delay of more than five days, then anybody will be able to run the proverb. But because we are the main prover, we will not prove something wrong. Okay, so disowness bugs are mitigated. As far as you trust us, as far as you trust the proverb. So this is not the best, because actually you should not even trust us. But at least we know that at the beginning of the, when we are starting this, we have the warranty, the users have the warranty that the prover is going to act correctly. And even after we remove as a trusted prover, the smart contract also contains a kind of a mechanism, that is, if you prove, if you sign to proof that goes to different state, then the smart contract will also halt.
00:12:52.446 - 00:13:17.100, Speaker A: And then of course there will be something wrong and we have to update. And the last thing that can go wrong, it's a little bit more specific for the proverb is that imagine that you have a transaction that you cannot prove, so that you cannot generate the proof. This is a state. And then what would happen here is that the roll up would just stop. You cannot create proof. So the roll up would stop for this. The mitigation is quite easy.
00:13:17.100 - 00:14:00.294, Speaker A: What we do is just, well, if in a week nobody's generating a proof, then the system will hold and we will be able to update the system. Okay, so this is our explain a little bit. This is the mitigations, these are the trailing bills, some of them, I already explained it. Okay. We have centralized sequencer, have a trust approver, we have this soundness, back detection by the smart contracts. We have this protection against this improvable transaction. And even on top of that, we will add temporary, at least while we are in beta, we will add also escape hatch, kill switch.
00:14:00.294 - 00:14:35.022, Speaker A: It's going to be a security console that at any moment will be able to just push a bottom and halt the system so that we can upgrade. This is going to be run it by independent people from Polygon. And it's going to be just temporarily. The thing if we remove this last one, then we will be in, according to Vitalik's classification, we will be in training wheels two. Okay. At the beginning, we're going to be training wheels one, because this last one, okay. So I would say, yes, we are ready for main net.
00:14:35.022 - 00:14:58.118, Speaker A: It's a main net beta. Okay. And here is, we're very excited for that. And I think it's an important milestone for the community. But again, it's a beta. I think it's important that the users that's using this network understand the risk. We want to be very transparent.
00:14:58.118 - 00:15:32.134, Speaker A: We are going to publish all the audits, all the code is available, you can check on that. I would ask you to give a try to try this network, but don't go crazy. I mean, don't put $1 billion in the network and then we have some issue here. Okay. But I wanted to explain that we will launch if everything goes okay on March 27. And yeah, just very excited for this main event. So, thank you.
00:15:32.134 - 00:16:01.580, Speaker A: And I'm going to take questions right now. We have 6 minutes, so I've been much faster. If there is no questions. Yeah, there is questions. Okay, that's great. Why select flunk? Right? Why flunk? Yeah. Why was flunk, that thought process behind that selection? Yeah.
00:16:01.580 - 00:16:50.374, Speaker A: Our main proverb is a stark, and it's a set of recursive starks on top of that. And it's just in the last state that we're verifying a stark with circuit, with snark here you could choose gross 16. Here you could choose plonk or you could choose flunk. Flunk is a new, it's a variant of flunk that has the advantage that the verification cost is more or less the same that grow 16. So it's very cheap verifying approved on chain. It costs, I think it's about 235,000 gas units, which this is really low. It's like gross 16 and it's the same that plonk.
00:16:50.374 - 00:17:14.994, Speaker A: It doesn't require trusted setup, actually. Well, it requires the universal trusted setup. But this is already run, but doesn't require a specific trust setup. So it has the same advantage of plon, but it's much cheaper to verify. The inconvenient here is that the proving time is a little bit. Actually it's much longer. But because this is the last stage of the prover, it doesn't take that much.
00:17:14.994 - 00:17:42.890, Speaker A: Okay. I think it takes something like about 1 minute. And if you are doing that every 30 minutes, for example, it's more than enough time. We're improving that side, but it's quite new. We are running right now an audit. So one of the audits that we are finishing right now is the flung protocol itself and the implementation of the flung protocol. But this is one of the new things that we are adding that I think is interesting for these systems.
00:17:42.890 - 00:17:53.760, Speaker A: If there is. Oh yeah. Okay. Yeah.
00:17:57.990 - 00:18:13.350, Speaker B: Thank you. I had a question about the trusted prover stage of it. Over what period of time ballpark would you say would be like the future for moving away from a trusted prover to trustless?
00:18:14.250 - 00:18:50.946, Speaker A: Let's see here. We need to define exactly. But the idea is we want to remove as fast as we can the kill switch, the scape hatch. This is the most centralized part that we have. I expect that once, maybe, I don't know, one, two months of running the system. We don't find any big thing we plan to remove on that. We will continue doing audits and this bug bounty and we'll see how confident we are.
00:18:50.946 - 00:19:32.798, Speaker A: But we need to remove that very soon. And regarding the trust prover, the idea is to start lowering down this time. So that we start with five days and then we go 45321. And actually at some point we just remove and we just try to let the market, just anybody just can generate the proof and start this prover market start spinning up. I think this will be very soon because we have the other protection. So we can be like running approver in the shadow. And if there is something wrong, we can always generate the right proof and hold the system.
00:19:32.798 - 00:20:21.818, Speaker A: So even for that, I think that's some mechanism that we will spin up really soon. I don't know if I need to sell you a time, I'm thinking about few months, but again we need to just plan just before finishing. I want also to maybe give you a little bit. So what's the future after the launch? We want to work very much with the AIP 4844 roll ups. The main limitation of roll ups, the bottleneck of roll ups are and will be the data availability. So even in the ZK, the prover is not the limitation anymore. The impact of the proving cost in the transactions is not an issue anymore.
00:20:21.818 - 00:21:00.438, Speaker A: It's really cheap on that. So we need to focus in the data availability, data compression. We want to also improve a lot the sequence, because the sequencer, if you want to scale, you want to increase at least one order of magnitude in the sequencer. And of course we also want to start working in the decentralized sequencer. It's a little bit near future for the ZKBM, but still a lot of work to do. And of course we want to finish. So we have some pre compiled smart contracts that are not implemented yet, like paddings and Shadow 56 and Blake mainly.
00:21:00.438 - 00:21:22.270, Speaker A: And we will add those in the next version of the roll up in few months. Bravo. So this is a little bit the short term roadmap for the ZKBM, for the ZKBM project. So guys, if there is no questions, thank you very much and let's give a try to the testnet.
