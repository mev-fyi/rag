00:00:00.090 - 00:00:24.174, Speaker A: And as you can see from the theme, we are at a beef ranch. That's why this slide is themed and it's an animal farm. Welcome to the workshop. Zero to hero Smart contract. If you have any questions, please feel free to interrupt me at any point. And we'll now begin. You got 30 minutes.
00:00:24.174 - 00:01:01.518, Speaker A: We're good. So this is kind of the agenda we have today. We'll talk a little bit about Manto, which is sponsoring me to be here. A little bit of what is the EVM? The current state of developer tools, your foundry, hard hap, truffle, apeworks, the various smart contract programming languages, and if time permits, we can check out more advanced topics and or tooling, such as fuzzing or proxy contracts. Can you guys hear me? Yes. Good. Great, perfect.
00:01:01.518 - 00:01:45.274, Speaker A: So who am I? I am lib EVM. These are my socials. I am currently a developer relations at Mantle. If you like to talk more about Mantle, feel free to just come and ask me questions after the talk. But I'm an engineer at heart, so what is Manto? I don't want to show too much, but TLDR, it's an EVM compatible scaling stack for Ethereum. So we're trying to bring the good parts of Ethereum and make it better. So why EVM compatible? We would like to leverage existing tooling and the community, and we want to build on the shoulders of giants.
00:01:45.274 - 00:02:30.634, Speaker A: So we want to be able to use the existing infrastructure, like metamask. We want to be able to use the existing tooling, like truffle, hardhat, foundry, the existing programming languages like solidity, Viper, Yule, huff, and we don't want to keep reinventing the wheel. We want to be able to absorb the existing community. And also a lot of these things take a lot of time and effort, and we thought it would be better to just inherit them rather than compete against them. So build with them instead of against them. So these days there's three standard toolings out there. If you would like to get started with smart contract development.
00:02:30.634 - 00:03:16.700, Speaker A: The recommended one is foundry from paradigm. And if you like Javascript, I would recommend hard hat. But if you like the Python syntax, I would recommend apeworks. Now, foundry is a little bit more new. It's written in rust, so things are a lot more quicker, whereas hard hat is a lot more familiar. For those of you who have been in the JavaScript ecosystem, however, you have to write JavaScript to test your contracts. Foundry, you can just test them in solidity, whereas apeworks and hot hat, you have to write the various languages such as Python or JavaScript to test the logic of your smart contract, which might not be ideal as there's a lot of context switching between them.
00:03:16.700 - 00:04:18.350, Speaker A: And we'll go a little bit overview about the smart contract languages. We have the most widely used today, solidity, which I'll be checking it out. I'll be going through a very brief overview on things. If you are an optimizer who likes to gask off, or who really likes to get close to the bare metal, huff is a good alternative. If you like the Python syntax, or if you do a lot of math heavy operations, Viper will be the recommended choice, such as curve. However, do be warned that it is not very extensible because due to limited language support, half is also not recommended to be used in production, actually, simply because it is very hard to get audited and it's very hard to find the logic. It is very hard to visualize the logic control flows, but at the end of the day they all compile down to EVM bytecode, so it doesn't really matter as they are just a form of abstraction.
00:04:18.350 - 00:05:26.922, Speaker A: And with that being said, let's check out a live demo. So in the live demo we'll be going through a couple of topics, mainly the keywords in the smart contracts as well how to deploy your own ERC 20 token. So right now I'm using foundry, so can you guys see the screen? Is it zoomed in enough? Perfect. So usually how this would work is that you would start your repository with forge in it. However, because the Internet is quite limited here today, I decided to just go ahead and initialize everything in case the Internet isn't too kind with me. Just need some water. 1 second so in the Solidity programming languages, there's a lot of primitives.
00:05:26.922 - 00:06:15.278, Speaker A: One of the primitives is a UN 256, and if you guys are curious what that means, it just means I can store a really big number that is 256 bits, long, unsigned, meaning it goes from zero to 256 bits. It doesn't account for negatives. If you were to do int 256, it'll be a negative number. You can go from negative to positive, but your range will be halved. So these are like, there's like special keywords such as UN 256, and you can also make this number public, meaning this number is accessible externally and behind the scenes. I'll show you what actually happens behind the scenes in the solidity programming language. Keep in mind, this only happens in solidity version I think, 0.4
00:06:15.278 - 00:07:01.530, Speaker A: and above. So not all versions of solidity will have this, but if you're using modern tooling, it should have it by default. So the public keyword makes your number public, but what it does behind the scenes is that it actually creates a new function called number. Well, get number because we can't have a collision in keywords which returns Un 256 and that just returns the number. So behind the scenes if you type out public, this is what it actually does now. But since we already have this public keyword, we don't have to recreate this function. We'll just make it a lot more convenient.
00:07:01.530 - 00:07:35.160, Speaker A: Cool. We can also mutate the number, like these variables are mutable by default. For those of you guys who are coming from the Javascript world, this should be very familiar. You can call set number and you can override the number that is currently being stored in this contract. So this contract counter has a couple of examples. You have a setter and you can increment the number. And let's see how we can test it out.
00:07:35.160 - 00:08:32.460, Speaker A: So this is foundry, by the way, when you initialize it, I just realized I didn't went through it, it would set up a couple of folders. You have the test folder, the source folder, the script folder, and a library. The library is where all the library is where you import existing contracts such as open Zeppelin, ERc 20, where you can immediately create an ERC 20 token, which we'll be doing later on today. Foundry also has this really cool thing called scripts, where you can write scripts in solidity, which is actually not supported anywhere else outside of foundry. This is very useful when you're testing solidity contracts, because you don't have to keep context switching from one code to another. However, this tool is also foundry specific, so you have to use the foundry tooling in order for you to use it. But we probably won't dive into this category today.
00:08:32.460 - 00:09:06.782, Speaker A: So let's see how we can interact with this script. And usually you would interact with it in the test folder. So we have this contract called counter test, which is going to test our counter object. So again, this counter object, all it does is that it has a number. You can store the number, you can read the number, and you can increment the number. And so how we would do this in counter test is that we define our counter object. We create a new counter, we initialize the counter to be zero, which is in the setup process.
00:09:06.782 - 00:10:01.926, Speaker A: So think of this as a function that you run before every time you initialize the contract, and we'll test the increment of the number and we'll test setting the number. So if we increment it from zero to one, the number in the counter should be equal to one. So that assertion should be true by default. Or we can also test setting the number to some arbitrary value x, of which the foundry framework will automatically fuzz this for us, meaning it will test various numbers from zero between zero to 2, quadrillion, whatever the maximum number is in 256 bits. And we'll make sure that that assertion, that the number is equal to x. And so we can run forge test. To test this out, we compile the project, and now both tests pass.
00:10:01.926 - 00:11:05.130, Speaker A: So increment, we have successfully tested increment and we have successfully tested the number. So that's how you would set, let me drag this back. That's how you would test smart contracts in Solidity. Now, solidity and most smart contract programming languages have a special keyword, and we'll be going through some of those special keywords with you today, such as function get keywords public. We have these things called message sender, TX origin, block number, and block timestamp. So these are smart contract specific things which I'll go through in a second, which you won't be finding anywhere else other than ethereum or any ethereum like language. Ethereum like environment.
00:11:05.130 - 00:11:45.478, Speaker A: So cool. Let's check out the difference between message sender and txorigen. So let's get message sender return message sender. They're both addresses, if you're wondering. And what message sender implies is that it's asking, hey, who called this function? So who called the get message sender function? Whereas TX origin also returns an address. I assume everyone here is familiar with addresses a little bit. All right, cool.
00:11:45.478 - 00:12:35.302, Speaker A: And we can return TX origin. And so what? The difference between TX origin and message sender is that txorigen returns the originator of the transaction, whereas message sender returns the address of whoever who called the contract. And we'll make this a little bit more concrete. Let's run some test keywords. Let's make this function call test keywords. And we can actually log stuff out in foundry with the log address keyword, but you have to inherit from the test functionality. Again, this setup should be default when you initialize your foundry project.
00:12:35.302 - 00:13:11.540, Speaker A: So we can try and log an address, for example, message sender, and just make sure that this works. Forge test. But since this test will pass and we want it to be extremely verbose, we would give it three v's test vvV, which means very, very verbose in my opinion. I'm sure giorgios will disagree. And as we can see, we have logged out an address here. And if I remember correctly, I can log out a string with the address message sender counter test. No.
00:13:11.540 - 00:14:09.976, Speaker A: Should I dive into it? Yes, we have a lot of time. Might as well. Maybe not. Ds test. It's okay, I'll just log a string message sender countertest and that's the message sender for counter test. But if we emit the address for counter get message sender, it would actually be different counter object. As you can see, even though we're both getting message sender, message sender in the test file is different from the message sender in the counter file.
00:14:09.976 - 00:15:34.596, Speaker A: And the reason why is because the countertest file is actually calling the counter contract. So in theory, if I logged out the address of this contract, which is the counter test, it would be the same as the message sender for the counter object when we call get message sender and let's test it out address of countertest. And as we can see, the address of the counter test is zero XFA something which is also the message sender for the counter object. Again, this is because the countertest file is calling counter getmessage sender and that is why the two addresses are the same. However, if we check the TX origin of counter, it will be the same as the message sender as the counter test. And let's check that out. TX origin counter get TX origin and boom.
00:15:34.596 - 00:16:31.658, Speaker A: TX origin is the same as the message sender from the counter. And that is because the originator of this whole transaction actually created and calls countertest, which is the TX origin. So that is the message sender for countertest, which is in fact a TX origin for every instance. So if we get the TX origin of this contract, it will be the same as everything else and we can test it out. So yeah, those are like some of the keywords you can find in solidity. Just keep in mind, like the little nuances between message sender and TX origin. Now, a little hack that a lot of smart contract developers use to ensure that the sender of the transaction is a human.
00:16:31.658 - 00:17:43.794, Speaker A: And by human I mean an EOA or externally owned account, meaning it's not a smart contract account that oftentimes they would put in this keyword, this requirement where the TX origin is equal to the message sender, which just basically means that your contract, the caller can't be a smart contract. And that way you can't perform bought actions. For example, determine a number that your contract is going to predict in the future, because you can get all the data from the smart contract anyway. This is how a lot of smart contracts make sure that the caller of the user of their application is not a bot, if you're wondering. Now, we also have some keywords such as block hash, which just returns the hash of the block, and that returns you a bytes 32, which is in fact just a UN 256, packaged nicely. Block hash. And we can check this out.
00:17:43.794 - 00:18:04.760, Speaker A: Log bytes 32, hash. Block hash. Is it a function these days? I don't remember. Oh, block hash. Block number. Yes, that's how you get it. Cool.
00:18:04.760 - 00:18:45.460, Speaker A: And it's zero because we're in a test environment, so we haven't initialized anything. So that's how you get the hash of the current block. And if you would like to get the block number, you can log un 256 unlog un, and you can log out the block number, which is one. So those are like some application specific keywords in solidity. Cool. All right, what else? We got ten minutes. Let's try and make our own token here, our own ERC 20, and it will be extremely simple.
00:18:45.460 - 00:19:15.150, Speaker A: All we do is import from the openzeppelincontracttokenerc 20, ERc 20 sol. And now if we just do this, mytoken is ERC 20. Give it a name, super token. And then just name it super and delete everything else. And you have just created yourself an ERC 20 token that fits all the specifications. Very cool, very easy. Let's try and test this.
00:19:15.150 - 00:19:38.958, Speaker A: I'll just keep this here a little bit longer so you guys can see how easy it is to make a simple token. Okay, great. Our audience size just doubled. Hooray. Welcome. So this is how you make a super simple token. And we can now test it because we renamed it to my token.
00:19:38.958 - 00:20:01.510, Speaker A: We have to change it here to my token public counter. But we'll just call it token and we'll set up a new token. And this is how you make a new token. Very easy. You just inherit from all the standard ERC 20 contracts. Oh great. Our audience size just quadrupled.
00:20:01.510 - 00:20:25.630, Speaker A: Amazing. Thank you. Yes, you missed the best part, which is the cow themed slides, because we are in a beef ranch, so everything's animal themed. But yes, it is very cute. But we're almost done. I think we got like nine more minutes. But anyway, this is the token.
00:20:25.630 - 00:21:01.094, Speaker A: You can make a new token, and you can test the functionality of the token test token public. And again, this token inherits from all the, it fits the ERC 20 specifications. So if you want anything like let's see if the Internet works. Okay, so what that means is that it fits the ERC 20 token standard. You have all these functions. It has the name, it has the symbol. Let me see, can you guys see it? Yes, it has decimals, it has total supply.
00:21:01.094 - 00:21:34.290, Speaker A: Blah blah blah, bounce off transfer. These are mutable functions, by the way, that mutate state transfer form just from inheriting from this ERC 20 contract. And we can check it out right now. Emit log string token name. And notice that I didn't define anything in here. Everything is inherited from the ERC 20 contract. This is in fact, in my opinion very lame because I'm not a big fan of object oriented programming languages.
00:21:34.290 - 00:22:00.766, Speaker A: But here we are. But these are the tools we have. Okay, great. We will log out the name of the contract super token. And as you can see, we never define the function name, but we can still call it. We also have stuff like symbol, which is just super as we have defined here. But there's no way to mint any token right now.
00:22:00.766 - 00:22:56.510, Speaker A: So we need to actually create a function owner mint or the magic mint, which ticks an address and then mints some amount b, 256 b to some user. And there's actually an internal function called mint where you can mint the contract, mint the tokens to address a with amount b. And so for example, right now, right now, my token, I don't have any token. It should return us zero. But if I mint myself some tokens, for example, token mint, address this, I'll mint myself 100 tokens. Now the e 18 is just saying that. I want to put this to, I want to give it 18 decimals.
00:22:56.510 - 00:23:24.582, Speaker A: That's just the standard. A lot of token standards, a lot of tokens such as die wrap eaters, all use 18 decimals to represent decimals. Don't ask me why it's 18, I have no idea. But we should have 100 tokens in our balance right now. It's magic mint. Magic mint. And yes, now we have 100 e 18 tokens.
00:23:24.582 - 00:24:10.940, Speaker A: Just from inheriting a contract and creating a fancy function called Magic Mint, we have now created a token that is mintable for anyone, which I do not recommend. So generally what happens is that you would put a require where the message sender is some address, for example, zero X 42. And if it doesn't pass, then this whole function reverts and we can check it out. In this case, it just reverts. So you have like an owner gated min function. So I think, yeah, that's how you make a token in ERC 20 land. And I just realized that we're running out of time.
00:24:10.940 - 00:24:55.494, Speaker A: We're running out of time. And I would have loved to dive deeper into more advanced toolings such as slitter and fuzzing and proxy contracts, but I will give the next speaker five minutes to prepare and thanks and Q A and happy deployment to your smart contracts. Those are my socials if you want to check it out, please do check out Mantle XYZ. We have a lot of grants prizes to support anyone who wants to deploy on our network. We are a L2 optimistic L2 that is EVM compatible. Again, lots of grants, so thanks. And if you have any questions, feel free to chase after me after this talk.
00:24:55.494 - 00:24:56.260, Speaker A: Thank you very much.
