00:00:08.170 - 00:00:36.230, Speaker A: Hello everyone. You hear me? Well, yep. Yeah. I'm Alejandro Ranchal from protocol labs, and I'm going to be talking about how to get fast finality on longest chain protocols. So this is the outline of the presentation. First, a little bit of the status quo of how longest chain protocols work, particularly for the case of filecoin. And our first take at providing faster finality with the EC finality calculator.
00:00:36.230 - 00:01:16.766, Speaker A: Then we kind of reached the kind of the lower bound of architectures that only have a longest chain protocol. So then we look at architectural options to provide even faster finality. And we came up with an architecture that we call f three. And I'm going to be detailing the architecture and how we integrate it in filecoin with the longest chain protocol. At the core of the architecture, there is a new consensus protocol that we call gossip BFT. And yeah, I'm also going to extend a little bit of that one, plus the finality exchange protocol in order to get succinct, verifiable proofs. Finally, a bit of the implications that f three brings to longest chain protocols and the roadmap for the case of file coins.
00:01:16.766 - 00:02:00.702, Speaker A: So, longest chain protocols, as probably everyone here knows, longer chain protocols assume probabilistic synchrony. So the confidence in a block not being reverted as a result of a fork grows over time, right? With more blocks appended to the chain. In Falco and until 2023, this meant 900 epochs. Not every longer chain protocol prescribes a particular finalization time or confirmation time. In the case of Falcon, it is prescribed because the power table of the system is part of the state of the system, and this power table is assumed to be final. Therefore, actually there is a number that is embedded in the implementation, which is seven and a half hours. It is so much because Falcon is not really a chain of blocks, it's a chain of tipsets.
00:02:00.702 - 00:02:55.380, Speaker A: And tipsets are sets of blocks of the same epoch and the same parent tipset epochs. So in Falcon, time is discretized into 32nd slots that we call epochs. So what seven and a half hours means for an example of gaming platform would be. For example, if you're launching this gaming platform and you have multiple games, you do not want your users to have to wait seven and a half hours every time they want to buy a game. So maybe you could do something like a subscription based system where a token is issued and they only have to wait seven and a half hours at the first time that they join the system, and then you have kind of like an l two for multiple games. And so in your l two you can run your own consensus that doesn't have to be longer chain, and maybe it takes about ten minutes. And suppose Alice and Bob want to play a game of chess, they can spawn maybe their own state channel and just play within seconds, right? So this is how it should be done.
00:02:55.380 - 00:03:22.742, Speaker A: Given the long finalization time in the main chain. Our first take on providing fast finality is what we call the EC finality calculator. ECS stands for expected consensus, which is the main consensus at the longest chain. So they're basically the longest chain type of consensus. At filecoin, the principle is that not all tipsets are the same. So in Filecoin, every epoch in expectation selects five proposers. And so in expectation, a tipset per epoch will have five blocks.
00:03:22.742 - 00:04:25.650, Speaker A: So if you see multiple epochs with suppose two blocks, you do not have the same level of confidence in that chain as the one that you can have if you see three consecutive epochs with five blocks right in the tip set. So using this during the good case, in the normal case, we can actually provide finality within 15 minutes, which kind of like reaches the lower band of longest chain protocols. We actually have PR, the Falco and the FRC in the FICO improvement proposal repo, and we also want to provide the functionality directly at the API of the clients, the Falcon clients, but it's not even needed. If you want to build an application, all the information is available for you to do the analysis and the risk assessment of finalization. Thanks to the EC Finality calculator, the gaming platform doesn't anymore need to spawn a L2, but still 1015 minutes. You do not want every move of chess to take that amount of time. So you probably still, like Alice and Bolt, probably still want to spawn a state channel or something of the sort, and play directly with one another right off chain.
00:04:25.650 - 00:05:14.974, Speaker A: So that kind of showcases that it's not perfect, right? The easy fan id calculator and the lower bound or longer chain protocols is better than ours. And in the case of the easy fan id calculator, it's great that we don't even need to modify the protocol. It's just an information that is readily available, but it's still tens of minutes, and ideally we'll get something better, right? But that's an idea. But even in the case of Ethereum, the finality gadget that they implemented takes about six minutes for finalization, which is not ideal. It's much better than hours, right? But it's not good enough. What we want is seconds, right? We want finalization within seconds. And we also want to be able to prove to observers that are not necessarily fetching all the data from falcoin that a particular block or a particular transaction has been finalized.
00:05:14.974 - 00:05:38.418, Speaker A: So we want succeed verifiable finality certificates. And the immediate outcome of this is that we need a new architecture. We cannot do this just with longer chain. So we look at multiple architectures. Of course, the immediate reaction was, let's look at the state of the art. Let's see how others do it. Maybe we don't need to create a new architecture and we set a set of goals.
00:05:38.418 - 00:06:10.818, Speaker A: Of course, fast finality. But we don't want faster finality at the cost of robustness. Right? You can already get that. If you just lower the finalization time, you're just going to have less confidence in the result. Normally, if you fix robustness and fast finality, what suffers is the assumptions, right? You just have a stronger set of assumptions on the adversary that you tolerate. We also don't want that. We want, or put differently, we don't want the assumptions that we make in order to introduce this newer finality module onto the system.
00:06:10.818 - 00:06:45.322, Speaker A: If there are assumptions, we don't want them to come from this module. They could come from different parts in the system. And also, we are looking at this in the scope of providing faster finality for a longer chain protocol or system that has been running around for years that is battle tested. So we want to change it as little as possible, also so that it doesn't spark too much angst in the community. So some options we looked at already went through longer chain or folk choice protocols. Not fast enough. We want faster finality for fast finality.
00:06:45.322 - 00:07:25.894, Speaker A: One that was very interesting was Avalanche's type of subsample voting, because it finalizes within seconds and it scales very well. The problem is, it has a very strong synchrony assumption that we felt we didn't want to have. And it only tolerates 20% of an adversary controlling 20% of the power table. 20% is actually not that bad when you have really a lot of nodes. But if we're looking at us, we think we can do better than that if we're looking at a membership in the scope of thousands of nodes. Another immediate state of the art project to look at the finality gadget of Ethereum or other best effort finality gadgets. The advantage, of course, is the small refactoring.
00:07:25.894 - 00:07:47.822, Speaker A: But there are some security concerns. In particular, I have not seen yet formal proof of the security of the Casper FG. And also it assumes strong synchrony is not fast enough. We still want within seconds. And Casper FG takes about six minutes to finalize anything. And of course the holy grail of distributed systems that have been studied for decades, BFT protocols. We know that fast, we know that resilience.
00:07:47.822 - 00:08:17.206, Speaker A: But changing a longer chain protocol into a BFT protocol is too much refactoring. It's definitely not the path of least resistance. So looking at the last two, there's an immediate idea. Why don't we combine them? Right. Can we provide maybe a BFT protocol as a finality gadget? Right, just as an additional model that provides finality. And what we claim is that what we get is we get fast finality, resilient, optimal security. We don't need to assume synchrony and we refactor.
00:08:17.206 - 00:08:52.466, Speaker A: So we basically follow the path of least resistance because we barely touch the main code, we just add a new model. So a bit of how this is what we call f three, which stands for fast finality in falcoin. But it's completely modular and can be applied to any other longest chain protocol. So the way it works, this is how a longest chain, like a very abstract schematic of a longest chain protocol works. So some blocks come from the network and there's some process that we're going to call the LC synchro that adds the blocks to the local view of the chain. And then there's some fork choice rule that selects the heaviest chain. Right? In this case, this one here with a head block.
00:08:52.466 - 00:09:42.760, Speaker A: So what we do is we add a new component that simply reads the head of the chain and this component proposes as input to a new VFT consensus protocol, this head to finalize. Then the VFT consensus protocol runs consensus and eventually it outputs some block that is final that needs to be finalized. Once this output comes out, the f three component marks the prefix up to that head, that new head block as final, which in this case will be b. So up to b will be final. And the block h, even though it was proposed by this node, it didn't get finalized in this iteration of the BFT consensus protocol. In terms of the integration, really the only changes that are necessary are the ones shown here. And these ones in the case of filecoin, for example, are already available.
00:09:42.760 - 00:10:34.870, Speaker A: We wouldn't need to do any changes necessarily to the API in order to integrate this model. However, for pragmatism, now at the implementation phase, we're doing some changes. But essentially the only thing you need to do is to read ahead and then to finalize some block in the finalized chain, which is what we call checkpoint in filecoin. And then of course implement the new model, the new f three model, completely independent, though some changes that we do, we actually create a new function to finalize rather than checkpointing, because checkpointing is more something for the user to do. So we actually change the folk choice rule to always select the heaviest suffix of the finalized chain. And instead of pulling from f three, we actually push the heads to f three. But those are minor differences.
00:10:34.870 - 00:11:08.958, Speaker A: We don't do this in the case of falcon, but you could also change the block header format in order for the longest chain protocol itself to update the power table if you have a longer chain protocol whose power table is part of the state of the system, as is the case of falcon. But we actually don't do this. We leave the power table untouched. And still it's taken 900 epochs in the past in terms of the folk choice rule. So yeah, very small modification. The heaviest chain is not anymore the one with the most weight. It's the suffix with the most weight out of the heaviest finalized prefix.
00:11:08.958 - 00:11:38.250, Speaker A: So suppose all the blocks here have the same weight. Normally, of course, the heaviest chain would be gab one, c d one. But suppose that b zero was finalized. This means that the heaviest finalized prefix is gab zero. And so the new forkshire's rule selects the heaviest suffix out of this heaviest finalized prefix, which will be. There's two suffixes possible, one, the empty one, and the other one is d zero. So that will be the heaviest chain once b zero is finalized.
00:11:38.250 - 00:12:10.802, Speaker A: So now a little bit into why we design a new consensus protocol, which also, of course, needs to be justified. It's not necessarily the path of least resistance. Good news is we call it gossip pvft. It's not a brand new consensus protocol. It inherits a bunch of ideas. And basically it's a generalization of Brasha's bicentennial agreement protocol that was proposed like decades ago and has been battle tested for ages. And it also, of course, inherits ideas from PBFT.
00:12:10.802 - 00:12:39.182, Speaker A: That's why, hence the name. Going back to the goals, we want the BfT consensus protocol to be fast, so low latency. We want it to be robust, and that translates to resistance to the Nav service attacks, censorship attacks, eclipse attacks. We don't want strong assumptions, no synchrony, optimal resilience, and path of least resistance. It needs to be a simple protocol. There is a trade off, because if you don't assume synchrony, then you have less resilience to an adversary. That's why we look at both.
00:12:39.182 - 00:13:20.310, Speaker A: Actually, we look at synchronous protocols and a passive synchronous protocols. There are very fast synchronous protocols and also this strong tolerance to an adversary. It's very interesting, but actually the fast synchronous protocols need to assume a single leader, which in the scope of open systems, if you want to tolerate denial of service attacks, would mean implementing single secret leader election. And those protocols are not that simple anymore. And even in terms of the latency, they wouldn't be that fast anymore. Plus, I haven't seen any single secret SSL protocol that tolerates an adaptive adversary yet. So it wouldn't really be that denial service systems, the best known leaderless variant that doesn't assume a single leader is definitive.
00:13:20.310 - 00:13:58.450, Speaker A: But now it takes nine times the synchronous bound. And the synchronous bound is important for safety, so it will be a pretty long bound, so it wouldn't be really low latency. That's why we ended up going for passive synchronous protocols. That in particular go CPBFT is a little less protocol, and that means that we tolerate about a 33% adversary. But I'm going to show later that we actually tolerate a stronger adversary for some attacks that are of concern for filecoin and surely for other systems. So gossip BBFT is a resilient optimal passive synchronous protocol. Resilient optimal meaning tolerating, as I said, an adversary controlling up to a third of the power table of the membership.
00:13:58.450 - 00:14:35.806, Speaker A: It's a very simple protocol, so every node that runs the protocol executes exactly the same code. There's no leader. It's round based, and every round has three steps, and there's one extra step at the end. So once termination happens, all the rounds have the same message format, a very similar message, validation and logic. And it tolerates eclipse attacks, as I mentioned, the Nile service resistance as well, and against. In the particular case of censorship attacks and long range attacks, we tolerate an adversary controlling 66% of the power table in terms of fast finality, low latency. The good news is gossipbbft only needs for a termination.
00:14:35.806 - 00:15:08.142, Speaker A: It only needs to exchange a linear number of leap p, two p messages of a linear sizing bit. This can be improved with some trade offs. I'll get into that. You could do constant number of bits. And of course, if you use committees, at some point, if your power table becomes too big. This could be made scalable by changing just a constant number of lip p two p messages. And in good cases, actually, you only really need two steps to finalize both asynchronous, by the way, we do four at the moment, because this is an optimization we're probably going to implement later.
00:15:08.142 - 00:15:36.946, Speaker A: But you will see in a minute why you only need to. Actually, you will see it right now. So, in the good case, we have other steps, but these are the key steps of any BFT protocol, right? So if you'll get lucky. Suppose we have a membership, a power table with four participants. Assume everybody has the same weight. One of them is bicentine, and in this case, this bicentine just doesn't communicate with anybody. The other three, suppose they start this iteration of gossip pbst with the same input, which is this purple block.
00:15:36.946 - 00:16:11.410, Speaker A: So they get very lucky. Everybody, by the way, receives the messages pretty fast in this good case example. And so the next phase, the next step of the round, that's called commit. Also, everybody proposes the same block. And at that point, you can already decide. We add a new step at the very end that we call the decide step, just so that we can create a finality certificate. So the decide step is the one that, after termination, a node can aggregate these signatures from the decide messages and prove to people outside the system that this block has been final.
00:16:11.410 - 00:16:49.690, Speaker A: And I will get into that in a minute. And without this step, we could still provide off an id certificate with a commit, but then we will only tolerate a long range attack against 33% adversary. So there are incentives, in the case of Haken, to create this extra step, to have a tolerance against a greater adversary. Now, suppose we're not as lucky, right? We still have this by something that doesn't communicate. And one of the nodes that is correct, unfortunately, proposes a different block, the yellow block. So what happens is in the commit phase, we cannot terminate by the rules of the protocol. So in this case, everybody suggests, hey, we cannot terminate empty block.
00:16:49.690 - 00:17:50.162, Speaker A: So what happens in this case if we go to a new round? In the new round, there is a new step that we call the converge step, which is the purpose of the converge step is to converge to one of the two or multiple values that could be proposed. Because the question is, who should change? Should the people who propose purple change to yellow? Should the one that propose yellow or orange actually change to purple? So what happens in the converge step? This is a synchronous step, is that everybody runs a VRF ticket result and shares index converge phase their proposed value with their ticket. And so at the end of the synchronous timeout, every node selects the lowest ticket, the value associated to the lowest ticket they saw. So suppose in this case, the lowest ticket belongs to the node that proposed yellow. Everybody's going to switch to yellow, and then we can actually have termination the same way we had. In the good case, this will be everything that is needed. As I said, even the decide phase is not necessary, unless you want tolerate a 66% adversary against a long range attack.
00:17:50.162 - 00:18:31.150, Speaker A: So an attack trying to fake certificates from all rounds. But we also want to tolerate censorship attacks against a very strong adversary. The reason being that a censorship attack becomes quite kind of incentivized in filecoin, because if you censor somebody for long enough, they eventually get penalized and out of the membership. So eventually you can take control of the system if you censor for long enough. So we felt like 33% wasn't good enough, and we wanted tolerate a great adversary. Here's a bit of the example of how this attack will work. It's very simplified, but suppose the longer chain will be the one that finishes with the head in the purple block.
00:18:31.150 - 00:19:06.902, Speaker A: A rational adversary, like these two nodes at the bottom, can propose yellow and basically prevent a decision and keep going into new rounds up until they receive the lowest brf ticket. And in that moment, they can force everybody to switch to their proposal, forcing a decision on a different fork that is not the heaviest one. And obviously we don't want that, right? We want to make that as difficult as possible. So it turns out this is how that will work. The way we do that is in the first round only. So you remember, the first round didn't have the converge step. It only had prepared commit, and if there is a decision, decide.
00:19:06.902 - 00:19:48.534, Speaker A: So now we have a new step that is executed at the very beginning called quality. With quality step, you can actually enforce many things. It depends on the requirements of your system. But in the case of the tolerating a censorship attack against an adversary controlling 66% of the power table, what we do is we enforce that a quality value, as we call it, must have been proposed by at least more than two thirds of the nodes, two thirds of the weight in the quality step. So, for example, in this execution, only purple will be decided. So yellow essentially cannot be decided anymore. Even if somebody holds the lowest ticket in a future round and proposes yellow, everybody will be able to see.
00:19:48.534 - 00:20:15.570, Speaker A: Yellow did not pass the quality phase. So yellow is not a valid block anymore. It's not a valid proposal anymore. So of course you could say, what if two people propose yellow, two people propose purple? Well, then the only decision is not to finalize anything right now. Let's just go to a new iteration. And hopefully by the new iteration, some people have changed to a different chain. And like in this case, this rationale now essentially switches to barple.
00:20:15.570 - 00:20:37.462, Speaker A: So essentially a liveness attack is still possible. But that's essentially what we do, convert a censorship attack into a liveness attack. So it's not rationally motivated anymore because censoring someone else becomes censoring yourself as well. Yes. So that's how it will work in the good case. And this is the actual implementation, thanks to the quality step. Yeah.
00:20:37.462 - 00:21:33.894, Speaker A: So something I kind of went over about is the fact that how do we make sure that everybody sees the same messages? So how do we make sure that people have agreement on which blocks pass quality step? Right. What if a participant proposed yellow to some people and purple to others, and they have different views of what is a quality value? So the way we do this is actually messages in gossip PBSD needs to be justified. There are two flavors of this justification. One of them is literally attaching the strong quadrant of messages from previous phases that justify this value. So in this case, for example, a message sent by this node that contains purple as prepared will need to also attach a certificate of signatures of people that propose the same value in the quality step. So we aggregate them, of course. But yeah, that would be necessary.
00:21:33.894 - 00:21:49.642, Speaker A: Otherwise this value is not valid. This message is not valid. That's one flavor. That's what we call explicit justification. The other flavor is to essentially make it so that everybody receives all the messages eventually. That's what we call assuming reliable broadcast. There are some trade offs.
00:21:49.642 - 00:23:07.254, Speaker A: Reliable broadcast is really good because the size of the message doesn't increase with the size of participants, because you don't need to attach any signature, but you need to change the network layer because of that. We decided, in the case of the implementation we're doing at the moment for filecoin to just go with the implicit justification, so that we don't need to touch other parts of the system, and we just attach explicitly the aggregated signature of messages that justify the value of the particular message. As for the properties, I already went through them, I feel, but of course, the classical agreement validity and termination with some variations, but basically the same properties. And then we also have a property we call proof of finality that relates to the finality certificate, and being able to prove to people outside the system that a particular block or a transaction or a prefix of the chain has been finalized, and I will get into the particular protocol that does that in a minute, then we prove progress. Proving termination of an iteration of gossip PBFT doesn't necessarily prove that there will be anything finalized because you can terminate not finalizing anything. Right? The agreement could be we haven't reached agreement. The agreement could be we try again next time.
00:23:07.254 - 00:24:05.394, Speaker A: So we actually prove that during synchronous periods, with probability more than half, we will finalize something, and actually not just something. So the heaviest common prefix, at least the heaviest common prefix of the inputs of all the correct participants. So we finalize the best case scenario with probability more than half during synchronous periods, and incentive compatibility. In the sense this relates also to the quality step. Nobody switches their proposal unless they see a strong quorum of support for that other proposal. So finality certificate finalizing a prefix of the chain is good, but it's not ideal if we can approve that to other systems that are not necessarily nodes fetching all the data of the particular longest chain protocol. So for example, smart contracts or other chains for chain bridges or l two s that you might be running in your system.
00:24:05.394 - 00:24:53.158, Speaker A: So an immediate side protocol of the f three is the finality exchange protocol that actually proves in a saxing way that particular chain has been finalized. We also use it for new nodes that join the system to catch up. Yeah, so in a nutshell, the fanaticity exchange protocol. So we assume whoever's verifying these fanatic certificates knows the public keys of the signers. So he must have received something. He must have received that perhaps in that genesis certificate or something of the sort, and the previous output. And with that, what we essentially sign in the decide phase is the power table delta.
00:24:53.158 - 00:25:46.898, Speaker A: So the changes that occurred in the power table as a result of the finalization of that new prefix, and also explicitly sign the tip sets that have been finalized by this new iteration of gossip DBFT. The power table deltas. We don't want to have a very big finality certificate that wouldn't be succinct, which is one of the requirements for the certificate. So we actually truncate the modifications to the power table by one byte in a cumulative way. So if somebody makes small changes to their power, eventually when the changes to the power are big enough, they become effective for the purpose of f three. And as I mentioned, thanks to the decide phase, we tolerate for these certificates 66% adversary. And thanks to accountability, even if there is an adversary that, a crazy adversary that controls basically the entire system, even more than 66%.
00:25:46.898 - 00:26:30.506, Speaker A: Because these messages assign, there's eventual detection and punishment. If there's a disagreeing output, it's, again, finality certificates. Okay, so in terms of the implications for longer chain protocols, that f three brings the immediate one we provide very fast finality. We're talking about tens of seconds, which is unheard of in the context of longer chain protocols. And it can be done for any longer chain protocol. Again, we do it in a very modular way. On top of that, we also provide saxin verifiable finality certificates that enables applications to build l two s smart contracts.
00:26:30.506 - 00:27:02.250, Speaker A: Also to verify finality. Also for chain bridges with other chains. And even like clients, too, they don't need to fetch the longer chain data. They can just fetch the finality certificates in order to verify the finality of a block or a transaction. Because of that, we think f three is a game changer for Filecoin and in general, for longer chain protocols. And going back to the gaming example that I showed at the beginning, where in the. Well, okay, that's inefficient.
00:27:02.250 - 00:27:42.818, Speaker A: Yes. So before we had a very long finality in Filecoin. And so this gaming platform will require to create its own l two and have users deposit some tokens once and wait these seven and a half hours. But once they do that, they can change and pay for games in their l two within like, tens of minutes. And then they should still probably create a state channel to actually play the game with somebody else. Then, thanks to the finality calculator and faster finality within tens of minutes, the gaming platform doesn't need to create an l two anymore. You could just have users pay for the games directly at the main chain, because it's going to take tens of minutes, which is kind of acceptable.
00:27:42.818 - 00:28:34.390, Speaker A: But still, to play, Alice and Bob will still need to create a state channel, something play off chain, basically, because it's too costly in terms of time to play in the main chain. And now, thanks to the final, to f three and fast finality within tens of seconds, still tens of seconds. Not every game will assume that amount, will accept that amount of latency. But maybe you're playing chess with one move every 30 minutes, and every move gives you a plus 10 seconds. It's completely acceptable then in terms of latency, maybe not in terms of how much it costs or whatnot, but it's completely acceptable for others and Bob to play directly in the main chain. And not only that, but every move is actually provable to other chains, or they could connect it to some other chains and have some conditional payments or something of the sort. Or even light clients could fetch this data directly without having to sync to falcoin.
00:28:34.390 - 00:29:24.850, Speaker A: So in terms of roadmap, where we stand, the finality calculator has been pR, and as I mentioned at the beginning, we expect to provide this functionality directly as an API call in the reference filecoin client. The reference implementations of the filecoin client, this function call will be in the form of some sort of risk assessment. So you basically get a probability of a particular transaction getting reverted based on some standard assumptions. That probably will provide also some options to tweak them depending on how much security you want. But it will be kind of like a fussy result. It wouldn't be it's final or not, because that's not what a finid calculator is about anyways. In the case of f three, however, we have already merged the entire design as a Falcon improvement proposal.
00:29:24.850 - 00:30:12.214, Speaker A: So the design is kind of, there's going to be minor changes, but it's kind of like finalized and we're at the moment working on the implementation. We have been working for a few months already, and actually it's kind of like finished. The internal audit is undergoing at the end of this week, end of February, external audit going mid March, and we're going to integrate it into the code base by mv 23, which is going to be at the end of q two in a deactivated state. The code and then will be activating no later than a month from that moment. That is in the case of Lotus and the other reference filecoin client implementations are closely following and also doing their part on it. And again, we have done an effort on modularity. There has been some pragmatism that probably not just for filecoin, but for other longer chain protocols will be interesting as well.
00:30:12.214 - 00:30:56.800, Speaker A: But either way, it's a very modular protocol that can easily be plugged into any other longer chain type of protocol. So that's it. In the end, it took me half the amount of time you needed. I get recognized when that be fast. But yeah, so thank you. And yeah, now faster finality in Falco and in longer chain protocol is a reality and you can use it as well to get finalized. So if anybody has some questions now, I guess I'm open for it, or if not, I can get off the stage.
00:30:56.800 - 00:30:59.950, Speaker A: Thank you.
