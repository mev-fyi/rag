00:00:07.450 - 00:00:25.640, Speaker A: Hi, everyone. My name is Stephen Shelton and I'm a blockchain engineer on the Moonbeam team. Before we jump in, just a quick shout out to my colleague Alberto. He created this content, was supposed to be here today, but he won't be in a little closer. Thanks. He'll be in next week. So one.
00:00:25.640 - 00:01:24.470, Speaker A: All right, well, what is Moonbeam's role in a multi chain future? So, if you're not familiar with moonbeam, Moonbeam is a EVM compatible blockchain in the Polkadot ecosystem. And if you're not familiar with Polkadot, Polkadot's big idea is that instead of having one blockchain that's going to do everything really well. What we expect is to see lots of blockchains that do one thing really well or maybe a few things really well. And so, true to this, Polkadot itself really only does one thing, and that is to provide block validation services to child blockchains. And so we sometimes refer to Polkadot itself as the relay chain or layer zero. And these child blockchains as parachains are sometimes layer one. And so Moonbeam is itself an EVM compatible parachain under Polkadot.
00:01:24.470 - 00:02:12.260, Speaker A: But Polkadot does one other thing that's very important, and that is to route messages between pair chains. So pair chains can send messages to each other. They can send messages to the relay chain. Relay chain can send messages to the pair chains all bi directionally. Oh, loading is not good. It driving some technical difficulties. Not sure why we're loading here.
00:02:12.260 - 00:02:34.090, Speaker A: Let me see if I can make this bigger. So maybe slideshow isn't working, but shoot. Yeah, wifi might be having trouble here.
00:02:38.120 - 00:02:38.870, Speaker B: Let.
00:03:03.060 - 00:03:27.924, Speaker A: We can do is. I've got the slides here. Oh, man. Well, maybe I could just continue with this. I know it's really small, less than optimal. So, as I was saying, moonbeam is a pair chain under Polkadot. Polkadot routes.
00:03:27.924 - 00:04:30.200, Speaker A: These messages, we call it XCM. And so one of the other things that Moonbeam does is that it's fully EVM compatible, like I talked about. So there are a lot of messaging protocols that interact with it and are able to talk to other blockchains. So this puts moonbeam in a good position where it can kind of act as a point of transmission and talk to not only other pair chains through XCM, but also these messaging protocols. So if one of these other chains wants to talk to another blockchain or they need to get into the Polkadot ecosystem, moonbeam is a good point of transmission for that. And so as a good example of this moonbeam also makes available this Xeom feature to smart contracts through precompile. So a smart contract is able to use XCM capabilities to talk to other parachains in the ecosystem.
00:04:30.200 - 00:05:37.296, Speaker A: And so as a good example of this, Lido is able to use Moonbeam's XCM capabilities to invoke staking functionality on Polkadot itself through the EVM. And so it can invoke staking functionality on polkadot and then represent that as liquid staking tokens on moonbeam itself. And so this provides kind of a much better user experience where instead of having to go through multiple steps to stake on Polkadot, you can just interact with it through Lido itself. So what is XCM? Well, XCM is really just a list of instructions and it's a list of instructions that one pair chain wants to send to another. And these instructions themselves are very granular and don't necessarily do anything useful. Internet USBC thank you. So these instructions are not very useful in and of themselves.
00:05:37.296 - 00:06:19.544, Speaker A: As an example, I might ask you to stand up and that wouldn't accomplish anything useful. But if I asked you to stand up and walk ten paces to the left and then flip a switch, I could get you to turn the lights off or on. And this is kind of the idea with XCM. So you take these granular instructions and the right combinations of them can do really useful things. So one fairly simple example of this would be a token transfer. So I could send an XCM to get a token sent from one relay chain to another and vice versa. But maybe a more interesting example is where I invoke native functionality on another pair of chain through these instructions.
00:06:19.544 - 00:07:10.236, Speaker A: And we'll take a closer look at that today. So this is kind of what it looks like on Moonbeam. What I've depicted here is a user, Alice on Polkadot and she wants to invoke some native functionality on moonbeam. And so what we do is we create what we call a multi location derivative account, which is a way for us to represent Alice on Polkadot as an ethereum compatible account id. And so then once we've done this, we can invoke whatever functionality Alice wants to invoke. This working now? Nope, bad idea. So once we've done that, we can invoke the functionality that she's requested as though it came from this multi location derivative account id that represents her.
00:07:10.236 - 00:08:02.412, Speaker A: And so a more specific example is remote EVM calls so we can use the same functionality to invoke the eVM on moonbeam from an xCM message from another parachain. Before we dive into that, let's take a quick look. This is probably a little too small to see, but what this is really depicting here is a user who wants to send a transaction to Moonbeam and have it evoked through the EVM. And so this user signs a transaction with ECDSA and sends it to RPC service. And this RPC service can then put it into a transaction pool where it can be validated. And if it's a valid transaction, it might be applied through the EVM and we can then see a state change occur. So this is all kind of normal stuff here.
00:08:02.412 - 00:08:34.904, Speaker A: Now when it goes through XCM, it works a little bit differently. I know it's too small to see here on the right side, but basically the user is going to submit a transaction potentially through another parachain. And the cryptography could be different there. So we can't make any assumptions that it's CCDSA. It could be SR 2519 or there might not be any signature at all. So this is one of the reasons why we come up with the multilocation derivative account id. That way we can represent it on our chain in a way we understand.
00:08:34.904 - 00:09:06.296, Speaker A: But there are also a couple other changes that we'll have to make to account for this. However, once all of this is done, it can then enter the EVM. And from that point on it looks exactly like a normal transaction. We finally connected. Hey, look at that. So some of the other differences that we have, there's a global nonce. So since there's no signature, it's entirely possible for two transactions that have the same fields to produce the same hash and cause a hash collision.
00:09:06.296 - 00:09:44.484, Speaker A: And so what we do is we have a global nonce. That way we consult every transaction with a unique number. Also, because there's no signature, there is no EC recover. So what we do instead is we take this multilocation derivative account id that we talked about and we substitute it in the from and the message sender when it goes into the EVM. And then we also do something similar with some of our RPC responses. And then lastly we set the gas price to zero. And this is mostly because we have a different mechanism for paying for fees.
00:09:44.484 - 00:10:15.290, Speaker A: So when you get into the EVM, you'll see that the gas price is set to zero. So these transactions can still be queried in the normal way. Here's an example of a curl call that's just going to call get transaction by hash. And such a transaction might look something like this. So in this case, we've replaced the from with the multilocation derivative account id that we talked about. We've replaced the gas price with zero. And you'll see that the VR and s have been set to some arbitrary constants, and that's because they're entirely unuseful in this case.
00:10:15.290 - 00:11:00.710, Speaker A: So I'm going to walk through an example where we're going to invoke a uniswap contract on Moonbeam from Polkadot itself. And here's a link to a tutorial. It's basically the same content with quite a bit more detail, if you're interested. So, basically what we're going to walk through is we've got Alice again here on Polkadot and she's going to build an XCM message, send it to Moonbeam. And then when moonbeam gets this, it's going to calculate its multi location derivative account to represent her on Polkadot. And then it will invoke the EVM, which we'll call the uniswap contract. And then we can see that there'll be a swap that happens.
00:11:00.710 - 00:11:31.616, Speaker A: So to do all this, we're going to need about four different steps here. And so basically, we're going to take call data that goes to the EVM and then we need to wrap it in a higher level call, and then we need to wrap that in an XCM message. And so this is kind of an encapsulation technique. I kind of think of it as layers of an onion. So the first layer of the onion, like I said, is going to be our EVM call data. And then the next thing we're going to need to do is build up what we call a palette Ethereum XCM call. And that will result in another layer of call data.
00:11:31.616 - 00:12:15.916, Speaker A: And then from there, we'll need to head over to a Polkadot relay chain and then create a XCM message with this call data. And then finally we can send it and it will head over to moonbeam. So let's take a look at the first step here. This is uniswap. So what we have here is a uniswap deployment on our moonbeam testnet along with the UI. And so it's worth pointing out here that while this looks a little gnarly, in a real world scenario, you would expect this to be all done programmatically and this would not be part of the UX, but we're kind of doing it by hand here. So what we do is we go to the UI and we set up a swap and we start interacting with metamask.
00:12:15.916 - 00:12:59.612, Speaker A: But instead of sending the transaction, what we're going to do is hit the hex tab here and we're going to scrape this data here. This is the low level EVM call data. And so now we're going to dissect it a little bit and replace a couple of things. So here's the call data from the last slide, and you can see that the function selector maps to swap exact eth for tokens. And then there's a number of other fields and we're going to replace a couple of them. So since we're doing this by hand and it might take a little while, we increase the deadline and we also increase the slippage amount in case the price moves on us. And more interestingly, we also replace the account id with a multi location derivative account id that we talked about.
00:12:59.612 - 00:13:35.480, Speaker A: And this again represents Alice on Polkadot. And so the next thing we need to do is what we call the palette Ethereum XCM call. So a palette is kind of like a smart contract in that it has functions that can be called. And so you can kind of think of it as the same way. So what we do here is, let me explain this UI a little bit. So this is a crude UI that wraps the low level functionality exposed by moonbeam. And you'll find the same UI exists for just about every blockchain in Polkadot.
00:13:35.480 - 00:14:06.980, Speaker A: So what we're doing here is we create a call to palette Ethereum XCM. We're going to call the transact function. And then this probably looks a little familiar. The parameters we're going to pass in look a lot like an Ethereum transaction where we have a gas limit, we have an action that is a call as opposed to a create. And then we have a contract address that we're going to specify a value. And then these input bytes at the end are the EVM data, the EVM call data that we just looked at. And so now we're kind of creating the second layer of our onion.
00:14:06.980 - 00:14:47.280, Speaker A: We now have call data that represents everything above. That's the Ethereum XCM call, including the EVM call embedded into it. And so now what we need to do is take this call data and move over to the Polkadot relay chain, or really our testnet version of it. And so you see the same UI here, but we are on a different blockchain now. And so we have Alice who wants to invoke the XCM palette and she's going to call the send function there. And there's going to be quite a few different fields here, so I'm going to kind of gloss over them. The first ones here towards the bottom, specify basically which chain it's going to go to.
00:14:47.280 - 00:15:20.232, Speaker A: So this specifies that this XM message should go to moonbeam. And then from here we're going to build up the list of instructions like we talked about earlier. So the first one is withdraw asset. And what this really does is take funds held under the control of Alice and puts them into a holding register which is kind of a temporary place that exists for the duration of the XCM execution. And the next one is buy execution. And so that takes funds that are held in the holding register and basically uses them to pay for fees. And then the interesting part is the transact instruction.
00:15:20.232 - 00:16:02.644, Speaker A: And so here again you see the encoded bytes. This is our encoded Ethereum XCM call data that we looked at previously. So now we've taken that and we've moved over to the relay chain and we're putting it all inside XCM message. And then finally is deposit asset. And all this really does is refund unspent fees. And so if Alice were to do all this and hit submit, then it would go over to Moonbeam, be unwrapped by the Ethereum XCm palette, and then the inner evM call data would be sent to the eVM. That would trigger a call to the uniswap contract.
00:16:02.644 - 00:16:36.532, Speaker A: And finally we can see here that a swap occurred. So we have our tokens that were swapped. Also of interest is that we have a gas price of zero, although we do still have gas that was used. So there is a gasometer and it is still respected in the normal way. And again, we can call gettransaction by hash to use the normal Ethereum RPC. And here you can see that we get a response, but the nonce has been replaced with the global nonce. We've replaced the from with our multi location derivative account.
00:16:36.532 - 00:17:08.910, Speaker A: Gas price set to zero, still consume some gas and vrns are still their useless constants. All right, well, thank you all very much. Sorry for the technical issues earlier, but if you're interested in today's slides, there's a QR code at the top right, a bitly link at the bottom left. There's a QR code to the right. For some more moonbeam related resources and then some of our socials as well. Also want to point out that we will have a booth next week. We'll be at Devtopia booth R.
00:17:08.910 - 00:17:50.510, Speaker A: I'll also hang around in case anyone is interested in chatting about this, and we might have time to take some questions as well. So is this only to make the call to another EVM that's on the power chain or to go, no, it has nothing specifically to do with the EVM. So it basically is a way to send instructions to another chain. And those instructions can do just about anything. They could just move tokens around or they could query some state on that chain. In our specific case, we're invoking the EVM, but that is kind of one specific use case of XCM. So XCM is very flexible.
00:17:50.510 - 00:17:57.560, Speaker A: Anything else?
00:18:02.330 - 00:18:11.180, Speaker B: What limitations, if any, do you see going to say back to Ethereum or even l two s chains like that?
00:18:12.430 - 00:18:29.520, Speaker A: Well, so XCM is kind of a completely separate thing. So I think anything you could do with XCM would be kind of a different thing. So you could kind of add these things together, but they don't necessarily overlap in that way.
00:18:30.050 - 00:18:34.000, Speaker B: Okay, so for the remote EVM calls, how do you think about those?
00:18:34.850 - 00:18:53.798, Speaker A: So the remote EVM calls, that's another chain sending an XCM message to moonbeam. And the moonbeam is going to go in and invoke its EVM. And so that could, for example, interact with a messaging protocol that wants to go to another blockchain and interact with it. That kind of. Get it.
00:18:53.804 - 00:18:55.640, Speaker B: Your question? Yeah. Thank you.
00:19:01.370 - 00:19:04.180, Speaker A: All right, well, thank you all very much. Appreciate your time.
