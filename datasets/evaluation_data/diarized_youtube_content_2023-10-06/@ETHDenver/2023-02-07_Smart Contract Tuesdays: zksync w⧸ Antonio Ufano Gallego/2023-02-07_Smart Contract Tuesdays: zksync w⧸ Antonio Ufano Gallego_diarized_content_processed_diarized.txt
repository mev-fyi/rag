00:00:00.490 - 00:00:11.838, Speaker A: So, hello from the past. I am Derek, the community steward at East Denver, aka Sporkdow. And today I'm joined by Antonio from Zksync. Hi, Antonio, how you doing?
00:00:12.004 - 00:00:13.742, Speaker B: Hello. Pretty good.
00:00:13.876 - 00:00:50.380, Speaker A: Thanks for coming on. So in a moment here, we are going to dig into what Antonio's team is doing over at ZK sync, explain some of the basics of what it is, what you might be able to use it for today, and what kinds of problems it's solving. But before we do, I'm curious, Antonio, is there a way you can sort of tell how you, as we like to say, fell down the crypto rabbit hole? Like, what was your background before you were at zksync? How did you end up finding out about either web three? How long have you been in the space? Just so folks can get oriented to who you are sharing this information today?
00:00:50.830 - 00:00:55.200, Speaker B: Yeah, do you want the short version or the director's cat?
00:00:56.130 - 00:01:08.930, Speaker A: Honestly, I would love the long version. We definitely have time for like the five minute version where you're like, well, I used to be a librarian. Stories are always super. There's like the one meeting that changed your life. So I am curious.
00:01:09.270 - 00:02:19.722, Speaker B: Yeah, no, in my case, I have a background in software engineering. So I worked as a software engineer for like twelve years and working basically in the banking industry. And after ten years working in the same company in very boring projects, I realized that software engineering can be a lot more fun than the things that I was doing. So I started working on my own projects while I was still working on the bank. I started building my own projects, I created my website, I started blogging and learning a lot of different technologies that I was not using in the bank. So I started coding with node JS, a lot of front end frameworks and cool things that I was seeing online. And it got to a point where I was having more fun, like building my own projects and blogging on my personal website that on my job.
00:02:19.722 - 00:03:22.510, Speaker B: So I had some savings and I quit my job in 2020 right before everyone went full remote on March. So yeah, then basically I spent like a year basically building my own projects. I created a weekly planner to do listhabitracker just for myself that anyone can use. I started a podcast kind of podcast thing and many different projects for a year until at some point I realized that, okay, I need to do something with my life, something that can pay my bills. So I thought, okay, what can I do? I mean, I don't want to go back to work for a bank or something like that. And that's when I decided to get into blockchain. So what I did is again starting in solidity and start a new blog.
00:03:22.510 - 00:04:06.486, Speaker B: The blog is called Solidity Tips. And basically I was following tutorials from crypto zombies and all these tutorials and everything that I was learning, I was blogging about it in there. I was putting small tips or how to's, things like that. And after three, four months I started getting messages from projects that were looking for people. And last year I got my first job in blockchain. I joined Chainstack, which is a blockchain infrastructure company, and I joined them as a developer advocate. And basically my job was to create tutorials and create blogs.
00:04:06.486 - 00:04:24.750, Speaker B: So that was pretty good. And recently, like four months ago, I joined CK sync again as a developer relations engineer, where my job is to again help people build on CK sync and create content. So amazing job. Yeah.
00:04:24.820 - 00:05:23.198, Speaker A: And for folks that are not familiar with these jobs, like developer advocate, developer relations engineer, you just talked about how it's kind of at the intersection of having the technical knowledge like software engineering, to know what you're talking about. But then also whether it's like some kind of communication skills, maybe that's writing and blogging like you mentioned. Maybe it's like what you're doing right now, this sort of presentational style, but this intersection of technical and communication or social skills, I think just to say the obvious for folks that have been around, that's not obvious to folks that are new to the space, that's a really in demand position. There continues to be not enough supply of people qualified to do it to meet the demand of people willing to do it. So if you are looking at what Antonio is doing today and saying that's a pretty sweet gig, I want to go around and explain some cool piece of technology and get paid to do it. That's called Devrel developer relations or developer advocate. And I hear places every week that are hiring.
00:05:23.198 - 00:05:34.694, Speaker A: You were writing a blog and three or four months in people were just dming you like, can you please work for us? I think that's a pretty cool path. You just learn in public, as we say, and then got scooped up.
00:05:34.892 - 00:06:06.882, Speaker B: Yeah, it's super demanded this role. At the end of the day, we are like the salespeople for developers. There are a lot of projects that are building tools and the client or the consumer are other developers. So what you need is a developer that is capable of explaining that product to other developers and build tutorials and demos that showcase how that product works. And that's the job, basically, yeah.
00:06:06.936 - 00:06:36.780, Speaker A: It reminds me of the old saying during a gold rush, sell shovels. It's something like that. You're trying to create infrastructure because a lot of people might be interested in doing ZK protocols, and ZK sync is an option to make it that much easier to do, rather than them having to figure out some esoteric, from scratch type of implementation. So maybe that's a good way for us to transition into ZK sync. For folks that are not familiar with zero knowledge technology. What is ZK sync? What is it trying to do?
00:06:37.790 - 00:07:25.766, Speaker B: ZK sync is a layer two blockchain. And don't worry if I get into technical details because we will explain everything later in the presentation. But it's a layer two that uses zero knowledge proofs. And basically we use layer two to scale Ethereum, basically to allow more people to use it at the same time. And the good thing is that it inherits the security from Ethereum. You have other layer one blockchains that are super fast and are capable to handle thousands of transactions per second. But they do that by not being as decentralized as Ethereum and as secure as Ethereum.
00:07:25.766 - 00:07:41.134, Speaker B: So what we are doing with CK sync, our other layer twos are trying to do, is trying to keep the decentralization and security from Ethereum, but we are trying to scale it and being able to handle more transactions per second.
00:07:41.252 - 00:08:30.640, Speaker A: Let's say the analogy that I think often gets used is to think of block space, like the number of transactions that are interested in being included on the next block. In other words, like, what happens next? You can think of it like New York, and that's like a finite amount of land. And so at first, when it's not completely developed, it's pretty easy. Like, I'll go over there, there's some empty plot of dirt. But then once it's filled, and we've developed the entire layer one of single story homes, if you want to have more people there living or working now you got to start building second stories and skyscrapers and so on. So Zk sync, if you'd like to think of it, is like a skyscraper where you can have more going on, but then it all rolls up to only occupy a finite amount of block space, and in this way be more efficient for the overall ecosystem of transactions that are happening each moment.
00:08:31.250 - 00:08:31.662, Speaker B: Yeah.
00:08:31.716 - 00:08:33.142, Speaker A: Is that a fair analogy?
00:08:33.306 - 00:08:42.210, Speaker B: Yeah, it is. And you mentioned roll up. Ck sync is a roll up. We'll explain it again during the presentation.
00:08:43.590 - 00:08:51.110, Speaker A: Okay, so what would you like to show us today? What makes it easier to understand these pieces as they play out in practice.
00:08:52.010 - 00:09:26.180, Speaker B: Yeah. So basically today's workshop is titled intro to layer two is built on the CKBM. And what I've realized, talking with a lot of developers, is that people start learning solidity and how to build things on Ethereum or other layer ones. But when you mention them, what it's layer two or what are serial knowledge proofs? Developers think of them as very complicated concepts and they think that the development experience, it gets too complicated and that it's going to be very different.
00:09:28.150 - 00:10:07.440, Speaker A: I would like to provide an example. I mean, we recently had a guest, Antonio Lendo, who showed us ZK snark technology and was talking about how you basically need to code in a completely different language, like a completely different framework. Like you need to do mathematical constraints on logical gates. And I was just like, I don't even know how to think that way, much less the syntax. This is really hard. So there are valid reasons that folks who hear about things like layer twos or ZK technology might have a first impression of like whoa, whoa, whoa, solidity is hard enough, dude. So what would you say to them?
00:10:07.890 - 00:10:57.546, Speaker B: Yeah, so basically we've built CK sync to maintain the same developer experience as Ethereum. So all the frameworks work. You can code the smart contracts with solidity or Viper, and most of the tooling works out of the box. And yeah, you have to do minimal changes in deployment script or your integrations with front end, but that's it. The part of writing smart contracts is exactly the same. And I will show you some examples later on. So basically, yeah, the goal of this presentation is for people to learn what are layer twos, the problems they solve, what is a roll up, what is the CKE EVM? And then deploy a few smart contracts, very simple, to the CKC testnet.
00:10:57.546 - 00:11:07.666, Speaker B: And if people do them, they will get git pop, which is an NFT for free. So yeah, that's it.
00:11:07.848 - 00:11:09.950, Speaker A: Okay, let's get some poaps.
00:11:10.110 - 00:11:15.250, Speaker B: Yeah, cool. So how can I present?
00:11:15.400 - 00:11:19.010, Speaker A: Yeah, next to mute and camera, there's a share screen thing here.
00:11:19.080 - 00:11:20.046, Speaker B: Okay, here we go.
00:11:20.088 - 00:11:35.690, Speaker A: While you're doing that, hi George, Cheb, welcome back. Vikrant, Juan, Geraldo, always good to see you and beam. You know I love you from the bottom of my heart. And then when you've got that full screen, Antonio, I can bring it up in the meantime. Yeah, I can see it.
00:11:35.840 - 00:11:38.250, Speaker B: Okay. Because I don't see.
00:11:38.400 - 00:11:59.780, Speaker A: I'll go ahead and put it here. Oh, let's do it like this. Great. Before we dig in, I put a link to a tweet that ethereum Denver eth Denver put out earlier today. If you're enjoying this, if you're finding this valuable and want to support us, it'd mean a lot if you could like and retweet that. Just to let other people know that we're having this conversation with Antonio right now. Thank you all.
00:11:59.780 - 00:12:11.240, Speaker A: So whenever you're ready, Antonio, I am super curious. Teach me. The secret is I like doing these because even if nobody shows up, I get to learn a lot. So, ready when you are.
00:12:11.770 - 00:12:30.940, Speaker B: Okay. Yeah. Okay, we're ready. So here it is. Introduction to layer twos building for the CKE EVM. So pretty excited to be here and talk to you about layer twos. I think we have already explained what this is going to be about, so let me pass this one.
00:12:30.940 - 00:13:01.426, Speaker B: Okay, so this is the agenda for the next 45 minutes. Something like that. We're going to start with an intro to layer twos. We will see what they are. We will talk about roll ups in particular, and we will also talk about the CKE EVM. After that, we will talk about why do we need layer twos, how to use them both as a user and as a developer. And we will focus on a few CK sync specific features.
00:13:01.426 - 00:13:18.074, Speaker B: And finally we will talk. We'll have some hands on time, and we will create and deploy a few smart contracts to the Ck sync testnet and we will learn how to interact with them if we have some time. I guess we can do Q and A's at the end.
00:13:18.192 - 00:13:18.860, Speaker A: Great.
00:13:19.630 - 00:13:57.858, Speaker B: Cool. So this is me. My name is Antonio. I'm a developer relations engineer at Matterlabs for the ones joining late. And I have around 15 years of experience in software engineering in a lot of different roles. So basically my job today, my current role is to help projects build on CK sync and also to educate other developers about all the awesome features that Ck sync offers and the different tools that we provide apart from that. That's my twitter handle in case you want to follow me.
00:13:57.858 - 00:14:35.540, Speaker B: And solidity tips is a blog that I started, the one that I mentioned earlier, in case you're learning solidity and you want to check it out. So at Matterlabs, we are building CK sync. And for those that don't know what it is, CK sync, it's a layer two roll up powered by a Cke EVM. And that sounds great. But if I know you are like this, don't worry, because you are in the right place. We are going to go through all these concepts one by one. So yeah, stick with me.
00:14:35.540 - 00:15:29.880, Speaker B: So what is a layer two? Well, layer two is a blockchain. It's a system built on top of another blockchain which is known as the layer one. In the case of Ck sync, the layer one is Ethereum and the layer two is Ck sync. For our testnet, the layer one is the go early testnet and the layer two is the Ck sync testnet. And if you see there is a line here connecting the two layers and we will talk about that line later on. So the main purpose of layer two is to improve scalability by moving the execution of the transactions of chain. And it also maintains the same security guarantees as the layer one.
00:15:29.880 - 00:16:15.990, Speaker B: There are different types of layer twos, like side chains, like polygon, there are plasma or state channels. But we are going to keep things simple and we are going to focus just on one of them. That is called roll ups, which is what we mentioned earlier. So what is a roll up? Roll ups are bundles. Basically a roll up is a type of layer two that bundles transactions together into batches before sending the transaction data to the layer one. And by sending the transaction data to the layer ones. Layer twos inherit the security from the layer one, in this case from Ethereum.
00:16:15.990 - 00:17:06.270, Speaker B: The same way that there were multiple types of layer twos. There are two types of roll ups, optimistic and zero knowledge. So we are not going to get into a lot of details about the difference between these two. But we can say that optimistic roll ups assume that all the transactions in the batch are valid and they rely in proof systems. These proof systems normally have like a seven day lock period, which means that during this time the system can dispute any transaction. And that means that the withdrawal periods from an optimistic roll up is normally those seven days. On the other hand, Ck roll ups use sigonoids proof.
00:17:06.270 - 00:17:49.250, Speaker B: And they generate a proof that the transactions that have been executed on the layer two are valid. And they submit this proof to the layer one where the proof is verified. They rely on math and cryptography instead of proof systems. This means that there is no lockup period. So basically you can deposit and withdraw funds whenever you want. And this is like a table with the main difference between them. Okay, so what is the CKBM? As you may know, transactions in the blockchain are executed by a virtual machine.
00:17:49.250 - 00:18:29.278, Speaker B: So in the case of Ethereum, the Ethereum virtual machine, but other blockchains uses different. Example Solana. It's a layer one that uses a different virtual machine. Stagnet is a layer two that uses different virtual machine as well. So having a different virtual machine usually comes with some pros and some cons. One of the main pros is that these virtual machines can be customized for specific needs like increasing scalability. We all have seen that Solana is able to handle like 100,000 transactions per second.
00:18:29.278 - 00:19:25.490, Speaker B: They do it because they have their specific virtual machine that is configured for that. On the other hand, having a completely different virtual machine means that the developers need to learn a specific smart contract programming language and tools. For example, again with Starnet, you need to learn Cairo to write smart contracts. A CKBM is a built on machine that is compatible with the ABM and is able to generate zero knowledge proof of these transactions that it executes. So the main benefits of Tasik ABM are these four. First of all, it's programmable with solidity and Viper just like the ABM. So developers don't need to learn any new programming language.
00:19:25.490 - 00:19:46.358, Speaker B: It supports the web three API, so most tools work out of the box. The security is inherited from the layer one because it sends the transaction data to the layer one. And finally it's resistant because you can submit transactions to the layer two from the layer one.
00:19:46.524 - 00:19:52.410, Speaker A: Quick question. When you say full support of web three API, are you referring to web three js?
00:19:54.990 - 00:20:34.870, Speaker B: It's very similar. Yeah. In the case of Ck sync, for example, you might have heard about ethers. So we are using our CLI, sorry, our library, it's called CK sync, web three, and it's built on top of ethers. So basically it uses the same methods, it uses providers contracts, it uses everything. So it's the same for the node, the client, it uses similar RPC methods, so you can send an eth central transaction and things like that. Everything is similar.
00:20:35.020 - 00:20:42.186, Speaker A: So not only will smart contract developers have a similar developer experience, front end developers will have a similar developer experience.
00:20:42.368 - 00:20:43.482, Speaker B: Very similar. Yeah.
00:20:43.536 - 00:20:45.706, Speaker A: Wow, okay, great, I'll let you keep going.
00:20:45.888 - 00:20:47.514, Speaker B: Yeah, cool.
00:20:47.632 - 00:20:49.580, Speaker A: Making people's lives easy over there.
00:20:49.970 - 00:21:38.250, Speaker B: Yeah, that's the main thing, because if you have to, I mean, obviously developers can learn new languages. They've been learning new languages forever. But the easier the developer experience is, the easier you will get projects built on the protocol. So that was one of the main focus for Ck sync. So now that we have explained the layer two roll apps and CKBM, we go back again. I guess it's easier to understand. So now comes the question, okay, why do we need layer twos? So I'm sure you have seen this diagram before.
00:21:38.250 - 00:22:20.220, Speaker B: It's the blockchain trilemma. And basically it says that a system can only achieve two of these three codes, security, decentralization and scalability. In the case of ethereum, it's one of the most decentralized and secure systems. But scalability is the weakest point. I think currently it's able to handle like twelve to 15 transactions per second. And in times of big loads, when there is a lot of people using the network, the transaction fees are super high. Probably just seem like someone trying to send a $50 transfer and the fees are $15, something crazy like that.
00:22:20.220 - 00:23:16.746, Speaker B: So layer two solved this problem in two different ways. First, by moving the execution of the transaction to the layer two and bundling these transactions together in batches, rocks, we increase the throughput and then using call data to store the transaction data and serving the fees between all the transactions in a batch, we reduce the transaction fees. So those are the two ways we increase scalability. Now, how does it actually work? Because we have talked about, yeah, it's a different blockchain, it works in parallel. But how does it work? Well, it works with smart contracts. Basically, a layer two has smart contracts deployed in both the layer one and the layer two. And these contracts interact with each other to keep consistency of the state.
00:23:16.746 - 00:24:12.720, Speaker B: In the case of a CK roll up, there is a layer two. There is a contract in the layer two generates the proof and sends the proof to the layer one along with the state changes. And then the contract in the layer one validates the proof and updates the state. As you can see in this diagram, the layer two generates blocks much faster than the layer one. Once it has enough transactions, it creates a patch, creates the proof, sends it to the layer one, and then it's validated. That's basically how it works, like in simple terms. So how do you actually use a layer two? As a user, how do you use it? So first you have to deposit funds in the contract in the layer one.
00:24:12.720 - 00:24:44.230, Speaker B: Then your funds will be available in the layer two. This is similar to a bridge. Then you have funds on the layer two. You can interact with any apps, you can go to a dex, you can go to an NFT marketplace, do or play games, whatever. Interact with us. When we send a transaction, this transaction is executed by the CKBM. When there are multiple transactions ready, they are bundled together into a batch.
00:24:44.230 - 00:25:28.150, Speaker B: Then a serial knowledge proof is generated for the whole batch and then it's sent to the layer one. Then the proof is validated by the smart contract in the layer one. And finally the state or balances are updated in the layer one contract. So that's basically how it works. And this process of banking transactions together, generating a CK proof, sending it to the layer one and updating the stake, that's happening constantly. So yeah, that's basically how it works. There are other benefits for layer two.
00:25:28.150 - 00:26:33.530, Speaker B: Basically the transactions have lower fees because the fees are paid between all the transactions that are included in the same bat, and we have higher transactions per second, as we said earlier. Then if we are moving transactions from the layer one to the layer two, basically we are reducing the load of the network of the layer one, which is another benefit. And apart from that, the CKEBM includes additional features like account extraction support and support for paymasters. Account extraction is a pretty cool topic that is talked a lot lately and we are not going to go deep into it. But after this, if you are curious about it, really recommend learning about account abstraction because it's very cool. Basically it promises to bring web two user experience to web three. So yeah, it's a huge promise and I got to say, it delivers.
00:26:33.530 - 00:26:53.202, Speaker B: So as a developer, how do you build applications on CK sync? First, you create your smart contracts with solidity and Viper or Piper, if you already have an application, you are most likely good to go and you won't need to do any changes in your.
00:26:53.256 - 00:26:56.900, Speaker A: Smart contracts, which is again huge.
00:26:57.670 - 00:27:21.706, Speaker B: Yeah, then obviously the CKBM, it works a little different. So you need to compile your contracts with one of our compilers and they're called Cksorc and CK Piper. And yeah, again, we use these compilers because the bytecode that they generate is different from the default bytecode that you.
00:27:21.728 - 00:27:38.480, Speaker A: Get from hard hat because folks who have been following along, we've been doing some hard hat tutorials, for example. And so we're familiar with like hard hat compile. So this is just like a slight difference. Maybe it's even in the config, it's not even a different command, you're just like compile, but now it's using ZK solk instead.
00:27:38.930 - 00:28:19.050, Speaker B: Exactly like that. And we will show you an example. We have a plugin for hardhat that brings our compiler, and then you just do hardhat compile and it compiles for CK sync instead of for Ethereum. It's pretty cool. After that we have our own SDK for front end integrations and it's called CKC web three and it's built on top of ethers and it uses the same classes and methods. So in most cases the thing that you will have to change is just the import at the beginning.
00:28:22.770 - 00:28:26.858, Speaker A: You get to keep a lot of your scripts and integration tests.
00:28:27.034 - 00:29:16.698, Speaker B: Yeah. So if you are importing contract from ethers, you will import contract from CK sync web three. If you are importing provider or utils from ethers, you will import those classes from CK sync web three and everything will work out of the box. Pretty cool. Then to deploy your contracts, you will have to write your own deployment scripts that uses the CK sync deploy packets. This is different, but they are like 90% similar to the deployment scripts that you get with hardhat. So the only difference is that they use a deployer class, which is different because the deployment process on CK sync is a little different under the hood.
00:29:16.698 - 00:30:08.590, Speaker B: But we have this package that handles everything for you. You just have to use deployer class and I will show you an example later on. And once deployed, that's basically okay. So these are a few examples of the differences between how you do things for ethereum or any other EVM and how you do things with Cksync. So first, this is an example of how to interact with a blockchain to retrieve some data. And in this case we are retrieving the network details, the latest block number. And finally we are retrieving transaction receipt.
00:30:08.590 - 00:30:45.930, Speaker B: Yeah, get transaction receipt. And we are passing the transaction and we're printing. So this is how you will do it for ethereum. And this is how you will do it for CK sync. And the difference is obviously the RPC URL is different because here we're using an endpoint from infuria, this is API key at the end, but we're using infuria for example. And here we are using CK sync endpoint. But apart from that everything is the same.
00:30:45.930 - 00:31:41.318, Speaker B: And even if you see the import on top, we are using ethers because what we mentioned earlier about the web three API compatibility. So our node, you can do get network, you can do get block number, you can do get transaction receipt, same thing that you will do as in for Ethereum, you can do it on CK sync and it works. They're exactly the same. This is another one. And this is how to interact with a smart contract. In this case, as you can see, we're using, here's the difference. Okay, so as you can see here, we are using the CK sync web three library, which as I mentioned, it's built on top of ethers, so it uses the same classes, provider, contract, wallet, et cetera.
00:31:41.318 - 00:32:30.010, Speaker B: So as you can see, the only thing that changes is the import. And in both cases we are initializing the contract with the address, the API and a signal and then we are calling the method from the contract in this case is set greeting and passing in a new message exactly the same. The only thing we are changing is the CK singer three import. What you mentioned earlier that you just have to change the import and everything works out of the box. That's it. So if you are migrating an existing project, basically summary is you don't have to do any changes on your solidity or viper code because most contracts will work out of the box. And then you will have to do minimal changes in the deployment scripts and front end integrations.
00:32:30.010 - 00:33:09.634, Speaker B: Okay, so that's that presentation and now we're going to do some coding. This is the repo that we have. And as I mentioned earlier, there are some tasks you don't need to follow along right now. You can do this tomorrow or during the weekend whenever you want. If you complete some tasks that are in the readme of the repo, you will get a git bulk. So that's pretty cool. So I guess that we can share the link to the repo like somewhere.
00:33:09.762 - 00:33:28.720, Speaker A: Yeah, I'll go ahead and throw it up on the screen for folks. And of course you could go back to the vod here and just pause and type it out and then I'll let you keep going with this demo. But I'm grabbing a couple of questions as folks have them as we go through. So we can come back to these during the q and a part.
00:33:29.170 - 00:33:29.774, Speaker B: Okay.
00:33:29.892 - 00:33:30.720, Speaker A: And dig.
00:33:33.730 - 00:34:16.640, Speaker B: Ok, here is the repo and as I mentioned earlier here there are some tasks and things that you can do later. But before jumping into the code, I want to show you a few things. First is the Ck sync portal. And basically this is like a front end that allows you to deposit funds on CK sync on the r two contact that I mentioned earlier. So basically, if you have any, go early. If you can deposit it here and you will send it to CK sync, just have to deposit. And if you don't have, tell me.
00:34:18.130 - 00:34:58.490, Speaker A: Bridges are famously a security concern in the space because you take this entire decentralized network that you're working so hard to have all these nodes secure, and then you make a bridge between two of them and you try to incentivize people to leave liquidity in the bridge. But these bridges often have less auditing than the entire networks that they're between. Last year there were just countless bridge hacks. This feels fundamentally different. The fact that it's a layer two and a smart contract that's on the l one. It's not like trying to pass state between two l ones. So can you just speak at a brief level to how this is like a pro and con of this bridge versus a bridge, say over to Polygon?
00:34:59.470 - 00:35:58.058, Speaker B: Yeah, so this is a trustless bridge. So basically this works with smart contracts on the layer one and on the layer two. There is no back end service centralized by ourselves or any other company that can get hacked or something like that. Basically the way it works is when you deposit funds, what you're doing is sending a transaction, sending ETH from your wallet to the Ck sync smart contract owner one, and then we are sending that ethync. Basically we are creating your wallet on CK sync on the layer two and we are depositing your eth the same amount of ETH. And whenever you do any transaction on the layer two, we have to generate a zero knowledge proof that is cryptography and maths like the heart of that. It's magic.
00:35:58.058 - 00:36:46.314, Speaker B: We have to send that proof from the layer two to the layer one. That proof has to be validated, and only when that's validated your state will change on the layer one. So there is no centralized entity, everything is smart contracts. And yeah, it's different than all these hacks that happen because someone stole the private keys, things like that. They are more secure. And we are running multiple audits on the system. We have run one by open seplin, we have another program that is open that people can find bugs and they will be rewarded.
00:36:46.314 - 00:37:18.694, Speaker B: We have another audit going on. So before opening the system for all users, we are going to have all of these outlets completed because security is very important from us and we are not just going to allow anyone to bridge funds to CK sync if the system is not ready. Security is one of our priorities and we are auditing everything. I guess that answers the question.
00:37:18.812 - 00:37:50.674, Speaker A: It does. Thank you. Yeah, I wanted to zoom in there just for a moment because that's another giant pro of this, even if we never end up seeing it matter. There's this old saying in the theater industry, if you're doing your job right, no one will notice. Like when the microphones work, it's seamless, but the second a microphone is off or does a big feedback screech, everyone's like, hey, who messed this up? So in that same way, this bridge is trustless. And as long as the audits were done correctly, it sounds like it's fundamentally different from other bridges. And you'll never notice that.
00:37:50.674 - 00:37:53.060, Speaker A: You never get rugged. And that's a good thing.
00:37:56.470 - 00:38:51.718, Speaker B: Basically this is how you can bridge, if you have currently you can bridge it to Ck sync so you can pay for the deployments, things like that. If you don't have, you can use the faucet which works. Basically you request funds and you have to post a tweet and it will give you like some eTH and some test die and test wrap btc I think as well other ERC 20 tokens to test as well. If you don't want to use this one, you can use any goldly faucet like this one from alchemy. And we have our own faucet that uses proof of work. So you have to mine CK sync and all these links are here in the repository as well. Cool.
00:38:51.718 - 00:39:33.620, Speaker B: Then this is our explorer, I guess that you guys know about explorers. Basically you can come here and browse any blocks, transactions, things like that. So we have our own explorer for Mainnet and for, and I think that's it. I think we can jump into the code. So how do we create a project with cksync? The easiest way to start is using the CK sync CLi. This is a tool that we have created. Let me see if it's not too big.
00:39:33.620 - 00:40:22.194, Speaker B: Better, I guess better. So this is a tool that we have created and basically it allows you to create a new project, deposit funds on CK sync and withdraw funds from cksync to install it globally. This is the same installation details from our docs. Basically you run NPM install minus G and then Ck sync Cli latest. I already have it installed. So basically once you have it installed you can use CK sync Cli create like here and then give it a project name and it will create a project for you. It's similar to when you do MPX hard create that it creates a new project for you.
00:40:22.194 - 00:40:23.620, Speaker B: Exactly the same.
00:40:24.310 - 00:40:46.780, Speaker A: Okay. Or by analogy for folks coming from the front end side, like if you've used create react app many times, okay, great, that's one thing. But at this point you might use something like Veet instead to accomplish a very similar goal. So there's just like a sort of a different starter repo but with a lot of the same config that's familiar to you, but it's already taking care of these ZK pieces for you.
00:40:47.150 - 00:41:15.090, Speaker B: Yeah, exactly. So basically what it does, it clones an existing template project for you and it contains a contract, it contains all the CK sync packages and dependencies, the compiler, it contains the config file. Ready? So yeah, basically similar to mpxrhat create or create react app or Vit or any of these starter Clis.
00:41:16.630 - 00:41:35.580, Speaker A: I don't want to sound too hyperbolic, but this is one of the better sdks I've been exposed to. This is like a fantastic experience. It's clear you've put a lot of thought into trying to make it as easy for folks as possible to take on a new technology and have the developer experience be minimally different from what folks are already used to. So again, appreciation to the team.
00:41:36.110 - 00:42:26.220, Speaker B: Thank you. Because yeah, before that the way to create a new project was you create a new npm project and you install hardhat manually and ethers and then all our dependencies and it was like a repetitive task that is not great. So it's very easy to build a CLI that takes a template project and push it for you. So this is exactly that. So basically if we go here, let me know if this is big enough, that's good enough. Yeah, so once you have it installed, you can do ck sync Cli create and we can give it like demo project name. And there it goes.
00:42:26.220 - 00:43:06.120, Speaker B: Basically what it does, it downloads a template project with everything that we need and everything set up out of the box. As it says, you just have to run CD demo to enter your project folder. Then the contracts are in the contract folder, the deployment scripts are in the deploy folder, and then we can do Jarhat compile to compile the contract, or Jarhat deploy CK sync to deploy contract. So I'm going to open this with the code editor. Oh, not this. Sorry.
00:43:07.630 - 00:43:09.750, Speaker A: You ignored step one, Antonio.
00:43:09.910 - 00:43:10.860, Speaker B: I did.
00:43:15.310 - 00:43:16.940, Speaker A: GM batch it. Welcome.
00:43:18.750 - 00:43:25.470, Speaker B: Okay, so this is our to, I'm a mess with Windows.
00:43:26.530 - 00:43:31.470, Speaker A: We all are. Thank you for being vulnerable and sharing your entire desktop. That takes a lot of courage.
00:43:31.810 - 00:43:35.502, Speaker B: Yeah, I mean I have order all the documents here. Yeah.
00:43:35.556 - 00:43:43.618, Speaker A: But if you could maybe just make the vs code full screen or double click it so that it takes up. Yeah, that'll give us some more room to work with. Thank you.
00:43:43.704 - 00:44:10.810, Speaker B: Okay, here we are. So basically, as we said, we have well, before going into this, let me show you first the hashat config file. So here we are. So there are a few differences here. Let's go through them first. Here are the imports of our packages. First is the CKC deploy and it's the dependency.
00:44:13.150 - 00:44:40.578, Speaker A: One thing I like to do when we dig in is acknowledge prerequisites. If you're looking at things and are confused, it might be because you're not familiar with hard hat. And so if you want to know more about hard hat. We've been streaming it here. We do it on smart contract Tuesdays when we don't have a guest. Or you could go take a look at Patrick Collins course on Freecodecamp. It's an amazing course and it's one of these development environments to make it easy to write and test and deploy your smart contracts.
00:44:40.578 - 00:44:51.900, Speaker A: So that's what hard hat is. And where Antonio is starting is making some modifications to the hard hat config so that we can be working in this folder. All of this is for the sake of the smart contracts, not the front.
00:44:56.430 - 00:45:41.530, Speaker B: The project template is basically built on top of hardhat. Anything special required for CK sync is built on top of hardhat. So if you develop with hardhat, you basically know how to develop for CK sync. So this is one of the differences that you will see if you're familiar with Hardhat. Here we are importing new packages. One of them is the Ck sync deployed that is used to deploy smart contracts to the cksing network, and the other one is the compiler. Then here is the way we define the networks.
00:45:41.530 - 00:46:38.838, Speaker B: As I mentioned earlier, a layer two. It works with a layer one. So basically to define a network normally in hardhat you just have to put the URL of the network and that's it. For Ck sync as it is a layer two, you need two URLs. You need the URL of the layer one and the URL of the layer two. And basically here what we are doing is that if we are in test mode we are using local endpoints, but if we are not in test mode and we want to target the testnet, we are using this endpoint for the layer two and then we can just say use correctly for the layer one and it will pick default RPC endpoints from ethers. And then we are passing the Ck sync flag which basically tells hardhat that this is for CK sync.
00:46:38.838 - 00:47:33.600, Speaker B: So I have to use their compiler and their deployer, their deploy dependency to work with this network. Apart from that we have the Cksolk configuration and basically this is the compiler that generates the special bytecode that we need for Cksync. And here this is the minimal configuration that you need. We just pass in the version of the compiler and that it compiles from binary. There's nothing else that you need to know for that. Basically when you're going to compile the plugin will download the binary file with this person and it will compile the smart contracts for you. That's basically it.
00:47:33.600 - 00:48:26.080, Speaker B: Now as we said, we have the contracts and deploy folders in the contracts we have greeter contract, and this is the exact same contract that you get from ethers. Basically it's a contract that stores a message, greeting message. And basically when you deploy it, you are putting a message when you deploy the contract. And then it has two methods. The first one is greet that basically returns the message that is stored in the smart contract and then set greeting basically updates the message that is in the smart contract. Very simple contract, but it will be enough for us to deploy it and interact with it. That's basically it.
00:48:26.080 - 00:49:05.942, Speaker B: So I'm going to open a terminal down here. First thing that we need to do is to compile this contract. So to compile we just have to run hardhat compile. And this is the same compile job that you have to run. You run it, there it is, it's compiled. And if you are familiar with hardhat, you will expect an artifacts and a cache folder. We are ck sync.
00:49:05.942 - 00:49:45.894, Speaker B: So we have artifact CK and cache Ck because why not? Now this has some reasoning and it's because you can configure multiple networks here and you can configure some of them with CK sync. False. So basically you might want to compile the same projects for a normal EVM and for the CKVM. So basically when you compile targeting one CK sync, you will get your artifacts in this folder. If you want to compile for the EVM, you will get your artifacts in a different folder. So yeah, that's the reason. But what you get is exactly the same.
00:49:45.894 - 00:50:44.620, Speaker B: You get a JSON file here with the API. And here the API contains all the methods and basically everything that you need, the events of the context, everything that you need to interact with it from a front end or from a packet. And the bytecode actually is different. I mean it's random numbers and looks like random numbers and letters and things like that. But basically if you compile this for Ethereum and you compile it for CKBM and you put them side by side, you will see that the pipe code generated is different. So our contract is compiled. How do we deploy this contract? So again, the project comes with deployment script out of the box and we're just going to go through it.
00:50:44.620 - 00:51:41.386, Speaker B: Let me guide you. So first we are importing the wallet class from CK sync web three, and it's the exact wallet class that you will use with ethers by default. Let me show you how to initialize a wallet. You can use new wallet, passing the private key, that's it, and you get one. Then we are importing ethers because we are probably using it down here for something to just use it to format. How much is it going to cost to deploy the contract? Then we have our deployer class because this is the one that we need to actually deploy the contract. So I just realized that the first thing I need to do is set my private key in my environment file.
00:51:41.386 - 00:52:15.560, Speaker B: So this project comes with this file EMV example with wallet private key. And the idea is that you copy this file, rename it to just eMv. And here you can put your private key and let me copy it from somewhere. I don't want you guys to see.
00:52:17.710 - 00:52:18.554, Speaker A: It.
00:52:18.752 - 00:52:53.394, Speaker B: Well, you're seeing it. Don't worry, it's a development private key. Great screenshot. So once it's there, it will be loaded by this package that comes again included in the project. And basically we can initialize the wall. Sorry, it's not this one, it's this one. Okay, so if we don't have a private key set up, it will just throw an error and if not it will just go.
00:52:53.394 - 00:53:22.640, Speaker B: I will say, okay, running a script to deploy the grid contract. It will initialize the wallet using the private key. It will create a new deployer class using the Hardhat phantom environment. This is something same as with hardhat. And it will pass the wallet that we just created. It will load the grid contract from here. And we are going to deploy in with this message that just says hi there.
00:53:22.640 - 00:54:17.870, Speaker B: Before deploying it, what we are going to do is estimate how much it is going to cost to deploy this artifact with this message. And this is something very cool because before deploying it, you can see how much is it going to cost. And if you have enough funds that will work, but you can check if the funds that you have on CK sync are enough to actually deploy the contract or not. So this is just a check that you can do. This block that is commented is to, basically what it does is it checks how much is it going to cost and it will bridge tokens from quarterly testnet to CK sysing for you. As the wallet that I'm going to use, it already has tokens on CK sync is commented out. But basically this is what it does, as you can see.
00:54:17.870 - 00:55:26.610, Speaker B: Let me uncomment it for you. It does deployer CKC wallet deposit. It deposits to the same address, and it deploys the amount that it's going to cost to deploy multiplied by two, just in case. And then it waits for this deposit transaction to complete, which takes a minute or two as I don't need it, I will just leave it commented. So basically what we do is we just print how much is it going to cost to deploy the contract and then the deployer deploy again, passing the contract and the message, and then we print here some messages. So to deploy this script we will do John Hardhat deploy CK sync and we will pass the script file. So we will do the script and the name of the file, which is deploygreeters ts.
00:55:26.610 - 00:56:22.550, Speaker B: So what we're doing is we're telling hey man, use the deploy CKC package and run this script in particular and it will execute this. So if we run it, let's see if I can bring this. So it says okay, it's going to cost this much. These are the constructor arguments and we will use this now don't worry. And it says okay, the grid of contract was deployed to this address. So when you deploy a contract, the first thing you do is normally to check it on the Explorer. So again, if we go here to the explorer, let's do it bigger, we search it and there it is.
00:56:22.550 - 00:57:11.602, Speaker B: Our contract is here. So now if we come here to the contract, you say are you the owner of this contract? You can verify it. Verifying contracts is something that you will normally do and that's something that we're going to do. And you can do that here as well in the Explorer. And basically the information that you need is the contract address, the name of the contract, the compiler version and the solidity version, and obviously the code. So the contract name we said was committer and it comes from here, this one, then Ck salt version and solidity version. We can get these ones from the Ck sync from the hardhat config file.
00:57:11.602 - 00:58:04.630, Speaker B: So we are using CksOr version one, two, three and solidity 817. So Cksor version one, two, three, solidity 817. Then the solidity contract code, we can just copy paste it. And then the constructor arguments are this thing that we have printed here in the terminal because we are passing a message, if we pass a different message that these constructor arguments will change. So when we verify it, if everything goes well, come on. Okay, so now the contract is verified. So what happens once the contract is verified? So we can come here and now we can actually interact with a contract.
00:58:04.630 - 00:59:05.690, Speaker B: We can see the source code and we can see the bytecode that was the block, which is huge. So if we want to retrieve the message that is in the contract, we just query this and we see that the message is hide there, which is what we put here when we were going to deploy it now if we want to update the message, we can just pass something here. So hi guys, send it. And as this is our write transaction, we need to actually sign it. And this is the transaction has. So we open this. The transaction is already settled.
00:59:05.690 - 00:59:56.694, Speaker B: It takes like seconds to settle in CK sync. So that's one way to interact with the contracts. But what happens if you want to, how do you interact with the contracts from a script? I didn't include like a front end for this because I want to leave that for the front end Wednesdays I think it is. But how do you interact with smart contract from a script? Well, there is a script again for you. This one is the use width. And basically what it does is it imports the provider class from CKC, web three and ethers. Again, this one is loading the ABI from the artifact CK folder.
00:59:56.694 - 01:00:38.790, Speaker B: Because you need the ABI to interact with the contracts. It's creating the wallet as well from the private key and it needs the contract address where it was deployed. So we put the contract here. Now what is it doing? First it's saying okay, running a script to interact with this contract. Then it's initializing a provider using this URL from CK sync testnet that is here. So this is the RPC endpoint that you will use. It's initializing a provider and then it's initializing a signer using the wallet and the provider.
01:00:38.790 - 01:01:23.366, Speaker B: Then it creates a contract instance and it just passes the contract address, the contract ABI and the signal. Then it uses contract grid to print the current message. Then it updates it. So what can I say here? Let me find the name of someone that is online. Check 22 no hello back. Check is one of the users. And then it says contract set greeting and it passes the message and then it prints the transaction has.
01:01:23.366 - 01:02:20.538, Speaker B: If you are familiar with ease and ethers to interact with contracts, this should be pretty familiar for you. You are initializing a contract and just calling the methods and passing the parameters needed. So to run this script as it's also in the deploy script, in the deploy folder you will run jar and hardhat, deploy CK sync and we will pass the script will be use greeter. If we execute this, the current message is hi guys. Then it sends the transaction and then the message. Right after that it's reading the message again and it's the new one that we put. So here you can see that it took like half a second to send the update and retrieve the message.
01:02:20.538 - 01:02:24.426, Speaker B: And the transaction was already posted and.
01:02:24.448 - 01:02:26.710, Speaker A: We can see that over on the explorer?
01:02:26.870 - 01:03:07.990, Speaker B: Yeah, of course. So if we come to the explorer, here is the new message. And if we get the transaction has transaction to change. The message was this one. And if we search it, this is the transaction. And as you can see it's included, but it's still very fine. This means that the transaction has been processed on the two, but it's still in that process of building a patch, creating a zero knowledge proof, sending the proof to Ethereum and validating Ethereum.
01:03:07.990 - 01:04:13.866, Speaker B: Here is a transaction from an old block and this is how it will look once it has been verified completely, like we have the signal knowledge proof. It's been to Ethereum, it's been verified and it's been updated. You will see these two boxes and you will see the execution transaction has on the Ethereum explorer. So you will get all these details from the r one transactions as well. Okay, so this is one example, pretty basic one, and I think we are running a little late, so I'll just do one more and I want to show you that you can use any code from any contracts. And this one is the open sepling visa. And this is pretty cool because basically you can build different types of tokens.
01:04:13.866 - 01:04:40.470, Speaker B: You can build an ERC 20, an ERC 721, ERC 1155 governor contract, custom contracts, and basically you just check boxes here and it will change the code that you will get. So if you want an ERC 20 that is mintable, vulnerable, palsable, it's adding the extensions here and creating all the methods for you. And this is pretty good.
01:04:40.620 - 01:05:09.550, Speaker A: It's super cool. I have a limited amount. My first paid gig in web three was basically using the open Zeppelin wizard to help a client create a custom ERC 20. And over 80% of their requirements were checkboxes here on the wizard. And I was like, well these are battle tested by Openzeppen themselves, why would I create it from scratch? It felt like cheating on my homework. But the reality was it was just creating a more secure product on a faster timeline. So everyone was happy that a tool like this existed.
01:05:09.890 - 01:06:03.860, Speaker B: Yeah. So basically what we are going to do is just take this contract and you can just copy it, download it, do whatever you want. So we can just copy this one and come back here to our project and create a new contract and we can call it Ck token solve, we can paste here. And obviously this uses a lot of dependencies from open separate, so we need to install that dependency. This project uses Jan instead of NPM, which is a different package manager. But to install dependencies, it's pretty similar. You do jar add instead of install minus D because it's a development dependency and open circling contracts and that's added and that should fix this thing.
01:06:03.860 - 01:06:38.150, Speaker B: Okay, so I think I want to rename this to Ck token. Okay, so to deploy this. Smart. Oh, first let's compile it, obviously. So John, compile. Okay, there we are. So now here in contracts we should have the ck token Sol.
01:06:38.150 - 01:07:15.024, Speaker B: And again this one has the ABI with all the methods. And this is huge because it has all these plugins. So it has a lot of things. And at the end this will be like the bytecode. Okay, so to deploy this contract, create another script, call it deploy ERC 20 ts. And I'm not going to lie, I have it here.
01:07:15.142 - 01:07:26.790, Speaker A: You're a professional. Of course you do. Yeah, but you didn't do the thing where you do like the dollar sign and vs code and it like that's too much. That's where we draw the line.
01:07:28.200 - 01:08:02.716, Speaker B: Yeah, I don't know how to do that yet, but yeah, let's go through it. It's exactly the same. And the only thing that we are, oh this is not the one, sorry. This is deploy ESC 20. My bad. And it's pretty similar to the previous one where we were deploying the gritter contract. Basically in this one, again, loading the private key from the environment, creating the wallet.
01:08:02.716 - 01:08:38.030, Speaker B: And basically we're saying this, in this case, just load the Ck token artifact to this one and then it's going to estimate how much is it going to cost. And in this case we are not passing anything to the constructor. It will print to the console. It's going to cost this much. Again, this is the optional step to deposit funds on CK sync in case you haven't breached enough tokens. And then it will deploy it. Print the constructor arguments and print the contract address.
01:08:38.030 - 01:09:16.930, Speaker B: So to run this script, where are you? Deploy ERC 20 ts. So Jarhat, deploy Ck sync. That's that script. Deploy ERC 20. Running this is how much it's going to cost. Okay, so this is the token. And again we come to the explorer.
01:09:16.930 - 01:09:40.262, Speaker B: Should be here. There it is. And Eric 20 token. We can add it to our wallet. And I have done quite a few as you can see. So this is the token symbol and the decimals CKX. And I have 1233 tokens.
01:09:40.262 - 01:10:22.934, Speaker B: And that's the symbol CKX. And this is the amount of tokens that we minted when we deployed it. Let's do a final script to interact with the ERC 20 just to do some transfers. So use ERC 20 ts. And again I'm going to bring it. And here what we are going to do is first add the token address here. There is.
01:10:22.934 - 01:11:10.194, Speaker B: Then we are loading the contract artifact from the artifact ck we have here. And we need a destination wallet. So I think I have one somewhere. Let me take this other account. And basically what we are going to do is again we are going to initialize the contact with the token address, the AbI and our segmenter with the private key. And we are going to transfer twelve tokens from the original account to this new one account. And we are just going to print the balances of them.
01:11:10.194 - 01:11:52.662, Speaker B: Here is the transfer token. Contract, transfer. We'll print the balances again. And I will include this in the wallet just to see that we don't have any of them. Yeah, we have zero ckx. So if we run this script again with Ck sync deploy and in this case is use ESC 20 ts, we execute it. Right now.
01:11:52.662 - 01:12:23.090, Speaker B: The first account has 1233 and the second one has zero tokens. This is the transaction. And now this account has 1221 and this one has twelve. So this one there is now has twelve. And this is the transaction has that we can search in the. Wait a second. In the explorer.
01:12:23.090 - 01:12:51.374, Speaker B: There it is. And it's in progress. So I could show you more examples like how to do an ERC 721. That's one of the tasks of the workshop in general. Basically the idea is that people come here and deploy the gritter contract. Verify the gritter contract. Deploy an ERC 20 token and deploy an ERC 721 as well.
01:12:51.374 - 01:13:19.362, Speaker B: You complete all those tasks. All those tasks. And then you have to fork this repo. And in this deployments MD file you will just have to add your contract addresses at the end. Create a pull request. Once we merge it, you will be eligible to get a git block. So it's pretty simple.
01:13:19.362 - 01:14:00.034, Speaker B: Just deploy a few contracts, add them to the list, create the pull request and you're ready. And. And if you have any questions you can send me a message on Twitter and I will help you for sure. And just before we leave because I know we're running late. The main takeaways of this is basically layer two roll ups. They scale Ethereum by executing transactions of tame in a layer two. CK sync is a layer two that supports solidity and Viper, which is pretty cool.
01:14:00.034 - 01:14:23.158, Speaker B: Most of smart contracts will work out of the box. No change required. You will need to do minimal changes in deployment script and front end integrations. And we have other sdks. Our sdks are based on the most popular libraries. So the Javascript SDK is built on top of Ethers. The Python SDK is built on top of web three PY.
01:14:23.158 - 01:14:59.742, Speaker B: We have a go SDK, a Java SDK and a Swift SDK. So yeah, choose your flavor and next steps. Again, go to this repo, complete those tasks and get an sd. Now learn about optimistic versus zero knowledge roll ups. And I didn't include a link because there are like thousands of articles. So just Google that. Also read about EIP 4844 prototype starting.
01:14:59.742 - 01:15:20.426, Speaker B: That's an update for Ethereum that is coming in a few months and that will scale layer two like by ten x or 100 x. It's a big update for layer two. Oh no. Come on.
01:15:20.608 - 01:15:22.030, Speaker A: Hey, your slideshow.
01:15:23.330 - 01:15:26.638, Speaker B: Oh, what is going on? I click a link.
01:15:26.804 - 01:15:28.000, Speaker A: Oh I see.
01:15:28.610 - 01:15:29.486, Speaker B: Come on.
01:15:29.588 - 01:15:32.350, Speaker A: Try using right arrow instead of clicking.
01:15:33.810 - 01:16:01.420, Speaker B: It was going so well. So next up, learn about account extraction argent. They have a series of blog posts called what the fuck is account extraction? That are very good. It's a three part, so this is the first one. Then check our docs. This is the link. We have a lot of tutorials that you can follow.
01:16:01.420 - 01:16:51.814, Speaker B: We have an ecosystem page we will be launching on. So we are on main net. I haven't said that we are on main net, but it's closed Mainnet. Only us can use it because we are still running the audits, the security audits and doing the final updates. We will open the gates for the projects that have signed up for Mainnet on a couple of weeks. So that's when projects like Ave Uniswap, Nosis german finance we have more than 150 projects that will deploy on CK sync, but at that point only those projects will have access. So it will be open for projects to deploy but not for the users.
01:16:51.814 - 01:17:36.802, Speaker B: Yet a few weeks later, when everyone has deployed, we will open the gates for everyone. So basically people will be able to enjoy a layer two with hundreds of projects ready for them. Also join our discord, follow us on Twitter and just build awesome projects. That's all you have to do. And obviously we're going to be in Denver. We are one of the main sponsors of if Denver and we're going to do an extended version of this workshop. We're going to do another workshop about account extraction.
01:17:36.802 - 01:18:07.090, Speaker B: We have our developer day happening, the 1 March, which will have talks from a lot of different projects. I think we're going to be like 25 30 person from matterlabs are going to be in Denver and we're going to have a booth there. We're going to give swag to everyone. So yeah, we're going to be in Denver. Just come find us, ask us questions. And we're going to be sponsoring the hackathon. So build something on cksink as well.
01:18:07.090 - 01:18:11.620, Speaker B: And this is the latest one. Yeah, that's the last one.
01:18:14.150 - 01:18:17.826, Speaker A: I have so many things to say. First of all, are you done here? Is that like where we stopped?
01:18:17.858 - 01:18:18.680, Speaker B: Yeah, I'm done.
01:18:22.010 - 01:18:41.594, Speaker A: Truly. Thank you. I'm stoked. And I have a few notes. First of all, thank you for the clarity. I think this one's definitely worth a rewatch for any folks that joins us partway through and are interested in what you're hearing about Antonio. Really, you've done an amazing job, starting from square one and explaining what zks are.
01:18:41.594 - 01:18:56.254, Speaker A: And then we really got into the hands on part, which I appreciated making some time for because I know that folks like B. Shambaugh and beam me up now here, want to get in and try this with their own hands and even get a Gitpo app. Could you do me a favor, please, and go back a slide or two with all those links that'll help jog.
01:18:56.302 - 01:18:59.678, Speaker B: Oh, yeah. And we have the slides on the repo.
01:18:59.854 - 01:19:00.450, Speaker A: Oh, great.
01:19:00.520 - 01:19:04.466, Speaker B: So the slides are public. Look at that if you want to go through them. Yeah.
01:19:04.568 - 01:20:03.830, Speaker A: Would you? One thing I want to say is ZK sync is the backbone of the food truck wallets for this year. So for those of you attending east Denver who enjoy the fact that we give you free money in a web three way to go get actual food, which we do every year, we're doing it again, and it's all on ZK sync. So thank you in advance, Antonio and everyone else on the ZK sync team, making it possible for us all to enjoy delicious free food, especially for biddlers, we're calling it like biddlebucks. And so as people are working on their projects during the biddleathon, they can check in and accomplish these checkpoints, like creating a team, creating your project submission thing on our platform, submitting your code. And each of these checkpoints, we give you more Biddlebucks on zksync in your wallet so that you can go get more food. In other words, we're like, trying to keep you fed so you can keep bidling.
01:20:04.250 - 01:20:41.700, Speaker B: Yeah. And you have no idea what we've built because it's not like, yeah, you have an ERC 20 token and you spend it on the tracks. Is that the way we've built it? Using account extraction and paymasters? People will not need to pay transaction fees. Which is like, what? Yeah, there are zero transaction fees with CKC. We will do a workshop on Denver explaining exactly that project, what we built for Denver for the track experience. We will explain that, how that works.
01:20:43.190 - 01:21:34.222, Speaker A: Another note I'd like to make here is the third bullet point for folks that have never heard of Proto dank sharding. First of all, I'd like to say that's one of the funniest words I've ever heard. Proto Dank sharding is an insane term to come out of my mouth, and a prototype of it was developed and piloted at East Denver 2022. So it's exciting that one year later, Dang sharding is getting to its level of maturity as like an EIP that's going to be accepted soon. It's cool to see, just tooting our own horn, genuinely, that people have sick ideas at ETH Denver that go on to become, not know, winners of bounties or prizes, and then you go on with your life. These are actually the kinds of ideas that fundamentally change the infrastructure, even just one year later. That's pretty quick for something to get that much traction.
01:21:34.222 - 01:22:07.450, Speaker A: So that's cool. A little credit to proto e for developing that last year. And I had one more. Oh, yeah, I have a question for you. Okay, so I'll give you an analogy of something similar in the web three space. So as we transition to proof of stake, folks can stake their ETH and in exchange they get staked Eth. If you use, there's like a variety of ways to do it, but for the sake of the conversation, we'll just call it staked Eth.
01:22:07.450 - 01:22:50.810, Speaker A: And I've heard it said before, why wouldn't we just have 100% of all eth staked and then staked Eth becomes our new native currency. That way, all of the ETH is securing the network, but we can still have the liquidity of the staked ETH floating around and doing things like instead of wrapped ETH, we would just use staked ETH. Why not? And so in that same way of, like, I mean, yeah, if we all just chose to do that, then that would be great. And now we're all earning interest on our ETH and it's securing the network. There's almost no reason not to. In the same way, I'm hearing about how we're solving the scalability trilemma and I'm hearing about how easy it is for folks to make this transition. Like the learning curve is not that high and the benefits are just obvious.
01:22:50.810 - 01:23:15.750, Speaker A: If you've been listening closely to this presentation, why wouldn't we see what's the catch? Why would we not expect there to be a great migration of a lot of the stuff that's happening on Eth main net on the l one towards Zk sync as an l two. Is there any barrier or obstacle that we're seeing that would explain a delay or a reluctance to make that shift?
01:23:16.250 - 01:24:12.038, Speaker B: Yeah, I think the main one is that zero knowledge proofs their application in blockchain. It's a technology that is not very mature. It's pretty young. The only other CK rollout that is live on Mainnet is stagnet and they are not EVM compatible. You need to write smart contracts in Cairo, which is their own specific programming language. And they've only been on Mainet since November, October, I don't know, not more than a few months. So I think that that's the main thing, that the technology itself is so new that it's not been proved that much.
01:24:12.038 - 01:25:24.750, Speaker B: So that's why we are being very conscious with security and without it. But once it matures, we expect that most of the traffic that right now is happening on the layer one, it will move to the layer two. And yeah, basically once the technology is ready we expect that all the traffic, because it doesn't make sense that users will have to pay that much fees for a normal transaction. And when you add to the equation things like account extractions and improving the UX and when you use what we've built for it, temper for the fruit track and you will see that the technology allows application developers to pay for the transaction fees so they are completely free for the users. That improves the user experience so much that it will make sense that most of the applications will run on the layer two. And of course some things will still happen on the layer one, but we expect that the layer twos will gain mass adoption.
01:25:26.530 - 01:25:30.880, Speaker A: Okay. As confident in an answer as I expected, basically.
01:25:31.730 - 01:25:32.480, Speaker B: Cool.
01:25:32.850 - 01:26:33.394, Speaker A: I again just want to appreciate the clarity of this presentation. How much effort you and the rest of the ZK sync team have been putting in to your sdks, to your docs for ETH Denver to help people eat tacos at food trucks. There's a lot of work happening behind the scenes and I want to just acknowledge the sheer amount of effort it's taken to get us here and to try to make this level of adoption as easy as possible. I think you've optimized for developers, in other words, which is a huge choice and one that I wanted to acknowledge because we're a community of developers and biddlers of all kinds, technical and nontechnical. And so I really appreciate the way that this is approachable for such an advanced technology, for such a young technology. It's definitely the kind of thing somebody could learn after knowing a little bit about solidity or a little bit about hard hat. Like one hard hat tutorial would be enough for you to rewatch this and go start deploying your ERC 721 on Zksync Live on main net.
01:26:33.394 - 01:27:04.634, Speaker A: Once that's available in a few months, once you know you're fully open. Because why not? If you're going to want something with super cheap transaction fees or even free for the users, or if you want all kinds of defi composability, they're going to have yearn finance. You can do all the fancy stuff you want to do. When I think about biddlers, like getting together and making projects like, oh, I had an idea for this. Teams of two, teams of four, just trying stuff out. Zksync being EVM compatible and having a few other benefits you mentioned seems like a really strong choice. I mean, for folks that have been watching our streams.
01:27:04.634 - 01:27:26.040, Speaker A: I'm not so covertly in Eth Maxi, and so I appreciate what you're doing to help solve some of the very real problems we're seeing. Like you mentioned at the beginning, if it costs you $15 to send somebody $20, that's a huge problem. CK sync is a huge part of the solution and I'm excited for what the next few months look for.
01:27:26.570 - 01:28:07.390, Speaker B: Yeah, we're pretty excited because we are just about to open the doors and we have so many projects lined up and just waiting for us to just open the door for them and then a few weeks later open the doors for the users. And it's been crazy weeks for us. We're working so hard to release this and also to have everything ready for December as well. So it's a mix of things for us at the company right now, but we're super excited. Just hoping to be ready for Denver.
01:28:07.990 - 01:28:24.310, Speaker A: We're trying our best. Thank you again, Antonio. For folks that want to get in touch with you. You mentioned your Twitter handle, it's at fauno with a four instead of an a four u f four n o and then Zk sync. At zksync?
01:28:24.810 - 01:28:30.842, Speaker B: Yeah, at zksync. And don't fall for any scams. There are a lot of.
01:28:30.896 - 01:28:32.534, Speaker A: No zksync underline.
01:28:32.662 - 01:28:56.258, Speaker B: No underline Zk sync website zksync IO make sure that you are on the official website, the official portal. You're using the official links from our community. Any announcements on discord come from verified community managers or verified users? Lots of scams out there. Yeah.
01:28:56.264 - 01:28:57.458, Speaker A: You got to watch out.
01:28:57.624 - 01:28:58.930, Speaker B: Yeah. Be safe.
01:28:59.910 - 01:29:13.780, Speaker A: Okay. Thank you again for your time, Antonio. Folks, I encourage you to go check out the links that we've posted a few times here. Go try it out. Get your hands dirty. And if you have follow up questions, you know where to find them. I appreciate you, Antonio, and the rest of the team.
01:29:13.780 - 01:29:20.730, Speaker A: For now, help me send everyone off for the rest for their day. This is how we end all these, with a big bye.
01:29:21.470 - 01:29:23.610, Speaker B: Okay, bye.
01:29:24.670 - 01:29:26.870, Speaker A: Thank you. Bye.
