00:00:07.370 - 00:00:49.802, Speaker A: It's really great to see already a pretty good crowd here at E. Denver for only the first day. Happy to see that as a Colorado native. And specifically, I'm excited today to talk about Solana. So I guess for a little bit of context, kind of the point of the workshop or the talk today is going to be about kind of giving you an introduction to Salana and kind of building some initial understanding of everything that you need to know to kind of get started building on Salana. But before I kind of dive into the specific agenda for the next 20 minutes or so, as a quick introduction, my name is Ethan, although I go by the alias Tabasco, and I do developer relations at Particle network. I actually am not with the Solana foundation, because the Solana Foundation, I think, is flying in two or 3 hours from now.
00:00:49.802 - 00:01:27.810, Speaker A: So I'm filling in for them, but this is their presentation, so I'm just kind of the proxy for it, but really excited to kind of dive into these concepts today. I've been building between both EVM and Solana for almost three years now, and definitely when it comes to building on Solana, there's a lot of nuances that are important to understand, but it comes with a lot of benefits that we'll talk about in a moment. So, kind of what I want to go over today is going to be broken down into three main categories, three kind of sections. The first is that we're going to go through the technical advantages of Solana. So kind of the reason why people want to build in Solana, and the reason why the ecosystem is as large as it is today. Then we go through kind of the Solana programming model. So we're going to go through four core concepts, accounts, programs, transactions, and instructions.
00:01:27.810 - 00:02:08.434, Speaker A: These are like the sort of building blocks of understanding development on Solana. So we'll go through these and define each one, go through even how they're formatted architecturally and stuff like that. And then finally, we'll end it off with this kind of context that we build through the technical advantages and through the programming model to show you what actually the lifecycle of a transaction looks like. And if you're familiar with building on EVM, hopefully it should kind of give you an insight into what Solana actually looks like in the background, how it functions. So, first, what I want to do is talk about the technical advantages. I'm sure everybody here has probably heard about Salana before, and specifically, Salana is known for having high performance. So this includes, number one, very quick confirmation time.
00:02:08.434 - 00:02:36.366, Speaker A: So I believe it's about 400 milliseconds for a transaction to be processed, which is major. I mean, as a user, you can imagine sending a transaction or interacting with an application, and it basically confirming instantaneously. This is a really big component of Salana and why people enjoy building within the ecosystem because of this lightning quick transaction time. The second is that this transaction time doesn't come at the cost of high fees. Actually, the fees on Solana are very low, usually a hundredth of a cent, fraction of a penny. So this is another big component. Right.
00:02:36.366 - 00:03:10.610, Speaker A: As a user, you can imagine I work at a company that has user experience. So building applications where users can start doing large volumes of transactions, large sequences of transactions, where they're happening almost instantly and they're paying a very negligible amount of fees. This is a major component of why Solana is as popular as it is, and then kind of in achieving these. Another big part of Solana that you might find interesting is that programs which are basically contracts, we'll get into this in a moment. These are executed in parallel. So Salana has parallel execution. And all these benefits don't come at the cost, again, of decentralization.
00:03:10.610 - 00:04:03.798, Speaker A: Actually, Salana maintains, like, full ledger state. It broadcasts ledger entries to every validator on the network to, I believe, now, almost over 2000 across the world. So this is a major part of Salana get fast transaction times, low transaction fees, parallel execution, while, of course, having full broadcast of block propagation across the entire network. So what I want to do is we just went over, like, three quick, high level benefits of why Solana is as high performance as it is, and kind of the numbers attached to that. So how does this actually work? How does Salana achieve this performance? How is this 400 millisecond transaction confirmation possible? So I'm going to go through very quickly the high level overview of Salana and kind of how it works in terms of a transaction being processed. So, number one is that, like most proof of stake networks that you're probably familiar with, Salana elects a leader. So a voting consensus validator for processing transactions in a block.
00:04:03.798 - 00:04:43.346, Speaker A: So this leader receives all transactions. It then processes these transactions and packages them all into a block. Now, unlike Ethereum, Solana doesn't have mempool for pulling and processing transactions. Instead, Solana basically has every leader that's elected in the cycle already with a large batch of transactions that they can execute or process and then have in a block. So Solana has kind of this interesting cycle of it's a continual leadership election and then transactions are processed and packaged into blocks. And this happens very quickly. And as we'll get into a moment, like I mentioned, number one is that this allows for block propagation across every validator in the network through turbine.
00:04:43.346 - 00:05:30.738, Speaker A: So turbine, again, a little bit too technical for this potentially, but turbine is the block propagation protocol that Salana uses to over 2000 different validators. Now, like I mentioned earlier, a big part of the performance here, and kind of why this model is unique is for kind of two reasons. The first is that transactions are executed in parallel. So this is very important because, of course, it contributes to a lot of the performance I talked about a moment ago in terms of the quick transaction times and the low transaction fees. And it's also important, and we're going to get into this in a moment, but transactions are stateless. Essentially, transactions can kind of be defined as an array of instructions. These instructions basically tell different contracts or programs on the Solana network what to do and what to execute data to read data to write, et cetera.
00:05:30.738 - 00:06:10.190, Speaker A: And essentially, transactions and programs themselves, they don't contain a single state. Rather, programs and transactions interact with data within different accounts across the Solana network. And this will make more sense in a moment, once I get into the kind of account structure on Solana. So this parallel execution, this kind of mechanism of electing a leader and then processing transaction and packaging into blocks and then propagating it across the entire network, this can kind of be defined under this idea of proof of history. So this is a big part of, again, why Solana has the performance that it does. Now, I won't get into too much about proof of history. Essentially, it involves kind of like timestamping events on chain through a VDF.
00:06:10.190 - 00:07:07.140, Speaker A: But definitely, if you're interested in kind of understanding this consensus mechanism more, that's something to definitely look into. But these kind of collective innovations, proof of history, parallel execution, and again, like the core mechanism I just described, contribute significantly to why Solana can achieve kind of those previous core benefits I mentioned a moment ago. So some key takeaways from those few slides is that number one, transaction has fast confirmation times. Number two transaction, or Solana has very low transaction fees, usually hundredth of a cent, sometimes a little bit more. Solana executes transactions or programs in parallel. And of course, Solana is ideal for high performance applications. So whenever you're building maybe something that needs this performance for some reason, whether it's for a consumer facing application, where slow transaction times and expensive transaction fees can make or break your application, salon is a perfect case for this because, of course, these fees and processing times are extraordinarily low.
00:07:07.140 - 00:07:37.706, Speaker A: So now, within kind of the twelve minutes I have left, I want to go through two key concepts that are very important. The number one is we're going to go through kind of four major parts of building on Salana and kind of the building blocks of that. After that, we're going to go through the transaction lifecycle using this as context. So, Solana, there's kind of four concepts that are very important to understand. Number one is accounts. Number two is programs, which is a type of account we'll get into in a moment. And then we have transactions, which is a collection of instructions.
00:07:37.706 - 00:08:14.230, Speaker A: So these are kind of components of each other, and they all fit together very seamlessly. So number one is accounts. This is probably, if there's one thing that you take away from this talk when you're understanding Solana, this is one of the most important things. So everything on Solana is an account. This means that from the contract that you're executing, or as Solana calls it, a program, all the way down to data that you're storing, or even like the method that users use to interact with blockchain, this is all happening through different types of accounts. Accounts that are some executable, some are just for data storage, and some are actually for user level interaction. So all accounts are unique 256 bit addresses.
00:08:14.230 - 00:08:48.326, Speaker A: They all hold some balance of Sol, or kind of the smaller denomination of that, which is lamp ports. They can store arbitrary data. So we'll talk more about this as well. But accounts can store, for example, token balances or something that indicates data on chain. Now, this data storage, storing arbitrary data on chain, it's not free. Solan uses this concept of rent to kind of charge data storage on chain, kind of corresponding with the volume of data that you're storing on a given account. Now, with accounts, anybody can credit soul, anybody can send soul to an account, regardless of the type of account it is.
00:08:48.326 - 00:09:15.190, Speaker A: Anybody can read data from the account. So this is important to understand. From this, only the account's owner can actually debit Sol. So that spends Sol, make kind of state changes to the sole balance or modify data on the account itself. So, to give some additional context and maybe visualize this in a programmatic sense, accounts are basically made up of these kind of five key fields. The first is the key, which is the public address of the account. Then you have lamp ports.
00:09:15.190 - 00:09:59.866, Speaker A: Lamp ports, for those of you that are familiar with Ethereum, are kind of the equivalent of Wei. Or if you're a more bitcoin native, kind of like SATs. They're just a very small denomination of Sol. Data is basically a collection of data bytes stored in the account and is executable, is a boolean that basically determines, is this account a program or is it not a program. So, does it have code within the data that is executable, or is it just a normal account for data storage or for user level interaction? Then the owner is a public key, which actually is a program. So essentially, you have accounts that are owned by programs on Solana. For example, like a normal account that you might use for sending SOl to person, a that would be owned by the system program on Solana, or an SPL token could be owned by the.
00:09:59.866 - 00:10:32.690, Speaker A: There's like a specific program for that. So basically, accounts on Solana are owned by programs. So the owner parameter here is the program that has right access to the account. So, like I mentioned, SOl is a denomination, or lamport is a denomination of SOl, one SOl is 1 billion lamports. So, now that we understand the account structure on Solana, everything on Solana is an account from smart contracts or programs all the way down to user level interactions. Those are, of course, accounts, as you might be familiar with, and then even data storage. These are all accounts.
00:10:32.690 - 00:11:04.234, Speaker A: To draw a parallel here, like on EVM, usually you'll have two types of accounts, externally owned accounts and contract accounts. So there's usually a differentiation with what you might be used to. But on Solana, everything has this data standard of account. And programs are no different. So programs or smart contracts, as you might know them better, as are also accounts on Solana. So a special type of account that has executable code that works with other accounts to store data and execute different instructions. So the data stored within an account is EVPF bytecode.
00:11:04.234 - 00:11:31.266, Speaker A: This is a Berkeley packet filter. That's what that stands for. Programs are written in rust or C and C. So of course, Ethereum and EVM has solidity. Solana uses rust, which I'm sure many guys are a fan of. This is compiled to LLVM, and programs are stateless, kind of like we talked about. Same thing with transactions, everything on Solana, the program itself uses kind of the logic to then execute and do things on other accounts.
00:11:31.266 - 00:12:08.098, Speaker A: So, data storage accounts that maybe hold results or hold some sort of resulting logic that happens after the execution of a program, as well as, of course, with accounts that users might use. So, programs can basically read and write data to other accounts, like I just mentioned. And a big part of this is that it allows programs to be executed in parallel, like we talked about in the beginning. So basically, with programs, you must be the owner to modify them, and programs process instructions. So this is very important because, like I kind of alluded to originally, hopefully this is clear. In terms of on Solana, everything is an account. Transactions are basically collections of instructions.
00:12:08.098 - 00:12:48.998, Speaker A: These instructions are very simply things that we want programs to do or things that we want different accounts to do within programs. So programs must process instructions, things that call methods that are outlined within their code. Looks like some of this got cut off, but programs can also send instructions to other programs, which is CPI, which is cross program invocation. So from this, we talked about two very large concepts of Solana very quickly. Number one is that everything is an account. On Solana, from the user side to the actual data storage side, to the programmer smart contract side, everything is an account. All accounts hold sole or usually programmatically denominated in lamp ports.
00:12:48.998 - 00:13:24.022, Speaker A: Accounts can hold arbitrary data in the form of bytes. So this can be anything, usually working hand in hand with some sort of program to dictate what this data is and how it changes. Accounts can also store executable programs. So contracts basically written in rust, and accounts are passed into programs allowing for parallel execution. So now I want to go into kind of a more granular understanding of kind of the topics that we just looked at a high level. So number one is instructions. Like I mentioned, instructions are very simply just calls to the methods or calls to a specific program that allows you to execute logic on chain.
00:13:24.022 - 00:13:49.702, Speaker A: This is the way that you send data to the Solana blockchain. And we're going to get into a moment. They kind of have unique data structures where you have to list every count involved in a given instruction. And transactions are collections of these instructions so that you can then do complex things on Solana while retaining those core benefits, like parallel execution. So the instructions on Solana, this is kind of what they look like. Again, a programmatic example of what the fields of an instruction are. Number one is the program ID.
00:13:49.702 - 00:14:20.970, Speaker A: This refers to the program that the instruction is targeting. Number two is an array. This array basically refers to every count that's involved in every step of the process with actually executing a given instruction. And of course, this contributes pretty significantly to the performance of Solana as well, and it contributes to parallel execution in that sense. I think my slide is broken. There we go. And data is basically specific instruction discriminator, plus the actual arguments for the instruction that you want to execute.
00:14:20.970 - 00:14:50.690, Speaker A: So this is the idea. Instructions are just calls to different programs. These are usually bundled in transactions, which is an etiquete on chain. And this is how you do things on Solana. Now, Solana and transactions, like I've talked about a little bit, basically contain one or more transactions, one or more instructions. Sorry about that. These instructions are executed atomically and essentially, like you might be familiar with most blockchains, is that these transactions require a small fee to be paid to transmit them to the rest of the blockchain.
00:14:50.690 - 00:15:32.450, Speaker A: This fee is quite low on Solana, and transactions must be signed by one signer. So the transaction needs to be signed by an account, just like you might be familiar with within EVM environments. So, transactions, this is, again, another programmatic example of what a transaction structure looks like. Number one is that transactions contain an array or a list of instructions, so things that are dictating what you want to execute within different programs. You also have to include the recent block hashes used for deduplication, and again, can contribute to efficiency and security. You also have the fee pair, which is a public key that determines who's paying the gas fee of this transaction. And finally, you have the signers parameter, which dictates basically the signed versions of this transaction.
00:15:32.450 - 00:16:23.650, Speaker A: So this is, again, what I alluded to a moment ago, which is needing to sign transactions before they can be executed on chain, just like you're used to already. So some takeaways from that data is stored in accounts, including programs, which, again, everything is an account. Programs are invoked by instructions, instructions are sent via transactions, and transactions are atomic and must be signed. So hopefully, this kind of idea or this visualization is kind of becoming clear about the architecture of Solanas. You have this really high performance that is coming from this kind of unique architecture around stateless program, stateless transactions, and of course, having this universal kind of generalized data standard of accounts across the entire network. So now to end it off here, within the next three minutes or so, we're going to go through the lifecycle of a transaction. So from the point where you interact with Jupiter or something of this nature, and then you actually execute a transaction, then it gets completed on chain.
00:16:23.650 - 00:17:11.302, Speaker A: What happens within that process? So, to illustrate this, we're going to go through an example. We're going to basically say, let's say we've deployed a counter program. So something that whenever you call an instruction on this program, it kind of increments a single numeric value on chain. So what this would look like is that number one on the client side, which refers to this decentralized application or some sort of website that is initiating this transaction, that's constructing this transaction. Basically, you perform it, it sends us to an RPC client. So an RPC node. This RPC then takes it to voting validators, which then basically, kind of like we went through originally in terms of that initial process that we talked about, eventually executes the instruction for the program, which increments the count on the counter account.
00:17:11.302 - 00:17:51.054, Speaker A: So what I want to highlight here is that in this example of we're creating a counter program, all we want to do is increment a number on chain. The actual number that's being incremented is not on the program itself, but rather it's on a counter account that stores the data that's resulting from the execution of this program. So again, this refers back to the idea that everything on Solana is an account and kind of data is stored within their own accounts, programs are stored within their own accounts, and so on. So some takeaways from that. The client applications take transactions usually constructed in tandem with the user, send that to an RPC client. The RPC client then sends these transactions to the network. Validators then execute these transactions, which invoke programs via instructions.
00:17:51.054 - 00:18:28.058, Speaker A: And then, of course, programs update account state as a result. So this is, I have about a minute, 50 left. This is kind of the introduction or the high level overview of Salana's architecture. So it is a really cool paradigm that Salana is building here in terms of, you have this very unique kind of architectural makeup that sets the stage for major, major innovations when it comes to, again, performance, transaction fees, et cetera. So this is kind of the major benefits of using Salana. Now, Salana foundation is actually here believe they're going to have four or five team members here throughout the few weeks of eventor. I believe their devil should be here in three or 4 hours at this venue.
00:18:28.058 - 00:19:10.074, Speaker A: So if you guys want to keep a lookout for him, but definitely take a look at this QR code. This is the Ethereum to Salana development course. So over the past 1520 minutes, I've talked a little bit about some parallels between Salana and Ethereum and the concepts that kind of overlap a little bit, like programs and smart contracts and so on. So rare skills is actually launching, and they've launched an Ethereum to Salana development course that I definitely recommend you take a look at. If you are interested in kind of learning the process of building on Solana and making that transition or kind of expanding your skill set to this kind of slightly different environment. And of course, Solana is also doing a few different bounties. I believe they're doing four one is for the best custom token integration, best Solana Integrated game, best Solana Defi slash payments integration, and best Solana social app.
00:19:10.074 - 00:19:29.102, Speaker A: So a lot of cool bounties to participate for as well. Gives you a good incentive to maybe try to pick up Solana and build something cool. Take advantage of that high performance over the next few weeks and submit your project to their different bounties. So thank you. That's about it. About 20 seconds left. If you want to ask questions about Salana, learn more about Salana the Salana ecosystem is amazing.
00:19:29.102 - 00:19:47.380, Speaker A: I've been a part of it for a long time, and their developer base is always more than eager to help you. Definitely head over to Salana Stack Exchange, follow Solana underscore devs on Twitter, and check out this QR code for more developer resources. In terms of learning about Solana, diving into the ecosystem and potentially building an application for yourself, that's about it. Thanks guys.
