00:00:12.090 - 00:00:40.466, Speaker A: Okay, we're going to begin, maybe. Does anyone have test RPC 4.0.1? That's how much free space you have. Don't. Okay, cool. If you don't, luckily this is going to be more of like me doing a presentation for 30 minutes. We're going to talk like we're going to talk about things and then the rest of the time is going to be just free time hacking.
00:00:40.466 - 00:01:10.814, Speaker A: And I'll be walking around and mic can help you out. But it's mostly just like educational because this whole slide code. Slide code is a little difficult of the format. If you do want to follow along and like code as we go, you should either way, pull this GitHub from cmditch if you want to type all this in. Or just go to my GitHub and get Hodlbox. Or Hodlbox. We'll call it Hodl.
00:01:10.814 - 00:02:12.310, Speaker A: Does everyone know what hodling is? Okay, hodling is a meme because somebody misspelled hold when the price of bitcoin was crashing and he was trying to say hold tight and he just spelled Hodl instead. So now hodl is like just this universal meme for like, hold on. The prices are so crazy in cryptocurrency. So get my hold box and we can get together. Yeah, smart contract 101, which Mike Pratt over there started out with us on. We went over solidity and like the basic syntax and how to compile, how to use truffle, which is a develop DAP development tool or framework. Well, today I'm going to more touch on maybe a little more advanced solidity and how to interface that with JavaScript and HTML in the web and make user interfaces.
00:02:12.310 - 00:02:53.042, Speaker A: So the platonic ideal of a good app is good code and a good user interface, good back end, good front end, and you have good app and good testing. I didn't mention that. That's boring. But it's really important. So good code. I'm not going to go into all the design patterns, but one of the most important ones is separating your logic so you don't get something like this. And your functions are all like touching each other and groping one another.
00:02:53.042 - 00:03:49.122, Speaker A: And it's very state gets very dirty and we refer to this as spaghetti code. Don't do that. I'll try to show you how not to do that. So how many of you heard of MVC or model view controller? So it's like a basic, there's a lot of MVCs out there. You have your model, which is your data or your state, your view, which is the user interface and the controller, which is kind of the application logic, which intermediates between the state and the field. So in my hoddle box, which I'll explain you, what the hoddle box does is you just put ETH in and you tell it how long you want it to hoddle for in terms of blocks. And I'll show you in a minute live, and it will lock your ETH in this contract and you won't be able to withdraw until a certain block is reached.
00:03:49.122 - 00:05:08.880, Speaker A: So it's just a way to force yourself to, it's like a bomb that has no interest rate, and if the price of ETH crashes then you have a negative interest rate. So this state, I guess true here, is looking at the GitHub repository or the code SSD. Okay, so in the JavaScript file you'll see kind of like more or less towards the bottom there's an object called app state or Window app state, and this is my model, and I'm just like putting very rudimentary type like, okay, contract address is going to be a string, the balance is going to be an integer, and whatever this contract is will be an object. But I haven't, these are all just like since JavaScript doesn't really have types. Lovely. Since it doesn't have strong typing, I just am like loosely or weakly defining what the types are here, and the reader will have to infer that's too dark. It's quite dark, but it does, I mean, people have it on their screens too.
00:05:08.880 - 00:05:50.330, Speaker A: So like the contract is going to be an object. When I define the contract later in the code, it's going to be applied to this app state, object contract. The controller or the functions or the logic is in another object, which is at the very top of the JavaScript file called app logic. And here we just have a bunch of functions. This is where you prevent spaghetti code. You want to have not really small functions, but definitely not large functions. And I'm not like a super Uber coder and I hack this workshop up fairly quickly.
00:05:50.330 - 00:06:35.190, Speaker A: So if my code sucks, just like throw tomatoes in stuff and let me know what I should have done better. But yeah, like oh yeah, I'm going to validate my form, I'll make a function for that, that's all it's going to do. And then I'll have like when I hit my button it will do the submit form, and when I first start my application I'll do the start app function. So you're like separating all these so you don't have like a giant procedural, just like mess of just one after the other. You just have these nice little black boxes of functions. And other things you can have are like utility logic which don't necessarily belong in the app state controller. It's your choice, but it's arbitrary.
00:06:35.190 - 00:07:36.302, Speaker A: Whether or not I have some utility, it's not actually in an object in my file, but I just have some basic functions which do things like show errors and log errors. And lastly I have a contract object which actually has the ADI or the application binary interface which lets web3 Js know how to interact with the contract, because otherwise the contract is binary. I mean it's hex decimal, but it's binary. It doesn't know how to, doesn't know what binary part matches up with a human readable name. That is the function name in solidity. So my function that you get your money out of the hoddle box is called release the hoddle, like release the Kraken and reference there. Ha, release the hoddle is just hexadecimal in the bytecode, it's like hidden in there.
00:07:36.302 - 00:08:21.406, Speaker A: So the ABI helps tell web3 Js, so you can actually type in the JavaScript like Mycontract, release the hoddle. And that's what the ABI is doing for you. The constructor is another part of a smart contract which we went over last week, but it's like the values that you put in on the very beginning of the contract during its creation. So in this case, the argument that we're passing when we create the contract is the amount of hoddling time, the amount of blocks we want to hold for. And you can see that if you look in the contracts folder, you can see the hoddlebox solidity contract, and you can see there's a function named capital H. Hoddlebox. That's your constructor function.
00:08:21.406 - 00:09:07.740, Speaker A: It's got to be the same name as the contract, and that's where we pass in the amount of blocks. I don't think I have the constructor as a part of my contract object in the JavaScript file, because that's something defined in form of the user interface. All right, so that's some code stuff. Now, designing things, we should all really strive to have beautiful interfaces, always. So this website is great, one of the most pleasant websites ever. It's probably given someone an epileptic seizure at one point. This form is amazing.
00:09:07.740 - 00:09:50.326, Speaker A: Anyone with like seven PhDs might know how to fill that out. The rest of them are just smashing their head against the wall. This is actually a beautiful form here. You'll have a chance to get my credit card number, just make sure you buy it or send it to my house if you want to buy something. But anyhow, that's quite a nice form for many reasons. That was an early revision of the hoddlebox. I redid some things like there's just too much noise going on here.
00:09:50.326 - 00:10:52.646, Speaker A: I mean, I'm not going to get into like a UX spiel right now, but I just think it's really important. So you'll see, I'll show you right now what the actual final hobble blocks looks like. So this is it right now. It's live at Cmditch, GitHub IO CallBox. And the first thing you see when you open it, and actually I'll paste that in this slack as well, just in case. So the first thing that nice little UI feature is, it's like, oh, where's the blockchain? Your RPC is not found, unfortunately, it only stays up for a few seconds because of how to program it. So that's not the UI you need to allow scripts in.
00:10:52.646 - 00:11:41.564, Speaker A: So if you're running chrome, it might be that you need to. There's a little shield up here. First you have to start test RPC. I will do that here. Yeah, just run it locally by opening the index file. What's that? You could just open it locally by running opening the index file in chrome. For web free or for test RPC? Yeah, regardless, it doesn't matter.
00:11:41.564 - 00:12:15.768, Speaker A: See, that's the cool thing is it's like a stack application and it's just HTML JavaScript. There's no interaction with any servers except for the blockchain. And since I don't have test RPC running, which is my blockchain, it's failing right now. So if I go in here, I'm going to say test RPC. And one thing we have to do for this app is say B, and we'll just say five, which means give it a five second block timer. Otherwise test RPC is just immediate. In order for this app to do its magic, you need to give it a block time.
00:12:15.768 - 00:12:50.870, Speaker A: Oops. And because I already have. Yeah, that's fine. So then I'll reload this page and we should see my ebounce go up and the error. And I need to disable metamask as well, so pardon me, extension. Yeah, that's another thing that got you. Metamask is kind of interesting to work with and test RPC.
00:12:50.870 - 00:13:28.942, Speaker A: Oh, lovely. So this is the part where my, oh, no, here it is. Here's the shield part. Okay, cool. I'm getting hung up on what I already know. So this is saying, oh, I can't connect to this, it's dangerous. GitHub is HTPs, but you're trying to connect to test RPC because it's not HTTPs.
00:13:28.942 - 00:14:09.570, Speaker A: So that's what this little shield up here is for. This will be useful if you're like developing locally and you're putting your stuff up on a secure site that you're trying to connect to test RPC, which is not technically secure. So then I'll say, load more scripts and then bam, it works. Now it's seeing my needs and everything's kosher. Has anyone who's trying this having issues currently or needs any assistance or. Everyone is perfect. Okay, great, I stole your deposit method.
00:14:09.570 - 00:14:45.146, Speaker A: Okay, cool. So another thing about this form is like there's form validation. Oh, the form's not filled out. That's good feedback, that's good Ui. There's zero values. Maybe we don't want zero values. The thing about the blockchain that's different from normal web programming is you can have your front end form validation and then in a normal web application you would also do validation on the server, just to be sure so you don't put weird data in your database.
00:14:45.146 - 00:15:13.860, Speaker A: If someone wants to bypass your user interface. You can't really do that with blockchain. So all your validation has to occur on the front end. Be very strong and adamant and scrupulous about that. So that's the difference. I'm going to put 42 E in for five blocks. That's another good ux is a little loading thing.
00:15:13.860 - 00:15:50.762, Speaker A: Here's my transaction went through and then I get a response and Mr. Hodor is hodling hard and I get a block count. Oh yeah, you can almost de hoddle. This is actually getting pulled from the chain. It's not just me manipulating text. So if I go and open a new tab, oh, there's the shield, black of the shield again. Boom, there's, there's the 58.
00:15:50.762 - 00:16:42.974, Speaker A: So 42 of it is indeed holed up. And then I will, when the locks were counting down. Yeah. What was causing that? I have a set interval JavaScript function that calls a function on my contract and it's a free call because you don't need gas to get this data because you're not changing state on the blockchain, you're just reading from it. And so that function is called like hoddling, remaining hoddling or something like that. It's in the solidity contract, you'll see it as one of the functions in the app object as well. So I'm just calling on an interval every like 2 seconds to get that data and then updating the UI accordingly.
00:16:42.974 - 00:17:10.082, Speaker A: So it's basically just counting down. There's not something happening on the blockchain that's causing it to decrement. No, it is. Well, I mean, other than the fact that the blockchain creates new blocks every 14 seconds, or in my case, every 5 seconds. I mean, that's just the thing. And it's going to do that no matter what, regardless of my app. But I'm using that because I'm setting like, all right, I don't want to release the hoddle anytime before this 7,000,000th block.
00:17:10.082 - 00:17:48.962, Speaker A: And so I'll be like, all right, in my check hoddling time left function gets like whatever your block is, minus the current block number, and then it returns that number in there. And then when everything's kosher, I change the UI. When that value becomes zero, I say, okay, cool ui. Put this, release the hoddle button in there that points to another function that then fires off a web3 function that indeed releases the hoddle more pending loading. Cool. Spinnery infinity Ui. Goodness.
00:17:48.962 - 00:18:20.590, Speaker A: And then. Happy hodor. Good to go. Everything seems to be using Coinbase instead of just the test RPC addresses. Yeah, so Coinbase is your default. Coinbase is not the company. The company got their name from this thing that blockchains use called the Coinbase, which is your default wallet, essentially, or the wallet that's like unlocked.
00:18:20.590 - 00:18:51.594, Speaker A: And in the case of test RPC, the default Coinbase is like, if count zero, they're all unlocked. Yeah. So, like if we type here in the console, web3 e accounts and this first account, and then I also type web3 e coinbase. You probably can't read that. Zero XD eight. Done. 50 x.
00:18:51.594 - 00:19:16.434, Speaker A: We're just not using it. We could say web3 accounts, seven, but we're just using Coinbase, probably metamask. That's relevant to developing metamask. This works with metamask on the main chain. Use it at your own risk. I don't know if there's any crazy dow bugs in there. I don't think so.
00:19:16.434 - 00:20:00.480, Speaker A: It's quite a simple contract. All right, web3 gotchas. So we're dealing with a whole new programming environment unlike anything we've seen before, except unless you work in banking with a 14.4K connection, we're dealing with something that has a lot of value and that has a lot of latency. In the case of bitcoin, like ten to 60 minutes latency. In the case of Ethereum, ten to 22nd latency. So that creates a lot of interesting problems for user experience.
00:20:00.480 - 00:21:02.580, Speaker A: That's why I use loading spinners and pending and people are going to be waiting around until this speeds up and this technology gets better. So the high latency, yeah, like I just said, spinners and just letting the user know the high value, that's where form validation becomes very important. And checking, lots of checking, like when I was checking to see how much hoddling time was left. But in the case of value, you could conceivably have a transaction that gets blasted out to the network and it just fails. Like in Ethereum, you can get this out of gas error thing and there's no response. In web3 that I know of that lets you know that you got this out of gas error. Correct me if I'm, correct me if anyone else.
00:21:02.580 - 00:22:13.914, Speaker A: Okay, so what you do get right away is a transaction ID, which is like the hash and all based on whatever transaction you're making, but you then have to checking or confirmation modules. That's what brings me to this slide. So you get a transaction hash back when I make my hoddle box and I do that transaction and it gives me a transaction ID. And then in the JavaScript further, you have to maybe have a set interval function which every 1 second does web3 get transaction receipts, which is a pretty important function in web3. And then you would type in the transaction hash or transaction ID in there and you'll get this object back. Either you'll get no object back, which means it failed for sure, or it won't have a contract address. That probably means it failed, or the block just hasn't been confirmed.
00:22:13.914 - 00:23:04.910, Speaker A: But an interesting little hack that I saw someone mention in the Ethereum docs is like if the gas you sent into the contract, which you know because you define that in your code, you can see it in my JavaScript file on that right below the start app function. There's like the deploy contract function in it, and I define the gas amount, I think it's like 2 million or something. So there's no way I'm going to run out. But if the gas that you sent in was the same amount of gas used, you'll see a gas used field in this transaction receipt object. It probably means that it failed, it ran out of gas, which is not 100% sure. Check. It's kind of hacky but that's just something to know you can use.
00:23:04.910 - 00:23:31.974, Speaker A: And it's, Mike, do you have anything to. It's super hacky, but I know what you're saying. It's definitely not user friendly. Like when something fails, you have to know what to look for. But I don't remember specifically what it was. Yeah, the reason why is you're almost always sending more gas than it's going to use, just in case. And then you'll get returned back to you whatever you don't use.
00:23:31.974 - 00:25:18.634, Speaker A: So just send more. The likelihood of it using the exact amount of gas that you sent is probably low. So just remember that as like a tool because as it stands, you don't get messages thrown back at you when something fails. And for a good reason, because you could dos the network, you could just send one gas transactions and the nodes would have to work them and then they would have to be sending all these clients a bunch of messages. And okay, if you open up the hoddlebox contract, we're going to do a little bit of like just a small amount of line by line to talk about some of the, some of the things that are occurring here. So on line 17 and 25, actually, I'll bring up the code in here's it. Much bigger it value.
00:25:18.634 - 00:25:51.662, Speaker A: All right, payable functions. This is like, well, this used to not exist, but now you have to define if you're going to be sending east into a function. You need to put this payable modifier in there like a native word in solidity. Who knows what those are called? That was the wrong way to put it, a native word. Reserve word. Yeah, reserve. Yeah, like you int or events.
00:25:51.662 - 00:26:54.450, Speaker A: These are things that you can't call your function event or you can't call a variable authorization. So lines 18 and 32 here I'm setting whoever makes the contract is now the hodler. And then on line 32, if I want to release it, I'm saying, hey, if you're not, what was defined as hobbler when this contract was made. If the person interacting with this contract is not the person who created the contract, then throw an error and they don't allow this function to go through ledger light. So it's just like this hobbling variable is just like a little micro ledger within the contract. So this is how all tokens work on Ethereum. They're just like little mini ledgers inside of a contract.
00:26:54.450 - 00:27:39.480, Speaker A: And you're like updating integers in contracts. Kind of interesting. It's that simple. So this is just a number and it's kind of my one number ledger. And I'm saying whatever ether was sent into the contract during its creation, well that's what my number is. And then if I want to deposit more ether into that, then I'll just like later on, then I can up that number there and then at the very end I'm going to make that zero, which actually isn't necessary because of the way I change the code and use the struct function. We'll get into that.
00:27:39.480 - 00:29:05.026, Speaker A: Before I move on from that, this idea of using the internal state, maybe that micro ledger ledger like concept can, if you go look at token contracts like the ERC 20 token contract, it's really that simple. They just have like a map record saying like oh, this address has this many tokens and they just have a whole list of addresses and integers that tell, that are stored in the contract saying how many tokens they have. And then there's other functions in that contract are like oh, if I want to transfer tokens then it's just going to call some function that decrements that person's amount of tokens. So that person's integer or tokens they hold to a new address or an existing addresses integer in that record. That's like all it is. Who here is programmed in Ruby? Like a hash in Ruby, your address is the key and the money held as the value pros are really used quite often, as we can see, especially on this one. So it's like the whole logic of the app.
00:29:05.026 - 00:29:40.490, Speaker A: The hodling part is right here. If the block number is less than whatever the hoddle block number is, then just don't allow that contract to be called. All right, who here is familiar? Oh, sorry. So when you throw, it ends the current transaction and I think it also consumes all the gas. It's kind of like a punishment to the caller. Okay. Not sort of disincentivized otherwise it's another like DoS vector, potentially denial service vector.
00:29:40.490 - 00:30:47.266, Speaker A: Who here is familiar with events? This is like a very important. So events in solidity are in Ethereum are these things I define up here. And using web3, you can watch for an event. So if I want that and then watch I'm them. So here we have, this is within my app state I have my contract which is just called the deployed hoddlebox. Deployed, which is like that particular contract because you can have a million hoddleboxes, but you need to define which one you want to interact with at a particular address. And it's stored in this.
00:30:47.266 - 00:31:55.914, Speaker A: And then because of the ABI, I can then have all these functions, and one of them is this event, which is called hoddle released. And I assign the hoddle released, and I'm looking for this particular value that's coming from that event, and only if it's true. So only if it's true, then you run this function called dot watch on it, and it's like a callback function. So the minute the blockchain emits that data and then that value that I'm looking for here is released. If it's false, which it can never be in my contract, this watch event won't fire off, but if it is true, it will fire off and then do all this app logic. So the way that's implemented in solidity is you just define the event and then what things are like, what values are in that event. In this case, it's just a boolean.
00:31:55.914 - 00:32:36.202, Speaker A: Sometimes you'll have events like you'll have something that's an address, like an account, or in a value, and they'll have multiple things and you can index the events to make the calls go a little bit faster. And then at the bottom, when I do the release the hoddle, there it is. That's how you send an event out. You just have the event name and then it could be false. That's in there. If I put false in there and recompiled it and ran my code, my UI would not update because it's only looking for true events. Does anyone have any questions on events? They're quite important for UI work.
00:32:36.202 - 00:33:30.080, Speaker A: I can't seem to get them to call from tests. Okay, always says no events registered. I'll have to look into that more and maybe we can chat on slack and figure out what's going on there. Stupid question, but I'm a back end guy. That is really a stupid question. Okay, anyway, long story short, just a quick console log, you use that for debug? Because I read today that there was some kind of callback mechanism that I shouldn't become familiar with when it comes to logging and debugging. Debugging? So you're saying don't use, you shouldn't? No, I'm asking should I? I don't know, JavaScript, you can do console logs, don't know what it is.
00:33:30.080 - 00:34:13.420, Speaker A: The only way you know what's going on in your contract at all. Yeah, console logging is very useful for debugging also, another thing I'll do is fire up, I'll open a new terminal. I mean, you can work in the console and use web3. Or you can just open up a terminal, open node, import web3, and just work in that node terminal. It's no different than working in the browser console. And then I'll interact directly with web3 eats, get transaction receipt, and I'll debug it that way too. So you kind of have to log things, but you also have to interact with it to be sure that things occurred as well.
00:34:13.420 - 00:34:47.000, Speaker A: Console log is the best friend. There was another question about events. Maybe I'm not going to really go over a lot right now, but another thing about events is there's this indexable thing. So my event is really simple. It's just a boolean. But oftentimes you'll see events that are saying, let's say you have a decentralized exchange like Ether Delta. Has anyone here used ether delta? It's super cool.
00:34:47.000 - 00:35:45.114, Speaker A: The event will be like, let's say you open up your ether delta and the watch event is only going to watch for events that happen under your metamask address. And so there's going to be tons of events happening on ether delta because it's an exchange, but it's only going to fire off. Like when you do watch, it's only going to do events that match your address. So that's a really handy way to my hobble box. You're the only one interacting with it. But if you have an application that tons of people are interacting with, you need a way to filter those events. And that's where these things you're going to have many things you're passing to an event, like an address, amount, a block time, blah, blah, a ton of things.
00:35:45.114 - 00:36:09.970, Speaker A: And then on the client side, you can filter specifically or you can not filter at all. You can just wash all of those. So is the line you have highlighted there setting that event to true, or is it throwing the boolean true value through throwing true. So right after I could put hollow release false and it would throw both. Okay. Yeah. And that's why you can kind of reuse the same contract and you don't have to reset it.
00:36:09.970 - 00:36:45.520, Speaker A: Exactly. Yeah. Constants are like things that don't change the state so you don't have to send gas and do all the crazy consensus that the blockchain does because you're just reading from the blockchain and anyone can download the blockchain. So constants are free. And here, that's where we have these functions. Like, my total countdown is a constant because it's just reading. There's no blockchain state mutation, just like doing a little bit of math and then returning the hollow count.
00:36:45.520 - 00:37:20.154, Speaker A: They're pure functions. If anyone here is into functional programming, that word gets me real aroused. Arousal is almost never bad. Um, self destruct. Self destruct, where are you at? Okay, self destruct. I used to have like a quirky logic in here that decremented the hope, the hodling. It set a variable to some weird stuff.
00:37:20.154 - 00:38:07.526, Speaker A: Basically prevented the dow. What the problem with the dow hack was, was they sent the money and then updated the balance in the local contract state. You need to do it the other way around. You need to update the balance and then send the money. Because of how contract interactions, like if you send money to someone, they can have a function that when they receive money, then calls back to the contract and calls the same function and just puts it in a loop. And if you don't have any logic saying, hey, look, if your balance is zero, then I won't allow you to withdraw anymore. Well, if you don't update the balance until after the send transaction, you can get this reenterency bug, which is how the Dow failed.
00:38:07.526 - 00:38:48.290, Speaker A: So instead of having all that logic ahead previously in here, I actually use this self destruct thing that's very important to the blockchain and solidity keyword. And then the argument you pass into self destruct is any ether that's in the contract is going to be returned to this person. So if there's no ether, then whatever. But that's a required thing because you don't know whether or not a contract is going to have ether. And you can't just blow up contract and destroy ether. It has to go somewhere. The benefit of destructing a contract is it saves the, there's kind of like two states more or less in Ethereum.
00:38:48.290 - 00:39:35.734, Speaker A: There's the entire blockchain state, the entire history, and then there's the working, important working state, because all kinds of stuff could happen in history, but things are changing and things are changing, and now you have the most important state that you're reading from and manipulating. This is where state tree pruning comes in. You might hear that talked about. So self destruct is healthy for the blockchain, and everyone should clean up after themselves, and that's how you clean up after yourself in blockchain. Otherwise you could just have a bunch of stagnant state on the chain, and it's just not good for the. I think there's economic incentives to using this too. I'm still looking into that.
00:39:35.734 - 00:40:21.750, Speaker A: But there should be an incentive to clean up after yourself, basically. It used to be called suicide as well. If anyone's wondering what does that do? So it destroys your contract once it's executed. It basically tells all the nodes that you don't need to hold this contract in your memory. Like maybe if you're a node and you're caching a bunch of the state in your memory, well it's going to tell that node like yeah, no one's ever going to work with this contract again, so you don't have to put that in your memory. Or it tells the light clients or the state pruning clients that they don't even have to download that contract when they initialize blockchain. That specific instance of the contract.
00:40:21.750 - 00:41:04.462, Speaker A: No, that specific instance, it's a specific instance. It's not believing the contract. Well, all contracts are specific instances. So you're like contract factory, which is like the bytecode that doesn't live on the blockchain per se. That's just like abstract. And you can instantiate out of that factory as many contracts of that type as you. Okay, interesting, because yeah, I'm going to kind of roll through these, get to some coding and having fun, me talking less the web3 initialization.
00:41:04.462 - 00:41:55.522, Speaker A: So now we're looking at the JavaScript file and not the sliding file. So on line 184 at the very bottom, I have this thing in here which is like a very common piece of JavaScript. You'll see I didn't write it, I just like paged it in there more or less. And then at the very end it's like checking whether or not web3 is there. It's providing some, like if it's not there I can do some logging and then very end of that when we know we more or less have web3. I'm starting doing my controller, my start app function like getting me started, and I wrapped it in a set timeout because I noticed some errors. My app is really light web3.
00:41:55.522 - 00:42:38.240, Speaker A: Even though it was called and getting imported, it wasn't done running through all the JavaScript and there was a race condition. So my app was failing, intermittently failing. So I just wrapped it in a little timeout to let web3 load. That's like pretty useful for really light dapps. So remember that. So when I load the page I see the no web3 should consider trying metamask message. Yes, because I think it's expecting, yeah, I'm loading web3 because I just copied this and didn't really edit it.
00:42:38.240 - 00:43:00.594, Speaker A: You're going to get that error. It's not true. This is not true. And then I'm doing a little web3 check myself. So yeah, I should have not called it web3 check. I should call it like blockchain check. So web3 is the library, the JavaScript library, but this web3 check is checking your connection to the blockchain.
00:43:00.594 - 00:43:59.100, Speaker A: And if you don't have test RPC running you'll see that other error we saw earlier that pops down in UI. That function is being called in a few different places, but it's actually just defined right here in a try catch. So it's saying hey, and I'm just using the Coinbase because it's a super simple synchronous, not an asynchronous call that you can make web3. If you find an address, put it in the console, and then if you don't, if there's an error, then display this error, but catch it, don't fail. The whole app. My blockchain check, which that should actually be called, is wrapped in a try catch. I already talked about the delay because my app is really light and then the DAP initiation, the start app function is the very first function in my controller and it's checking for web3.
00:43:59.100 - 00:45:10.482, Speaker A: It's going to set the Coinbase address in my model and also the contract factory, not the actual contract instance, but the contract factory which uses this web3 function and all you pass into it is the API. And then finally I'll run the next function which is get my balance, basically put that on the UI. How are you telling it to check the robot provider column? Yeah, so right here it's saying like Ba else web3 equals this. So it will look to regular blockchain first. Yeah, I mean that's just arbitrary. You could put in here anything you want or nothing at all and have the UI do something else. This is just so I can switch between the real blockchain and my test quite easily and I'm using metamask and disabling it.
00:45:10.482 - 00:46:10.706, Speaker A: Enabling just allows a nicer testing and developer experience. Are there local providers that provide this? Yeah, so like any window to the blockchain that hardly any of us probably have a full node because I have a laptop and I should have a full moon and I'll wipe the node on the laptop and get a new one. But when you go to mine into wallet, they're pointing to a whole host of nodes using same with all block stores, they have like a bunch of nodes and they're all load balanced because they're getting a ton of requests. So those would be running everybody's DAP that they're trying to interact. But then that actual node itself gets written to only either changing hands or what actually gets written to the node. If you're interacting with Hodl, you're not doing that on the blockchain. You may pull a level.
00:46:10.706 - 00:47:01.086, Speaker A: You are so like that little countdown timer I had. If I was on the real chain and I was using Metamask, Metamask would intercept that function call and they would call out to one of their full node, their host of full nodes, and they're using various number of services out there. Like Microsoft Azure has a thing, Infura is another company that you can fire up full nodes on, but Metamask has their own set of full nodes. And even though I'm not writing to the blockchain, that data is still coming from a full node somewhere because it can't come from my browser. Like I don't have all of the blockchain in my browser. Are those rewarded anyhow? Not from calls, but from writing the blockchain. They get transaction fees.
00:47:01.086 - 00:47:24.010, Speaker A: Okay, yeah, they get the gas and then they're mining. If you're a mining node. So if you're not a mining node, non mining. But the thing that incentivizes non mining full nodes is that they have a product. Metamask has a product. You might not pay for it, but same with Jax. Jax is pointing to full nodes.
00:47:24.010 - 00:48:05.574, Speaker A: Wallets have an interesting revenue model. We won't really get into what that is right now. Maybe later we can talk about that. But it's in their interest to provide you a window to a node. Something I've been wondering, maybe, is there a way to make a full node mining machine force a contract that was written by, say, the owner of the machine? What do you mean by that? So we're going from like proof of work, proof of stake and all that stuff. What if I write a contract? Crappy one, but it does serve some sort of conveyance utility, logic, purpose. And then my computer was always mining a 26 mega hash is just focused on that contract.
00:48:05.574 - 00:48:33.086, Speaker A: Is there a way to do that? Yeah, but then your node will, because you're only focused on that contract. You're only going to produce a block. You're only going to mine a block that has that contract in it. And then that block will be out of consensus with all the other blocks, and your node will get kicked off and start its own chains. So it will fall out of consensus. Okay. So you can reorder, I think you can give certain transactions priority, which has been a problem with during these ICOs.
00:48:33.086 - 00:49:10.382, Speaker A: We'll see mining operations, they'll prioritize their transactions first, but you can't actually remove or add transactions because then you'll get out of consensus. Okay, form validation, that's in there. You can pull up these slides and look at the lines if you really care. Other really useful functions are two way and from way you noticed in solidity we're defining the hobling amount as an integer. Well, in my dap it's a float. It could be like 8.6 or whatever.
00:49:10.382 - 00:49:56.018, Speaker A: Well, that's not an integer. That's because we're only dealing in Wei, which is the lowest amount. It's like the satoshi, it's like the ethereum's equivalent to a satoshi, which is the smallest increment of bitcoin that you can send all the way to the 8th decimal. So we can kind of guarantee you just be working in integers. But since we don't want to read our account balance in a way like, oh, I have like 17 bajillion trillion way, I'm a millionaire, I don't know. No, we deal in ether or bitcoin, so we use two way and from way functions to just help do really fast conversions for us. Error display little actual UI pop down, not just logging.
00:49:56.018 - 00:50:40.890, Speaker A: The error is in there as we noticed earlier. And then the set interval and set timeouts are like really important JavaScript functions because we're dealing with a very, like I said, high latency system. So set interval will watch. Each one of these you pass in two arguments. The first is a function that you want to call, and the second is the time and milliseconds that you want to either call it once for in the case of set timeout, or call it on an interval for. And if you write this, it would be in your interest to also do a. I don't know what the funk, it's in my code somewhere, but it's like stopping, stopping this loop.
00:50:40.890 - 00:51:37.884, Speaker A: Once some condition is met, you then stop the innovative. All right, now it's time for the rest of the class. We can code and ask questions and talk. So here's some ideas that I had. Like my improvements that could be made to hoddlebox is like the placeholder is a really simple UI improvement. Like placeholders inside of a text box are confusing. They're not necessarily the best user interface choice because value, well, if I type some stuff in and then do other things in my life and come back to it, I don't know what those are.
00:51:37.884 - 00:52:22.240, Speaker A: So that's a pretty rudimentary user experience thing. Like, oh, which one is which? I forgot. And then you have to delete it and oh, blocks could change that. That's pretty boring, but it's up to you. More interesting one is if we refresh my page, we lose the contract. So we lose that instance. So if I send like I have 100 e right now, if I want to hold twelve e, let that go through, boom.
00:52:22.240 - 00:52:57.688, Speaker A: Well, if I like my computer crashes or I refresh the page, I've basically lost, unless I remember that contract address. There's a way to find the contract. It's on the blockchain and you can reference your address in a block explorer. The user interface is lacking a lot here where, oh, shoots. It should know that I'm already holding hottening something. The way we could solve that is by, well, I'll get into the next slide here. Lastly, this contract is expensive.
00:52:57.688 - 00:53:58.640, Speaker A: So in its very single purpose it's like all of this stuff is happening on the instantiation of the contract. And then there's one function that destroys the contract. So there's like state creation and destruction, and a lot of gas is being used for the creating contract. You could make a contract that is like a global or public hoddlebox. You know, it's like a public good. So instead of anyone who interacts with the contract would get like popped in a map and their value adjusts accordingly and the contract would live forever. And you can define, anyone could call a function that says, I want to hold for ten blocks and then send some ethereum with that function call, and then they'll be hodling and the contract can keep track of like a million different hoddlers, and the contract could just live forever.
00:53:58.640 - 00:54:35.230, Speaker A: So I wrote that version of the contract up. It's on a different, I shouldn't tell you this now because we haven't gone to it. It's on a different branch in the GitHub, I think it's called, like, I forget what it's called, but it's in there. So that logic is actually incredibly simple. So creating this as like a publicly usable contract is very simple, and it uses a lot less gas for people because of that. Those function calls are much cheaper than creating contracts. All right, and here's a little more detail on each one of those.
00:54:35.230 - 00:55:43.204, Speaker A: You can do whatever you want and we just talk or whatever. But these are some interesting ways to improve the contract as far as the page refreshing portion goes. You could use this thing. If you open up the JavaScript console, local storage is like a browser native browser function functionality and local storage setitem and then some key and some value and then get item for the key or maybe remove item at that key. So you could on the deploying of the contract, set the contract address in your local storage and if you close your browser or refresh the page or do whatever, barring throwing your computer in the trash, this will always come back up when you go to the website as long as you haven't removed it and you can check for that on the start of the application. If anything is at if local search getitem anything at this key which is just a string, the key can be whatever string you want. If there's something there then cool.
00:55:43.204 - 00:56:15.556, Speaker A: We know how to handle the app now we'll let them interact with the previous hoddlebox. If there's not, then let them create a new hoddle box, that kind of stuff. Does that make sense? That's quite simple enough, but I feel like that's really important because when I refresh the hollow box you lose your eh, yeah, it's within the browser. Yeah. So I'll do, I'll just show like an example really quick. I think it's really cool. It's similar to cookies.
00:56:15.556 - 00:57:02.600, Speaker A: You could also use cookies. Cookies is like another form of local storage, but this is much more pleasant to interact with. What's that? It is, it is newer. So here we like local storage set and all browsers support this. Yeah. I think at this point, safe to say I might be wrong. So maybe cookies are like the better choice and I'm just a fan of doing the latest and greatest test and then bam.
00:57:02.600 - 00:58:13.100, Speaker A: Then if we do local storage getitem test, there it is. And the actual like seeing that application, at least within Chrome is right here. Storage in one of these many things all the way up test. So clearly it's got to be supported because Google Slides is very heavily using local storage. It's like a little micro database and that's it. So now if anyone wants to take it upon themselves to work with the HTML, JavaScript and solidity that's in the GitHub repo and change it around and make these improvements or make whatever improvements more, feel free. Thank you.
00:58:13.100 - 00:59:02.722, Speaker A: Thank you. Yeah cool. Yeah. Now before we cut the video completely, does anyone want to talk about anything or have any questions? Local storage creating like a globally accessible hollow box. How do you do that? From my perspective, I'm always looking around like how can I do what these big industries are doing. You heard of the ride network of Ethereum? Yeah. So I thought, why don't we make a thing where it would basically be that what else can be done other than an extra service? Or how could we modify this extra service to send album to say what to do? Something just different.
00:59:02.722 - 00:59:26.426, Speaker A: Yeah. So that was going to be my recommendation for the hackathon is an escrow service is really as simple as it gets on the blockchain. It's a very simple type of application. It's incredibly boring. So make an escrow service. That's interesting. Hoddlebox is, like, slightly less boring, but it's basically just a time based escrow.
00:59:26.426 - 01:00:26.370, Speaker A: You could have another escrow that requires the signature of another known address or group of addresses. But as far as the hackathon goes, you'll be judged on novelty. I'll judge you on humor, because I like humor. If you are really funny, it doesn't mean you're going to win. Like, if your code sucks or if it's just, like, really boring. If it's really funny, probably not even win. I have a really interesting idea, in my opinion, that involves postal, the postal service and using smart contracts, QR codes, and sending ETH as a form of postage stamp, and then having the receiver do some function call on that QR code contract when they receive the package, and it would release the ETH in the postage stamp to the postal company.
01:00:26.370 - 01:01:05.118, Speaker A: I just told you, like my idea for the hackathon. Steal it, I guess, and see how you get judged. But that's an example of cool, novel escrow. It's not just escrow. It has, like, real world application, because otherwise escrow is just like, I don't know, make a drink. What kind of flavor of drink do you want to make templates? I don't know. Sasha came up.
01:01:05.118 - 01:01:21.266, Speaker A: I think you had a group of people come up with the escrow idea at one of the first meetups. Yeah. So we had a little planning session before we picked this up. Cool. We're going to create in 6 hours. They utilize the blockchain. Yeah.
01:01:21.266 - 01:01:57.906, Speaker A: If we did something more than something that simple, we would be looking at like a two day hackathon or something. Because a lot of hackathons are one to two days. We have a very relatively short hackathon. All right. So I encourage you to make, I would really be curious in the remainder of this, tonight's workshop to see someone implement the page refresh. Like, I haven't done that yet, and I think that would be cool. It might be a little ambitious, but at least to put the basic logic in place.
01:01:57.906 - 01:02:40.690, Speaker A: And then also the globally accessible hot box. This is more like Ui oriented, and this is more like back end. Like how do we restructure the solidity contract itself? And then this one is just incredibly banal. But don't let that deter you, because it's important for your users to have a good experience. And I'll leave it at that. So if anyone has any questions regarding solidity or the development stuff, then Mike and I will be walking around and. And that's that live string.
01:02:40.690 - 01:02:41.390, Speaker A: It's.
