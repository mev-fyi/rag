00:00:25.330 - 00:01:17.846, Speaker A: And with me is Austin Griffith. Wow, this is loud. So today we're going to talk about the gas station network and how we decentralize the meta transactions. Now, before we dive into the gas station network, let's talk a little bit about why gas is a challenge are we trying to solve? So this is something I call the DAP paradox. When you are building a decentralized app, its value typically comes from a netform network effect. This means that your first users are getting little value. But as more and more users join the DAP, it becomes more valuable for everyone.
00:01:17.846 - 00:01:57.278, Speaker A: This means that we need to make it really easy for the first users to join now. So let's look at Facebook, for example. Facebook is probably the best example of network effect. So in the old days when Facebook was just getting started, the first users, it wasn't very interesting to be one of the first users of Facebook because nobody was there. But at least it was easy to join. So you would sign in, look around, there's nothing to do, you forget about it. But then as time goes by, you start getting more and more notifications about friends of yours joining.
00:01:57.278 - 00:02:55.830, Speaker A: So eventually you click it again, you go back in, and now it's interesting, now your friends are there. So that's how network effect works. Now imagine what would happen if in order to join Facebook the first time, you would need to go to an exchange pass KYC process, prove your identity. Then you need to transfer money from your bank to the exchange, buy ether, install metamask, pass the ether from the exchange to your metamask, learn how to use that, all that just to be able to pay for gas to register for Facebook. I imagine we wouldn't have Facebook right now. So we need to make it much easier to onboard new users to adapt in order to create network effect. So I think this is probably one of the most important problems we need to solve for the Ethereum ecosystem.
00:02:55.830 - 00:03:05.560, Speaker A: And there's already a solution for this called metatransactions that I let.
00:03:06.090 - 00:03:39.662, Speaker B: Yeah, so I recognize a lot of faces in the room. I bet a lot of people know what metatransactions are, but we'll kick through it real quick. Basically, since you already have a key pair, key pair is really easy to generate, right? But ETh is really hard to get. So gas is hard to get. Key pairs are really easy. So what if you could sign a transaction that's very similar to a real transaction, but instead you don't send it on chain, you send it to a relayer, the relayer wraps that transaction up, puts it on chain, pays the gas for you. And you could do kind of like this little atomic swappy thing in there where they get paid a little reward, too, right? So you don't have any ETh.
00:03:39.662 - 00:04:15.614, Speaker B: You just sign transactions within the DAP. You send them off to a relayer. That relayer is incentivized somehow, either from you or by the DAP or a lot of different ways, and then the relayer submits it into the contract. The contract, EC recovers it. You can cryptographically prove that that person signed it. Even though they didn't have gas, they were still able to interact with your smart contract. So the problem with this is, and if you ever use any of my demos, there's basically, like, this one central server that lives out on AWS that does this relaying, and that's awful, right? It goes against our entire ethos of how we like to do things.
00:04:15.614 - 00:05:05.182, Speaker B: So we've always been pushing, we kind of created the Metacartel to solve this problem and to kind of create standards around it. And what we were after was a way where we could have a decentralized network, where we could actually not have this one central point of failure. And what we were doing was we were thinking it would be a pool. It would be similar to Ethereum transactions, where we would take a meta transaction, we'd put it out in a pool, and then a set of relayers through game theory and other stuff that's over my head would just happen to get your transaction through for you. Right, as long as they were economically incentivized. What we found was it was just incredibly complicated, and there may still be a solution in there somewhere, but this guy and his crew at Tabooki came up with a really good solution that I call relayer returns, but he calls 1800 ethereum. Okay.
00:05:05.316 - 00:05:52.190, Speaker A: Yeah. All right. The problem with having everything, with having a secondary transaction pool is a synchronization problem. When you try to send a transaction through such secondary pool, all of the relayers are looking at the same pool. They are not synchronized. So each of them is going to pick the same transaction, the most expensive one, because that's how they make money. So they all end up taking the same transaction, putting it on chain, and all of them except one get reverted, because transactions should only go on the chain once, and all the other transactions never get to the blockchain.
00:05:52.190 - 00:06:39.958, Speaker A: We decided instead of trying to solve this problem, we try to approach, to try to turn the problem upside down. We realized that the sender is already the most incentivized party to get the transaction through, but we need to give it the tools to do so. And then we don't have to use a transaction pool. We can talk to a single relay and still be decentralized. So the tools needed for that. First the sender needs a way to discover relays and then it also needs to be able to verify the service to know that it's getting the service without waiting for mining to occur. And if we can provide these two things somehow, then we turn the problem upside down.
00:06:39.958 - 00:07:46.100, Speaker A: Instead of creating a transaction pool, we create a relays pool and let the transaction go to the relay instead of doing it the other way around. So the approach we took is based on a singletone smart contract called relay hub. There's exactly one on the entire blockchain and all the relays have to register with it. When they register they put a stake. That's like a performance bond. It's like a performance bond that guarantees that the relayer is going to provide the service. And the relay also announces what its fee is going to be, how much it expects to get compensated, a URL that tells users how to reach it, and then as it gets used, relay hub also emits events that allow anyone to calculate a reputation to decide whether a certain relay is worth interacting with.
00:07:46.100 - 00:08:47.566, Speaker A: Now in order to really make it work, we needed to find a way to get immediate feedback. So we don't need to wait for mining because otherwise it would be really easy to take the system down or to make it very slow by just creating a bunch of relays that tell you that they are providing the service and then not put anything on the blockchain. So the client will just connect, provide a transaction, wait and until it waits for long enough and see that it doesn't appear on the blockchain. So say okay, so this relay is not reliable, go to another one. If you create a bunch of these relays, you make the system unusable. What we did instead is we said that when the sender gives a transaction, when a client sends a transaction to the relay, the relay needs to do two things with it. One is to put it on the blockchain, but the other is within the same HTTP connection.
00:08:47.566 - 00:09:44.498, Speaker A: Return the signed transaction, the same one that it's supposed to put on the blockchain, just return it to the user immediately. So this is an immediate operation and now the client can actually take this transaction and put it on the blockchain. Because the transaction is signed by the relayer and it already has gas, you can put it on the blockchain so you can verify the transaction and know that it's actually going to happen. There are still a few corner cases, a few attacks that would have been possible here, and hopefully we addressed all of them. But I don't think time will allow us to go into each and every attack here. So if you want to learn more about these details about the attacks and mitigations, you can read my medium post here, or you can go to EAP 1613 where we describe the internals of the network. And there you can also scroll down to a section about attacks and mitigations.
00:09:44.498 - 00:10:14.886, Speaker A: You can see the metrics of attacks and how they are mitigated. But now I think we just switch to a demo. So the network is live. We actually have Relays running. It's not on mainet, but it exists on Robstand and on the XDI network. Thank you. So what I'm going to show in the demo is we took metacoin.
00:10:14.886 - 00:10:50.490, Speaker A: Metacoin is a sample app, a sample app that comes with truffle. So anyone who is developing with truffle here probably familiar with it. And we made small modifications to metacoin to use our gas station network. When you use it, what happens behind the scene is the client will actually find the relay from relay hub, agree on a fee, perform the transaction through that. So I'm going to show you how it works. And then we look behind the scene. We just look at ether scan and see what really happened behind the scene.
00:10:50.490 - 00:11:25.030, Speaker A: So here I have two instances running, one of them in incognito mode. So they have two different addresses. I'm going to copy this address and we're going to send one token. So it already went to the relay. Now we are waiting for robsten to mine it. So let's give it a second. And should have used XDai.
00:11:25.030 - 00:11:46.810, Speaker A: Yeah, Xdai would have been faster. Yeah, next time. So, okay. Yeah, we really should have used XDI.
00:11:49.730 - 00:11:52.250, Speaker B: The reason why is because of ether scan, right?
00:11:52.420 - 00:12:08.310, Speaker A: Yeah, because I wanted to show it on ether scan. Because when you use XDai, the interface for looking at transaction is just not as nice. Well, if it doesn't get mined soon, we just switch.
00:12:11.770 - 00:12:13.730, Speaker B: Wonder if there's a chance of a network.
00:12:13.890 - 00:12:38.714, Speaker A: Yeah, it could be. Well, I still have tabs open from when we tested it earlier, so I'm just going to show it with that. Okay. Yeah, mining works. Okay. So now first, let's look at this address. So this is the address that sent the token.
00:12:38.714 - 00:13:13.100, Speaker A: And we see that the token count went down if I now refresh on the other side, we should see six. Now we have six. Now if we look at this address for a second, we'll see something interesting. You see that there are no transactions from this address, like ever, because it never had the money to pay for gas. But you see that it does have token transfers. So token transfers happened through a relay, and that's why there are no transactions. Now let's look at the transaction, see what really happened.
00:13:13.100 - 00:13:54.242, Speaker A: So here we see that a transaction went from that address. It's a different address from the one we used. If we look at this one for a second, you see that it has a lot of ether. I'm sorry, zoom in. I don't know how I could do that. Here, control plus, maybe like. Is that better? Okay, so you see that this address, actually it has ether.
00:13:54.242 - 00:14:22.720, Speaker A: This is the relayer. So the relay signs transaction. We see that 1 minute ago there was a transaction here. Now going back to the transaction, let's see what it was. So the transaction came from the relayer and it went to relay hub, which we'll see in a second. During the transaction, one ERC 20 token was transferred from the address of the wallet to the other wallet. And the call here was a relay call.
00:14:22.720 - 00:15:02.438, Speaker A: So you see that behind the scene, the client made a relay call. Now I'm going to switch to the relay hub contract. So in the relay hub contract, we see the transaction that happened 2 minutes ago. And if we look at the internal transaction, at what happened internally, we see that the transaction actually, it was actually three different internal transactions. That's because the first one was checking the contract to see whether it's going to accept the transaction. We let the DAP decide whether it's willing to accept the reverse charges, since the DAP is going to pay for it. So we pass the transaction to the DAP.
00:15:02.438 - 00:15:27.880, Speaker A: The DAP tells us, yeah, I'm going to pay for it, I want the transaction. From that moment on, even if the transaction reverts, it still gets compensated. The second one is the transaction itself. This was the token transfer in this case. And the third one is an accounting call. It just tells the contract how much it ended up costing it and which user is responsible for it. That's in case you have your own accounting system.
00:15:27.880 - 00:16:05.294, Speaker A: But now the interesting thing to look at is how did we even find a relay? All we know is the address of relay hub. So like I said, when you register relay. When you register a relay, it appears there. So it appears in the events in relay hub. Let's look for it. So I'm just looking at the number here and okay, so we see that this is the relay transaction. And we see that it went from this relay.
00:16:05.294 - 00:16:43.742, Speaker A: We saw this transaction. Now let's look for it some more. Okay, so here we see there was a relay added event. This is the register command that came from the relay. So this is how we discover the relay. You see that the relay added was called when it gets called every time a relay registers or refreshes itself, which it has to do occasionally. And so what we see is that it provided us with its address, its transaction fee, stake size, and most importantly the URL, so we know how to reach it.
00:16:43.742 - 00:17:19.542, Speaker A: Let's change it to text. So here you see the actual relay that was used for this transaction. And every time it will be a different relay. So you can have as many as you like. And the relays are just competing over fee and reputation in order to handle the transactions. I think that shows how the system works. Now if you want to add this to your own contract, let's see, what do you need to do? You have a DaP and you want a DAP to start using the gas station network.
00:17:19.542 - 00:17:50.130, Speaker A: The changes are really minimal. What you need to do here is first you need to inherit from a contract called relay recipient. Relay recipient. It just provides you with all the code you need in order to interact with relay hub. And then you need to implement two functions. So one function is accept relay call. Accept relay call is a view function that you need to implement, and it tells the relay whether it's going to get compensated.
00:17:50.130 - 00:18:35.310, Speaker A: It's supposed to look at the transaction, the sender decide whether it's a transaction that it actually wants to handle. You can call it as a view function from the relay so it doesn't cost you anything. And then it gets called again during the transaction to see whether the relay should be compensated. The second function is the post relayed call. This is transaction that tells you how much the transaction ended up costing you, which consists of the actual gas price multiplied by the transaction fee. The transaction fee, that's the markup that the relay is requesting, which you agreed on. Now finally, you need to go through your contract and change message sender to a get sender call everywhere.
00:18:35.310 - 00:19:08.630, Speaker A: That's because message sender is now the relay address. It's not the address of the real sender. So what getsender does is usually it just returns message sender. So it's identical, except if the call came through relay hub. If it came from relay hub. Then it calculates, it finds the real sender and returns the address of the real sender here. So if you want to look at it and try to add it to your dap, we have a hands on tutorial that we posted yesterday.
00:19:08.630 - 00:19:39.160, Speaker A: You see the link here? This tutorial walks you through taking metacoin and adding this functionality so you can do the same for your own DAP. And during the hackathon, I'm going to be available here. So if anyone wants to add it to his project here, just talk to me and I can help you through the process. And I think we still have enough time, so I want to let Austin here demonstrate something.
00:19:41.850 - 00:20:06.542, Speaker B: So, just to do a little too long. Didn't read there. Basically, we were going out and we were trying to make a pool, right? He came up with a way to do relay returns, which is basically he queries for a relay. He queries for a decentralized relay from a smart contract that you can stake and you can slash on. So you can make those calls quickly within a block. Right. You can find your right relay with just an HTTP request, and then you send that off and he handles your call for you.
00:20:06.542 - 00:20:24.370, Speaker B: Just too long to read. Okay, so now we have implemented this live into production of the burner wallet. So there is a moment in the burner wallet where you want to send. Let's go back real quick, make sure that. Let me make sure my bow tie is right. Okay. Make sure.
00:20:24.370 - 00:20:33.030, Speaker B: So this guy's got $0. This is a brand new account, right? In fact, you don't even have to have an account yet, right? Like we could be sitting on Google right now. We're just using this for the QR code reader.
00:20:34.090 - 00:20:35.720, Speaker A: Yeah, control platform.
00:20:37.050 - 00:20:59.134, Speaker B: Okay. So what we're going to do is just use the QR reader. What I'm going to do over here is I'm going to package up a link for. I'm going to send that to an escrow contract. This is basically just link sending. You can send funds through a link to someone else that doesn't even have a wallet yet. It will land, it will generate them a wallet and it will pull the funds in.
00:20:59.134 - 00:21:27.266, Speaker B: So this is the share link so far. If you guys stole that, you would be able to grab it. But what's going to happen here is he doesn't have any gas to claim this, right? He's got to claim this from the smart contract. So what we're going to do is Joaf's team basically just threw me a pull request one day and it was like, hey, we implemented the gas station and it totally worked. So if I put this up here, what it's going to do is it's going to go pick one of his relayers. I hope it's mine, too. We're both running relayers.
00:21:27.266 - 00:21:42.830, Speaker B: That'd make it more decentralized. Right? Right. So it's going to pick one of his relayers, and then that relayer is going to pay the gas for it. It's going to get its prize, which is like a percentage of the gas price. Right. And then it's going to deliver us our funds. Twenty five cents.
00:21:46.450 - 00:22:09.400, Speaker A: Here we go. All right, thank you. So now that the transaction passed and we see the $0.25, we can actually look at the. So we can actually look at relay hub on the XDI network. Let me refresh it here. Yeah.
00:22:09.400 - 00:22:25.660, Speaker A: Okay. So 41 seconds ago, we had a transaction. This is the transaction. This was a transaction through relay hub. So we see that it picked some relay and used that.
00:22:27.070 - 00:22:28.570, Speaker B: Please let it be mine.
00:22:37.010 - 00:23:21.510, Speaker A: Okay, so this was the relay call. The relay call went to this d three. So this ended up being the relay call. And here we can see that it was a transaction relayed. Now let's look at this relay and see if it's Austin's relay or one of mine. So hold on a second. Are we.
00:23:21.510 - 00:23:24.840, Speaker A: Yeah, I'm less familiar with this interface.
00:23:26.140 - 00:23:27.880, Speaker B: But this one's open source.
00:23:28.700 - 00:24:00.156, Speaker A: Yeah, let's just look. Here's. So that's the actual transaction. And now, hopefully, this is the registration. Let's look at. That's. No, this was transaction relay.
00:24:00.156 - 00:24:04.210, Speaker A: That's the wrong one. It's less searchable than.
00:24:05.060 - 00:24:09.090, Speaker B: That was the one where we were pushing to production 45 minutes ago, testing this.
00:24:12.020 - 00:24:35.120, Speaker A: It. It. Yeah, that's the one. So here you see, this was a register relay call, and it came from relay one. Relay one XDI. Yeah, this is one of mine. When we tested this, it went to his relay.
00:24:35.120 - 00:25:03.576, Speaker A: The point is that it doesn't matter which relay he takes. It negotiates. He takes one relay and uses it. So anyone can start a relay. And what's cool here is that at this point even, I mean, once the network is up, we at Tabooki don't matter anymore. Let's say right now, I'm shutting down all of my relays. It doesn't affect the system because once other people like Austin started relays.
00:25:03.576 - 00:25:10.848, Speaker A: And so Austin also has a relay on the same network. The network goes on. I have no way of shutting it down at this point.
00:25:10.934 - 00:25:15.936, Speaker B: And it took me about maybe 15 minutes on AwS to sign it up. Yeah. Okay.
00:25:16.118 - 00:25:48.270, Speaker A: Yeah. So starting a new relay, it should take you minutes because there's a docker that does everything for you. You just start it, you fund the relay and you're good to go. You start making money by relaying transactions. And modifying an app is also rather simple so anyone can start using this. Yeah. So thank you.
00:25:51.120 - 00:25:53.996, Speaker C: Congratulations. First, this is truly amazing.
00:25:54.178 - 00:25:54.732, Speaker A: Thank you.
00:25:54.786 - 00:26:06.252, Speaker C: Two quick questions. First one, do you know how much extra gas you are paying for relaying one of these transactions? Instead of sending an ERC 20 directly?
00:26:06.316 - 00:26:08.592, Speaker B: The EC recover is probably the most expensive part.
00:26:08.646 - 00:26:38.052, Speaker A: Yeah, EC recover is probably the most expensive. I don't remember the exact numbers, but yes, it does make the transaction a little bit more expensive. The point is that I don't think it's the right thing to do to compare it to the cost of an ether transaction because it's the cost of acquiring users that otherwise you wouldn't be getting. It's not that these users would come because they pay less gas, they wouldn't come because they don't own eth.
00:26:38.196 - 00:27:02.370, Speaker C: So that's a great answer. And my second quick question, and I'm going to sound like a broken record, but when can we pay gas with Dai like Mainnet? When you go to Mainnet, are you going to be able to pay for the gas in other tokens other than e?
00:27:02.980 - 00:27:58.240, Speaker A: Yes, this is actually outside the scope of the system because the way we designed it is we have the relay recipient contract that you have to inherit from, but you can subclass it, you can create a subcontract and implement your own model. So for example, if you have an internal token in your DAP, you could charge the user with tokens. We actually have a sample that does just that in our git repository. So there's a sample relay called token relay recipient where you implement your own token. You have a balance for each user. Whenever a user makes a transaction through a relay, you accept the charges, but you charge the user with your own token. And you could do this, for example with a credit card, just assign users credit externally, put it into your contract and you can start charging users.
00:27:58.240 - 00:28:32.128, Speaker A: You implement your own model. So you see it's outside our context because we created a system in a way that makes it easy for you based on your model. For example, if you're implementing a Dow, maybe you don't want to charge your users directly, but you want to have a whitelist of Dow participants. And if someone abuses it and sends a lot of useless transaction. The others can just vote him out, get him out of the Dow. If it's a game, then maybe you'll want to monetize on your users separately or pay with your own token. So it depends on your logic, but you can implement whatever you like here.
00:28:32.128 - 00:28:33.056, Speaker A: Great. Perfect.
00:28:33.158 - 00:28:34.028, Speaker C: Congratulations.
00:28:34.124 - 00:28:34.448, Speaker B: Thank you.
00:28:34.454 - 00:28:37.584, Speaker A: Thank you. Hi.
00:28:37.622 - 00:28:41.104, Speaker B: I may have missed this part, but how does the relayer hub choose which.
00:28:41.142 - 00:28:43.090, Speaker C: Relay you get to use?
00:28:43.460 - 00:29:17.596, Speaker A: So it's not the hub choosing. The point is we wanted to give all the power to the user, to the sender. So now the sender, the client picks it. The relay hub, just the dub developer chooses. So you have all the information, you have all of these relay added events, the registration events, you can see them as events emitted from relay hub. And each of these events give you a URL and the fee you are going to pay. So you can select it based on a fee or on the reputation or even hard code one.
00:29:17.596 - 00:29:39.140, Speaker A: If you like it, it doesn't matter. And then the sender, the client gets to pick which one to use. Normally it just connects to three of them at a time, just pings them and talks to the fastest one. It does something interesting with the other ones, making them inspect the first one, but that's a bit of a longer explanation why we do that.
00:29:39.290 - 00:29:39.990, Speaker B: Thanks.
00:29:42.200 - 00:30:18.700, Speaker A: So what happens if your relayer get out of money? If your layered get out of it? You have to put it right. Yes. You have to be funded. First of all, if you don't have enough funding, then the register call will fail. Relay hub actually verifies that the relay address is funded. And since you have to re register every once in a while, then you are going to be thrown out of the system, so to speak, if you don't fund it. Besides, the client can also check your balance.
00:30:18.700 - 00:30:34.310, Speaker A: So when the client picks a relay, it not only looks at its URL and fee, it also gets the balance for this relay. If the relay is not good for it, if it can't afford a transaction, you just don't pick it, go to a different one. Okay, thanks.
00:30:35.720 - 00:30:37.220, Speaker D: Hey, great job guys.
00:30:37.370 - 00:30:38.596, Speaker A: So I have a quick question.
00:30:38.698 - 00:31:02.816, Speaker D: If the relayers were kind of malicious and they had like, maybe they were a rival Dap, and they decided to come out and they wanted to shut down the Dap that's calling out to get these relays, would they be able to do some damage there? So you have a Dap that's trying to relay transactions and they're a rival. So they have relayers and they're going to try to just shut it down. Is that possible? Have you thought about mitigation of that?
00:31:02.998 - 00:31:17.750, Speaker A: So good question. And the system is designed totally trustless. So dapps don't trust relays. Users don't trust relays. Relays don't trust anyone. Everything is incentivized and trustless. So if a relay doesn't provide a service.
00:31:17.750 - 00:32:04.450, Speaker A: If it doesn't provide a service, since you know about it immediately, because it didn't provide you with a signed transaction, you switch to another one and you don't wait minutes, you wait maybe 2 seconds, so it delayed you for 2 seconds. You go to the next one, but from now on you're also going to ignore this relay. So the relay will just stop getting traffic. And since it put a stake, you can't spawn as many relays as you like. You have to put like ten ether stake when you create it. And if you want to change the address of the relay, you need to unregister, wait for 30 days only, then get your stake back and register a new relay. The idea here is that if a relay doesn't give a good service and it stops getting traffic, in order to redeploy the stake, you need to wait.
00:32:04.450 - 00:32:08.950, Speaker A: You wait for 30 days. Awesome. Thank you.
00:32:09.480 - 00:32:14.420, Speaker B: This guy coming up is Ricardo. He helped me write the initial links contract for the burner wallet.
00:32:14.780 - 00:33:07.240, Speaker A: Okay, my question is, how do you guarantee that the relay gets paid? Because if you are also like changing in a token or maybe directly, how do you take that fee? Or you guarantee that part, so the relay always gets paid with the native currency of the system, be it xdai or if even if internally, you are going to charge your users by other tokens. And the way it's guaranteed is that when adapt wants to start using this, then aside from changing the code, it also has to put a small deposit. That's enough for the next few transactions. So you have to put the deposit in relay hub. You put like half ether or something like this. This should last you for quite a while. So you put a small deposit.
00:33:07.240 - 00:33:41.890, Speaker A: Whenever a relay call gets to your DAP, your DAP is asked using the accept relay call function. It is asked whether it's willing to accept a transaction. If it does, then if it does, then the relay will get compensated from your deposit. So the relay can verify that by calling this function as a view function earlier, it knows that it's going to get compensated and it will not put it on chain if it's not. Okay, thank you.
00:33:44.520 - 00:34:21.360, Speaker E: Can you give some clarity on the slashing conditions. So if I am a DAP, right, and a user uses my DAP, and that query gets forwarded to a relayer, and you said that relayer is supposed to give me a signed message response. Well now let's say it doesn't, right, the relayer is offline or it's malicious or something, what kind of proof can I compile to then send to the relayer hub, contract that hey, this relayer sucks and stake what information does the DAP have and how does that get verified?
00:34:22.420 - 00:35:02.590, Speaker A: Yeah, good question. So this is taken care of the way the protocol works, because if the relay wants to not serve you, it can do one of several things. One thing it can do is just not return anything to you. But then it only delayed you for 2 seconds. You switch to the next one and now you will blacklist this relay. You don't need to report it to relay hub, it's just that your DaP, whether it's from the client side or centrally in your dapp back end, you are going to blacklist this relay. So if it just doesn't provide service that's fine, just you discover it within 2 seconds and you don't talk to it again.
00:35:02.590 - 00:35:44.164, Speaker A: And you can't have many such relays because you need to deploy ten ether for each of them. So that's not a scalable attack. Another thing it could do is it could create a signed transaction, return it to you so you think you are getting service but he doesn't put it on the blockchain. This case is again not really an attack because you have the transaction, you can just go and put it on the blockchain yourself, it's already signed, it has gas, so you put it there yourself and it still happens. But for the relay it's a really bad thing to do because now the relay doesn't know whether you are going to put it there or not. So it doesn't know if it should advance the nons or not. So it's stuck.
00:35:44.164 - 00:36:18.528, Speaker A: When it wants to do the next transaction, should it advance the nons or not? And if it doesn't, then this opens an interesting attack and that's what the stake is for. You actually get penalized. Someone can take away your stake. This is provable on the blockchain. What happens in this case? Let's suppose that the relay tries to cause a more significant delay by giving you the. So he's giving you a signed transaction, but at the same time he puts a different transaction with the same nonsense on the blockchain. So your transaction will get to the blockchain, but it will get reverted on bad nons.
00:36:18.528 - 00:37:08.864, Speaker A: But this will take like 2 minutes at worse. So now it caused the delay of 2 minutes. But the thing is that now this is provable because you have a signed transaction with a certain nons, and now you see on the blockchain a different transaction signed by the same relayer with the same nons. And there's never a legitimate reason for that. So you take these two transactions, you give the two transactions to a penalized function in relay hub, and once this is verified on chain, the penalized function is going to unregister this relay, take the ten ether stake and give it to whoever reported it. So there's a very strong disincentive here, but since we didn't want the app to keep monitoring the blockchain for that, because we wanted to be a fire and forget thing, you just put it there and forget about it. So that's why you talk to more than one relay.
00:37:08.864 - 00:37:34.920, Speaker A: When you get a signed transaction, you don't put it on the blockchain, you give it to another relay or to two other relays. So those relays now have an incentive to look at the blockchain, to look at of the first relay and to look at the transactions and see whether it puts a different transaction with the same nons now or in the future. If it ever does that, then the other relays are going to take away the stake.
00:37:35.420 - 00:37:37.480, Speaker B: We probably better call it. I think we got time.
00:37:37.550 - 00:37:38.744, Speaker E: Yeah, that answered my question.
00:37:38.782 - 00:37:39.216, Speaker A: Thank you.
00:37:39.238 - 00:37:40.528, Speaker B: Okay, thank you.
00:37:40.694 - 00:37:41.070, Speaker A: Thank you.
