00:00:01.450 - 00:01:01.550, Speaker A: What we call parameter optimization and emergent behavior in Defi. So this is a trimmed down version of a two hour workshop that we gave in Devcon last year. So I'm going to try and cover all the bits that we covered there. I've updated it a bit with some new information, but there's also various additional work and stuff if anyone wants to dig in later that I've got links to share and all this stuff. So yeah, I'm going to go over what Vega protocol is to give you some context behind what I'm discussing here. Why we think that large scale agent based simulations are a really good solution to the issues that we see becoming more prevalent in DeFi as it grows, and something that we think should be tackled now, but can also be a really good benefit to the ecosystem and like a selling point in future if they're tackled properly. I'll then dive into the code a bit more on what we call the Vega null chain and the Vega market simulator.
00:01:01.550 - 00:01:42.778, Speaker A: This is how we kind of answer the questions that we raised. And since the workshop, I'll try and do some actual coding, see how well it and yeah, show some of our runs of scenarios and stuff. So, first quick introduction. I'm Tom McLean. I've worked in traditional finance for seven or eight years prior to joining Vega protocol. And I've been here at Vega for about a year, working in the research team, sort of answering questions like this and building out tooling to do so. So Vega protocol itself is.
00:01:42.778 - 00:02:09.990, Speaker A: We're a layer one. Well, we're building a layer one blockchain. It's proof of stake. It uses tendermint for its consensus layer, but beyond that it's totally sort of custom processing. And the idea is that it's really optimized for trading derivatives and generally margined products. It's got a full order book system, so it's not an Amm style, it's placing orders. People can come along, they trade later and you've got a whole shape of prices.
00:02:09.990 - 00:02:59.910, Speaker A: One of the key distinguishers of Vega protocol is that the market creation is totally permissionless. So people can come along and propose their own markets based on their own oracles. The community decide what goes in and once it's voted, people can trade on it in future. Instruments should also be totally permissionless and can be created by the community. Whilst this is a strong selling point, it also obviously introduces a whole load more complexity because you've got to ensure that if someone can create a market, it works and it's not going to blow up the entire system. There's also various liquidity mechanisms to encourage early adoption and early trading, so that people who join early and stake more liquidity get more of the fee revenue later. When the market grows.
00:02:59.910 - 00:04:01.450, Speaker A: A lot of people ask, why run your own l one? Why not just branch off ethereum or other EvM tile things? One of the crucial things is that we think a limit order book style market. You really can't have fees on placing orders because a lot of your information comes from that and you don't want to be sort of blocking that information flow that really makes the market work. So we have no transaction fees on any of that. People pay a fee when they make a trade, but before that, no fees. Additionally, we can have atomic closeouts, which means when someone is distressed, when someone runs out of money, you can immediately close them out. Properly close them out, ensure that the market stays robust without waiting for another person to come along and close you out. We can also implement risk calculations, really sort of bare metal level to make sure they're fast and actually proper risk calculations in future.
00:04:01.450 - 00:05:01.156, Speaker A: There's also plans to have what we call Wendy. It's a custom block ordering which ensures fairness as much as possible in terms of first in, first out trading. So what do we see as the problem and how are we going to fix it? This is a problem which really isn't just an issue in Defi, it's an issue in traditional finance as well. If you imagine markets, I mean, a lot of the blow ups in markets in the past have been because people just can't picture the whole market. You can't test it. Any given bank will have sort of risk models and tests for certain scenarios that they see. If this person collapses, what do we do? If the market moves five points this way or that way, what do we do? But there's very little at a sort of systemic whole level, and it's really impractical to do it like regulators might a couple of times a year do a whole practice with multiple banks.
00:05:01.156 - 00:06:13.146, Speaker A: But that's hugely time consuming, hugely effort consuming, and you don't actually have a guarantee that what you do there is actually what would happen when the market does collapse. Because there's so much human intervention moving to a Defi world, though, so much of it is in code, that we can assure that once we've tested something, if the inputs are the same, that's what it does. We can also set up scenarios to run as often as we want and with whatever parameters we want, and really sort of stress test the whole system, this is something that we see becoming more and more of a problem. Now, as things grow as DeFi protocols, even at simple levels, the interactions between them will inevitably create sort of much more complexity than you can really reason through a priori. And as they become more complex, as their interactions become more complex, the difficulty just explodes. So it's something which can really be an advantage of defi, but it's something we have to tackle while it's still manageable before it becomes just too big, like a traditional finance system. Louder.
00:06:13.146 - 00:07:03.162, Speaker A: Is that better? Awesome. Yeah. So there's also a lot of parameters, especially in Vega protocol, because of the complexity, but also in other markets too, that it's hard to immediately go from what you want to set the parameter to, to how you want the market to behave. So unless you can really test out how the market will behave under this setting or that setting, you don't know and you can't really make safe, well reasoned decisions. So we want people to be able to trust markets, to be able to trust that they know what's going to happen if things go wrong or in a weird edge cases. So that's why we think that this is a really good solution. When we say agent based modeling, ultimately it's a pretty simple concept.
00:07:03.162 - 00:08:06.340, Speaker A: You build out what we call agents, what people call agents who act as an individual person in the market might, they might buy and sell randomly, they might trade, they might try and exploit the market, but you can rationally reason out that this person does this, that person does that, and then ultimately you put them together in a market and you run it and you see what happens. But through doing that, you can hopefully simulate really good models of a real world. When we're going talking about types of agents, we can start at a really base level with zero intelligence agents. These will be hard coded based on sort of the state at the time, but with no real optimization, no sort of learning as time goes on. Examples of the kind of things we have here will be we'll have some traders who just buy and sell randomly. Each time there's a 50% chance they buy, 50% chance they sell, so they're not doing anything particularly smart. But crucially, they're not changing their behavior as time goes on.
00:08:06.340 - 00:08:46.160, Speaker A: At the other end of the scale, you might have an optimizing agent. They have sort of a full knowledge of how the market works, how other agents work, and for them, the whole world is an optimization problem. So once they step away, they can figure out exactly what they think should be doing. But once they come to the market, they're not changing their behavior. They know what they think is the perfect thing to do every time, and they will always do that in the middle ground. And what can be really helpful in our case are reinforcement learning agents. Generally, for anyone who doesn't know, their general cycle is that they will look at the world.
00:08:46.160 - 00:09:43.858, Speaker A: They will take an action based on their beliefs. They will look at how that action affects the world, how that benefits them, and then they will change their behavior in the future. Often people might try and use these to build like good trading agents. But interestingly, the main thing that we care about here is that they try to explore the whole state space of the market, which is what we really want, and be able to have confidence about its behavior in certain situations. So now that we've got a bit of an overview, I'll dive into how we're implementing this and how we're testing this. As I mentioned, we're using something we call the Vega market simulator, which ultimately is a full Vega code base with the tendermint layer, which is a consensus layer, and generally does the communication between nodes, between validators and builds blocks. We get rid of that and we call it a null chain instead.
00:09:43.858 - 00:10:42.952, Speaker A: That means it just accepts transactions blindly and allows you to forward time or stop time, or do whatever you want, really, and gives you real control over the market. You can fast forward time, hours, days, or stop it, dig into it, see how it's behaving. From there. We can then build an API layer that translates your blockchain level communications, your caring about block time, about state that kind of thing into a market level language that you talk about trades, buying, selling, placing orders. And that lets you really express agents much more, much more how they should be thinking rather than worrying about being on a blockchain. From there we build out what we call scenarios. So these are ultimately sort of aggregations of composable agents that we'll have selected from some library and then a state of the world.
00:10:42.952 - 00:11:43.468, Speaker A: So we might have a price movement. And that's where we'll set up the Vega setup itself. Like block size time, a block represents things that you might care about, but don't necessarily, agents don't. We split the scenario into agents who take their actions each step and the environment, which is sort of the number of steps, some config, some logging, that kind of thing. And then it's just a diagram to picture out how we split it out. We've got the environment and then agents, which are just each one will initialize, print itself some money generally, and then for however many steps we go, they get a turn, they get a random turn, they do their stuff, and we move on to the next one. An additional benefit of the market simulator is that we can, in addition to this null chain version, we have a network version that we can use for trading with other people.
00:11:43.468 - 00:12:36.190, Speaker A: So if we want a testnet that the general community can come and try out or just load test the network, we can spin these up. We can connect to a remote network. And because we've just stripped out that layer, all the bots and the agents can do their thing and they're just trading the same way. And then a bit, just a bit about Vega itself. If you're spinning it up locally, you'll have a core node that is your network, a data node that is like your historic layer. So that's just this big SQL database break, basically that ingests events and gives you a nice historic view and then a wallet and a console, because ultimately we find a console that's built for people. Trading is also a really good debugging tool that's designed to make the market clear and usable for people.
00:12:36.190 - 00:13:07.084, Speaker A: So from here, I'm going to jump away from the presentation for a bit and show building a really basic agent that I don't know how zoomed in is that visible. One more. One day I'll remember where the zoom is. Zoom in. There we go. Cool. So I'll send a link to this repository.
00:13:07.084 - 00:13:47.136, Speaker A: It'll be at the end of the thing. But ultimately this is a really simple repository that lets us wrap one of our scenarios and has a simple agent in it and a run step. So the run is we'll run it with this simple python engine, desk docs for it. And what it does is it sets up this scenario that is curve market maker. It's a market maker. It builds a nice curve for you. I don't trust the Internet here, but it's got a function to pull historic prices and then it makes a price curve for you over however long you want.
00:13:47.136 - 00:14:36.854, Speaker A: And you can, once you've got this, this builds your agents. And we're going to plug in our own agent here, plug it in, and then we just ultimately call run, and it'll run through and test the agent. Sorry. So the question was, how are the interactions between the agents modeled? Ultimately, the way we see it is agents don't interact directly with each other. They see the market. So each one gets a turn. It can query from the market whatever it wants.
00:14:36.854 - 00:15:21.320, Speaker A: It can send stuff back to the market and then they interact through with the market as the intermediary. So each sort of step will have a block of agents, and generally we'll sort of shuffle the order so that they don't. It's not always the same one going first each time, but then they interact by the market changing and the state changing. We've got a simple agent here. It basically has these two steps, an initialize, which we're not going to change too much. Here it gets a market and it loads information about the market, about the asset, and then it mints, prints itself some money. Because we're in a null chain world, we can just take money for free.
00:15:21.320 - 00:16:03.214, Speaker A: And then the meat of it is this step function. That's what's going to be called every time round. And so let's put together a simple one. If you load this repository, we've got a few sort of useful helper functions at the top. So I think today we're going to build an agent who, let's say they pick the mid price at each time point, and if it's higher than the last one, we'll buy because it's obviously going to go up. And if it's lower, it's crashing and we'll sell it. So it's a very kind of describing the market as you want it thing.
00:16:03.214 - 00:16:56.470, Speaker A: So we'll just pick our mid. We'll need a last mid. Let's say it's greater than our last mid. I don't want to sell from that one. But then we're going to buy. And we've got another function up here to place a market order. A market order for people who aren't too versed in these things just means that it's buying an amount at whatever price it can get.
00:16:56.470 - 00:17:43.920, Speaker A: So that just saves us having to think about prices. And then we'll say, if the mid is less, then we will instead sell. And then at the end we're going to have to update our mit. And that's really all you need to make a bot with some highly complex logic. We can run this now and it'll run, it'll trade on the market. And if you wanted to, it outputs a whole massive log at the end that you can dig through. But for now, all we really care about is how much money we're making.
00:17:43.920 - 00:18:49.706, Speaker A: So we've got another helper function up here you can throw in and it's going to load our positions and then print out a position, PNL, that is. Let's try running it, see if we see if I coded that right. So we're spinning up here. We log out some output about. We've got endpoints for rest, for GrPC, for graphQL, and then we are trading and losing a large amount of money. But if you want something that maybe trades a bit better, this is an easy place to start off and hopefully don't lose $6,000. Yeah, so that'll run its way off.
00:18:49.706 - 00:19:22.280, Speaker A: Now, jumping back to presentation. So we've got a few agents in our library that if you want to spin up and test, they're all sitting there waiting for you. We've got an ideal market maker and a curve market maker. These are optimizing agents, as I discussed before. So they use mathematically perfect values for best bid and ask based on their model of the market. If their model of the market is correct, then they're good prices. If it's wrong, then it's wrong.
00:19:22.280 - 00:20:16.518, Speaker A: They also sort of place a nice shape of orders behind it. And we've then got some other agents to simulate sort of activity on the market. A liquidity taker who blindly trades up and down, an informed trader who has some estimate of the future, and momentum traders who use technical analysis type trades to not make money. So while we've got some time left, how are we actually using these to inform the development of Vega protocol and improve it and make it more robust? One of our key things is in parameter setting. This is choosing good values for the inputs that I mentioned earlier. To do this, we just set up a market that is simulating some real world conditions. We throw some agents in and like a good experiment, we run the same initial conditions with our one value changed and we see how it changes.
00:20:16.518 - 00:20:47.058, Speaker A: And hopefully we've got some metric of how we want that to affect the world and we choose the one that does the best. There's a few difficulties here still. Obviously one of our main ones is that we've got to choose our initial conditions. So really there's a few ways to go about it, obviously. One, we just test a range. We test either simulated prices that conform to some real world fitting, or we just run actual historic prices. The choice here depends on what you're wanting to test.
00:20:47.058 - 00:21:35.040, Speaker A: Some of our things will be testing what happens when the market crashes. And there you can take. There's a few examples, obviously, of crypto markets crashing that we can take and run through. And we've got to assemble our agents as well. So here, this is probably going to be too small to see, but the graphs at the end, the interesting bit. So this is running here one of our parameter tests that I don't trust the Internet, but this loads data from historic Eth prices. We run 20 different price windows, and for each parameter we choose a set and run them.
00:21:35.040 - 00:22:28.046, Speaker A: So here we're just running through, I'm sure it's entirely unvisible, different agents that we've got plugged in. So we run with sort of a curve market maker, a whole batch of random traders, and then here we're jumping through time to show it, sort of simulating stuff. If we jump to the end, we've then got a nice Jupyter notebook to visualize how this impacts the world. So you can see for most things, these parameters are pretty, the same market state means that we're in a nice trading thing. It occasionally drops into an auction, but they're pretty similar. Where we get a difference here is we can see at the end here if I stop it, I don't know if that's visible, but it says received liquidity fees. So what we were tweaking here was a parameter that affects how well market makers are paid, which obviously for a market is a big factor.
00:22:28.046 - 00:23:21.998, Speaker A: You've got to decide, and we have a payout based on how competitively you're placing prices. So we chose here, basically affecting how much the payoff drops off as you move away from best bid or ask. And once we've got this simulation, we can quite easily look at these. We can say how much does a market maker make on varying conditions. We can look at how much they make on a centralized exchange and how much they expect to be making. And then we can reasonably make some choices about what our parameters should be to ensure that prices are good and market makers still make enough money to stay with us so quickly while we still got some time. The RL agents I mentioned earlier, how do they help us? The main way we found, so far, as I say, is testing weird edge cases.
00:23:21.998 - 00:24:25.160, Speaker A: So when you've got your zero intelligence or your optimizing agents, you can really run a lot of tests, but there's a limit to how much market state they cover because they're still doing sort of a small set of actions, they're doing reasonable things. But often we want to put the market in totally unreasonable states. We want to go to weird worlds that you can't reason out. You can't set up an agent to go in each way. So what we do for that is we're running long term RL simulation runs where it's just constantly trying to learn better and better trading, and we'll reinstantiate the agent, get them to try different paths. And the great thing about this is that it's constantly trying to go new ways, learn new things. And through doing this, we've found a number of sort of weird edge cases that you might only hit one day a year running it normal trading, but because we're running 24 hours a day, we can hit them in a day or two and fix these before they become issues on the real market.
00:24:25.160 - 00:25:09.718, Speaker A: So closing out while it took some time, just a plug for main net sims that we've got running. So we're coming up to hopefully releasing a code version that we believe is suitable for production trading. So we're running a few, what we're calling main net sims, which is a week of trading on a testnet with testnet assets, but with a reward pool up of up to about 69,000 baker tokens, which is our governance token. It's worth a dollar or two currently split between the top traders. So if you want to come along and have a go, we're trying to get as realistic a market condition as possible. We've got two more to go. I think the next one starts in about a week.
00:25:09.718 - 00:25:25.770, Speaker A: So you've got just about the right time to get things set up and you go to fairground. WTF? And then we've. Yeah. So thanks very much for your time. This QR code takes you to this presentation. If you want to take a photo of. It'll get you back here.
00:25:25.770 - 00:25:57.640, Speaker A: A few interesting repos. We've got Vegamarket sim, which is the whole complex thing, Vegasim agents, which was the simple one that I showed just there, that's got the one thing to run and then a basic market maker that's a separate sort of agent that runs on a live network and does some semi smart listening to a binance price and quoting on Vega. So you can maybe just spin one of those up and run it on the simulation and see if you win. Thanks very much for your time. I don't know if anyone has questions.
00:26:06.690 - 00:26:10.960, Speaker B: Yeah, you mentioned earlier in your presentation about your API that you built.
00:26:11.410 - 00:26:13.600, Speaker A: API, yeah, sorry.
00:26:14.130 - 00:26:32.374, Speaker B: That I guess helps you avoid some of the difficulties of actually interacting with an actual chain. I'm just curious if you could maybe explore that a little more kind of how that helped you or how you built it or anything you have on that would be great.
00:26:32.572 - 00:27:20.530, Speaker A: So I can show you the repo later, but broadly, it's a big class. That's sort of got methods that just have place limit order, place market order, and then the values on that will be things that a trader cares about when they're placing limit order. So the price, the market, how much you're placing, that kind of thing. And then it converts it to a, being a blockchain, most of the numbers are sort of ints. So it does all this like conversion from floats to ints and it does the communication blockchain and stuff. So the agent just calls a thing called place limit order and doesn't care that it's connecting to a local node, it's connected to a remote node that it's waiting. You can have functions to wait for the block to commit before it gives you back the thing, but the agent itself is just trading on a market for all it cares.
00:27:20.950 - 00:27:26.370, Speaker B: Okay, cool. And so were you using that API in the examples you were showing us, was it being implemented?
00:27:26.450 - 00:27:37.740, Speaker A: Yes. Yeah. So that was all using the API and without going too much into python stuff, it's like a context that you go into and then it sets up all your connections and stuff when you do that.
00:27:38.590 - 00:27:42.540, Speaker B: And is that exclusive just to Vega? It wouldn't work.
00:27:44.030 - 00:27:53.546, Speaker A: Yeah, it interacts with the sort of Vega chain. It uses our rest endpoints, our GRPC endpoints to do the communication.
00:27:53.738 - 00:27:55.520, Speaker B: Okay, cool. Thank you.
00:28:04.250 - 00:28:28.954, Speaker C: Thank you. My question is, when you're training the smart agents, do you train them against an environment that includes other smart agents? So are they all kind of like antagonistically learning from each other or is it kind of a fixed environment that they are trained against and then you kind of set them loose against each other? In the multi agent simulation, we've kind of done both.
00:28:28.992 - 00:28:53.666, Speaker A: Really? Our original was obviously just like one in a thing. We've tried out adding a couple. I guess we've kind of got an advantage in that we don't really care whether they actually make money in the end. Our main thing is that we want them to cause a bit of chaos and send the market in weird directions. So yeah, we can throw a few in and see what they do and observe that just as well as doing one or two. Got it.
00:28:53.688 - 00:28:54.500, Speaker C: Thank you.
00:28:57.650 - 00:29:03.340, Speaker A: Thank you. I think we've got to go, but anyone else who wants questions, I'm happy to answer, I.
