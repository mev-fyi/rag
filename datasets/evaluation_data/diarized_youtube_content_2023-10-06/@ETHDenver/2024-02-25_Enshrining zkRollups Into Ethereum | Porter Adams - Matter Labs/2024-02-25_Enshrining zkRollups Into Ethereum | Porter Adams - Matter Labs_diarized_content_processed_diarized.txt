00:00:08.410 - 00:00:28.070, Speaker A: Hello. Welcome everyone. I'm excited to be talking about enshrining ZK rollups into Ethereum. So my name is Porter. I am a protocol security engineer at Matterlabs. Matterlabs is one of the teams that's building Zksync, which is one of the biggest rollups. We're also the fastest and cheapest.
00:00:28.070 - 00:01:05.066, Speaker A: This talk is not too much about CK sync, it's more just about in general, what is enshrinement and how does that affect the long term future of CK rollups in particular? So this talk is based on a blog post by Vitalik that came out last year. Should Ethereum be okay with enshrining more things in the protocol? Now I'm going to explain what enshrining means. It's kind of a big word. I'm also going to say that word like 50 times during this presentation. So here's the agenda. Enshrining deen shrining future it'll be fun. I think it's a really cool topic.
00:01:05.066 - 00:01:41.642, Speaker A: So what is enshrinement? It's a good place to start. Enshrinement is including something into Ethereum's core protocol. So there are lots of things that happen sort of in the ecosystem around Ethereum. The l two s, all the smart contracts, all the applications, and then there are some things that happen within Ethereum itself. And so the question is always like what should be included into the Ethereum protocol itself, and then what should be left to the smart contract layer, basically. So here's a joke from one of our head of education. Coogan made this meme for me, so I think it fits well.
00:01:41.642 - 00:02:12.786, Speaker A: If you love ZKvM so much, why don't you just incorporate them directly onto the alt one? Now I do. One caveat for this enshrinement is not just for roll ups. I'm going to be talking about roll ups because that's what I'm most interested in. But we could talk about enshrinement for any other application pretty much in the entire space. So for instance, Uniswap. Maybe Ethereum should have built in token swaps for ERC 20 tokens. So theoretically you could enshrine uniswap into Ethereum core and then it would be sort of the default way to swap.
00:02:12.786 - 00:02:57.860, Speaker A: The same way for Ethereum name service, tornado cash. If you wanted to enshrine privacy and actually include privacy at the protocol layer of Ethereum, I'm not sure that one's going to happen, but it would be cool. Oracles are another good example of. It would be nice if we could use the Ethereum validators themselves to sort of be the oracles, because we already trust the Ethereum validators, but I don't trust a lot of the oracle providers. Liquid staking, et cetera. Anyways, today we'll just focus on enshrining layer twos, or roll ups specifically. So first, background, how do l two s roll ups work without enshrinement? So this is the current state of things.
00:02:57.860 - 00:03:32.590, Speaker A: This diagram kind of helps parse out some of the buzzwords. So you start as your user and then making your way through your transaction gets included into a block through the sequencer. There's an unverified block that data is posted down to an ethereum. And then for Zk roll ups, we prove everything with zero knowledge proofs. The proof is also posted down to Ethereum. And given the data and the proof that it's valid, this way Ethereum can keep track of everything that happens in the l two. So using the l two is like the same security as Ethereum.
00:03:32.590 - 00:04:15.150, Speaker A: So this is the picture that we're working with. You don't have to get too much into the whole top half of the picture. What's most important for enshrining is that the only thing that really needs to be on the layer one is posting some data and verifying a proof, which is very minimal. And so if we want to include this, I'll go into more detail later, but if we want to include Zk roll ups into Ethereum, it would not take that much effort, because most of this still can happen to layer two. Not that many changes would need to happen to Ethereum. Current situation what happens if we need to update an l two? This is kind of the motivating problem for this. Ethereum makes changes every couple of months.
00:04:15.150 - 00:04:54.246, Speaker A: They're big upgrades. Similarly, l two s have their own upgrades. Occasionally it's security related, but sometimes we're just trying to keep equivalent with Ethereum. And so if you need to be updating, you can't be using immutable smart contracts. So someone needs to be in charge of who updates the verifier on the l one. And so this is kind of the problem with the current model, is it's not the Ethereum validators, but if we enshrined then the Ethereum validators would be able to update Ethereum itself and the l two at the same time. It's kind of weird to have separate update mechanisms.
00:04:54.246 - 00:05:31.000, Speaker A: It's kind of messy. So in a little more detail, currently we have security council and then multipruver systems. These are kind of two ways to help control the update mechanism. So the multi prover system is something that I'm actually very proud of. We have at ZK sync we are building a SGX trusted execution version of our ZK proof system. So if there happened to be a bug in our ZK proof, we would also do a completely separate implementation inside of SGX. And only when both agree can we actually move the l one state forward.
00:05:31.000 - 00:06:01.002, Speaker A: So this kind of gives us that added resiliency to our protocol. The same way that Ethereum layer one has multiple different client implementations. The multiproover is kind of the equivalent for ZK roll ups. Occasionally, though, we still need to do updates like multipruer. Both might need to be updated at the same time if we make some change to the protocol. And so the way it works is we have a security council. This four of seven is a screenshot from Vitalik's blog.
00:06:01.002 - 00:06:58.980, Speaker A: It's not details on how Zksync Security Council works. This is just a generic picture so you can get the idea, but within shrining. So a lot of people critique the Security council because it's a little bit trusted they get to upgrade the code. What if they upgrade it to something bad? And so even if you do like four out of seven, or say you do like, I don't know, 100 out of 150 people on the security council, you have some crazy massive thing. It's still not as good trusting those like 150 people as it is just trusting the Ethereum core full nodes. So how do roll ups work with enshrinement? So if we enshrine roll ups again, all we need to do is change this base layer down at the bottom, and pretty much you just need a verifier included natively into ethereum. So that's it.
00:06:58.980 - 00:07:42.106, Speaker A: It would be pretty nice. And then when we're making an update, it would just need to be made in each of the different ethereum client implementations, geth and rest and all the others. And this way they would decide, hey, we're going to upgrade to 4844 at this time. And in the exact same step, we're also going to upgrade Zk sync's verifier contract to match the 4844 changes. This way we don't have to have the separate Security Council come in and do the same upgrade at the same time. Cool. So that's kind of what is enshrinement and some basics.
00:07:42.106 - 00:08:24.734, Speaker A: Here's the common arguments against it. One, we want to keep Ethereum core simple. And to keep it simple, you don't want to include too many things into Ethereum core. So in that first list of all the different protocols with privacy and liquid staking, and there's mev stuff, if you start enshrining everything, then you end up with a very large core protocol. And Vitalik talks about Unix philosophy is keep it very minimal and then let the higher layers figure everything else out. Second point on why not enshrinement maybe is give more flexibility instead of having one enshrined option. I'll talk about this in a second.
00:08:24.734 - 00:09:49.338, Speaker A: Why I think this one's a little fake and maybe people not quite understanding what's going on, but there's lots of options whether something's included within the Ethereum core protocol or whether it's done at the smart contract layer, in fact giving developers, well, actually I'll get to in a second. I have critiques on all of these points, and the last critique, which I think is probably the most serious but also the most important, is overloading ethereum consensus. So overloading ethereum consensus means we shouldn't use the ethereum consensus mechanism for too many different things because we don't want to be having arguments all the time on what's the current state of the chain. So it should be pretty rare that we need to have a bug fix or do an upgrade or anything else this gets into. Restaking is kind of a similar idea where you'reusing the validators for other purposes. Enshrinement is like a more direct way of doing that where you're just giving the validators more responsibilities. Anyways, argument for enshrining anyways, keeping Ethereum core simple is nice, but from the perspective of users, it's simpler to enshrine, like you want the whole system to just nicely flow together and there's just like one update mechanism that everyone can use.
00:09:49.338 - 00:10:57.710, Speaker A: And so I think overall, and for the users it's simpler to do this, so could be good to enshrine still again giving more flexibility or having one enshrined option. Sometimes enshrining gives developers more tools to work with. So the current example is account abstraction. On zksync we already have native account abstraction, but on the Ethereum layer one, the user you're facing accounts are sort of privileged in a way, and by enshrining account abstraction you can have all kinds of smart contract wallets and other ways of signing transactions. So it's almost like deenshrining the old user accounts by giving Ethereum developers more options to work with and more flexibility for building wallets and all these other things. So entraining doesn't mean limiting, it can be opening for more options. And then the last critique was overloading ethereum consensus.
00:10:57.710 - 00:11:46.320, Speaker A: If we don't use Ethereum consensus, then we're stuck with security councils or even worse, whatever the bridges are using and all these other random multi sigs. And sometimes you can give multi sigs very nice properties. But really, at the end of the day at least, I really want Ethereum full nodes. Like if you're running a full node at home, you should be able to check everything and check that everything's being done correctly. And I'm in favor of, in general, giving the full nodes the power to do this. I think they're the most trusted group as opposed to any other. If every protocol has to make up their own group of trusted people, it's kind of a mess.
00:11:46.320 - 00:12:25.738, Speaker A: So ZK rollups are well suited to being enshrined. In particular, ZK rollups are finalized as soon as that proof is verified by Ethereum, and the proofs are relatively quite small. I mean, that's part of why ZK proofs are succinct. It's a very cool property. So to enshrine ZK roll ups, we just need an enshrined verifier contract, and it could be a very neutral contract. So there's lots of different l, two s and ZK roll ups, and we could all share one ZK verifier. Obviously it has to be tied to one ZK proof system.
00:12:25.738 - 00:13:07.614, Speaker A: I'm getting into some the nuanced implementation details here, but even if we pick one proof system, you can do a stark proof and then wrap it down into a snark proof. It's not too big of a problem. As long as there's one available enshrined ZK verifier, all the roll ups can use it. If you have multiple hyperchains in the ZK stack, for example, they could all use it at the same time. So you don't have to enshrine like 50 different verifiers for every single one of these chains or every single one of these projects. That's not how it needs to work. You really just need one verifier for every single ZK roll up and the world works, and it's magical.
00:13:07.614 - 00:13:52.230, Speaker A: And that's part of why ZK proofs are amazing. Okay, so future of enshrining ZK rollups as much as possible. I think Ethereum validators should decide everything and also I think we should have more discussions about what should be enshrined. I think there's lots of room here for cool design. I think restaking is sort of taking the narrative over but potentially if some protocol is adding that much value to Ethereum and it's that important that a lot of Ethereum validators are restaking and users are using it and it's doing very well. I think at some point we should just enshrine things into Ethereum. We get better security properties, it's better for the users.
00:13:52.230 - 00:14:19.660, Speaker A: There's a lot of good benefits to enshrining things and ZK rollups in particular I think are very well suited and think it's the future of scaling. So think it's very cool. But if you want to talk more I think that's it. Thank you. I will be over at the booth at the ZK Quest booth. Happy to talk about this anytime or if you want to know ZK details or anything else. Thanks.
