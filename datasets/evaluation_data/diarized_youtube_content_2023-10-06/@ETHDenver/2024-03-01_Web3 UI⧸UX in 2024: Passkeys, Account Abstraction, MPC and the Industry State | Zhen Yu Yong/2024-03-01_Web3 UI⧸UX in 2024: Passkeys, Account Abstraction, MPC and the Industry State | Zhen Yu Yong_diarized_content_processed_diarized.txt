00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:09.090 - 00:00:19.920, Speaker B: Hi, everyone. Welcome to the Trident stage and welcome to ETh Denver 2024. Our next speaker is Zen, CEO of Web three Auth.
00:00:23.440 - 00:00:38.644, Speaker A: Thank you. Hey, guys. Hi, Denver. How's everybody doing? Is it a fresh morning? Is. I'm feeling a little bit jet lagged, to be honest, but glad to be here for sure. The spark whales are a lot cuter this year. I was checking one out.
00:00:38.644 - 00:01:07.768, Speaker A: I'm Zen. I'm one of the co founders of Web three Off. We are the leading wallet as a service company that provides social logins to wallets and via account interaction, MPC and more. We power Nosisafe, Animoka brands and a lot of other both web two and web3 brands that you guys might know and have heard of. Today I'm going to be talking a little bit more about. Let me just get this out. It's a bit weird.
00:01:07.768 - 00:01:33.832, Speaker A: Okay, today I'm going to be talking a little bit more about something a little bit more technical. I'm going to talk about pass keys and basically enabling face touch id on wallets and on your applications so that you guys can go off and try it out and kind of like play around with it yourselves. So before that, just want to do a quick lay of the land.
00:01:33.966 - 00:01:34.650, Speaker B: Right?
00:01:35.100 - 00:02:18.640, Speaker A: Who here knows what pass keys are even in the first place? Okay, most of you all and who here also know what account abstraction is? Okay, also everybody. And also fantastic. That's just perfect. Who knows about web authent? Okay, I'm surprised. Okay, yeah, that's great. Okay, so most of you kind of know what pass keys as a construct are. Pass keys are an implementation of Webauthn, which basically is an interface on your browser or also on some native devices that allow you to use your hardware enclave key pair to sign and authenticate to web two applications.
00:02:18.640 - 00:03:01.890, Speaker A: Now, although Pass keys and the user experience is really nice and seamless, it actually looks a little bit like this. This is me doing it on my Mac. I was just doing it last night. But basically you can see that I just use my touch id on my Mac and I'm basically into the application or into whatever I want to do. Right? So Paskis is also a trend that has been pushed out by large industry giants including Apple, Microsoft and y'all know that already because most of y'all know what Paskis are. Some of you might have felt the experience on applications that you guys already know and love. Coinbase in particular just launched it I think a couple days ago or last night.
00:03:01.890 - 00:03:51.220, Speaker A: Binance has know all of these nice applications have passes. And now today we're going to learn a little bit more about how these are implemented and how also y'all can do that in your application yourselves as well. So first steps, the first thing is digesting, kind of like the flow and authentication flow of pass keys themselves and how that works. So this is just ripped off from the website directly itself. You'll see that there are two main parties over here. The first party is the relaying party server. And this is the server that's looking to authenticate the user, looking to digest and understand and make sure that the user is who they say they are.
00:03:51.220 - 00:04:27.800, Speaker A: And the second one is the authenticator. The authenticator as well as the browser and all that lives on the user's device. And that's the second stakeholder here. Now, the flow of authenticating a pass key is simply the relaying party server issues a challenge. This is not too different from what you think an OTP is or an email, a passwordless email OTP might be. It typically is a string. You can configure it as the relaying party server and you issue that challenge to a user's front end.
00:04:27.800 - 00:05:20.190, Speaker A: Then it's ingested by the javascript on a user's website or on the website that your user has loaded up the web. Authentic API is then called. It hits the browser and then it hits the authenticator. Now, authenticators are actually generalizable. There are lots of different authenticators out there. Pass keys is a form of a authenticator in particular that Google and Apple have implemented on their phones, but I'm not sure. Do you guys know like UB keys? Let's see, UB keys, authenticator app is different, but UB keys and all of these different hardware keys that you might have played around with before, that's also forms of web authentic authenticators as well.
00:05:20.190 - 00:05:57.416, Speaker A: Today we're specifically talking about pass keys. And so the authenticator will basically sign on the challenge that's been issued. This challenge is then propagated upwards. Generally a new polyprivate key pair is generated for each credential that we're talking about signing on. And that's also relayed upwards in step number four. And finally, last but not least, it's relayed through the browser and passed back to the relaying party server where we see server side validation. So how do we add crypto into this? How do we add a connection to the blockchain into this?
00:05:57.518 - 00:05:58.170, Speaker B: Right.
00:06:00.220 - 00:08:12.870, Speaker A: So the way we do it is, and this is the first way to kind of a way to kind of naively implement this would be steps one to five are basically exactly the same, right? But afterwards the public key as well as the credential is relayed via inferior whatsoever on chain. In particular on either a smart contract wallet or an account abstracted setup right on chain and just used the designed object which was received back from the relaying party server is used as verification and it's used as an intention for a user interaction. So we would basically choose to edit the challenge right? In step number one we would instead of just issuing a random nonce or random a random challenge to the front end, we'd actually issue maybe a set of commands, something like transfer 20 USDC. We then go through the same process, sign relay that object through the gas relay in step six and then it goes on chain as verified on the contract. The signature itself is verified on the contract itself. Now this is a naive implementation, a naive architecture of how this would be done. Can anybody kind of spot what's wrong with this implementation just outright? If we were just to do this, if we were just to take a web authentic signature or a pass key signature and put it on chain, can everybody spot something that's wrong? I don't know if we have A-Q-A and mic, but you guys can shout anybody what? Wrong curve? Yes.
00:08:12.870 - 00:09:18.910, Speaker A: Well then it's a wrong curve, but that's why we are actually doing the signature validation on chain in step eight relative to it. He mentioned wrong curve and that's absolutely correct. Well, advanced signatures do not comply with ECDSA or SCCP two, five, six, k one signatures. And therefore we need to validate web authentic signatures specifically on chain. And while that's correct and accurate, that wasn't the problem that I was trying to point out here. Can everybody else see potentially what's wrong in this naive setup? Again, we're just taking a signature and we are relaying it on chain and intending that that is an interaction that the user wants to do. For example, in step one we are saying, hey, you want to send 20 USDC? And we are just relaying that on chain and that acts as verification for the contractor wallet to then move forward.
00:09:18.910 - 00:10:23.676, Speaker A: Anybody? Okay, so the problem is actually replay attacks. In particular. In particular it's replay attacks. The main issue here is that if I choose to try to send ten USDC outwards and a signature from web authent describes my intent to do so. Somebody, once I relay that transaction on chain, this transaction is public, people can see it. People can basically take this same web authentic signature, this same intent and replay it. So for example, if I zen were to send Bob $10 and I actually had $100 in my wallet, Bob could take that same signature and replay that ten times.
00:10:23.858 - 00:10:24.252, Speaker B: Right.
00:10:24.306 - 00:10:59.156, Speaker A: Because it's the web authentic signature that we're verifying on chain, because the curve is not compatible. That describes my intent to send money. How will we fix that? Does anybody have fix to this? Now that we have outlined the issue, what do you say? Yes, that's right. Use a nonce. He said use a nonce. So basically we just have to add a nonce on chain. That describes part of the intent.
00:10:59.156 - 00:11:48.324, Speaker A: It's not unsimilar to the transaction nonce that you might typically implement. So you just add a nonce and this nonce will increment. It can start at zero. And that means that every signature that you sign on is unique because of that nonce. And if it's not signed on an incrementally increasing nonce, it's just not a valid signature. Yeah, and that basically is more or less a very high level interpretation of how one can implement pass keys into an account abstracted setup. So us at web3 off, we've done this with a couple of clients and a couple of companies, and we've made a lot of mistakes along the way.
00:11:48.324 - 00:12:41.572, Speaker A: Pass keys is a relatively new concept, it's a relatively new thing for users to be adopting. And as such in production you actually face quite a few issues here and there. The experience is great in general, but definitely one of the biggest problems is that passkeys themselves, or webauthn works super well on Apple and some of the latest Apple versions. But on other devices, on Windows, on Androids, they don't work so well. There's a lot of different versions of Android, there's a lot of different versions of Windows, a lot of different manufacturers, and there are issues with Pasky's implementations across them. Right. Another thing is definitely there's extra cost for the verification in particular because the chains are not compatible.
00:12:41.572 - 00:13:37.000, Speaker A: You are paying an additional component for pass key verification, which is on chain verification, which can be costly. And then last but not least, so it's about like the last I checked is about $15 to $0.20 on Polygon and quite a bit more expensive on Mainet. And last but not least, there's actually a centralization risk with the relaying party server. So pass keys, as well as web author in general are application scoped, meaning that there has to be a relaying server party issuing the challenge and receiving the challenge as well, in particular, this is required by the domain specification and it's enforced by domain ownership, like DNS ownership. Right. So if somebody basically you are dependent, your pass key is dependent on that specific domain to be used.
00:13:37.000 - 00:14:47.570, Speaker A: And if this domain goes down, they can't steal your money, but you basically can't use your pass key anymore. So some implementation recommendations so that you guys don't commit the same mistakes that we do and some of our early customers did are definitely with pass keys. What you want to do is you definitely don't want to use pass keys in a silo at this point in time. What I mean by this is you don't want to use pass keys as the only signer to your account, extracted wallet or the only signer to your account. Essentially why this is the case is because pass keys are, well, not exactly as robust. There are edge cases, people do lose them and you don't want people losing accounts on your different implementations. No web two implementation that exists today includes just a pass key login into a user account because recovery is an issue.
00:14:47.570 - 00:15:43.772, Speaker A: So the second thing is just to add on that you can use it as an alternative login as the first factor, but you can also use it as a second factor, like a two FA, as per normal. Last but not least, you want to restrict your implementation to compatible browser and OS setups. So for example, Chrome and iOS just don't work with Parskis, you won't be able to access your hardware. Enclave via Chrome Paskis is a very specifically safari integration. So on iOS you only want to allow safari. And if the user is not on safari, you don't want to enable this feature because it just runs into ritroutes. And it is the same on Chrome Android.
00:15:43.772 - 00:16:39.252, Speaker A: You only want to allow Chrome Android or Chrome and Windows edge Chrome as well in particular. Yeah, that's about it. And I hope you guys enjoyed this little snippet. I can take some questions actually, if there's any time for Q A in particular. Anybody has any questions, anything they want to double click on here? Yes sir. So the Coinbase implementation is a very interesting and novel implementation. For those of you who don't know, the Coinbase implementation is they have your main key, right, your main smart wallet that is on Coinbase wallet itself.
00:16:39.252 - 00:17:41.364, Speaker A: And then they basically use pass keys as session keys for dapps and applications to use and sign without having to go back into the Coinbase wallet to confirm each and every transaction. So what they're using pass keys as is, essentially they're using pass keys as session keys for dapps. I think it's a good implementation because even though you lose your pass key, you never lose your original account with Coinbase, you just lose your session key and your session on that application. You can rehydrate it and you can create a new pass key for that DaP. So there's no concerns of loss. I think it's quite an innovative and novel approach of using Paskis and I think it's really cool. Any other questions? All right.
00:17:41.364 - 00:18:13.216, Speaker A: Okay. Yeah, you can find us here. If you guys want to use social logins in your applications, do hit up web3 off. We also have recently released our pass key SDK as well as our Farcaster login SDK. So if you want to do login with Farcaster into your application, do check us out as well. Unfortunately, we aren't sponsoring Eve Denver this year so we have no prizes to offer. But if too Liu, that's it.
00:18:13.216 - 00:18:14.370, Speaker A: Thank you, guys.
00:18:22.330 - 00:18:26.850, Speaker B: Thank you so much. Zen. Stay tuned. Our next talk is at eleven.
