00:00:44.120 - 00:01:11.510, Speaker A: You want to. All right. Can you hear me? Yes. Nice. So are we good to go? Yeah. All right. So first presentation of the day, how are you? Like last night, events like super cool, eh? Eh, super cool.
00:01:11.510 - 00:02:21.540, Speaker A: I salute you who survived because it was tough, tough evening. So let's talk a little bit, a little bit about Webtree like, shall we? What's the first word that comes to the non web three user when they start using web three, and in particular NFT experience, first word is probably frustration because you know any front end developers here? Back end developers, just developers. So big problem with web three is that in web two, non crypto, non nft world we have a lot of stuff. And according to Google, if your page loads less than 3 seconds, you will be bounce rate increases on 32%, which is a lot. And the whole web two world is full of optimizations. We have a lot of stuff there for front end developers. We did, and I am a front end developer in the past we did a lot of stuff to compensate delays, sub milliseconds, delays.
00:02:21.540 - 00:03:19.308, Speaker A: Just this stuff should work fast. And yeah, there are like Google Lighthouse metrics and your page shoes should be almost near real time, otherwise your users, you will lost them. But in web three, for some reason we see this. I hate helloing because I had skeletons and those are skeletons. So every time web two user who is not native to web three who is not native to nfts, every time they load something that is super slow, they just want to throw the computer away because it doesn't work. And why it happens because actually web three blockchain, we paying for the decentralization, we're paying for distribution. There is no one big server who sends you the data in milliseconds, there are plenty of nodes and this is a trade off that we have, we have pretty slow experience for user and that's kind of not good.
00:03:19.308 - 00:04:03.370, Speaker A: And how to solve this problem, you may ask? Well actually this problem solved 20 years ago if you remember something like that. This is like pre web three, pre web two stuff. And back in the days when user asked server hey, can you give me this picture? If the experience wasn't smooth and we had a really bad connection and user wasn't happy, everything was red. What we did back in the days, it was quite simple. You just have cdns, you put servers close to the clients and you're good to go. So you need your content to be as fast as possible. Unfortunately web three and in particular NFT, we will talk about this today.
00:04:03.370 - 00:04:30.740, Speaker A: We don't have it like that because chains are l three chains, of course, are pretty quick, but other chains are not so quick. And we need something to compensate this delay, this decentralization. And we need some engineering solution to make your nfts work fast. What's that? It's of course, indexer. So my name is Jenny Kota. I'm vp of engineering and rival. And let's talk about indexers.
00:04:30.740 - 00:05:00.268, Speaker A: First question is, why do we need an, why, why not just, I don't know, pull your data from blockchain directly, first of all. And the big problem is that on chain data format is not really convenient. For example, one example. So you have your web application, for example, NfT marketplace. You want to show something to user. You want to show picture, nft picture. How you do that.
00:05:00.268 - 00:05:26.864, Speaker A: First of all, you have to run token Uri. You have to ask for token Uri from the smart contract. Then you get the metadata. And in this metadata, you have your image, your attributes and all the stuff. And the big issue here is that only after that you can finally ask for the picture. Of course, it's super slow. And second thing is that the format is not so convenient.
00:05:26.864 - 00:05:53.900, Speaker A: For example, if you want to aggregate attributes, for example, in nfts, for ape nfts, you have a lot of attributes. For example, I don't know, what's the hat, what's the eyes, what's the face and other stuff. And you want to aggregate it to show filters. You want to aggregate it to show everything else. And you need indexer to do all of this. That's the first thing. Second thing is that on chain data is not complete.
00:05:53.900 - 00:07:08.900, Speaker A: There are plenty of other stuff which is off chain. For example, orders, metadata itself, which is, to me, it's a bit strange because how it works, anybody knows how nfts works, like some of the people, okay, so in many chains, not all of them, but your pictures, your actual image data, it's not on chain, it's somewhere else. Usually ipfs. But in NFC blockchain, you store only metadata for that. And what does it mean? It means that just to get all of the information is stored somewhere else, which can cause a little bit of a problem. For example, if someone minted some collection where all of the assets they hosted somewhere else, for example, on your laptop, it went down and someone bought your NFT for two e, and then bam, you closed your laptop. And people cannot get their metadata for marketplaces, for example, it's a big problem when actual image is not accessible.
00:07:08.900 - 00:08:07.560, Speaker A: That's the issue. So some of the marketplaces or many of them. They store all of the metadata, all of the data, actual data in servers because otherwise it can be not accessible anymore. What else? Also aggregation data, for example, floor prices, volumes, et cetera. It's not on chain, of course, some of the chains, they store orders and metadata on chain, which is cool, but not all of them. And if you aim for multichain experience for your nfts, you should consider that. And of course chain API is slow, slow, not like super slow, but it's way slower than web two users used to, because we used to, okay, we open the page, page should be opened in I hope milliseconds, maybe seconds, but not like minutes.
00:08:07.560 - 00:08:45.590, Speaker A: And that's a complicated. So all of this will lead us to, hey, we need indexers. If you want to have nfts in your application, in your wallet or your marketplace or anything that you develop, you need indexer. And many people would say okay, indexer, it should be pretty easy to do, right? You just have your node for a blockchain, you just pull some events. I have a really small node JS JavaScript script and that's it. It should be like couple of nights and couple of beers. Problem? Well, actually it's not.
00:08:45.590 - 00:09:28.572, Speaker A: And is it hard to write good index here? Well, writing indexer is like delivering a talk. You come with some clever thoughts and in the end you just have like, it's just like, it's like kind of hard. It's like a heart. So in the development, something like that. When we tryable just started, it was not a big problem in the beginning. But after half a year, after one year of development, we realized that something is not so easy to do so and why? There are at least three reasons for that. There are of course many other reasons, but why you shouldn't write your indexer and use some providers.
00:09:28.572 - 00:10:00.456, Speaker A: First of all, just imagine we have a blockchain, we have indexer in the middle and you can consider it like a caching server, right? So you have all the blockchain data and blockchain data is the single source of truth. So everything is on chain. It's cool. But you need something in the middle to aggregate and do all this stuff. Biggest issue is that brings delay. And as I said, users, they don't want delays at all. They don't like delays.
00:10:00.456 - 00:10:45.784, Speaker A: Funny stories. It's complete off topic, but actually in some cases users okay with delays. There is an article and I can share it in my twitter. There is an article about perceived speed of the page, of the web page and there was a funny story, it's complete, not really one, two index here, but yeah, in Germany I believe they have cashy machines. So you can get your coins there like metal coins and get your cash. So if you have a lot of coins, you can just press a button, put a lot of, several pounds of the coins and get your cash. And developers of these machines, they did awesome job on refactoring.
00:10:45.784 - 00:11:51.552, Speaker A: And the calculation of all these coins went in like milliseconds, but users were not convinced. They pressed cancel and get all of the coins back because they were okay, I have a lot of kilograms, a lot of pounds of coins, and I don't believe the machine, I don't believe you can count it so quickly. So there's fun facts, but in general, people don't like delays and why it's so why do we have such delays? So for example, we have indexer, we have blockchain, and blockchain emits some blocks, and if it's like 1 minute between blocks, it's okay. Indexer can kick back and relax. Because I mean, just imagine on bitcoin, right, each block can be emitted in hours, at least minutes. So that's not a big deal. But what if your indexer should support l two and l three? And as we can see from many talks from yesterday and today, l two and l three s, they are like de facto standard, or at least they will be there for a while.
00:11:51.552 - 00:12:57.876, Speaker A: What if you have like 200 milliseconds between blocks and you have processed everything and your index is like, oh my gosh, what should I do? Because your code should be faster than the blocks emitted, otherwise you will get a lot of queues and other stuff. So that's a big problem. And also indexer, it's complex machine, right? So it's not just a javascript, three lines of code in our case, that's like a big machine, which also adds some delays. For example, we have some stats from all other indexers and they add some of the delay. For example, 3 seconds, 12 seconds, 4 seconds, 6 seconds, which is a lot because from user experience, when you press mint button or you buying nfts, you want to see result immediately. You don't want to sit there and see the skeleton or like loading indicator, which shows you, all right, you did something, but we don't know the status, it's doing something because we have delays. So delays is a big thing.
00:12:57.876 - 00:13:46.372, Speaker A: And I believe that real time indexers now, they will win the market. So if your indexer is not almost real time, it's a big problem. And every time when you have 12 seconds delay, user usually just break their computer and just go away to some other. Also a big problem is consistency. In the heavy path scenario you have your blocks, index is happy because you have your data which is relevant to blockchain. But what if you have forks? What if some blocks are wrong and in the blockchain that it happened and bam, your state is not the same as you have in the blockchain. You have to recalculate everything, you have to remove stale data and then bam, that's really complicated thing.
00:13:46.372 - 00:14:32.208, Speaker A: And from our experience, again, it's not easy tasks to do. Of course, in seven minutes I cannot share you all the secrets, but you can catch me after that and we can talk about it. Also data. So data itself should be convenient to users. In this example, if you get nft by id, it would be nice to add to this data not only image, not only metadata attributes and everything else, but also for example bestselle order and other optional royalties when it's created, make, price and all of the data. So the more information you give to the consumers of indexers, of your indexers, the better. And again, it's not an easy task.
00:14:32.208 - 00:15:17.920, Speaker A: And orders, big issue with orders is that in many marketplaces, orders are off chain and there is no one single API about how to receive orders. A lot of marketplaces, they do different stuff. And just if you want your indexer to aggregate orders from all over the world, all the marketplaces, it's also like a bit complicated task. So how to do it in the right way? Few examples, few tips. Again, not diving deep because it's 20 minutes talk, but if you want to create your own indexer, you just consider that. So making an indexer, it's like making a sandwich. It's really easy until you want to create a biblically accurate hemp sandwich.
00:15:17.920 - 00:16:10.900, Speaker A: So pretty easy on the surface, but then it's like a bit complicated. So first of all, indexes themselves, they should be as modular as possible. So here's just simple block scheme of the whole solution. And here in this corner, we have indexer. So for example, if you want to index Salana, ZKC and carbitrom or any other chain, it should be in one place because the whole system, and in our case it's like that. We have indexer which talks with the blockchain, all other parts of the system, they don't know about details of the blockchain, particular blockchain. So in our case, indexer indexes everything and then unifies the data.
00:16:10.900 - 00:16:55.520, Speaker A: And here we have a union database, in our case MongoDB, which has united aggregate data, which also not so easy because just imagine you have so different, there are some evm chains, non evm chains, and you have to unify all the data and should be in one format. So orders, nfts themselves, they should be in one format, which is also not so easy. So yeah, first advice is it should be as modular as possible. Second is tech stack matters. I'm not saying that, for example, Javascript is bad, or rust is better, or I don't know any other language. I see benefits in having strict tech stack. In our case it's kotlin.
00:16:55.520 - 00:17:36.412, Speaker A: So yeah, we have Kotlin, we have Kafka, MongoDB under the hood, and elasticsearch. It's super cool for showing you aggregated stuff and you have different slice of information, but tech stack matters. We saw some examples when some of the solutions were failing apart when your code base is growing. And again, from my experience, not about indexers, but still supporting big Javascript, code base is a bit complicated task. Kotlin is easier in that matter. And the third one is measure everything. How to deliver best delay in class.
00:17:36.412 - 00:18:17.500, Speaker A: Of course you have to measure it, but if you measure it just from start to beginning, it's not granular enough. In our case, we measure a lot of things, like how data goes from the blockchain, from scanner to other part of the system. And each and every part of the system is covered with tests and delays metrics. So we can see okay, all right, we have some spikes here, and looks like this part of the system is most crucial. So let's work on it, because otherwise it's just falling apart. You know that your delay is not so great and how to do that. You can tweak all the parts of the system, but you don't see how to measure this result.
00:18:17.500 - 00:18:45.408, Speaker A: So third advice to you is to measure everything. Put logging everywhere. Of course it's a bit of a hassle to aggregate all of the data. And of course there are plenty of logs. Like in our case, we have gigabytes of logs in a couple of hours, a couple of days, and this is complicated. And the fourth advice is that nodes add delay too. Different node providers, they add different delays.
00:18:45.408 - 00:19:32.276, Speaker A: It can be 1 second delay, it can be like 2 seconds, some were better, some not so good. So you should consider it too. So if you're building almost real time indexer, you should think about node providers. You can host your own nodes or you can choose any of the popular node providers but should consider that. And last piece of advice, if you want to build your own indexer, of course UX and developer experience is what matters, what distinguishes you from others. So it should be convenient to run your indexer, to use your API, to use your data structures, to, I don't know, just open the portal and look for documentation. All of this important.
00:19:32.276 - 00:20:11.340, Speaker A: So like wrapping up I would say of course you can build your own indexer. If you're crazy enough and you want to spend a lot of time I would advise you not to do that and just use some of the providers. We launched like two days back our new version of API so if you want to chat about this and use us, just catch me and after that and we can talk about it. But yeah, building indexes is not so easy. There are some things that you should consider and that's it from my end. Thank you very much for your attention.
