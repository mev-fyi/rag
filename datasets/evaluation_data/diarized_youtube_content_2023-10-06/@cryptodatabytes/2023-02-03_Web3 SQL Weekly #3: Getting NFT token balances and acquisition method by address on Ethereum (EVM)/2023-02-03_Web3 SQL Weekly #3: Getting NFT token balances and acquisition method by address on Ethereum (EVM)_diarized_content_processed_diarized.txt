00:00:00.250 - 00:01:00.442, Speaker A: What's up everyone? Welcome back to web3, SQL weekly number three where I break down queries into bitesized bits. This week we're gonna be covering how to get NFT balances, specifically ERC 720 ones, and looking at how much they were paid for and whether they were airdropped, minted or bought. As always, there's gonna be a written version of this video linked in the description below, so be sure to read that and stay subscribed so you can learn more tips and tricks. Let's get into it. So this week's question is listed here in the canny board reminder that you can go to this link and submit or vote on questions for next week. So here we can see we have some query where we are putting in a wallet saying we want Ethereum's chain and we're getting all of these different NFTs, the value that they were required for, how they were acquired. In this case, I filtered for just bought token ID contract address when it was acquired transaction hash of acquisition.
00:01:00.442 - 00:01:27.254, Speaker A: So before we can get into the query, you have to understand what an ERC 721 token is. So if you just go to ether scan, in this case I just typed in Azuki. You can see here there are some total supply. So there's 10,000 Azuki tokens. It's about 5000 holders. Certain number of transfers. The best way to understand these token standards I think is still just go to Opel and Zeppelin and they'll explain here.
00:01:27.254 - 00:02:31.590, Speaker A: These are the functions of ERC 721 contracts and these are the events, right? It's fairly similar to an ERC 20 token in terms of you still have approvals to then do transfers, except instead of amount transfer, you have a token ID, right? Every single token on an NFT contract gets its own unique ID. That's why it's non fungible, because each ID only occurs once. If it occurs multiple times, that's an ERC 1155 contract, which I'm not going to go into today. If you want to play around with the different implementations of ERC 720 ones, go to open Zeppelin's wizard and you can see here. Okay, this is the actual contract like solidity code for an ERC 721. And if I want to add like Mintapal or like voting or a possible contract, we can click through these to really explore all the variations. This is the same thing that we saw done on Zora foundation opensea with their shared storefronts where artists create NFTs just all on the same contract.
00:02:31.590 - 00:03:12.342, Speaker A: This has evolved with like foundation has a collection factory. So artists can own their own collections now. But for the most part, you have to keep in mind, okay, just because contract address has a certain number of token IDs, that doesn't mean that it all represents one collection. There's a lot of different ways for metadata to actually be connected. So that's something you want to look into when you're trying to analyze a specific NFT collection. But that is enough for us to get started with today. Now the main event you're going to have to know is this transfer event where there's transfer from some address to some address of some token ID and that's going to be represented inside the NFT transfers table.
00:03:12.342 - 00:04:20.938, Speaker A: So let's get into it first we need to get all NFT transfers, all right? And I know this is my table because I can search up NST transfer and I can see there's token standards and there's also, let's see, there's also blockchain. So I want to say where blockchain equals. I'm going to do something new this time. I'm going to say chain and token standard equals ERC 720. For chain, I'm going to do list and I'm just going to copy from here, say default Ethereum, right? So this is going to give me all Ethereum transfers of ERC 721 tokens. And I can see here maybe there's like a, from, of who the tokens transferred from, who received it, the ID of the token and the contract address. The first stuff we need to do is we actually need to get the last transfer of every token.
00:04:20.938 - 00:05:11.486, Speaker A: So we can do that by using row number. And so what row number does is. Let me just find. This article is linked in the newsletter, but row number is one of the window functions that essentially allows you to start account based on some ordering and a partition in this case here in this article, they're ordering by power descending so that it counts from one to 15. And then I believe they do a partition by two. In this case they're partitioning by company. So for every single company it's going to row number count descending on power, right? So you can see here, Toyota counts 1234, Honda gets its own one, two, three count.
00:05:11.486 - 00:05:56.958, Speaker A: We want to do the same thing, except we need to partition by the contract address and the token ID. So we're trying to get the order of transfers for every token ID on a contract address. And we're ordering by block number descending. And we also need to order by event index descending. And we're going to say this is last transfer. And why do we need both of these? It's possible that in a single block a token was transferred multiple times. So we want the last event index, meaning the last time the transfer event was emitted in the block for this specific token ID and contract address.
00:05:56.958 - 00:06:47.200, Speaker A: And I'm going to call this with last held as all of this here. So let's start with the next step, which is select all from last held where last transfer is equal to one because the last transfer for specific token ID and contract address is going to be one because we're counting from the last to the first time is transferred, basically. Now this is going to be a lot of data. So let's filter this more. We only want transfers where two is to some address we're interested in. And in my case I'm interested in Deez's address. So I can just do this and let's run this here.
00:06:47.200 - 00:07:30.442, Speaker A: So essentially what this is doing is saying, all right, get me the last transfer for every single NfT out there and then only keep the ones where the last transfer was to an address that I'm interested in. Note that I don't use any quotes or anything here because this is a byte array and byte arrays are like a native type in Dunesql so you don't have to worry about, oh, is this case sensitive or not? I don't have to do a lower or anything. I just have to make sure I basically put it here without quotes. Right. So this is the equivalent of me doing this. All right, so here I can see there's 4796 NFTs that D's currently holds. And this is just the raw transfer data.
00:07:30.442 - 00:08:18.422, Speaker A: You can see here there's a bunch of zeros, which is a mint. And we're going to get into that. And if I just wanted to check things to make sure that the data is what I want it to be, I can look for, let's say he's the one who called the mint. And all of these are transfers to these as address. All right, so it looks like he minted like 40 tokens here. So this is good as a startup, but we want more metadata and we want this to be more focused. All right, what we're going to do is we're going to say select all from last held user.
00:08:18.422 - 00:08:42.340, Speaker A: I'm going to alias it. And first we want the token metadata, right? So token metadata I can find just by searching tokens, NFT. So this contains token metadata for NFTs across all blockchains. I just need to do a left join. It's not an inner join because there might be some nfts. We don't have metadata on. We're going to join on.
00:08:42.340 - 00:10:09.866, Speaker A: The contract address from the transfer event equals the contract address of the token. And I want where the blockchain is equal to chain, which is Ethereum in our case. And the metadata I want from here is I want the token symbol, I want the name and I want the category if it applies. And what's the other data we need? We want to have the transaction hash, we want to get the block number as the acquired block number and we want to also keep the token ID from the transfer and the contract address from the transfer. So this is getting us closer, but what we want last is we want the value and we want if it was gifted, minted or bought. So to get these two columns we need to do another join on transactions where we're matching the transaction hash to the transfer transaction hash. And because I want this to work for all chains, I'm going to replace with chain.
00:10:09.866 - 00:11:10.642, Speaker A: But this is equivalent of me typing Ethereum transactions. So for value I can just take transaction value and divide it by one E 18 as acquisition value native. It's just an approximation, doesn't really apply when it's gifted, but at least for minting a bot it's a good kind of easy approximation of oh, they probably minted it for some amount of ETH or probably bought it for some amount of ETH. So for getting if it was gifted, minted or bought, we're going to use a case one. So case one is basically an if statement and I'm going to say case, when transaction from is not equal to the address of the receiver, then that means that it was gifted. Because this is saying, okay, I wasn't the one who signed the transaction, but I'm still the one who got the token. That means someone else must have sent it to me and we'll do another one.
00:11:10.642 - 00:11:49.002, Speaker A: The transfer from is equal to the null address. So we'll just do null address here. I'm going to copy this here. So if it's from the null address and notice is transfer from, this is not transaction from. Now if the token was transferred from the zero address, that means that it was minted. And you'll notice here I don't do a check of oh, if transaction from is equal to address or not because case one evaluates like sequentially. So if it gets to here, then that means that this was already false.
00:11:49.002 - 00:12:36.394, Speaker A: And else if it wasn't gifted and it wasn't minted, then it has to have been bought. And I'm going to say this is bought and I'm going to end this as I'm going to end this as acquired. How? With this we can run the query and I need to delete this. I'm going to save this as NFT balances user address. So we have our results now and I can filter by bot for example and get the highest acquisition value. And I can see there looks like there's a few art blocked curated NFTs that Deez has bought again. Remember, this is just ETH.
00:12:36.394 - 00:13:23.114, Speaker A: If he bought in something other than ETH then it doesn't show up here. With that, you're done with the query of the week. As a bonus question, try and figure out if you can get a more accurate acquisition cost for bot methods. So to do this, you're going to want to leverage the NFT trades table and you'll have to join on blockchain equals Ethereum or chain in our case. And you're going to want to join on transaction hash as well. And you're also going to want to join on two other columns. I'm not going to tell you which ones, but I'm just going to say that it's possible that a trade in a hash trades multiple tokens, so you want to make sure that that you only have one value per token bot.
00:13:23.114 - 00:13:37.130, Speaker A: All right? So try to figure out what other columns you have to join on. And don't forget to submit or vote on a query for next week. The link is in the description below and I will see you guys next time. Bye.
