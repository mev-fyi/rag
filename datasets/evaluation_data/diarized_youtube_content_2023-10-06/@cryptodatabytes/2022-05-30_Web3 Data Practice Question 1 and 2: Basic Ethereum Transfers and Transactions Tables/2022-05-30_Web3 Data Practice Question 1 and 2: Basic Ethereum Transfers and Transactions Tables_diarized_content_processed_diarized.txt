00:02:54.010 - 00:02:54.880, Speaker A: Good morning.
00:02:55.650 - 00:02:56.560, Speaker B: Good morning.
00:02:57.490 - 00:02:59.040, Speaker A: We are already live.
00:03:01.570 - 00:03:02.320, Speaker B: Really?
00:03:03.170 - 00:03:15.360, Speaker A: So I'm live streaming on YouTube at the same time. Okay. So that's why I can't have my video open on Zoom, because it's like not letting me use my video in two apps at once.
00:03:16.290 - 00:03:19.350, Speaker B: Oh, so if we go to YouTube, we can see you?
00:03:19.500 - 00:03:20.200, Speaker A: Yes.
00:03:20.570 - 00:03:22.406, Speaker B: Interesting, interesting.
00:03:22.588 - 00:03:34.026, Speaker A: I'll put the YouTube link as well. I'm going to figure this out slowly. I feel like this is Zoomer. Boomer. I was trying to set this up and I was like, is this like.
00:03:34.048 - 00:03:39.914, Speaker B: A premium account feature? Like you can stream on YouTube or like a free account can also do the same?
00:03:39.952 - 00:03:45.360, Speaker A: Free account? Yes. You could go and.
00:03:47.490 - 00:03:52.462, Speaker B: Stream too one day when I have a need.
00:03:52.596 - 00:04:17.750, Speaker A: Yeah. Let's see. All right. Yeah, I was going through y'all's practice question answers. They all look good to me, I think. Let's see. Delegation was good.
00:04:17.750 - 00:04:19.320, Speaker A: Is kind of hard.
00:04:20.730 - 00:04:32.970, Speaker B: Yeah, I feel like we decided kind of just like let you take it whenever you get there. We have our own interpretations and then. Yeah, I feel like we just approach it from different angles.
00:04:33.790 - 00:05:12.780, Speaker A: Yes, that's totally fair. Let's see. Okay. All right. Yeah, so I think first part of this was going to be a review for the people on Zoom, but figured might as well start from scratch with the first question again, have the weird. I can never figure out mark now. All right, I have to edit out all this later too.
00:05:12.780 - 00:05:36.722, Speaker A: All right. I can see the YouTube live chat. So for anyone in there who does have questions as I go, feel free to just chat them in. Cool. All right, so practice questions. I think there are ten in here. Like ten main ones.
00:05:36.722 - 00:06:04.474, Speaker A: There's a bunch of bonus ones. I think some of the bonus ones even I would struggle with for a little bit or a lot of it, we'll find out. So don't feel bad if any of the bonus and we get stuck. We'll start with the easiest, which is basically transactions versus traces table. Let's go to doom. I was trying to play with the V two engine, but I think they're still figuring some stuff out. So we're going to stay on V one for now.
00:06:04.474 - 00:06:49.366, Speaker A: Then we'll probably revisit V two in a couple of weeks, I would say. Just because some of the functions that we use, such as like byte and numeric, don't work on Spark SQL. So we're going to have to come back to that. All right, let's just started with easiest. Let me do that. So hopefully if you are here, you've done some sort of wallet transaction before. So you've at least seen like ether scan.
00:06:49.366 - 00:07:35.682, Speaker A: So if I take any of these transaction hashes, and as a reminder, every transaction has its own unique hash and they shouldn't repeat or it's a very low probability of repeating. This would actually be, I think this one that I took is like the very first transaction all the way back in 2015. But even here you can see there's transaction hash. There's a block that it occurred at. There's a from address who is the signer, and then there's a to address who's a receiver. There's some sort of ETH value, some sort of gas fee, and we won't go into gas price and whatnot yet. But the important part is just kind of getting familiar with like, okay, I can see the stuff on ether scan.
00:07:35.682 - 00:08:19.814, Speaker A: I can see the exact same data here in Dune. The only thing you'll notice is that Dune uses like a slash X instead of a zero X, which has to do with how postgres stores, like byte data. So if you're not familiar with SQL, if you're not familiar with SQL, basically all of these addresses and whatnot hashes, I guess they look like strings, but they're technically not strings in the database. So that's something that I think takes some people a bit of time to get used to, of like, oh, I want to do something with this string, but I can't. Or I want to convert it to a number and I can't figure it out and whatnot. Right. So we'll get into that.
00:08:19.814 - 00:09:16.490, Speaker A: But for now, let's just do the very basic, like, all right, how much value is transferred just in this transaction? And the first one, it says one ETH. And the value I see here is like ten to the 18, basically, right? And you might be wondering, well, why is that? And the easiest reason is that you don't have decimals as a concept on chain, technically, right? Just because I think I can't remember the exact reason. But something about decimals makes the offcodes a lot harder to work with. So instead you have big ints or like padding, basically. So everything is to 18 decimals by default, right. So if I wanted to get the actual values, I would divide it by ten to the 18. And that'll give me like one for this column.
00:09:16.490 - 00:09:51.342, Speaker A: Let's say I wanted to look at traces instead. Um, do this. So traces is what's executing kind of alongside a transaction. So some transactions don't have traces. Some transactions do have traces. We'll get into this more. When we look at actual smart contracts, as Adrian says, floating arithmetic, that's what they want to avoid.
00:09:51.342 - 00:10:46.566, Speaker A: Yeah, I haven't gone that deep into the EVM, but I know there is something where it's like, this is a lot harder to do in EVM if you can't cut decimals. Yeah, you all are correct. So traces is more for technically when contracts call other contracts. So if I call a function a smart contract, I guess there technically is a trace for it. But most traces is like, if I called uniswap to swap something and then uniswap calls, let's say I'm swapping USDC to ETH. Then if I called uniswap to swap, then uniswap would call the USDC contract, and that would show up as a trace. Right? And the only other thing that, not only other thing, but the main other thing that shows up as a trace is just the base call where you're transferring ETH value.
00:10:46.566 - 00:11:34.614, Speaker A: Right? So if I looked at this transaction hash, and remember, whenever you select a transaction hash or something from ether scan, make sure you change this from zero X to slash X. Otherwise you're going to errors. So when I look here at this transaction on traces, I can see the value is also one. Right. But you have to remember this value that's transferred in transactions here is only the value transferred from this signer to this to address. Right. And sometimes you're calling contracts kind of like three levels deep that actually does the ETH transfer.
00:11:34.614 - 00:12:54.654, Speaker A: And so that'll only show up in traces that won't show up in transactions. Right. So this first track question is kind of asking you, all right, how do you calculate the difference between transactions block by block over the last week? So the easiest way we can do this actions, and let's just do number some value. We'll continue to use our left comma method. Something else you should have on in dune, if you don't already, is turn on the autist. I'll make your life easier. So for those with less SQl experience, essentially what we're doing here is we're saying, hey, I want the total value transferred per block, right? So you say, basically there's something you're summing by.
00:12:54.654 - 00:13:57.460, Speaker A: So in this case, we're summing over value by block number. And then you say just group by block number. You could add multiple things here if you wanted both block number and who sent that ETH. But we don't need that for now. So I'm just taking the sum across both and then selection value and should probably do a full outer join traces value if you are familiar with joins, they're a little more confusing. But essentially in this case, I'm just saying I want a side by side of both the transactions and the traces by block. All right, so I'm going to do on block block and let's take this.
00:13:57.460 - 00:14:36.750, Speaker A: I know there's an error here but we'll revisit here. We'll revisit it in a second. It here. I'm just renaming the columns, otherwise it's just going to show up as sum sum. If you hear squeaking in the background, that is my dog. All right, so one other thing. I put, I think in the last week here.
00:14:36.750 - 00:15:16.494, Speaker A: Yeah. The main reason for this is just because otherwise this query is just going to time out. So what you want is to filter on block time. Right. And we want only the last week. So postgres has a now function. So I can just take now minus an interval of one week or you could put seven days or I can't do the math, but however many hours, I'm just going to put seven days and hopefully this runs quickly.
00:15:16.494 - 00:15:54.580, Speaker A: I might have to do a lower interval actually for debugging. Let's just go as lower interval. Yeah, that's going to take a while. Right. So why full outer join? Right, so one of the reasons for that is you might have a block that had transaction. Actually no, you can't have a block that transaction value and no traces transferred because if you transfer ETH then there always is going to be a traces call for it. So actually I can just do a left join.
00:15:54.580 - 00:17:18.856, Speaker A: I was going to say you have to do a full outer join and then you need something that's basically like a coalesce. But I don't think we need that complexity. So this looks right to me. And now we're just going to take the difference and. Cool. So now we can see like block by block, what is the difference of traces over transactions of value transferred? And we're just going to use Dune's easy visualizations to basically say, all right, I just want to see the difference over time. And you can basically see by block it's usually transactions that has a higher value than traces.
00:17:18.856 - 00:18:03.432, Speaker A: So that means basically not concretely, but basically people are transferring more from one address to another than ETH transferred in just pure contract to contract calls essentially. And there's some of them with huge differences. You might see like, oh, there's a 7000 e difference here and it might be cool. To then dig into that and be like, okay, what's causing that difference? That should be a bonus question. I will add that as bonus question. Let's see. I cannot read Markdown.
00:18:03.432 - 00:18:45.580, Speaker A: Here we go. Right. So one approach to that is just. All right, let's figure out what block number it was. So this is block 14 86854. I'm not going to remember that. So let's just sort here.
00:18:45.580 - 00:20:04.954, Speaker A: All right, I'm going to comment this. I. And the easiest way of figuring out the difference is just order by. And I can see essentially someone transferred a ton of E. That doesn't add up. Okay, so this is why we dig into things. So we thought we saw 5000 ETH difference, but that block only had a total of 535 ETH transferred.
00:20:04.954 - 00:20:36.440, Speaker A: Right. Which tells me I did something wrong. All right, so let's take a look at that's. Oh, I'm dumb. I was looking at transactions. This is why we label things. It.
00:20:36.440 - 00:21:41.560, Speaker A: I should actually specify this in here, traces. Because if you looked at only, like, which transactions, like why transactions had a higher difference, they probably just find some whales that are transferring a ton of ETH. But if you look at traces difference, you can probably find something interesting at a contract level. Right. So let's just do the same thing. I'm glad I didn't mess up that query. Wait, was I already something on traces? Okay, that looks right.
00:21:41.560 - 00:22:11.720, Speaker A: So let's look at this again. Also, let me just check how many people we have on YouTube. Okay. We have some friends. Nice. Cool. So let's order value again.
00:22:11.720 - 00:23:07.410, Speaker A: And we have three massive transfers of the same amount. Right. So they're all in the same transaction hash. Let's see what happened here. This looks like a swap. Swapping into die no, man. Sometimes ether scan is not fun to look at.
00:23:07.410 - 00:23:57.710, Speaker A: Let's look at what was. This other site was versatile. Let's just plug in here. Okay. This is a lot easier to look at. So who sent this? This is the from. This is the traces.
00:23:57.710 - 00:24:45.946, Speaker A: That's not fun. It. I think this is just swapping into Lido, but I think I'm misinterpreting something here. Oh, swapping out of Lido is what this should be. Yeah. Okay. Yeah, we'll get into this more.
00:24:45.946 - 00:25:21.414, Speaker A: We're looking at ERc, 20 contracts and whatnot. But basically when I was looking here, it wasn't super clear what was going on. Like, I was pretty sure they were swapping from Lido to ETH. But using versatile is a lot clearer in terms of, like, looking at the account balance differences. So I can easily just check through here and see. All right, they definitely had a decrease in curve and they had an increase in ether, basically. And I'm not going to worry about everything in here.
00:25:21.414 - 00:25:52.910, Speaker A: Well, this is interesting, actually. No address went up and down. Wait, how does the null address go down? In balances. I was going to say it went up in balances because. Okay, so if the null address went up imbalances, that means this much of the token was burned. And in this case, if it went down, that means that this much why we. The urine vault ETH was minted, basically anyways.
00:25:52.910 - 00:26:30.816, Speaker A: So that's just a fun way of seeing, like, okay, what was the highest in this case? And if you really wanted, you could dive deeper into what calls exactly caused this. But we won't go that deep in this question. Yeah, that's the first one. I spent longer than that than I should have. All right, looking at question two. And I'll save this. Let me just check YouTube to make sure.
00:26:30.816 - 00:27:11.470, Speaker A: Lost shadow from Singapore. What's up, Jashon? All right, question two. Looking at an example transaction. So I think for this one we picked just one of the more complex swaps that we could find. Basically, we were trying to try to find a transaction with. Yeah, so, yeah, null address means minting or burning, right? So like anytime you mint a token, it's not like the null just itself can have an increase. Increase? Yeah, it comes down to how decodes, but yeah.
00:27:11.470 - 00:27:56.212, Speaker A: All right, I think my wifi cut off for a second there, but I think we're good now. All right, example transaction. So we're going to look at this hash 25 days ago. Um, first thing, which I'm sure you all know how to do by now, is we want to go to the transactions table and just filter on where the hash equals this hash. Right. And if you're ever confused on what is available, then you should just be able to. Oh, no, that's in v two.
00:27:56.212 - 00:28:40.348, Speaker A: Never mind. You'll kind of get used to what column headers are in here. But probably the main things that trip people up is like, oh, what is the column name for either the transaction hash or the block time? Because if you're using the transactions table, it's just hash. If you're using the traces table, it's transaction hash. If you were to use any of these decoded tables, which we'll get into, then if it's a call, then it becomes like call transaction hash. And if it's event, then it's event. Transaction hash, same thing for like, block time and whatnot.
00:28:40.348 - 00:29:03.690, Speaker A: But you kind of get used to it. But you can just assume hash exists on every single table. Right. Like hash is your main way of connecting across all tables. Or when I say connecting, I mean joining. All right, so we're looking at this. We have select all, not select all, but we have select this hash from both.
00:29:03.690 - 00:29:13.870, Speaker A: And we get only one transaction. Which makes sense. You should only get one transaction. And for traces, we should get a ton. Yeah. 204 rows. Right.
00:29:13.870 - 00:29:58.450, Speaker A: So in this case, there's a couple of ways of going about this. When you see something this complicated, you could try to go through internal calls. I have the wrong transactional calls. And you'll see these kind of like, basically a call type and then like a number. And essentially you can kind of think of this as an ordering. Let's say this is like delegate call. Here, let me do it this way.
00:29:58.450 - 00:30:48.128, Speaker A: So in this case, we have delegate call, zero, and the static call, zero, zero. So it's like delegate call is happening at the top level, and then within the delegate call, there's a static call happening as well as another delegate call, which is kicking off another static call, which is kicking off a delegate call. Right. So this was zero. This was basically the first thing to happen in. This is one, which is the second thing to happen. And then you have, and you can see it keeps going.
00:30:48.128 - 00:31:20.750, Speaker A: It goes like, how many levels deep is this? 345678. 910. Right. So basically what's happening is it all kind of rolls up an execution. Right? So this happens and it waits for everything under it to finish, kind of before moving on to like, I'm sure there's a zero two in here somewhere. If you go to the bottom, I just want zero. I don't know if this is going to work the way I want it to.
00:31:20.750 - 00:32:05.980, Speaker A: There isn't zero, zero, two. Okay. So sometimes there's another one after that. Anyways, that's just to kind of give you a sense of why are there so many calls? It's because, oh, I called one contract. Right. So in this case, I called the Insta account v. Two contract, and the function I called on, it was cast and cast, basically.
00:32:05.980 - 00:32:52.460, Speaker A: Then calls basically makes this call and then a delegate call, which calls like a bunch of these other contracts that makes all of these kind of swaps across exchanges and deposits and devolves and whatnot. But it's all chain calls, which is why you see so many of these. And sometimes the order doesn't really matter to you for your analysis, but sometimes it actually does. So it's just good to know what all these numbers mean. And you'll see we basically have just three kind of main call types going on here. You have a delegate call. You got a static call, and then you have a normal call.
00:32:52.460 - 00:33:50.106, Speaker A: Your normal call is kind of like the most basic one. So anytime you're transferring ETH from one address to another, that's a normal call. Anytime you're just calling a function, that's a normal call, right. Basically calls saying, hey, this is something that's going to be able to modify memory or storage. When I say modify memory storage, that means like changing your ERC 20 balances or changing your ether balances, that's going to show up in a call if it's something that's not modifying storage. So it's basically just like, oh, I want to get the allowance of ERC 20 transfers between my address and a contract. Then that'd be a static call because it's just retrieving data basically, and it's not modifying it.
00:33:50.106 - 00:34:13.680, Speaker A: So that's static calls cheaper. And then you have delegate calls. Delegate calls are specific type of forwarding you can kind of think of as like email forwarding. So I send an email to some anon@gmail.com and anon@gmail.com automatically emails, forwards that email to andrew@gmail.com right.
00:34:13.680 - 00:34:28.260, Speaker A: That's kind of what delegate call is essentially, but it's a lot more complex on chain and it has to do with gas saving and whatnot. But we'll probably cover.
