00:00:52.220 - 00:01:34.980, Speaker A: It. Okay. All right. Oh, good morning, everyone. Let me turn this audio off. Happy Sunday. All right, so last week we started looking over pseudoswap.
00:01:34.980 - 00:02:22.976, Speaker A: For those of you who might not been here, they're an NFT amm, right? So basically all that means is that you put a bunch of NFTs into this pair and you custom specify how much the price moves for each token that's traded. So, for example, in this pair, they have four NFTs from, I think this is zero X Mon's collection. And there's like a current price of 17 ETH if I was to buy one of them. And then there's a linear delta of 2.5. So if I buy two, the first one's going to cost 17.75 ETH, the second one is going to cost 19.55 e, and then so on and so forth.
00:02:22.976 - 00:03:43.660, Speaker A: So it's not a constant product price, it's a constant Delta price, basically. So last time when we were looking through this, we got through the creation of the pairs and looking through like, all right, they have three main pool types based off of, based off of what kind of pair you want to show, right? So you could equivalently just list NFTs without putting any liquidity in there. If you want people to only be able to buy NFTs and not be able to sell them, you could only put tokens. If you want to only have people sell, you sell their NFTs but not buy them. Or you can have a trade where it's like, all right, people can go both ways, but besides that, everything else is functionally the same. There's like a little bit of stuff around fees where if it's not trade pool, then you don't have fees involved. And if you use a trade pool, then there's no asset recipient because there's no one for them to send the tokens or NFTs to if it's like a one single sided liquidity pair.
00:03:43.660 - 00:04:32.620, Speaker A: So we put in the malady contracts, I believe, last time, and got to the pairs created and like all the deposits into these pairs. Right. But this time, and I think they're all exponential bonding, which is good here. And last time, the pair contract itself wasn't decoded. So what does that mean? That just means that if you looked at a pair such as like this one on ether scan, it doesn't show up with the contract decoded. Right. Because of that, it also wasn't decoded in dune.
00:04:32.620 - 00:05:43.524, Speaker A: And one reason for this is because they use a minimal proxy standard, which is just like the cheapest way to clone contracts on Ethereum. And the issue with that is etherscan kind of has trouble decoding, or not decoding, but verifying minimal proxy contracts. And an added level of difficulty on top of this is they actually have a base pair, but then wrappers on top of the pair based off of the ERC 721 standard of if they use enumerable tokens or not. So it's like actually five or six different variations. So what I went ahead and did was I went to the repo and I compiled just their pair contract to get the ABI of just the pair. Because for the ones on top of it, there's just like this pair variant formula that's like a pure read formula, not formula function. So we actually don't care about this function at all.
00:05:43.524 - 00:07:16.112, Speaker A: We can just submit the ABI as if all of these different pair wrappers, whether it's ETH, ERC 20, ETH enumerable, ERC 20 enumerable, or just enumerable, we can just pretend they're all the same, basically because the ABI is complete enough, right? So given that I just compiled just the pair, and you can submit just that ABI into dune, because dune, unlike either scan, doesn't check that the bytecode is a one to one match. Instead it just checks like, okay, assuming that this ABI is correct, we're going to decode what we can using this, right? So if you submit incomplete ABI, you'll still get your stuff decoded, but some of the functions just won't be decoded correctly. So that's something to keep in mind. But anyways, we were looking at parameters last time and we saw that there's like a change delta and change spot price. Those are like the owner functions that a pair can call that then emit like delta updated or spot price updated. It turns out that they use spot price updated and delta update as the same events for trades and swaps as well. So it doesn't really matter if there's no way.
00:07:16.112 - 00:08:35.340, Speaker A: Not no way, but it looks the same if someone calls the parameter change or someone calls a swap change, which has its pros and cons. The pro is for spot price updates. I don't have to check two different places for what the spot price has been updated to. The con is later when I'm digging deeper into this data into terms of like, oh, can I use spot price for how much someone decided to pay for a token? And the answer is no, because someone like the owner could have changed a spot price to from one ETH to ten ETH. That doesn't mean that someone bought ten ETH of a token. Right? So that's something to keep in mind for when you're trying to use these events to create something like an abstraction for the dune like NFT trades table later. So we need basically to get the spot prices, the most recent spot price of each of these pairs, and then we need to get the most recent delta for each of these pairs.
00:08:35.340 - 00:09:13.560, Speaker A: So that's actually fairly easy because we don't need these two. All we need is select from, let's see, from delta update Delta. And then let's left join here. Let me double check what the pair does it emit the pair address. Contract address. Right. We can just use contract address, left join.
00:09:13.560 - 00:09:50.660, Speaker A: Spot on. So we're joining on contract address because this is the contract address of the pair. Wait, no, we can't do that. No, that won't work. All right, hold on. Let me make this a little mess here. Select all row number here.
00:09:50.660 - 00:10:34.650, Speaker A: Essentially, we just have to get the most recent from both. So let me just do this. And most recent ones should be at the end. But let's see, I'm forgetting sequel get last row. Do I have to offset? Oh, yeah, that makes sense. All right. But we need a partition by contract.
00:10:34.650 - 00:11:20.894, Speaker A: So, all right, we'll do this the long way. So we're going to do row number, right, which is just, it creates like an index based off of the partitions you choose. So we're going to say for each contract address, order by event, block number is fine. This assumes that no one changed the delta twice in each one, which is a bad assumption. So let's also order by event index descending. So we want both of these. And that'll give us basically like.
00:11:20.894 - 00:12:12.010, Speaker A: All right, what's the most recent delta for any of these? So we're going to take new Delta, divided by 18 decimals is Delta. And we're going to do contract address. And we don't really care about the rest. So we want it such that the most recent one is the first number. Most recent. So what we need is, let's call this one dell. And then we're going to do the same thing on spot price.
00:12:12.010 - 00:13:08.690, Speaker A: So spot price update. Let me just double check new spot price instead of new Delta spot price. Everything else should be fine on spot. Right? So again, all this is doing is. Oh, all this is doing is getting us the most recent spot price. And so I'm going to say I want where when I'm joining these two tables I want where their contract addresses are the same. And.
00:13:08.690 - 00:13:46.590, Speaker A: Hold on, I needed a full outer join. I knew contract addresses are the same. And most recent equals one. And spot most recent equals one. All right, so this is going to give me something that looks a little messy, but you'll see. Oh, some of the tables empty, some of the tables full. So what do we need? We need to coalesce things, right? So coalesce is just saying take the first non null value.
00:13:46.590 - 00:15:08.792, Speaker A: So we're going to do from Delta Coalesce and from spot coalesce as contract address. And then we're going to take Delta Delta, and we're going to take spot spot price. Right. So this is going to give us the most recent spot price in Delta based off of the changes. Why am I seeing the same contract address twice? I've bungled this up. All right, well, I didn't want to do this, but I think I have to. So what's happening is me trying to filter on most recent in the join is a bad idea.
00:15:08.792 - 00:15:56.100, Speaker A: It's not working. It's creating duplicates. So I need to make this messier. Messier where most recent equals one. And then we're going to delete this from here. Now, we should not get all these duplicates. Did I miss parentheses somewhere? Line 21.
00:15:56.100 - 00:16:32.210, Speaker A: Okay, well, this should work, right? No. All right, I have, I didn't put a from. Ah, now that should work. So now we should see that each address only appears once. There are 750 pairs. It looks like some of the spa prices are zero. Wait a minute.
00:16:32.210 - 00:16:59.690, Speaker A: That probably just means there's nothing in them and that this was like a test is my guess. Yeah. When they created it, they just put 0.1 in there. I'm guessing that this is pool type zero, which was just a token, just an ETH pool. So they're just testing here. So that's why that one's zero.
00:16:59.690 - 00:17:42.450, Speaker A: Cool. So now we have most recent spot delta. We have the most recent spot price in delta based off of parameter changes. However, they did not emit delta update when the contracts deployed. Right. So a delta is set on deploy, but that doesn't emit an event. So I actually have to do one more join because of this.
00:17:42.450 - 00:18:33.870, Speaker A: And also I'm going to add this note in here, both cleaning up notes. All right, so Delta, we actually don't care about NFT deposits, which is nice for now, but I'm going to keep that in there. So here we have. Let's take off this join. So here we're going to get the. Oh, wait, why are there so many? Nice. All right, this is going to make it harder, but this will be fun.
00:18:33.870 - 00:19:28.952, Speaker A: These are all the pairs have been created, right, for the malady contracts. And what we're going to do is we're going to join most recent on pair address equals. Here, let me change this naming as pair address equals most recent pair address. And we want pricing type. We want to coalesce. So here's where things get fun. So we want to coalesce the delta from most recent versus the delta from when it was created as Delta.
00:19:28.952 - 00:20:23.250, Speaker A: Right. And the concept here is if Delta was never updated, just keep original, deploy Delta. Right? And we need to do the same thing for spot price update. If the spot price was never updated, then keep original spot price as spot price. Same logic as above. We don't care about contract address and order like the NFT address and the NFT IDs right now. Actually, yes, we do because we need the number of NFTs currently in the pool, which we can't actually do from.
00:20:23.250 - 00:21:07.116, Speaker A: So we could have done like a cardinal or cardinality of this ID array to get how many tokens were in there, but that doesn't give us the most recent. So we also need to get token balance of each pair currently. So that's another table we need to create if we want to simulate depth. So we have delta, we have spot price. And just so I can kind of keep track of all the different pairs, I'm going to keep pair address in here. Do we want to keep. Let's create crater because it might be interesting.
00:21:07.116 - 00:22:22.516, Speaker A: All right, this should work. It does not because it's ambiguous. Yeah, of course we can just use PC for these because we're left joining on PC and all of these should have values. Amazing. All right, so we need the ERC 721 balance of each contract. I've shown ERC 721 balances before where you have to select the transfer of each and basically get like, hey, how much have you sent? And how much have you received from each? Like, oops, I'm going to end this soon. For fungible tokens, you have to say, oh, how much have I sent? How much have I received? Right, but for ERC 721, you can just get the most, like the last person who held the token and that's all you need.
00:22:22.516 - 00:23:43.200, Speaker A: Right, so we need the row number from, is it ERC seven to 21? ERC seven is that transfer where. Right, so first let's do this just so you all can see what I'm looking at where. Contract address. All right, so these are all the transfers for the maladys with the token IDs. Right? So what do I need? I need to get row number over partition by token ID order by the same idea here as last held. We're gonna take all. Wait a minute.
00:23:43.200 - 00:24:44.550, Speaker A: How did I end up down here? Ah, sorry, my brain's clearly not awake. All right, we need this for ERC 720 and transfers. And just like earlier, we need to do a second select to get the most recent. So where last held equals one. So that would give us, for all of their tokens, partition by partition by for all these tokens who last held them. And I forgot to remove the limit. And we're almost done with balances.
00:24:44.550 - 00:25:23.890, Speaker A: All we need is now contract address or. No, not contract. Sorry. We want two as holder. We want array aggregate of token IDs as token IDs held. And we want count of token ID or count as tokens held. And we're going to group by one, which is holder.
00:25:23.890 - 00:26:00.934, Speaker A: And that is how you get ERC 721 balances. Oh, that's token IDs. So someone holds who holds 1600 milades. What the hell? Um. Oh, it's the contract itself. Malady Maker. All right, I don't know enough about this project, but anyways, this is fine.
00:26:00.934 - 00:27:04.170, Speaker A: We're now going to left join ERC 721 balances, bow on bow. What did I call these columns? Token held and bowel token IDs held. I'm going to put this in here. Comment. Okay, all right, we're getting there. We're getting there. So now we can see which pairs actually hold tokens and which pairs don't.
00:27:04.170 - 00:28:03.058, Speaker A: There's only actually, like, what is this? Seven or eight pairs that hold tokens. The rest of them are empty. All right, so to make this easier, I'm going to do where bowel tokens held is not null. Remove pairs where they're. Wait, no, I can't do that. I just realized I need pool type in here because some of these are nfts, some of these are tokens. Oh, lord.
00:28:03.058 - 00:29:06.332, Speaker A: Okay, all right, let me think through. I just realized because there's more pool types, the logic is going to be a little more difficult. Oh, how do I want to do this? So here's what occurred to me. We need the ETH balances for token pool types if we want to get cells. This is still assuming no one's created an ERC 20 pair or. Let me just double check, please. Make my life easy.
00:29:06.332 - 00:29:37.040, Speaker A: All right, there's still no ERC. 20 pairs. Okay, this is doable. This is doable. NFT deposits we don't care about. I'm going to comment this out here for exploration, not. So let's get ETH balances as.
00:29:37.040 - 00:31:18.130, Speaker A: Okay, easiest way to do this is to look at one of my previous queries, ETH balance. Let me go to little nouns and we're going to treasury value and ETH in ETH out for each pair. Oh, this is going to be a little harder. So here was basically, you can look in traces to get how much money or how much ETH has gone in and out of something, but we have more than one pair. So we need to get the ETH balance of each pair if we want to be able to simulate selling. Right. So, okay, just walking through this again, if you only wanted to simulate buying, then you would only need NfT balances.
00:31:18.130 - 00:32:04.420, Speaker A: If you want to simulate selling, you need only ETH balances. We're probably going to end up breaking this into two queries. But for now, let's do it in one, just so we have one place for everything. So we need. Let's see. Do I want to do a join or do I want to do an in? Is kind of slow for scaling. We could do it where exists.
00:32:04.420 - 00:33:11.500, Speaker A: All right, let's do it where exists and exists. Select one from. What did I call it? Pairs created. Pairs created where the trace is equal to pair address and also where pool type equals trade or pool type equals token. So exists is like a faster version of in usually. Let me just double check. I have these pair types, pool types, correct.
00:33:11.500 - 00:34:12.330, Speaker A: NFT trade token. Right. So we need trade for both. Okay, cool. Trade token and where exists trade token. And we want tr two as Holder address from as Holder address and Holder address. He's in left join east out on east in.
00:34:12.330 - 00:35:02.444, Speaker A: Holder address equals out holder address. We don't need to coalesce on address because you shouldn't have sent any ETH out if you haven't received any ETH in. Okay, so now we're going to left join ETH balances. I need to make this cleaner. Ethbol on Ethbol. Holder address equals PC payer address. And now we're going to get, I'm going to comment that out for now.
00:35:02.444 - 00:35:46.924, Speaker A: We're going to get ethbow ETH balance. And I hope this doesn't take too much longer to run. Queued. Why am I queued? All right, let me refresh this. Okay. Oh, group by. Sometimes dune will tell you you're queued and it just means there's like some running error.
00:35:46.924 - 00:36:32.500, Speaker A: So you just need to refresh. But make sure you save your work before you refresh. And okay, let's try this one more time. How long is this going to take to run? It might take too long to run. It might be faster if we figure out the biologic first and then come back to balances. So let's recall the pseudo am bicell simulation full. And I'm going to take a new query and remove.
00:36:32.500 - 00:37:50.370, Speaker A: Well, not remove, but we're not going to join ETH balances on this other query because basically going through traces takes a long time. So this would likely take probably three, four minutes to run at least, if not longer. But NFT balances are a lot faster so we don't have to worry about that. But we're going to let it run just to make sure it can finish simulation. Okay. Right. So in this case, when we're simulating buys, then we only want where pool type equals are we interested in NFT or trade? And NfTballance tokens held is not null for buying simulation.
00:37:50.370 - 00:38:36.898, Speaker A: We only want pools that sell NFTs and currently have liquidity still running. It's still running. So this should give us only nine rows. So just like kind of mentally thinking through this before we start simulating. This one has a spot price of 2.18 ETH and token held is just one. So this is basically you're listing your NFT at 2.18
00:38:36.898 - 00:39:16.510, Speaker A: E. This one has 55 in it, a spot price of zero point 73, and a delta of 1.1. Which means if they were to sell all of them, we would go to 1.1 to the 50 or 55. So the 55th NFt would sell for 1.26. Right. And if we were selling into.
00:39:16.510 - 00:39:43.100, Speaker A: Okay, we don't care about selling into the pool yet. Selling into the pool gets complicated because it depends on how much ETH is in the pool. So we're going to do that second. But let's do buy simulation first. Okay. So let's first simulate. Mmm.
00:39:43.100 - 00:40:49.230, Speaker A: Sorry, I need to think for 1. Second it. Okay. All right, let's do it this way. All pairs cleaned as this. And. Okay, for each of these pools, we need to get.
00:40:49.230 - 00:41:43.820, Speaker A: Hold on. I was thinking about this through the week just to get me mentally through this. What's the easiest way? We basically want row by row, simulate each trade happening, right. So we could create essentially an array with each spot price and delta based on the bonding. Yeah. Okay, let's do that. So price simulation as select all from all pairs cleaned.
00:41:43.820 - 00:42:38.714, Speaker A: Let's have some fun. All right, so we have two price types, right? Case one, exponential. No. When pricing type equals exponential bonding, then, and then when pricing type equals linear bonding, then end as simulated prices we're going to do. We essentially need to generate a series of. Wait a minute. What's the easiest way to do this? Okay, I'll show you what we want.
00:42:38.714 - 00:43:22.150, Speaker A: Right. So for the first one, it's like zero point 73, six, and then zero point 73, six times 1.10.736 times 1.1 times 1.1, yada, yada, yada. So what we need is to generate a series based on tokens held. So generate series from one to number of tokens held.
00:43:22.150 - 00:44:09.090, Speaker A: Okay, hold on. This will make sense, I promise. And increment by interval one as base array. Right? So here, let me take away the CTE for now. Right, just so we're on the same page about what this looks like. Why did this not work? All right, sorry. Generate series automatically unnests.
00:44:09.090 - 00:45:37.810, Speaker A: So we have the base. Now that we have the base, we need to multiply the base by the delta. So in the case of exponential pricing, then we're going to multiply spot price by delta two. Base array. Um, and in the case of linear, we're just going to multiply by base array as simulated prices. Right? So wait, this should be plus. Okay, so just in this case, you can see that for the one with 55 quantity, the ending was the 1.27.
00:45:37.810 - 00:46:27.960, Speaker A: Linear has to be plus. So I messed that up. Are the rest of these all exponential? Yes. Okay, so fixing this to be additive versus multiplicative, we get this should be correct. Now where's linear? Yeah. So this linear one trades out 2.18. So now we actually have all the simulated prices for buying x amount of NFTs from this pool.
00:46:27.960 - 00:47:43.170, Speaker A: So now what we can do is, what's the most fun? To visualize this here, we can already start visualizing this. We can do a scatter of simulated prices. Oops, what's the. Here, I should keep NFT address in? Here's still running. Eleven minutes. Okay. ETH balances.
00:47:43.170 - 00:48:28.148, Speaker A: So the cell simulation, we're going to have to migrate to dune v two. That's not going to run on V one. Okay, so it's kind of an ugly way and we'll make this prettier in a second. But now we can kind of see like the pricing distribution of, of all these pairs. So most of them are between 0.7 and like 1.27. And then there's a few ones that are out here kind of all alone.
00:48:28.148 - 00:49:58.790, Speaker A: Right. So we want to simulate the cost. Right. So hopefully at this point it should be more clear what we have to do. We need a row number, row number over order by simulated price ascending. Um, let's just do all from price simulation order by simulated price. It Cte point times one just so people can read it.
00:49:58.790 - 00:50:32.012, Speaker A: So you've simulated prices essentially now across the whole pool. So there's 91 tokens in total. Buying the 90 oneth one is going to cost you 14.796 E. But this isn't enough. I'm going to actually put this up here. I can't put that up there.
00:50:32.012 - 00:51:33.784, Speaker A: All right. Because we want the cumulative, right. Okay. So row number as NFT depth, liquidity depth, we want simulated price. So now we can get the price based off of how many NFTs you buy. What is the cost going to be and which pool are you buying from? Okay, now would this run into issues if the prices are the same? Because row number would show up the same across. Hold on.
00:51:33.784 - 00:52:21.520, Speaker A: I think there's a conflict issue here where if two things have the same price they're going to have the same row number, which is not what we want. So I think we need a dense rank. Dense rank versus row number. Dense rank is also. Oh no, row number is what we want. So in the case, yeah, that's fine. So let's change this to a bar chart actually.
00:52:21.520 - 00:53:00.000, Speaker A: Um. And then simulate by pair dressing. Oh dude. We need an update to these plots. Enable stacking. All right, so this is the price basically and the pair you're buying from. So let's add one last thing and then we are done for the day.
00:53:00.000 - 00:53:40.618, Speaker A: We're going to take Nft liquidity depth. We're going to take the sum of simulated price over wait order by NFT liquidity depth. Wait, could I have done some of simulated price over order? Yeah, I can. Hold on. We can make this, it's a little less readable though. I don't know if I like that. Because we can sum by simulated price because that's the same thing.
00:53:40.618 - 00:54:24.960, Speaker A: Right. So we don't have to do like a double query as total cost. Um, yes. Here we go. We're going to add one more. We're going to remove the grouping, we're going to add a right axes. We're not going to add a right axis column.
00:54:24.960 - 00:55:18.340, Speaker A: No, that's ugly area. No, that doesn't work. We want scatter of price line of total cost. I will do total cost ETH price per token. And let's do simulated price is on the left, total cost is on the right. Let's do label format is zero point a. Tick format is zero a or zero point.
00:55:18.340 - 00:56:03.396, Speaker A: Um, is this readable? Doesn't look pretty. Hold on, column. No, that's ugly. Let's do area. Why is the opacity so bad? My God, the opacity is terrible. Oh no. Okay, let's just do this.
00:56:03.396 - 00:57:28.920, Speaker A: So we have simulated price per token and now total cost of how much it would cost to buy everything. All right, so let's just do this again. Total oops. Total cost ETH price per token e. Okay, it so we're going to have to do cell simulation next time on Dune v two, which I don't even think the V two engine has pseudoswap, does it? It doesn't. Okay, I'm going to have to message them to see what we can do about that because we're going to have to migrate the query. However, NfT simulated prices for buying X number x for buying some it.
00:57:28.920 - 00:58:23.302, Speaker A: And there we go. We got two simulated prices. So now I should be able to put in. Here's the test of if this works. I should be able to put in Xerox Mons and be able to run the same thing again. And I can cool. There's probably something fancier we can do here about token IDs based off of the most expensive ones, but it's working.
00:58:23.302 - 00:58:50.200, Speaker A: We're done. That was fairly clean. Thank you for sticking with me throughout this. And yeah, next week we'll cover the sell side in V two and probably eventually make an abstraction into the V two repo as well. But enjoy the rest of your Sundays. That was perfectly an hour and I will see you all soon.
