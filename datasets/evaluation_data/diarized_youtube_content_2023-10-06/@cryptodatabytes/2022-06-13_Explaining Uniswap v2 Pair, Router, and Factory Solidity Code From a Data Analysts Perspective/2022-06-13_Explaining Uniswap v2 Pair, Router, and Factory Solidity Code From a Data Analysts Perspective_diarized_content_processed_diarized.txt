00:00:00.410 - 00:01:27.830, Speaker A: It. Let's do something new and fun. All right, let me get the link for this link. Copy it. Okay, I think we are live and working. So I'm going to go over, essentially, we're going to go over the pair, the factory and the router. From a data analyst point of view, when I'm looking at solidity code, basically, what are the things that I look for? Obviously, like event and function calls, right? We already know those are what we're looking for, but normally what's very important is what's happening between those functions or what's happening before and after an event.
00:01:27.830 - 00:02:27.000, Speaker A: And that's context you can only get from reading the solidity code itself. Right. So I'm not saying you have to know how to write solidity, and you have to know all the modifiers and storage optimizations and whatnot, but you do need to know start kind of how to read. Like how in solidity are we calling other contracts? How is the ordering of these events kind of handled? Is there any data encoding happening? Yada, yada, yada. So that's all important. Usually you won't have docs to really look at, or the docs you look at will be completely terrible in this case. Normally where I would start is like, hold on, let's do this on hard mode.
00:02:27.000 - 00:03:19.084, Speaker A: Normally you have a GitHub, which is hopefully helpful. And I like to start with interfaces. So interfaces essentially is like the highest level. Like, what are all of the events and what are all of the functions within this contract? Right. And this is just a very quick way of seeing, like, all right, we have these functions here, which are all like your basic ERC 20 functions, and same with these events. There's nothing surprising here. And then you have these functions and events here, which are just like, all right, these are not normal ERC 20 functions.
00:03:19.084 - 00:04:34.836, Speaker A: These are probably the functions that I'm going to have to get into. Hopefully, most of the times it's obvious from the function name and what's being returned, what the function is doing, hopefully. So in this case, the swap, it's pretty clear in this case that, okay, there's some amount coming in, there's some amount that's going out, and actually don't know what the call data does here. So this would be something where I'm like, I do expect to swap out and in, but I don't know why there's an address and I don't know why there's call data. So that's like, already, like, I would start writing down notes of like okay, these are two things I need to look into. And something else that would be interesting is like, oh, why am I putting both how much I'm getting in and how much I'm getting out? Shouldn't it do the calculation for me? Right, so this is something where I'm like, all right, that would be interesting. Something else you'll note is that these two code blocks are kind of separated.
00:04:34.836 - 00:05:50.332, Speaker A: And you'll see that one of the main differences is these functions up here all have like view in them, or peer, peer is like, how do I explain this? So functions have memory. Like there's memory and then there's storage, right? So storage is like the contract is keeping track of how many tokens are held in the pair. And that's like every time you want to access that or change that, that's a storage thing. But memory is like, if I have a function that adds two numbers together, and I do like function, input a, input B, and then it has in memory like C equals a plus B, return C, then that c is a memory variable, right? So view functions can have memory, but they don't touch storage. Pure functions don't even touch memory. That's always something good to know. So these are going to be like your read functions, the ones where we saw in the previous YouTube video of like, oh, there's a lot more traces calls than logs emitted.
00:05:50.332 - 00:06:45.570, Speaker A: And that's just because it was probably one of these read function, sorry, view functions called, which don't emit logs, right, versus these ones, which are actions that actions should always, for the love of God, should always emit events. Otherwise you just hate your data analysts and your front end engineers and your back end engineers. So yeah, we see there's mint burn swap, skim sync swap is probably the easiest place to start. So I'm going to start there. You could either clone the repo and put into vs code, but I think personally I'm fine with just finding the contract and just using death. I'm sure a lot of people have already seen me do this. Death net.
00:06:45.570 - 00:07:45.308, Speaker A: Sorry, death IO. No code not found. Oh, I'm looking at the wrong thing. Hold on, where's the pair? Where is the pair? This one go to contract, and now we can do. And we have the pair. You'll see that there's this interface which is the same one we were just looking at. And then we have this other interface.
00:07:45.308 - 00:08:19.852, Speaker A: We have libraries, I won't cover libraries. And now we have. Hold on. So basically, all right, just explain what's going on here. This pair contract is using a bunch of other contracts kind of within it for logic or inheritance purposes. So if you use death, you're just going to see it all like what's called flattened. All right? If you ever see flattened mentioned in solidity or whatnot, flattened is just like the file with everything in it.
00:08:19.852 - 00:09:27.910, Speaker A: So death gives you a flattened file unless it can make a cleaner folder structure. And I actually don't know when it does it because sometimes death makes a nice folder structure, but in this case it's just a flattened contract. So I'm going to just scroll down to pair. You can see we have the unison factor in here, but we're not going to look at that. All right, finally, line 306, we've gotten to the pair. You can see it inherits the interface and it inherits the ERC 20 base Unisop token contract, which I think is just like, should just be like a carbon copy of Open Zeppelin's ERC 20. If you haven't heard of open Zeppelin before, please google open Zeppelin ERC 20 API and read through this because you should know everything covered basically in these three, at least these two, like you should have read all of ERC 721 and ERC 20 on opens upload because it's just a great reference and they explain things very well.
00:09:27.910 - 00:10:50.860, Speaker A: Anyways, so here, remember what I was interested in earlier was looking at swap, right? So I'm just going to scroll through, see if I can find swap. We can see Mittenburn, which I don't really have to go into in this case. All right, we have swap here, right? So in this case, I can see there's a require. Okay, so first things I'll check is usually the require just because essentially it requires, like if this require condition is not satisfied, then you're going to get a revert, right? So anytime you see a failed transaction and it says failed error, because XYZ, it's like this is the code that's being emitted and this is the check that failed, right? So this is important because some contracts or protocols have a set of state management. Essentially it's like Avo V three when we're looking at it. Last week, right? It had isolation mode, efficiency mode, basically like a bunch of different rules for what you could borrow and use as collateral. And that's something you would figure out kind of by looking at the requires within swap.
00:10:50.860 - 00:11:55.680, Speaker A: In last week's case, it was the requires within borrow. But in this case, I can see swap. All it's checking is that you're not swapping zero tokens and that there is enough liquidity in the pool for you to make this swap. Because yes, liquidity pools have minimums just so you're not like swapping out the very edges. It kind of goes to infinity. But I can see those are my two requirements if I'm interested. Sometimes I might be like, oh, this drives data questions for me of like how often does a pair hit insufficient liquidity? Right? So I could do query for swaps where the swap failed and the liquidity was below the minimum, right? Obviously liquidity below the minimum is not data I can get from the failed function, but I can get the liquidity at the time of that swap.
00:11:55.680 - 00:12:45.404, Speaker A: And kind of see like, okay, this pair hits minimum liquidity like x number of times a year. And this is how many failed swaps that causes. Oh, that probably correlates to when ETH is crashing like yesterday and everyone's trying to run out of some trade. This is what it's like. Okay, requires are useful for helping me frame more questions and events to look into. Require two design one. So you're going to have two types of checks, right? You're going to have logical checks where it's like you want to make sure that there's enough liquidity and then you're going to have security checks.
00:12:45.404 - 00:14:13.162, Speaker A: In this case, it's just making sure that you're swapping the, hold on, I need to figure out where two is going. Okay, this is going to get confusing because they have their own transfer functions, but basically they're trying to make sure you don't transfer tokens to the wrong place. Because sometimes front ends will make errors or users will make errors where they think like a parameter means one thing and it actually means another, especially when addressers are involved. People put all sorts of wrong addresses in and you don't want to get your token sent to a contract where there's no way of getting your tokens back out because then those tokens are basically locked forever and you've just basically screwed someone. In the case that they swapped like 100K, it's like, oh shit, you can never get that 100K back. And in case you're wondering if that happens, yes, that happens. And there's like someone honestly should create a leaderboard like how much locked or lost liquidity of tokens there is of like ETH and USDC and whatnot.
00:14:13.162 - 00:14:47.098, Speaker A: Because it's in the millions. It's in like the tens of millions. So saying, all right, there's enough liquidity, you're not messing up the address. I'm going to try to transfer these tokens, right. And see if the transfer is kind of making through. And then they adjust the balances of the tokens in the pool. Update and then emit the swap event.
00:14:47.098 - 00:15:40.554, Speaker A: Notice that the event is always emitted last, because normally you don't emit the event until everything has run successfully. But this is now when you start looking at like, all right, I know the basic logic here. What else is being called within this swap? And basically you want to look for anything that has this pattern underscore function with like brackets, right, because those are internal calls. Basically what is internal versus external? External is functions that can only be called from outside of the contract, or internal is functions that can only be called within the contract. So no one else can call update on the pair. Right. Only functions on the contract can call this function.
00:15:40.554 - 00:16:15.762, Speaker A: And that's like a security thing. So I see that the two internal functions in this case is there's an update function, there's a safe transfer function. This one's also important. But I'm going to come back to this later, so I'm just going to look for update. And I can see update is called within sync as well. All right, so here's update. Update is just saying, let me take the balances after the swap and update the price cumulative.
00:16:15.762 - 00:17:12.230, Speaker A: Essentially. Basically you're moving the price curve and then you're emitting a sink, right? So this is basically saying, all right, the prices, like the quantities of tokens in my pool has changed. I need to make sure that the price variables that are read right, remember that price zero cumulative, price one cumulative have their own read function so that people can get the prices. I need to update these prices such that if someone else queries this contract, they're getting the most accurate prices and not the prices pre swap. Right? So this checks out with what we were looking at dune earlier, where for every single swap there was a sync event, and now we know why. It's because swaps call sync every single time. And there might have even been more sync events because you could call sync without calling swap.
00:17:12.230 - 00:17:44.050, Speaker A: Right. There's also the skim function. I actually don't know how to explain this very well, but it's essentially a way of arbitraging things to make. I should know this. Hold on, let me not give a lazy answer. See the white paper skim to protect against. Let me make this bigger to protect against token implications that can update the pair balance.
00:17:44.050 - 00:18:15.036, Speaker A: Two bailout functions in the sync. Yeah. So sync is updating balances skim in case enough tokens to overflow. Oh, okay. I wonder. Okay. It'd be interesting to see how often skim is called, but yeah.
00:18:15.036 - 00:19:28.912, Speaker A: So overflow is this error. Not really error feature of solidity where if you go over the UN 112 max, or whatever the un size is max, then it overflows from the maximum back to one, or not to one to negative, which is one in this case, sorry, it does go back to one. So skim would be there to make sure that if there's some access, we don't overflow and someone can take the excess liquidity to keep things working smoothly. Just from this alone, I can see, okay, we were looking at just swap and the emits of swap for trades. But if we actually look at the solidity, you can already see there's, like, three or four other things that would be interesting to look into. And you can keep going down this path of, like, okay, there's some interface being called where we're getting this, right. Anytime you see, like, I something or some contract function call, this means we're calling some other contract.
00:19:28.912 - 00:20:03.710, Speaker A: And the contract being called is this to address. Right. So, like, interface or any contract objects in solidity, you have to say what address it is that this logic is being applied to. Then the contract is going to say, all right, I'm going to apply this Abi to this address and try to call this function. It doesn't know whether this function exists or not, but it's going to try to call it. So I can take this and try to find it. And I can see, okay, there's some function here.
00:20:03.710 - 00:20:38.882, Speaker A: Unisoft v two. Kali, it's only an interface here. So if I want this function, I need to go through here, and I need to find. Hold on. And I need to find this Kali, I don't see the actual function. Anyways, I'm not going to waste time on that. I know we're really short on time.
00:20:38.882 - 00:21:20.510, Speaker A: I'm going to quickly go over the factory. So that's the pair, right? And then the pair. The main thing there was swap. I'm not going over mint and burn because I think that's more interesting to go through with the router. And I'm going to leave that as practice for you all, is go through this router contract and try to figure out how mint and burn on pair is used. I'm just going to quickly cover how the factory is used here. So, again, this is something you'll see me do a lot, but I'm going to have the factory open in GitHub in case I need to pop around quickly, but I'm actually going to open it in death.
00:21:20.510 - 00:22:41.930, Speaker A: And you're going to see the same thing, right, where we have a flattened contract that imports every interface that we need as well as any other logic that's useful. You can see the pairs in here, right? And you might be saying, oh wait, why is unisoft d two pair in here? And we're going to cover that in a second. But we have, where's the fraction? Hold on, here it is, line 394. You'll see there's a storing of every single pair in what's called a mapping. A mapping is basically like a solidity JSon object or like a python dictionary. You can see this is actually a nested mapping. So if I put in some address, then put in another address, then I would get the pair, if that makes sense, right? So it's like the way to read this would be saying I'm going to put in token zero and I'm going to put it in token one and it's going to give me the pair address if it exists, and if it doesn't exist, it's going to give me zero X.
00:22:41.930 - 00:23:40.488, Speaker A: So mappings is just a quick way of kind of storing maps from. Basically it's usually used for addresses, but you'll remember that emodes for OPA V three were stored in a mapping, right? Like user reserves or user data is normally stored in a mapping. Nfts use mappings. This is probably the most flexible, most used data structure in solidity, and the most annoying ones are where you have mappings of mappings of struct arrays. Anytime I see that I get very upset. But in this case this is simple. Again, this is just like a token search up, right? And you'll see that this mapping is actually used in a get function later.
00:23:40.488 - 00:24:20.890, Speaker A: But we're going to come back to that. So there's a pair created event. We've already looked at this in question three, if you haven't seen that YouTube video, it's on recorded where we go over pair creations. So there's event create, sorry, there's event for pair created. And then there's a function for calling create pair, where you put in two token addresses and eventually they'll tell you where the pair is created. And again, first thing to look at require, always look the requires, right? So this is a security require. It's not interesting for data purposes, it's just making sure you're not putting ETH and ETH in the same contract, because I actually don't know what would happen.
00:24:20.890 - 00:24:56.788, Speaker A: It's making sure that you haven't put the zero address in because there can't be a token at the zero address. And it's checking if the pair already exists. Right? So this is the mapping that we were looking at earlier. And you can see they're putting in token zero and token one and seeing if the address equals the zero address. Because if it equals the zero address, then that means there's no pair. And if it doesn't equal the zero address, then that means the pair exists. Um, this is a crate code.
00:24:56.788 - 00:25:52.216, Speaker A: This has kind of changed a lot over the years. It used to be just like you would say, like new pair equals new uniswap b two pair with like constructor paraphrase. It used to be this. And then this would return address of pair. And then you would have this whole emitted thing, right? So essentially it's saying, create a new pair, store this pair in our get pair mapping, put it into our all pairs array, and emit that the pair is created. And that was the create zero opcode. But we now have a create two opcode.
00:25:52.216 - 00:27:14.690, Speaker A: And one of the reasons that create two is nice is you can actually predict the address that the pair is going to be deployed to before it gets deployed. So it's like, this is useful for fun and purposes, in case you don't want to wait for the contract to be deployed to check what the address is, you can get the address right away using create two opcode. And you'll notice that there's this assembly bracket. And that's because when we're calling opcodes directly, you have to use assembly essentially, right? And if you don't know what opcodes are, you should read Ethereum. You can either read the yellow paper or you can just go to EVM codes. And EVM codes will explain to you every single opcode that exists on Ethereum, right? And you'll see create and create two are both here, right? And they do functionally the same thing. But create two allows you to put an assault which makes things predictable is my naive way of explaining it.
00:27:14.690 - 00:27:42.680, Speaker A: But that's assembly. Again, you'll always see this on assembly. More and more contracts are using assembly. Assembly is much harder to understand than solidity. For example, the new C four contracts from Opensea are all written in assembly. And once I understand that, then I'll do a session on it. But I'm going to be honest, I don't understand how to really read this yet when it gets to more than a few lines of assembly.
00:27:42.680 - 00:28:23.464, Speaker A: So that's the factory created. I wouldn't say there's anything super interesting about it, much less so than the pair. Like factories are just very standard at this point. There's somewhere tracking them. You admit when a factory is created and you check that there's no duplicates and that's it. There are fees I'm not going to get into fees that get complicated here. Yeah, basically assembly.
00:28:23.464 - 00:28:39.164, Speaker A: This is an opcode. This is an opcode. This is an opcode. This is memory load. This is adding I think pair. What was it earlier? This is where my memory kind of fails me. I remember we were looking at pair earlier.
00:28:39.164 - 00:29:54.120, Speaker A: There's something, right? Swap had bytes call data. I should have done this earlier, but I don't know what that's for. Bytes call data. All right, where is data used? Data is used only in this unisoft v two call, which there's an interface for, but I couldn't find. So typically if there's an interface then the actual contract somewhere and it's overwriting the interface with the actual logic. And this is kind of bad practice, but typically interfaces will have a description above that explains what are the variables being called and why and what they do. But Unisoft didn't put it in here, so we have no idea what this does.
00:29:54.120 - 00:30:45.352, Speaker A: So if anyone from unison is watching this, well, they do a good job of MV three, so I can't be a. Let's see if we can find it a functional. Here we go. We're getting somewhere. It's commonly used for flash swap. Your contract that borrows from the pair needs to implement it. The exchange doesn't.
00:30:45.352 - 00:31:45.016, Speaker A: Okay, so here we go. They do have docs on it. I just haven't actually seen this before. Developer resources. So flash slots, flash lens, all that's fairly complicated. I'm not going to explain it today because I actually can't explain it well, but I need to look into it. But this is a composability thing, right? So for most cases, if you're just exchanging on Uniswap, normally, whether that's through the router, through zero, X, one inch or whatnot, data is going to be length zero.
00:31:45.016 - 00:33:13.712, Speaker A: And that's something we could check in the data and like, actually that should be something that I should leave us with is I want, I want the hashes from traces where it. All right, what is the. Essentially we want to check for swaps where data is not zero. So it's swap unit two, five, six. You know what? Hold on. There's a faster way to do this. Ether scad.
00:33:13.712 - 00:34:26.660, Speaker A: This was the pair, and I just look for swap being called, then I could see the method ID. All right, that's faster. We have this where, or actually in this case, we don't need to do this raw. We can do Ave. No, I kind of default to doing everything from raw data, but we should do pair, call, swap. Oh, man, you been forked so many times. So hard to find.
00:34:26.660 - 00:35:26.508, Speaker A: Wait, is it not under this? Okay, hold on. Let's go to V two engine because uniswap should be in here. Uniswap is not in here. Okay, uniswap, pair, swap, select all from. That's probably too many. Let's do limit ten. So here I can see this is swap.
00:35:26.508 - 00:36:35.444, Speaker A: There's mount zero, mount one, data two. I'm going to look for swaps where, um, data length greater than two. One problem here is that, okay, that did work. So there's a bunch of transactions here where the length was greater than zero. I was going to say this might not work because of these dune tables. Just look at where the two address is the contract, and it won't include traces. Oh, wait, no traces are included in here.
00:36:35.444 - 00:37:05.242, Speaker A: Wait. Oh, that's new. Oh, my God, that's amazing. Okay, I was going to say one problem with Dune before was like, traces weren't included in the function tables, but now it looks like it is. That's actually huge. All right, so let's end on this. I'm going to take this transaction and I can see that it's not even decodable, but there's some contract here that's also not decoded.
00:37:05.242 - 00:38:33.520, Speaker A: So this is probably some bot trading bot. And we're looking at potentially flash swaps being used essentially because that data is being transferred or passed along. And this would be something to kind of start looking into of like, all right, what are the most common contracts built on top of the pairs that use data? And how can I understand how this data is being used for flash swaps? That would be the next step. But yeah, again, that's stuff like you would only ever see this if you took the time to look at the solidity and ask, what is this variable? And I don't know what it does. It's something you wouldn't figure out, just being kind of more naively, just analyzing the highest level basic swap or basic deposit. So I'm sure if we looked at average V two, you would see stuff like that as well. Again, I did uniswap V two because I think it's one of the cleanest contracts to kind of look at, and they basically have every single basic pattern you need to know, from factories to routers to ERC, 20 tokens to state management.
00:38:33.520 - 00:39:02.790, Speaker A: And it's not overly complex yet. If you tried to do this with balancer, you get lost, I would say, but try to run through this exercise yourself. Again, looking at the USA V two pair, the V two factory and the router, and that's just good practice to get you ready. Looking at basically any other solidity contract out there, and with that, I'm going to call it a day.
