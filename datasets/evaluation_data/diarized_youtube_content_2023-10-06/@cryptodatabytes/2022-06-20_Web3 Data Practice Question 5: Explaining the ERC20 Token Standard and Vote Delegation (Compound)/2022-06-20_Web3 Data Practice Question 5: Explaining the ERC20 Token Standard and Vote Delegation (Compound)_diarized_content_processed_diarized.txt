00:00:00.570 - 00:01:16.710, Speaker A: It. Let me share my screen. Let's see. Screen two and then tomorrow we can go back to the dollar. All right, let's see. Wait, do my live streams echo two swaps in this case. Hold on, I think some of my live streams echo.
00:01:16.710 - 00:02:30.844, Speaker A: Give me 1 second. Let's see, there's audio input and then there's. Do I turn this off and then there's no echo. Maybe. Hold on, let me check. Let's see, is this echoing maybe. Hold on, let me check.
00:02:30.844 - 00:02:56.672, Speaker A: I can't tell how much of a delay this is running on. Hold on. Testing. Hold on. It seems my mic is really quiet on the stream. Let's see, is this echoing it it maybe. Testing, testing.
00:02:56.672 - 00:03:23.230, Speaker A: I can't tell how much of a delay this is running on. Hold on. Maybe better. Hold on, it seems my mic is really quiet on the stream. Okay, all right, I think that's better. Cool. Let me tweet this out and we should be able to get started.
00:03:23.230 - 00:05:00.460, Speaker A: Okay. Share, copy, tweet it to bear market Twitter. Okay. All right, we have to cut out the first five minutes, but so today is just going to be practice problems. I'm not going to do protocol analysis because there's something else that I'm working on which maybe will be announced in the next month or two. All right, so today's question five. We're finally past the very basics.
00:05:00.460 - 00:05:46.720, Speaker A: I feel like at this point, if you're watching this video, you should be familiar with Ethereum logs, Ethereum transactions and Ethereum traces to the point where you can look at Etherscan, know exactly how that ties into these tables. You know the differences and similarities between data structures across these three. And you should be fairly comfortable working with both. Bytecode like decoding from raw data or using when we're looking at the Uniswap question. Question three. We took a look at the decoded pair, pair, underscore event, underscore swap, like stuff like that. It's like knowing how to combine those decoded tables and the raw tables.
00:05:46.720 - 00:06:55.800, Speaker A: So if you don't know how to do that yet and you're not watching this live, I would then go and watch those previous videos first because we're going to go a bit faster in today's lesson. Start by going to Dune. And how exactly did I specify this question? What's an ERC token standard and how can you find the transfer event or function call? So at a high level we already covered how to get from an event to a function signature or topic, but I will cover that again. But let's go over what an ERC 20 token standard is first. So I'm sure if you've done anything on chain, then you've probably interacted with USDC. You should have used USDC or USDt. At the very least, you've probably used wrapped ether.
00:06:55.800 - 00:07:42.148, Speaker A: These are both ERC 20 tokens. Wrapped ether is a little different in how it's minted because it's like you deposit one ETH to get one wrapped ETH, and there's like a deposit function there that most ERC 20 tokens don't really have. Right? So we're going to use the USDC token. They do something a little fancier on the ERC 20 standard called a proxy. But let's not worry about that. That doesn't change the base standard. I like to use open zeppelin, which is this like.
00:07:42.148 - 00:08:26.662, Speaker A: Well, it used to just be a library, right, where they would have all of the base libraries or contracts you would use to inherit when you're trying to develop anything token related. Now they've kind of expanded into defender and a bunch of other wizard. A wizard is actually a good one that I should share. That actually might be an easier way to explain. Yeah, actually, let's start with just the library. So you've probably heard of ERC 20. You've probably heard of ERC 721.
00:08:26.662 - 00:09:09.010, Speaker A: You've maybe heard of 777 and 1155. If you've played like Axio Infinity or something. Today we're just going to focus on ERC 20. So, ERC 20, you've heard of NFTs. These are fts or fungible tokens, basically, meaning that they can be split into decimals, and there's no way of telling one token apart from another. We'll see this in a later lesson that NFTs have token IDs, but each USDC does not have its own identifier, which is different from the actual dollar, where each dollar actually does have an identifier. So if you're holding a dollar bill, it's technically an NFT.
00:09:09.010 - 00:09:58.150, Speaker A: But USDC is saying, all right, or ERC 20s in general, say there's some total supply of tokens and you're basically tracking the balances of who's holding those tokens at any given time. Right. So first thing you need to know is like, okay, how are balances tracked? I would start there. Hold on, I'm used to their 2.0 docs. Okay, I need to go to the API reference. Sorry, I think I was in the wrong.
00:09:58.150 - 00:10:22.110, Speaker A: Where was it? I was up here. So this is just explaining high level. You want to go to the API section here because it's going to talk about the functions and events. And this is what makes the ERC 20 standard. The ERC 20 standard, basically. Right? Because there has to be some total supply of tokens. So these are all tokens that are not held by the zero address.
00:10:22.110 - 00:11:13.930, Speaker A: Basically there's a balance of account. So that's how many tokens is a certain account or address holding transfer, which is I'm calling transfer and I want to send it to some address with some amount. And then there's transfer from, which is saying anyone can call this and transfer some amount from a sender to recipient. And that's where approval and allowance come in. Right? So let's say basically, okay, anytime a contract is transferring funds such as, like, let's say you're adding liquidity to uniswap. Sorry, not adding liquidity. Let's say you're swapping tokens on uniswap.
00:11:13.930 - 00:12:02.560, Speaker A: You're trying to swap like USDC to ETH. The contract is going to be calling to say, hey, I want to transfer some amount of tokens from me to the pool and from the pool to me. And they typically use transfer from and transfer from will check allowance. So there has to be a certain allowance that an address has between, well, a certain token allowance between addresses. So this starts at zero, and then if the spender approves, sorry, if the sender approves some amount to the spender. So this should say recipient. Technically, you're basically approving some amount to be sent to the recipient at any given time.
00:12:02.560 - 00:12:31.846, Speaker A: So you approve it, the allowance has gone up, and then you can do a transfer from, or anyone could call transfer from and exchange those tokens. So this is like an action that actually moves tokens. This just increments allowance. This is like a get function. So it's like read only. It doesn't do anything. Transfer is basically only called by a sender, whereas transfer from is called by any contract.
00:12:31.846 - 00:13:05.170, Speaker A: Balance of is a get function. Total supply is a get function. Transfer is emitted on both transfer from and transfer. So you don't have to track two different functions, basically. And approval is emitted on approve, as you would imagine. Um, let's see. How deep do I want to go into the actual solidity? Okay, we should go into the solidity part.
00:13:05.170 - 00:14:25.340, Speaker A: So let me go open contracts, tokens, and just for reference if you're on their GitHub, it's formatted the exact same way that all of these. What's it called table of contents. Stuff is formatted, so I know to go into tokens because here they have it under tokens. Right. So I went tokens ERc 20, let's just do ERC 20 here and you'll see that similar to when we were looking at uniswap last week, it's always inheriting an interface. And essentially the interface defines all the functions and events, right. So again, if you're ever looking at contracts and you're trying to get a very quick overview of like, oh, what should be the functions and stuff that I want to know, always go to the interface just because it tells you without all of the logic, like this is an event, what is happening here? Oh, it's admitted to allowance, basically incrementing allowance when approval is called.
00:14:25.340 - 00:14:57.980, Speaker A: Right. Something that is key here though, and I think this is something that confuses a bunch of people, is private functions aren't included basically in, how do I say this? They're not included in the interface. Right. Because an interface is only for other contracts or other EOAs addresses to call an interface. Right. And you're never going to call a private function on an interface. So you'll see.
00:14:57.980 - 00:15:38.740, Speaker A: And I think I covered this last week as well for unison maybe, or maybe it was during the ave, but anytime you see this underscore anything that's like a private function or private variable. So you'll see, for example, when you call transfer, it's calling this underlying transfer function. And that's the same underlying function that's called when transfer from is called here. Where is it? Here. Right. So they do the same underlying thing. It's just that transfer from is called by anyone and transfer is only called by the sender.
00:15:38.740 - 00:16:43.600, Speaker A: Again, I'll keep repeating that because that is important. Um, I think I have this in a later question that you need to check. Basically, I think this is question six, this bonus question here on question six, you'll have to look at this contract and understand what's going on with approvals, because obviously if you approve before transferring, that's extra gas and you don't want to approve every time. So some protocols have you do basically an infinite approval, which is just approving like a max balance to be spent by the protocol, which can be dangerous if there's a hack. So there's whole revoke patterns around this. But I'm not going to go too deep into approvals today. We'll go over that probably next week.
00:16:43.600 - 00:17:45.380, Speaker A: Yeah, definitely next week when we get to this. But what do we need to know, we need to know the transfer function, right? So we go to Kak hash and I have this linked in here. It's the same online tool. Remember that this is case sensitive, right? So it's the function name and then the types without spaces. So function signatures, remember, are just the first eight here. So transactions, that's going to be where two equals USDC and substring data. One to the fourth byte equals this.
00:17:45.380 - 00:18:37.282, Speaker A: Is that eight? That is eight. Okay, let's copy this. Oh, that's uppercase. I want the lowercase version. Let's just take the first ten OD number of heximal digits. I can't count, so I had nine digits there. But I can take any of these transactions and I should be able to see that transfer was called right here.
00:18:37.282 - 00:19:15.178, Speaker A: Transfer is called. They transferred one dollars from the circle address to whoever this is. This is probably one of the first ever USDC transactions where they were just kind of testing out. They're basically just testing out if the USDC is working as planned. Wow, that's four years ago. Jesus, time flies. Anyways, so that's the transfer one, one of the transfer functions.
00:19:15.178 - 00:20:05.780, Speaker A: And remember that there is another one which was transfer from. Let's just find it. And this was transfer from address address Un 256. Right? So I add that address address un 256. And if we take this. Okay, so something that's interesting about transfer from is you should actually look at this from traces, I would say. Oh, taking that count is going to be atrocious.
00:20:05.780 - 00:21:21.370, Speaker A: Transfer from is. No, it's usually an internal call transfer. It's just good to know. Generally I won't look at the numbers, but you should kind of look into this and see which contracts are using transfer, which contracts are using transfer from, and why that might be. I would say that's good practice. But obviously if we're trying to look at all transfers of a token, then the event is faster than doing like a union on both transfer and transfer from. Because if we looked at the contract, well, first of all, they both call the internal transfer function, but more importantly, they both emit transfer from to amount.
00:21:21.370 - 00:22:43.840, Speaker A: And this is going to be the topic that you see the most across the ethereum ecosystem. You're going to see this DDF, and anytime you see this DDF, no matter how good or bad that decoder is, you'll know, okay, that's a transfer event, right? Topic one equals this. Remember, if I do this, then that's going to give me transfers on like literally every single token out there. So I need to do where the contract address that emitted. This was the USDC token, right? Yeah, there we go. Either function which transfer event. All right, so let's save this as PQ again reviewing.
00:22:43.840 - 00:23:36.680, Speaker A: We took a look at this ERC 20 standard from open zeppelin, and we know that the functions that it has to implement are these ones. You'll see that there are extensions. So this is like a base ERC 20 contract where you have to have these in here. And you might be asking like, oh, who decided that? Was that open zeppelin? And no, it wasn't. It's actually ERC 20. This is actually basically anytime you see an ERC, it's something that's officially gone through, like the Ethereum improvement proposals kind of committee. And you can see every ERC that's tried to be passed or has been passed or is in the process of being passed.
00:23:36.680 - 00:24:23.732, Speaker A: And these are all standards that are basically recognized by all developers as like, yes, okay, if we're implementing a certain pattern, we will use this standard. Otherwise kind of break the composability to the system. Sometimes if you don't follow the standards, if you change something in the ERC 20 standard. But let's say you added another thing here where you wanted a boolean of true false for some reason. Functionally you could still have transfer do the same thing, but now the signatures are different. You're not following the standard anymore. Right.
00:24:23.732 - 00:25:27.200, Speaker A: So if you wanted to build on top of it, then you inherit the contracts and then you basically write functions on top of that. And we're about to get into that for compound because if this is your first time seeing standards, you're probably kind of confused. So let's go to ether scan again. Were there any questions? I think everyone should know. Okay, so let's take it up a notch. Comp token. I think they were the first ones to really implement this well, but basically that's not okay, so in their case they don't inherit.
00:25:27.200 - 00:26:20.704, Speaker A: Again, sometimes you'll see the ERC 20 token is usually inherited and then they build off of it. But I think this contract is old enough that they just basically wrote in all of it manually. Right. But you'll see, even though they wrote it manually and it's not inherited from the open Zeppelin library or something, it still implements all of the same kind of required events, functions and variables, right? So it still follows the standard. But what you'll notice is if I go to transfer, this is now a transfer tokens, and you'll notice the variable names are different. That's fine. Variable names doesn't matter.
00:26:20.704 - 00:27:03.810, Speaker A: For a standard, you could call this whatever you wanted, but it's still transfer Azure, un right. That's the important thing you'll see. Now it's transfer tokens instead of transfer, right? So that means you've probably also learned that you could change the internal function, and that doesn't really matter too much. Okay, so now if we look at transfer tokens, a lot of it looks the same, right? There's requirements on where the token can be sent to. Obviously you don't want to just burn it. There's the change in balances. I think their math here is different because solidity math has come a long way.
00:27:03.810 - 00:28:07.340, Speaker A: Let me just check here. Yeah, you'll see that some contracts do different variations of security checks around, moving balances around. And this is actually important. You can't just add or subtract arbitrarily, otherwise you're going to end up with overflow or underflows where people end up with obscene balances or just other dangers. But you'll see, opens upland has like a before token transfer and after token transfer, which actually don't know what that does. Okay, I'm going to be honest, I actually don't know what this hook does. Someone who knows solidity better than me can explain that.
00:28:07.340 - 00:29:53.760, Speaker A: I think what happens in the older version that didn't exist yet anyways. Point being, when you do do a transfer, there's a change in balances, there's an event emitted, and normally that's where things end. But compound has an extra function here which just says move delegates. And essentially what this does is hopefully you've seen delegating votes in some shape or form when you've claimed airdrops. I think it's been around for a while now, but it's expensive to vote on chain, right? It's kind of different with snapshot, but still, it's like if I only have ten tokens and there's like a proposal every week or so, I don't want to have to spend the gas to go and vote. And I probably also don't care to go and vote every single time, so I can delegate my votes based on the balance of how many tokens I have, right? So obviously if I transfer tokens from me to another user, or like if they buy it from uniswap or something, then the delegation has to change as well. So even if I have a delegated someone else already, if I transfer the tokens, it gets kind of redelegated to the recipient and then they can choose to delegate it to someone else again, you can obviously also, like, I'm sure this is callable in a non transfer function.
00:29:53.760 - 00:30:38.662, Speaker A: Yeah, it's callable in this delegate function as well, which is probably called by another public external delegate function. So you can choose to change your delegate anytime. There's also delegating by signatures, which I'm not going to get into because that's a little more complex. But basically the only thing you need to know about delegate by signature is that there's an expiration date, whereas delegate is no expiration date. But point being is I'm kind of getting off track here. You can build off of the ERC 20 standard as long as the base logic is the same. You could add stuff like delegation of votes and whatnot.
00:30:38.662 - 00:30:55.458, Speaker A: That's not included in the base ERC 20 standard. Right. I actually don't even know if it's in their wizard. Hold on, let me see. Is it. Oh, they do. Right.
00:30:55.458 - 00:31:38.480, Speaker A: So you can see here that I can click votes and there is essentially it's going to add in like this votingdelegate. Is it called a library? Sorry, I actually don't know if this is called a library. I think it's a library library. No, it's just abstract contract. Okay. And you can see here that they have probably more streamlined delegation of vote than what compound has. Because remember, compound was like the first to do this and they just did it in like a flattened contract with everything in here.
00:31:38.480 - 00:32:29.594, Speaker A: But if you wanted to deploy something that basically does exactly what compound does, then you would go to the wizard here, click votes and add that in as functionality. If you don't need voting, then you only need to inherit your base ERC 20 function. You'll see there's other stuff here like flash minting and snapshots and whatnot. Or like pausable is like if there's a hack and you want to pause all transfers, then like you could pause all transfers. Is that decentralized if you make the owner multi sig, maybe. But anyways, there's other stuff here that's like more functionality that you're building on top of the standard. But the main one we're going to cover today is just voting.
00:32:29.594 - 00:33:26.026, Speaker A: Right? So the bonus question that I put out here is basically how can we study voting power swings of governance proposals based on token transfers? So if I was to map this out, right, we have Governor Bravo, which is like a contract that I'm going to explain in a second. And there's a few ways of changing votes. Right. You're either delegating the vote, you're either doing a delegate by SiG, or you transfer the tokens. Right. I was looking at the compound docs earlier just to kind of get a faster way of looking at this. So some things to note.
00:33:26.026 - 00:34:12.874, Speaker A: Right. I think, hold on, this is the most important part. When the governance proposal is created, there's a two day review period after which voting, which are recorded and voting begins. Right. And you might be saying, oh, why do you want to lock voting power before the vote starts? And one of the big reasons why is actually flash loans, essentially, I'm not going to go into too much, but there are ways in which you can borrow millions of dollars of a certain token just for one block. It's, the idea is like if I borrow something and return it in the same block, then it's fine. There's technically no risk because there's never a block where I'm not, where the protocol doesn't have the token.
00:34:12.874 - 00:34:47.862, Speaker A: Right. So you could imagine if there's some contentious governance proposal going on, someone might flash loan or basically borrow tokens, use those tokens to vote, and then return those tokens all on the same block. And that could drastically swing voting. Right. And no one wants that. Or there are reasons for why it might be good. But one of the main ones was like, in 2020 be to protocol is like building on top of maker.
00:34:47.862 - 00:36:10.594, Speaker A: They're kind of like, you borrow through them and they manage liquidations. And I think they were doing this proposal to get approval, to not get approval to build on top of them, but get help, I think, anyways. But they did a flash swap and there was like a bunch of like, sorry, not flash swap, flash loan. And there was a bunch of contention around it. So now the more common way around this is there's like a pause period where the checkpoints or voting weights are recorded such that you can't just flash loan things or borrow things just for the sake of voting with it and swinging the votes anyways, right? So for this question, we want to look at the two days directly after each proposal, right? So we have, I should say this is the bonus question. Do we have the governance contract? We can check all of the proposals and then we can check basically within those two days which proposals had the most swing in delegations. Right? So I hope compounds.
00:36:10.594 - 00:36:39.538, Speaker A: Governor Bravo is in here already. Please tell me I'm spelling that right. Okay, hold on. Governor Bravo, delegator. Come on, Dune search. Oh no, there's no way. It's not in here.
00:36:39.538 - 00:37:08.410, Speaker A: All right, this is good practice. So I know that the address is here. I don't know if it's decoded. So I'm going to look from Ethereum contracts where address, I forgot the schema. Hold on. Where, okay, it is address where address equals governor. Bravo.
00:37:08.410 - 00:37:48.070, Speaker A: It is in here. Oh, delegate, right, because it's a proxy contract, they have the delegate, which is called by the delegator. But people decode. Sorry, this is confusing, but when you decode things in Dune, it follows the logic's name, not the proxy's name. So even though they're decoding this address, it's decoded under the logic's name, which is delegate. Right. And again, if you want to verify this, it says Abi implementation is here.
00:37:48.070 - 00:38:48.554, Speaker A: And I can see that this is called delegate. And that's why when I was searching up delegator, it didn't show up anyways, little tidbit thing. And the reason I'm not doing this from scratch is because governance contracts actually are a little complicated in terms of the data that they use. Right. Because here, let me give an example. Event proposal created. Let's look at this transaction, right? So this was a transaction where someone created a proposal.
00:38:48.554 - 00:39:56.210, Speaker A: And you'll see there's like byte arrays, there's string arrays, there's like text values, there's like value arrays. And if I viewed it as just bytecode, I would say this is on the harder side of things to decode. If you're trying to learn how to decode this, I have an example that I haven't done a video on, and I might at some point where I did look at Nounsdao or lil Nounsdao actually. Where's it, here we go. So this is me doing like raw decoding of basically the governor contract. So if you are curious, go and search this one up and look through it. If you can understand what's going on here, then you're pretty much like a raw decoding master in terms of Ethereum events and functions.
00:39:56.210 - 00:40:32.314, Speaker A: But again, that's complicated and that's not the focus of the question. So we're going to start with this decoded contract. And last little side bit. If it wasn't decoded, then you just go to your creations contract, add contract, and put in the address and it would do it for you. But in this case it already is. So we have the created date, right, and this is the start block, that's the end block. I don't know exactly how the days are calculated in the contract.
00:40:32.314 - 00:41:21.250, Speaker A: Hold on. Again, it'd be checking checkpoints, I will say, because remember earlier that you'll see that a checkpoint is written each time that delegates are changed. Right. Hold on, let's look at this event. Do I see this in here again? This is on the comp token. Oh, there's so many forks here. Oh, here we go.
00:41:21.250 - 00:42:50.840, Speaker A: All right, so I want for each proposal, transfers within the first two days of each proposal. How do I want to do this? This now becomes a SQL problem more than a web three data problem. But let's take, all right, let's figure out how many days are in block time, right? So if each block is about 13 seconds. All right, so then seconds in a day. So we not, that times two divided by 15 or divided by 13, that's the number of blocks we want. So our block ranges is, let's see, weight cast block. So we want start block plus as.
00:42:50.840 - 00:43:31.570, Speaker A: So let's just simplify this. We have ID as proposal ID, we have start block and we have weight cast block. And I don't think we need anything else here because the values don't matter. So let me just double check that. This is doing what I wanted to. So we have the start block and the block in which the weights are cast in. And so now what we want proposal shift.
00:43:31.570 - 00:45:11.810, Speaker A: I hope you all are ready to see me struggle for a little bit. Actually don't know the best way of doing this. We could get the sum of votes changed by block and then do a rolling window between start block and weights cast block. All right, let's see how to do some across multiple ranges on point SQL. Here we go. Google to the rescue. Let me close some of these other, we don't need this tab.
00:45:11.810 - 00:46:46.070, Speaker A: Don't need this tab. Don't need these tab. Is that the fastest way? All right, let me just format this table first. Balance, new balance. So let's just do by block number event block number sum of balance minus previous it. Oh my God, I can't spell. Oh, did Dune just kick me out? Dune just kicked me out.
00:46:46.070 - 00:47:36.420, Speaker A: My JWT token expired. Okay, where were we? Previous balance. And I want to take the absolute value of this because otherwise the sum is not going to change as total vote. Wait a minute. No, that's not right. Hold on. Because that's just going to end up as zero if I do that, right? Because for each hash, if I change.
00:47:36.420 - 00:48:11.960, Speaker A: So maybe just divide that by two, I think should be fine. Okay, so if I just did that sum right, then that would give me basically for this transaction, for example, right. Someone moved their delegate from this address to this address. Right. And that's going to move the same amount. So I'm double counting. So I'm going to divide by two by one.
00:48:11.960 - 00:49:29.346, Speaker A: And that should be fine. Here, let's test this by just using this block. To me and I think comp is how many decimals? Decimals 18. Okay, so divide by two and, and times one. That should be fine. Let me just triple check that this is correct. Again, I can't stress this enough.
00:49:29.346 - 00:50:27.520, Speaker A: Anytime you're doing analysis, please check, please check on etherscan that the logic is still tying out because it's very easy to mess that up and you want to check that earlier rather than later. All right, so this is working. So we have changes per block. And again, I would say this isn't the most accurate way because again, we know that delegates change when a transfer happens. So it might just be market volatility that's causing this. And there's ways to dig into this. But at the very least we can now do select all from proposal shift ranges PR.
00:50:27.520 - 00:51:28.100, Speaker A: And then let's do a left join of changes per block. On CPB event block number is greater than or equal to start block PR, start block. And CPB event block number is less than or equal to cast block. All right, so what I'm doing, and I don't know if there's a faster way, but I'm essentially saying, hey, for all the proposal ranges, give me basically all of the blocks that the proposals here. Okay, this will make sense. Let me just take this one for example. So for this proposal ID, it's saying, all right, from, hold on, wait, this will make sense soon.
00:51:28.100 - 00:52:48.620, Speaker A: Let me order by event block, right? So starting from this block, anytime there's a vote change, include that in this range up until whatever the last time there was a change is. And this is less than, right? Oh, hold on, why am I lagging? Okay, so it looks like five, six, seven was the last time that there was a change, right? And just to be sure, I'm going to do where event block number is less than this ordered by event block number descending. So I'm doing this just to check a join correctly. And yeah, that is the last block here. Again, SQL has given me trust issues, so I check that every time that I can. And the reason I limited one here is just because it's so much easier to qa things when you're just doing like one thing at a time. Right? So we know that that works here.
00:52:48.620 - 00:54:13.160, Speaker A: And so now what we can do is proposal proposal ID sum of total vote change as total vote change, order by group by one and order by two, descending. And now that looks like it's working. So I'm going to take this limit off and we can now see for all the proposals where the votes change the most. Right. And to add kind of a little more flavor to this, let's get what might be interesting description. Let's pull in description, and let's pull in event block time and values maybe. No.
00:54:13.160 - 00:54:59.640, Speaker A: So you can start, like, breaking this down further depending on what you want to do. I broke my left comma rule, so we could do description here. I might actually put proposed at description group by one, two, four. I know some people out there are going to hate that I'm doing numbers. I apologize. And now we have it. So total vote change.
00:54:59.640 - 00:55:48.380, Speaker A: I can see that the most contentious vote was deprecating gas market, um, updating a c token implementation, which that makes sense. That had contention open Zeppelin security partnership. This one was actually really cool. So I'm not surprised that Owen's contentious change in proposal thresholds, yada, yada, yada. But yeah. With that, we have now answered the question and that's all we're going to cover today. Let me see if there are any questions.
00:55:48.380 - 00:56:08.370, Speaker A: Do we still have people watching? We do have people. Cute. Yeah. I'll tweet out a summary of this. But that is question five of the practice questions. We are getting into harder stuff. I'm going to say next time.
00:56:08.370 - 00:56:35.428, Speaker A: Some of these bonus questions are hard and I might not go through all of them. I'm trying to see. Yeah, question six is a little harder. Seven, I should probably add something on impermanent loss here and that'll make it harder. And then we're going to get into aggregate tables. And the Nft stuff, I think is actually easier than the ERC 20 stuff. Like ERC 20 tokens.
00:56:35.428 - 00:57:04.820, Speaker A: People have done some crazy, crazy stuff with Nft stuff. I don't think it's been a long enough for us to see crazy like fractionals, like some of the craziest stuff I've seen with NFTs and even theirs is not too complicated to follow. But ERC 20s are insane. Um, and we won't even talk about 1155. But thank you for joining me this morning and I hope to see you all soon. Bye.
