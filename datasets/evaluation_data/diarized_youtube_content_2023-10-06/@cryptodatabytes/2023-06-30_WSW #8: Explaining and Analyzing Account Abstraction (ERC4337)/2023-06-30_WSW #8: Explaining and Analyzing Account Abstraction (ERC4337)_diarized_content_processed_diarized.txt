00:00:00.330 - 00:00:22.942, Speaker A: You. What's up, everyone? Welcome back to Web three, Sql weekly. This week we're going to look at ERC 4377, which is account abstraction. It's a smart contract wallet. I know you're thinking, okay, not another kind of wallet signature scheme. I really don't want to have to make the mental leaps to learn another one. I promise you this one's worth taking a look at.
00:00:22.942 - 00:01:08.862, Speaker A: There's a bunch of improvements here that I think are really going to be critical to scaling the ecosystem. So let's just dive right into it, all right, explaining it like you're five. Let's just walk through what's going on in the wallet space right now. So there's key storage, there's submission of transactions, and then there's account storage. So let's take the simplest example that hopefully you already know is private keys. When you use a private key to sign a transaction and that private key is linked to a single externally owned account, that private key, you've probably generated one from a seed phrase using metamask or rainbow or some other hot wallet. And then if you're more experienced, then you've probably used a hardware wallet like ledger or cold storage to basically store it more securely.
00:01:08.862 - 00:01:43.174, Speaker A: Multi party compute, it's fairly new. Coinbase has it in the Coinbase exchange app, not the Coinbase wallet app, where essentially they share the secret. So it's easier to manage, easier to recover the keys, but it's still a single private key that's being split. Smart contract wallets. You probably think of Gnosisafe when you hear smart contract wallet, but that's just like a separate wallet that's like later on in this curve here, that's controlled by EOA or smart contract wallets. But the individual smart contract wallet that's more well known is Argent. Argent uses social recovery.
00:01:43.174 - 00:02:24.294, Speaker A: So it's, hey, I generate an encryption key on my phone that's then used to verify a transaction to Argent. And then Argent has a relayer, which is basically approved to send things to your smart contract wallet. They can't send things without your permission, but they can send along your signature, and it's called a relayer. That's an externally owned account. And if you look at this transaction, for example, this was an argent wallet transaction, you can see that it's calling an argent module wallet from a relayer account. So let's look at the most recent innovation. Four, three, seven abstracted accounts.
00:02:24.294 - 00:02:51.198, Speaker A: So there's three key things being done here. One is allowing you to use any sort of validation system. So you don't have to use any traditional signature system. You could say validated signature is just one equals one. It's not safe, but you could. And there's already four or five different implementations of the wallet itself. Two is there's a paymaster now, which means that the person sending the transaction does not have to be the one paying the gas fee.
00:02:51.198 - 00:03:36.074, Speaker A: It can be someone else, it can be sponsored, and you don't need some special gas token redemption system either. And the third thing is between the bundler and the entry point, you're now creating this kind of new mem pool where you can have a set of bundlers processing a bunch of submitted transactions. Because if you have abstracted accounts that can send things gaslessly, you have to deal with spam. And the entry point has a lot of other improvements such as aggregated signature validation, just to make it even safer, even faster, to process all of these user operations. They're still transactions, but people call it user operations. You can see it at play here. This is biconomy's bundler, which received a user operation and had to first create an account.
00:03:36.074 - 00:04:43.858, Speaker A: And we're going to go through this. They had to create a sender, which means they created this zero x nine five one smart contract wallet. And then this smart contract wallet was ultimately the one that calls that called a mint. And we're going to look at this in a bit. So my good friend Kofi, he's created a great dashboard on Dune, showcasing ERC four three seven adoption in terms of both accounts created from implementations we know of as well as user operations submitted. So we can see that across all these chains, Polygon is leading here, but there's almost 30,000 accounts created and that's 77,000 user operations submitted. So one thing I wanted to see was to go a step deeper and say, okay, can I see what user operations are being called, what contracts are actually being called by these accounts? But essentially what you can see here is that for Polygon, one of the top contracts here has been called 44,000 times by 21,000 different smart accounts.
00:04:43.858 - 00:05:33.000, Speaker A: This belongs to cap X, which is making token distribution just a lot simpler. LMB, the noise, they're an NFT collection. They used mint, which actually uses account abstraction. And even though there's 7000 owners here, we can see that there were 4000 or so minters that came from smart accounts. So half of the mint base is using these abstracted account or the smart account systems. There's also fantasy, which is a fantasy cricket mobile app that gives out matic rewards and also Dexwin, which is a sports betting app. Kind of the first applications you would think of in terms of okay, now that we've simplified things a bit, who can we attract? I expect to see more and more interesting applications of this going into the future.
00:05:33.000 - 00:06:15.810, Speaker A: Now let's talk about the query itself. I'm not going to dive too deep into it, but essentially what we know is the bundler basically created the sender in this case after handle Ops is called. So handle Ops is called by the bundler, it sends all of the user operations, even if it's from different users, it just bundles it all. And then every single operation inside of there is handled with inner handle op, which says inner handle op is okay, I'm going to pass this along to the smart contract wallet or the smart account. And then the smart account is then going to read what was passed along and say ah, okay, you want me to mint. So then it's going to execute the mint. And that happens about four layers deep into the traces.
00:06:15.810 - 00:07:23.846, Speaker A: So for the query itself, the main logic is I need to go and query the entry point for inner handle op calls, pull out the sender from the JSON of Op info, which is one of the columns, and then I need to join it on traces. And I'm saying, okay, I want the trace where the sender was the from part of the trace. I don't want the delegate calls and I want to make sure that it's only the first trace being called because you have some functions like mint that then also have a callback like on ERC 721 received. I only want when the sender called the mint, which is the first basically subtrace within inner handle op. So if inner handle op appears five times in the same transaction, I want to join on traces and only keep the first call from that sender to a contract within that subtrace. Which is why I have this like greater than three. And I also check that the trace address of each inner handle op is equal to the trace address first element of the trace address on the actual traces table.
00:07:23.846 - 00:08:06.614, Speaker A: So that way I don't end up with any duplicates. The 0.6 entry point was deployed in April, so I just add a filter here to make it faster to work with. You can check the query itself if you want to see how I then made it prettier with joining for contract names and function signatures and all of that. But this is the base logic you need to go and figure out, okay, how do I want to analyze user operations specifically, you might wonder again, why can't we just create a table with all deployed smart accounts and then filter for them in traces? Right now there are many different smart account implementations. We're still gathering them. Eventually we'll have these tables in spellbook to make it easier, and you won't have to work with all of this.
00:08:06.614 - 00:08:44.174, Speaker A: But it's still good to understand how we got this user operation data, because you can't just use transaction from because transaction from is going to be the bundler in this case. Cool. Overall, I'm really excited by this. I think it solves a lot of problems. I'm excited to see what different smart account implementations come out that use more innovative ways of basically passing along validation that don't even require this pseudo private key to be generated. And I will say, if you are working on ERC four, three, seven, wallet or application, I'd love to just chat with you. Please don't hesitate to reach out.
00:08:44.174 - 00:08:54.180, Speaker A: My friends and I, we'd want to chat. We want to help. We're also happy to invest, so don't hesitate to reach out to me on Twitter and with that, I will see you all next week.
