00:01:03.210 - 00:01:58.652, Speaker A: Let me send you tweet and then we'll get started it. All right. Good morning. Good morning. Hope everyone had a good week. Cool. So actually, hold on, let me get water.
00:01:58.652 - 00:03:23.570, Speaker A: 1 minute chat message. Yeah. Hydrate or digit? All right, so last week we went deep into the RC 20 token standard and I think we mainly spent time looking at how basically optionality and features are built on top of the ERC 20, mainly looking at voting. Was there anything else? I think that was the main thing. This week we're going to look into balances and then briefly touch on approval allowance calls. Basically see if we can put together a table that's like protocol and then infinite approval or approval per transaction. Basically see if we can categorize some of those for USDC.
00:03:23.570 - 00:04:14.726, Speaker A: And then we're going to calculate rebases for staked ETH, which is probably going to be the most difficult part. I already spent an hour this morning looking into it just because I was like, I don't think I know this well enough. So that's why you see that there's already a bunch of tabs open, but we will get to that. Let me just put this away for now and we'll come back to it. So the first part should be pretty easy. I think I said that you could use either transfers, there's like this transfer event table, or just going from base logs. First thing we need to do is get the contract for USDC, my wife to go out.
00:04:14.726 - 00:05:01.520, Speaker A: No, we're good. All right, let's see it. Oh, lagging. All right, so we're going to take the US DC contract do new query. We're going to get logs where contract address equals this. Remember you always want the lowercase version, otherwise it won't be found. Right.
00:05:01.520 - 00:05:38.556, Speaker A: All right, and we need the transfer event. Let's just go here, transfer to the topic. Hopefully this should all be second nature to you. Now let's start with this. That's actually going to be a lot. Let's do cancel, cancel, cancel. All right, so we have basically address from address two, I believe.
00:05:38.556 - 00:06:22.190, Speaker A: Yeah. So let's just take from, oops. Membrane. All right, let's do topic two. We only want the last 20 bytes of this. So we're going to go 32 bytes total 1320 bytes from data. It's it.
00:06:22.190 - 00:06:50.740, Speaker A: And I think it's 18 decimals. Hold on. Actually no, USDC is nine. Six. All right, six. That looks right to me. That's an address.
00:06:50.740 - 00:07:44.354, Speaker A: All right, so I usually do this with CTEs for balances. So let's do receive by one it. So this is all transfer that's received. All right. And we need the other way around. We need step and that should be actually, hold on. Topic two was sender.
00:07:44.354 - 00:09:38.992, Speaker A: So this would be topic three, topic two group by and then select all from received. Left join spent s. Again joining spent on received because you shouldn't. This is a good trick question. Is there any address that could have spent more than it received or could have spent first? The answer is yes, but I'll give a moment on R user and let's do all s. It actually probably take like 20 seconds. And so summing this across all of logs is obviously going to be slow.
00:09:38.992 - 00:10:41.960, Speaker A: Right? So what dune has nicely done for us in abstractions is there's an ERC 20 table or schema basically, right? So if you go to Ethereum, you find ERC 20. You'll see there's a tokens table which has all of the main or like top addresses with the symbol and decimals. But there's also more importantly, ah, I just don't know where their ERC 20 transfer is. Transfer. All right, maybe that's not exposed, but there's a faster way to do this. All right, if I wanted to finish this, I need r dot amount minus coalesce zero. Right? Because it could have spent zero as balance.
00:10:41.960 - 00:11:53.090, Speaker A: So that would give me the balances for using logs. But we can also use ERC 20. ERC 20 event transfer. All right, so let me open a new query for this. While this runs from equals USTC address. Let's do. All right, so you can see that in this table, it's like nicely decoded from to valley already.
00:11:53.090 - 00:13:14.270, Speaker A: And it's in the same kind of schema format as like all the other auto generated tables. Right, so this exists for ERC 721 as well. But if we now did balances here, this would be a lot faster. All right, so received as and it'd be a lot faster because it's only transfer versus every event on ethereum. I want two user sum value. And remember it's six decimals it from left join spent Sr user equals s. Everything else is the same.
00:13:14.270 - 00:14:51.290, Speaker A: So I can just take this, pop it on over and you'll see this runs much faster or should. Ah, actually surprised this is taking so long because I know, let's see, just pasting it in there. This is q six because I have like all balances query that used to run pretty quick. Hold on, let's see. Yeah, this query runs literally like right away. And yeah, if you want to search up this query? You can either search by this or copy the link here, but this one is just like all of your ERC 20 balances. And the only difference is I'm not filtering on.
00:14:51.290 - 00:15:43.664, Speaker A: Oh, of course this is going to be faster. I'm only filtering on one from address. This is getting all of your token balances, right? So if I wanted to look at like, wonder if you can search up Vitalik. Okay, I don't think you can. Let me just look at the last person who transferred DOdC from this poor person that we're using as an example. Okay. They only held USDC.
00:15:43.664 - 00:16:21.974, Speaker A: They don't hold anything else. Wow. I'm actually really surprised it's taking so long. But I guess USDC has a lot of transfers, so that's not too surprising. Why is this? I saved, but that is how you get balances for USDC. I'm trying to think if there's a way to make it faster. Maybe we'll just try this on the new engine and see if it's faster.
00:16:21.974 - 00:17:28.136, Speaker A: All right, so let's do this. Let's take a new query. Let's go to V two. There are balances tables in V two. Hold on, are these filled it? We will not be using the V two engine. The query line is a little too long right now. Ah, well, it looks like there is already a balance of seeable in V two, so it's kind of cheating.
00:17:28.136 - 00:18:33.086, Speaker A: But you could use this and the indexing should be faster on V two. So you could rewrite this just using like, let's see, where were we doing this? So instead of ERC 20 dot, ERC 20 would be ERC 20 dot. Or use one feed two. Wow, there's 92 queries in a queue. Okay, well, we can't see the results, but you're just going to have to trust me that this works. We can just let this run in the background and I'll work on some other stuff. So approvals before transfer calls.
00:18:33.086 - 00:19:32.882, Speaker A: I think the easiest way to do this is we need essentially three steps. We need getapproval calls and get amounts approved. Check for only approval calls on addresses in Ethereum contracts. Namespace get table with schema name namespace approval approach. All right, where approval approach is either infinite or small. I think that's a good way to start. So I don't think there's an ERC 20 approvals table.
00:19:32.882 - 00:20:25.510, Speaker A: So we're going to need to do that manually here. Let's say open zeppelin API. Approve is address U and 256 or hold on. Address. So approval address. So there's our approval emit. All right, so let's take all, select all from Ethereum logs where contract address equals.
00:20:25.510 - 00:21:19.170, Speaker A: Let's see, we want the USDC address again, just this one. And topic one equals this. Let me do ten just to be sure. All right, let's cancel this one. The queue is definitely, we're not making it out of that queue. All right, so we have this just to be sure. Let's check the transaction hash.
00:21:19.170 - 00:21:50.312, Speaker A: All right. Yeah, that looks right. Let's do left join. Actually just a join. So this is an inner join on Ethereum contract. C contract stress. Oh no, I can't do that.
00:21:50.312 - 00:22:30.100, Speaker A: I need to add another join. Transaction. Transaction two equals. Yeah, that's fine. Transaction two equals C dot contract address. Right, so let's do l dot and then let's do l dot data. L dot transaction hash.
00:22:30.100 - 00:23:06.984, Speaker A: And then C contract address. Maybe it's just C address. All right, so we have the transaction hash and we have namespace. Okay, yeah, transaction two doesn't work because I'm being dumb. All right, going over approvals again. Right, so approving is you're approving someone to spend. Right.
00:23:06.984 - 00:23:48.728, Speaker A: And you're calling the USDC contract to spend. You can't have an approval called through like an internal call because it has to be like message sender. I believe message sender means it has to be the signer of the transaction, passing it along. Yeah, I guess you could do a multi call. But anyways, so we actually don't want to join by the transaction. We want to just check the address suspender here. And that is topic two here, which should be topic three in our case.
00:23:48.728 - 00:24:46.710, Speaker A: So let's get rid of this. And we want substring topic three and we don't. Just the address. Right. All right, now we're getting somewhere. Let's take, I think there's a couple of ways of doing this, but I'm just going to take average size and remember this is USDC. So let's just do this and then let's do c name space, c name, c dot address.
00:24:46.710 - 00:26:18.340, Speaker A: So let's start with this. All right, so if we go by one, two, three, order by four, send it. So this should give us, again, we want only approvals to contracts. Another approach here would have been row number and get just last value. Um, that might actually be faster for us in this case, but let's do like. So there's some difficulty here of figuring out if they're doing like infinite or not because I can't just do like case one, approval size is bigger than some amount because some people just transfer ungodly amounts of value on chain. So something that would be good to check and this is like the extra logic you want to do is basically seeing like after approval.
00:26:18.340 - 00:27:33.508, Speaker A: So right now we're getting approvals to contracts. We would probably also want to join transfer to a contract and get average, sorry. And get spend by user, which is topic two. It, it subtract from. Okay, average is going to take way too long. Maybe we just do last. I think that's going to be faster.
00:27:33.508 - 00:28:27.424, Speaker A: So let's do row numbers over. So this is a window function we're partitioning by. I think we just partition by address, order by event block, event index. That one's still running. I probably should have chosen different token. What other query do I have running? All right, we're not going to do that one. Index, transaction.
00:28:27.424 - 00:29:23.340, Speaker A: Index and transaction. Oh, it works. All right. So now we can see actually the contracts, the addresses of approvals, and a lot of the approvals are basically like infinite size so that you never have to approve them again. I have no idea why these approvals are negative. That's weird. How in the world? Anyways do I have a logical error here? No, this should be fine.
00:29:23.340 - 00:31:17.750, Speaker A: So I would have just done something that's like if let me do case one is greater than like to the 50, I would say then infinite else transaction take a few minutes to run again. So this was six. So let that run. But I think basically every protocol does infinite again because it's bad ux to approve basically every time you want to do something. If you approve 100. So if you approve 100 and spend 20, does that mean you have 80 remaining to spend or you can spend 100 at a time? That's a good question. It means that if you approve 100 and then spend 20, there is only 80 left.
00:31:17.750 - 00:32:02.790, Speaker A: So it actually decreases the allowance. Right. So a good way of seeing this is, oops, if I go to the actual contract and I look at transfer from, actually there's this function here that's spend allowance. That actually is called before transfer. Right. And the reason why for that is basically it checks that this balance exists to spend. So I can take a look and say spend allowance.
00:32:02.790 - 00:33:09.370, Speaker A: And all it does is basically change the approved to be like this changes the approved amount to now be whatever the allowance was subtracted by the amount you're spending. All right, so we can see that in the contract. Yeah. Okay. That's going to take a minute. So that is that one it, it trying to think. Okay, so now we're on to the mind melter.
00:33:09.370 - 00:33:34.980, Speaker A: We've done balances. Let me just make sure I cover things. We've done balances. You could get top 100 holders basically just by adding an order by and a limit. Right. We could just do limit. That's like the fastest way, I would say.
00:33:34.980 - 00:34:44.780, Speaker A: And where is it? Yeah, so there's like functional differences that can be built on ERC 20, right? Like the functional differences are stuff like vote delegations or flash minting or stuff like that, right. But there's also, I guess storage differences or like internal differences. That's not the right way of explaining it. Basically you can play with balances a lot more than just relying on minting, burning and transferring to manipulate balances. Some good examples of this are like a lot of people have tried, or a lot of protocols have tried token streaming before. So you have protocols like Sabler and superfluid that essentially you set a stream rate and then it calculates your balance based on how many blocks you passed, right. So if you're streaming like 0.2
00:34:44.780 - 00:35:29.348, Speaker A: USDC per block, it just kind of keeps track of that until the other person wants to spend it and it basically moves the balance over. Right. Interest rates for protocols like compound and Ave work the same way, where there's kind of this exponential average interest rate that's calculated as you're borrowing or deposit rate. And it's like that's multiplied by the time number of blocks that have passed. And compound and Ave implemented in different ways. But the math they use is basically the same, I think. And then the last most fun one that we've seen is like rebasing tokens.
00:35:29.348 - 00:36:23.070, Speaker A: So it's like there's some rule that basically inflates token supply. So every single day if you put two tokens in, then the next day when there's a rebase, you might get like 0.1 tokens given to you. So everyone gets the same proportional increase in their held tokens. This is popular for tokens like I think synthetics and Olympus Dow did it. But probably the one that's going to stick around the most, I hope is staked ETH, right? And this is implemented by Lido. And the idea there being is like if I staked ETH into lido, then I have to get my rewards somehow, right? So I get a rebase basically with my staked ETH rewards every day.
00:36:23.070 - 00:37:34.672, Speaker A: And you might be asking, oh, does this mean that they send tokens to all of the token holders once a day, and the answer is no. For staked ETH, in their case, they track using shares, right? So it's like the same concept you have with Uniswap where if I deposit tokens into uniswap, I get this LP token back that represents my shares in the protocol. And it doesn't matter how much more liquidity is added or removed from the liquidity pool. My shares of the pool don't change in percentage terms, right? So it's like take that share concept and now add a proportional increase every day to your shares, if that makes sense, or, sorry, that's not a good way to explain it. It's not exactly to your shares, but like, to the whole pool. So that's probably confusing, but. Oh, this query finished running.
00:37:34.672 - 00:38:11.100, Speaker A: I wonder if there's any in here that are not infinite. Oh, we do have some. Well, this depends on the threshold you set, but I'd say that's still infinite, actually, for 49. Anyways, for this question, you should probably play with the range. All right, Lido, this is going to be fun. I'm going to try to explain this as clear as I can. So the way to calculate rebasing is actually not too complicated.
00:38:11.100 - 00:40:15.910, Speaker A: You have some base token that you're redeeming for, and then you have the token that represents your shares, right? So in uniswap you would have USDC is what you're trying to redeem, and then you have your LP tokens are your shares, right? So you could kind of calculate how much token you're supposed to get based off of fees, kind of from that, or not based off of fees, but based off the total pool. So in our case for staked ETH, it's like how much total ether is in the contract divided by how many total shares people hold, right? So you can kind of get an exchange rate of like, oh, if there's 1200 ETH rewards total in the pool, but the total deposit of shares is like 1000, then it's like, okay, the rebase is like 200 over like 200 extra, right? So it's like whatever 1200 divided by 1000 is, that'd be like a 20% rebase. And that's like, you can kind of think of that as like an exchange rate as well. That might be like an easier way to mentally format it. So basically, when I was looking at it, the way it works is they use an oracle system that tells basically the lido contracts, hey, today, this is how much more ETH rewards we earned. And based on that, increase the max shares distribute fees to the staking operators, but more importantly, increase both the amount of ETH in the pool and the total shares of the pool. That probably doesn't really make much sense, so let's just look into it.
00:40:15.910 - 00:41:17.876, Speaker A: The contracts are easy to find. You can just search steeth and you'll be able to find staked ETH. The one with the lido symbol, right? It is a proxy. So if you want to look at the actual implementation code, you have to go into the implementation address. And we could do our typical death net, but in this case the functions are a little more confusing, I would say, in terms of what calls where, right, so you have your base Steve Token, which is inherited, and they kind of explain in the contract here how shares work. There's shares that are actually tracked by address in here. And so there's transferring of shares on top of transferring of tokens.
00:41:17.876 - 00:43:08.540, Speaker A: The same way that last week when we were looking at like, oh, if I'm transferring the compound token, my delegation is changed upon transfer, the shares is just transferred as well per transfer, right? So like here I'm trying to find transfers called transfer. Shares is also called, right? And again, this is important because otherwise if I swapped something in uniswap and I have the tokens but the shares weren't transferred, someone can still burn the shares for the underlying ETH amount, but then I wouldn't be able to burn the token. Right, if that makes sense. Trying to think the best way to explain this. So I actually went and took the lido, Dow, GitHub, repo and put it into vs code just because I needed to rely on the solidity visual debugger or developer, right? So I needed this in this case. And all I did to use this tool is once you have it downloaded and you've forked the repo, just click called graph instead of graph this, remember graph, this is just the contract itself, but graph is like the whole repo. And I basically wanted to understand when shares were created or burned.
00:43:08.540 - 00:43:57.164, Speaker A: So I clicked on mint shares and I can see, oh, this is called by the Lido contract and it's called by handle Oracle report. And this seems to be the main piece of logic that's moving things around here. And I can also see that it's called by this fallback function. And a fallback is just like, let's say you call the lido contract with a function that doesn't exist on the contract. Like it checks the function signature and the function signature doesn't exist on the contract, then it actually looks for the fallback. It's like, okay, last case, last resort. Like what do I do with this data? Right.
00:43:57.164 - 00:45:10.908, Speaker A: So a fallback function basically always just handles, it handles the data based on what's being submitted. So it's like, okay, as long as you're submitting data within it, it doesn't matter what function, signature or like input you use. And that calls submit and submit has like, basically this is a deposit function. I'm not going to go over this, but the main one we can see is like, okay, there's a handle oracle report that's like minting these shares. So I would look through here and see, all right, what's happening in handle Oracle report. There's probably all of this wording that is more like contract pattern relevant than actually relevant to the data stuff for us. But if you kind of just look through it, you can see, oh, there's some sort of rewards going to validators, there's some sort of fee happening, but I don't see where mint is being called.
00:45:10.908 - 00:46:11.700, Speaker A: So I have to kind of look through here and see, okay, it's actually distributed fee that's calling mints, right. So then if we go to distribute fee, then I can see they're explaining here what exactly is happening in the pool. And this is important. It's essentially saying, all right, there's some amount of fees, basically shares that are going to the miners or not the miners, the node operators, right. And what they have to calculate or basically for the rebase to work, they have to add the amount of ETH that's now in the pool after the rewards come out per day, and they have to mint new shares to the operators because obviously that's what they're earning. Right. You're not minting new shares to the holders.
00:46:11.700 - 00:47:18.380, Speaker A: Right. So if I have 500 shares, I'm not getting extra shares, but the total amount of ether in the pool goes up. So I am getting more shares, if that makes sense, right? Like if I held 100 shares and then Jackie held 100 shares and there's 20 ETH in the pool, and then this reward thing happens and two more ETH gets put in the pool. Now Jackie and I both have eleven ETH, right? But there's part of that that's taken out into fees that goes to the miners or the, no, I shouldn't say miners because that doesn't technically exist on e two, it's the validators. So like some amount of fee, which is, I actually don't know how much fee they take. That'd be a good thing to look into, but essentially some amount of the fee goes to the node operators and that's minted as new shares, right? So it's as if like, oh, Jackie and I both had 100 shares, but now this validator gets ten shares. So our percent ownership of the pool changed.
00:47:18.380 - 00:49:33.960, Speaker A: So some amount of that new two ETH would end up going to the validator in terms of redemptions, but the rebase is still happening in terms of like, we now get more ETH for the same amount of tokens we've put it right. And essentially that's what's being calculated in Richard's query, right, where it's like, all right, I know that total shares changed and that the total shares changed because of the fees that were paid to the validators. And I know the post like total ether in the pool changed because that's like, basically they push this once a day and tell them, hey, this is now basically how much ETH you're getting for one staked ETH, right? If you've looked around Twitter, you've seen like, oh, there's like a 7% discount factor. And it's like, yeah, you're getting 7% basically per ETH you put in over time. And that's the APY that's calculated here is like, okay, if I now compare this rebase from last year to this year has exchange rate of ETH to steeth kind of gone up, right? And so this is like your actual ETH steeth redemption kind of balance. But there's all this complications around queuing and liquidity in terms of, obviously you can't withdraw any ETH off of ETH two right now because it's locked until the merge, right? So this is like your real exchange rate, which obviously isn't going to match the exchange rate on curve because that's like liquid rate, right? But this is what it should be if it was fully liquid, if that makes sense. So staked is like an interesting case for rebasing.
00:49:33.960 - 00:50:44.650, Speaker A: Olympus style's implementation isn't too hard to understand. The interest rate ones are a lot more complex and it's easier to use storage data, I think, for it. I'm not going to cover that this time because that'd take a while to cover, but hopefully that helps make rebasing make a little more sense. Again, the logic is just like, you have some sort of shares you've put in once and you're automatically accruing rewards based on either some oracle or some daily kind of like unlock and you're essentially getting more and more of the token, right. I'm trying to think if there's anything else important on that concept. I think it covers the important bits of it. If you're still confused, I would take more time and literally just read this one.
00:50:44.650 - 00:52:09.750, Speaker A: Like you have to understand how the fees are distributed when the oracle is called. And you have to understand this first part of the code here of how are shares mapping to balances. If you can understand those two, then you should be able to understand like, oh, okay, this is how they're paying out fees and increasing your rebase rewards without actually transferring any tokens. Otherwise it's like if they wanted to do a full rebasing reward then they would have to have another. Actually, would they have to have another? Okay, this is where I'm like my expertise kind of stops. I was thinking, I was like do they need another token to represent that? Actually I don't think you do. Anyways, point being, hopefully the math here makes sense now technically you don't need all to know all of this to do this query, but I think it's good to understand this pattern because rebasing is used quite often, I would say in a lot of kind of rewards protocols where there's any sort of liquidity lockup, meaning some sort of protocol where you deposit your tokens and can't withdraw them for some amount of time.
00:52:09.750 - 00:52:54.468, Speaker A: All right, that's kind of what staked Olympus is as well. And yeah, it's kind of used a lot for crazier financial incentives because it's like, oh, the more that people lock, the more liquidity you lock, the more liquidity you have to generate revenue. And the longer you have it locked, the longer you can generate revenue. So the more rewards you can distribute back to the holders. Right. So it's like this kind of like flywheel effect and that's why rebasing tokens are fairly popular. Yeah.
00:52:54.468 - 00:52:57.760, Speaker A: All right, I'm going to end it there. I hope that is helpful.
