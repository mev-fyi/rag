00:00:00.880 - 00:00:47.592, Speaker A: All right, so perfect. So hello, everyone. This is Varun from Hash flow, also known as Gandalf the Brown. And today we are going to kickstart our first cross chain swaps panel. And we have Brian from Layer Zero and Victor from Hashlo and myself from Hashlo as well. I would generally be moderating the panel and ask questions about, but also generally, I like to make this a discussion so anybody can ask questions, and we can all have a more candid discussion around the road to cross chain and a bit more context. Hash Flow recently launched their first bridgeless cross chain swaps that is powered by layer zero.
00:00:47.592 - 00:01:25.544, Speaker A: And we had a bunch of questions around how this thing works under the hood. We figured this would be a good opportunity to pick Brian's brains around how they built layer zero and then how we came to the design decision around integrating with layer zero and what does the future look or entail? So that said, why don't we start with a brief introduction? We can start with Brian, and then, Victor, you can give a bit as well about yourself as well as the project you're working on.
00:01:27.164 - 00:01:27.564, Speaker B: Cool.
00:01:27.604 - 00:01:55.234, Speaker C: Yeah. For me, I think probably many of you guys know me by now. I'm Brian, one of the founders of Layer Zero, currently CEO of Layer Zero Labs. Super excited to see more things getting built, and this one was particularly exciting. So I'm pretty pumped to just dive in. I think there's a bunch of, like, kind of nuanced questions around it, and I think everybody will find it super interesting. And I still have some questions that, like, I want to see get answered, so I'm pumped.
00:01:59.974 - 00:02:27.320, Speaker B: Awesome. I'm Victor. I'm one of the co founders here at Hash flow, and I had the privilege of building most of our crossing architecture. A lot of it has been been live for almost a week now. So you guys have hopefully had a chance to play with it and, yeah, like, I'm excited to be here and talk a lot about it. It's been a good ride. And, you know, the layers of your tech has been amazing too.
00:02:27.320 - 00:02:34.164, Speaker B: And, yeah, happy to. Happy to answer questions and talk more about this space.
00:02:35.104 - 00:03:07.474, Speaker A: Excellent. Thank you, guys. So I was thinking perhaps it might be a good idea to start with a bit of a context or around the landscape of interoperability and seeing exactly what's out there and how do you guys currently view the cross chain space and what's happening, and then you start to build upon how layer zero came about and what were the shortcomings in the space, and then where do you guys fit in? The ecosystem, perhaps that's a question directed towards Brian.
00:03:08.754 - 00:03:45.826, Speaker C: Yeah, sure. I mean, from our end, like, when we started building this, there wasn't really a cross chain space. There were like IBC as a messaging standard that lived, you know, only in cosmos. There was Polkadot, who was like, you know, wanted to be the hub and spoke of everything. And there were a few bridges, but everybody's really focused purely on bridges. So moving, you know, taking some asset from chain a and bringing it over to chain b, typically through this, like, lock and mint kind of wrap synthetic method. So the goal of layer zero had always been that there was no really need for the nuance between these things.
00:03:45.826 - 00:04:59.762, Speaker C: Everything very similar to the way that sort of messaging on the Internet came about was some form of general message passing. Bridging is just a special case of generic messaging. So we really started to build just that, a system that really is just meant to be this really extensible core primitive that anybody can build anything on top of. So if you have arbitrary contract invocations and you can pass payloads, aka messages, then you can really build anything across chains that the contracts themselves can support. So we didn't think there's any need to create random, arbitrary limitations at the technology layer, and so we started building that. And obviously, as it built, all of these other interesting questions came in in terms of, how do you actually build this as secure as humanly possible from the ground up? How do you give applications themselves the ability to specify what they want to pay on that current of cost versus security? What does parameterization look like? All these other really cool things. But, yeah, I think early on it was, we were just tinkering, we were building a game, and then realized you couldn't actually do anything in this game across change without, like, a centralized contract that was coordinating.
00:04:59.762 - 00:05:17.174, Speaker C: And then we were like, okay, let's look at bridges. They all suck. Let's make a slightly better bridge. And then very quickly just realized, oh, hey, kind of the thing that underlies all of this is this transport layer, and that really is the thing we should be working on. And that was just consumed our lives for the past 15 months.
00:05:17.634 - 00:05:55.694, Speaker A: No, excellent. Thank you for the response. Actually, I was going to add a follow up question there. I think oftentimes people use the term bridge and message passing synonymously, and there tends to be confusion how you define a bridge versus what's a message passing system. And what are all these terms, especially for newcomers who are coming in the cross chain space? I wonder if you guys could clarify, how do you guys see a bridge. And I think that also goes into my next question around how is Stargate sort of different from the layer zero score protocol?
00:05:57.874 - 00:06:27.766, Speaker C: So most bridges. So, again, like, Stargate is a bridge. This is a bridge that's built on top of layer zero. Bridges are really trying to bring some unit of value from chain a to chain b. So there's, like, a couple different ways you can do this. Most of the historical ways, in terms of a bridge, was lock an asset up on chain a and mint a synthetic asset on chain b. And this is really tricky for a lot of reasons, one being that you might actually, you know, have wild success and lock up a huge amount of assets and mint a lot of synthetic assets.
00:06:27.766 - 00:06:56.364, Speaker C: And that seems kind of great in the case. But, like, an ideal world from a security perspective, is that the user only really bears. And maybe I'm getting too technical here, hopefully not that the user really only bears risk on the duration of the transfer. So you're wiring money, or you're doing whatever. Maybe something goes wrong in the middle, you're taking on the risk of that technology. But once the money gets there, or once your asset gets bridged to the other side, you don't need to worry anymore. You have the real thing.
00:06:56.364 - 00:07:23.912, Speaker C: You're done. That's all over. All the scary part's done. But now you have this synthetic, and so what actually happens is maybe $10 billion of outflow happens, and so you lock up 10 billion on chain a, and you mint 10 billion on chain b. But that risk never, ever goes away as long as that synthetic exists. So now you have your asset on chain b, but you're not done, because there's still 10 billion locked in a contract on chain a. So now you have, like, two direct attack surfaces.
00:07:23.912 - 00:07:41.178, Speaker C: Three, actually. You have local smart contract risk. So this is like the wormhole hack. There was a bug in the local smart contract. Somebody hacked it, and, you know, the money was taken. There is a consensus mechanism failure. So maybe you have some chain that sits in the middle, some consensus mechanism that turns malicious.
00:07:41.178 - 00:08:22.914, Speaker C: They can basically mint an arbitrary amount of tokens on the other side, making your synthetic now worthless, or steal kind of the locked asset, meaning your synthetic is not backed by anything. That's a pretty terrible outcome. And then there's, like, fraudulent message where a hacker, you know, stuffs a bunch of clever bytes in a message and tricks the contract to releasing money when it shouldn't. So all these things are kind of risk vectors. And so that was kind of the old bridge was, hey, we're going to do this lock and mint. But the problem is you're always carrying standing risk, always. And that is a really, really big concern, because that can be, you know, again, in the success case, where this happens a lot, this can be like a systemic level of risk.
00:08:22.914 - 00:09:00.296, Speaker C: And so the user doesn't just bear risk in the transfer. They bear risk for as long as, as long as they hold the asset on their side, whatever they're doing, as long as that's in existence. And so, and there's a lot of contagion there as these get integrated into lending protocols and Dexs and all these other things. So then we came up with Stargate, which is basically like native asset pools on both sides. So maybe you put up 100 million on chain A and 100 million on chain b, and users can, like, add to one and subtract from the other. And now, from the user perspective, they're now only bearing risk for the duration of the trade. Right.
00:09:00.296 - 00:09:29.576, Speaker C: They add to pool a and they take from chain b, but there's no synthetic. They're getting the real asset on chain b, and the LP's bear all of the risk, and they're getting, obviously, rewarded for doing this. And so now you could have kind of that same 10 billion of outflow. Well, only maybe having $200 million in the pools, assuming you can rebalance them comfortably. And so now you have, like, a much, much more risk effective framing of way to bridge this. And then now, like with you guys and lots of other things, there's like, even extensions on top of this. Right.
00:09:29.576 - 00:10:03.720, Speaker C: But I think the ideal case always is that you want in the bridging construction risk for the user to only be on kind of the duration of the transfer. Like, that's the ideal kid. Some things are unavoidable, and you have to design around a lot of other things. But I think that's kind of been the evolution of bridges thus far. Bridges are really just, again, value transfer. Somebody's got a bag of money and they want to walk across a bridge and, like, land in the next place and kind of have their bag of money over there. And I talked for too long now, so I won't go into, like, the layers or specifics, but hopefully that's a high level on bridging.
00:10:03.842 - 00:10:42.414, Speaker A: No, I think that actually adequately answers a question. I think many, many people here, because I think that was more commonly asked questions around, isn't this already a bridge? Speaking of which, I think this is a question for Victor. It's just so, so obviously, with Hashler we market ourselves as a bridgeless cross chain swaps. And I think this might be a good idea for you to elaborate on Ryan's concept around why are we bridgeless? And how does hashless architecture fit into the current paradigm? And then what makes this more unique in terms of how we re enable cross chain?
00:10:43.354 - 00:11:48.960, Speaker B: Well, certainly, yeah. So when you think of it, Hashel does something that is very, very similar to Stargate, which is simply relies on messaging between two different layers in order to execute a trade. Which means that similar to Stargate, the risk is bare by the LP's and also the trader only bears the risk for duration of the trade. So just to give a little bit more context, whereas in Stargate, say you're transferring things between Ethereum and avalanche, and say you're having tether on Ethereum and tether on avalanche and you're going to say transfer 1000 tethers. Essentially you're going to be transferring 1000 tethers into the pool on Ethereum and you'll be debiting another thousand tethers from the pull and avalanche to your account. Right now in hash, we extend that a little bit and we use our market making infrastructure to be able to do something that is more like a trade. So it shares the same mechanics, it shares the same risk factors.
00:11:48.960 - 00:12:28.834, Speaker B: However, what you actually get is a full on swap where you can say transfer 1000 thousand tethers on Ethereum, but get avax in return on avalanche. Right? And I mean, we can dive deeper into this later, but essentially the reason we are able to do this is because we utilize the pool architecture, which is very, very common in defi, but we also use market making and signatures to enable, to enable guaranteed execution, right? You don't have, you don't have any crazy cross chain muv scenarios that you have to fear. But.
00:12:31.654 - 00:12:43.554, Speaker C: For everybody here and for myself, to be honest, can we just walk through like start at the beginning, you have some asset on chain a, you're going to some asset on chain b, like every step of the way. What does, you know, what does this look like?
00:12:44.334 - 00:13:13.444, Speaker B: Absolutely, yes. So say you're trying to trade USDC on Polygon for Ether and Ethereum, you're trying to buy ether. What you're going to do first is request a quote from a market maker that is willing to make that happen. The market maker is going to be managing liquidity on both Ethereum and Polygon so they can link the two pools and give you a quote. So suppose you're transferring 1000 and you want to buy 0.3 ethers. Right.
00:13:13.444 - 00:14:00.218, Speaker B: The market maker is going to issue that quote, is going to sign it, and that signature is going to be specific to their pools. Right. And what you're going to be doing as a trader is you're going to take that signed message and that signed message is going to be a clear cross chain trade. You can still hashful protocol and you're going to send 1000 USDC on Polygon. What the hash for protocol is going to be doing is it's going to be taking that, verifying the signatures, running a bunch more security checks, and then transferring that message over to the liquidity pool on Ethereum, which is owned by the same market maker, right. Via the layer zero messaging protocol. So layer zero is going to be, and Brian's probably going to dive deeper into how this works.
00:14:00.218 - 00:14:23.324, Speaker B: But layer zero is going to be assuming the message is going to be providing message integrity so that the pool the market has in Polygon can send the fact, send this message that the trade happens to the pool that that is on Ethereum. Once the Ethereum pool receives the message, it validates it further and then it disperses funds over to the trader on the other side.
00:14:24.584 - 00:14:53.016, Speaker C: Okay, got it. So broadly, two pools, or, you know, a bunch of pools managed by a market maker. But let's say, you know, we're using market maker a, that's who's given us a quote. We added to their pool on Polygon. We're given a receipt through layer zero. You bundle that up in a message, you send it over to the destination chain, then in your contract or their contract, well, their pool within your contract, I guess, verifies that that's a valid message. All the signatures are valid and then the funds are released.
00:14:53.016 - 00:15:29.444, Speaker C: And so what this looks like from the consumer perspective is that you have some consumer that's sitting on polygon, they have matic, they probably don't have ethnic ethereum, or they don't have whatever the destination gas asset is. They clearly don't have the asset they're trying to go into. And you sign a transaction from polygon, you pay all of this in Matic on polygon, and then kind of this whole flow gets executed in the background. So the users not seeing any of this stuff happening, they're not switching wallets, not signing more messages or doing anything. And then, you know, at the end of all of this, they just have EtH in their wallet. On Ethereum, that's how it works.
00:15:29.604 - 00:15:30.544, Speaker B: That's right.
00:15:31.204 - 00:16:31.472, Speaker A: Fast. Okay, so actually, not a follow up question necessarily, but I think actually, it is a follow up question. So I think generally, the way I view it, just to describe, you have market makers submitted giving users a quote, and then there is a messaging system. And generally the way I tend to view the ecosystem or any caution messaging is you need someone to validate that the transaction has taken place on chain a, and then you need somebody to relay that information to the destination chain. And that's generally, I think, the formula for most cross chain protocols, the way they work. I was curious to see how layer zero's messaging works, because I understand that you guys use Oracle and relayer and they have to work together in carrying the message. And I was curious if you would like to elaborate a bit more in terms of how layer zero's message passing works and how does it differ from.
00:16:31.472 - 00:16:38.084, Speaker A: So the other protocols, like, say, axlar or wormhole and Nomad and such?
00:16:38.504 - 00:17:02.394, Speaker C: Yep. Yeah, 100%. So I don't want to, you know, I want this spaces to be more about you guys than us. Yeah, you guys built something cool, so we'll spend most of the time on that. Broadly, I will say kind of. And again, you guys, you know, everybody who hasn't heard me talk about this before, you know, you can find probably a thousand instances of me doing so. But broadly, most of these other systems are reliant on kind of one consensus mechanism that sits in the middle.
00:17:02.394 - 00:17:30.504, Speaker C: So you mentioned wormhole. There's 19 guardians. You mentioned Axelr. They have kind of their axelar chain that aggregates all these light clients on there. But at the end of the day, there's a single consensus mechanism that deals with validating some source chain transaction and then sending out the destination chain. So broadly, kind of the concern with this is a couple fold. One, all parameterization kind of lives in that chain into two, that that chain is kind of, you know, you're basically becoming this hub and spoke for everything.
00:17:30.504 - 00:18:36.164, Speaker C: So ultimately, that chain needs to be kind of more secure than everything on every chain that it's tying together. Because if there is an avenue for, like, an economically viable kind of attack on this, it has the ability, you know, that consensus mechanism is broken for even a very brief period. It has the ability to arbitrarily write messages universally, kind of, to every application on every paired network. Right? So this is why, like, we've had hub and spoke models for a very long time. This is not the first time this has broadly been tried. I think you have these really adverse properties of, like, you secure a couple billion, and then a huge application opts in, and now maybe it's 20 or 30 billion and then aave ops in now it's 50 or 60 billion. And unless the bond in the underlying system is growing kind of nonlinearly to the value that's being secured, you have this really adverse property where it's making each new application signing up is creating a less compelling security construct for every existing application because there's more and more at risk.
00:18:36.164 - 00:19:24.124, Speaker C: Well, not an equal amount securing that. Broadly, how layers are addresses, this is the risk is sharded across this oracle and relayer set. We're in self proclaimed beta right now because we have a very limited subset of relayers and oracles that's going to be changing very soon. But broadly, you split all this, you give the applications autonomy such that they can run one of these components where you're effectively cross referencing every single transaction that happens. So you have no unilateral control, but you also have complete control over security where nobody can do anything without you validating or cross referencing it. And then on top of that, there's a bunch of other kind of cool things. I'm trying to be very high level here and not dive in too deep because I don't want to make this about the layer construct.
00:19:24.124 - 00:19:39.054, Speaker C: But yeah, again, you guys tell me I can spend 30 minutes talking about this. I've done it 100 times before. I think a lot of people on this have heard me talk about it before, but otherwise we'll keep it as hash flow centric as possible.
00:19:39.434 - 00:20:23.722, Speaker A: No, no, no worries. I think generally the way I see it is if there is an interesting information, especially even for hash flow users, sometimes they would care about what's happening under the hood in terms of security. So this information is usually useful. But I would like to ask one question to Victor here. Now that we've mentioned a bit of a. We discussed something about message passing, I was curious, how did we arrive at the design decision in terms of evaluating different transport layers and figure out what works the best? What went into that thinking to evaluate different designs and why we ended up with layer zero for sure?
00:20:23.778 - 00:21:03.970, Speaker B: Yeah. So I think one main design decision was that we wanted to rely on something like interconnect, like pools on different chains that are interconnected by a messaging system. Right. And it was pretty clear that this model would work well, the so called bridgeless model. That being said, I do believe that the space is very early. Right. And what that means is that, you know, a lot of, a lot of the knowledge that circulated is theoretical, right.
00:21:03.970 - 00:21:52.534, Speaker B: Because, you know, even thinking of something like okay. Value that's locked in a bridge goes up, incentives that the attackers go up. People are going to be putting in a lot of effort and money to be able to hack something that holds, say, 10 billion worth of liquidity. I think a lot of this theoretical, because we haven't gone there and the space can evolve. I think one of the things that we really wanted to do is to assume that the system is very modular, right. We wanted to assume that we just have pools that communicate with each other, and how they communicate with each other doesn't really matter. And there are different ways to actually send these messages that we can plug and play.
00:21:52.534 - 00:22:20.064, Speaker B: So layer zero here becomes a messaging layer between two pools. But theoretically, it doesn't have to be the messaging layer. If I wanted to run something on my laptop and validate transactions, and the pools were totally okay with that, technically speaking, they should be able to. They should be able to opt into it. Now, in practice, that's definitely not something that we want to do. Right. So then that brings us to the layer zero design.
00:22:20.064 - 00:22:59.266, Speaker B: I do think that one unique thing about layer zero is that it kind of relies on game theory to kind of talk, to kind of mitigate this whole risk. Right. It's a very modular framework. It was, you know, some of, some of the early things that we noticed is that, you know, it does. There was a lot of research and a lot of thinking that, you know, Brian and the team put into trying to figure out different attack vectors and different systems of incentives. Right. And, you know, that the system itself, the layer zero system itself was very modular.
00:22:59.266 - 00:23:41.374, Speaker B: So it didn't actually lock you into a specific vendor like specific oracle, a specific relayer, but at the same time, like, with this modularity, it also made it very easy for users to onboard. So simple things like the testing suites were very easy to use. There are relayers and oracles that are easy to use out the box. Right. So on the one hand, it makes it easy for you to onboard. On the other hand, it's modular enough and it has long term security as one of the main considerations for us, it was very easy to build. I think our architecture helped a lot because we didn't have to modify a lot of our code at the pool level to be able to support this.
00:23:41.374 - 00:23:53.394, Speaker B: I think it all worked out and we were able to build this quickly. Right now it's running in Alpha, but, you know, the experience has been great and. Yeah. Does that answer your question?
00:23:53.974 - 00:24:28.454, Speaker A: No, it does, actually. Yeah, it covers a lot of ground. I was actually curious to see like, you know, obviously we've assumed that generally we are relying on a relayer and an oracle model. And obviously, so far we're talking about the good case scenarios. But let's say if there is an adversarial scenario that exists, how does hash flow? Or do we have any ways to mitigate those risks? What's the worst thing that could happen in a doomsday scenario? What are we looking at?
00:24:28.994 - 00:25:36.964, Speaker B: Yeah, like Brian mentioned, doomsday scenario is that someone corrupts the messaging system. Anyone can send messages. Obviously, I want to say that there are, there are risks that the LP's bear, right. And the fundamental risk between different blockchains is that them being different layers, they're vulnerable to 50 plus one attacks, right? So I think we can't do anything about that. However, we can do something about the middle layer being corrupted, right? Suppose anyone can start sending messages through pools. One thing that the pools rely on is signatures, like they always have, right? So pools have to authorize each other and they check each other's signatures, which means that if you're setting up, even if you're corrupting the messaging layer and you're starting to send messages, you cannot really send correct messages that the pools would recognize unless you work to be able to forge the, the signer's private key on the other side. Right.
00:25:36.964 - 00:25:48.864, Speaker B: So in a sense, this is almost as secure as a intra layer swap, because it relies roughly on the same cryptography guarantees.
00:25:49.924 - 00:26:16.804, Speaker A: So is it safe to say that because we have signature checks in place, it's so agnostic to what validate in vlayer set we use, given that both sides do a signature check. So it kind of really means to using a validate relayer to do message passing, but it's somewhat agnostic to what kind of relay or validator set you use, so long as they're offering you the latency that they're offering you good latency in order to achieve a swap?
00:26:18.344 - 00:26:20.244, Speaker B: I believe that's correct, yes.
00:26:20.984 - 00:27:24.344, Speaker A: Okay, so in that vein, my next question, because we talked about signatures, I think this is also one of the crucial elements why we are able to get around something called cross domain mev at this point. Because previously MeV was a big thing when you were using amms, and if you had large trades, someone with last luck on the trade could, was able to front revenue. And now I think the moment we move towards cross chain transactions, this becomes an even bigger problem. So obviously, I would like to give you guys a chance to talk about perhaps what MeV is just to define a bit more for all the new people here who may not be familiar with the term, and then perhaps like to hear your viewpoint. And how do we go about solving for Mev? And Brian, maybe if you have any thoughts on the, what's been the issues around, around MeV in the cross chain space.
00:27:25.244 - 00:28:08.338, Speaker C: Yeah, yeah. So Mev is minor extractable value, right? So this is broadly like some transaction is coming in and somebody wants to buy, you know, $1,000 worth of something, and they say, you know, I'll take a slightly worse rate, up to, you know, 0.5% slippage. Now, the miner seeing this happen has the ability to insert their own transactions or kind of reorder these transactions however they like. And so they can, you know, put in their own transaction that brings this up to exactly 0.5% slippage and then sell immediately after. So they've driven the price up, bought a bunch of tokens you buy, which drives the price up even further, and then, you know, they sell after that at kind of a higher price.
00:28:08.338 - 00:28:42.258, Speaker C: So kind of taken some value over there. And this can be a lot of things. This can be, you know, that's what they call like a sandwich attack, where there's all these arb and triangle arb and all these different opportunities that exist around the space. Basically everything, you know, at any action that's being taken, you're slightly disjointing, like fair value, quote, unquote. And that creates opportunities. Again, oftentimes this is just arbitrage, but the person who is ordering these transactions or processing them has the ability to capture those. This has been largely commoditized these days by groups like flashbots and others who basically work with the miners.
00:28:42.258 - 00:29:24.958, Speaker C: People auction off kind of what they're willing to pay for this slot. The miner gets paid from them, and then they sort of extract the value. So when you're building even, you know, on a single chain, this happens all the time, whether it's the Solana validator set or the Ethereum validator set or avalanche, or any of these others. Right? They're kind of Mev. And all of these systems is depending on kind of the amount of control that the validators have in kind of ordering transactions. And so then when you're going cross chain, there usually comes up this question of like, but hey, now we have, you know, ten minutes or 1 minute or, you know, whatever kind of the duration is that you're waiting for this message to go through. Like, doesn't this create so much more MEV and the, you know, the short answer is no.
00:29:24.958 - 00:30:02.692, Speaker C: And I'm sort of happy, happy to sort of dive into why that is the case. But broadly. Broadly, latency is not the biggest issue with this stuff. Right. When they're measuring latency in a matter of, you know, milliseconds, not a matter of minutes or seconds. And so having like, 1 minute, the way you create MeV is kind of having your order execution matters. And so if you knew something was coming in ten minutes from now, some buy you, buying now would not help you at all, because you would be disjointing the price, and then somebody else would use that dislocation to, like, you know, you would become the MeV for the next person.
00:30:02.692 - 00:30:46.754, Speaker C: So it's really about being in the exact block positioning or, like, as close as possible to when that event is happening, which still just comes down to the same thing prior. And there's some things you can do. You know, you can submit to flashbots, RPC on the other side, you can do other things to sort of lessen this as much as possible. But you guys don't suffer this, because at least my understanding of it is that the quote is already happening and finalized on the source chain. So we've been thinking a lot about some other things that we might be doing kind of around, you know, more broadly around systems like this. And it seems like if you're doing anything with value kind of across multiple chains, being able to have some sort of source chain quote where you have. So this was like Stargate's instant guarantee of finality.
00:30:46.754 - 00:31:03.314, Speaker C: You have sort of price finality ahead of time, and then you're really just like, the messaging and everything else is really just for settlement. Right. And so when you have that, then you don't have this issue of kind of Mev because you've already agreed upon a price and it's kind of guaranteed.
00:31:04.154 - 00:31:08.774, Speaker A: No, that's, that. That's absolutely true, Victor, if you want to add more color to it.
00:31:11.714 - 00:31:44.900, Speaker B: No, I think. I think I second Brian's thoughts. I mean, the MEV. I mean, obviously, we have a huge MEV advantage against most dexs, mostly because we have guaranteed execution. But yes, I think in a very sophisticated world, right, where people actually pay attention to activity and so forth, Mev kind of reduces cross chain to single chain meV. However, I do think that there are other challenges, obviously, for ammunition to function.
00:31:44.932 - 00:32:11.044, Speaker C: Across, actually, just as a quick aside, because I don't actually know. So, two questions. How do you guys guarantee. How do you guys guarantee execution? Like, what forces the market maker to act faithfully on the other end, or not being able to, like, pull away the whole pool on the destination chain before the money gets there, etcetera. Is there some sort of bonding system slashing? Like, how is this enforced?
00:32:12.544 - 00:33:18.156, Speaker B: Yeah, I can give more color. So the market maker in general on hash flow has to be trusted. So there are, you can think of market makers almost as money managers, in a sense. So they would put their, they'll put their reputation there, take people's money, and then make, make markets with them. In a sense. There are, there are liquidity race scenarios, however, right? So obviously, people can trade at the same time, and because transactions are not atomic, you cannot guarantee, for example, that certain balances are going to be available for settlement. We fix this by, obviously, a making sure that we operate within certain bounds, so we wouldn't be operating the pools or would be filtering against, say, market making quotes that kind of very close to the line.
00:33:18.156 - 00:34:33.483, Speaker B: Right? However, theoretically, like, there's a theoretical constraint here where under, under the wrong circumstances, it could be, it could be possible for a pool to reach its balance limits. I think we use tokens, we use placeholder tokens, we call them age tokens to deal with that. Similar to how they rebalance pools for single chain transactions, where market makers keep part of the inventory on a centralized exchange for hedging part of the inventory on hash flow. And then whenever a certain token runs out, they kind of transfer over from the centralized exchange to hash flow, and from hash flow to a centralized exchange, they will be transferring assets back into the pool as the pool runs out of balance, and those tokens would be redeemable for those assets. Right? So, for example, if you have only 50 USDC left in a pool, but then you have two trades at 100, the first trade is going to get 50 USDC and 50 h tokens, and those h tokens are going to be redeemable later on. And the second trade is going to get just 100 h tokens, which are going to be redeemable later on. So it does rely on the market maker, honestly.
00:34:33.483 - 00:34:58.434, Speaker B: However, um, market makers are KYC institutions. Uh, they're, they're making markets operating interims. So, uh, any, any. If there was a case where a market maker were to say, take, uh, take up e funds away, they, there will be, there will be legal action and so forth. So they're not incentivized to run away with funds, if that makes sense.
00:34:58.974 - 00:35:24.854, Speaker C: Okay, cool. Yeah, got it. And the other thing, I was going to ask about fees, but broadly, the market maker is just like, they're just quoting a price. So there isn't like inherent fee, they're just like quoting some spread like they would when they're making markets on centralized exchange. So ultimately, anything that the market, any incentivization that the market maker is getting is coming just from filling a bid at a price that they were willing to basically operate at. Is that accurate?
00:35:25.154 - 00:35:26.306, Speaker B: That is correct.
00:35:26.490 - 00:35:29.394, Speaker C: Cool. Okay. Yeah. Okay, go on.
00:35:30.414 - 00:36:03.444, Speaker B: So, yeah, I mean, to that point, I think a lot of the, you know, people ask like, you know, what comes, what comes in Liyo slippage. Right. The reality is that every single fee, every single tolerance to price changes and volatility gets baked into the quote. So in very volatile markets, for example, you'll see, you'll see quotes that have worse prices to say account for volatility. So that's roughly how it works. But at the execution level, once you get a quote, you have guaranteed execution of that particular quote.
00:36:09.464 - 00:36:20.604, Speaker C: You actually have guaranteed execution. Or if the market maker doesn't execute, they will get in trouble and you will have each tokens which the protocol will fulfill or like something will happen around.
00:36:23.084 - 00:36:43.904, Speaker B: In a single chain scenario, you have guaranteed execution. In a cross chain scenario, you have, like you mentioned, pseudo guaranteed execution where you have guaranteed execution as long as the pool has funds. And the protocol itself, the back end layer of our protocol tries to avoid situations where funds are out. Does that make sense?
00:36:44.284 - 00:37:03.284, Speaker C: Yeah. And you can, you know, you can always do something like Stargate does with instinct, like the credit system and making it so before they remove liquidity, they need to go back and kind of request from the destination chains, but it's a bit messy to do so. Cool. Okay. Yeah, I broadly understand where we're at here. Cool.
00:37:03.784 - 00:37:22.194, Speaker A: So I think we have like seven minutes left, so perhaps it makes sense to open up. We can take over three questions from the audience and then before we call the wrap. So if anybody wants to ask any question, raise your hands up and perhaps.
00:37:35.134 - 00:37:42.584, Speaker B: Are you able to enable the person to speak or. So I have to do it through this account.
00:37:42.964 - 00:37:44.564, Speaker A: Brian, can you go ahead, do it?
00:37:44.644 - 00:37:48.304, Speaker B: Sure. Okay. All right, first up we have TLCB.
00:37:58.564 - 00:38:00.984, Speaker C: I don't think they got brought up as a speaker yet.
00:38:04.844 - 00:38:08.824, Speaker B: Okay, let me try to give Walid 1 second.
00:38:10.284 - 00:38:11.064, Speaker C: Ok.
00:38:16.684 - 00:38:20.464, Speaker B: Yeah, I see that. It's just saying connecting and is loading.
00:38:21.484 - 00:38:26.052, Speaker A: Hey guys, thanks for having me. I had a question for Brian.
00:38:26.228 - 00:38:43.084, Speaker B: He asked Victor how, you know, his part or his, his aspect was making sure that the middle man or the market maker was not exploiting the transaction. How does layer zero achieve this? I just wanted to know. Thanks.
00:38:44.064 - 00:39:19.172, Speaker C: Yeah, yeah. So there's a couple of ways. At the messaging layer, all messaging is non sorter enforced. So, like, the relayer has no ability to reorder transactions. So every transaction is basically submitted in the exact order that they were committed on the source chain in for each application. And so normally how this happens at the validator level, again, is a validator gets a bunch of messages that are incoming and it just shuffles them around and says, oh, well, this transaction is happening here. I'll just slip in this little bit of mev by doing another transaction here or there and so on.
00:39:19.172 - 00:39:42.244, Speaker C: But with layer zero, not everything is coming in. It's not like a constant stream. It's by block of source chain. So you have a bunch of transactions that were in a single block on a source chain, and then you take all of those and guarantee transaction ordering. So it's nonce order enforcement, and the destination chain will reject them if they're ever submitted out of nonce.
00:39:43.864 - 00:39:44.304, Speaker A: Awesome.
00:39:44.344 - 00:39:44.964, Speaker B: Thanks.
00:39:45.944 - 00:39:47.124, Speaker C: Yep, for sure.
00:39:48.944 - 00:39:52.364, Speaker A: We've got two more questions. Anybody?
00:40:01.484 - 00:40:17.024, Speaker C: I'll ask a question while we wait. Feel free to, like, keep bringing people up as they have them. What are you guys most excited about for this? Like, what do you guys. What is the biggest unlock in your mind that this brings?
00:40:19.044 - 00:40:21.064, Speaker A: Victor Yang first, or should I go?
00:40:21.884 - 00:41:18.560, Speaker B: I have one. One thing that I'm really excited about, which is the fact that, I mean, the reason that I always said this, I don't think we can have multichain without cross chain. And I think this enables things like, for example, onboarding users. I think one of the biggest pain points is always getting things like native tokens to be able to start utilizing the chain. Then you have all these apps that are kind of separate across different chains, and you need your funds. You need your funds to do certain things, and it's just a pain to always get them out. So I think with more and more protocols that make this a little bit safer and faster, obviously, people will really be able to use a multi chain world and not just transfer test funds to some of these blockchains, but also be able to move funds and work on different networks as they need to.
00:41:18.560 - 00:41:23.964, Speaker B: Right. So it makes this whole multi chain space a lot more seamless. At least that's what I hope.
00:41:28.144 - 00:42:31.260, Speaker A: No, I think I was going to say generally. I think the thing I'm excited about is essentially, if you think about the things uniswap or other AMM designs that essentially boards the d five from zero to one. I almost view this as the next iteration as one to n on how do we scale the fighter to really get it to the masses, but also attract institutional capital and liquidity into the space and enabling this sort of feature that allows people to not just swap between chains, but also swap between chains. And coupled with the design that allows for more modularity and bringing price discovery to deFi essentially means you can actually not just do cross chain swaps, but also expand the suite of offerings beyond just trading some blue chips or spot assets. You can do things like options or ETF's and things like that. And now you can go and do these between chains and build out from there. That's sort of where I think this design works really, really well.
00:42:31.260 - 00:42:34.584, Speaker A: I think that's something that we've been really excited about building.
00:42:38.814 - 00:42:42.594, Speaker C: Awesome. Yeah, yeah, I agree. Super, super, super cool.
00:42:43.254 - 00:42:52.834, Speaker A: But I think we might be up on time. Unless anyone else has any last questions that we may have missed.
00:42:55.294 - 00:42:58.714, Speaker B: It looks like Nicole might be requesting to speak.
00:42:59.294 - 00:43:00.274, Speaker A: All right.
00:43:03.204 - 00:43:04.864, Speaker B: Okay. I've just added her.
00:43:08.204 - 00:43:09.144, Speaker C: Hi, friends.
00:43:10.164 - 00:43:11.788, Speaker A: Hello. What's going on?
00:43:11.876 - 00:43:22.544, Speaker C: Hello. Thank you so much for this conversation. I really enjoyed it. I'm learning a lot. My question is, what's next for hash flow?
00:43:24.044 - 00:43:28.584, Speaker A: All right, Victor, you gotta take this one. Or should I go for it?
00:43:29.194 - 00:43:42.042, Speaker B: I don't know. I mean, I feel like. I feel like we added a poll and everyone said Solana, so I'm, like, trying to figure out if it's Solana. So, like, I'm waiting for it to come back online so I can start doing on it. I don't know. What's this for? Hash one?
00:43:42.098 - 00:43:43.814, Speaker A: No, we like Solana, by the way.
00:43:44.434 - 00:43:49.494, Speaker B: Yeah, I mean, Solana is definitely coming. I mean, just. This is Alpha here. Solana is definitely coming.
00:43:49.794 - 00:44:08.234, Speaker C: You just have to wait. You have to wait for business hours, right? Is that the new meme? But no, we also love Solana. We will be on Testnet, on Devnet, on Solana, like, within two to three weeks. So, like, very, very, very soon. So if you guys are going that direction, we will, you know, have that all set up for you.
00:44:08.534 - 00:44:41.144, Speaker A: Yeah, I think the way see this, we are lining up a series of new chain deployments. We're gonna start with all EVM chains. So, like, including optimism, gnosis, and has Phantom as well. And then expand the suite to be on non EVM chains, including Solana and the Cosmos ecosystem and so on. And then from my product milestone, I think we are going to put out a roadmap that will be more public facing in the upcoming week, but I think that's something to look forward to.
00:44:43.684 - 00:44:45.424, Speaker C: Okay, cool. That's really exciting.
00:44:49.984 - 00:45:30.044, Speaker A: All right. I think that might be it. Wet above time, but I think that was worth it. And I hope everybody else enjoyed and learned a lot from this first space. Have you thinking about doing this more of these more often and invite more guests to talk about what's happening in the world of cross chain? Because I think this is a, this is still very, very early and there's a lot to be learned. And I think this is something we could, we could continue doing more often. But thank you so much, everybody, to come to coming to stop by here and looking forward to see you guys soon again next week.
00:45:31.904 - 00:45:33.824, Speaker C: Amazing. Thanks so much for having me, guys.
00:45:33.944 - 00:45:35.024, Speaker A: Of course. Thanks, Brian.
