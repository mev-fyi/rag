00:00:04.200 - 00:00:31.758, Speaker A: What is going on, people? It is Aldo from zero to mastery. And today I'm excited to introduce to you this Python 101 crash course by Andre Niigoy. You don't know who Andre is? Doesn't everyone know who Andre is? Okay, maybe not. Well, all you need to know is you're about to fall in love. Figuratively, not literally. Andre is an incredible instructor with almost 1 million people having taken one of his courses. I am one of his students, so I can attest to just how great his courses are.
00:00:31.758 - 00:01:14.420, Speaker A: And now you're getting to learn Python from him for free. See? Don't you love him already? Okay, okay, I'll be serious now. Andre is a senior developer with numerous years of experience working from startups all the way up to Fortune 500 companies where he has worked on real world applications for companies in both Toronto and Silicon Valley. In this video, Andre is going to start from the very beginning and teach you the complete basics of Python from scratch. If you end up liking this video and want to dive deeper into more complete python topics, then I highly recommend you check out his complete Python bootcamp course, which I have personally purchased and taken. And let me tell you, it's a beast of a course. It covers everything you would ever need to know about Python.
00:01:14.420 - 00:01:37.170, Speaker A: And the best part about it is the projects you build are actually fun and have a real world purpose. You'll get to build an ML model, a web scraper, a Twitter bot, a secure password checker, a portfolio to help you stand out and get hired. If you want to check it out, click on the link in the top right hand corner or in the description down below. That's enough chitchat for me. Let me hand it over to Andre so you guys can start learning Python. Enjoy.
00:01:44.550 - 00:02:27.746, Speaker B: What is a programming language? If someone asked you this question, can you answer it? Programming is simply a way for us to give instructions to computers. We give it an instruction manual and the computer follows. Without code, computer programs wouldn't do anything. You wouldn't be able to move the mouse around on your screen, you wouldn't be able to Google things. You wouldnt be able to play Pokemon on your phone. Right? I cant just tell my computer what to do. You see, computers dont understand English or any other human language for that matter.
00:02:27.746 - 00:03:20.170, Speaker B: So what language do computers speak? Well, they speak in ones and zeros. All electronics speak that language of on or off zero or one. But writing ones and zeros would be gibberish for us. It's hard for us to communicate like that, right? So humans have developed programming languages that are in between human language and machine language. That is, zeros and one. Some programming languages are lower level than others, that is they're closer to machine language, and other programming languages are higher level than others. That is, they're closer to English or a human language.
00:03:20.170 - 00:04:11.734, Speaker B: And there are lots of programming languages. You have languages like assembly that is really, really close to machine code. You have languages like Python and JavaScript that are really, really close to English. Okay, that's great. We have these pieces. But what are we missing here? I mean, if I want to find flights to Hawaii, how do we go from here to, well, having, let's say, a website show us a display of all our flights, telling the computer to show those flight information on our screen. What are we missing here? Well, we have these programming languages that we usually write on a file, such as Python, JavaScript, maybe even Java.
00:04:11.734 - 00:05:14.190, Speaker B: And then we somehow need to get these files that we write into ones and zero so that our machines can understand. Well, we need a translator, right? We take our code that we write what we call a source code written in a programming languages and we give that to a translator that can understand that language but also understands machine language. And this translator just translates these files for us. So what is this translator? It's not really a person, right? I'm not giving my code to somebody and somebody's going to just start shouting at the computer. That would be quite silly. What is this translator ready to have your mind blown? Well, it's another program written by a human. It can either be an interpreter or a compiler.
00:05:14.190 - 00:06:06.698, Speaker B: Now Python usually uses an interpreter, usually, and an interpreter, just like a translator, goes line by line through our code and executes our code on our machine. Compilers are a little bit different. They take your code all at once, reads the entire file all at once, and then translates that to machine code. So again, interpreter goes line by line and each line executes an instruction. A compiler takes the entire file and turns it into machine code. Now the differences between these two are a little complicated and beyond the scope of the course. And don't worry, we're going to come back to this topic.
00:06:06.698 - 00:07:10.996, Speaker B: But I want you to just have this general picture that when we write code, whether it's Python, JavaScript, Java, C or C, what we're doing is we're typing it in a language that is human readable. We're giving it to one of these translators, like an interpreter or a compiler, and these spit out code that are able to run on our machines. So to review interpreters translate line by line and execute the line before going to the next line. Compilers translate all lines of a program to a file, usually called a binary, and execute the whole file at once. Now, in the next video we're going to talk about this process a little bit more in detail, especially on how it works with Python. But why did I start with this? I mean, this is a complex topic. Most developers, especially if they're starting out, don't even know of this process.
00:07:10.996 - 00:08:07.690, Speaker B: They just know that they write code and then it runs. So why did I teach this here? Because in order for us to be able to write Python code, well, I can't just write it anywhere, right? If you went right now to your computer and let's say you opened up a text file like this one and you started typing Python code, but for now we don't know Python. So let's just say I want to go search for Pokemon. Well, this might be code. We don't know if it is, but I can't just use this, right? I mean, this isn't really PYthon code, but how would my computer know what I'm talking about? In order for us to start writing Python, we need to download this translation service. And in the next video I'm going to show you how to do that. I'll see you in that one.
00:08:07.690 - 00:09:02.496, Speaker B: Bye bye. Welcome back. We just learned what a programming language is. It's just set of instructions that we give to a translator, and this translator can be an interpreter or a compiler, and we give these files that we create our own code, our source code, to these translators, and they allow us to give instructions to machines, to computers, to phones. So we learned that we need these machines in order for us to write Python. Right? How can we get these? Well, we download them. And here we download Python from the Python Software foundation, from python.org
00:09:02.496 - 00:09:48.530, Speaker B: dot. Now, before we download Python, we're going to wait a little bit because in this course I want you to understand why we're doing things, not just follow my tutorials, follow my videos, and, well, not understand the meaning and the fundamentals behind what we're doing things you should be able to teach what you're going to learn. So let's take a pause here for a second. If this is the first time that you're learning a programming language, I have some good news for you. At the end of the day, all programming languages do the same thing. They tell the machine what to do. However, different languages have different ways of doing it.
00:09:48.530 - 00:10:54.660, Speaker B: The beauty is that most languages have very similar principles. If this is your first programming language, well, this is going to be the hardest part, learning the first one. Afterwards, every new language you learn becomes easier and easier in the sense that it's not the same as, let's say, learning English and Japanese, two very distinct languages. In programming, things become a lot easier as you learn that first foundational language. Now, if this is not your first language, and let's say you've written code in C, C or JavaScript and you just want to learn Python, well, you're going to find these first couple of videos quite easy, but bear with me, trust me, we're going to get into some advanced topics here and we're going to make you a full fledged developer by the end of this. But let's go back to this topic at hand, this idea of downloading this translator. The thing is, when people refer to Python the language, they're most likely talking about the implementation.
00:10:54.660 - 00:11:38.050, Speaker B: That is, they're talking not about the language itself. Because Python, the language is just a specification. You can think of it as a document that somebody wrote that says, hey, when I write the words def, that means something in Python, and when I write something like print, that means something in Python. But the translation machines, well, we can have tons of them, different interpreters, different compilers. For example, python.org comma. When you click download here, you're actually downloading this, the C Python, because it's written in the C programming language.
00:11:38.050 - 00:12:20.230, Speaker B: This is what you're downloading. It's a program written in C to read your Python file and well, run it on a machine. But there's other implementations. For example, there's the Jython project, and this is a translator that is written in the Java language. There's Pypy, which is actually written in Python. So it's a interpreter, it's a translation machine written in Python. And then there's also things like Iron Python, which is written for the.net
00:12:20.230 - 00:12:55.760, Speaker B: framework. So here's a little trick question. When you download from Python, the official language is actually C Python. You're downloading this interpreter that follows the Python specification. But at the end of the day it's a machine built by somebody. But these machines can well come in many forms. So when most people talk about Python, they're talking about this one, C Python that well does our translation for us.
00:12:55.760 - 00:13:49.650, Speaker B: It interprets our Python code and runs it on a machine. So we're downloading this. And if you want to really get into details as to what we're downloading, well, we're downloading a machine that takes our python code, which don't worry, we're going to write and I it goes through the interpreter which we download using c python. And this c python is going to create something called a byte code. For example, this bytecode prints hello world on our screen. Now this might look like gibberish to you, and even for me, I don't know, bytecode, this looks pretty well confusing just for printing hello world to the screen. Well, the interpreter does that automatically for us.
00:13:49.650 - 00:14:48.636, Speaker B: We don't see it. It's behind the scene. Now once it creates a bytecode that is closer to machine code, it then uses the c python virtual machine again, just something that runs this code and then this code gets run on our machine. Now you're never ever going to be asked this question in an interview. I mean, maybe, and most developers don't know this, but I want you to use this as a reference that when we write python code throughout the rest of this course, this is what's happening. We're writing python, it goes, gets interpreted line by line and formed into what we call bytecode. This bytecode gets run on the c python virtual machine which runs on our computers, our phones, our laptops, and when we're downloading from python.org,
00:14:48.636 - 00:15:13.808, Speaker B: we're downloading these two pieces so that once we have them downloaded, we can run Python. Alright, that was a tough one. And I mean, we just got started. I hope your brain isn't exploding again. This is something for you to use as a reference. But you know what? I think it's time for us to learn how to actually run Python code. And don't worry, we are getting there.
00:15:13.808 - 00:15:40.842, Speaker B: We are going to write our first python program very soon. I'll see you in the next one. Bye bye. All right. Oh man, we've been talking for a long time. How can we finally run Python code? I want to start coding. Right, let's download this translation service.
00:15:40.842 - 00:16:13.420, Speaker B: Right, well, I'm sorry. Actually, this is something we're going to do later on in the course. And I know what you're thinking. WTF, Andre? But what is this, kindergarten? I mean, come on, I came here to learn Python. Start teaching me python. And I know, I know, and don't worry, in this course we're going to get you to have a professional setup with Python so that when you go into the workforce you are doing what you're supposed to be doing. We're going to learn how to have all of these set up.
00:16:13.420 - 00:17:00.106, Speaker B: First we're going to have our terminal or command line where we can run Python from right in what we call a repl. And then we're also going to use code editors like sublime text and visual studio code. We're also going to use ides or integrated developer environments like Pycharm and Spider. And we're also going to use Jupyter notebooks. And I'm going to show you how to set up all of these on your computer. What the pros and cons of using each are, and how some of them might be used for machine learning, while others might be used for writing quick scripts. And I know this is a lot, but it's good to have these skills depending on what type of job you want.
00:17:00.106 - 00:17:48.190, Speaker B: And if you are a professional python developer, well, you should be using most of these. But there's a problem if I start introducing this in the course right away. You see, these tools you have to install differently based on what computer you have. So if you're using a Mac, a windows, a Linux, maybe you're using a mobile phone. Because we want to get started right away and write some code. Instead of worrying about installations and making sure that your computer is all set up, I want to make sure that all of us can get started right away, no matter what device you're on. Now, if you're really, really keen, head on over to the section where I show you how to install all these on all of your devices so that you have it set up and you can come back to this section.
00:17:48.190 - 00:18:30.948, Speaker B: But I warn you, it's easy to run into problems and get confused when installing these tools. So I recommend sticking with what I'm about to show you, and I promise we will get you this professional setup. No other course is going to teach you all these things, but before I dive into these, we need to learn. Well, we need to be able to just have fun and write some code. So what is this trick that I keep mentioning where we don't have to install any of these and still run Python? It's called repl. You see, instead of us having to download this, we can go to repple it. And when you go here, you'll get a login screen.
00:18:30.948 - 00:19:01.350, Speaker B: Now I recommend creating an account on here because trust me, it's going to be very, very useful. It's one of my favorite tools and it allows you to save Python files just online. For example, once you log in and create an account, you can just create a new repl. Choose the language that you want to use. In our case, we want to choose Python. We can name our repl. So we can just call it hey, hey.
00:19:01.350 - 00:20:02.060, Speaker B: And we can just create a replacement and check it out right away. We have, without ever downloading this Python translation service, we can actually start writing python right here in our browsers. And this is going to work for anybody that has an Internet connection and a browser because this interpreter just runs automatically here. And the beauty with Repl is that, well, you can save these files, you can have different folders. So as we work through the course, you can actually have a folder for all your Python work and just have a really nice organized file structure that you can access anywhere you have Internet connection. Now if you don't want to sign up for repl it, it's completely free. You can also use this open source glot IO, which again you go to Python and you're able to run Python online.
00:20:02.060 - 00:20:32.982, Speaker B: So take your time, sign up for repl it, and let's get started with our first Python program. I'm finally getting there. In the next video we're going to write our first piece of code. No more waiting, it's coding time, so I'll see you in the next video. Bye bye. Hey, you're still sticking around. That's good.
00:20:32.982 - 00:21:19.950, Speaker B: I didn't bore you with all my talking, but yes, in this video, finally we're going to write some python code. Holy moly, thank God. I thought that was going to last forever. Alright, so what is our first program going to do? Well, let's create a very, very simple function and probably the first thing any programmer learns to do to print our own name. So in here, once you have your repl it set up, or remember you can also use glot IO. We're simply going to write print. And then you see over here that it gives us some information, but all we want to do is write brackets, a quote.
00:21:19.950 - 00:22:00.288, Speaker B: So you can do double quotes here, or a single quote and just type your name. And if we click run on the right side, we've just written our very first python program. Very exciting. But what's happening here? Well, let's look at everything. First of all, if you're confused why my thing is dark and yours might be light, it's because if I go to settings, I've set my theme to light or to dark. I prefer the dark version. But you can change some of your settings.
00:22:00.288 - 00:22:43.994, Speaker B: You can change the font size if you want, based on when you watch the video, this website. The look might be different, but most of the settings should be the same. We see that we have a main py which is the Python extension. Any file that has a dot py or py is a Python file. So what we've just written here on line one is a program that prints, in this case, Andre Nagoy, or in your case, your own name. And we've written it to this file. Now, repl, it takes, this file already has this interpreter for us.
00:22:43.994 - 00:23:19.330, Speaker B: It runs this piece of code, gives this source code of main py to the interpreter, and runs it right here on our right side. If you look over here, we're using Python version three 6.1. And down below we see that. Oh, we have Andre Nagoy printed. That's awesome. So this is our code running. Remember this diagram? All we've done is we have our main py where we wrote print Andre Nagoy.
00:23:19.330 - 00:23:57.600, Speaker B: We gave it to the interpreter that the repl already provides for us. That interpreter takes our code, converts it into bytecode, and here it'll say Andre Nagoy. And then it runs it in the c Python Vmdez, which was on the right side that we saw. And it finally prints our name because it tells the machine, hey, we want that text printed. So that's what we're seeing here. This is the c Python virtual machine, essentially running this code and telling this machine, hey, I want you to print this. All right, but this isn't very exciting.
00:23:57.600 - 00:24:40.988, Speaker B: I mean, let's make this program a little bit more dynamic. For our first program, we want to do something more impressive than just print name. So I'm going to teach you another thing we can do in Python, and it's called input. Now in here I can say input. And you see that repl dot? It actually gives me some information saying that, oh, I have this, you can just click here and this input over here. Well, what can we do? This input is going to prompt a user, and if I hover over it, you can see how it's giving me some information. But input simply gives us a way to capture information.
00:24:40.988 - 00:25:32.952, Speaker B: So let's say, what is your name? And if I run this code, we see that we have our python code running and it's asking me, what is my name? With this cursor here. So I can actually type something here, I can say Andre. And if I hit enter, well, there you go. I've just typed in my own name. Nothing that exciting, right? But this is where code becomes interesting because we can store this information on our computer. So again, these are things that we're going to go over in detail in our basics Python section. But just to write our first code, let's assign this to memory.
00:25:32.952 - 00:26:14.840, Speaker B: That is, let's say that name equals whatever is the input of what is your name? And then finally we can just print the name. So remember, the interpreter is going to take this first line. It's going to ask, what is your name? I'm going to type something that typed information is going to get assigned to name. And then finally we print name. Remember, an interpreter takes line by line, converts code to bytecode, and then finally runs it. So let's give this a try. I'm going to click run.
00:26:14.840 - 00:27:06.366, Speaker B: Alright, what's your name? My name is Andre. Did you see that? I typed in my name, hit enter, and then it printed out Andrey. So for the final feat, let's greet. So we're going to say print hello and then plus name. Now don't worry about this syntax, we're going to go over it. But all we're doing is saying hello and then adding our name to the end of this. So let's see what happens if I run this and say, what is your name? My name is Andre, and I hit enter, I get hello Andre, but no spaces.
00:27:06.366 - 00:27:48.320, Speaker B: So let's add a little space, hit run again for the fourth time. My name's Andre, and says hello Andre. There it is, our first python program. Now, it's not very exciting because it is our first program. We're just learning the steps here. But I hope, because we've covered some of these topics ahead of time, that this isn't just pure magic, right? You understand that this is source code. This is main Py that we give to an interpreter that runs our code line by line and then executes our program.
00:27:48.320 - 00:28:12.400, Speaker B: In this case our what is your name? Program. How cool is that? This is just the beginning. We're going to get more and more advanced tier. See if you can play around with this. We don't know that much about Python yet, but I hope this gets you excited because, well, there's a lot more coding coming along. I'll see you in the next one. Bye bye.
00:28:12.400 - 00:28:49.840, Speaker B: Hey there. This is Andre from the future. Exactly. Right after I recorded the videos in the replay, well, repl it decided to upgrade their Python interpreter to the version right here. Now you might be asking yourself, hold on, if I go to python.org comma, the version of Python is higher than this. As you can see, the latest version of Python is right here.
00:28:49.840 - 00:29:27.370, Speaker B: But again, repl just takes a bit of time. So we are fine as long as the version is three or higher. Now I want you to keep in mind that repl usually implements the Python interpreter a little bit later because they have to work out some kinks, make sure that it's integrated properly onto their website. So this number might be a little bit lower than what you see on python.org. but don't worry, everything that we do in this course you're going to be able to follow. As long as we're using Python version three, we're all set. Now, depending on when you watch this video, this number might be even higher.
00:29:27.370 - 00:30:10.254, Speaker B: But again, everything we're going to learn you're going to be able to follow. Just keep in mind what I said before that is that these versions are constantly going to upgrade and constantly going to evolve. In this course we're using the latest version of Python. But because Repl now has a higher version, it allows us to do some neat things that perhaps we weren't able to do in older version versions of Python. For example, later on in the course we're going to talk about something called the Walrus operator. And this is a new feature that is new to Python 3.8. And because of that we're going to be able to use it inside of this repl.
00:30:10.254 - 00:30:54.730, Speaker B: But we're getting ahead of ourselves. You'll see that when we talk about the walrus operator. Anyway, just a quick note, let's get back into it. Welcome back. Whenever you start to learn Python, it's unavoidable that you'll encounter this topic of Python two versus Python three. So what is this all about? And it's a very important topic. Now, first of all, Python is created by a human, right? As a matter of fact, it was created by this person right here.
00:30:54.730 - 00:31:22.840, Speaker B: His name is Guido. Now, a programming language is always evolving. It's not like somebody creates a programming language. It's perfect and that's it. No, all programming languages are constantly being updated. Just like on your phone, you constantly get software updates. Well, a programming language is constantly evolving to make it better and better because nobody gets it right the first time.
00:31:22.840 - 00:32:09.840, Speaker B: And by the way, this is a great video that I'm going to link to. You can check it out in the resources. Now, Python was created in 1991 by this gentleman and it was actually created with the name from Monty Python, which was a british comedy group. But like I said before, the language is always evolving. And in 2008, Guido decided that, well, Python version two, which has been used for a very long time, had some things that he and the community wanted to change. So in 2008 they decided to create Python three, a new version of the language. Here was the tricky part.
00:32:09.840 - 00:32:57.400, Speaker B: You see, when you update software, let's say, on your phone or even on your laptop, you expect things to keep working right. Updates are usually good, they're improvements. But some of the features that Python two had, they didn't like or they wanted to change completely. So Python three introduced what we call breaking changes. That is, if you updated to Python three. Remember the Python interpreter, the C Python translator that we've been talking about? Well, as soon as you updated that, your Python two code wasn't really going to work. It's like updating your phone and then all of a sudden all your apps stop working.
00:32:57.400 - 00:33:55.670, Speaker B: That doesn't sound very good, does it? That's pretty much what happened in 2008. Most companies that wrote their code in Python version two just kept Python version two because, well, for them to upgrade meant that they had to go through their code line by line and make some changes. Now, these changes weren't that significant. For example, I'll link to some resources, but don't worry, these are topics that we're going to cover throughout the course. But different things wouldn't work. For example, the print function, which we've learned about in Python two, it didn't have the brackets, it looked like this, and Python three used the brackets so all the code that had print like this would break. Now, the differences themselves aren't that big.
00:33:55.670 - 00:34:44.496, Speaker B: I mean, you can read through them and we'll talk about this in the course, but overall, you can learn them in a day. That's why when we learn Python, most of the time we're learning Python three. But you can use the same knowledge with the older version of Python. Now, you may see some Python version two code out there for companies that haven't upgraded, but it's now what we call legacy. That is, come 2020, it's going to stop receiving security updates. So the community, Python community as a whole is saying, hey, everybody, start using Python three because we're going to stop maintaining Python two. So we're going to learn the most up to date version three in this course.
00:34:44.496 - 00:35:25.598, Speaker B: But we're also going to touch on some older topics that Python two covers, just in case you encounter them when you work for a company that perhaps still supports legacy code. But as I mentioned, the whole community as a whole is moving towards Python three. This website, for example, shows you how many big packages, popular Python packages, which we'll talk about, support Python three. In our case, there's only four popular packages that don't support Python three. So what I'm saying is Python three is the way to go. It's the way of the future. That's what we're going to learn in the course.
00:35:25.598 - 00:36:28.690, Speaker B: But I want you to be aware of the historical context, and one thing to be careful of when in this course you're searching for answers. Or maybe I have some exercises that require you to Google things. For example, if we go to the Python documentation, which is the reference of how well what the programming language does, you'll see that you can choose the versions here, and you always want to go with the latest, but you might find some answers online that still use Python version two. So you want to make sure that when you're searching for answers that you don't encounter any legacy code. Like I said, 95% of the time it's mostly the same, but you usually want to keep current with the language. It has the most community support, most up to date, most secure language. So just a quick note about Python three versus Python two.
00:36:28.690 - 00:37:00.750, Speaker B: When you hear the word Python, people are generally just talking about both Python three and Python two. And if you remember in our repl when we created our first program, you see that you're using Python version 3.6. This is the default standard version that Repl comes with. So right away we know that we're using Python three. Awesome. It's up to date, it's new. The whole community is behind it.
00:37:00.750 - 00:37:37.320, Speaker B: Well, most of the community is behind it, so we're all good to go. I'll see you in the next video. Bye bye. Welcome back. I wanted to answer this question that I get a lot of, even from professional developers that have been in the field for years. So I want to tackle this question really quickly right now. Why are there so many programming languages? Why can't we just have one language that does everything and everybody's happy and we don't have to worry about learning so many programming languages.
00:37:37.320 - 00:38:30.590, Speaker B: And here's the thing, in your career, you don't need to know 510 eight languages. No, you can be a really successful developer programmer with just one language, just finding that speciality of yours. And programming languages like Python, Java and JavaScript offer a lot of opportunities where you don't need to learn another language. But why are there so many languages? If we go to Wikipedia, these are the list of programming languages. And if you're looking through here, you should be intimidated, because there's no way in your lifetime you're going to learn all of these. And well, you won't. Most likely you're going to learn one two, maybe three languages in your entire lifespan or career as a programmer.
00:38:30.590 - 00:39:08.722, Speaker B: And different programming languages are good for different things. Just like we have different tools to, let's say, build a house. You can't just build a house with a hammer. You need different tools that are good at different things to assemble what you want. So it's impossible to build one ultimate language when we have so many applications, so many mobile phones, so many computers, so many devices like cameras. So you have low level languages that we've talked about, like assembly code or c, and then we have higher level languages like Python and JavaScript. Now here's the thing.
00:39:08.722 - 00:39:43.892, Speaker B: Python is usually slower than languages like C or C hash or even Java. And we don't need to get into technical details here. But I do want to tell you about a trade off. You see, you don't really want to write Python code for low level systems and hardware interactions. If you're taking this course, well, you're probably not even interested in that field. You see, Python, although slower than some languages, is good at one thing and does this really, really well. That is developer productivity.
00:39:43.892 - 00:40:42.750, Speaker B: Because Python is so easy to learn, or at least is very similar to the english language, it's become really, really popular for developers to be productive and write code really, really fast in less lines than something like C. So a print hello world, for example, in Python would take, well, just one line. But all languages have their different strengths. For example, if you want to build an app on Android or an iOS device, well, you're not really going to use Python. But if you want to do machine learning, maybe you want to build a web server, maybe you want to do data visualizations, build scripts that process thousands of excel files. Well, in that case you're going to use Python and we're going to cover what different things you can do with Python and what Python is really, really good at in this course as we explore different projects later on. But keep that in mind.
00:40:42.750 - 00:41:23.696, Speaker B: The reason there are so many programming languages is that every programming language excels at some things and, well, doesn't do so well at others. It's all about trade off. There is no ultimate language. And if a programmer tells you, hey, my language is the best language, they're probably junior developers that don't know what they're talking about. Everything is a pro and con, everything has a trade off. And as programmers, what really good senior programmers do is being able to detect what these pros and cons are and what tool to use for a specific problem. Something that throughout this course I'm going to try and teach.
00:41:23.696 - 00:41:54.436, Speaker B: I'll see you in the next one. Bye bye. Welcome back. Let's do our first exercise. And this exercise is going to be really easy for you to skip, but I do recommend that you actually do it. I know it's not coding, but it's important because you'll learn that teaching somebody a topic actually helps you learn. So this is the exercise based on the videos that you've watched.
00:41:54.436 - 00:42:20.900, Speaker B: How does Python work? But don't think about it in your head. I want you to talk to somebody. I want you to teach somebody how Python works. So the first thing you're going to do is go to our community, our discord community. We have lots of people here. We have about 1500 people online right now, plus some alumni, plus some star mentors. Well, there's a lot of people.
00:42:20.900 - 00:43:19.016, Speaker B: What I want you to do is go to the programming buddies channel, if you haven't already, and find a buddy. And with that buddy, whether that person is taking a python course or taking a JavaScript course, it doesn't matter. Just say, hey, can I spend maybe five minutes teaching you how Python works and see if you can explain it to them how it works, just like you've learned. And then after you've done that, I want you to go find a friend or a family member that has never done programming before and see if you can explain in simple terms how Python works. That is how Python gets written as source code. We use this translation service called an interpreter to run this code and then, well, spit out some instruction for our machines. I kind of gave away the answer, but you know what I mean.
00:43:19.016 - 00:44:02.870, Speaker B: I want you to practice teaching somebody this because by understanding these fundamentals, it's going to help you learn more and more and understand how things work underneath the hood as we get more and more advanced. Right. First little exercise. It shouldn't be too hard. I'll see you in the next video. Bye bye. Now let's get started, shall we? In order for any programmer to learn a language, there are four key things that you need to really master for any sort of language, including Python.
00:44:02.870 - 00:45:00.436, Speaker B: First are the terms of of that language. Sometimes a programming language has different words and different definitions for these words that you're going to have to memorize. Things like statements, variables, instantiation, really complicated sounding words, but you need to understand what they mean so that you can talk to other programmers. You also need to learn about a languages data type. That is, what sort of data can a program hold? You can think of it as values, just like in real life, we have different ways to represent values like numbers, letters and symbols. In programming, we have these data types to store information, and each programming language has different sort of data types. Next, we need to learn about actions.
00:45:00.436 - 00:45:41.968, Speaker B: At the end of the day, all programming is, is a way for us to tell our machines, hey, store this data and then retrieve this data and perform some action on it. That's all it is, just using memory and performing some actions. So we're going to learn how to perform those actions. And then finally we have to learn the best practices of each language. There's good ways of writing Python code, and then there's bad ways. So that when we build our applications, our programs, well, we don't have a leaning tower like this, but we have a solid structure and a solid program. So throughout the course we're going to learn about these things.
00:45:41.968 - 00:46:18.192, Speaker B: But keep this in mind, these four things are what you need to become a good programmer. And I want to start the basic Python section with the data types. So let's get started. Let's learn about the python data types, all the options we have in Python. Now we're back to our repl it so we can write some python code. We see over here that we're using Python version 3.6. That's great.
00:46:18.192 - 00:46:50.910, Speaker B: Let's minimize this and start writing our first python code. Now we're going to talk about data types, and Python has several available to us. Now I'm going to list them out for you, and then we're going to talk about each one individually. First we have something called int. And you see right away when I type, I have the repl already give me hint. And it's highlighting it. If I hover over it, it shows me that int stands for integer.
00:46:50.910 - 00:47:40.340, Speaker B: We also have something called float. We have bool, which stands for boolean. We have str, which stands for string, list, tuple, set, and dict. Now what are these? These are data types, right? A data type is a value in python, so you can think of it as exactly that, values. So int would represent all numbers, for example. String will represent all letters, for example. And a program is simply instructions that tell a computer what to do.
00:47:40.340 - 00:48:35.460, Speaker B: And what does that mean? It's all about storing information or a data type and modifying that information. We're taking actions on these data types. So the two crucial steps when learning a programming language is that, well, we have these data types that we need to understand that exist in a language, and then we need to learn how we can manipulate the data, create store, read, change, remove this data from the machine. Now, these data types are called the fundamental data types in python. They are the core to the language. Now, after the fundamental data types, we also have something called classes. So beyond these data types, we can actually create our own using something called classes.
00:48:35.460 - 00:49:39.328, Speaker B: So these will be custom types, again, something that we'll learn about. So I can create a class that I can name whatever I want, for example, supercar. Now that doesn't exist, but I can create it. And we'll explore how to do that in the course. Now, besides the fundamental data types, the classes which will be our own custom types, we also have something called specialized data types. And these specialized data types, they're not built into Python, but they're special packages and modules that we can use from libraries. Now, again, this is a topic that we'll cover later, but these are, you can think of it as extra boosts whenever we don't have a data type that we want in the standard Python package.
00:49:39.328 - 00:50:17.342, Speaker B: And maybe we don't want to create our own custom types, there are specialized data types that we can use from what we call modules. So you can think of it as extensions that we can add to the language. Again, something that we'll talk about later on in the course. And then finally there's another type that is a little special called none and none. As you can see, it's being highlighted, which means it means something in the language. None, as the name suggests, means nothing. It's kind of like the idea of zero in mathematic.
00:50:17.342 - 00:50:43.910, Speaker B: It's the absence of value. It's simply nothing. And you'll see why this is important in programming later on. So these are our data types that we're going to talk and we're going to use in our language. Now we're going to start with the fundamental data types, which are nice and simple for us to get through. So let's start one by one. And you know what? Let's start with these two for now.
00:50:43.910 - 00:51:10.030, Speaker B: I'll see you in the next one. Bye bye. Welcome back. Let's talk about our first data type. And you know what? Let's do two at the same time. We have int and floats. Int stands for integer, as you can see here.
00:51:10.030 - 00:51:37.992, Speaker B: And float stands for a floating point number. Let's explore that. First. Let's start off with integer. An integer is, well, a number, three or four or five. These are all integers. In a programming language you can use integers to do mathematical operations.
00:51:37.992 - 00:52:18.870, Speaker B: For example, two plus four. If I run this well, nothing gets printed because again, we have to perform some action on these data types. And one action that we've learned so far is this idea of printing. And we print something by calling the printhead keyword with the brackets. So the brackets is almost like saying hey, perform this action on these data types. And if we run this, we get six right here. Awesome.
00:52:18.870 - 00:53:05.570, Speaker B: So not only are we using print, but we're also using the plus sign to perform an action to add the two data types together. And as you can imagine, we can do most mathematical operations. The basic ones we can do negative we can do let's say two times four, and then we can also do two divided by four. And if I click run here alright, it looks like everything is working. We've added, we've subtracted, we've multiplied, and then we've also divided. Now here's the interesting part. Up until now we've used what we call integers.
00:53:05.570 - 00:54:09.322, Speaker B: That is, these are whole numbers, there's no decimal places, they're just, well, integers. And a neat trick that I can do here is I can actually say, hey, what's the type of two plus four if I click run here? All right, let's, let's decipher what just happened. I've taught you another action that we can perform, which is something called type, which tells us hey, what data type is this? And just like in math, we go bracket by bracket. So the first part, Python says, hey, what's two plus four? Well, that's going to be six. And it's going to say, hey, what's the type of six? Well, the type of six, that's an integer, so it's going to say class Int. We don't have to worry about the class keyword for now. That's something that we'll talk about later.
00:54:09.322 - 00:54:50.044, Speaker B: But we see here that we're using int for integer. And then finally after this gets evaluated by python, we print out whatever this does, which is class int. Now check this out. Let's do the same for all these ones as well. So we're going to say type here, type here and then type here. And if this syntax is intimidating, don't worry, this is something that you get used to. If this is your first programming language, it is not going to be easy because, well, if it was easy then everybody would be doing it.
00:54:50.044 - 00:55:29.330, Speaker B: So hang in there. Trust me, as you practice more, this is going to start making more and more sense. Now, before I click run, what do you think the output of each one of these lines are? Ready? Give it a guess and let's click run. Alright, we got int for six. We have negative two here, which is also an integer. We have eight here, which again is also an integer. But then we have float because two divided by four is 0.5.
00:55:29.330 - 00:56:06.390, Speaker B: Hmm, what is that? Well, remember we are talking about two data types here. We're talking about int and float. And float is what we call a floating point number. A floating point number is simply a number with a decimal point. In our case this is 0.5, so it's a floating point number. So if we write a number, let's say we'll do print type, and then I'll say 0.001.
00:56:06.390 - 00:56:59.974, Speaker B: What do you think we'll get? Well, we would get a float. If I do 5.001 again, we'll get a float. What about the number zero? If I click run, I get an int because, well, there's no decimal points. Why do we need to make this distinction in programming and specifically in python? Well, it's because a float takes up actually a lot more space in memory than an integer. Right? Because remember this number, the number six, this needs to get stored in memory on our machine. And remember that machines don't really understand this.
00:56:59.974 - 00:57:48.070, Speaker B: They understand zeros and one, and they store this number in something called a binary or binary numbers, which is zeros and ones. Now the problem is when you have decimal places like 0.1, or let's do 10.56, it's hard to represent that in a binary number, zeros and ones, because of this point. So a floating point number essentially stores these numbers in two different locations, one for the ten and one for 56. Now we don't need to get technical here, but that's the idea. The idea is that we need more memory to store a number like this than a number like this.
00:57:48.070 - 00:59:00.402, Speaker B: Now the topic of floating point numbers is really, really interesting, and I'll link to a resource, but the best way to learn more about floating points, again, it's not super important that you know the technical details, but if you go to floating point number Python again, you want to make sure that you go to the documentation for version three and you can actually learn about floating point arithmetic. And these official documentation by Python are always a good tool for you to use whenever you get confused about something or you want to get a little bit more extra detail. But let's get back to the topic at hand. Both Int and float are used for, well, numbers, right? And Python is going to automatically format the type to whatever. Well, makes sense. For example, if in here I do 20 plus 1.11 is a integer.
00:59:00.402 - 00:59:51.758, Speaker B: The other one is a floating point number. But when I click run here automatically, Python is going to convert it to float. Let's remove these here so that we don't get confused by them. So if I run this, we see that this whole expression is converted into, well, a float. Now, if I do, let's say 9.9 here, which will equal to eleven, and I click run, these two floats add up to, while still a floating point number, because if I remove the type from here and I click run, it gives me the result 11.0. It keeps the floating point numbers all right.
00:59:51.758 - 01:00:32.300, Speaker B: But at the end of the day, what we care about is that that Python works the way we expect it to. That is, we can do mathematical operations. As a matter of fact, we can do a few other things as well. There's also this idea of the double multiply. So this means to the power of so two, to the power of two, well, that's going to equal four. Two to the power of three is going to equal eight. We also have the double divide.
01:00:32.300 - 01:01:18.904, Speaker B: That is, we can do two divided by four, but then we use two slashes here. If I click run here, I get zero. This actually returns an integer round it down. If I do three divided by four, I get zero. But if I do five divided by four, I get one. This gets rounded down to a integer. Finally, the last operator that we're going to learn about is called Modulo, and it looks something like this.
01:01:18.904 - 01:02:02.620, Speaker B: If I do five modulo, which is the percent sign divided by four, or Modulo four. If I run this, I get one. Modulo is used to represent what's the remainder of this division. So if I divide five by four, the remainder of this division will be one. If I do six divided by four with Modulo, and I run, I get two. Two is the remainder of four. All right, let's take a break and learn a little bit more about these numbers in the next video.
01:02:02.620 - 01:02:57.386, Speaker B: Bye bye. Welcome back. Let's continue our understanding of int and float. We talked about the idea of these two data types and how we can use operations on them that we're familiar with from math class, plus a few ones that maybe we haven't seen before, such as Modulo or the double slash or the double multiply for the power of. Now, this is really cool, because we can get our computers to do, well, math for us, like a calculator, right? But a programming language also provides for us different actions that we can perform. Now, besides these ones, we also learned that there's a type action that we can take. There's a print action that we can take.
01:02:57.386 - 01:03:55.880, Speaker B: But there's also specific mathtype functions that Int and float are able to use are built into python. Now these are called, well, math functions and functions, something we'll talk about later on are these actions that we've been talking about. Remember our diagram here? We're starting to learn about the data types and the actions that we can perform on them. Now in most programming languages these actions are called functions and we have a whole section on them. But for now there's some functions that we can use. So this is a print function, this is a type function, but there's specific math functions such as round. And you see right away when I type, repl is a tool like an id that hints and tells us what we can add.
01:03:55.880 - 01:04:27.910, Speaker B: So it says round and give me a number and maybe an n digit. But let's just worry about the first one for now. So round, if I do 3.1 and I round here I get two. Well that's not right. Right. That's actually the result from up here because we need to also tell it to perform with a function of print, hey, print to the screen, whatever the result of this is.
01:04:27.910 - 01:05:00.820, Speaker B: And just to make things easier to see, I'm going to comment this out. So I'm just selecting everything and then pressing command slash or if you're on windows, control slash. If I click run, I get three because I'm rounding down the number. So let's say if it was 3.9, I click and I get four. Again, I'm rounding the number. Another math function that's built into python is something called abs.
01:05:00.820 - 01:05:46.728, Speaker B: And you see right away that I get abs here and abs returns the absolute value of the argument. And again, for those that aren't too familiar with math, an absolute value simply means, well, no negative numbers. So an absolute value of negative 20 is 20. And now because we know about math functions, I can start googling, right? I can say, hey, I'm a Python programmer and I want to learn about math functions. Well, I can go Python three math functions and look at that right away. Google tells me that there's a ton that we can use. You don't have to memorize all of these.
01:05:46.728 - 01:06:22.820, Speaker B: As a matter of fact, some of these I've never ever used in my programming career. But it's good to know that they have these tools available to you. And as a programmer this is something that you'll have to get used to. The idea that you won't actually memorize every single action that we can take for each data type because some of these are very rarely used. Some of them you'll never use in your career. The key is to understand how to google them and how to find them. And throughout this course, I will show you the important ones that you're going to see over and over and over.
01:06:22.820 - 01:07:11.918, Speaker B: But as a way for you to develop as a programmer, at least you know that this is how you look for answers and find out that, hey, there's different math functions that we can use with numbers. All right, let's take a break and continue in the next video. Bye bye. All right, this is a big video. Now, these videos are going to be sprinkled throughout the course. They're developer fundamentals video. These are the topics that are going to be super, super short, but important because as a beginner, it's hard to learn these things because you don't know what you don't know.
01:07:11.918 - 01:08:20.508, Speaker B: So what I'm going to try and do in these developer fundamentals is tell you, well, how to avoid the mistakes that I made when I got started and what a lot of people do when they get started. That is, they don't have a clear path and don't understand what the most efficient way to do things is. So with developer fundamentals, we're going to talk about key things to make you first of all, efficient in learning Python, but also make you a programmer that is really, really good and that companies want. So what is this first developer fundamental? It's don't read the dictionary. What does that mean? Well, when you're learning a language such as Python, you're going to have a tendency, especially when you're starting out, to try and learn every single thing, every single function, every single syntax, every single trick. It's almost like you're trying to learn a language by reading a dictionary from page one all the way to page, I don't know, 1200. But that's now how things work.
01:08:20.508 - 01:09:13.169, Speaker B: As a matter of fact, when I work with different programming languages, I don't know all the syntaxes, I don't know all the methods and functions. And what a lot of developers do is not necessarily memorize everything just like you would every single word in a dictionary. Instead, you understand what exists and what you can use. But you can always Google things, and most of the time developers are googling things, no matter how experienced they are. For example, if we go to the Python documentation here, we can go through everything, right? I can go through the language reference and read through everything. And this is really, really useful information. But you're not going to memorize every single thing about the language because there's a lot.
01:09:13.169 - 01:10:14.222, Speaker B: This is the Python language, and then there's also the libraries, the standard libraries that we can use. And if you sit through here and just read everything in here, well, you're not going to memorize anything. In order for you to actually learn Python, you have to use the language. And you'll notice that some things are used a lot more than others, just like in human languages. Like when you learn English, there's really difficult words that don't get used that often, and there's words like and I, the or Apple that get used very often. So we're going to learn the language in a way that makes sense, in a way that's efficient, where we focus on the 20% that gets used 80% of the time, and all these smaller, more complicating things we're going to cover, but we're not going to cover one by one from start to finish. We're going to jump around.
01:10:14.222 - 01:11:04.430, Speaker B: The idea being that when you learn a programming language, you're just using these concepts and slowly you're learning what's out there so that when you have a problem, you can identify it and remember, oh, I think Python has a path library that I can use, or perhaps remember that, oh, I can use tuples in Python. So your first developer fundamental is this, don't learn a language as if you're trying to get 100% on a test. We're going to learn a language by actually using it, focusing on the things that actually matter. All right, that's enough talking for me. I'll see you in the next video. Bye bye. Welcome back.
01:11:04.430 - 01:12:20.390, Speaker B: Let's talk about a important term when it comes to programming, and that is operator precedence. Now, what does that mean again? We're using our knowledge from math class. It's the idea that if I do 20 plus three times four, it means that different operators have precedence over different ones. That is, we multiply this first equals to twelve, and then 20 gets added to twelve because the Python interpreter is going to follow a basic set of rules. For example, if I do 20 minus three here and let's print this out, click run, I get eight because three times four gets evaluated first, which equals to twelve, and then subtract it from 20. It's not that this goes first and then we multiply 17 by four. And this operator precedence shouldn't be new, right? If you've taken any sort of math class.
01:12:20.390 - 01:13:13.760, Speaker B: You understand that this is how well math works, and this works the same in all programming languages. So the order is this. First we follow the brackets, so whatever is wrapped in a bracket, we do first. The second is we do the power of. So whatever is done in the power of will be after parentheses. For example, if I do parentheses here, and then to the power of, let's say two, or let's do plus two to the power of two, well, the first operation that will happen is 20 minus three because that's the first precedence. And then we do two to the power of two because that's the next precedence.
01:13:13.760 - 01:13:55.496, Speaker B: And then only after we do that, we add these two together. If I click run, I get 21, which again makes sense, 17 plus four. After the power of we have the multiplication and division. And then finally the last precedence is addition and subtraction. Now, this isn't going to be a math class. Some people really love mathematic, some people really don't. But I want to just give you this basic understanding of operator precedence when you see it.
01:13:55.496 - 01:14:54.314, Speaker B: We'll do some exercises here to get accustomed to it, but trust me, this is as Mathy as we're going to get in this course. The math part of the course is, well, just here. It's going to get a lot more interesting as we learn about different data types. I'll see you in the next one. Bye bye. Welcome back. This is a quick optional video that, well, with something that you probably won't use, but I want you to just know that it's out there.
01:14:54.314 - 01:15:34.770, Speaker B: And that is there's actually an extra data type that I didn't talk about and it's called complex. And as the name suggests, it's pretty complex. However, a complex number again, is a number that is a third type. Instead of int and float, we also have this type for numbers. Now, the reason I'm not really teaching complex is that you only use this if you're doing something really, really complex math. Most of the time you'll never use it. I personally have never used it, but it is good to know that it exists.
01:15:34.770 - 01:16:34.774, Speaker B: It's the equivalent to a real number, and you can read about complex numbers if you want, but again, that's something that you don't need to worry 99.9% of the time. Another thing I want to talk to you about is this idea that these integers and floats get stored, such as five in memory as binary, that is, as binary numbers, ones and zeros, and there's actually an action or function that we can use in python called bin for binary. And you can see that a bin returns the binary representation of an integer. So it's going to return whatever the binary version of five is. If I click run here, well, I have to print, remember? So let's print and click run and I get the binary representation. Now instead of all zeros and ones, there's also this idea of b.
01:16:34.774 - 01:17:31.810, Speaker B: And that is what Python uses underneath the hood to say, hey, when I see this number with zero b, that's a binary number. But if I google binary number five, I see that the binary number for five is 101, which again, that's what we see here. So that's really cool, really interesting just to know that it exists. By the way, just for fun, let's say that we want to return this into a decimal. Let's say we're at the computer and we just retrieve this binary number. I can do int and then wrap this like this in single or double quotes. And then with the int I can also say, hey, I want this return to a number that is base ten, which is what us humans use.
01:17:31.810 - 01:18:20.916, Speaker B: So if I actually do print here and click run, well, actually we have to do base two here, right? Because what we're saying is, hey, this number is base two and convert it to integer and base two number is, well, zeros and one. It's a binary number. So if I click run here, look at that, I get five. So in your head you can think of it this way. When we store a number like five, an integer like five, when a computer retrieves that number, let's say we're doing some addition, well, it's going to grab this for memory. It's going to say, well, this is a binary number and I'm going to convert it into integer. Very, very cool.
01:18:20.916 - 01:19:19.588, Speaker B: Now, the reason I taught this here, you won't see this a lot in beginner courses and especially so early in the course, but I think it's an important principle, although you might not get tested on this ever, for you to just understand how things are working underneath the hood, I believe is an important thing for you to do in order to become a great developer. So hopefully this doesn't confuse you too much. I'll see you in the next video. Bye bye. There is such a thing as a complex number in Python, but we talked about the main ones, the int and float, and there are still a few data types remaining. But before we get to these, we are missing an important concept and this is going to be our first important term. In Python and as a matter of fact, in all programming languages, it's called variables.
01:19:19.588 - 01:20:03.770, Speaker B: Yep, that's a term. Now, if this is your first time learning a programming language, you might not know what this means. If this isn't your first time. Well, this is very simple because all languages have variables. But what are they exactly? Well, variables store information that can be used in our programs so we can hold perhaps user inputs like values. Maybe when you log into Facebook you need to hold some information, such as your profile picture or maybe your date of birth in a variable. Variables are ways for us to store information on our computer.
01:20:03.770 - 01:20:40.600, Speaker B: So let's have a look at this. If we remove this and let's say I'm creating a quiz program, and this quiz program maybe measures your iq, and let's say you just took the quiz and you found out that your iq is 190, quite high. Good job. But we need to store that information somewhere. Well, we can do that with variables so that in python all we need to do is name it whatever we want. In our case, it will be IQ. And we're going to say IQ equals 190.
01:20:40.600 - 01:21:11.760, Speaker B: And this iq here is a variable. It is something that I just completely made up. I can name it whatever I want. That's a variable too. The idea is that once we assign to a variable, that is, we're saying 190 is going to be assigned to IQ, I can now use it in my program whenever I want. For example, I can later on print make sure it's not cap. Let's do print IQ.
01:21:11.760 - 01:21:58.158, Speaker B: And if I do that and click run, you see that I can use IQ. So we can pretend here that a user takes a quiz, finds out their iq is 190, we can store that information in this variable. And later on when they come perhaps online or try to use the program again, they don't have to take the quiz all over because, well, we store that information in IQ. And remember what I said at the beginning, programs are simply data that's being stored, that's being changed, that's being removed, and that's all programs are. And variables are important concepts in python and all languages. Now, variables can also sometimes be called names. So this could be a name, for example.
01:21:58.158 - 01:22:38.470, Speaker B: And assigning a value is also known as binding. That is, we're binding the value 190 to this variable so that when we request this variable later on in our program, our computer knows how to look for this information. It's going to say, hey, I know what IQ is. I stored it somewhere in memory and it's going to go look for that. And because it's being bound to a value, it points to this value, 190. And remember, this number in memory gets stored as a binary representation in zeros and ones. Right.
01:22:38.470 - 01:23:26.648, Speaker B: But it doesn't matter to us because however our machine stores it, we don't care, we just want to be able to retrieve it. And then when we print it to do well, get 190. Now we're going to be using variables all over the course, but on top of just naming variables however we want, there's some best practices around variables of how you should write good variables. And as a matter of fact, these are specific rules that the python community as a whole has that you'll just have to remember. So let's have a look at this. Variables and remember, this is the symbol for best practices are what we call snake case. Snake case means it's all lowercase and then spaces.
01:23:26.648 - 01:23:50.290, Speaker B: Well, they don't exist. We use underscores. Variables must start with a lowercase or an underscore. Variables can be anything with letters, numbers and underscores. But remember, they have to start with lowercase and underscore. That means we can start a variable with a number. They're also case sensitive.
01:23:50.290 - 01:24:37.772, Speaker B: That means if I create a variable, but let's say this snake case, this variable has a capital e instead of a lowercase, eternity, that'll be a different variable. And then finally, you can't overwrite keywords. Let's go through these with some examples. First, a variable has to be in the form of a snake case. That is, if I want to call this user IQ, I should technically have an underscore here instead of a space just to make sure that a programmer, maybe I'm working on a team, can read this variable. So that's snake case. You also have to start your variables with either a letter or an underscore.
01:24:37.772 - 01:25:09.160, Speaker B: So I can technically do this and I click run. Well, that's going to give me an error because I've changed the variable. So now in order to access that variable, you have to go like this. Now, underscore in Python signifies a private variable, something that we'll go over later on in the course. But usually you're starting your variables with a letter, and afterwards, yeah, you can add numbers if you want in here. That's no problem. This is still going to work.
01:25:09.160 - 01:25:46.796, Speaker B: This is a valid variable. Finally, a variable is case sensitive. So if I do user IQ here and I do capital letters, I can't access this like this because, well, it doesn't exist. Again, it's case sensitive. We have to make sure that we match. And finally, we don't want to overwrite keywords. What does that mean, keywords in Python? Well, they already mean something in Python.
01:25:46.796 - 01:26:17.950, Speaker B: For example, this print is a keyword. You can see it highlighted in blue. So that if I create a variable saying print equals 190, and then I do print, print. Hmm, let's see what happens. We get an error because I can't really assign to this variable because print already means something. Now, I know what you're wondering. What are these keywords in Python? That's a simple Google search away and we'll learn these throughout our course.
01:26:17.950 - 01:27:00.166, Speaker B: If we go to Python keywords by ee, three schools, you'll see that we have these keywords that each mean something in Python. Again, we'll go through these and we'll learn them throughout our course. And if you look, it's not that intimidating, there's not that many. So as we practice, you'll start to get familiar with them. But the easiest way to tell whether it's keyword or an important word in Python, well, you see that it's highlighted in blue. As soon as you create a variable that is unique, it's highlighted in white. And this will be the case with whatever environment that you're typing code into, as long as it's set up for Python.
01:27:00.166 - 01:27:34.284, Speaker B: Now, beyond the Python keywords, there are different things. Like, for example, the int for integer that we've learned. So these we're going to get familiar with. So a good rule of thumb for variables is to make them really descriptive, really say what your intention is. And a good programmer is somebody that's able to name things really well with their variables. So if a new developer comes and looks at your code, it's easily understood. Finally, variables can also be reassigned.
01:27:34.284 - 01:28:33.150, Speaker B: For example, let's say we have iq here of 190, and then I decide to perhaps have another variable, call it user age. And for some reason I want to assign user age to perhaps have iq divided by four. Is that going to work? It should, right? I'm saying user age is going to equal 47.5. I am using iq, which is 190, dividing it by four and then assigning it to user age. I can maybe assign this to another variable called user age or called a. And once again I run this and it's printing the same thing. So you can use variables to store that information and use it whenever you want.
01:28:33.150 - 01:29:22.634, Speaker B: You can use it in operations, you can use it to reassign it, whatever your program needs. Now, later on in the course we're going to learn about classes, and classes actually have a different convention than this, but we'll get to that later on. For now, though, I want to mention two small gotchas with variables that you should be careful with. For example, there's an idea of constants, and constants are those things that never change in a program. For example, if we wanted to create a constant such as the value of PI, let's say for now it's 3.14, we can have it all in capitals, and that's going to tell other programmers that, hey, this is a constant. This number is not meant to change.
01:29:22.634 - 01:29:58.856, Speaker B: I mean, we could change it if we want. There you go. I just made PI equal to zero, so it was stored as 3.14 in memory, but then we overwrote it and reassigned it the value of zero. You can still do that, but a good convention is that if you see this, that means this number, this value, should never be changed. Another type of variable that you're going to see, and this is something we'll see later on in the course, are the, it doesn't look like I just did double underscores here, but it's two underscores. And we call these dunder.
01:29:58.856 - 01:30:24.380, Speaker B: And as you can see here, we have some dunder variables that Python has now. We'll learn more about these later on. But the idea here is that these are meant to be left alone. You should not touch them. You shouldn't create a variable with two underscores like this and call it hi. Hi. And assign it a value.
01:30:24.380 - 01:31:06.406, Speaker B: I mean, you still can. However, this is generally not good practice, so you want to be careful with that. But the one thing that I really want you to take away from this is that variables are really important concepts. In programming, naming variables is one of the most important skills you have as a programmer. I know it sounds silly, but there's so many times that I read code that is so hard to understand simply because a programmer is not descriptive enough. So throughout the course we're going to learn how to name things well so that our code reads like English. And that's the whole point of writing good code.
01:31:06.406 - 01:31:55.848, Speaker B: The point of writing good code is that it's readable and understandable by other programmers. By the way, to finish off, I just want to show you one quick trick. There's also a way that you might see in some code bases that uses something like this, equals one, two, three. And this is simply as a way for us to rapidly assign values to variables multiple times. So for example, if I do print a, then print b, then print c, and I run this, you see that I get one, two, three. We assign value of one to a, value of two to b, and value of three to c. Just a quick shorthand way that you might encounter.
01:31:55.848 - 01:32:29.710, Speaker B: Alright, lets take a break and ill see you in the next one. Lets learn another important key term. Well, two for that matter. One is expressions and the other one is statements. Youre going to hear this a lot when talking to programmers. So what do they mean? Let's have a look. If we create a piece of code here, let's just say iq is 100, iq has lowered.
01:32:29.710 - 01:33:33.400, Speaker B: And then let's say user age is going to equal iq divided by five. An expression is this part of the code? It's a piece of code that produces a value. In our case this produces a value, right? Because 100 divided by five is going to equal 20. So this is an expression. A statement, on the other hand, is an entire line of code, not this entire thing, but an entire line of code that performs some sort of action. In this case, what action are we performing? Well, the action is that we're calculating 100 divided by five and then assigning that value to the variable user age. So this is an expression, this is a statement, and also this is another statement.
01:33:33.400 - 01:34:17.440, Speaker B: So if you hear me mentioning these terms throughout the course, hopefully now you know what they mean. I'll see you in the next one. Bye bye. Welcome back. I want to quickly talk about something called augmented assignment operator. So we've learned that we can create variables like some value and we can assign it a data type. In our case, let's just assign it five.
01:34:17.440 - 01:34:46.508, Speaker B: There's something called augmented assignment operator that allows us to do something quite neat. Let's have a look. So if this value, I want to increase it, let's say five plus two. So add two to it. I could do that. Or I could even use some value which is already five by the time it gets to line three. And do something like this.
01:34:46.508 - 01:35:29.768, Speaker B: If I print some value and I click run, I'll get seven, because five plus two equals to seven. So in memory some value points to seven. But there's a neater way of doing this called augmented assignment operator. Instead of doing something like this, I could just simply add a plus to the equals. So we're going to say some value plus equals two is still going to equal seven. So it's the same thing as before. And this is called augmented assignment operator.
01:35:29.768 - 01:36:06.950, Speaker B: It's a shorthand of us doing something like this. We can also change this to something like minus, which once again is like subtracting two from whatever the previous value of some value was. Now, if I was to do this at the beginning here, so let's just do here and then comment this out. And if I click run, I'll get an error. Because some value is not defined. We haven't really created anything. So in order for this to work, we need to make sure that this variable has some previous value.
01:36:06.950 - 01:36:37.120, Speaker B: So we've learned about the plus, the minus, and then finally we have the multiply. Once again, if I run this, we get ten. Remember, this is just the same as us saying some value times two. It's just a shorthand form. Alright, this was a quick video in case you see something like this in the wild. Now you shouldn't be afraid. Remember that the operator comes to the left of the equal sign.
01:36:37.120 - 01:37:13.530, Speaker B: I'll see you in the next one. Bye bye. All right, we're almost kind of flying through this. I know we're going slow here, but trust me, once you get these data types things become a lot easier. So we're just climbing that mountain so that we can start looking at a higher level at the language of python. To keep going. Let's talk about this data type str, which stands for strings.
01:37:13.530 - 01:37:47.292, Speaker B: Let's see what they are. A string is simply, well, a piece of text. For example, a string can be written with quotation marks and I can say hi, hello there. And that is a string. You see that the color changed here in my editor. I can also make strings with double quotes. So once again, this is also a valid string and I can put anything I want in here.
01:37:47.292 - 01:38:18.936, Speaker B: I can do numbers if I wanted to. Exclamation marks. It's just a piece of text. You can think of it as a sentence for now. And if I do the type function here, remember, these brackets denote that we want to perform some sort of action, which is we're using the type action that python gives us. And if I click run, you see that? Oh, and remember, we have to print it out as well. So let's do print so that we can see the display and I click run.
01:38:18.936 - 01:39:08.490, Speaker B: You see that? It's str, it's a type of string. Now we can use this in important ways. For example, imagine you're creating a login form and we want to collect somebody's username and password. Well, we can have username variable that we assign, let's say some sort of username, let's call it supercoder, and then password can be super secret. And now we have these variables, usernames and passwords that we can use throughout our program, such as to check if a password exists. And remember, I can use single quotes or double quotes. But there's a third way that we can write strings in python.
01:39:08.490 - 01:39:37.352, Speaker B: And this, well, is used for long strings. So let's just create a variable long string. And what we can do here is three single quotes in a row like this. And then here I. I can just say, wow, maybe a pair of eyes of somebody that's really impressed. And let's go with the mouth that actually kind of looks like hair. All right.
01:39:37.352 - 01:40:21.550, Speaker B: And then I finish it off with three single quotes again. So now if I print the long string and I click run. Look at that, my little weird emoji face is printed. So the three single quotes is for long strings that I can keep going on multiple lines. For example, I can't do this with the single quote. You see that the orange color is now gone because Python is going to say, this is a new line and this is another line, and it's going to give me an error because, well, a cret with a quote doesn't mean anything. But if we use three single quotes, you can see that we can do multi line strings.
01:40:21.550 - 01:41:23.574, Speaker B: And this is really useful if you want to have maybe long sentences and paragraphs. Now with a string, we do, we can do some cool things that we saw in the numbers videos. What if I had something like this? Let's say I wanted to grab the first name of a user, just give my own name here and then last name. And again, my super hard to pronounce last name. Could we do something like this where we have full name equals to first name plus last name? And then if we print here the full name like this. Should this work? Well, let's have a look. Let me remove this part over here just so we have nice and clean looking code.
01:41:23.574 - 01:42:08.070, Speaker B: And if I click run. There you go, my name is printed. But you see that there's no spaces here because we're going to use the addition sign to attach Andre to Nagoye. But you can see that there's no spaces here. So I can add a space if I wanted to, or I can just simply create another string inside of here just like this, and then add a space in between. So we're just using the plus sign, which we've seen in the numbers videos, but instead to add strings together. And now if I click run, you see that I got the space because I'm adding a space in here in between the names.
01:42:08.070 - 01:42:56.630, Speaker B: Very, very cool. But there's a few more neat things that we can do with strings. So let's take a break and I'll see you in the next video. Welcome back. I want to quickly touch on the subject of what we call string concatenation. Yes, programmers love creating really complex names when concepts may not be as complex. So what does string concatenation mean? Well, it simply means adding strings together so I can do hello plus Andre and I've concatenated the string.
01:42:56.630 - 01:43:41.060, Speaker B: I've added two strings together. So if I print this, I get hello, Andre. So if you ever hear people talk about string concatenation, that's what they mean. We're concatenating strings. By the way, what do you think will happen if I do hello plus five if I click run? Hmm, that's not good, is it? I get typeerror, must be string, not int. So it looks like string concatenation only works with strings. We'll explore that a little bit more in the next video.
01:43:41.060 - 01:44:20.168, Speaker B: Welcome back. Remember in Python that string is written as str. And this is a special word. Actually, it's a built in, what we call function or built in action that we can take. Now, let me ask you this. What happens if I do string 100? 100 is clearly a number, an integer. But what if we run the string function on this? Let's find out.
01:44:20.168 - 01:45:13.860, Speaker B: Let's do print here and then run this. If I click run, I get 100. All right, but, hmm, is this an int or a string? To find that out, once again, let's wrap this. So the answer of whatever this value is into type like so, I know this is a lot of brackets, but remember, we're evaluating this piece of code. So we're turning 100 into a string or running the string action. And then we're going to check the type of this entire thing and then we're going to print it out. If I click run, I see that it's a string type.
01:45:13.860 - 01:46:17.430, Speaker B: So we've converted 100 into string using this. Now, just to confuse you a little bit more, what if we do something like int like this? All right, even more brackets. What happens now? Can you guess? Well, we convert 100 into a string, then convert it back into an integer, and then we check the type of it, which is a class int, and then we print that. So remember, this was the same as me saying a equals STR 100 and then b is going to equal int of a because we're evaluating this part. And then I'm saying c is going to equal the type of whatever b is. And then finally we're printing c. So that piece of code was the same as doing this.
01:46:17.430 - 01:46:51.122, Speaker B: Very, very cool. Now, this is the idea of type conversion. Again, if I were to write that down, it's called type conversion. We're converting the type of our data types and you can do that throughout programming. And we'll talk a lot about this throughout the course. But it's the main reason we have things like STR int, we have things like float and many other data types that we're going to talk about. I'll see you in the next video.
01:46:51.122 - 01:47:45.566, Speaker B: Bye bye. Welcome back. Let's talk about something called escape sequence in Python. Let's comment this out and let me ask you a question. What if we wanted to have a string that tells me, let's say the weather, and here we want to write it's sunny. Hmm. You see how the highlighting changed here? Because I want to say it's with an apostrophe s, but Python is reading this and saying, okay, this is the start of the string and this is the end of the string, and then I have no idea what this is.
01:47:45.566 - 01:48:34.840, Speaker B: And then we're starting a string again. How can we fix this? Well, we can add a double quote string and said, and this now works. But what if for some reason we also wanted to add its kind of sunny in quotation marks? Well, now we have another issue. So how can we solve this? Because in human language we have double quotes and apostrophes. Well, we can use escape sequences here. And this is a little hard to understand at first, but it's simply adding a slash like this. So the one right above your enter on the keyboard.
01:48:34.840 - 01:49:22.954, Speaker B: So this slash, when Python goes through it is going to say, all right, whatever comes after this, I recognize this symbol. Whatever comes after this, I'm going to assume it's a string. So now if I do backslash here and then backslash here, it's going to say, hey, Python, I'm letting you know whatever comes after this is a string. I'm letting you know whatever comes after this is a string. And then I'm letting you know what comes after this is a string so that when we print the weather, everything is printed nicely. Awesome. Now, this escape sequence can be used in multiple ways.
01:49:22.954 - 01:50:06.654, Speaker B: For example, if I want to have an actual backslash, well, I can go like this. And because it's saying whatever comes after this is a string, it's going to assume that this is a string now. So if I run this, you see that we get this backslash and there's a few other neat tricks that you can do with it. For example, one of it is the backslash till. Hmm, what does that mean? Well, let's remove this for now. There you go, the backslash t, remember? Well, let's add a space in here so we can distinguish. It is going to say, hey, whatever comes after this, I want you to add a tab.
01:50:06.654 - 01:51:05.952, Speaker B: This is a special meaning here. So if I click on run, you see that it's added a tab spacing to my string. Another one is using n or a new line. So let's leave t here and then add a backslash n and then say, hope you have a good day. What do you think will happen here? If I click run, I have a tab from the backslash t, and then I have a new line after, kind of sunny, because I do the backslash n, which denotes a new line so that this shows up on a new line. Now, these escape sequences are hard to see at first, but they're pretty much available in all programming languages that use strings. So if you come from another language, this shouldn't be that strange to you.
01:51:05.952 - 01:51:46.354, Speaker B: If it's your first time seeing this, you just need to get used to this syntax. And every once in a while go to the python documentation and just type in escape sequences and you'll see all the ones that we have. These are the main ones that you need to know. All right, more to learn in the next video. Welcome back. Let's talk about the topic of formatted strings. Up until now we've just written simple strings, but we want a program that's dynamic, that's static.
01:51:46.354 - 01:52:35.216, Speaker B: Let's say we have a Amazon page and we're working on Amazon actually. And when a user logs into their profile, well, we want to display their name or what they have in the carta. In that case, we don't want to just hard code and write every single user's name, like Andre or another user Joe, and write every single name in the world. No, ideally what we can do is have something dynamic where let's say it's a profile page and we simply use the name variable and we display that on the page. Now this name variable should equal whatever the user's name is. And this is something that we can grab from the database. Again, something that we'll talk later on in the course.
01:52:35.216 - 01:53:19.970, Speaker B: But let's assume that in here when we do equals we're going to grab some user information, which will be the name and this name for now will be John or let's go Johnny. And this Johnny we want to display on the profile page. And we can do that with formatted strings. We can simply do something like print and then say name. But we also want to greet that person, right? So let's do hi and then plus name. And remember to add a space. If I click run I get high Johnny.
01:53:19.970 - 01:53:56.010, Speaker B: But as we get more and more information, let's say we have age and Johnny is 55. If I wanted to extend the sentence and I want to say you are and then add another plus, make sure we add a space in here and then add year old run here. Hmm. All right, we get a type error, must be string, not int. Oh boy. Alright, so we have to convert this into a string. So remember we can do that like this.
01:53:56.010 - 01:54:53.220, Speaker B: And then if I click run hi Johnny, you are 55 year old or years old. All right, that was a little cumbersome, but we're making our Amazon page dynamic. We can grab different information from the database and we'll have in a string something according to the user. But there's a better way of doing this. And with formatted strings all we need to do is add an f at the beginning and this f at the beginning is going to tell Python, hey, this is going to be a formatted string. And instead of doing all this plus and name and all this stuff and doing the Str to convert the type, we can simply do something like this. Let's remove this and simply do brackets and say name.
01:54:53.220 - 01:55:44.150, Speaker B: And then again remove all of this and say age. So I'm going to say hi name, you are age years old. And if I click run here, you see that it still works. This is a new feature of Python three. By adding f to the beginning it's saying hey, this is going to be a formatted string. And I want you to just make these variables available as strings inside of, well, this string. How much cleaner is that? Now, although this is nice and clean, and this is my preferred way of writing strings, before Python three you didn't really have this.
01:55:44.150 - 01:56:26.966, Speaker B: So in python two. And mind you, this works in Python three as well. As you can see, we had something different to accomplish this. What we had was this idea of a dot format and dot format. So let's remove the f here is going to do the same thing for us. We do a bracket here and then we say hey, we want Johnny and age of 55 and we can just remove these variable names. If I click run here, hmm, I get an error and you have to be careful here.
01:56:26.966 - 01:57:02.830, Speaker B: Dot format works on strings, but you can see over here that we did it outside of the brackets. And what it's doing is saying, hey, run the format. Action on this print. But print is not really a string, right? So you have to make sure that we move the brackets to the outside so that we evaluate this piece of code first. So the string is going to get formatted, and then we're going to print. If I run this. Hi, Johnny.
01:57:02.830 - 01:57:30.720, Speaker B: You are 55 years old, so that works the same way. But what if we wanted to use variables? Because right now we're just doing this by order, so whatever I comes first gets filled in first in the brackets. Well, we can do something like name and age. Let's see. Can we do that? Let's run. There you go. That works the same way.
01:57:30.720 - 01:58:05.850, Speaker B: What if we had a specific order? Maybe we want this to be age and here to be name. Well, we can mix those around. We can say one here and zero here, because in computer science we always start counting from zero. So this is zero and this is one. If we had something else in here, let's say a third variable, then this will be two. So if I click run here. All right, everything is upside down.
01:58:05.850 - 01:58:37.234, Speaker B: Finally, I can just create my own variables if I wanted to. So let's say hi, let's say new name equals Sally, and then age of Sally is going to equal, let's say, 100. Sally is very old. Now. If I do zero, let's say I'm one here, I click run. So now we'll actually get an error. Tuple index out of range.
01:58:37.234 - 01:59:05.412, Speaker B: Now, we haven't really learned about tuples and ranges, and this is a little confusing, but a bit of a trick here. We want to make sure that we add now because we've given the actual variable a value. We need to actually say new name here. And here will be age. So that if I click run. There you go. Hi, Sally.
01:59:05.412 - 01:59:41.958, Speaker B: You are 100 years old. As you can see, with dot format, things are a little bit more complicated. You'll still see this, and all Python two code still uses the dot format, and you'll see a lot of python three code bases that still use dot format because some people prefer it. But I would argue that the f at the beginning of a formatted string is the way to go because, well, it just makes things so much easier. Right. Nice and clean. Nice and easy.
01:59:41.958 - 02:00:53.956, Speaker B: So I do recommend that you use the formatted string with the f in front. And for short, we usually call this an f string. Alright, I I'll see you in the next one. Bye bye. Now up to this point, we've learned that STR is an ordered sequence of characters, right? It's essentially a piece of text where we can write our names, passwords, paragraphs and sentences and strings underneath the hood are stored in memory, as I said, as an ordered sequence of characters. So, for example, if I had the string, me, me, then this will be stored in our computer's memory in an order. So m will be stored in a place in memory, and after that place in memory, e will be stored, then the space will be stored, and then m, then e, then space, then m, then e.
02:00:53.956 - 02:02:06.730, Speaker B: So if you think of a bookshelf, each one of these is ordered in a different part of the bookshelf, but one after another. And the way we can think about this is like this. The m is stored in location zero and then e is stored in location one, and then space is stored in location two and so on and so forth. And each shelf now corresponds to a value so that when we ask the computer, hey, I want you to grab this string. We know that, hey, we're going to look in the shelf zero to seven. Now why is this important? Because one of the most useful things you can do with strings is to access different part of a string using its what we call an index. So for example, when you have a string, and let's call this variable or this piece of string selfish, and selfish has me, me, me, me.
02:02:06.730 - 02:03:09.800, Speaker B: And I'm going to comment this out just like this, make sure it's aligned. Okay? And what I'm going to do here is I'm going to say selfish and then square brackets right here and then type in zero. Now if I print this and I click run, check that out, I get the letter m. Why is that? Well, using the square brackets, I'm telling the computer, hey, grab the variable selfish. And then from that variable selfish, grab whatever is in index of zero. And what's on that bookshelf of index of zero? Well, the letter mh. What if I do seven? What do you think will happen if I click run, I get e, because on the bookshelf of number seven, that's e.
02:03:09.800 - 02:03:48.906, Speaker B: And when I'm getting just selfish, I get the entire string. It's going to say, all right, I'm going to grab from the bookshelf index of zero all the way to seven. Very, very cool. And this concept we're going to explore throughout the course. And you're going to see why it's important very soon, but using this knowledge, we can do a lot of string manipulation. And Python has this unique feature that we're going to talk about right now that allows us to grab different pieces of text. So let's have a look here.
02:03:48.906 - 02:05:00.020, Speaker B: The rule here is when we use square brackets in python, the first item that we put between the square brackets is what we call the start. The start is, hey, where do you want me to look? In our case, we said we want to look at zero. So we got m, we wanted to look at seven, we got e, but then there's an extra thing that we can do. If we do a colon here, we also have the option to say, hey, where to stop? What does that mean? Well, if I do something, and you know what? Let's change this to 0123-4567 just so it's easier to understand. If I do, let's say zero, colon two, and I click run, I get start at zero, end at two, so I get to grab zero to one. Because remember I'm saying start here, but then stop as soon as you get to bookshelf two. We don't want that.
02:05:00.020 - 02:05:53.048, Speaker B: So if I do zero to seven, what do you think will happen? Well, I click run and I get all the way to six. So in order for us to grab the full string, we have to do zero to eight because there's actually eight characters here, right, because we start from zero. If I click run. There you go. Now, there's a third thing that we can add here, and this is called the step over. And the step over says, hey, start here, end here, and then step over a few things. So the default is one, because we're going one by one to our bookshelf, you see that we get the entire string, but if I add two here, it steps over by two.
02:05:53.048 - 02:06:45.960, Speaker B: So I grab zero, then I step over one, two, grab two, then step over one, two, grab one, graph four, step over, and so on and so forth. So let me ask you a couple of tricky questions here. What happens if I do this? Is this valid? If I click run, what will happen? Ready to guess? I get 123-4567 this says, hey, start at one. So that is right here, but then afterwards stop. Well, there's nothing there, so the default is going to say go all the way to the end. I know this is confusing, but hang in there. Practice this often enough and this will become second nature.
02:06:45.960 - 02:07:40.874, Speaker B: Okay, what if I do something like this where I don't follow the start and do five here? What happens now? Ready? I get 01234 all the way until five. So it starts as default zero and goes to five. Okay, what if I do something like this, two semicolons and then one. If I click run. Alright, I get the default behavior because it's starting at zero when there's nothing. It ends whenever the string ends when there's nothing, and then we're stepping over through it once. All right, but what if we do something like this? What if I do minus one here? Hmm, this is a tricky one.
02:07:40.874 - 02:08:25.632, Speaker B: What will happen? Let's find out. I get seven. In python the negative index means hey, start at the end of the string, so that if I do minus two I get six, if I do minus three I get five because I'm going backwards. And a neat trick that you can do here is if we do semicolon, semicolon minus one, and this is actually quite a common operation. So you just have to memorize this, even though it looks weird. It means start, stop. There's no limit here, but I want to step over from the back.
02:08:25.632 - 02:09:33.210, Speaker B: So what do you think will happen here if I click run? Do you see that? We get the reverse of the string. So this is a very useful notation if you want to, let's say reverse an order, and if we want to, let's say skip by two, I click run and you see that we're skipping by two now. Now hopefully your head doesn't hurt with all this notation. You just have to get used to it. It's something quite unique to python, but it's very, very useful. So up until now we learned that strings can be accessed quite easily, and using the square brackets we can access different parts of the string. And this idea of a start, a stop and a step over is what we call slicing or string slicing, because we can slice the string however we like.
02:09:33.210 - 02:10:27.634, Speaker B: But we also need to learn another important term that's going to come up again and again throughout this course. And as a matter of fact, it's an important concept that as you get more advanced into programming, you really need to understand. What is this concept? Well, it's this idea of immutability. It's an important term in programming. What does immutability mean? Well, strings in python are immutable. That means they cannot be changed. What do I mean by that? Now that we've assigned selfish this value, this string, well, I can reassign it, right? I can say selfish is 100 now, and if I print selfish and I click run, that works.
02:10:27.634 - 02:11:35.652, Speaker B: But if I instead do something like the first index of selfish is going to equal eight. And I click run, I get an error, I get a typeerror saying string object does not support item assignment. Why is that? Because strings are immutable. That is, I cannot change the value of this once it's created. I can't just immediately change it to 8123-4567 no, it has to stay the same. The only way that I can remove this or change this is to completely reassign the value so that in memory, Python removes all of this from our bookshelf of memory and instead just assigns eight into the zero bookshelf and removes everything else because we don't use it anymore. Now, this idea of immutability is something we'll explore more and more, especially when we start talking about lists.
02:11:35.652 - 02:12:16.584, Speaker B: But for now, just remember that you can't reassign part of a string once created. It exists like that, in that form. The only way we can change it is to create something new. We can do selfish plus eight, and we can create it that way. But now this selfish is a whole new string. This no longer exists, and a whole new shelf space was created for us to use this whole new string again. If this doesnt make sense to you or why its important just yet, dont worry.
02:12:16.584 - 02:12:39.946, Speaker B: Well get there. For now, though. Ill see you in the next video. Bye bye. Welcome back. So far, we've learned a few built in functions that Python has. Few built in actions, right, actions that we can take on data.
02:12:39.946 - 02:13:21.120, Speaker B: And we learned about STR, we learned about Int, we learned about float and the type conversion that we can do. We also learned about type. We also learned about print and these built in functions in Python. Well, there's a few of them, and I'll link to this resource, but there's not too, too many. As a matter of fact, we've also seen ones like Abs or round in our numbers video. So numbers had some functions that we can use. Some built in functions.
02:13:21.120 - 02:14:15.390, Speaker B: Well, strings also has a very useful one called len, which stands for length. So, as you guessed it, if I type in something like this and I print this out and I click run, I get nine, because it's calculating the length of the string. In our case, 123-45-6789 the length of the string is nine. Now, you have to be careful here, because the length itself doesn't start at zero, as we've seen with indexes. Instead, it counts like humans do from one. So a neat thing to do here is I can do something like this. Let's say that we have a variable greet that equals hello.
02:14:15.390 - 02:15:22.660, Speaker B: Well, I can grab the greet variable, which is a string, and use string slicing to grab well the first and then go all the way until the end. Now, the default already does this. If I leave it like this, it's going to grab hello. Oh, make sure I add a bracket here. Let's click run, I get hello. Now, if I do zero to length of greet, what does that mean? Well, if I click run, I still get hello because the length of greet is nine like so. Now this length function is quite useful, and we're going to use it a lot in this course, but I want to introduce to you the concept of built in functions as well as what we call built in methods.
02:15:22.660 - 02:16:15.380, Speaker B: Hmm, what does that mean? A built in function had this syntax of the word that was highlighted in blue, and then we used curly brackets to perform some action on a data type. However, Python also has this idea of methods and methods are similar to functions, but they, they are owned by something. So for example, in Python we have string methods. So these are methods or actions that only strings can perform. And don't worry, this is something that we'll talk more about when we talk about classes and functions. But for now, Python, for example, has string methods. So these are methods that we can use specifically for strings.
02:16:15.380 - 02:17:07.679, Speaker B: And methods have a special syntax where instead of just the word with the curly brackets, it usually has a dot in front of it. So dot and then some sort of word. And we've actually seen one format, right? Dot format, curly brackets or brackets is a method. And if I go to python string methods and I scroll down or scroll up, we see that format format specific values in a string is a method. Now, why do we care? Well, with this, Python gives us automatic tools that we can use on strings. So let's explore some of these string methods. Let's create a quote here, and the quote is going to be to be or not to be.
02:17:07.679 - 02:17:56.700, Speaker B: Now in here with this quote, we can use some methods on this string. Now, I'm not going to go through everything because, well, 60% of these you're most likely never going to use in your career. I'm going to go over the important ones that you'll see over and over again, but I'll also link to this so that you can see this for yourself as a reference. Remember, as a programmer, your job is not to memorize this and read a language like you read a dictionary. Instead is to know that this resource exists and it's for you to explore and learn as a specific problem occurs. But let's get back to the task at hand. One thing that we can do is to use the upper method.
02:17:56.700 - 02:18:49.389, Speaker B: We use a dot and then type in upper and then the curly brackets. And luckily for us, our editor shows us that this actually exists because of the dropdown menu. So what happens now? If I print this and I click run? Look at that. Everything gets capitalized to be or not to be. There is also another one we can use called capitalize. What's the difference between the two? Well, if I run, you see that it capitalizes the beginning of the sentence. And by the way, your editor, or in our case, our repl, if you hover over this, it'll actually tell you what it does.
02:18:49.389 - 02:19:32.770, Speaker B: It returns a capitalized version of s. So whatever is to the left of the dot, and a good editor will actually show you all the things available to you. So as soon as you press a dot, look at that, I see all these purple boxes, which are methods that are available to me for a string. And you see there's a lot of them. Now, don't worry about these double underscores, these Dunder methods, because this is something that we'll talk about when we talk about classes. But you can see that you have different things that you can use. For example, you have lower instead of upper.
02:19:32.770 - 02:20:36.694, Speaker B: It lowercases everything. What if I want to use find, for example, and find simply says, hey, does b exist in the code to be or not to be? And if I click run? Well, it tells me that, yes, quote, dot find has b, and it starts at index of three. So if I go to zero, one, two, and then look at that, three. So we have find, which finds us the first occurrence of a piece of text. You also have things like replace, where I can replace whatever I give it as the first thing and then separate it to the second thing. So you can see over here, it tells me old and then comma, new, and I can replace this with me. If I click run, I get to me or not to me.
02:20:36.694 - 02:21:16.874, Speaker B: So this replaces all the occurrences of me. Now, the final thing I want to point out to you is that if I print here, what do you think is going to happen? I've printed here and I replaced to me, to be or not to be with. To me or not to me. Quite a selfish quote. But if I print this again on the fifth line, what do you think will happen? Let's find out. Whoa. Is this what you expected? Think about why this might happen.
02:21:16.874 - 02:22:08.478, Speaker B: Based on what we've learned, here's the thing, remember, strings are immutable. That is, they cannot be changed. We can overwrite them if we want, but we don't change them. We either create them or destroy them. In our case, when we do quote replace to me or not to me, it's creating a new string. Now, we're not assigning this string to anything, so eventually after we print it, we remove it from memory. But if I do something like this where I have quote two equals quote replace and I print quote two, well, in our case, we're creating a whole new string.
02:22:08.478 - 02:22:32.120, Speaker B: We're creating a string but we never modify the original string because it's immutable. So that quote always stays the way it is until we destroy it. Until we remove it, our program ends. This is going to exist. Alright, hope you're having fun. Hang in there. More to learn in the next video.
02:22:32.120 - 02:23:15.672, Speaker B: All right, all right, all right. So up until now we've spent forever talking about numbers and strings and you're thinking, oh God, we have so many more to go through and my head hurts already. Well, you know what? I think you're going to really, really like this one because this one's really, really short and they're called booleans. And booleans in Python is bool and bull. Well, there's only two options. A bull can either be true or false. That's it.
02:23:15.672 - 02:24:05.456, Speaker B: How awesome is that? You just learned booleans. So a boolean I can assign to, let's say, my Facebook profile, I can say Andre, or I can say name equals Andre and make sure that we form this into a string. And then I can say, well, let's say we're creating an even better social network than Facebook. We're creating our own. And this social network also has the is cool option on your user profile. And let's say for now it's false. You see over here that's being highlighted now, iscool is set to false, but all of a sudden I'm thinking, hmm, my profile doesn't look good if iscool is set to false.
02:24:05.456 - 02:24:46.268, Speaker B: So I'm going to change that. I'm going to say is cool is now equal to true. Now my profile has been changed to iscool is true. Hooray. And that's it. Booleans represent this idea of true and false, which in programming is kind of like saying zero and one. They're logical values, right? There's some logic that we can use and we'll see when we talk about conditionals in upcoming videos where booleans become really, really useful because we can use booleans to control the flow of our program.
02:24:46.268 - 02:25:34.970, Speaker B: To do something if something is true, to do another thing if something is false. It's a cornerstone of computer science. And by the way, a topic we're going to explore more and more is this idea of using booleans to denote logic. So, for example, what do you think a bull of one converting one to Boolean would do? If I print this and I click run, I get true. In Boolean, one means true, a zero, well that equals false. And remember, we're just simply converting this integer into a boolean value. And a boolean, well is just either false or true, nothing else.
02:25:34.970 - 02:26:01.340, Speaker B: That's it. And I can also convert a string that says true into a boolean true. Again, this is something we're going to explore a little bit more when we talk about conditional logic. But I wanted to make this video nice and short to let you know that hey, not all these data types are as complex as, well, numbers and strings. All right, nice and short. I'll see you in the next one. Bye bye.
02:26:01.340 - 02:26:53.880, Speaker B: Welcome back. So up until now we've learned about integers, floats, strings and boolean values. So let's try and tie some of those things together. Let's imagine you are Facebook. How do you think Facebook works underneath the hood when it comes to your profile? Well, they would have, let's say a variable called name, and this will have your name, and then they'll probably have a variable with your age, let's say 50. I'm not actually 50, but I'm pretending to be for this case, just so I sound wiser. And then let's say relationship status.
02:26:53.880 - 02:27:30.080, Speaker B: So again, we also have relationship status on Facebook. And for now, let's say single. So that's my Facebook profile right there. Now, if we wanted to perhaps change that, let's say my relationship status all of a sudden goes from single to it's complicated. Well, that's an easy fix. We would just do relationship status equals to it's complicated. And remember, because of the single quote, we'll have to do backslash.
02:27:30.080 - 02:27:53.940, Speaker B: It's complicated. And now if I print my relationship status, you'll see that it's been updated to it's complicated. I am no longer single. Hooray. But this is pretty simple. Let's do something more complicated. And this is going to be a fun exercise.
02:27:53.940 - 02:29:03.836, Speaker B: Let's create a program that guesses your age. Let's use the input method that we've seen before. Remember, the input method allows us to type something in here and receive it as input so we can assign that to a variable. So let's say this variable is going to be birth year, and that's going to equal the input that's going to ask when or what year were you born? Now, from here, I want you to pause the video and try to solve this yourself. How can you make it so that at the end of this program you're going to get asked what year were you born? You're going to type in your year and then it's going to print out your age is whatever the age is. So pause the video, try and solve this on your own. Mind you, there is a bit of a trick in here.
02:29:03.836 - 02:29:48.380, Speaker B: So if you get stuck, try to google around and figure out what the issue may be. Again, part of being a programmer is trying to solve these problems that you don't know the answers to. All right, let me show you my solution. We have our birth year here that we're going to store in a variable, and now we're going to calculate the age. I'm going to say age equals, well, it's going to equal the current year. Let's say 2019. And then 2019 here is going to get subtracted from whatever the birth year that you entered.
02:29:48.380 - 02:30:28.122, Speaker B: So let's enter that. And then we're simply going to say, print your age is, and we want to use an f string here. So I'm going to add an f here and then simply say age. If I run this, I get what year were you born? I was born in 1986. Hmm. We get an error. And if you try this yourself, you may have encountered this error.
02:30:28.122 - 02:31:06.280, Speaker B: We get something called a typeerror, and there's lots of errors that you can get in python. Again, we have a section on error, so don't stress too much about it. But if you read here, it says unsupported operand type s for minus, int and stringental. Hmm. Let's try and debug this. It looks like we're using minus on an integer and a string. So let me print out here the type of birth year.
02:31:06.280 - 02:32:04.560, Speaker B: If I run this and let's enter 1986, I get class string. And this is a little gotcha, because what input does is it asks you for an input, but that input that I wrote, 1986, well, that actually gets converted to a string and assigned to birth year. So what that means is that we're trying to subtract a number or a string from a number. So how do we solve this issue? Well, you'd have to turn this into an integer. And this is something that we saw previously. What we need to do is to convert this into an integer with using the int function. So let's try that.
02:32:04.560 - 02:33:12.740, Speaker B: If I remove this and click run, I'll say 1986. And look at that. Your age is 33. We've created a program that is able to tell your age based on the year that you were born. Now this may have been tricky to you, but it teaches an important concept in programming that is, sometimes you're storing data into different data types, and sometimes you need those different data types to interact together. So you'll see a lot of problems where you have to convert a data type, and this is a very common one where you take an input that's a string and then you convert it to something like an integer so you can perform a mathematical operation. And that's why, if you remember, we gave you a list of all our data types in Python, the fundamental data types, and all of them were blue because, well, each one of these are actions are functions that we can use.
02:33:12.740 - 02:34:19.710, Speaker B: For example, I converted the birth year into integer, but I could have also converted this to a float, for example. And if I run this, it would still work because Python knows that well, we can use integers and floats in mathematical operation, but you can see here that it's converted into a float. Now, if we convert this into a boolean and I click run, your age is 2018. That's really confusing, right? Well, that's because this gets turned into true, and underneath the hood, Python does something weird where a true value is converted to one, because Boolean, remember, it's one or zero, true or false. Alright, hopefully this didn't confuse you too much. It's something that we'll encounter throughout the course, so don't worry, we'll get more and more practice. However, I hope you get to practice this a little bit to really understand what's going on.
02:34:19.710 - 02:35:05.366, Speaker B: Because although this is a couple of lines of code, the principles that we use here, we're going to use throughout bigger and bigger code bases. So I guess I'll see you in the next one. Bye bye. Let's talk about another developer fundamental, and this one is commenting your code. Up until now you may have seen me comment, add comments to our scripts. For example, right here I added a comment of booleans and this tells the python interpreter, hey, this is a comment. Don't run this, it's just for me.
02:35:05.366 - 02:35:54.080, Speaker B: You can just ignore it and skip over to line two. And you saw that I simply did that in python with the consignment, as soon as Python sees a pound sign it adds a comment. And you can do that after a line as well. I can say this assigns to a variable and although this may look like two lines, it's actually just the word wrapping that's happening. And you can see that the interpreter just completely ignores these comments. Now commenting sounds very very simple, but it's an important concept. And if you want to be a good programmer in all languages we have commenting, but there's good ways and bad ways of commenting and this is something that comes with practice.
02:35:54.080 - 02:36:49.958, Speaker B: But here are some key guidelines. When you're commenting your code, the idea is that you're adding valuable comments. That is, if I add a comment here that says, hey, this is assign name variable a value of Andre string a comment like this is not really good. Why is that? Well, because your code should be self explanatory, right? The idea is for us to write code that is easy to read, easy to understand. It's not trying to be clever. Instead it should read like English. And any Python programmer would know that here we're just simply adding Andre as a value of name.
02:36:49.958 - 02:38:01.220, Speaker B: We're assigning a variable and adding a comment like this that's self explanatory just adds clutter to your code. So there's a trade off here. It's good to comment your code for, let's say if you're working on teams and other developers come and they want to understand your code, but you have to remember this principle of code being easy to read. The only time you want to add comments to your code is, well, when something really really important is happening where it might be a little complex, you first decide, hey, is this code written in a way that makes sense? For example, if this was variable a and this was variable b, well, this might be really hard for somebody to understand. So you might say that this is is cool flag. But before you add that comment, you want to say to yourself, hmm, maybe my code is hard to read. Maybe I should just change the variable to is cool to make it more understandable.
02:38:01.220 - 02:39:07.500, Speaker B: Now this is something that you improve upon more and more, and you do want to use comments as an extra tool to make your code understandable. Maybe you write code that six months from now you want to go back to understand what you did. But remember, more comments doesn't necessarily mean better code. You want to be concise in keeping things simple while adding comments only when necessary to help others understand your code, not trying to make your unreadable code more readable. We'll explore this topic and give you advice on it throughout the course, but remember this key developer fundamental because you're going to need it throughout your career. By the way, this article over here has some really important points that I think you'll really benefit from, especially in the commenting best practices. You can read some of the do's and don'ts and what some of the top programmers do when commenting.
02:39:07.500 - 02:39:45.428, Speaker B: I know it sounds silly, but it is an important concept that most courses overlook. So I highly recommend you read over this. I'll link to it in the resources and I'll see you in the next video. Welcome back. Let's try and do an exercise to tie everything that we've learned up until now. Together we're going to create a password checker. Now what we want to do is to create some sort of an input that we're going to ask.
02:39:45.428 - 02:40:50.280, Speaker B: So we're going to use the input function and here we're going to ask for a username. Then we're going to ask for another input. It's going to be the password. And then at the end with the input we want to print something, the lines of password and then we'll have maybe the actual password in here and it will say is another variable here long. So what we want to do is the password and then maybe the password length so that let's say we printed our username jjdehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehehe and then we give it a password of secret. Well, we should print the password. Secret is 123456 letters long.
02:40:50.280 - 02:42:00.088, Speaker B: Now obviously we don't want to show or display the password, maybe for security reasons. So we want to convert this secret to 123-4562 stars. So your task is to convert these two inputs. And you know what, let's also do a greeting where we say the username here. So we're going to say, hey Jj, your password, which will be marked in a star, is six letters long. Now one neat trick here that you haven't learned yet and you might want to use here is this that you can do with strings. I can go times, make sure that the star is a string, multiply it by ten, and if I print this out I get ten stars.
02:42:00.088 - 02:42:47.190, Speaker B: So you may want to use this functionality when we're doing this. All right, pause the video, give it a go if you can. Remember, the goal is to print the username and have the password blocked with how many characters the password is. Alright, pause the video. If not, I'm going to get going with the answer. So the first thing we're going to try and do is I'm going to create two inputs. So the first one I'm going to get the username, gonna assign it to the variable username, and it's going to say, what is your username? Then the second one will be the password.
02:42:47.190 - 02:43:46.684, Speaker B: And the password, well, we'll say, what is your password? And although this is a simple example, this is something that you will see with other big websites like Instagram or maybe Netflix when you're logging in. So now that I've stored this information into a variable, I can use it, right? I can print. And we'll do an f string to make our lives easier. So I've added the f here. And what we'll do is this, we'll say username, your password, and we'll add the password here is. And then we'll add another variable here, which is the password length. So how are we going to calculate that? Well, let's try something here.
02:43:46.684 - 02:44:15.822, Speaker B: Let's see if I can use the length function. And in here do password. Let's see what happens here. What is my username? Let's go with Andre. What is my password? Let's just type in secret here and I get Andre, your password. Well, I can't speak English properly. My password secret is six.
02:44:15.822 - 02:44:45.650, Speaker B: Well, six what? Let's write six letters long. Awesome. So this is working because with an f string, I can create or add a python expression in here using the length password. But there's an issue here, right. We don't want to actually print out secret. We want to print it out in the star form. And this is a good discussion topic on readability of your code.
02:44:45.650 - 02:45:21.924, Speaker B: Now this is a simple example, but we can make this code a little bit cleaner. For example, we can break things down so that we'll have password length will be length password. So we're calculating the length. So this is going to store six or whatever the input of our password is. And it's nice and descriptive. It's easy for other developers to understand. And then in here, I can also have hidden password.
02:45:21.924 - 02:45:55.670, Speaker B: And this hidden password will be the password length. And we're going to use that star string and multiply it by the password length. Let's make this a little bit bigger so that now our code can be understood well in an easier fashion. So we have the password length. So we're going to say username, your password password. But we want to make sure that it's the hidden password. So we'll copy this over here.
02:45:55.670 - 02:46:32.920, Speaker B: So username, your password. We're going to print out hidden password is and then we're going to copy password length. Now I argue that this reads better because each line is doing something simple. And then finally we're printing the output. And although this is a small, simple example, this idea of readability and making and writing code that makes sense is an important concept. So let's see if this works. I'm going to click run my username Andre.
02:46:32.920 - 02:47:02.966, Speaker B: This time around my password is going to be super secret. And look at that, Andre, your password is eleven letters long. Good job getting this far. Hopefully you got that. I'll see you in the next video. Welcome back. Let's talk about our next data type.
02:47:02.966 - 02:47:44.408, Speaker B: And it's a big one, a very, very useful one. It's called list. And list is an ordered sequence of objects that can be of any type. So you can think of them as strings. Right? We had strings previously that we learned about, except that each sequence of this string, well, was, was a string, was a letter or number wrapped in quotation marks. Lists, on the other hand, looks something like this. Let's say we create a variable, Li, and lists we denote with square brackets.
02:47:44.408 - 02:48:26.150, Speaker B: And inside of these square brackets we can have different objects. So for example we can have 12345. We can also have, let's say Li two, and this is going to have a BDE, C, and it can have any collection of items that we want. We can even mix and match and say that we have one, two, then a, then maybe even the boolean value. True. So all of these are lists. Now, lists are extremely important.
02:48:26.150 - 02:49:25.242, Speaker B: And in other programming languages you might have heard the word arrays. So in Python, lists are a form of array. And later on when we get into the modules section of the course, we will talk about the difference between lists and arrays. But if you are coming from a different programming background, then lists are like arrays in your language, a collection of items. Now the neat thing about lists is that it's the first data structure that we're learning. Now, what is a data structure? Data structure is a very important concept in programming languages. It's a way for us to organize information and data into, let's say a folder or a cupboard or a box, so that these data structures can be used with different pros and cons.
02:49:25.242 - 02:49:57.034, Speaker B: For example, you have a fridge where you store your food. And fridges are really, really good at putting your food inside, keeping it cold and then taking it out. Or you might have a backpack. A backpack is really, really good to stuff everything in there. But when you're looking for things in a backpack. It's really, really hard. So you can think of data structures similar to that, a container around your data that has different pros and cons of accessing that data, removing that data, writing data.
02:49:57.034 - 02:50:33.706, Speaker B: But that's something we'll get into a little bit later. The key here is that these square brackets allow us to contain information and data like strings, integers, floats, if we want to booleans into a contained fashion. So let's think of a good example here. What if we had a shopping cart? Let's say we're Amazon here and then Amazon has the Amazon shopping cart. And in here we can collect different things that we want. Maybe we collect some, I don't know, notebooks. And you know what? Let's get some gadgets.
02:50:33.706 - 02:51:17.736, Speaker B: Let's get some, maybe some sunglasses. We can add different items here, different strings, different data into this cart. And now just like we saw in strings, we can access the Amazon cart in different ways. For example, I can access it again with square brackets and simply say I want item zero. So if I print here and do Amazon cart, look at that, I get notebooks. The second item, I get sunglasses. What about the third item? Nope.
02:51:17.736 - 02:51:54.050, Speaker B: List index out of range. But this should make sense. Now this is a list where we're accessing the index of, but it only contains two items. So if we're going zero, one, two, the third item, nothing exists. So our program says that doesn't work, you're doing something wrong. And just like strings, these list items are in memory in their separate bookshelf, right? But one right next to each other. So we can go 012345, so on and so forth until the list ends.
02:51:54.050 - 02:52:31.870, Speaker B: Alright, let's learn about lists a lot more in the next video. Bye bye. Welcome back. Let's continue with lists. Now, so far, these square brackets, we've seen them before, right? We saw them when working with strings. And just like strings, lists are quite similar in that we can use list slicing. If you remember with string slicing we had things like hello.
02:52:31.870 - 02:53:19.230, Speaker B: And we were able to assign it to a string, let's say a variable string, and we could do string and then slice. So do something like this where we had the start, the stop and then the step through so that we start at index of zero and end at index of two and then go one by one. So list slicing is also available to us. So let's make this cart a little bit bigger and you can actually just make things cleaner by formatting it this way. All right, so what should we add to our cart. We'll also add some toys. And then, you know what, Amazon does groceries now.
02:53:19.230 - 02:53:46.210, Speaker B: So let's add some delicious grapes. Awesome. Now let's say I wanted to get every single item in the cart. Well, we just simply do this and we have our entire list. But let's use some list slicing. Let's say I wanted to grab from the first item to the second item. If I click run, I get notebooks and sunglasses.
02:53:46.210 - 02:54:29.280, Speaker B: Maybe I want to go all the way till the end, but skip every second one. I get notebooks and toys. We start at zero, we step over to toys and we step over and we're done. Awesome. And this is something that we've already seen when talking with strings. Okay, but here is where it gets interesting. Remember how I said that strings are immutable? That means we can't change them, right? And we talked about this when we had a string like hello, I couldn't do greet zero equals to, let's say, z.
02:54:29.280 - 02:54:54.348, Speaker B: I'd get an error here. I get Str. Object does not support item assignment. It's immutable. But the interesting thing with lists is that they are mutable. So that if I change my Amazon cart and say that, you know what, I don't really want notebooks. So I'm going to grab the first item, which is notebooks.
02:54:54.348 - 02:55:25.208, Speaker B: And instead of notebooks, I. What do we want? We'll say we want a new laptop. It's a big upgrade when I print this Amazon cart. Look at that. I'm able to change this list and it didn't give me an error. In that sense, lists are immutable. We simply replace on the memory bookshelf of our computer notebooks and I say, hey, change it to laptop.
02:55:25.208 - 02:55:53.040, Speaker B: And they let us do that. Okay, so that's awesome. But let's try something here. What if I create another print here? And in the Amazon cart I'll use list slicing. So let's say I want item from index of one all the way until index of three. Let's run this and see what happens. Try and guess.
02:55:53.040 - 02:56:38.020, Speaker B: Is that what you expected? Let's go through this code. When we get to line ten, we grab the Amazon cart, which has been updated with laptop, and I grab item one to three. So that is sunglasses to toys. So zero, one, two, and then we stop at three. Just to make this easier to understand, let's start off with zero here so that we see that laptop has been changed. And then here in the second one on line eleven, we print the Amazon cart. But hold on a second.
02:56:38.020 - 02:57:15.520, Speaker B: This list did not change. And that is because with list slicing we're creating a new list list, a new copy of this list. So here we're creating an entirely new list so that I could actually assign it to a variable. New cart is going to be Amazon cart. And let's just do the same thing here. And new cart is an entirely new list on its own. I could change new cart, let's say zero into, let's say gum.
02:57:15.520 - 02:58:29.896, Speaker B: And if I print this, you see that I have two new separate lists, but our list is mutable because I can change whatever is at the index anytime I want. And every time we do list slicing, we create a new copy of that list. But I have a tricky question for you here. What happens if I just do this? If I run this? Hmm, did you see that? Instead of slicing my list, I simply said that new cart is going to equal the Amazon cart and I change the new cart index of zero to equal to gum. But now my Amazon cart got modified as well. Why is that? And this is a bit of a tricky question that you might encounter in an interview. The reason is that right now the way that I did equals means that hey, new cart is going to equal Amazon cart.
02:58:29.896 - 02:59:25.430, Speaker B: And what does Amazon cart equal to? Well, Amazon cart points somewhere in memory in our machines that says, hey, this is what Amazon cart is. So because here we're not copying the list, instead we're just saying, hey, the value of new card is whatever is in the memory of Amazon cart. We now, when we modify new cart are simply changing the Amazon cart all the way back from here. So this is an important concept. If you want to, let's say copy a list, then you do something like this where you copy the entire list. And this is something that you'll see a lot in code bases, but this line is saying, hey, I want to create a copy use list slicing to copy this Amazon cart. And it's going to equal new cartoo.
02:59:25.430 - 03:00:07.580, Speaker B: So that now if I run this, you'll see that the original Amazon cart stays the same, but the new cart is now something different. This is a quick gotcha that you just have to get used to, but it's an important concept, this idea of copying versus modifying the list. And it's something we'll explore a little bit more in the next couple of videos. For now, take a break and I'll see you in the next one. Bye bye. Welcome back. I want to talk to you quickly about something called matrix.
03:00:07.580 - 03:01:09.472, Speaker B: And a matrix is a way to describe 2d lists or multidimensional lists. What do I mean? Well, I can create a matrix and this is a name that I just made so I can call it whatever I want. But usually these are called matrix in programming and it looks something like this. It's an array with another array inside of it. So let's say for example, I have one, two, three here and then another array, one, or let's do two, four, six and then another array, seven, eight, nine. What's happening here? Well, it's a two dimensional array. We have the main array and then we have sub arrays, three arrays to be.
03:01:09.472 - 03:01:44.080, Speaker B: Exactly. Now why is this useful? And by the way, this is two dimensional, but we can have multiple ones. For example, we can have another array inside of this array. But why is this important? These type of matrices come up a lot in topics like machine learning or image processing. For example, a computer doesn't really know what a photo of a dog is. The only thing it understands is zeros and ones. So a lot of photos.
03:01:44.080 - 03:02:46.882, Speaker B: For example, let's say we had a very simple photograph of a giant x, maybe this letter x. Well a computer can understand an image based on pixels on the screen. So maybe we can have 010100 or, sorry, one here, zero here and then one. And right now a computer can look at this and if this represented, let's say a tiny little pixel here or maybe a pixel here on my screen, the computer is going to say, oh, there's a one here. So that means I should make this green in this corner, then dark here, then green, then dark green, dark green, dark green. And a computer is able to draw, let's say an x. And this is a simple example and using matrices we can do a lot of these heavy calculations.
03:02:46.882 - 03:03:51.722, Speaker B: And that's how computers work underneath the hood when, let's say for example, it's trying to display something. But the reason I wanted to talk about this here is when you want to access a multidimensional list, well you would do something like this, let's say matrix, access the first item in the matrix, which in this case will be this first array because it's the first item. And then let's say we want to access the zero in here or let's change this to five. Well I'll do square brackets again and just do zero, one. So if I go one here and let's print that out and I click run, I get five. So it's accessing the first item in the array. So it's going to look at the first outer array, grab the first item, which is right here, and then grab the second item in that array.
03:03:51.722 - 03:04:30.846, Speaker B: So zero, one, which is five, and you can keep doing this. If you had multidimensional arrays, you can keep adding, keep adding, keep adding to access that information from an array or list. But remember, in Python we want to use the term list. I'll see you in the next one. Bye bye. All right, let's learn about some actions that we can take on lists. And this is very exciting because you can perform a lot of actions on lists.
03:04:30.846 - 03:05:16.846, Speaker B: Now, we've learned about built in functions, right? Functions that come with Python. And we've actually seen this one before when we talked about strings, which is the length function. And here we can have it calculate the length of a list. So, for example, if we had a basket here that had 12345. Well, this basket, if I calculate the length of the basket, let's do print here so we can see the result. And I click run, I get five. The length of the basket is five because, well, there's five items.
03:05:16.846 - 03:05:58.100, Speaker B: Remember, a length is the actual length. It doesn't start counting from zero. It's going to do human length, which is five. But lists get really powerful when it comes to methods. So instead of a built in function, remember a method is an action that's owned by something and it's specific, let's say, to a data type. So if we go to list methods, you'll see that python has a few list methods that we can use. And the way we use these methods is, remember, we just add a dot after a list.
03:05:58.100 - 03:06:31.128, Speaker B: So let's have a look at some of them. First, I'm going to start off with the adding ones. So let's say in this basket we want to add something to it to the end of the list. Well, we can use the append. And remember with a method, as soon as you write the dot, it'll tell you what we can use, which is very, very useful when you have an editor. So the first one is append. And if I hover over this, well, it just tells me appends an object to end.
03:06:31.128 - 03:07:12.160, Speaker B: And in Python, an object is, well, everything in Python is an object, a number is an object, a list is an object. So just think of it as an item for now. So if I want to append, let's say 100 to the end of the list. And you know what? Let's add a new list here, and this new list will do the append for us. If I print the new list and I click run, I get none. Hmm, that's weird. What if I print basket here? If I click run.
03:07:12.160 - 03:07:50.544, Speaker B: All right, so it looks like the basket was appended to. We added 100 but a new list when we assigned it the basket dot append. That new list is completely none. And that is because append changes the list in place. What does in place mean? It means that it doesn't produce a value. All it does is saying hey, I'm just going to append 100 to this basket that you gave me. But I don't really care.
03:07:50.544 - 03:08:26.650, Speaker B: I'm not producing a result. I'm just changing this for you. I know it's a little confusing. So in order for our new list to have that 100 at the end, we have to do something like this. If I click run, there we go. After we've appended to the basket, then we can assign, so that new list points to basket, which points to this list that was modified. Alright, what else is there? Well, there's also something called insert.
03:08:26.650 - 03:09:02.640, Speaker B: And you see over here, that insert gives an index and an object. So we can insert something not at the end of the list. I mean we could, but we can also insert it anywhere we want in an index. So for example, in this case, if I do insert 100 at 01234. So let's do index of four and I click run. I've added 100 to the index of four. If I do index of five and I click run, I've added 100 at the end of the list.
03:09:02.640 - 03:09:54.458, Speaker B: Now let's try and copy this and see if we can just add it into here. If I click run again, same thing. Insert modifies the list in place. It doesn't create a new copy of the list. All right, and if we add this like this, well, once again insert modifies the list in place. That is, it doesn't really output a new list, it just modifies whatever is existing in memory. Finally, there is another method called extend and extend, instead of an actual item or object takes what we call an iterable, which we're going to get into later on.
03:09:54.458 - 03:10:39.404, Speaker B: But it's something that you can loop over, you can iterate over, which is a list. So we just give it another list like let's say 100 or 101. So if I run this once again, it doesn't output a new list, it just modifies the list in place and adds on or extends our list. And we can also just give it one item. All right, let's keep going with the removing methods. Now with the removing we once again have a few fun things that we can do. So let's continue with this basket that we've been using.
03:10:39.404 - 03:11:27.292, Speaker B: That now has 100 included into it. And the way we can remove things is, well, there's a few ways. First one is basket dot pop and basket pop. If I go like this and let's print this basket, I'm going to comment out the new list for now since we're not using it. And then we're going to say basket pop and then print basket. Let's run this and pop pops off whatever is at the end of the list. In our case at the end of the list because we've extended the basket to 100, that 100 gets removed.
03:11:27.292 - 03:12:09.358, Speaker B: If I do basket pop. Again, not here, down here. And I run, you see that both 105 get removed. What if I do pop zero. If I click run here, it removes the item in the index. So here pop zero is going to remove whatever is at index of zero, which is one. Now there's also dot remove, remove again is we give it a value that we want to remove.
03:12:09.358 - 03:12:48.276, Speaker B: So in our case, let's say we want to remove number four. Well, if we run this, it's going to remove four for us. So remove, we give it the value that we want to remove. With Pop, we give it the index that we want to remove. And just to see if this is working, let's add a new list here and we'll say new list equals basket remove. Add a new list here, see if that gets modified. Nope, it does not get modified.
03:12:48.276 - 03:13:11.906, Speaker B: That means remove is working in place. It doesn't return a value. It just simply changes whatever list you give it. What if we do pop? If I run this, I get five. Hmm. Why is that? And this is something that you just have to get used to. Different methods do different things.
03:13:11.906 - 03:13:51.308, Speaker B: For example, pop. The way it works is that pop returns whatever you have just removed. In our case when we did four, that is index of 01234, it returned the number five. Four for me, even though it removed it from the basket, it still returned something. And the reason for others is that we got none. That is, when a method doesn't return anything, it returns none, a topic we're going to cover shortly. So you have to be careful and understand what each method returns.
03:13:51.308 - 03:14:42.400, Speaker B: If I go over extend, I see here that this little arrow shows me that none is returned. That means it's not going to produce anything with this method. It's only going to change or extend a list that it was given. Don't worry if this is confusing. That's something that you're going to get used to as we get more and more practice. Now, the last removing method I want to show you is clear and clear as you might guess, if I click run here, well, this is none, but if I go to basket and I click run, the basket is empty. Clear removes whatever is in the list, completely clears it, just as the name suggests.
03:14:42.400 - 03:15:06.484, Speaker B: All right, that was a lot, but there's still a few more. So let's take a break and I'll see you in the next video. Bye bye. Welcome back. Let's keep going with some more string methods. Now, we've learned about adding and removing ones. We learned about append, insert, and extend.
03:15:06.484 - 03:15:51.088, Speaker B: And then in removing we learned about pop, remove and clear. There's a few other important ones. Let's go with the index. So instead of clearing here, let's clean this up and we'll do basket, dot, index and index. As you can see, we give it a value, a start, and a stop. What does that mean? Well, we want to say, hey, what index is number two? If we do index of two and I click run, it's going to give me one. I know this is a little confusing, but it's asking for the index.
03:15:51.088 - 03:16:42.538, Speaker B: Where is number two? Number two is at index of one. Let's change these into letters just so it's more clear. So we have ABCD and then finally e. And again, if I do d here and I click run, I get an index of three because 0123, it's on shelf three in our memory. And you can also do a optional parameter here, which is, where should we start looking? So I want you to start looking at index of zero and then finish looking at index of two. If I do run here, I get an error. It says, hey, d is not in list because, well, we started at index of zero and stopped at index of two.
03:16:42.538 - 03:17:31.686, Speaker B: If I do three and I click run, nope, it stops right before three. So if I do four and I click run, there you go, I get three. Now, errors are not good in our programs. Ideally, we don't want to get errors, so how can we avoid this? What if we're looking for something and we're not sure if it's in the list or not? There's another nifty way of looking for things in a list, and this involves what we call a python keyword. A keyword is something that you use in python that, well, already has some meaning. For example, a keyword here. If I go to Python, keywords are all these words that already mean something.
03:17:31.686 - 03:18:35.650, Speaker B: Now we're going to go through them and we haven't seen a lot of them yet, but we might have seen true, right? In boolean values, true means something. So in python we can't really use the word true because, well, it already means something. There's a word called in that, as you can see, as soon as we type means something is a keyword in python. And this is quite nice. We can say hey, is d in basket? And if I run this, I get true. Okay, is x in basket? I get false because, well, it doesn't exist and this is actually quite useful and we can even do it for strings. For example, if I'm looking for, let's say the letter I in a word, and let's say it's I in hi, my name is Ian.
03:18:35.650 - 03:19:15.510, Speaker B: If I click run, I get true because the letter I does exist in this string. All right, let's learn another one. Another one is basket, dot count, and we can count how many times an item occurs. So for example, if I do d and I click run, I get one because d only exists once in the list. But if I add another d in here and I click run, we get two. It counts how many times this value occurs in our list. Very, very useful.
03:19:15.510 - 03:19:45.440, Speaker B: Alright, a few more still to go. Let's do some exercises and I'll see you in the next one. Alright. It feels like it's never going to end. We have so many methods with lists, but like I said, lists have a lot of methods because you can do a lot with them. It seems like a lot right now, but trust me, these are going to become second nature. So hang in there, I have a few more to show you.
03:19:45.440 - 03:20:35.134, Speaker B: The next one is called sort. Guess what sort is going to do? If I click run, I get none. But remember, sort sorts the list, as you can imagine, in place. That means it modifies the list. So if I remove this up to here and then do sort or do basket and I click run, look at that, I get a sorted list where d was moved in front of e. If I add, let's say x at the beginning here and I click run, it's going to move the x all the way to the end. It's going to sort the list in place for me.
03:20:35.134 - 03:21:33.152, Speaker B: Again, if I hover over it, sees that it's going to not return anything, which is why our print initially didn't work. We had to print our basket, not whatever this produces, which it doesn't produce anything. But what about this one? If we go to built in functions, I have something called sorted, and if I do sorted, and because it's a function, not a method, I can do sorted dot or basket. So around the brackets, just like print. If I run this, all right, nothing has changed. But what if I remove this and put it in here? If I click run, I get a, b, c, d, e, x. What if I comment this out so that we're not sorting it anymore? We just have the basket and then we run this sorted function.
03:21:33.152 - 03:22:12.858, Speaker B: If I run, did you see that? Sorted. I know, it's confusing. Why do they even have two? But sorted produces a new array. So if I do print basket here and I click run, the basket hasn't been modified, the basket still remains the same. It's this one over here that's not sorted. Sorted, on the other hand, doesn't modify the basket in place. Instead it creates a new copy of the basket and sorts it.
03:22:12.858 - 03:23:07.510, Speaker B: It's almost as if we're doing this. We're saying new basket equals basket and then we're going to copy that basket. Remember list slicing? And then we're performing new basket dot sort on this new list so that if I do new basket and I click run, we get the same thing. So you have to be careful of certain actions that perform an action in place or create a completely new list to begin with. By the way, there's also, instead of this, a copy method that we can use. And if I run this again, we get the same thing. Copy, just as the name suggests, copy the list for us and returns for us a new list.
03:23:07.510 - 03:24:08.500, Speaker B: All right, one last one. And that is basket reverse. What do you think this does based on the name? Well, if I check out the basket here and click run, is that what you expected? It reverses the basket in place, but notice that it's not like sort, it's not sorting, it's simply switching all the indexes into opposite sides. So d is now index of zero, e is now index of one, index of two, three, so on and so forth. So you can see here that it doesn't actually sort it. Instead, what we might want to do is sort first, then reverse. And if we click run, we have a sorted reversed basket.
03:24:08.500 - 03:24:36.622, Speaker B: This is a little tricky one that some interviewers might ask. All right, good job getting this far. We're almost done with lists, so I'll see you in the next video. Bye bye. Welcome back. Let's talk about some useful tricks with lists. Of that you'll see a lot in python code.
03:24:36.622 - 03:25:20.610, Speaker B: Well, one we have already seen. It's this idea of length, you're going to be using this a lot, that is to figure out the length of a list, which in our case is now seven. Another really useful trick is to reverse a list. Now I've already showed you how to reverse a list, but sometimes you can do that with, listen, slicing. Again, something that we've seen in string slicing. So I can actually do basket and then semicolon, semicolon, negative one. If I click run here, is that what you expected? Let's go through this line by line.
03:25:20.610 - 03:26:27.616, Speaker B: I've sorted the basket so that it's from a all the way to Zenong and then I've reversed this so it's in z all the way to a and then I've reversed the basket again so that instead of being in reverse, it's now in order. Abcdex. And this list slicing creates a new list, right. If I printed basket here, you'll see that the basket is the reversed version, the last action that we've taken on it versus list slicing that creates a new version. So this notation, you'll see a lot with lists when you need to reverse a list. Or maybe you need to make a copy of the list like this, or maybe you need a portion of the list. Another useful thing that you'll see a lot of is something called range.
03:26:27.616 - 03:27:08.786, Speaker B: Let's comment this out for now. If I wanted to generate a list really quickly, let's say from one to 100, I can do something like this. I can say range and then start and then stop. So let's do 100. And if I print this and I run, I get a range one to 100. But if I wrap this in a list which is going to create a new list for us, and I click run, look at that. I get a range from one all the way to 99.
03:27:08.786 - 03:27:54.560, Speaker B: Remember, it's the start and then whatever to stop at. So before it hits 100, it's going to stop. Now if I remove this and just do one single thing, I get a list starting from zero all the way to 99. If I want a list that has 101 items because it starts at zero, I would just do 101. And range is something we'll talk about a lot more, especially when we talk about loops in programming. But this is a great way of you to generate a list really really quickly, especially a numbered list. Finally, the last common thing that you'll see a lot is this idea of dot join.
03:27:54.560 - 03:28:47.770, Speaker B: What is dot join? Join is actually something that works on strings. It's a string method, but it's often used this way we have an empty string and this empty string, let's say sentence. And then we can do sentence, dot join. And join takes what we call an iterable, which is a list for now. And in here we can have a sentence like hi, my name is Jojo. And now if I print sentence and I click run here. Hmm, I don't get anything.
03:28:47.770 - 03:29:45.726, Speaker B: Let's figure out why. What if I type in an exclamation mark here and I click run? Alright, it's printing out sentence, but it looks like Join creates a new item for us. So let's just assign that to new sentence. Now if I do new sentence and print that out, we see that I get hi, my name is Jojo. Hmm. So this is a little funky, right? We have these exclamation marks between our items, and join joins these little iterable items, these lists by whatever is in front of it. So if we actually change this to an empty string, click run, we now get this.
03:29:45.726 - 03:30:24.874, Speaker B: If I add a space in between and click run, we get hi, my name is Jojo. And sometimes you'll notice this pattern a lot, especially if you want to join and create a new string out of a list of items. Now a shorthand way of doing this is to actually not even bother with this and just doing an empty string join and then joining all the list items. There we go. So all we're doing is combining lists into a string. And this is a common pattern that you'll see a lot of. I'll see you in the next one.
03:30:24.874 - 03:30:52.720, Speaker B: Bye bye. I want to teach you one last thing. When it comes to lists, and it's called list unpacking and it's a really, really nice feature. I really like it. With list unpacking we can do something like this. Let's say I have a list that is, well, very simple. One, two and three.
03:30:52.720 - 03:31:45.584, Speaker B: And I want to assign a variable to this list. Let's call it basket equals 123. But what if I wanted to assign a variable to each item? Well, I can actually do something like this. A, b, c. So that when I print a and then let's print b and then print c and I click run, I get one, two, three. And this is something that we've seen when we talked about variables where even if it wasn't a, listen, as long as we gave it by comma, separated by comma, different values, we're able to print one, two, three. But this is where list unpacking gets really, really useful.
03:31:45.584 - 03:32:46.450, Speaker B: We can actually, let's say, extend our list to include all the way till nine. What if we wanted to unpack one, two and three, but keep everything else still in a listen, could we still do that? Well, with list unpacking we can. All we need to do is say comma and then add a star and give it a variable name, whatever we like, let's say other. So now if I print other and I click run. Look at that, I'm able to unpack my list however way I want. What if I add a comma here and add d? Well, if I run this, I get a list all the way until eight. But now D is, well, actually the very last item.
03:32:46.450 - 03:33:23.380, Speaker B: So that's very, very neat. Maybe the use case right now is not absolutely clear to you, but this is something that might help you, another tool in your toolbox to unpack a list and change a list in different ways. We'll explore this more later on in this course, but for now, list unpacking. When you hear that word now, you know what it means. I'll see you in the next one. Bye bye. Welcome back.
03:33:23.380 - 03:34:21.386, Speaker B: When we talked about lists, we saw our special type of none, where some methods that worked on lists didn't really produce anything. They modified the lists in place, but the output of whatever they were doing was this thing none. Remember how we had in the output this none. What does that mean? If you remember, I mentioned none as a special data type that exists in Python, and most languages have something like this to represent the absence of value. In some other languages you might have heard of null, which is another thing that again represents the absence of value. Now why is this useful? Well, for now it's hard to really conceptualize it. We'll see it being used a lot more as we get further into the course.
03:34:21.386 - 03:35:01.840, Speaker B: But I could do something like a equals none. Let's say, for example, we're just starting a video game, and in this video game we have a user's weapons, but when you're just starting the game there are no weapons that the user has. Well, in that case we might want to assign the variable weapons. Maybe in our code we use this variable, but we also want to know that this user doesn't really have any weapons. It's none. So this is completely valid Python. If I run this, I get none.
03:35:01.840 - 03:35:34.320, Speaker B: And we'll explore this a little bit more throughout the course, like I said. But hopefully this way you're not intimidated when you see it. As the name suggests. It's just nothing. Let's talk about our next data structure. And this one is called a dictionary. In other languages, it might be called a hash table, maybe map or objects.
03:35:34.320 - 03:36:19.544, Speaker B: In Python we have this idea of dictionary, or as Python likes to call it, dict. I have to make sure I pronounce that properly. That's a really hard word to say when you're recording and you're repeating it over and over. Anyway, dictionary, what is it? Well, it's a data type in python, but it's also a data structure. Remember that I mentioned this idea of data structure when we talked about lists? There were the first data structure in Python that we learned. It's a way for us to organize our data in a form that is has some different pros and cons on how we access it. For example, with lists, we saw that they're easily ordered.
03:36:19.544 - 03:36:49.050, Speaker B: We can access them through indexes like zero, one. We can reverse them, we can insert into them. It was really, really nice. What about dictionaries? Well, let's see what a dictionary looks like. A dictionary will look something like this. We'll have a key and a value, then another comma and then another key and another value. Let's decipher this.
03:36:49.050 - 03:37:33.230, Speaker B: So I'm using curly brackets here, which denotes a dictionary. And unlike a list, we have what we call a key value pair. A key is a string for us to grab the value. What do I mean? Well, in order for us to access any of these values, I would go dictionary and then say the key. In our case, let's say we want to grab b, we would grab the key, and then when we print here the result, we get the value two. We're essentially telling the computer, hey, I have this variable dictionary. Remember, I can name this whatever I want.
03:37:33.230 - 03:38:00.718, Speaker B: I have this variable dictionary. I want you to go find the key b and this key b, if it exists, grab me the value. So it's going to go into your memory or into the machine's memory. It's going to find where b is stored in our memory and grab the value. So in the bookshelf b, we have the value two. What if we do c, which doesn't exist. If I click run? Nope, I get an error.
03:38:00.718 - 03:38:31.620, Speaker B: It tells me, hey, sorry, you're looking for key c, but I don't really have that key. And this is what a dictionary is. A dictionary is an unordered key value value pair. What do I mean by that? Unordered means that they are not right next to each other in memory. Remember, with lists, we could access lists with index of zero, then index of one, index of two. All those bookshelves were right next to each other. A dictionary, on the other hand, they're all over the place.
03:38:31.620 - 03:39:11.940, Speaker B: Although I've put a and b here. This might be in one spot in memory and this one in another spot in memory. And if I added, let's say, x, this will be in another spot in memory, and this might not be in order. Maybe I've written it ABX, but when I actually return the entire dictionary, maybe I don't have this in order. These are all just scattered all across our memory, as you see here. When I receive the dictionary, I get these things in order, but that's only because it's small. If I had a really, really large dictionary, I might not have them in order that I've inserted it in.
03:39:11.940 - 03:39:48.574, Speaker B: So a dictionary is an unordered key value pair. And as long as we know the key, that is whatever the key that we're looking for, then we just give that and our computer is going to know, hey, where in memory to look to grab the values. Now here's the cool thing about data structures, like dictionaries and lists. They're containers around data, right? So this can be anything that we want. Let's say we want this one to be a list. One, two, three. Maybe we want this to be a string.
03:39:48.574 - 03:40:14.020, Speaker B: Hello. And maybe this is a boolean value, like true. That is completely valid. I, I can access the a like so, and I get the list. What if I want the second item in the list? Well, I do index of one like this. And there you go, I get two. And this is the same with lists.
03:40:14.020 - 03:41:13.888, Speaker B: And you'll see this a lot where if we had a list, or let's call it my, listen, and my list contains a dictionary that has, let's say a one. And you know what? Let's just copy and paste this. We'll do this. So we'll have the first item in the array like this, then comma, then another item in the array. And this time around, this one has four, five, six, so that I can now grab from my list the first item in the array, and then maybe grab the a, that is the a key. So remember, this is a string. And then we want to grab, let's say, the third object item.
03:41:13.888 - 03:41:55.800, Speaker B: So we'll go two. If I run this, I should get three and two. There you go. Now you might be asking yourself, hmm, what's the deal with these data structures? Like, why do we need dictionary? Why do we need lists? Why can we just have one thing that does everything? Isn't that simpler. Think about that, because in the next video I'm going to try and answer that question for you. Let's talk about our next developer fundamentals. And this one is understanding data structures.
03:41:55.800 - 03:42:43.166, Speaker B: A really good programmer is a programmer that is able to decide what data structure to use when. Up until now we've learned about dictionaries and lists, and we'll learn about a couple more throughout the course. But a really good programmer, a programmer who's experienced, is able to understand what the trade offs are, when to use what. And although I can give you a list of this is when you should do this and this is when you should use maybe dictionaries. The thing is, this takes practice and experience. So throughout our course and then the exercises that we're going to do, the projects we're going to build at the end, I hope that this idea of understanding when to use what data structure makes sense to you. But let's go back to our example.
03:42:43.166 - 03:43:37.528, Speaker B: When should you use a list and when should you use a dictionary? Well, the first thing we have to realize that a dictionary is not sorted, right? A list has order, it has zero, one, indexes, so on and so forth. A dictionary has no order. So maybe if you want to have a list of people in line at your shop, well, you should probably use a list. But maybe you have a user that is playing a game and that user has first name, maybe weapons, maybe an h that doesn't have to be ordered. So you might use a dictionary. Also, you'll notice that dictionaries hold more information than lists of, right? Because lists only have that single value. That is, a list has the index and then whatever the value is.
03:43:37.528 - 03:44:20.836, Speaker B: And here we have a dictionary inside of a list, which is holding a lot of information. Deep down, a list is simply an index and some sort of value here, right? Versus a dictionary that holds a lot more information, it holds a key. So this could be the weapons of that user, hello can be the greeting of that user. Maybe is magic is another information about that user. So we're able to have both keys and values in a dictionary. So it holds a lot more information. And as we learn different data structures, you'll have these different pros and cons.
03:44:20.836 - 03:44:52.810, Speaker B: You'll start to understand as to when to use what. All right, there's another developer fundamentals. I'll see you in the next one. Bye bye. Welcome back. I mentioned to you that a dictionary's values can hold any sort of data type. But what about the keys? Up until now I've only used strings to denote a key.
03:44:52.810 - 03:45:37.740, Speaker B: But could I do something like this? Could I do one, two, three like this? Well, let's have a look. Let's give it a try. If I do one, two, three and I click run, I get one, two, three. Awesome. That works. Um, what about, what about true? If I select if I have a key true and I click run, will that work? Yep, it looks like it works. What about a list? What if I have a list of, let's say, just 100, would that work? If I click run? Nope, it doesn't work.
03:45:37.740 - 03:46:09.244, Speaker B: It says unhashable type list. What does that mean? Dictionary keys need to have a special property. A key needs to be immutable. That is, a key cannot change and numbers booleans. I mean, this is a value that cannot change. A string, if you remember, is a value that cannot change. It's immutable.
03:46:09.244 - 03:46:58.016, Speaker B: But a list, if you remember, can be changed, right? On a list, I can reassign, let's say, the index of zero to something else. Right? So because of that, a dictionary says, hey, my keys, because I'm storing them in memory and I don't want to lose them. It has to be something that isn't going to change on me. Maybe a programmer comes in and by mistake changes this array of 100 to have an index of something else. Well, dictionary doesn't really want that because it doesn't want to lose this value. So a dictionary key always has to be immutable. And as we learn a few other things, like a tuple that we'll see in upcoming videos, you can use those as keys as well.
03:46:58.016 - 03:47:53.380, Speaker B: However, most of the time, 95, 99% of the time, a key for a dictionary is usually something descriptive like a string. Okay, but what about this? What if we have another string? One, two, three. And let's just remove this for now. What happens when I search for one, two, three? The string. If I click run, I get, hello. A key in a dictionary has to be unique because there can only be one key because that key is going to represent a bookshelf in that memory space. So anytime I do the same key and maybe add a value, it's going to overwrite.
03:47:53.380 - 03:48:22.652, Speaker B: So this no longer exists. A key has to be unique and it's something that can only exist, well, just once. Otherwise we override it. Which is why you see, hello, here we've lost the array. One, two, three. Let's explore this idea a little bit more in the next video. Welcome back.
03:48:22.652 - 03:49:11.844, Speaker B: Now, if you remember, let's have something different here. So we have unique keys, if you remember, we have to have unique keys. So let's say this is greet and this is a, I don't know, let's say a basket and we can access basket like this. If I click run, we get one, two, three. But I what if we don't know what this dictionary is? Maybe a dictionary is something, well, somewhere else where we can't see. But we want to know if this, let's call this user. If this user has maybe property like age, so do they have this age key? Well, if I click run, I get an error key.
03:49:11.844 - 03:49:53.016, Speaker B: Error, age doesn't exist. But remember, errors in our programs and this is something we'll cover later on are not good. They're going to stop the program. As soon as the Python interpreters enters an error, it's going to kick out of the program and say, hey, you have an error and it's going to completely ignore what's underneath it. Here we don't have anything, but in a real life program we want to avoid these errors because it stops execution. So another good way to access a key and to see if it even exists is to use dot get and guess what get is. Did you guess a method? Well, there you go, doc.
03:49:53.016 - 03:50:35.750, Speaker B: Get is a method on the object or the dictionary in python. So here, if we do get age and do run, I get none. So my program doesn't error, it just says, hey, there is nothing there, it's an absence of value. And we've learned what none means by now. So that's a really nice way to avoid those errors. By the way, if, let's say there's no age in the user, but you want to have a default value, you can do something like this. So you add a comma and then here you say whatever you want as the default value.
03:50:35.750 - 03:51:10.810, Speaker B: So let's figure that out. If I click run, I get 55, because now I'm saying, hey, grab the age from the user dictionary. If age doesn't exist on the user dictionary, use 55. So now we have 55. But if the user already has age and I click run, I get 20. So this is, hey, in case age doesn't exist, add a default value. That's really, really nice.
03:51:10.810 - 03:51:59.140, Speaker B: Now I'm going to show you another way to create a dictionary, which is not very common. Most of the time you want to use this syntax, but just so you're aware of it, here's another way. Let's say we have a new user. So user two, I can create here a dictionary by saying dict, which again is a built in function. And in here, look at that, it shows me hey, this is going to create a new empty dictionary and we can create different values, key value pairs, and we simply say I want the key to equal the value. So in my case, let's just say that I want the name to equal John. John.
03:51:59.140 - 03:52:55.080, Speaker B: If I now print out user two, well before I click run, I see that I have a ret. And by the way, if you see here, PI flakes, that's something called linting, something we'll talk about when we talk about developer environments. We're using this linter that tells you whenever you make errors in python and it says keywords can be an expression that just means that hey, the keyword needs to be, well, just a variable that we create. So if I click run here, look at that, I have name Johnjohn. So we've created a user with this key value pair. Now like I said, this way of creating dictionaries is not very common. Most of the time you'll do something like this, but at least now you know that this is why this built in function exists.
03:52:55.080 - 03:53:52.240, Speaker B: I'll see you in the next one. Bye bye. By the way, there is actually one more way that we've actually seen in lists how to look for an item in a dictionary. Remember how in lists we use the keyword in, we said something along the lines of hey, is I in a list that contains I? Or we even used a string like hi. Well, you can do the same with dictionaries. I can say does basket exist in user? And let's print this out and run. And it's going to say, yep, basket does exist in user.
03:53:52.240 - 03:54:42.630, Speaker B: What about, what about size, does that exist? No, that's false, that does not exist in user. But here is where it gets really interesting. And this again is another dictionary method that we can use. And by the way, you can see that there's not that many dictionary methods that, well, dictionaries have. Luckily we're going to go over the main ones here. The one is called keys and keys, simply checks the keys. What are the keys of user? So if I go hello here and I click run, well, no, keys are, sorry, on this side, not this.
03:54:42.630 - 03:55:36.490, Speaker B: So this is a value. So if I want to check keys, I'd say age, which is true. But if I want to check values, well in that case, if I do hello, I get true, it's going to go over, or what we call iterate over the values. Another one that's really useful is the items and items is special because we've seen keys and values, but items actually grabs the entire item. So the way we can actually see this is, let's just remove and click run. All right, this is interesting. I have dictitems here and I grab looks like a list.
03:55:36.490 - 03:56:10.544, Speaker B: And in here we have a bracket basket. One, two, three, greet, hello, and h 20. But there's some weird syntax here that we haven't seen before and this is actually a tuple. So we're going to hold off on this and talk about this a little bit more when we talk about our next data structure. But keys, values and items is an easy way for us to grab these things for us from our dictionary. Let's continue on with other dictionary methods that we might use. One is a very nice one.
03:56:10.544 - 03:57:19.494, Speaker B: It's called clear. And if I run this, you see that I get an empty dictionary. What if I just run users clear here and run user? Well, it's still an empty object or an empty dictionary. So you can see here that clear doesn't actually return anything. It doesn't? Well, it's just in place, removes whatever the dictionary has, so it just creates an empty dictionary. What about copy? Well, a copy allows us to copy a user so that if I print user and user two and I click run, I get two users each keys and values copied. But if I now, let's say clear the first user and I click run, the first user is empty.
03:57:19.494 - 03:58:06.178, Speaker B: But because I've copied the second user, the second user has the old information. And this is a concept that we've talked about before. Another useful command. And let's just go back to having user is user dot pop, which removes a key and a value from the dictionary. So in our case, let's just say we want to remove the key that is age. So I'm going to say age and if I run this, I get 20 because pop returns the value of whatever got removed. But if I do print user now, you'll see that age does not exist anymore because we've popped it off.
03:58:06.178 - 03:58:45.426, Speaker B: But pop, as you can see, removes the actual value or returns the actual value. 20. Here's another really fun one pop item. And honestly, this I haven't used much, but I just think it's a fun one pop item. If you guessed, well, you're not going to guess. Oh, and that's because I have to make sure I write it properly with lowercase. If I run this, what just happened? It randomly pops off something, one of the keys and the values, in this case age 20, is removed.
03:58:45.426 - 03:59:24.410, Speaker B: So the last item on the dictionary gets removed. But remember, a dictionary is unordered. So if this was a massive, massive dictionary that, well, doesn't have any order to it. Sometimes it removes some pair, as you can see, not the last one, but some pair of key value. So you have to be careful with this one. It doesn't necessarily just remove the last thing that you entered, but it might be useful on some occasions. Finally, we have something called update and update, simply updates, as the name suggests, a key value.
03:59:24.410 - 04:00:05.970, Speaker B: So let's have a look here. All we have to do is give it a new dictionary, so curly brackets, and just simply say, hey, I want to update age to 55 if I click run. Oh, and I forgot a bracket here, let's try that again. If I click run. There you go, age got updated. But if this was a key that doesn't exist like ages, and I click run, it will still update with a new key item. So this is another really useful method.
04:00:05.970 - 04:00:48.284, Speaker B: All right, that's it for dictionaries. I'll see you in the next video. Hooray. It's time for our third data structure as we continue down to our different data types in python. And this one is called a tuple, or tuple, depending on how you like to pronounce it. And we actually saw this slightly when we talked about dictionaries. But before we get into that, what are tuples? Well, a tuple are like lists, but unlike lists, we cannot modify them.
04:00:48.284 - 04:01:26.466, Speaker B: They are immutable. So you can think of them as immutable lists and they look like this. So let's call it, my tuple is going to use brackets to denote a tuple. And we can do 12345, just like a list. Now, you remember how in a list we could have modified this and said index of one? Well, now is going to equal z. If I run this, it's going to error out. It's going to tell me, hey, Tupleobject does not support item assignment.
04:01:26.466 - 04:01:50.930, Speaker B: A tuple is immutable. Once you create it, it's the way it is. You can't sort it or reverse it like we saw with lists. It's just there. What about this? Can I just print a tuple and just grab the second item on that tuple? Well, yes, you can. Just like a list. You can access it through an index.
04:01:50.930 - 04:02:28.464, Speaker B: Can I maybe do, does five exist in my tuple, just like we could in a list? Well, yes, we can. The difference is that it's immutable. Right? Now, why do we need this? I mean, we already have lists. Why do I have to learn tuple if you know it's pretty much the same as list? It's. The only thing is I can't change it. There's a few benefits to this. For example, if you don't need to change the list, that makes things easier because it tells other programmers looking at your code, hey, this shouldn't be changed.
04:02:28.464 - 04:02:54.632, Speaker B: Unlike a list, I want this to stay the way it is. Keep this order so it makes things easier and more efficient. It makes your code safer because people can modify it. Right. It makes code more predictable, however, it makes code more predictable, but it's less flexible than a list. I can't really sort a tuple. I can't run reverse on tuple now because of this, because they are less flexible.
04:02:54.632 - 04:03:27.592, Speaker B: The other good thing about them is that they're slightly more performant than lists. So they're usually faster than lists. And if you don't need a list to change, well, use a tuple. So a good use of a tuple, for example, if you work at Uber, is geographic location and coordinates, right. You can have latitude and longitude here. And because, let's say, this won't change, or maybe a user's location or pickup point doesn't often change. We can just use a tuple.
04:03:27.592 - 04:04:23.750, Speaker B: However, maybe when you're in a car as a driver and you're an uber driver, well, you probably need your coordinates, your latitude, longitude in a list because your car is moving that's constantly changing. And we saw tuple when we talked about dictionaries, right? Remember when we did user or we did user dot items and then I said, hey, just print user dot items. And we saw here that we got a dictionary items. And inside of this dictionary we see that basket. One, two, three, greet, hello, and age 20 are a tuple. So this actually returns our key and value as a tuple. And as I mentioned before, a dictionary can have keys that are immutable.
04:04:23.750 - 04:04:48.736, Speaker B: So a tuple is a completely valid key in python. So I can do one, two here, and that is a valid key in a dictionary. And the way I would access this would be like user curly bracket twelve. So that if I click run here, oh, I have an extra bracket. Let's fix that. Let's click run again. And there you go.
04:04:48.736 - 04:05:40.920, Speaker B: I'm able to grab user tuple twelve and grab 123 list. You see here how I'm trying to use different data structures, combining them together. Let's take a break and finish off our understanding of tuple. In the next video. Now, tuples, like I said, are quite similar to lists. So if I wanted to, I can say new tuple and use my tuple and then slice that tuple. So, for example, if I do one, two like this and print new tuple, I'm going to get two comma.
04:05:40.920 - 04:06:21.736, Speaker B: Hmm. Why is that? Well, we started zero, one and end at two. If I did four here and click run, I get two, three, four. It's still a tuple. But you have to remember that a tuple that only has a single item tends to have this little comma at the end, but it's still a tuple. And just like a list, I can assign different things. For example, I can say x equals to my tuple zero, and then I can say y equals my tuple one.
04:06:21.736 - 04:07:13.920, Speaker B: And x and y will equal one and two. But a short form of doing this, again similar to lists, is to say, hey, I want x, y, z, and you know what other to be the values assigned from the tuple so that if I do x here and I run, I get one. If I do z and I run, I get three. What if I do other? And if I click run, I get four and five as a list. All right, if your head doesn't hurt by now, don't worry, I have some good news. Luckily for us, a tuple has only two methods that we care about. Count and index.
04:07:13.920 - 04:07:58.500, Speaker B: How nice is that? So nice and simple. Guess what these mean. So let's go back to my tuple and now try these out. If I go my tuple that count, well, it's going to count the value. So if we want to count how many fives occur in the tuple, I get one. If I had another five in the tuple, I get two. What about index? What's the index of five? Well, the index of five is four because 01234, the first value that it finds, it's going to return the index of.
04:07:58.500 - 04:08:23.990, Speaker B: And then finally we can also do length, right? We can use this built in function to run length. And it's going to tell us that, yep, it has a length of six. Awesome. There it is. We're flying through them now. This is our third data structure. Remember, they're simply lists that are immutable.
04:08:23.990 - 04:08:49.876, Speaker B: I'll see you in the next one. Bye bye. Can you believe it? I hope I didn't put you to sleep, but we're almost there. We have one last main data type set and then we're done. I know, I know. This isn't the most exciting topic. Trust me.
04:08:49.876 - 04:09:16.452, Speaker B: This is the hardest part. When you're starting out and you're just learning these things without understanding, why do I need this? How am I going to build the next game? How am I going to build the next netflix? How am I going to build the next coolest Apple app? You're looking at this and thinking, I just learned a bunch of theory. I feel like I'm in math class all over again. I know. Trust me, I went through this. I was a self taught programmer as well. These are the Lego blocks that builds our foundation.
04:09:16.452 - 04:09:53.264, Speaker B: Once we learn these, we can move on to new things. And you'll see that once you climb this little mountain, things become so much easier. And you'll realize the power when we start building these projects, toward the end of the class where you're going to say, oh, all these blocks that we learned, all this frankly boring part is all going to make sense. So hang in there. It's supposed to be hard. It's supposed to be tough. But you'll see very soon why this is so powerful and why what we've just learned is going to allow us to build some really awesome things and create some really awesome programs.
04:09:53.264 - 04:10:24.604, Speaker B: So let's finish off with the last one, the last data type, the last data structure that we'll see in python, at least from the main ones. And it's called set. And sets are simply unordered collections of unique objects. Hmm. Let's have a look. Let's create a myset and my set. We create with curly brackets, like a dictionary.
04:10:24.604 - 04:10:45.330, Speaker B: But instead of a dictionary, we don't have key value pairs. Instead, we just have values like 12345. That's it. That's a set. We just created a set. But remember the definition I gave you. Set is an unordered collection of unique objects.
04:10:45.330 - 04:11:30.006, Speaker B: What does that mean? Well, if I print this and say my set, and I click run, I get a set. But if I had, let's say another five in here, and I click run, it only returns the unique sets or unique items. You see, in a set, there's no duplicates. Everything has to be unique. So this five just never gets added to a set. For example, you can add things to a set like my set, and then I can say dot add and give it a value like 100. And then let's say I do myset, add, and then give it two.
04:11:30.006 - 04:12:04.970, Speaker B: If I click run here, I see that I was able to add 100, but two, well, two wasn't really added because my set already contained that data. It's unordered I mean, we've created 12345 here, but there's no real order to it. There's no bookshelf in our memory space that is right next to each other. These are all over the place in memory. But I. A set is able to find them because they're all unique. So they're all in just one location in memory.
04:12:04.970 - 04:12:52.996, Speaker B: So let me ask you this, and this is going to be a fun little exercise. If I gave you an array, and let's say this array contained, well, this right here, and I want you to return an array with no duplicates. So I want everything in, let's say, let's call it my list. And a programmer has already created this. Okay. And then your task is to create or return a list or a collection that has only unique items. How would you go about converting this into a set? Well, we've seen this before.
04:12:52.996 - 04:13:33.658, Speaker B: We have a set function, and we simply wrap my list in that set and let's print it out. I click run, check it out. We have formed a new set from a list, and I've removed all duplicate values. When would this be useful? Imagine if we had usernames, right? Or email addresses. We're collecting email addresses on our startup page, but we don't want to have duplicate emails. We might want to convert this, a list of emails to a set and remove any duplicates. So we're not sending emails over and over.
04:13:33.658 - 04:13:54.932, Speaker B: So that's really cool. What about this? Can I. Let's change this into a set. So let's call it my Sethe. Going to change this into a set. There you go. And then what if I wanted to access my set at index of zero? Hmm.
04:13:54.932 - 04:14:32.464, Speaker B: Set object does not support indexing. Well, again, you can think of it more as a dictionary. In order to access a set, we have to grab by the item that's in it. That's the key to getting the information from memory. The way we would check if something exists is we simply say, hey, is one in my set? And we run this and we get. True. We can also do length of my set and we get five.
04:14:32.464 - 04:15:13.628, Speaker B: Again, nothing too crazy, but 12345, remember, it only counts the unique things because this will never gets entered. It's a set. And alternatively, we can also convert this into a list. If I click run here, you'll see that I now have my set as a list. And then we can also do, let's say, myset copy and actually copy my set into something, let's say new or new set. And then this will be completely different. Or a new copy than this original one.
04:15:13.628 - 04:15:56.072, Speaker B: So let's test this out. This new set, if I use a method that we may have seen before, which is myset clear, which, as you can imagine, clears the set, and I click run. I have that new set. But when I try and print our old set, which was my set, it's going to be empty. An empty set. But the true power of sets comes in the next couple of methods that I'm going to show you. And sets have quite a few methods, but don't worry, most of them are quite similar.
04:15:56.072 - 04:16:25.670, Speaker B: So let's explore that in the next video. Welcome back. The methods we're going to talk about when it comes to sets are right here. It looks like a lot, but they're quite similar. So hang in there. I have two sets for us. Our mysetan, which is one through five, and then your set, which is four through ten.
04:16:25.670 - 04:17:22.674, Speaker B: Now, let's go one by one and see what these methods do. And if you've ever seen Venn diagrams in your school, for example, two circles that are overlapping each other, what we're about to do is quite similar to this. The first one is difference. And sets are very useful when having two sets of and comparing them to each other. So, for example, in here, difference simply says myset dot difference, and we give it another set, such as your set. If I print this right here and I click run, I get one, two, three, it's going to find the difference of the first myset with your sethe. So any duplicates between the two, which is four and five, gets ignored, and it only shows the difference that is one, two, three.
04:17:22.674 - 04:18:11.210, Speaker B: What's different between my set and your set when viewed from my set? Well, your set doesn't have one, two, three. What about the next one? Discard. Again, if we do my set, dot discard, it says it removes an element from a set if it is a member. So here we can say discard five. And if I do print my set and I click run, I get none. But if I print here my set and I click run, I get 1234. Because we've just discarded five, it modifies our set.
04:18:11.210 - 04:19:30.270, Speaker B: Just to keep our working space clean, I'm going to comment these out. Next is difference update. So I'm going to say my set, and then once again, let's see what difference update does remove all elements of another set from this set. So if I do your set here, and once again, I do print and I click run, I get none, because it just modifies my set. So remember, we just have to have our print myset and now this, my set is updated with just one, two and three because we're updating it so that the differences are removed. So four and five are removed, unlike difference where it just told you the difference without changing. Again, if we go back here and simply do my set and I click run, you see that my set here was not modified right here, but then my set bottom was modified because of difference update.
04:19:30.270 - 04:20:13.720, Speaker B: All right, a few more to go. Intersection and this one once again, my set and in here, once again, let's read what it does. It just has intersection with something else. Let's find out. If I do your set here and I do print and I run this, it's going to give me four five because that's the intersection. The two common things that my set and your set has. What about is disjoint? Well, if I do my set and then your set, I feel like I'm saying those words over and over.
04:20:13.720 - 04:20:59.960, Speaker B: Hopefully that's not too annoying. And then here, if let's comment this out, we run this, I get false, is disjoint, simply says, hey, are those two circles overlapping? Do they have anything in common? If, for example, my set didn't have four, didn't have four and five, and I click run, I get true, because is disjointed means these sets have nothing in common. Awesome. Just a few more. The next ones we're going to see is, is subset and is superset. But actually, before we do that, let's do union. Let's see what this does.
04:20:59.960 - 04:21:39.940, Speaker B: Union will say my set. And in here we want to add the other set, your set. If we print this and click run, I get 1234-5678 910. What did that just do? Well, union just united these sets together but removed any duplicates. That's kind of nice. And as you can see, it created a new set for us. It returned a new set.
04:21:39.940 - 04:22:14.480, Speaker B: By the way, there's actually a shorthand that you can do here in python, which is the shift and then the key above your enter, which is right here, this straight line. So shift and then the backslash. But if you press shift, you'll get this little straight line. If you print this, well, remove the brackets here. Let's run again. And you see that works as well. And by the way, this also exists for intersection.
04:22:14.480 - 04:23:22.492, Speaker B: Again, you don't see it that often, but with intersection you can do the same thing where you just do the end, and if you do that, it gives you the intersection of my set and your set. Alright, I promised you this is going to be short. So two other ones is subset and is superset. As you can imagine, my set, if, let's say my set only has four and five, and I say, hey, is my set, is that a subset of your set? And I print this, if I click run, it's true, my set is a subset. That is, it's inside of the circle of your set because four and five is inside of it. So my set, the entirety of my set is inside of this other set, which we call a subset. On the other hand, we also have this idea of superset.
04:23:22.492 - 04:24:02.844, Speaker B: So if I do instead of is subset is superset, I'll get false because, well, my set is not a superset, it doesn't encompass your set. It's the other way around. Your set is a superset of my set because your set encompasses everything that my set has, which is four and five. Oh boy, that was a lot. And you're asking yourself, there is no way I'm going to memorize any of that. Well good. I don't memorize any of this either.
04:24:02.844 - 04:24:50.330, Speaker B: As a matter of fact, I usually go to the python documentation or just Google around. And because I know sets exist, if I ever want to compare, let's say two sets, I know to just go here and find the tool that I want. That's the cue of a programmer that I keep mentioning over and over. It's not memorization, it's the ability to know that there's tools that you can use and being able to Google for them. I know it doesn't sound exciting because in movies you see everybody typing super fast and coding everything, but that's just not real life. In real life, you just Google around, find solutions, because by now you know what sets are, you know what sets can do so that you can Google for methods that are appropriate to your problem. I'll see you in the next one.
04:24:51.750 - 04:25:18.200, Speaker A: Hey guys, I'm going to hand it back over to Andre in just a second, but he wanted me to let you know about two resources that he's made for you guys. The first one being the monthly Python newsletter read by thousands of Python developers to keep up with anything and everything involving Python. The second one being the python cheat sheet of that was initially made for students of his full Python bootcamp course. You can check both of those out in the description down below. Now let's get back to learning Python.
04:25:27.420 - 04:26:47.250, Speaker B: Welcome back. We learned about our basic python data types. We also learned a little bit about some of the terms that we might use when talking about code. We learned a few best practices, but most importantly, we learned how to perform actions on these data types. We saw that there's built in functions that we can run on any data type, such as the print function, but we also learned that most of these data types have their own methods, that is, that dot some sort of a name, and then the brackets to perform some actions on them. Now, we're still scratching the surface here, but we now go into an area that gets really, really exciting, because up until now, what we've been doing is this, every time we write code, we do something here, and then we go to the second line and do something else, and then finally go to the third line and do something else, and so on and so forth. Our Python interpreter just went line by line one, all the way to whatever line number we have on our py file and just ran the code.
04:26:47.250 - 04:27:42.580, Speaker B: And it ran it really fast, because machines are good at that. They run code really fast. But we haven't discovered the true power of programming, and specifically programming for machines. You see, the power comes when we start to incorporate the idea of maybe running multiple lines over and over, or maybe skipping a line and going from line one to line three. And in this section, we're going to talk about the idea of conditions and conditional logic. We're going to talk about looping and loops where we can perform actions hundreds, thousands, millions of time over and over, something that machines are really, really good at. And that's when programming becomes really powerful, because machines can do certain tasks a lot better and a lot faster than humans.
04:27:42.580 - 04:29:00.828, Speaker B: So we're now going to break into a new world where instead of going from one, two, three, everything in order, we're going to start to break some of that apart so that we have more control over our programs than just going line by line. Let's find out how to do that in the next video. Let's talk about conditional logic, an important concept all over programming. What do I mean by conditional logic? We've learned about booleans, right? We have true and we have false, and some of you might be wondering why they're so useful. And when it comes to conditional logic, booleans are really, really important. For example, let's say we create a variable is old, and you know what? We're going to create a car that automatically detects if you can start the engine. Maybe if you're not old enough, the engine won't start and it won't let you drive so that they make sure that this car is super safe and only people that are perhaps over 18 can drive it.
04:29:00.828 - 04:29:51.418, Speaker B: So how can we code something like that? Let's assume Tesla has a new feature like this. Well, we'll have something like Isolde, and we'll set this to true, right? Maybe we have something else. Maybe it checks the license to make sure that we have a license so we can say is license, and then we can set it to true. Now, these could change true and false depending on the user and the driver. But when I talk about conditionals, this is what I mean. In Python, we can use the if keyword to say if some condition exists and this is just me writing it, it doesn't exist. You can see that I get a red underline with invalid syntax.
04:29:51.418 - 04:30:35.970, Speaker B: But here we want to say a condition that evaluates to true or false. In our case, we can say, hey, if is old, which what does it evaluate to? Well, it evaluates to true. If that's true, then let's say print, you are old enough to drive. Now, there's a few new things here. One, I've added a semicolon or a colon. And then you'll see here that the indentation is different. As a matter of fact, when I press enter after the colon, you see that it automatically gives me a space.
04:30:35.970 - 04:31:22.578, Speaker B: This tells the python interpreter I'm going to do an if statement, a conditional operation. And if this happens to be true, run everything that's inside of here that has this indentation. And if I do something without the indentation, let's say print, check, check. This to the python interpreter is like a completely new line. It is not part of this if block. And if you're using the repl, you see over here, I get a little minus sign. If I click this, you see how it hides? Well, what it does is it's saying, hey, this is a code block over here.
04:31:22.578 - 04:32:06.004, Speaker B: It's an entire thing in itself, but anything outside that is not indented, well, doesn't belong to it. So to a python interpreter, it's going to say, I have this line, and then I have this line. Let me show you what I mean. If I run this program, I get you are old enough to drive, and then I also get check. Check. But what if I say isolde is now false? What do you think will happen if I run this? I get check, check. Our python interpreter is going to say, hey, set variableisult to false.
04:32:06.004 - 04:32:41.042, Speaker B: Hey, setislicensed equals to true. And then it's going to go to line three. Nope, nothing. There I'm going to keep going line four. Hey, if is alt, is this true? No, if old is false and the interpreter is going to say, okay, I'm only supposed to run this piece of code. If this is true, because this is now false, I'm just going to completely ignore what's underneath here and just go to the next line that has, well, no indentation. So it's going to print, check, check.
04:32:41.042 - 04:33:23.532, Speaker B: And this is the power of conditionals. We're able to essentially skip lines. The interpreter doesn't even care what's in here because I just told my program to skip from line four to line six. How cool is that? So we learned that there's this if keyword, but there's also another thing we can use called else. And you'll notice here that I didn't add it to the indentation. And else, as the name suggests, simply says, hey, if this something is true, then do this. Otherwise, also else do this.
04:33:23.532 - 04:33:46.821, Speaker B: And again, you see that I've added the indentation. So try to guess what's about to happen in this program. If I click run, I get check, check because it's saying, hey, is old. Is that true? Nope, it's not true. Okay, I'm going to completely ignore that. The interpreter sees else. Okay, well, this wasn't true, so I'm going to run.
04:33:46.821 - 04:34:41.418, Speaker B: Whenever this evaluates to false, I'm going to always run print, check, check. What if I change isold to now equal to true? What will happen next? Well, I get you are old enough to drive. Else only runs if the if block of code evaluates to false. Very, very cool. All right, let me ask you another question. What if I did print here and let's change this to, you are not of age. If I run this, is that what you expected? Well, I hope by now you agree that this is the expected behavior, because Isolde is true.
04:34:41.418 - 04:34:56.515, Speaker B: I'm going to print this. And then Python interpreter is going to say, well, this was true. So I'm going to completely ignore the else block and then just go to the next line. What's on line eight? Nothing. So I'm going to go to line nine and I'm going to print. Okay. Okay.
04:34:56.515 - 04:35:46.055, Speaker B: Okay. As you can see, we're now controlling the flow of our programs, where instead of going from one to nine, just line by line, we're now saying at line four, do some sort of check. And based on that, skip a few lines. Very, very cool. All right, there's one other thing I want to show you, and it's the Elif and I know this kind of looks weird. You would think that it'll be else if, but no, no, no, it's Elif. And what do you think this does? Well, you use it in combination with if you say if something, if otherwise, else if another condition.
04:35:46.055 - 04:36:24.070, Speaker B: So let's say is licensed, then do another condition. So let's say print, you can drive now. So let's go through this again. I'm going to say, is this person old enough? If that person is old enough and this evaluates to true, well, then I want you to run this. Otherwise, I want you to run this condition. Hey, is this true? No. If it's not true, then jump to else.
04:36:24.070 - 04:37:12.169, Speaker B: So what will happen here? If I click run, we get true for the first conditional block right over here. So automatically python interpreter is going to say, well, we just got true here, so I'm going to ignore this and ignore this and then print. Okay, okay, but let's say that is old is now false. What will happen next? If I click run this is false. So Python interpreter is going to say, nope, not going to care about this block. And I'm going to go, hey, else, if a condition, hey, is this person licensed? Yep, they are. So I'm going to print, you can drive now and ignore else.
04:37:12.169 - 04:37:39.568, Speaker B: So it works like this. What if both of these were false? Well, as you can imagine, the python interpreter is going to ignore. It's going to run this, say, nope, this is false. This nope, this is false. And then finally it's going to run this. You see, that else is a catch all. That is, if none of these conditions are true, then we're just going to run this.
04:37:39.568 - 04:38:06.868, Speaker B: So it's a backup, in a sense. Hey, if all things fail, then just do this. Very, very cool. Now, if you look at this program, you're thinking, hmm, this program doesn't really work that well, does it? I mean, we're checking if the person is old and if person is licensed. But shouldn't we check both? We want somebody who has a license and who's old enough to dry. Hmm. This is, this is a buggy program.
04:38:06.868 - 04:38:51.909, Speaker B: If we implement this in a Tesla, well, we're going to get a lot of lawsuits, right? Because we can get somebody who's maybe licensed but isn't old enough, which I guess doesn't make sense. But we can get somebody who is old enough but never got their driver's license, and somehow we get access to the car and they can start the engine and drive and. Oh, that's a, that's a lawsuit waiting to happen. So how can we fix this? Hmm. You know what the power is that this is an expression, right? An expression, if you remember, is something that produces a value. And that means that this doesn't have to, you know, just have true here. It could be an expression.
04:38:51.909 - 04:39:31.929, Speaker B: So I could say if is old and is licensed, then I can do that. And this is something new that we haven't seen before. The end. This is another keyword in Python, and in an upcoming video we're going to talk about more of these keywords. But this should read like English, right? If Isolde and is licensed, then do this. So we can now remove the elif. And then here both expressions need to evaluate to true.
04:39:31.929 - 04:40:17.510, Speaker B: That is, whatever happens here, this has to evaluate to true, and this has to evaluate to true. And only when both are true again, as end states, then you're old enough to drive and you have a license. So that if I run this well, I get an error, right? Because, or not an error, but it goes into the else block because both of these are false. If only one of them is true and I click run, you are not of age because both of these have to be true. If I click run. Hey, all right, the car is starting. You can drive away with your Tesla.
04:40:17.510 - 04:41:08.710, Speaker B: Okay, before I finish this video, because this is a lot, I want to just note one thing. That is the lhide if statement. The Elif statement is really, really useful because when you have code like this, where you have an if statement and an else statement, usually you only see one of each. I mean, sure, in another part of the program, I could have another if statement and an if statement with another else statement inside of here. But usually when you have this grouping together, you only see one if and one else. But you can have multiple elifs. So I can have Elif another condition here, and then I can have another elif, another condition here, and you can have as many as you want.
04:41:08.710 - 04:41:27.290, Speaker B: Eventually the program is going to either evaluate one of these conditions to true or it's going to go into the else block. But usually you follow this order. Order. All right, that was a lot. Let's take a break and explore this topic a little bit more. I'll see you in the next one. Bye bye.
04:41:27.290 - 04:42:26.462, Speaker B: I want to add a quick note about this spacing that we see in this code. Now, this isn't just for Python. In other languages, you'll always see this. You're not going to see that every single line of code always starts as well in the first space. Different languages will use this differently, but in order to organize code, usually you'll see some indentation like this. Now Python, however, is unique because the indentation and spaces that we see here makes the interpreter see it and say hey, this means something. The interpreter would actually see the space and say because there's space here.
04:42:26.462 - 04:43:24.742, Speaker B: I know that this is part of the if block. In other languages like JavaScript, well, you have something similar, but usually you'll have an if statement and then some condition followed by make sure I spell condition right, followed by something like a curly brace. And in here, whatever is in here, you can see that I still get the space and I can do whatever I want. But JavaScript interpreter doesn't really care that there are spaces. If I want, I could write my code just on one line like this, and it's still valid JavaScript code. So people usually do the spacing more for style purposes. Python, on the other hand, is not just for styling that we do this, but because the interpreter actually finds meaning in the spaces, which is actually one of the big selling point with Python.
04:43:24.742 - 04:44:03.572, Speaker B: It's very clean. There's no extra stuff here that makes it difficult. I mean, it's just English, right? If Isolde and if is licensed, then print this. It's just really nice to read and really clean. Now if you notice here my editor and we're going to talk about editors and ides in an upcoming section, but if you are using the proper tools, this automatically is created for you. Now, in the programming world there's this debate about tabs and spaces, and we're not going to get into it. It's frankly a little bit silly.
04:44:03.572 - 04:45:01.146, Speaker B: That is, some people prefer to hear if they want to create a space, they might use spaces or they might use tabs. At the end of the day with Python, the rule is we can use spaces, you can use the tab, but the idea that if you use spaces, you usually use four spaces, it's just a standard. Now if you notice here, I actually don't have four spaces, it's two spaces here. And that is because up until now, well, I've just been following along whatever this editor gives me, but if you look over here, there's an auto format button. If I click on this, it automatically formats my code into the appropriate format. And you see right over here that I now have four spaces. But you see that the code still works.
04:45:01.146 - 04:45:58.576, Speaker B: Again, it's because at the end of the day, the important part is that there's a distinction between hierarchies that is the top and then maybe the children. But the interpreter itself is going to notice these spaces. So you do have to be careful because based on where this print is, as soon as I add a tab in here and I click run, well, I get Isolde and islicensed. But as soon as one of this is false and I click run, you see that? Ok, ok, runs only if this condition. Again, if previously both of these were true, I only get the first line printed. So that little space here changes the outcome of my program. So you have to really be careful with this.
04:45:58.576 - 04:46:28.670, Speaker B: And luckily your editor or where you code is going to help you out with this. But it is a gotcha that if you're just starting out, you want to be mindful of. All right, no more debates about spaces and tabs. I'll see you in the next video. Bye bye. Welcome back. In this video I want to talk about the idea of truthy and falsey.
04:46:28.670 - 04:47:18.990, Speaker B: What do they mean? And you'll hear this a lot in python programming. You see, up until now you've used booleans here as values, so it was really easy. If true and true, then run this code. But Python can do other things as well. For example, if this was five and this was, let's say hello, what do you think will happen here in our program? Well, if I click run, you are old enough to drive and you have a license. Is that what you expected? And this is because what Python does underneath the hood is actually convert these to booleans for you. So it's almost as if it is doing this.
04:47:18.990 - 04:48:04.340, Speaker B: Remember type conversion? We're converting the type to Boolean as soon as we get to this if statement, because Python is saying, hey, I want true or false. I don't care what isold is, I don't care what islicensed is. Just give me true or false so I know whether to do this or to go to the else block. Now, if I was to just print, let's do this here, let's do print boolean, hello. And then finally print Boolean five. Let's see what we get. We get true true, and this is what we call a truthy value Python.
04:48:04.340 - 04:49:09.906, Speaker B: That is, it's a truthy value because if we run the boolean type conversion on it, it evaluates into true. What's a falsey value? Well, if I do zero, and if I do, let's say an empty string and I click run, those are false. That is, it's not actually false, but it is false because if we run Boolean on it to Python, it's going to say, oh, this is false and zero. That's false. And that kind of makes sense, right? And if you actually go to stack overflow, if you've never seen stack overflow before, if you ever have programming questions and you're googling them, usually the top five answers will contain either one or two stack overflow answers. And basically what happens is people ask questions like what is truthy and falsey in Python? And you get answers. So you can see over here that it has four answers and you usually look for the check mark, which means that this is a verified answer.
04:49:09.906 - 04:49:42.330, Speaker B: It means that hey, this question owner has accepted it as the best answer. So the person who asked this question just said, yep, this is the right answer, this is the best one. But you also have other people voting. So you can see that this answer received 46 marks. And although it was marked as the correct answer by the user, maybe somebody else came along later on and gave an even better answer. So now we have 123 upvotes and you see that this answer is a lot better. All values are considered truthy except for the following.
04:49:42.330 - 04:50:50.610, Speaker B: So you can actually see here that in python these values are considered falsey. You can see zero here, you can see an empty string here, and then there's a few other ones. Empty set, you have a empty dictionary, empty list, empty tuple, you have decimals, you have things like fractions, you have 0.0. False is that, and also none is falsely so that if I type in none here, that's false too. Now you don't need to memorize these because most of the time it makes sense, right? But it helps us do conditional logic very nicely. For example, let's remove this and let's say that we have a user, and this user has to have a password and a username. If, let's say the username is Johnny and the password is one, two, three.
04:50:50.610 - 04:51:39.000, Speaker B: Well, instead of me saying, hey, if this user has password and username, and we're not checking if the username exists or password exists, we just want to make sure, hey, did this person fill out the form and did they try to submit a username and password? I can just simply say password and username. And I don't have to worry about converting this to a boolean or anything like that. Because if password and username exist, then try to log them in. And you see that it reads a lot nicer because each one of these get evaluated into a truthy and falsely value. It's a nice little feature to keep python well, nice and simple and reading like English. I'll see you in the next video. Bye bye.
04:51:39.000 - 04:52:27.532, Speaker B: I want to talk to you about another way to do conditional logic. We saw the if Elif and then the else statement, but, and there's another way called the ternary operator. Now, this is still the same as the else if or if else statements, but it's a shortcut. So you can only use these on certain conditional logic. So it doesn't mean that, hey, this is just an entirely new way. This is a shortcut in a sense for you to make your code a little bit cleaner. Let's have a look.
04:52:27.532 - 04:53:08.782, Speaker B: By the way, these ternary operators can also be called conditional expressions. And when you hear the word expression, that should mean something to you, right? It's an expression because it evaluates to evaluate. So a ternary operator or a conditional expression is an operation that evaluates to something based on the condition being true or nothing. And it's actually a new feature of python as of version 2.4. So let's have a look. The way we use this is to say is condition. If this is true, then do this.
04:53:08.782 - 04:53:45.024, Speaker B: So this is the condition if true. And bear with me here, it is a little bit confusing at first we say if, and here we give condition, otherwise, condition if, else. All right, that is a little confusing. So let's go through it. So the if is going to check this condition. So it doesn't actually start with here. It's going to say, hey, if this condition, now this is going to evaluate to either true or false.
04:53:45.024 - 04:54:22.340, Speaker B: If it's true, then we're going to do this. Otherwise we're going to do this. So let me show you an example of how that would work. Let's say we're trying to determine if, well, if a user is your friend, so we'll say is friend. And here we can set true or false for friend. Maybe we can check on Facebook if users can message you, or on Twitter whether Twitter users can give you direct messages. Well, here and let's do can message.
04:54:22.340 - 04:54:56.950, Speaker B: And here we can do our ternary operator. We're going to say message allowed if. So this is if the condition is true. The condition is, hey, is this person your friend? Otherwise, condition that is false. Well, I'm going to say not allowed to message. And you can see here that this is a one liner. It looks like two lines, but you can see over here that it's not really, it's just that we're wrapping so we can see the entire code.
04:54:56.950 - 04:55:57.910, Speaker B: So let's run this and see what can message prints. If I run this message is allowed because, well, we've assigned message loud to canmessage because, well, the condition was true if this person wasn't my friend. And I run this not allowed to message because the condition that if condition evaluates to false. I know the ordering here can be a little bit confusing, so you might have to look at it a couple of times and you do need to use it a few times to really remember it. But this is the general rule. Condition if true, if condition else condition if not, if else if false, can't spell. All right, a nice shorthand way to do something when a condition is either true or false or evaluates to true or false.
04:55:57.910 - 04:56:48.500, Speaker B: Alright, I'll see you in the next video. Bye bye. It's time to talk about another topic that sounds a lot more confusing short circuiting than it actually is. It's quite simple. Short circuiting looks something like this. Remember when I taught you the word and so we can use, let's say, for example, is friend equals to true and let's say is user is equal to true. And I can do an expression here saying is friend and is user.
04:56:48.500 - 04:57:46.190, Speaker B: Now in here, when we run this, let's print it here just so we can see. If I run this, I get true because both of these evaluate to true. So that if I had this as an if block, let's say if it was if isfriend and isuser print best friends forever. Now, short circuiting can be done when we use something like or which we haven't seen before. But again, you can see here that it's highlighted in blue. So it is a keyword, a python keyword now, or says if either one of these conditions are true, then run this piece of code. So if I run this, I get best friends forever.
04:57:46.190 - 04:58:37.852, Speaker B: Now let me ask you this. Which operation do you think is more performant? The or the and is there a difference? As a matter of fact there is, because of short circuiting. You see, when I do or here, because I only care if either one of these is true, the python interpreter is going to say if is friend and it's going to evaluate that and say, oh, this is, this is true. And then it's going to see the word or, and it's going to say, hey, I don't care what this is. Maybe this is a really heavy operation or something that I need to look up. Well, I don't really care because this is already true. Whether this is true or this is false, I don't really care because either way I'm going to have to print this.
04:58:37.852 - 04:59:16.462, Speaker B: As you can see, it still prints best friends forever. So short circuiting happens when the interpreter is smart enough to say, I already did enough work. I don't care what this is, this is just wasted work if I do it. So I'm going to short circuit and say, hey, I'm going to just ignore this and I'm going to start printing. So using or is a little bit more efficient. But again, it depends on what you need. If you need to check if both isfriend and isuser is true, you'll have to use and, but this works both ways with and as well.
04:59:16.462 - 05:00:02.294, Speaker B: For example, if isfriend is false, this is going to get short circuited because I'm going to say, hey, if isfriend is false, well, I don't really care what is user is because there's no way that both of these are true. I've already seen that one of them is false. So I'm going to ignore this and I'm going to print this. And when I say I, I mean our good old friend Python interpreter. Now, this topic of short circuiting doesn't really get taught in beginner Python courses, but now if you hear this, maybe you hear this in an interview. As you can see, it sounds a lot more difficult than it actually is, and frankly, it makes a lot of sense. Right.
05:00:02.294 - 05:00:29.170, Speaker B: We want our machines to be efficient and it is quite efficient due to short circuiting. I'll see you in the next one. Bye bye. Welcome back. And let's talk another term, logical operators. And they're very, very useful when it comes to conditional logic. Let's have a look.
05:00:29.170 - 05:01:16.320, Speaker B: Logical operators are, well, as a matter of fact, you've actually seen them before and is a logical operator, or is a logical operator. It allows us to perform logic between two things. What else is a logical operator? Well, let me list it out for you. We have greater than, less than equal to. Let's actually use them in an example. Is four greater than five? Well, if I print this, what do you think will happen? Shouldn't be a surprise. That's false.
05:01:16.320 - 05:01:44.252, Speaker B: Four is not greater than five. This is a logical operator that you may have seen in math class. If I do the opposite is four less than five. That makes sense. That's true. What about is four equal to five? If I run this, I get false. Now, why did I use two equals here? Why not just do this? Well, if I run here, I get an error syntax error.
05:01:44.252 - 05:02:30.840, Speaker B: Keyword can't be an expression. It's because remember, equal is what we use to assign to a variable, right? And if you remember, I told you that a variable in python can start with a with a number, it has to be a letter or underscore. So when I do this, it's going to error because the interpreter is going to say, hey, I'm trying to assign variable for the value of five. And, well, that's not really allowed. So we use double equals to tell the interpreter, hey, I'm not assigning a variable here. I want to compare things and we can compare different things. I can do hello equals to hello equal to true.
05:02:30.840 - 05:03:13.242, Speaker B: What if I do a is greater than b, I get false. Now why is that? This, I want you to google on your own and figure out y is a greater than b. What if I do a is that greater than capital a? That's true. Hmm. This is, this is interesting, and this is actually quite an interesting reason. So I know, I know it's easy for me to just give you an answer, but I want you to practice googling this. And the reason I'm not giving you an answer is it's also because it's not very important.
05:03:13.242 - 05:04:00.244, Speaker B: Because most of the time you want to make code that is easy to understand and understandable, you're most likely using greater than and less than with numbers. So if you see something like this in code, well, you wouldn't know what's going on. What is this person trying to compare? Why are they doing? Is lowercase a greater than capital a? It's not something that you see very often, but the reason you get this expression is quite interesting. So I do recommend you Google Google into it. Like I said, I'm a strong believer in not holding your hand the entire way. I know so far the videos up until now have been quite easy, especially if you are an experienced programmer. But as we progress, you'll see that after this course, you need to figure things out on your own.
05:04:00.244 - 05:04:46.270, Speaker B: And my job is not to just handhold you the entire way, it's to develop the skills in you to become an employable programmer. So I hope you bear with me as I just give you this little challenge. All right, we went a bit on a tangent, so let's bring it back. Can I do things like this? Is one greater than two or you know what? Let's do less than two and less than three and less than four. Will this work? Well, of course it will. It's just an expression, right? That we're evaluating and all of this is true. But as soon as I change and something is false, it's going to short circuitous, which we learned about previously, and return false.
05:04:46.270 - 05:05:30.412, Speaker B: Alright, so we know the greater than equal to less than sign. We also have greater than or equal to so that if I do zero here and I click run, I get true because it's saying, hey, is this greater than or equal to zero? I can also do less than or equal to zero. And here I get false because zero or one is not greater or equal to zero. But if I do zero here, I'll get true. Here's another one. What if I do this exclamation mark equal. This means in python not equal to.
05:05:30.412 - 05:06:08.458, Speaker B: If I run this, I get false. And this is a little tricky. What it's saying is, hey, is this not equal to this? So it's the opposite of doing equals. If these two things don't equal, it's going to say true. So if I do one here, I'll get true because these two things do not equal. So we've learned greater to or less than greater to equal equals equals or greater or greater or equal to. We've learned about less than or equal to.
05:06:08.458 - 05:06:47.250, Speaker B: We've learned about not equal to, but we've also learned about and, and, or, and finally, there's one more I want to teach you. And it's the not keyword. I know, I know it's a, it's a little, it's a little much, but it's not as hard as you think. Not is, well, the opposite. So if I do here not true, what do I get? I get false. And you see that not is also a function. So it's a keyword, but also a function that we can use.
05:06:47.250 - 05:07:38.924, Speaker B: If I do not false again, I just get the opposite. What if I do this? What if I do not one equals to one, what will I get here? I get false because this expression evaluates to true and then not just does the opposite. So let's take a break here and work on a little bit of an exercise to make sure that we understand this. Welcome back. Let's do a fun little exercise. We just got hired by a gaming company and we're creating this wizard game. And this wizard game has the is magician in the user's profile.
05:07:38.924 - 05:08:11.930, Speaker B: And for now we'll just set it to false. We also have is expert and whether this user is an expert at this game, we'll leave it at true for now. And then. Hmm. Let's, let's do this. Here I want you to check if both, or check if magician and expert. And if that's the case.
05:08:11.930 - 05:09:07.402, Speaker B: If true, then I want you to print you are a master magician. And also I want you to check if magician but not expert. If that's the case, I want to just print. At least you're getting there. And then finally, let's do a check that says if you're not a magician, I want to say, hmm, well, you need magic powers. Now I want you to use what you've learned about logical operators to create this conditional logic. You can pause the video if you want and try it yourself in a repl.
05:09:07.402 - 05:09:55.990, Speaker B: Otherwise, I'm going to keep going with an answer. But you should be able to solve this fairly easily if you've been following the videos and exercises so far. So let's start with the first one where we say you are a master magician. So I'm going to say if is expert and is magician, I am going to print you are a master magician. So I'm going to copy that and say print you are a master magician. Nothing too crazy here. And then next one I'm going to say if, or I could even say Elif if I want.
05:09:55.990 - 05:10:31.510, Speaker B: And again, this is something that you can decide what you prefer. I usually like using El if, if it's part of the same concept as the first one. In this case. Yeah, we're, we're still trying to figure out what type of user it is. So we'll use Elif and we'll say Elif, we want to check if it's a magician. So that is Isdev magician. So we're going to check if that's true, but we also want to check if, well, not an expert.
05:10:31.510 - 05:11:39.438, Speaker B: Now, how do we do this? I mean, we could say use short circuiting and say is expert. And even if this is false, we can get true here because is magician short circuitous? And print this part. At least you're getting there, because the interesting here is that this code block is never going to run if both of these are true. Because in the first if block, we're checking that so that as soon as this is true, we're going to completely ignore the elif. So we could do that. But, hmm, this is a little bit hard to read because I really have to think about it. If I come back to the code or somebody else looks at my code, it's not clear that unless I comment that I'm checking if it's magician but not expert, because this will never run if his magician is false, then that's what they're checking for.
05:11:39.438 - 05:12:07.964, Speaker B: I know, it's kind of confusing even saying it. So I prefer using something like this. Using and not. And that reads a lot better, right? It makes a lot more sense. Hey, if this person is an expert and magician, do this. Otherwise, if this person is magician and not an expert, then print this. That reads pretty nicely.
05:12:07.964 - 05:12:51.290, Speaker B: And yes, you can do this because remember, not is simply checking, inverting, whatever the boolean expression is. So this still evaluates to a boolean that and can check. All right, let's finish the final one. If you're not a magician, you need magic powers. So how do we check here? Well, we can do another Elif and say not is magician. And if I run it like this and say print, and we'll just copy here, you need magic powers. And let's remove the comments for now, just so we can see the blocks of code.
05:12:51.290 - 05:13:20.500, Speaker B: And we're going to test our program. Hopefully we coded it properly. Hopefully there's no bugs. But let's have a look. If I run this, you need magic powers. Why is that? Well, if magician is false, none of these are going to work. What if I change this to true and I click run? All right, I am a master magician because I'm an expert as well as a magician.
05:13:20.500 - 05:14:13.590, Speaker B: What if I turn this to false and I click run? Hey, at least you're getting there. I'm a magician, but I'm not an expert yet. I'm still, I still need to improve my gameplay. Now, you may have gotten a different answer than me, and there's many ways to do this, right? You could have used an else statement you could have used or conditional logic is all about writing code that makes sense not only to you, but for other people reading your code. The idea is not to be extremely clever or really worry about short circuiting. Yes, it can be more performant, but a machine is so powerful that just tiny bit of optimization there is usually not worth it when you're losing, perhaps readability. So you want to make sure that your code reads like English.
05:14:13.590 - 05:14:59.656, Speaker B: And this is a topic that frankly, a lot of beginner programmers have a hard time understanding, where they try to be as clever as possible, write as little code as possible in the shortest possible lines, when instead you want to focus on readability. Because a code that is easy to understand is a sign of a good developer. And I hope looking at this, you're thinking, yeah, this is, this is pretty easy. I mean, this all makes sense. But this is not the only way, maybe my version of what breeds well is different than yours. The idea is to each of us try our best to make our code simple and nice. And in programming there is no one right answer.
05:14:59.656 - 05:15:54.776, Speaker B: There are many ways to solve a problem, but the key is to solve it in a simple manner that is readable. I hope you had fun and I'll see you in the next one. Alright, in this video I'm gonna try and trick you. I want you to look at these expressions where I'm checking for equality, right? I'm saying, hey, does true equal one? Does empty string equal one? Do two rays equal that are empty equal? Well, each other. Now pause the video here and try to guess what the outcomes of this are going to be. Ready. By the way, if you get 100% on this, well, good for you, because if this was my first time learning python, I wouldn't get this.
05:15:54.776 - 05:16:28.430, Speaker B: Let's go. Hmm. Is that what you expected? True evaluated. So true equals one evaluated to true. An empty string equals to one evaluated to false. That makes sense because they definitely don't equal each other, right? An empty array doesn't equal to one and a ten equals 10.0, and then both arrays that are empty equal to true.
05:16:28.430 - 05:17:00.958, Speaker B: Now, the reason I'm showing you here is that the double equals checks for equality or equality of value. That is, if, for example, the first one true equals to one. There's two different types. One's an integer, one's a boolean. It will convert them into the same type. In this case, this will be converted like this to a boolean value. And if you remember, one is truthy.
05:17:00.958 - 05:17:48.122, Speaker B: So this will evaluate to true, which is why we get true. What about the other one? Well, an empty string is falsely so it evaluates to false, and false doesn't equal true, right? Because we're checking for equality here. So one of these gets converted to the other's type. What about an empty array? Again, an empty array is actually falsey, so that's not going to equal one. A ten equals to a float of 10.0 that gets converted to an integer or float and they're going to equal each other. And that's an expected behavior.
05:17:48.122 - 05:18:11.320, Speaker B: And then an empty array, well, equals an empty array. If I add in this array, 123123 and I click run, I get an invalid syntax. Oh, because I have this here. Let's run that again. I get true. That makes sense. Let's change this to one and see what happens if I click run.
05:18:11.320 - 05:18:54.520, Speaker B: Alright, still false. Now this does get a little tricky, right? Like hmm. Should this have evaluated to true? But no, we get false. So this doesn't get converted in type versus what we had here. Now don't get confused by this because this would be bad code if you're checking something like this. Well, obviously you should be checking two types, two of the same types together. Ideally when you use comparison operators or logical operators like this, you're comparing two types and you're not letting Python do this type conversion.
05:18:54.520 - 05:19:38.044, Speaker B: And hopefully python figures it out for us. But I hope the double equality makes sense because there's another check that we can do, which is, is and is. Well, is a keyword in python. What happens if we change all these equal signs to is? Do you think there would be a difference? Let's have a look. If I click run, I get false for everything. Hmm. So what's the difference here? Equals checks for the equality and value such as 123.
05:19:38.044 - 05:20:13.276, Speaker B: Well, that has the same value as one, two, three in a list is actually checks if the location in memory where this value is stored is the same. Let's go through that. So true is that one. No, true. Is not one true, is, well, only true. Right, that will be true. What about string one? Is that one? No, I mean, for one to be a string, that needs to be one.
05:20:13.276 - 05:21:05.762, Speaker B: Right? Because the one string isn't only in one place in memory, it's literally the exact same thing. What about this list? As a matter of fact, let's do is array empty array? Is that or is this list a list? Well, if we run this, I still get false. Hmm. And this is a little tricky and also advanced. Every time I create a list, it's added in memory somewhere. So this is in a location in memory, but whenever I create a new list, it's created in another location. So these are two completely different lists that live in different locations in memory.
05:21:05.762 - 05:22:10.362, Speaker B: So it's going to check. Hey, is this in the same memory space, same bookshelf as that one? Nope, that's not it. But why does this work for things like numbers and strings? And that's because underneath the hood, these are types that are very simple, that are in memory, but in one location versus something like a list, even though this might be the same list with the same items, because this is a data structure, every time we create it, it's created in a new location. So that even if we have a variable a that contains this list. And by the way, this will be the same for all our data structures like dictionaries, sets, tuples. If I do, b equals this and I check a. Is that b? No, they're created in a different memory space.
05:22:10.362 - 05:22:52.264, Speaker B: So this where a points is in a different place than where b points. But if I do a equals to b, I get true, because this double equality checks only the values. Now, this is a bit of a hard topic, so you might have to watch this video a couple of times. You might have to practice this a few times yourself. But just keep in mind the difference between is and double equals is tends to be a little stricter. You're checking for the exact thing that you're looking for versus equality, which checks the value. All right, that was a doozy.
05:22:52.264 - 05:23:35.900, Speaker B: I'll see you in the next video. Bye bye. Let's talk about loops. We've talked about conditional operators, logical operators, but loops gives us a whole new power when it comes to our machines. The concept of loops or looping in programming is really, really powerful. We saw that with logical operators and conditional logic, we're able to skip lines in our program so that we don't always go 123456, so on and so forth. But loops do a really interesting thing.
05:23:35.900 - 05:24:37.332, Speaker B: It allows us to run lines of code over and over and over. And that's really powerful because that means we can run things thousands of times, millions of times. And this is where machines excel. Machines excel at doing small tasks over and over, really, really fast, way better than humans. So loops are one of the most powerful features of programming languages. So how do we create one? Well, it's as simple as using what we call four, or in Python, we call them for loops, with this keyword for, we're able to say for, let's say item in zero to mastery, do something. So they're kind of like conditional operators instead of if we have four, but then we have this thing right, where we have item, which.
05:24:37.332 - 05:25:12.392, Speaker B: What is that? We don't really know. Well, this is a variable that we created. We can name it whatever we want. We can say I, we can say teddy bears, whatever you want. This is a variable, and a variable is created here for each item after the in. So it's saying, hey, for every item in zero to mastery, do something. And we've seen this in keyword before, and we'll dig deep into this later.
05:25:12.392 - 05:25:58.426, Speaker B: But we call this an iterable. An iterable is something that is able to get looped over. So an iterable allows us to use this notation of a for something in an iterable to iterate over each item. In our case, if I print item here and I click run look at that. It prints each item in the iterable, which is the string zero to mastery. So every letter, it goes into every bookshelf in our machine's memory and prints each item one at a time. Now, this works with strings, but we can also use lists like 12345 that we've seen before.
05:25:58.426 - 05:26:30.470, Speaker B: If I click run again, this is an iterable, we're able to iterate over it and it grabs each item in the list. Let's do a set. Can we do this with a set? Well, if I click run, that works as well. What about a tuple? Let's do it with a tuple. If I click run, that works as well. That's amazing. What about a dictionary? Well, we'll get to dictionaries in a bit.
05:26:30.470 - 05:27:09.920, Speaker B: So for loops, allow us to iterate over anything that has a collection of items, so that in this case we're looping 12345 times. And you can see over here that we have the column and then the indentation to tell Python, hey, whatever comes here, I can print item again. I can print item again. I can do it as many times as possible. As long as I have indentation. It's going to keep printing our numbers. But as soon as I open up here and print something else.
05:27:09.920 - 05:28:08.140, Speaker B: Well, I only get that once because it's not in the loop. So our program first runs this for one. So it's going to print one three times, then two, then three, then four, then five, and then only finally. Then it goes to print. You see how we're looping over and over and over? Now what happens if I try and print item here and I click run? Did you see that? Item gets printed at the very end here. I don't know if you can notice it, but you see that there's four fives. We've printed 1234 each three times, but five gets printed four times, because this last print at the very end is, well, five, because by the time the loop ends item, the value of item is actually five.
05:28:08.140 - 05:28:52.204, Speaker B: Let me ask you this, can I do something like four, let's say xdev in another list that contains strings a, b and c. Could I do something like this? Absolutely. I can nest things in Python. And as a matter of fact, when we do conditionals in python, like if statements, we can always nest those as well, because in python it's always the indentation. Right? So I can say print here, item and then also print. And you know what? Let's print them one next to the other. So I'm going to say print item and print x.
05:28:52.204 - 05:29:48.240, Speaker B: If I click run, you see that we're printing one and a, one and b, one and c, because item we run line one. So item is created currently one. So we're going to go to the next line, line two, and we're going to say we're going to loop over this iterable and we're going to say this is x. So this is going to be one, this is going to be a and then Python comes back to line two because we're still in this loop and we're going to say, hey, what's X now? Well, we're done with a, so let's go to b. So it's going to run Bde and then c, and only once this is done does it go back out. And now starts with two, which is right here, two a two b, two c. So you can have nested loops over and over and over as well.
05:29:48.240 - 05:30:49.034, Speaker B: All right, so these are loops. And right now maybe it's not completely obvious why these may be useful, but before we get into that, I want to talk about this idea of iterable in the next video. Welcome back. I kept mentioning this key term iterable, but what does it really mean, iterable? You're going to hear that over and over in python programming and other programming languages as well. And as we discussed a little bit in the previous video, iterable simply means it is an object or a collection that can be iterated over. So again, an iterable can be a list, can be a dictionary, can be a tuple, can be a set. It's a collection of items.
05:30:49.034 - 05:31:26.530, Speaker B: We also saw that a string could be iterable. Now, these things are iterable. Why? Because they can be iterated. That is, iterated means we can go one by one to check each item in the collection. And you're going to hear this over and over when talking to Python programmers. So you want to make sure that you have that vocabulary. You're iterating over something, you're looping over something.
05:31:26.530 - 05:32:25.160, Speaker B: So iterable is the noun and iterated, or iterate is the action of iterating over an iterable. I know it's a little confusing. Now, many objects in Python, like I said, are iterable, but there's a few special ones that we haven't covered yet, specifically, dictionary. We saw how lists, tuples, sets and strings can be iterated. But what about an object? Let's say we have an object here, and this object will be users, and users or user will have a name of Golem, will have age of 5006 golems, pretty old. And then we'll say can swim golem, let's say cannot swim. False.
05:32:25.160 - 05:33:12.422, Speaker B: What if we use this object right here for item in user and we print right here the item? What do you think will happen? Let's run this. Well, I get an error because I forgot a semicolon here. And we don't want equals, we want semicolon. And then obviously this needs to be a string as well. Now if I click run here, look at that, I get name, age and can swim. So I've printed the keys of the dictionary. Now this dictionary, we have the keys.
05:33:12.422 - 05:34:12.508, Speaker B: That's great, but, hmm, what if I wanted actually the values? Is there a way to do this? Well, dictionaries have three methods that are really, really useful when we want to loop over their keys and values. The first one is items. And with items, when I do this and I click run, you'll see that I get the key value pair in a tuple. And this is a very common pattern that you'll see a lot. Another one that we have is values. And guess what that does? That gives us the values of the dictionary. And we saw that user just leaving it blank gives us the keys.
05:34:12.508 - 05:35:16.000, Speaker B: But we have a method that is more descriptive and allows us to show exactly what we want to do, which is keys. And if we run this, you'll see that I'm able to iterate over the keys. And these three methods are very common, and you're going to use them a lot in your programming career. So make sure you take note of them, items, values and keys. It allows us to iterate over dictionaries. But another interesting thing that you can do, and another common pattern when iterating over dictionaries, is what if you want to print, for example, separately the items name and column? So right now we're returning a tuple, and we saw that we can do tuple unpacking. Right? I can say key value equals item and then just print key value.
05:35:16.000 - 05:36:12.360, Speaker B: If I run this, you see that I'm able to print these, but there's actually a shorthand way of being able to do this in here, in the for loop, I can say key value and just completely avoid this entire line. And if I run this, there you go, it still works. And this again is a very common pattern where if you're collecting the items of a dictionary, you can separate them into key and value. Or you might even see shorthand k and v. Again, these can be any variables that you want, you can name them. Whatever helps your code be more readable. By the way, just for fun, let's say in the last line here I want to iterate over the number 50.
05:36:12.360 - 05:36:46.206, Speaker B: What do you think will happen then if I click run? Sorry, name error name key. Oh, I get an error here because I haven't changed these. So let's change these back. That's not the error I was expecting. The error I was expecting was this typeerror int object is not iterable. Now this error should make sense now because I've said it over and over. Why is it not iterable? Well, because it's not an object that can be iterated over.
05:36:46.206 - 05:37:15.664, Speaker B: It's not a collection of items, because we learned that in python. These are iterable. I'll see you in the next video. Bye bye. Welcome back. Let's try a simple exercise. I want you to build a simple counter, and this counter is going to count the items in our list.
05:37:15.664 - 05:38:19.440, Speaker B: What does that mean? Well, let's say I have a list and this is a reserved word. Remember, it's an actual word in python. So let's name it my list as a variable and this list has 1234-5678 910. What I want you to do is using looping to loop over this iterable list and sum up the total of the list. Pause the video if you need to. Otherwise, let's see how we can do that. What I'll do is create a counter variable that will equal to zero to start off with, and then I'll say for item in my list I'm going to counter equals counter plus item.
05:38:19.440 - 05:39:08.500, Speaker B: And then at the end I'm going to print counter. Let's see if this works. I'm going to hit run and I get 55, which, if my quick math is right, should be correct. Now, when doing this exercise, you may have gotten tripped up a bit, so let's think about this. Some of you may have made an error where you did the print here, but if you did the print here, you remember that it's going to get looped over. It's part of this code block because of the indentation, and it's going to print as many times as there are items. So you have to make sure that the indentation is like this so that you get the total.
05:39:08.500 - 05:40:23.378, Speaker B: The other thing that you noticed is that in order for you to keep a counter or a total of all these items, you had to make sure that you had a variable outside of the loop, because the loop runs the code over and over and you needed something on the outside that doesn't change because if you moved the counter to zero here, well, every time the counter will be reset to zero, so that by the time we get to ten, counter would be zero. So you get zero plus ten, which equals ten, and then you'd get, well, ten. So you have to be careful here that the indentation is an indication of us looping. And when you loop something and you want to keep a tally or total of something, that you have these issues of making sure that what you want to loop over is inside of this code code block. But why you don't want to, if you want to have some sort of information that's outside of this loop, that you keep it like this. If you weren't tricked by this question, good job. If you were, don't worry, it's all part of learning.
05:40:23.378 - 05:41:20.534, Speaker B: I'll see you in the next one. Bye bye. When looping in Python, one of the most common tools is this range function that we get out of the box with Python. And you see here that range, well, is a range object, a special type of object in Python that returns an object that produces a sequence of integers from start to stop. Let's explore that a little bit more. If I print here a range and I say range 100 and I click run, I get range of zero to 100. So it looks like a tuple, but it's not.
05:41:20.534 - 05:41:55.876, Speaker B: It's a range object. It's a special type of object. And range, you can give it like this, which gives you a default of zero to whatever you give it, which is 100. Or you can just simply type zero 100. And if I click run, it's the same thing, but where range becomes really useful. And you'll see this in 99% of cases in python is in for loops. You see, besides tuples and lists and sets and dictionaries and strings, you can iterate over a range.
05:41:55.876 - 05:42:42.814, Speaker B: So for example, if I do for I in range, and let's just say item, or in our case, let's just do number in range. And in here I do print number. If I run this, you'll see that I'll get numbers one to 100. And why is this useful? Well, using range, I was able to loop 100 times, as you can see, all the way till 99, because our count starts at zero and we're able to loop as many times as I want. So I can tell the loop. Maybe we want to loop a certain number of times. Maybe you won't want to loop ten times where I can tell the loop how many times to run.
05:42:42.814 - 05:43:25.244, Speaker B: It's extremely useful. Maybe here we're performing some action where it says, I don't know, email, email list. So we want to send ten emails to an email list, for example. Well, again, I can just click run and I sent that email, well, a bunch of times. Ten times. Another neat trick is that, well, you might not even need number, right? We're not really using it in our code. And often what you'll find in Python programs is if a programmer doesn't need this variable, you just do an underscore and this is just a variable.
05:43:25.244 - 05:44:44.144, Speaker B: I mean, you could use it like this and you'll still get these numbers, but it just indicates to other people that, hey, I don't really care what this variable is, I'm just trying to use range so that we can loop overdose over things, let's say ten times. Now, range also comes with a third parameter, and what that is is the step over. So if I do two, and by the way, default is one here, if I do two, it jumps from zero to ten by two, which is very, very handy. So what is range? Well, range creates a special kind of object that we can iterate over. Okay, what if I do minus right here? What if I do minus one? Well, if I run this, hmm, that's not going to work because, well, let me show you why. If I change this to zero and ten and I do minus one, it's going to go in the opposite direction. But if I did just ten and zero, that's not going to work.
05:44:44.144 - 05:45:36.740, Speaker B: If we want to do something in reverse, we just have to make sure that we add that minus one, or if we want to step back twice, then we click run. So you have a lot of options to play with the range. You can do ascending, descending, one final thing, another place that you might see ranges. And like I said, most of the time they're in for loops. But you can also do something interesting, like let's say a range of ten. And then if we wrap this in a list, remember, a listen function allows us to convert something to a list. If I run this, did you see that? Let's simplify this so that this range is going to just be two.
05:45:36.740 - 05:46:12.040, Speaker B: If I click run, you see that? I loop two times. And in here I'm going to print, first of all, I'm going to create a range, an iterable object that has ten items, and then I'm going to convert that into a list. So you can see here, zero to nine into a list. So this is a quick way to create a list that, well, has integers. A neat trick that you'll definitely use along your programmer journey. I'll see you in the next one. Bye bye.
05:46:12.040 - 05:46:53.996, Speaker B: Let me show you another useful function that we'll use, just like range. Mind you, it's not as common as range range. You'll see it a lot in python code, but this other one is still very useful and it's called enumerate. Now what does it do? Let's have a look. I can do a for loop and I'll say four and we'll say character in enumerate and then enumerate. We wrap around something that what we want to enumerate. So let's see what that means.
05:46:53.996 - 05:47:36.990, Speaker B: It returns an enumerate object. So iterable must be another object that supports iteration. So we have to give it something that enumerate can iterate over. So this time around, let's just do a string that says hello. Now enumerate is special because what it's going to give us is it's going to take an iterable object and gives you an index counter and the item of that index. What do I mean by that? Well, you can actually say I character. So we're unpacking this and we're saying, hey, print I and character.
05:47:36.990 - 05:48:37.480, Speaker B: If I click, run, look at that, I get hello iterated over again. If we don't have enumerate, then we would have just gotten hello. But we also, because we use enumerate, we get this I or index of each item and where it is the index. So that if I had a list here, let's say one, two, three. Again, I'm able to use and access the index number of the item as well. What if we had a tuple? Again, we get the index number. So enumerate is very useful if you need the index counter of the item that you're looping through.
05:48:37.480 - 05:49:00.086, Speaker B: So let's do a little exercise. Let's say that we want to create a script that enumerates a list of numbers one through ten. So we'll use range to create that. I'm going to say listen, and then I'm going to say range. I know there's a lot of functions here. Range, that is 100. Actually.
05:49:00.086 - 05:49:33.600, Speaker B: Let's do that. And I want to be told what the index of the number 50 is. So pause the video if you need to do that. Now here, I want it so that, let me make this a little bit bigger. I want it so that we only print the index of, let's say the value 50. I want to know where 50 is in the list. Now, again, this is a simple example, so you can probably already guess what the answer is.
05:49:33.600 - 05:50:39.844, Speaker B: But how would you code this so that only in here we get the index of 50? Or it says the index of 50 is whatever. Pause the video if you want to give it a go. Otherwise, let's try this. I'm going to do a conditional and says if character is equal to 50, then I'm going to print index, or I'm going to do an f string and I'll say that the index of 50 is. And then I'll add the index in here so that if I run, I get index of 50 is 50. And just to confirm if, for example, I just print here, and let's say print I in character, I click run, we see that. Yep, we have the indexes the same as the numbers.
05:50:39.844 - 05:51:12.766, Speaker B: Again, not too difficult of a question, but you see here that we're able to extract this information. Again, not as useful as range, but you will see it occasionally in code. So I wanted to make sure that you're not surprised by it. As you can see, it's not that difficult. Welcome back. Up until now, we've learned that with looping, we can use for. But there's actually another way for us to loop.
05:51:12.766 - 05:51:52.740, Speaker B: And it's called instead of a. For loop a while loop. And while loop is a little different in that we say while a condition is happening, do something. So you can see that there's a bit of a difference here. For example, I can say that while zero is less than 50, do something. Or I can say, for example, I equals to zero. And I'm going to say, while I is less than 50, print I.
05:51:52.740 - 05:52:29.878, Speaker B: Now, if I ran this program, what do you think will happen? Let's find out. If I click run. All right, do you see that? I don't know if you can tell, but I'm scrolling right now through all of this. It's looping, looping, looping, looping, looping. And you see that the programming still running. As a matter of fact, I have to stop it because what it was doing is it was looping and looping and looping. Because if we look at the code of, well, zero is always going to be less than 50.
05:52:29.878 - 05:52:54.382, Speaker B: So what happened was, while this was true, we printed I, and then the python interpreter went back to line two, says, hey, is zero still less than 50? Yep. Okay, next line. Print. Hey, is zero still less than 50? Yep. Okay, next line, print. And it kept going, kept going, kept going. Now, this is what we call an infinite loop.
05:52:54.382 - 05:53:37.892, Speaker B: That is, the program doesn't know when to stop. I mean, we're telling it to just keep going forever, for eternity. And I have some safeguards in place here, but if you did this in code, you'd get this infinite loop until your program crashes. If you actually run this code, well, it's going to keep running until the machine just doesn't have enough power anymore, enough resources to keep doing this over and over. Everything has limits, right? So with a while loop, we have to be really careful. This infinite loop can be very dangerous. So how can we solve this? We have this idea of a break statement.
05:53:37.892 - 05:54:04.722, Speaker B: And break is, well, just another keyword in Python. And as you may have guessed, if I click run, look at that, it only runs once. As soon as Python sees break, it's going to say, all right, break out of the while loop. So it's going to go to line five, and it's going to say, got nothing there. Program's done. I'm going to exit out of the program. Hmm.
05:54:04.722 - 05:54:52.790, Speaker B: But, okay, what if I want this to be looped 50 times? How can we solve that issue? Think about it. Well, we can just simply say I equals I plus one, and then make sure that we change this to I. Now, what's going to happen if I click run, we stop. Well, at 49, we've done it 50 times. We've looped through it 50 times because we kept incrementing I over and over so that I, each time we came back to the loop, was incremented by one. Now, a shorthand for this, we've seen it before, is to do plus equals one. So that if I run.
05:54:52.790 - 05:55:33.734, Speaker B: Look at that same thing. So we're also able to break out of the while loop as long as we're able to turn a condition into false. So you'll see this a lot as well. So to jump out of a while loop, you can either turn the condition false, or you can break out of the while loop. Now, another interesting thing that we can do with a while loop is we can have else blocks. And here we can say print, done with all the work. And if I click run here at the very end, look at that.
05:55:33.734 - 05:56:26.986, Speaker B: Done with all the work. And this should read like English, right? While I is less than 50, keep looping through here. And as soon as we get to the last part where I becomes 50, where 50 is no longer less than 50, Python interpreter is going to say, all right? I don't care about anything under there. Let's go to the next line and I get otherwise. So in this case we don't have anything else happening. We can print done with all the work. But you're probably asking yourself, hold on, can't I just not do this and just make sure my indentation is at the end, click run, and that that works, right? Why would I ever want to write else here? Well, else is a special case here.
05:56:26.986 - 05:57:19.112, Speaker B: There is one thing that is useful. That is if we added a, for example, a break statement here and I click run, you'll see that the else statement does not print. And that is because the else block will only execute if there isn't a break. That is, if the while condition turns to false, then it's going to keep going and do the else. But if there is a break, it's going to break out of this whole thing and go to the 8th line. So a little gotcha here that you won't see else too often next to while. But there is that special case where else is used when you want to make sure that this will be executed.
05:57:19.112 - 05:58:06.310, Speaker B: Only if there isn't a break statement. Only if the loop is finished doing whatever it's doing without the break statement. Let's take a break and explore while loops a little bit more. So when should you use a while loop and when should you use a for loop? And it really depends on the problem you're trying to solve. For example, in a for loop, I could do for item in, let's say a list, one, two, three. And just looking at this code, you know right away that it's going to be looped over three times. Right.
05:58:06.310 - 05:58:55.720, Speaker B: And I could say here, print item. But you can do this in a while loop as well. I can say I equals to zero, and then while I is less than, let's say the length of the list, that is one, two, three. Well, in that case, I want you to print I or the item and then increment I by one. If I run this, I see that, well, technically here we're incrementing the I, which is the value. But let's say we had a list up here. So my list and this list will be one, two, three.
05:58:55.720 - 05:59:46.744, Speaker B: Well, my listen can be iterated with a for loop, or it can be iterated with a while loop. And we simply say my list at index of I. And if I run this, I get the same results. But which one do you think is better? First off, while loops are very flexible, we can do a lot, because we have this conditional statement, we can loop more than three times if we really wanted to. So in that case, while loops are more powerful, but for loops are simpler, right? Like this code reads really nicely and really well. It makes sense. We just want to loop over something that we already know how many times we want to loop over.
05:59:46.744 - 06:00:26.160, Speaker B: Three times. With a while loop, we have to create this variable and we have to make sure we remember to increment the variable so we don't get an infinite loop. So with a while loop, you need to make sure we remember to halt the loop at some point. So my rule is usually this, for simple loops or iterating over iterable objects. For loops are great, but let's say you're not sure how many times you want to loop over something. You're not really sure how long it's going to take for looping. So you want to say while something is true, just keep looping.
06:00:26.160 - 06:01:29.284, Speaker B: For example, let's say we're trying to go through an email list that we've collected on a website, and for each email list we want to send an email. Well, while the list is still there, let's just keep sending emails. There are many, many cases, but one of the most useful ways to use the while loop is like this is to say while true, do something and make sure that at the end we break. Hold on, what's happening here? I'm saying while true, wouldn't that create an infinite loop? I mean, true is always going to be true, and you'd be right if you noticed that. But again, we have a break statement here. So at the end, after we run line three, it's going to break. But now we can do something powerful like input here.
06:01:29.284 - 06:02:00.650, Speaker B: And if you remember, an input is going to ask us for a prompt to enter something so I can say, hey, input, say something. And if I click run, it's going to say, hey, say something. You know what? Let's add semicolon here or a colon here, and let's try that again. And look at that. It's saying say something. I'm on line three right now, so I'm going to say hi. And did you see that? We just broke out of the loop.
06:02:00.650 - 06:02:25.092, Speaker B: It only asked me once, even though this was true, as soon as we got to line four, I was done. But what if I remove this and I click run? If I say something, I say hi. And then it asks me again, hi. Hi. I'm telling hi. And it keeps asking me, asking me, ask me. And we have an infinite loop.
06:02:25.092 - 06:03:20.246, Speaker B: But the interesting thing here is that we can use conditional logic, right? What if we said response here and collect whatever the response is and say, if response is equal to, let's say by then I'm going to break. So that if I run this again, I say hi. Keeps asking me, and you know what? I'm getting annoyed with you, machine. I'm going to say bye. It's going to exit it out for me. How cool is that? So while loops are extremely useful for tasks like this, where looping can happen for a long time, you don't know how many times it's going to happen, but this is something that you're just going to have to get used to with practice eventually. And I promise you this happens wherever.
06:03:20.246 - 06:03:49.046, Speaker B: You'll figure out when to use while when to use for loop. But at the end of the day, use whatever solves your problem. I'll see you in the next one. Bye bye. Welcome back. Now, up until now, we saw the break keyword that we can use to break out of a loop. And you see here that we're able to loop with a for loop, but with a while loop.
06:03:49.046 - 06:04:20.740, Speaker B: As soon as we break, we're done. We've just, well, broken out of the loop. But could we do that in a for loop? Let's find out. Yep, break keyword works in a for loop as well. But there's actually two other things that we can use besides break. One is called continue. And you can see here again, blue highlighting.
06:04:20.740 - 06:04:57.470, Speaker B: If I do continue here and I click run. There you go, we get our looping again. But you're thinking, why? Why do we need this? Like, it seems completely useless, right? Well, a break, when we use the break statement, it breaks out of the current and closing loop. So when we used a break statement, we broke out of this loop, right. This whole while loop, we just exited it. And same with the for loop, we completely exited it. However, with a continue.
06:04:57.470 - 06:05:37.508, Speaker B: What we're saying is, hey, whatever happens when you hit this line, continue on to the top of the enclosing loop. So the current and closing loop, what is it? It's this for loop. So it's going to go back to the for loop. So that if I do something like print here, so that we get it printed twice, or you know what? Let's just move print down here like that. And then same here. We're going to just print at the bottom after continue. If I click run, nothing gets printed.
06:05:37.508 - 06:06:23.210, Speaker B: Because as soon as it sees continue, it's going to say, okay, I'm going to go back to the loop and it's going to keep going, keep going, keep going until, well, the loop ends, so that we never actually hit line ten and line four. So that becomes really useful in conditional logic as well. Finally, the third one is called pass. And pass is, well, not very useful. It essentially does nothing. If I click run here, and again, it shows me here line ten, something's wrong. Well, we have to move print up to the top so that, well, we don't get my list of index of three, which doesn't exist.
06:06:23.210 - 06:07:03.180, Speaker B: So again, going back here, if I click run, pass doesn't do absolutely anything. It just essentially passes to the next line. So why is that ever useful? It's very rare that you'll see pass in your code, but passes a good way to have, let's say, a placeholder while you're coding. For example, you want to loop through the for loop, but we don't know what we want to do yet in the code. Let's say that here, we're still thinking about it. If I do this and I click run, I get an error here because. Whoa, whoa, whoa.
06:07:03.180 - 06:07:46.476, Speaker B: Expected an indented block because now the for loop or the python interpreters looking for the next, like, what am I supposed to do with the loop? I'm trying to loop and there's no code for me. So you can add a pass here to at least fill something for the for loop to say, hey, I'm thinking about it. I'm just going to pass it for now, just so you have something, so you don't bug me, and I'll come back to it. So if I click run, that still works. So pass is one of those placeholders that we can use so that there is a line of code that does absolutely nothing that we can still pass through. Again, a very rare thing to see in production code. But while you're developing, some developers like using pass.
06:07:46.476 - 06:08:12.172, Speaker B: And there you have it. Break, continue, and pass. I'll see you in the next one. Bye bye. All right, your head must be spinning because of all these looping. That's, that's a really bad joke. But I thought it was funny because I've been recording for hours now and I think I'm going a little kooky.
06:08:12.172 - 06:08:46.564, Speaker B: So this is going to be my last video for the day, not for the course, but we're going to do a little fun exercise. Now. I call all exercises fun. Obviously I'm biased, but this one, this one's especially fun. What are we going to do well, we're going to simulate what a computer does when, when we have something like a graphical user interface. That is a computer is able to display, let's say even an image over here, right? I can see the robot over here, I can see the mouse. This is a graphical user interface.
06:08:46.564 - 06:09:43.820, Speaker B: I see pictures, I see images on my screen, these pixels on my screen and I can control them. Well, we're going to create a basic version of this to show you how a computer would work just from the stuff that we've learned up until now, using loops and using conditional logic. So what are we going to do? Well, this is the exercise and you can check out the repl here, or you can recreate this. Or again in this video, you should have resources attached that you can play with it yourself. And what I want you to do is I want you to loop through this list of lists. And every time you encounter a zero, I want you to display on the screen over here, an empty space. Because zero in a computer denotes nothing, right? We want a blank on the screen.
06:09:43.820 - 06:10:28.390, Speaker B: However, when I see a one, I want to simulate a pixel, right? That tiny, tiny dot on our computers that can be full of colors. It could be green, it can be blue, it can be orange. But for our case, I want it to be a star. And using that, I want you to create a program that takes this picture that, let's say is in our database or in our computer's hard drive and displays it on the screen using space or multiply. And all I want you to do is when I click run, I want you to display that image right here. All right, this is a little tough one and I'm kind of letting you figure out on your own. But trust me, you've learned all the tools necessary to do this.
06:10:28.390 - 06:11:06.830, Speaker B: Pause the video, give it a go. Otherwise I'm going to show you how it's done. So the very first thing I like to do is to think about what I'm about to do. I want to make sure that we have a plan in mind. So I'm going to comment first and I'm going to say, well, we definitely want to iterate over picture, right? So we're going to do some sort of iteration here. So that's number one. And then in here I want to say that if it's a zero, then I want to print an empty space.
06:11:06.830 - 06:11:52.390, Speaker B: And if it's a one, I want to print a star. Alright? So that's the plan. Okay, so this shouldn't be too hard. Actually, before you get started, in order for this to work, you need to google a special parameter or special option that you can give the print function. And as a matter of fact, the print function that you need to add, or the option that you need to add is this end option. And if we scroll down it doesn't display it that well. But you can see here, string appended after the last value.
06:11:52.390 - 06:12:30.600, Speaker B: So the default when we print something is a new line, but ideally we might not want a new line. So when that happens, you might have to use this end option. Now I know I left it really vague. I want to, I want you to practice googling this and, and figuring out from your mistake, you're going to have a bug when you create this code, when you try to display this information, but try to solve it using the tools that you have of problem solving. All right, enough talk. Let's get to it. So the first thing I want to do is iterate over the picture.
06:12:30.600 - 06:13:20.560, Speaker B: I'm going to say for image in picture because, well, this is one picture right here. So this is the picture, but it's inside of a list because we can have multiple pictures. And then I'm going to loop once again over this individual list. So once again I need to do a for loop. And this time I'm going to say for pixel, because each one of this is a pixel in the image. So this is a nested for loop. Now I'm going to add a conditional and say if pixel one, then I'm going to print a star.
06:13:20.560 - 06:13:57.640, Speaker B: Otherwise I'm going to print an empty string. Well, maybe not empty, right? Because we do want a space, a blank space in the image. Alright, so let's see if this works. If I click, run. Hmm. That's not really what I wanted. I want a clear image here, but I'm just getting things one in line.
06:13:57.640 - 06:14:48.670, Speaker B: And remember this was the little trick where a print, every time it prints, it creates a new line. The default again, if we close this, you'll see is that end equals to this escape sequence of new line. So we can change that by simply saying star, comma, end. And then I'm going to say for the end, I don't want a new line, I just want, well, a string, but an empty string. And same over here. If I do comma and, and if I click, run. All right, it's getting a little bit better.
06:14:48.670 - 06:15:14.590, Speaker B: But now I have an issue where we don't have any new lines. Everything is on one line. Hmm. That's not good. How can we solve this? Well, ideally at the end of this first loop where we're just going, the image or the line in the image. At the end of this, we create a new line right here. Right.
06:15:14.590 - 06:16:07.382, Speaker B: So again, looking at the indentation, I don't want a new line on every pixel, which we had the first time, but I also want to add a line between the lists of rows. So maybe a better name for this will be a row in picture. And in here, I'm going to add at the end of this for loop. So after we're done looping through the entire row at the bottom here, I'm going to print an empty line. But remember, the default is going to be a new line. So again, an empty string, it's going to default to a new line, and we're still going to have this code. If I run this, I get an error because image is not defined because I've just changed this to a row.
06:16:07.382 - 06:16:46.562, Speaker B: So let's do row here, click, run, and look at that. We have our beautiful Christmas tree. If you don't think this is beautiful, this is the best I could, but this is a Christmas tree. And we finally have a displaying. We've used loops, we've used conditional logic, and we used a little googling to figure out, hey, we need this option now. Our code works, but I want to do something better here. And in the next video, I want to clean up this code a little bit and cover a very important topic when it comes to programming.
06:16:46.562 - 06:17:23.190, Speaker B: I'll see you in that one. Bye bye. It's happening. Our next developer, fundamentals. And that is what is good code? I mean, what is good? That seems so vague, right? Like when somebody says, I'm a good coder, I'm an excellent programmer, he's a senior programmer, he's an expert programmer, he's a tech lead. He's a genius. What, what does that really mean? Well, you can narrow it down to these simple statements.
06:17:23.190 - 06:18:06.092, Speaker B: What is clean good code? I kind of gave it away. The first one is clean. That is, we want to make sure our code is following a style that, let's say, the Python community endorses. Are we following the best practices? And Python has this great feature of auto format, and Python has standard ways of using spaces to make sure that our code is clean. I'm not using unnecessarily ugly spaces like this, or maybe making lists really weird and funky. Maybe no spaces in between here. Maybe I have a lot of random comments over here.
06:18:06.092 - 06:18:49.664, Speaker B: We're keeping our code clean. We make sure that every line that we have is easily readable, but also we don't have any extra stuff that we don't need in there. And this also relates to the idea of readability. Now, readability means the ability to, well, to read your own code. Maybe two years down the road you're going to come back and look at the code. Are you going to be able to understand it? If you work in teams or for companies and other coworkers, come and look at your code. Is it easy to understand? And here, this is obviously personal preference, but most of the time the ideas are, are simple.
06:18:49.664 - 06:19:57.544, Speaker B: For example, I'm using names here that make sense. If I had variable names that don't make sense, it'll be really hard for somebody to read my code. Maybe people will be confused why I have this print statement here. In that case, maybe I should comment in here being like, need a new line after every row, or maybe they'll be confused why we need this as well. So depending on your style, you might want to add comments, make sure that the naming of your variables are good, and maybe making sure that it's not only you that understands the code. The other one is the idea of predictability, and this is my favorite one. That is, sometimes people try to be really clever with their code, trying to have the most compact code or using the newest features or some really obscure tools that, or functions that are not very common just to look, well, frankly, smart.
06:19:57.544 - 06:20:34.596, Speaker B: But you want to have code that makes sense, that does things, just one thing really well. Now, this code is quite small, so it's quite predictable. You know, it just has one pass through and it's easy to predict what's going to happen. We're going to print. But as we get more and more into the course, you'll see that our code is going to get larger and larger. And having predictable, easy to understand code is really important. And then finally, this is an important principle that you hear everywhere is dory, do not repeat yourself.
06:20:34.596 - 06:21:35.240, Speaker B: You don't want to have code that you're constantly repeating yourself over and over again. This is a small example, but it's very easy as a programmer to say, oh, I'm going to copy this, and then I'm going to run this again so that if I click run, look at that, I have two trees. Now, this is amazing, but maybe that's not the best idea. You now have 28 lines of code and people might be confused why we're doing this twice. Maybe instead we want to programmatically have a counter here of maybe saying, running this twice or maybe using something like functions, which we'll learn later to make sure that we can repeat this process over and over and over. Now, keep these in the back of your mind because throughout the course we're going to explore these topics. But let's say I just came onto this code and I wanted to clean it up a bit.
06:21:35.240 - 06:22:26.160, Speaker B: Again, this is just personal preference, but these are some of the things that I would do. One is here, pixels equal to one. Instead. This is kind of confusing. I'm just going to say, if there's a pixel here, and I know that pixels are either zero and one, then print here, because this is a truthy value that we'll just evaluate to true. So that just kind of cleaned out my code a little bit better. Next, another thing that I might do, maybe I want to make this more extensible, which might mean doing something like, let's say fill variable that equals to the star and then maybe empty, which equals to an empty string and change these to fill and empty.
06:22:26.160 - 06:23:06.742, Speaker B: Now, this is extra line of code. But for example, if we're doing this multiple times, instead of perhaps, maybe we're running print over and over and over. Or maybe we have another line of print over here and another line of print over here. And then maybe another line of print over here that is empty. Instead of me having to change five locations here, I can now change just this part. And maybe instead of star, I want to display, I don't know, dollar sign. And if I run this, all right, I get a little different image here.
06:23:06.742 - 06:23:40.744, Speaker B: But again, I was able to just change the variable, and the variable was used to fill out whatever I needed done. Now, these are all things that you do need a bit of experience to get used to. But we'll hopefully explore this throughout the course. And by the end of it, you'll have all these best practices in mind. I'll see you in the next one. Bye bye. Welcome back.
06:23:40.744 - 06:24:22.540, Speaker B: Let's do an exercise where we check for duplicates in a list. So I have some list here, and I want you to be able to check this list and print whatever the duplicate values are. In this case, we see that n has duplicates and also b has duplicates. So I want you to print b and D as a list in here. How would you go about doing that? Pause the video, give it a go. Otherwise, I'm going to keep going with the answer. And by the way, you're not allowed to use sets for this.
06:24:22.540 - 06:24:52.654, Speaker B: So for this exercise, you can use the data structure sets instead. You have to just use conditionals and loops that we've learned to in the past couple of videos. So give it a try. Pause the video and when you're ready, I'm going to go ahead with the answer. First I'm going to create a variable called duplicates. And this is going to be an empty list that we're going to populate with any duplicate values. Next, I'm going to loop over this list.
06:24:52.654 - 06:25:38.848, Speaker B: So I'm going to say for value in somelist and in here. Well, what can we do? This is a tough one, but what I'm going to do is say if somelist count. Remember, count allows us to count how many times an item in a list exists. And I'm going to say value so that some list count and I give it a, it's going to come for me how many times a happens in the list. Very, very useful. Again, if he didn't come up with that, there's many solutions to this problem, so there's no one right answer. I'm just showing you how I would have done it.
06:25:38.848 - 06:26:19.464, Speaker B: Now here I'm going to say if that's greater than one, in that case that means there's a duplicate. So I'm going to add it inside of the duplicates. So let's just go ahead and say dot append because I want to append and in here say value. And at the end of all this, let's just print duplicates. Now let's see if this works. I'm going to click run and all right, I get both b and n, but I, I don't need this duplicates. I just need to know what are the duplicates.
06:26:19.464 - 06:27:11.200, Speaker B: I just need one instance of b and one instance of n. So what we can do here is do another if statement and say if value is not in duplicates. And yes, this is a bit of a trick, you may remember that not is the opposite, right? So we're checking hey, is value in duplicates and not essentially says, hey, if value is not in duplicates, it reads like English. And this is going to evaluate to true and false. And then finally make sure that we get the indentation right. We're going to append the value. So if I click run, I get b and n.
06:27:11.200 - 06:28:04.012, Speaker B: Again, if you didn't get this right away, don't worry, it can get tricky. And this is one of those things that you just need to keep practicing. But you see here that I was able to use loops. I was able to use logical operators like not and conditionals like if statements to solve a problem in just a few lines of code. It's time to talk about functions. This is where things get really interesting, because up until now we've seen functions, right, functions, where things like print, like list, Boolean. We even saw the input function to get the input of whatever the user types.
06:28:04.012 - 06:28:31.718, Speaker B: And those allowed us to perform actions on our data types. But the true power comes when we can start creating our own functions. That's right. We're not limited to whatever Python gives us. We're able to create our own functions and use them in our programs. So let's learn how to do that the way we create a function in python. And functions, by the way, exist in all programming languages.
06:28:31.718 - 06:29:09.120, Speaker B: They're very, very important. If we do def that lets the Python interpreter know that we're about to define a function. Def is short for define, so the interpreter is going to say, all right, they're about to define a function. What's the function going to be? Well, we can create whatever we want. We use the same naming case as we do with variables to define our functions. So let's create a function again. We'll call it say hello, just a variable that I created, but this time it's a function because we use the def keyword.
06:29:09.120 - 06:30:04.960, Speaker B: Now in here in say hello, we also add the brackets to let the interpreter know that this is something that we're going to take action on, or this is going to perform an action on a data type. We use the colon, and then within this block of code we can say print hello. And that is a function. If I click run, nothing happened. Why is that? Well, we've created the say hello function, we've defined it, and now it's living somewhere in memory on our machine. However, in order to use a function, remember, just like we use the print function, we have to call it with the brackets. So after we define a function, we say say hello.
06:30:04.960 - 06:31:18.718, Speaker B: And did you notice how my repl, as soon as I said say actually gives me the say hello command because I've created it and you see this purple box which shows that it's a function? Well, we now have it available for us to use, just like we had the print function available for us to use. So if I do say hello and run it with the brackets and I click run, I get hello. How cool is that? By the way, what happens if I run it without the brackets and I click run, nothing happens. Because remember, in order for us to take an action, we have to let the interpreter know, hey, I want to run say hello now, the reason functions are so powerful is because of the principle that we've talked about, right? The idea of dry, which stands for do not repeat yourself. Functions are really, really useful when you have things that you want to do over and over. For example, the print function. We've used it a lot.
06:31:18.718 - 06:32:15.698, Speaker B: Imagine if we had to code that ourselves every single time and say what print function does. Luckily, Python gives us print because it's such a useful tool. But if in our program we want to say hello multiple times, and you can imagine this actually being a lot more complicated, maybe ten lines of code. Instead of writing those ten lines of code over and over, I can just define it as a function and use it anywhere I want in my program. For example, remember this, where we had a picture and we printed a Christmas tree? Imagine if we wanted to run this multiple times. Well, in order to do that, I would copy and paste this code and then add it again. And if I click run, I now have two Christmas trees.
06:32:15.698 - 06:32:48.198, Speaker B: But that's, look at that, 26 lines of code. I just copy and pasted the same thing over and over. With a function, we can do something like this. I can say define show tree, colon, and we now have a function. But remember the indentation in python, right? Indentation is important. We have the semicolon. We're defining a function, so we have to create that code block inside saying, hey, whatever's indented here, that's part of this function.
06:32:48.198 - 06:33:25.700, Speaker B: So now that we have the show tree, check this out. I can say show tree, run it again. Maybe let's run it three times. If I click run, how cool is that? I'm able to do the same thing over and over by just calling this function. And that's the power of functions. Functions allow us to keep our code dry. We don't repeat ourselves and reuse things that our machines can do over and over.
06:33:25.700 - 06:34:00.442, Speaker B: And the beauty is that this stays in memory for us. Showtree now means something to this program because we've created it. So we have our own custom action that we can take. Now, what happens if I move show tree here to the top? Well, if I run this, I'll get an error name. Error name. Show tree is not defined. Why is that? Well, because our interpreter goes line by line.
06:34:00.442 - 06:34:35.960, Speaker B: It first says, all right, picture equals to this value, and then it goes to line eleven and says, run show tree. But we haven't defined show tree yet. So the python interpreter is going to error out and say, hey, I have no idea what Showtree is. What are you talking about instead with a function, we need to make sure that we define the functions at the beginning. So that Python interpreter says, all right, showtree now means this. I'm not going to run it, I'm not going to use it yet. I'm just going to keep it in memory.
06:34:35.960 - 06:35:15.168, Speaker B: And when I finally come across Showtree, I'll know that it means something. I'm going to grab it from memory using show tree, and then I'm going to run it using the brackets. For example, if I do print showtree without anything, without the brackets, if I click run, you see that I get function show tree at this location. This is just the location in memory. This is the bookshelf where we store that showtree function. Very, very cool. And functions are an important, powerful concept in programming.
06:35:15.168 - 06:36:07.882, Speaker B: And in the next video we're going to extend this and explore this a little bit more. I'll see you in the next one. Bye bye. Let's talk about arguments versus parameters, which is one of our key terms that we use when describing functions. Let's see what they mean. You see, right now our say hello function is pretty generic, very simple, right? We're just, well, printing hello. It's kind of useful, but not really the power of functions beyond just being able to call this multiple times because it only lives in one location in memory, is this ability for us to make it dynamic.
06:36:07.882 - 06:36:46.280, Speaker B: For example, in these brackets, I can give it what we call parameters. So in here we give it parameters inside of the bracket. So for example, I can give it name, which is a variable that I just made up. I can call whatever I want and I can leave it like that, or I can keep giving it parameters, as many as I want. I can keep adding 100 if I wanted to. So in this case, let's just say this is an emoji. So these are two variables or parameters that I've created.
06:36:46.280 - 06:37:39.922, Speaker B: And this say hello function is able to receive these two parameters. What does that mean? It means that we're able to use these variables inside of this function. For example, I can create this as an f string and say hello and add the name, and then finally add the emoji. And because I have these as parameters, I can use them as variables inside of this code block. Now, these parameters allow us to give the function, when we call it what we call arguments. And by the way, the confusion between parameters and arguments, people usually say one when they mean the other. It's a little tricky, so hang in there.
06:37:39.922 - 06:38:23.868, Speaker B: Arguments are used as the actual values we provide to a function so now, in say hello, I can give it a name. In my case, let's just say hi to myself, and then I can give it an emoji. And you see how my editor is giving me the hint that I should give it an emoji because, well, I defined it here, again, something that editors help us do. So let's just give it just a smiley face with the tongue out. Now, these are arguments. These are the actual value we provide to the function. And the name of the variables that we use, that we receive are called parameters.
06:38:23.868 - 06:39:29.290, Speaker B: So, parameters are used when we define the function, and arguments are used when we call the function, define, and call. And by the way, some people also like saying call or invoking the function or invoke the function. So if you ever hear those words, you know what they mean. So if I run this, I get hello, Andre with that smiley face. And this is when functions get really powerful, because we're able to not just make generic functions that always do the same thing, but we can create functions that do things based on what parameters we give it or what arguments we call it with. So that now I can use the say hello function to say hello to my friend Dan and also my friend Emily. And if I click run, we've made our function more extensible.
06:39:29.290 - 06:40:26.766, Speaker B: We can use it in multiple places. And if we're designing a game, well, we've just used this to greet our users. And based on the username, I can use the same function over and over again. We're keeping our code dry and clean by doing something like this. How cool is that? All right, let's take a break, and I'll see you in the next video. In the previous videos, I showed you how to define a function with parameters. Now, the way I've shown you this and these parameters is what we call positional parameters, or we might want to call them positional arguments, and they're called positional arguments because the position matters.
06:40:26.766 - 06:41:27.648, Speaker B: Right. If I change our arguments to, let's say, andre as the second argument, and if I click run, you see that I get hello, smiley face Andre, which maybe is not what we want it to do. Positional arguments are arguments that require to be in the proper position. So if we defined name here first and then emoji second, you have to make sure that the first argument will be the name and the second argument will be the emoji. However, there's something called keyword arguments, and keyword arguments allow us to, well, not worry about the position. What do I mean? Well, I can do something like this. I can say, say hello and in here give it a keyword and a value.
06:41:27.648 - 06:42:27.810, Speaker B: So I'm going to say emoji equals to, let's say this smiley face, and then comma, name equals to bb. Now, if I run this, you'll see that I get hello Bibi. Because I was able to use keyword arguments, I tell it explicitly, hey, I want emoji to be this and name to be this. So positional arguments, these matter, but keyword arguments it doesn't. Now, I argue that this is bad practice because you're making the code more complicated than it needs to be. If the definition of the function is to give name an emoji, you should follow that practice and not confuse other developers. Then just stick to that name and emoji.
06:42:27.810 - 06:43:36.360, Speaker B: So you can still use keyword arguments, but make sure that they are in order, because why wouldn't you just follow what the function tells you? It's the same result, but at least this way you are following well the standard flow. And by the way, these keyword arguments can sometimes be confused with what we call default parameters. I know it can get really, really confusing, but this is something that will come naturally to you after you practice a little bit. So I'm going to just comment this out and show you how default parameters work. Default parameters allow us to give right in here as we're defining the function, what we want as default. In this, in our case, let's say Darth Vader is the default name and the emoji will be this little angry Darth Vader. Well, it doesn't really look like Darth Vader, but this is the emoji that we're going to use.
06:43:36.360 - 06:44:47.902, Speaker B: So what does this do? Well, if I run my program, everything works the same. If I do keyword arguments and run my program, nothing changes. Let's make this a little bit bigger. However, default parameters allow us to do something interesting. For example, if I run another function, say hello, but I forget to give it parameters or arguments. In our case, well, if I run this, I get hello Darth Vader, because with default parameters it says, if you're not able to get name and emoji because you were called without any arguments, well, in that case, make default Darth Vader and make default emoji. This little emoji, if I use, let's say just one argument and I click run, then, well, it will fill that name variable.
06:44:47.902 - 06:45:41.190, Speaker B: But anything that we don't give it, like emoji, will be pretty defined. So this is a great way to make sure that your function runs, even if it's called the wrong way. So keyword arguments increases the readability of your code because you know exactly how we're calling. Say hello. And default parameters allow us to keep our functions a little bit more safe because we make sure that when we use a variable, we're going to have it no matter what, regardless of how it is being called. But positional arguments are also useful because it's nice and clean, right? We're just following what the function tells us to do, and it's easy to read, so there's pros and cons of using each. But I hope this demonstrates to you some of the ways that you can define functions and also call functions.
06:45:41.190 - 06:46:09.532, Speaker B: I'll see you in the next one. Bye bye. Welcome back. In this video I want to talk about an important concept, which is return. It's a keyword in Python that we are going to see a lot when working with functions. So let's have a look. If I, let's say I want to create a function called sum, which by the way already exists.
06:46:09.532 - 06:47:16.390, Speaker B: Python, but we're going to create our own, and I'm going to say num one for number one and num two. Well, our sum function is going to add num one plus num two. Nice and simple function. Now, if I run sum with number four and five, guess what's about to happen. I'm going to hit run and nothing happens, which, I mean, might not be surprising to you because we're not printing anything, right? But what if I run print here? Will this change? Let's see. Hmm, I get none. Is that what you expected? And we've seen none before, right? I mean, remember when we had a list, let's say one, two, three, and then we did something like clear on it in our editor, it gave us this little arrow and said none.
06:47:16.390 - 06:48:11.908, Speaker B: And we talked about this idea of on lists, something like clear changes the actual list and clears everything and empties the list. But it doesn't return a new list, it just modifies the existing list, but instead just returns none to us. Well, functions are just like that. They always have to return something. And when they don't return anything, like there's no return keyword here, it automatically returns none. So if we don't have something like return here, it's always going to return nothing. But if we add return, it's going to say as soon as we get to line two, hey, I want you to exit this function, and when you exit this function.
06:48:11.908 - 06:48:57.990, Speaker B: I want you to return whatever this expression gives us. If I click run, I get nine. If we change this to ten plus five, we get 15. And this is a good general rule with functions, because functions can do two things, right? One, it can return something. So at the end of the function, whatever, after the function gets run, we return something, either none, or some sort of a value, some sort of a data type. Or we can have a function that doesn't return anything but perhaps modifies something. So, for example, I could print hi.
06:48:57.990 - 06:49:47.070, Speaker B: And if I hit run here, I return none, because I don't have that return statement. However, my function does something. It modifies, well, the look of this text, right? It prints high for us. So a function either modifies something in our program or returns something. And this is a topic that is quite advanced that we'll get into later on when we talk about functional programming. But a good rule of thumb with functions is this. A function should do one thing really well, and usually a function should return something.
06:49:47.070 - 06:50:50.760, Speaker B: Now this doesn't mean that any function that maybe does multiple things, or any function that doesn't return something is bad, but it's generally good practice to make your code simple and readable, to have these two rules. For example, here, if I have print and addition well, this function is doing multiple things. It's worrying about printing, and it's also worrying about summing and the definition. This function is called sum. I mean, if I didn't know or I didn't see this, and all I did was run sum, I think having printing high would be surprising because the name doesn't really describe what it does. I mean, I'm expecting this to be summed. Why is my program saying hi? So we want to make sure that our function does one thing and one thing only really well, because as we'll see later on, we can combine and run different functions together.
06:50:50.760 - 06:51:37.400, Speaker B: And then also we want to make sure that we return something, because this way what we can do is we can actually assign this return value to a variable. For example, I can say total equals to sum ten five. And because this function returns something, and when it's done running, is going to have 15 as a value. That's the same thing as what we're doing here. And here's the cool part. Now I can run maybe sum ten plus total. Now let's go through this one by one.
06:51:37.400 - 06:52:04.166, Speaker B: I define my function. The python interpreter is going to say, all right, I know what sum is. Now you've defined it. I'm going to keep it in memory. It's going to keep going, keep going until line seven. And it's going to say, hey, I want a variable total, and I want that total variable to equal sum ten, five. And before we even assign anything to total, Python interpreter is going to say sum what? Sum again.
06:52:04.166 - 06:52:24.150, Speaker B: Oh, I remember here it's in memory. Okay, at sum, I'm going to give it arguments ten and five. So it's going to go run that function. As soon as we end this closing bracket. It's going to go into the sum. It's going to say, hey, num one is going to equal ten. Hey, num two is going to equal five.
06:52:24.150 - 06:53:07.660, Speaker B: Now we go to line two and it's going to say, hey, I want you to add ten plus five because I know what these variables are. And then once you're done with that and this turns into 15, I want you to return. So the python interpreter, finally, when it's done calling sum, is going to say, hey, assign the value of 15 to the variable total, and then it's going to go to the next line, hey, I want to print something. What do you want to print? Well, I want to print this. It's going to say, hey, what sum? I know what sum is, I have it in memory. And then again it's going to say ten, and then the next argument is going to be total. Hey, what's total? Let me go in memory and find out.
06:53:07.660 - 06:53:58.860, Speaker B: Oh, it's 15. So it's like saying 15 and this is the power of functions, right? I'm able to return things and assign them to variables and call them like this. And I can keep running them if I wanted to. If I want to make this even simpler, I can go sum instead of total will be right here. And look at that. Now I have it all in one line, and if I click run again, it still works. Okay, but what if we do something like this? What if I say define sum and then I'll say, define inside of here another function.
06:53:58.860 - 06:54:50.416, Speaker B: And this function takes num one and num two. And in here we finally return num one and num two. Hmm. Let's test this out. What do you think will happen? Well, first let's say total equals sum, ten plus 20, and then I'm going to print total. If I click run, I get none. Now, why is that? And this should be obvious to you, because here I'm saying, hey, I want you to define sum, and what are we going to do with the function sum? Well, inside of here I'm going to define another function, but this return statement is actually not run.
06:54:50.416 - 06:55:35.086, Speaker B: Right, because all we're doing inside of this block, this code block, is this part, we're defining the function, but we're never calling another function. So this returns none and we've lost the ability to, well, to call this function. So how can we solve this? One way is to return. Right? So at the end here we have to make sure that the indentation is right and we're going to return another funk. So let's add return and see what happens here. If I click run. All right, I get this function now.
06:55:35.086 - 06:56:10.888, Speaker B: So total is going to equal this function that we returned and it's in memory. Okay, but I'm not getting the result that I want, right? And why is that? Because, well, we're not calling this function. So there's a few ways that we can do this. We can either give it the parameters or the arguments in here. So let's say 1020. And if I click run, I get 30. Or if we want to keep whatever we give it here, I can just simply say another func.
06:56:10.888 - 06:56:45.508, Speaker B: So if we give it num one and num two, and I clicked run. Hey, look at that, I get 30. Now this video you might have to watch over and over because it does stretch your mind a little bit. And to be honest, this function is not very good because it's, well, it's very confusing. Your function should be easy to understand. So we might want to change this up a bit. Maybe instead over here of having the same parameter names.
06:56:45.508 - 06:57:43.684, Speaker B: Just to clarify it, maybe we can say n one and n two, and then here we do n one plus n two. To clarify that, when we return this other function, I'm using the parameters num one and num two that we called here. Because this definition of a function doesn't really care what these things are. It only cares when another function gets called. Now, if you need to pause the video and look at this and maybe practice this a little bit, that's completely understandable, but I wanted to show you the power of return. You can have nested functions just like you could with conditionals, but you have to be careful that your function either return something, otherwise it's going to return none. And most of the time you're going to want to return something from a function.
06:57:43.684 - 06:58:40.052, Speaker B: So we can do something like this where we assign it to a variable so we can use it later on in our programs. I'll see you in the next one. Bye bye. One last thing, a return keyword automatically exits the function. So that in here if I added another piece of code like print hello, or maybe even have return five in here, you see that it's still valid. But if I run this, I still get 30 because the interpreter never gets to line five and six because as soon as we return something from a function, it exits that function. And the reason that this part doesn't exit the function is because, remember, inside of this function we're defining.
06:58:40.052 - 06:59:48.744, Speaker B: So we're not actually running this part, we're just saying, hey, when we see another function coming up in our code, we know what it is, but we're not going to run it. So it's going to look like this, and as soon as it sees the return statement and when it gets called, it's going to say, all right, I'm exiting out of this function with this value. Just a little heads up. Hey, long time no see. It's been a while, but I'm glad you're back and I'm glad you're still hanging in there. Trust me, things are going to get a lot more fun once we actually start building applications. But we do have to go through the basics, so hang in there.
06:59:48.744 - 07:00:27.728, Speaker B: Now, you may have heard me mention methods and functions before, and I briefly touched on the subject. Right. We have functions like list, print, we have things like max min, what else do we have? We have input. These are all built in functions in python. Python just comes with this and we're able to use them. And we also learned about functions that we can create ourselves, custom functions like, well, some random stuff. And I just created a function that does absolutely nothing.
07:00:27.728 - 07:01:22.640, Speaker B: I can just pass through. And these are all functions because the way we call them is, well, we say sum random stuff and then we call it with the brackets and give it some sort of data or leave it empty. But we also learned about methods. And methods were different because the way we use them was using the dot notation. We set dot something. For example, if we had a string hello, and I do dot, I get a list of all these methods that the string data type can use. These aren't things that we can use like this, because if I do capitalize like this, well, it's going to give me an error.
07:01:22.640 - 07:01:54.510, Speaker B: It's going to say, well, I'm going to get an error with Max because it's expecting an argument here. But let's call comment this out and click run again. I get name capitalize is not defined because it's not a function, it's a method. And a method has to be owned by something. And who owns a method? Well, whatever is to the left of the dot. In our case, the string owns the method. Capitalize.
07:01:54.510 - 07:02:44.622, Speaker B: And that's what methods are. They're built in objects that have methods such as strings, dictionaries, sets, tuples, all the things we've talked about, where as soon as we do dot, we have access to all these methods. They're owned by an object or a data type. And the fun thing is that there's ways to build your own methods, and I'll show you how to do that later on when we start talking about classes. But you can see here that our editors help us determine what type of methods that we can use. And again, these are built into Python. And you can also learn about these methods that we can use by going to the python documentation.
07:02:44.622 - 07:03:24.202, Speaker B: Right, Python three documentation is going to have a ton of things for us. If we go to library reference, for example, we can see here that we can learn about built in types. So let's go to, let's go to the set types. And here you can see that we have set type and it shows us how we can use it. Now, Python doesn't have the easiest documentation to read for beginners, unfortunately. So sometimes it's better to actually just Google instead of going through the actual documentation. But you see here that the set type has clear, has pop, has remove.
07:03:24.202 - 07:04:05.374, Speaker B: If we want to use it, we have update, and these are the methods that we can use. But at the end of the day, both methods and functions allow us to take actions, right? To take actions on our data types, to have our programs do something. And although they have these different names and one has a dot in front of it and another one, well, we can just call it like this. The difference is very minimal. But keep that in mind when you hear people talking about methods and functions, there is that difference. And like I said before, we will get to methods when we talk about classes to show you how we can create our own. I'll see you in the next one.
07:04:05.374 - 07:04:58.110, Speaker B: Bye bye. There is a unique thing that we can do with functions that we haven't seen before, and they're called doc strings. Let me show you what I mean. If I had a function here, and we'll just call it test and test, let's say, receives a parameter that is a. And in here it's going to print a what? A useless, completely useless function. Now, if I run this well, nothing's going to happen because I have to call test and then say, well, exclamation marks. And you see that our function works, but we can actually, with functions in python, use something called doc strings and it looks something like this.
07:04:58.110 - 07:05:37.756, Speaker B: You do single quote, single quote, single quote, so three of them, and then at the bottom, once again, single quote, single quote, single quote. So the beginning of the function like this. And in here I can add some info about the function. For example, this function tests and prints param a. Now here's the interesting part. If I run test here and I do brackets, look at that. My editor tells me info this function tests and prints param a.
07:05:37.756 - 07:06:52.836, Speaker B: This is called a doc string. And what it allows us to do is to actually comment inside of our functions in a way that if another person, let's say, is using the test function, they can actually, let's say in the future when we write large applications, wherever it's not just ten lines of code, or maybe we have different files, instead of just finding what test does as I'm typing it, it's going to tell me, hey, test is going to return or print param a. So I find out information about this and if we ever use something like length for example, and run this, you see that this gives us information about the function by using doc strings, but it comes built in with Python. Another way to view this, mind you, when we talk about developer environments, our editors are going to do this automatically. But there's a few other ways that we can actually read this. For example, I can do the help function, which we haven't seen before, which comes pre built with Python. And we don't want to call the function, I just want to call help on test.
07:06:52.836 - 07:07:37.250, Speaker B: If I run this, look at that, I get test a info. This function tests and prints param a so we can use help to find out what a function does, which is really, really useful. One other way to do this is to use what we call a magic method or a dunder method, which again we'll get into later on in the course I do double underscore, then I do doc and then double underscore like this. If I click run. Well, we have to print something here. So let's print, click, run and look at that. I get the same thing.
07:07:37.250 - 07:08:44.966, Speaker B: So these doc strings are really, really useful to add comments and definitions to your functions, so that when other people on your, let's say, team or coworkers come across your function that you created, they're able to understand what it does right away without searching through your python files or multiple files. Very useful feature. I want to talk quickly about the idea of clean code, something that we've talked about before. And this is a good example to do with something like a function. For example, let's say we had a function that perhaps checks if a number is even or odd. So let's say is odd or, or even as a function that takes in a number. And we're going to here say well how are we going to check? Well we can use the modulo operator.
07:08:44.966 - 07:09:29.460, Speaker B: I can say if number modulo two, which remember, gives us the remainder and if it's an even number, the remainder is always going to be zero. So this is going to tell us if it's an even number. So if it's an even number then I want you to return true. And if it's not an even number. So let's say num two doesn't equal zero. So if this is an odd number there is always a remainder. In that case we return false.
07:09:29.460 - 07:10:07.106, Speaker B: So maybe let's change this function to be more descriptive. Is even. So it's going to return true if it's even false. If it's not even. So in here, if I do is even and give it 50 and I run, oh, I get an error because I have to make sure that I do an lhide if statement here we have to print here. So let's do print and click run, I get true. If I do 51 and click run I get false.
07:10:07.106 - 07:10:54.140, Speaker B: Alright, it seems to be working, but how can we clean up this code? Well, here's the thing. We have some ways that we can actually make this a little bit tighter. For example, if we're only checking for iseven we don't really need to check this again because if number modulo two doesn't equal zero, that is, if a number divided by two doesn't always have a remainder of zero, we always know that that's, well, it's not going to be even. So we don't even need this statement. We can just say else, right? So that if I run this, this still works. Sorry. So we cleaned up our code a little bit.
07:10:54.140 - 07:11:31.360, Speaker B: But here's the thing. Another thing we could do is we know that return exits the function automatically. So we don't even need the else statement. I can just say return here because it's only going to get to line five if the statement is not correct. So if it's not even, well I'm going to skip line four and go to line five so that if I run this, this still works. Alright. But we can make this even cleaner, right? Because right now we're just returning true or false.
07:11:31.360 - 07:12:16.120, Speaker B: And usually if you have something like this, we're returning true false directly. There's usually a better way, and that's using an expression that evaluates to a boolean. What we can actually do is simply say, hey, remove all of this, and I want you to just return like this. And if we run this, this still works. And if I do 50, this still works. Because what we're saying here is I want you to return whatever this value is. And this is an expression, right, that's going to evaluate true false directly so we get the exact same result as we had before.
07:12:16.120 - 07:12:44.682, Speaker B: But look how much cleaner that is. That is just nice, simple code. And as a developer, I can come in here and right away see that. All right, iseven is just performing this operation and returning true or false. So this is a good way to think about clean code. How can you clean up your code? And mind you, there's no perfect solution. You can always clean up code, but thinking like this really allows you to develop the way that advanced programmers think.
07:12:44.682 - 07:13:32.468, Speaker B: I'll see you in the next one. Bye bye. Let's talk about something called arguments and keyword arguments. I mean, we've already seen that before, right? With a function, we actually have the special characters that we can use called ArG's and star. Star, keyword Arg's. How can we use these? Well, let's have a look. Let's try and have a function, let's say define, and we'll call this a super funk for super function that receives some sort of arguments and these arguments that we're going to receive.
07:13:32.468 - 07:14:17.600, Speaker B: And remember, although I'm calling these ArG's, this itself is a parameter, remember? But let's say that we want to just return sum of the arguments. And you might be wondering, whoa, whoa, sum, don't we have to define that function? Well, sum actually exists in python, as you can see over here. So we can just return the sum, the arguments. So let's try this, let's say super func and give it arguments. 12345. If I click run, hmm, I get an error. Super func takes one positional argument, but five were given.
07:14:17.600 - 07:15:06.550, Speaker B: And that makes sense, right? Like, I only have one person parameter here, which is a positional argument that it accepts. And I'm trying to sum this so it only receives one. But I'm giving it to all these things that it doesn't know about. And this is where we can use something like this. By adding a star to here, we're saying, hey, this can accept any number of positional arguments like this, as many as I want. As a matter of fact, let's print this out. If I do print star arg's and we run this function, we see that the print star args gives us 12345.
07:15:06.550 - 07:15:56.720, Speaker B: These are all the parameters or the arguments that we get. And if I actually remove the star here and click run, look at that, I actually get this as a tuple. So Arg's inside of this function is a tuple of arguments that I give it 12345. So sum of the tuple 12345 is going to give us the right answer. It's going to print for us the answer 15. Very very cool. So this way we can extend and use our star arg's to have a function that can accept any number of arguments.
07:15:56.720 - 07:16:59.270, Speaker B: So what is this one now? Well, this one allows us to use keyword arguments. For example, let's say I have the star star keyword arg's like this. And by the way, this can technically be anything. So this is a variable that we're creating. So I can name it who if I wanted to, but the standard is to name it Arg's and keyword Arg's because other developers are using it this way, and it's just the way it's done in the python community. Now, with the keyword Arg's, as you might have guessed, I can add keywords like num one equals five and then num two equals ten. So that if I print the keyword arg's and I click run, I get a dictionary of num one equals to five and num two equals to ten.
07:16:59.270 - 07:18:05.824, Speaker B: So I can actually do something like sum plus sum of items in the keyword arg's and grab the values. Right, we've seen that before. And let's actually grab this and do a for loop and say items in keyword Arg's values. Remember to grab the values over here and in here just add up the totals. So let's say that in here total equals or plus equals items, and we'll add a total in here that is initially zero. So that sum will be sum arg's plus total. If I run this, I get 30, which looks about right.
07:18:05.824 - 07:18:55.270, Speaker B: Now, this does look a little confusing. So let's go over it. We have the star args, which allow us to grab these positional arguments and just sum everything. And we also have keyword Arg's, which allow us to grab any number of keyword arguments and get a dictionary which comes as keyword Arg's and then use them however we want. In our case, we're looping over all the values so items in keyword arg values. And then I'm just going to total all those items have a total and just return the sum. Now this is again extremely useful because our superfund can now take as many arguments, as many positional and keyword arguments as we want.
07:18:55.270 - 07:20:01.450, Speaker B: Now one final thing. There is a rule of the ordering that we can do of our parameters here, right? So the order, the rule is this. First in our parameters we have well our actual params. Then we can do Arg's, then default parameters, then keyword Arg's. Let me show you what I mean. If we want to define this function, we want to make sure that if we give it a parameter of, let's say name that should come before star Arg's and if we have default parameters that should usually come after ArG's but before keyword Arg's. So if I do, let's say I equals hi and make sure we add a comma here we now have following the rule.
07:20:01.450 - 07:20:47.888, Speaker B: And by the way, you would never actually write a function like this because well frankly it looks super confusing. Usually youre only using two of these or maybe just one of these. But this way I can call this function with name Andy. Then my Arg's, then my default parameter, which will be I equals to high which let's say we don't even pass in and then we have this. So if we run here, this still works. We are just not using name and I but you see that I'm following the rule of Params Arg's default parameters and then keyword Arg's. All right, hopefully your head doesn't hurt too much after this one.
07:20:47.888 - 07:21:24.408, Speaker B: Take a break and I'll see you in the next one. Bye bye. All right, it's exercise time. Let's combine everything that we've learned into this challenge. What I want you to do is to create a function called highest even. And this function is going to take a list data type and this function for now we'll just pass. But I want you to fill in this part with whatever you think is going to allow us to achieve this.
07:21:24.408 - 07:22:04.296, Speaker B: If I do print highest even and I give it a list of let's say 12348, I want the highest even to be printed in this list. And actually let's do ten here. So the highest even number in this list is ten. Just for fun let's add eleven as well. So the answer should be printed here as ten. So based on everything you've learned so far, try to fill this part so that you create your own function, highest even. Pause the video here, give it a try.
07:22:04.296 - 07:22:57.780, Speaker B: Otherwise, I'm going to go with the answer. So what I want to do here, let's think about this, is I want to make sure that, first of all, we only consider the numbers that are even in here. So maybe what I'll do is create a new list called evens. And Evens is going to be an empty list for now, but I'm going to populate this with all of the even numbers. So I'm going to remove three and eleven from this. So let's do that. I'm going to say for item in li, if item modulo two equals zero, which means it's going to be even, then I'm going to even append the item.
07:22:57.780 - 07:23:45.430, Speaker B: So I'm going to add it to this new list. And then finally in here, once we have the evens list, I want to find the highest number. Now, you can do this manually and go through it one by one, or python comes with a nice function called Max, and as you can see, we give it an iterable and it'll tell us what the max number is. In our case, we can just give it evens. And remember, we want to return something from this function. That is, what is the highest number? Well, we want to return whatever the max of the evens is. If I run this, I get ten.
07:23:45.430 - 07:24:32.682, Speaker B: Awesome. Looks like it's working. Now, some of you may have gotten tricked and tried to return inside of the for loop, but if we do this, remember that this still works, but we actually return from the function when we hit our first item. If we had another item, let's say two in here, and I click run, we get two. And why is that? Because I'm returning when we loop the first time through our item, which will be two. Is two an even number? Yes, it is. So we're going to append, and then we're finally returning max events, which only contains a the item two.
07:24:32.682 - 07:25:16.036, Speaker B: So you want to make sure here that the indentation really matters. And if you're returning something from inside a loop, you want to make sure that that's your intended behavior. You usually want to loop through something and then return, so make sure you don't prematurely exit the loop. Nice and simple. Remember, your answer may be different than mine. There are many ways to go about this, but hopefully by practicing this, you have a better idea of functions? We now have a great utility function, highest even, that we can use all over our program. Good job getting this far, and I'll see you in the next one.
07:25:16.036 - 07:25:43.204, Speaker B: Bye bye. Welcome back. Let's talk about the walrus operator. And this one is a fun one because, well, it looks like a walrus. It looks like this, see? Looks like, well, Google Walrus if you don't know what that is. It's an animal and it kind of looks like that. Just Google this.
07:25:43.204 - 07:26:25.220, Speaker B: All right, we're getting distracted. So what is this new operator we're going to learn about? The reason I want to teach you this is because I also want to teach you how to learn about new features in Python. For example, this is a new feature. If I go to the Python documentation here, usually what Python does with each new version, they create a what's new in Python document. So you might see what's new in Python 3.9, what's new in Python 3.10 and it gives you a summary of some of the new features added to the language because remember, a language is constantly evolving.
07:26:25.220 - 07:27:18.822, Speaker B: So let's say you want to learn about new 3.8 features because let's say the repl you're on now has 3.8, so it's able to understand the new features like the walrus operator that we weren't able to write before this version. So I would go into the documents and see what's new in Python 3.8. And we see one of the first things is the assignment expression called the Walrus operator. So what I would usually do is just read about the summary of what this does and you can learn about all the new features added in this version. Now let's just focus on the walrus operator because it is useful and also kind of fun to learn about what this new syntax does is it assigns value to variables as part of a larger expression.
07:27:18.822 - 07:28:14.770, Speaker B: So usually you use it in an expression when something is being evaluated, like in an if statement, maybe a while statement. So let's play around with this and see what we can do. So let's say we have a string, and we'll call this string. Hello. Now in here, let's say I want to do a conditional statement. I'm going to say if length of a is greater than ten, I want you to print a string that simply says to long, and we'll say length a elements. Make sure I do that properly.
07:28:14.770 - 07:28:59.954, Speaker B: Now if I click run here, I get too long 14 elements. And why is that, well, because each character here we have 14 elements because it's greater than ten. This conditional block runs and we print out too long. We have a length of 14 elements. So where does the walrus operator come in? Well, we're writing code and we're repeating ourselves here because we're calculating a length twice. We're using this a variable and doing some sort of a calculation multiple times because we want to use it here and here. But with a walrus operator I can do exactly that.
07:28:59.954 - 07:29:52.910, Speaker B: Remember, if I go to the documentation, it says assigns values to variables as part of a larger expression. So what I can do here is I can create another variable like n, and that says, well, walrus operator, so colon and equals little walrus there. And this n is going to equal length a. So I'm just going to wrap this in brackets. So we're evaluating this part of the expression and we're assigning the variable n, whatever the outcome of length a is. So now n is something that has the value of a. So I can replace this with n.
07:29:52.910 - 07:30:24.838, Speaker B: And if I run this now again, same thing. So again, what we can do is we can assign values to variables as part of a larger expression. For example, if I did, n equals length a. Well, this isn't going to run, it's invalid syntax. But because of the walrus operator, we can do this. Now let's do one more just to make sure we have it. So let's say in here we're going to do a while loop.
07:30:24.838 - 07:31:11.994, Speaker B: While loop is going to say n walrus operator, length a. Again, we're going to do the same thing. If it's less than this time, let's do one. And while this is true, I want to print the value of n. And we're going to reassign the value of a, the variable a, to have one less letter. So I can just do that with the minus one short form here. So we're going to remove the last letter every time we loop through here so that the a variable, the hello becomes smaller and smaller and smaller until it equals to one.
07:31:11.994 - 07:31:51.652, Speaker B: And once it equals to one, the while loop is going to stop. So let's just run this. All right, we're getting true, true, true. And we made a bit of an error here because remember the parentheses, we want to evaluate this first. So if I run this again, 14 1312 1110. This is the length of a that's being calculated every time. And at the very end, if I print a and run it, you see that we have h remaining there you have it, the walrus operator.
07:31:51.652 - 07:32:39.160, Speaker B: You might not see it very often. It's essentially a way for us to minimize doing calculations that are similar, let's say, inside of an if statement or a while statement, where we want to do something based on a condition and then calculate that value again. But this also hopefully teaches you how to look at new Python versions and learn about new features. There's only a handful of features that get added to the language. Most of the important ones have already been added. But it's also good to keep an eye out on things as the language evolves, so that whenever you see something like a walrus operator in the code base, you now understand what it does and that it's part of the language. I'll see you in the next one.
07:32:39.160 - 07:33:31.262, Speaker B: Bye bye. In order to finalize our understanding of functions, we have to talk about scope, another one of our key terms. What is scope? Let's have a look. Scope is something present in a lot of programming languages, and Scope simply means what variables do I have access to? That's it. So what do I mean by that? Well, we've seen this before, right? Where I do print, and then let's say name. If I click run, I'll get an error. A name error.
07:33:31.262 - 07:34:23.040, Speaker B: Name name is not defined because, well, it doesn't exist, right? And up to this point we haven't really discussed this, but this is because of scope. What variables do I have access to? The Python interpreter says, hey, what do I have access to? And when we use something that it doesn't understand or it doesn't have access to, it's going to throw a name. Error or variable is not defined. Error. And scope in Python has what we call functional scope or function scope. What does that mean? Well, up until now, when we create a variable like total equals to 100, this is part of what we call global scope. That means anybody on this file has access to this total variable.
07:34:23.040 - 07:35:02.580, Speaker B: I can use this inside of a conditional block. I can use it inside of a function. It has global scope. But when I say Python has function scope, what I mean is that when we create a function and let's say we create total as sum, or let's say sum func, and we create total inside of the function. If I print total here and I click run, I get the same thing. Name total is not defined. This is because of Python's function scope.
07:35:02.580 - 07:35:49.570, Speaker B: Anytime we create a variable, if it's not inside of a function, then it is part of the global scope. We have access to it. But you see, over here, we get that red, underlined, undefined name total. If, let's say, for example, I had a condition. If true, then x equals to ten. If I do this and I say x and I click run, I have ten because, well, although I have indentation, the only time I create a new scope, you can think of this as a new universe that we spawn. Well, we can only do that when we define a function like this.
07:35:49.570 - 07:36:25.900, Speaker B: So think of scope as a new world that we create. In our case, when we create a function, we create a new world that anything that's indented inside of the function is its own world that we don't really have access to. We can only use total if we indent printhead and it's part of this world. That's what scope is. Who has access to who? So let's take a break here, and I want to play a little game in the next video where we try and figure out who has access to who. I'll see you in that one. Bye bye.
07:36:25.900 - 07:37:10.000, Speaker B: All right, let's play a little game. Can you guess what the output of this program is going to be? I have over here a equals one. Then we create a function called confusion where we have a equals to five and we return a. My question is, when we print a and when we print confusion, what do you expect to happen here? Take a second to figure out. Pause if you need to, and let's find out. One and five. Is that what you expected? Let's go line by line.
07:37:10.000 - 07:37:30.218, Speaker B: First, we assign a value of one to variable a. We then create a function called confusion. And Python interpreter is going to say, all right, confusion function. I know what it is. I'm going to put it in memory. When you need to use me, just let me know. And then it's going to go to line eight.
07:37:30.218 - 07:37:54.230, Speaker B: And line eight is going to say, hey, print a. What's a? Well, the only time that I've seen a is right here. A equals one. So go into memory. What's a? A equals one. But then when I run confusion like this, I'm going to say, hey, a is going to equal to five. And now we return a, which is five.
07:37:54.230 - 07:38:57.660, Speaker B: Okay, what if I change the order of this? What if I go like this? What will happen if I click run? Is that what you expected? Once again, we have a equals one. Then we define the function, and then we print confusion. Now, confusion here is going to assign a equal to five and then return a. But why didn't this change? Why is a still equal to one? By the time we get here. And this is because of scope, right. What the Python interpreter does is when it runs the confusion function, it's going to say, hey, a is going to equal to five, but I'm creating a variable here called a in my own universe, I don't know anything about a equals one. Here I have my own universe.
07:38:57.660 - 07:39:33.280, Speaker B: And after we run this function, then, well, we're done, we've returned the function and it's completely gone. But we never left the universe into the global scope. So there's a set of rules that the Python interpreter goes through to check a variable. And the rules are this first is going to check with the local. So start with local and what we call is a local scope. A local scope is a scope that's part of this local function. So a is a local scope.
07:39:33.280 - 07:40:15.580, Speaker B: It's going to check there. Hey, do I know the variable a? Well, yeah, when I return a, I have a variable defined here. So it starts there. But let's say a wasn't there. Let's say I remove a and I click run. Here I get both ones. Because the second rule is if there's nothing in the local variable or local scope, then number two, is there a parent local scope in our case? What's the parent of this function? Well, it's the global scope, but we can also do another function.
07:40:15.580 - 07:40:54.106, Speaker B: Let's say parent, and parent is a parent of the confusion function. And in here, let's say a equals to ten. Now in here we'll return confusion just so we can use it again and actually run it. So let's call parent and click run. Alright, let's go through this so it's not too confusing. We have the parent function that gets called. So when we call that, we assign a equals to ten.
07:40:54.106 - 07:41:39.940, Speaker B: And then we also created a new function, confusion. And then finally we return confusion and actually run it. So we're going to return a and then in here print whatever the value of a is, which is ten. And why is that? Well, because we first start with the local scope. Hey, does confusion know what a is? Nope, I don't have it in my local scope. Okay, does my parent local scope have it? So it's going to go up a level and say, hey, does parent function know what a is? Yep, I have a equals to ten. So it's going to print that the third rule, or the third order is global, and global is what we call the indentation of nothing.
07:41:39.940 - 07:42:31.150, Speaker B: It's this file, right? Whatever the file has that is global. In our case, if a equals to ten doesn't exist here, there's no local, there's no parent local, and I click run it, checks the global scope. And then finally there's one other rule, and this is number four, and it's a tricky one. And this is what we call built in Python or built in python functions. So Python comes with predefined functions such as, well, the sum that we've talked about before, this sum, let's say just give it five is going to check. Or actually, let's not give it anything. Let's just do sum here.
07:42:31.150 - 07:43:24.104, Speaker B: When I run this, I get built in function sum. Now, how did I know what this was, what this variable at the end of the day was? Well, it, because it said, hey, do I have sum inside of this universe? Nope, I don't. Okay, do I have sum in my parent scope? Nope, I don't. Okay, do I have a sum in global? Nope, there's nothing sum in here. And then the final thing it's going to check is, hey, is some, some sort of a built in python function? Yep, Python actually gives us some so you can use it so it doesn't error out. And this is the scope rules that the python interpreter follows. Very, very cool.
07:43:24.104 - 07:44:06.920, Speaker B: There's still a few more things that we need to learn, so I'll see you in the next video. Welcome back. Let's try and answer some questions that you may have. For example, what about parameters? If I do parameter, let's say b here, what is this parameter? When I use b like this. So let's say print b. And in here I'll run confusion with, let's say the number 300. If I run this, this works.
07:44:06.920 - 07:44:55.430, Speaker B: And that is because b, the parameter, is part of the local scope. That is, it's part of this. So parameters are considered local variables. We're able to use it inside of the function, but we can't use it outside of those functions. Technically, when we define the function, we let the interpreter know, hey, b is going to be a local variable. Okay, what about this? What if we have this a? But I want to make sure inside of my function that I'm actually referring to the global a. Is there a way for us to just use this value without creating a new variable? Well, let's use a better example for this.
07:44:55.430 - 07:45:46.410, Speaker B: Let's say I wanted to create a a counter so we'll have total equals to zero. And then in here I'm going to say define count, and this function is going to say total plus equals one. So we're going to add every single time. When we add count, it's going to increment zero by one and then one by one, so on and so forth. So we're going to return total at the end of this. Okay? So if I run here print count, let's see what happens. I'm going to hit run and I get an error local variable total referenced before assignment.
07:45:46.410 - 07:46:32.600, Speaker B: And that is because, well, count doesn't know about total. You're trying to use total, but we haven't assigned anything yet. But we want the total from the outside world to run. Because if I just do total equals zero here and I run count, that's great, I get one. But what if I wanted to run count multiple times? What if I wanted to run count, let's say three times so that the count total will be three. So let's do print on the last one here and I click run. I still get one because every time we run the function we reset the total to zero.
07:46:32.600 - 07:47:16.922, Speaker B: That's not very useful, is it? So one way that we can fix this is using what we call the global keyword in python. And global says use the global total if it exists in here. So that instead of having to create a new variable, I can use the global variable total. Check this out. Well, I get an invalid syntax, and that is because we first have to say global total is going to be used in here, and then we can say total plus equals one if I run this. Hey, look at that. We have a proper counter.
07:47:16.922 - 07:48:21.216, Speaker B: So global is a way for us to access this global variable. However, I argue that this is actually not a good way of doing things because it can get really confusing when you start adding globals and all these different universes are accessing each other's variables. A better way of doing this is something called dependency injection, and this is a simplified version of it. But the idea is that instead of accessing variables outside of the function like this, which can get really, really complicated as files get bigger and bigger, is to do instead this total like this. We create a parameter and then we pass in the that parameter or argument in here, but as you can see, it's still one, because by the time we print the third total, well, this never changes. This is a global zero. So instead we can do something like this.
07:48:21.216 - 07:49:07.256, Speaker B: We can say count total, of which we're going to count again and then count again. If I run this, I get three. And I know what you're thinking, this is completely insane. It looks confusing, look at all these brackets. But let me show you what we've actually done. We're able to detach the dependency or the effect that this count function had on the outside global scope and instead just focus on its health. All we needed to do was say, hey, I want you to give a count with total of zero.
07:49:07.256 - 07:50:02.096, Speaker B: And then after that this is going to evaluate to one. And then we do count. Total of one plus one is going to equal to two, and then count two plus one is going to equal to three. And this way we're able to still do our count without having to use that global keyword, which I would argue is nicer. Mind you, if this is your first time seeing this, it can get a little bit tricky, but at least this way you know that there's different ways of doing things. One other word I want to show you is something called non local, but for that one, let's take a break and I'll see you in the next video. Oh boy, there's some code on the screen and it looks terribly confusing.
07:50:02.096 - 07:50:54.720, Speaker B: This is an example of a really convoluted, complicated function that you would never write, but it'll be good for exercise purposes. And we're talking specifically about this right here called non local. It's actually a new keyword in Python three and as you can see, my repl doesn't even notice it, so it doesn't even highlight it in blue because it is a new feature. But I do want to talk to you about it and let you know what it does. The non local keyword is used to refer to this part, this parent local. It's a way for us to say, hey, I want to use a variable that is not a global variable but is outside of the scope of my function. So based on that definition, try and pause the video and see what this function might do.
07:50:54.720 - 07:51:32.596, Speaker B: I'll run it right now and then go through the code. If I click run, this is what we get. So let's talk about this. We have an outer function and then we call the outer function. So the python interpreter is going to go and say, all right, we have an x variable that is local to the outer function. And then inside of here we're going to define an inner function, another function. And in here, before we even call that, we jump to line nine and say alright, call inner function.
07:51:32.596 - 07:52:06.662, Speaker B: We come back and we say, hey, line five, I want to use non local x. What does that mean? Well, I want to use this x variable because it's non local. That is, I don't want to create a new x variable. I want to jump up the scope to my parent, scope my parent local and grab whatever you find in there. As long as it's not global variable, any parent will do. I want to grab that non local. So now this x is referring to the outer function here.
07:52:06.662 - 07:53:18.220, Speaker B: So when we say x equals non local, we're assigning this new string and replacing this Local so that when we print inner x we get non local. But also when we print the outer x, we've modified this outer scope with the non local keyword, so that becomes non local as well. If I remove this line and let's comment it out and I click run, you see the difference? Now we have the inner non local, but then the outer local hasn't been modified because this is a new variable. Again, I argue that this actually makes your code more complicated than it needs to be. So there are special cases where you might want to use this. But if you can, try to make your code predictable where you can avoid using things like non local and global, mind you, they are there for a reason, because they are useful in some situation. With that said, keep in mind, make your code predictable, make your code clean, and I'll see you in the next video.
07:53:18.220 - 07:54:50.100, Speaker B: I want to address a question that you may or may not have, but it's something that's taken me years to understand, and that is, why not just have everything as global variables? I mean, all this confusion of who has access to who. How easy would it be if everything was just on the main page, all our information, all the data on our global scope, so that everything has access to everything, wouldn't that be easier? And you'd be kind of right? I mean, that would make all this headache go away, right? But you have to remember that machines don't have infinite power, don't have infinite cpu, don't have infinite memory. They all have limited resources. And as programmers, we have to be conscious of what resources we use, because sometimes that can cost us money, sometimes that can crash our computers. And scope is a great demonstration of this. For example, this code right here, when this function is run, we're creating technically just one location in memory for the x variable. So we have that bookshelf in our computer, that is x that's pointing to local when we actually call this function.
07:54:50.100 - 07:55:36.444, Speaker B: And then when we say non local here, well, we're saying, just don't create another bookshelf for us. Just use the one that we already have and assign it non local. If we didn't have this line by the time we get to line seven, we've placed in memory. X equals to local and x equals to non local. So we have two locations now in memory. Now this isn't a big deal because, well, in this day and age we do have a lot of memory, but as programs get larger and larger, this does become a bit of a problem. Okay, but what about a function? I mean, we learned that functions allow us to not repeat ourselves and being able to call out or multiple times.
07:55:36.444 - 07:56:23.150, Speaker B: But another good use of functions is that once we call this function and all of this is done, the computer and the Python interpreter specifically destroys all this memory. That is, once we finish with the outer function, I can't really call print x here. It's going to give me an error. It's going to say, I have no idea what x is. And why is that? It's because after we call this function the Python, what we call the garbage collector, is going to say, hey, it looks like we're done with this function. And I see that this x variable, well, and this x variable we're not going to use because we're done with this function. So I'm going to collect that garbage and then just throw it out.
07:56:23.150 - 07:57:03.780, Speaker B: So I'm going to empty that memory cupboard so that other resources or other programs can use that. And that is a really nice feature where Python just automatically removes these for you so that you don't clog up the computer's memory. And that's why scope is useful. We don't have to think about it in such detail like I've mentioned it, but it's nice to know that it's there so that your programs don't hog up a lot of memory and they can run efficiently. This is a bit of an advanced topic, but I did want to include it in here so that you can think about why programs are designed the way they are. All right, I'm going to stop talking now. I'll see you in the next video.
07:57:03.780 - 07:57:04.740, Speaker B: Bye bye.
07:57:05.680 - 07:57:24.720, Speaker A: Aldo here again. What do you think of the video? Drop us a comment to let us know. Also, if you did enjoy this beginner Python course, make sure to check out Andre's full python bootcamp, where you'll get to go a lot deeper and gain the skills to get hired as a python developer. Check out the link in the description below, or watch that video right there on your screen to see what it's all about.
