00:00:04.360 - 00:00:56.162, Speaker A: Want to level up your design and web development skills with mind blowing 3d experiences right inside of a website? Well congrats. You clicked on the right video. This crash course, led by Jesse Joe, will teach you the fundamentals of three js and set you on your path to creating stunning 3d experiences. Jesse, a seasoned expert in 3d design and web development, has won multiple web design awards and currently leads the 3d team at moment as their technical product lead. And he was kind enough to give away the first 7 hours of his complete three J's bootcamp course so that you guys can get started learning the fundamentals, including core principles and components. But you won't just be learning theory, trust me, you'll be getting your hands dirty. Jesse has included an exciting project where you'll get to build a 3d model of the solar system, allowing you to apply what you've learned and see the results of your work in action.
00:00:56.162 - 00:01:33.000, Speaker A: And for those who really want to master three js, the full course includes a project that will blow your mind. You will be creating your own personal portfolio, but with an awesome twist to make it stand out. Your own personal portfolio will be in the form of an interactive 3d web based game with your own avatar. In all honestly, this project can get you hired by itself. It's so damn cool. Just a heads up in this crash course, we'll be skipping over the lighting and shadow sections of the full boot camp course so the resources may seem a bit out of order. But don't worry because you'll have everything you need in the description down below.
00:01:33.000 - 00:02:06.110, Speaker A: Three JS boot camp course is about 20 hours long and as you can see this crash course includes about a third of that. So once you finish up this video, make sure to check out his complete three JS bootcamp course which you can find in the top right hand corner as well as the description down below. Also, if you enjoyed this video and find it helpful, the least you could do is show Jesse some love by dropping this video, a like and a comment with your questions, thoughts or concerns down below. Alright, thats it from me. Let me hand it over to Jesse so you can start learning three js. Enjoy.
00:02:22.050 - 00:02:34.504, Speaker B: Alright, welcome to the three js course. Im so excited for you to be here. I'm excited to be here to teach this. This is one of my most favorite things to do. It's what I do for work. I love my job. It's what I actually use to actually get my job.
00:02:34.504 - 00:03:11.360, Speaker B: Hilariously, because someone just really loved some of the work I was doing and they're like, oh, this is crazy. Like, come work for us. And this library is going to be able to enable you to do some of the craziest things that at least I never thought were possible to be able to do in the web. So if you don't know what three js is, don't worry. In the following videos, I will go into a more in depth explanation of three js, Webgl and related technologies. But for now, if you don't know what it is, I think the easiest way or the best way to show you is to actually show you some examples of what others have created with three GS. Because this is such a visually demonstrative experience.
00:03:11.360 - 00:03:41.120, Speaker B: It's so, it's some of the stuff that people create are so beautiful and so visual that I think the best way to do it, to show you what three js is capable of, is actually looking at some of these examples. So I think three js had the same idea as us. This is actually their homepage. And the only thing that we see is just a bunch of examples and their menu bar on the left side. So let's go ahead and click through some of the examples. I am reacting to this. This is the first time I'm seeing some of these websites.
00:03:41.120 - 00:04:04.130, Speaker B: Because I think it's going to be cool for us to experience some of this together because of how crazy these websites are. Holy crap. So this is actually not a video, right? This is actually a 3d world. So. Okay, start the journey. Oh, so already you can imagine the crazy stuff that we're able to do within this 3d environment. Let's do it.
00:04:04.130 - 00:04:15.850, Speaker B: I don't know what's happening, but I know that there's a world there that we can probably travel to. We're not going to do that for now. Let's click on something else. I know this one. This one is actually Sujin. I've seen this before. It's web versus metaverse.
00:04:15.850 - 00:04:37.966, Speaker B: So they have like this metaverse type experience, but it's entirely in the web. So you can see like I was just in their homepage and then 2 seconds later I'm in this like 3d game and I'm controlling this with my wasd keys. I think I can pan the camera. Yes I can. By clicking and dragging. Super cool. And I know this is their lobby, but they have another site which is like, they have like a full on metaverse.
00:04:37.966 - 00:04:54.064, Speaker B: And it's crazy. It's all done on the web and it's all powered by three js. Let's take a look at this what is this? Oh, it looks like it's in japanese. Oh. Oh, so that's really pretty. So look at these animations. Look at these effects.
00:04:54.064 - 00:05:09.840, Speaker B: This would be really, really difficult to do in CSS HTML, but it is enabled by our use of three js. Look. Look at the pedals. Okay. Crazy. I have no idea what it said. Next thing, let's see what else looks cool here.
00:05:09.840 - 00:05:28.200, Speaker B: Well, actually, there is another thing that I could show you. Actually, before we do that, let's take a look at this. Oh, start. Oh, that's very cool. Oh, okay. So cool. Okay, so can I actually click on this? Oh, no way.
00:05:28.200 - 00:05:45.016, Speaker B: Yes, I can. Okay, so you can actually. Oh, what happens if I click shut down? So this looks like someone's actual portfolio. So if I go to my showcase. Okay, so you can go to their projects. So cool. And then what happens if I shut down? Okay.
00:05:45.016 - 00:06:02.544, Speaker B: As expected. Okay. But there's one more thing I'd like to show you, because now that we're on the actual topic of portfolios, my portfolio has actually made it onto the site. So this is the portfolio that my current employer actually found before he reached out to me. So he's like, okay, like, I love your portfolio. Come work for me. And I'm like, sure.
00:06:02.544 - 00:06:37.300, Speaker B: And we're on some pretty cool stuff right now, but you can take a look at my portfolio if you care about it at all. And this is what I created within six months of learning three js. I know some of this stuff may look daunting, may look like a really crazy experience that you may not have otherwise seen on the web, but it didn't take me very long to learn this, and I learned it on the side while I was having another full time job. So this is definitely approachable for beginners, and I'll show you some of the stuff we can do. So, yeah, this is my portfolio. So I have some of my older projects. I haven't updated this in a little bit.
00:06:37.300 - 00:07:09.006, Speaker B: There's also an about me, so you can learn a little bit about my experiences, some of my skills. Again, a little bit out of date, but yeah, this is what I was able to create with three j's. I was able to showcase my skills, my hobbies, some of the things I care about. I'm a big basketball fan, big raptors fan. I'm actually out in Toronto. And so, yeah, this is my way of expressing or showcasing my abilities with three js and with coding, but in a way that's very, very visually demonstrative. And I think that's something that three js really unlocks for you.
00:07:09.006 - 00:07:49.220, Speaker B: So if any of this is interesting at all to you, if you're as excited about this as I am, I think you're going to love this course. I'm so excited for us to get started, and I think we're going to have a great time. So let's do it. Let's get started. All right. I hope that last lesson, or the few examples that I provided you gives you a little bit of excitement. I hope it gets you excited to learn about the different ways that we can create these types of experiences on the browser.
00:07:49.220 - 00:09:04.866, Speaker B: At least for me, seeing some of the crazy stuff that other people were able to do with three js got me super excited and I was like, this is exactly what I want to learn and I wanted to dive right into it. So in this lesson, we're going to go one level deeper and just explain what is three js? In its essence, what is the thing that lets us create some of these experiences. So three JS is a high level JavaScript library or API for creating and displaying 3d graphics in web browsers. It makes it easy for us to create 3D graphics and animations, including 3D models, particle systems, lights and cameras, without the need to understand some low level webgl code. Now, before I unpack some of the terminology for you, I think it might also be important for us to take a step back even further and understand a little bit just about 3d graphics, or graphics processing in general. So what is graphics processing? Well, graphics processing is the process of rendering 3d graphics on a computer screen in real time. Now, in real time, the distinction between in real time and something that's not real time is that there's lots of ways for you to provide a 3d graphics experience for someone in something like a video.
00:09:04.866 - 00:10:07.344, Speaker B: So when I go ahead and like play you a video, you're still watching some type of like experience, especially if it's like in a 3d environment where you have the camera, it's some type of animation that's still a 3d graphics experience, except that it's not happening in real time, such that you can't really interact with it like we were with the experiences I showed you in the last lesson. You know how it can click through the screen and the experience would often follow my mouse, or I can click and drag. Well, that happens in real time, and that requires millions of calculations per second. And in the strictest sense, computer graphics is actually very, very difficult. It's hard to conceptualize the millions of calculations that are required to just serve a very basic 3d experience. Your computer needs to know about each vertex of an object, where it is at any point, what color it is, where it sits on your screen, and at the hardware level, none of this can be taken for granted. There is some piece of instruction somewhere on your computer that tells you exactly what to render for each pixel of the screen.
00:10:07.344 - 00:10:54.746, Speaker B: And there's so much of this processing happening that we actually invented a special type of hardware that can run lots and lots and lots of simple calculations in parallel. And that's what we call a GPU. So a GPU stands for a graphics processing unit, and it's a special type of hardware that can run simple calculations in parallel. And by doing so, it's designed to handle the demands of rendering 3d graphics. Now, to render 3d graphics in a browser, we need a way to actually communicate to the GPU, and that's where Webgl comes in. So, Webgl is a JavaScript API for rendering 3D graphics in a browser using the GPU. Now, if you don't know what an API is, it's essentially a way for you to interface or instruct some underlying process.
00:10:54.746 - 00:11:53.012, Speaker B: Many technologies provide you with an API or an interface to allow you to use their service. And the intention behind it is to either abstract away complex stuff, or it's supposed to hide what's actually going on underneath the hood. So, for example, you don't really need to know how a car works to interface with it or to instruct what to do. You don't need to understand, like the very technical intricacies of how fuel injection works for you to drive a cardinal, all you need to do is understand how to use a steering wheel, the pedal, the brake. And in this analogy, that's all part of a car's API. In a similar fashion, I've heard of the analogy that a menu at a restaurant can be an API because it provides you with a succinct set of instructions to communicate and access the functions of a very complicated process under the hood. And that being, if you can imagine, like a crazy kitchen in a restaurant, you don't need to understand how all of that works.
00:11:53.012 - 00:12:51.854, Speaker B: You need to instruct those chefs specifically. All you need to do is you need to tell your waiter or your server specifically which part of the menu that you want to access. So for us, Webgl is kind of that menu that provides us with a language or a communication protocol to talk to the GPU, to instruct it, what to render. Now, with any type of API, to me at least, they all exist on a type of API spectrum. And the way that I like to break this down is that generally there's a little bit of a trade off between specific APIs and abstract APIs. And on the left hand side we have something like a specific API, and generally there's a type of correlation between how specific an API is and how much control the end user has over the product. On the other hand, the more abstract an API is, the more user gives up granular control of something for ease of use.
00:12:51.854 - 00:13:34.304, Speaker B: So of course this isn't a linear spectrum. Some APIs are just better than others. They allow for more control, but are still easier to use. But we generally like to think of APIs potentially as existing as a high level or a low level API, and a low level API being those specific APIs that give you more granular control but at the cost of greater complexity. And then those abstract APIs being a high level API which provides you with a lot more convenience and a lot more tools supported out of the box. But perhaps you may not be able to have more granular control over your output. And generally speaking, we can think of Webgl as an API that leans harder towards the left side.
00:13:34.304 - 00:14:32.116, Speaker B: So it is something that communicates directly with the GPU. However, it is a lot more complex and it's a lot harder for at least beginners to start using web3 D to really communicate with and really program with. Sometimes it's a very difficult language to kind of wrap your head around. Luckily for us, three JS is a higher level or a more abstract API that's built on top of WebGL and implements it under the hood. Three JS abstracts away some of the complex Webgl language into a more easier to understand JavaScript API to allows you to focus on more of the creative parts of the process. So for someone like me, three JS was a great way for me to learn about these web technologies. As I've gotten a better understanding of web3 D and I've taken more projects, I've gotten more into the weeds, then I could start diving deeper into the actual inner workings of three JS and WebGL and try to do more with the underlying technologies.
00:14:32.116 - 00:16:10.818, Speaker B: But that only started because I had a way to kind of like get me into and introduce me to some of these web graphic technologies. And three JS was a way for me to create really, really cool experiences in a really short amount of time without learning very, very complex inner workings of WebGL. Now that's not to say that because we're using a higher level API that we're giving up a lot of control. As I've shown you in some of the examples I've provided you, most of those examples, if not all of those examples, just use three js out of the box, because three JS is still a very, very flexible protocol and a very flexible API out of the box that provides you with a lot of the necessary tools for you to create many, many different diverse types of experiences. For me, three JS was what I use entirely, and I was able to create that fun, vibrant portfolio that I think is different from a lot of websites without having to really get into the weeds of how WebGL works. And for a lot of people, three JS is that kind of more specific API because let's face it, not a lot of people know how to code specifically, not a lot of people know how to code within web3 djdehehehehehehehehehe and so there are actually even more abstract APIs being built in the market that are basically just web builders if you could imagine something like Wix or squarespace, but instead they're using three d and they're actually implementing three GS under the hood. So as a beginner, I think this is a fantastic way to start, and I hope this course will do the same for you as learning three js did for me, which is really unlock my ability to create some really amazing experiences that are readily accessible to anyone with a device and a mobile connection.
00:16:10.818 - 00:17:04.046, Speaker B: So if you're as excited as me, I hope to see you in the next lesson. And let's go ahead and start to learn a little bit about three jsD. All right, before we get started, let's talk about a couple of prerequisites that you will need to know and prerequisite tooling that you'll need to have before we get started with three js. So regarding the knowledge, three js is a JavaScript library. It's built in JavaScript and it's also implemented in JavaScript. So some basic knowledge in JavaScript will take you a long way in this course. So basic concepts I'm talking about, if you understand what variables are, what objects are, what loops are, what functions are, you should probably be good to go.
00:17:04.046 - 00:17:45.772, Speaker B: We're really not going to dive very deep into some really crazy JavaScript concepts. Most of it will be using the three JS API. Now if you are a developer in another language, you may have also recognized some of the concepts that I threw at you. And so for example, my actual first JavaScript project was actually in three jS. Hilariously because there was nothing else that I really wanted to develop. I was like, well, if I'm going to make a website, might as well make it in three daughter I have since learned a lot more about web development and I've become a lot better of a web developer. But hilariously, my first project in JavaScript was a three JS project and prior to my first project in JavaScript I actually worked on some Python projects.
00:17:45.772 - 00:18:17.360, Speaker B: So I was developing in Python. I was doing a little bit more on the data science side, so I really didn't know anything about web development. I was an amateur Python developer and I was able to get by. So I'm sure if you have some basic knowledge of coding concepts you will feel right at home. The next thing is some basic math. So we will be using a little bit of math in three GS, but this is going to be the very basic math and believe me, I don't like math as much as anyone else. So if you aren't comfortable with math, don't worry, you can still be a very good three js developer.
00:18:17.360 - 00:18:59.478, Speaker B: I know lots of people who are, who totally despise math, but it will be something that we will be using and is more good to have. And then finally, let's talk about tools. So regarding tooling, I have two recommended tools. So Chrome is recommended because I recommend you use Chrome if you want to follow along exactly to what I'm doing. But Safari and edge will work just fine as well in terms of functionality. Similarly with visual studio code is my ide of choice. You can use whatever you want, but if you want to follow along step by step, make sure that every click works properly, then visual studio code may be helpful for you.
00:18:59.478 - 00:19:37.790, Speaker B: And then finally, Blender is something that we will be using in one of the lessons to actually create our own 3d scene. Blender is a 3d modeling software that's totally free and it's open source and it's amazing. If you don't care about that, if you don't want to do any 3d modeling, that's totally fine as well. You do not have to follow along. I will provide you with a model at the end of it and we will be working with that model in three js. But I know a lot of developers who don't care anything about 3d modeling and they don't want to even touch the design side, and that's perfectly fine as well. But if that's something you're interested in, I think you're going to have a good time and blender is the tool that we are going to be using.
00:19:37.790 - 00:20:35.454, Speaker B: So that's about it. There's really not a lot of prerequisites, it's just a couple, you know, some basic knowledge of JavaScript, a couple tools and we should be able to get started. All right, so the first thing that we're going to do is actually take a look at the documentation. And we're doing this for a couple of reasons. The first reason is I think this is best practice and I want to get you used to best practice because as we start progressing through the course, this is something that we're going to refer back to very often. It's not the most well documented library, but however, it does have a wealth of information that I think is going to be really important for you to kind of take advantage of as you start becoming a better developer and start learning more and more about the library. And so to access the documentation we're at three js.org
00:20:35.454 - 00:21:16.188, Speaker B: dot. If you need to, I can leave a link under the video as well and click documentation that brings you to, you know, what you would expect documentation to look like. So you know, you can search up. If I cared about different meshes, I can go to take a look at what an instance mesh is or skin mesh, and obviously this has examples of properties, methods, et cetera. We will be using this, but right now we don't need to dive right into it and that's not how we're going to go about this course. We're not going to go page by page and learn everything there is to know about every documented page. What I want to show you is very cool thing about this documentation is three js actually has a bunch of their own examples within their documentation.
00:21:16.188 - 00:21:43.582, Speaker B: So this isn't those examples that you saw where it was like someone else's portfolio or someone else's website that used three js. And it's kind of like a black box. You don't know what's going on. It's obviously very cool. But what we have here is we have a ton of three js native examples where they just show how to make cool stuff. And if you click this button on the bottom right hand corner, you can actually go right into the actual raw code itself. So you can see line by line exactly what they're doing.
00:21:43.582 - 00:22:26.506, Speaker B: And they have some really cool stuff here, for example. So this is a loader, you can go ahead and search anything you want. So for example, if I want to take a look at different geometries I could take a look at how those work under the hood. I can take a look at animations. So one of the first examples is actually something that you'd be able to do with Regis walking characters, if you can imagine in a game. And the coolest thing about this is that it's also a great way to learn how to do stuff that you have no idea how to do. So this is one way that I approach learning three js is if I find an example that I think is super interesting, what I can do is I can actually just go into the code and I start playing with stuff myself and tweaking examples, see what it does and really picking it apart.
00:22:26.506 - 00:23:20.386, Speaker B: So that's exactly what we're going to do in this lesson. I won't show you anything that I won't be showing in subsequent lessons regarding three jS, but I will show you how to actually just access some of these examples and play with some of these yourself if that's something you're interested in. And I think this is also a good practice going forward. If you find anything you like, feel free to dig into the code and really pick it apart and find out what works and what doesn't. So let's go do that. All right, so this is going to be our quick and dirty way of getting our hands dirty with our three JS examples. And I guess in a way kind of, and I'm here quoting here, like hack into some of these examples and really, you know, get to know their inner workings.
00:23:20.386 - 00:23:58.810, Speaker B: And this is one of the ways that I would recommend you to do to learn more about the internals once you start understanding, building upon your knowledge of three js. And you really want to see how some of these examples work, I think there's lots of opportunities here for a lot of learning. So to do this, we're going to actually go ahead and go to the actual three js repository on GitHub. And so I will have this linked under the video. We're going to click this big green button and we're going to just go ahead and actually just download the zip. So I actually have this downloaded and in the future videos we will just download or bring in this repository with NPM. So we won't actually be downloading the zip as we are now.
00:23:58.810 - 00:24:52.646, Speaker B: But for this lesson I went ahead and downloaded it and I went ahead and extracted it. So you can see now lives here in this folder, three JS master. And it has all of the actual files that actually run three JSD within this examples file, you can see that it has a whole bunch of HTML files and these HTML files actually correspond to all of these examples. So if actually double click one, you can see for one it just opened on another browser, but it's also completely black and we don't know what's going on. If I go ahead and actually right click and I click go to inspect, you can click command shift C on Mac or control shift C on Windows and we go to the console tab, you can see that one of the errors that we're getting is it's not allowed to load our local resource. So this is actually a security feature in web browsers that essentially prevents your websites that you're running to pull files from your local hard drive. And that's exactly what this file is trying to do.
00:24:52.646 - 00:25:30.784, Speaker B: It's trying to, it's not trying to pull, you know, from your actual data, but it's trying to pull from its own repository. But Chrome sees that as websites trying to access your own files. So obviously you wouldn't want that to happen and you kind of want this feature. You can imagine what malicious websites may want to do with that type of access. But to work around this, we actually have to just go ahead and actually emulate a web server delivering us files from our own computer. One way to do this is to actually install the live server extension from three js. In future lessons we will just use vite which will provide that local development server for us.
00:25:30.784 - 00:26:08.540, Speaker B: But for today you can go ahead and install that extension if you'd like to follow along. So I went ahead and installed it and the next thing I'm going to do after it's installed is actually pull that entire file directly into versus code. So I'm going to go ahead and pull it into versus code and it's going to populate my left hand side with all of the files within that repository. So if I want to access the examples, I'm going to go under the examples folder and I'm going to click on any of these. Any of these will work. And click on this go live button on the bottom right hand side of my ide. Once I click go live, it'll actually just start a server and boom, you can see that now finally works.
00:26:08.540 - 00:26:21.852, Speaker B: This is pretty cool. I click q or a to move the arm. Okay, so this is a physics demo. Super cool. So this is one of the things that you can go ahead and play with. If this is interesting to you. The one example, the very simple example that we're going to use involves text.
00:26:21.852 - 00:27:02.654, Speaker B: So it is this example, but let's get it to say something that we want it to say. To access the actual code, we're going to go ahead and click on the bottom right hand corner and it's going to bring up the actual code itself. And the only reason I'm doing this is I'm going to actually search up the title or the snippet of code so that I can access that same file on my local machine. So I went ahead and actually just searched it up and I just clicked the file that corresponds to it. You can see that it has the same title. So I know that this is the file that we want. I'm going to click on that go live button again to close the server and I'm going to click once more time to launch the server now with the new HTML file.
00:27:02.654 - 00:27:43.760, Speaker B: Okay, so now you can see boom. Instead of hosting it from three js, I'm actually now just hosting it on my own machine. So on the left hand side is the code that runs the experience and on the right hand side is the experience itself. So I mean, technically we just can go ahead right now and just code in three js. Obviously we haven't been exposed to any of this yet, but I think the simplest thing that we can do right now is just change this message. So let's change this from three j's simple text to this is the best course ever. Hit save command S for Mac, control S for Windows.
00:27:43.760 - 00:28:13.440, Speaker B: And there we are. This is the best course ever. Obviously this is not a groundbreaking change. I'm sure I'm not blowing many minds here, but if this is your first three js application, well, there you go. You can write anything you want, the 3d experience in the browser. And then as we start building on our knowledge of the actual three js API, I'm sure you can imagine we could do much cooler stuff than just change text right now. Just taking a look at this, I know that color accepts a string, so I can just make this red.
00:28:13.440 - 00:28:36.184, Speaker B: And then I know that this accepts a string as well. So let's make this blue. And yeah, feel free to have as much fun as you want. Feel free to go into the many, many, many other examples and see what you can do, see what you can break. You know, feel free to break it. It's not going to hurt anybody and it's all for the purpose of learning. So I hope this has been a fun example for you.
00:28:36.184 - 00:29:19.370, Speaker B: I hope this gives you a good example of some of the things that you could do with the three JS examples. And very quickly let's get started coding our own 3G experiences. Alright, see you in the next lesson. Alright, let's talk three JS fundamentals. I know that we are excited to probably jump right into the code. We're probably excited to get something on the screen. But before we do that, I think it's going to be very important for us to understand, at least at a high level, the structure of a three JS application.
00:29:19.370 - 00:30:29.410, Speaker B: And with that I have that depicted to you visually here, the structure of the JS application. And this is something that we're actually going to come back to fairly frequently because as we go through the course and we start to populate our knowledge of a three JS application, because I want to really start connecting the dots for you and I really want you to start understanding how all these different constituent parts ultimately fit together because it will get a little bit complex. But once we understand the structure of it and once we have the scaffold in place, I think it'll be easier for us to start building on top of that to really develop really fun and amazing three JS applications. Now, for here we have basically a high level depiction of the three JS scene, including the scene, the camera and the render. Obviously, we also have everything that exists within a scene, but I won't spend too much time diving into that because we will inevitably start going much deeper into something like material geometry, which make up different scene objects. But for now, we'll understand them as scene objects which exist within the scene. And then we also will have the camera and the render being discussed in this lesson.
00:30:29.410 - 00:31:27.872, Speaker B: Now, real quick, a 1 second summary of these three different objects is essentially the scene holds everything that can be viewable by the user. The camera is what determines what is ultimately viewed by the user at a given point in time. And the renderer takes information from the scene and the camera puts it all together and then generates an image or a series of images for the user. Now I'm going to take a few minutes to dive into each of these individual parts specifically and go into a little bit deeper about what makes it up and why it's important for our application and different important features of the scene camera and the render. So let's start with the scene because I think it's easiest for us to understand, to draw analogy for the scene. So you can imagine a scene in three GS is similar to a scene in something like a Hollywood movie. So what would belong in a scene in a Hollywood movie or any type of movie set? Well, it's anything that we ultimately want the viewer or the user of the application, in our case, to ultimately see.
00:31:27.872 - 00:32:11.026, Speaker B: So that would include all the objects of the scene, all of the lighting, the foreground, the background, that all exists within our scene. Now, the difference that I want to bring out here, or the important, distinctive feature of a three JS scene, is the way that it's organized within this type of hierarchy. So this hierarchy right now is depicted by these types of parent children relationships within this group and these meshes. So this group is Paris to both of these meshes. And why is this important? Well, this is important because, well, one, it helps us organize our. The objects within our scene. You can imagine a scene can get very complex very quickly if each individual part of a scene exists independently.
00:32:11.026 - 00:33:03.930, Speaker B: So an example here is, let's say we had something called like a car within our scene. Well, that car within our scene could actually be something like the group. And this would be important is if we wanted each wheel on the car. So I'm going to depict that with a w to be a different object within our scene, and then the whole of the car to be a different object of the scene. And what this lets us do is lets us organize all of these different groups within that one pair, object car. So if you want to do anything to the car, we can just apply some type of transformation to the car instead of doing it to each individual object or children of that car. And that brings us to the second important feature of this hierarchy like structure is the fact that given this parent children relationship, children of a parent actually inherits transformational properties from that parent.
00:33:03.930 - 00:33:49.608, Speaker B: And now, why would this be important? So, for example, let's say it's a car, so we expect it to move. Let's say we wanted to move this car x amount of units to the right. Well, because we have independent meshes within our scene, four of them being wheels, one of them being the hull of the car. We could, in theory, move all of these meshes independently. And so all of these would be different instructions for this mesh to be like, okay, move this wheel, move that wheel, move the next wheel, so on, so forth, x amount of units to the right. Or we can just tell three js, you know what, move that car x amount of units to the right. And what that lets us do is it keeps us organized and it keeps us, it lets us abstract the amount of transformations or the amount of instructions we want to do on the scene to the highest relevant level.
00:33:49.608 - 00:34:28.180, Speaker B: In this case, for us being that car. Now, ultimately, everything feeds up to the parent, to the ultimate parent of the scene, which is the scene itself. So the scene itself is actually a 3d object as well. And it is ultimately the thing that holds all the different children within that environment. The next is going to be the actual camera. So the scene holds everything that we want the user to see. And the camera tells us, okay, what is the user ultimately seeing right now? And if you can imagine, just like in a Hollywood movie set, the position of the camera is going to be important as well as something like maybe even the lens of the camera.
00:34:28.180 - 00:35:16.656, Speaker B: So that lens is going to determine the field of view. If you have a wider lens and a wider field of view, you have more things visible within your scene. And obviously you can imagine, given the position analogy, if something's behind the camera, yeah, it can exist within your scene, but the user's not going to be able to see it. Finally, we have our render, which is going to be a little bit more difficult, let's say, to draw an analogy for, because there's really no render within this Hollywood movie analogy, but to render is to generate an image. And so essentially what we're doing within our three js application is we're essentially taking information from the scene, we're taking information from the camera, we're passing it to the render, and we're telling it to render. And so that's what this snippet of code is doing here. So we're calling the render method on the renderer.
00:35:16.656 - 00:35:58.238, Speaker B: We're passing in this information, we're saying, give us an image. And this is essentially what's going to happen if you call the render method once. Well, what that's going to do is going to take that information, it's going to give the user an image. What happens if we want a movie, just like in our movie analogy? Well, same considerations happen if we want our three JS scene to animate or if we want our three JS scene to be interactive. Well, in that case, just like in a movie, where a movie is actually just a sequence of pictures, most Hollywood movies are 24 frames a second. We just have to call that Redder method X amount of seconds to make sure that it looks like a moving picture. For us, it means it's about 60 times per second for most display screens.
00:35:58.238 - 00:37:07.846, Speaker B: You know, obviously modern displays can get up to like 120 frames per second. But this is essentially what I'm depicting here in this render loop. And so this render loop is something that gets called, on average, oftentimes 60 times per second. So 60 times a second, we're telling the renderer, we're feeding information to the renderer about the scene and the camera, we're telling it to generate an image that ultimately gets passed on to the user screen, and then that user gets to experience your three JS application. So in summary, we have the scene which holds all the information about the actual experience and all the objects in a hierarchical like faction, the camera which views the scene and tells the render what specifically we're looking at. And the renderer is responsible for ultimately delivering that experience and giving the user the images that we want them to see. All right, let's get started.
00:37:07.846 - 00:37:38.734, Speaker B: Now, I know we're probably super excited to jump into the code. I am. Believe me, I really want to get started. And we're right there. And there's just a couple more things we need to understand or a couple of things you need to do in order for us to get started. So for our course we're going to be using the build tool called Vite. Now, a build tool in the context of web development is a software tool that automates the process of transforming code, the code that we provide it into production ready HTML, CSS and JavaScript that will be read by the browser.
00:37:38.734 - 00:38:32.140, Speaker B: Now, build tools are used to compile, transpile, bundle code, amongst other things, and Vite is one that's specifically designed for modern JavaScript development, which means that it provides a fast and efficient way to bundle your JavaScript code with modern tools such as something like instant server start, lightning fast, hot module replacement, optimized build, and really things that you necessarily don't actually need to care about. But I promise you, in the absence of it, you will notice. So with Vite being a JavaScript build tool, if we click on get started here, you'll see that the one thing it'll need for us to do is actually install something called Node JS, and it actually has a required version. Now for us I'm going to tell you to install the latest version of node JS. So for me, I'm going to install it for macOS. I'm going to install the one recommended for most users, the most up to date one. If you have Windows, obviously install the Windows one.
00:38:32.140 - 00:39:23.250, Speaker B: But before you do that, it may be important for you to understand what Node JS actually is, because for me, at least when I started getting started in software or web development, something like Node JS, I really got confused with NPM, and you'll hear NPM all over the place. Once we start managing dependencies. But essentially what Node JS is is it is something that lets you run JavaScript outside of a browser environment. So Node JS provides a runtime environment for running JavaScript code on your desktop, let's say, because otherwise you may understand JavaScript as that language that's understood by browsers. So something like Chrome, something like Safari, they understand JavaScript, but your computer doesn't unless you install Node JS. And something like Vite is actually created with Node JS. So we'll have to install Node JS first.
00:39:23.250 - 00:40:24.188, Speaker B: On top of that, Node JS also provides us with NPM, and now NPM actually stands for node package manager, which is what confused me so much because I'm like, is node a package manager, is it not? Node provides us with the runtime environment, but it also provides us with the package manager, which is used by vite to manage its dependencies and packages. And we'll also use NPM to manage the other dependencies. One of them, I'm sure you can imagine being three js, which you can see the first line here, it tells us you could install three js with NPM. So that's why the first thing you'll see here when we go into the actual instructions for installing vite is to run NPM, create vite at latest. And where does that NPM come from? It comes from node, which could be confusing, you know, like where does this command come from? Well, it comes after you installed node, so let's go ahead and get started. I have this empty versus code window right here, which is actually the directory of, which is actually the parent directory that I want my course to live in. So I have something called course teaching.
00:40:24.188 - 00:40:55.958, Speaker B: I'm going to go ahead and drag and drop it into that, and you can see that it leaves this window right here. It's telling me that okay, so whatever I create, whatever project I create is going to live within this course teaching folder. Now I'm going to go ahead and copy this code, I'm going to paste it in, or you could just, you know, type it up to you. I'm going to paste it in, and then it's going to ask me to make a project name. I'm going to call this project name hello Dash World. It's also going to ask me to select a framework. So for us we're doing a vanilla JavaScript.
00:40:55.958 - 00:41:33.166, Speaker B: We are using just JavaScript instead of typescript, and now it's telling us to run CD hello World NPm install, and then NPm run dev in that order, CD stands for change directory. So it's telling us, okay, right now we are in the parent directory of course teaching. Let's go into the hello World project directory. So run that command. Then we're going to run NPm install. So what this is going to do is actually right now we have a package JSON folder which houses all of the dependencies that V requires. And by running Npm install it's actually going to automatically install those dependencies for us.
00:41:33.166 - 00:42:00.732, Speaker B: So let's go ahead and do that. It'll take a couple seconds. Okay, well that was a lot faster than I thought. I. And then now we're going to go ahead and run NPM run dev to actually run our local server which actually vite provides for us. So it actually provides us with a development server. So when we actually start editing our website, when we start editing the index or the counter or the main js or all the projects within our file, we can see what it looks like at real time.
00:42:00.732 - 00:42:44.432, Speaker B: So now it served us this website. It has different buttons that go different places and that's all within this template configuration that has provided us with this index, this counter and this main J's. We will obviously get rid of all of this in the next lesson, but for now if you have this running. Great. Let's get started with some 3d. I'll see you in the next lesson. Alright, so by now we should be looking at this hello vite template that we created in the last lesson.
00:42:44.432 - 00:43:28.756, Speaker B: And by the end of these set of lessons we will create our first hello world in 3D. Now I know this red square, it's actually a cube, but right now we're facing directly in front of it. So it's a square isn't something super fancy. But I promise you, we will very quickly be able to build really cool experiences that you may have never thought that we'd be able to create without this new type of framework. So before we get started, I would also like to point your attention to two things, one of it being the actual three JS fundamentals document. Once again I said that we will be referring back to this as we build out our knowledge of a three JS application and the structure of and where all parts fit together. And as well, I want to point your direction to the docs.
00:43:28.756 - 00:44:30.546, Speaker B: Now this is a habit that I want you to get used to because, you know, as we start getting into the weasel three js, you will find it hard to potentially maybe like the different methods and properties that are unique to this type of 3d program. So we'll get started here with creating a scene. If you'd like to follow some of these instructions yourself, obviously you can follow along with me, but I just want to get you into the habit of eventually, once we start diving deeper into things, really understanding how to pull information out of the dock. So feel free to take a look at creating a scene, see if you understand a little bit about what's going on, or maybe you can try to understand at a high level. Then obviously, you know, come back to the video and we will go ahead and take you step by step to get you to a functioning three js application. All right, so right now what we are looking at is the index, the main, the counterjs, basically the files that were created, this template project that vite has provided for us. So few things that we'll need.
00:44:30.546 - 00:45:03.984, Speaker B: So you'll see that if you actually look into the actual creating a scene, they have their own, you know, HTML that you can throw in. What I advise you to do at this point. And we won't be doing this in future lessons because I will be providing a starter. But for now I will just start, you know, removing some of the things that we don't need. So obviously we have, you know, some boilerplate HTML stuff. We don't need this div, we're also pointing the source to this main J's. Obviously this main J's is responsible for rendering a lot of this stuff on the screen right now.
00:45:03.984 - 00:45:30.496, Speaker B: And I'm going to go ahead and actually delete all this. I'll go ahead and save it. I'll also remove this counter file because we don't actually need that. We're no longer importing it through main js and I'll go ahead and save both files. And that's for me, that's just command s control s on Windows. Now let's go ahead and see what's going on. So we have a blank page and that's expected because obviously we aren't putting any HTML in.
00:45:30.496 - 00:45:57.666, Speaker B: But did we load our main js file? Well, we can go ahead and click console dot log and then do like a hello world. So if it loaded our main js file, we will see our hello world in our console. Now how do we find our console? Well, there's a couple of ways. One of them is actually to right click inspect and then boom, you can see that we have this window pop up. We can click it and go ahead and console. Okay, first of all we see hello world. That's great.
00:45:57.666 - 00:46:34.830, Speaker B: That means we have successfully loaded this as well, though I want to show you there's also shortcuts. We can use shift command c on a Mac or shift control c on Windows to pull up our console. And that takes us to the same place. If you don't like where this console is or where it takes up in terms of the screen real estate, and click these three dots on the right and you can choose on the right hand side. You can also choose on the left hand side or you can have it as a separate window. I'm going to keep it on the bottom because that just fits the screen real estate better. And now we can get started within actual programming in JavaScript.
00:46:34.830 - 00:47:06.914, Speaker B: Now the one thing that you may have noticed is we actually have it installed three. We don't know where it is, no idea what to do. Like how do we have access to this library? Well, if you go into the installation page you can see that it tells us to run NPM install three. So let's go ahead and do that. I'm going to click control C to stop this terminal, control C on Mac and on Windows and I'm actually going to paste this in. So let's go ahead and install that dependency. And then we are going to follow the introduction.
00:47:06.914 - 00:47:48.362, Speaker B: It's going to tell us to actually import the entire three G's core library. So let's go ahead and basically copy this. We're going to go ahead and paste it in, which means that we're going to import the entire core library, which is what is denoted by the star as three from three. And three is essentially the name of the folder where it lives within our actual node module. We're basically saying, okay, import the entire library as denoted by the star as three, which is the name of where we're going to store that whole library. It's the variable that we are assigning this entire library to from this location. That location is actually pointing to this section of our node modules.
00:47:48.362 - 00:48:33.564, Speaker B: So how do we know that it's installed? Well, instead of, you know, creating an entire application to know whether it works or not, let's go ahead and actually just, well, first we have to get our development server back up and running again by running NPM, run dev, follow that link. Obviously I was already on that link here so it automatically refreshed. And then we are going to say console dot log three. So once again I said the entire library is stored within this variable. So if I log it out, we should see that we have access to every class that three j's provides us perfect. Okay, that's exactly what we want. And I think we have enough to get started with the first big part of our application, that being the scene.
00:48:33.564 - 00:49:17.472, Speaker B: So I'll see you in the next lesson. Let's start with our scene and let's add that to our three js application. All right, so let's go ahead and add the scene to our three js application. Now, if you remember from the three js fundamentals lesson, we talked about the scene as basically like a container for other objects. So obviously, as part of this lesson, we won't just be adding the scene, but also an item within the scene that the user is going to be able to see. Because you can't just see the scene. It's where things belong.
00:49:17.472 - 00:49:50.314, Speaker B: But we actually need to populate it with those respective things. So let's go ahead and add the scene to our three JS application. We do that by doing const scene equals new three dot scene. And you will see this pattern arise a lot of the times. Anytime we want a new three JS objects, we call new three, which holds all of our three J's classes. And then we're going to call the actual class in an uppercase followed by the brackets. Next we're going to actually add a mesh to the scene.
00:49:50.314 - 00:50:42.442, Speaker B: So if we actually look at the diagram that we have here, so we have meshes that are composed of geometries and materials. And those are the two arguments that we're going to pass to a mesh and we're going to add that mesh to the scene. You will notice here that I'm going to go fairly quickly or I'm not going to go too, in detail about the different types of arguments, the different types of materials and geometries, because there will be subsequent lessons that will explain the specifics of something like materials and geometries. For now, let's just get something on the screen so that we can start playing with our three JS application. So I'm going to specify the thing that we want to add to the scene by doing const cubemesh equals new three dot mesh. And that's going to take two arguments. So you can see our mesh takes two arguments.
00:50:42.442 - 00:51:43.766, Speaker B: It takes a geometry and it takes a material. So let's go ahead and actually pass that to the actual cube mesh. So we're going to call cube geometry cube material lowercase. I'm going to do lowercase. And then because we haven't specified that, we're going to do const cube geometry equals new three dot box geometry, which is actually what the cube looks like if we just pass it lengthwidth and height being the same length, and then go ahead and actually pass a cube material, which is going to be a mesh, basic material, which is a type of material within three g's. That obviously I will explain a little bit into the material lesson, but the arguments of which we're going to pass a color, I'm just going to say red. It can handle strings and that is basically just going to provide us with a material that does not respond to light.
00:51:43.766 - 00:52:04.870, Speaker B: So it'll just look red. We don't have to add anything else to it. So now that we have these two arguments, we can go ahead and actually log them out. So let's see console, dot, log, qmesh. And then let's go ahead and log out our scene as well. Log scene. I'm going to save and then I'm going to go into our application.
00:52:04.870 - 00:52:20.646, Speaker B: I'm going to go into our console so you can see. Okay, so we've created a mesh. We've created it with the box geometry. Okay, so that was done properly and we've also created it with the mesh basic material. Perfect. All right, and let's take a look at the color. R being one, the others being zero, zero.
00:52:20.646 - 00:52:58.042, Speaker B: So red is one, green is zero, blue is zero. So it's going to give us a red box that's perfect. And then let's go ahead and look at our scene. So our scene actually still doesn't have any children inside of it. Why may that be? Well, as I've alluded to in our actual three js fundamentals, there's this parent children relationship within our scene itself. But we have to be very explicit regarding what this relationship is. Now, for something like a scene, it may be intuitive to think that, okay, well, it's a scene, obviously it's a everything else as a children of the scene, but in three cs you can actually have multiple scenes.
00:52:58.042 - 00:53:34.594, Speaker B: I've taken advantage of that paradigm. But like traditionally, it's not unexpected for you to just have one scene. So maybe unintuitive to kind of have to explicitly call that out. But at the same time, perhaps this mesh we don't want to add directly to the scene because anything that you add this mesh to becomes apparent. For example, maybe I want to add this mesh to the actual group itself and then add that group to the scene in a later step. So for us to tell the three J's application that we want this mesh to be within the scene, directly. We actually have to be very explicit by using the scene dot add method.
00:53:34.594 - 00:53:57.662, Speaker B: And this add method belongs to any type of 3d objects. So we can add a mesh to another mesh if you want. You can also add a mesh to a group, which is another 3d object. But for now, we're going to add the cube mesh to the scene and we're going to go ahead and console log the scene again. And then once we take a look within the scene again, we're going to dive into the children. Okay? And there it is. There's our mesh.
00:53:57.662 - 00:54:49.778, Speaker B: It is now in the scene. Now, for us to actually look at the, at the scene, we will need to have our camera. So obviously we have this camera here. If for some reason is missing this little diagram, which I'm going to crudely draw wherever I. You can see that the camera is responsible for looking at the scene. So let's go ahead and add that in the next lesson. So now that we've created the things that we want the user to see, we want to add the camera to the scene to specify what the user sees or from what perspective the user sees those objects.
00:54:49.778 - 00:55:35.718, Speaker B: So we do this by going ahead and initializing the camera, doing const camera equals new three perspective camera. So a perspective camera is a type of camera, but it's also the type of camera that we will most traditionally use. There will be a full lesson on cameras, I think, immediately following this. But for now we're going to provide it with a few numbers, one of them being the field of view of this perspective camera, the next one being an aspect ratio of the actual scene itself. Now, an aspect ratio is just one number divided by another. So we can actually provide it with any number that we want. But if in order for us to actually specify the proper aspect ratio of the scene, we have something within our browser called the window object.
00:55:35.718 - 00:56:09.322, Speaker B: And the window object has two properties within it. Let's go ahead and check it out. Console, dot log window. So we can see the window and we can see the different properties within it, one of them being inner with and one of them being inner height. And so those two properties couldn't tell us definitively within an application. Okay, so what is the actual aspect ratio? Because obviously this aspect ratio being width divided by height would be something like 16 by nine, perhaps. This may be three by two, this may be one by one.
00:56:09.322 - 00:56:49.380, Speaker B: And obviously, anytime the user starts adjusting their windows starts adjusting the application, that aspect ratio will change. And we will need to make sure that we're telling three js what that actual aspect ratio is. So to do that, I'll show you that we can go ahead and actually access the inner width and we can also access the inner height. And let's log both of those out and you can see. Okay, so we have the inner width in pixels, which is obviously a lot greater than our actual height. And we pass that as a ratio. And to pass it as a ratio, we go ahead and copy this, paste it in divided by inner height.
00:56:49.380 - 00:57:38.140, Speaker B: So I'll actually just go ahead and split these arguments out so it's more viewable. And you can see the next two arguments that we passed to it are actually the camera near property, which is anything closer than this distance, you will not be able to see. So I'll do something like 0.1 and anything further than this far property, you won't be able to see either. So I'm going to put 30 and I'm going to go ahead and save it. Now, we haven't done anything with this camera yet, but first I want to basically show you what's going on here before we actually run into this mistake. So what we've actually done right now is we've actually initialized the camera and a mesh in the exact same position because we actually haven't changed any of these positional properties of the actual mesh we created and the camera.
00:57:38.140 - 00:58:13.812, Speaker B: So they're all at zero, zero. So let's assume this part of my screen here is zero, zero. The camera right now is actually pretty much inside of the mesh because it exists within the same area. Now, if you can imagine if you had a camera inside of something, it would be very difficult for you to really see what that something is. Now, what's the solution? Well, maybe it's worth it to move the camera back. So that's exactly what we're going to do by actually manipulating a property of the camera called the position. Now, this position property exists on any 3d object, which alludes to the fact that this camera is in and of itself a 3d object.
00:58:13.812 - 00:58:46.008, Speaker B: So we can go ahead and do camera dot position dot. Now, there's x, y and z properties. I'm going to tell you that we want to move the z property back, but obviously that's not intuitive at first. So we will, in the following lesson, have an explanation about different accesses and what those mean. But for now, we're going to access the z property and we're going to set it to five, which is actually going to move that camera back. I'm going to save. Obviously, we have nothing yet because we haven't called the render method on the rendered and we don't even have a renderer.
00:58:46.008 - 00:59:29.370, Speaker B: But as well, I'm going to do one more thing and I'm actually going to do scene add camera. And the reason for this is just to demonstrate the fact that just because it's a camera doesn't mean it's not still a three GS object, still a 3d object. And for that reason, we can add it to the scene if we want. We can also keep it out of the scene so it works both. You don't actually have to add it to a scene, just like for example, for a Cubash, you have to add it to the scene. A camera, you don't, but it could be important to add a camera to different 3d objects. So for example, if we wanted to add it to a car, then the camera would be able to have that car's point of view and that would obviously be a different interesting experience for the user.
00:59:29.370 - 01:00:18.740, Speaker B: So I'm going to show you that we can, but I'm also going to at the same time leave it out. And then in the next lesson we'll go ahead and initialize the render and so we'll finally have something on our screen. All right, I know that we are a few, maybe a little bit more than a few lessons in and there's still nothing on the screen yet, but that's going to change by the end of this lesson. So let's do it. Let's drop in. All right, so if we take a look at our actual three JS fundamentals document, you can see that the last thing that we need is this render. And this renderer is going to take information from the scene and the camera.
01:00:18.740 - 01:01:05.414, Speaker B: We're going to call the render method with the information from the scene and camera on the renderer, and it's going to provide us an image. Now up until now, I don't think it's been clear. At least it wasn't clear to me where the actual image is going to exist. If you have a fundamental understanding of HTML, or at least a basic understanding, you'll know that this right here, this HTML, this constitutes essentially everything that the user is going to be ultimately seeing on their webpage. And right now, there's no reference to any type of image or any type of part of this website that's going to display this image that's generated by the renderer. And that's where the actual canvas, HTML five element comes in. And so this canvas element acts as a drawing surface for rendering two d and three d graphics.
01:01:05.414 - 01:01:55.534, Speaker B: And I think the name canvas is a very well suited name because if you can imagine a canvas and painting, it's the surface that we are going to be drawing on. To add this canvas to our actual website, we go ahead and write canvas, we pass it a class and this class can be anything that we want. But I'm going to call this three GS. It was going to be easy for us to go ahead and find within our actual application and then I'm going to close it out and it's going to look like this. So I'm going to go ahead and save and then within our actual application itself I'm going to go ahead and actually retrieve that from the HTML document. And I do that by doing const canvas equals document query selector. And I'm going to pass it in a string, that string being canvas dot three js.
01:01:55.534 - 01:02:34.482, Speaker B: So this three js is referencing this class that we private it. The canvas is referencing the actual element itself. So let's go ahead and log that out to see that we actually have retrieved the canvas properly and it looks, we have perfect. And then let's go ahead and actually now pass it into the render. So the render is new three webgl render. And then it takes the canvas as an argument within an object. So within this we actually pass in an object and that object is canvas is canvas.
01:02:34.482 - 01:03:11.606, Speaker B: That's essentially what we're doing. But if you want the quick and easy way, JavaScript allows you to basically remove this redundancy and basically pass it like this. But essentially we are actually just passing it as an object with the canvas element being the canvas. All right, so the next thing we want to do is render the scene. So let's go ahead and render, or dot render, and then we pass it the scene, we passed the camera and we save and see what happens. Voila. I know it's not what I promised, so let's figure out what's going on.
01:03:11.606 - 01:03:36.058, Speaker B: So right now the render actually doesn't really know how big you want to draw it. And the way that we can specify is this. We can actually call this method set size. So set size takes two arguments. It can take width and the height. So we can specify that to whatever we want. 500, 200, we can make it really wonky.
01:03:36.058 - 01:04:14.308, Speaker B: But as you may remember from our lesson about the camera, we actually have access to exactly how wide this window is and exactly how high this window is or how tall it is. And if we actually set the size to the window inner width and the window inner height, we can go ahead and make sure that it fills the screen. So there we are. We now have a full screen experience, you know, obviously minus these margins, which we will fix with CSS styling in the following templates. But yeah, now we actually have something on our screen. It is not yet interactive. That is coming in the future episodes.
01:04:14.308 - 01:04:38.502, Speaker B: I hope you're excited. I know this is not something super fancy, but I promise you we're going to create some really cool things really fast. I will be walking you through step by step, so I promise you will make it very accessible. But the range or the extent of things we're going to be able to do is going to grow very, very quickly. And I'm very excited for you to go through this process. So I hope you enjoyed this. I feel like this is going to be a great course.
01:04:38.502 - 01:05:24.780, Speaker B: Let's do it. Alright, so in the last lesson we created a three js experience from scratch. And what that means is we went ahead and installed node JS, installed vite, installed three js. But in this lesson and in subsequent lessons, we're actually going to start with a starter pack. And we're doing this for two reasons. For one, it makes sure that we start from the exact same starting point, so we can reconcile any type of small differences in dependencies between now and the time you're watching this course. Obviously, if there are any large differences, I will go ahead and make sure that those are addressed.
01:05:24.780 - 01:06:04.416, Speaker B: And then secondly, it makes sure that we don't have to create a lot of boilerplate before we even get started. The last lesson we did a lot just to get a square on the screen. We want to make sure that we aren't doing a whole bunch of redundant stuff before we start every single lesson. And so to actually get started, you can download the actual starter pack and it should be linked under the video, extract it as I've done here. And then I'm going to go ahead and actually let me see, make sure that we can see it. I'm actually going to pull it into our versus code. As soon as you pull it into the versus code, you will notice a couple things, one of them being we have now a readme file with instructions on how to actually use this starter pack as well.
01:06:04.416 - 01:06:51.972, Speaker B: We have a vite config file which is actually going to tell us where we are serving up our experience. We are now serving up our index HTML file within a source file and then the public directory. We're telling it essentially we are going to be hosting our static assets within the static file. And so I have a texture folder within the static folder and that's exactly where we're going to be keeping any textures or additional assets as we progress throughout the course. So once we go into the source file, you can see our index HTML file looks very similar to the last course. I haven't changed anything about the JavaScript, but I did change something about the CSS, which I'll go ahead and show you as we get this opened. For us to actually start this experience we take a look at the read b and then it tells us one to have node JS installed.
01:06:51.972 - 01:07:34.608, Speaker B: So you should have that installed from the last lesson and then to run NPM install and NPm run dev. So you'll notice that this is the exact same command for the last lesson. Essentially what we're doing by running NPM install is installing vite and three js, you may recall. Okay, well didn't we install that in the last lesson? Well, we did, but we only installed it for that specific project. In every subsequent project, what we're going to do by running NPM install is it's actually going to take a look at our package JSON file. It's going to look at all the dependencies that I've already listed out and it's going to go ahead and install them for us. As soon as you run that command, what this means is that I won't have to, you know, install three js, install vite in this massive bundle and then send it over to you.
01:07:34.608 - 01:08:06.200, Speaker B: And then you have to download this massive file. What this means is essentially what you're going to do is you're going to have to run NPM install and it's going to download all those dependencies for you. So you can see now we have a node modules file and then it includes vite and includes three. So the next thing that's going to tell you to do is actually run NPM run dev. So again, same as last lesson. So I'm going to go ahead and run that and it's going to go ahead and actually serve up the experience at this URL. What I did there was actually click command click.
01:08:06.200 - 01:08:44.092, Speaker B: You can also just copy and paste this into your browser. So let's take a look at the actual experience. You can see that this is where we left off in the actual last lesson, but a couple of things are different. For one, we no longer have that margin, and so let's take a look at what we actually changed. These changes actually exist within the style CSS file so our index HTML file is actually pointing to a style sheet that exists within our style CSS file. And within our style CSS file you can see that there's only two lines of code, there's only two properties that we're changing within this body element. And that body element is what wraps our actual canvas itself.
01:08:44.092 - 01:09:09.342, Speaker B: So let's take a look at the body element. Let's take a look what happens when we comment these out. So when I comment it down, okay, you can see that white margins are back as well. There's this little scroll bar. If we go ahead and actually just leave the margin in, you can see that what it does is it actually just goes ahead and deletes the margin for us. But we still have margin on the right hand side and on the bottom. And the reason for this is this is actually where the scroll bar is.
01:09:09.342 - 01:09:47.523, Speaker B: So you can see for one, it looks ugly. And second of all, we probably don't want them to scroll in this experience, or at least when we want them to scroll, we don't want them to scroll on the screen. We want them to scroll within our three GS experience and we want our three js experience to handle what we want it to do when a user scrolls. So to prevent them from scrolling, we provide it with the overflow hidden property. And you can see now we're back to our full screen experience. So taking a look into our script JS file, you can see that this is exactly where we left off in the last class and in the subsequent lessons I'm going to teach you. The next thing we're going to learn about is the actual camera and the render loop.
01:09:47.523 - 01:10:54.112, Speaker B: So lets get started. So in the previous lessons we went ahead and put together a three jet scene, really quick and dirty, and we just added a perspective camera to the scene. In this lesson we'll talk a little bit more about three JS cameras, the different types of cameras available, how it relates to the render loop, and then really dive deeper into what the inner workings of something like a perspective camera. So anytime I'm introduced to a new topic, I want to reinforce the principle of basically going into our actual documentation and going ahead and giving it a search within the three GS docs to find, you know, what we can pull out of the documentation. So I went ahead and just searched up camera. You can see that one of the things that come up is the actual perspective camera that we're using. And this is just one of many cameras that three js provides us, but it is also the traditional camera that most games and virtual experiences use.
01:10:54.112 - 01:11:27.572, Speaker B: So let's go ahead and see the actual properties of a perspective camera. So a perspective camera has an fov. It has an aspect ratio, which I talked about in the previous lesson. It has a near and a far property. Now, the one thing that I didn't really specify is the actual, what constitutes a field of view. Now, the field of view is the extent of a world or an experience that is seen at every given moment. So in photography or in videography, the field of view is essentially the angle that is captured by the lens.
01:11:27.572 - 01:12:06.684, Speaker B: I think the best way to basically understand this is with visual representation. So I will have this linked in the description, but we can see here that the field of view is denoted by everything between these two purple lines. That is the field of view. And essentially, while in photography, it is basically expressing the amount that is captured by the camera, which is essentially what we're talking about right here. So right now we're saying how much is actually captured by the camera. You may also hear in gaming, you could also adjust your field of view in some game settings. And essentially it's referring to the extent of the environment that is visible to the player on the screen.
01:12:06.684 - 01:12:41.414, Speaker B: So that's exact same thing that we're talking about here. The actual field of view angle is this angle right here. So you can see this angle is actually going to determine the actual field of view, of the actual experience. You could see that as we increase the angle, as this angle gets wider, we can see more and more of that experience. And as we decrease that angle, we decrease the angle. We could actually see less of the experience. But because the experience, or because of the actual image itself, fits onto our screen, so the left and right parameters actually fit directly onto our screen.
01:12:41.414 - 01:13:27.130, Speaker B: What this means is that with a smaller field of view, you can see less of it, but proportionally, the things that you're seeing are going to be much larger. So you're going to see this relationship respected. When I go ahead and actually change our field of view. So if I go from a 75 degree field of view to a 20 degree, actually, let's go ahead and change it to a two field of view, what do you think is going to happen to our experience? So I'm going to go ahead and save, and you can see, boom, it takes up the entire screen, right? And that should be expected when you think about the fact that as I go smaller and smaller and smaller in our field of view, I'm seeing less and less. And the amount of things I can see becomes narrow and narrower. So the things that I am directly looking at proportionally get much larger. So that's our field of view.
01:13:27.130 - 01:14:35.540, Speaker B: And within any experience, there's no rule to the actual field of view that you provide. You know, if two works for you, if you have things very far in the distance and you want them to look a lot bigger, feel free to use that. In conventional photography, a lot of cameras use a 50 degree or 35 degree field of view. So that is perhaps something that you may stick with as well. But, you know, just kind of play with these settings to see how zoomed in essentially, do you want your experience? The next properties I want to talk to you about are the actual near and far properties of the camera. The reason I'm skipping the following property, which is the actual aspect ratio, is because we already covered it in the actual introduction or the introductory scene lesson. And as well, it's not something that you will probably ever play with, likely because you want your aspect ratio to kind of respect your actual screen size.
01:14:35.540 - 01:15:13.884, Speaker B: So you don't want some crazy wonky aspect ratio, you want it to be according to the screen. So this is actually the property that you will most likely stick with, regardless of the experience. That said, there are near and far properties that you may want to change between experiences. And the near and far properties are fairly intuitive, such that anything within your camera and the distance of the near property, you won't be able to see. And anything after the distance between your camera and the far property, you won't be able to see either. And I'm going to say distance, but I'll also refer back to it as meters or units of distance. Because we are dealing with a virtual environment, it is basically completely arbitrary.
01:15:13.884 - 01:15:51.268, Speaker B: It's going to completely just depend on the scale of the different objects within your scene. As long as they all match. And as long as we're using the same consistent units, that's fine as well. So I'll be going ahead and just using meters to denote units of distance. But again, it is completely arbitrary. And I think technically they're supposed to be SI units. So with that said, for us to, you know, kind of test our knowledge or understanding of this, what properties would you provide to the near and far properties of this camera to make sure that you see? Like, everything? Like a lot like as much as you can? Well, in that case, you would probably provide it like a very, very, very small near distance.
01:15:51.268 - 01:16:22.474, Speaker B: Because anything between the camera, and let's say if you had a, you know, one as the actual near distance. If you had anything between the camera and that near distance, you won't be able to see. So you want to keep that near distance as small as possible if you want to see everything. And then you may want the far distance to be super, super large as well, because you want to see everything. You want to see something for millions of kilometers or miles away, right. In practice, this is probably not a good idea. This causes something called z fighting, and it's a little bit out of the scope for us to understand how that works.
01:16:22.474 - 01:17:00.866, Speaker B: It looks a little bit like this at times. It has to do with the fact that a GPU doesn't really know the depth of some of very closely positioned objects. But basically to avoid it, you know, stick with numbers that are a little bit more reasonable in the 0.1 ranges or the then don't have something that's like infinite miles away. Do what you can to kind of stick with some numbers that aren't excessive, aren't beyond the scope of what you actually need them for. Now, to further test your understanding, I have a question to ask you. So right now, the camera and the actual object itself is five distance or five units, 5 meters away, right.
01:17:00.866 - 01:17:38.856, Speaker B: So right now we are positioning the camera at z equals five, and then the actual object itself is z equals zero. So we are 5 meters or units away. What would I set the far property to make sure that I can't see this actual box? Well, let's say something like three, right? Because anything beyond 3 meters I won't be able to see anyways, right? So like the box is going to be 5 meters away. I won't be able to see that. Okay, that's totally fair. So let's put that back to like 200. And then what about the near property? What will I have to set to make sure that we can't see that box? Well, if you guess five, I think you'll be pretty on the nose.
01:17:38.856 - 01:17:51.856, Speaker B: Right. Okay, so anything between the camera and 5 meters away from it, you won't be able to see. So maybe someone like 4.9 will be able to see it. Okay, well that's strange. 4.8. Okay, that's not working either.
01:17:51.856 - 01:18:21.774, Speaker B: Now why is that? It's not because three js can't handle decimals or anything other than integers. Like we can do 4.75, you can do, you know, long floats. That's totally fine as well. But what's actually happening here is, and I'll show you the diagram. The camera is actually positioned at 5 meters away, but that's only the center of the object itself. However, the actual object itself exists because it's a one by one by one.
01:18:21.774 - 01:18:48.868, Speaker B: It still exists within 4.5 meters of the actual camera. So what you'll have to do is you'll have to make sure that the value that provide the near property is actually smaller than the actual smallest distance between you and the surface of that object. And that surface of the object you can see lives at about 4.5. So as soon as I do something like 4.49, I believe we will be able to see the actual object. Okay, that's perfect.
01:18:48.868 - 01:19:09.202, Speaker B: And I believe 4.5 or 4.51, you won't be able to see. Okay, that totally makes sense to me as well. If we are seeing 4.5 in, we should, should still be able to see the inside of the box, right? Well, that has to do with the material itself. So our material that we've provided isn't double sided, it's actually just one sided.
01:19:09.202 - 01:19:36.884, Speaker B: So if you actually look into an object, sometimes you may do that in games. If you look into the object, sometimes you don't see the inside of that object. You kind of just see right through it. And that has to do with how that material is set. Alright, the next thing we want to do, because I think we have a thorough grasp on how perspective camera work is. Perhaps we may jump now to the orthographic camera. But before we can jump into the orthographic camera, the first thing we want to do is be able to like, look at this from different perspectives.
01:19:36.884 - 01:20:29.030, Speaker B: Because this is a perspective camera. And without looking at this from different perspectives, we won't really be able to tell the difference between a perspective camera, which has perspective, and an orthographic camera. The distinctive feature about that is that it has no perspective. So let's go ahead and tell you how to set up something called orbit controls. All right, now the first thing we're going to do when we dive into a new class or a new concept is we're actually going to see if there's any reference to something like orb controls within our three js documentation. And we can go under add ons we can see. Okay, so what's add ons? We have a orbit controls.
01:20:29.030 - 01:21:01.432, Speaker B: Well, for one, add ons tells us that this isn't actually part of three JS package. It does come installed with everything that you've installed. But it's not going to come out of this three object. So where does it actually come out of? Looking at the documentation, there's no real references to where we actually get the orbit controls. There's no import here, but what we can do is we actually go into the examples and you can see the examples are always a good way to play with things that you want to test out. And if there are examples, I would always recommend you to go find it. And you can see now these are the orbit controls.
01:21:01.432 - 01:21:34.692, Speaker B: What I can do is actually click and drag and you can see, okay, so right now we get a pretty intuitive understanding or view of what's happening. Essentially we're orbiting around some point in the scene and then these controls let us do it in a way that's very intuitive, very smooth. So what I'm going to do is click, I'm going to drag really quickly and you can see that it actually swings our experience. So it's very fun. Intuitive controls. And they're very mobile friendly as well as always. If you go into the examples, you go into the bottom right hand corner, you can find the actual code example and we can actually see where they actually pull orbit controls from.
01:21:34.692 - 01:22:01.650, Speaker B: So they actually pull it from something called three add ons controls. Orbit controls, js. Luckily, because we installed three with NPM, we have access to this three folder where we actually hold this three object from. So we don't have to install anything else. What we'll have to do is just copy this line and we're going to go ahead and paste it into our code. I'm going to go ahead and save. I'm going to go back to our actual code and obviously nothing's happened.
01:22:01.650 - 01:22:16.842, Speaker B: Let's log it out to find out what we have here. Orbit controls. I'm going to save and I'm going to open up the console and you can see. Okay, perfect. So we have access to it. Now we just got to make sure that we initialize it. To initialize it.
01:22:16.842 - 01:22:48.420, Speaker B: You can see that within the examples itself. What it does is basically we need to create a new controls variable. We need to instantiate orbit controls and pass the camera and the Dom element. And then finally there's one more mention here to actually call an update method. So what we need to do is we know that we need to pass it an actual Dom element. So it's going to happen after we've created that Dom element. What does that Dom element look like for us? Well, for us we can see that we actually have something called the canvas.
01:22:48.420 - 01:23:32.938, Speaker B: So I've obviously explained what the canvas was in the prior sections and essentially what they're doing when they actually take the render and they actually append it to the Dom element. It's the same thing that we're doing by passing the canvas into the actual render itself. So instead of passing the Dom element into the scorpion controls, what we can do is actually pass it the canvas. So let's go ahead and do that. So I'm actually going to initialize, initialize the controls, instantiate the controls, cons, controls equals new orbit controls, controls. And I'm going to pass it the camera or camera in lowercase and the canvas. Perfect.
01:23:32.938 - 01:24:07.772, Speaker B: I'm going to save, I'm going to go ahead and refresh. Okay, so nothing's happened yet. And here you can see that the controls update is only required if controls enable damping or controls auto rotate are set to true. So those aren't set to true. And technically you can run this experience without enable damping. It makes it a lot better because damping is the thing that makes sure that you get that smooth spin when you spin the camera. But we technically don't need it, so we don't actually have to call this controls update method.
01:24:07.772 - 01:24:45.120, Speaker B: So what are we missing here? Well, the fundamental thing that we're missing with this experience, if you actually think back on our actual three JS fundamentals lesson, we have something called the render loop. And what that render loop does, it actually goes ahead and actually calls render once every frame. And right now what you'll notice is that we've only done it once. So JavaScript takes a look at our file. It runs each line of this code once. And then basically what we've done is we've called render on it one time and then that's pretty much it. Whatever was in the scene at that time is going to be rendered and displayed as an image onto your browser.
01:24:45.120 - 01:25:54.108, Speaker B: In order for you to actually call this render loop, basically every frame we need to use something called requestanimationframe. Before we talk about requestanimationframe, I'd like for us to think about other ways that may fix our problem. So our problem at hand is essentially what's happening right now is we're actually just calling rendered once, and recalling render once is just telling the computer to draw, basically capture what's happening at the scene at that moment and then provide it to the actual user. And so what can we do to call this multiple times when you're ahead? You might think, okay, well, there's lots of tools that lets us run functions at fix intervals. So for example there is like set timeout, set intervals. You could even just strictly do a loop that just calls itself and it'll just run constantly. And that's one way to achieve the problem, albeit you'll likely crash your application.
01:25:54.108 - 01:26:24.506, Speaker B: So let's go ahead and try that. Hilariously. So cons loop equals console log. So we'll go ahead and log out the results loop, and then we're actually going to go ahead and just call itself, and then we'll see what happens there. And then we have to actually start the loop by calling loop. So here what's happening is I'm calling the loop function, which goes ahead and runs and then logs out loop. And then it calls itself, which will run again and loop, and then it'll call itself and run again a loop.
01:26:24.506 - 01:26:57.578, Speaker B: And it'll basically, it calls itself as fast as the computer can possibly call it. So as soon as the computer is available to call it, it'll keep calling it. And then basically it'll just kind of like, go berserk. You can see, okay, I mean, very quickly it crashed, and then we're, I feel like there's going to be an error here some. Yeah, okay, so there's a maximum call stack. And essentially what's happening is, you know, we're just infinitely calling this loop function, but we really don't need to do that. And the reason is your device has a frame rate capped.
01:26:57.578 - 01:27:30.392, Speaker B: So there are modern devices out there that are crazy there. They're like 240 frames per second. It's crazy stuff. It basically has a very high refresh rate, and that's what it's called. But lots of computers actually only have a refresh rate of 60. And some computers have a refresh rate of 120. And basically what that means is that if in order for us to have a fluid experience that syncs with the actual refresh rate of the screen, what we want to do is we want to match the screen's refresh rate so that if it has a refresh rate of 60, we will render the scene as many times as that refresh rate can keep up.
01:27:30.392 - 01:28:07.456, Speaker B: So rendering it more than 60 times a second. For example, in this crazy loop, we're rendering it probably hundreds times a second. What's the point of doing that? Because you're just going to kind of like overload your computer bandwidth instead. If it's 60 frames a second, we want to make sure that we call our render function 60 frames a second. And I'm sure by now you may have realized that settimeout or set interval doesn't let us get to that level of precision. So even if you set the interval, for example, to one 60th of a second so that it gets called 60 times per second. What happens if you have a 120 frames per second screen? Well, then you only get to serve up half the frames and maybe that's enough.
01:28:07.456 - 01:28:59.370, Speaker B: But you know, if your application could run at 120 frames per second, why not run it at the smoothest possible refresh rate? So in order to do that, we can take advantage of something called the actual requestanimation frame. And what that comes from is actually the window object from the browser. The window object is actually just the global state for your web application. And what it does is it actually holds lots of methods that it actually provides to us, one of them being setinterval and then another one being requestanimationframe. There it is, requestanimationframe. So if I go ahead and log that out, you can see that we have access to it via the actual window object. And the way that we use it is requestanimationframe is a function that actually takes another function and tells a computer, okay, right before you paint the next image, right before you generate the next image, call this function.
01:28:59.370 - 01:29:58.466, Speaker B: What this means is that we have something that tells us exactly when the computer is about to generate the next frame. And in a 60 frames per second experience, requestanimation frame, right before the computer is about to paint the next image will call the function that we provided, and it's going to do that 60 times per second. So the way that we use it is we can just kind of do the same thing that we were doing previously, but obviously not as ludicrous. I'm going to call it render loop. I'm going to go ahead and pass the window that request animation frame, but I'm actually going to pass the render loop itself as an actual function into that argument. And what this is going to do, essentially what we were just doing with the loop previously. But instead of automatically calling the loop, as soon as your computer has the actual ability to do so, requestanimationframe is going to tell it, okay, just wait until you are actually able to produce this frame and then call myself again.
01:29:58.466 - 01:30:35.520, Speaker B: And obviously, if you can imagine this is just a loop. So if I go ahead and console log render loop, and then actually call the render loop itself, you can see that this is happening at a much more reasonable rate. Now, I believe my screen is 120 frames per second. So obviously it will call it more than it would if it used 60 frames per second screen. But we are also now going to actually pass the render render method into the actual render loop. And I'm also going to make sure that I set the size of the render before I actually start the render loop. So I'm going to put that in here, I'm going to save.
01:30:35.520 - 01:31:02.390, Speaker B: And then let's take a look to see if our controls work perfect. Okay, so they work, but they are a little janky. And the reason for that is because there is the enable damping property on the orbit control. So obviously I always recommend go into the actual documentation, see what you can do with it. And the few things that pop out to me is, okay, so there's auto rotate accepts a boolean. So true or false, I'll return that to true. And then there's also a enable damping that takes a boolean.
01:31:02.390 - 01:31:23.370, Speaker B: And I'm going to set that to true. So I'm going to do both of those controls. Enable damping true. And then controls auto rotate. Auto rotate equals true. I'm going to go ahead and save. And the one thing you're going to notice is control is not defined because I spelled it wrong.
01:31:23.370 - 01:31:47.936, Speaker B: Okay. It's kind of weird and janky. It's not rotating, that's for sure. If you go back to the documentation, you may remember that we've been instructed that controls update is required if enables damping is true. And you can see that this update method is actually being called within the animation loop. And the reason for that is because we want to frequently update the actual experience. Right.
01:31:47.936 - 01:32:16.472, Speaker B: And how often do we do that? Well, we're going to make sure that it syncs with your device's refresh rate. And this is one more thing that I like you to keep in mind. Okay, so now you can see it's spinning. Amazing. One more thing I like you to keep in mind is essentially anytime that we want to make changes to the scene, we're going to have to do that before we call the render. So we make a change, and then we call the render, which basically takes a snapshot of the scene and provides it to the user. Right? So you can imagine like a claymation, all right, like you make a change, then you take a picture.
01:32:16.472 - 01:32:38.230, Speaker B: Essentially what we're doing, we're calling the update, then we're taking a picture with the renderer, and then we're providing it to the user. So there we are. Well, first of all, let's take a moment to appreciate how fluid this is, how fun this is. At least when I started, I had a lot of fun just playing with a red cube. I'm like, holy crap, I created that. And within, you know, my own web experience. So for me, I think this is pretty cool.
01:32:38.230 - 01:33:21.796, Speaker B: It's super fun. And let's take a look at some of the other cameras. And also the controls that we have available to us. All right, so let's talk about the actual orthographic camera. So the difference between an orthographic camera and a perspective camera is kind of in the name. But orthographic camera actually doesn't have perspective on it. Now, what that means is that essentially, objects look the same to you, proportionally the same to you, regardless of how far away they are.
01:33:21.796 - 01:33:55.168, Speaker B: And obviously, that's very different to how we perceive the world. We have perspective vision, I guess. I mean, we have stereo perspective cameras at our head. And it means that as things get further away, they start to get smaller and they warp. And I think the best way to show you is basically to take a look at things that are viewed in a perspective camera. As you can see, all the lines here are parallel, as opposed to perspective, where everything, all the lines are conjoining into the middle as you look further along the horizon. Another way is this is the unity documentation.
01:33:55.168 - 01:34:26.576, Speaker B: You can see that this is, you know, traditionally, if you look at a scene, you would expect this type of view into the scene. It's kind of like a perspective view. Right? But however, there's also, if you were to render this in an orthographic view, you can see how all the lines are parallel. And I think this lets you do some pretty cool stuff. So a lot of this art, a lot of this, I really enjoy these types of renders with blender. I love these types of like, pretty much like dioramas, I guess they're all rendered in perspective view. And I think it provides a pretty cool way to visualize something.
01:34:26.576 - 01:34:52.186, Speaker B: So that's where we're going to implement it. Taking a look, the parameters here, the parameters that it's going to require. It's going to require a left, right, top, bottom, fresh from plane. So what does that mean? What are we specifying here? Well, these are all numbers. You can see that they're all distance provided. And what they're doing is they're actually specifying these parameters. So you can see in this diagram that I've provided for you, there's a few things that we're looking at here.
01:34:52.186 - 01:35:18.642, Speaker B: The first one on the left hand side is the actual perspective camera. So what we provided to this perspective camera is actually the field of view. And that field of view is going to dictate what types of objects that you're going to see in front of the camera. So, for example, anything like here, here and here in blue. Is not going to be viewed by the camera. But anything within the field of view is going to be viewed by the camera. Similarly, we are providing limitations of what can be viewed within the camera.
01:35:18.642 - 01:35:41.722, Speaker B: With the arguments to the orthographic camera. However, what we are denoting is we are denoting the distance between the center of the camera and the left plane. So, for example, this may be negative 1 meter away. This is 1 meter away. This is 1 meter above. And this is negative 1 meter below. What we're doing is we're denoting the distance between the center of the camera.
01:35:41.722 - 01:36:03.762, Speaker B: And the actual edges of this box. Now, what this box tells us is that anything within this box. Is going to be viewable by the camera. So anything outside here in the blue, we won't be able to see. Right. And anything within this box will be viewable by the actual end user. So let's go ahead and instantiate that for us.
01:36:03.762 - 01:36:23.604, Speaker B: Let's create that experience. We will leave the actual object rotating. But we are going to go ahead and comment out this perspective camera. And then we're going to do const. Camera, orthographic camera. I'm going to pass it negative one. Because negative one is one to the left.
01:36:23.604 - 01:36:45.272, Speaker B: And then it increments positively to the right. So one to denote one to the right. And above, we're providing a top and also writing it up bottom. So negative one. And then we're provided a near and a far property and save. And then we're going to see what that gets us. Okay, so immediately, this is looking pretty wonky.
01:36:45.272 - 01:37:07.588, Speaker B: It's pretty fun, though. Let's go ahead and full screen and see what happens. Okay, so something's happening here. It's a very wide boy. It's kind of like stretching across my scene. Now, what's actually happening here is that we're essentially taking a square image of the scene. So I designated negative one one and negative one as the arguments.
01:37:07.588 - 01:37:27.648, Speaker B: So what that does is it tells the scene to render a square for us. But because we've rendered a square. Once we stretch the actual scene across my actual desktop. It stretches the square and it becomes this rectangle. Which you would expect if you pull the square apart. What that ends up looking like. I'll just give you an example.
01:37:27.648 - 01:37:52.344, Speaker B: If I were to actually go ahead and show you an example. Where this viewport is kind of squared off. This is kind of the effect that you would expect. You would expect it to look a little bit more like this. Right. So instead, what we're going to do is we're actually going to provide the arguments with some information about the actual aspect ratio of the screen. And we're going to go ahead and multiply that aspect ratio by the actual distance values.
01:37:52.344 - 01:38:37.754, Speaker B: So instead of actually rendering this square image, we're going to basically render the same image that is the size of your actual screen. So our screen right now is actually like a rectangle. So I wanted to take something like this. It's kind of like a wider screen as opposed to something more square. So to do that, I'm going to basically tell it what our actual aspect ratio is. So I'm going to do const aspect ratio show and then basically use the exact same arguments that we did previously when we told the render what our aspect ratio was. And then I'm going to go ahead and actually multiply the left and the right by the actual aspect ratio.
01:38:37.754 - 01:39:35.598, Speaker B: And you can see when I actually refresh my screen, it doesn't become this super wide augmented experience. And so that's the orthographic camera. I think it lets you do some pretty cool stuff. I personally really like these types of renders myself. And then the next thing we're going to do is look at examples of different controls that we can also implement. All right, so this is kind of the fun, exploratory part of the course where we're more so looking at examples as opposed to strictly going step by step on how to implement them. The reason is because there's just so many possibilities in terms of what we can do with three js, that if I were to explain every example, especially the ones that don't have a lot of use cases, it would take us all day.
01:39:35.598 - 01:40:04.848, Speaker B: But I think it's going to be fun to basically take a look at what the depths of different controls are. So this is fly controls. So it looks like it's following where my mouse is. So my mouse is designating where I'm looking, and I'm not clicking and dragging. And then I can go ahead and fly as if I were controlling like a plane. So I can go ahead and I'm clicking w right now to go forward. Clicking a right now to move to the left, d right now to move to the right.
01:40:04.848 - 01:40:38.898, Speaker B: And there's even role controls. So obviously, this is very different from orbit controls. In that orbit controls has a pivot point, and you will always kind of move around that pivot point unless you update it. But here it's kind of like we're traveling and it's kind of an implementation of first person controls where you're kind of just going where the mouse is headed and also where your actual keyboard controls are. Another one, I believe would be. I believe this is first person controls. Yeah, this is first person controls.
01:40:38.898 - 01:41:12.670, Speaker B: It's under pointer lock. But essentially what's happening is your pointer is designating exactly where you're looking. So I'm moving with my mouse, taking a look around, and I'm also using WAsD to move. I'm clicking space to jump. And so obviously, I'm sure you can imagine many different types of first person games that can implement this type of perspective. And all of these you have access to by going to the actual examples and it could show you how that example is actually implemented. So I believe there may actually be a pointer law controls.
01:41:12.670 - 01:41:51.624, Speaker B: Yeah, there are pointer law controls in the actual documentation itself. So you can go ahead and take a look at that if that's something you're interested in implementing as well. You have something called trackball controls. And essentially with trackball controls, I believe it's just orbit controls, except you can kind of go all the way down and then kind of just like really mess with my perspectives. Whereas orbit controls, you're kind of limited to the vertical angle. So I can kind of like just keep spinning and keep spinning. And then another cool one is something like drag controls, which, you know, if you pass it objects, you can go ahead and actually just click and drag different objects within the scene.
01:41:51.624 - 01:42:42.404, Speaker B: And so these are all supported out of the box with three js. And I'm sure it'll have a lot of fun, kind of experimenting with some of these. All right, before we get into the actual meshes and how to animate them, I'm going to make sure that we address two things that you may have noticed about our experience that is less than optimal and teach you how to address them. This is kind of an extra lesson because there's no starter pack. We don't need to kind of work off of any new boilerplate code. I'm working off of the actual camera and render loop file, so we're just adding a couple lines of code. So it's really not going to require a lot of.
01:42:42.404 - 01:43:10.620, Speaker B: However, I would like to kind of explain what's going on so you get a thorough understanding of what I'm actually doing to fix some of these problems. On the left hand side, you can see that I actually commented out our orthographic camera. I put the perspective camera back in. I've changed nothing else. About the code. And then on the right hand side you can see our experience itself. So right off the bat you'll see that there's really nothing that's immediately wrong, nothing that I recognize and being immediately wrong if I just stay within this experience.
01:43:10.620 - 01:44:13.960, Speaker B: But however, when I go ahead and actually full screen this or I move this to any other aspect ratio, you can see that if I full screen it, the one problem is it doesn't fill up my entire screen. If I make the experience smaller, you can see that it doesn't actually center itself, which is not what is expected off of modern websites. So what's happening here? Well, for one, you may recognize this problem as similar to the other problem from the previous lesson, such that when we went ahead and set up our render, set up our camera and we just called render one time, we didn't actually do anything to update that render method. We didn't go ahead and call the render multiple times to make sure that it keeps up with a new experience. Well, that's a similar problem happening here, such that we only went ahead and actually set the size when we actually opened this application. So this application runs, it calls render set size once, and then now the renderer knows that the size of your application exists within this actual, the parameters of this window. But when I go ahead and change that, the render does not know what's happening.
01:44:13.960 - 01:45:09.490, Speaker B: So what we can do is we can actually call the set size method anywhere in our application. So for example, if I wanted to call it again here to override the actual initial parameters, I set it. I can go ahead and do that. And you can see that the actual application respects the last time that I actually called that to set size method. So if you can apply what we learned from the last class to here, where would you actually put this render set size method after you've actually set it once? So where's the second time you would call this what you call the set size method? Well, one of the things you may think of intuitively, perhaps you may think that it may be useful to actually put it inside this actual render loop. So now it's setting the size every single frame. So anytime you change it, we can change this in any which way and it'll always know exactly what the size of your render, of your window is.
01:45:09.490 - 01:45:27.988, Speaker B: You will notice immediately. One problem is if I go ahead and full screen it, it becomes this like super wide. Boy, it's super. It's just like kind of similar to our orthographic camera. You know, when we first initialize that we could fix it, obviously. Bye. Refreshing, which is similar to how we fixed the original problem.
01:45:27.988 - 01:45:53.470, Speaker B: If you went ahead and refreshed the program previously, it would go ahead and resize itself. But right now what's actually happening is actually we've provided the camera with an aspect ratio at the start of the application. We've never updated that. So the aspect ratio right now on my screen is I have a 16 nine screen. I know there's a top bar here. So it's technically like 16 point, maybe like eight or something. What's happening is that's the ratio that I provided the camera.
01:45:53.470 - 01:46:31.294, Speaker B: So now that at every point in the application, the camera knows that it's about to be 16 by something like eight. However, when I shrink the aspect ratio to something closer to maybe like a one by one aspect ratio, the camera still thinks that we're trying to cover that same aspect ratio. So now we're squeezing in the actual information from the camera. Similar situation to when we actually start with an aspect ratio closer to one and then we stretch this aspect ratio. This new aspect ratio is now a two to one aspect ratio. So we're actually stretching out the experience. So what we can do is we can actually go ahead and actually change that aspect ratio at any point in the application.
01:46:31.294 - 01:47:07.188, Speaker B: Well, when we first initialize the camera, we pass the aspect ratio as arguments to the camera. So how do we go ahead and change it? We're not going to call the perspective camera again because we've already created a camera. By calling the new three perspective camera, we've actually created that. We can access that at any point of the application. So maybe I do console log camera and I'm going to open up my console. You can see that we still have access to that perspective camera. And you can see within this perspective camera, you can see all of the actual properties applied to it now, one of them being aspect.
01:47:07.188 - 01:47:47.270, Speaker B: So another way to actually get access to all these properties. If you go into the actual documentation, you go into the perspective camera documentation, you can see that under properties, these are all the properties that is currently assigned to the actual camera. If I go ahead and search read only, you will find the properties that you cannot change. So the only way you can use this is perspective camera is to actually log it out so you can see that it'll return true. Because we do have a perspective camera, but I can't go ahead and change that by calling camera is perspective camera equals true. I can go ahead and change that value. What I can do is I can change any other property that is not read only.
01:47:47.270 - 01:48:33.144, Speaker B: So, for example, camera aspect, I can go ahead and change that to anything that we want. And so right here you can see that camera aspect as a property. And if I go ahead and change that to maybe something different, maybe five, you'll see a very stretched experience. Actually, before we go ahead and do that, let's go ahead and first try the actual camera by changing the aspect method here. So let's actually do that within our actual render loop, just like we did with our render. So we can go ahead and call camera aspect equals window inner width, window inner height. So now we're actually updating that aspect ratio for the camera at every given frame.
01:48:33.144 - 01:48:57.850, Speaker B: So I'm going to go ahead and save this. I'm going to have to pull up the console and you'll see. Okay, so we went ahead and saved this. But when I go ahead and actually full screen this experience, nothing's changed. It doesn't seem like it actually works. So if I start my experience here and I go ahead and shrink this experience to half my window, it should remain the same. But however, we are going to see that it suffers the same problem.
01:48:57.850 - 01:49:18.994, Speaker B: It's going to become this very skinny cube. Right? So, but didn't we change the aspect ratio? I did tell you that we can actually change it on the fly at any point. So let's go ahead and actually log it out to see what actually happened. Camera aspect. So you can see that we have an aspect ratio here, 1.4. So that makes sense because it's telling us that the width is 1.54 times the height.
01:49:18.994 - 01:49:44.950, Speaker B: That is what you should expect. If I go ahead and full screen this, what would you expect the new aspect ratio to become? It would become greater or smaller. Well, if you guessed greater, you would be right, because now we've stretched it out. Now the aspect ratio is about 2.8 times the actual height. So we are updating the actual aspect ratio here. But for some reason it's still not changing our experience.
01:49:44.950 - 01:50:28.790, Speaker B: And the reason for that is if we actually go into our methods, you'll actually find that there is a method that must be called after any change of parameters, which is the actual camera projection matrix. Now, what the actual projection matrix is, is out of scope of this, course, because there's really nothing else that you would have to do with this except for update it anytime the camera parameters change. So we'll just go ahead and actually just call that function and see what happens. Camera dot update projection matrix. And then now if we go ahead and resize this to whatever we want. It will always center itself on the screen and it'll always be a full screen experience. Perfect.
01:50:28.790 - 01:51:20.220, Speaker B: One last thing to address this problem is the fact that we are actually calling this every single frame and that's not something that we have to do. For example, if I'm just using this application like this, I'm just playing with the application, or maybe if I start at full screen and I'm playing with the application, nothing about the camera aspect ratio, nothing about the actual render. And the window needs to change. The only time it needs to change is when I actually go ahead and resize the window itself. So this camera aspect that I'm changing, this update projection method that I'm calling, this render set size, all of that I can stick within an event listener. Now, if you don't know what an event listener is, it's something that's provided by the actual window object itself, similar to how our request animation frame was provided by the window object. So it's a tool that our browser provides us to actually listen to events.
01:51:20.220 - 01:51:53.068, Speaker B: It takes two arguments. The first one is the type of event. So I'm going to listen to a resize and then the next one is actually you provide it with a callback function by doing so. So the second argument is actually a function itself. So I'm providing it a function and then the function I'm going to provide is console log resized. So let's go ahead and test this out. By opening our log, you can see that I actually resize the window itself by opening up the console because obviously that's changing what the size of that window looks like.
01:51:53.068 - 01:52:43.464, Speaker B: If I go ahead and resize again, you can see that it increments one. If I resize it back to the actual right side of the screen, you should see that it should increment to three. So every time we've resized our window, our event listener has went ahead and actually called the function that we provided it. Instead of calling console log resize, why don't we go ahead and actually just pull all this logic from the actual event listener and slap it in there, and we're going to go ahead and save and we're going to see if our application works accordingly. So you can see now that we've actually went ahead and added it to the event listener, we no longer have to call every frame. So we don't have to be so wasteful with our calls. We can just go ahead and actually just move this around and it will work accordingly.
01:52:43.464 - 01:53:27.370, Speaker B: Perfect. Now, so that's one problem solved. And there's one more problem that we'll need to solve. And I'll address that in the following lesson about how do we get rid of this staircase like effect on our actual cube itself? So you can see, you may not see it from my experience, but if you see it on your screen, maybe I'll stop the auto rotate here while I explain. So I'll comment out the auto rotate. And if I just move the camera to a position where the actual sides of the cube are on an edge or not parallel to the pixels of the screen, you should see a staircase like effect, these sharp edges that exist on the side of your cube. So let's go ahead and figure out how to fix that.
01:53:27.370 - 01:54:29.146, Speaker B: All right, so the next problem we are trying to solve is the issue of these staircase like edges on the side of our cube. So you can see on the edge of our cube, you can see this almost like this staircase pattern. And if you're not noticing it from the video, feel free to look at your own website because the way that this video is being presented to you is going to be compressed and the compression may mess with the actual way that you view these visual artifacts. So go ahead and open up your own application and go ahead and open up your own site and take a look at the sides of the cube. And it may be especially noticeable when you actually zoom out the actual staircase like pattern that emerges on the side of these objects. Now, if I go ahead and refresh when we start. Okay, this actually looks perfectly clean.
01:54:29.146 - 01:55:01.024, Speaker B: So it starts off fine, but it's only when we start rotating that we start seeing these staircase like edges. Why is that? Well, this is something called aliasing, and it's a well known phenomenon within computer graphics. And it's something that if you were playing video games, you may be aware of as well. But to understand what's actually going on right now, I have depicted to you the actual physical pixels of a screen. And now these physical pixels of a screen. Let's imagine what it needs to do to render something like a square. Just like when we start our application.
01:55:01.024 - 01:55:35.676, Speaker B: Well, if it needs to render something like a square, it can do that by coloring in these exact pixels on the screen, like so. So all these pixels get colored in. And what's essentially happening is these actual edges themselves. You can see this edge of the actual cube itself lines up perfectly with the edge of the hardware pixels on the screen. However, what happens if you need to render something like that? Well, you can't actually. So a rule of the graphics is you can't actually render half a pixel. There's no such thing as saying, okay, well, let's render this half of the pixel and let's render this half a pixel.
01:55:35.676 - 01:56:19.464, Speaker B: You know, all these other ones we start filling in. No, you have to render pixels individually as a whole. So you'd have to render them like this. So if I take away that line, if I take away that line, we end up with that same staircase like pattern that you may be seeing on your screen. So there's two ways to solve this problem. So obviously the problem is, you know, the fact that we can see very clearly the staircase pattern that emerges on your screen. Now, there's two ways to solve this problem.
01:56:19.464 - 01:56:59.368, Speaker B: One way is a hardware type of solution. Another way is more of a software type of solution. Now, the hardware solution is if you ever heard of something like a retina screen, Retina is just Apple's marketing term to basically say, we're going to provide you more hardware pixels per software pixels on the screen. Now, the distinction between hardware pixels and software pixels is such that the hardware pixels, the actual amount of pixels that you get on the screen, are logical. Software pixels are used by the browser to determine the size of the elements on the webpage. But realistically, what you end up looking at are actually the hardware pixels. Now, let's say we're trying to render that same line, right? Oh, sorry, that is a very jagged line.
01:56:59.368 - 01:57:53.988, Speaker B: There you go. Instead of basically just coloring in this pixel and this pixel and this pixel, if we actually had more pixels on the screen. So I'm going to start drawing in some of these pixels. If we had just more pixels on the screen. So you can see now I'm dividing each length and width of each pixel by two. We can actually just get more precise with the actual staircase and by being more precise with the actual staircase and by removing this final thing, you can see that now we have a staircase, but it's less noticeable, right? So if I go ahead and fill in some of these mini staircases, it's less noticeable by the viewer because, you know, the smaller something is, the less noticeable it becomes. So that's one way to do it, is essentially to provide a higher pixel ratio for the actual experience.
01:57:53.988 - 01:58:38.970, Speaker B: Now, pixel ratio, you can just think of it as more pixels. So the solution here is essentially to render more pixels. And I'm sure you can imagine the more pixels you have to render and pixels being the final product of your experience, the more pixels you have to render, the harder it is going to be on your device to render it. It is a little bit more of a brute force solution, but it is something that we will implement just to make sure that we will get a smooth experience or a nice experience to basically take advantage of all the pixels on your device. I'm going to draw another line here to basically show you another type of solution. Well, another type of solution is right now what we've been doing is actually drawing in one color. So I'm going to make sure that all of the pixels that are 100% within this line are colored by one color.
01:58:38.970 - 01:59:52.552, Speaker B: Right. So everything within this line. So we still have the staircase like effect. But let's say instead of going, even though we have to color in all the pixels at once, instead of actually drawing in a full pixel at that exact same color, what happens if we start to shade it with a slightly different color, a slightly lighter color, so that we can start to kind of create this gradient like effect? So when I go ahead and remove the actual staircase, what you can see, it's still a staircase, but it's not as harsh, it's not as sharp, it's a little bit smoother, kind of like a little bit more blurred staircase. And what that ends up being is a software type of anti aliasing solution that essentially creates a little bit of illusion of smoother lines. So let's go ahead and implement both of these in the code. Luckily for us, both of these problems are actually very easy to solve from the actual code level, given the amount of tools that we have at hand.
01:59:52.552 - 02:00:24.236, Speaker B: So the first thing that we'll do is actually go ahead and log out something called the window device pixel ratio. So you can see that I'm on a MacBook, and if I go ahead and log it out, you could see that I actually have a higher pixel ratio than one. And some of your devices may have a higher pixel ratio than one. If you don't have a higher pixel ratio than one, it just means you have less pixels to work with. But that's fine. There's other ways to solve this problem. But for us, we have a window device pixel ratio of two.
02:00:24.236 - 02:01:01.586, Speaker B: So we're going to go ahead and actually take advantage of that. To do that, we can go ahead and do render set pixel ratio, and then essentially we can provide it with the window pixel ratio. And then we can make sure that because we have a device pixel ratio of two that we can actually set, that we can give that to the actual render itself. Now, one issue with this is that there may be some phones out there. I know there's some Sony's with a, like a 4k display. No reason why you need to have that. And realistically it's a mobile phone, so it has less computing hardware and more pixels to actually render.
02:01:01.586 - 02:02:03.630, Speaker B: So the issue with actually sending the default pixel ratio is some manufacturers, for the sake of marketing, they want to market like a 4k phone, kind of provide a really high pixel ratio for no reason. It's actually more detrimental the experience because it's more pixels that we have to render and it's not even a noticeable difference. So in order to address this, we can actually do const Max pixel ratio. And we want that max picture ratio that we're provided to be the minimum of our actual window pixel ratio, device pixel ratio and two. And so what is this actually doing? I know that it's kind of unintuitive because we're praying a minimum, but essentially what we're doing is we're saying, okay, so if your device pixel ratio is one, well, there's no point in setting it to two because we can't set that to two anyways, because your device pixel ratio is one. Is one. If your device pixel ratio is two, then both of these are equal, so it'll set it to two.
02:02:03.630 - 02:02:42.704, Speaker B: But if your pixel ratio is three, well, that's unnecessary. So what we're going to do is we're actually going to find the minimum between two and three, which is two, essentially capping our pixel ratio at two. If your pixel ratio is four, the smallest number is still two. So we've capped it at two. And so what we can do is we can actually pass that max pixel ratio into our render set pixel ratio. And then finally we will be able to have, if you take a look at my screen, or you take a look at your own screen and you have a kind of like a retina like display, you will see that the staircase is a lot less noticeable. Another way to handle this is to actually just pass this in directly as an argument.
02:02:42.704 - 02:03:11.020, Speaker B: And I know that that isn't also a cleaner way to look at that as well. So that has mostly solved my problem, at least. I don't really see too many other staircases. But the final way to add anti aliasing. That software solution we provided is actually we have anti aliasing supported out of the box. So if you just do anti alias, true, as an argument to the Webgl renderer, that will work as well. And you shouldn't notice any more staircase pattern.
02:03:11.020 - 02:03:57.904, Speaker B: And yeah, essentially, now that we've solved this problem, let's move on to some more fun parts of the course. But I hope that this makes your experience a little bit more fluid. Now that you can have full screen. Now you no longer have these weird edges on your screen, I think we can go ahead and create some more fun experiences. All right, so before we get started, I want to run through the actual installation of the starter pack one last time just as a refresher. But then this will probably be the last time that I do this. So you can always refer back to this video to go through the steps again.
02:03:57.904 - 02:04:54.572, Speaker B: So I have my starter pack downloaded as a compressed zip folder so I can go ahead and double press to decompress it or just right click and extract. I'm going to pull it into my visual studio code. We have instructions in the readme, but if you just follow along, all you need to do is run NPM install to install the required dependencies. Wait a minute for it to finish installing and then NPM run dev and that'll get you access to your local server. Make sure you follow this link and then you'd be able to open it up from where we are going to start off in this lesson. Alright, I'll see you in the next lesson. So in these next few lessons we're going to be talking all about the three GS mesh.
02:04:54.572 - 02:05:56.130, Speaker B: But before I dive directly into the mesh and where we're going to be talking about it, I think it's going to be important for us to take a step back and talk about where we are in the course, what we learn and what we will learn in the context of the three js application. So obviously we'll be doing this constantly in the course to kind of like reinforce ourselves and make sure that we know exactly where we are and to ground ourselves and give ourselves that context. So we've covered the camera, we've covered the render, and now finally we're talking about the things that exist within a scene. To set up the most basic application, we went ahead and just threw a mesh in there and we threw a very basic red material and a very basic cube geometry. And as sequence lessons I will be taking deeper dive into the different types of materials, geometries and textures. But for this lesson we'll just be specifically talking about the mesh and the manipulations and transformations that we can apply to them, specifically the position, rotation and scale. So let's take a look at our starter and then recall back in a couple lessons ago when we first started setting up the scene.
02:05:56.130 - 02:06:34.820, Speaker B: What was the one transformation that we have already applied to the scene, to a 3d object within the scene? We actually started with the mesh and the camera in the exact same position. And to make sure that the camera could actually see the mesh, we had to go ahead and actually pull it back. And we did that by actually accessing the position property of the camera and the Z property of that position and setting it to five. So let's start with a simple operation similar to that. So I'm going to do Qmesh position dot y one. Now, I know this is a simple operation. However, there's a lot to unpack here.
02:06:34.820 - 02:07:22.920, Speaker B: There's a few things we want to ask. One of them is what are the units? Two is what are the axes, and then three is what are we actually doing? How are we accessing this property? And then what are the other properties that we can actually access? So the first question is, what is the units that we're using? And I've alluded to in my other lesson that it's realistically, it's nothing, it's arbitrary. You can use any units that you want. And the reason for that is, well, it's a virtual space. So realistically, whatever unit that you start with that you think is most logical for your actual application, as long as you stick with that throughout the application, it's totally fine. So let's say that we were playing something like a multiplayer game. Well, if we're doing a multiplayer game with avatars, for example, maybe it's like an FPS as a shooter, we want to know very importantly how tall your avatar is.
02:07:22.920 - 02:07:49.940, Speaker B: And then maybe you'd want to scale everything else in the environment proportional to that avatar, because the avatar is probably the most important part of your game. So maybe you would set the avatar to 1.7 units, that being maybe an analogy to 1.7 meters for like how tall you want your avatar to be. And now as long as you set that to 1.7, everything else in your scene just has to be proportional to that. So, for example, if you want a room, you wouldn't make that room shorter than 1.7
02:07:49.940 - 02:08:07.772, Speaker B: meters because then your player wouldn't be able to get through. Maybe you'd want to make it 2.5 units high. Similar analogy to a 2.5 meters high ceiling that you would have. That's how one would be able to walk into. So your units are arbitrary, but as long as every other parts of your application respect the scale of the other objects, then it's totally fine.
02:08:07.772 - 02:08:41.438, Speaker B: And it's all relative. Now the next thing to ask, what are the axis he's that we could use? So, for example, I just incremented something on the y axis, and the y axis exists as a property of the position. We will get into what a position actually is and how it exists within three js and some of the other fundamental properties of meshes. But for now, I think it's important for us to quickly understand, you know, what these axes actually are. If you remember from high school math, something that looks like this. This is a cartesian plane in which there's two axis. The y axis determines the vertical axis, the x determines the horizontal axis.
02:08:41.438 - 02:09:13.716, Speaker B: And as you increment rightwards, you go along the x axis. And if you increment upwards, you go the y axis and that's vice versa. So basically, if you increment leftwards, you increment negatively on the x axis. And if you increment downwards, you increment negatively on the y axis. Well, that's exactly what we're looking at here, except there's one more axis, which is the z axis. And the best way to actually visualize this is to add an access helper to our scene. And the argument that we're passing the access helper is the length of the actual visualization itself.
02:09:13.716 - 02:09:40.288, Speaker B: And then we're going to go ahead and add it to our scene as we do with any other 3d object that we want to be able to see. So you can see right here I have access helper equals two. If I make it five, you can see that the lines are just much longer. So I'll keep it at two. Then I'll show you. The y axis is green, the x axis is red, and the z axis is blue. Now this isn't something that you're likely going to remember.
02:09:40.288 - 02:10:14.256, Speaker B: And I'll tell you just straight up when you ask me, what's x, Y and z? A lot of the times you're looking at the scene from different angles and you'll have no idea. So the only way for you to know where you want to move an object, for example, let's say you had this red box and I want to move it to the right. Well, I would just go ahead and try. So I'm going to go, okay, cube mesh, I believe it's the x axis. So I'm just going to say, position x equals one. Will that work? And then, okay, it moves it to the right. So now I know that this is the x axis, and I know that going rightwards means incrementing positively on the x axis.
02:10:14.256 - 02:10:50.600, Speaker B: And that's essentially it. If you really want to have a rule of thumb, you can memorize the colors. And as well, I think it's important to know that you can see that there's three axes, but wherever they're pointing. So you see this y axis, you see how it's only pointing upwards and it's not going downwards from the origin. So wherever it sends outwards from the origin, it tells you essentially when you go upwards on that axis or when you increment positively on the axis, it's going to go in that direction. So this x axis goes to the right from the origin. It's going to tell you that if you increment positively on the x axis.
02:10:50.600 - 02:11:23.454, Speaker B: So if you go from three to five, it's going to go right. The same thing for this blue axis right here, which is our z axis. If you increment positively on the z axis, if you go from z equals zero to z equals five, it'll move this direction. So in our case, it'll move closer to the camera. It'll move in the direction that the actual axis helper points. And if you increment negatively, it'll move in the opposite direction from where that axis helper points. So essentially, I know that this z axis is pointing towards the camera.
02:11:23.454 - 02:12:22.840, Speaker B: So if I increment negatively, it's going to go the opposite direction from where it's pointing. So it's actually going to move further away from the camera. And we can see that if we set the z property to negative one, you can see that it's going to be behind the actual axis helper here. All right, take a minute to maybe absorb that and maybe play with it yourself to kind of get used to the different axes. And the next thing we're going to do is going to talk about what a position property actually is in three js as well, the different other properties that we can go ahead and manipulate. So in the last lesson, I gave you the instruction to do cubemesh position y to change the value on the y axis or the change the positional property on the y axis. But let's go a little deeper.
02:12:22.840 - 02:13:17.916, Speaker B: What is this position? You know, where does it come from? How did I know to target it? And what other properties can we change? Well, to know the different ways that we can actually manipulate a mesh and to understand a little bit deeper about the actual properties themselves, there's two ways to do it. For one, you can go ahead and just console log that mesh itself. So go ahead and console log cube mesh, and then we're going to go into our inspector, we're going to go into our console and we can actually go to the dropdown and then you can see, okay, so here's all the properties of the mesh. We have the children, and as I've alluded to, within the three G's fundamentals, all mesh exist in some type of parent children relationship. So this mesh is a child of the parent and it can have children of itself just like this group does. And as well, there are also properties such as geometry and material that I told you about. And then as well, finally down here we can take a look.
02:13:17.916 - 02:14:00.820, Speaker B: There are some types of like number properties, including position, rotation and scale. So there's where some of the properties come from. But another way that I like you to explore is to actually take a look at the actual mesh class within the documentation. Now if I search up mesh on the left hand side, you'd find mesh under here and I can go into it and I can go ahead and actually look at the properties. So as with I showed you in the actual camera lesson, if you want to get a deeper understanding of some of the properties or some of the things you can manipulate within three GS, you can just take a look at the actual properties within the documentation. What you will notice here is that this is a fairly limited list of properties. It's actually nothing as many properties that we actually found within our console.
02:14:00.820 - 02:15:03.710, Speaker B: So where is the property? Where is the scale? Where is rotation? We're going to find those. Well, for one, it tells us to see the base object 3D class for common properties as well. If you scroll to the top and you see above the mesh, anytime we see this link to another class with an arrow, we know that this mesh inherits all of its properties from a base class, in this case called object three. Djdeheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheheh so if I go with an object 3D, you can see now here is where you find some of the more generic properties that belong to all object three ds, including position, including scale, including rotation. And that's why we were able to actually manipulate the camera property, the camera position, because a camera actually inherits from object 3D as well. Even though you may not expect it to be some type of 3d object, it's kind of just like a point that looks at something, but you want to be able to move the camera in different ways. So that the best way for three js to implement that is to have that as part of an object 3d class or inherit properties from the object 3D class.
02:15:03.710 - 02:15:49.382, Speaker B: So here you can go ahead and take a look at satellite position, and then you can see the first thing that we see in position is actually the return value. So this return value is actually what holds that positions information or what the position actually is. The position isn't just an arbitrary container of random numbers, it's actually a vector three object. So let's go into vector three and understand a little bit of what vector three is. Now, a vector three class is a class representing a 3d vector. I know that's not very informative, but a 3d vector is essentially just a set of three numbers labeled x, y and zenith that tell three j's. In this case, what the positional coordinates of something are.
02:15:49.382 - 02:16:33.468, Speaker B: Now, because we know that it's a vector three class, we can basically apply any type of method, or we can manipulate any type of property that exists within the vector three class. So you can see the property that we were actually manipulating. We didn't just arbitrarily say, okay, well, cubemash dot position for no random reason. What we're saying is, okay, so within the cube mesh there is a property called position. And once we go into position, there's a property called y, and you can see that property right here. And then we're manipulating that property of that vector three class. Now what this also means is that we also have access to a lot of other methods that exist within that vector three class.
02:16:33.468 - 02:18:04.601, Speaker B: So for example, we can add another vector, we can add a scalar and some useful ones that we can potentially look at, is for example, something like a vector three class can copy another vector three class. So what happens if I do that? Let's go ahead and show you the power of being able to manipulate vector three class as separate objects. So if I created something called const temp vector equals new vector three, and then I set that position to three, what I could actually do is because I know that position is a vector three class, I can call any method that exists within this list and I could do copy temp vector. And then if you could potentially guess what this does, it essentially says that we've set a vector three units above the origin, and then what we're going to do is this copy method actually lets us copy the value of the past vector three and we're passing into it, into this vector. So this is just another way of moving that cube 3 meters up. So another method we can actually use is something called the distance two method, which calculates the distance between the vector three that you're calling this method on and another vector three that we're actually going to pass it. So for example, if I wanted to actually calculate the distance between the block that I'm looking at right now, actually going to do, we're just going to lower this distance or just keep it at zero, just for example's sake.
02:18:04.601 - 02:18:49.368, Speaker B: And if I wanted to calculate the distance between the camera and the actual mesh, I can actually use this distance too, because the camera position, if you could recall, is also a vector three. Now for us, we know that the distance between the camera and the cube is 5 meters. So we can go ahead and validate this hypothesis. And the reason I'm starting my code after the camera is because we actually have to have access to the camera position. So make sure that you call this method after the camera has been initialized. But we're going to do cubemesh position dot distance two, and then we're going to pass in the camera dot position. And if we go ahead and log it out, console log, we go ahead and log it out, we go into inspector, you can see, okay, five, that's perfect.
02:18:49.368 - 02:19:32.020, Speaker B: Obviously for us that was easy to calculate because we actually just set it. But for example, what if we set the actual q 1 meter up? Well that's some like pythagorean theorem stuff. But if you want to do it quickly, all you have to do is basically just call the distance two method. And then now you have the distance between the actual cube and the camera, or at least at the time what it was called. I'm sure you could imagine that this is very useful. This can be used in many applications that require some type of proximity based detection. So for example, if you had a player moving around and you knew where that player was, because we're changing that positional property of the player in order to move it, you have access to that position vector and you have access to another object's positional vector.
02:19:32.020 - 02:20:44.180, Speaker B: You can always call the distance two so that you can create some type of detection such that if you get close enough to an object, perhaps it triggers some type of event. And you would use this type of method that comes conveniently packaged with a vector three class to do that type of operation. Alright, so so far we've learned that a position is a property of the mesh. That position itself is a vector three. And that vector three has three properties, x, y and z, as well as a sleuth of other methods that may be helpful for us to make some calculations between vectors, to understand the distance between objects, to copy and there's many other operations that we will slowly start using as we build on our knowledge of three js throughout the course. But for now, let's take a look at some of the other properties that exist within the actual itself. So let's go ahead and do console, dot log cubesh.
02:20:44.180 - 02:21:17.252, Speaker B: And we can see that scale is something else that we could also manipulate as well. And we can also see that scale is actually a vector three. So we can go ahead and actually do the same thing that we did with position. So we can actually do cube mesh, dot scale. Y equals two. Now perhaps you can go ahead and try to guess what this cube will end up looking like. And if you guessed that, it'll just be twice the height.
02:21:17.252 - 02:21:48.814, Speaker B: Well, I feel like that's fairly intuitive, but we'll give you some bonus points. But yeah, essentially what we're doing is we're saying, okay, the axes are the same. So for example, when I'm saying on the y axis, you can expect it to kind of scale it vertically two times. Same thing with the x axis. I'm sure you can imagine what this means for the actual object itself, what this object may look like. Well, it'll just be two times wider. And now I'll show you one other thing that you can also do, is you can do scale, dot set.
02:21:48.814 - 02:22:22.998, Speaker B: So this is another one of those methods within the vector three. So you can see within the vectors three, we have a set method. And this is one way that you can go ahead and change all three properties of the x, y and z by setting that sets the x, y and z components of this vector. So we can go ahead. If I wanted something x twice as wide, twice as tall, but just as thick, I can go ahead. You can see that it's twice as wide, twice as tall, but it is only the same distance as thick. So that's another property that we can go ahead and change.
02:22:22.998 - 02:23:38.482, Speaker B: And we can use the set method to go ahead and change all three values at once. All right, before we get to the final property that I want to show you, I want to bring you back to our three js fundamentals and talk about the actual hierarchical structure of the actual scene itself. So when we refer to this hierarchical structure, we mentioned that there is some parent child relationship between meshes, such that children of a parent mesh will actually inherit properties or transformational properties from the actual parent mesh. And this isn't to say that whatever a parent scale is will determine what the children's scale is. It's just a factor that determines the children's scale. Because when we actually set the scale or position of an object, what we're doing is we're setting the object's local scale and we're setting the object's local position. Now in three G's, the local scale of an object or local position of object refers to the scaling of the object relative to its own local coordinate system.
02:23:38.482 - 02:24:06.084, Speaker B: And the local coordinate system is going to be inherited from the parent. And I feel like the best way to show you what this means is to actually go ahead and set this up ourselves. So we know that we have a cubemesh. Let's go ahead and actually create a couple other cube meshes. And we'll call this cube mesh two and cube mesh three. And then we're going to put all these cube meshes within something called a group. So a group within three J's is basically just an empty object, 3d.
02:24:06.084 - 02:24:40.678, Speaker B: It doesn't have any material or properties of its own. We can actually just add a mesh within another mesh to represent that same parent children relationship. But we don't need to add it to a mesh because this group is just going to be a holder of other meshes and we really don't need it to look like anything. So we do const group equals new three group. And then we're going to do is group just like we did with scene. Because if you can think in reality, scene is just like the parent of all groups, right? So we do group add cube mesh. Then we can add Cube mesh to and then group mad Cube mesh three.
02:24:40.678 - 02:25:12.776, Speaker B: And then finally the group right now just exists in isolation. So we can make sure that we're doing scene add group. So now we're saving and then what do we have? Well, I only see one cube. You may have recognized that we actually haven't changed any of those positional properties. So we can do that right here. And so we're going to do a cubemesh two position X equals two and we're going to cube mesh three. Position X equals negative two.
02:25:12.776 - 02:25:47.564, Speaker B: So we're going to move one two units to the right and we're going to move one two units to the left. I'm going to go ahead and save and see what happens. Okay, so now we have three cube meshes and they all exist within this one parent. Now let me show you what happens if I go ahead and actually scale this parent. So let's say we're going to do group scale. Y equals two. You can see that by scaling the parent itself, it applies all that transformation to the actual children within the meshes.
02:25:47.564 - 02:26:55.698, Speaker B: If I go ahead and actually change the position, why it moves everything as well, right? And so what we're basically saying when we're setting the object's local position is that right now the object's local position at y is equal to zero. What happens when we set it to y equals negative one? Well, we know that the world origin here is zero, zero. So if we were setting the absolute position of, let's say the second mesh. So we're targeting the first cube mesh here, which is actually the cube mesh in the middle, if we wanted to set it to a position to minus one. What you may expect if you were setting the world position is we would expect it to be one unit below the world origin. However, because we're only setting the local position, and anytime you set the position or the scale or the rotation, you're setting it relative to the actual group itself. So by doing cubemesh position, y equals negative one, we're not going to be sending this one unit below the world origin.
02:26:55.698 - 02:27:41.696, Speaker B: We're going to send it one unit below the actual position of the group itself. And because the group is at y equals two, we're actually just subtracting one from that. So it's absolute world position will still be above the world origin. So you can see that in practice here. So that's kind of that hierarchical relationship. So you could imagine the same thing applies to scale, such that if I go ahead and scale the actual group dot, scale dot, we could do method called setscaler, which is another one of those vector three methods that basically applies the number that you apply within the argument to all x, y and z coordinates. So basically I'm saying x equals two, y equals you and z equals two.
02:27:41.696 - 02:28:12.910, Speaker B: I can go ahead and double the size of all of these. But if I actually go ahead and set the cube mesh scale to equal 0.5, what I'm doing is I'm not actually setting the absolute scale of this to 0.5. I'm saying it's 0.5 relative to the actual group itself, which is two. So I'm actually setting the scale to one dot setscaler 0.5. I can go ahead and delete these.
02:28:12.910 - 02:29:20.782, Speaker B: And then now if you can imagine this is basically how our cube looks like in any other scene. So if I go ahead and actually just remove all this and add the cube mesh back, you can see that nothing's changed because the absolute scale is actually the same thing. They're both absolutely scaled at one by one by one. But because we've doubled the size of the group and we've half the size of the original relative to the group, it basically has the exact same one by one by one dimensions as if we basically weren't to do that at all. So that is how that parent child relationship exists. And we'll explore that later in the course when we start building something like a solar system as one of the projects. Alright, so now we're at the final part of the transforming meshes.
02:29:20.782 - 02:30:04.144, Speaker B: Part of the lesson, the final transformation that we're going to apply, which is the rotation, comes after the section where we talk about the scene hierarchy, is because I actually want to use the axis helper in a way that's going to help us describe some of these rotations. So I want to do two things for us here. For one, I'm actually going to change the material from the solid red color to something called the wireframe. And the wireframe is part of the object that we pass to the mesh, basic material. And this object includes the color which is specified as red. And we're also going to pass the wireframe which we're going to specify as true. So what that does for us is it provides us with, instead of a solid red color where we couldn't tell the edges were, which may be confusing when we're rotating these objects.
02:30:04.144 - 02:30:42.480, Speaker B: Now we have the wireframe of the actual mesh itself. The second thing we're going to do is we're actually going to go ahead and for one, I want to show you what happens if we move the cube mesh. Now we've done this many times before, so it should be no surprise that if we move the cube mesh one up, you can see that it moves one up on our screen. But our axis helper is still centered in the origin of the world. That should be expected because we haven't moved the actual access helper at all. However, if we actually go ahead and instead of adding the axis helper to our scene, because it is a 3d object just like any other 3d object, we can actually include it within our cubemesh. So we can actually add it to our cube mesh.
02:30:42.480 - 02:31:41.158, Speaker B: And now you can see if we save wherever we move our actual cube mesh. So for example, if I set the position to one, you can see that the axis helper remains centered in the middle of our actual cube. So that's exactly what we want to do when we actually start exploring some of the rotations that we can create. So now that we have our mesh set up with the wireframe, and we also have our access helper built into our mesh. You can go ahead and look at the actual rotational properties that exist within our object 3D. If you scroll down on the object 3D, you can see that we do have a rotation property, just like we have a scale and a position property. However, this rotation property is expressed in Euler's.
02:31:41.158 - 02:32:34.134, Speaker B: Now, Euler is essentially just a way to describe the rotation to an object depending on its various axes. So the constructor in a Euler, it takes three arguments, just like our actual vector three. Technically it takes four, but the fourth one actually just specifies the order. Because the actual result of a Euler rotation is going to depend on the order by which you apply the x, y and z rotations. But essentially we're specifying a rotation to be applied on separate different axes, just like how we, when we translate something, we specify that we want to translate something amongst the x axis or along the y axis. Rotation is the same, such that we go ahead and apply transformations on different axes separately. We'll also see one more important reference to rotation that exists inside this description of a quaternion.
02:32:34.134 - 02:33:24.456, Speaker B: And a quaternion is just another way to basically describe a rotation to an object. It's like a mathematical construct that is used to represent the actual rotation in using four values. And it's a little bit out of scope of what we need to understand about rotation. But we will be using it later on in this course and I will be getting into a deeper explanation about that. But for now, what we need to understand is a quaternion is another way to express rotation, but it's a lot more complex and it's not as intuitive to understand. That being said, the reason why it's used at all is, is because it solves some issues that you may run into with a euler, such as gimbal lock. So if you think there's some weird problems with your actual rotations, it's a good idea to look into perhaps expressing that rotation as a quaternion, which we'll do later in this course.
02:33:24.456 - 02:34:01.108, Speaker B: But for now we're going to stick to Euler's. I think that's kind of three js's thoughts as well, such that, you know, it is the default value that they use for to express the rotation property. And that's because to understand rotations in Euler's is actually fairly intuitive. So let's go ahead and actually express a desired rotation that we want to do. So we know that the Euler has the same x, y, and z types of properties that a vector three is. So let's go ahead and actually just go cubemesh. Rotation Y equals two.
02:34:01.108 - 02:34:36.572, Speaker B: So let's see what happens there. Okay. As you can see, our y axis, or at least this access helper, hasn't changed. And it doesn't change regardless of what I actually set as the value. What this is telling me is that it's actually rotating about the y axis. So you can see that everything that's rotating right now, or at least the axis that are rotated right now, as you can see, the red line, you can see the blue line rotating as I increment this value. But you can see that the green line stays the same.
02:34:36.572 - 02:36:18.266, Speaker B: And what we're doing, when we specify a value, when we pass a value into this rotation property, or into an axis of the rotation property, we're essentially saying rotate about that actual axis itself. So if I go ahead and try to draw this out, when we try to specify a rotation about the actual y axis, we're essentially saying rotate around it as if you were a shawarma on a spit, right? So I don't know if you know what a shawarma looks like or what a shawarma is essentially just like a bunch of slabs of meat. And you got a stick that's stuck right through it from top to bottom, and it rotates around because that's the way that it cooks around this, like, heating element. And the way that's rotating is actually rotating along the y axis. So if I were to actually tell a three JS application, or make a three JS application that describes rotation of an actual shawarma, I would actually just say shawarma rotation y equals some type of value, and I would increment the value as a shawarma keeps rotating. If you don't know what a shawarma is, perhaps I may describe something like roasting hot dogs over a fire, in which case we would have a stick amongst the x or the z axis, I would have a hot dog on that stick. And then the rotation, when you rotate the hot dog around, like this way when you rotate it around so that every part of the hot dog, every surface all around the hot dog gets exposed to the fire, what you're doing is you're either rotating it along the x axis or you're rotating it along the z axis.
02:36:18.266 - 02:36:56.428, Speaker B: So that's exactly what we're doing when we actually go ahead and start rotating on specific axes within three js. So I'm going to go ahead and refresh here. The next thing you may wonder is, okay, so we are specifying the axis of rotation, but what is the value that we're passing? It is a degrees, because that would make sense. For example, if I went ahead and said, okay, we'll rotate, you know, along the x axis. The next thing you may want to tell it is like, okay, well, how much do you want to rotate? Because 360 degrees would be like a full rotation. Well, this is the part where it gets a little bit confusing. We are expressing rotations as a function of radians.
02:36:56.428 - 02:37:30.410, Speaker B: So when you tell it to do a ten, y equals ten, you're telling it to rotate ten radians. Well, how does that translate to degrees? All we know is that math PI, which is just PI. So 3.14 specifies a half rotation. So 180 degrees rotation is denoted by 3.14. So if you were to, or one, five, whatever, et cetera, et cetera, a very long number. So technically, if you were to rotate it all the way, you would have to tell it to do math PI times two.
02:37:30.410 - 02:37:52.830, Speaker B: And that's like a full rotation. So you can see nothing's changed. The z axis is still pointing to the camera. The red axis is, or x axis is pointing to the right. So we've done a full rotation here. If you want to rotate it 90 degrees, well, that's just math. PI, which is half rotation divided by two times 0.5.
02:37:52.830 - 02:38:19.820, Speaker B: And then now we've rotated it 90 degrees. So now you can see that, whereas before the blue axis was pointing towards the camera, now it's 90 degrees counter clockwise. Now it's rotating to the right of. If I want to rotate it clockwise, at least when I look at it from top bottom clockwise, I would go ahead and specify negative. And it would rotate. This z axis indicator would rotate to the left. So we can go ahead and see that in action.
02:38:19.820 - 02:39:02.072, Speaker B: I know that this is probably a little bit confusing. I mean, I think it's probably convention as to why they are using radians. But there is a utility that we can use that comes out of three JSDEV called three mathutils degree to radian. And then you specify some type of degree. So, for example, if I wanted to do that same 90 degree rotation such that the blue is on the right, that I can go ahead and save. And you can see that we could express our desired rotation in degrees and it automatically converts it into radians and then gets passed into that rotation. Euler so that's one way to do it.
02:39:02.072 - 02:39:44.270, Speaker B: The degree to radian function is actually just a very simple function. It just does that conversion for us. But I can imagine that it can come in handy in many ways, and it often comes in handy for me because I'm not going to try to remember that relationship between Radians and degrees often. Now, the next thing that we want to do is start to combine some of these rotations. So, for example, the reason why the actual axis helpers are important is because we realize that not only are we rotating the object, we're also rotating the axes themselves. So let's go ahead and actually show you what happens when we are in the original state. So let's go ahead and actually just rotate amongst the x axis.
02:39:44.270 - 02:40:22.076, Speaker B: When we rotate along the x axis, and let's say. Let's say something like 45, so we know what's going on. Essentially, we've rotated along this axis. So we've kind of like tilted, follow my mouse, tilted the box this way so that this edge comes closer and closer to the camera. You can see that the actual y axis has changed with it. So you are no longer rotating, like, along this vertical top to down axis. Now the y axis has actually changed such that the y axis now expects you to rotate it kind of this way.
02:40:22.076 - 02:41:01.800, Speaker B: This is the new axis of rotation. That's what becomes a little bit confusing about Euler rotations. And this can cause a bunch of issues once you start changing one axis of rotation and that causing another axis of rotation to start to change. So let's see what happens if we try to change the actual angle, the y axis after that. If you are like me, you would expect that because we're rotating about the y axis at 90 degrees, we really shouldn't see a change here. Nothing should really happen because if you rotate 90 degrees, it's a cube. All the angles should light up again.
02:41:01.800 - 02:41:27.040, Speaker B: So if I actually just go ahead and save. Yeah, okay, perfect. So nothing should really happen. Nothing should really happen because we went ahead and rotated amongst the x axis, and then we went ahead and rotated on the y axis. The only thing that changed is the actual axis helpers themselves changed position. So if I comment this out, you can see the blue axis helper is pointing downwards. And then now we rotate it.
02:41:27.040 - 02:42:03.226, Speaker B: It's pointing to the right, as expected. Now, what happens if I actually change this order of rotations such that first I'm going to rotate on the y axis. So I want to rotate on the y axis 90 degrees. So let's go ahead and see that in action. So the actual blue axis was actually pointing towards us, and now it's pointing to the right. So now rotated 90 degrees, you would expect. Now, now that I go ahead and try to rotate along the x axis and the x axis being red, you would expect that there would be like a 45 degree.
02:42:03.226 - 02:42:44.596, Speaker B: So we would see, like, we would see the actual, instead of it being in this square shape, it would still be a square, but it would kind of resemble like a kind of diamond. So let's go ahead and try that and see what happens. Weird. Okay, you may have recognized this from before. This looks exactly like the way that we had it originally when the y axis came after the x. Right. So if I go ahead and save now, you can see that actually changing these angles, changing the order of operations, hasn't actually changed anything, even though we expect that after we change the y axis, this becomes the new x axis.
02:42:44.596 - 02:43:44.036, Speaker B: And because that becomes a new x axis, technically, when we're looking at it, we should see a diamond shape. If we rotate it 45 degrees. Well, that's where the actual order of operations comes in. So you know how I specified in the Euler argument, I called out the fact that there was an order. Well, by default, even though I put the y axis transformation before the x, three j's will always apply the x and then the y and then the z transformations in that order. And the reason why is because it keeps it consistent and it makes sure that switching around a couple lines of your code won't completely break your application. And so the way you get around it and the way that you specify that you want three js to compute your rotation in a certain way, and you go ahead and call cubemesh rotation, and then you actually call a reorder method, and then you pass it as a string, the order that you want our actual rotation to happen.
02:43:44.036 - 02:44:19.844, Speaker B: So I want to rotate on the Y first and then the X and then the z, and then, now if I save, you should see that. We should see that kind of diamond appearing. Oh, and that's actually a lesson in and of itself. I should be calling this rotation reordering before we actually reorder, because three G's essentially has to know the order that we have to apply it before it actually starts applying rotations. So I believe if we save it now. Perfect. Now it looks like we are rotating along the x axis after we rotate along the y axis.
02:44:19.844 - 02:44:57.674, Speaker B: So, yeah, just something to keep in mind. And in our further lessons, we will dive deeper into rotations and different transformations. And we talking all about quaternions and we'll get real deep into it. But for now, you should be able to kind of chain some of these together. And I think you should go ahead and have some fun reordering or changing rotations and also changing positions and also even changing scale. We can really start chaining a lot of these together to create something wonky. And I want you to keep in mind one more thing is that you can actually have these in any order that you want.
02:44:57.674 - 02:45:40.600, Speaker B: I know that the rotation order matters, but as long as you have this reorder, or you can even not have the reorder, and the default order is XYZ, all the rotations will be called in the same order, regardless of where all of this code exists on the page. So you can see, I can move this anywhere that I want and keep saving it, and I can move this here. And all of these transformations remain the same regardless of where it sits in your application. Just make sure that you have access to those properties so you've instantiated the cube mesh before you start calling those properties. Start chaining it together. I hope you start enjoying yourself and start playing with some of the stuff that you already have at hand. All right, perfect.
02:45:40.600 - 02:46:50.972, Speaker B: I hope you enjoyed this lesson. I know it was fairly long winded, but I'll see you in the next one. So these next few lessons will be about animations. And luckily for us, because we spent so much time really getting down into the details of animations, you know, even getting down to damn cartesian planes as well, because we spent some time talking about the render loop and understanding a little bit of that in order to get our actual controls to work. We can combine those two principles into animations in a way that should seem fairly intuitive to you, and it should be a very relatively quick set of lessons. Now, animations is essentially just a transformation just applied dynamically, such that previously, in the last few lessons, we applied transformations once and we transformed the scale or the position, and now it's in a different point in the screen. If we were to apply those transformations dynamically, such that we kept applying different transformations.
02:46:50.972 - 02:47:31.270, Speaker B: So imagine going back to that claymation analogy that I brought up working with the controller. We made a transformation, then took a picture, then made a transformation and took a picture, made a transformation and took a picture. That's essentially how animations still work even in modern digital studios. You make a change to something via a keyframe, and then that change is captured within a frame. And then if you have enough frames per second, it looks like a fluid animation. So let's go ahead and actually apply some of those changes into our mesh. But instead of doing it before we actually initialize the render loop, let's do it within a render loop so we continuously apply those transformations to the mesh.
02:47:31.270 - 02:48:19.852, Speaker B: Right now I am working within our animation starter. If you don't know how to set it up, make sure you watch the last lesson regarding the actual transformations, which I went ahead and used our starter from scratch. And here we will get started with just a code on my left hand side. And if you installed it properly, you should be able to see a wireframe cube on the right hand side. And I think this will help us better visualize some of the transformations that we're applying to it. So how do we actually get this delta? Well, first I want to clean this up. Let's think about it in our heads before we write any code.
02:48:19.852 - 02:48:53.170, Speaker B: I always like to think about it conceptually. Right. Understand the difference between the time when this current frame is called and the time when the previous frame was called. Well, first we have to have some reference to absolute time. We need to know what time it is right now because let's say this frame was called once per minute. Well, if I knew that the current frame is called at 145 and the previous frame was called at 144, well, I know the delta between the frames was 1 minute. So in order to get reference to the time, we can go ahead and actually just initialize the clock.
02:48:53.170 - 02:49:48.622, Speaker B: And then to do that we do const clock or whatever variable we want to provide. It equals new three and it's clock, this clock class. And what this clock class provides us. Sorry, it's a little bit of a tongue twister, is it provides us with something called get elapsed time. If I go ahead and log this out, you can see that the elapsed time is essentially the difference between when this method was called and when we first initialized the clock. Right. So if we do that, what we can do is we can say that the current time is equal to clock elapsed time and then the delta would be equal to current time minus previous time, which is the last time this render loop actually fired.
02:49:48.622 - 02:50:42.796, Speaker B: Now, how do we have access to the actual previous time? Well, if we set previous time after we go ahead and calculate the delta, so the delta is already calculated. But what we're doing here is we're making sure that the next time we call it, it has reference to when the last time was called. That last time is being called right now. So we can go ahead and say previous time equals current time. So essentially what we're doing is on the current frame we are going ahead and finding the current time and we're subtracting it by the previous time to get the delta. And for the next frame we are resetting the previous time to the current time to make sure that we have a index or a tracker or a marker to understand when the actual method was called last and we're setting it to our current time right now. I know that's a little bit complicated, or at least may need a minute to wrap your head around it, but really just think about right now.
02:50:42.796 - 02:51:47.012, Speaker B: If we're going ahead and resetting the previous time after we get the delta, what we're doing is we're preserving the actual timestamp to use for the next time. We call this method in which we'll do that subtraction in order to get the delta. If I go ahead and save you'll see that we have an error that such that previous time is not defined. What we'll have to do is we make sure that we do use a let to tell JavaScript that this is a value that's going to be changed and we're going to do let previous time equal zero and so that when we first run the actual function itself we have access to a previous time which would have been zero. And then finally we're going to log out the delta. And then you can see now, instead of a constantly incrementing value like we had when we had clock get elapsed time, we're actually just tracking the tiny fraction of time that's happening between frames that are firing. And for me I have a 120 hz display, so I'll have a smaller value than you would if you had a 60 frames per second display.
02:51:47.012 - 02:53:00.672, Speaker B: But what we can do now is because we have access to this time, we can go ahead and actually just multiply the transformation that we had by the actual time. And so this may dramatically slow it down, but you can actually just go ahead and actually multiply this by any amount. It doesn't matter as long as Delta is one part of the multiplication, so maybe we have to multiply it by a lot more. As long as Delta is one part of the equation we can create an experience that's frame independent, which means regardless of your frame rate, your experience will look the same whether you have a 60 or 120 hz or even a 30 hz display. Thats all you should need to know about the way the that we animate in three js before you can start animating any property that you want. But there's a reason why I've only shown you rotation so far is because of the way that we're constantly incrementing by a delta. So we're constantly incrementing by some value.
02:53:00.672 - 02:53:34.348, Speaker B: If I went ahead and actually just animated the position, you'll see that one issue that we'll run into while we're teaching equals, if I just went ahead and actually just plus equals 0.1 times delta, what would happen is, well, actually this is fairly slow, but let's say, let me sped this up. Eventually the queue would just kind of keep going off the screen and we'll lose it forever. And that's expected. We're essentially saying is okay, one times delta. This is just some number. Imagine if Delta was 0.5.
02:53:34.348 - 02:53:53.744, Speaker B: So 0.5 seconds between the last frame and the current one. It would just be saying every frame, add 0.5 units to the x value and eventually we kind of lose it. Same thing with scale. It eventually just balloon up into this massive thing and it would just be like, you know, very different from how we started the lesson. But that's expected.
02:53:53.744 - 02:54:32.834, Speaker B: Obviously, if we're animating like that, that's totally fine. Another type of animation may involve a sine wave. So if you know what a sine wave is, or if you're taking trigonometry, you know that a sine wave, right now we're incrementing this number, right? So any normal number, if it was just a linear relationship, which is kind of go up, up and up, but a sine wave oscillates between one and negative one, one and negative one, depending on the number that you provided. And even if you give it a billion, the actual value of the function would exist between the intervals of one and negative one. So let's go ahead and actually provide, let's do a console log. Let's log out. What happens when we do math? Sign.
02:54:32.834 - 02:55:21.424, Speaker B: So math is an actual object provided to you by JavaScript in the browser, and it has a sign method that takes any value that we want. We're going to provide it with our current time because we know that our current time is something that increments positively. It basically it's the difference between the time right now and the actual first time that we instantiated the clock. So the longer the time between right now and the time we instantiated the clock, the greater this number will be. So we're essentially incrementing along this x axis and the actual output will be the actual result of this y axis, which is going to be oscillating between one and negative one. So let's go ahead and log that out. So you can see it goes all the way to negative one, and then it goes back to zero, and then all the way to one, and then it goes back to zero all the way to negative one.
02:55:21.424 - 02:56:01.778, Speaker B: So what we can do is we can actually say cubemesh scale equals. We're not adding it, we're just saying equals to this. So now you can see in my right hand side, we have an x value that's oscillating between negative one and one. And obviously, a negative x value may seem unintuitive. For in three js, you can actually scale something by a negative value and essentially just inverts itself. If you don't want it to invert itself, we can go ahead and just add a base value to it. Because now what we're doing is instead of going from positive one to negative one, we're adding one to both the highest and lowest, and we're also adding one to every point.
02:56:01.778 - 02:56:50.260, Speaker B: But to understand intuitively, at the lowest, it's going to be zero instead of negative one, and at the highest, it's going to be two instead of one. So now it doesn't collapse in on itself. And then if you want to make sure that at the smallest end, it is at least a box, you can add two, so that we know at the smallest end it is at least one, and then the actual at the highest end, it will be three, because now we're adding two to the highest number. So this is just something that you can just play with. You can also mess with the actual amplitude itself, which will impact the actual relative difference between the highest and the lowest points. So if I don't want it to grow and shrink as much, I can go ahead and just add, multiply by 0.5. If I wanted to grow and shrink by a ridiculous amount of, I would multiply this amplitude.
02:56:50.260 - 02:57:44.170, Speaker B: And this amplitude you can see here is defining essentially how big are those swings. So if I want those swings to be really big, I make sure that I multiply the actual function itself as opposed to just adding something. So if I multiply this by 20, you'll see that it goes really, really, really wide and it comes back. So I'm going to go ahead and try that. So you can see how it goes really wide and it comes back and then goes really, really, really wide, and then it's also rotating. And the reason why I'm showing you the actual rotation itself is because I want to show you that we can combine transformations and then obviously you can do the exact same thing with position, but I'm going to keep it at a lower amplitude just so it doesn't fly off our screen. So, yes, you can see we can combine and just start playing with a whole bunch of animations, different transformational properties.
02:57:44.170 - 02:58:35.068, Speaker B: We can chain them together. We can also do the same thing with groups as we did. So we can go ahead and actually add this to a group and actually just animate the group itself. To animate multiple things at once, that's totally fine as well. And that's just something that I think you should go ahead and try explore yourself to get a hang of animations within three JSD. All right, so before we get started, I think it's going to be important for us to take another step back and kind of frame our understanding of the things that we learned within the broader context of the three js application. So, so far, we've covered the camera, the render and the render loop.
02:58:35.068 - 02:59:51.716, Speaker B: And then the most recent lessons, we've talked about the things that go within a scene. So that includes all of the meshes which inherit their properties from 3d object. And then that 3d object, or as three JS calls it, object 3d, has properties such as scale, rotation and position that you can ultimately transform to kind of manipulate your mesh in different ways. We learned about how objects within the scene are organized in this hierarchical like fashion, such that the transformation that you apply to the parents are ultimately propagated down to the children. And then we also learned how to basically change some of these properties within the render loop so that we are able to create a dynamic experience, or we are able to create an animated three js experience for the user as we update some of these properties, or we transform some of these properties every frame and ultimately deliver some type of moving animated experience for the user. Now, in this lesson, because we've covered basically the transformation and some of the properties that we can transform on the mesh itself, we are going to go one level deeper to understand what constitutes the things that make up a mesh. So, so far, we've actually just used the very basic red material, a solid red material.
02:59:51.716 - 03:00:32.444, Speaker B: And as well, we've used a very basic cube itself. But in this lesson and the following lesson, we'll go one step deeper, and then we'll dive into, in this lesson, the geometry, and in the next lesson, we'll dive into the actual material itself. So if you've noticed a pattern, we've actually started at the top of the application. So instead of building this bottom up, we've actually started the top and very quickly created a type of experience that you go ahead and play with. But as we start to dive deeper into this course, we're becoming a little bit more granular in the things that we are trying to change. And in this lesson, it's going to be all about the three js geometry. I'm going to go ahead and actually run the starter pack.
03:00:32.444 - 03:01:11.734, Speaker B: So I already have the starter pack installed and ran, and I have the code on my left hand side and the starter experience on my right hand side. You can see that I set the wireframe to true, so I'm keeping this true just so that we can actually see the base geometry of the box itself, so that it's not just one big red blob. Also, I'm not animating it. I'm actually just auto rotating the camera. So the actual orbit controls is just orbiting around the geometry itself. And then right now, I'm basically using the box geometry that we use so far that three js actually provides us. Now, that brings us into a little bit of discussing where we get our actual geometries from.
03:01:11.734 - 03:01:52.846, Speaker B: So there's a few ways you can actually create geometries in three GS. For one, they provide us geometries right out of the box, and that's something that we will be exploring in this lesson. A lot of the times you will be using three js's own geometries, and they actually call them primitives. Another way to create geometries in three g's is actually to do it from scratch. And we're actually going to try that in this lesson. It's not going to be something that we're going to be doing throughout the course because, you know, oftentimes their primitives already provide us with a lot of good starting options. And if you really want to get more custom, it's better to do it within a 3d modeling application such as blender or Maya.
03:01:52.846 - 03:02:47.110, Speaker B: It's very rare. I can think of very few scenarios where you would want to forego the use of a 3d modeling application and just create a geometry from scratch. And the reason is because, as you'll see very quickly under this video, it's a lot of boilerplate code just to create something like a triangle that we want. But for the purposes of learning, that's exactly what we're going to do. So we're going to actually go ahead and comment out the geometry and then we're also going to comment out the actual scene, add cube mesh, and we're also going to comment out the actual cube mesh itself, just so we don't get any issues as we're setting up the code required for the actual custom geometry. So let's go ahead and say create custom geometry. And before we do that, let's take a quick look into the documentation to take a look at something called the buffer geometry, which we'll be using to create our own custom geometry in three js.
03:02:47.110 - 03:03:45.946, Speaker B: So let's talk about the buffer geometry. A buffer geometry in three js refers to a type of geometry where vertex data is stored in the memory as binary arrays or buffers. And that's where the buffer in buffer geometry comes from. It's essentially referring to the fact that this geometry stores its information about the actual vertices in these arrays. Now, a vertice in three js, or just in geometry in general, refers to these points where these lines make up. So it's basically like you see these edge points right here? These are the things that determine the actual shape of your geometry itself. And so we have to store these points in some way.
03:03:45.946 - 03:04:35.334, Speaker B: And the way that we're storing these points determine the type of geometry we're using. And in this case, because we're storing these in binary arrays, we're using something called a buffer geometry. Now there is a distinction between a buffer geometry and other types of geometries or other implementations of storing this type of data. But for us, distinction is no longer so important because the primitives that we are provided out of the box, such as the box geometries and the sphere geometry and some of the other primitives that we will be talking about later in this course, actually implement buffer geometries under the hood. Now the reason I'm bringing this up is because this wasn't always the case. And previously if we wanted to use a buffer geometry, we would have to call something called a box buffer geometry. But instead, now box geometry implements this out of the box.
03:04:35.334 - 03:05:20.272, Speaker B: And the reason why that matters is because buffer geometries are more often than not more efficient in terms of memory usage and speed compared to other implementations of geometries. Now if we were to look strictly at the code and how to actually implement the buffer geometry, you'd see that we actually create a buffer geometry. Then we create a, some type of array. Then we actually pass that array into a buffer attribute which we use to set the position attribute of the geometry. Now strictly speaking, this is a little convoluted. Obviously it's not hard to follow in terms of like, it's not hard to type out these numbers, these few lines of code. But conceptually speaking, maybe we should take a step back.
03:05:20.272 - 03:06:22.750, Speaker B: Right now we are working with a buffer geometry. So at this point in the code you have created a buffer geometry that has no idea what the different positions of these vertices are. And once again, the positions of the vertices will dictate the actual shape and the look of your geometry itself. So how do we actually pass in information about the actual positions of these vertices themselves? Well, three JS has something called a buffer attribute, so you can see that to read and edit data in buffer geometry attributes, see the buffer attribute documentation. So if we go to buffer attribute and we follow the documentation, you can see that a buffer attribute is just a way for us to store that information. So we store information about the positions of these vertices themselves and we actually go ahead and tell three js to set the position attribute using this information that we've provided it. So the reason why it's important to actually set the position is because the buffer attributes can hold lots of different types of data.
03:06:22.750 - 03:07:06.482, Speaker B: For us right now we are using it to store information about the vertex positions. But you can imagine if it's just an array of information, it can hold anything. It can hold information about the color of each pixel on the screen, right? But for us we're providing it the actual x, y and z position of every vertex. And the way we do that isn't directly through this buffer attribute class we actually pass in a typed array. Now a typed array is a JavaScript object. You can see it's basically a kind of array. And for us we're going to be using a flow 32 array, which should hold more than enough information for us regarding the actual precision of each number that we're going to provide it.
03:07:06.482 - 03:07:45.776, Speaker B: And this array can be as long as we want it to be or as small as we want it to be, but it's going to ultimately depend on the actual geometry that we're creating. Now I know that that was probably a lot of information all over the place, but I think this diagram may help simplify that a little bit by working kind of backwards. We start from the array itself. So this array is going to determine the actual positions of the vertices that we provided, and I'll show you how we describe those positions within an array itself. We pass this typed array into a buffer attribute. So we're going from JavaScript to three JS at this point. Because a typed array is just a JavaScript object.
03:07:45.776 - 03:08:29.006, Speaker B: But now we pass it into a buffer attribute which is a three G's object and we're going to store this information inside the buffer attribute. Finally, once we store that information inside the buffer attribute, we're going to set the position of this actual buffer geometry. Sorry, I wrote that wrong. We're actually going to set the position property of the buffer geometry using that buffer attribute. So with all that said, let's go ahead and implement it. And hopefully by going through this one more time in the code it should provide you with a better understanding and we should go ahead and actually just start to create this ourselves. Let's go ahead and start by defining the actual array that we're going to go ahead and pass into the buffer attribute.
03:08:29.006 - 03:09:01.016, Speaker B: Again, we need to have an array and that array is going to store information about the position of our vertices. So we're going to actually call it vertices because that's exactly what it's defining. And we're going to create a new float 32 array because that's the array that we want. The float 32 array is going to take an argument being that array itself. And then here we're going to start to define what we actually want those positions to be. Before we can do that we actually have to know what we're trying to draw. Let's go ahead and actually draw this out.
03:09:01.016 - 03:09:45.520, Speaker B: So right here I have a cartesian plane, or I just basically just have a grid for us. I have the origin points and I've actually just denoted measurement points on the actual y and x axis. You will notice that this is in 2d. So we aren't creating a 3d object, but it would be a similar exercise with a 3d object. The difference is for us because we're creating it in 2d, but within a 3d space, the z position that we're creating, because a position takes an x, y and z coordinate, the z position that we're creating is actually going to be zero. But for us, let's just go ahead and create a 2d triangle for beginners. And let's say we wanted the 2d triangle to look something like this.
03:09:45.520 - 03:10:42.782, Speaker B: If we wanted to create a triangle like this. Well, the actual positions of the vertices themselves that we're going to provide to three g's or provide through this array are going to be determined by the values of measurement that we see on this plane. So we can see that there is a position at zero zero. So that's going to be one of our first vertices is actually going to be at zero zero itself. Then we see another vertices up here at y equals zero, at x equals two. Because we denote our vertex positions by x, y and z in that order we know that the x position is zero, the y position is two and then finally we have another one vertex where we're going to tell it that the actual x value is two and the y value is zero. Now we're going to use this information to pass it into the array and luckily for us we don't actually have to specify any order to provide the actual vertices.
03:10:42.782 - 03:11:29.544, Speaker B: The only order that we have to respect is the order of the numbers within each vertex position itself. So we can't pass this vertex as zero two, we have to pass it as 20. And then similarly for all of these other vertices, as long as you go ahead and actually just pass in the correct order of the x, y and z positions within each vertex, you can arrange them in any wish way. So I can go ahead and actually say that we want to pass this position in first, then this position and then this position. And when I say position I just mean positions of the vertex so we can do it in that order. So knowing that, let's go ahead and specify it. And again, I worked in this 2d space, but within our 3d space we actually have to provide it with a z coordinate as well.
03:11:29.544 - 03:12:00.726, Speaker B: For us that z will be at zero. So we're going to provide it with the first vertex, zero, zero. The next vertex we're going to provide it is going to be, you can see here, zero, 20, so zero, 20 and then finally the last vertex is going to be 20, zero. And I could have passed this in any which way. I could have passed this like this. That would have worked as well. There's no issues there obviously.
03:12:00.726 - 03:12:26.338, Speaker B: Like I'd get rid of some of these extra spaces, but the only reason I'm doing it like this is so that we can all see it properly. Let's go ahead and format this. Oh, you can see if I format it actually passes it as one long array. So yeah, you can pass it in any way that you want. And then we're going to go ahead and pass this vertices information into our actual buffer attribute. So let's take a look what the buffer attribute actually takes as arguments. For one, it takes the actual typed array itself.
03:12:26.338 - 03:13:22.370, Speaker B: So perfect. We have a typed array and that's here. And so we're going to pass that in and the next thing we're going to do is actually pass the item size. Now to understand the item size you'll have to understand a little bit about the item that we're passing now the item that we're passing is actually the vertices themselves. And because each vertex takes three arguments, an x and y and a z, then the item size or the size of the thing that we're going to pass it or the size of the vertex is going to be three because they're essentially saying, okay, we're passing you vertices and then each vertices is going to be comprised of three different numbers and that's how it's going to know how to organize these almost seemingly like randomly tossed in numbers into actual positions for the vertex themselves. So let's go ahead and create the buffer attribute. Attribute, attribute.
03:13:22.370 - 03:14:03.976, Speaker B: And then we're going to do new three buffer attribute and then we're going to pass it vertices. So our typed array and then we're going to specify three perfect. The next thing we're going to do is actually go ahead and finally set the position attribute of our buffer geometry. So we still haven't created that buffer geometry. So cost geometry equals new three buffer geometry. We're not actually passing the arguments. What we're going to do is we're actually going to go ahead and set the position of the actual geometry itself by passing in our actual buffer attribute.
03:14:03.976 - 03:14:52.604, Speaker B: So again, the buffer attribute can hold information about lots of different things, including color, including normals. But for us we're going to specify specifically that we're passing in information about the position itself. So let's go ahead and do that by actually doing geometry. Geometry, dot set attribute. And then we're going to pass in position as a string to specify that that's exactly what we're changing. And then we're going to go ahead and pass in the buffer attribute. Then I'm going to save and I'm going to go ahead and refresh and then we currently don't have anything on the screen because we actually haven't specified that the actual cube mesh will be taking this geometry or pass it into the geometry.
03:14:52.604 - 03:15:34.230, Speaker B: And then we're going to add the cube mesh to the screen. If I save again and zoom out a little bit and then maybe turn off the auto rotate, you can see that we finally have a triangle on our screen. So to me that was a lot of work for a triangle. If you enjoyed that, good for you. And I feel like you're going to really love the inner workings of three js and Webgl. But me personally, I didn't enjoy spending that much time just to create a triangle. Luckily for me and for a lot of you who maybe found that a little bit tedious? We will be having access to a lot of three G's primitives or three JS shapes and geometries out of the box that we can use, and we're going to go ahead and explore that next.
03:15:34.230 - 03:16:45.908, Speaker B: But now that we've drawn our own custom geometry, I think it'll be fun to now explore the different types of geometries that three G's supports. Out of the box. Out of the box. It's funny because the first thing that we're looking at right now is the box geometries, but this is just one of the many different types of geometries that three J's actually lets us use and implement very quickly. And to get a comprehensive list of everything that we have available, you can actually just go to the left hand side of the documentation and you can actually just search up geometry and you can see find that comprehensive list of everything that we can create without having to specify the individual vertex positions. So if we go to box geometry, you would obviously recognize that as being the geometry that we started the course with. And you can see that we actually can create the box geometry with the three width, height and depth arguments that we've provided.
03:16:45.908 - 03:17:34.846, Speaker B: But as well, there are three other arguments that we need to look at, one of them being the width, the height and the depth segments. So it's basically the same arguments that we provided previously, but instead of just specifying the length of it, we're actually specifying the amount of segments within it. To get an understanding of what you're changing when you change the actual segments, you can actually take a look at this fun little gui that three GX actually provides you. And this gui exists for basically every geometry that they provide you. So you can actually see specifically what you're changing for the box geometry. When I actually do go ahead and increase the width segments, you can see that I changed it from one to two. What's actually happening is that I'm actually changing the amount of triangles that constitute the actual cube itself.
03:17:34.846 - 03:18:32.146, Speaker B: So if I specify this, if I create a much higher number, what I'm essentially doing is I'm saying, I'm telling three js to create this cube with a lot more different types of segments. And immediately it doesn't seem like it's doing a lot for the actual box geometry, but for something like capsule geometry, increasing the amount of segments actually increases the precision of the shape itself. It's becoming more and more smooth. So you can see with something like segment of one, you can see that it's just this really boxy, low poly capsule. Doesn't really even look like a capsule, but with more and more segments, what you're doing is you're creating, you're increasing the precision or the smoothness of the actual geometry itself at the increased cost of performance. If you don't know already, the more triangles that your computer has to draw, the worse off the performance going to be. Something like this isn't going to immediately destroy your performance, but it is something to be wary of.
03:18:32.146 - 03:19:20.494, Speaker B: So try to get it to a point where you're comfortable with the way that it looks without having to specify an arbitrary large amount of segments. You can see something like circle geometry as well, or maybe even better, something like the sphere geometry. You know, the width segments and the height segments are going to determine how much this looks like a disco ball. So if I have a really high height and really high width segments, you can see that as it becomes a lot smoother. But the less of each I have, the more it looks like this blocky sphere that we have. So, you know, I think the fun exercise would just be to play with these yourself and to see, you know, what types of geometries that we have at our disposal as well. What I'm going to do is I'm just going to go ahead and just run you through a couple examples of the code.
03:19:20.494 - 03:20:08.158, Speaker B: So we have the actual geometry itself, and then let's go ahead and actually specify the with segments. So by default they're one, one and one. But let's go ahead and specify them two, two and two as additional arguments onto the actual cube. And you can see now, instead of our one face being comprised of two triangles where we had that here, now you can see our one faces comprised by two triangles in this example where I go ahead and add three more arguments, it's now comprised of eight. And the reason why we've doubled it, but it's not four, is because we're doubling on the width and we're doubling on the height. So we're multiplying two by two, which gets us four, and multiplying by two again, which gets us to eight. So that's the height, width and depth segments.
03:20:08.158 - 03:20:41.736, Speaker B: The next thing I want to do is maybe just like try a few other geometries. So for example, Kant's geometry equals new three. I like the sphere geometry, and the sphere geometry takes an argument about the radius, and then it takes an argument about the width and the height segments that I specified earlier. So let's provide it eight and eight and see what that looks like. So that isn't as circular as I would like it. So perhaps I would go ahead and increase this to 16. And again you would.
03:20:41.736 - 03:21:13.760, Speaker B: Oh, I provided way too much height segments, so something like this would probably be good enough for most applications. And again, I'm getting all of these arguments from this documentation itself. And then another one to try is maybe the plane geometry. This is something that I use often, equals new three plane geometry. So essentially just a 2d plane, which takes arguments about the width and the height and as well as the actual segments. So it's one by one by default. But let's set it to two by two.
03:21:13.760 - 03:21:35.912, Speaker B: And then this is just like a 2d plane. But often, like, if you were to set this as the ground or as a wall, you may use this. And then maybe as another example, we do something a little bit crazier. Taurus. This is ridiculous. Taurus dot. Like, I don't know why this is a primitive, but, you know, let's go ahead and implement that.
03:21:35.912 - 03:22:05.510, Speaker B: So we could do const, geometry equals new three dot torus, not geometry. And then the arguments we're going to pass, it is the actual arguments that we see in the example, because not too familiar. This isn't something that I use very often. I'd be surprised if it is something that you use often, but I. We'll pass it. Ten, 3116. So you can see I'm getting that from here.
03:22:05.510 - 03:22:25.062, Speaker B: So let's go ahead and save, see what happens. Okay. I mean, if this is something that you enjoy looking at, sure looks pretty cool, though. But, yeah. So this is, you know, what I recommend you to do. I'd recommend you to just like, take a look at the documentation, see what you could implement. There are, for example, more than one type of sphere you could implement.
03:22:25.062 - 03:22:46.564, Speaker B: I actually like this. This is called, basically called an icosphere. So to me, this is more visually pleasing than the one that they just call sphere geometry. And there's lots of other shapes and primitives that three just supports out of the box that I suggest you take a look at. But that's our lesson on geometries. And in the next lesson, we will dive deeper into textures and materials. And I hope you're excited for that.
03:22:46.564 - 03:23:45.606, Speaker B: So let's go ahead and dive right in. I'll see you in the next lesson. Okay, so in this lesson, we'll be learning all about the three j's, materials and the different types of three g's, materials and their different properties, how they change the way that a mesh looks. So you can see in this diagram that we have a three just material as well as a geometry. And both of them go ahead and actually determine the way that a mesh looks. So I'm sure, as you may have realized from the last lesson regarding the actual geometries, the geometry impacts the shape of the mesh versus the material impacts the way that the mesh actually looks on the surface of that mesh. So, for example, like the color of it, the shininess of it, the different patterns on it.
03:23:45.606 - 03:24:44.732, Speaker B: And it's also important here to make the distinction between a material and a texture. So in this lesson, we'll be covering the material, but a texture is actually something that's technically separate. It's part of the material, but it's only one part of the material that makes up the way that the end material ends up looking like it's not the same concept. And I'm sure if there's probably a decent amount of people that aren't as familiar with, perhaps the game industry or the 3d art industry, and those two concepts may kind of be jumbled into one. But I think it's going to be important for us to make the distinction between a material and a texture. And actually, if we go into three JS's own documentation, you can see that we are at the documentation for one type of material that they provide us, which is the mesh standard material. And you can see that we can actually play with the different properties of this material, but also recognize the fact that there is actually no texture here to play with at all.
03:24:44.732 - 03:25:14.540, Speaker B: There's no texture in this material. Material can stand on its own. It doesn't need a texture. And the material itself would define the look and feel of the object itself. But you can also add a texture to further add more information about what could be on the pattern of this material. And I think the best way to illustrate the difference between the material itself and the texture within the material is to actually look at some exotic car wraps. So let's go back to this example.
03:25:14.540 - 03:26:02.534, Speaker B: First of all, I really don't know why you would do this to a nice car, but let's say you wanted to fashion your car with some type of wrap. Well, you can see that there is a skull, and then there's some type of. Maybe it's like a pedal design or something that's basically, there's a pattern on this car, and that's going to be dictated by the actual texture itself. So you can see that there's like some types of patterns, there's like some type of signature or some type of words there. And that's going to be fed into the material as a texture to define how some of those patterns actually look. Now, the material itself is going to determine other parts of the way that the car looks, including the actual reflectiveness of the car, how shiny it is, or versus how matte it is. Here, I can give you another example of another type of wrap.
03:26:02.534 - 03:26:33.000, Speaker B: But this is like a matte wrap. And that mattness or the inability to reflect light is going to be a property of the material itself that's separate from the texture. Now, I'm sure you can imagine that there's a version of this type of wrap that has the exact same pattern. So it may have the exact same texture, but it's matte. And in my opinion, it may actually look better. I kind of like cars that are matte. I like that type type of look and feel, but that Matt ness or that lack of reflectivity is actually a property of the material itself and not the texture.
03:26:33.000 - 03:27:49.390, Speaker B: So in this lesson, we'll be talking all about the actual materials. And then the next lesson, we'll talk about how textures, how we load textures, how we import them and feed it into the material to further augment the way and further customize the materials that we have. When I talked about materials and the distinction between materials and textures, I made reference to a lot of different properties and materials, such as, like, the roughness of something, the reflectiveness, how shiny it is, how matte it is. And if you know anything about virtual environments or different types of virtual rendering engines, you may recognize the fact that these are all properties of materials that respond to light. For example, if I were to talk about a shiny object, if there were no lights in the room, there would be nothing to shine. If you turn off all the lights in the room, the level of shininess of an object really doesn't matter. And another thing that you may have realized all the way up until this point of the course is we actually haven't been using any lights in our scene.
03:27:49.390 - 03:28:13.862, Speaker B: We've actually been using a material that is just a solid red color. It really doesn't respond to any different types of lighting. It doesn't look different. At least the material doesn't look different from different angles. And that's because three js actually has two, at least in my mind. I like to classify them as two different types of materials. And one type of materials are the non environment reacting materials.
03:28:13.862 - 03:29:02.262, Speaker B: And this is by no means an exhaustive list of all the different materials in three GS these are just some common ones that I'd like to break apart in terms of, that I like to classify in terms of their ability to respond to the environment and their lack of ability to respond to the environment. And what we've been using so far is you may recognize the actual mesh basic material. And as the name implies, basic just means that there's really not much you need to do. You could just throw it into the scene, you could look at it from any angle, doesn't have to have any lights, and it'll just look the way that you intend it to be. If you set it to green, it'll just be one solid color. Now, different materials can coexist in a scene, so you can have material that response to light. In an environment with another material that doesn't respond to light, it may look physically inaccurate, but in different scenes it's going to depend on the context.
03:29:02.262 - 03:29:51.330, Speaker B: And you can go ahead and mix and match them however you want. But the distinction is important that there are some materials like the mesh basic material, the mesh matcap material, as well as the mesh depth material are all examples of materials that aren't going to respond to like stuff like lights and shadows that you throw at it. Now on the other hand, or the other types of classification is for the actual environment or light reacting materials. And the way that I've actually depicted them here is I've actually depicted them on a spectrum of graphical accuracy. And another way to say that is things on the left hand side will look more fake and the things on the right hand side will be more physically accurate. Now that's not to say that 1 may look better than the other. There are lots of different art styles that don't need to be physically accurate.
03:29:51.330 - 03:31:05.536, Speaker B: But if you are going for physical accuracy as you progress through the different types of materials, or as you start using materials further on the right hand side, like the mesh standard material and the mesh physical material, you'll have more control over properties about materials that may exist in the real world. So, for example, in the real world, different materials have different roughness. They may also have different levels of metalness or shininess. And those properties are properties that you'll be able to change on the mesh physical material, but for example, you wouldn't be able to change that on the mesh Lambert material. Now, obviously there is some type of trade off to this graphical accuracy because otherwise we would just all use mesh physical material, and that trade off being the actual performance of your application. So if you had like 1000 different objects with all using the mesh physical material that would obviously perform worse than 1000 different objects, all using the mesh lambda material, and that the feel or the performance distinction is going to be very apparent on some lower end devices, like some mobile devices that you may be trying to create your experience for. So that's a high level summary of the different types or the two main classes in my head of three JS materials.
03:31:05.536 - 03:32:08.424, Speaker B: And then within the actual environment reacting materials class, you can see that there is a type of spectrum with regards to how physically accurate a material looks. Now let's go ahead and jump into the code and see how we implement this in three JSD. All right, let's get started with the code. As always, on the left hand side you will see that I have my starter pack, and on the right hand side I will actually just have the experience and then we can go ahead and jump right into the material. Now, the way that we've been creating this material previously is we've actually just been creating a mesh basic material, and we've been provided with an object which holds a property of color. And then we've been just setting the color as a string. So this is one way to set the color is actually to use the hexadecimal code as well.
03:32:08.424 - 03:32:34.198, Speaker B: Previously we were actually just specifying as red, so we can do that as well. In this case, I just wanted to change it up. So let's go ahead and specify it as green. And I think that it was actually lime green before. And I want to illustrate here that this is one way for us to actually set the properties of the material itself. So a color is one property that we can provide. Another property that we can provide is actually something like transparent.
03:32:34.198 - 03:32:59.930, Speaker B: So transparent is a boolean property. So we can go ahead and set that to true. If I set it to true, it doesn't automatically just become transparent. What we actually have to do is we have to do set an opacity. So I set the opacity to 0.5. You can see that it loses a little bit of its color. And the reason why we can't tell the difference between an opaque or transparent object here is because we actually have nothing around it to show.
03:32:59.930 - 03:33:32.460, Speaker B: So let's go ahead and actually create another object. We're going to use the same geometry. At this point, I want to reinforce the fact that we can pass the same geometry to different objects. So let's go ahead and do that. So we're going to do const, mesh two equals mesh equals new three mesh geometry and material. So I'm actually using the same geometry, same material, but I'm actually just going to change the position itself. Mesh to position x equals 1.5.
03:33:32.460 - 03:33:54.960, Speaker B: And let's place that on the screen. And then we also have to add it to the scene itself. So I actually forgot to do that. But that's another lesson. You can't just create the mesh, you also have to add it to the scene. So now you can see, because of this opacity property, we can actually kind of see right through it. And this is a way to pass arguments into the actual material.
03:33:54.960 - 03:34:26.320, Speaker B: But I also want to show you that this is actually just one way of passing material. What you can actually do is you can change properties of the material after you instantiate it. And the way to do that is instead of setting the some of these properties within this object, what we can do is we can do material dot transparent equals true. And then we're going to do material opacity equals 0.5. And we can set that after the fact. And you can see that that still works. Now the one thing that's going to be a little bit different is the color.
03:34:26.320 - 03:34:56.546, Speaker B: So you can see if I actually just go ahead and change the color to do material, or if I set the color after the fact equals green, or in this case lime greenhouse. And I go ahead and save. And actually delete this and go ahead and save. You'll see that we get a block screen. And the first thing I like to do when I get a black screen is actually go ahead and check the errors. And I check the console. And you can see that we actually don't have anything logged out.
03:34:56.546 - 03:35:36.078, Speaker B: There's nothing immediately that jumps out to us in terms of what's wrong. And I'd like to point out that this is actually an exception. And you can see if we actually go into the three js documentation. You can see that there is an exception here regarding the property color, which by default is a hexadecimal string that is white by default. And that the color dot set color is actually called internally. So whatever you actually pass into this argument, whatever color you pass, there's actually a color dot set which is actually being called. And this color object that has this dot set method is actually a three gsobject.
03:35:36.078 - 03:36:21.770, Speaker B: And the way that we actually go ahead and add it to our material is we actually go ahead and do new three dot color and then we can pass in whatever we want. Basically we can pass in the same string that we did previously. So now I can add it back and now you can see that we have the reduced or we do the lime green. And additionally we can also use hexadecimal. So if you just use any type of RGB color selector, you would often see some type of hexadecimal code that specifies a color. So for example, I know that ox and you can pass it in without these brackets, zero, x, and then provided the hexadecimal. So I know ff, zero, zero.
03:36:21.770 - 03:37:00.826, Speaker B: That'll give us red cubes. A green would be zero, zero, ff, and that would give us the green cubes back. And this is just, if you just search up hexadecimal string, or if you go to any color selector and you pull the hexadecimal, you can pass it in as a color argument. So I went ahead and quickly just introduced you to this transparent property. I also introduce you to the opacity property. But as with any type of three js class or concept that we play with, we want to go ahead and actually log it out. Or alternatively you can go into the documentation, but we want to log out the material as one way of actually having access to those properties.
03:37:00.826 - 03:37:35.966, Speaker B: So you can see this mesh basic material has all of these properties that we can play with, and one of them was the actual opacity itself. You can see we have the opacity. We also had the transparency. And then once again, I think it's also good practice to actually go into the documentation to see what we can actually change. You may be familiar with the fact that, remember, when we actually looked at the properties for the mesh, we couldn't find the scale, we couldn't find the position. Similarly, there is no reference to transparency, at least in stock. There also is no reference to opacity.
03:37:35.966 - 03:38:29.306, Speaker B: And that's because our mesh basic material inherits a lot of or some of its more basic primitive properties from the material class itself. And this material class will actually have some inherent primitive properties that will be inherited by like the mesh standard material, mesh physical material. Basically, all the materials in three js will have these very, very standard properties. And those standard properties, I'm sure you can imagine being transparent and opacity, regardless of what type of material you have, there is this exact same opacity property on that material. So you can see if I go scroll down now, if I go to opacity passive, you can see that there's an opacity property as well. There's actually a transparent property. So you can see there's transparent, it's a boolean and it's a true or false.
03:38:29.306 - 03:39:16.500, Speaker B: And another property I'd like to show you that it's important is actually the side property. And the way to show you why this would be important is if I actually go ahead and create a new geometry called const plane geometry geometry. And I create a new plane with the arguments of one and one. And I use the same material. But now I'm going to do const plane equals mesh plane geometry, but the same material. I'm going to go ahead and actually reorganize this code a little bit so that we separate out the position arguments. So I'm going to do plane position x equals negative 1.5.
03:39:16.500 - 03:39:50.510, Speaker B: And then we're going to go ahead and add that to the scene. So let's go ahead and add it to the scene. And now if I actually go ahead and turn the camera around behind the actual plate itself, you can see that actually disappears. And the reason for that is because three js actually by default has one sided materials. Now luckily for us, there is an easy way to change that. We can actually go ahead and change that by changing that side property. So it'll do material side equals three dot double side.
03:39:50.510 - 03:40:24.410, Speaker B: And if we can go ahead and look behind it now, we can see that it works on both sides. Now a couple quirks to call out. For one, you may wonder, why is it only for planes? Well, it's because for a cube, the backside of the cube is actually the inside of the cube. Everything else is technically its front side. So that's why you can see a cube from all angles or the box from all angles. But the plane geometry, the actual backside, is just right behind it. Secondly, you may realize that we actually didn't go ahead and call new double side like this.
03:40:24.410 - 03:41:06.996, Speaker B: And the reason is because this is what we call a three j's constant. So a three js constant isn't like a class, not like this box geometry or this plain geometry. These are classes from three js that we can actually instantiate and we can actually call methods on and we can access the properties. If we go ahead and I just console log, three double side, and I can get rid of this log right here. If I just log that out and pull up my console, you can see that it's just two. So basically what we're returning when we call three double side is actually just the integer too. So if I should just set two on material outside, that actually just works just as well.
03:41:06.996 - 03:41:45.210, Speaker B: And the reason why there is this constant is basically it's just three jS's way of making sure that it's convenient. So you don't have to remember that to make it double side, we have to set the material side to some arbitrary integer. Instead, we set it to this constant that three js provides us. Essentially, it's just storing this number in a variable so that we could just pass three dot double side and not have to, you know, check in the documentation. Like, what's the front side? Like, what number is the front side? In fact, I don't actually know. I mean, it's probably zero or one. But instead, if I just went ahead and just wrote front side, you can see now we don't have access to the back.
03:41:45.210 - 03:42:25.452, Speaker B: So that's just a quick intro to three JS constants. And if you ever see it, that's why we don't actually instantiate it. Now, we just took a look, and so actually. I'll keep that. We actually just took a look at the properties within the material itself, but now we can actually go back up a level and we can actually look at the actual mesh basic material. And so some of the properties of the mesh basic material, the important ones to go through, one of them being the color that we know about, but the next one is actually fog. And fog is pretty interesting because it'll give us an opportunity to play with our scene in a way that we still really haven't.
03:42:25.452 - 03:42:51.248, Speaker B: Currently, we've been using this black background environment, and if you're like me, you may be starting to get sick and tired of it. So let's go ahead and introduce the idea of fog. Fog itself is actually a three js class. And you can do fog by actually. By doing const. Fog equals new three dot fog. And then we set a fog color.
03:42:51.248 - 03:43:20.996, Speaker B: So in this case, it'll actually be white. So I know that white is going to be ff or, sorry, fff. And then we're going to set a near and a far property. So this is going to be. This near and far property is going to be similar to the way that we think about the camber, near and far. And is basically, we're going to create a fog in our scene. And the earliest that you're going to be able to see the fog, or the closest you're going to be able to see the fog is at one unit of distance.
03:43:20.996 - 03:44:01.824, Speaker B: And the thickest that the fog is going to be where the fog is going to be at 100% thick, so you can't see anything, is actually going to be at ten. And the way we add it to the scene is we actually do scene fog fog. And let's go ahead and save and see what happens. So you can see now we have, if we actually go ahead and zoom out, you can see that the actual fog itself fogs up all of our material. So let's go ahead and actually remove the opacity and the transparent. And you can see, as we get further away, our objects get clouded in fog. However, this looks a little bit weird because essentially what's happening is we're just turning our objects from green to white.
03:44:01.824 - 03:44:44.740, Speaker B: Nothing's really that gets this black background is really difficult to see what's actually going on. So this is the first time we're actually changing the background, and we're going to change the background by doing a scene dot background. So we're just changing a property of the scene itself. And, like, the way that we actually created the color here and we assign it to the material color property, we actually have to provide the scene dot background with a color by calling this new three dot color class and then create setting that color to white. So now I don't believe that this is working properly if I set this to white. Okay. So you can see that that worked for some reason.
03:44:44.740 - 03:45:07.760, Speaker B: Okay. I think it was just. It didn't like the fact that I was adding capitals. So now, to me, this is a much more intuitive fox. You could imagine if you had objects in a very foggy environment. You can see that the closer it is, the easier it is for us to see it. So I can actually only see the actual cube in front of us and the objects behind we can no longer see.
03:45:07.760 - 03:46:09.704, Speaker B: And then the further it gets away, the more shrouded in fog it becomes. Now, the reason why it's important, I mean, the reason fog is important at all in this material lesson is because there actually is a fog property on our material. And by default, our fog property is actually set to true. If we actually go ahead and set it to false, you can see that our objects no longer fade out as they fall into the fog that no longer exists. And this property of fog, if we actually remove it, or better yet, if we set it to true to explicitly show you what's going on, then you can see now it gets clouded in fog. So that's the mesh basic material. And if we go back to our diagram of some of the more common three JS materials, you can see that there's also the mesh maca material, as well as something called the mesh depth material, mesh macam material we'll actually cover in the following lesson about textures, because we will be required to actually pass it a texture.
03:46:09.704 - 03:46:49.648, Speaker B: And then the mesh depth material is just another example of a three G's material that doesn't respond to light. But in actuality it's not used. I mean, I haven't seen too many cases where it's used in practice. It's just a material where the depth determines the actual color of the mesh itself. And so the closer you get to it, more white it is, the further you are from it or the closer it is to your camera far property, the darker it becomes. And these are just some materials that you can actually go ahead and look into the documentation for and just like, play with some of the parameters. But it's not something that we are going to dive into in this course because there's not too many use cases.
03:46:49.648 - 03:47:54.552, Speaker B: There are a lot more use cases for the actual materials that react to the environment. So let's go ahead and jump into those in the next lesson. All right, so this part of the lesson is going to be working with the actual environment, reacting materials in three GS. And as I've alluded to previously, we're going to start with the left hand side and start working our way up to start adding more and more properties. And that's essentially what happens with this three J's materials, at least from left to right, is that we start off with a very basic material and then we start adding on more properties that we could actually use to add more physical realism to our scene. So let's go back to the project. I'm going to take off the information about the fog and the background and the material.
03:47:54.552 - 03:48:18.960, Speaker B: We'll go back to the basic material. It'll be a white material against a black background. If I did it properly, that's perfect. Then let's go ahead and explore our first material. So the first material that we actually are going to start with is actually the mesh Lambert material. So this is actually the cheapest material, but it also has the least amount of parameters that we can play with. Let's go ahead and save.
03:48:18.960 - 03:48:51.540, Speaker B: And immediately you can see that there's nothing in the scene. And you should expect this, given what we know about the actual material itself, is that it requires some information from the environment. And specifically, it's going to require information about the actual lights. So let's go ahead and actually create that lighting. Initialize the light after we created the material itself, and you can actually do it before the material. There really is no distinction here, but let's start off with a very basic light. And there is going to be a subsequent lesson about lighting.
03:48:51.540 - 03:49:31.162, Speaker B: So I'm just going to go through this very quickly and just create something called an ambient light, which takes an argument about the color. So let's do a white color. Let's do an intensity of 0.5, add it to the scene just like any other 3d object. Lights have to be added to the scene and you can see, boom, we have lighting. Now, if I go ahead and actually increase the intensity of this light, you will notice that there's really no difference right now between a mesh basic material and the mesh and the Lambert material that we're using right now. And that's because ambient light really isn't an analogy for an ambient light in real life.
03:49:31.162 - 03:50:16.358, Speaker B: Because there's nothing in real life that lights all parts of the scene equally. You know, in real life you have lights that exist as maybe like a lamp. And that light is going to emit from all directions but from a source. Ambulate, on the other hand, is basically saying, well take everything in the scene and just raise the actual luminance values. And that doesnt actually exist in real life, but it does exist in three js because we can basically just look at every parts of the material and equally light them. And because of that, because every part of this material is equally lit, youre not going to be able to see any distinction between the front and the back as you would if we had some light that was pointing towards it from the front. So let's go ahead and simulate that type of fake light.
03:50:16.358 - 03:50:47.458, Speaker B: We will still keep that ambient light because, you know, in real life, light bounces all across your scene. It bounces off walls. So just because you have a light in front of someone, it doesn't mean the back is going to be completely black. But in three GS at least, because there's no lights to bounce off of this, not a ray traced scene. If we only have a light in front of it and nothing behind, that object will be completely black. And that's not something that we want. So we want to add some artificial ambient lighting to make sure that it gets lit from all sides at least a little bit.
03:50:47.458 - 03:51:19.124, Speaker B: So let's go ahead and create a point light. And a point light is just like any other three js object. So we can create the point light by passing in a argument for the color and the actual intensity. So let's set that intensity to one. And it's like any other three js objects such that I can actually just set the point light dot position position dot set. And then I can pass it three arguments. So I'm going to set it to two, two and two.
03:51:19.124 - 03:51:53.724, Speaker B: Just to have something that's a little bit to the right, a little bit up, so that we kind of get this light shining down from an angle. And let's go ahead and do scene dot add point light. So now you can see that there is now a distinction between the different sides. So you can actually see some type of depth to this. Let's actually bring this point light out further so that it's coming from the right side of all the objects. Because I believe the scene, this cube right now is set at 1.5. So two would be set, like right here.
03:51:53.724 - 03:52:16.062, Speaker B: So let's set it to five. Five and five. So it's coming from above to the right and closer to the camera. And let's go ahead and actually set the ambient light to 0.2 so that now you can see. Okay, so there's a light that's coming from up here and everything behind it will be a little bit darker. So here you can see that there is a material.
03:52:16.062 - 03:52:58.874, Speaker B: It does respond to light. But what I don't like about the scene currently is actually, we just have a few very, very flat surfaces. So you really won't see the effect that some of this lighting has on some of the smoother surfaces that will be able to bounce light more accurately. So let's go ahead and actually create a new material. I know in the previous lesson I actually was roasting that Taurus knot. I'm like, when are you ever going to use this? Well, we're going to use this in this lesson because I think it gives us a pretty good depiction of how different materials will react in different surfaces. So let's go ahead and create the torus not geometry, by doing new three dot Taurus, not.
03:52:58.874 - 03:53:33.368, Speaker B: And there's. I'm just going to pass it. Some arguments that I found work for me regarding the actual radius and the tube. So this is not something I do often. So I just kind of wrote this down in terms of like, I don't really use a torus knot in any other scenario, but we're going to make sure that we're actually going to pass this torus knot into the mesh two geometry. And then if I go ahead and save, you can see now I have a little bit of a better depiction of what happens with this mesh Lambert material. So you can see it's looking all right.
03:53:33.368 - 03:54:21.308, Speaker B: It still looks like, you know, CGI from a nineties movie, but you can see how there is different parts of the surface that responds differently depending on, you know, the proximity to the actual light itself. But you'll also notice that the lighting itself is kind of crude. You can see, at least with the smooth surfaces of material, you can see a little bit of some like artifacting, how there's a little bit of banding. And with better, more expensive materials, you can actually get rid of some of that look as well. There's not really too many parameters. You can't actually specify how rough this is or how shiny it is. And changing from the mesh Lambert material to the next least expensive material, mesh file material, actually gets us access to a property called shininess.
03:54:21.308 - 03:55:04.184, Speaker B: So let's go ahead and actually change this to a mesh fall material. And it's basically another type of material that's very cheap as well. But now if I go ahead and save it, you can see a little bit, just a tiny bit of glimmer on it. Let's go ahead and actually change that property or increase that property so we can do material shininess and then we can set it to something like 90, for example. And you can see that this is a little bit shinier. But I think the best way to illustrate this is if I actually went ahead and just created menu options. So I actually went ahead at the start of the starter, created a pane we haven't accessed until now.
03:55:04.184 - 03:55:51.490, Speaker B: But if you recall from our actual Gui lesson or a lesson about tweak pain, you can do an add input method to the pane and then it takes the actual object that we're trying to change. So it's going to be material and we're changing the shininess property of that material that we're going to specify a min, we're going to specify a max and we're going to specify a step. So I'm going to go ahead and save a. Now you can see that we can actually play with the shininess parameter. And I think the reason why we don't really notice a difference is because our point light is a little bit intense. So if I go ahead and actually set this to maybe something like 0.3, you can see by changing the shininess parameter, you can see that the closer it is to zero, the more dull it looks.
03:55:51.490 - 03:56:37.682, Speaker B: So this is that distinction between a glossy and that matte look. You can see the closer it is to 100, the shinier it looks. That's what going from Mesh Lambert to mesh Phong gives us. It actually gives us one more parameter to play with. So that we can have some materials that are shiny in our scene, and some materials that are more matte, like the mesh basic material. Mesh Phong and Mesh Lambert both have color property, so you can still set the color, and that doesn't override any of the actual existing material properties that you've already provided it. So let's say we wanted to pass it red color, instead of setting the entire mesh as a solid red color like we did in mesh basic material.
03:56:37.682 - 03:57:41.072, Speaker B: If you set a mesh phong and a mesh Lambert to a red material, it'll still inherit the same light responding properties of the material, but it'll also just set red as that base color. Now, the next material that we're going to look at is the actual mesh standard material. And the reason it's called the mesh standard material is it actually inherits a lot of different properties from industry standards. And for that reason, it's going to be pretty hands on. So I'm going to dedicate that to its own lesson. So the next lesson, let's dive straight into the mesh standard material and explain why it's so important and why it's so commonly used. Alright, so to understand the mesh standard material, we first have to understand something called pbrjtainde.
03:57:41.072 - 03:58:45.596, Speaker B: And now PBR stands for physically based rendering. And it's basically a way to create 3d graphics and animations based on the principles of physics, such as the law of light and materials, to simulate the way that light interacts with different surfaces. So previously, when we're using Mesh Lambert and Mesh Phong, those were different types of rendering models that tried to simulate the actual look and feel of lighting in different environments. However, PBR basically just takes it a step further and tries to apply different principles of physics into the actual look and feel of the end result. And that's where the physical and physically based rendering comes from. Whereas Mesh Lambert and Mesh Fong weren't necessarily physical approaches, there are more like mathematical approximations. The PBR workflow tries to simulate the way that something like roughness and metalness interacts with light in the real world, to help you get closer to realistic looking scene, as if you were to see it in real life.
03:58:45.596 - 03:59:58.852, Speaker B: Now, the best part about PBR is that, at least in my opinion, is that it actually has become the industry standard in many 3d applications. So here they provide us with unity and Unreal, which are both very popular game engines, and then 3D Studio Max, which is a type of 3d modeling software created by Autodesk, which also makes Maya, which is a very popular 3d modeling software for animations and also character animations as well. Blender also has its own implementation of PBR. So because this is the standard across many different applications, the types of properties that you are going to use in these 3d modeling softwares actually translates across into the mesh standard material. So, for example, if I'm creating a PBR type of material in blender and actually export it as a GLB, and I bring it into three js, well, the mesh standard material is actually going to recognize some of those channels, and those channels being the metallic and the roughness channels. And it's actually going to display the actual model in three GS, very similar to the way that it looks within blender. So you can see that if we actually take a look at the examples.
03:59:58.852 - 04:00:39.756, Speaker B: So this is a model that is using physically based mendering, and it's using the mesh standard material as a material itself. And you can see that this gets us pretty close to like, real. You know, obviously, there's a few more things it needs to have before I can mistake this for a real gun in real life. But you will notice that this just reflects the environment as if it was in a real environment. And as well, it has proper roughness, it has proper metalness. And so that's basically the power of mesh standard material, is that it lets us use PBR workflows. And these PBR workflows are very powerful workflows that let us approximate how light works in real life.
04:00:39.756 - 04:01:17.890, Speaker B: And it is also the industry standard across many different types of 3d modeling software. So to get started with the mesh standard material, let's go ahead and actually get rid of our input for our shininess. Let's get rid of our actual mesh font material, and let's instantiate the mesh standard material. And then I'm going to go ahead and just call it just like that. So by default, it's white. We can go ahead and actually set the color to really green. Just for fun, the new three dot color green.
04:01:17.890 - 04:02:04.680, Speaker B: Now, with PBR workflows, it's going to be important for us to pass information about the actual roughness and the metalness. And now for us, that information, at least in this lesson, is going to be just between zero and one. So we're going to change those properties like we change the actual shininess properties of the mesh phone. However, in the next lesson, I'll show you how we can often encode some of that information into roughness and metalness maps, which is basically encode them into textures that we pass into the actual material itself. But for this lesson, let's go ahead and just add. We can go to the pane, and then we can add input. And then we're going to change the material object.
04:02:04.680 - 04:02:34.270, Speaker B: We're going to change the metalness property. And then we're going to specify a min of zero, a max of one, and a step of 0.01. We're going to do the same thing for the roughness, roughness. And then let's go ahead and play with those properties. Right now, I believe the scene is a little bit too dark. So let's go ahead and push the ambient lighting to 0.4, push the point light to 0.7.
04:02:34.270 - 04:03:16.790, Speaker B: Then now we have, by default, a very rough material that has no roughness. So let's go ahead and see what happens if I turn down the roughness. So you can see, this is basically like when we were playing with the mesh phone. You know, we're basically getting shininess, and this is basically doing the same thing. But instead of shininess in a PBR workflow, we actually go ahead and use this roughness parameter to change how glossy this is going to look from the outside. And you can see that it actually approximates it a lot better than, at least in my opinion, how it looked with the mesh Lamborghini material or with the mesh phone. If I go ahead and change the metalness, there's no real better way to describe this, aside from the fact that it looks more metallic.
04:03:16.790 - 04:03:58.550, Speaker B: Like, I don't actually know. It's hard to describe the specific way that the light is bouncing off the object. But essentially, I mean, like, I have like a bike lock that looks like this, right? So it's basically just looking more metallic. And let's go ahead and turn up the actual light itself, because the more metalness you have, the, I guess it absorbs light less, and that's what makes it metal, but it also just bounces it off in a very specific way, but also makes your objects look a lot darker. So these are the two properties that we can change with the mesh standard material. There also is something called a normal map that is going to be very important in PBR workflows. And again, we are going to approach that in the next lesson.
04:03:58.550 - 04:04:35.978, Speaker B: And then the last thing that I'm going to show you is actually the mesh physical material. And the cool thing about the mesh physical material, the cool thing about understanding a little bit about the PBR workflow is it actually does everything that the mesh standard material can do. So it has the exact same roughness and metalness workflow. So I can actually switch it out right here by doing mesh physical material. And you can see that these levers or these controls that we have work the exact same. However, there is a couple other properties that are going to be important. And specifically, they are so pain dot.
04:04:35.978 - 04:05:08.766, Speaker B: Add input. Add input. Specifically, they are the clear coat and the reflectivity property. So let's go ahead and try reflectivity. We'll set a min, we'll set a max. We'll set a step, and then you'll see, for one, if I actually go ahead and turn this to Max metalness and I have low roughness and actually change the reflectivity, you see, nothing really happens. And that's because we have high metalness.
04:05:08.766 - 04:05:47.690, Speaker B: We essentially just have the most reflective thing that we can get. However, if you have something with low metalness, prior to having this reflectivity parameter, there wasn't any way for you to get something a little bit more reflective. So now you can see that there is a difference. However, I would argue that you can probably approximate this reflectivity with some type of roughness and metalness combination. But again, at the lowest levels of metalness, you really don't have any way to get any type of reflectivity. And now you could do that with the actual rotation fluctivity here. And then finally, we have something called clear coat.
04:05:47.690 - 04:06:10.930, Speaker B: And what Clearcoat is the easiest way to describe it. I may have spelled that wrong. Yep. The easiest way to describe it is basically like a wax. It's approximating the type of, like, clear coat finishes that you get on a car. And so I hope you can notice the difference between. Yeah, you can see, like there is.
04:06:10.930 - 04:06:45.532, Speaker B: It's almost like you put a, like, reflective gloss over it. And I think that three G's actually does a good example of explaining it. So if you go to clear coat or depicting it, you can see that it's almost like you put this, like, layer of wax over it. And that's just one more parameter that you're going to be able to get with the actual mesh physical material. So those are all the materials in three js that I think are going to be important for us to cover. There are other materials that you can use, and I'm sure you can go ahead and go into the documentation and find. Take a little bit of a deeper dive.
04:06:45.532 - 04:07:50.618, Speaker B: I think you may have fun looking at some of the other materials that you may be able to use. But for us, I think this is more than enough to get started to building out a more robust scene. And in the next lesson, we will talk about textures, which will add a lot more context regarding the different things that we can do with our three JS materials once we start feeding them textures. So I hope you're excited, and I'll see you in the next lesson. All right, so in the last lesson, we talked about materials. We talked about the different general properties of materials that will impact the way that an object may or may not respond to light, how it may be rough, how it may be shiny, the different ways that we can essentially make these surface topology look different to the end user. And now in this lesson, we'll be talking about another part of materials called the texture.
04:07:50.618 - 04:08:28.884, Speaker B: Now, this texture is going to be provided to three js via sub images. We're going to load it. I'll show you the different properties of textures. I'll show you how it maps onto different objects, as well as show you how we can use textures to provide three GS with more information about some of those PBR properties that we talked about in the last lesson, which are the industry standard for conveying properties of an object as it relates to physical light simulation. So to get started, let's do a little bit of practice. Let's go back to our. I have my starter on my left hand side, and then I have the actual application running on the right hand side.
04:08:28.884 - 04:09:07.760, Speaker B: But let's go ahead and start to practice a little bit of our three js by adding a couple more meshes. And we're going to go ahead and make them spin. And obviously, this is just a little bit of setup so that we can see how our textures map onto different objects. But it'll just also give us a little bit of practice in actually setting up three j's objects. So right now we have three objects lined up horizontally. So if I wanted to add other objects, we could add them above or below just so we can take up an appropriate amount of our screen real estate so we don't create objects that are, you know, outside the view of our camera. So another object that I want to add to the scene because I think it'll be useful.
04:09:07.760 - 04:09:43.180, Speaker B: I think there's lots of scenarios where you may be using this type of geometry is actually a sphere. So let's go ahead and actually just initialize a sphere geometry. So we do that by doing const. Sphere geometry. Geometry equals new three dot sphere geometry. And then the arguments we're going to pass, it is the radius of the sphere and then the width and the height segments and the more width segments you provide, it the more detailed it's going to be, but also the more triangles that it's going to use, the heavier it is compute. So I think if we stick to 32, 32 that'll be fine.
04:09:43.180 - 04:10:24.350, Speaker B: And then finally another geometry that may be also useful is maybe something like a cylinder geometry geometry. And then we're going to do new three dot cylinder geometry and then we're going to pass it arguments about the actual radius. So the top radius. So the circle at the top, we're going to provide the radius of that, the radius of the bottom so it doesn't have to be a uniform cylinder. We're also going to provide it the actual height of and then we're going to provide it the amount of radial segments as well. So this is similar to the actual sphere. Let's go ahead and save and then what we're going to do is we're actually going to create these meshes.
04:10:24.350 - 04:10:56.420, Speaker B: So I'm going to do const sphere. And previous to this, you know how you could actually take properties of the material outside of the construction and you could assign it after the fact? Let's do that for our mesh because I don't believe we've actually done that with our mesh. And it's just another way to actually create your meshes. And perhaps it may be a more cleaner way to create your meshes so that you can separate out the actual properties. We want to assign it line by nine. So we've created a sphere and it's a new three mesh. And then what you can do is you can do sphere, dot geometry equals sphere geometry.
04:10:56.420 - 04:11:24.282, Speaker B: And then you can assign the sphere material to the material that we're going to use for all of the different objects. We're going to do the same thing for the actual cylinder. So we're going to do const cylinder equals new three dot mesh. And then we're going to assign it the cylinder geometry. And then we're assigned the material property, the material. Next we're going to go ahead and add it to the scene. So let's go ahead and call scene dot add sphere.
04:11:24.282 - 04:12:20.490, Speaker B: And then another way for you to actually use this add method is to actually add multiple arguments and each argument being a different thing that you want to add to the actual scene. So instead of calling these three times, instead of calling scene, add three times separately. What you can do, and this is up to personal preference. And perhaps you may not find this as clean or as easy to manipulate, but you could actually just add them all into the arguments of one add method. So if I go ahead and remove this and I save, you see the first problem is we actually haven't seen any change or any difference in our scene, and that's actually because we have initialized both of those meshes still at zero zero. So like with the other meshes themselves, we can actually go ahead and make sure that we position these properly so we can do sphere dot position, dot y equals 1.5 and then let's do the same thing here, but instead we'll do negative 1.5.
04:12:20.490 - 04:12:54.286, Speaker B: So let's go ahead and save. And now you can see we have our scene initialized. So what we learned here is that you could actually create a mesh empty with no arguments and then assign properties of that mesh being like geometry and material after the fact. And that's essentially what we've been doing with the actual position property. We're creating the actual mesh itself and then we're assigning the property after the fact. However, you may not have realized that this is also something that we can do with arguments of the actual mesh itself. The next thing we're going to do is we're going to make this a little bit more dynamic.
04:12:54.286 - 04:13:28.684, Speaker B: So I want all of these different meshes to actually rotate. And one way to do it if you wanted to, to brute force it. And because we've learned about this in our animation lesson, if I just wanted to go ahead and do like sphere, I do sphere, dot, rotation, dot y plus equals 0.01. Actually that's not going to be easy to detect. But let's do cube, because if a sphere rotates, you can't really tell the difference. But now if I rotate the cube, that's what that looks like. Another way, instead of having to, you know, call it on the sphere and then the nod and the plane.
04:13:28.684 - 04:14:21.646, Speaker B: Another way to do it, let's say you had a lot of objects in the scene, is to actually access the scene dot children property and then loop through all the meshes and then make them spin within the actual render loop. And so the scene actually has a children properly just like any other object in three g's. So if we actually call console log log scene children, you should see that it's actually an array of different children that exist within the mesh. So if I go ahead and pull out the log and I go to the actual array, you can see that because it's an array. What you can do is you can actually loop through the array just like you would in any other JavaScript application. So to do so we can do scene children dots for each. So for each is just a method array that is provided to us by JavaScript.
04:14:21.646 - 04:15:10.846, Speaker B: There's nothing inherently three j's about this. And that foreach is actually going to take a callback function and then we can pass an argument of the callback function, and that argument is actually going to hold information about each child of that array or each object within that array. If I go ahead and actually log it out, just show you step by step what's happening. If I do console log children and I'm actually going to pull this out of a render loop so we don't get like just, it doesn't have to run 60 times a second. If I actually go ahead and log it out, you can see that what we did is we went through for each of the actual children within the scene, we went ahead and passed that children variable into the log, and so we have access to that children variable within our console. And you can see this is actually just the mesh itself. So this mesh specifically is the sphere.
04:15:10.846 - 04:16:32.502, Speaker B: And so I'm sure you can imagine what we can do is we can actually just go to children, children rotation y plus equals one, just like we did previously. Now if I go ahead and save, I'll mention one immediate issue with this, is that there are lots and lots of children of the scene and some of them might not actually be meshes. So if we want our actual objects in the scene to rotate, what you may not want to do as a side effect is you don't also want to be rotating something like the lights, because if you had a directional light and that was rotating, that may not give you the effects that you actually desire. So in order to actually make sure that we're only rotating the meshes, we can do if child instance of an instance of is a type of operator that JavaScript provides us. So this isn't three GS specific, but we can use it to detect if something is an instance of a mesh and anything that we have on the screen that's a mesh, regardless of the geometry, we know that it's a mesh. So because we want to rotate all the meshes, if it is a mesh, then we can do child dot sorry for each, instead of children, I'm going to name a child, and then for each child we're going to go ahead and rotate it on the y axis if it is a mesh. So let's go ahead and do that.
04:16:32.502 - 04:17:07.024, Speaker B: And you just see that there's no difference in our actual scene itself because we don't actually, I mean, the lights in our scene don't actually impact material that we have because we're actually starting off with a mesh basic material. So that's one way to actually rotate the meshes in your scene. It's a way that I have found to be, to be fairly useful to actually loop through an array. Another issue with what we're doing right now is that there could be lots and lots and children within the scene. And so right now we have a fairly small application. There's only seven children in the scene of. But I'm sure you can imagine what happens inside the render loop happens 60 times a second.
04:17:07.024 - 04:18:17.470, Speaker B: So if you have a really big scene and you really only want to rotate a few things, I wouldn't recommend looping through long arrays multiple, multiple, multiple times a second. So one thing you can do is we can actually create, initialize a group and then I want to do const group equals new three. And then what you can do is instead of adding all of these different meshes to the scene itself, we can do group add and then we can go ahead and actually add that group to the actual scene itself just like we did when we were working with the scene graph and while we were transforming properties. And then finally if we go down here we can actually do group children and that should work the same. So now we are making sure that we are only looping through everything that we add to the group so we can be selective about the things that we add to the group and so that we don't have to create large arrays that the render loop has to loop over. Alright, so how is a decent amount of setup? But I hope it will actually just give you a little bit more practice into how to set up a three JS scene. Now let's dive directly into textures.
04:18:17.470 - 04:19:19.400, Speaker B: All right, now that we have our scene set up, let's go ahead and get ourselves set up with our first set of textures. Now textures are any image and use any image for different textures. But to make it relevant for us, let's get textures that we may actually want to put onto materials that may be in a scene that we want to create in three js. And to do that I'm actually going to point you towards a site called freepbr.com. and what they have is they basically just have a catalog of many, many different types of really cool materials that you can use. And then within each material itself you can actually download a file that has all of the different textures that relate to the material as it relates to the actual appropriate PBR channels. We will dive a little bit deeper into that a little bit later on in the lesson.
04:19:19.400 - 04:20:07.798, Speaker B: But for now, I'm just going to point you towards the site and I'm going to tell you to download the wispy grass meadow, the space cruiser, as well as the Badlands. And there's going to be the examples that we use. I'll provide the links under the description and I recommend you go and download those for yourself. And the reason why I haven't actually included that into the actual starter pack is because this is someone else's work and this is someone that is actually providing it to you for free. But as well, you can choose whether or not to actually contribute. So I actually paid, I believe it was $9 to buy the commercial license or the commercial rights for this because I'm making money off of teaching you with this material. And if you find this useful as well, I think $9 is a very, very reasonable price given 400 plus textures that you get and you get it all into one file.
04:20:07.798 - 04:20:47.330, Speaker B: So I didn't want to distribute someone else's work. So if you want to go and pay a fair price, you can do that as well. But as well, if you just want to, you know, experiment with it and you just want to play with something for free, they are 100% free to use as well. So go ahead and download that and let's go ahead and get ourselves set up. The first thing that we want to do is we actually want to initialize something called a texture loader. So in three js, there needs to be a way for you to import that texture and turn it into a texture that three js is able to recognize. And to do that, we're going to go ahead at the top of the scene and we're going to do initialize showize the loader.
04:20:47.330 - 04:21:25.594, Speaker B: And then we're going to do const loader or texture loader because there may be other like model loaders that we will explore later in the lesson. And then we just do new three texture loader. So all we have to do is actually create this texture loader once, regardless of how many different types of textures that we have. Basically this is just a utility class that has load methods on it. And we're going to call those load methods anytime we want to load the actual texture. And then we're going to pass the actual texture or the URL of the texture into the arguments of that load method. So let's go ahead.
04:21:25.594 - 04:22:09.470, Speaker B: And after we initialize the material, I'm going to go ahead and actually initialize, initialize the texture. And to initialize the texture we're going to create a variable to hold the texture itself. So we're going to call it texture test and then we're going to make that equals to texture loader dot load. So that's the load method that I talked about. And then we're going to pass it a URL of the actual texture itself. Now that URL is actually just a path to the textures that we want to use. And I'll show you where I've stored the textures, at least within my repository or at least within my working folder.
04:22:09.470 - 04:22:36.002, Speaker B: If I go into the static folder I have a textures folder. If I go into the textures folder I actually just went ahead, extracted the texture, the downloads that we got and I actually just threw them into the textures folder. The naming is the exact same. You can see if you have all of these different textures then it means you've done it properly. And I just went ahead and actually through those into the textures folder. So let's actually get the URL to that. And to do that you can actually go into versus code.
04:22:36.002 - 04:23:15.598, Speaker B: And if I want to get access to this albedo texture and this albedo texture is just another way of saying base color. I can go ahead and right click copy relative path and then I can paste it into this load method. I'm going to go ahead and actually remove this static. And that's because within our vite configured three js or our application actually knows to look inside the static folder for any types of assets or any type of URL's, we pass it. And so we can just start our actual URL from the textures folder. And then we're going to go ahead and do console dot log texture test. So I'm going to log it to see if we have access to it.
04:23:15.598 - 04:24:03.618, Speaker B: Okay, perfect. We have access to the actual texture itself. And then what we're going to do is we're going to actually change the map property. The map property being basically just a base color that we're going to provide it and we're going to change that map property of the material. So let's go ahead and actually move this up before we initialize the material because after we actually have the material itself we want to go ahead and assign the map property of the material to the texture that we have. So let's go ahead and save. And you can see now we have our first texture applied to our objects because we actually initialized our scene with a mesh basic material for all of these meshes, at least with regards to the actual texture itself, what you see is what you get.
04:24:03.618 - 04:24:54.546, Speaker B: So essentially, you know, the colors of this texture itself is actually mapped one to one to the actual mesh. Now that's going to be different with different materials. So, for example, when we use a mesh standard material, this texture is going to define the base pattern underneath the material. But stuff like the actual lighting of the scene is also going to impact how it looks. But for now, because we've actually used a mesh basic material that doesn't respond to light or anything else, our actual image itself is going to map directly onto the output color of our material. Now, that's not to say that we can't actually alter this, because like I said, texture is actually just part of a material and that is still true for the actual mesh basic material. So if I should go ahead and do material color equals new, and then we'll assign it a three G's color, and then we'll assign it maybe like a red color.
04:24:54.546 - 04:26:10.106, Speaker B: You can see that if I go ahead and save it, we've now still have information from that texture. You can see, you'll still see kind of like the outlines of the grass, but now we've applied a very, very red hue to it. So this is just once again reinforcing that principle, that texture is just one part of the material, but you can still go ahead and change other properties that material. But now in this next lesson, I'm going to show you how to change properties of the texture itself, and I'll show you how that impacts the end material. All right, let's go ahead and explore some properties of the textures that we can change to impact the way that the material looks. As always, it's always good practice to actually explore the class itself within three JS's documentation to take a look at some of the properties that may not be covered, at least in this lesson. Or just perhaps if you're just trying to find out how to change something very specific in your head to see if that exists within the documentation, feel free to give that a look.
04:26:10.106 - 04:26:45.340, Speaker B: But in this lesson, we're going to cover a couple of properties that will be relevant to many different types of use cases. So to get ourselves set up in this environment, I'm actually just going to be using the plane. So I'm actually going to comment the group dot add out, and instead I'm just going to do group add and then we're just going to add the plane and then as well. I don't want this to rotate anymore. So let's go ahead and comment out of that part of the render loop. Finally, I'm going to rotate this as if it was basically like a ground. So I basically want a ground mesh that we're going to serve as the terrain.
04:26:45.340 - 04:27:20.344, Speaker B: So to do that, I'm going to go to the plane. I'm going to rotate it on the X axis. And I know that the X axis is the one that we want to rotate because if I'm looking at this directly, I know that the x axis is kind of the same x axis that you see in graphs. And I know that if I kind of stick a skewer or a spit through this and I rotate it on that axis, what that'll do is it'll actually flatten it out. So we actually have a plane. So we'll do rotation x equals mass PI. Because I know that math PI gives me a half rotation or a rotation of 180 degrees.
04:27:20.344 - 04:27:41.738, Speaker B: If I want a 90 degrees rotation, I'll do 0.5. So now I'm rotating this 90 degrees. However, rotating those 90 degrees can rotate it one of two ways. It can rotate the square clockwise or counterclockwise. I generally don't know which way it rotates by memory, the same thing. It's hard for me to sometimes know which axis to rotate by memory. So I kind of just, like play with this.
04:27:41.738 - 04:28:19.106, Speaker B: I know that this rotated it the wrong way. So if I rotated the other way by wrapping this with a negative operator, I can actually rotate it upwards. And then I'm going to go ahead and scale this scale dot set. And I'm going to set it to 100 by 100. And then I'm also going to raise the actual camera itself. So I'm going to set the camera dot position dot y five. And then I'm actually going to increase the far property of this so we can basically see all of the mesh in its entirety.
04:28:19.106 - 04:28:46.826, Speaker B: Okay. So I'm sure you can imagine an issue that arises if I actually set an absurdly high value for this mesh. And I'm saying absurdly high value for the scale. But in reality, it's very reasonable for you to have a very large plane or a very large mesh for the train itself. And what's essentially happening is we're basically stretching the detail of this texture. So this texture is very, actually very detailed. But there's a limit, right.
04:28:46.826 - 04:29:21.212, Speaker B: If I keep zooming into this, if you could imagine if I actually had this scaled up to like 10,000. You know, eventually players are going to be able to see the ground in a very, very pixelated manner. So to actually solve this problem, three js has a repeat property on its textures. And this repeat property is a vector two. So just like we have a vector three which has x, y and z coordinates, a vector two has x and y coordinates. And we can use very similar operators that we use with the actual vector three. So we can actually just access the x and the y properties of repeat directly.
04:29:21.212 - 04:29:50.744, Speaker B: Or we can set the x and y properties of repeat by using the set method provided to us by the vector two class. So we can see that there actually is a set method. So you can do set and you can pass it in X and Y. And so that's exactly what we're going to do. And we're going to basically go to the actual texture itself. We're going to name it grass texture. Instead of texture test, make sure that you reassign the material dot map to this new name that we've provided it.
04:29:50.744 - 04:30:34.694, Speaker B: And then we're going to do grass texture, texture, dot repeat dot set. And then we're going to provide it like 100 by 100. And what we're essentially doing is we're going to say, okay, let's repeat this texture 100 times on the x axis and 100 times on the y axis. Let's go ahead and save that, see what we get. Okay, so something's happening. It's, you know, just one big green chunk. But if I go into the actual one of these corners, I'm actually going to go ahead and expand out to the viewing distance.
04:30:34.694 - 04:31:07.860, Speaker B: So I'm going to set this to maybe just 10,000. So we don't see we have any problems with any of our edges. If I go into this teeny, tiny little corner, you can see that we actually have the original mesh and then everything else is just kind of stressed to infinity. So what's basically happening is we can actually look and see that the edges of this texture itself is actually stretched to infinity. So what's happening is that we are repeating this like 100 times. And maybe 100 times was a little bit aggressive. Let's repeat it ten times.
04:31:07.860 - 04:31:41.090, Speaker B: And so we'll get a larger texture in the corner. So you can see we are repeating this kind of ten times. And at least this texture is one 10th of the size that it was when we originally had it. However, what we're doing is we're actually just repeating the edges of this mesh. What we want to do is we want to repeat this texture in its entirety and kind of like stamp it across. And the way that we do that is actually there's a wrap s and a wrap t property to all of our textures. And the wrap s property is with regards to the actual x axis.
04:31:41.090 - 04:32:10.366, Speaker B: And the wrap t property is with regards to the actual y axis. So let's go ahead and set these individually and see what happens. So if I go ahead and do texture, or we should do grass texture, dot wrap s equals. And then you remember how I assigned a constant to the actual side property of material. So I actually provided a three dot double side. This is the same thing that we're doing here. The wrap s property actually expects like an integer.
04:32:10.366 - 04:32:56.214, Speaker B: And instead of having to memorize an integer, we're just going to provide it with a constant. So we're telling three js to basically on the edge of this actual texture. Instead of just stretching the last pixel, we're going to repeat the entire image. So let's go ahead and save it. So now you can see that we've actually started to repeat or tile that texture along the x axis, so that when it gets to the end of the texture, it just repeats that texture in its entirety. We're going to go ahead and do the same thing for the y axis and we do that by accessing the wrap t property. And then now if we actually zoom out, you'll see that it's not just one big texture, but the same texture repeated ten times on the x axis and ten times on the y axis.
04:32:56.214 - 04:33:35.272, Speaker B: If wanted to make it even more detailed, I can obviously set this to a higher value. But an issue that you may see or that may occur is actually, you can see now that there is, at least to me, a fairly recognizable pattern. So it seems fairly uniform. And for some it may look unnatural. So if you've ever played Minecraft, you may recognize that it's a hard problem to solve. I mean, there's a few ways to solve this, not using some complex math, but you could just kind of expand the size of your texture so you don't have to repeat it that much. But that comes at the cost of having to load really large textures to your scene, which often isn't a best solution.
04:33:35.272 - 04:34:04.722, Speaker B: So there's really not any easy way to fix this. But there are also other different types of actual wrapping that we can provide it. So instead of repeat wrapping, there is something also called mirrored repeat wrapping. And then it's going to be difficult to see how this looks with the grass texture. So let's actually just go ahead and load another texture for us. So maybe if we actually use the panels texture. So let's go ahead and copy this relative path and then you don't have to follow along.
04:34:04.722 - 04:34:46.918, Speaker B: I'll just show you. So I'll go ahead and just paste this in and then I'll remove the static so you can see now. And maybe the best way to illustrate this is to actually do something like two. You can see if we were to do regular wrapping. So I'm going to comment this out and we're going to do. And I'm just going to do regular repeat wrapping. And if I were to do repeat wrapping, you can see that when we do repeat mapping, what we basically do is this is scaled twice on the X and twice on the Y.
04:34:46.918 - 04:35:25.638, Speaker B: And basically when we get to the end of the actual texture, what we actually do is we start back at the leftmost part of the actual. And I'm talking about the X axis. We started the leftmost part of the actual texture and we basically repeat it from the beginning again. So we're going from zero to 100. And then at the middle point, once we start to repeat again, we go back to zero, back to 100. If we were to do mirrored repeat wrapping, we essentially go from zero to 100. But now we're not starting from this leftmost part of the texture, we're actually starting from the actual rightmost part and then we're flipping it.
04:35:25.638 - 04:36:22.476, Speaker B: So we go from zero to 101 hundred back to zero. So I hope you can see the distinction. It does end up providing like a little bit of a psychedelic type of look. But yeah, that's just one option for you to actually repeat wrap. And I believe if we actually go to the wrap s, you can see that there are also clamp to edge wrapping, which is the default. What happened when we actually saw, when we went all the way to the end and then instead of actually repeating it all over again, we just stretch that last pixel all the way out of. All right, so in this lesson we're going to cover another property that I think is going to be relevant to you and it's actually going to be the offset property.
04:36:22.476 - 04:37:02.069, Speaker B: Now what this offset property changes is actually the positioning of the texture within the mesh. So right now we have it positioned so that you start from the left hand side or the top left hand side and then you start to tile this texture. I'm going to go ahead and actually set this back to the regular repeat mapping. But regardless of how this repeats, there's no way for me to basically tell three js that I want maybe this part of the texture to be centered onto the material itself. And the way to do that is with an offset property. And that offset property lets you change the actual positioning of the texture within the material itself. So let's go ahead and set that up.
04:37:02.069 - 04:37:40.498, Speaker B: I'm going to, I know it's called, it's still called grass texture, but there's going to be a short lesson. So we're going to keep it called grass texture even though we're working with space cruiser material. And I'm going to change the grass texture offset property. And that offset property is actually a vector two, just like the repeat. So I can actually access the X property of it directly and I'm going to set it to 0.5 and we're going to visualize the difference. Now you may not have remembered how this looked originally, so let's go ahead and actually add a GUI in situations like this where you want to visualize the impact of the thing that you're changing immediately.
04:37:40.498 - 04:38:15.544, Speaker B: So I'm going to initialize this GUI in a slightly different way. Instead of creating an X and a Y separately, there's actually a way to feed both X and. Yeah, I properties as different separate objects into the same menu option. And I'll show you. This is just one option for you to do. It may not be the most intuitive or the most helpful, but let's go ahead and do pane add input and we're going to provide it with the actual grass texture as the object that we're going to change. We want to change the actual offset property.
04:38:15.544 - 04:38:56.223, Speaker B: And the offset property has properties in and of itself, that being the X and the Y. And instead of starting at the top level as grasstexture offset at the providing the X and Y, we could actually go ahead and specify it here as two separate objects. And the first object is going to be the X that's going to hold information about the minimum, the maximum and the step. And then the second object is going to be the actual Y value, and then we're going to provide it the minimum, the max and a step. And you can see that what this provides us is actually a new GUI. I actually set it to 0.5, so I'm actually going to remove that and just start at zero zero.
04:38:56.223 - 04:39:32.776, Speaker B: But this new GUI, whether or not you like it, is a different story. But it does provide us with a cool unique way to now specify what we want to change this offset to. So for example, now I want this to be in the middle. Perhaps I would provide an offset. Or maybe we should do minimum of negative one for both of these. And now if I want this to be centered, I go ahead and just play with this. And then now I can go ahead and actually copy these values into the actual offset property.
04:39:32.776 - 04:40:30.304, Speaker B: So this is just a way for you to experiment and play with the actual offset of your texture in relation to where it sits on the material in real time. And that's just another property that I think would be very helpful to you. Now, in the next lesson, we are going to cover something called uv maps and we're going to explain how that accounts for the different ways in which textures map onto objects. All right, so now that we've covered texture, repeat and offset properties, we no longer have use for this very, very large plane. So let's go ahead and actually undo some of those changes we made for demonstration purposes. So I'm going to remove the pane. I'm going to remove the wrap s and wrap t properties as well as the repeat properties.
04:40:30.304 - 04:41:19.246, Speaker B: I'm going to go ahead and load the appropriate grass texture back in by copying the path for the wispy grass metal albedo Png. I'm going to pass it back into the actual arguments for the load method and removing the static. And then I'm going to go ahead and remove some of these transformations we made to the plane. And then we're going to remove the group add plane and then bring back all of the actual objects that we had. And then finally we're going to uncomment out this loop that we had to animate the meshes. Okay, perfect. Now, one thing you may have noticed when you started looking at these textures and the way they mapped onto the art geometry, you may notice that different geometries have different ways in which the textures actually map onto them.
04:41:19.246 - 04:42:07.574, Speaker B: Now, if I look at the plane, a plane I feel like is the most straightforward. It's basically like a square texture and it's a square geometry that's mapping onto, and it maps on from edge to edge. And it's a similar case for the actual cube itself because the cube is just, you know, six different faces of the same square. However, if you take a look at something like the torus knot, which is a fairly weird looking geometry, it's not unexpected for the texture to map onto it in unexpected ways. And the similar case for something like the cylinder, you can see how like the actual texture, you can see there's a warping effect that's happening. It's basically stretching across the actual surface or the side of the cylinder, you can see the similar situation happening at the top of the sphere. You can see there's a little bit of warping happening.
04:42:07.574 - 04:42:45.432, Speaker B: Basically, different textures are going to map onto different geometries in different ways. The way they map onto different geometries is actually defined by something called a uv map. And this uv map is basically something that tells three js how to map a texture onto a geometry. I think the best way to illustrate this is with an example of my own. So right here, I actually have the, the blender file or the 3d model for my ramen shop that I used for my personal portfolio. And there's no need to follow along here. I'm just, this is for demonstration purposes.
04:42:45.432 - 04:43:13.490, Speaker B: But if I go ahead and just focus on this chunk of geometry. So this is actually just all the machines that I have. So I call them machines joined. And these are all the machines that I have in my actual portfolio, in the model for my portfolio. And this is actually one geometry. And this one geometry is actually colored by, at least in my actual portfolio, the color of all of it is defined by one texture. And that one texture actually looks like this.
04:43:13.490 - 04:44:11.580, Speaker B: And now at this point, you may question, okay, well, how does three js know that we want to map this, you know, part of the texture onto this part of the geometry? It's no longer straightforward. It's no longer like, okay, it's no longer like a square that I map, you know, one clean and simple texture to. Now, it's a very complex geometry with a very complex texture. And the way that three g's actually knows how to map it is because we've actually provided three g's with a set of coordinates that define the uv map. If I go ahead and actually go to the uv map here, you can see that three js actually has information about where every vertice of my actual model sits on this actual texture. And this is all this information defines the uv map. So, for example, you can see that I can actually, if I go ahead and select a face right here, this face within my texture corresponds to this part of my geometry.
04:44:11.580 - 04:45:31.388, Speaker B: All of this information is passed into three g's as a set of uv coordinates. And then three g's reads these uv coordinates, similar to the way that it reads the position attributes that we send to three js that has information about where each vertex sits in 3d space. Well, three js reads a set of coordinates and understands, okay, so basically, if I'm reading from a texture, then this part of this geometry or this vertex that corresponds to one part of the geometry here is going to be mapped to this part of the texture. Now, three GS has its own set of uv maps for its own primitive objects. And I think the best way to illustrate that is if I actually go ahead and open a new file with a cue within blender and I'm going to go ahead and map a texture onto that and I'm going to play with that uv mapping to show you how the different uv maps can change the way that textures map onto different objects. Alright, so now I have this cube in blender and again, you don't have to follow along. This is just me kind of quickly just showing you a demo of uv mapping.
04:45:31.388 - 04:46:03.262, Speaker B: And I have this cuban blender. And the only thing I've done to this, I've actually went ahead and applied a texture that I've actually provided to you within the static folder. It's called uv mapping test. I've actually applied this texture onto the actual cube itself. Now, Blender's set of uv maps is actually different from three JS's set of uv maps. Now go ahead and actually take a look at how blender unwraps this cube. The way that blender defines the way that a texture maps onto its cube is it's actually unwrapped itself, like so.
04:46:03.262 - 04:46:54.714, Speaker B: So basically, if you are familiar with GiF wrapping at all, I'm sure you can imagine if you unwrapped a gift, it would basically look like this. If you're wrapping like a box, it basically has all six sides and all six sides kind of take up different parts of the actual wrap itself. And then if you put them all together, you can actually like cleanly wrap this one object. I'm going to go to material preview here. And basically what this uv map is defining is defining, as I said in the last lesson, which parts of the texture map onto which parts of the geometries. So if I actually click this button right here, what we're basically doing is whenever I select a part of this actual geometry or a side of this geometry, we will see it reflected here. So for example, if I select the top of this actual box, you can see that this top of this box corresponds with this part of the uv map and what this part of the uv map says.
04:46:54.714 - 04:47:32.864, Speaker B: Okay, for this actual part of the geometry, this is the actual texture that we're going to use. And we can see this actually lines up. So we have the t and the e and the s here. And we can have the top half of the trat and that maps exactly onto what we see on the right hand side when we're actually looking at the geometry. If I actually go ahead and change these uv coordinates, I can actually move this. You can see that now I'm defining a different part of the texture that will map onto this geometry. And the cool part about this is, however I change this to in whatever software I use to change this uv map, I can go ahead and export the model with the uv map, and it exports with the uv map by default.
04:47:32.864 - 04:48:20.634, Speaker B: And the three js will know if I actually import the same model and I import this texture, it'll know where to map the texture onto the actual geometry itself. Let's take this one step further and go ahead and go into three js and map the same texture onto our three G's geometries to see how that ends up looking. So I'm going to go ahead and open our directory and go into where the uv mapping test lives. I'm going to go ahead and copy relative path. I'll paste it in here and I will get rid of the static. And then, now let's take a look at how three G's maps are textured onto our geometries. Now, you can see that by default, three js actually maps it a little bit differently to blender.
04:48:20.634 - 04:49:00.068, Speaker B: So while blender actually goes ahead and unwraps this, almost like this gif wrap on the texture itself. Three GS. What three GS does, at least for the cube, is it actually maps the entire texture onto a face of the cube. Now, if we wanted to actually go ahead and do that in blender, and again, this is for demonstration purposes only. Later in the course, we will be working with a 3d model and I'll show you how this uv knowledge will apply. In that case, I just want to show you basically that three GS has its own set of uv coordinates. And to emulate that, I'm going to go ahead and show you how to change the uv map in blender to actually emulate that exact same type of wrapping.
04:49:00.068 - 04:49:37.888, Speaker B: So what they've done is for each face. So for example, if I were to just start with this face right here, this front face, for each face, they've actually mapped the entire texture onto it. So if I wanted to do that, I can actually just scale up this uv coordinates and I just go ahead and just map it directly onto the entire image. And now you can see, even though it's rotated improperly. And that's because I can actually just change this orientation to work appropriately. You can see that by doing this to each and every one of these actual faces, I can go ahead and emulate the way that three G's maps its textures onto its geometry. This is a very crude way of doing it.
04:49:37.888 - 04:50:48.898, Speaker B: The actual appropriate way to do it is to select all faces and then to do something called cube projection. And now you can see that this is basically how three GS actually wraps its own textures onto its geometries. I'm sure there's some type of rotation that we can apply to some of these actual uv coordinates to make sure that it works exactly the same that it does in three G's. But this is just to demonstrate that three G's internally has its own set of uv maps that it applies. And that's going to impact the way that different textures apply onto the actual geometry. Now, this isn't really actionable knowledge you're going to be using in the immediate term, but it is going to be something that's very important to you when you start working with 3d models and start understanding how textures apply onto these 3d models. All right, so now that we have an understanding about uv maps, we have our understanding about different texture properties and how to change them, how they impact the end material.
04:50:48.898 - 04:51:35.792, Speaker B: Let's finally dive into the other textures that we've downloaded from the website, and we can finally use them to start to tell three G's about the actual PBR channels within our actual material. Now, from the last lesson, we learned that PBR is a workflow that relates to this industry standard way of defining some of the physical properties of our materials. But that material specifically will have to at least be a mesh standard material or a mesh physical material. So we can no longer use the mesh basic material. Let's go back to using the mesh standard material to now show how to use these different textures to define some of these PBR channels. So I want to go ahead and save. And so you can see now we have objects that respond to light.
04:51:35.792 - 04:52:07.160, Speaker B: Let's go ahead and actually copy the path of the actual grass texture again. We're going to reapply it here. I'm going to remove. Oh, sorry. That is the absolute path. We want the relative path. Gonna paste it in, remove static, and then I'm actually going to call it grass base color or maybe grass albedo, just to be aligned with the naming convention from the actual website.
04:52:07.160 - 04:53:10.300, Speaker B: And then, now let's go ahead and add other textures and then start to use them to actually define the different textures that we have. So I'm actually going to expand this fully so that I can have a good view into our actual repository itself as well as our code. And so I'm going to do const, grass ao or ambient occlusion equals texture loader or dot load. I'm going to pass it the actual path from our ambient inclusion. And now I'm going to actually go ahead and actually just fast forward to when I have all of these loaded properly. All right, now that we have all of our textures loaded, let's take a step back and explain why we need different texture maps or different textures to define different properties about our material. Now, in the last lesson, you may recall that we had properties of our material itself, like roughness and metalness, that we could actually go ahead and actually change within three js.
04:53:10.300 - 04:53:50.430, Speaker B: However, what we were doing is we're actually changing the roughness or the metallicness of the material uniformly. However, you can imagine that there are scenarios in which not every part of material has an equal amount of roughness or not every part of a material is equally metal. And I think the best way to illustrate this is actually with the space cruiser material that I have provided for you. And you can see that this is the actual preview. This is what the material is supposed to look like. You can see here that this material holds lots of different information. It's not just one uniform material, such that it's not that the entire material is just one solid metal.
04:53:50.430 - 04:54:30.640, Speaker B: Specifically, there are parts of this that are like, for example, these blue parts that look non metallic to me. Or maybe they are metallic, but like, at least the surface is some type of paint or some material that isn't reflective like a metal. And there are other parts of this material that are very metallic, that are very reflective. And the way that three GS knows where to actually apply these metal disc properties is with a map that provides specifically where on this texture or where on this material exists those metallic elements. And so let's take a look at the actual albedo. Take a look at this base color. So this is actually the base color, but you can see nothing here is actually metallic.
04:54:30.640 - 04:55:23.186, Speaker B: We don't really know which parts of this is actually metallic. If we actually pull in now, the actual metallic map, you can see that what we're basically doing is we're defining the areas that are going to be accepted as metal elements by three js. So you can see, like, this part just by looking at it, it's just kind of like this white material. But by providing it this metallic map, we can specify the three g's where on the material itself, we expect to have metallic materials. And where on this material do we expect to respond to the metalness properties that we apply to it? And the metalness property that we apply is the same way that we did in the last lesson, where we specified it on a scale of zero to one. Well, if this metallic map says that, okay, there's no metalness here. Well, regardless of what you change that property to, three j's won't change the metallic property of that actual material in that area.
04:55:23.186 - 04:56:12.934, Speaker B: And the way that three js knows specifically where to apply those elements is that for every pixel on this actually texture that we provided, it exists on a spectrum from black to white. And the more white it is, or the stronger the white colored it is, the more metallic it is. Now, it is difficult to kind of see, at least in this example, because it goes from absolute black to absolute white. But if I show you the roughness map, which is basically the same principle, the amount of roughness in a specific part of the material is encoded by the actual black and white channels. So if you go into the roughness map, you can see now there are smoother gradients between black and white. And the more white something is, the more rough that part of the texture actually is. Let's go ahead and actually add these textures into our actual application.
04:56:12.934 - 04:57:07.660, Speaker B: And we're actually going to start with the roughness map. Unfortunately for us, when we start with the grass example, it's not going to be very clear what this roughness map does, because the details are so fine. But to actually go ahead and add the roughness map, we just go material roughness map equals graph roughness. And then if I go ahead and actually save this, you can see that immediately at least there's nothing, a very discernible difference with regards to this map, with or without the roughness map. If we can go ahead and actually comment out the part that spins all of our materials or all of our meshes, you may see that we have a better look into it. But what we have done is we've actually told three G's which parts of this material needs to be more rough than the other parts. You can still, at this point, influence the roughness parameter.
04:57:07.660 - 04:57:40.432, Speaker B: As I said, if I set this to 0.1, you can see it'll become very glossy. However, whatever you do to change this property itself, it won't actually impact the parts of the material that we have said isn't rough. And the parts of the material that we set isn't rough are the parts of the material that are actually darker on this actual map. The metallic map works in the exact same way. So we could actually go ahead and specify material metalness map. Metalness map equals grass metallic.
04:57:40.432 - 04:58:35.338, Speaker B: And I'm going to go ahead and save. And again, no real difference here, but let's think about a grass. Does a grass have any metal properties to it? Is there any metal part of, if you just think conventionally of just grass in the real world? Well, no, and there's no metal real properties of this actual grass material either. And because of that, what would you expect the actual metal in this map to look like? Well, if you guessed that it looks absolutely pitch black, because there's no white parts of this image that we need to actually specify where the metallic parts are, because there are no more metallic parts, we'd actually just end up with this like black map. That for us, at least in this use case, is completely useless. I'm showing you for demonstration purposes, but it'll become more apparent when we actually load it with space cruiser material. But just wanted to show you that it is loaded in the same way that we load the roughness map.
04:58:35.338 - 04:59:34.874, Speaker B: And then we can also set the actual metalness channel to a number. But you will notice here that I've actually set it to one. You'll notice that now, as opposed to if I didn't have this actual metalness map and I set it to one, you can see that this actual property has an impact on the way that our material looks. And the reason is because what we're basically doing is we're uniformly applying this metalness property to the entire material. However, when we go ahead and actually specify a metal mismap, what we're doing is we're only applying this property to the parts of the material that are metallic that are specified by this image, because we haven't specified anything. Or we're basically saying there's no metal parts of this material. If I specify the metallic map and then I try to set the metal this after because there are no metal parts of this material that we're actually trying to impact or to change, the property of this actual slider will have absolutely no effect.
04:59:34.874 - 05:00:40.174, Speaker B: And that's basically what our maps help us do, is they help us define which parts of the actual image or which parts of the material itself that we can impact with our actual roughness and metalness channels. All right, so roughness and metalness work in very similar ways. And in the next lesson, we will be talking about what the normal map does. Alright? So we've talked about the metalness and the roughness maps and how those define the parts of the material that will be impacted by these metal and roughness parameters. But we haven't been able to solve one issue that may have become immediately apparent to you when we loaded these textures onto these actual models, and that these textures look very, very flat. And I don't mean flat as in, like, straight, just like flat on the ground. You can see, obviously, like this actual material is, or this geometry is a sphere.
05:00:40.174 - 05:01:29.610, Speaker B: So it's technically not flat, but the actual texture itself, it just seems like it's mapped onto a very smooth or flat surface. But in reality, grass is very rough, has thousands of different blades. It's a very complex geometry. And what's essentially happening is we have a very, very simple geometry, and we've mapped a very complex texture to it. And regardless of how detailed you make this texture, there's no way for this, at least this base color, to simulate the way that light will bounce off of the actual geometry of the grass. And so the way that light bounces off the geometry of a cube is very different from the way that light bounces off the geometry of actual, real blades of grass. And for that reason, you can tell discernible difference between grass that has real geometry and grass that's just a texture that you put onto an actual cube.
05:01:29.610 - 05:02:11.760, Speaker B: Now, there's one very simple way around this, and there's one way to basically create an illusion. The first simple, straightforward way is basically just to model the geometry. But I'm sure if you can imagine, to model grass could be very, very resource intensive. There's thousands, maybe millions of blades of grass in a field. You would never want to. I mean, maybe you would, but it would be difficult to have to render so many triangles in your scene just to make sure that we have grass that looks like grass. The other way to basically account for the fact that light bounces off of flat surfaces versus complex surfaces differently is to basically simulate the way that light bounces off of these different surfaces.
05:02:11.760 - 05:03:01.654, Speaker B: And the way that we tell three js to simulate this light is by providing it information in the form of a normal map. Now, I'm not going to get into the very, very technical details of how this normal map works, but I think it's just important to understand that what this normal map holds is information that tells three j's how to fake the way that light bounces off of different materials. And this specific material is very rough. And so what this normal app is going to encode is going to hold information about what it's going to look like if you look at this grass from different angles. So let's go ahead and actually apply this normal map. I think the best way to illustrate what it does is to actually take a look at what our model looks like after we apply it. So now that we've applied the actual map, you can see now it's almost like we've created a more complex geometry.
05:03:01.654 - 05:03:38.450, Speaker B: So if you look at it, at least from far back, you can see that it almost looks like there's, like, divots now to this actual sphere. And these divots are where I. There are high and low points in the grass. And it's almost like we've simulated a more complex geometry without actually having to change the geometry itself. So this geometry is still a sphere. And what we're doing is we're using a normal map to affect the way that light is reflected off the surface of a more lower resolution model, creating the illusion of more detailed and complex geometry. And so, at least to me, this difference is night and day.
05:03:38.450 - 05:04:57.610, Speaker B: Even if I look at the cube, which I know intuitively, is actually just like a very, very simple geometry, there's nothing about it that should impact the way that it shouldn't look like there's real grass growing on the cube, given the actual simpleness of the geometry. But after we've actually applied this normal map, the three js knows where the actual light is in the scene, and it knows the information from the normal map, and it uses that information to basically simulate a more complex geometry on the surface of this material. And so to me, this is a really, really cool way to simulate very, very complex geometries. And it's used in many games and in many PBR workflows to basically add more information without having to actually change the surface of the actual geometry itself. All right, so the next map that we're going to look at is actually the height map. And the reason why I called it a height map is actually, I followed the naming convention from the actual website itself. But in three js, this is actually called a displacement map.
05:04:57.610 - 05:05:44.720, Speaker B: And I hope that the displacement map kind of provides is a little bit more descriptive about what's happening to the actual material or the actual mesh when you provided the map. So in other maps that we've actually used, we're actually telling three G's how to simulate the way that light bounces off that material. So, roughness, we're telling it basically. Okay, well, this material is this rough and therefore, light should behave in this way. Metalness, same thing. And then the normal map, we're basically simulating the way that a more complex surface may react to light to basically create the illusion of a more complex geometry. However, the height map or the displacement map is actually physically displacing the vertices of the mesh in a way that's actually changing the real surface topology of the mesh itself.
05:05:44.720 - 05:06:18.290, Speaker B: And we can actually apply it by doing material displacement map equals grass height. And then we can go ahead first. Let's go ahead and save. You can see like when we were using just the actual. Let's go back to the normal map, even though that we were changing the way that it looks more rough, right? So it looks more rough. But if you actually look at the edges of the surface itself, you can see that it's still perfectly round. And that's because we actually haven't changed the actual geometry of the mesh.
05:06:18.290 - 05:06:55.026, Speaker B: But if we actually provide it with a displacement map, we are in fact changing the geometry of the actual material. And now if I go ahead and actually set the scale down to something a lot smaller, so it's called displacement scale and scale something like 0.1, you can see that this now is a much more reasonable, much more reasonable way. I mean, it is just a much more reasonable scale. You can see here there's some issues with the way that it's actually mapping. And that's because we've actually physically displaced parts of the actual geometry. So this isn't something that I would recommend using a lot.
05:06:55.026 - 05:07:28.860, Speaker B: There's a reason why there exists something called a normal map, which basically does the same thing, except actually, well, it doesn't do the same thing, but it's basically, it's achieving a similar effect. And that is trying to simulate a more complex geometry. And the reason why that exists is because it's actually a lot cheaper than to actually impact the real geometry of the actual. Of the mesh itself. So this allows you to create some type of real depth to the actual. To the actual material, but comes at a cost of increased triangles. It comes at a cost of increased geometries.
05:07:28.860 - 05:08:31.470, Speaker B: All right, the last texture we're going to apply on our actual model is the actual ambient occlusion texture. Now, ambient occlusion is a shading or rendering technique that we use to add more depth and realism to the scene. So let's take a look at the actual badland boulders ambient occlusion map. And we can see that the ambient occlusion texture helps us simulate the way that light is occluded or blocked in areas where objects are close together, or one object is casting shadow over another. So essentially what we're doing is we're encoding some type of shadow information onto this texture. And this texture will actually just be applied to the material itself to basically add a level of depth to basically show where some of these shadows are. Now these shadows are going to be different from shadows cast by other objects within the scene.
05:08:31.470 - 05:09:06.256, Speaker B: An object can actually cast a shadow onto itself. So let's take a look at like an object with and without ambient occlusion. As you can see, the object with ambient occlusion and that ambient occlusion happening in areas where that shadow, where objects within the parent object are actually very close together. This adds a little bit of depth and a little bit of shadow information that makes it seem a little bit more realistic. And I think another way to illustrate this is through three GS's own examples. This isn't using a ambient occlusion map. It's actually just generating ambient occlusion through an actual post processing effect.
05:09:06.256 - 05:09:51.030, Speaker B: But you can see if I increase the ambient occlusion here, what I'm doing is I'm increasing the shadows in areas where objects are close together and basically occluding light from the actual source of the light. When we use something called an ambient occlusion map, we're basically faking this kind of occlusion. We aren't actually calculating where light is in the scene. It has no knowledge of where the light is on a scene. We've essentially baked it into the image such that that ambient occlusion cannot change. But it does add a level of depth and realism in a way that isn't physically accurate, but looks like it is. So, for example, you can see without ambient occlusion, and it looks a lot more like CGI, but with ambient occlusion, you can see it becomes a little bit more real.
05:09:51.030 - 05:10:33.922, Speaker B: If I really turn it up, you can see the areas that we are impacting, and it's going to be those areas that are kind of like close together. But, you know, a more subtle effect is going to look more realistic. In order to implement this, we actually need a second set of uvs. If we go into the mesh standard material documentation under AOMap, you can see that the AO map requires a second set of uvs. When I talked about the concept of uv coordinate, I told you that three GS actually provides its own set of uvs, and that's going to define how textures are going to map on its own geometry. And so that uv information is actually stored within each geometry. So let's go ahead and console log out our geometry to see where we actually store that information.
05:10:33.922 - 05:11:35.280, Speaker B: So the console log geometry, and then I can go ahead and open up the console. You can see that within the box geometry there's something called attributes. And that attributes is going to hold information about the actual normal information, position information, and now the uv information. So remember how when we created our own position attribute and we actually created our own geometry, what we had to do was we actually had to pass in that information into the geometry through a buffer attribute? Well now we're basically doing the same thing because there actually isn't a second set of uvs that are provided to us by three js by default. So what we'll have to do is we'll actually have to pass in a new set of uvs. And where are we going to get those uvs from? Well, because this ambient occlusion map and the rest of our textures kind of live in the same uv space, they're basically coloring the exact same thing. What we can do is we can actually just go ahead and copy this set of uvs and we can pass it back into the actual geometry itself.
05:11:35.280 - 05:12:41.048, Speaker B: So if we actually just console log out geometry, dot attributes, attributes, dot uv dot array, you can see that we have access to the float 32 array and we can use this to pass it back into the actual geometry through the buffer attribute. So remember when we actually created a buffer attribute for position? Well, we're going to do the same thing for uv two. And then we're going to do is we're going to do equals new three dots buffer attribute. And then we're going to actually just pass in this array. And then the second argument for the buffer attribute, remember is item size. And the last time we worked with item size we actually worked with an item of a size three because our each item actually specified the x, y and z coordinates of a vertex. However, when you think back to our actual uv example, remember how our uv map existed on that 2d space? So each coordinate of our uv map actually had an x and a y position property.
05:12:41.048 - 05:13:16.190, Speaker B: So instead of working in a 3d space, we were working in a 2d space and therefore our item size is actually two. Now if we actually pass that back into the geometry, and remember we do that by, we set the attributes by calling a set attribute method. And we did this with our position. And instead of specifying position here, what we're going to do is we're actually going to specify uv two. And then we're actually going to pass in our new buffer attribute that we've created. We're going to save. And what we're going to do is we're actually going to console out, log out that geometry again to make sure that we've actually assigned it properly.
05:13:16.190 - 05:13:48.684, Speaker B: And then now you can see in our attributes, we actually have a uv two. Perfect. Let's go ahead and actually set this will do the same thing for all of the different geometries because the uv maps exist on the geometries, not material or the mesh. So we have to do the same thing for every geometry. And then I'll be right back after I finish that. All right, perfect. I went ahead and set additional uv coordinates or sets of uv maps for every one of the geometries that we have.
05:13:48.684 - 05:14:33.170, Speaker B: And then all we need to do now is we need to do material. AoMap equals grass ao. Now again with the actual roughness and the metallic settings, it's fairly subtle, but there is a AoMap intensity parameter that we can play with. Citi equals one. So we can actually change this to any value that we want to impact the actual intensity of our ambient occlusion map. And I think the best way to illustrate this is to actually add a GUI add input. So we're going to impact the material and then we're going to impact the AoMap intensity.
05:14:33.170 - 05:15:30.366, Speaker B: And then we're going to set a minimum zero maximum to one and a step of 0.01. And then now you can see that if I actually play with the ao map intensity, you can see that it adds just a tiny bit of additional shadow to the shadow areas and it provides a little bit more depth. Alright, perfect. The next thing I'm going to do in the next lesson, I'm going to go ahead and basically do exactly what we did with this material, with all the other materials that we have. So the boulders and the metalness. And I'm going to add a few more toggles and then we're going to go ahead and play with those different parameters to see how they impact our actual meshes. All right.
05:15:30.366 - 05:16:09.560, Speaker B: And finally here we have a summary of how all of the different actual that we've downloaded or are going to impact the way that our actual material looks. And I just set this all up off camera because it's just a lot of boilerplate. So I loaded all of the boilerplate textures. So all of the boulder and the space cruiser textures, I went ahead and assigned them all to the actual materials themselves. I actually also added a GUI for us to control some of these parameters so we can see the impact of them. And then, yeah, that I just like put it all into the scene. So let's go ahead and now finally see play with these parameters individually.
05:16:09.560 - 05:16:49.826, Speaker B: So now let's. I think this is a good example where I think I can show you basically what that metalness roughness map has helped us define. So if I go to the space cruise material and play with the metalness, you can see now, it could impact, basically the metalness of the actual object itself. But this is only going to impact the metalness in the specific areas that that actual metalness texture has actually told us that we can impact. So regardless of how I actually play with this actual slider for metal, this intensity, I will never actually impact the look and feel of this part of the material, because it actually has no metalness inside of it. It was difficult to see. Regarding roughness, it's like same idea.
05:16:49.826 - 05:17:25.486, Speaker B: So there's only some parts of this that are rough, and there's some parts of this that are rougher than others. So you can see that the actual roughness that we're applying to the material isn't impacting this entire material in a uniform way. It was difficult to actually see the effect on the actual grass, because it was just like, some of the details were still fine. But if I go ahead and play with the grass roughness slider, you can see that I am actually, as I lower the roughness, there are parts of this actual grass to start to really gleam and start to reflect. This is almost shiny grass texture. However, this doesn't affect the entire material. Uniform.
05:17:25.486 - 05:18:10.864, Speaker B: Lately. Taking a look at the difference between, I think it's a good, at this point, to illustrate the difference between our displacement map and the actual normal map. So our displacement map is actually impacting the surface topology. You can see, if I increase the displacement map intensity, it's actually increasing the surface topology or changing the surface topology of our actual material. However, if I set it to zero, if I set all these to zero, you can see that even though I set it to zero, when I look at this actual object itself, it looks like there is depth to it, right? It looks like there's depth to a same thing. I can see the same thing for here. It looks like there's depth to it and what's impacting that.
05:18:10.864 - 05:18:56.640, Speaker B: If you actually look at the edges of the sphere, because we have no displacement map, you can see that we're not actually impacting the actual, actual geometry itself. The thing that's responsible, and I think the illusion is perfect here. Thing that's responsible for giving us the illusion that there is some depth to this actual material is that normal map. So even without the displacement map to physically change the surface of our material, there's still that illusion of depth that's provided to us by the actual normal map. And then finally, I think we can play with the ambient occlusion intensity. It wasn't that obvious with our actual grass, but you can see if we actually try it with our space cruiser, you can see that there's a decent amount of difference. So more ambient occlusion, you add to this, the more it looks like there's actual depth to the object itself.
05:18:56.640 - 05:19:43.830, Speaker B: So I hope that puts all of these concepts regarding the actual PBR textures together for you into one kind of easy explainer. I'm going to leave this as the actual final output of this project. So you can download this, play with this yourself, play with the different roughness. If I make this less rough, you can see that this doesn't actually uniformly apply. So all the bolder, and I think that gets us a pretty realistic look. And I think you should go have some fun and play with some of these sliders to see what the different channels do. Congratulations.
05:19:43.830 - 05:20:25.456, Speaker B: If you've made it this far and you didn't skip ahead means that you have covered most of the topics that are required for you to create something pretty cool in three js. There's lots more to learn, so make sure you stay tuned for working with 3d models and creating our own custom portfolio. But for today, we're going to be putting all the stuff that we actually learned in previous lessons together into a cool scene. And it's something that you'll, by the end of it, will likely be able to put into your portfolio. You can show it off. And specifically, what we're making is we're actually creating a solar system in three js. It's not super complicated, but by the end of it, I think it will look very, very cool.
05:20:25.456 - 05:21:20.052, Speaker B: So I hope you're excited for that. And without further ado, let's go ahead and jump right in and get us some practice and kind of recaps on the stuff that we've already learned. All right, so before I start any real project, and the bigger the project, the more important this becomes, I always like to kind of plan out what I think we're going to want to do and what I think I'm going to want to achieve by the end of the project. And then kind of start narrowing down the steps I'm going to take to get there. And I think this is a similar case to this lesson. This lesson isn't necessarily too complex. So it's not like we're going to need some multi step planning process, but I would like to kind of get a scaffold, at least at a high level, to understand what we're going to do.
05:21:20.052 - 05:21:47.044, Speaker B: So the first thing we're going to do is we're going to need a sun. So we're going to create a mesh. The mesh is going to be a sphere. And at least at the top of my head, most of the things, if not all of the things that we're going to create are going to be spheres as well. So we'll stick to having a sphere geometry. We're going to use it for the sun, and then we're also going to use it for the other planets that revolve around our sun. So with these planets, we know that these planets are going to spin on their own axis, so we expect them to be spinning on their own axis.
05:21:47.044 - 05:22:21.258, Speaker B: And this is something that we know how to do. You know, we know how to rotate something on its own y axis, but we also expect it to be rotating around the sun. And this isn't something that we've done so far. We've animated meshes that go back and forth left and right, kind of with that sign pattern. So we remember when meshes kind of like went back and forth, but we've never actually rotated a mesh around a center point of origin. So we're going to have to learn how to do that. And as well, not only are we going to have to rotate planets around the sun, and we're going to have different planets that rotate around the sun at different orbits.
05:22:21.258 - 05:23:19.622, Speaker B: So some are closer to the sun, some are further from the sun. We're also going to have little moons, and we're going to have these moons that are going to rotate around the planets themselves. Now, our moons aren't going to be orbiting around our sun the same way that our earth is, even though eventually it does circle around the sun. But realistically, our moon's orbits are going to be relative to the actual planets, and we have learned how to do that, and we've learned how to basically inherit transformations from parent to child. So that's going to be something that we're going to have to keep in mind in this lesson. And finally, we're going to try to, I mean, there's going to be a lot of planets there's going to be a lot of moons, and you know, to add this by hand, I'm sure you can imagine becomes fairly cumbersome. So we're going to take advantage of some JavaScript tooling to basically help us create that by abstracting some of the hard work, putting them into reusable functions and then using that to help actually generate our solar system.
05:23:19.622 - 05:24:16.690, Speaker B: Now I think the first thing that we're going to want to do is basically understand the idea of planets rotating around, or objects rotating around some center point of origin. And so we're going to use that, we're going to apply it to the planet, we're going to apply it to the moons. And so let's go ahead and get us started with a very quick prototype of how this would work. Alright, so let's get started here. The first thing we're going to add to our scene is the actual sun itself. So recall that any meshin three j's takes a geometry and a material, but we are going to be using the exact same geometry for every material. So let's go ahead and initialize a generic sphere geometry equals new three dot sphere geometry.
05:24:16.690 - 05:25:20.906, Speaker B: And then the argument we're going to pass it is a radius and then the width and the height segments. Now I know that we will have different sized objects for obviously the sun's not going to be the same size as the actual earth, but instead of passing, you know, creating different spheres with different radius properties, instead we're going to create a generic sphere with a radius of one and width and height segments of 32. And then we're just going to scale up the actual mesh itself, not the geometry, depending on which object we're dealing with, those are two ways to basically influence the absolute size of the objects is one we can actually change arguments we pass into the geometry, or you can just scale them up and down after the fact. Let's go ahead and create a material for our sun, and we're actually going to call this sun material because we're going to have to have a different material for our sun than we would for earth or moons. So let's make it a three mesh basic material. And the reason why we're using a mesh basic material is because we don't want it to be dark in any spots. It's going to be our emitter almost of light.
05:25:20.906 - 05:25:49.260, Speaker B: So it's going to take an argument that is an object and that object itself is going to hold arguments like color. And for us let's do yellow. Or alternatively, if you wanted to pass in the hexadecimal code. You could actually just search up color picker on Google. You can go ahead and find the color that you desire. And so let's say I wanted something like this. I can pass everything after the actual number sign into this hexadecimal argument.
05:25:49.260 - 05:26:23.832, Speaker B: So let's do color of yellow that we're going to do. Then we're actually going to create the sun new three mesh we're going to pass in this sphere geometry and then the sun material and then we're going to go ahead and add it to our scene. Scene add sun. All right, so we have our sun. It's looking a little bit small, but obviously that's relative. It's just because my actual camera is positioned far from it. But because everything is going to be relative to the actual sun, we don't want to be dealing with, you know, planets that are like a fraction of a decimal.
05:26:23.832 - 05:27:01.292, Speaker B: So let's go ahead and scale that up. So we could do sun dot scale and then we can call multiple different methods to achieve the same purpose. So we can do it. Go ahead and call set set takes three arguments and scales the x, y and z values respectively. Or we can go ahead and actually call set scalar because we are going to scale it by the same x, y, z coordinates because we are dealing with a sphere and we're going to do set scalar five and that'll just blow up our actual sun. Perfect. At this point I will go ahead and tell you that we're going to basically quickly add in our earth and moon without caring too much about how it looks.
05:27:01.292 - 05:27:30.270, Speaker B: We'll deal with that a little bit later. But I think it's going to be important for us to first nail down the functionality of what we were trying to achieve before we go ahead and actually try to make our scene pretty. So don't worry, we will end up with a good looking scene, at least to my eye, I promise. But let's go ahead and focus on the functionality first. So to do so, let's go ahead and add the next object, which is the actual earth. And that Earth is going to take the same geometry but a different material. So let's go ahead and create a new earth material.
05:27:30.270 - 05:28:11.692, Speaker B: And obviously for demonstration purposes we're going to just stick with a very basic material. So we're going to add a mesh basic material and we're going to pass in a color value of blue. Next we're going to actually create the actual earth itself. So earth equals new three dot mesh. It's going to take in the geometry and then the earth material and then finally we're actually going to have to set the position. So if I didn't set the position, what would you expect us to see? Well, it would be basically we'd be spawning earth right in the middle of our scene. And because our sun's so much bigger, it would just kind of consume it and we'd be really confused as to where that was.
05:28:11.692 - 05:28:35.014, Speaker B: So let's go ahead and just do earth position. And we only have to change one value, one axis so we can change it on the x axis and we're going to say x ten. And then we're going to go ahead and add it to our scene. Scene at Earth. I did something wrong. Let's go ahead and check what I did wrong. Earth is not defined.
05:28:35.014 - 05:28:57.140, Speaker B: Of course it's not, because I spelled it completely wrong. Okay, perfect. So we have a sun and we have its Earth. And then the only thing we're missing in this very, very simple demo is the actual moon. So let's go ahead and reorganize this a tiny bit. So we'll add the sun right after we've created it and scaled it. And then finally we're going to do moon material.
05:28:57.140 - 05:29:32.168, Speaker B: It's very similar to how we did. The Earth was new three dot mesh, basic material. And then we're going to pass in a color of gray. Finally we're going to actually create the moon itself. Const moon equals new three dot mesh. And then it's going to take in the geometry and it's going to take in the material. We didn't have to scale the actual Earth because the sun has already scaled up and we just left the Earth to be one.
05:29:32.168 - 05:31:03.080, Speaker B: But if we want to the actual moon be smaller than our Earth, so we'll set scalar or do 0.3 and then we're going to assign it a position. And now at this point you may recall from our last lesson and just conceptually the idea that we want to have our actual moon sitting relative to the position of our actual planet. So the actual distance property that we provided, or the actual position of property that we're going to provide it is actually the local property. And recall that when we talked about a local versus world position, the local position is going to be relative to its parent and that parent is going to be the actual Earth. So if we wanted a moon to be on our right hand side, if you take a look at the experience, if we wanted to be at the right of the earth. Right now, knowing that the distance from the actual Earth from the sun is ten, what would we need to basically do? What's the minimum value that we'd actually need to provide the moon in order for it to sit to the right of the actual Earth? Well, if you guessed minimum of ten or any value above ten, you're talking about world space and you're talking about basically we need to have an x distance of at least ten in order for the moon to be positioned further right of the sun in world space, but in local space, because we're positioning it relative to the actual Earth, any value over zero will technically make it so that the actual moon is further right, at least in our scene perspective wise, to the actual Earth.
05:31:03.080 - 05:31:47.860, Speaker B: So let's go ahead and provide it with a position x of something small, like two. But let's make sure that when we actually add it to our scene, we're adding it not to the actual scene itself, but we're adding it to the Earth. And what we're basically saying is the moon is a child of the Earth, which is ultimately added to our scene, so still exists in our scene, but we're adding it as a child of the Earth. So let's go ahead and save now. And you can see even though the distance is a distance of two, it's still further away from the actual sun than the Earth is. All right, now, the next thing for us to do is to actually make sure that these planetary objects are orbiting around as you would expect them to. So let's do that in the next lesson.
05:31:47.860 - 05:32:34.692, Speaker B: All right, let's go ahead and get our actual meshes moving. Now, if you may recall from our animation lesson, anytime we want to animate something, we are going to go ahead and add that animation. Add animation here. We're going to add that animation into the render loop. Now, let's think about the types of things we want to animate. One for sure, we want our actual planets and our moons to start orbiting stuff, but as well, we also want them to start rotating on their own. So let's go ahead and do that.
05:32:34.692 - 05:33:15.148, Speaker B: We know that the Earth rotates, or I hope we know that the Earth rotates so we can do Earth dot rotation. And recall that we access the rotation and then an x, y or z property of the rotation and we'll do plus equals 0.01. Now, you're not going to notice too much here because the actual Earth, I mean, it's one color, so you're not going to tell when it spins. Until we start adding textures to it. What you will notice, though, is when I actually start rotating the earth, the moon automatically starts rotating around it. Well, that's because the moon is a child of the actual earth. And when we rotate the earth, all of its children are going to rotate around, too.
05:33:15.148 - 05:33:51.722, Speaker B: And because its distance is relative x value is 2.5, or I believe so, or its relative x value is two, it's always going to rotate two units around the actual earth itself. Now, if you think about this, this makes a lot of sense. This is one way for us to rotate stuff, and this would work if we actually start to. Now, for example, if we wanted to rotate our earth in the same way, we would go ahead and attach our actual earth to our sun. And then if we rotate the sun now we have the actual earth rotating around the actual sun. And if you think about it, this makes a lot of sense.
05:33:51.722 - 05:34:35.660, Speaker B: Basically, if you have an object and that object is rotating, right, it's rotating. It could be a cube. But as long as it's rotating, it doesn't matter if you attach, like, a string or you attach some type of object sticking out of it, a straight object sticking out of it, and then you basically maintain that rotation. Well, now that object that's sticking out of it is basically describing a full circle. So let's go ahead and see what happens when we actually go ahead and try to apply the same principle into our solar system by doing, instead of adding the actual earth to the actual scene, what we're going to do is we're actually going to add the earth to our sun. A couple things happen here. For one, it's big now, and we also haven't started rotating it.
05:34:35.660 - 05:35:09.254, Speaker B: So let's go ahead and do sun rotation. Y plus equals 0.00. Let's have a smaller value. A couple things are happening here, for one, because we've added it to the sun and we've actually scaled up the sun to five, all of its children is going to inherit those properties. So this earth will also be scaled. Another thing that's happening is the fact that we're rotating our sun at all. And I'm not actually sure how fast our actually sun rotates, but I'm sure it's not that fast.
05:35:09.254 - 05:35:51.626, Speaker B: I'm sure there's just some type of spatial inertia that keeps it going, but it's not how the earth rotates. And as well, this might not actually work for us in the way that we think it does. Let's go ahead and actually extract the actual earth out of the sun's orbit as it currently stands. So let's do scene add Earth, and let's describe what would happen if we actually had multiple planets. If we had multiple planets, and they all kind of followed the same principle, such that they were all attached to our sun so that they can orbit around our sun. Well, there's going to be no way for us to actually control those individual orbits. They'll all essentially be in a line, even though you can kind of, like, change its actual local position to make sure that this not all lined up.
05:35:51.626 - 05:36:28.630, Speaker B: Well, they're all going to be rotating in the exact same cadence. There's no way for an object to be kind of like, rotating faster than another one. So, for example, some planets may have faster orbits than others. So we kind of don't really want to use this technique to describe circles for us. It's not very useful when you have more than one moon and there actually are multiple planets with more than one moon. And so it would make sense for us to actually describe the way that we're animating circles in another way. If you think back to our animation lesson, we had a way of describing an animation that basically oscillates back and forth.
05:36:28.630 - 05:37:25.368, Speaker B: And the way we did that was with something called the sine function. And what the sine function did for us is essentially, as we passed it, a value that increments for us, we passed it time. And because we passed it time and that time increments, the actual output of that sine function would basically oscillate from a zero to a one, a one to a zero, a zero to a 0.1. And what it'd basically be doing is basically be creating this constant up and down pattern in a smooth way, such that the actual output of the pattern can be used to describe 3d objects that move like left and right or up and down. But what we are doing is we are only translating that mesh on one axis. And so we can specify on the x axis or the y axis. But what we can also do is if we actually pass in a cosine function, which basically does the same thing, except it does it from one to zero.
05:37:25.368 - 05:38:19.082, Speaker B: So it's basically opposite. Instead of going from zero to one, it's going from one to zero. If we use the cosine to translate it simultaneously on another axis, what we can do is essentially, we can end up basically going in a circle. It's not super technical, but we can definitely dive deep into trigonometry to explain how this works. But essentially, what we're doing is instead of oscillating just on one axis, we're oscillating on two axes. And because of the way that sine and cosine are kind of opposite, if you plot the output of one on one axis and you plot the output of another on a perpendicular axis, what you end up with is basically every value that that function produces given the exact same variable passed in. So right now, I'm passing in the same x variable regardless of what variable I pass in, as long as they're the same.
05:38:19.082 - 05:39:11.950, Speaker B: If you plot the output of those functions on x and y, or basically on perpendicular axes, the output will always land on some point in a circle. And if we end up plotting points that are basically constantly increasing, what we can describe is a circle that kind of goes round and round and round at a constant interval. So if that wasn't a sufficient enough explanation for you, I would highly recommend you kind of like play with this tool to kind of see visualize what's going on. So this green value is basically describing the output of the actual sine function. The blue value is described the output of the actual x function, and they're plotted on perpendicular axes. And you can see how as one gets bigger, the other gets smaller. And because they're on separate axes, what that basically means is that you go in a circle.
05:39:11.950 - 05:39:49.532, Speaker B: And so I recommend you check out basically under the video, I'll have a link to this tool. I think it's a great way to visualize what happens with sine and cosine, but let's go ahead and try to actually implement that in the code. If you're not entirely comfortable with the concept after that explanation, don't fret. I'm hoping that actually going into the code and actually implementing ourselves would help you understand a little bit better. So don't try to go back potentially, and kind of like watch it go word for word and try to like, really break it down. If we actually go ahead and implement the code, I hope it'll become a little bit more clear. I'm going to go ahead and remove the rotation of the sun because we don't need that to rotate anymore.
05:39:49.532 - 05:40:33.764, Speaker B: And let's go ahead and actually start to change whatever axis is. So like I said, all we have to do is we have to basically let sign describe one of our axes and let cosine describe the other one. But the axis is we're going to use is the x and the z axis. If we want to use the Y, we can use the Y. However, by using the y axis, what we're going to do is we're actually going to have it almost like tilted on its side because the Y is going to describe an oscillation on the vertical axis. So basically, if sine of x is describing the Y, you're going to basically have something that goes up and down. So instead we're going to go ahead and make sure that we are influencing the x axis.
05:40:33.764 - 05:41:11.736, Speaker B: We're going to say it equals math dot sign and we're going to pass it some value. That value. All it needs to do is it needs to just like constantly increment in order for us to have it smoothly go in circle. So let's go ahead and initialize a clock because constantly increasing value could just be the amount of elapsed time since the start of your application. So let's do const clock equals new three clock. We're going to go ahead and call the get elapsed time. Elapsedime equals clock get elapsed time.
05:41:11.736 - 05:41:41.450, Speaker B: And we're going to pass that elapsed time into the actual sine function. What we're also going to do, well, first, let's go ahead and save and see what we get. You'll notice that we lost our earth. And that's because, as you may recall, sign goes from zero to one, back to zero, back to negative one. So basically it has a range of one to negative one. And for that reason, our actual earth is within the sun, kind of oscillating back and forth. Basically, the distance isn't far enough for us to actually see what's going on.
05:41:41.450 - 05:42:27.024, Speaker B: And the value that we're going to multiply this by is we're going to multiply it by ten because we want the radius of our orbit to actually be ten. And by actually specifying or multiplying our amplitude, which is currently going from one to negative one, our actual output after multiplying it by ten is going to go from ten to negative ten. And that's actually going to describe the radius of the orbit that we have. So whatever we expected the actual absolute distance to be between our Earth and the sun, we're going to go ahead and pass that and multiply the actual output of this sine function. So let's go ahead and save and see what happens. So now you can see that our earth is moving far enough away from the actual sun that we can actually see what's going on. But if I actually rotate the camera.
05:42:27.024 - 05:43:16.894, Speaker B: So now I'm kind of trying to get a bird's eye view of it, you'll see what's happening. It's basically only oscillating on one axis and let's go ahead and try to impact the other axis. I'm going to go ahead and copy this, paste this, and instead of the x coordinate we're going to affect the actual z coordinate and we're actually going to use the cos function. I'm actually going to comment out the sign function just so you can see what both of these functions do independently. So now you can see if I get the bird's eye view of this. It's basically doing a very similar thing to what the sine function is doing, but instead of going kind of horizontally left and right, at least from the top looking down, it's kind of going forward and backwards. And now if you combine both of them, if you really think about what a circle is doing, it's basically just going back and forth but on two axes.
05:43:16.894 - 05:44:10.330, Speaker B: And if I go ahead and comment the sign and I save now you can see if I get my bird's eye view, we're finally oscillating around the sun at a constant axis. Now you can see that our moon itself has that kind of, I mean, it's still rotating because it's rotating about the actual Earth's rotation. So let's go ahead and make sure that each moon itself has its own orbit as well. So we can do moon position XDev equals math dot sign. I'm going to pass it in elapsed time and I'm going to multiply again by the radius that we want for it. So we had, we previously had two, so we're going to do the same thing and then we're going to basically do the same thing on the Z axis, but instead of sign we're going to use cosine and let's go ahead and set what we have. Okay, perfect.
05:44:10.330 - 05:45:18.884, Speaker B: That's basically all the logic that we actually need for our solar system. Now all we got to do is populate this with more planets and more moons and assign them their appropriate materials. But instead of doing that by hand, in the next lesson we're going to take advantage of some JavaScript tools to really start merging three js and JavaScript to take advantage of a little bit of automation. So I'm going to see you in the next lesson and let's get a few more planets within our solar system. Alright? So at this point in lesson what we can do is we can actually basically take all the principles of the things that we already just learned about and just keep adding planets, keep adding moons, and then before you know it, we'll basically have a fully functioning solar system. It was in three g's. However, that's going to be a lot of repeated code, and that's going to be by the time we get to our fifth planet and that fifth planet perhaps having like twelve moons, it's going to be pretty chaotic.
05:45:18.884 - 05:46:26.052, Speaker B: Basically going the same way that we were doing so far, where we're creating a mesh, we're passing in a geometry, we're creating custom material, and then we're setting a size, setting a scale, setting a position, and it's really not going to help us be organized, not really an organized way of kind of going about this project. So instead what we're going to do, I'm actually going to delete everything that we've created except for the actual sun itself. And I'm actually going to start storing some of our information into an array of objects. And those objects are going to hold information about our planets, it's going to hold information about the size of them, the distance from the sun, the speed of rotation, and it's going to help us basically be concise about where we're storing all this information. And then in order for us to actually create the planets themselves, instead of creating them verbatim, like kind of like new mesh, new this, do that, like multiple many times, we're going to create helper functions that are going to automate some of that for us. And this is more often than not when you're working on large projects. And it's going to be important for you to start thinking in this way.
05:46:26.052 - 05:46:50.882, Speaker B: How could I automate the way that I actually create my three js or my JavaScript experiences? So to do so, we have our sun. So I'm going to go ahead and actually remove some of this. So we have our sun. We're not actually going to use the elapsed time. I'll show you why in a little bit. And I believe so I've deleted the planets, I just have the sun. We're keeping the sphere geometry and we're keeping the sun material.
05:46:50.882 - 05:47:27.390, Speaker B: We'll go ahead and save and the next thing we're going to do is I'm actually going to create an array and I'm going to call it planets. And it's going to be array, an array with square brackets, and it's going to consist of different objects, and each object is going to hold information about each planet. So let's go ahead and start with earth. So we're going to start with, what we're going to need is maybe we'll have a name, so we'll have this earth and this is more for us to know. Have a name. We'll have a radius and then maybe this will be one because our actual sun was like five. We'll have a distance, maybe of something like 20.
05:47:27.390 - 05:48:02.692, Speaker B: And then we are going to also have a speed. And I'm kind of just making this up as we go. I'm saying kind of because, you know, I've already created this before, so I'm just basically, like, copying the actual values that work. If you were creating this from scratch, I'm sure what you would probably do is kind of experiment with different numbers. So we're going to create a speed, and that speed is going to inform our actual animations and we'll get to that a little bit. And as well, we are going to create a material and we're going to call it Earth material. We're not going to have access to it yet.
05:48:02.692 - 05:48:39.270, Speaker B: And then finally what we're actually going to do is we're actually going to have an object called moons. And the reason for that is because there are going to be objects with multiple moons. Essentially, what that moons is going to describe is it's going to hold an array of objects and each object is going to be a moon. So basically, in the same way that we were describing some properties of our actual planet, where I'm going to pass in the name, I'm going to pass in the radius. Radius 0.3. So it's much smaller. I'm going to say the distance, three.
05:48:39.270 - 05:48:55.722, Speaker B: And then we're going to need the speed as well. And I'm going to set that to 0.015. Again, these are just like random values that work for me. There's nothing. They're more or less arbitrary. So that's basically how I describe one planet. I'm not going to go through this entire, like, every single planet.
05:48:55.722 - 05:49:26.476, Speaker B: I'm actually going to fast forward. But if you like to basically keep up, what you could do is you could actually download the actual file pack of this course and basically just like, copy in the values that I'm going to provide, or you can just kind of, like, take them from my screen. So I want to go ahead and fast forward and do that. All right, so I went ahead and added in Mercury, added in Mars and Venus as well. I actually didn't know that Mercury and Venus didn't have moons, but Mars has too. I mean, they're barely moons. They lay asteroids, like not round at all.
05:49:26.476 - 05:50:23.130, Speaker B: But anyways, I think that's good enough for us to start. And so in the next lesson, let's go ahead and take this array and let's pass this into helper functions to help us get information or basically turn them into meshes, add them to our scene and then animate them. All right, in the next lesson, we'll actually take our array of planets and moons and we'll go ahead and pass them through helper functions to help us actually create our scene automatically. But before we do that, we actually made reference to multiple materials. So you can see we have Mercury, Venus, Earth. And so let's go ahead and actually create those materials ourselves. If you look into the static folder, you'll see that I actually have a bunch of textures that are provided for you.
05:50:23.130 - 05:50:49.150, Speaker B: The ones that we're going to load in this lesson are going to be the Earth day map. Mars, Mercury, moon, and the sun and the Venus. Don't worry about the Milky Way backgrounds and don't worry about the textures of the cube map. We will be worried about that a little bit later in the course. But for now, let's go ahead and create our texture loader. Let's load those in and let's add those two materials. So let's go ahead and say texture loader.
05:50:49.150 - 05:51:34.210, Speaker B: Then we'll do const, texture loader equals new three dot texture loader. So this texture loader is going to be responsible for loading all of our textures. And we do so by actually saying, adding textures, by actually calling the actual texture loader load. And so I'm going to give you an example here of the actual sun called sun texture. And I'm going to go ahead and pass in the URL for the sun texture. So we do texture loader load and then we can go ahead, I'm going to go pull the actual sun JPEG, copy the relative path. I'm going to paste it in to here and remove the actual static.
05:51:34.210 - 05:52:09.158, Speaker B: And then I'm going to go ahead and actually log it out. Console log texture. And then make sure that before you actually run this, you go ahead and comment out this actual array because this actual array has references to materials that we haven't created yet. So if I go ahead and save, let's see that we get our sun back and then we also have the texture perfect for the sun. Again, we want to use our mesh basic material because we don't want it to be impacted by light. It essentially is going to be where the light in our scene comes from. But all of the other objects, we want to make mesh standard material.
05:52:09.158 - 05:52:30.810, Speaker B: But for the sun, let's go ahead. We can remove this color because we'll no longer be using this color parameter. Instead, we'll be using the map parameter and we'll pass the sun texture in. Okay, perfect. So we have the sun texture, and let's do the same thing for all the other textures. So I'm going to go ahead and fast forward while I load all the other textures. And let's go ahead and build materials out of them.
05:52:30.810 - 05:52:56.058, Speaker B: All right, so I went ahead and loaded all of the textures that we're going to be using except for the background. So we'll be using the Mercury, Venus, Earth, Mars, and as well as the moon texture. I'll be using the same moon texture for all of them. They're going to be pretty small anyway, so you don't really tell the difference. But, you know, I'm sure you can imagine the moons don't look very different from each other. There's just this, like, gray rock. So let's go ahead and create materials for each of these actual planets.
05:52:56.058 - 05:53:43.940, Speaker B: So we're going to do const Mercury material, and instead of mesh basic material, we're going to be using the mesh standard material again because we want it to be impacted by light. So we do mesh standard material or pass it in a map, and it's going to be Mercury texture. All right, I'm going to do the same thing for all of the other materials. All right, I've added in all of our other materials. And then finally, if we go ahead and actually uncomment out this array and save, you should see that we no longer have an error because now we've actually provided it the proper materials. Obviously, we haven't done anything with these materials yet. And that's going to be the next lesson where we pass this array into some helper functions to help build out our entire scene.
05:53:43.940 - 05:54:31.224, Speaker B: All right, so we have our list here of all of the actual, actual planets that we want to add and all their moons. And what we want to do is we want to go through this list. And for every planet in that list, we're going to want to create a mesh, and we wanted to add it to the scene. We want to, for every planet's moon, we want to do the same thing, but we also want to actually keep track of all those planets so that we actually have access to them. When we go into the render loop and start animating them. So we want to do two things here. The first thing can actually be accomplished by a simple for loop loop.
05:54:31.224 - 05:55:10.854, Speaker B: So that basically means that we just go for each object within our planets array. We can go ahead and just add it to our scene. But as well we also want to keep track of all of these objects so that we can have access to them within the render loop. And what that means is the best way for us to do that is actually call a map method. And a map method is a method that you call in any array, so an array for example being our planets. And the way that you call the map method is you call it map. And the map method actually takes a callback function and it basically passes each object of that array into the callback function and then the return value of that function gets returned into a new array.
05:55:10.854 - 05:56:07.428, Speaker B: Let me show you what that actually means. So do const test array and then basically we pass it a callback function. And what we're going to do, what this map method is going to do, it's going to iterate through every object of this array and it's going to basically call the callback function on that object. And the way that the map method has access to each object within planets is we actually pass it a random variable. You can call this whatever you want, but I'm going to call it planet and then we have access to that object within our actual function. So if I do console log, planet name, planet name, and then I go ahead and actually console log it out, you can see that what I'm doing is basically I'm going through every object in this array and I'm passing that object into a function. And that function, we could do whatever we want with that actual object.
05:56:07.428 - 05:56:59.270, Speaker B: In this case, I'm logging out the name. Cool thing about the actual map method over something like a for loop is I can actually specify a return value and the return value I'm going to say I'm going to return the planet dot name and that return value is going to be passed as a separate object into a new array that I'm calling test array. So if actually go ahead and console log this out, the test array, you can see that this new test array, instead of having, you know, all this exact same objects, this test array actually has a array of return values that we've actually got from this function. So you can see I've basically on each one I've returned the name. So now we can have an array of each of our planets names. And so what we're going to do is we're actually going to return an array of actual planets. And this array of planets we're actually going to pass into our render loop.
05:56:59.270 - 05:58:03.130, Speaker B: And that render loop will handle animating all of our meshes for us now that we have access to them in a clean array. So let's go ahead and actually call that map method onto our planets array. And then we're going to return that into an array of meshes that we're going to use to animated called planet meshes. And we're going to do planet map. And then we're going to basically take in a callback function that takes each planet, it's going to actually create the mesh, add it to our scene, and then it's also going to loop through each moon and create that, create the moon and then add the moon to the planet. All right, let's go ahead and take this step by step by first going ahead and actually logging out the planet and taking a look at what we have. So we'll do console, dot, log, planet.
05:58:03.130 - 05:58:44.348, Speaker B: If I log out the planet, you can see that within each of these objects we have access to all the properties that we actually passed it before in the actual object. And let's take a look at the ones that are going to be relevant for us. So we have a distance that's technically not going to be relevant for us until we actually start animating it. But we may have to use that to basically, if you want to see the results of the impact of our actual code before we start animating it, we can go ahead and use that. We have the material that's going to be relevant to us when we create our mesh. Obviously, we have the moons, and then we also have the radius that's going to impact the way that the actual scale of our object is. And then the speed doesn't matter until we actually start animating our objects.
05:58:44.348 - 05:59:36.608, Speaker B: So let's go ahead and create the mesh by going ahead and doing const, planet mesh equals new three three mesh. And we're going to pass it in our sphere geometry, pass in the planet dot material. And that's basically how we access these internal properties. We do, we use the actual dot just like we access any other property of any other object that we have. And then we can go ahead, set the scale by doing planet mesh, scale dot set, scalar and then we're going to pass in the planet radius. Finally, like I said, we don't actually have to deal with the actual radius, the distance itself until we start animating. But we probably want to be able to actually see it on our screen.
05:59:36.608 - 06:00:02.222, Speaker B: So let's do planet mesh. Position x equals planet distance. Let's go ahead and add that to our scene. So add it to our scene by doing scene add planet mesh. Let's go ahead and save and then let's take a look at what we have so, so far. It doesn't look like there's an okay well, and there we are. So what we've done so far is we've actually initialized them.
06:00:02.222 - 06:00:29.092, Speaker B: We've set the scale of them, we've set the distance, but we currently can't see them because they are a mesh standard material. And remember that with mesh standard materials, what we have to do is we have to actually add lights to our scene. Let's go ahead and add an ambient light. Ambient light equals new three dot ambient light. And I'm just going to put a default white light in there. So I'm going to do a white light and I'm going to have a 0.5 intensity.
06:00:29.092 - 06:00:46.686, Speaker B: And then I'm going to have to add it to our scene. Just like that. We've basically looped through all of our planets. We've assigned them the proper scale. We've signed them the proper distance from the sun, and we've actually assigned them the material. So this is actually looking pretty cool right now. Obviously, we haven't animated them, so this isn't very dynamic.
06:00:46.686 - 06:01:16.982, Speaker B: But we also haven't actually added our moons. So let's go ahead and loop through each of the actual moons. And let's go ahead and create them to access our moons. If we do console dot log and we do planet moons, you can see that our actually moons exist in their own arrays. So you can see the first two planets, I believe Venus and Mercury, they do not have moons. So they have an array of zero, but the following two planets. Earth has one moon and then Mars has two.
06:01:16.982 - 06:01:51.440, Speaker B: So what we want to do is for every planet, for every planet's moons, we want to actually go ahead and do planet moons. And we want to basically run a for loop on each of them. So we can do foreach dot for each moon. Let's go ahead and actually console, log it out. Console log, moon. So I'm going to go ahead and add another bracket to that. And let's go ahead and log it out.
06:01:51.440 - 06:02:20.122, Speaker B: You can see for the first two there's no moons. So we didn't log it out. But after that, for each moon that exists on this moons array, we can actually go ahead and log it out. And so basically, to access these properties, all we have to do is we can do for each moon dot something like radius. Let's do radius. Let's log out the radius. And you can see now, basically we have the same access to those properties that we did previously where we're accessing the actual radius values of our actual planet.
06:02:20.122 - 06:02:52.602, Speaker B: We can do that by basically saying for each of the moons, we pass the moon into this function and then the properties can be accessed in the exact same way. So let's go ahead and do const. Moon mesh equals new three dot mesh. Go ahead and pass in the sphere geometry. But instead of passing in the moon material, we're going to pass in our generic moon material that we created from that one texture. We're basically going to reuse that same texture for all the moons. And then we're going to want to actually set the scale.
06:02:52.602 - 06:03:44.978, Speaker B: So we're going to do moon mesh scale dot setscaler to moon dot radius. And then we're going to want to set the position. So moon mesh, dot position dot x equals moon dot distance. And then finally, what we're going to want to do, instead of actually adding it to our scene, remember that we're going to add it to our planet. So we're basically going to do scene dot, add planet mesh, or, sorry, planet mesh, add moon mesh. And then finally we're going to actually return the planet mesh. And then we're going to take a look at the actual console dot log planet meshes to see what we have.
06:03:44.978 - 06:04:11.652, Speaker B: If I go ahead and save, you can see everything that we wanted to add to our scene has been added appropriately. Our Earth has our little moon. Our Mars has its own two little moons. And then if I go into the actual array, you can see that array has all the meshes. And you can see, okay, so it has four meshes so far. And these are all of our planets. But where are our actual moons? Well, because they exist within the three G's hierarchy.
06:04:11.652 - 06:04:46.870, Speaker B: If you actually take a look into this one for Earth and I go to his children, you can see now that the children is where we actually store our meshes, which should mean that if I actually go into the last mesh that we have and we go into its children, you can see that this is actually Mars. And you can see that there's two children, each of them representing a moon. Perfect. Okay, so that's exactly what we want to do. We can actually, you know, for the purposes of teaching, let's go ahead and actually abstract this out one more time. And then we're going to abstract this out into functions. One of them called const create planet.
06:04:46.870 - 06:05:14.214, Speaker B: And then we're going to create function that takes in a planet from the list of planets. And it's going to actually create the mesh and add it to the scene. And add it to the scene. And then we're going to go ahead and do the same thing for the for the moon. So I'm going to do create moon and it's going to take it a moon. And it's going to create the mesh and add it to the scene. Perfect.
06:05:14.214 - 06:05:45.518, Speaker B: I'm going to go a little bit quickly here because basically what we're doing is just reorganizing the code. So it takes a planet. So what we can do is actually create the planet mesh in here, right. And then we're going to set the actual scale and the distance. And then we're actually going to return the planet mesh. So planethood return the planet mesh. And then that planet mesh is going to be returned into the output of this create planet function.
06:05:45.518 - 06:06:33.788, Speaker B: And then we can use that actual mesh that's returned and then add it to the scene while we're inside this planet meshes array. So let's go ahead and do create the mesh. So we'll do const planet mesh equals create planet planet. And then we're going to do scene dot at planet mesh. And then for each moon we're going to basically pass in, we're going to create the geometry, we're going to set the scale, set the distance, and then we're going to return the moon mesh. So for each moon, what we're going to do is we're actually going to say const moon mesh equals create moon. We're going to pass in the moon.
06:06:33.788 - 06:07:06.794, Speaker B: And then finally we're going to take that moon mesh that's created out of the actual create moon function because we return it right here and we're going to go ahead and add it into the actual planet mesh. If I go ahead and save, we should get the same results. And you can see now we have the same result, but it's just a little bit cleaner because I've separated out that logic. And it's very clear what's happening within this actual array method. It's basically taking each planet, it's creating a planet, adding it to the scene. And then for each moon, it's creating a moon and adding it to the actual planet itself. Perfect.
06:07:06.794 - 06:08:04.000, Speaker B: All right, so we've created all of our planets and the next thing we have to do is we got to make sure that we can start to animate them. All right, so now that we have our actual array of meshes, what we can do is we can actually animate them using a for loop within our render loop. So let's go ahead and try that out. Let's go ahead and do planet meshes. Dot for each. And then we're going to say for each planet we're going to, let's say rotate it on the actual y axis. Planet rotation y plus equals 0.01.
06:08:04.000 - 06:08:37.306, Speaker B: So let's go ahead and do that and save. And now you see. Okay, perfect. So we have our actual planets rotating. However, recall that I actually went ahead and we actually went ahead and actually added the speed parameter into each of these properties. So how can we multiply this actual rotation by the speed? Well, if I go ahead and console log out the actual planet itself and we're going to get like a whole bunch of them because this is happening at like 120 frames per second. So you can see now this is basically like every frame which is 120 times a second.
06:08:37.306 - 06:09:17.368, Speaker B: What we're doing is we're looping through each planet and we actually have no access to the actual properties that we've provided here. Remember that our actual planet meshes is just an array of three g's objects. So these are all three G's properties that are different from the custom properties that we used. Obviously, the custom properties that we use to actually create the planets are going to be passed in as partly as arguments. So for example, we're using the moon distance to actually influence the position property. But at this point of the application with the planet meshes array alone, we actually have no access to the actual properties that we've provided it previously. We have no access to any type of custom speed property.
06:09:17.368 - 06:10:17.418, Speaker B: In order to actually access these properties, let's go ahead and actually log out a second argument that you can pass into the foreach callback function called index. And this index is basically going to provide us the actual index of each planet. And because we have four planets, it's going to go 0123-0123 it's basically going to keep looping and looping and it's going to log out the index of each planet. So you can see we have 0123 back to 0123. And if you pass that index into our actual planets array, so not our planet meshes array, but the original planets array that holds all the information about our actual planets that we're going to create. If you pass that into our planets array, what we're basically saying is for each planet we have access to the planet mesh, but we're also going to have access to the actual properties of that planet. So if I actually now go into each of these actual planet properties, I can see now I have access to something like radius speed.
06:10:17.418 - 06:11:06.026, Speaker B: So now if I log out something like planets speed, I can see basically for every one of these planets, I'm going to rotate the actual planet itself. And I also have access to the actual speed property that we pass it. So now if I go ahead and multiply our actual rotation by the speed and I'll save, and I believe what's happening is they're rotating very, very, very slow. So I'm actually going to remove this multiplier and I'm going to basically just say for each planet we're going to rotate it according to the actual speed that we've provided it. So now you can see now they're rotating according to the actual speed we provided. So you can see how the actual, I believe that's Mercury rotating a lot faster than Earth is. And that's because we've actually provided it a higher speed value.
06:11:06.026 - 06:11:52.232, Speaker B: That's something like Earth. But for demonstration purposes, if I wanted to make Earth or Mercury rotate at a speed of ten, you're going to see that this is going to be kind of ridiculous. You can see now it's spinning out of control. But now at least I think it's helping demonstrate the fact that we have access to that property now. So basically, whatever we provide into this actual planet array, our planets themselves as well as the moons will actually respect that property. Let's go ahead now and basically take that speed parameter, or basically take that information, and now let's actually apply it to the actual orbit. So remember when we were doing our orbits, what we were doing is we were animating the x and the z properties according to sine and cosine.
06:11:52.232 - 06:13:02.188, Speaker B: So we're going to do planet, planet, position, position, dot, x equals mass, dot, sign. And then what we're going to actually do is instead of passing it a date parameter, remember that all we have to pass into the actual sign and cosine values is we have to pass in the same value and it has to be constantly incrementing because we are constantly incrementing planet rotation y. What we can actually do is we can actually pass that value into the actual sign function. So we can do planet rotation y. And then we're also finally going to actually multiply this by the distance. So remember, in order for us to actually make sure that it has an orbit, the radius of that orbit is what we're going to actually multiply the actual sine function by and to get that distance, we're going to basically do the same thing when to do the planets, access the index and we're going to do distance. If I save this now, you can see that again, we're rotating it on one axis and it's basically doing exactly what we expected to.
06:13:02.188 - 06:13:50.848, Speaker B: If we have something like Earth and we have that distance, be something crazy like 50, you can see that I have a much, you know, finer control of what's happening with the actual orbit. So now you can see, because I actually changed distance to 50, that value is being respected. So I'm going to keep it back to a distance of 20. And then I'm going to do the same thing that we did in the previous lessons regarding the actual orbit. And I'm going to animate the position dot z, animate the z property of the position. According to cosine, I would do planets, dot rotation, dot y multiplied by planets and then index distance. Amazing.
06:13:50.848 - 06:14:31.170, Speaker B: So now we have rotating planets. And the next thing that we have to do is we have to make sure that the moons also follow the planets orbit. Alright. In order for us to actually get access to those moon meshes. Recall that the moons are being added to the actual planets themselves. So if we actually go ahead and do console log, planet and I go into each planet mesh, you can see not this one, not this one, but this one, basically have to find either Earth or Mars. Okay, finally, within the actual mesh itself, we have that children property.
06:14:31.170 - 06:15:16.772, Speaker B: And that children property is going to be an array of moons. So if I actually go ahead and do planet planet children and save, you can see now anytime that we have an actual planet with moons on it, it returns an array that's going to be populated by the actual moon meshes themselves. Because it's an array, we can do a similar thing to what we are doing with our actual planet meshes. So we can do planet children for each. I can go ahead and pass in the moon and as well a moon index and I'll show you how we're going to use that in a second into the actual callback function. And I'm going to do console log moon. And so now you can see, okay, now we're actually logging out the meshes or moons.
06:15:16.772 - 06:16:06.932, Speaker B: We're basically going to do the same thing that we did here. However, to actually access these properties, these distance and speed properties, we have to go one level deeper. So before we do that, what I'm going to do is I'm actually going to comment that out of and I'm going to show you how we're actually going to want to access that property. Because previously the way that we actually accessed properties of something like Mars is, let's say console log. We know that Mars is our fourth planet and so we know that because computers, they count from 0123, we can actually go ahead and log out planet number three. So planets three, basically our fourth planet, but the index is three. So if we go ahead and log out planets three, you can see that we have access to Mars and we have access to those properties.
06:16:06.932 - 06:16:44.196, Speaker B: But in order to actually access maybe second moon of Mars, we actually have to access the array itself and then pass in a new index for the actual moon. So the way to do that is to planets Moonshi. If I log this out, this will actually give me the array of moons and then I have to pass in another index that will actually tell us which moon that we want to access. And so let's say we wanted to access the second moon. We know that the second moon has an index of one. So we'll have to go ahead and pass in an index of one. And then from here we can access the properties such as speed.
06:16:44.196 - 06:17:35.610, Speaker B: So instead of going directly planets, something like moons speed, we actually have to access the planets array first access the moon property of that planet and then access the actual index or basically pass in the index of the moon that we would want to use and then finally pass in the actual property that we want to access. So to do that, we basically need two indices. One of them is actually going to be the index of the planet itself and the other one is going to be the index of the moon. And that's essentially where this moon index comes in. So it's just a little bit more complicated. But the reason we have to do this is because we essentially have arrays within arrays. And so finally to access this, what we're going to do is we're going to do moon, dot, rotation, dot, y plus equals.
06:17:35.610 - 06:18:21.960, Speaker B: And so we're basically going to do the same thing. We're going to pass in the first index into the planets array. So we're going to do index, index, dot, moons, right? Dot, moon, Moonindex. And then we're going to do speed. And so I think it makes it a little bit clearer if I actually, instead of calling this index, I call this planet index, planet index. And so we're going to pass a planet index into the actual planets array and then we're going to pass in the moon index into the moon array. So now if I go ahead and save, I just have to do moons moonindex speed.
06:18:21.960 - 06:19:12.134, Speaker B: And so now you can see, hopefully if I zoom in enough, you can see that the actual Earth moon is actually rotating and it's a little bit too fast for me to keep up with it. Let me go ahead and actually just comment out these. So now you can see that even though our moon is orbiting around our actual Earth, it has its own rotational properties. So you can see the same thing happening with Mars moons. Okay, basically we're going to apply the same concept here to the actual distance property. So we're going to go ahead and do moon position dot x equals math dot sign and we're to pass in the moon dot rotation dot y and then that distance property. We're accessing the same way we're going to do planets.
06:19:12.134 - 06:19:32.850, Speaker B: We're passing the planet index and then we're going to do moons. And we're passing the moon index. And then finally we can access that actual distance property. I'm going to go ahead and copy this. I'm going to paste it in so that we can go ahead and just change the actual x to a zenongous. And then we're going to change the actual sign to a cosine. And then I'm going to save.
06:19:32.850 - 06:20:34.758, Speaker B: And then now finally you can see that we have our actual planets orbiting around the sun and then we have each moon orbiting around their own planet. Perfect. Okay, so we're pretty much there. We're just going to do a couple other things in the next lesson to basically touch up our scene and so that we can have something that looks closer to an actual solar system. Alright, so let's go ahead and add some final touches to our scene to polish it up. The first thing you may have noticed is the fact that we went ahead and used an ambient light, which in reality is no different than actually using a mesh, basic material in the way that you light your objects. So instead, I'm going to want to make sure that it looks like our sun is our actual source of light and then everything around it is basically being lit by our sun.
06:20:34.758 - 06:21:36.460, Speaker B: So what I'm going to do is actually comment out the actual ambient light. For now, we'll go to comment out the ambient light. What I'm going to do is I'm actually going to add a point light to the middle of our scene. Now, the one thing that you may be concerned about is if I add something to the middle of our scene, is our sun not going to block our actual light? Well, if you recall from our actual shadow lessons, there's no such thing as actually light occlusion or basically things don't block light within three GS the way that we have shadows, three js implements a custom solution to basically start to fake shadows. And because we have to fake shadows, the actual engine itself doesn't actually make it so that things that block other things naturally block their light. So if we don't manually add shadows to our actual objects, there's no such thing as actually blocking light with another object. So what we can do is we can actually just go ahead and do const point light, add it to the center of our actual experience, new three dot point light.
06:21:36.460 - 06:21:59.814, Speaker B: And instead maybe we want to. I mean, let's start off with a white light for now. And then I'm going to set the intensity to something high, like two. Just so we could actually light our objects that may be a little bit further away. Then we're going to go ahead and actually add it to the scene. So scene, add point light, and we'll see how that looks. Okay, perfect.
06:21:59.814 - 06:22:27.776, Speaker B: So now this looks a little bit more realistic, right? It looks like the fact that they're not just being arbitrary lit, they are being lit from the sun itself. But I'm also not a big fan of having it pitch black behind the actual planets. I know that this is probably more physically accurate, but I always like to have a little bit of ambient lighting. So maybe we'll do it like something like 0.1. So you can at least see a little bit more of like a silhouette. Okay, so that looks a little bit nicer to me. Okay, perfect.
06:22:27.776 - 06:22:48.944, Speaker B: We can also experiment with having a yellow light. So if I do this, or if you search up the actual hexadecimal code to yellow light, it would be fff zero zero. I don't actually like how that looks at all. I'm going to keep it at a white light. Perfect. And the next thing that we're going to do is add a background. So this isn't something that we've actually done yet.
06:22:48.944 - 06:23:21.470, Speaker B: We've changed the actual background color. But let's actually try to load an image and actually add it to the background. In your static folder, I've provided an actual, a two k map. And it's called two k stars Milky Way. And it's basically an HDRI, which is basically another way of saying just this an environment map or a map that dictates basically the background of your scene. And what we can do is I'm going to go ahead and copy the relative path and I'm going to go ahead and load it for us. So I'm going to do const.
06:23:21.470 - 06:23:43.832, Speaker B: Background texture. Round texture equals texture loader. Loader load. And then I'm going to go ahead and actually pass this in. Remove the actual. Just need to make sure that there is no spaces like that. Okay.
06:23:43.832 - 06:24:04.314, Speaker B: Then we can go ahead and console log it out. Background texture. Now let's see what we have. Perfect. So we have a texture loaded. And then what we can do is there actually is a scene dot background property that we can actually assign to the actual background texture. If I go ahead and do that and save a.
06:24:04.314 - 06:24:18.486, Speaker B: You'll see what we have. So we've gotten a background in. Okay, so this, first of all, this looks pretty cool. We've gotten a background in. However, if we actually rotate our camera, what we're doing is we're not rotating the objects within our scene. We're actually rotating our camera. We're pivoting our camera around.
06:24:18.486 - 06:24:48.782, Speaker B: You would expect that if I kind of rotate 180 degrees, we'd be seeing the other side of the actual galaxy. Instead, our actual background is actually completely fixed. And the reason for that is when we actually set the background to a normal texture, what happens is three G's basically just puts it in the background. And that's basically like behind everything in your scene. Basically is just like a plane at the back of your scene. What we want to use is something called an environment map. And an environment map, one way to call it is an HDRI.
06:24:48.782 - 06:25:26.144, Speaker B: Another way someone may describe an environment map is via a cube map. And essentially what happens is with a cube map is essentially just an object or basically a set of six images. So you can see it's a set of six images that basically define the inside of a cube. When you start to pan around your scene, you basically see different sides of the inside of that cube. And the way for us to do it is there's actually an eight k Milky Way. If I actually went ahead and assigned this to the background, I feel it'd be pretty aggressive. But there's an eight k HDRI and it's basically just this background texture.
06:25:26.144 - 06:25:59.382, Speaker B: What you can do is you can actually pass it into this website here that basically takes an HDRI. So I'm going to upload an hdriver. I'm going to maybe change the exposure so you can change the exposure to whatever you feel is appropriate. And then let's take a look at the actual cube map view. In order for us to create a cube map, three JS basically expects six textures like so that it can pass into something called a cube texture loader. And the output of that cube texture loader can be set to the scene dot background property that you could see here. So I went ahead and actually converted this for you.
06:25:59.382 - 06:26:30.580, Speaker B: If you wanted to convert it yourself, make sure that you select this option and you can choose your resolution. I've chose 512, but I believe that 1024 would probably be maybe a little bit more appropriate. This one's a little bit blurry, but again, you don't want to have really big textures. You're going to hit process and it's going to go ahead and actually save it with the proper naming conventions. I went ahead and actually extracted it and I put it into your actual cubemap folder. So I haven't done anything to change these names. And we're going to basically copy what three Jess is doing here.
06:26:30.580 - 06:27:05.010, Speaker B: It's creating a cube texture loader. It's setting a path and it's actually loading an array of textures. So let's go ahead and implement that. I'm going to create a new cube texture loader just like we did with regular texture loader. And so it's called cube textureloader equals new three cube texture loader. We call the actual setpath method to basically say, okay, well, this is where we want you to actually look for the cube textures. So let's do cube texture loader dot set path.
06:27:05.010 - 06:27:30.454, Speaker B: And we're going to set it to our slash textures. And I put it within a cube map folder. Put it uppercase cube map folder. Perfect. So it's basically going to look into this actual path for our cube matte textures. Now to actually load the Cube app textures, let's go ahead and call cube texture loader. We're going to call the load method and the load method.
06:27:30.454 - 06:28:09.600, Speaker B: Instead of taking an argument for just one path, it's actually going to take an argument to six different paths, to six different textures. And you can see within the example what they provided is we have to pass an array starting with positive x, negative x, positive y, negative Ydez, positive z, and negative z. Now, this order matters. It's very important. However, it's not something that you necessarily have to be worried about. For example, because when we actually went ahead and saved, we actually chose the layout that matched this exact specification. And because of that, the actual files that it downloaded matches the actual expectation of three js exactly.
06:28:09.600 - 06:28:54.070, Speaker B: So if we just copy this and paste this in and we can set this to the actual const, background, we'll call it background cubemap equals that. And then we go ahead and set it as our background. Background equals background cubemap and we save. Now you can see the result that we get is now we have a cube map. That's when you go ahead and pan out and you start rotating your actual scene. Now you can see that the actual galaxy in the background is actually responding to our input. Amazing.
06:28:54.070 - 06:29:19.678, Speaker B: So we're going to stop there. If you'd like to take this further, you can go ahead and just add a couple others. So if I wanted to just add another Mercury, I can just go ahead and do that. And I'm going to call this Jesse's planet. I'm going to go ahead and make this distance a little bit further. Maybe I'll make it something like 30. I'll make the radius really big and then I'm going to assign it the same material.
06:29:19.678 - 06:29:44.728, Speaker B: When you create a new planet, you can actually go ahead and download the textures from that link I provided. And now I can save, you can see I got this, Jesse's planet. And it was so easy for us to actually go ahead and implement. I'm going to change the speed because it's rotating at the same speed of Mercury. So I'm going to change it to something like this. Oh, wow. Dica C has his own orbits.
06:29:44.728 - 06:30:21.548, Speaker B: And I hope you have fun with this. We've made it very easy for us to add new planets, add new moons, and then to take this further, I would recommend maybe just like going through and just adding more planets, adding more moons, have fun with it, play with different materials. But if this was your first Brijaz project, congratulations. I hope you found this fun. I hope you found this useful. And as a pretty good recap. So if you were familiar with most of the concepts covered here, that you should be familiar with most of what we learned in the actual fundamentals lesson, and yeah, there's still lots more to come, but I hope you could enjoy the fact that you've created a pretty cool project that you could probably add to your portfolio.
06:30:21.548 - 06:30:25.600, Speaker B: And excited to keep going and excited to continue this journey with you.
06:30:42.110 - 06:31:28.498, Speaker A: You did it. Completing this three JS crash course is no small feat and it shows your commitment to learning three js. But guess what? This is just the beginning. There are still over 30 13 hours of in depth lectures and an incredible project waiting for you in jesses complete three js bootcamp course as I mentioned earlier, you will be creating your own personal portfolio, but with an awesome twist to make it really stand out. Your own personal portfolio will be in the form of a 3d web based game with your own avatar and all. But the best part is youll get to really master three js with physics, animations, interactivity, cameras and even blender. So why wait? Join Zero two mastery today to dive deeper into three js and to master the art and science of 3d design and web development.
06:31:28.498 - 06:31:54.300, Speaker A: Plus, as a member of ZTM, you get access to our private discord community where you can get help from experts like Jesse and other fellow students. Click the video on your screen to get a glimpse of our vibrant discord community. Lastly, if you found this crash course helpful, please show Jesse some love by dropping this video a like and leaving a comment with your thoughts, questions or feedback down below. Thanks for watching and I look forward to seeing you inside the zero to Mastery Academy.
