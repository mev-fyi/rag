00:00:04.000 - 00:00:54.390, Speaker A: Data is everywhere, from the apps we use every day to the businesses shaping our world. Data is the backbone of the digital age and at the heart of managing, understanding and leveraging this vast ocean of data is SQL, the language that powers databases worldwide. Welcome to our SQL databases crash course. This isnt your typical classroom lecture here youll be thrust into the thick of the action, working on numerous exercises throughout the course. Whether youre just starting out from scratch or looking to diversify your knowledge, youre in the right place. This course is taught by not one, but two instructors, ZTM founder and lead instructor Andre Nigoy and senior full stack engineer Mo Bini. These two combined have over 15 years of experience and they were kind enough to share their knowledge with you completely for free.
00:00:54.390 - 00:01:47.088, Speaker A: Now captain obvious here, but youre not going to become an expert by just completing this course. SQL is a technical topic and requires a substantial amount of time to truly master. But who says your learning has to stop here? This crash course is actually part of MO and Andres complete SQL and databases boot camp course which has over 17 hours of additional lectures and exercises. Our full bootcamp, which you can find in the top right hand corner and in the description down below, will absolutely teach you everything you need to know to become an SQL expert. One more thing, if you're enjoying this crash course and are finding it helpful, the least you could do is show Mo and Andre some love by smashing that like button and dropping a comment with your thoughts, questions or feedback down below. Alright, that's enough chit chat for me. Let me hand it over to Andre so you can start learning SQL.
00:01:47.088 - 00:01:48.020, Speaker A: Enjoy.
00:01:58.840 - 00:02:38.906, Speaker B: Hello? Alright, I have some bad news. I know I started super excited, but this story begins with a bit of a downer. You see, you just got hired by Keiko Corp, one of the fastest growing tech giants in Silicon Valley, and they have just encountered a data breach. Somebody has stolen their trade secrets. Somebody accessed their databases and stole important information that they cannot get out there to the world. Now they're afraid that this information is going to go somewhere on a black market and their whole company is going to be ruined. I know.
00:02:38.906 - 00:03:19.098, Speaker B: Not an exciting way to start a course, is it? Anyway, back to the story. You've just been hired by this guy over here. His name is Bruno and he has the perfect hair. Now, Bruno is freaked out a little bit because he has no idea who stole this data, but he needs to get it back. Now, he heard that you're the expert, so he wants you to solve this right away. Hold on a second, hold on how are you supposed to do this? You barely have any information. Well, luckily for you, we're going to take you on this journey to learn about databases, to learn about SQL, and try to solve this mystery.
00:03:19.098 - 00:03:54.744, Speaker B: So Bruno tells you that, hey, you get access to all this data, the company data, and you'll be able to snoop through the databases to figure out if you see anything strange, maybe any clues that might lead you to who may have done this. And here's the thing. We need to solve this case because Bruno told us there's a big present for us if we're able to help him out. Hmm. I wonder what the present could be. Okay, I'm getting sidetracked. Now, who could have taken this data? You look at their company records and, oh, boy, they are a big company.
00:03:54.744 - 00:04:44.042, Speaker B: They have a lot of employees. Bruno mentions that it might be one of their employees, but there's hundreds of them. Your challenge is simple. Find out who the bad guy or girl is and solve this mystery. As you start to think about the case, you start remembering some of the things that you learned about databases and SQL, and you fall into a daydream. What is a database? Hold on a second. Maybe you are a smartypants and you know what a database is, but trust me, in this section, you may learn a thing or two that will surprise you.
00:04:44.042 - 00:05:37.040, Speaker B: So no matter what level of experience, just hang in there. Promise we'll get to some really fun stuff. You see, I remember when I first learned about databases and SQL. I couldn't understand how it was all connected with other fields. I would learn about web development or Python or machine learning and had no idea how this SQL or database is really related to those fields. So I want us to always understand the big picture and connect the dots so that the things you learn in this course, you understand why it is useful and how we can use what we learn to do some really interesting things in the world of tech. So what is a database? A database is a collection of data and also a method for us to access and manipulate that data.
00:05:37.040 - 00:06:27.778, Speaker B: So let's think about this statement. Data is everywhere, right? Data is now the most valuable commodity in the world. Companies that control data, companies that have a lot of data, like Uber, like Alibaba, like Amazon, like Facebook, like Google, are some of the most valuable companies in the world because they have this data. And every day in our world, we produce data, right? Whether it's drones with footages or location data, mobile phone apps, maybe website and webpages, even security cameras. We even have autonomous cars. All those things collect data. And the crazy part is that it's estimated we produce 2.5
00:06:27.778 - 00:07:08.334, Speaker B: quintillion bytes of data every year. And by the way, quintillion means this many zeros. It's a lot of zeros. More data is collected in the past two years than the entire human history. So where does all this data go? Does it just get stored in a notebook? Does somebody with pen and paper write it down? No. Right? And how can we really have that statement that more data has been generated in the last two years than all of human history combined? I mean, sure, there's more humans on earth, but there's always been the same number of atoms in the universe. You can't just create something out of nothing.
00:07:08.334 - 00:07:50.068, Speaker B: When we say that data is being created, more and more, the idea is that we're capturing this data. We're saving this data somewhere to be used in some way. Data is something that we, as humans create, but without capturing that data or using it, it's completely useless. We use oil to power cars, but if we don't extract that oil, if we don't use that oil, it's completely useless. So we need a way to capture this data, and that's what databases do. They capture this data for us so that we can use it. And here's another crazy number.
00:07:50.068 - 00:08:18.160, Speaker B: 44. The digital universe. That is, the data that we store is estimated to be about 44 zettabytes of data. How many zeros? Once again, lots and lots of zeros. So all this data is being captured in a database. Without a database, we wouldn't be able to store this massive amount of data. And more importantly, we can do some useful things with this data.
00:08:18.160 - 00:08:53.492, Speaker B: All those things we saw, like autonomous cars, Instagram, Facebook, Google. Without data, none of it would work. So without a database, the ability to query a database, that is, to ask database information about its data, it would be impossible for us to do a lot of things. But here is a secret. We mentioned that a database is a collection of data and a way for us to access and manipulate that data. But the secret is that databases aren't anything special. They're just hardware and software.
00:08:53.492 - 00:09:32.574, Speaker B: They're just computers. So a database, even though we always see this scary looking cylinders, are just computers. We see images like this all the time, representing databases, but they're just computers. It's hardware with software. So that is, hardware is the mechanical part, and the software is the actual code on top that allows us to collect and use the data. Really useful. So in this course, what you will see, is that we do the first step, which is one, we install software to turn our computer into a database so that we can all practice.
00:09:32.574 - 00:10:24.290, Speaker B: And two, we add data to this database that we create with this software, and then we're going to start using it and analyzing it. Because at the end of the day, a database is exactly this, just a disk drive, a way for us to store ones and zeros on a computer. And the beautiful thing is that as long as we can install something, we have a computer, something with memory that we can store memory in. And we have a machine, a computer, we can create a database. That is, we can create a database even on a mobile phone, on our desktops or on our laptops. And that's what we're going to do in the course. But when you see somebody having a database, that's all it means they have a computer somewhere in the world with software installed for it to store and manipulate that data.
00:10:24.290 - 00:11:12.498, Speaker B: Let's take a break and I'll see you in the next video. Hold on. You didn't learn anything in the last video? Oh boy, you're a tough cookie. Don't worry, we will get into more and more advanced topics later in the course. But let's finish our talk on databases, because again, I want to connect the dots for us. We learned that a database is essentially a computer with some database software on top. In a way, if you've ever used something like Google sheets or Excel, that's a database, right? It's a way for us to store data, and the Excel software allows us to manipulate that data in a way.
00:11:12.498 - 00:11:40.466, Speaker B: A pen and paper is a database as well. It's not digital, but it's a way for us to store data. Now the reason we always see these images as databases is because of this. This is called drum memory. And I'll link to this resource so you can read more about it. But back in the day before we had disk drives, this is how we stored data. It was called drum memory.
00:11:40.466 - 00:12:46.326, Speaker B: And as you can see, it's cylindrical, and that's why for historical reasons, just like our save button on a computer is a floppy disk. This draw memory represents usually databases, but again, in this day and age, they're all just computers. So because a database is just a computer in some software, are there many different types of databases? Well, yeah, there are. I mean, we talked about Excel, right? Essentially you can use a spreadsheet that you get in Excel to store data. So why don't we just use that for all companies? Why do we need something bigger, something like a database that we're going to talk about. You see, the problem with things like Excel is that eventually you'll get to a point where you have too much data, where an excel or a spreadsheet just can't handle it. And on top of that, there are many things that databases that we'll learn about in this course will solve, such as making sure that database has integrity.
00:12:46.326 - 00:13:22.050, Speaker B: So that is, not everybody can just modify data or delete a database. You can store terabytes of data. You can combine different databases. You can automate steps and use programs to do some really interesting things that you might not be able to do on a spreadsheet. Again, something we'll cover later on in the course. But some of the most popular databases are here. This is just a fraction of the databases out there, because data is so different, because every company, every user uses data in a different way.
00:13:22.050 - 00:13:59.990, Speaker B: We have different databases that do things differently, and each one of these have pros and cons. Now, the beauty is that in this course, we're going to cover some of the main databases and way to interact with them. And later on we'll learn about the pros and cons. So you can decide which database you should use based on your situation. But let's take Keiko Corp as an example. How would Keiko Corp or a company use a database? Well, we mentioned that there's lots of data coming into a company, and a company as big as Keiko Corp. Has a lot of uses for data.
00:13:59.990 - 00:14:36.530, Speaker B: For example, you might have product managers and product managers always have to know the product that they are working on. For example, drones. They need to get data and learn about the product's health, whether a product is working properly. Learn from data. Learn from different information. To perhaps improve a product, you have things like marketers and marketers. You need to find out information from data you want to analyze business decision, give you insights about how to market a product.
00:14:36.530 - 00:15:51.560, Speaker B: Or you might be a web developer, a mobile app developer that creates apps on phone or on the web. And those apps usually have things like user sign ins or profiles that you need to store somewhere so that when a user comes back onto your app, they're able to reload their information. Or maybe they're playing a game and they need to start the game from their last saved location. You also have things like data analysts or data scientists that understand data, that analyze data of a company and make decisions, such as perhaps even building machine learning models, so that a company can serve better information to a user, better products to a user, analyze different parts of the company to maybe see which employees should get a raise, who to hire. And then you also have data engineers or database administrators. These are the people that actually help set up the databases in a company. Update software, install things, make sure that databases are connected with one another.
00:15:51.560 - 00:16:39.624, Speaker B: They might use things like Hadoop, Facebook's Presto, Google's Bigquery, Amazon Redshift, and set up all this infrastructure in place for other parts of the companies to use databases. Now, as you can see, there's lots of data, and more importantly, there's lots of different databases, different people in a company that use databases in different way. But hold on a second. All this data is used differently by different people, right? Different operations, different options. Each of these people are interested in different parts of data. And this is why you're taking the course. You're taking this course because you want to hopefully be able to work in any of these fields.
00:16:39.624 - 00:17:29.978, Speaker B: And the good news is that even though there's all sorts of databases, even though there's all sorts of jobs, one of the most common ways to work with databases, to ask a database a question, what we call a query, to interact with it, to use that information that is so useful, we use SQL, a way for us to interact or communicate with that database. And that's what this course is all about. Let's take a break and I'll see you in the next video. Phew. Welcome back. Now, I know, I know I've been talking a lot and we've been staring at slides. I know you want to start doing something.
00:17:29.978 - 00:18:23.010, Speaker B: You want to start writing some SQL queries and actually interacting with a database, which we're going to start to do in the next video. But hold on tight just a little bit more because we just talked about all these databases. It all looks kind of intimidating. So let's wrap our understanding of databases in this lecture so that we can start doing some fun exercises. So in order to complete our understanding, or at least initially complete our understanding, let's talk about some of the confusing terms you will hear throughout the course, because computer scientists just love giving difficult names to not so hard concepts. Now, in this course, the way things are going to be structured is because we have data coming from all over the world, all different places. And when you work at a company, most likely a company already has databases set up.
00:18:23.010 - 00:19:04.382, Speaker B: We want to focus on three main things. One is how to put data in a database. Yes, we'll show you how to install a database on your machine, which you might do at a company, although very rare. We're going to learn how to put data in a database that already exists. We're going to learn how to use update, learn from this data, and we're also going to learn how to remove data all using SQL. But first, let's talk about these confusing acronyms that you're going to hear out in the wild and also myself and mo speak. The first one is DBMS or a database management system.
00:19:04.382 - 00:19:48.140, Speaker B: A database management system is a software. It's a program that is used to manage the database. It receives instructions from somebody like us that wants something to do with data and instructs the system, the database to make this, to actually grab the data or make changes to the data. And then we have relational database management system. This is a subset of database management system. What we're going to learn about is something called relational databases. They're the most used, the most common, the most popular type of databases, and in my opinion the most useful.
00:19:48.140 - 00:20:49.062, Speaker B: Things like MySQL, SQL Lite, Postgres, SQL, Microsoft Server, Oracle all use this relational database management system. At the end of the day, it's the same thing as a DBMS is just more specific saying, hey, this uses a relational database model, something that we'll talk about shortly. And then finally why you're taking this course is SQL or a structured query language. It's a way for us to interact with a database management system. Now all these words are a little bit confusing, so let's use another diagram. We have all this data coming in and this data coming in can be images, can be user profiles, can be audio files, can be logs of information, of statuses. And we learned that we need to learn how to put this data in a database, how to use update, learn from this data, and also possibly how to remove this data.
00:20:49.062 - 00:21:36.646, Speaker B: And in order for us to do this, we use those acronyms that we just learned about, that is we have data. So data which is being stored in a database. We have a DBMS or rdbms. Remember it means database management system. And we use something like Postgres SQL, which is a relational database management system. So again, a database management system usually gives us functions, basic ways for us to read data, to create data, to update data, more, to delete data, often called crud operations. And a database like postgres is what we call a relational database, which is why we use this r at the beginning.
00:21:36.646 - 00:22:35.950, Speaker B: Again, something we'll talk about later on in the course. But a relational database is a database that allows us to set up connections among different data records. And then finally this whole picture of data combined with a data management system. A database management system is what we usually call a database. You see when you hear things like MySQL, postgres, Cassandra, MariaDB, CouchDB, CockroachDB, all of these things are actually software or database management systems, a way for us to store data but also interact with this data. So when we refer to a database, we essentially mean these things. But at the end of the day, when you hear postgres or MySQL, those are all just database management system, a way for us to interact with this data.
00:22:35.950 - 00:24:06.268, Speaker B: And then finally we have SQL, the structured query language. It's not really a programming language, it's a query language where SQL, its role is to give us the ability, like all the people that we saw, like product managers, like business analysts, like data engineers, like web developers, to communicate with these databases using a very simple language, SQL, that is very English like. And anybody can use a very simple thing once you learn its rules and interact with all these database management system. Now in here, I have postgres as an example, and we'll use postgres in this course because it's one of the most popular databases. But the beauty is that when you learn SQL, it doesn't just work with one database management system. If you remember our diagram, by learning SQL, we get to interact with a lot of databases because a lot of these databases, not all, but a lot of them, like Mariadb, like Microsoft SQL Server, Oracle database, MySQL, SQL Lite, postgres, SQL. Most big database engines are compatible with all SQL code because they all say, hey, I want our database to be as easy as possible for people to pick up because we want people to use our database.
00:24:06.268 - 00:25:01.054, Speaker B: So they use the SQL standard and they implement in their software a way for them to understand these SQL commands. So once you learn SQL, it should be very familiar and similar for you to work across many databases. This is the beauty of learning SQL, that it gives you the power to work with multiple types of databases, no matter what your role is. And later on in the course we'll even show you how to decide on different databases. But for now, that's a lot of talking for me. I want us to start doing some exercises and actually learn what this whole SQL thing is about. In the next video, I want us to create Amazon and learn about how they went from not needing a database to using spreadsheets to finally implementing a database.
00:25:01.054 - 00:25:37.196, Speaker B: And we're going to write our first SQL statements let's have a look. All right, everybody, it's exercise time. And in this exercise, we're going to build Amazon, or at least understand how Amazon uses databases. Now, I want to take us back all the way into the nineties. That is Amazon. Before Jeff Bezos looked like a superhero. We're talking Jeff Bezos in the nineties.
00:25:37.196 - 00:26:16.630, Speaker B: Now, imagine you're starting Amazon. You just started. You're starting to deliver some books. You are getting your first customers. If you're a Jeff Bezos, what's your first thing that you're going to do? Well, maybe you will use a notebook, a pen, and paper, and say, Joe just ordered a Harry Potter book. I'm going to write down his name, grab their credit card information, or check and grab their address so that I can ship them that book. Now, eventually, this notebook, pen and paper, is going to overwhelm Jeff, and he decides, you know what? Let's use Excel.
00:26:16.630 - 00:26:32.718, Speaker B: Let's use a spreadsheet. And Jeff starts using a spreadsheet. And now look at that. Things look a lot better, a lot cleaner. Instead of pen and paper on the computer. Now, Jeff has some orders. We have Andre.
00:26:32.718 - 00:26:48.960, Speaker B: Myself, I ordered a toy duck. I wanted two of them. And this is my address, not my real address. Don't try and send me mail. We have mo, who likes candy and just bought 100 candies. Wow, that's a lot. Bruno, again, has perfect hair, and he buys a lot of hair gel.
00:26:48.960 - 00:27:16.482, Speaker B: And then finally, Sally is buying a Harry Potter book. Awesome. So Jeff is keeping tracks of orders. He knows when to send those items because he has the address, he has the quantity, he has the name. Everything is great. But then comes a problem. The excel sheet gets a little bit bigger, and now we have something confusing that Andre has done.
00:27:16.482 - 00:27:44.476, Speaker B: You see, I wanted to get some cool glasses, so I ordered some cool glasses, and there you go. Ordered them. But once I received them, I didn't really like them. I don't think they were as cool as I thought. So, well, I decided to return them, and a week later, I decided, you know what? I wasn't thinking straight. Those cool glasses, they were actually very, very cool. So I decided to order another pair of glasses.
00:27:44.476 - 00:28:09.380, Speaker B: But, oh, just a heads up, I actually moved to Japan in the meantime. So Jeff, looking at this, is saying, hold on, hold on. Okay, so is this the same Andre? There's two different addresses. There's a minus one here. And in his head, has to keep track of all these things, all these changes. And imagine having more and more rows. Imagine this excel sheet getting bigger and bigger and bigger, more information, more data.
00:28:09.380 - 00:28:37.038, Speaker B: Things start to get confusing. And this is why databases exist. Instead of this, let's imagine a better system that Jeff implements. Now for you, I want you to go to this link that. I'll link in this lecture and try this out. This is an interactive playground. This is a website that actually has a database already as part of it.
00:28:37.038 - 00:29:18.654, Speaker B: You can see here that this is your database and it has different tables with different records. So there's 91 customers, there's eight categories, and there's also a playground for you to run SQL statements. Now we haven't really learned about SQL yet, so this might be gibberish for you, but I just want you to click run SQL. And by the way, your SQL statement here might be different than mine. That doesn't matter, just click run. This is essentially what a database does. We kind of get the same results as a spreadsheet, but we use SQL statements and we grab information that we need.
00:29:18.654 - 00:30:24.426, Speaker B: But it's not just one big Excel file, right? There's different pieces of data. So if I go to customers, I see all my customers, each customer has an id, has different columns with important information, like address, like the contact name. If we go to orders, we have some order date, we have some customer id. So who ordered the orders? If we go to products, we see all the products that we have and all of these are grabbed using SQL statements. Now I know this is still confusing. Might not understand what the difference between this and an Excel spreadsheet is. But before we do, before I go into the next video and show you the exact difference and why this system might be more beneficial to Jeff, I want you to play around over here, start clicking on some of these categories around the SQL commands and just kind of understand what we're trying to do.
00:30:24.426 - 00:31:11.794, Speaker B: Essentially, when we select star from something, we get some data. See if you can modify this information right over here to perhaps match different databases and find out about our Amazon store. So play around even though you have no idea maybe what these statements do. And in the next video, we're going to dive deeper into Jeff's Amazon database. Welcome back. So we just left off with our friend Jeff having a really hard time keeping track of orders. Things were getting bigger and bigger and harder and harder to manage just with a spreadsheet.
00:31:11.794 - 00:32:07.870, Speaker B: So we advise them that a database might be useful. So how would Jeff implement a database, let's say in Amazon? Well, remember, a database is just software and hardware that holds that data and allows us to manipulate that data. So Jeff, on his computer, decides to install a database management system. Let's say he picks postgres SQL, he installs it, and then he starts putting the data that we had in a spreadsheet into postgres, into a database. Now, again, something that we're going to learn about throughout this course, but for now, I've simplified the diagrams for us. So now Amazon decides that we're going to use a database, not a spreadsheet, because our company is growing. So they start creating a different way to organize data that kind of looks like a spreadsheet, like an excel sheet, but a little bit different.
00:32:07.870 - 00:32:44.304, Speaker B: One is we have customers. That is, each customer now has a customer id, a unique customer id that we can identify the customer with. So I'm customer one, Sally is two, Bruno is three, Mo is four. The beauty of this is that if I ever moved, I have one location where Jeff could look to see my new address. So there's only one record of myself and my address. So Jeff knows exactly where to ship my product. Next, we create the product data.
00:32:44.304 - 00:33:16.220, Speaker B: So this is another table that we're creating. And products, just like customers, have an id to uniquely identify them. We have the description of the product, but also the price. Again, if we ever add products to our company, to Amazon, then we can just add it all in one location. If we want to change the price or offer discounts, we can change the price in one location. Then, of course, we need our orders. In order for us to make money with Amazon, we need to actually sell stuff.
00:33:16.220 - 00:33:47.608, Speaker B: So how do we keep track of orders? Well, each order, just like we had with customers and products are going to have a unique id. But this is the beauty of something like a database order. One. Who ordered the first order? Well, customer id is right here. What's the customer id want? So Andre ordered something. This is when I ordered it. What product did Andre order? Well, what's two? Product id.
00:33:47.608 - 00:34:28.122, Speaker B: Two is a toy duck. Okay. Andre ordered a toy duck, and then the quantity is one. So now I know exactly who ordered it, what product, how many, what the price is, and also the address to ship it. Now, pause the video and see if you can connect all of these relations for the rest of the three orders. Once you're done, let's take a look at what we've just created. We've essentially created relations, right? Instead of having everything in one excel sheet, we now have these tables that link to one another.
00:34:28.122 - 00:35:39.550, Speaker B: Each table has a relation to one another. For example, the customer ids are matched over here we have the product id that's matched over here. All of these are related with one another, connected. And because there's only one location for us to change things, for example, let's say the address changes, I know exactly where to update those customers. I know exactly where to update the products or even the orders. And this is one of the big things with databases, especially when it comes to a relational database where we're able to create large, massive amounts of data beyond what an Excel sheet might be able to do, but also organize it in a way that is really intuitive. Although it might be really hard for you to understand how to look at this data right now for a computer, when we start using things like SQL, a computer understands this a lot better than a confusing excel sheet of with many, many rows, many, many cells that are not linked or connected properly.
00:35:39.550 - 00:36:22.306, Speaker B: So to finish off this video, I want you to go back to our playground over here and start seeing how these tables are organized. For example, go to the orders table and try to figure out what this first order was. We see that there's an order id, there's a customer id. Find out who the customer is, who the employee is that sold this product, and the shipper id. Who's the shipper? Once you start to decipher tables like that, well, that's when things get more and more interesting. Congratulations. We just managed to help Jeff become the superstar that he is now.
00:36:22.306 - 00:37:12.750, Speaker B: You're welcome, Jeff. All right, I'll see you in the next video. So what are all the differences with all these databases? I mean, I've only shown you a few of the options as we have for databases. There are hundreds of options. For example, if I search database management system, I'll probably get a list of database management system. Let's do Wikipedia here. All right, so database management systems, as you can see, there are a lot of them.
00:37:12.750 - 00:37:39.678, Speaker B: Once again, we should understand this. If we go to databases, we get a list of databases or lists of database management systems. So let's look at list of database management systems. And again, there are a ton hun. Now if we click on, let's say the first link. Yeah, that's a lot of databases. Now you're never going to use all these databases throughout your career.
00:37:39.678 - 00:38:19.540, Speaker B: You'll probably touch a few, just probably less than five. Most people might just have two or three databases that they work with. But you can categorize databases into five main types. These five main types of databases. I'm not going to go into full detail because you need to learn more about databases before you truly understand their differences. And later on in the course, we'll actually cover some of the differences between databases and learn about some interesting popular databases that are out there. But for now, let's talk about the five kinds, often called the five data models.
00:38:19.540 - 00:38:48.806, Speaker B: One is the relational model. This is one of the most popular ones. This is the one that we kind of saw with MySQL and postgres. They support something called asset transactions. Sounds complicated. We'll dive into what that is. But popular databases like Postgres, like MySQL, Microsoft's SQL server, all use this relational model, and it's probably the most popular.
00:38:48.806 - 00:39:31.664, Speaker B: And this relational databases work really, really well with SQL. So you'll see these types of databases and a lot of e commerce websites, a lot of websites that have customers or users inside of businesses. They have a lot of applications. And in this course, we're really going to dive deep into relational databases. Next is a document model, a document model database. You may have heard of things like Mongodb, couchDb, or firebase. They use what's called a document model, and in this case, data is almost in a document rather than rows and columns like we saw in the Amazon exercise.
00:39:31.664 - 00:40:11.772, Speaker B: These databases are usually a big document that contain a ton of related information together. These types of databases are usually really, really good at what we call scalability databases that have to hold more and more data, that have to be more and more performant. We'll talk about the differences between these types of databases and document databases because it's a popular topic. You may have heard of postgres versus MongoDB. We'll have a video on that later on. Then we have key value databases. Now, you may have heard of things like Redis, etcd or dynamodb.
00:40:11.772 - 00:40:40.972, Speaker B: These are key value storage systems. It's a model that is one of the simplest ways to access data. You essentially have a key that is, hey, I want to get user id one and you get user id one back. We're going to have a section on redis. In the course, we can learn how a key value database might work. Then we have graph model databases. These are databases like neo four J or AWs Neptune.
00:40:40.972 - 00:41:17.410, Speaker B: These types of databases are a lot rarer because they're a little bit more complex and they use something called a graph model. That is, it's really good for data that is connected in different ways. It's all about relationship between different units. So a social network website might have graph databases because they want to see how different users are connected. To one another. Out of all of these, graph databases are probably one of the least used because they are so specific. And then finally we have something called wide columnar model.
00:41:17.410 - 00:42:11.444, Speaker B: These wide columnar models are fairly new and they were pioneered by Google's bigtable databases like Apache Cassandra. Google's bigtable are very popular. Now, I'll link to a resource if you want to dive a little bit deeper into what these differences are, but I recommend to hold off on that until you are done with the course because a lot of these are new topics that might be hard for you to understand. Ideally, you finish the course. We explore some of the relational document key value databases, understand what their differences are, what the pros and cons are, and then you can dive deeper and deeper. But I wanted to just mention it briefly here, because with this course, the goal is to get you comfortable with SQL, with the idea of databases, and so that you are able to make decisions on when to use what. I'll see you in the next one.
00:42:11.532 - 00:42:12.360, Speaker C: Bye bye.
00:42:22.870 - 00:43:15.950, Speaker B: All right, everybody, one more exercise for you for this section, because I've been talking a lot, and I hope that you now have a better understanding of what a database is. So that's my question, what is a database? And here's the thing. I want you to answer that in just one sentence. And as an exercise in one sentence, go to our discord community right over here. And we have a database channel right here. And in the database channel, I want you to just write down your definition of what a database is and maybe check out some of your fellow students answer to what a database is in one sentence. Now, my answer, again, don't watch this until you've actually answered this yourself in discord.
00:43:15.950 - 00:43:54.856, Speaker B: But my answer to what a database is, well, a database is a system, hardware and software that allows a user to store, organize and use data. Hopefully you got that. I'll see you in the next one. Bye bye. Holy moly. That was a lot of information thrown at you. Hopefully you learned something new if you're experienced, and hopefully you learned a lot of things if you are just starting out.
00:43:54.856 - 00:45:05.242, Speaker B: This is when the course really starts. This is when we start learning some useful skills, ways to use SQL to interact with all these databases. So for the rest of the course, as we learn more and more about these, we're going to dive into SQL, how it works, and then later on, once we have a good understanding, we're going to revisit this idea of different databases, when to use what, how to use something like a key value store like Redis when you should use something like MongoDB versus postgres. But the key takeaway is that we first have to ask ourselves one, do we have useful data? If we do, then we're going to need SQL. The two is, well, in this course we're going to have to use a database. And for that you'll see that eventually we're going to show you how to install a database software, a database management system onto your computer so that we can actually store this data. And then finally we're going to use SQL to first of all add that data to the database and then use that data to find different interesting things.
00:45:05.242 - 00:45:12.090, Speaker B: Things. It's going to be a lot of fun. I hope you're excited. I know I am. Let's dive right in.
00:45:22.070 - 00:46:17.782, Speaker C: Hey everyone. Now before we get into the bulk of the course, I just wanted to introduce you to one of the tools that we will be using throughout the course to quickly test queries to play around. It's called DB Fiddle and it's one of those tools that we will be using to create playgrounds. What do I mean by playgrounds? Well, when we will be writing queries, we'll want to play around with some of the concepts that we're learning as we go along. And DB Fiddle is an ideal place for us to quickly create a database without having the overhead of having to set up a local database, software and all of this and that. And it's a pretty cool tool because you can actually switch between different versions of SQL in here from different vendors. Right here you can see I'm using postgres version twelve and that is the version that we will be using throughout the course.
00:46:17.782 - 00:47:01.210, Speaker C: But more of that will be known when we get into the setup, the more rigorous setup that we will be going through. But what you need to know right now is that this tool is a tool that will be coming up again and again as we're learning small concepts here and there around SQL and small things that we will be doing. Super important tool right now we don't have to pay attention to what is in the schema. This portion right here is where we will be setting up a database for you. And the portion on the right hand side query is where you will be playing around and testing out stuff. Now the majority of the time we will be providing you a database schema that you will be using. So you just have to copy paste something in here.
00:47:01.210 - 00:48:00.130, Speaker C: You don't have to pay attention to any of this and you can fire off some queries as we go along and test out some of the concepts that we will be teaching you, it's a fast and easy way to hit the ground running and be able to play around with SQL. All right, so now we're getting to the core of the course, what is SQL? And there may be a lot of questions surrounding what SQL is. Well, SQL is a language that we will be using to talk to our databases. It's a programming language. And a programming language, in essence, is a set of instructions that we are using to talk to a system to get a specific output, an output being an answer. In this case, we're asking for data. And with SQL, we are mainly talking to databases.
00:48:00.130 - 00:48:33.888, Speaker C: Now, a database is nothing more than a structured set of data. Now you may ask yourself, what kind of structure are we talking about here, right? There are different structures that you could basically apply to data. Heck, we could take a notepad and we could write a book in there, or we could take an Excel sheet and make a personal budget. And all of these ways of storing data are your own structure, right? Like you determine in a notepad. This is my headline. This is my body, this is my paragraph. In an Excel sheet, you can say, these are my columns, these are my rows.
00:48:33.888 - 00:49:15.620, Speaker C: This is how I'm going to put the data in here. But when we go off to database country, we're looking at these huge companies like Amazon and Microsoft and all of these big corporations that are basically helping out millions and millions and millions of people. And when you have that much data, you can't just go into a flat file or an Excel sheet and store that much data. You need a larger system. And a database, in essence, is that larger system. Now, what determines, like how we're going to store data in a database and what makes a database, right? Well, there are different models you can follow. And throughout the course, we're going to talk about these different models, mainly focusing on one.
00:49:15.620 - 00:50:05.290, Speaker C: And SQL is going to be the language that we're going to be utilizing to talk to the database, to pull data, to insert data and so forth. And when we use SQL, we are going to be writing statements, statements being instructions that we're going to give to the database to give us back data. These are called queries. Now let's dive a bit deeper into what a query exactly is. All right, query time. So in the previous video, we ended on talking about queries. A query is nothing more than an instruction, right? In English, a query is defined as a question.
00:50:05.290 - 00:50:33.112, Speaker C: And in SQL, queries are the way that we are going to put together our questions to which we want an answer from the database. A query is also known as an SQL statement. Those are just synonyms. Query is equal to SQL statement. SQL statement is equal to a query. Just different ways of saying the same thing. So if we look here, there is a very basic query, select star from users.
00:50:33.112 - 00:51:04.310, Speaker C: And if we were to break this down, what it's basically saying is select us all of the information. So the star here is what we call a wildcard. We don't know what we want to get back, but just get us everything back. So select us everything from. So we're going to say where we want it from. And we know somewhere in our database we are storing users, right? So select us everything from users. All right, that's pretty straightforward.
00:51:04.310 - 00:51:30.716, Speaker C: So let's execute that. All right, so here we see select star from user over here. Let's just copy paste all of this information. Just put it in your DB fiddle. Let's not worry about that just yet. And if we execute our command, select star from user, what we're going to get is a bunch of information. Because a bunch of user information was inputted.
00:51:30.716 - 00:52:05.952, Speaker C: We can see they have an id, they have a name, a last name, date of birth, sex, and a role. Awesome. So we can see here that select star from user is actually selecting us all of the information that we have around that user. And if we filtered and we just said name, what we would see happen is we would only get the name back. Amazing. So let's hop back into the slideshow and check out what a breakdown of a query looks like. So here we've expanded the query a bit because we want to break down something a little more complicated.
00:52:05.952 - 00:52:33.460, Speaker C: So let's say we did select name. So select the user's name from our data source. Users in the database where role is equal to manager. So this is new, right? Where role is equal to manager. This is what we call a condition. So where is our keyword? And we're saying where the role of the user is equal to manager. Return us the name.
00:52:33.460 - 00:53:02.866, Speaker C: I hope that makes sense. We're filtering data at this point. We're saying where the role is equal to manager of the user. Give us back their name. And so if we were to break down this query and we looked at it line by line, select name is a clause from users is called a clause, and where role is equal to manager is called a clause. These are just parts of the SQL statement or the query. So each line here is called a clause.
00:53:02.866 - 00:53:29.820, Speaker C: And when we see select name. Name is called an identifier. Now, what is an identifier? An identifier is just a different word for a part of the data. We know that users have a name. So when we select name, we're saying that name is the identifier that we want. And when we look at the last line where role is equal to manager, our filtering line, this is a bit more complicated. Right.
00:53:29.820 - 00:53:56.670, Speaker C: Where is our keyword? Role is our identifier. But the line role equals manager is called the condition. So a condition is something that needs to be met. We're saying that, okay, a user has a role. That role needs to be equal to manager in order for us to get some data back. Pretty straightforward. And manager is called our expression.
00:53:56.670 - 00:54:27.240, Speaker C: We are expecting that some of the roles may be equal to manager, but some may not be. So that's why we call it an expression, because we are making an assumption here that some of the roles are equal to manager. We want to filter based on our assumption. Awesome. So let's fire that real quick. All right, so we have our query here ready to go. So let's run it.
00:54:27.240 - 00:54:57.300, Speaker C: And as you can see, we are getting back George, Janine, and Jason. So let's verify that that's actually what we want. So let's get back all of the information. All right, so we see here George, Janine, and Jason, and we see that the role is equal to manager. All right, that makes sense. But who else did we have here again? So let's go look at that. This is a way to put a line in comment.
00:54:57.300 - 00:55:15.292, Speaker C: You just, you don't want to execute that line. It's a quick way of turning lines on and off. So let's run that. So here we can see, okay, George is a manager. And then we had Macy and Bill, who are employees. Okay, that makes sense. So let's turn that line back on.
00:55:15.292 - 00:55:50.190, Speaker C: If we run it and we said, okay, now filter us the employees. Awesome. So we see Macy and Bill come up. All right, awesome. So now it's all starting to come together, right? We know how to build a very, very simple query. And I would push you to copy paste what's in here, put it in your DB fiddle, and try to write some simple queries where you filter and you select certain fields. And that way you can play around with it.
00:55:50.190 - 00:56:19.038, Speaker C: So we've done our breakdown, and now we know all of the different parts that go into a query. And that's super powerful, right? Because now we've just said select name from users where role is equal to manager we asked a question and we got an answer back. This is what we call a declarative language. SQL is a declarative language. Now what does that actually mean? Well lets dive a bit deeper into that.
00:56:19.214 - 00:56:53.084, Speaker A: Hey there. Aldo here. Before moving on to the next video, I want to reiterate the importance of hands on learning. This is a concept that Mo and Andre truly believe in, which is why they have included 18 exercises for you to complete to help retain all the information getting thrown at you. Now to make things easier on everyone, we have included the text, lectures and the links in a zip file that you can find in the video description. All the files will be organized by lecture names so you shouldnt have a problem locating each one. Once you finish the exercise, come on back and take the rest of the course.
00:56:53.084 - 00:56:55.920, Speaker A: Alright, let me hand it back over to Mo. Enjoy.
00:57:06.470 - 00:57:48.476, Speaker C: A declarative language. What are we talking about? I can already hear you saying declare a what? Well to put it into simple terms, a declarative language is a language where we say what will happen? Okay, I can see the gear spinning, right? What will happen? When we look at our SQL query, we said select star from users, we know we want to get data back. We're saying what will happen? Select star from users. We are going to get data back from users. But we have no idea how that's going to happen. That's why we call it declarative. We are simply stating something that is going to happen.
00:57:48.476 - 00:58:25.450, Speaker C: On the counter end of that we have what we call imperative programming. And imperative programming says how it will happen. So what do we mean by that? We just defined declarative. Declarative meaning we say what will happen, but we have no idea how it's happening. And on the other end, imperative is saying how it will happen. Imperative programming is where you go line by line by line saying do this, do that, do that, go read from over there. In declarative, you just say, give me this, let's break that down a bit more.
00:58:25.450 - 00:58:52.594, Speaker C: If we were to look at this, the man asking for a ham sandwich and getting one without having to do anything, well that's equivalent to declarative programming, right? You say, I want something. This is what I want back. This is what should happen. And you get it back. And however it happens is irrelevant to you. It happens in a black box. It happens somewhere behind the scenes and you don't know anything about what goes on there.
00:58:52.594 - 00:59:21.942, Speaker C: In an imperative programming, you are the band leader. You are the one saying let's do this. Then let's do that and then we will have an outcome. So in the case of a ham sandwich, you are the one saying, slice the bread, slice the ham, and putting together the sandwich. And if we were to look at some examples of declarative versus imperative programming, what we would look at is, for instance, SQL, right? We've already defined that. That's on the declarative and select star from users. Very clear, very straightforward.
00:59:21.942 - 01:00:12.524, Speaker C: You know that you're going to get user data back. And Java, an old programming language that is still relevant today that some of you may have heard of, is a programming language where traditionally you would define everything that needs to happen. You would define where you need to read from a hard drive, where all of the data is, and you would do all of the actions to get the data on the opposite end. Something like Python can be both declarative and imperative. You can do both with it. So we've created this clear divide and we've seen what declarative can do versus what imperative can do. And it's more simple than it looks, right? Declarative is very powerful because of its simplicity, because you don't have to worry about what's going to happen behind the scenes and you can just say, hey, get me this, hey, get me that.
01:00:12.524 - 01:01:09.160, Speaker C: You can be more productive versus imperative. You have more flexibility, you have more power, you can do way more things, but it becomes more complicated as you go along because you have to manage all of these extra things. We've learned so much so far. We know what SQL is, what a query is. We even know why we call SQL a declarative language, but what we don't know is the history of SQL. How did SQL come to be? Where did it all start? Well, don't worry, I've mapped it all out for you in the small section on the history of SQL. So the original name of SQL is SQL, and you'll often hear these used interchangeably.
01:01:09.160 - 01:01:53.688, Speaker C: Do we use SQL? Some people will call it SQL. Some people will call it SQL. Well, SQL was the original name and it stood for structured english query language, but it had to change its name due to copyright conflict, so they changed it back to SQL, structured english query language. And that's why you'll hear both names used interchangeably. Now, it was invented in the early eighties and it still holds strong today as a standard for querying and manipulating data. But how did it come to be and who was behind it? Well, in the seventies, a programmer from IBM named Edgar Codd wrote a paper that set the standard for databases and SQL. His paper was called a relational model of data for large shared data banks.
01:01:53.688 - 01:02:39.754, Speaker C: What a long name. But that's not the important part. You know, he wrote this paper, but what was amazing is that it inspired two other developers from IBM, Donald Chamberlain and Raymond Boyce to implement his vision. They took his paper and they created the very first version of SQL, both the language and the software to create and manage databases. And so to this day, SQL reigns supreme. And SQL is known to be a language to manipulate and manage databases and they laid the foundation for it. Now, there were specific reasons for which this paper was written and when we dive deeper into why we use databases this will become clear.
01:02:39.754 - 01:03:38.596, Speaker C: But for now the important part is to know that these two fellas from IBM, based on his ideas wrote the original version of SQL. And what's even more fascinating is that SQL is a language that is standardized. What do I mean by that? Well, let's take a closer look at what standardization is. Alright, so now we're going to talk about standards. As we all know, SQL is a language that's used to talk to databases. And a lot of different companies make databases, right? They supply databases. If you just think off the top of your head, there are many, many companies that have the software and the database infrastructure.
01:03:38.596 - 01:04:28.868, Speaker C: Microsoft, Oracle, Postgres, MySQL, just some of the names you might have heard of. And all of these different companies are supplying database software and databases, but they're all using SQL. So if SQL is the language, how do we make sure that all of these companies know what version of SQL they need to make? Well, SQL is what's known as a standardized language. What do I mean by that? Each language has a set of rules and SQL has standards. So there are a set of rules in place that need to be followed. Think of the gold standard and a bunch of people will come together to talk about these standards and what should be next. That's what we call standardization.
01:04:28.868 - 01:05:43.296, Speaker C: If a committee comes together, a bunch of people, and they start saying, okay, we need this and this and this, and they put together new rules year after year, then we're creating standards. Now you may think like, okay, so if SQL is a language and a committee is coming together to put together these rules about how you're supposed to make SQL work for your database, why would companies follow this? Well, since SQL is a widely adopted language, right, everyone knows how to use it, everyone talks about it. It is good for companies to follow the standards because that means I that you have consistency. Since everyone knows this one language, companies want people to use their software so they will follow the standard and then they will add some extras just to make their product slightly more appealing than the other products. So this committee comes together, they put together some standards, the companies follow those standards, and then they put some hot, new shiny things on top of it to make their product more appealing. They put the latest and greatest in there. And they do this because they want a high adoption rate.
01:05:43.296 - 01:06:41.984, Speaker C: What do I mean by that? They want all the people in the industry to use their software, their databases, as opposed to other people. That's why they will implement the standards and then add all of those knobs on top. And if we look at the history of the standards, we started all the way back in the eighties when the first version of SQL was released. They released a paper with all of the functionality that SQL should have and go forward to 8992, all the way up to 2011 and beyond. And we're still creating these standards and companies are still following these standards, but they go beyond the standard, like I said, because they want the latest and greatest for their software to get people to use their software. So if you look at, for instance, the SQL version in postgres versus the SQL version that Microsoft would use or Oracle will use, there will be slight differences, but there will be a lot of things alike. And that's what makes SQL so attractive as a language.
01:06:41.984 - 01:07:18.952, Speaker C: The fact that we can go in and say, hey, here's this one language we all know and you can hit the ground running, and we have all of these extra things that this other vendor, Microsoft, Oracle or whatnot may not have. Great. So now we know all about the standards, we know all about SQL. We know about queries. We know that databases are structured sets of data, but there's so much more to uncover. When we talk about databases, we know now that SQL is being used to talk to the database. We know that we're going to use queries to get the data.
01:07:18.952 - 01:07:59.424, Speaker C: And we definitely know the history of SQL now and I that there are standards. So before we get into all of the functionality around SQL, let's take a deeper look at the database and how it operates. What makes a database what it is. Let's just look at that under a microscope. See you in the next video. So what is a database? So far we've talked a lot about SQL. We talked about queries.
01:07:59.424 - 01:08:42.873, Speaker C: We talked about why we use SQL. We even talked about why it's called a declarative language. But we didn't really talk much about what a database actually is. We gave it a short definition, which was, it's a structured set of data that is structured in a certain way to scale with organizations that have massive quantities of data. Now, databases are our modern day interpretation of how to organize data. But before databases were around, we had something called file processing systems. This is the precursor to the modern database.
01:08:42.873 - 01:09:26.395, Speaker C: And the reason I'm zooming in on this is because to know where we are, I find it important to know where we came from. So file processing systems were a massive leap ahead, especially in terms of, you know, we used to have cabinet systems and filing systems. On paper, these file processing systems were software based, and they were a huge leap ahead of whatever we had back in the day. But they had their flaws. First of all, you were saving data on individual files, right? And there was no correlation between the files. What do I mean by that? There were no relationships between the data. You basically were creating systems to save particular types of data.
01:09:26.395 - 01:10:01.550, Speaker C: Let's say you had a real estate firm. In one part of the system you would keep all of the listings. In the second part of the system you would keep all of the customers, and in the third part of the system, you would keep all of the sales. But there wasn't really any relationship between the data. Now what do I mean by that? Of course, with purchases, you would know which customers did the purchase. But the limitation lied in the fact that if a customer changed over here, the change wouldn't go all the way through to the sale. You basically were copying customer information into the sale.
01:10:01.550 - 01:11:20.926, Speaker C: So whenever the customer, let's say, changed their employment or changed their address or changed their phone number, the update would happen here, but the previous sale would not get the reference to the new information. So file processing systems had a lot of benefits, but a lot of negatives, because you were building custom software in specific coding languages like Java, that would manage your data, you were doing it all, the programmers, the coders, the developers, whatever you want to call them, they were building their own systems. And that's what we call file processing systems. Now, in terms of file processing systems, for a user, you would be talking to the computer and some specific coding language, let's say Python or Java, would be talking directly to the machinery. And this, like I said, was a large disadvantage because you had all of this management to do in Python or Java or whatever other language you had. The software was so customized to the system, you even needed to know how your data was being stored, what hard drives you were using, what software was running on the server, whether it be Mac, Windows, Linux, you needed to know all of that in order to write the software. So there was a lot of overhead here.
01:11:20.926 - 01:11:53.882, Speaker C: On top of that, the user didn't really care about what system was managing the data. Yet every system was specific to a type of data. You could build a customer entry software and then you could build a sales software. And all of these systems did not have common ground. What do I mean by that? They were all built custom. So the user needed to know each and every particular system in order to work efficiently, not to mention all of the flaws. So back into the limitations.
01:11:53.882 - 01:12:27.096, Speaker C: Let's say you had a school system. What you can see here is clearly that the student system, the exam system and the library system were completely independent from each other. So let's say an exam recommended certain books. The exams database didn't necessarily know how the library was storing their data, and the library data didn't necessarily know how students were storing their data. All of these systems were independent. That means all of the way that the files were stored were different. There was no common model.
01:12:27.096 - 01:13:13.240, Speaker C: Now what is a model? Well, a model is just a way of saying, hey, my data is going to follow this structure. We're going to have columns and rows in column a, I'm going to put this, in column b, I'm going to put this. You would put together a system of how your data would be structured, and if all of the data followed a similar model, they could talk to each other. But back in the day they didn't. That means if a student were to loan a book to study for a particular exam, the library would copy the student data and then store it with the rental, and the exam would copy the student data when the student took the exam. So you would have a bunch of redundant data, not to mention that all of the data was isolated and none of the systems could talk to each other. These are huge limitations.
01:13:13.240 - 01:14:32.376, Speaker C: Now in comes a database oriented approach where we migrated to a singular system. This is fascinating. Let's dive a bit deeper into this. So in the previous video, we ended on talking about the limitations of a file processing system and how redundant data, isolated data and the file structures in which the data were stored were problematic for systems to talk to each other and for users to be able to understand how to manage their data. In comes the database oriented approach. As the pros started outweighing the cons, when Oracle and Postgres and Microsoft came out with these database softwares, people had no choice but to migrate away from their approach of building custom software to manage these systems and using a database approach. Now, what do we mean by a database approach? Well, there is this software that is utilized to manage databases and it's called a database management software.
01:14:32.376 - 01:15:06.706, Speaker C: Its sole purpose is to put constraints in place. It's going to manage your data. That's its only task is to manage your data. And the way it does this is by following a model. So different database softwares follow different models becomes a bit tricky. Right. So what are we saying by that? Well, if we had a school system where we had library exams and students, all of these concepts are going to be managed by this database management software.
01:15:06.706 - 01:16:01.188, Speaker C: But on top of that, it's going to enforce a model, it's going to enforce a structure of data that each and every one of these needs to follow. And by enforcing that structure now, no one needs to care about where the data is stored. This isn't important anymore because all of these structures are following the same principles. And there is a layer of software in front of whoever's talking to it that is doing this management. That means you don't need software developers anymore to create custom solutions. You don't need all of these migration and gluing together of systems that you previously needed between the data which would happen here to make systems talk to each other. What you had now is one piece of software that promised you, if you follow this model of the way to save your data, we'll do all of the management for you.
01:16:01.188 - 01:16:56.408, Speaker C: And that is what the database management software did. So a database approach took all of these fragmented, isolated systems that store data separately in different ways and unified, made them one. That is amazing. That's a huge step forward, not only because it simplified so many things, but also because you can now build more robust systems. You could build a library exam and student interface that knew about each other and could make relationships. If a library rented a book to a student, it could reference the student by an identifier, by something unique to that student. And if the student updated his address, because the library referenced the student by something unique, it didn't have to copy over the student's data, it just had a reference to the student, like a student id or something like that.
01:16:56.408 - 01:17:41.024, Speaker C: It depends on the model you follow. But what's important here is that because that model is enforced and you unified the data, you can now draw relationships between the data. You can say a student is related to a book rental, a student is related to an exam. You could make these mental maps. And it was so much more logical than saying, well, my students are stored over here and my exams are stored over here and my library rentals are stored over here. And if I need a student, if he's going to rent a book, let me just copy his information from over here and put it in the rental. Because if that information ever changed, how are you going to migrate that change over and such? All of those things went away with the database oriented approach.
01:17:41.024 - 01:18:31.582, Speaker C: And by using this software. Now, how does that look in practice? Previously we saw that a user just was using a system and that would talk directly to wherever the data was stored. There was custom software in between, but by utilizing the database oriented approach, we now had this new player, the DBMs or database management software. This software was the interface between your data and whatever was storing your data. So now you didn't even need to care if you were running Windows, Linux, Mac. This software over here would handle all of that and it would just give you a common way of saving data. And with that common way of saving data came a specific language, that specific language being SQL structured query language.
01:18:31.582 - 01:19:09.874, Speaker C: It was a unified one way of talking to the database management software to get data, to put data. And by unifying all of that, you simplified all of your systems. So the user now didn't need to know the specific system. All he needed to know was SQL. And by knowing SQL, it didn't matter what database management software you were using. Sure there are small differences here and there between the versions of SQL as we discussed prior, but by knowing SQL you basically took this entire layer away from the user. They didn't need to know anything about the way that that was stored.
01:19:09.874 - 01:19:57.504, Speaker C: And you also took away the need for developers to build complex software solutions to manage this data. All they needed to do was learn how to model their data for the database management system. Because each database management system has their own model. And we'll get deeper into the different types of models as we go along, focusing primarily on one which is the relational model, but we'll get into that later. For now, all you need to know is that a database management system follows a specific way of structuring and saving data called the model. And as long as software developers knew how to model their data for the database management system, they were golden. They could structure relationships between data, they can make a student exam library system easily.
01:19:57.504 - 01:21:00.890, Speaker C: And by structuring the data in that model now SQL could easily talk and retrieve data. There was less isolated data, there was less need for redundant data, and there was less of an issue migrating data between systems because all the systems used the same model and the same software to manage the data. And that brought along so many benefits that we've seen, taking away all of those limitations that file processing systems had. So let's talk a little bit more about database models. All right, so database models, this is something we've seen come back again and again. And in essence, a database model is nothing more than a way to organize and store your data. But it also does so much more than that.
01:21:00.890 - 01:21:50.812, Speaker C: That core definition explains only a portion of what's going on here. And there are many, many database models out there to list some. Here you have hierarchical networking entity relationship, relational, object oriented, flat, semi structured, etcetera, etcetera. There are many, many models out there that you can use. And a lot of these models are designed with rules and concepts in place that allow you to create a view of the data that you're going to store. Now, the one that we will be looking most at throughout the course is relational, because it is still to this day one of the most popular and widely used models out there. But I selected two other models that I thought were very important to look at.
01:21:50.812 - 01:22:37.302, Speaker C: They're slightly outdated and they were popular way back in the seventies and eighties, but they hold a core foundation of where we started to where we are now. So we'll be taking a closer look at hierarchical and networking. Let's get into it. Alright, so first up is the hierarchical model. Now this is a fairly old model. It was primarily used by IBM in the sixties and seventies and hasn't been seen today very much due to its inefficiencies. It isn't as popular anymore because it isn't really an efficient model for storing data.
01:22:37.302 - 01:23:20.706, Speaker C: But how does the data get organized in the hierarchical model? Well, as the name suggests, there is a hierarchy. It decides to store and organize data in a tree like structure. And it has this concept of parent child. So what we can see here is that the parent author has two children, Mo and Andre. And Mo and Andre have two children as well, two books that they wrote. So every child only can have a single root. What do I mean by that? There is no ability to say Mo and Andre both co authored book one there.
01:23:20.706 - 01:24:03.828, Speaker C: There is no linking of one child node to someone else's child, each and every node. And what we mean by node is a child that are synonymous to each other. Each and every node can only have one parent. So with this tree like structure, we already have put in place one constraint. Every parent can have multiple children, but every child can only have one parent. Now I hear you saying, okay, I understand the concept, but what does that look like in real life? Well, because this model is very outdated. There aren't many things that emulate it quite as well as it used to be used.
01:24:03.828 - 01:24:36.000, Speaker C: But one thing we can use to kind of make this structure look like it would have been stored is XMLA. And XML is a document type in which we structure data also in a tree like fashion. Over here, you can see an example of XML. We have a parent node author, and then we have a child node, mo, and a child node. Andre. And Mo and Andre are storing some data about themselves. They're storing their name, and they're storing their country.
01:24:36.000 - 01:25:09.440, Speaker C: These are directly related to Mo, and then they're also storing their books, book one, book two, and the release dates. And Andre is doing the same thing. He has his name and his country, his books. Now, you can see here, because of this structure, if I were to delete Mo, all of the information about Mo would be deleted as well. Same counts for Andre. If I deleted his book one, the release date goes poof. So this is one of the drawbacks of a hierarchical structure right here.
01:25:09.440 - 01:25:41.500, Speaker C: Because you have this parent child structure, and every child can only have one parent. When you delete a parent, all of the child's information goes away. So the data is what we would call tightly coupled. The child data is tightly coupled, tightly coupled, meaning it is directly related to its parenthood. If the parent goes away, the child information goes away. This is what we call tight coupling because it's directly related. And if the parent were to go away, so would the data.
01:25:41.500 - 01:26:32.948, Speaker C: Now, what we can see here is that this is pretty good for describing what we would call real world relationships. Mo is directly related to his information and his books, but it is also good for describing what we would call a one to many relationship. Let me backtrack a little bit to explain what that means. What a one to many relationship means is that if we look here, an author can have many children, but a child can only have one parent. Andre can only be related to author. Book one can only be related to Andre because it's his book. It's not Mo's book that we don't have a way of saying, hey, book one right here was both Mo's and Andre's.
01:26:32.948 - 01:27:00.094, Speaker C: They wrote a completely different book, one. Just think of it as having a completely different title, for instance. So what do we mean by one too many? One parent can have many children. The child can only have one parent. That is what we call a one to many relationship. So the hierarchical model supports one too many relationships. And that is very apparent here.
01:27:00.094 - 01:27:27.800, Speaker C: Author has two children and the children have more children. See, Mo has name, country, book, book two. So that becomes very clear. We now know how the hierarchical model is storing data. This is just an example of how data would be stored. This is nothing, exactly how it was stored back in the day when hierarchical databases were out. Again, these are rarely seen today due to their inefficiencies.
01:27:27.800 - 01:28:14.794, Speaker C: So then came along the networking model, and the networking model expanded on the hierarchical model, allowing many, too many relationships. Now, what do I mean by that? Well, suddenly we could allow co authoring. Mo could now help Andre on book one, and they could have a significant relationship that related to each other. We could now say the child entities could have multiple parents. Let's solidify that a bit more and go back to the hierarchical model. So what we said here is that each and every parent can have multiple children, but each child could only have one parent. All right? Because of that, we couldn't do things like have a book be co authored.
01:28:14.794 - 01:28:58.274, Speaker C: So because the networking model expanded on the hierarchical model and allowed the many to many relationships, it became a bit more complex to manage your data. And if we took our XML example, the software would basically do something like, okay, we have an author, we have Mo. Again, we know this. But then his book one would reference author Andrea, and then it would specify his relation to be co author. And then Andre would have the book definition of book one. Now, what this would mean is that the software would have to keep intact what a relationship was. And this is just one way of defining a relationship.
01:28:58.274 - 01:29:52.810, Speaker C: Now, this is in no way the practical way, in any way, shape or form that a networking model would have done its relationship. But for reference sake, let's just say that the software did have this type of relationship where it would say, okay, the author, the other parent is Andre, and my relation to it is co author. That way we would have enough information to say, go get the information from Andre about book one. And here's the extra information about me, I'm the co author. Now, that would mean that if Andre ever deleted his book one, the software would have to go and say, okay, Andre deleted book one. Let me go through all of my other data and see if there is a book one that links author Andre so that I can manage the deletion. And this meant that it became more complex for the software to look at relationships and warrant the relationship between data.
01:29:52.810 - 01:31:11.844, Speaker C: So now that we know how the networking model in the hierarchical model our historical models used to work where one to many relationships came to start. We defined where many to many relationships came to be, and people started to think, huh, okay, this tree like structure that we're storing our data in, it isn't really working for us. So in comes the relational model. Let's take a closer look at that. So the relational model, now, we looked at the hierarchical model, and we looked at the networking model, the networking model being the expansion of the hierarchical model and how they followed this parent child structure, which to its own right, had its efficiencies when retrieving data, because once you had the parent, you had all the child information right there. But it came with its own set of inefficiencies with the networking model because of the way many to many relationships were formed. Like we said, if you were to delete book one from Andre, you would have to go and look at every other parent and see if they had a reference to book one of Andre with a specific relationship.
01:31:11.844 - 01:31:53.304, Speaker C: So there were these intricacies in data management that came to be. So in comes the relational model. EF CoD looked at the landscape of how we were organizing data and realized that most of the models we were following, they were informal. There wasn't any set rules in place for the hierarchical model nor the network model. There was this idea, and there were these theoretical papers on the models, but there weren't any hard set rules in place to say, hey, this is how you should do it. This is how you get the most out of it, and this is how we're going to model our system. So he came out with a relational model which had a formalized set of rules.
01:31:53.304 - 01:32:34.368, Speaker C: The first model with the formalized set of rules, to be exact. And if we look at the model here, it doesn't follow that parent child like structure anymore. It chose a completely different route. Instead of relating your data through a parent child relationship, it followed a table structure, organizing your data in tables, also called relations. Now, here you're saying, what is a table? Well, think of an excel sheet. An excel sheet has columns and rows. And when you use an excel sheet and you have those columns and rows, you can give the sheet a name that's very closely related to what tables are.
01:32:34.368 - 01:33:00.716, Speaker C: Our table has the name author, and a table has the name book and the columns, although not like Excel, having the name A, B, C, and D, they do have specific names. Let's take a closer look at that. Here you can see three tables. Over here you can see the table for author. Over here you can see the table for book and don't pay attention to the middle just yet. We'll get to that. When we look at author, we can see our columns aren't called a, B, C, and D.
01:33:00.716 - 01:33:39.414, Speaker C: We have author id, first name, last name. So we're specifically saying, what is going to go in this column? And over here we can see author 20 is Mobini, author 21 is Andre Nagoy. You may ask yourself, why do we have this author id? Well, we want something to uniquely identify our data because first and last name, well, there may be someone with my first and last name. There may be someone with Andre's first and last name that's not really unique. So we choose something that can uniquely identify each and every piece of data. And the same for book, the book name isn't really unique. Book one, two, and three, there may be someone that has the same book name out there.
01:33:39.414 - 01:34:13.132, Speaker C: So we choose a book id. All right, now I can see you looking at this and being confused. When we looked at the network model, in the hierarchical model, we were storing data in that. Remember the XML format that we were looking at, we were storing it in a parent child like structure, and every parent had all of the information of its childhood. How does this relate to what we're doing in the relational model? Well, remember I said we're storing all our data separately. Now, we don't have this parent child structure anymore. We have a table structure.
01:34:13.132 - 01:35:02.910, Speaker C: So now, instead of having an author parent, each and every author is an individual piece of data with a unique identifier. And each and every book is an individual piece of data with a unique identifier. Now, you may be thinking, okay, I can see that they're completely separate, but how do we link them together? Well, in the relational model, we have a bunch of concepts that we will get into on how to draw relationships between data. This is one way of doing it. We'll create a third table where we say, okay, author mo wrote book 200, and author Andre also wrote book 200. So now we can say, oh, they may have co authored this. And then author Andre also wrote book 201.
01:35:02.910 - 01:35:46.720, Speaker C: So book two was written by Andre and book three was written by Mo. So by linking their unique identifiers together in a separate table, we can now say, hey, this author and this book is related. And by retrieving all the authors for a book, we could potentially now say, oh, this book has two authors. So there may be a co author situation. So by storing all our data in a flat way unrelated to parent and childlike structure, we can now draw relationships in a much simpler way. You could do this in an excel sheet in a very simple way. You can input this data in one sheet, input this data in another sheet, give the sheet a name book, and then in a third sheet you could start putting ids together.
01:35:46.720 - 01:36:19.938, Speaker C: And that is the exact same concept here. Now I hear you saying, okay, okay, but if I put this in Excel, Excel isn't going to tell me that these are actually related. There's some kind of logic there, right? And you would be correct. The logic of how the relationships are linked are managed by the database management software. Now. So now we've looked at three models, right? We've looked at hierarchical, network and relational. Each and every one of these models, formal or informal rule sets in place have specific rules.
01:36:19.938 - 01:36:47.270, Speaker C: Right there. There is a rule that you have to follow. Hey, author id needs to be unique. Hey, book id needs to be unique. Hey, in the hierarchical model, you can't have more than two children linked to a parent. Hey, in the network model, when you change a book that has two parents, we need to change it in both places. All of these things, all of these rules, all of these things that we've talked about need to be managed, and we're not going to manage these.
01:36:47.270 - 01:37:38.298, Speaker C: These need to be managed automatically. We don't want to do manual data entry. That would be unfair. So like I said, with file processing systems there's always software in place. And with the models, we went to a database oriented approach, meaning there is one piece of software that is going to manage the model and that is the database management software. Now we'll look at the relational model more closely and all of its rules later on. But I really want to zoom in and look at the database management software right now because it is the key player in making sure that when we do implement a system like this, a structure like this, that all of the relationships and all of the management of your data and the safety of your data and where your data is going to be saved, it's going to manage all of that.
01:37:38.298 - 01:38:29.670, Speaker C: Let's take a closer look at that piece of software because it is extremely important to the whole picture. All right, so database software, we keep talking about this. We keep talking about databases being the data we store and it being stored in a specific way called the model. But we never really dove deep into what actually makes this happen. Well, that is called the database management software. And it's a piece of software that basically says, okay, I am going to manage your database. I'm going to be your supervisor, I know all of the rules about the way you want to store your data.
01:38:29.670 - 01:38:52.480, Speaker C: I know your model, and when you give me an SQL query, I know exactly how to get your data and give it back to you. It's kind of like your mediator or your manager. It's there and it knows everything and it's kind of like a referee. It's like, hey, hey, hey. You can't store things this way. Hey, hey, hey, don't do this. I am going to enforce very specific rules on you.
01:38:52.480 - 01:39:37.820, Speaker C: It's like if you took an Excel sheet and you made it a bit smarter. Well, this software says, I'm going to follow a model, whatever model that is. It can differ between the database softwares. And I'm going to enforce these rules for you and I'm going to use SQL as a way for you to talk to me and I'm going to make sure that your database is safe and secure and that I manage it the correct way. So if we look at what a database management software system can do, well, we're talking about create, read, update, or delete crud operations. Okay, let's take a step back here. What do I mean by that? Well, because your database management software is between SQL and your database.
01:39:37.820 - 01:40:08.498, Speaker C: It's basically the one that's saying, okay, you want to create a database? Let's create you a database. Okay, you want to create some data? Let me put some data in your database. Okay, you want to read some of the data? You want to send me an SQL query? Well, I'll give you back the right data. Oh, you want to update something? There's some data in there that doesn't match your expectations. Cool, I'll do that for you. And it can even delete some stuff. Okay, we accidentally added a student that isn't going to be part of the school.
01:40:08.498 - 01:40:45.700, Speaker C: Let's quickly remove them from the system. Create, read, update, delete, crud. This is an acronym that you will often hear when talking about SQL and databases because this is the bulk of what SQL is going to do for you when you talk to your database management software. And this is the bulk of what the database management software intends to do for you. But on top of that, I talked about the database management software doing a bit more. A database management software not only allows you to do those crud operations, but what it's also going to do is it's going to manage your data. It's going to make sure that it's saved in the right place.
01:40:45.700 - 01:41:38.948, Speaker C: It's going to make sure that it knows on what hard drives it's going to put what, it's going to secure your data, it's going to make sure that not everyone can touch them. It's going to put in place the right security policies and the right permissions, and it's even going to do something called transaction management. This is something fairly complicated that we're going to get into later, but transaction management is basically like, hey, I want to update something and someone else wants to update something and they're updating the exact same thing at the same time. Well, the database management software is going to basically say, oh, something happened here, I'm going to quickly undo the change because that's not what we meant to do. It's going to do way more complex scenarios. It's going to handle those for you. Database management software is basically there to guarantee that your data is always going to stay safe and always going to be accessible.
01:41:38.948 - 01:42:50.188, Speaker C: Basically, when we used to build our own custom software, what could happen? Well, some developer could push a change and it could corrupt some data or could do something wrong in a certain operation and some specific record of a user could go missing. Record meaning like a specific part of data, like you had a user's address. And when we built the custom software, remember the file processing systems? Let's say a developer committed a piece of code that was supposed to update your address and something went wrong there. Because a database management software is removed from that custom build and it has one sole responsibility. We're always guaranteed that it's going to do these things to the best of its abilities and that they're rigorously tested. So this database management software is very good at doing these tasks, both the crud operations as well as the security management and making sure that your data and the people that are interacting with your data do the right things. That is very, very, very key to a database management software, and that is what makes it so powerful because it has a sole responsibility.
01:42:50.188 - 01:43:36.050, Speaker C: Maintain your database, maintain your data. So who is making database software? Well, Microsoft has SQL server, IBM has a couple of solutions. We all know mysql fairly well. There's Oracle out there, and some of you may have heard of postgres, which is an open source variation of a database management software. But these are the companies that, basically the biggest companies that make database software, and they all make it slightly different from each other. You see, each and every one of these companies makes a database software that is in essence going to maybe follow the relational model or maybe follow some other model of storing data, but they also have different features. They're all trying to compete with each other.
01:43:36.050 - 01:44:07.432, Speaker C: So when we talk about MySQL versus what Microsoft brings out, which is SQL Server, they're both using SQL for us to talk to it. But they may have slightly different features to kind of upsell you, hey, we do this slightly better. Hey, we do transaction management a bit better. Hey, we do security a bit better. Oh, we have the best this or that. They in essence compete with each other on features. But at the end of the day, there is a core to them, SQL, and a certain model of storing data.
01:44:07.432 - 01:44:50.366, Speaker C: So again, what can it do? Well, we talked about the database management software, managing the database, and all of these players competing with each other in order to allow SQL to talk to the software. Right. They all have slightly different variations of SQL. They could add some special little things in there. But what we are going to focus on is the core of SQL. We want to give you the toolset and the core of the language to be able to go to any of these vendors and be functional. Sure, in each and every one of these, you may need to learn some of the tips and tricks that go with the software because each of these softwares are different, but the baseline of SQL is abstracted away from this software.
01:44:50.366 - 01:45:40.240, Speaker C: This software is supposed to understand SQL and SQL is supposed to talk to this software. So even if the software is a bit different between these, they all do the same thing. At the end of the day, they do the crud operations, the security, the management, and they may all do it slightly differently, but we are going to give you the foundation to be able to interact with any of these. And that is what is so powerful. And we're going to do that through SQL. So if I were to take a database management system, and I were to put it in a simple analogy, because analogies are so powerful, let's say that your database management software was a chef and that SQL was the customer and that the database was a type of cooking. Well, if the database management software is a chef, we all know that chefs do things differently.
01:45:40.240 - 01:46:29.382, Speaker C: You can go to three restaurants, you can order the exact same dish, the exact same pizza, Margarita, spaghetti, bolognese, a steak, and each and every one of these chefs may do it slightly differently. So each chef has their own quote unquote, database of cooking, and they may all store the data in their head slightly differently. They'll do steps differently, they'll do this differently, that differently. But at the end, when you ask them to make you a pizza, you are going to get a pizza. I hope that makes a bit of sense. And then if we were to stretch that analogy a bit further, and you asked the chef for a recipe, you asked the chef, okay, how are you going to do this? If we looked into that, every chef is going to do their recipe a bit differently. They're going to write down steps differently, each of them thinks differently, and the same is true for a database management software.
01:46:29.382 - 01:47:16.936, Speaker C: Each and every one of these interacts differently with the database, interacts differently with how they're going to store the data, what hard drives they're going to use, where they're going to put certain files, and how they're going to take your query, make me a pizza. And how they're going to process that to give you the pizza. That really simplifies the way that we have to look at this, because a database management software is basically the one interacting with both ends. If we took this and we put it at a 10,000 foot view, a user is interacting with SQL and is firing some kind of query. And the database management system is interacting with a certain database. It can store multiple databases. You can have databases for multiple, multiple reasons.
01:47:16.936 - 01:47:52.056, Speaker C: You could have a school database, you could have a recipe database. And the database management system is just storing these. And then at the hardware level, some hard drive or multiple hard drives or multiple systems are storing this data for you. And the database management system is taking your query and figuring out, okay, I need to talk to this database and I need to go to this hard drive to get the data. And this is how I need to break it down. That's basically how it looks from a high level view. Now on the Internet you may see rdbms.
01:47:52.056 - 01:48:41.550, Speaker C: So DBMS stands for database management software. And database management software is the general term for a software that is going to manage your databases. But then the r portion, we've already spoken a little bit about the relational model and what the relational model is in a very, very brief way. We'll dive deeper into that as we go along. But when you see rdbms, you're looking at a database management software that's specializing in relational databases. So it's focusing on one single model. And this one single model was developed by a developer at IBM in the early eighties and then taken by two of his colleagues who invented the original version of SQL as well as the very first database management software.
01:48:41.550 - 01:49:32.272, Speaker C: They took his ideas and basically built the very first version of SQL and the very first version of a database management software. But because they were following the relational model. And because we've already spoken about the database management software, being your referee, being your security, implementing the specific rules that you need to follow. Edgar Codden, the person who came up with the relational model as well as the database management system, wrote 13 rules that needed to be followed in order for a database management software to be considered a relational database management software. He coined these the 13 rules of CoD. Now, we're not going to go into the specifics of them because they're very much at a high level understanding. They're basically rules that need to be followed to build a database management software.
01:49:32.272 - 01:50:43.988, Speaker C: They are the rules that the database management software is going to enforce on you when you get an error, when you're trying to do something that doesn't follow these rules. That's what the database management software is doing. It's following these rules in order to give you some constraints and give you a way to save in a relational way. And when we say a relational way, we're talking about the relational model. We're talking about storing things in tables and columns and rows and enforcing that these rules are followed, the database management software is going to enforce them. So now that we know so much about what a database model is and how a database management system is going to be your connecting piece, your referee, your middleman in terms of getting data into the system and pulling data out and enforcing all of these rules, let's take a closer look at this relational model and how we are going to store data so that we can form a full picture of, okay, this is a database. This is my database management software, and this is the model I'm going to follow.
01:50:43.988 - 01:51:43.708, Speaker C: This is how I'm going to store my data. And once we have that, once we have that full picture, we will understand how to use SQL to interact with software like Oracle, like postgres, like MySQL, to store and retrieve data. Now that being said, there are multiple models out there you can follow, but each database management software worth its salt will focus on one single model. You may have heard of terms like no SQL and other variations of that, hierarchical databases and so forth. Don't focus on any of those. We will dive into those individually to explain how they differ from relational models down the line. But right now we really want to slim down and focus solely on the relational model so that we can really get a solid foundation on a single model, a single way of storing data and using SQL with that model.
01:51:43.708 - 01:52:54.800, Speaker C: And once we have that solid foundation with one model, when you want to expand to different models, it'll be easier than you think. So, the relational model, we're finally looking at how we are going to store data and what format we are going to store data in. Now, as we spoke about previously, each and every database management software and each and every database follows a specific way of saving data that we call a model. And each and every database management software enforces the rules of these models. Now, when we talk about the relational model, what we're going to be talking about are the terms on this screen, relation schema, attribute degree, cardinality, tuple, column, relation, key domain tables, relation instance. Now, don't get overwhelmed here. Each and every one of these terms is very simple to explain and in essence very, very straightforward.
01:52:54.800 - 01:53:58.370, Speaker C: All we need to do is break it up into small portions, and that's exactly what we're going to do. So let's start with tables and let's take a closer look at them. What is a table and what is a table in the relational model? Well, we've looked at multiple, multiple examples of how to break down data. And each and every time we've broken down data, we've broken them down into these entities or objects or concepts, whatever you want to call them, be it a user, a student, a teacher, and a table is a representation of that object. So here we have the object user and we have a table. And when we create a table, we give it a name. That name is of that object, so we're going to call it user.
01:53:58.370 - 01:54:28.946, Speaker C: So a table has a name. That's the first and foremost important thing we need to know. Each table has a name, and that name relates to the concept of the data we're going to store. Think of an excel sheet and giving the excel sheet a name. And then when we look at a table, we can see that we have these things at the top called columns, and each column represents a specific type of data. We have id here, which is an incrementing number. It goes up 12345.
01:54:28.946 - 01:55:00.160, Speaker C: Then we have first name that contains the name of the user, the first name and last name. And then we have their gender, male, female, and so forth. And then we have their date of birth, which follows a specific year, month, day. So what we can see here is that a table has a name and a table has columns that store specific types of data. Kind of like an excel sheet, but an excel sheet. The names of the columns are already named. If you've seen Excel, you can see a, b, c, d.
01:55:00.160 - 01:55:34.494, Speaker C: Here we get to choose the names. So that's very important because we're specifying what type of data we want to store in each column. And then here next to the columns we have these rows also like in excel sheet, these rows of data. And each and every row is a singular piece of data. It represents one single piece of data for that table. So here you can see Mobini, me, the instructor, and you can see my date of birth, my sex and my id as a user. That is one piece of data.
01:55:34.494 - 01:56:16.058, Speaker C: And that data is split up into columns that represent each and every piece. Very very important. So here we can see the relationship between what a table is and what an excel sheet is. Like I said, you can see over here every sheet has a name, kind of like a table has a name and every sheet has columns. A, b, c, d, e, f. Kind of like our table has columns, but our columns are more specific. We are actually saying what we want to store in each, every column where in excel the columns are generic, they're pre named so to speak, so that it doesn't matter what data you put in here, it's going to accept any type of data.
01:56:16.058 - 01:56:48.654, Speaker C: You just know that your column name is a, b or c. You can go a bit farther in excel and give specific columns. At row one you could put first name here, last name here, date of birth here, just so you know what's going to be in these columns. But you, you would lose a row. But that being said, the relationship between the two is very close. Except in the relational model, a table has much more nuance. What do I mean by nuance? There's a lot more details here.
01:56:48.654 - 01:57:47.196, Speaker C: We're very very very specific in what we want to store and how we want to store it. So now that we know that, let's take a closer look at what a column is and how that gets defined. Alright, so columns, we already kind of talked about this when we defined what a table was, because a table is a collection of columns and rows and each column has a specific data that it wants to store. For instance here, last name, we're being very specific about what we want to store and each and every column has a name. But columns are a bit more complicated than that. They have more going on than seemingly just being a place to store a specific type of data. Now what do I mean by that? Well, one single column is called a column.
01:57:47.196 - 01:58:13.978, Speaker C: We know that. But what would we call the collection of all the columns? Well, that's what we would call the degree of, we call that the degree of the relation. If we were to take a table and we were to say, okay, what is it we're storing in the table? Well, we would say, like we're storing multiple columns. That's. That's one way of saying it. Or you could say the degree of the relation is id, first name, last name, sex, and date of birth. It's a very theoretical thing to say.
01:58:13.978 - 01:59:00.766, Speaker C: Nevertheless, it's the term that we use to call out the collection of columns, and each and every column stores a specific type of data. Here we can see that last name stores the last name, and that sex stores male, female, or otherwise, and that date of birth follows a very strict year, month, day. Well, when we talk about what a column can store, we call that the domain or the constraint. We're saying, okay, in date of birth, we can only store dates. So we have a lock here symbolizing, you are constraining the data. You're saying only put this in this field. So we're saying in date of birth, only put dates.
01:59:00.766 - 01:59:29.264, Speaker C: And the same, we could say for sex, only put one singular letter m or f or otherwise. So we're being very specific about the domain of the data. The domain of the column. That's what we call domain. It's the constraint of the data. It's what can go in here. And another way of talking about columns is saying, well, my table has these attributes with these constraints.
01:59:29.264 - 01:59:51.268, Speaker C: So there's very theoretical ways of talking about this. And all of these are used interchangeably. You could say attributes. You could say degree of the relation. You could say columns. You could say, my columns have these constraints or these domains. And the only reason I'm pointing these out to you is because when you go into the real world and you talk to people that are making databases, they may use this terminology interchangeably.
01:59:51.268 - 02:00:24.806, Speaker C: And all you need to know is that a lot of them have synonyms or simpler ways of saying them. You could say column. You could say the table has these attributes. You could say the table has this degree of relation, being id, first name, last name, sex, date of birth. You could say, one of my columns has these constraints, or my column has this domain being date, time, or a single letter. So all of these are very important nuances to take into consideration. Now, let's back that up a bit.
02:00:24.806 - 02:01:10.120, Speaker C: We said every table has a column, multiple columns. Or you could have a singular column, but mostly you'll have multiple columns in a table. So every table has columns. Columns are also called attributes, and the collection of columns is called the degree. And each and every column may or may not enforce a specific type of data to be saved in it, you can see id can be only numbers, date of birth can only be date time. We call these constraints or the domain of the attribute attribute domains, so to speak. Let's keep it simple and call them constraints, because we're constraining the data to be a certain type.
02:01:10.120 - 02:02:20.210, Speaker C: Alright, now that we know that, let's take a closer look at rows and all the specifics around them. Alright, so what's so special about rows? Well, so far we've talked about tables and tables being a collection of columns and rows, and we kind of talked about columns being special in that they have specific types of data that can be saved into them. Now, when we go into the specific data that we're saving, well, each and every column has that constraint, right? The constraint that we talked about, or the attribute domain. Well, when we start creating rows, we're actually inserting data into the table at this point. And another word for rows that you will hear used interchangeably is tuples. I can hear you saying tuples. What are tuples? Well, a tuple is nothing more than a single record of data.
02:02:20.210 - 02:02:48.346, Speaker C: That's all it means. So one tuple is one singular row of data. Tuples are multiple rows of data. And so what's important to know here is that each and every tuple follows the column constraints. Right? Remember when we had constraints above here, date of birth should only be date time. Well, each and every tuple has to follow the column constraints. So the id must always be a number.
02:02:48.346 - 02:03:31.970, Speaker C: First name and last name can only be text. The sex or gender has to be a singular letter. Date of birth has to be a date of birth. That's what's so special about rows, or as we call them, also tuples. Now, remember when we said multiple columns are called the degree, the collection of columns? Well, when we talk about all of the tuples or all of the rows, all of the data that is in the table, we have a special term for that as well. We call that the cardinality or the collection of rows or tuples. That's a special term that you may also hear used, although not that often.
02:03:31.970 - 02:04:35.520, Speaker C: But it is the correct terminology. When talking about multiple rows of data, you talk about the cardinality of the table. All right, so now that we've dove deeper into both columns and rows, let's take a broader look at what makes the relational model so special. So we ended on cardinality, and we've looked at a lot of the relational model. We've seen so much of it, but yet we haven't hit the main point of what makes the relational model the relational model, and that is the ability to link relationships between different types of data. If we look over here, we can see something called the primary key. And so the primary key, in essence, is a key.
02:04:35.520 - 02:05:16.480, Speaker C: Now you may be thinking, okay, well, yeah, I can read too, primary key, but what this is is something that uniquely identifies your data. We've always seen this in most of the tables that I've shown you. We've seen the id field there and we've seen it uniquely identify each and every row. 12345. It is a unique identifier. It uniquely identifies each and every row. And why is that important? Well, uniquely identifying each and every piece of data means that we can now know for certain the person with id one is Mobini.
02:05:16.480 - 02:05:57.062, Speaker C: Now, it's great. I'm number one. I'm not trying to say that, but what I'm trying to say here is that because of the id being the primary key, primary key being the term that we use to say, this is the thing that's uniquely identifying each and every row, because it is the primary key, we can now use it and we can say, well, hey, I have some other data over here and it's kind of linked to this. It's kind of linked to Mobini. And so I can use his id, right? I can use his id and I can say, oh, this is linked to Mobini. And yes, you can. That is the vital part of the relational model, the ability to draw relationships.
02:05:57.062 - 02:06:41.132, Speaker C: And so how would that look? Well, let me show you. There is also something called the foreign key. And the foreign key is just this other terminology for saying, well, if the primary key is uniquely identifying my data in place, if I am going to reference data from somewhere else, well, I'm going to reference it by that primary key because like I said, I want to uniquely identify Mobini. So Mobini is number one. Well, if I went into the manager id, I can see here m one, m two, m three. And so if I'm going to link that relationship, if I'm going to say, well, you know what, Clyde Bowie is the manager of Mo. Well, then I'm going to have to do that in a certain way.
02:06:41.132 - 02:07:23.906, Speaker C: So we see over here in orange, the manager id being the primary key of managers. M one, m two, m three. And so over here we see the primary key, Mobini one. And the manager of Mobini is done by drawing a relationship to manager id. And the way we do this is by injecting a column. There is a new column in this table, and the sole purpose of this column is to manage that relationship, is to say, hey, well, Mo is managed by m one. So a foreign key references the primary key of a different table.
02:07:23.906 - 02:08:09.406, Speaker C: Let me repeat that again. A foreign key is a key that will reference the primary key, the unique identifier of a different table, therefore allowing a relationship to be formed that is solidified in stone. More so than my fiance and I's marriage. I'm kidding there, of course. But that being said, with this, what you basically get is a relationship and a relationship that is warranted by the fact that is linked to a key and that key is unique. That key cannot be changed, that key cannot be deleted, because if it is deleted, then it would cause issues throughout the system. We'll get into that part later.
02:08:09.406 - 02:08:55.956, Speaker C: But that being said, what we need to know now is because we are referencing a unique key and because we are injecting this column that says managerid in the same table as the employees. Well, now we know for certain that Mo manager is Clyde Bowie. And that is how we link relationships. We link relationships by primary keys. And once you've created a relationship, a primary key, where it is injected, becomes the foreign key. So now that we know all of that, we know the core of the relational model. We know the essence of why the relational model is the way it is.
02:08:55.956 - 02:09:24.280, Speaker C: This unique way of drawing relationships is what makes it special. Amazing. Well, now we know the relational model. Now we know all of this stuff. Let's look at how these databases can be used. So far we've learned a lot about relational databases. We learned a lot about the model.
02:09:24.280 - 02:10:13.208, Speaker C: We learned a lot about how it's put together and what rules there are in place. But you may be asking yourself, hey, what are these used for? What kind of databases can we make with these? Well, I'm here to tell you there are two different uses that are distinctly grouped for relational databases. One supports the day to day operations of a company, and the other supports the analysis of a company. Now what do I mean by this? Well, when you have a company, there are two distinct factions in a company. Now let's think of an Amazon. Well, in an Amazon you have the day to day sales people coming in, logging on, buying things, and you have databases that are supporting those day to day transactions. Let's keep a log of what they ordered.
02:10:13.208 - 02:11:09.766, Speaker C: Let's keep a log of what credit cards they'll use, all different types of things that support the day to day business. But then you have this entire back office that is supporting the analysis. So they have all of this data on you, and they're trying to figure out, hey, what makes this customer tick? What are they interested in? And then you have this entire faction of the company that's taking this day to day data and doing analysis on it to give you recommendations, to give you all of these different types of things. And as I already said, they're grouped into two distinct buckets. Well, if we went and we looked at the supporting day to day, we call that OLTP online transaction processing. These are databases that are driving the day to day transactions. They have the users, they have the orders, they have the purchases, and all they do all day is store and categorize this data in that relational model.
02:11:09.766 - 02:12:08.030, Speaker C: And so the users can go and they can select that raw data, transaction processing. So the transactions that we do the back and forth, and then the second type is called online analytical processing, or OLAP for short. And so that's when you take what was at that front office, that transactional processing, and you take the data and you put it in a data warehouse, and then you start doing all types of analytical processing on that data to figure out what is making that data tick. What is valuable about that data, figuring out what can we do with that? Because data is key. Data is everything we work with. Everything you do online, every interaction, every action you do that is used somewhere, somehow, to drive analytics, that drives a company to make decisions. And those decisions then lead to new products, new markets, new interactions with their customers.
02:12:08.030 - 02:12:57.150, Speaker C: And that is what Olap is used for versus OLTP. OLTP is driving the day to day business, that data that you need. And OLAP online analytical processing is driving those future decisions. Knowing all of this, knowing now how relational databases work, let's kick it off. Let's get into the dirty. Let's get querying. I thought it would be fun to complement this theoretical course with a small exercise around OLAP versus OLTP, because they are kind of abstract concepts.
02:12:57.150 - 02:13:32.720, Speaker C: So let's dive into it. Exercise. So the format here is that we are going to be guessing which ones are oltps and which ones are olapse. So a database is being used to log orders and customers. Two, a database is being used to figure out what new products we should offer. Three, a database is being used to derive statistics for reporting to the executives. And four, a database is being used to keep track of logged in users.
02:13:32.720 - 02:13:50.306, Speaker C: So pause the video right here. Think about it. Write down 1234 and whether you think one is an Oltp or an olap. And two, and three and four. And when you come back, we'll run through them. All right, so we're back. One was a database is being used to log orders and customers.
02:13:50.306 - 02:14:14.188, Speaker C: So let's go look at that. Well, that's an OLTP. So it's a transactional database. An OLTP. Why is it a transactional database? Why is it Oltpde? Well, it is OLTP because it's being used to drive the day to day of a business. All right, let's take a look at two. A database is being used to figure out what new products we should offer.
02:14:14.188 - 02:14:48.840, Speaker C: Let's go take a quick look. Ol AP. All right, so two was OLAP. Why is it an analytical platform? Well, as I said, a database that's being used to figure out what new products we should offer to look to the future, to do kind of like an analysis on where we are and what we're doing that's typically used for analysis. So it's being used to figure out the day to day driving of the business. Three, a database is being used to derive statistics for reporting to executives. That is OLAP.
02:14:48.840 - 02:15:41.054, Speaker C: Again, we're using a database to derive statistics for reporting to the executives. So we're trying to figure out, okay, what's going on here, what is in the company, what data, what statistics do we need to run in order to figure it out? So we're pumping out data from a database and we're trying to figure out some stuff on top of it. And then four, a database is being used to keep track of the logged in users. Now this one was tricky because to keep track of the logged in users, you may think, oh, I can use that for analytics, but in essence it is Oltpenne because it's being used to drive the day to day of the business. You're basically using it to keep track of, okay, this many users are logged in. This is how many sessions we have. Eventually it could be fed into a system that could use it to derive analytics to, for instance, figure out, okay, this is our daily active user.
02:15:41.054 - 02:16:04.050, Speaker C: But in essence, that database that's keeping track of that stuff at that given point in time is being used as a transactional database because someone's logging in, the record is going in saying, I'm logged in. Then when they log out, it'll log out a timestamp. And by doing that, by that definition, it is OLTP, but it could be used in an OlaP way. All right, so let's move on to the next video.
02:16:08.870 - 02:16:12.810, Speaker A: Remember, practice makes perfect. Tackle those exercises.
02:16:21.230 - 02:17:21.664, Speaker C: So you may be asking yourself, what tools are we going to use during the SQL course? Well, it is pretty simple. For the course we will be focusing on the most popular relational database software in the market, postgres SQL. And we will be using an open source software that is cross platform called Valentina DB and it is a UI that is used to manage postgres. And the reason we're using these two free tools is because they are extremely popular and you will also see them in production environments. People use them all over the world and they have proven track records. Now, in terms of if you have a favorite software to use to use with postgres SQL, I suggest you go ahead and use that if you want. But for the intents and purposes of this course, I will be doing the majority of the querying and tooling with Valentina DB.
02:17:21.664 - 02:18:05.400, Speaker C: So if you want to follow along properly, download the software and learn the tips and tricks. Now again to deeper dive into why Postgres SQL? It is widely, widely adopted. You'll see it everywhere. You'll see cloud service providers use it like AWS, Google, Microsoft, all of their clouds offer you the ability to use postgres SQL. Now we could have gone with Oracle, we could have gone with Microsoft. And to an extent those service offerings offer you different features. But to keep it open source and to keep it light and easy, we wanted to give you the opportunity to utilize a very highly respected and widely used tool, which is postgres.
02:18:05.400 - 02:19:15.102, Speaker C: So now that we know all of that and now that we know why we're using it, let's get into the installation in the setup. Basically what we're going to do is we're going to install postgres directly onto your machine. And again, the reason for this is because when running larger databases, it makes it easier for you to control the speed that the queries will run at. And DB fiddle basically can't handle that large scale database. And Valentina DB is just going to be a tool that's going to make it very, very easy for us to run queries and manage our database in a visual way. And so when installing this software, the installation process is going to be different for Mac, for Windows and for Linux, and the configuration is going to differ slightly. Now, because we are running a setup on your computer, there is going to be a URL associated with postgres.
02:19:15.102 - 02:20:01.030, Speaker C: Because postgres is running as a server and a server always runs on a URL and that URL is going to be local host localhost is just referring to your local machine. And it's going to be running on a certain port. So what does that mean? Well, a port is just like a number on a house. It's a certain door that is open for your computer and it's kind of like an address. So localhost, that address, 5432, is where we'll find postgres. So our username is always going to be postgres and our password, we're always going to try to set the root so that we have a consistency here in terms of what we're trying to set up. Now, this is not a secure password, nor should you ever do this in a work environment or a production environment.
02:20:01.030 - 02:20:45.604, Speaker C: So the URL is localhost, which means the connection URL is also going to be localhost. These two things mean the same thing, don't worry about it. And so when we go into the installation phase, what you need to know is that we will be installing version twelve of postgres. Version twelve of postgres is the latest and greatest, but you can go and you can use the newest, latest and greatest version of postgres because the databases we have here should be just fine. Any version beyond twelve. One thing to note here is that if you are running a 32 bit system of Windows, you are going to have to install version ten and version ten will work just fine as well. Now how do I know if I have a 32 bit system? Good question.
02:20:45.604 - 02:21:32.960, Speaker C: Well, if we go into Windows and we go into system information, what we'll see here is a system type, and here you can see I'm running a 64 bit system. If you are running a 32 bit system, what you're going to need to do is install version ten. Everyone else can focus on version twelve, and there will be different installation steps for different platforms, and we'll go through those as we go along. But just know version ten is just fine. You're going to be able to run all of the queries we talk about. Some of the things may not overlap quite as well because postgres twelve has newer features, but just know that you'll be able to do everything just fine. So with that being said, let's get into the installation for the different platforms.
02:21:32.960 - 02:22:36.580, Speaker C: All right guys, so before we dive into the setup, you may find that some of the things we are about to do may venture into areas that you're unaware of when working with a computer. Some of you may be more powerful users, and some of you may just be new to all of this. And we want to give you a solid foundation on which you can build. So we want to show you things that you may not have seen before. And depending on what type of system you run, you may find that there are just certain features that have eluded you throughout your usage. You may be a powerful Excel user, maybe a powerful PowerPoint user, but there are just certain things to a computer that you haven't been in touch with yet. So when we're doing SQL and postgres and over here you can see I'm on my Mac.
02:22:36.580 - 02:23:29.820, Speaker C: Well, certain systems use Unix or Linux or Mac. These are types of operating systems and Mac is very close to Linux. And then you have people that use this completely different paradigm. The majority of you may be Windows users, but what all of these computers have in common is that they use bits and bytes. And so there are ways in which you can communicate with your computer that you may not be used to. And before we get into setting up all of this that you see here, well, first we have to get into the setup of our databases. And postgres particularly is an interesting technology that you're learning because although you have all of these tools to show you things visually, a lot of people like to run postgres in the command line.
02:23:29.820 - 02:24:13.340, Speaker C: Now you may be frowning and saying like, command line, what's the command line? Well, this tool may have eluded you throughout your PC usage or your Mac usage or your Linux usage. Not so much for the Linux users. If you're in the Linux space, if you're using Ubuntu, you've probably found your way around the terminal. But basically there is this thing called a terminal and on windows it'll be called the command line. And so what that looks like is the following. It's a textual interface. So when you open it up, it may look like this, it may look a bit smaller, it may open up in a frame about this size.
02:24:13.340 - 02:25:05.318, Speaker C: But depending on how you use it and depending on if you're familiar with it, it'll just open up in a basic way. And what it allows you to do is it allows you to interface with your computer from a text perspective. Now there are multiple commands that you can run in command line and we'll reference some material that will help you supercharge your adventure down the command line route. But some of the most important ones that we'll be using are ls, which is list directory. You can also do ls a, which will show you the directory and the hidden files, files that you normally can't see when you browse your system. There is change directory which is cd change directory. And if you see if we go into databases, well if we do ls there.
02:25:05.318 - 02:25:39.468, Speaker C: Now we have a completely different file structure. And so this mimics us going into documents and seeing what's here. As you can see here, we're seeing databases, and databases zip. And then when we're inside of databases, we can see France employee. But we see these files here, icon, question mark, DS store files that we can't see when we're in our finder. And so that's what's cool about using command line. It doesn't only look like a matrix hacking sequence, it's actually very functional when you start using it.
02:25:39.468 - 02:26:23.862, Speaker C: When you're programming and doing SQL and doing other things. And when we pop over into windows, you can equally use the same in command line where you do ls. Well, that doesn't seem to work well, how do we do that in windows? Well, in windows the command is actually dir and that'll show you the directory dir. And to change directory, it's the same thing. So we can do CD desktop, and then if we do dir in here, you can see what all is in the desktop. So you can see over here we have backup SQL right over here. And then we have two directories and one file.
02:26:23.862 - 02:27:24.692, Speaker C: All right, so with this you have the power as a user to interface with your computer in a different way. And again, we'll be linking materials to push you along a journey to use command prompt wisely and successfully. But with this introduction, you have a solid foundation to know what we're talking about when we start doing things like importing our databases into postgres and other things that we can do along the line. We will also include a section on specifically interfacing with postgres and command line when we go into talks about how to maintain your database. So stay tuned for all of those. So, installing on Windows as we said in the tooling video, if you are running a 32 bit system, make sure you install version ten. Everything will work just fine for you.
02:27:24.692 - 02:27:52.818, Speaker C: Some of the features in version twelve will not be available for you, but it will be just as well possible for you to run all of the queries. Now if you have a 64 bit system, make sure you install version 12.2 and we'll go through the installation steps together. The installer is installed. We'll see the same exact thing for version ten as version twelve. We press yes, let's close this window. And so over here you can see setup postgres.
02:27:52.818 - 02:28:21.270, Speaker C: So let's press next it will specify where postgres will be installed. Over here you can see it will be installed in postgres twelve. If you're installing version ten, this will say ten, we press next. And here you can see it's going to install postgres server, an administration tool, stack builder and command line tools. Let's just select everything by default and press next. Here you can see in which directory you will store your data. Just leave it to the default.
02:28:21.270 - 02:28:48.420, Speaker C: And here you can select your password for your database. So the password we said was root, root. And if we press next we can now select the port, the address that postgres will be available at. So that's 5432. Let's press next and let's select the default locale. And here you can see everything that's going to be used during the installation. So let's press next and let's get this installed going.
02:28:48.420 - 02:29:28.830, Speaker C: Once this is done installing you will have a full fledged version of postgres on your system. And whether you installed version ten or twelve you'll be able to run the exact same commands. And so in the next video what we'll be running through is how to import your databases and setting up those databases for you to start going through the course. So now that this installation is complete and it's going to ask you to run stack builder, we're not going to run that. And so now you have that full fledged postgres server. Where is it? Well it's on your computer in the C drive. It will be under program files.
02:29:28.830 - 02:30:12.360, Speaker C: If you installed version ten you will only have one program files folder which will be x 86 which refers to a 32 bit system. So if we go into program files then you'll see postgres and for you guys it'll be named ten. Here it's twelve because it's version twelve. And if we go into the bin folder here you can see all of the commands that we can possibly run under which the P SQL command. And so in the next video, like I said, we will be running through how to set up your databases and how to import your databases to set yourself up for that success. But there is one more piece of software we have to install, which is Valentina DB. And so if you go to valentinadb.com
02:30:12.360 - 02:30:59.660, Speaker C: you can see here under download that there is the availability to install Valentina studio Valentina server components for C we want Valentina Studio. So let's view the releases in this category and over here you can see for that it runs for Mac, Windows and Linux. So if we press view files at the bottom. What we'll see here is Valentina for Windows 64 and Valentina for Windows 62. And if you press download you will go through the exact same installer and once you've installed Valentina DB it will say that it is an unknown installer. You press more info and you press run anyways. It is completely valid software but you do have to install it from the Valentina DB website.
02:30:59.660 - 02:31:46.240, Speaker C: It's because it's an unknown publisher and thus you will go through the same installation steps. Installing Valentina studio ten and go through next, next and then install. And once it's all installed you should be good to go. And if we open Valentina studio, well it's going to ask you to install the bonjour installer. We should also do this next install finish and here's going to ask you to run Valentina studio. And when we run Valentina studio you can register your copy for free if you press next. And if you fill in this they'll send you a serial code for free.
02:31:46.240 - 02:32:58.358, Speaker C: Right. Now let's get out of this. And as you can see it's already found my postgres instance over here. And so our password was root. And here we can see that we don't have any databases yet, so the next video is going to be all about installing those databases. Hey, it's Mo back again and I, I'm here to quickly explain how to set up your environment on windows to allow for quick and easy access to the PSQL command on Windows because in our initial setup videos we were referencing these bin files directly. Now if we were to say want to use command line as our main source of interacting with postgres, we don't really want to do that, right? So this video is here to show you quickly and easily how to set up postgres in such a way that you can use the PSQl command and all of these commands easily from your command prompt.
02:32:58.358 - 02:34:01.188, Speaker C: No hus, no fuss. So if you go down here to start and you look for environment variables, you can see that we'll have this little option here, edit system environment variables. And if we open that up here at the bottom, what you'll find is we'll have a environment variables button. When we click that, what we'll see is that you have user variables, in this case for education, which is my user, and you'll have system variables. Now we want to zoom in on the system variables and we specifically want to zoom in on the path variable because what the path variable is is it is the variable that is going to be loaded by command line and subsequently PowerShell and any other command prompt that you may install or want to use. But the path variable is basically a variable that in essence will point to all the binaries, all the executables, the software, basically that allows you to run certain commands. And so if we open up the path variable, what we can see is that you have multiple different options.
02:34:01.188 - 02:34:43.144, Speaker C: In here we have System 32 which is pointing to all of the regular commands that we can run in windows and all of these other ones. But the one we want to zoom in on. And the most important one is that to the path variable we add the postgres bin folder. And the postgres bin folder bin stands for binary and it adds all of these commands that we can see, pgd, rewind, rewire, all of these different commands are going to be able to be used. And one of the most important ones that we want to use is this PSQL1. Now when we install software, basically what we're doing is we're installing what quote unquote binaries. And these binaries are what allow us to run certain things.
02:34:43.144 - 02:35:42.698, Speaker C: And in this case this binary pSql is the main command that we use to connect to the postgres world from the command prompt. And when we add the bin folder, the entirety of the bin folder to our path, what we're seeing is hey, command prompt, go and actually use this folder and load in all of these binaries for me so that I can run these commands inside of the system, so that I don't have to reference them directly from where they're at, you're going to know about them forever. And by adding this and pressing ok, what we can now do, and if you already had Powershell or command line open, what you're going to want to do is you're going to want to restart it. Powershell is by far the best tool that you can use. I would steer away from command line. Command line is great for basic usage, but Powershell just has more features and is better overall. So if we open Powershell, what we can see is that if we run the PSql command now, it's going to try to log into my default user, but that's not what I want to do.
02:35:42.698 - 02:36:17.560, Speaker C: I want to do psql U and I want to log into the postgres user and now it's going to ask me for my password, which during setup we set the postgres. If I do coninfo what I'll see is that I'm connected to the postgres database. Now let's go ahead and verify that we can run some of the commands. So let's create a table. Let's do create table and let's say it's a test table and let's quickly run that. Well, we can see that we've created a table. So if we run dT, what we can see is that we have a test table.
02:36:17.560 - 02:37:10.568, Speaker C: So we have the ability now to run all of the commands and log in to postgres. Now I would recommend using Powershell because it's a more fully fledged command line and it's easier to use. The old command line is kind of limited and a bit different. But yeah, with all of this we've set up our environments in windows to be able to access command line, effectively installing on Mac. So this is a bit different than the other installations because on Mac you typically have a different installation procedure. See, installing software on a Mac generally falls into two buckets. Either you go through an installer or you drag an app into your app folder.
02:37:10.568 - 02:37:53.196, Speaker C: And there are installers for postgres, for MAcD, but there is also the Postgres app. So if you go to postgresapp.com, what you see here is that Postgres app is a fully featured postgres SQL installation based on standard Mac app. Okay, what does this mean? Well, it means it's a zero install postgres. Basically you drag it into your applications folder, you click initialize and it basically does everything for you. Now this does bring with it two questions. Well, how does it differ from our initial installation? Because as you may remember, we had certain settings, certain defaults in place.
02:37:53.196 - 02:38:31.250, Speaker C: We had localhost port 5432, a username, a password, etc. Etcetera. Well, when we go with Mac and we use the Mac app, basically the only things that are changing are the username and the password because the app configures its environment based on your current user. So the user you're logged in with on a Mac. So the username you use on your MacBook is the username you will use when logging into postgres. And the password you use when logging into your Mac is the password you will use when logging into postgres. So if you have no password, that means there will be no password.
02:38:31.250 - 02:39:05.200, Speaker C: So if we go back to the website and we go over to the download section, what you can see here is that there are multiple releases. There is a postgres app with Postgres twelve, you have a postgres app that has 1011 and twelve. You have all supported versions of SQL. You can literally have a postgres app that can run the multiple, multiple versions of postgres. Now since we're focusing on twelve, I want to keep it light here. So once you press download, it will download the installer. And once the installer is done downloading, what you will see is the following.
02:39:05.200 - 02:39:44.970, Speaker C: You will see postgres over here that you can drag into the application folder. And once you drag it into the application folder, what you will see is that you have the postgres available. And so when we run that, what you'll see here is that you have servers and server settings. So when we go into server settings you can give your database a name. I called it ZTM from zero to mastery and I put the port on 4532 as we said in our slideshow. But you can change the port here to whatever you want. It'll tell you where your data directory is, where there's going to store the configs, the logs, all of that good stuff.
02:39:44.970 - 02:40:28.030, Speaker C: And then when we press start, it's just as easy as that. And as you can see here, I already have all of my databases in here, but I'm going to show you how to import these databases. So hold on. One more thing we should also note is that you can have multiple databases running side by side. So if I wanted to add one, and I wanted to say, well, this is my new one, I can say it runs on version twelve because that's the one we installed over here. And I can say well, put my data in there and maybe run it on a different port potentially. Oh, it's going to complain.
02:40:28.030 - 02:40:54.954, Speaker C: The data directory is already used, so let's call it 13. And so now it's created a new server. And so if I stop this one over here and I press initialize because that's what you're going to see. What you're going to see is it's going to initialize a database. Right now my user is called education. So whatever your username is, you'll see a database for that. You'll see a template and you'll see a postgres database.
02:40:54.954 - 02:41:16.704, Speaker C: That's what it's going to initialize for you. And so now what we can do is we can import our databases. So let's get into that. But before we do that, let me change my port back to 5432 so that we follow the settings that we discussed. And let's start it. Good to go. So easy, so straightforward.
02:41:16.704 - 02:42:01.106, Speaker C: Now before we get into actually installing and putting our databases in and installing our backups, we also need to install Valentina DB. So if we go to Valentina DB what you'll see is that under downloads there is a download for Valentina Studio. And if you go down here what you'll see is when you press view files you'll see that there is the availability for Mac. And so let's press download on that one. And so once this is done downloading we can install Valentina studio which is our graphical user interface. It's our way of talking to our database in an easy way. So let's open that up.
02:42:01.106 - 02:42:36.450, Speaker C: And again a drag and drop motion. Now I've already installed Valentina studio so let's open that up. And what you can see here is that I have my postgres instances installed. So let me go and delete those real quick so I can show you how to set them up. So if we go back into the postgres app you can see here I'm running new one and I'm running it on port 5432. So if I added a bookmark which will bookmark one of my databases so that I always have easy access to it. Here you can see it's going to default to localhost so I don't have to fill anything in.
02:42:36.450 - 02:43:19.734, Speaker C: We're going to just connect it to the default database and we're going to say my user is my username on the Mac and my password is my password on the Mac and the port is 5432. Now let's press. Ok. And as you can see I have my database available so that's the same database that is available over here. Now the reason you can't see these two is because they are internal, they're supposed to be hidden. You're not supposed to be able to delete these two databases, so don't because you'll mess up your database. Alright? So now that we've downloaded Valentina studio and now that we've downloaded the postgres app and I've shown you how simple it is to get both up and running, we're ready to import our databases that we will be using for the course.
02:43:19.734 - 02:44:04.310, Speaker C: So let's get into that. All right, so installing on Linux depending on your distribution of Linux you may have different installation steps you need to follow and the postgres docs really run you through for each and every major distribution what you should do. As you can see here we're running Ubuntu. So let's go to the Ubuntu page. And down here you can see that the postgres apt repository supports the LTS versions 18.04 and 1604. So depending on the version you're running, you may have different things you need to do.
02:44:04.310 - 02:44:55.650, Speaker C: So it says create the file etc app sources list pgp and add the line for this repository. So let's go and do that. So let's copy this and let's go into terminal, let's clear out here and let's do nano and let's paste the path that we just copied. And then let's copy in this line over here and let's paste it in there and then let's save it. So the permission is denied. So one thing we need to do here is we need to run this with elevated permissions, meaning we have to run it as a pseudo user or a super user. And so then we go ahead and we copy and we're saved.
02:44:55.650 - 02:45:36.300, Speaker C: Then the next thing we do is we import the repository for signing and updating packages. So let's copy that and let's paste it in here. And then on your system it may run a little more elaborately, it may be that I already have it, then let's sudo apt get update just to make sure we update everything and we have the most recent packages. So once we've done all that we're ready to install postgres SQL eleven. And so let's do that. And so then let's continue. And this is basically configuring everything for postgres eleven.
02:45:36.300 - 02:46:05.890, Speaker C: All right, so our postgres install is complete. Now we've installed postgres eleven. So to log into our user account, what we want to do is pseudo minus you postgres. And then we run the PSql command and we give it postgres. And that's how we get in. And so if we did slash l plus you can see here we have a template db, we have our postgres db, we have our template one database. So we're ready to rock and roll.
02:46:05.890 - 02:46:49.150, Speaker C: We have everything we need in order to get started and import our databases. So just remember that all you need to know for this course is that you need to run anything above postgres ten. So whatever is supported by your major Linux distributor, just install that version. As long as it's above ten you should be just fine. 1112 doesn't matter. And so now that we've got that all set up and we know the command to log into our postgres, we're good to go and we can start importing our data now the other thing we needed to download was Valentina DB. So if we go and we look up Valentina Db you can see the first link linking to Valentina DB.
02:46:49.150 - 02:47:35.450, Speaker C: And if we go into download you can find the download for Valentina studio. Now feel free to use whatever other database management software you're comfortable with if you do know one. But we are using Valentina Db throughout the course. So if you go into view files here you can see that there is a distribution for Linux Debian installation and an RPM installation. And since we are on Debian we'll install the Debian. So let's do that open with software install. And so once this is done downloading we'll go into a software installation for Ubuntu and we'll press install and I have to give in my password.
02:47:35.450 - 02:47:59.620, Speaker C: So now that Valentina studio is installed what we can do here is Valentina. Let's go back here. It was there. V studio, they call it V Studio. They've abbreviated it so this is an unregistered copy. You can get a free serial code by filling in the information over here. For right now we're going to run without it.
02:47:59.620 - 02:48:52.000, Speaker C: And so as you can see because I'm running in a virtual machine it's already connecting to my postgres instance outside of my virtual machine. So let's delete that real quick and let's try to connect to our local postgres. And so that's connected at 5432 on the postgres and we just fill in the password that we usually fill in which is root. And so let's try to connect from there. And so as you can see right here the authentication failed because there is no password and you're supposed to supply a password. So what we actually need to do here is slash password for the user postgres and we'll enter the new password root, root and we're good to go. Now let's exit this and then let's go in here and let's fill in root.
02:48:52.000 - 02:49:30.580, Speaker C: And there we go. We're good to go. So as you can see when we installed postgres by default there was no password associated with my postgres user. So as we can see here we don't have any databases yet and so we still have to import those. So let's get to it. I know setup is hard and hopefully your postgres installation went smoothly. But sometimes problems may arise and I hope you're reaching out to our amazing community on discord or leaving a comment in the QA section.
02:49:30.580 - 02:50:02.244, Speaker C: Now with that said, now that you have postgres fully set up, what we can do is we can go inside Valentina studio. Whether you be on Mac, Windows or Linux Valentina should look the same. And what we want to do is we want to connect to a database. And over here on the left hand side you'll see all of the different databases we can connect to. Now we want to select postgres. And when we select postgres all we need to do is fill in the password for the user that you're connecting with. Now if you're on Windows that would be postgres.
02:50:02.244 - 02:50:33.742, Speaker C: Postgres. If you're on Linux it would also be postgres postgres. And if you're on Mac it would be the name of the user that you're logging in with and the password of that user. Okay, so let's connect. And now that we've connected we're greeted by this completely new screen schema editor. And this is where the bulk of how we work with Valentina is going to work. Okay, so over here you can see in this panel it says databases.
02:50:33.742 - 02:51:06.864, Speaker C: And so what we want to do here is we want to create all types of different databases. Now on the resources file of this video you will find a zip file. And that file is the one that we need to download. And once you download and extract what's in the zip file you'll be greeted by 1234 files. These are the four databases that we are going to make. Okay, so let's start with the employees database. First of all, what we want to do here is we want to right click and say create new database.
02:51:06.864 - 02:51:58.830, Speaker C: So let's create our databases, employees. And then let's create a database called store. And then let's create a database called France. And then let's create a database called world. And so now that we have all four of these databases ready to go, what we can do in Valentina studio is we can go to file and we can say load dump. Now I know, what does this have to do with loading a database? Why doesn't it say load database? Well, traditionally when you extract all of the data from a database it's called a database dump. So we're going to be loading the data into these empty shells that we have here, right? These empty shells are empty because if we click on them and we look at the public, there's no tables, right? There's no tables inside of this database.
02:51:58.830 - 02:52:17.360, Speaker C: So what we want to do now we're going to click on employees. Make sure you click on employees. And we want to say load, dump. And when we load, dump, what we want to do is we want to set the following property. So we're going to load SQL. So make sure this one is selected. We press continue.
02:52:17.360 - 02:52:40.908, Speaker C: Then we're going to go select the file from in our documents. So for me, that's inside of SQL. Course, inside of data. Wherever the file lives that you've extracted, that's where you want to go. So we're going to go to the data folder here. And what we want to do is we want to select the file that we want to load. In this case, we're loading the employees database.
02:52:40.908 - 02:52:58.950, Speaker C: So we want to load employees dot SQL. We click it and then we press open here. And so now the path is pointing to employees SQL. So let's press continue. And we're just going to leave it like that. Don't select that option. We're going to press continue.
02:52:58.950 - 02:53:35.394, Speaker C: And now what it's going to do is it's going to load all of the data that is in that file directly into the database. So all of the data, these files basically contain the whole database and all of its data. And what this is doing is it's just going to take all of that from that file and put it into that database. It contains the tables and the data. And once this is done loading, we'll be able to see all that is in employees. And that's absolutely amazing. And then we have three more databases to load.
02:53:35.394 - 02:53:54.610, Speaker C: Right. We have to do world France store. So as you can see, it progresses fairly quickly. It depends on your system setup. So be patient. Now, once this is done, we can hit done. And now if we go into employees and we hit public again, well, look at that.
02:53:54.610 - 02:54:09.186, Speaker C: We have departments. We have department employees. We have department manager. We have employees. We have salary and we have titles. Awesome. So now that employees is loaded up, now we have to do the same thing to France because France is empty as well.
02:54:09.186 - 02:54:31.792, Speaker C: So how do we go about that? Well, we'll do the exact same steps. Load, dump SQL. We'll go pick the file France from our data dump. We'll press open, press continue again. Don't select this, press continue again. And boom, we're done. And now France has departments, regions, towns.
02:54:31.792 - 02:54:55.994, Speaker C: It has all of this data, right? All of this data. And that's amazing. So now we'll do the same for store again. Load, dump. We'll go to SQL, we'll go over here, we'll do store, select, continue, continue, and boom, it's processing the queries. It's that easy. It's not hard at all.
02:54:55.994 - 02:55:19.350, Speaker C: And so again, we'll go over here, load, dump and SQL store SQL. Well, we need world because we're loading world. Continue, continue. And we're done. That's all we needed to do. Now we have all of this data in our database. All of these databases have been loaded and we're ready to rock and roll.
02:55:19.350 - 02:56:10.156, Speaker C: All right, so let's get querying. It's finally that time. We're about to embark on a journey of a lifetime. And by the end of this, you'll be able to operate SQL and write queries like a pro. Now, without further ado, here are all of the commands that you will be learning throughout the course. Now, we will focus more specifically on ones than others, but this is just to give you a lay of the land. When we talk about SQL commands, we bucket them.
02:56:10.156 - 02:56:57.048, Speaker C: As with everything, you need categories to understand what the possibilities are. And so when we bucket them, we use these abbreviations called DDL, DQL, DML, DCL. And what do these mean? Well, it's simpler than you would think. DCL stands for data control language. So granting and revoking access, the ability to give someone access to a certain data set or revoke access, then we talk about DDLH data definition language. Now, these are a broad set of statements that are often used when you're setting up your database and you're setting up your world and you want to change things. All of those commands have to do with the definition of data.
02:56:57.048 - 02:58:21.370, Speaker C: And so if we drill down into them, you can see here, create, to create a database, to create a table, to create a whole bunch of things in your world, alter to change the state of something, change the state of the database, change the state of a table, the name of a table, drop, delete something, remove something, rename the ability to rename a table, rename a database, truncate fully, remove all of the data inside, comment, and so forth and so forth. All of these commands have specific reasons and specific implementations that you can use them for. Then we go into DQL data query language, and this is the one we're going to focus on heavily. Why? Because it contains the select statement, and the select statement is the one that drives your world. Because once you've set up a database or once a database is already there, the majority of the time what you're going to be doing, figuring out how to view that data and how to draw things from your data, and so the select is vital to find out things. It's the way to maneuver through your data. And then we have DML data modification language.
02:58:21.370 - 02:59:26.094, Speaker C: And these have to do with the data that we actually have inside of the tables, inside of the database. So once we use DDL to define our database and to define our tables and to define the relationships when we're actually talking about the data, we use DML instructions to insert certain rows, to update certain rows, delete certain rows, merge rows, etc. Etcetera. There are a whole bunch of commands that you can use to talk to the specific rows of data you have. And so throughout the course you may see us use varying amounts of these commands, mainly focusing on the DQL, the select statement. So now that we know all of this, let's flash back to our simple select statement. You guys remember this, when we did our very first exercise on the select statement with a filter and we did select name from users where role equals manager.
02:59:26.094 - 03:00:11.420, Speaker C: Well, this SQL statement we can call a simple select statement because it's doing something very simple. It's selecting the name from the users table and filtering by role. All right, so knowing that, knowing that this SQL statement is very, very simple, very basic, what we can say here is a select statement is utilized to get us back information. A select is to retrieve data. That is what we use it for. And intuitively we already knew this, right? We've been writing select statements throughout and we've been getting data back. But I want to solidify this principle.
03:00:11.420 - 03:00:43.410, Speaker C: The select statement is DQL. It's data querying language and it's used to retrieve data. And we can do a whole bunch of types of retrievals and we're going to get into all of those. But let's solidify that principle. A select is used to retrieve data. Think of it like the stork, but instead of it getting us a baby, it's getting us the data we want to select. All right, so knowing that, let's get into some simple SQL exercises with the select statement.
03:00:43.410 - 03:01:35.690, Speaker C: We're finally getting into our first exercise. We're hitting the ground running and we're going to do a bunch of these throughout the course because we want to set the stage for you to be able to build up your knowledge around SQL. And we want you to have a concrete foundation because that's what's most important here, not the fact that we had to do all of that setup around postgres or import all of those databases. At the end of this course, we want you to be an SQL master. We want you to feel comfortable writing selects and joins and all of these crazy SQL things. So let's start off simple. Our first exercise is give me a list of employees in the company.
03:01:35.690 - 03:02:11.450, Speaker C: And so as you know, we installed a software called Valentina studio. So let's head over there and let's remind ourselves of the question we're asking, a list of all employees in the company. All right, so here we are in Valentina studio, and you may be more acquainted with over here, the start page. So let's go into our database. And when you're in the database overview, the schema overview basically, or the schema browser, you'll see all of our databases here. And so we talked about wanting a list of all employees in the company. So we're going to use the employees database.
03:02:11.450 - 03:02:51.222, Speaker C: And then we have a scheme of public in here. And so if we look here, we have departments, department employees and department managers, and then we have employees salaries and titles. And so our question was, we want all of the employees in the company. So it stands to reason that we may want to do a select statement against the employees table because we want to get all of them back. We want to know who they are, we want to know what they do. Someone in the company came over to you and pushed you on the shoulder and said, hey, I kind of need to know this right now. And you're like, no problem, I got you.
03:02:51.222 - 03:03:32.980, Speaker C: I'm going to get all of that data right now. Well, if we were to go about that, what we would need to do is we would need to write a query. So let's go over here to our connections, and let's right click and let's say open SQL editor. And so this is an editor that's pointing to this instance, my postgres database. And it has all of the databases that we were talking about. So how would we go about finding what we need? Well, first of all, in this dropdown, let's select employees, and that'll give us an overview of everything that is in employees inside of public. And then if we go inside of tables, we can see all of the tables we were talking about.
03:03:32.980 - 03:04:22.008, Speaker C: Okay, so we wanted a list of all of the employees. Now, we've already looked at the basic breakdown of a select statement, so pause the video right now and try to write a query that will get you all of the data from the employees. So I hope that went well. But let's reiterate what we're trying to do here. So we're trying to select star from and then if we want to make it simple on ourselves, let's just double click here, and it will auto fill both the schema and the table. And so a schema is just us saying, hey, let's subdivide our tables under different logical names. It's a nice way of being able to separate tables and concerns in databases.
03:04:22.008 - 03:04:48.886, Speaker C: But for all intents and purposes, don't worry about schemas. We're always going to work with a public schema. We're not trying to create complicated databases that are going to scale like crazy. So when you see public, just know that this is okay. We only have one schema. You could just as well remove this part and just say, hey, select it from employees. But when you do work in a larger system, there may be schemas available.
03:04:48.886 - 03:05:08.712, Speaker C: And so then you may want to kind of do that. Don't worry about it at all. We'll be looking at that further down the line. For now, just focus on the fact that you can auto fill by double clicking. So this is the query we're trying to run. Select star from employees. And when we execute this, there we go.
03:05:08.712 - 03:05:33.380, Speaker C: Here is all of our data. Here is all of the data that we wanted. Great. We have the list of all of the employees, and there's quite a few, but that's amazing. We just wrote our first query, and it was so simple. So let's build on that a bit. Now, I'd like to know how many departments there are in the company.
03:05:33.380 - 03:06:03.030, Speaker C: All right, so departments. So the guy comes over and he's like, okay, I know all the employees are here, but hey, I'm new to this company. How many departments do you have? We're SQL masters. We know how to do this. Let's go into Valentina studio. So, as we know, here was our very first query. Let's look at all of our tables and figure out from which one we should select in order to figure out how many departments there are.
03:06:03.030 - 03:06:33.132, Speaker C: All right, pause the video here. Try and figure it out, and when you come back, we'll solve it together. Cool. So, as you may or may not have seen, we have this table over here called departments. And if you do select star from departments and you execute that, what we can see here is that we have nine records. So there are nine departments. 123-45-6789 great.
03:06:33.132 - 03:06:59.274, Speaker C: We have our answer. It's as simple as that. Look at how fast we're building up our knowledge, both of this database, but as well, kind of trying to connect the dots together. Think logically. We're going to get so far, just you wait. So let's build on top of that. So our next question is how many times has employee 10,001 had arrays? So this becomes a little more complicated.
03:06:59.274 - 03:07:23.492, Speaker C: But then again, we haven't learned a lot of different types of queries, but we're trying to build up our knowledge. We're trying to get familiar with the data. We're trying to see how it works. So don't fret. If the way that we're doing it isn't the easiest way possible, we're going to keep building on this knowledge. We're going to learn new methods, we're going to learn more complicated ways of being able to get simple answers. But for now, we're exploring.
03:07:23.492 - 03:07:54.108, Speaker C: We're getting to know our database and we're getting to know SQL. And the more simple queries you write, the better a foundation you're going to have when we start throwing in all of these functions that you're going to be able to use. So let's head over back to Valentina studio. So if we look over here at our tables, we have a bunch of them. We have departments, we have employees. We've already used both. So let's pause the video here and you guys think for a while and try to figure out the answer.
03:07:54.108 - 03:08:17.778, Speaker C: And then when we come back, we'll work through it together. All right, so I hope that was fairly straightforward, but if not, don't worry, I, we're going to work on it together. So select star from. And over here, you can see the salaries table. So let's go in there and let's see what's in there. So we were looking for user 10,001. All right, here he is right here.
03:08:17.778 - 03:08:32.546, Speaker C: Okay. So he started at a base salary of 60,117. And then he went up to 62,102. Then he went up to $66,074. Oh, my God. Numbers. And then up to 66, 596, and so forth and so forth.
03:08:32.546 - 03:08:52.026, Speaker C: And so. Oh, this guy has a lot, a lot of raises. He must be a better employee than I am. But that being said, he goes all the way from one to 17. So he has had 16 raises because he started at a base salary. He didn't get a raise at this point, I guess. Well, stands to logic.
03:08:52.026 - 03:09:12.970, Speaker C: You come in at a certain salary and then you start getting raises. So he has had a total of 16 raises. Cool. Now, there are easier ways to derive this answer, and there are more complicated ways of getting an exact number. But for now, we're exploring the data, we're getting to know it. Just some simple queries. Just flexing those muscles, you know, just getting a good pump before we get into the hard stuff.
03:09:12.970 - 03:09:52.722, Speaker C: The next exercise, what title does employee 10,006 have? What is his title? The boss comes over and he says, hey, today was the day that everyone got new titles. They got their raises, they got their new titles. What did 10,006 get? What title does he have? I don't care about his paper. What title does he have? So let's go figure that out. So back in Valentina studio, let's pause the video here and let's try to figure out what title the employee has. And when you come back we'll figure it out together. All right? So I hope you explore the data a bit and figured it out.
03:09:52.722 - 03:10:38.760, Speaker C: If not, we'll go through it together. So first of all, we have this titles table over here. So let's go and let's select the data from there. All right, so here we can see 10,006 is a senior engineer. Seems like he wasn't promoted anytime soon because he is currently still a senior engineer. And so if we look at this data like what is this, 999-0101 well that's the way the database is depicting today to date. Because if you look at 10,005, well, he was a senior staff from 1996 to today, but before that he was just staff from 1989 to 1996.
03:10:38.760 - 03:11:16.966, Speaker C: You see that over here? So he got promoted and he's senior staff until this day. So the senior engineer did not get promoted. Well, your boss will be happy about that. Alright, so now that we flexed our muscles, now that we've went through some basic queries, explored the data, let's continue building on what we just learned. Amazing job, guys. Renaming columns. So I think we've had enough of those simple select statements.
03:11:16.966 - 03:11:57.216, Speaker C: I think you're all professionals by now in selecting all of the data and figuring out like the most simple select statements and just filtering out certain columns and rows and all that goodness. And I think you're all very competent in that area. But now we're going to get into something a little more fun. We're going to teach you something new. Renaming columns. So what does that mean? Well, over here you can see customer id, first name. Well, what if we wanted to rename that to first name uppercase f? Uppercase n? Well then we would want to rename some columns, right? We want to present the data in a nicer way.
03:11:57.216 - 03:12:35.682, Speaker C: Let's say your manager comes up to you and he's like, hey, can I get a subset of data from this table and can you make sure that it looks pretty, pretty? Well, then you may want to go in and rename some columns, make them look a little nicer. You don't want to give your manager like just a raw spreadsheet. You want to make it look a little nicer. You want to give it a little pizzazz. So how would we go about that? Well, when renaming columns, it's a very simple statement. It's select column has, and then between string quotes you give it a new name. And so you can fill in anything there and the column will be named.
03:12:35.682 - 03:12:50.682, Speaker C: That. Isn't that cool? So let's get into that. Let's do an exercise around that. So here we are in Valentina studio. Let's get to renaming some columns. Let's make this data look cool. All right, so here we go.
03:12:50.682 - 03:13:19.278, Speaker C: Select star from. Let's go with employees. That's where we want to like revamp some of the data. So over here we can see employee number, birth date, first name, last name, gender, and hire date. So let's take the first three and let's make them look a little nicer. So let's take employee number and let's rename that. Well, okay, looks like I selected everything here by auto selecting, but all I wanted was employee number.
03:13:19.278 - 03:13:40.150, Speaker C: And we want to do that as employee number. All right, let's see, let's see how that works. There we go. Employee number looking nicer already. Then we had birthdate. So let's do that as birthday. That's a nicer way of saying it, less formal.
03:13:40.150 - 03:13:58.736, Speaker C: And also let's take first name. Whoop. First name. And let's do that as first name. All right, what's this going to look like? Boom, there we go. Easy peasy. And just like that, you know, we have an easier way of naming columns.
03:13:58.736 - 03:14:29.506, Speaker C: We can format columns. It makes it so much nicer to visualize data when you can give the columns the proper names. If you need to generate kind of like an overview or whatnot. If you needed to export this or if you just wanted to look at it in a nicer way and you needed to select a subset, it's nicer to give columns an easier name to read. So there we go. That's renaming columns. And feel free to go through any of the other tables and do a global select look at the data, figure out if you want to rename some.
03:14:29.506 - 03:15:18.404, Speaker C: Play around with it, a little column concatenation. Alright, so we just looked at how to rename columns. What is this concatenation business? Well, we want to make our data look prettier, simpler. You know, we just want to learn how to fiddle around with the columns. It's the most basic thing after learning the select that you figure out, okay, I have all of this data and it's formatted in this way. But what can I do with it? Can I play around with it? Can I concat things? We're slowly building up our relationship with the data. So let's say we wanted to concat columns.
03:15:18.404 - 03:15:54.450, Speaker C: What do I mean by that? Well, over here you can see customer id, you can see first name and you can see last name. And so what if I tell you you could do this customer id name and suddenly Mark Johnson, Katie Bell. Wait, wait, wait. Wasn't that first name and last name? Yes. You can concatenate columns together. You can squish them together to form one column and you can even put spaces in between to make it easier. So how would we go about this? Well, I'm going to show you.
03:15:54.450 - 03:16:45.160, Speaker C: So let's go into the employees database and let's try a column concatenation. So we're going to concatenate the first name and the last name of the employee into one column. That's the exercise we're going with. All right, so here we are in Valentina DB and we were in the employee database. So let's go over to titles real quick and let's do a select star from titles and let's see what that gives us. Okay, so we have senior engineer and then we have the from and the to date. All right, so there's not much we can concat here, but let's just concatenate the employee number to the title and let's just call it employee title.
03:16:45.160 - 03:17:33.580, Speaker C: So what we would do here is we would use the concat function and we would do employee number and then we would do a space and then we would do title. Alright, let's run this. So this is how we did a string previously, but that's not working for us. Single quotes are for characters. Now let's run that. So when you concat, what you're basically doing here is you remember when we renamed columns and we would use the double quotes to rename it? Well, when you use concat you can insert text and for text we're going to use single quotes. So let's do that because double quotes are referring to a column name.
03:17:33.580 - 03:18:03.334, Speaker C: So if we do this, we can see, we can see that. Okay. Okay. Okay, I got it is a. All right, so let's do that, huh? 10,001 is a senior engineer, 10,002 is a staff. But hey, what happened to our column name? When you run a function like Concat, you basically need to rename. So let's do it as employee title and let's execute that.
03:18:03.334 - 03:18:25.304, Speaker C: There we go, employee title. Boom. That's how you concatenate. So let's look at that a bit closer. You see, when you do concatenation, you can concatenate text to text, or you can concatenate columns together. And like I just showed you, text is done in single quotes, whereas renaming columns is done with double quotes. It's because you're renaming the column.
03:18:25.304 - 03:19:03.580, Speaker C: So just remember, when you use a concat function, use single quotes. All right, so let's get into some exercises. So if we go over to the employees database, what I want you to do is column concatenation. And what I want you to do is concatenate the first and last name of the employee into one column. Name it what you like, but make sure you concatenate the first and last name and put a space in between there and then rename the concatenated column. So first off, just try to concatenate two columns together, maybe put a space in there and then rename the column. You can pause the video now and go try it out.
03:19:03.580 - 03:19:48.834, Speaker C: All right, I hope that worked well for everyone. So here is an example of that query. So select employee number and then concat first name, space, last name as full name from employees. It's as simple as that. We've now concatenated two columns together with a space in between the data, and we rename the column. Who knew? So easy. We just looked at column concatenation and you may think to yourself, okay, I understand what it does.
03:19:48.834 - 03:20:40.130, Speaker C: So we select employee number, we select concat of the first and last name, and we rename it. But what is it exactly that we just did here? Well, let's answer that question. When we call concat, what we are calling is a function. And so you may ask yourself, what is a function? Well, a function is nothing more than something that takes an input and generates an output. Now let me take that a step back. When we gave it first and last name, what we were doing was we were giving it the parameters that it was supposed to take in, right? First name, last name, and then the function is named Concat. So the name tells you what it's going to do.
03:20:40.130 - 03:21:13.958, Speaker C: So by giving it the input parameters, first name and last name and telling it to put a space in between there. So we're telling it, okay, concatenate the first name, concatenate this space and then concatenate the last name. We're telling it to run that function called concat. So it takes very specific input parameters and it will concatenate them together. It will put them in a sequence beside each. So we run that function, we run that function, we run that function and we run it against each individual row. So each individual row is being concatenated.
03:21:13.958 - 03:22:07.596, Speaker C: It's not like we're taking all of the data and concatenating it in one long string. No, no, we're running it against each and every row. And so the output of that is what we saw and that is basically what a function does. So when we think about functions, right, we always have to look at the name of the function because that's going to tell you what it's going to do. And then the next part is, well, what kind of inputs does it take? And so once we figure that out, we can know what to give it. And once we know what to give it, when you run your query, well, that function is going to run and then you're going to have an output. Alright? So now that we understand that, you may ask yourself, well, okay, we saw concat, but what other type of functions are there? Okay, let's give a function a definition.
03:22:07.596 - 03:22:55.550, Speaker C: Let's define what a function is. A function is a set of steps that creates a single value. All right? So we just talked about the fact that when you give a function input parameters, it's going to generate an output. So we gave it first name space, last name, all right, we gave it the input parameters and we called concat and it's going to produce a single value called full name. It's as simple as that. So now that we know what a function is and we've defined what it is, you may ask yourself, well, what type of functions are there? And so you have two types of functions. You have aggregate functions and you have scalar functions.
03:22:55.550 - 03:23:27.986, Speaker C: All right, I can see your head spinning, being like aggregate scalar. What do these words mean? They're simpler than they sound. Aggregate functions, aggregate data. So they take all of the data, they take everything and they produce one single value. Think of it like having a column of salaries and then wanting to calculate the total amount of salaries that you're paying out. Well, then we would run a sum, right? We would do all of the salaries plus each other and we would get there. That's aggregating all of the salaries together to generate an output.
03:23:27.986 - 03:24:13.380, Speaker C: That's one example of an aggregate function. And then on the other end you have scalar functions. And what scalar functions do is what concat did they run against each individual row. So what they do is you give them the inputs and they're going to run that function against each individual row of data. So you get multiple outputs, right? When we concatenate the names, we see each and every individual's name concatenated. We don't have one long list of one concatenated name of everyone, right? So that's what scalar functions do, they run against each individual row. So to summarize, aggregate functions run against all of the data and produce one output, scalar functions run against each individual row.
03:24:13.380 - 03:24:54.470, Speaker C: So if we were to summarize that in a definition, aggregate functions operate on many records to produce one value. So again, we're taking all of the values in the table and we're producing one value just like that salary example. What we can say that is that it produces a summary, it produces an output. So an example of this would be, well, you have all of these salaries and you want to select the total amount of salaries that you pay. So we have 100, 250 and 50. So 50 plus 50 is 100 plus 200 is 300 plus 100 is 400. So we would know that our salary total is 400.
03:24:54.470 - 03:25:30.364, Speaker C: And so that's what an aggregate function is going to do. It's going to produce that one output. If we looked at scalar, the non aggregate functions, well, they operate on each record independently. So what does that mean again? Well, that's kind of like our concat. If we look at it more closely, we have a table that has Mo Bini and Andre Ngoy, first name, last name. So if we were to for instance, concatenate the name like we did, we see that the function runs on each individual record. We're not producing one output, we're producing multiple outputs.
03:25:30.364 - 03:26:47.918, Speaker C: And that's what scalar or non aggregate functions do. So now that we've taken a closer look at functions, and now that you know the difference between the different types of functions, we can now categorize more easily what type of functions we're working with. Because with that foundation, what we basically gain here is the knowledge to look at a function and know what it's going to produce. See, there are so many functions in SQL and we could spend months and months trying to hit every single one of them. But what we want to give you here is the foundation to be able to look at a function and see if it will fit into what you're trying to do. And to understand that you have aggregate functions versus non aggregate functions gives you that basis to look at something and be like, well, I need this to run on each individual record, or I need to produce one output, and then you can go and you can figure out the best way to do that. In the previous video, we took a closer look at the types of functions there are, and we differentiated between aggregate and non aggregate or scalar functions.
03:26:47.918 - 03:27:23.150, Speaker C: And we even saw an example of it with concat. Now, I didn't want to leave you hanging with this whole aggregate function business and not show you some of the aggregate functions that are available. So over here, you see, I've listed some out for you, and they're very reminiscent of math class. Basically, you have functions that can do calculations on a set of data. And so we have average, which can calculate the average. We have count, which will literally count the amount of rows that are available. We have min and max that will select the highest or lowest value in a data set.
03:27:23.150 - 03:28:01.094, Speaker C: And we have sum that will calculate the sum of the values. And so I wanted to show you how some of these work before we get into some exercises. So the first thing I want to do is I want to go over to Valentina studio, and I want to figure out how many people are actually working in our company. So let's go over to the employees database. All right, so here we are back in Valentina studio, and we have the employees database open. And so inside of the employees database, we have a bunch of tables, and we have the employees table. And so, like I said, we want to know how many people are actually working at this company.
03:28:01.094 - 03:28:38.020, Speaker C: So let's go ahead and write a query to do that. And as you saw, between our aggregate functions, we have the method count. So let's do that, select count, and let's count the employee number. It doesn't really matter what you're going to count because all of the records are going to be counted in the table. And so we're just going to take all of the employee numbers and just generate a count of how many employees there are. So let's select that from employees and let's see what happens. So if we execute that, we can see we have 300,024 people working for our company.
03:28:38.020 - 03:29:03.744, Speaker C: That's a whole lot of people that we are supplying money to. Wow. So that's a big, big company right there. All right, so over here you can see, very simple. We did select count which is an aggregate function. We counted the employee number from employees. And so you can do the same with sum min, max average, depending on the data set that you're using.
03:29:03.744 - 03:29:40.646, Speaker C: You don't want to use these quote unquote math functions that are min and max against something that will not generate a meaningful value. We can, for instance, select the minimum employee number, and we'll get the lowest employee number, which is 10,001, and then we'll know what is the max employee number, and that's 499,999. Okay, great. Doesn't tell me very much. Just gives me the min or Max employee number. So it really depends on the set of data you're operating against. What I wanna do now is I wanna dive into some exercises around aggregate functions.
03:29:40.646 - 03:30:29.210, Speaker C: And so I want you to get me the highest salary available, and I also want you to get me the total amount of salaries paid. So feel free to pause the video right here, and when you come back, we'll solve it together. All right, so I hope that went smoothly for you. So let's hop back into Valentina studio and get the highest salary available. If you look at our database, we have this salaries table, and that salaries table has a field called salary. So if we wanted to get the max salary, we would select the maximum salary from salaries. And what that will do is it will look through the entire data set of the column salary and get us the highest value available.
03:30:29.210 - 03:31:12.902, Speaker C: And so the person that's being paid the most makes $158,220. That's a lot of money right there. All right, our next question was to get the total amount of salaries paid. So how much are we spending every year on these 300,000 people's salaries? Well, for that, let's do the sum of salary. Let's execute it. Well, we would need to format this number, because I'm going to have a hard time reading it, but it is a lot of money. Let's try that.
03:31:12.902 - 03:31:35.550, Speaker C: Let's try to do this. So, three, three. That's a million. And then another three. So 480 million. So $181,480,757,419, if that's correct. That's quite a bit of money that we're paying to these people.
03:31:35.550 - 03:32:29.384, Speaker C: So you can see how powerful these aggregate functions can be, and you can use them in a multitude of scenarios. But the most important thing to note here is that while it's useful, it also has to be used in good scenarios to give you meaningful answers. One thing we all love to do is add comments. We love to add comments to our code. Now, this is a best practice. You should always be doing this. Comments are kind of a way to describe what is happening.
03:32:29.384 - 03:33:44.050, Speaker C: For now, we're writing really, really simple queries. But as you gain more and more complexity, these comments are going to help you and they're going to help you document the complex scenarios that you're going through, the thought processes that go through the code. Because when you write complex queries, what ends up happening is you have three, maybe 400 lines of some kind of stored procedure or something complex that's happening on an existing code base because someone wrote it. And when you go in there and that person put comments there, you're going to thank him so much because everyone says code is self explanatory. Well, we can just read this and we can figure out what's going on. But when you get into the nitty gritty and we just saw what functions are, when you start combining functions with queries and all of these different things and potentially updating something and reading from somewhere else and joining and aggregating all of this data, kind of like selecting from multiple tables. When you do these complex scenarios and you don't have any kind of commentary on what's happening, it may become very difficult for you to deduce what's going on.
03:33:44.050 - 03:34:19.674, Speaker C: So these are an absolute must. These are a best practice, and you'll find them kind of redundant for the exercises that we'll be doing in the beginning as we are building a foundation. But they become absolutely vital when we get to the more complex queries. And from there, you know, who knows? Maybe you'll start a job as a database engineer, and then you'll start writing complex queries and you'll start documenting code. And maybe they won't have practices on how to document things and you'll be the one doing it and starting a practice. But this is a must. So how do we add comments? Well, I'm glad you asked.
03:34:19.674 - 03:34:56.110, Speaker C: We're going to do an exercise to show you how I would normally document something. And you have two types of comments. You have single line and you have multi line. And what they allow you to do is quickly put something in between a line or next to a line, or the multi line can be used to document a multitude of things. Now, the database we'll be using is the employees database, since we're most familiar with that right now. And the type of exercise we'll be doing is comment your select statement. Now this may seem very basic and very outlandish to do when you're doing a very simple query, but the principle is key.
03:34:56.110 - 03:35:43.432, Speaker C: So I want to take a blast of the past and go all the way back to the simple select statement. And back when we did the simple select statement, you may have noticed that we did something a bit more complex, which was a filter. So we had all of these clauses. Select column name from table users where the column row equals manager. So when we were evaluating each and every row, if your role was not equal to manager, then you'd be kicked out of the results and we wouldn't see you, you'd be gone. So that simple select statement was a bit more involved and had that filtering option. Now I want to bring that back to set that basis because we're going to be doing an exercise with a filter.
03:35:43.432 - 03:36:11.030, Speaker C: Just wanted to cut that quick refresher out of the way. So two questions we have. Select the employee with the name may shuler and then comment on your query. What exactly is happening. Now, feel free to pause the video here and go ahead and try it out if you feel brave enough. And when you get back, we'll be solving it together. Otherwise, stick around because we're going to jump right into it.
03:36:11.030 - 03:36:52.480, Speaker C: So first off, let's make sure that our server is running. All right, now that we're up and running, let's get in here. So let's connect to the education database, and let's go to our employees, open that up, and then let's open the SQL editor. So let's go over to our schema public, and let's go over to our tables. So we're looking for my Yuma Shuler. So we have our employees table right here. And in the employees table, we have the field called first name and last name.
03:36:52.480 - 03:37:29.170, Speaker C: Huh. All right, so if we looked at our query, we were doing a select where role equals manager. So based off of that, we kind of know how to find her. All right, let's get to it. So let's write that query, select first name, comma, last name from, and then let's double click the table here just to make it easier on ourselves. And then we want to say where firstname equals Mayumi. Let's see what that gives us.
03:37:29.170 - 03:38:14.790, Speaker C: Oh, well, we can see there are many, many Myumi's in this codebase, one of which is Schuller, the first one, luckily. So we know she's there. But. So how would we filter on both her first name and her last name? Well, SQL has this cool term called and that you can use an aware clause and it's basically saying okay, let's filter on this and this. Logical, right? Very easy. So let's put last name equals Schuller. And what we'll see happen here is that we'll only get back one result.
03:38:14.790 - 03:38:44.158, Speaker C: All right, let's take this a step back. We just learned a lot, right? So select first name and last name. And then we saw in our simple select query that we can do a filter on a single column. But now we introduce this and keyword. And what that gives us is the power of checking multiple columns. That is amazing. Okay, we complicated our filtering.
03:38:44.158 - 03:39:03.704, Speaker C: We made it more complex. We made it check two values now. Great. Now we have a dumbed down search result, right? We only have one record shown. That's great. Now you could have done this query just as well with the first filter. You would have had to filter through a lot of data.
03:39:03.704 - 03:40:01.110, Speaker C: So let's document what's going on here. So two dashes means inline comment filter on first name and last name to limit the amount of data returned and focus the filtering on a single person. Now I see you thinking, well, mo, why didn't you use a multi line comment here? Well, I should have. So let's do that. Let's port it over to a multiline comment. And so like that, we can just take this, put it over here, do that, and now we have a multi line comment right here. And it doesn't matter how many spaces you leave between the select and where, because the semicolon is telling it where it's going to end.
03:40:01.110 - 03:41:00.372, Speaker C: Now, at the top here, we can say select statement to filter Myumi Schuler. And this basically tells us what the select query is going to do. Now, it is always best practice, like I said, to comment your code, it is up to you to decide how you're going to comment your code. But what's absolutely vital, and what I would suggest you always do, is when you write a query right above the query, put a comment of what the query is trying to accomplish, what is the intended outcome of the query, and then if you have some complicated things going on, well, you can always comment where it's happening, or you can comment beside the line. Even you can say filter here on my own Schuler. So you have a lot of versatile options here in terms of how you're going to filter. So I hear you saying now, well, I know what the and keyword does.
03:41:00.372 - 03:42:12.152, Speaker C: And okay, okay, I get all of the commenting and I understand that it's important. Cool. But mo, now that I have unlocked the superpower with where and what else can I do? And trust me, we'll be getting into that. We have a whole bunch of videos for you to master filtering. But before we get into all of that, I quickly want to dive into the most commonly made mistakes when writing queries, because I think it's important for you to see what the most common mistakes are so that you can avoid them, avoid them completely. We're going to be masters here, so let's get into that before we dive into mastering filtering, the most common mistakes that people make when writing queries. Now, I hear you thinking like, I'm not going to make any mistakes, but trust me, even the most seasoned database engineer will make some of these commonly made mistakes because they're common.
03:42:12.152 - 03:42:46.620, Speaker C: And even when you write more complicated queries, you may fall into one of these pitfalls somewhere along the way. Because most people that write SQL don't only write SQL. They may write some other programming language, and they may mix up some things here or there. It's not very often that a developer or a database engineer will solely use SQL. You may be using another programming language to supplement what you are doing. So let's get into some of the common mistakes. Well, the number one thing is misspelling commands.
03:42:46.620 - 03:43:35.650, Speaker C: Now I hear you saying misspelling commands. What do you mean? Well, you can run into this where instead of select, you write sleeked. Now, we know it's supposed to be here, but the computer doesn't, and it's gonna throw a big fat error in your face if something like this happens. And then you may not have noticed this, but I even mistyped from so form and then I mistyped the users table. So all of these things can throw some kind of error in your face. Can't find the table, don't know what sleeked is, what is form, and that may lead you to confusing scenarios. Now, the error will guide you in the right direction, but try to avoid these as much as possible.
03:43:35.650 - 03:44:05.596, Speaker C: Now, a second common mistake is using the semicolon instead of the comma or vice versa. I hear you saying, why would I misuse those? It's pretty self explanatory. Well, it is. Depending on what you're used to, it may not be so common and you may make those mistakes. So select first name, huh? Oh, yeah. Yeah. This is supposed to be a comma, right, guys? Because it's first name, comma, last name.
03:44:05.596 - 03:44:40.210, Speaker C: We're trying to say first name and the last name, not Semicolon. That seems wrong. And then, oh, we're ending the line with a comma. Well, that's not great because the semicolon tells us when the line ends. So try to avoid this pitfall as well. And then you may run into this scenario where you accidentally double comma'd and then SQL is going to be like, well, what did you want over here? I don't know what you want over here. And in that scenario, it's best that you either put an extra column between here or just remove the comma.
03:44:40.210 - 03:45:21.100, Speaker C: Ah, this looks much better. Select first name comma, last name from users. This is how it's supposed to look. Guys, doesn't it look pretty? Oof, we just hit a doozy here using double quotes instead of a single quote. Now what do I mean by this? This issue, this common mistake, it has multiple layers to it. It's not as straightforward as it sounds, but like I've said in the previous videos, single quotes are the way that you write text in SQL. Do not use the double quotes.
03:45:21.100 - 03:46:25.030, Speaker C: And for all of you out there who are already used to programming this, 1 may be a bit confusing to you because depending on the programming language you're using, you may be used to the double quotes, you may be used to using them to write text, and it may not come as easily for you to switch over to the single quotes. But don't worry, as you write more and more queries, it'll become more and more common. And for those of you who have no basis at all, well, don't worry too much about this one because you're starting off on the right foot. You're always going to use single quotes. But what are these double quotes for? Well, what if I told you that double quotes are for tables, single quotes are for text. Now you may be looking at me, what is he talking about? We didn't talk about that. Well, what if I told you that SQL is case insensitive? Basically, when you create tables in SQL, you decide how you want to name them.
03:46:25.030 - 03:47:21.500, Speaker C: So you may name them users with an uppercase u, you may name them users all uppercase. Heck, you may even call it users with an uppercase r if you want to be out there. But depending on how you type it, SQL might not be able to interpret it. Let's go back to the previous query over here. You can see that we have users as lowercase no quotes at all. But it seems to be working, right? Well, what if you were in a database where someone decided to call their table users with an uppercase u? Well, then it becomes tricky because if you typed users in all lowercase you may not get your results back and that may become extremely tricky. So when you use double quotes, it is to tell SQL, hey, what I'm trying to select from here, the table I'm trying to select from is called users with uppercase u or some other kind of spelling notation.
03:47:21.500 - 03:48:18.664, Speaker C: And you can even use this for column names. Column names? Are you serious? Mo well, yeah, you can even wrap the column names between double quotes. So what do we see here? We see a clear differentiation between what we consider text, which is using single quotes, and what SQL is interpreting from the data, which can use double quotes. So if we had a different type of spelling here in our table name, or we just wanted to wrap the naming convention of our column, we can use double quotes. For all intents and purposes, it is a best practice. Depending on the type of database you're in, to use double quotes, it could be up to the team even to say like hey, wrap all your columns and all your table names with the double quotes and make sure you reference them properly. Some teams may not enforce that.
03:48:18.664 - 03:49:01.980, Speaker C: It really is a team norm at that point. Me personally, depending on the type of database you're in, if you're managing it personally, you can decide for it or against it. It won't really hurt you in the long run as long as you are consistent in your naming conventions of your columns and your tables. So case sensitive tables, what did I mean by that? Well, like I said, the double quotes can tell you what type of table you are selecting from. If your table is all lowercase, you can just do this. If your tables uppercase u, you need the double quotes. And if you decided, well, I'm going to do it all uppercase or I want to put a space in between, you definitely need the double quotes.
03:49:01.980 - 03:49:40.248, Speaker C: So just always make sure that you keep your naming conventions consistent so that you can decide if you need double quotes or if you don't need double quotes. The last common select mistake that you will see made most often invalid column names. It's just that easy to do. It's just that easy to mistype a column name. And that's where software often helps you. If you use Valentina studio, it helps you auto fill column names depending on if it knows where you're trying to select from. But if you're a keyboard junkie and you're just trying to write in your notepad your select statements.
03:49:40.248 - 03:50:33.120, Speaker C: You may hit a scenario like this where you select first name, not first name, first name from users. And what you'll hit is a big fat SQL error. So always try to cover your basics. As long as you cover your basics, you are going to write amazing queries and you're just going to have a great time because when that result hits your screen and you're not constantly hitting error cases because of these small issues, productivity is just going to skyrocket. And so now that we have all of that out of the way, let's dive into some filtering. Let's supercharge our skills here. How to filter data.
03:50:33.120 - 03:51:42.074, Speaker C: Now, I might sound like a broken record at this point, and I totally get it, but we really, really want to solidify those fundamentals and those fundamentals with querying gear around, answering complex questions with queries. And the only way we'll solidify our base of knowledge here is to practice, practice, practice, and reiterate some of the basics that you may have gotten up until now, but elaborate on them as we go along. And so at this point, you may be like mo, you've explained to us how filtering works twice. And yes, yes, I have. If we flash back to our very first filter, which is the very first query I showed you and we saw previously, we can see here that we've already seen how the where clause works. But what if I told you that filtering data can become infinitely more complex as you go along? Because just because you know how to write this clause doesn't mean you've mastered this clause. And that's what we're here to do, right? We're here to master everything to do with SQL.
03:51:42.074 - 03:52:40.272, Speaker C: And so when we look at where, we know that a simple filter will be where role equals manager. So we're trying to filter out the roles of a manager. And when we look at this SQL statement, we see the three clauses, the select the from the where, and we know what all of these do. We're selecting columns from a table and then we're filtering where something is happening. All of that solid base that we've built up until now is great. But remember in the previous video where I showed you the ability to filter on multiple criteria? Well, that's where it becomes very, very interesting, right? Because as our questions become more complex, so do our queries, as our need to create deeper subsets of data grows. Subsets, meaning, well, we only want to see a fragment of the data that correlates or is related to the question we're asking.
03:52:40.272 - 03:53:47.326, Speaker C: When people ask us questions as SQL ninjas and they're like, I want to see this and I want the constraints, I want the filters to look like this. I want to know the salary of these people between these ages and from this gender, or I want to know the salaries of these role descriptions for these age groups, or I want to know the salaries for the people that were hired between this and this date. Because we're doing a salary review, things like that become vital. Answering those questions in a way that we can write queries to get the information needed is what we're trying to accomplish here. And I find that when we think of queries like questions, it becomes easier to answer them because at the end of the day, what we're trying to enable through looking at data is a way to read the data. We don't want to just be able to write queries without an outcome. We want to know what outcome is driving the query.
03:53:47.326 - 03:54:42.440, Speaker C: And so when we look at filtering, it is an essential skill. When you look at writing queries, because it is the base of almost any query, as usually when you're asking a question, you only want to look at a subset, a fraction of that data that relates to the question you're asking, you may be thinking, okay, where is what? Where is the keyword that we use to filter data, right? So when we fire our query and we go to the database, well, this is our original table, but we may only want to filter out the mosaic. And so we're really solidifying that understanding here. But now we want to build on it. I think we all understand now what the where clause is, and we understand that it is a very powerful tool. Now, if I were to ask you the question, get me a list of all the female employees. You would know how to answer this.
03:54:42.440 - 03:55:31.870, Speaker C: And let's go into Valentina studio and just quickly write out that query. So over here we're in Valentina studio and we're in the employees database. And if we go look at the employees, we can see here that we see all of the employees in the table. But if we wanted to write a filter against this, we would go into our query view, and here we would say, select first name from employees, and then we would say where gender is equal to f. So let's run that back. It looks like the gender is capitalized. So we would need this.
03:55:31.870 - 03:56:14.260, Speaker C: And let's execute that now. And now we can see that we have filtered out the first name of every female employee, the company. So with that, we know how to write these simple queries and we also know how to get that subset of information when our filters are simple. But what if I told you that with the multiple search criteria which we've tried out, it becomes more and more complex. You can layer your filter. And so over here, what if we wanted to filter by age and gender? That's where we get into more interesting use cases. So let's talk about the and keyword.
03:56:14.260 - 03:57:10.368, Speaker C: The and keyword. We already kind of looked at this in a previous query we wrote, but what does it actually do? So let's refresh our memory here. When we do select first and last name from users, we know we're getting the full list of users back with their first and last name as the data. We'll see. But when we do the filter with the where, well, here's where it becomes interesting. When we do first name equals Mo and last name equals Beanie, we are now telling our filter to only filter on that first name and that specific last name. So both those criteria need to be met in order for a subset of data to come back to you.
03:57:10.368 - 03:58:02.138, Speaker C: And that's what makes the and keyword so powerful. You're now saying this and this need to be true in order for me to get any data at all back. And that is what is interesting. We are now selectively filtering our listen based on two criteria. And you can do three criteria, four criteria, five criteria. You can link all of the ad keywords you want together, but be wary because the more filters you put in, the less chance you have of getting anything back because there may not be anyone that meets all of those search criteria. So when we look at the and keyword, if we were to do the where Mo and Beanie as first and last name, well, then we know we are only going to get back one result from this table here.
03:58:02.138 - 03:58:33.196, Speaker C: Only one result matches both those criteria. And that's what makes the and keyword so powerful. We can now chain multiple criteria to be met on a single row of data. So when we look at a row of data, well, we have Mobini, first and last name. But Mobini has a gender, right? That's male. He has a date of birth. He has all of these criteria that are linked to that single row of data in that table, that specific table that we're looking at.
03:58:33.196 - 03:59:14.762, Speaker C: And as long as we write a filter where all of the data that we're putting in that where clause match a single line of data in that table, we can get an outcome, which in this case is Mobini. Now that said, I can hear you say, mo, I got this. I know what the and keyword does. Great. That means we can move on and we can look at something more complicated. What if you want to filter on two first names? Well, you want to say first name is equal to Mo or first name is equal to someone else's first name. You want to filter on both Mo and Andre.
03:59:14.762 - 03:59:49.444, Speaker C: Let's go try something out here. So here we are in Valentino studio. And if we go to our schema and we go to the employees, we can see here first name Georgie and first name Bezalel. So what if we wanted to filter out both Georgie and Bezalel? Well, let's try it with the and keyword. So let's copy their first name. And let's go in here and let's say where first name equals Georgie. So what is that going to give us? Well, that's going to give us all of the georgies.
03:59:49.444 - 04:00:06.722, Speaker C: There seem to be multiple. Okay, so let's say. And last name equals. And let's go get their last name real quick. Fisello. So let's grab that out of there and let's put it in here. So now we have two Georgie.
04:00:06.722 - 04:00:32.332, Speaker C: Fascinating. Okay, we have two in our database. So that means we need a third criteria to filter them by. So let's see what their gender is real quick. Do they have the same gender? Okay, so they're both male. So the only other criteria we can filter by is their hire date. So let's see, at their higher date, does it differ? Yes, it does.
04:00:32.332 - 04:00:55.110, Speaker C: So we want to get this specific Georgie. So let's copy that. And let's say that we pulled their last name and their hired date. And let's say. And hiredate equals. Let's filter that out. And here we got it.
04:00:55.110 - 04:01:33.290, Speaker C: One single result. But now we also want to see Bezalel's data. So what would happen if we do. And the first name equals Bezalel. Well, now we're getting into complicated territory. Nothing's going to come back because there is an order of operations. What do I mean by that, an order of operations? Well, here we can see we're doing where first name equals Georgie and last name equals Vasil.
04:01:33.290 - 04:01:57.570, Speaker C: And then we're checking the hire date. So now it becomes complicated. Right. And then we want to say, okay, but we also want Bezalel's information. So how are we going to get that? Well, our filter here is extremely specific. Right. Well, we're filtering on three core principles or three core pieces of data that link to Georgie.
04:01:57.570 - 04:02:47.072, Speaker C: The first name, the last name, and the hire date. And so how are we going to get Bezalel's information? Well, that's where we get the or keyword. So what would happen if we put in the or keyword? Because, well, stands to reason that if we say or the first name equals Bezalel, that it's now going to change what we're filtering on. Because when we say first name is Georgie and first name is Bizzlell, that doesn't really make sense, right? You can't have two types of first names in a single field. So we're trying to filter out different people here. So just think of it this way. When you do and you're checking that, that piece of information, that specific piece of information that we're looking at, like first name matches both those criteria at this point.
04:02:47.072 - 04:03:18.810, Speaker C: But when you do or you're saying or the first name equals Bezalel. So let's see what that does. Okay, so now we've gotten back multitudes of information, but we only want this Bezalel. So let's filter on her last name as well. And I last name equals simul. So let's execute that. Now we only have two people back.
04:03:18.810 - 04:04:25.720, Speaker C: Okay, and so remember when I talked about the order of operations? Well, because we're doing where first name Georgie, last name Fisello, and hire date equals, we're saying if all of this matches or all of this matches, but what if I threw a chink in the chain and I put this over here? What would happen then? We're saying where first name is Georgie or first name is Bezalel and last name is simul and last name is Ficello and the hire date is equal to. Okay, now it's getting complicated. So let's frame this in a way that makes sense. Where first name equals Georgie or first name equals Bezalel and last name Simmel and last name sello. Now, we just said that when we filter on two last names with ants, weird stuff happens. So let's execute this. Oh, now we're getting a lot of georgies back.
04:04:25.720 - 04:05:17.434, Speaker C: Why is that? Okay, so let's take it back a step. When you do where and you do a filter, there is something called the order of the operations, which means that the way in which you structure your filter is the way in which SQL will check certain things. So when SQL season, and it's going to chain that and to the previous statement it was checking. And when it sees an or, it's going to start checking a completely different thing. So when it does first name equals Georgie, it's only going to look for the Georgies. And then when or comes along, it's going to say, okay, well, now I need to start looking for other things. So I'm going to do first name and, and, and it's going to chain all of those ants together.
04:05:17.434 - 04:05:53.390, Speaker C: So if we took over here. So if we look in our data over here, we're not going to see any bezalel's. We're only going to see Georgie's. And why is that? Well, that's because there is no Bezalel with last name simul and last name ficello. And the hired a equal to. So if we took this information and we put it back up here, what we'll see is that the order of operations is based on the or clause. So where SQL sees the orlando is where it's going to start doing a new filter, so to speak.
04:05:53.390 - 04:06:40.280, Speaker C: It's going to check either this or this other thing and then the and keyword, they link back to the previous. So where first name equals Bezalel and last name equals symbol. So it's going to check the first name and the last name where this or clause started. So if we were to put braces around it, it would look something like this. These are the statements related to this filter, and these are the statements related to this filter. And the way that we look at it is where the or comes in. So let's execute this again, and you'll see that parentheses, they help you structure your filter in a way where you can understand what is happening in what order.
04:06:40.280 - 04:07:51.910, Speaker C: So didn't I say filtering can become complex? And it really can really quickly? Because when you go down the rabbit hole of wanting to filter out multiple things, it can become very tricky for you to say, well, I want to filter out this person and this person based on this information and based on this salary group or based on these criteria. And here we're just filtering out two separate people, very specific separate people that we saw here, 10,100, 10,002. And we could have just as easily done it with the employee number. And done like where employee number is 10,001 or employee number is 10,002. But what if we didn't know that information? What if we only knew their first and last name and when they were hired? Well, that's when this comes into play, because as you can see, we had multiple georgies and we had multiple bezalels and we even had two georgies with the same last name. So we had to add in the higher date to very specifically target them. I hope that this is not overwhelming you just yet, because we're just getting started with filtering and it's going to become so amazing, all the things you're going to be able to do once you master this principle.
04:07:51.910 - 04:08:45.972, Speaker C: Now, I just quickly want to summarize everything that we learned here. When we do a filter, when we do a where clause, there is an order of operations. There is an order in which the where is going to look at criteria. The and keyword helps you chain together multiple criteria to filter. So when you want to filter out a specific group, all the ands will be chained together. The moment the where clause finds an or, it's going to start a new filter, it's going to look for other things, potentially a different set of information that could also be matched. See, we could just as easily have done where last name is equal to symbol or the last name is equal to facello.
04:08:45.972 - 04:09:32.876, Speaker C: So if we just did this, what would we get? Where lastname is equal to facello or last name is equal to Syml? Well, let's execute that. And now we get a lot of information because we're saying, well, if your last name is a cello or your last name is simul, give me your information. There is no strict criteria, but you can see very strictly now how the and keyword filters out that facello line more specifically, or filters out that syml line more specifically. So we're adding to the specific filters of where that or clause is. So that or clause actually separates out what we can do, what road, what path we're going to take. It's this filter or that filter. And that filter could be more specific than the previous filter.
04:09:32.876 - 04:10:33.924, Speaker C: So we're saying this or this. Pretty straightforward, right? So we started off with the question, what if you want to filter on two first names? And we saw how the and keyword doesn't really work for that, but the or keyword really does help. So if we did select first and last name, where first name is equal to mo or first name is equal to Andre, we can clearly see how our filter is working in this case, because an and keyword over here would say, well, the first name has to be Mo and the first name has to be equal to Andre. There's no way that a filter could understand that the first name can only have one value. It cannot be Mo and Andre. That would be impossible. How could you have two sets of values in a single field in a table? A first name cannot be equal to both Mo and Andre, but a first name can be equal to mo, or a first name could be equal to Andre.
04:10:33.924 - 04:11:33.000, Speaker C: And that's how we get into that more specific filtering mechanism. Alright, so I've curated an exercise that combines all of the things that we just learned here and that uses the filtering with and and or. And we're going to use the store database to work on it. So the question I have for you and the question that we will be answering is how many female customers do we have from the state of Oregon, which has the abbreviation or, and New York, which has the abbreviation NY. So we're combining all of the things that we just learned. Feel free to pause the video here and try out this exercise on your own. And when we come back, we'll be answering this question together.
04:11:33.000 - 04:12:13.516, Speaker C: All right, so here we are in Valentina studio and we're going to start breaking down this exercise piece by piece. So we wanted to know who all is a female customer from the state of Oregon and the state of New York. Awesome. So over here we can see we have the state. So we already know that we have to abbreviate on NY and or. And then where is their gender? Okay, so over here we see their gender and we can see that it is simplified in a filter with m and F. As I said, this exercise combines all of the things that you've learned so far.
04:12:13.516 - 04:12:53.424, Speaker C: So what we want to do here is we want to combine all of the things that we've learned so far and get the amount of customers that are female from the state of Oregon and the state of New York. So let's start with a simple query here. So let's do a select here. And let's select the first name and the last name from customers. And we can always verify what we're doing here by looking at our table. And then we see customers over here and we can always know what fields we have to work with. So let's execute that.
04:12:53.424 - 04:13:36.312, Speaker C: And here we can see we have a bunch of weird first names and weird last names. So let's go over to customers and we can see here that indeed the first and last names don't really make any sense. This is because it's generated data. So don't worry too much about that. But what we wanted to do was we wanted to filter our results, right? Because right now we have thousands of results and our filters were pretty clear. So we wanted to do where. And let's go look here.
04:13:36.312 - 04:14:04.522, Speaker C: What is the field called? Our state. So where state is equal to Oregon. Okay, so let's filter out that subset of data. And we can see we have way less here, but we also wanted to filter out where the state was equal to New York. All right, so let's do that, huh? Oh, yeah. Yeah. We're not supposed to use the and keyword, right? Because that will conflict.
04:14:04.522 - 04:14:48.926, Speaker C: A state can't have two values, so it's or the state of New York. Awesome. So now you can see we have 400 records instead of 200. All right. But we also wanted to filter only the female customers. And this is where the exercise became tricky because I showed you a couple of principles, but were you able to implement them in the right way? Because, as I said, there is an order of operations, and that's what becomes tricky about this exercise. What is that order of operations? What we're saying here, where the state is equal to Oregon or the state is equal to New York, and then we only wanted the female customers.
04:14:48.926 - 04:15:21.220, Speaker C: And like I told you, after the or statement, you start a new filter tree. You're filtering on different things. So what some of you might have done is. And gender equals f. And then put and I gender equals f to be able to make sure that you got the gender for both states to set the female. So let's, let's quickly check and let's execute it. So all of the genders are female.
04:15:21.220 - 04:16:09.140, Speaker C: But what some of you might have also done, which might not have worked in your favor, is done this, where state equals Oregon or state equals New York and gender equals female. And when you execute that, what you'll see is, oh, I'm getting male results here. Why are they male? So let's add the state to the result set and see where they're coming from. And we can see that they're coming from Oregon. And that's because this and filter isn't filtering on female for the state of Oregon. And so if you saw that happen, you probably ended up doing this, which is great. You will now get only female results from both states.
04:16:09.140 - 04:16:48.702, Speaker C: Now, there is a way to write this more simply. And if we copied out this and we used the parentheses in a way that combined the. And for both filters, we would end up with something like this. Huh. This is new, right? So I showed you the simple way of doing this, which is after the or statement, the filter becomes for one or the other. And in this case, if you didn't use the parentheses in this way, you would have to use and gender equals f for both statements. But what would happen if we did this? Let's execute this.
04:16:48.702 - 04:17:30.980, Speaker C: And what you'll see is we're getting only female results for both. Interesting. So the parentheses are filtering the gender for both. Huh. Now, remember when I told you the order of operations. Well, this goes into something called boolean algebra, and we'll get deeper into that as we go along. But what we're seeing happen here is, remember when I told you that or statement starts a new tree where it's going to search for this or this, and we just saw that if we copy the and keyword both for the state of New York and the state of Oregon, we'll get the same results.
04:17:30.980 - 04:18:24.584, Speaker C: But if we use the parentheses in this way where we wrap state equals Oregon or state equals New York, and then we do, and afterwards, something interesting happens the and gets applied for both use cases. That's a powerful little tool right there. And we'll dig deeper into why that is in subsequent videos. But now we have our result sets for both. But the question was to get the total number of female customers. Now what we could do is we could go to the bottom here and we would know that there are 200 female customers for the state of Oregon and the state of New York. But what if we did a count and we counted the first name? Well, now we know for sure that there are 200 female customers for the state of Oregon in the state of New York.
04:18:24.584 - 04:19:45.210, Speaker C: But we learned something much more valuable here than that answer. And that is how powerful parentheses can be when we do filters. And so, remember when I said filters can become complicated? Well, we're just scratching the surface now before we dig deeper into how filtering works at a deeper level, what exactly is happening behind the scenes? And how can we combine and twist all these things together to make complicated operators? And how do these parentheses actually work? All of those questions will be answered in due time. I wanted to show you something else, and I wanted to pose it in a what if. What if you want to filter everything but something? What if you have so much data that you're saying, I want everything but this one thing? I want all of the credit cards except these ones. Not these ones. Or you say, I want everyone except the person that has this name.
04:19:45.210 - 04:20:51.584, Speaker C: How are we going to do that? Because right now what we've seen is, and allows you to chain, when you filter, it allows you to filter down into specifics or allows you to venture different paths. It allows you to say, well, filter this or filter that and show me the results of both. And combining them allows you to create these crazy strong filterings. But again, what if, what if you want to filter everything? But there must be a keyword for that, right? The not keyword you can say, select first name and gender from users where the gender is not equal to male. Now, gender is a very, very simple example because you only have a limited set of options. So in that pool it becomes easy for you to, for instance, use an and, but let's say that you were going to filter by age. Well, now suddenly you have a large age range.
04:20:51.584 - 04:21:28.304, Speaker C: You know, you could say, I want everyone but this age group. And this age group, I don't want to see them. I don't, I don't want them in the results. And so the larger the pool of potential options is, the stronger the not keyword becomes because it's an exclusion where and works as an inclusive filter. Not is saying, well, don't put these in, I don't want these. And so with that, we know now that you have and or and not. And the combination of these three together can create very, very powerful filtering queries.
04:21:28.304 - 04:22:08.770, Speaker C: And that's what we really want here. We want to master this where clause. Now, I've shown you very, very complicated things with the filter. And don't let it scare you off, because at the end of the day, what we're trying to accomplish here is we're trying to layer our knowledge like a cake. And by trying and learning these things and by implementing them in phases, you will be able to create complex filters over time. Now, you may ask yourself, well, but mo, you showed us like these parentheses and the way the ankiword works and oh, this is, it's a lot. It is but one step at a time.
04:22:08.770 - 04:22:55.976, Speaker C: We know now that we have the and keyword, we know now that we have the or key, and now we know that we have this keyword not that is going to remove things from the results that we don't want. And each of those pieces individually allow us to create filters that can answer questions, because that's what we're trying to do. We're trying to answer questions. We're trying to get results based on real world questions. We want an outcome out of these questions and the queries drive that outcome. We want to understand what's coming out of our data. And although all of our exercises are simple in nature, the core premise here is to really understand the nuance of these keywords.
04:22:55.976 - 04:23:25.176, Speaker C: And by understanding that nuance, eventually, when you're posed a difficult question, you'll be twisting and combining and using parentheses all over the place. Don't worry about that just yet. That'll come. But the core principle here is to understand what each and every one of these keywords does. So the not keyword removes results. That's what we're getting. So let's do a quick exercise on the store database and let's do it filtering with the not keyword.
04:23:25.176 - 04:24:05.930, Speaker C: Now, our exercises, how many customers aren't 55? So this again is combining multiple things we've learned so far. So let's go ahead, pause the video here. Go and try out that not keyword and see what result you get. All right, so let's jump right into it. If we go over here to our database, we can see that all of our ages in the customer database are numbers, which is great because that's what we want to filter on. And we can already see here someone's 55 and we don't want them in our search results. So let's go over to the scheme editor and let's start a query now.
04:24:05.930 - 04:24:23.794, Speaker C: Here you can see my previous query still. Let's remove that real quick. So let's just do a quick select age from and then let's do customers. Let's execute that. Okay, we got our ages. Here's the naughty, naughty 55 year old that we don't want in our search results. Cool.
04:24:23.794 - 04:24:42.874, Speaker C: So we know now where not and then age equals 55. Let's execute that. Boom. No more 55 year olds in our search results. It's that easy. We have 53 year olds. We have 54 year olds, but we don't have 55 year olds.
04:24:42.874 - 04:25:21.370, Speaker C: We've removed them from the results set. And how did we count again? Well, you could scroll down, but there are quite a few search results here. So let's do a quick count of age and let's see how many people are not 55 years old. 19,716 customers are not of the age 55. And we can even chain this and we can say, and not age equals 54. Let's remove all the 54 year olds. And if we execute that smaller result set, well, let's try 20.
04:25:21.370 - 04:25:51.700, Speaker C: How many would be up with then? 419. So this way we can keep removing pieces of the result set. And that's what the not keyword does. It's super powerful in that regard and the ability for us to use it to filter down our search results based on things we don't want. Because with the and and or we went the approach of we want these sub results. We want to know all of these specific things. But sometimes you want to go the opposite route where you just want to remove things that you don't need.
04:25:51.700 - 04:26:48.124, Speaker C: And that's where the not keyword becomes very powerful. So with that said, you may ask yourself, well, we saw how to do not 55, but what if we wanted a range? What if we wanted a range of ages? Well, that's where we can use the comparison operators and let's go look at those real quick. Comparison operators. So, so far we've seen a lot of different things. We've seen a lot of ways to filter data. We've gained a deeper understanding of and or, and we recently learned about the not keyword. And with that exercise, what we learned was that we could filter out results that we don't want.
04:26:48.124 - 04:27:36.494, Speaker C: We could filter out the age group 55. We could filter out the age group 54. If we wanted, we could do. And, and, and. But what if we wanted to do a range of ages? What if the question was, well, who over the age of 44 has an income of more than 100,000? Well, now we're in quite the pickle, aren't we? It becomes difficult to understand how to compare ranges with what we've learned so far. Now, for those of you who have done programming before, and you may have an inclination towards how exactly we're going to solve this, but for those of you who haven't, all we've seen so far is and or and not, and those allow us to specify and target what we want or what we don't want or alterations with or we want this. Or we want this.
04:27:36.494 - 04:28:17.248, Speaker C: So now we're getting into ranges, and that's where we use something called comparison operators. And so there are many different comparison operators. And for those of you who are accustomed to programming, you may already know these. You see comparison operators, they allow us to check is it greater than or less than, is it equal to or not equal to? And so here I've listed all of the different comparison operators you can use. So let's get into the deeper understanding of each of them. When we look at the equal to sign, we're saying check if given values are equal. If it's equal, the condition will be true.
04:28:17.248 - 04:28:39.484, Speaker C: Zero is equal to zero and mo is equal to mo. That one is very basic. This one we've used on many different fields. And in essence, what it allows us to do is just check equality. Then we go into not equal to. Well, that is check if given values are not equal. If it is not equal, the condition will be true.
04:28:39.484 - 04:29:02.766, Speaker C: So we have two ways of writing this. Zero is not equal to one or zero is less than greater than. This is a special syntax, syntax meaning a special way of writing it down. You could use this. I prefer this method because it reads more clearly to me personally. But this is another way of writing it zero is not equal to one. That is also true.
04:29:02.766 - 04:29:51.432, Speaker C: So not equal to allows us to check that things are not equal. Now, how does this differentiate from the not keyword? Well, in essence, they kind of operate the same way. But comparison operators are often most used for number comparisons. When you're comparing text, what you get into is weird things where it may not always give you the right result. And so not equal to as an operator can operate roughly the same way as the not keyword. Now, looking at greater than, check if a given value is larger than the other value. If it is greater, the condition will be true.
04:29:51.432 - 04:30:12.232, Speaker C: So ten is greater than zero. That is of course true. Zero is greater than ten. Well, we all know that zero is smaller than ten, so that's false. And here we can see a text comparison with greater than. So with not equal to. It operates the same as the not keyword.
04:30:12.232 - 04:30:35.470, Speaker C: But let's say you use greater than with text. Well, ABc is greater than ace because a and b are ahead in the Alphabet of a and C. And so it goes in alphabetical order. Well, is a greater than a? No, they're equal. Is b greater than c? Yes. You won. That's kind of how string comparisons work, with greater than or less than.
04:30:35.470 - 04:30:59.656, Speaker C: Not really ideal, unless you're trying to compare the Alphabet. I guess. So we get into less than. Check if a given value is smaller than the other value. If it is less, the condition will be true. Zero is less than one that is true, greater than or equal to. So we looked at this one.
04:30:59.656 - 04:31:28.618, Speaker C: Check if a given value is larger than or equal to the other value. If it is greater or equal, the condition will be true. Two is greater than or equal to one that is true. Two is greater than or equal to two that is true. If we put a three here, that would have been false. Less than or equal. To check if a given value is smaller or equal to the other value.
04:31:28.618 - 04:32:01.990, Speaker C: If it is less or equal, then the condition will be true. So zero is smaller than or equal to one that is true and one is smaller than or equal to one that is also true because it is equal. It is not smaller than, but it is equal. If we put two here, it would have still been true. If we had put zero on this side, it would have been false because one is not smaller than zero. So it really depends on what end what number is. If we had put zero here and one here like we did here, of course it's true.
04:32:01.990 - 04:32:30.210, Speaker C: If we had swapped them, one is not smaller than or equal to zero. One is larger than. So we're really getting into it. These comparison operators, although simple in their task, are powerful in their outcome. Well, always reach back to this overview I gave you. Screenshot it, snapshot it, keep it close to you because these operators are of vital importance when comparing numbers. Now let's get into some exercises.
04:32:30.210 - 04:33:45.075, Speaker C: Logical operators. So we've seen a lot of different logical operators so far, and or not the comparison operators. And you may be thinking, okay, I got them down to a science, I understand how they work, and I'm filtering data out of my database successfully. I've done the exercises, it's going well, but how do they actually operate like, what's happening behind the scenes? And how can I chain them to make more complex statements? Well, we're going to give you fundamentally a deeper understanding of all of that. But first, let's summarize what we've seen so far and define it. So far we've seen and or and not, and we've also seen some of the comparison operators. But the and or and not keywords are vital to what we want to do here, to filtering as a whole.
04:33:45.075 - 04:34:38.266, Speaker C: Like I said before, filtering is like layering like a cake. You need to know what you want to know, and then you can choose the right operators in conjunction with each other to chain a filter or make a more complex filter. And so if we were to go into definitions, when we look at and if both the Boolean expressions are true, Boolean being true or false, if both of those are true, then the test will return results. So what we're saying here is if the expression we put with an and on both sides are true, you will get results back. This and this need to be true in order for me to get results. You see it here in this simple select statement. Select first name and last name from users where first name is equal to mo and last name is equal to beanie.
04:34:38.266 - 04:35:31.123, Speaker C: So if either of these statements are untrue, you will not get a result. And then if we looked at that from a visual layer, well, what we're saying here is that both Mo and Beanie need to be true in order for us to get a single result set. And then we went into the oR, which said, if any of the Boolean expression is true, then we will return results. So this or this needs to be true, right? It's not exclusive. And again, when we looked at that in an example, when we select first name and last name from users where the first name is mo or the first name is Andre, means we're going to get two results back here. If your first name is Mo or your first name is Andre, we're going to see you in that results. And looking at that again from a high level means, well, it's either Mo or it's Andre.
04:35:31.123 - 04:36:32.720, Speaker C: And both of them will create unique result sets that will be merged at the end. Now I like to create these visualizations more for an illustration of the mental model. A database will do optimizations on how it will filter and how it will merge the responses of an or an and a not, and using these in combination together. But it's important to have that high level mental model of, well, it's this or it's this. And so creating that visualization just helps you kind of map out what you want to do and what you're trying to achieve to do. This is not exactly how a database would process the outcome, but thinking about it in this way helps you build that complex structure of a filter. And then we looked at the nothing, and what the not said was if any boolean expression is not true, we will return results.
04:36:32.720 - 04:37:06.348, Speaker C: So it was that way of saying, I only want things that are not related to this. An easy way to filter down in an opposite way. So if we said here, select first name, last name from users, where not first name is Mo. Weird way of phrasing it, of course, when you read it that way. But we're seeing here where your first name isn't Mo. So we're filtering Mo out of the results that completely, and that is powerful. And again, if we visualize that, well, we're saying not Mo.
04:37:06.348 - 04:37:52.839, Speaker C: Well then take him out of the filters and give me a result set where anyone with the first name Mo is not present. Okay, so we have our foundation of filtering here, and we know how this filter works, how this filtering mechanism works. And we now know three keywords we can use to create very, very powerful, complex queries. But I hear you asking yourself, Mo, how does this get executed and what exactly is happening? And I have the answer for you. In a database there is something called the order of operations. And what the order of operations are. In what order is everything happening? So we've seen simple select statements.
04:37:52.839 - 04:38:45.220, Speaker C: We've seen select from where. So we know how to filter now, but in what order is this being executed? Well, what I can tell you is that we first select from the table that we are going to do our filter on. Then we apply our filter. So we apply our where and we filter down everything that we selected from that table. And then we subsequently, after the fact, narrow down what exactly it is we want to pluck from there. What is, what are we selecting? Are we only selecting the first and last name? Are we selecting the income and the state? What exactly is the outcome? So again, high level visualizations help create that mental model. So we select all the data from the table and we filter it, filter it, filter it down with our where clause.
04:38:45.220 - 04:39:35.040, Speaker C: And then we get into our select statement where we say, okay, this is the eventual result set I want, this is what I want to visualize. And that's what we call the order of operations. So this is how it's happening behind the scenes for you. And of course the database is going to do optimization on optimization to make sure that this result set gets filtered as fast as possible. But for you to know in what order what is happening, that allows you to first of all know what is happening when and how. And when you start writing queries, you will already know, well, this isn't going to work because this gets fired after this, or this gets fired after this or before this. I hear you saying, well, mo, there's only three things happening here from where and select, you're right.
04:39:35.040 - 04:40:13.250, Speaker C: But as we go along our SQL journey, more and more steps will come into the order of operations. For now, we have three things because we're only doing filters. But as we go along, more things will come into play. And now I hear you saying, I get it, we select the data and then we filter it. Sure. And then we narrow it down. But what exactly is happening in this? Where like how do I determine if an and is going to happen before an or? If an or is going to happen before an and, and I alluded to this in a prior exercise where I showed you a short form syntax of something.
04:40:13.250 - 04:41:16.616, Speaker C: So let's look at that. Let's look at operator precedence. All right. We've seen a lot in the past couple of videos talking about order of operations, the logical operators that are and or, and not the comparison operators. We've seen a lot about filters, and it can be overwhelming because there's a lot of knowledge in there that drills down deep into what filters are and how you can write them. But trust me, as you go along this journey, you are going to be a master at filtering. And so when we talked about the order of operations, what we were talking about is how is the database deciding how to execute the query in what order? And then we talked about operator precedence.
04:41:16.616 - 04:42:25.350, Speaker C: Well, as I alluded to you in that one exercise where we use the parentheses to shorten the filter SQL has a way of deciding how it is going to process that where clause and certain operators have precedence over other operators, precedence meaning they are applied before or after depending on their priority. So defining operator precedence, a statement having multiple operators, multiple ands and ORS is evaluated based on the priority of operators. So what this means is that every operator we use and or not parentheses, all of them have a priority. What is that priority? Well, at a high level, from top to bottom, we're going from most important to least important. The most important is the parentheses. These will always take precedence over the rest. They are the most important.
04:42:25.350 - 04:42:48.890, Speaker C: And then we go into multiplication and division. If you do multiplication and division in the where clause, this will take precedence over anything below it. Same for subtraction and addition. That takes precedence over anything below it. But everything above it takes precedence over it. So this already looks like math class. Multiplication and division take precedence over subtraction and addition.
04:42:48.890 - 04:44:20.910, Speaker C: But then we get into our logical operators, our Boolean logic, and then we can see here that, well, not has precedence over and and has precedence over or meaning that or is the least important operator and that and and not take precedence over it, they will be executed first over the or statement. Right? And if we add parentheses, well, that takes precedence over everything because it is the most important. And so now you may be asking yourself, okay, mo, well, I get it, if you use parentheses, it's more important than multiplication and division and so on and so forth. But what if I'm just using multiple operators in a row? What happens there? And they have equal importance. Well, if the operators have equal precedence, for instance, you're using multiple ands or multiple ors or multiple nots, then the operators will be evaluated directionally from left to right or right to left. I can hear you saying, huh? What do you mean from left to right or right to left? Well, okay, we just discussed that each of these operators has a priority, so they will be executed in that priority. But now we're saying, okay, well what if I use multiple ands, multiple ors, multiple nots, what's going to happen then? Then they get evaluated directionally.
04:44:20.910 - 04:45:30.960, Speaker C: Huh? What determines the direction? What determines if it's from left to right or right to left? Good question. Here is a snippet from the postgres docs, and don't focus too much on all of it, but they have this associativity column. And what that says is, is it going to go from left to right or right to left? And which ones have which associativity so if we look here at the bottom, we can see not and and or. And we can see that and has left associativity and or has left associativity and not goes from right to left. Interesting. Interesting. Okay, so the operator precedence, when we're talking about using multiple of the same, goes from right to left for not and left to right for and and or, meaning that when you use a not statement, it's going to look to the right side of it and negate it.
04:45:30.960 - 04:46:16.050, Speaker C: And when you use an and statement, it's going to chain the previous one to the next one in order to say this and this and this and this and the or does the same thing. It goes and looks to the left. It's this or this or this. So when you chain them, they're looking to their left, except not, we'll be looking to its right. So an example of this would be, well, if we select state and gender from customers where the gender is female and the state is Oregon or the state is New York, Mo. What's happening here? Well, we looked at this, right? This was the original exercise. And if you look at the where clause, it doesn't work.
04:46:16.050 - 04:47:20.124, Speaker C: This is the broken where clause. Because what we're saying here is, get me state and gender where you are a female from Oregon or you are from New York. So interesting, interesting. When we read queries, we want to be very, very precise in what the outcome is going to be. And so I phrased it in this sentence so that you can clearly see why it is broken. We are saying here, get me state and gender where you are a female from Oregon or you are from New York, we can clearly see that the female filter did not apply to the people from New York because it goes and state Oregon or state New York. So here we're looking at a priority sequence or gets executed last and the and has been chained to the filter of state Oregon.
04:47:20.124 - 04:48:06.370, Speaker C: So these will execute together and this will execute separately. And so the gender female only applies to the people from Oregon. So you may be asking yourself, well, what was the correct answer again? Well, if we select state and gender from customers and we say where gender is female and the state is Oregon, or the gender is female and the state is New York, well, now what we're saying is get me state and gender where you are a female from Oregon or a female from New York. Okay, that makes sense. That makes sense. We're clearly distinguishing the difference in the filter. And now we can get into the parentheses case.
04:48:06.370 - 04:49:04.990, Speaker C: This is the shorthand that I showed you during the exercise that may have tripped you up because parentheses, what do these do? Right? Well, let's dig deeper into it. If we said select state and gender from customers where the gender is female and parentheses state is equal to Oregon or state is equal to New York, we can now say, okay, well, SQL is going to apply the parentheses first. So it's going to filter this. First it's going to check are you from Oregon or are you from New York? And then it's going to do the and, and it's going to check if you are female. So because of the parentheses, the chain ends up being different. Here we're saying, get me state and gender where you are a female and you are from Oregon or New York. And so now I can hear you thinking, well, those two queries, they did the exact same thing.
04:49:04.990 - 04:49:42.816, Speaker C: Yes, they did. But when we want to explain our query as a phrase, we want to explain it in a way that reflects the way it was written. Even though the results are the same, they are written differently. Here we can see that we are saying where the gender is female and, and then we use the parentheses to create importance. So that's why we write it differently. All right, so I can hear you thinking, okay, mo, I get it. I get why you did it during that exercise, and I get why it simplifies things.
04:49:42.816 - 04:50:29.800, Speaker C: But could you show me how the priority chaining works and how the right to left, left to right works? Yes, we're going to get into that. We're going to dive deeper into that. I have a bunch of examples that I can show you on how SQL is going to decide if it's going to do a priority or a right to left, left to right. So let's get into those. So let's look at some priority sequencing. As we said, a statement having multiple operators is evaluated based on the priority of operators. So just a quick refresher.
04:50:29.800 - 04:51:33.280, Speaker C: The operator precedence is parentheses, then multiplication and division, then subtraction and addition, then the not, then the and then the OR. This is most important to least important meaning or is the least important. So if we looked at priority chaining, what we would see here is that state and gender from customers, where gender is female and state is Oregon or gender is female and state is New York, means that, well, we have two filters going on here. One gender female from Oregon, two gender female from New York. So two separate filters are going on here. Conceptually that I will say in our mind, we should view it as two separate filters. So on the one hand, we're filtering out all the females from Oregon, and on the other hand, we're filtering out all the females from New York.
04:51:33.280 - 04:52:28.030, Speaker C: And why should we conceptually view that as two separate filters? Well, that's the way we wrote it. We split on the or and then we can read it based on, well, it's this or it's this. That doesn't mean that the database management software is going to execute the query like this. That may be unoptimal, that maybe not be fast enough. The database management software does optimizations behind the scenes on queries. But for all intents and purposes, what we are trying to get here is a mental model. We are trying to look at a query and say, okay, how do I read this? And how do I read this filter? And how should I look at it in my mind? Even though the database management software may optimize it in different ways, how do I break it down for me? So let's look at another example.
04:52:28.030 - 04:53:12.722, Speaker C: Let's say we selected state and gender from customers where the gender is female and the state is Oregon, or I, or the state is New York with parentheses. Okay, how would we break this down into a mental model? Well, we would look at it a little bit like this. We would say, one, select me, everyone from Oregon. Two, select me, everyone from New York. And then three, filter out all of the females. I know you're asking yourself, mo, why is this so much different than the previous one? Well, the way we would read a query like this is because of the parentheses. We can now consider it to be one action.
04:53:12.722 - 04:54:09.670, Speaker C: We don't have to look at it as two separate filters. Rather, we could look at it as one filter doing two things, because we know that we are filtering if you're from Oregon or you're from New York, and then we're tacking on the ability to filter on gender because we know that we can read this as well. It's either this or this and for both of them, this. So that's why we read it as one filter, everyone from Oregon, two from New York, and three filter out the females. So then we get into directionality. We said if the operators have equal precedence, then the operators are evaluated directionally, meaning from left to right or right to left. And we looked at the difference between and or and not and and or being left and not looking to the right of itself.
04:54:09.670 - 04:55:07.956, Speaker C: And so how would we read queries that are written like that? Well, if we said we had a where clause, where we said age has to be larger than 20 and the salary has to be larger than 1000 and the gender has to be female and you're not from the state of New York. Well, how would we read that query? Well, because of the directionality and because of the priority, we can say, well, not was more important than and. Right. Okay, okay, if not's more important than and then we know it's going to execute 1st first. And then we said, well, and reads to the left of itself so it's going to chain up and the not reads to the right of itself. So it's going to say not state equal to New York. So it's going to invert state equal to New York to be the opposite of what it would originally mean if we didn't put the not keyword there, meaning you have to be from New York.
04:55:07.956 - 04:55:39.428, Speaker C: Well, it's doing the opposite of that, saying you don't have to be from New York. So how would we read that? Well, we would say, okay, based on priority. First we're going to say, well, you weren't from New York so we're going to filter that out. Then we're going to say you were older than 20, your salary is larger than 1000 and your gender is female. So what if we did this and we added the parentheses here and we said age between 20 and 30. So 21 to 29. The ages between 21 and 29.
04:55:39.428 - 04:56:43.242, Speaker C: We want to know if you have a salary larger than 1000 and you're not from New York or you're not from Oregon. So how would this execute? Well, knowing that the parentheses are the most important and then that the not is the second most important, then the and being the third most important and the, or being the least important. Well, how would this execute? Well, because of the parentheses we would look at it this way for everyone between the age of 21 and 29, not from New York, not from Oregon, give me the ones that have a salary larger than 1000 and that's how we would read that where statement, that filter statement. Okay, one more. Let's say you had this age larger than 20 years old or age below 30 and the salary larger than 1000 and not from the state of New York and not from the state of Oregon. Well, what would happen here? Because we lost the parentheses, right? So how would we read this? What's going to happen? Well, I'll tell you. We're going to have two filters going on.
04:56:43.242 - 04:57:28.560, Speaker C: Filter one is going to say, well, if you're younger than 30 and you're not from New York and you're not from Oregon and you have a salary larger than 1000, then I'm going to give you back results. And then filter two is going to say, well, if you're older than 20 in general, I'm going to return you. And so those two streams are going to merge and you're going to get results back from both. So there's two distinct filters going on here. And you may be asking yourself, okay, why mo? Well, because we removed the parentheses, we can now view this or statement as a clear separator between what's going to happen here and what's going to happen here. And because it has of least importance, it's going to be fired last. That's why we view this as, quote unquote, a second filter.
04:57:28.560 - 04:58:25.986, Speaker C: If we were looking at it based on priority, but we have that clear separation between, well, this is going to fire all of this together with it and this is just going solo. So this would ruin a result set. Let's say you were trying to get everyone younger than 30, not from New York, not from Oregon, with a salary larger of 1000. Well, this filter is just going to suddenly populate a whole bunch of people that are just older than 20, not taking into account any of these filters. Right? And so what if we said, okay, age larger than 20 or age lower than 30 or salary larger than 1000? Well, there is no concrete outcome here. We're saying, well, you're either older than 20 or you're younger than 30 or your salary is over 1000. So we have three distinct filters going on here.
04:58:25.986 - 04:59:01.920, Speaker C: So the result set isn't going to tell you very much concrete information unless that's what you were looking for. You're just looking for anyone that's younger than 30 or older than 20 or has a salary of that amount. Right? So the mental model here is to look at them as separate. But when there's parentheses around ors, it changes the context. I can hear you saying, okay, mo, I get it. But like what if it becomes really complicated? Well, that's when we get into priority and direction here. I wrote down an example query where we can see.
04:59:01.920 - 04:59:40.330, Speaker C: I used multiple parentheses, nested parentheses even, and multiple logical operators. And so you may be looking at this being like what is happening here? We'll break it down line by line, don't worry. So first of all, we have an outer parentheses, okay? That means this is the most priority. This is of the highest priority. So everything in here is going to be executed first. Alright? So let's go look in here because this is the highest priority. And if you had two levels of top level parentheses depends on how they were chained.
04:59:40.330 - 05:00:34.730, Speaker C: So because this is the leftmost statement with the top level parentheses. Well, we're looking for people that have a salary larger than 10,000 and are from the state of New York, or they are between the age groups of 20 and 30. So 21 to 29 and they have a salary of less than or equal to 20,000. And then we tack on at the end and we say, well, they also have to be female. Anything from this result set also has to be female. So we're looking for all of the females that have a salary of over 10,000 from the state of New York, or are between the ages of 21 and 29 and have a salary of lower than or equal to 20,000. So how does this work in terms of filter? Well, there's two filters going on here.
05:00:34.730 - 05:01:46.000, Speaker C: First, we will filter the salary of larger than 1000 from New York, female, and then we can look at it as a second filter within where we're saying, okay, between the ages of 21 and 29, if you have a salary lower than or equal to 20,000 and you are female. So we can break down that query. You see, we did have the parentheses, we even had nested parentheses, but we can still break on that. Or, but we have to look and take into account the highest level, next logical operator, which is the, and that is filtering on both result sets of whatever comes out of here. So to summarize again, what we're saying here is we're filtering out everyone with a salary over 10,000 from New York that is female, or anyone between the ages of 21 and 29 with a salary lower than or equal to 20,000 that is also female. Now, feel free to pause the video here, take a look at the query, take a look at the filters, and let it really sink in. All right, so let's go look into some more ways of filtering.
05:01:46.000 - 05:03:03.660, Speaker C: Checking for empty values. So far we've seen how to handle multiple types of queries and how to filter. And with filtering, there comes a lot of nuance when it comes to what am I supposed to filter? How am I supposed to filter it? All the data we filtered so far has been pretty straightforward because all of the values were there. There wasn't a case of us having to deal with empty values. And now you may be thinking, what do you mean by empty values? Well, when we look at data, you can have records that do not have a value and that is considered empty. So when a record does not have a value, it is considered empty. Alright, but what does that mean because I haven't seen any empty records in my data? Well, here's the thing.
05:03:03.660 - 05:03:55.504, Speaker C: When we talk about empty values, there is one type that reigns supreme under empty. Now, if you've done coding before, you may have heard of it. It's called null and null values are values that are empty. Null is used to represent empty or missing values. So n u l l, that is the term we use to represent that missing value. And now null is a special type because null is different from being zero or a field that may contain text and have some spaces in there. Null is special in a way that it does not conform to what you would consider, right? If we have a number, we have a number.
05:03:55.504 - 05:04:46.134, Speaker C: And when we have a date, well, we know that the field will contain dates. And then when we have text, we know we can put empty spaces and this and that. And an empty space is a way to kind of mess up your thought process because the field will look empty, but it won't be so. Null is that special value that across the board is just used for things that you do not know exist yet or you may not have a value for. So if you looked at Valentina db and you wanted to check for empty values, well, you could do a simple select query, and what you would see here is you would have a customer id and a first name, and maybe you didn't put, and maybe you didn't have everyone's first name. And so here you can see one, Mark two. Oh, wait, we don't know user two's first name.
05:04:46.134 - 05:05:33.158, Speaker C: And so most database software will actually show you this type of syntax when a value is empty. This is too strictly visualized to you that this is a null value, that this does not have a value because let's say you had Mark. But Mark was a bit smart and he decided not to fill his name in, but put in a bunch of spacebars. And now this shows as a blank space because you saved it that way. Well, then the database software went ahead and denoted what is actually null versus what is kind of a hack. Now, data should never come into your database without being sanitized or checked for correct values. That being said, it could happen.
05:05:33.158 - 05:06:09.472, Speaker C: And so it's nice to know that you have this visualization over this. Now that's something that the database software can do for you, right? It doesn't have to. The database software, when you do a select query, can show you those null values. Let's go over here to DB fiddle. And what I've put together here is a small table with some null values. And just to show you that most tools will catch this null value and visualize it to you, if we press run here, what we will see is that DB fiddle is showing us those null values. Well, the age is not filled in.
05:06:09.472 - 05:06:39.510, Speaker C: The last name isn't filled in. Oh, here, the first name wasn't filled in. Here, first name and last name wasn't filled in. So we know that the null value is there. But just to show you the difference, if we did this and we put a couple of spaces in here, and then we did a select, well, let's run that back. Oh, name is empty. So an empty string can show up as empty, but null will show up as null.
05:06:39.510 - 05:07:34.010, Speaker C: Okay, good to know. So we can now determine what is null versus what is empty. And so the fact that most database software will do this for you out of the box, show you those null values versus an empty value, well, that is very important for you to understand what's going on with your data. But I hear you asking yourself, should I use null? Is it okay for me to have empty data? Is it okay for me to kind of be leaving stuff blank? This is a question every database administrator struggles with. Now, I have three things that you need to keep in mind. Be careful, be mindful, and be deliberate. What do I mean here? Well, when I say be careful, what I mean is be very careful with what you make nullable.
05:07:34.010 - 05:08:08.480, Speaker C: Don't just make everything nullable, because when you create a table, which we'll get into later in the course, by default, every field is nullable. You can insert null values. So when I say be careful, it goes back to that old saying, always be defensive. You learn this in driving. You learn this in technology. The first thing I learned when I did it, security, was turn everything off and turn on only what you need. Well, the same can be said for null.
05:08:08.480 - 05:08:52.736, Speaker C: When you create a table, hey, maybe turn everything off, make everything not nullable, and then be very deliberate about what you want to be nullable. The second one is, be mindful. Whatever you turn into null may have effects on queries that other people will write. So maybe don't make fields nullable that you have to do calculations on, or don't make fields nullable that are vital information to the business, like first and last name. You need to know who you're shipping an order to. So be mindful of what you're making nullable, because you might not be able to catch these things later on, and they might unravel for your colleagues. Having to look into it.
05:08:52.736 - 05:09:31.030, Speaker C: So work as a team and be mindful of what you're making the level, and then be deliberate. What do I mean by be deliberate? Make a choice and stick to it. Document it. Make it clear that that field, that particular record of data is going to be nullable. And make a design doc, make a document outlining why it's nullable and why you made that choice. Always be careful, mindful and deliberate when using null because it is hard for other people to understand what you are doing when you make things nullable. So just keep those things in mind.
05:09:31.030 - 05:10:03.970, Speaker C: Now, null is a contentious issue. No matter what opinion you have, people may disagree with you. I've met database administrators that like to keep things nullable, and I've met some that like to make things as strict as possible. No nulls ever. And there are people in the middle that are more pragmatic, that are like, well, we got to make the right decisions here. I fall into the middle group. When you make a decision, make sure you document why you're doing it.
05:10:03.970 - 05:10:24.966, Speaker C: Make sure you talk to the team about it. Just make sure that it is known why you're doing this. Because it is a contentious issue. It can cause bugs. It does cause bugs. Null causes bugs all the time. I can't tell you the amount of times I've written software where I've had to catch these null cases from a database coming up or the other way around.
05:10:24.966 - 05:11:31.872, Speaker C: It causes chokes along the software development life cycle. You may not have an adverse effect from making something nullable, but once someone consumes your database to build an app, a website, or any other thing, well, null may come into play and it may cause bugs, issues, hard times, being able to handle the data. For instance, if you made first and last name nullable, well, now your end developers need to be able to catch that, oh, first name and last name may not come back even after a user is created. So let's just say you had an app and users use that app to interact with your system, and you have the website, and users use that same thing to interact with whatever you're building. Let's say it's YouTube or whatever. And from the website you can register and from the app you can register, but on the website there's a bug and suddenly people can register without having a first name. And then they log into the app and the app didn't catch that.
05:11:31.872 - 05:11:54.740, Speaker C: The first name can be nullable, but they got through the register process without a first name. Well, now your app may break. That is why null can be one of those contentious issues. That's why it can be one of those things where, okay, when we're going to do it, we need to be deliberate. We need to be mindful. Just make sure that everyone knows what is, what isn't and why. The why matters.
05:11:54.740 - 05:12:28.200, Speaker C: Null is also a special value. You see over here, one is equal to one will yield true and one not equal to one will yield false. But null equal to null will output null, and null different than null will output null. Let's look at that. So over here, we're in Valentina, and you can see that I did select null equal to null. Well, let's run that. So when we execute that, what we can see is it's outputting null as a value.
05:12:28.200 - 05:12:57.948, Speaker C: And now I want to show you what I mean by that, why it's special. Why is it outputting null? Well, if we un comment select one equal to one, what you're going to see is it's returning true. Huh, interesting. Okay, that makes sense. So null is going to return null. So null is a special value. Null will return null.
05:12:57.948 - 05:13:41.334, Speaker C: Now, what does that mean? What effect does that have? Well, all roads lead to null. No matter what you do with null, it will always be null. If you subtract, if you divide, if you do equal, if you try to do something with a null value that we've learned, if you have null values and you're trying to do an average, for instance, you're going to get back null. Null can be one of those nasty side effects. So that's why, again, you have to be mindful, be careful, be deliberate, be clear what is going to be null. Because when you start doing these things, it may cause issues. Again, no matter what you do with Null, it is always going to return you null.
05:13:41.334 - 05:14:28.688, Speaker C: And you only need one null value. You could do a complex calculation of one plus two plus three plus four divided by and so forth and so on. And if you divide it by null, well, you're going to get null back. And it's going to be hard for you to trace down which value is null and why it's null and who didn't fill it in. So you may be asking yourself, now, how should we use null? Well, let's look into that. So, you may be asking yourself, now, how should I use it? Well, let me clarify that for you. Because null being one of those contentious things, it is quite difficult to pick and choose when to use it.
05:14:28.688 - 05:15:27.292, Speaker C: And so I want to give you three guidelines, solid principles that can help you make a decision. Now, be aware that most of the times these decisions should be talked over and decided as a team rather than the individual because it is important that everyone knows why you are making something nullable. If that is a hard set requirement on your team, if you have guidelines in place, you can follow those. But here are some general things you can look at. Is my data optional or required? Now what do we mean by that? Well, some data that you store may be optional and some data may be required. Optional data could fall into the category of, well, we may notice at some point, but when they sign up, we don't. And required maybe stuff like first name, last name, date of birth, email address, all of that good stuff that you need to be operational as a company.
05:15:27.292 - 05:16:30.508, Speaker C: So what would fall under optional? Well, you've probably done those apps where you sign up and then it starts asking you a bunch of questions, like a survey, kind of like what Apple Music would do, and it starts asking you your music preferences. Well, here you can see that the required information was your username, your password, your first name, last name, billing address, all of that good stuff to create an Apple account. And then when you go and to Apple Music, well, when you signed up for Apple, you didn't automatically sign up for Apple Music, right? You signed up for your iPhone or your app store or whatever, and that was the base information. You gave them the billing address and all that good stuff, the payment information. And so now you can look at the database and say, well, okay, they have all of that required information about me. And so what would be optional? Well, when you sign up for Apple music, that is a product offering that they have, that is not something that is immediately tied into you having an account. It is something that they are offering you on the side.
05:16:30.508 - 05:17:14.504, Speaker C: So it stands to reason that a lot of that information around your music preferences, around your listening activity, all that stuff that is unknown to them, they don't have that information. Now at scale, they have different operational mechanisms to catch that. They may run all of your music preferences on a separate database, for instance. But let's just go the simple route. Let's think about it in the most simple way. Well, if you looked at this as one table of user preferences, for example purposes, well, you could look at optional data as being that music preference because you don't know that upfront, you don't ask that during the registration process and you don't know it immediately. So it could theoretically be nullable.
05:17:14.504 - 05:17:52.386, Speaker C: That ties into future info. Optional info is often future info. Usually when you have optional information. It is information that you are going to either get in the future or get at some point in the user process. And then you have to think about your rationale. You have to think, well, if I make this nullable, what impact is that going to have? You have to think of all of the edge cases. Now, how do you think of those? What ties into that? Well, it is important that you take into account what type of product you are trying to offer and talk to the teams that are going to build those products.
05:17:52.386 - 05:18:28.468, Speaker C: Communication is the vital part of an organization. You may look at data as a database, but building software is about teamwork. Teamwork makes the dream work. I can't say that enough. Get farther together than you do alone, you go fast alone, you go far together. So always build a rationale and build a team opinion. Now, what does future data look like? Well, like I said with the Apple music example, it may be a column that you're adding to your database.
05:18:28.468 - 05:19:10.576, Speaker C: At some point you're doing a new product offering, you have some new data that you need and you don't quite know yet what it is or where it's coming from. Like you had all of the customer information, suddenly you have to track their address. Well, you have 10,000 users and you have none of their addresses. Okay, so you add the column address, and now what? Well, you can make two choices here. You could choose to make the field nullable, and by default it will be null. Or you can choose to put in some temporary data, you could say temporary address. What would the drawback of that be? Well, the UI would work like all of the software would continue working because data is coming back.
05:19:10.576 - 05:19:48.888, Speaker C: There's no null value coming back. But the drawback is your data now becomes cluttered. You have to keep track of. In this column we put this temporary thing, and in this column we put this temporary thing, and here we did this. That doesn't really create a solid foundation to build software on. So in this case, because this is future information, this is something we're adding, a new offering requires the address, et cetera, et cetera. Well, now you have to go take into account that you may have to catch a null value here or there in the subsequent software you're building, and you may have to make a team norm out of, hey, the address field, null.
05:19:48.888 - 05:20:34.392, Speaker C: That's the value we're going with. Because when you use a temporary value now, you have more technical debt to keep track of. Now, technical debt, that is a term that is so important. Technical debt is making a decision that you later on have to clean up, making a decision that in essence causes you to do rework. So if the system gives you a null value, my personal opinion is, well, in this certain scenario, go with that null value, it'll push you way farther because you now don't have to go and clean up. Okay, software has to catch this case, okay, you have to communicate, but you're reducing the technical debt. That is a key term that we should always keep in mind.
05:20:34.392 - 05:21:45.762, Speaker C: Is what I'm doing going to cause rework later? Is what I'm doing going to harm the team later on? Decisions like that is why team norms are important. Working on software, working on databases, is a team sport, not a solo race. All right, so now I hear you asking, well, mo, I get that I shouldn't use nulls, and I get that in certain scenarios I can use nulls, but what does that mean for my queries? What does that mean for me as an individual when I'm writing the queries that are going to be consumed? Well, my core principle in software is be defensive, be defensive, play on the defense, always expect the worst possible outcome, expect things to break. So how are we going to do that with queries? Always check for nulls when necessary. When you know something is nullable, when you go and look at the table and you see null values or this or that, always check for nulls when necessary. And that is so core. You see, in my experience, it is always of the utmost importance to be on the defense.
05:21:45.762 - 05:22:18.130, Speaker C: Anything you write should be safe to consume. That doesn't mean that you can't send nulls through. It means that when you're trying to do complex calculations, you should always check for nulls when possible. When you're trying to do complex queries, make sure you catch those nulls, because they may just cause a bug, they may just cause something to have the outcome of null. So how do we do that? Well, one, we want to filter out the nulls. We want to filter them out. We don't want them in our results set, and we are now filter masters.
05:22:18.130 - 05:22:58.832, Speaker C: Okay, there's still a lot to learn, let's be clear. But we are solid right now. We know all about the where clause and how to filter out things, so we want to filter out those nulls. How do we do that? Well, you may be saying, okay, what if I go and I say is not equal to null? How would that work? Well, let's try it out. So over here we have DB fiddle again, and we have a small database with about five students. And let's see what happens when we select the last name. Well, then we said we're going to use our where clause.
05:22:58.832 - 05:23:20.296, Speaker C: So let's say where last name not equal to null, and let's see what that does. Huh. No results. Okay, so let's do that with name and last name. Huh. Still no result sets. Interesting.
05:23:20.296 - 05:24:15.578, Speaker C: How could that be? Well, you can't check null to null because as we saw, when you select null equal to null, it will return you null. So how do we check true or false here? It's breaking our where clause is breaking our mastery of the where clause conceptually. It's kind of weird, right? We know that we could do like not equal to null. Huh. But as I said, anything you do with null returns, you know, so how do we do this? What we're going to use is called the is operator. The is operator allows you to filter on values that are null, not null, true or false. So it is a special keyword that is reserved for the where clause in the cases that you want to check on null and not null.
05:24:15.578 - 05:24:48.478, Speaker C: And how it works is you select star from a certain table where the field is, and then you can optionally put a not is not null or is null. So let's try that out. We're back here in db fiddle, and let's do name is not no. And let's see. Oh, we're suddenly getting values back. Okay, so we can see student two, student five, and we can see that their last name isn't null. So let's go try that with last name again because that didn't work prior time either.
05:24:48.478 - 05:25:17.498, Speaker C: So we're going to check where the last name isn't null. And now we can see different students. So there's one student that has a last name but no first name. So the is keyword is that powerful keyword. So what we have to keep in mind with the is keyword is that it allows you to filter on values that are null, not null, true or false. It is extending our understanding of how to write filters. You can use the is for null, not null, true or false.
05:25:17.498 - 05:25:52.050, Speaker C: Okay, so the is operator can operate on true or false. How does that look? Well, you remember when I said if your field has text, you could leave empty text in there? Well, you could do something like this. Select from certain table where a field, a column is equal to empty, and then we could say is not false. So we could invert it. We could use the not keyword like this. Remember when we said that we could say exclamation mark equals is not equal to. Well, this is another way of writing that we could say is not false.
05:25:52.050 - 05:26:21.428, Speaker C: Huh? So if we said that we're saying where the field equals to empty, not false, that's basically is true. Confusing, right? That's basically the same as saying is true. So we're saying where the field is empty. So we could say is not false or is true. So there's a lot of different ways you can use this is operator. This is kind of a messed up way of writing it. I'll be fair.
05:26:21.428 - 05:26:38.520, Speaker C: But it's to show you the nuance of the power of these keywords and how you can chain them. So you can use is not null. You can use is not false, is true. You can do a lot of different things here. So here we're saying where the field is equal to empty. I didn't need to add this to the end. I didn't.
05:26:38.520 - 05:27:26.480, Speaker C: It was unnecessary. But it is possible because it's more explicit. You see what I'm saying here? There's a lot of different ways that we can chain and use things to make our queries more powerful. So what if we did it with a number? Well, if we did select star from users where age is equal to 20 is false, we're saying everyone that is not 20. Now, you remember when we did it the other way around? We could say where not age is equal to 20, or where age, exclamation mark equals 20. So a lot of different ways to write a true or false where statement. And it's up to you to determine what you like more.
05:27:26.480 - 05:28:14.750, Speaker C: Personally, I like with numbers, the not equal sign more. It reads better. It tells me I am operating against the number. And I like to use the is keyword or other keywords when I'm operating against different types of text fields. Now I hear you asking, well, mo, what if I want to replace the null values? What if I want to show something else when I do a query? What if I want to predify my data that has null values? Well, let me show you how to do that. In the previous video, we looked at the is keyword and how that can help you identify null values. Now, that goes into being defensive.
05:28:14.750 - 05:28:59.818, Speaker C: When you are working with null values, it is extremely important that you are aware that you are working with null values. And so we talked about cleaning up your data, replacing those null values with sane values. And so how would we go about that? Well, we would do something called null value substitution. It is the ability to replace null values to operate on the data, you basically are making the null not a null value. In this case, you're replacing it with something else. You're substituting it. And so there is a keyword called coalesce, which allows us to do this.
05:28:59.818 - 05:29:53.432, Speaker C: When you do select coalesce column name and you give it a fallback value, what you are basically saying here is coalesce this column that may or may not have null values. And when it is null, replace that null with empty. And because we are running a function against a column, you all remember that we have to alias the column name if we don't want it to be named after the function that was executed upon it. Because when you execute a function on a column, it loses its column name because you are now ostensibly changing that data. And so what's important to note here is that when we coalesce, Coalesce returns the first non null value in the list. So if it's null, we'll replace it. But if it's not null, we'll replace it with the value we found.
05:29:53.432 - 05:30:25.920, Speaker C: What do you mean, mo, you only saw one value go in there. You put the column name as the first parameter and the fallback as the second parameter. Well, that's what's special about coalesce. You can give it multiple columns to fall back on. So if you had, let's say, a table that had multiple columns that may or may not contain data, what you could do is you could coalesce against each column and then have a fallback. What that means is that the column one is the first one it's going to check. If it doesn't have a null value, then that's the one we're returning.
05:30:25.920 - 05:30:38.464, Speaker C: Okay, it has a null value, so we'll fall through. We'll go look at column two. Does that have a null value? Oh, no. Okay, then we'll take that. But if it does, let's fall through the column three. Does that have a null value? Yes. No.
05:30:38.464 - 05:31:11.320, Speaker C: And so it's like this. If else case, if this is null, else go look at column two, else go look at column three. Else return our default. And so you're combining the coalesce against columns. This allows you to create a more complex fall through of null value substitution. And so let's go take a look at that. So over here, we are in DB fiddle, and here is our table again with some data from students that contain null values.
05:31:11.320 - 05:31:46.200, Speaker C: So let's select star from student and let's look at it. Well, what we can see here is that student one has a name and no last name. Student two has the same thing going on. Student one also has no age. Student three has no first name. Student four has no first and last name, and student five has no last name. Okay, so how would coalesce work here? Well, let's say you wanted to select all of the students by name.
05:31:46.200 - 05:32:14.390, Speaker C: Well, let's say we did name and we did last name for good measure. So let's run that. Well, what we can see here is that student one has null, student two has null. Student three has a last name. Student four has no first and last name. So let's go ahead and let's coalesce the first names. So let's run coalesce.
05:32:14.390 - 05:32:47.180, Speaker C: And let's say, well, you take name or you say no name available, and let's see what that does. So let's expand this out, huh? So the column name was renamed to coalesce. Interesting. Like we said would happen. And if there is a null value, we are replacing it with no name available. So coalesce allows us to substitute the null values. Awesome.
05:32:47.180 - 05:33:24.754, Speaker C: What if we wanted to run a sum against the ages? Well, let's go look at that, because we clearly have ages available. So if we set suma age, well, the value of sum will most likely take nulls into account. But let's run it. 137. Well, let's look at that. Let's go look at age as an individual attribute, and let's go check if that's right. 25 plus 2045 plus 34 plus 58.
05:33:24.754 - 05:33:56.160, Speaker C: Huh. That seems to be correct. So it took the null value into account, but let's say we did sum of age, but let's say we did something special, and we coalesced the null values, and we said, well, if it isn't an age, let's return 20. Will this work? Let's take a look. And I see here it's coalesce. So we're coalescing against a fallback number. Let's see if this works.
05:33:56.160 - 05:35:04.010, Speaker C: 157. So what if I make this 200? Huh? We are falling back on age, and we are giving it a default value. So let's say we got into a scenario where we had a database and a table where we had null values and we had an approximation of what the price should be. Well, then we could just give it a fallback value against the sum, and we could coalesce those null values to be rounded up to the nearest. There are many scenarios in which you will want to coalesce null values to give it some kind of variation for instance, if you were in a classroom and you knew that the general age of the population in the class was 13 because it is a certain grade, you could coalesce the null values to be 13. In this case, the nuances of this approach vary depending on the scenario you are in. You may or may not want to use coalesce, but the thing is, always try to use it when dealing with null values to give it a sane fallback.
05:35:04.010 - 05:35:16.680, Speaker C: Because if you're doing complex calculations, sure, in this case, sum took it into account, but some analytical functions may not handle null values as well. Alright, so let's get into some exercises.
05:35:21.180 - 05:35:23.124, Speaker A: Are you completing the exercises?
05:35:23.252 - 05:36:20.532, Speaker C: I'm watching you. We've reached a very special part of the course. So far we've learned, and or not, we've learned all these filter techniques. We've learned about the different values and how filtering actually happens, and the fact that we need a truthful or a false assumption in order to get the filter to work. Now, we also just learned about null and how null can throw a wrench into all of this, because null is equal to null. Well, in SQL we have something special called three valued logic. Now what is that, you ask? Well, besides true and false, the result of logical expressions can also be unknown.
05:36:20.532 - 05:36:54.594, Speaker C: It can be null. Thats what we call three valued logic. In most programming languages, unknown would often result in false. That would make sense, right? If you don't know something, it must be false. Well, in SQL there is a slightly different approach, and we saw that when we looked at null being null. When you select null is equal to null, when you do that comparison is null, equal to null. Well, that's going to return you null.
05:36:54.594 - 05:37:32.082, Speaker C: It doesn't return you true, it doesn't return you false. So three valued logic works like this. On the left hand side we have statements that can be true, and on the right hand side we have all the statements that can be false. And then here in the middle, there is this intersection where depending on what we do, a value could be null. And if it's null and we compare against it in some logical fashion, it may return us null. It may return us unknown. And that throws a wrench into our entire query, to be honest, because now it isn't going to work, and that is a bad thing.
05:37:32.082 - 05:38:05.696, Speaker C: So, three valued logic means that each expression can have three different outcomes. An expression can be true, an expression can be false, or an expression can be null. And we want to avoid null as much as possible. That's why we looked at null coalescing that's why we learned the is keyword null is a bad thing. Not always. It's good to have nulls around in your data type if you're expanding. And we talked about all of these different edge case scenarios, but speaking frankly, null can cause unwanted behavior.
05:38:05.696 - 05:38:41.276, Speaker C: So in three valued logic, the SQL null is a value and it could be anything. Null doesn't mean it's nothing, it just means we don't know what it is. So when we look at it conceptually, when we look at a null conceptually, it just means it could be anything. SQL isn't going to determine what it is for you. It's not going to say it's true or it's false. It's going to say, I don't know, this could be anything. And that's why we call it three valued logic.
05:38:41.276 - 05:39:05.430, Speaker C: Now, we also looked at null and we said nothing equals null, not even null. Each null could be different. So if null is not equal to null, that means an unknown value is not equal to an unknown value. Null is not equal to null. Null equals null is not true, not false. It is null. SQL will reject that statement.
05:39:05.430 - 05:40:13.340, Speaker C: It will say, I don't know this. And that is what is important here to understand that with that three valued logic, you have three different streams of outcome. When you do a filter, you can say each statement that is true is going to return me a result. Each statement that is false is not, and each statement that is null is going to return null because nothing equals null, not even null. That is why we use the is null check when we did null is equal to null, we got null back. So SQL gave us this special operator is null and that is what is telling us, is this true or is this false? Because null is unknown, we need a special operator in order to tell us, hey, am I operating against nulls here? Are there nulls here? Is there a possibility of anything being null in this data set? So the is null check is important, is of vital importance when working with values that can be null. So let's look at some of those over here in the right hand side, you can see I tried to elaborate on what the statement below is going to be.
05:40:13.340 - 05:40:40.732, Speaker C: So we say null equal to one or one equal to one. We're going to look at some tricky scenarios about three valued logic. So we know that null is not equal to one. So that's going to return us not false. No, it's going to return us null. Okay, so we know this part is going to return us null and then we say or one equal to one. Oh, well, that's a normal expression.
05:40:40.732 - 05:41:18.840, Speaker C: That's true, right? Yeah, yeah, that's, that's true. One equal to one true. Okay, so where is the tricky part in this? Well, as you can see, I highlighted the green part. And by highlighting the green part, what I'm saying is this statement, if you did this in a where clause, it's going to be true. Now why is that? Now think back to our or statement. Remember when I told you when you implement an or, you're basically starting a separate tree or a separate filter, not in actuality, but conceptually it's a different node. You're going down a different flow, a different side of the river where you're checking something else.
05:41:18.840 - 05:42:01.326, Speaker C: So when we say null equal to one, we know that's going to return us null and that's not going to help anyone. But because we have the or statement here and because we're saying or one equal to one, well, then the whole expression becomes true because one of the sides of the expression, not the left side, but the right side, is true. Or says, well, if one of these is true, all of it must be true because of that fact that the or does that, all of it is true. Okay, so that makes sense. We will still filter on one is equal to one because of the fact that the or works that way. Now let's look at another scenario. Well, here you can see I highlighted the null section.
05:42:01.326 - 05:42:37.260, Speaker C: Why is that? Well, null is equal to one returns us null and zero is equal to one is false. It's not equal to one. Huh. So why am I returning null here? Well, like we said, or is this or this being true or false makes either side true or false. But now we're using and which is inclusive. It's this and this need to be true in order for it to be true. This and this need to be false in order for it to be false.
05:42:37.260 - 05:43:22.410, Speaker C: Well, null and false equals null because null is always going to give you back nulls in an inclusive operation as and there is no result set, nothing will come back of this. Alright, so we're getting the flow here. Null can be a tricky thing. Now let's look at something a bit more elaborate. Select column from table where column is equal to null. We already kind of looked at this during null coalescing and is null in learning about the is keyword. And we know that that's going to return us the null section because null is always unknown.
05:43:22.410 - 05:44:25.006, Speaker C: So this is going to reject all of the results because null is not even equal to null. Alright, so what if we did select column from table where column is null? Well, we learned this is null checks for unknowns, so it's going to be true. So we're going to get results back if it is in fact an unknown value of the unknown type. You're starting, are you starting to see the nuance difference between the equal sign and the is keyword? That is what we're trying to hammer in here. This is how nulls work in SQL. So now let's get into some real strange scenarios because the previous ones, although I called them strange, we basically all already knew what was going to happen because we looked at null coalescing and we understand how nulls work. But here select column from table where column equal to null or not column equal to null.
05:44:25.006 - 05:45:00.800, Speaker C: Well, what would this return? Pause the video here and think about it. Well, the parentheses are here to throw you off because we learned that parentheses give us the ability to have something execute. First, we know that column equal to null is null or is either this or this. Now, not column equals null. Well, column equals null is null, so not null is still going to return null. So consequently all rows will be rejected. Nothing is going to be returned.
05:45:00.800 - 05:45:33.440, Speaker C: Here's the next strange scenario. What would this return? Well here we're using the is keyword, so is null is not null. Ha. So we're saying where it is null or it isn't null. In this case, because we're using is null, we're saying if it is null or it isn't null, return us the data set. So what would this return? Pause the video and think about it real quick. This in essence is a trick question.
05:45:33.440 - 05:46:01.110, Speaker C: Nothing will be rejected. What do I mean by that? Well, we're filtering on what is null or what isn't null. So everything will be returned, the entire data set. Let's look at that real quick over here. I put together a query, select star from student where age is null or age isn't null. So let's remove that where clause and let's see what data we have here. So we can see we have student 12345.
05:46:01.110 - 05:46:43.932, Speaker C: And when we implement the where age is null or age is not null. Let's see what happens when we run that. So when we run that back, we still have one to five, huh? Okay, let's just verify our hypothesis here. And if we run that back with is null, we're getting back one student, okay, so it stands to reason that we are getting everything back that we want it to. So let's take a quick look at our previous one. Let's say not equal to and let's see it reject everything, no results to be displayed. See, the tricky part here is null is equal to null.
05:46:43.932 - 05:47:41.590, Speaker C: So when you think about it conceptually, when you put these where clauses together, it can become quite tricky. I put the parentheses in, I put the or statement in to kind of give you a curveball. And as you can see, the equal sign with null does not work. But we already knew that because we are masters of the is keyword. Now what we want to remember and what we want to stick with us is that SQL differs from many programming languages, being that it has that three valued logic system being true, false or null. And null is that tricky little thing, that thing that you may think won't hurt your query results, won't hurt your filters, but can do unknown things. It can strip things from your results, it can do weird things.
05:47:41.590 - 05:48:47.204, Speaker C: If you're doing calculations, you have to be careful with nulls. But the most important thing to keep in mind here is that we know that SQL has that three valued logic system, being that it can have true, have false and have null. Hey everyone. So on a lighter note, we've been learning a lot about filtering. We've been learning a lot about different ways to filter, and we've gained a lot of tools in our arsenal to be able to filter like pros. But what I wanted to do is I wanted to show you something that could make your queries a little easier between and a shorthand to match against a range of values. Mo, what do you mean? Well, let's take a look.
05:48:47.204 - 05:49:31.796, Speaker C: When we do select column from table where column between x and y, what we are doing is an inclusive range search. Anything that is x or y or in between, we will return. And this counts for dates, for numbers, for a whole bunch of range of stuff. So between and is this sweet syntax that can shorthand us to look between a range of values. And now I hear you asking yourself, that sounds familiar. Where did I use that? Well, remember when we had to write out this column has to be greater than or equal to and this column has to be smaller than or equal to. To kind of do the range comparison.
05:49:31.796 - 05:50:12.450, Speaker C: Well, between and gives us that nice swiss army knife kind of feeling because it's more readable. You see, you only have to type your column once and you say between and it's kind of, it reads like a sentence where my age is between 20 and 30, where my salary is between 120 and 180 and so forth. So you may be asking yourself, well, what's the difference here? Mo? Nothing. They are exactly the same. And that is what's so powerful about them. Note that between and is sensitive to the order of the arguments. You are saying between this and this.
05:50:12.450 - 05:51:23.064, Speaker C: So why should you use it? It's more readable, it's more maintainable. So let's do some exercises on it. Hey, everyone, I wanted to ask you a question. What if you wanted to filter on multiple values in an easy way? What if you wanted to filter on those multiple values, but not write a endless and statements filter on this and this and this. Let's say your boss comes to you and he says, well, I want a list of these employees information. Well, if you have to go in, how are you going to find all of those employees information? You may have their names, you may have their employee numbers, you may have multiple values that you can hit against. Let's say in the case you got their employee number, how would you filter against that? Well, there's a special keyword.
05:51:23.064 - 05:52:05.440, Speaker C: It's called the in keyword. And the in keyword is used to check if a value matches any value in a list of values. So what does that mean, a list of values? What does that look like? Well, say we did a select statement and we said select star from a table. Well, we could say where a certain column in, and then we can hit the parentheses. So we add them and we can comma, separate values. And that's how we're creating a list. So we say where column in value one, comma, value two, comma, value three.
05:52:05.440 - 05:53:31.886, Speaker C: For instance, in age where the age is in 5153-5762 you want certain age ranges, for instance. Well, let's take a step back and look at how this would work in a scenario where your boss came to you and said, hey, I want for these employee numbers their information. So here we are over in Valentina studio, and we're in the employees database, and we have a query that says, select from employees where the employee number is in 100,001, 100,006 and 11,008. And over here you can see we got our results set. So we got the information for all of these users based on the employee number. Now, if we were to write this out normally, we would have said something like where employee number equals that or empnumber equals and so forth and so forth, right? So we would have ored it. Well, an in is an easy way to say, well, I want it to match any of these given values, this list of values, if you were to say, so in is very powerful, and it can be used for a whole lot of different types of filters.
05:53:31.886 - 05:54:26.494, Speaker C: So I've prepared some exercises that you can try out on the in keyword. And what we want to note here is that all of these keywords that we're teaching you are just easier ways of filtering, different ways of filtering. And as the questions become more complex, you can reach to all of these different utilities, all of these different keywords, operators, functions that we've taught you to build complicated queries. So go try out those exercises. I hear you saying mo. So I found all these ways of filtering, and I know how to filter against lists. I know how to filter between values, with between.
05:54:26.494 - 05:55:06.590, Speaker C: And we can do ranges, we can do lists, we can do all kinds of different stuff. I know I'm a master at and, or, and not, and all of these different utilities that we've learned different ways of filtering. But mo, what if I don't exactly know what I'm looking for? Well, SQL gives you the ability to do partial lookups. If you don't know exactly what you're searching for. Partial lookups help you figure out, hey, it may be something along these lines. It may be something that looks like this. So SQL gives you the like keyword.
05:55:06.590 - 05:55:30.280, Speaker C: The like keyword works as follows. Select first name from employees wherever I. The first name is like m. And then the percentage sign. Huh? So that means get everyone whose name starts with m. Oh, that makes sense. So we're doing a partial match.
05:55:30.280 - 05:55:59.392, Speaker C: We're saying like m. So the string, the piece of text has to start with m. And then the percentage sign is telling us anything after that. So get everyone whose name starts with m. Pattern matching is what we call this. In order to use the like keyword, you need to build patterns to match. You need to build those patterns in order to establish what exactly you're looking for.
05:55:59.392 - 05:56:42.824, Speaker C: You see, in the previous slide, we said M percentage sign. So we're saying start with mhde, and then anything after that match it. So what kind of patterns can we match? Well, pattern matching happens with wild cards. Well, what is a wildcard? Well, a wildcard is a placeholder that we can put in a like operator to match parts of strings. So we saw the percentage sign, and the percentage sign means any number of characters. Remember when we saw m percentage sign? Well, that means any number of characters following m. Then we have the underscore, which means one character.
05:56:42.824 - 05:57:24.010, Speaker C: If you want to match one character, after you could do m underscore, which would find mo because that's two letters. So it would only find m with one extra character. Percentage sign would find m with any given number of characters. So what kind of patterns can we match against? Well, let's look at some pattern matching examples. Here we have, like, dollar two, which means anything that ends with two. And then we have, like, dollar, two, dollar, find me fields with two. Anywhere in there.
05:57:24.010 - 05:57:53.670, Speaker C: Okay. Anywhere in there. What does that mean? Well, anything that has a two in it in any given position. Let's find that one. And here we have, like, underscore zero zero percentage sign. Huh. So stands to reason that this would mean find this, anything that has two zeros after the first character and anything after the third character.
05:57:53.670 - 05:58:49.690, Speaker C: Okay, what would be an example of that? Well, 2000 would be an example of that because it starts with a two and then there's two zeros, and then there's a zero at the end. 20,000 is also an example of that because 20 zero and then two zeros after. Are you starting to see how we can use this pattern matching to accomplish different types of outputs to partially match against things? Here we have, like, percentage sign, 200%, which means find us fields with 200 anywhere in the value. Next up is, like, to underscore percentage sign. Underscore percentage sign. So that finds any value that starts with a two and are at least three characters in length. Interesting.
05:58:49.690 - 05:59:41.976, Speaker C: How does that work? Well, we have a two here, and then we're saying, well, we want at least one character after, and then anything can come in between, but then we want another character at least after that, and then anything can come after that. So it means, well, it has to start with a two, and it has to have at least two more characters, for sure. And anything can kind of fall in between, but we want it to be at least three in length. And then we have, like to underscore, underscore, underscore, underscore. It's not really clear how many underscores are here, but trust me, it finds any value with five digit numbers that start with two and end with three. So there's three underscores in here. So five digit numbers starts with a two, ends with a three, and that's what we're aiming towards.
05:59:41.976 - 06:00:25.470, Speaker C: So the underscore can be used as a placeholder to say, well, I at least want something to happen here, and I at least want something to happen here. And anything in between can come or go. I really don't care, but it can be used to say, well, it needs to have at least this at this position. So you can say I want a name that starts with m and then put a percentage sign and put two underscores at the end. And you're saying the name has to be at least three characters in length because I have two underscores at the end. But anything in between can be anything. So the like keyword postgres only does like against text compares.
06:00:25.470 - 06:01:14.886, Speaker C: So we must cast whatever we use to text. I hear you saying mo, what does this mean? Let's take a step back. When we look at our database, we have a lot of different types of data. We can store dates, we can store numbers, we can even store nulls, which are very controversial. But that being said, postgres only does the like operator against text. So when we say we must cast whatever we use to text, what we mean is that anything we're going to use in that like command, any column that we're going to use to do a partial match against, we're going to cast it to text. Now you may be thinking, how do I cast? We haven't seen that.
06:01:14.886 - 06:01:52.996, Speaker C: Well, casting is the act of changing something to something else. So changing a number to a string, changing a string to a date. And when we cast, we're basically saying, well, for us to use the like keyword, we're going to have to cast. So how do we do this? There are two different ways of casting. Over here you can see that casting to text can be done with the cast keyword. You could say cast salary, salary being a number. We know salary is a number because it comes back as 100,000, 80,000, 70,000, whatever the case, it's a number.
06:01:52.996 - 06:02:47.808, Speaker C: So we say cast and it's a function. So we use the parentheses and we say cast the column salary as text. Or we can shorthand it and we can say colon, colon, text, salary, colon, colon, text. So these are two ways to say, okay, I know this field is something else, but make it text. And in that way you can use it to do the like keyword. Alright, now that we know that, now that we know that one caveat of the like keyword, now that we know we can do partial matching with the like keyword, and now that we know all of the different ways we can use the like keyword, let's look at I like, now I'm not saying I like, it's an actual keyword. It's not like I like candy, it's stupid joke.
06:02:47.808 - 06:03:21.898, Speaker C: It's a different way of using the like keyword. And it is case insensitive matching now, you may be asking yourself, mo, we haven't even done an exercise on like yet. Trust me, there are enough exercises to go around. But it is important that we know that we have these two keywords. Now, like is used for partial matching. And as you saw, you can partial match against multiple different things. But that doesn't account for the case where you have to take into account, hey, this may be uppercase.
06:03:21.898 - 06:04:09.454, Speaker C: This may be lowercase. What shape is my data and what kind of text am I working with? You see, you could fill in a name into a database, and uppercase the first letter and lowercase the last letter. But depending on who's input the data, they may make typos, they may accidentally uppercase, lowercase. And depending on how the data is stored, this may make it hard for you to do a matching operation. So I like is just a different keyword that allows you to also do the partial matching the same exact way that like works, but it does case insensitive matching. So no matter what kind of text you're matching against, it's going to match whether mo is uppercase. Mo is lowercase.
06:04:09.454 - 06:04:39.380, Speaker C: It doesn't really matter. It's going to match all of those. So you don't have to do complicated things there. So let's take a look at how that works. Here we are in the employees database. And over here, we can see that we have all of our data from all of our users, and we're selecting star from employees. Now let's take a look at how we would use, like, well, let's say someone came to us and they wanted to find users whose name started with g.
06:04:39.380 - 06:05:08.828, Speaker C: So let's do that where first name like, and then let's say g. And we learned that the percentage sign is the one that we need to use to match anything after. So let's look at what that looks like. Awesome. Awesome. So we can see here that we found thousands and thousands of employees whose names start with g. Okay, let's go one step further.
06:05:08.828 - 06:05:46.840, Speaker C: Let's say their name has to end with an r. Let's do r. Because we can see that the strings go from uppercase to lowercase. And here we can see we've still found hundreds and hundreds of employees. Okay, so now let's say that it needs to be er. And now you can see we're starting to filter more and more down. So if we said, well, it has to be g and it has to end with Ger, we can start filtering down our list and filtering down our list as we go.
06:05:46.840 - 06:06:15.922, Speaker C: Okay, now let's say for some reason the name was misspelled, right? Let's say that this was Ger, but it was uppercase. Well, you don't know how the data is stored. In this case, all the data is stored. Normally this would be a case for I like, and you could say, well, I don't want to pay attention to uppercase, lowercase. I don't want to deal with any of that. So let me just fill it all in an uppercase and find me everything that has with it. Well, I like gives you that ability.
06:06:15.922 - 06:06:42.438, Speaker C: Or you could say, you know what, just fill it all in lowercase. I don't really care the search parameters. I don't want to care about what it's uppercase or lowercase. And let's do that. And the reason we do that is because as you can see here, if we use the like keyword and we did a lowercase g, we're not going to find anything. There's no first name, there's no last name because it starts with uppercase Ghdem. And these are use cases for you to use like versus.
06:06:42.438 - 06:07:18.828, Speaker C: I like say, hey, if I don't know. And if I don't care about case, how about I just use I like? In any case here you can see the power of like and how we can use it to supercharge our where clause when we don't know exactly what we're trying to find, when we're trying to partial match against something. And you can combine it with many different cases. You could say, hey, I want people born in 1980 whose name starts with a g. You can build queries like this now. Yes, if your boss comes and asks you a question, you can find the answer. You can do partial matching now.
06:07:18.828 - 06:08:14.564, Speaker C: You can do value mapping, you can do and or not. We're really becoming masters of this where clause. And that's what we're trying to become, masters of filtering and masters of SQL. I'll see you in the next video. So here we are, date filtering, one of the most elusive topics when it comes to any type of software development or database management. Dates are hard. Dates are one of those things that make database management, software management and everything in between so much harder.
06:08:14.564 - 06:08:54.260, Speaker C: Now, for those of you who have written software, you know the pain that it is to work with dates. They're just hard to work with. But for those of you who are new to this space and new to SQL and new to databases, what makes working with dates so hard is the standard. The standard around dates has shifted as time has moved forward. And now, in 2020, we're in a place where there are standards. There are ways to deal with databases and to deal with dates in databases and dates in software. There are standards in place that we can utilize.
06:08:54.260 - 06:09:39.128, Speaker C: But I hear you asking yourself, okay, where did this all start? Well, dates are hard because of time zones, because we all live in a different place in the world. We all live in different times. We all live in various places across the globe, across the equator, and all these places vary in time, day, even, sometime. So what is a time zone? Well, in 1884, Sir Sanford Fleming went to an international conference in the UK in Greenwich. Now, you may have heard of Greenwich. It is known to be the central hub of time. Now, at this conference, he had the idea.
06:09:39.128 - 06:10:18.760, Speaker C: He basically went there and he said, hey, everyone, let's try to align on the way we handle time. Now, how did he do that? Well, he basically proposed that we pick a point in the world and we offset every other country's time based on that central point. Now, that central point ended up being Greenwich in the UK. Now, why Greenwich? Well, it was a central hub of commerce in the world at the time. Everyone was trading with them. They were all over the place. They were a powerhouse.
06:10:18.760 - 06:10:52.830, Speaker C: And so they got to be the center of time. Now, that's a big compliment to them. And of course, it was a monumentous moment in the world because we started uniformly measuring time. Never before in history were we so aligned. It was great. But there were still some issues. How do you draw the lines? Who is in what time zone? And there are all kinds of rules around this, and those rules dictate how time zones work.
06:10:52.830 - 06:11:26.454, Speaker C: Now, you may be thinking to yourself, okay, mo, what does this have to do with databases? Well, I just told you that the UK, Greenwich, is the central hub of time. Now, that can mean two things. That can mean one, every database should be set in GMT. Or two, well, we have no standard. Therefore everyone sets their database in their own time zone. Both things happened. Some people set their database in GMT to align to a universal standard, and others set it to their local time zone.
06:11:26.454 - 06:11:58.834, Speaker C: On databases, this had a huge impact. How do you determine what your standard is now? GMT being the standard, Greenwich mean time. At the time, it wasn't really a standard. It was more an alignment. So, smart as we are, we decided to create a standard. And so we came up with UTC or cut or UCt. All of these abbreviations mean the same thing.
06:11:58.834 - 06:12:17.350, Speaker C: Universal coordinate time. It is a standard. It is a way to measure time. It is not a time zone. Let's be extremely clear. No country in the world is using UTC to determine its time. No country is using it as a time zone, so to speak.
06:12:17.350 - 06:12:40.692, Speaker C: It is a standard. So what's the difference? Well, GMT is a time zone and UTC is a time standard. Now, let's take a step back here, because there's a whole lot of information there. So Sir Sanford Fleming in the 18 hundreds, decided, we're going to align time across the world. Great. 100 years later, we start building databases. And now we're in this predicament.
06:12:40.692 - 06:13:00.210, Speaker C: We have to measure time. And at the time, okay, we weren't building the facebooks of the world and the instagrams of the world. No, no, no. We were building local apps for local hubs. And there wasn't really a problem with time zones or time standards or anything like that, really, because everything was local. We weren't really a global society online yet. We were getting there.
06:13:00.210 - 06:13:39.646, Speaker C: We were moving forward, we were threading the needle on a lot of different issues, but we didn't really need a time standard just yet because software development was a new practice. But you can already start to feel the pain now, you're an engineer, you're an architect, and a client comes to you and they're like, hey, I need an app that crosses all boundaries of the world. Everyone should be able to use this. Now, you have to make a decision. Okay. This app heavily relies on times and dates. And how am I going to work with this? Well, there is only one way.
06:13:39.646 - 06:14:28.588, Speaker C: We have to use UTC. And since no territories use UTC, it is the standard that we can use. Now why do you ask? Why, why can't we just use GMT? Aren't they the same? Well, they share the same current time. In essence, they are the same, but conceptually they are different. And why should we use that? Why can't I just use my local time zone and offset everything? Well, to be fair, you could. And if you set that as a standard and you store everything in that specific way, it should be fine if everyone else knows that they have to offset it that way. And if incoming dates contain a time zone, for instance, let's just say I'm in Toronto right now and someone's using my app in Australia.
06:14:28.588 - 06:15:04.532, Speaker C: Well, if they send their date with the time zone information, I can easily put that in the Toronto time and store it that way. And as long as I know that they live in Australia, I can reverse that back into their time zone. But that's a bit cumbersome, right? Sure, we know that our app is in Toronto time, but it doesn't really scale. Let's say we start having developers in other countries and we globalize like Facebook or Instagram. Well, standards are what drive everything. Standards are what make us aligned. And that's why UTC is a thing we want to align.
06:15:04.532 - 06:15:35.450, Speaker C: We want to all know the same thing. And as long as we know that we are storing things in UTC, there is sanity in the system. Now you may be asking yourself, okay, UTC and GMT share the same time, so why don't I just use GMT? Well, again, conceptually they are different things. One is a time zone, the other is a time standard. We don't want our app to act as if it is in the UK. We want our app to act as if it's universal. Therefore we use the standard UTC.
06:15:35.450 - 06:16:31.532, Speaker C: Now, should we always use UTC? Over here you see a command and this command you can use to set your postgres session, your current session in UTC. And then you can start viewing dates and times as UTC. Now before we get into that, I hear you having the question in your head. Okay mo, this is a lot. So we know GMT, we know UTC, we know a standard versus a time zone, and we know all of these things. Why do we need all of this? Again, keep in mind that when you're building software, we're a global society now and many different users from many different regions will use your software. And so it is important to align to a standard that can allow software developers to offset dates and times in a sane way.
06:16:31.532 - 06:17:16.730, Speaker C: You need to store them so that moving forward they are all aligned. I don't want to store a date from a user in Australia with his australian time zone, then have to offset that later on. That's a bit much, but I know the user lives in Australia, so why don't I just take his date, put it at a baseline and whenever he requests it again I just do the calculation. Everything is normalized, everything is the same. That's the important part here. And when working with dates, it is important that we think about them in a uniform way. Always try to think about your data in a uniform way.
06:17:16.730 - 06:17:43.084, Speaker C: Don't try storing data for different users in different ways. Always try to find the baseline. Always try to find a standard. We don't want to be storing the salary for one person in text and another person in number. We always want the same data type. And so when we think about dates and times, we want the same standard. We don't want to aligned to a person's country standard.
06:17:43.084 - 06:18:19.558, Speaker C: We want our own standard. So over here we're in postgres and you see the command show time zone. Now if I execute this, what you'll see is that my time zone is set to America Toronto. Now why is that? Well when I installed postgres it aligned its configuration to my local configuration to show me dates and times in my local time zone. Now does this mean that postgres is storing dates and times in America Toronto time? Not at all. Not at all. Postgres is one of those database management softwares that has aligned their standard.
06:18:19.558 - 06:18:53.876, Speaker C: They save everything already in UTC. They go even farther, they assume anything you give it that is both date and containing time is UTC. We have to do special operations in order to tell postgres that this is of a different time zone. Now we'll get into all of that, we'll look deeper into all of those edge case scenarios. But for now the thing you really need to know is UTC is the standard that we want to follow. 99% of the time. It is the standard that makes the most sense.
06:18:53.876 - 06:19:50.548, Speaker C: And when we install postgres, postgres is kind enough to align with our system time zone to show us dates and times that are visually and mentally aligned with the time zone we are in. But when it stores dates, when it stores times, anything that it takes into the system, it is going to assume that you are giving it a UTC format, a universal coordinate time format. So if I for instance wanted to fill in an hour that was 10:00 if I did not specify that it had its own time zone, postgres would automatically assume that the time you are giving it is already UTC. So Postgres is a database that stores everything in UTC time. And going off of that knowledge we can now build our frame of reference around how time zones work. So let's go ahead and build that frame of reference. So over here we see that time zone is set in America Toronto.
06:19:50.548 - 06:20:12.250, Speaker C: And as I said, we can set the time zone to be UTC. Now when we do this, we are not setting it to show us everything in UTC. No no, no. We are setting our time zone only for this session. Let me show you. So right now it's America Toronto. And on the next run it's UTC.
06:20:12.250 - 06:21:07.254, Speaker C: Now let me close Valentina studio and let me reopen it. And what you'll see now is that when we do show time zone, oh, we're in America Toronto again. So when you set time zone, when you use that command, it is only for that session. If you want to change it at a system level to show you all dates and times in UTC at all times, you can do this and you can do this in your PG config. Let's go look and see how to do that. Hey everyone. So I quickly wanted to show you how you could set the time zone for all of the sessions for the user you log in with, which is the most important, right.
06:21:07.254 - 06:21:46.652, Speaker C: You as a user, when you log into postgres you want to align the dates and times you see to certain time zone. So when we show time zone you can see that my time zone is set to UTC one. And this is true for all the sessions I use. If I connect to a separate database and I go into France and I do show time zone, what we're going to see here is that it is also UTC one. So how do we alter this? Well we can do something called alter user. Alter user is a command that is going to alter our user that we log in with. Now if you are on windows or Linux your user should be called postgres.
06:21:46.652 - 06:22:21.290, Speaker C: So you do something like alter user postgres and you would say set time zone equal to UTC. Now for those of you who are using Mac and you have the postgres app installed, you should align your username with the user you log in with on your Mac. In my case this is education. So if I say set education times on UTC and I execute this command, well now it's set. So has it changed? Let's do show time zone. Huh? Still Utc one. Well make sure to kill all of your connections and then reconnect to your database.
06:22:21.290 - 06:22:47.990, Speaker C: And now let's do show time zone again. All right, so we're aligned. All of our future sessions will now be in UTC. Now let's just make sure that that's the truth. Let's quit Valentina studio and let's reopen Valentina studio. And now let's reconnect to our database. Let's go to SQL and let's do show time zone UTC again.
06:22:47.990 - 06:23:19.832, Speaker C: Great. So now we've set that our user, the one we log in with to our database. Any session that user starts moving forward will show time zones in UTC. This is a very powerful command that does not affect every single user in your ecosystem. Now you could go ahead and set this at the server level and alter all sessions for all users to be UTC. By default it is done sometimes. But the most important part of this is that you individually can set your time zone to UTC.
06:23:19.832 - 06:23:42.344, Speaker C: If that's how you want to view dates and times. Now I hear you asking yourself, okay mo, I get it. We know about time zones. We know about GMT. We know UTC is the standard. We know how to set our time zone. And basically now we have a solid foundation for understanding how postgres interacts with time zones because postgres saves everything in UTC format.
06:23:42.344 - 06:24:43.850, Speaker C: And now that I've set my time zone it's going to show me everything in UTC format. But how do I manipulate dates and what does this matter in terms of me interacting with dates and times? Sometimes dates don't have times. And you are absolutely correct, you do not always have to store dates with time zones. But when thinking about dates we have to think about the holistic approach. Dates with times, dates without times, and what impact and what impact each of those have with how we interact with postgres. So let's look at some of the common ways that we work with dates and date times in postgres and how that affects how postgres stores and views your data and how you have to think about time zones. I see the light bulb going off in your head.
06:24:43.850 - 06:25:34.270, Speaker C: You're thinking to yourself, hey, I get all of this. I know what UTC is, I know why it's important and I know why I should use it. But then again, you may be asking yourself with this whole UTC thing, what does it look like? Well, postgres uses a standard called ISO 8601. It is a standard that tells us how we should format dates and times standard that basically says, hey guys, when you're working with dates and times, just show them like this. Just process them like this and everything will be straightforward. As long as we follow the standard. As long as we follow these rules, all applications can consume dates in the same way.
06:25:34.270 - 06:26:23.270, Speaker C: Now it stands to reason that ISO 8601 as a standard doesn't necessarily show you a date and time in the way that you would view it in your home country. For instance, me in Belgium, well when I lived in Belgium at least we would show dates day, month, year with slashes in between. But other parts of the world, like North America, they'll show dates starting with the month and then the date and then the year. Moving here was extremely complicated. I made many mistakes on many forms. That said ISO 8601 is a standard that we want to use on computers. It doesn't mean that when we send the date to the end user we can't still format it in the way it should look for them at that point in time.
06:26:23.270 - 06:27:21.800, Speaker C: But all along the chain we want to follow standards. And since we're in the database layer, since we're at this place where we're storing everything, we want to follow as many standards as possible so that all other applications that consume our data can base themselves off of the standards. And we are basically at the lowest possible level of data. We're storing it, we're holding it. So following these standards is of vital importance for us so that other applications understand how to consume what we give them. Now, how does that look? Well, when you use ISO 8601, we are looking at a format. Why? Why? Why? I can hear you thinking why? Why? Why am I working with dates and times? But trust me, it makes more sense than it looks in this obscure format.
06:27:21.800 - 06:28:32.920, Speaker C: Yy mm dd t hh colon Mmss. Alright, what does this mean? Well, this is the ISO 8601 format for date time, both the combination of date and time. And when we look at that standard as a format, what we see here is we would depict the 17 August 2017 as 20170 817 and then we would say the time is 1240 716 and then we could say plus 0200. So we're saying the time zone is a two hour offset from UTC. It's plus 2 hours. That makes sense. So in this one string we are depicting so much information, and by following a standard, we now have a standard way of saying, well, if this is the way things are going to come in, I know how to understand them.
06:28:32.920 - 06:29:13.680, Speaker C: Year, month, day, hour, minute, second time zone. So optionally behind this there is a plus with the time zone. This is optional because if you do not give it, it will assume that it is already in UTC. It does not have a time zone, therefore it is UTC format. The ISO 8601 is a document that specifies how things should be formatted. UTC is a time standard and not giving a time zone to something assumes that it is already UTC. Is all that making sense because it can become confusing.
06:29:13.680 - 06:30:14.530, Speaker C: In any case, always remember, UTC is a time standard. ISO 8601 is a formatting standard. It is a way to depict a UTC date and time in a uniform way, a uniform way for which we can understand it. And we already said that postgres at its core uses UTC and the way postgres will store date formats is in the standard of ISO 8601. Now a format is a way of representing a date and time. Make sure you remember this. A format is a way of representing a date and time because this is of utmost importance when understanding how we're going to format dates and times later and how we can translate our formats if we so have them into a UTC ISO 8601 format.
06:30:14.530 - 06:30:55.390, Speaker C: Now let's take a look at timestamps and how timestamps work. Because we've talked about UTC, we've talked about ISO 8601, we've talked about how we store dates and times in a representative way in a format, in a standard. But now you may be asking yourself, mo all I've seen in the database so far are like dates, they just have year, month, day. I haven't seen anything that contains time like you just showed me in that standard. Well, let's take a look at the data that can contain both date and time. And we call them timestamps. So let's zoom into that.
06:30:55.390 - 06:31:48.670, Speaker C: Timestamps, something we've been talking about throughout the previous videos was time zones and time zone information. We also talked about UTC and ISO 8601. So we know all about time zones and we know how computers want to store time information linked to a date. We know the standard that it's going to use to do that. But when we talk about timestamps, the definition is way more simple. A timestamp is a date with a time and potentially time zone information. So a timestamp is a date with a time.
06:31:48.670 - 06:32:49.560, Speaker C: And when we use timestamps, for instance, we do select now we get back a ISO 8601 formatted string, potentially with the time zone information depending on the time zone set in your postgres installation. So timestamps are one of those things that we utilize in order to store more granular information about our date. Say you wanted to store the last time someone accessed their account, they logged in. Well in that case you would want to store the time zone information and the timestamp information in order to trace where it came from and when it happened. So timestamps are one of those things that you can use in very powerful ways, but you have to decide when and how to use it. And when it comes to time zone information, we want to understand exactly how postgres handles this information. So let's take a look at that.
06:32:49.560 - 06:33:35.298, Speaker C: All right, so here we are in Valentina studio. And when it comes to timestamps, what we need to know is that how you decide to store your timestamp is of the utmost importance. So over here we haven't really looked at the create command or the insert command or how to create tables and insert information. But because we're tackling such a heavy topic, I thought it'd be important to jump ahead and show you some nuances. Now, the create table command creates a table, and over here you can see I'm creating a table, time zones. And what I want to show you is the different ways you can store timestamps. Because we know how to store dates and we know that dates hold year, day, month.
06:33:35.298 - 06:34:08.580, Speaker C: But when it comes to timestamps, you can hold so much more information. And so knowing that we have the ISO 8601 format and we have UTC. Well, what are the different ways we can store timestamps? Postgres comes with two, what we would call different ways of storing a timestamp. And over here you can see it, I have a t's, which stands for timestamp. And I'm storing a timestamp without a time zone. And I have TZ, which is a time zone column. And I'm storing a timestamp with the time zone.
06:34:08.580 - 06:34:40.372, Speaker C: And basically what this allows me to do is store a timestamp with its time zone value. So let's run this command back. And basically now my table is created. So let me comment this out. And over here at the top you can see I have an insert command. So now on the table I created, I want to insert some information. So I'm saying insert into the table time zones the following values and the order you give them in passes it into the order of the columns as they were defined.
06:34:40.372 - 06:35:14.590, Speaker C: So column 1234, the columns go in sequence. So the sequence in which the columns are created is the sequence in which the data will be inserted. So over here you can see that I'm inserting two values into t's. I'm inserting timestamp without time zone. And for both I'm inserting the year 2000, January 1 at 10:00 at minus five -5 hours UTC. So Toronto time. So I'm 5 hours ahead.
06:35:14.590 - 06:35:52.930, Speaker C: So this in essence would be 05:00, right? And in Tz I'm doing timestamp with time zone. Again, the same exact one. Now let's see what happens when I actually insert these values. So I executed that. And over here I have the selection, so let me run that back. And what I can see here is that when I select from time zones I have the t's and the Tz. Now, one visual difference we can immediately see is that with the ISO 8601 format, these are formatted differently.
06:35:52.930 - 06:36:19.654, Speaker C: Interesting. Tz has plus zero. Zero, huh. What is that about? Well, we know that by default postgres stores things as UTC values. And we set up our session to always show us the UTC dates and times. Okay, so when we inserted, we inserted with the time zone into TZ. Right? We inserted with time zone.
06:36:19.654 - 06:36:45.328, Speaker C: So over here we can see that. Huh? It's 03:00. Excuse me? It is 03:00 because ten plus five equals 03:00 not 05:00. I made a little pronunciation mistake there. But 5 hours ahead would be 03:00 in Toronto time. So this is indeed correct with the time zone, 5 hours ahead from ten, 1112. One, two, three.
06:36:45.328 - 06:37:20.570, Speaker C: So it's 03:00. So with the time zone we're getting 03:00. Okay, that sounds good. We're getting the time zone information and it's being offset when we insert it. But here's the nuance. You see how TZ has this extra information and t's doesn't? Well, when we created our table, we said t's is a timestamp without a time zone, and Tz is a timestamp with a time zone. So the way that we declared our column had a lot to do with the way that the column stored the information.
06:37:20.570 - 06:37:58.766, Speaker C: TZ stores the extra time zone information. T's does not. The second nuance that I wanted to show you is when we inserted timestamp without time zone, what we can see happen is that t's isn't storing the information with the additional time zone information, but also it didn't offset the time. It's still 10:00. Interesting. So there's two sides to this. The way you decide that your column is going to store information, decides how much information it's going to store.
06:37:58.766 - 06:39:10.698, Speaker C: When we say without time zone, we're not going to store that additional information. But on top of that, the way that we insert information is also of the utmost importance. Because when we say timestamp without time zone, basically what we're telling postgres is, hey, this minus zero five here, ignore that and act as if the timestamp that I'm giving you already UTC, even if it isn't. And when we say timestamp with time zone, we're saying, hey, postgres, this thing I'm giving you, it's in this time zone. So make sure that when you store it, because you're going to store it in UTC, make sure you take into account this extra information I'm giving you over here and you offset it back to UTC so that you're sure that you're storing the time I'm giving you correctly. So interestingly enough, when we define columns, we can define them in a way that stores more or less information. And when we insert timestamp information, we can insert it in a way that tells postgres, hey, ignore the time zone or take into account the time zone and offset the time.
06:39:10.698 - 06:40:21.878, Speaker C: Now, these are very specific nuances that may seem irrelevant, but when we work with time zone information, when we work with time sensitive information, we always want to make sure that we're storing information correctly and these little nuances can come back and bite you. If, for instance, let's say you accidentally inserted all of the information without the time zone, and now everyone's information that was inserted into the database didn't take into account their time zone, well, now you're going to have to go do a massive operation and figure out in which time zones which people live and go and offset every single date you have, potentially. So always make sure that when you're working with time zones and time sensitive information that you're inserting it in the right way. Now the question becomes, do I use timestamps or do I use dates? Well, it depends on what you're storing. Depending on what you're trying to accomplish, you may want to utilize timestamps. But for the majority of the cases, we often find dates because the granular information that we require isn't really necessary. Now, I've worked on apps where time zones were of extreme importance.
06:40:21.878 - 06:41:23.820, Speaker C: Depending on where the user was in the world and if they were cataloging certain sensitive information in the medical space, it became extremely vital for the doctor to know, hey, when was this administered? Where was this administered and at what time was this administered? Because it was medication. And so with things like that, timestamps are crucial. But then on the other hand, you have apps that use timestamps where they could actually be using dates. Now, it's easy to go from a date to a timestamp, and it's easy to go from a timestamp back to a date. But make sure that you pick the right one up front so that you always have the information you need. And with that being said, let's go dive into some date operators and start working with dates in a way that we can use to filter information and get back to supercharging our where clause know how. Because postgres gives us operators to help simplify dates.
06:41:23.820 - 06:42:16.750, Speaker C: And so let's zoom into those. And just so you know, those same operators work with timestamps. They work against both postgres and data operators. As we said in the previous video, postgres gives us operators to help simplify dates. And working with dates, and specifically dates and times can be extremely time consuming. So what we're going to do here is we're going to run through some of the most common operators that you would use when operating with dates. And after this video there will be exercises available where you can go and test out these operators against questions that will lead to queries.
06:42:16.750 - 06:43:05.482, Speaker C: So let's get into it. What if you want to get the current date? Well, if you want to get the current date, there are two main ways you can do it. You can do select now and you can cast it to a date, or you can do select current date. And what that will do is it will give you a formatted subset of the ISO 8601 date format. It will give you year, month and day. And so because it gives you year, month and day, you can quite easily get the current date to work against in other queries. You can utilize it to compare against the previous 30 days or whatnot, or anything that is today, any transactions that came in today.
06:43:05.482 - 06:43:52.820, Speaker C: So what if you wanted to format that? Well then you can use something called the Tochar command. And the Tochar command is used to format the current date. So you could give it the current date or now colon colon date, which is a cast date from a timestamp. So if you did to char current date, you could now pass it in a specific format. So in Europe it's often common to do slashes and do day, month, year. And if you did this with two char, what you'll see happen is you will format your current date in that format and it will come out this way. And feel free to pause the video at any given moment and go try this out in your Valentina DB or whatever editor you chose to use.
06:43:52.820 - 06:44:56.940, Speaker C: Now when we look at formatting dates, we saw that with ISO 8601 and with the Tochar command we're using d, m, and Y. And these are what we call format modifiers. So each modifier has an identifier, d being day, m being month, y being year. And if you go over to the postgres docs, what you'll see is that there is a whole list of patterns, identifiers that you can use that are going to give you a different type of format. You can do hour of the day from zero to 23, which is military time, or the twelve hour notation which is used most often in North America. You can format to seconds seconds past midnight. You can use aM PM syntax, you can do years, you can do ISO 8601, weak numberings.
06:44:56.940 - 06:46:05.686, Speaker C: There's a lot of different things you can do with the identifiers and formatting your date in a way that you want to see it. So you can basically use the Tochar command and format a date with all of these modifiers to kind of get the result you want. So if we were to, for instance, to see Ddd here, but let's go try that out. So if we said select current, select two char and we said current date, and we said, hey, format it to DDd, well, let's see what happens, huh? It gives us 142. Why does it give us 142? Well, let's go look at the docs again. Ddd is the day of the year, and if we used IDD, it's going to give us the ISO 861 weak numbering. So let's look at that, 144 and does that differ? Yes.
06:46:05.686 - 06:47:22.012, Speaker C: So there is a clear difference between some of these modifiers and how they choose to show you numbers and how they choose to show us certain information. If we wanted to know what week of the year it was, we could do ww and we would know that it is the 21st, 1st week of the year, for instance, based on the current date. So with all of that said, all of these modifiers, all of these format modifiers help you format a date in the way you want to see it. Now, what if we wanted to calculate the difference between two days? What if we wanted to say, hey, what is the difference in days between now and the 18 hundreds? Well, if you did a simple difference with a minus sign, what postgres will return you is an interval. It will tell you the number of days and hours, minutes and seconds that have passed since January 1, 1800. So this is a little useful for you to kind of do calculations here and there. Now, subtracting dates returns the difference in days.
06:47:22.012 - 06:48:04.650, Speaker C: That is something that you must keep in mind to date. So like we said before, not everything is considered a date, right? We know that these modifiers over here, they make a string or a piece of text. They give us text. But if we wanted to, for instance, say, utilize it as a date, we could cast it to a date. And using to date can help us cast it. So if you put date in front of the string, it will consider it a date. It will consider it to be of that value, but it will also format it at the same time.
06:48:04.650 - 06:48:53.202, Speaker C: Interesting, because as you can see here, this is invalid syntax for the format that we saw. That was ISO 8601. No, we're using slashes. So when we cast it to a date, it is going to cast it to an ISO 8601 date. It converts the date to a date format for postgres, which is the format that we learned, ISO 8601. Now, what if we wanted to calculate the age? Let's say we wanted to know, hey, how old is someone? Well, we have this little function right here called age. Well, you can pass it any date in history and it's going to tell you the age of that date.
06:48:53.202 - 06:49:29.218, Speaker C: But. Huh, something seems to be wrong here. No, we passed it age and we passed it to 1800 0101. But why are we getting an error? Well, let's take a look at that. So let's do select age and let's give it 18010 one. What does that give us? Age unknown is not unique. Oh, remember when we learned about to date of, we always have to make sure that we're casting something to a valid date.
06:49:29.218 - 06:50:23.332, Speaker C: So when we put date in front of it, what do we see here? 220 years old. That seems about correct. So when we calculate age, we have to make sure that we put a cast to date and then it will return us the number of years, number of months and number of days. Now, if you wanted to calculate the age between two things, age can take multiple parameters. So if I wanted to calculate the difference between my age and the 18 hundreds, then I could pass in my date of birth and I could pass in the 18 hundreds in whatever string format I want. Casting to a date will take into account whatever you filled in here and formatted in the right way. And what we can see is, well, it's 192 years, ten months and twelve days since I was born between the 18 hundreds.
06:50:23.332 - 06:51:15.822, Speaker C: So we can also calculate the age between two specific points in time. But again, it will return us an interval. So we may want to cast this to the amount of days, for instance, later on. So you can use a two char around this and go look at the formatter that's going to give you the amount of days, etcetera. There are many different ways you can go around playing around with dates. Now, if you wanted to extract the day from a date, you could use the extract keyword and select extract will give us the day from a date, which will give us 13. Now the parentheses here are very important.
06:51:15.822 - 06:52:13.066, Speaker C: Don't forget them as it will not extract correctly if you do not give it a specific parentheses around what you're trying to extract. So extract day from and my birthday will yield 13 as 13 is the day. And you can do the same with month by using the month keyword, which will return us eleven. And you can do the same with the year keyword by using it with extract as well, which will yield 1992. Now, you may be asking yourself, how do I round a date? How do I round down a date to a specific point in time? Because there may be use cases where you don't really necessarily care about the month and the day. You want to normalize them to the first day of the month, the first day of the year. Whatever the case is, you can use the date trunk function, trunk standing for truncate.
06:52:13.066 - 06:53:11.450, Speaker C: And when you pass it, a parameter, for instance, year, what it's going to do is it's going to say, okay, I'm going to take the year and then I'm going to set the month and the day to the lowest possible value, the lowest possible value being the first month of the year and the first day of the month. And with that we're truncating to the year. If we were to pass in month here, we would see 1990 2110 one. And why would you use this? Well, in certain cases, your boss would want to know, hey, can I get everything between the beginning of this month and the end of this month? And you could do, for instance, a date trunk against the month of the current date, instead of having to hard code a string. So rounding a date can be very useful in certain scenarios. Date trunk works in the exact same way. When you pass it month or day, it will round down the day to the lowest possible value, which is zero, one.
06:53:11.450 - 06:54:12.342, Speaker C: And if you pass the day, well, it's not going to do anything unless it was a timestamp, in which case it will set all of the values in the timestamp to zero. Is this starting to make sense? Date truncate will round down your date to the value that you pass in. So if you have a date, you can round down month, day, year. If you have a timestamp, you can do a more granular truncation, kind of saying, hey, for this date, I don't want to know about what time it is, I just want the date itself and so forth. Date trunk is very useful in that way. Now, the last thing we're going to look at is interval. And what interval does is it gives us an easy way to talk about time in a readable manner.
06:54:12.342 - 06:54:54.384, Speaker C: Now, let's say you wanted the date of purchase for the last 30 days. Well, we could say purchase date smaller than or equal to now, which is the current date minus the interval of 30 days. So now -30 days ago, if the purchase date is smaller than or equal to any purchase that happened 30 days prior in that 30 day time period, return them to us. So 30 days before the given date. So you can see how this is already more readable. It's easy to work with interval to do these types of things. Interval allows us to write queries in a way that mirrors language and that is extremely useful.
06:54:54.384 - 06:55:35.980, Speaker C: It can store and manipulate a period of time in years, months, day, hours, minutes, seconds, etcetera. Intervals are just useful that way. They're a keyword that allow us to write things in a natural language fashion. And the identifiers you get are years, months, days, hours, and minutes. You can say 30 years, 30 months, 30 days, 3 hours, 20 minutes, and you can say interval of that string and it will translate it for you. And when you do it, minus a date. So it's an easy way to subtract and add two dates to know how far ahead or how far back you should be looking.
06:55:35.980 - 06:56:48.536, Speaker C: So you could say interval of one year, two months and three days, or interval of two weeks ago, or interval of one year, 3 hours and 20 minutes. And because we're using the interval keyword, when we tell postgres to subtract or add this to a date or a timestamp, it's going to do all of the calculation of that math for us so we don't have to go ahead and calculate, hey, what is a year from now in 3 hours? And do all of that manipulation on a timestamp, like create a timestamp current date and then add and subtract to it? No, we can say plus interval of one year now plus interval of x. And it's going to give us a very, very easy, straightforward way to calculate dates in the future or the past. So can we extract with an interval? Yes, we can. If you say select, extract the year from interval, five years and 20 months, well, it's going to say that's six years, so it's going to extract six. Because 20 months is more than a year, you can adjust intervals. It can store and manipulate a period of time in years, months, days, hours, minutes, seconds, weeks, etcetera.
06:56:48.536 - 06:57:46.990, Speaker C: Intervals are just that powerful. When you want to do manipulations with dates towards the future or the past, make sure to keep in mind that you should use intervals. And with that being said, we have a bunch of exercises for you to test out all of these date functions that you can utilize. See you in the next video. Whew. We learned a lot so far. We went deep into dates and time zones and all of that material being so dense and so heavy, I thought it would be fun to learn a new keyword that does something fairly simple but very powerful.
06:57:46.990 - 06:58:35.252, Speaker C: And that is the distinct keyword. Now, as with all videos, we're going to look at the concept and how it works. And then there will be exercises around the distinct keyword. So what does this distinct do? Well, in essence, it removes duplicates. Sometimes you'll write queries where you do not want to have duplicate data. And with those queries, well, the one thing you can do is you can add the distinct keyword because the distinct keyword or distinct clause keeps one row for each group of duplicates. Huh.
06:58:35.252 - 06:59:35.350, Speaker C: Now how does that work? Well, when using distinct keyword, you can give it one column or multiple columns, and it will evaluate based on the combination of columns. And so it will remove any column that seemingly has the same values. If you used, for instance, distinct against age and date of birth, there may be people with the exact same age and the exact same date of birth. And if you're trying to catalog something in a way that you do not want duplicate information, well, then the distinct keyword will help you figure that out. So what would a use case be of using the distinct keyword? Well, that's a good question. Over here, I'm in the employees database, and I'm looking at the salaries of employees. And so let's say I wanted to select the distinct salary from the salaries.
06:59:35.350 - 07:00:30.284, Speaker C: Well, let's see what happens here. Well, first off, you can see over here that it's returning me a lot of data. It's returning me 85,000 records. But that being said, there are way more records than 85,000 in the salary database. So what we've done over here is we're only selecting the values that actually are unique. Now, what's the purpose of this, you say, well, there are many different purposes for which you can use the distinct keyword to get distinct information. For instance, if you wanted to know generally which age groups were working at your company, or information of that type where you're trying to say, hey, I just need a sense of the duplicates without the fluff.
07:00:30.284 - 07:01:21.770, Speaker C: I just need to know, hey, this is the range of information that I have. This is the range of x, y or z that is in the company. There are many different directions you can take a distinct keyword. One thing to note here is that when you use it against multiple columns, it can become a bit tricky. So if we say select distinct salary and then we want distinct as well on the from date, well, now we're going to have more duplicate data because it will only remove the duplicates that match both when you got it and how much it was. So as you can see over here, we have way more records. Why is that? Because a lot of people probably got a raise on the exact same day for the exact same amount because they were in a similar position.
07:01:21.770 - 07:01:38.490, Speaker C: So with the distinct keyword, you can get varying results based on how many columns you give in and what you're trying to distinct against. Now, there are exercises available that you can try out the distinct keyword in, and I'll see you guys in the next one.
07:01:40.910 - 07:01:43.582, Speaker A: Hey, those exercises are vital to your.
07:01:43.606 - 07:02:33.900, Speaker C: Learning, so don't skip them. So we've looked a lot, a lot, a lot at filtering. I've given you so many tools to use with filtering, and the material has varied from straightforward to extremely dense. Think time zones, but don't think about time zones. In any case, all of that is extremely useful. We know how to filter, but now we get into the next piece, sorting data. Do you remember when we were talking about the relational model and how it doesn't give you a specific order of information, it doesn't care about how the data is sorted.
07:02:33.900 - 07:03:33.260, Speaker C: It's just going to insert it. It's not going to sort alphabetically, it's not going to sort numerically, it doesn't care about sorting. Now, in some cases, if you do use a primary key, that is an auto incrementing or auto addition number, well, yes, every time you insert data, it's going to be 123456. But I, that is aside from the fact that actually in reality, relational model and relational databases don't really care about sorting. So how do we go about sorting data? How do we go about sorting certain columns and certain data in certain ways? Well, here is a new keyword, order by. This is a new thing that we add to our query. We had select we had from we had where, and now we have order by sorting data either in an ascending or descending fashion by column.
07:03:33.260 - 07:04:16.690, Speaker C: So it's either going to sort ascending or descending. What does that mean? Well, it's either going to sort from a to z or z to a, and depending on if you have a number from high to low or low to high. And if it's a combination of things, well, then it has certain sorting mechanisms to figure out, hey, if it's a date, well, lowest date to highest date, highest date to lowest date. So ascending or descending order by. So when we order data, we're going to be sorting it. So if we wanted to sort ascending, we would do something like select certain amount of columns from customers. And then we could order by name, which means it would go from a to Zenith, an ascending fashion.
07:04:16.690 - 07:05:18.340, Speaker C: And if we were to do this in a descending fashion, well, then we would use order by the column name and we would use the keyword descending to say, hey, go from z to a. Fairly easy stuff. Now what if you wanted to use multiple columns? Well, you could do something like select star from customers, order by name comma, last name descending. Now here's the trick question. Is it going to sort by name and last name descending, or is it going to sort by name, ascending and last name descending? Well, let's take a look at how that would work. So over here we're in our employees database again, and we have their first name and their last name from employees. And let's say order by first name comma, last name.
07:05:18.340 - 07:05:49.456, Speaker C: Alright? And we said last name descending. So let's see what happens here. So when we do this, we can see that order bye. Takes columns in the fashion they come in. So technically speaking, when we use order by, it's going to do it on a column by column basis. This does not apply to both of these. This only applies to the right most, which is last name.
07:05:49.456 - 07:06:23.530, Speaker C: So technically speaking, what's happening here is it's doing order by ascending. So first name, if you do not give it an identifier, it considers it ascending. This will yield the exact same results we just saw. Why is that? Because of what I just said. This only applies to last name. If we said order by first name descending, well, then we're going to see a very different result set. We're going to see it order by first name from z to a, and then last name from z to a.
07:06:23.530 - 07:06:56.038, Speaker C: So you're going to see last name, last name from lowest to highest with Alphabet. It's not from highest to lowest. It's from z to a, if you know what I mean. In any case, what we can see here is clearly that order by goes on a column by column basis and the identifier is linked to the column specified right beside it. Interesting. You can also use expressions with order by. We could order by the length of a name.
07:06:56.038 - 07:07:34.048, Speaker C: So let's try that out. Well, let's say we wanted to do first name descending. What we're going to see here is that we're going to go z. But what if we did length and we said go descending? Well, then we're going to see a very different name pop up. Whoa. Okay, so you can see here, you can use expressions functions with the order by clause in order to determine by what you want to go ascending or descending, very, very, very powerful keyword. And this is the extent to which that this keyword can be utilized.
07:07:34.048 - 07:07:54.712, Speaker C: It can be utilized to order your data in the fashion that you want it. And you can utilize this with your where clause to again, sort the filtered data in the way you want to visualize it. So it is a visualization tool. It's an easy way to say, hey, I filtered all this data. I did all this stuff. Now show me it in this fashion. Show me it in this order.
07:07:54.712 - 07:09:06.854, Speaker C: Because again, the relational model does not warrant you an order of the information. It's not going to give you first name and last name from a to z if you don't tell it to order it that way. Now, there are a bunch of exercises around order by, so you can go sink your teeth into those. It's time to expand on the knowledge we've gathered so far. So far, we've mastered filtering in many different ways, but the filters that we have used have been relatively simple in kind. We've been answering relatively simple questions, things that, although valuable, are simple in nature. Now, in a professional environment, the queries we will write are often much, much more complex and often involve multiple tables.
07:09:06.854 - 07:10:06.926, Speaker C: Now so far, all our exercises have involved a single table, a single question, and a single outcome. But what if we wanted to select data from multiple tables? I know you've been asking yourself this question, hey, what if I wanted to show an employee beside his salary? What if I wanted to show their information? I only see the id. Things like that go into what we call multitable selects. Multitable selects are combining the data from multiple tables in order to create a visualization that can span relationships, relationships across tables. So what if you want to combine data from multiple tables? Well, let's say we wanted to show the salary of an employee beside his information. Well, first off, let's start with a simple query. Right here in front of you.
07:10:06.926 - 07:10:55.106, Speaker C: You see a select statement, a very, very simple select statement. We see select a dot employee name concat a first name, a last name. So we're concating the first and the last name and b dot salary. So what are a and b? Well, when we go to the from clause, what we can see here is that we're selecting from the table employees, but we're creating an alias. Now, you've seen the as keyword being used over here in the select statement to generate a name for a column when we use a function. Well, that same principle can be applied to tables. Over here you see employees as a, a being an alias for employees.
07:10:55.106 - 07:11:56.448, Speaker C: So now we can alias any column that is an employees through a, like a employee number and salaries as b. So b, salary. Okay, so over here we see this relatively simple query. But what will happen here? Well, combining data is hard, right? So when we look at this, what we're doing is we're getting the employee number, we're getting the first and last name, and we're getting the salary. But what's linking it together? Well, what happens here basically is because we're not putting a link in place because we're not saying, hey, this employee number belongs to this salary. Employee number. When you execute this query, what's going to end up happening is you're going to assign every single salary from the salary table to every single individual multiple times.
07:11:56.448 - 07:12:54.904, Speaker C: So here you can see that George Facilio has 123-4567 and so forth. He has so many salaries. Why is that? Why would it add so many salaries to one person? Well, when you look at this from the relationship standpoint, table a, which was employees, and table b, which was salaries, are linked through a primary and a foreign key. What does this mean? Well, in employees, every employee is denoted by an employee number, our primary key. And in table B, every salary is linked to an employee number. So that means that each individual employee and his salary is linked to the number, but the number is a reference to the employee number. It isn't a different number.
07:12:54.904 - 07:13:26.008, Speaker C: It is the foreign key. It references the primary key. When we write this query, what's happening is, well, we're not saying anywhere that, hey, this key, this 20 is linked to this 20. We're saying, hey, select me Mobini and then select salaries. There's no link. But what if, what if we could use the where clause to create that link? That's a good idea. That's a great idea.
07:13:26.008 - 07:13:56.910, Speaker C: So let's try that out. Over here you see the same query, select a dot employee number, concat the first name, last name, get the salary. And then we see from employees and the same alias from salaries as b. And then we see a where clause. And in that where clause we're saying, hey, the alias of a. So a do it. Where the employee number in employees is equal to the employee number salaries.
07:13:56.910 - 07:14:29.834, Speaker C: Interesting. We can use the where clause to do something more than filtering. Well, this is technically a filter because we're saying, hey, only give me data back when the employee number of employee is equal to the salary that I'm trying to visualize. The employee number that's there. And what we see now is way, way less data. Okay. There are still 17, 1819 salaries because Georgie Facilo has had multiple raises throughout his career.
07:14:29.834 - 07:14:53.070, Speaker C: So we're seeing every single raise. But as you could see in the previous slide, his salaries were all the way in the 500. So there were way too many salaries being assigned to him. So let's try this out in Valentina studio. And so over here in Valentina studio, I've abbreviated the query a bit to be a bit simpler. We're only selecting the employee number and the salary. And so let's execute that real quick.
07:14:53.070 - 07:15:47.730, Speaker C: And this query still is going to take some time because there are thousands, if not hundreds of thousands of records. And so what we can see here is that we have all of the salaries linked to a specific individual where the employee number is given. So let's do something more. Let's do an order by the a dot employee number and let's just order the data so that it comes back in the right order. And so what we can see here is that starting at row 18, we're getting all of the salaries for each individual, meaning we're getting the salaries plus their raises, their initial salary, all the way up to their most recent raise. And if we added b from date, we would see that. We can see that each individual record of a salary is unique and it's going all the way up until the future.
07:15:47.730 - 07:16:32.950, Speaker C: But then again, when we did this, what we're going to see happen is way, way, way too much data being correlated because we're not doing anything, we're not linking, we're aggregating based on nothing. So each employee number is going to get each salary from bhidden. And you can see how long this query is running. I probably will run out of memory before it's done. So that's why we do the where clause, that's why we do the link, and that's why we get 17 salaries back. So you can kind of see where we're going here. When we have primary keys and when we have foreign keys and when we want to select from multiple tables, it's important to lay that link.
07:16:32.950 - 07:17:09.352, Speaker C: Otherwise you'll get into scenarios where you're aggregating data and for each record from a different table, it's going to add it to each record from the original table and you'll get 505,000 5 million results because it's just combining everything. Great. Good job. We did it. We got the right query. But what did we actually do? Well, we joined two data sets. We join them through the employee number, and a join combines columns from one table with those of another.
07:17:09.352 - 07:17:52.890, Speaker C: That is essentially what a join is. A join is a combination from one table with another table, and the combination happens to happen on the link between two pieces of data. In this case, the employee number from employees and the employee number from salaries, which happen to have a correlation. Now, joins take a column from one table that can map to the column of another table. That's a way to summarize it. So a join aggregates data from two tables, but it does it based on taking one column from one table that can map to the column of another table. Again, employee number to employee number.
07:17:52.890 - 07:18:33.724, Speaker C: The most common approach is to link the primary key to the foreign key. This is the most common approach of doing a join. Joins usually happen from a primary key to a foreign key. There are instances in which you could say, hey, the data in this table, well, these records can kind of map to these records coincidentally, and they may have the same data. This could happen if you're talking about cities and you have two tables that have cities and you just so happen to want to match them. It's not really a primary to a foreign key relationship. It just happens to be two tables that have data that is common.
07:18:33.724 - 07:19:13.788, Speaker C: But in 99% of the cases, I can't say 99%, but you get what I'm saying. In most cases, you're linking a primary key to a foreign key. Now, let's look at the different ways of joining data, because what we just did here, although it's awesome, it is a very basic way of doing a join. We use the where clause. We use the know how that we learn during filtering. But now you can kind of see that, hey, if this is something that is super common to do, there must be a better way of doing it. SQL must give us ways of joining data, and you would be right.
07:19:13.788 - 07:20:09.326, Speaker C: So let's take a look at those. First up is the inner join. Remember the case we were looking at with the salary of the employee and combining the data with the where clause? Well, inner joins are the type of join that we did there. If you have columns that link to a column from another table, you can use an inner join. And over here in the right hand corner, you can see exactly what an inner join does. What an inner join does is it finds the intersection of two data sets based on a link, and it returns you that subset. Now, I said a lot of words there that are very technical, but let me break it down for you.
07:20:09.326 - 07:21:15.044, Speaker C: If table A has 1000 records and table B has 1000 records, and we link employee number from table A to employee number from table B, and it's a primary key to a foreign key relationship. Well, if Table B only has the salaries or the ids for approximately 500 of the ids in Table A, well, then the matched is going to be 500 large. You see, the intersection of what you find between a and b depends on what you're trying to link employee number to employee number. For instance, we found multiple, multiple, multiple records and we also saw that they came back in different orders. So when we do inner joins, we're mapping columns from table A to table B. And the intersection that we find between a and b is what we will show you. Now, here is what we did.
07:21:15.044 - 07:22:18.590, Speaker C: We used the where clause to apply a link a join. But this syntax is familiar from filter. What if I told you that there was a different way of doing this exact same thing? Well, all SQL languages come with a syntax to do joins because joining is such a common practice. Joining is a crux of being able to answer questions across your data when you have large data sets. Well, finding answers to complicated questions, you can't just be working in one table with one slice of the data and then taking that data and then going somewhere. No, you have to be able to take data from one table, take data from another table, and kind of relate them to each other in some way. And so because that is such a common thing, we have a syntax called inner join.
07:22:18.590 - 07:22:49.244, Speaker C: Inner join is the exact same thing that we did with our where clause. Okay, so let's break it down. Let's go through it over here with our where clause. We could see that in the from, we were selecting from table A and table B employees and salaries. And in the where clause we were doing the filter to kind of match employee number to the salary employee number. And then we got our intersection. But if we use the join syntax, it changes slightly.
07:22:49.244 - 07:23:33.328, Speaker C: It changes in a good way though. When we do our select, we're selecting the same exact data. And when we do our from. Well, here's where the first change comes in. You see, when you do a join, you have to decide what's going to be on the left side and what's going to be on the right side. Meaning where am I selecting from and what am I trying to join it with? Well, if the question is I want to have the salaries by employee, then I'm going to select from employees and I'm going to join salaries to it because employees is the main part of the data that I'm trying to get. So deciding what's going to be on the left and what's going to be on the right is always an important question.
07:23:33.328 - 07:24:04.646, Speaker C: Where am I selecting from and what am I trying to join to? Now here, what I'm trying to join to is the employee to his salary or her salary. So when I do from employees a, well, here's the syntax. I do an inner join, same principle as the where clause. But again, we're doing an inner join and we're saying inner join the table salaries as b. We're not adding salaries as b to the from clause like we did over here. We're not doing this anymore. No.
07:24:04.646 - 07:24:57.750, Speaker C: Inner join says, hey, inner join this table to the one in the from clause and give it an alias. Okay, so we know that this is the same as doing the comma salaries as b. Now how do we do our where clause? Well, there is no where clause on an inner join. When you say inner join, you're saying inner join this table to the one in my from clause and do with on. So join salaries on employee number. Okay, so how do we read this? Well, we know we're selecting the employee information in the from clause, but when we do an inner join, what we're saying is link this table to this table and do it on the employee number. So over here you can say what you want to join on.
07:24:57.750 - 07:25:27.560, Speaker C: Makes sense. You kind of read like a sentence, what do I want to join on? I'm joining salaries to employees on the employee number. It's the exact same way to do what we did with the where clause, but it reads more nicely. So the inner join syntax is generally considered a best practice. It is more readable than using the where syntax. It shows you what's being joined. It's great.
07:25:27.560 - 07:26:20.160, Speaker C: Now, like I said, the results always come back unsorted. So when you do a join, make sure that you order by the employee number. If we go back to our example here, we could see that when we used our where clause, we weren't getting the data back in the order we expect. See, we have the very first person, but then we go all the way up to 10,005. And so if we do order by a employee number, suddenly we'll get them back in the right order. This is because you cannot deterministically say how something is going to join. The, the relational model does not warrant the order of the data, so it is up to the query to sort the data.
07:26:20.160 - 07:27:18.854, Speaker C: So that being said, knowing that you have to order your data, especially when you do joins, they kind of go hand in hand. Now here's a curveball. What if I wanted to know the salary of an employee, but only the ones that led to a new title? You see people get salary increases year over year, kind of like the percentage base or whatnot. But rarely do you get a salary bump that leads to a promotion in title. So what if we wanted to do that? What if we wanted to know the raises from a promotion using inner joins? Well, we know that employees links to salaries through employee number, but title changes link to salaries through the from date. You see over here, we're already doing something a bit different. We're combining inner joins.
07:27:18.854 - 07:28:06.270, Speaker C: We're selecting from multiple tables. We're adding a third table to the mix. This is a nice curveball for the query, but how would we solve for this? Well, what if I told you that title changes always follow two days after the raise? So if title changes always follow two days after the raise, we kind of know how to write our query, but it's going to become complex. So right here on the right hand side, you can see what we're doing. Employees salaries, titles. And through the inner join there is going to be a very tiny intersection of data that we matched. But how would that look? Well, if we were to select from three tables, you can see the query over here.
07:28:06.270 - 07:28:38.972, Speaker C: Select a dot employee number. We're concatening the first and last name. Still we're getting salary from the salary table. We're getting the title from the title table and we'll get the from date from the title table so that we know when you were promoted on what date. So we're joining employees to salaries on the employee number of a. Okay, so that's very simple. We already did this one.
07:28:38.972 - 07:29:24.496, Speaker C: We know that we're going to get the salaries, we know that we're going to get each salary for each employee, including all the raises. But now we need to know when there was a title change. So we do a second join and we're joining the table titles as c. And so now we know that title changes always follow two days after arrays. Okay, so first off, each title is linked to an employee number. So we need to make sure that we link the employee number from the title to the employee number that we're trying to find. So the employee number that we're cycling through in employees is the one we're going to link to the title.
07:29:24.496 - 07:29:51.420, Speaker C: We need to make sure that we don't link every title to every employee. Right. We know this because when we join data, we need to join on something that is known. We know now that we're going to find the salary by the employee, and we're going to find the title by the employee. But now here's the curveball. The title change always follows two days after the raise. So the on keyword works just the same way as the where clause.
07:29:51.420 - 07:30:20.610, Speaker C: So we introduce an and. Okay, so when we introduce an and it's working the same like it does in aware clause, we're saying, hey, where the employee number in titles is equal to the employee number in employees. Find me the title. Okay, so we'll know the title for each salary. Let's try that out. All right. So here we are in Valentina studio, and we have part of our join over here.
07:30:20.610 - 07:30:45.600, Speaker C: What you can see is we're selecting the employee number, the salary, the from date, and the title. And we're taking all of the employees from a. We're joining the salaries on employee number, and now we have titles. So let's go look at the schema of titles. We can see that it has an employee number, which is a key reference. We have a from date, that's a key reference. And then we have a title, which is also a key.
07:30:45.600 - 07:31:38.938, Speaker C: So interestingly enough, we have a lot of data to join on. Okay, so over here in our query, we're looking at titles. And what we can see here is that if we join a employee number to c dot employee number, what's basically going to happen is we're going to join everything on the employee number, but we're going to get way too much data back because we're not syncing on the unique title. So what you can see here is that we're getting all of the salaries for 10,001. Huh. Interesting. And then we can see that we're getting all the salaries for 10,002.
07:31:38.938 - 07:32:00.796, Speaker C: Looks okay so far. And then the same for 10,003. But then here we hit 10,004. And we can see that because he has had a title change. Now the data starts going wonky. Interesting. Okay, so in 1986, in December, he was an engineer, and then he was also a senior engineer.
07:32:00.796 - 07:32:14.236, Speaker C: And then the same in 87. And the same in 88. No, no, this data isn't making sense. Okay. So you may be thinking to yourself, well, if we looked at the schema, there was a from date. Ha. And it was a key.
07:32:14.236 - 07:32:55.690, Speaker C: And salaries has a from date. That's a key. Okay, so let's join those two to each other. So let's say, and b dot fr om date equals c from date, what will this give us? So when we execute that, what we're going to see now is that we're getting the unique salaries back. Okay, so we're getting the right salaries. We can see that 10,000. But what happened? Weren't people getting incremental raises? What happened here? Well, what I can say is that title changes always happen two days after a raise.
07:32:55.690 - 07:33:51.610, Speaker C: So how would we go about doing that? So what we see here is basically their starting salary because it's the salary they started with. And if we go to salaries table, we can basically verify this. If we go to the titles table, we can see that they took a 10,001, took senior engineer on the 26th and 10,004 was an engineer on the 12th and became a senior engineer in 1995. On the 12th. Okay, so we know what their title is supposed to be at a given time. So let's go look at their salaries. So if we look at their salaries, what we can see here is that 10,004 started at 40,000 and went all the way up in 1995 to 60,000, but he went up on the 29th.
07:33:51.610 - 07:34:52.340, Speaker C: Yet in the titles table, what we can see here is that his title changed on the 1 December, but he got his raise on the 29 November. So two days after. Well, luckily we learned a lot of date functions. So if we say b from date plus interval, two days and we equal that, what would we get now? Well, now we're getting all of the employees that ever got a title change. Interesting. Okay, this makes sense. So we're getting the intersection of all of the data for the titles that matched arrays.
07:34:52.340 - 07:35:18.600, Speaker C: Good. So these are all the title changes and salaries that were linked to a raise plus title change. If we remove the two days we got their initial salary, their salary that they came in at when they were hired. Also. Interesting. But that doesn't solve for the particular case we were trying to solve for. This is why we said title changes always follow two days after arrays.
07:35:18.600 - 07:36:16.460, Speaker C: And that is why we use the interval. Now, what if you want to know the original salary and also the salary at the promotion? Well, let's take a look at that. Well, we know that if you do the, and with the interval we're going to get specifically the raises with a title change. So what if we do and, and just do this? Will that do it? Huh? What's happening here? Seems like we're not getting any data back. Why is that? We have on employee number c and we have our and statements. So what exactly is happening? Well, it's not really an and, right. Remember and or not.
07:36:16.460 - 07:37:20.694, Speaker C: This is actually more of an or statement. So what we want to do here is we want to say or we want it to be either equal to the from date or a race that came two days later. So let's execute that. And what we see now is we're getting their salary when they came in, as well as the salary when they got a raise and a title bump. So we've answered that question. We now know both when they were hired, what their salary was, and when they got their first promotion or second promotion or third promotion with a title change, what their salary was at that point. So when we do the inner join on titles, we can use the on statement as a where clause has a way to filter against this subsection.
07:37:20.694 - 07:37:55.440, Speaker C: We can narrow down the matched data in the inner join in the on clause. It is the way that we can determine, hey, only match the data when these parameters are met. And so joining data also works as a filter, right. It basically is a filter. Okay, we're joining two tables, but we're also using it to filter our results a certain way. Only return me data that matches this way. That's how inner joins work.
07:37:55.440 - 07:38:55.678, Speaker C: And so if you took the query here and you executed it, what you basically would get is something along these lines. You would get their name, their salary, and when they got a raise, which is basically the exact same thing that we saw happen here. And we can see when they got their title bump. Now, inner joins can become complicated as you add more tables, when you want to combine more data, more tables, more cases, inner joins can become quite difficult. But just remember the principles of always use inner join as a best practice. The on is where you start linking data together. And 99% of the time, I can't say 99% of the time, but, you know, most often it's a primary key to a foreign key relationship in which we'll find that sweet subsection of data that is correlated or related in a certain way that can answer a question we're trying to answer.
07:38:55.678 - 07:39:38.928, Speaker C: Now, you may be asking yourself, okay, I get the inner join. I get what it's trying to accomplish, but what kind of other joins can I do? Let's take a look at those. The next type of join, we're looking at self joins. Joining a table to itself. I know it sounds crazy. It is crazy, right? How would you do that? Does a table have a reference to itself? Mo, you just told us that primary keys and foreign keys are the main way to join. What is this all about? Hear me out.
07:39:38.928 - 07:40:14.326, Speaker C: This usually can be done when a table has a foreign key referencing its primary key. I can hear you saying, mo, you're crazy. This isn't a thing, and I can most certainly assure you it is. It's not super common, but it can happen. There can be a foreign key in a table that references the same primary key in the table. Let's say you had a table where you had employees and the employees had an id. Now you have Mo here and you have Andre.
07:40:14.326 - 07:41:10.064, Speaker C: And let's say that Andre was the CEO of the company and I was an employee. And let's say that we in that same table kept a reference to a supervisor id who is supervising who, who's who's manager. That was a weird sentence. Who is the manager of whom in the table? Now in this case, you can see that Andre is a supervisor of Mo, but Andre is also the supervisor of himself, meaning that he reports to himself, basically. Although this is an uncommon scenario because normally you would have some kind of manager table that would keep references to these things, there is something to be said for simplicity. In some tables, in some databases, it's easier to keep a reference to itself. There are guaranteed scenarios out there where you would do something like this, and this is just one of them.
07:41:10.064 - 07:41:59.660, Speaker C: Now let's say you wanted to see the supervisor's name. You didn't want to see it by id because in the example I gave you, sure, there were only two people and we could clearly deduce who's who. But let's say you had 500,000 employees and you had multiple levels of supervisors and you wanted to see the supervisor's name beside the person because you wanted to see who they report to. Well, here is the solution, self join. This works the same way that the original inner join worked that we did where we used the where clause. You see, we're still going to use the from. There is no special syntax for a self join, but what we're going to do here is we're going to select from the same table twice.
07:41:59.660 - 07:42:45.750, Speaker C: We're going to say from employee as a and employee as b, and we're going to say where a dot supervisor id is equal to b dot id. So let's go look at that. So over here you can see I'm in db fiddle and I have this exact query running that we just typed out of. And if we run that back, what we can see is that we have Andre Mo and the boss man. And the boss man reports to himself because he is the boss man. But Andre reports to the boss man and Mo reports to Andre. This is the exact scenario in which a self joint is useful.
07:42:45.750 - 07:43:32.948, Speaker C: Now, could we do this with an inner join? Of course we could. If we said here, inner join employee, and we said on and we ran that back, we would basically get the same results. Why is that? Well, a self join is the same thing as an inner join. Inner joins are just joining data and trying to find that middle intersection. But a self join is all about joining a table to itself, because a primary key and a foreign key are in the same exact table. If you ever come across a case like this, you know that you can use a self join to accomplish this. And a self join is nothing more than joining a table to itself.
07:43:32.948 - 07:44:54.670, Speaker C: It's not a different type of join necessarily, but it is possibility for you to join a data set to the same data set, as long as you have a primary key and a foreign key in the same exact table that reference the same exact information. In this case, supervisor id being a foreign key to employee id. Knowing that and knowing that self joins are just a variant of the inner join, where you join a table to itself, we now know how to join a table to itself. Alright, on to the other fun joins. Outer join. Here's a what if I also need the rows that don't match? That's a good question, right? You see, with the inner join, we answered the question of what is the intersection I'm looking for? What is the correlation? What is the subset of data that I need to answer my question. And now the question becomes, what if I also need all the rows that don't match? What if I also want to see those? You see, with our filter, what we basically went towards is that middle point.
07:44:54.670 - 07:45:41.258, Speaker C: And what outer joins try to do, as opposed to inner joins, is also take into account everything outside of that inner puck that we were looking at. Outer joins add the data that don't have a match. Now, what does that look like? Well, let me tell you something. There are two types of outer joins. Remember when I told you that when you join data, you have to decide what table is going to be on the left hand side and what table is going to be on the right hand side? Well, there are two types of outer. There's a left outer join and a right outer join. Now, with the inner join, we were aiming for this golden intersection.
07:45:41.258 - 07:46:28.220, Speaker C: We just wanted the things that matched our join. Now, what a left outer join does, or a left join. We also call it a left join is you can see here that I've highlighted table a in blue, while a left outer join adds the data that doesn't have a match from table a. From the table that we put in the from clause. When we talk about on the left hand side of a join, we're talking about the table that is in the from statement. When we talk about the right side of the join, we're talking about the table that is being joined. So when we do a left outer join, we're joining the data that doesn't have a match for table a.
07:46:28.220 - 07:46:54.436, Speaker C: Now, the syntax looks something like this. Select star from table a as a, and then you can decide. This is just a matter of preference. You can type left outer join, or you can type left join. They mean the exact same thing. Some people prefer to type left join. Some people prefer to type left outer join.
07:46:54.436 - 07:47:30.080, Speaker C: Decide which camp you want to be in. It doesn't really matter at the end of the day. So you left join table b as bhdem. And we use the same syntax on a id is equal to b dot id. Now what this left join is going to do is it's going to say, okay, let me find everything where a dot id is equal to b dot id. That golden intersection we talked about that the inner join gives us. But what the left join is also going to do is it's going to say, well, everywhere where I couldn't find an a dot id.
07:47:30.080 - 07:48:04.112, Speaker C: I'm just going to return that data to you. I'm just going to show you those rows. Some values may contain null because you can't find a correlation with b. Some of those columns that you're trying to join with, they may not have a value, they may be null. And we know from the three valued logic, nulls are a contentious thing. But it's okay when you're joining because we can coalesce, we can value substitute. So any value that does not match is made to be null.
07:48:04.112 - 07:48:44.980, Speaker C: So let me give you a problem statement. What if you wanted to know how many employees aren't managers? What if that was the question? How many employees aren't managers? Well, here's a query for you. Select count employee number from employees as EMP. And we do a left join on the department manager table. And we're going to call it as Dep. And we're going to say on EMP, employee number is equal to depth employee number. So from our inner join we know that that golden intersection is going to be everyone that is a department manager.
07:48:44.980 - 07:49:32.520, Speaker C: Now here's the nice part, because we're doing a left join, that golden intersection we talked about here is empnumber is equal to DepMP number. So those are all the department managers. But because we're doing a left join, we're also getting all of the people that aren't department managers. So we can say, hey, on top of us doing that join, filter out all of the ones that are nullified in department employee number. So when we do the join, we're going to see that a bunch of them are going to be null. So let's go look at that real quick in Valentina studio. So here we are in Valentina studio, and you can see part of the query that we're talking about here.
07:49:32.520 - 07:50:08.548, Speaker C: So if we execute this, we can see that the left join has a bunch of null values because not every employee is a manager. So a bunch of them aren't managers. So there are a bunch of null values. So who is a manager? Well, let's take a look. We can use the where clause to filter where depth empnumber is not null. And if we execute that, we'll see that we have 24 managers. So 24 of those people our managers.
07:50:08.548 - 07:51:01.130, Speaker C: Okay, that's easy to count because we can just, there's not a lot of information. But if we did is null, now we can count on EMP do employee number. And what we'll see is we'll actually get the count of the amount of people who aren't a manager, which is 300,000. So the left join allows us to take into account everyone that didn't match against department manager. Now, you could have done this in multiple steps with multiple queries and done a subtraction on your calculator or whatnot. But what we're trying to get here is in the groove of allowing SQL to do the hard lifting for us. And for that, we need to know a couple of basic concepts, how to work with the data, what exactly we're looking for, and how that can work in our benefit.
07:51:01.130 - 07:52:15.750, Speaker C: Now, now that we know how the left outer join works and how it can benefit us, what if I gave you a different problem statement? What if I told you we want to know every salary raise and also know which ones were a promotion? You see, our previous query we just looked at, hey, these ones are promotions, and these ones were the base salary, the salary they came in at. But what if we also wanted to see every other raise that wasn't a promotion? Well, let's take a look at that. All right, so over here, we had our original query, which was the two inner joins, and we inner joined employees on salaries and titles. And we had the original salary that they came in at in the original title. And if they had ever gotten a promotion, we also had that salary and title. Now, what if we wanted to also include all of the salaries that didn't account for a title change? How would we do that? Okay, well, let's think about this logically. So we want all of the salaries that didn't account for a title change.
07:52:15.750 - 07:53:23.060, Speaker C: So we don't want to be strict on the titles. So let's make that a left join and let's see what happens. So what we can see here is that we're expanding that golden intersection to also include all of the salaries that aren't necessarily linked to a title or a from date. If the employee number for some reason doesn't match on top of this statement, we're still going to see it. So now we can see all of the raises that an employee ever got up until the point that they became a senior engineer. For instance, you can see here coming in as an engineer and becoming a senior engineer, there were quite a few raises for 10,004. All right, so now that we know that, we know how left joins can be powerful, and we could even go so far as to coalesce the title and say, if it is null, no title change.
07:53:23.060 - 07:54:06.716, Speaker C: And that just adds to making the data a bit prettier. There we go. All right, so here we can see a more elaborate solution than the one I just showed you. But what we're basically trying to accomplish here is trying to say, hey, when a join is trying to allow all the things on the left side to be included, that may not align with the specific join. That's what a left join is for. It's saying, hey, everything that is null on the left side, if it doesn't match this criteria, just show it as well. So we're showing everything that is also not linked to specifically a title change, because title changes only happen with raises or when you join the company.
07:54:06.716 - 07:54:41.030, Speaker C: But raises aren't linked necessarily to title changes. So we're seeing all of the salaries linked to that person and specifically when that salary was linked to a title change, when they came into the company or when they got a promotion. Now, feel free to pause the video and go execute that query and play around with it. And you can see when their title changed. And you can see over here the coalesce function. So we didn't add in our alternative column value for this one. Now, you may ask yourself, okay, we saw left outer join.
07:54:41.030 - 07:55:36.040, Speaker C: What are right outer joins? Well, right joins add the data that don't have a match from table b. So, on the right side of the join, if something in title didn't match what came out of employee number in the employee table, we'd see all of the null values for table B. It's basically the opposite of a left join, and it basically has the exact same syntax as a left outer join, except it uses right outer join. So with that, you now basically know the difference between right outer join and left outer join. They are the inverse of each other, but one acts against the table that is being joined and the other acts against the table that is joining. So, for instance, the left outer join goes against the from statement. The right outer join goes against the table that is being joined.
07:55:36.040 - 07:56:16.636, Speaker C: The table that is in the join statement. Any value that does not match is made to be null. Again, exactly the same, like a left join. Now, let's take a look at some of those joins that you won't see very often. Let's talk about some joins that you won't see very often. And the reason you won't see these very often is they're just not used that often. So we're not going to spend too much time nailing down in which specific edge scenarios you may or may not use them.
07:56:16.636 - 07:57:00.198, Speaker C: But just to give you an idea of what they do and what they are, it's important that we summarize the purpose and the outcome of both of these joins. So these join techniques just aren't used that often. It doesn't mean that they can't be used, and it doesn't mean you may not find the scenario in which you could use these. It is completely possible that you'll see these out in the wild. It's just not that common of a join in business cases. The first one that we're going to talk about is the cross join. Now, the cross join creates a combination of every row with every other row.
07:57:00.198 - 07:58:05.514, Speaker C: So if you had 1234 and you had one, two, you're basically going to create a table that is going to add every row from table B with every row from table A. We call this a cartesian product. You may have seen this from math or somewhere else, but basically it's a combination of everything with everything. And when you combine everything with everything, what you're going to see is very, very, very large data sets. So let's take a look at that over here we're in Valentina studio, and let me create a table called Cartesian A, and in that table we're going to put just an id column as a number, and let's create a table Cartesian B that also has that. So let's execute these two commands, and now let's comment them out. So now what we want to do is we want to insert data into these.
07:58:05.514 - 07:59:35.586, Speaker C: So if we do insert into Cartesian A, and we said values one, and let's do this a couple of times because we want a couple of values in here, two, three, and now let's do this for Cartesian B and let's say one and two, and let's execute these. Now, we have our data in our tables, so let's go look at it. So if we select star from Cartesian A and we cross join Cartesian B, what are we going to see here? Well, we're going to see the following. We're going to see one to one, one to two, two to one, two to two, three to one, three to two. So we're cross joining every value from a with every value from B, and this is what we call a Cartesian product. We're creating every possible variation. And so if you have thousands and thousands and thousands of records, well, basically what you're going to see is that cross join of all of that data, with all of that other data.
07:59:35.586 - 08:00:27.740, Speaker C: Not so useful in scenarios where you have massive amounts of data, but there are use cases that you could come across. So now that we know that the cross join returns us the Cartesian product, or the combination of every row with every other row, we know the use case for it, we know what it does, and we know that it might not be as useful in most cases. The next one we're going to look at is the full outer join. Now, we've looked at the left join and the right join, and what we know is that whether you do a left or a right, you're basically going to be returning the values that don't match from the right side or the left side of the join. What the full outer join does is it returns all the results from both sets whether they match or not. So let's take a look at how that would work. Over here.
08:00:27.740 - 08:01:31.406, Speaker C: We still have our Cartesian and we can use this to do a full join. So if we did a full join and we added an alias for b and we did a dot id equal to b dot id, well, what we're going to do here is we're going to join on one, two and one and two. But what's going to happen? Well, we're going to return the values that don't match. In this case we had three, but let's look at some more elaborate cases. So let's add some more data to our table so we can see what's actually going on. So we've inserted a bunch more data into our table and if we now go and we do our full outer join again, what are we going to get? Well, we're going to see that everything that doesn't match is also returned. So we're creating a combination where we're saying, hey, if this matches our on statement, well then return me the match.
08:01:31.406 - 08:02:35.010, Speaker C: One and one and two and two. Match three doesn't have a match in table b, four doesn't have a match in table b, and five doesn't have a match in table b, and 20 doesn't have a match in table a, and 30 doesn't have a match in table a. So we're joining, but we're saying, also return me all of the results that don't have matches, which creates more potential null values. Now, the reason this is less common is you may not find many scenarios where this data is useful to you. Most questions a left join or a right join will answer for you. And so knowing that we know the less common joins that you may see, and there are even more joins out there, there are some database managers that implement joins that you won't see that often, but the ones we covered here are the most common, the most used, the most seen, and with those joins you can accomplish the most value. And with that being said, we can now jump into some amazing exercises around joints.
08:02:35.010 - 08:04:03.180, Speaker C: Join syntax is one of those things that we are going to use very, very often, because a simple table only contains so much data. So we find ourselves joining data very often. And in what ways can we simplify the join syntax? Well, there are a couple of different strategies, and for the most part, I would suggest always sticking with the on keyword because you can mix and match and do complicated matches. But there is one case in which, hey, if we're doing a straight shoot of comparing primary key to foreign key from one table to the other, and both tables are having that same column, if you're comparing, for instance, employee number to employee number, well then there's an easy way to write down that join and you don't need to use the on keyword, and I wanted to give that to you in the cases where you're just doing a simple join exercise or whatever, or trying to test something out. So let's take a look at what that looks like. So over here, you can see that I'm selecting employee number, first name and department number from employees. And I'm joining department employee.
08:04:03.180 - 08:04:41.446, Speaker C: And as you can see over here, I'm doing as de, but I'm doing something else. I'm nothing doing the on keyword where I would do on de dot employee number equals e dot employee number, which would give me the same results. I'm basically saying, hey, Kyoshi works for department three and mary works for department nine, etc, etcetera. No, no, I was doing using. So using is saying, hey, I have this column in this table and this table. So, hey, just compare those. Just do it for me.
08:04:41.446 - 08:05:28.348, Speaker C: Make it easy. When I execute that, what's basically going to happen is the same exact thing. Okay, so that simplifies us, comparing a primary key to a foreign key relationship on a column that exists in both places. But I see you thinking, hey, mo, but what if I wanted to get the department name here? It's a good question. Let's see what that looks like. So if we did inner join here and we said, let's inner join departments as D and let's do the using, we know that based on our schema, department employee has a department number and departments has a department number. So could we just do department number? Well, let's see what happens when we do that.
08:05:28.348 - 08:05:51.120, Speaker C: Because you told me using is like for the simple primary foreign key relationship. So let's execute that, huh? Okay. Okay. So what if I do d department name. So let's see, what is the department name? Depth name. So let's see what that's about. D dot department name.
08:05:51.120 - 08:06:25.608, Speaker C: So if we execute this, what we'll see is, huh, interesting. So we're getting Marie working in customer service and Alain working in production. Moss working in production, Danielle working in development. Interesting. So the using keyword can be used to easily match primary to foreign key relationships. And that's a good thing. It makes it easy for us to say, hey, I'm just trying to compare and this to this other thing.
08:06:25.608 - 08:07:10.644, Speaker C: And the using keyword is one of those easy ways. Now, I would still suggest using the on keyword the majority of the time. It just makes it easier and I think more readable to know what's going on. And you can selectively say which tables you want to reference. And there's less ambiguity there because as you get to more and more and more joinsd the using keyword can become confusing as you reference the table directly. You know what you're trying to compare to what, and as your joins become more complex, you may get into weird situations. With that said, the using keyword is a very powerful keyword and you should always try to use it where you're doing simple joins.
08:07:10.644 - 08:07:20.600, Speaker C: So it works the same exact way as the on keyword, and it just helps you clean up your code sometimes clean up your query. Awesome.
08:07:21.620 - 08:08:12.504, Speaker A: Congrats on finishing the crash course. You just took a huge leap forward in achieving your goal and you proved that you're up for any challenge. Now's the time to roll up your sleeves and dive even deeper by taking the rest of Mo and Andre's complete SQL and databases boot camp course, which has a lot more exercises waiting for you. The full course is just about 26 hours long, so just imagine how much more there is to learn. Oh, and the best part, by joining zero two mastery, you get access to our private discord community where you can get help from experts like Mo, Andre and the rest of our instructor team. Click the video on your screen to get a glimpse of our supportive community. One last thing, I promise, if you enjoyed this video, the least you could do is show Andre and Mo some love by dropping this video a like and leaving a comment with your thoughts, questions or feedback.
08:08:12.504 - 08:08:17.000, Speaker A: That's it for me today and I look forward to seeing you inside the zero to Mastery Academy.
