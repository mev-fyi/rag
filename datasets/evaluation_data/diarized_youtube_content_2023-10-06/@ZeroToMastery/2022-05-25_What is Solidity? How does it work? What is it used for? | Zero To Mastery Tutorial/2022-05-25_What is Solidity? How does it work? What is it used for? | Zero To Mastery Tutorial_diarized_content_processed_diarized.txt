00:00:05.360 - 00:00:43.540, Speaker A: So all this talk, but we haven't actually coded yet. But we can finally get into the fun part. Let's write some smart contracts, and for that we'll be using solidity. If you remember, smart contracts basically consist of these opcodes that are instructions for the Ethereum virtual machine. And yes, we could start writing these opcodes directly and maybe sometimes there are even crazy people out there doing this. But for normal people like us, we need something that is much easier to understand. Solidity is here to help us.
00:00:43.540 - 00:01:26.360, Speaker A: This language is written specifically for smart contracts, so it has a lot of features that make only sense in the context of blockchains. You may think it looks a bit like JavaScript, and it's true. The syntax is similar, but otherwise they are quite different. For example, a solidity is strongly typed, unlike JavaScript. That means every variable has a predetermined exact type. So a variable could be of type, string or integer, for example. If you're wondering what this means, variables are how we reference data and the type tells us how to interpret the data.
00:01:26.360 - 00:02:13.490, Speaker A: So how do we use solidity? Well, what solidity actually is, is a compiler called Solsi. If you're using tools like truffle or hardhat, they are using the solsee under the hood. And the compiler takes the solidity code and compiles meaning, transforms the code into the mentioned opcodes, an application binary interface, in short ABI and a metadata file. So the opcodes for contract looked something like this. Okay, not really, I'm kidding. This is japanese. But they may as well look like this because you won't understand much more anyways.
00:02:13.490 - 00:02:45.110, Speaker A: Unless of course you are one of the few that can read Japanese. This is what they actually look like, just a long list of opcodes, not really understandable, like I said. Unless again, you are one of the few that actually can read this. Then kudos to you. And then we also have this bytecode here. This is what the smart contract actually is. So this is the data representation of this.
00:02:45.110 - 00:03:39.520, Speaker A: And yeah, this is now really only understandable for a machine. And then along with the opcodes, the compiler also gives us this ABI, which stands for application binary interface. This is a bit more readable, but you're not really meant to read it yourself. It's required though, because if you only have the opcodes here, how will you know how to interact with the contract? You can't directly read what functions the contract has. And so the ABI tells you exactly all the functions in this contract, what data they expect, what data they return and how the data is encoded. So you'll need the ABI of a contract if you want to interact with it. So it's kind of like having interpreter in between the smart contract and you.
00:03:39.520 - 00:04:16.120, Speaker A: The interpreter can translate in both ways. So now you understand what the contract says and the contract understands what you say. And lastly, the solidity compiler also generates contract metadata. This file contains all information you can imagine about the compiled contract. So things like the compiler version, the source code, the ABI, and additional documentation. This metadata file is quite useful to verify the source code of a contract without relying on Etherscan.
