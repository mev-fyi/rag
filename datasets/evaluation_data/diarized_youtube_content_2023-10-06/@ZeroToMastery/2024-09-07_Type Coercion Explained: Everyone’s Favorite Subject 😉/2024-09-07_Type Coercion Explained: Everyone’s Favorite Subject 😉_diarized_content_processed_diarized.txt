00:00:07.520 - 00:01:36.032, Speaker A: Ah, type coercion. If there's one thing that's going to make you pull out all your hair out of frustration, it's type coercion. If you googled type coercion in JavaScript and looked at some of the posts, you're going to see a lot of people angry at some of the funky things that JavaScript does, and we're going to talk about that and I'm going to just give you a brief overview of it, because it does get really convoluted, complex, and it's something that you should understand and know what it is, but you don't have to know every single detail because most of the tricky parts, well, you shouldn't be using it in your code because it's confusing. So what is type coercion? It's something like this, one equals to string one and that equals to true. You see, type coercion means that when the operands that is, the things to the left and to the right of the operator are different types, that is number and string type, one of them will be converted into an equivalent value by the JavaScript engine. So the JavaScript engine is going to say one equals to string one. I think you mean number one.
00:01:36.032 - 00:02:50.108, Speaker A: So it's going to do this for us and compare number one to number one. Now, based on that definition, type coercion means the language converting a certain type to another type. Let me ask you a question, do all languages have type coercion? What do you think? Yes, they do, because we always need to convert types between programs to do things in memory. Different types look completely different than what we type, right? The number five in actual physical memory on my computer is represented in ones and zero, and all languages do this. So there is some sort of type coercion at different levels of the stack. It just so happens that JavaScript has an especially heavy type coercion nature to it because it's dynamically type, which is why it does this. Let's go back to the example in JavaScript.
00:02:50.108 - 00:03:59.156, Speaker A: Type coercion happens when you use the double equal double equal sign simply means compare the two values and if they have different types, try to, well, curse one into the same type. If we go back and do a string here and I do three equals and I run, I get false. Because three equals in JavaScript means compare two values, but don't try and coerce the values. Be explicit with your comparison and do exactly what I tell you. So is there ever a time you should just use two equals instead of three equals? I would say that. No there isn't. Some people may argue that double equal can actually have some interesting applications where we coerce something and we do some sort of checking really quickly, but it's not predictable code, right? It can be confusing.
00:03:59.156 - 00:04:25.529, Speaker A: It could really be a gotcha and trick. Some people so always use three equals instead of two. Now type coercion doesn't happen just with the equal sign. You can also do an if statement. So if one, then return five. And if I run this oh, there's no function in here. Let's do console log.
00:04:25.529 - 00:05:19.390, Speaker A: I've been recording for a long day today, all right? So give me a break everybody. All right, if I run this, five is logged. Why is that? Because JavaScript courses one to equal true. What if I do zero here? If I do zero, nope. JavaScript coerces this and says well I want a boolean here, so I'm going to take your zero and turn that into a false. Now this sort of type coercion, there's a lot of interesting specifics to it, and as a matter of fact, there's a nice little website that shows you some of the comparisons that JavaScript does with three equals, that is, with no type coercion, things make sense. You see that false equals to false and that's it.
00:05:19.390 - 00:06:04.308, Speaker A: You can see that string false only triple equals, and returns true with string false again. But if we do double equals, well, oh boy, that's just a mess, isn't it? For example, string one is the same as true. An array that contains one is also true when it's compared to string of one. And there's so many weird little edge cases here. If you want to play around with this, go for it. But I like to stick with triple equals. You can also see some of the if statements here and some of the if cases.
00:06:04.308 - 00:06:52.330, Speaker A: That can really be tricky. Now if we go to this MDN page, which I will link to in this video, we see that we have the double equals, the triple equals, but then also something called object dot is. That's fairly new to JavaScript. And this is an interesting one that you most likely won't see very often, but I think it's interesting, so we're going to talk about it just quickly. You see, in JavaScript there is a concept of negative zero and plus zero. Strange, I know. So if I do negative zero, triple equals plus zero and I run, I get true.
00:06:52.330 - 00:08:32.616, Speaker A: But they're technically different things in JavaScript, so I can actually do object is and give it the two parameters and run and I get false. Now why is this useful? If we go back to this page, we see that object is works pretty much the same as the triple equals, except for a few cases that is the plus and negative zero. And if we scroll all the way down to this funky little n a n, not a number, and we can do a whole course on how weird this not a number is. But if I did not a number which represents not a number in JavaScript and I do triple equals not a number, I get false. But why is that? This is, this should be equal, right? So if we use object is, this turns into true again, most likely in your day to day programming life, you're never going to encounter this problem, but I wanted to demonstrate for you how confusing type coercion can be. And if you're the type of person that just loves type coercion and wants to read all about it and understand all these intricacies, I'll link to the actual spec that talks about how the equality comparison algorithm works for me. If I read this, it'll be a good bedtime reading to make me fall asleep.
00:08:32.616 - 00:09:07.068, Speaker A: If you're interested in it, you can have a look. The main takeaway from here is that, well, you should use triple equals, because type coercion in JavaScript can be really tricky. By the way, as a fun little side note, this is a screen capture I took from Netflix watching this great hilarious documentary, and you see that bugs in the code are unavoidable. Even the mighty Netflix every once in a while has an issue somewhere. Not a number. All right, that's it for now. I'll see you in the next one.
00:09:07.068 - 00:09:07.348, Speaker A: Bye.
