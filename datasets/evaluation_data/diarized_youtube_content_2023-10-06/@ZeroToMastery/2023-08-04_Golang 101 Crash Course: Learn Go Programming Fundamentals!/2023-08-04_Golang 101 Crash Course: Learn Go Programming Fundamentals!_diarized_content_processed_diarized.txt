00:00:04.320 - 00:00:46.594, Speaker A: Hey, has the buzz around go caught your attention, but youre finding it a tad intimidating to learn? Or maybe youre a complete newbie looking to learn go from the ground up. Well, brace yourself my friends, because youre about to start your journey of learning and mastering go, and you couldnt have found a better resource for it. Now let me tell you why. Reason one, you get to learn from Jason Lennon. Jason is a world class instructor who started as a self taught developer and then he transitioned into a university student. This gives him a unique ability to understand the struggles of being self taught, but at the same time, he comprehends how difficult it can be to understand complex subjects at a higher level. Needless to say, he can relate to wherever you're starting from.
00:00:46.594 - 00:01:30.716, Speaker A: Reason two, Jason is a firm advocate of the practice makes perfect philosophy. This means that you won't just be passively listening to lectures like some other YouTube courses. Instead, you'll be thrown straight into the action with plenty of hands on exercises scattered throughout the crash course. Reason number three your learning doesn't have to stop here. This crash course is actually part of Jason's complete Go programming bootcamp course. So once you finish this video, make sure to check out his complete course where you'll learn many more advanced topics, all the way to even being able to get hired as a go developer. One last thing, if you're liking this content and are finding it helpful, please drop it a like it really helps us out and it shows us that you want us to keep delivering more great free content for you guys.
00:01:30.716 - 00:01:36.680, Speaker A: But enough chitchat for me. Let me hand it over to Jason so you can start your journey of learning. Go. Enjoy.
00:01:45.740 - 00:02:31.760, Speaker B: Hello and welcome to the ZTM Golang course. In this introduction, I'll be talking about the Go language, why you would want to program in Go, and a little bit about the course itself. So why would you want to program in go? Go is an in demand language used by high profile companies such as Google. It's simplistic and easy to understand by design. It has built in dependency management, including a package registry similar to the JavaScript NPM ecosystem. It also has a familiar C style syntax, so jumping in and learning Go is really straightforward and easy to do. A few technical features about the Go programming language are that it has first class concurrency primitives, and this makes the language perfect for backend programming such as making web servers.
00:02:31.760 - 00:03:13.028, Speaker B: The Go language also has type safety, which is enforced by the compiler, so you'll be able to write your code as if it's like C, but then you'll get type checking as if you're writing C, hash or Java. This helps make programs much easier to write and tracks down lots of bugs. Go is a memory safe language, so you'll never get any use after free bugs. It accomplishes this by using garbage collection, so there's no need for you to manage any memory. Go compiles down to machine code for very fast speeds, so your programs will always run extremely quickly, even though the language is garbage collected. Since everything is running at machine code speed, the garbage collector overhead is very minimal. Here's a little bit about the course.
00:03:13.028 - 00:03:49.270, Speaker B: We have lectures, demos, and hands on coding exercises. We'll be working with the Go CLI, which is used to manage your project, and we'll be utilizing the Go package ecosystem and its generated documentation. Since Go is a lower level language, we'll be covering concepts such as pointers, memory, and concurrency. If any of these are unfamiliar to you, don't worry, I'll be talking about them in enough detail to make you more comfortable with them. That way you're able to fully utilize the Go language. In addition to the regular exercises, we also have recap exercises which will cover an entire section. This will help solidify your knowledge about the topics learned in that section.
00:03:49.270 - 00:04:29.440, Speaker B: And finally, at the end of the course, we'll be building a fully functional GUI desktop application. Thank you for watching this introduction and I hope you'll enjoy my course on the go programming language. Ill see you in the next video. Congratulations. You have just been hired at KeikoCorp as a software engineer. KeikoCorp is a Silicon Valley tech giant with multiple clusters of applications powering mobile and web services. KeikoCorp's services have been increasing in popularity and are in need of some performance tuning.
00:04:29.440 - 00:05:08.156, Speaker B: Your boss, Bruno, this guy here with the perfect hair, has tasked you with rewriting KekoCorp's services to be more efficient. This is a big task. KeikoCorp relies on these services for their core business, so there is no room for failure. But this is your first time optimizing applications. How are you going to increase the efficiency of Keiko Corp services? Don't worry, we are going to be learning the go programming language, which was designed to build efficient services. Over the next few weeks, you'll learn how to program and go, which will help you achieve the task that has been assigned to you. Bruno is confident that he made the right hiring decision, but he wants Keiko Corp services optimized yesterday.
00:05:08.156 - 00:05:50.020, Speaker B: We better get to work. In this video, we'll be going over the installation of the Go toolchain and Visual Studio code. The first thing you'll do is open up a web browser and navigate to go dot de v dot. Once the page loads, click on the download link under featured downloads. If you're on Windows, click on the link for Microsoft Windows and click on Save file. Save it wherever you like. Once the download completes, open up the installer, click on next, click the checkbox, and click next.
00:05:50.020 - 00:06:25.970, Speaker B: I'm using defaults so I just click next all the way through and then click install. Once the install completes, click finish. After clicking finish, your go toolchain is ready to run. Next we'll be installing Visual Studio code and its extensions back in your web browser. Navigate to code dot VisualStudio.com dot click on the download for Windows link, wait for a moment, and then click on Save File. Save it wherever you like.
00:06:25.970 - 00:07:03.820, Speaker B: Once the download completes, open it up. You'll need to accept the agreement and click next. I use defaults for everything, so I just click next all the way through and then click on install. Once the installation is complete, make sure the launch visual studio code button is checked and click on finish and it may take a moment to launch the first time. Once visual Studio code loads, we're going to click on the extensions button on the left. We'll type in go and it should be the first results in our extensions and have several million downloads. We'll then click on the install button.
00:07:03.820 - 00:07:53.860, Speaker B: After you click on the install button, we'll need to open up a go file in order to finish the installation. To do so, we can go back to the getting started page and click on open folder and open up the course content materials that you've downloaded. I saved mine into my documents, so just navigate to it. Then click select folder and then open up any of the go files. You'll have a pop up that says install or install all just click on install all this installation process may take a lot of time as there are a lot of tools to download and install in order to get visual studio code set up for Google programming. Once your installation finishes, click on always update if you get a pop up and you should see in your terminal that the tools have been successfully installed and you'll have a message that indicates you're ready to go. Once you see that message, then everything is good to go and we can start the course.
00:07:53.860 - 00:08:42.050, Speaker B: In this video we'll be talking about packages and modules. Packages and modules will be encountered as soon as you start writing go code, so it's important to have an understanding of how they work packages are Go's way of organizing code. Programs are written as one or more packages, and packages can be imported from the Go package registry. Packages should be focused and perform a single thing. Some examples of good packages are argument parsing, drawing graphics, and handling HTTP requests. For each one of these packages. You would just want it to do the single task that it was designed for, and if you needed to do something else, you can just create a new package.
00:08:42.050 - 00:09:36.260, Speaker B: To use a package, all we need to do is write the import keyword in our code followed by the name of the package within double quotes. Since packages are so commonly used in Go, we can batch import many packages at once by using the import keyword again followed by parentheses. Each line would be a package, so we have the name package along with the namespace package name package. It's customary in go code to have a namespace and then your package name. That way if you have multiple packages, they'll all be listed under the same namespace by default. Whenever you import a package in Go, we have to refer to the name of the package in your code. If you don't want to do this, we can use a dot before the package name and we'll be able to access all the functions and structures contained within without having to type in the name of the package.
00:09:36.260 - 00:10:03.150, Speaker B: We can also rename package imports. So for example, on this second line here we have package name as the name of our package. However, that's kind of a long name, so we can just refer to it as pk. So in your code you'll just be typing pk instead of package name. Now lets talk about modules. Modules are simply a collection of packages. Theyre created by having a Go mod file in the root directory of your project.
00:10:03.150 - 00:10:31.732, Speaker B: The Go mod file can be managed by the Go CLI, and it contains information about your project, which includes dependencies, the Go version, and the package info. All Go projects have a Go mod file. Here's an example Go dot mod file. We have the module keyword followed by the name of the module. Here we're using the namespace of example.com, but you can use whatever you like. So this module would be named practice, and this is the namespace example.com
00:10:31.732 - 00:11:04.460, Speaker B: dot. We then have the go version indicated here, so we just type the word go and the current version that we're using or whichever one you use to compile the program. Next we have a require block and we're using parentheses just like we did with the imports. Each one of these lines here in the require block is going to be a package along with the version that we're using within our code. You can see here we have to use the entire namespace, so we have GitHub.com party color. Color would be the name of the package, and this entire section is the namespace.
00:11:04.460 - 00:11:36.660, Speaker B: As previously mentioned, the namespace can be anything you want it to be. However, it's customary to include the URL in the namespace. That way people can easily find your code. To recap packages are gos way of organizing code. Packages should be a single program or single purpose library. Packages can be published to and imported from the Go package registry. Modules are just a collection of packages, and they're declared by having a go mod file, and this file can be managed by the go Cli.
00:11:36.660 - 00:12:24.590, Speaker B: In this video we'll be talking about data types, including primitive types and type aliases. So first let's cover exactly what a data type is. All data in programs consists of binary numbers, meaning zero or one. A data type is just the way that the program can interpret the binary numbers. Numbers, letters, and words are all different data types. Some examples of different data types are 15, the letter y, and the word hello. Go is a statically typed language, so data types in Go must be provided by the programmer.
00:12:24.590 - 00:12:57.050, Speaker B: Go uses a technique called type inference to determine what type of data it is working with. This means that data types only need to be provided in specific circumstances, and you can always specify the type if you want. If you do specify the type and you end up using the wrong one by accident, you'll get a compiler error. This is how the Go compiler is able to provide type safety. In Go, all primitive data types are numeric. This means that they're simply a stream of bytes. The type indicated in the code is simply a convention.
00:12:57.050 - 00:13:31.836, Speaker B: It is possible that the data is invalid for the given type, but this only applies when you're working with user input or if you're manually manipulating the binary data itself. So for the most part, the type that's indicated in the code is the correct type. Let's cover a few different types that are available. First, we'll talk about signed integer types. Assigned integer is just a number that is an integer, and it could be negative or positive. And here's a listing of the available integer types that are in go. Along with the ranges, we also have unsigned integer types.
00:13:31.836 - 00:14:11.726, Speaker B: Unsigned integers are integers, but they're positive only, and they include zero. And here's a listing of the ranges for unsigned integers. At the bottom here we have the uintptr, which stands for unsigned integer pointer, that will be the pointer size on your current architecture. What that means on 64 bit systems is the UNT PTR type will be a UN 64. On 32 bit systems it'll be a UN 32, etcetera. Some other data types that are available are the float 32 which is a 32 bit floating point number. Floating point numbers are just decimal points.
00:14:11.726 - 00:14:43.624, Speaker B: We also have float 64 which is a decimal point number with enhanced accuracy. We also have complex 64 and complex 128 which includes real and imaginary parts. And then we have a boolean which is simply true or false. We can also make type aliases. What a type alias does is simply assign a new name to an existing type. This is useful to provide an indication of what kind of data is being utilized down here. We have some examples of type aliases.
00:14:43.624 - 00:15:11.902, Speaker B: We have the type keyword along with the name that we want to provide as a type alias. And then the original type will be the third part of the statement. So here on the second line we're creating a new type alias. We're calling it direction and we're assigning it the byte type. For the third one we have the speed alias and that's going to be a float 64. And you can have type aliases on top of type aliases. So on this last one we create a new type alias.
00:15:11.902 - 00:15:40.060, Speaker B: We name it velocity and we set it to be the type of speed. And we know a speed is a float 64. So here the velocity is actually a float 64. The primary reason for doing this is to make your code easier to read. So instead of just having a function using float 64, we can have the name velocity. So we know exactly what we're working with. We can also convert between different types using parentheses.
00:15:40.060 - 00:16:15.324, Speaker B: So here we have two type aliases. One for user id, which is an integer, and one name speed, which is a float 64. If we wanted to create a new user Id, we just supply the name of the type, some parentheses and then the underlying value that we can use. Since five is an integer, we'll be able to create a user Id. The same thing goes with speed. We have the word speed parentheses and then we have a floating point value within the parentheses and that will create a new type of speed. Let's recap.
00:16:15.324 - 00:16:51.180, Speaker B: A data type is a way to specify how data should be interpreted by go. Go uses static typing which is checked at compile time. The compiler uses a technique called type inference, which automatically determines which type to use. Type aliases can be created to give new names to existing types. And here we have an example of how to do it, we use the type keyword followed by the name that we want along with the underlying type. Converting between types requires parentheses. So if we want to convert an integer to a user id, we just have the name user id parentheses, and then we have the number five as our integer.
00:16:51.180 - 00:17:36.242, Speaker B: In this video, I'll be discussing strings and runes, including text encoding. About runes and about strings. First, let's talk about text encoding. Textual data in go uses utf eight encoding. And encoding is a way to represent thousands of different symbols using code pages. Code pages are tables which use the first few bytes of data to determine which page to use, and each symbol in the code page is called a code point. Let's take a look at an example code page.
00:17:36.242 - 00:18:03.428, Speaker B: If we look at the lowercase d here, we'll see that we're at code .1 and three. So to create a d, it actually takes two bytes. In this case, we have to have a one and a three down here at the bottom. If we want to create this japanese character, we'll have to use four f followed by one. So this particular character here takes three bytes, four f and one in. Ago.
00:18:03.428 - 00:18:34.064, Speaker B: When we work with strings and runes, we're actually working with individual bytes, not letters themselves. So it's important to understand that letters can consume more than one byte. Now let's talk about runes. Text and go is represented using the rune type. This is similar to char in many other programming languages like circumental. Roon is just an alias for int 32, which is just a 32 bit integer. Since runes are just an alias for INT 32, you're actually just working with numbers whenever you're working with a roon.
00:18:34.064 - 00:19:06.378, Speaker B: This includes when you try to print out messages using runes. In order to print the actual character it represents, you'll have to use a special formatting operation which we'll cover later. Runes can represent any symbol, and this includes letters, numbers, and emoji. Let's take a look at how runes are represented in memory. Here we have two green rectangles which represent int 32s. Each one of these blocks are eight bits, which adds up to 32 bits. We have here on the bottom the number of bytes.
00:19:06.378 - 00:19:59.740, Speaker B: So here's the first byte, second byte, third byte, and fourth byte of a 32 bit integer. To represent the capital letter Q, we have to have 51 in our position, one byte to represent the zigzag. We have to have this combination of bytes in these specific locations in order to get a zigzag. The reason this is important is because the letter Q is only one byte, the zigzag is three bytes. But if we were to try to iterate over each letter, we'll actually be iterating over each one of these bytes instead of the entire letter itself. Once we get to the section on looping, we'll be covering how to iterate over the actual representations instead of the byte values. Now that we've covered runes, let's take a look at strings.
00:19:59.740 - 00:20:29.860, Speaker B: A string is a data type for storing multiple runes, and strings are just an array of bytes and a string length. There is no null termination with a go string like you have in c. When iterating a string, iteration occurs over bytes, and bytes are not symbols. As we previously seen. Special iteration techniques are required to retrieve these runes and symbols, which we'll be covering in a later lecture. Let's take a look at how strings are represented in memory. On the left we have some runes.
00:20:29.860 - 00:21:01.748, Speaker B: We have a bitcoin, the number three, a right arrow, and a cent sign. Each one of these runes has a specific bit length. On the right we have a string which is just a combination of all of these runes. This particular string is nine bytes long. We have three bytes from the bitcoin, one byte from the three, three bytes from the arrow, and two bytes from the cent sign. So if we were to iterate through the string, we'd be going one byte at a time. And if you split these bytes in half, then you won't have a bitcoin anymore.
00:21:01.748 - 00:21:30.830, Speaker B: You'll have some different symbol. Recall that runes are just numbers. And since a string is composed of runes, a string is just more numbers put together. Let's take a look at how to create some runes. So to create runes in code, you surround the rune that you want to make with single quotes. So here we're creating a rune, a rune r and rune seven. You'll see also that we can create an omega symbol, a ruby symbol, and a one two symbol.
00:21:30.830 - 00:22:10.616, Speaker B: Instead of using single quotes like we're using here, we're using backticks. The backtick symbol is next to the number one on your keyboard, and you'll need to use it whenever you're trying to type a symbol that isn't present on your keyboard. So basically, anything that's not a through z, one through nine and zero, and any of these symbols, such as the sign, dollar sign, percent sign, those are all okay to use these single quotes. However, everything else you'll need to use backticks. If you aren't sure if you need to use single quotes or backticks. You can just always use backticks and you'll get the symbol that you're looking for. There is one exception to this, and that is escape symbols.
00:22:10.616 - 00:22:53.780, Speaker B: Escape symbols start with a backslash, so backslash n will turn into a new line, and we'll see here in the string shortly that they'll be highlighted in your editor so you'll know if you're working with an escape sequence. To create strings, we'll use double quotes. So here we have amount is â‚¬22 followed by an escape sequence which is backslash newline. So this string will have a newline at the end. And we can also put a single letter within a string using double quotes. So here we have the letter k and that's a string instead of a rune, even though we could just make this a rune since it's a single letter. Since we want a string in this case we can use double quotes and that's fine.
00:22:53.780 - 00:23:36.846, Speaker B: Lastly, we have the raw literal, and a raw literal is surrounded by backticks. Youll want to use raw literals whenever youre working with strings that have single quotes in them or double quotes. The reason youd want to use these backticks is if you have double quotes within your string. Since the double quote is used to create strings, if you want to include them in your string, either have to escape them with a backslash or you can just use a raw literal. I recommend using a raw literal since its much easier to read the string without a bunch of backslashes. One thing to take note with the raw literal is everything you type in here is going to come out as is. That includes this escape sequence here.
00:23:36.846 - 00:24:09.402, Speaker B: Notice how this one is highlighted in purple and this one is the same color as a string. That's because when we type a raw literal, it's going to type everything literally as you see it. So we're going to get a backslash and an n in the output instead of a new line. So here we have a new line because we're just using double quotes. And here we have a backslash n because we're using raw literals. It doesn't apply any processing to your string, so it's just going to come out however you type it. Let's recap.
00:24:09.402 - 00:25:05.956, Speaker B: Text in Go is encoded using Utf eight. The roon type can represent any individual symbol, and roon is just an alias for Integer 32, and they are created using single quotes. The string type contains a series of symbols as bytes. Strings are not null terminated, and they are created using double quotes raw literals are created using backticks, and whenever you type something in a raw literal, it'll come out exactly as typed. In this video I'll be discussing the go CLI tool along with a few of the common commands that we'll be using throughout the course. The Go tool chain provides the Go command line utility. This tool is used to update dependencies, build and test projects, manage, build artifacts, and format source code.
00:25:05.956 - 00:25:31.494, Speaker B: So basically everything you need to do to work on a Go project, the go tool will help you out. Let's take a look at a few everyday Go commands. The first one is build. Build will build the project and emit an executable binary. Build is the command you'll want to use when you want to distribute your project. The next command is build race. What that will do is check for concurrency problems.
00:25:31.494 - 00:26:15.578, Speaker B: So if you've written a concurrent program in Go, which is really common since it's so easy to do, you always want to check your source by using build race, and it will emit any errors if it finds problems. Next up we have the run command. The run command will just run the project directly without emitting an executable binary. This is useful when you're testing code or when you're working through the exercises as part of the course. The mod command manages your modules and dependencies, specifically your mod go file, and the mod tidy command will clean up that file if there's any errors, and download and update any dependencies that your project relies on. Next we have the test command, which runs the project test suite. It's always a good idea to write tests for your code.
00:26:15.578 - 00:27:04.688, Speaker B: That way you can ensure that it maintains the proper logic after updating it. Lastly, we have the format command short, FMT for short that formats all your source code files, and usually this will be automated with your ide, but you can always run it manually if you so desiree. In this video I'll be talking about variables. I'll be discussing what variables are, how to create them, the comma ok idiom, and naming and constants. So let's talk about what variables are first. Variables provide a way to store and access data in your program. The data within a variable can be anything or, and it can vary, which is where it gets the name.
00:27:04.688 - 00:27:38.130, Speaker B: Variable. Variables are simply an alias to some data in memory, and it makes it easier to access that data. When you store data into a variable, it's called assignment, so you'll be assigning data into variables. Variables have multiple components. We have the name of the variable, the data that's part of the variable, or lack thereof, and a data type. There's multiple ways to create variables, and in this example we'll just be creating a single variable. So we'll use the var keyword to create a variable.
00:27:38.130 - 00:28:31.072, Speaker B: We'll give it a name. This one is named example we'll use the equal symbol to assign a value, and in this example we're assigning three, so the number three will be assigned to the example variable. We can also use type annotations as in this example. So we're creating the same variable now we're giving it the int data type, and again we're assigning it three. In the second example, since we're using a type annotation of integer, if we try to assign a string such as hi, then we'll get a compiler error because hi is a string and it's not an integer. In this third one we're creating a variable named example and we're setting the data type to int. However, we're not assigning any value initially, so this will be considered an uninitialized variable and it'll get a default value if we fail to assign to it.
00:28:31.072 - 00:29:03.952, Speaker B: In this case we are assigning to it. So in the second line we have example three, so we're assigning three to the example variable. And again, if you forget this line, then this will be equal to zero, which is the default for an integer. We can also create multiple variables at the same time. So here we're creating variables a, b, and C, and they're separated by commas. We have our assignment equals sign. Then we're assigning these to one, two, and the string sample.
00:29:03.952 - 00:29:46.918, Speaker B: So a will be a one, b will be a two, and C will have the string sample. This way of creating variables makes it really simple to assign multiple different data types to multiple variables. We can also create multiple variables using a block. So if we have the var keyword and parentheses, everything within this block will be created as a variable. So we'll create an a, it'll be an integer and we'll set it to one. We'll create the variable b, also an integer, we'll set it to two, we'll create the variable C and assign it to sample. We didn't include a type annotation here, and that's because the compiler uses type inference.
00:29:46.918 - 00:30:30.888, Speaker B: So it will see that we're working with a string because we have double quotes and it will assign a string type to c down here. After this block we'll be able to use a, b, and C as individual variables as if we had created them one line at a time. We also have a create and assign shortcut. This is done by having the name of the variable, and then we have a colon equals and then the value. So this is what you'll commonly see in go code because it's shorter and easier to write and you get type inference as well. So this example variable will have the value three assigned to it because we're using the create and assign operator. We can use the create and assign operator with multiple variables as well.
00:30:30.888 - 00:31:00.722, Speaker B: So we have a and b. A will be one and b will be the string sample. Here's a little bit more information about variables. Variables can be reassigned and assigned to other variables. So here we're creating variable a or assigning it the value of one. Later on in the program we can then reassign two to the value of a, and then we can also assign three into the value of a. Remember that this is the create and assign.
00:31:00.722 - 00:31:34.504, Speaker B: And since a has been created right here, we no longer need to create it again down here. So we can just use equal to assign it. Over here on the right, we have a equal to one. We then create a new variable b and we assign it to the value of a. So b will be one because one is inside a, and since one is in a, one will not be in b. And we can also use the var keyword to create the variable c and just assign it to b, which will also be one. Whenever you do this, we're creating a copy.
00:31:34.504 - 00:32:19.798, Speaker B: So even though we have an a, if we were to change later this a into a two, for example, b will still be equal to one because we just copied the data that was in a, we created this variable. It's just a copy of a, or putting that copy into b. The same thing goes for c down here. So when we do create a new variable c and assign it to a copy of Bde, variable names can only be used once per scope. What this means is here we're creating a variable a assigned it to the value of one. Later on we try to create variable a again using the var keyword and assign it to five. This won't work, so that's going to be a compiler error because it's already been created one time.
00:32:19.798 - 00:33:20.520, Speaker B: In this case we would need to just drop the VAR keyword and have a equal to five variables that are declared but not assigned will automatically have a default value. So whenever you create a variable such as this name variable as a string it's going to have a default value because we haven't assigned anything yet, so there's no equal here, so we have no value. What this means is we'll get a default, and so for string, the default is an empty string, so you'll just have, it's the same as doing double quotes. There'll be no bytes within the string and it'll just be empty. For numbers, the default is zero, and for everything else the default is nil. Nil is equivalent to null in other programming languages, meaning there's an absence of a value, so there's no value. Whenever we have a nil value, we also have the comma ok idiom, which is a special case that allows us to reuse, create, and assign operators.
00:33:20.520 - 00:33:43.970, Speaker B: So as we saw earlier, we have an a. We're creating and assigning one. We then try to create a again and assign it to five. So this will be an error because we already created a one time, so we can't create it again. In the middle here we have a comma b. So we're creating two variables, create and assign. We'll assign one to a and we'll assign two to b.
00:33:43.970 - 00:34:46.698, Speaker B: Later on in the program we can do c comma b, create an assign, and we'll assign three to c and then four to b, even though we created b right here. Since we're using the comma okay idiom, we're allowed to reassign b again, even though we have the create and assign operator. So the reason we have this special case is because lots of code might give you errors, and when that happens, we'll have the variable assign and possible error values, and we'll need to check for those errors, which we'll be doing later. But when we use the create and assign, it allows us to easily create this new variable while still reusing our air values. If we weren't allowed to do this, we'd have to have like error one, error two, error three, and it's much easier to keep reusing the same error variable since it's going to contain the same type of information, which is just error information. Naming variables in Go has a convention, and we use camel case. Camel case always starts with a lowercase letter, and each word has an uppercase letter to denote where the word begins.
00:34:46.698 - 00:35:22.260, Speaker B: So we have my long variable name, so the l, v, and n are all capitalized and the m is lowercase. Whenever you're coming up with variable names, it's good to have something that's descriptive for what's going on. So here's an example of a good variable name. We have total guests is equal to twelve, and here's a bad one. We have ttl, which is equal to twelve. So ttl might be short for total or time to live, and even if it is total, we still don't know what the total is about. So to make your code easier to follow, it's always good to use descriptive variable names.
00:35:22.260 - 00:36:02.206, Speaker B: Also, these are code comments, so double slashes is a code comment which are ignored by the compiler and just allow you to leave notes for yourself and other developers. We also have constants which are created using the const keyword. They're useful when you're declaring some value that needs to be utilized throughout some or all of the program. And in contrast to variables, constants never change. So once you assign them, you cannot reassign them. Here are some examples of some constants. We have a max speed set to 30, we have minimum purchase price set to 750, and we have application author is equal to Bob.
00:36:02.206 - 00:36:31.426, Speaker B: Notice that we don't need to use a colon here, we can just assign it directly. And the naming convention for constants is a capital letter for each word. So in C usually these would be all caps, but in go we prefer to just start it with a capital letter. Let's recap. Variables are a way to access memory locations using an alias. There are multiple ways to create variables. We can create variables on their own.
00:36:31.426 - 00:37:05.010, Speaker B: We can make compound assignments. We can create variables using blocks. And there's also the create and assign operator. Variables can be assigned to other variables, and variable names can only be used once per scope. This means once you create a variable, you're unable to create another variable of the same name. Variables that are declared but not assigned to will have a default value, and the default value for numbers is zero, and for strings is just an empty string. The comma OK idiom allows you to reuse the second variable when you're creating a compound variable.
00:37:05.010 - 00:37:47.670, Speaker B: Assignment and comma OK is frequently used when you're checking for errors. In this demo, we'll be creating and utilizing variables in a simple program. Once you're ready, fire up visual studio code and let's go. Once visual studio code loads, you'll see the getting started screen. We can then click on open folder to continue. If you don't have the getting started screen, we can click on these documents right here to open the Explorer. If we click on that, we'll see what the Explorer has loaded and then we can click on open folder from here.
00:37:47.670 - 00:38:43.230, Speaker B: Once you click on open folder, you have a file browser and you're going to navigate to the location where you downloaded the go Lang files. So you're looking for the zero two mastery IO Golang Folder and a double click that and we want the SRC directory here. And then finally we want to double click on the lectures folder right there. Once you double click on that, click on ok, or your equivalent on your operating system to open up the folder. Once it loads, you'll see that we have the lectures at the top, followed by a demo folder and an exercise folder, and finally a go mod file. It's important that you have the correct folder open. That way the go tools in visual studio code will work properly and you'll be able to easily run the programs just like I do in the demos.
00:38:43.230 - 00:39:33.298, Speaker B: If you see down in the bottom right where it says analysis tools missing, if you have that message, just click on it, then click on install and you have to wait for a moment for the tools to be installed. Once that's done, we can close this, and as long as you're in the correct folder here and you don't have any error messages down here, then you're ready to go. So we'll go ahead and close this getting started page. We'll click on the demo folder. We're working with variables, so we'll scroll down to the variables folder and double click on the variables go file. You'll see that all these here are red, and that's because all these files are empty and they're just templates that we're going to be using during the demos. We won't be trying to compile every single one at the same time.
00:39:33.298 - 00:40:13.070, Speaker B: We're just going to do these one at a time, so you should have no problems writing the code. I'll be closing these windows. That way there's a little bit more space to work with. Alright, so the first thing you'll notice we have the package keyword here and the word main. So what that does is that specifies that we have a main package and allows us to have the func maintained. And the main function is the first function that's ran when you ever run a go program for most of the demos, we'll be utilizing the main package along with the main function to implement and test out different code. You'll also see that we're importing the FMT package.
00:40:13.070 - 00:40:40.370, Speaker B: FMT is the format package that's part of the standard library and it's used to print out information. So we're going to be printing out information and creating variables in this program. So the first thing we'll do is we'll just create a string variable. So we'll use the Var keyword and this will be called my name. And you'll just place your name here. My name's Jason, so I'll just put Jason there. We'll then print it out so we can use format println and that's short for print line.
00:40:40.370 - 00:41:15.806, Speaker B: And all we need to do is have a string. So we'll use double quotes and we'll say my name is and then we'll have a comma and we'll have the my name variable. So what's going to happen here is we're creating the myname variable. It's going to substitute Jason for here my name and we going to print out some data with the println function. We're going to print out my name is and then it's going to print Jason because the myname variable refers to Jason. We're now going to save this and run it. So to save you could just do control S and we need to run it in a terminal.
00:41:15.806 - 00:41:43.956, Speaker B: So to do so we'll open up the menu and go to terminal and click on new terminal. Once your terminal loads, we can type in go run. We'll use a demo variables. That's because we're on the variables lecture and the variables program. Once we hit enter, it should compile and run the program. And here we have the output. My name is Jason, which is just what we expected.
00:41:43.956 - 00:42:17.754, Speaker B: We have my name is Jason. The print line function will automatically add a space whenever you have a comma. So if you add additional variables here. So if we just copy this again, we'll have my name comma my name. And so now it'll just print out my name twice with a space in between. I'll be switching to an external terminal from now on, but you can continue to use the integrated terminal if it's easier for you. The next thing we'll do is create another variable and we're going to be using type annotations.
00:42:17.754 - 00:42:48.840, Speaker B: So let's have the variable be named name. We'll set the type to be a string and we'll assign this to the name of Cathy. We can then print it out name equals name. So just like before we have name equals and now it's going to print out the name, which is Cathy. So here we're just using type annotations. Next thing we can do is assign and create or create an assign rather. So we have username equals admin.
00:42:48.840 - 00:43:18.724, Speaker B: We're using create and assign with a colon equals. Again, we're just going to print that out. Username equals and then we'll have username. If we check to see what we've got so far, we should have my name is and then your name, name equals Kathy and then username equals admin. So I'm going to run this and we'll make sure that's what we get. And there we go. We have, my name is Jason.
00:43:18.724 - 00:43:46.750, Speaker B: Jason. Because we put it twice. Name equals Kathy and username equals admin. The next thing we're going to do is create an uninitialized variable. So we have a variable named sum and we're going to assign it to be some type of intensive. And we didn't assign any value and we're just going to print it out. So we have the sum is and then we'll use that variable and this is going to be assign a default value of a zero since it's an integer.
00:43:46.750 - 00:44:19.624, Speaker B: So when this prints it'll say the sum is zero. Now we're going to make a compound assignment. We have part one and other create and assign one and five. We're going to print this one out. Part one is then we'll have part one, another comma, other is and we'll have other. So just like the other ones we have two variables, part one, other. And we're just printing everything out using commas and the print line function.
00:44:19.624 - 00:44:48.174, Speaker B: So it'll print out. Part one is one, other is five. Next we'll be utilizing the ok error idiom. So we'll have part two other and we'll assign this to two and zero. We'll then print this out. So we'll have part two is part two, other is other. So you'll see we don't have any red squigglies here.
00:44:48.174 - 00:45:21.690, Speaker B: That's because when we have two variable assignments here we can reuse this second one. So other is being used twice. So when this one prints out down here it'll be a zero and when this one prints out it'll be a five. Next up, we're going to reassign a variable that we already created. So we created the sum variable up here and now we're going to assign a value to it. So we'll make sum equal to part one plus part two which should be equal to three because part one is one and part two is two. We'll then print that out.
00:45:21.690 - 00:45:41.894, Speaker B: Sum equals and then we'll have the sum. Next we'll create a block assignment. So we'll use the var keyword followed by parentheses. And we'll create two variables. One will be lesson name and we'll use variables. And the other will be a lesson type. And this lesson type is a demo.
00:45:41.894 - 00:46:13.260, Speaker B: So we'll put demo here. We'll then print both of these out. And we'll print out the lesson type as well. The last thing we'll do is we'll have a compound assignment where we ignore one of the variables. So we'll have word one, word two, and an underscore. We'll create an assign and we'll assign to hello, world and an exclamation point. We'll then just print out word one and word two.
00:46:13.260 - 00:46:41.064, Speaker B: So word one is going to contain hello, word two is going to contain World. And when we do a print line, hello, world will be printed. We won't have any exclamation point because we're ignoring that using the underscore. So this exclamation point, that's just going to get thrown away if we go to our terminal and run the program. We should get all this information printed out. And there we go. So here we have the sum is zero.
00:46:41.064 - 00:47:09.680, Speaker B: So that's the uninitialized zero. We then have part one is one, part two is two, and we have the sum of these two as three. So we reassigned sum to be the value of three. Here's our two variables that we created in a block assignment. And finally, here's our compound assignment at the end where we ignored the exclamation point. Go has many ways to create and assign variables. You'll see all of these used when you're reading other people's go code, so it's good to become accustomed with all the different ways that it can be done.
00:47:09.680 - 00:47:47.770, Speaker B: This concludes the demo on working with variables. I'll see you in the next presentation. In this coding exercise, we'll be going hands on with variables. Once you're ready, fire up visual studio code and let's go. Once visual studio code loads, we're going to click on the exercise folder. We're doing variables for this exercise, so we'll click on the variables folder and then double click on variables. Go.
00:47:47.770 - 00:48:25.050, Speaker B: The coding exercises in this course are designed to be done on your own. After watching the lectures and following along with the demos, there's a summary of each exercise describing what you'll need to make, a list of requirements to be followed, and some notes to help you out. You should always give the exercise a go before watching the video. Once you complete the exercise, continue on with the video in order to see the solution which may differ from your own. Seeing alternative ways to implement the exercise will help round out your go knowledge which helps you become more proficient with the language. Go ahead and start working on this exercise now with the video paused and once completed, resume the video to see my implementation. Alright, let's go.
00:48:25.050 - 00:48:56.940, Speaker B: So in this exercise we'll be printing some basic information to the terminal using different variable creation techniques. The first thing that I usually do when I have something with a list requirements is I copy and paste them down into the source code area. That way I can easily just fill out the information. So I'll paste those in now. So the first thing we need to do is store the favorite color in a variable using the var keyword. So my favorite color is red. So I'll do favorite color equals red and I'm going to print it out.
00:48:56.940 - 00:49:39.506, Speaker B: My favorite color is and we have the favorite color variable. Next we need to store birth year and age in years using two variables and compound assignment. So we have birth year, age in years and I was born in 1987 and that would make me 34 years old today. Then print these out. Born in birth year aged age and years years. Now I need to store my first and last initials in two variables using block assignment. So we'll create a new block.
00:49:39.506 - 00:50:14.090, Speaker B: So first initial that will be j. I'll use runes for this one and my last initial will be l. Again, we'll just print them out. Next we need to declare, but not assign a variable for your age in days. Then assign it on the next line by multiplying 365 with the age variable created earlier. So we'll create a new variable, age in days. And we'll create, make that an integer.
00:50:14.090 - 00:50:52.168, Speaker B: Well then assign age and days equals 365 times the one we created earlier, which is up here age and years and contains the value of 34. So that'll be age in years and then we'll print that out as well. I am age in days days old. Now that it looks like I'm done, I'm going to hop into a terminal and give it a go. So we'll run this with go run exercise variables. And so we have, my favorite color is red. I was born in 1987, age 34 years.
00:50:52.168 - 00:51:16.620, Speaker B: My initials are 7476. So this happened because I used runes and runes are just numbers. So I'm going to go back and change those to strings. We go back up here, we can just change this to double quotes. We'll use strings for now. Later on we'll learn how to print runes using special characters that allow us to print it with the actual glyph value instead of the numeric value. But for now we can just use a string.
00:51:16.620 - 00:51:50.762, Speaker B: So let's try that again. So my initials are JL and I'm 12,400 days and ten days old. This concludes the exercise on variables. Ill see you in the next presentation. In this video, ill be talking about functions. Ill explain what functions are, how to create and use functions, and how they work. Heres a little bit about functions.
00:51:50.762 - 00:52:18.180, Speaker B: Theyre the most basic building block of go programs. They allow functionality to be isolated, which makes programs easier to test, debug, extend, modify, read, write, and document. Functions are simple. They take data as input and they return data as output. Note that the input and output portions of functions are optional. So you can have a function which takes no input and a function that returns no output. An example of this would just be displaying a generic message.
00:52:18.180 - 00:52:54.030, Speaker B: There would be no input to the function, and the function will return no value. Let's take a look at how to create a function. We use the func keyword followed by the name of the function. We then have parentheses, and within the parentheses we have a parameter. After the parameter we have the type of that particular parameter. If we want multiple parameters, we can separate them with a comma. So in this function we have parameter one and parameter two, and as you can see, those will be our input datas, and they must be of the type specified here.
00:52:54.030 - 00:53:33.098, Speaker B: The output data is listed here as a specific type, and it's outside of the parentheses. We then have curly braces, and within those curly braces is the body of the function. The body of the function will have all the code for processing the information. So within this function body we can access param one and param two. Param one will be of this type, param two will be of this type, and within the function body we must return whatever this type happens to be. Here's an example function. We have the func keyword, and we're naming this function sum.
00:53:33.098 - 00:54:15.610, Speaker B: So we're going to be adding things together. We then have a lhs and Rhs. Let's just sort for left hand side and right hand side. We use a comma to separate the two parameters, and we're assigning both of them to an integer value. So if you have multiple parameters and they're all the same type, you can just list them with commas at the very end, indicate which type you'll be using. The return type for this function is integerdata and within our function body we use the return keyword to return data from the function. Within the function we take the left hand side and we add to the right hand side and then we'll just take this together and return it as an integer.
00:54:15.610 - 00:54:57.048, Speaker B: When we use functions, it is referred to as calling functions. The caller of the function provides arguments to be utilized by the function parameters. Arguments are the input data to the function. So here's our sum function that we just wrote earlier, and we have a create and assign variable here using the create and assign operator, and we're creating and assigning the value of this function. So we're going to call the sum function with arguments two and two. This two will go into the left hand side and this two will go into the right hand side. We'll then enter the function body.
00:54:57.048 - 00:55:38.220, Speaker B: We'll return the result of the left hand side plus the right hand side, which will be four. That'll get returned as an integer, and that four will then be placed right here, and then eventually we'll have a four in result. So we're creating a variable and assigning it to the value of this function call, which will be four. We can also return multiple values from functions. So here we have a function named multireturn and it doesn't have any function parameters. It's going to return three integers. And so we have multiple return values by using parentheses followed by the name of each type that we want to return.
00:55:38.220 - 00:56:18.658, Speaker B: Within this function we're returning one, two, and three. We can create variables from each one of these return values by using commas. So we have an a comma, b comma underscore, and we're creating and assigning those variables to the return values of the multi return function. So a will be one from right here, b will be two right here, and whenever you have an underscore you're ignoring that return value. So we have a three, but we're going to ignore it. So maybe in this particular case the programmer wants to ignore the third value. The naming convention for functions in go is camel case.
00:56:18.658 - 00:56:44.022, Speaker B: So just like variable names, so we have the lowercase m to start the function name. Then each word will have an uppercase letter. Just like variables, we'll want to use names that convey the purpose of the function. So here we have a good function name. The function name is encode, and we're going to encode some data which is a stream using the supplied codec there. Here's a bad name for a function. It's just named compute.
00:56:44.022 - 00:57:00.008, Speaker B: We're computing a, b, and c. They're all 64 bit floating point numbers and it returns a floating point 64 bit number. We don't know what compute actually does. It could do any kind of computation. It could do nothing. We just don't know. So this is not a very good name for a function.
00:57:00.008 - 00:57:30.510, Speaker B: We want a name that conveys what's actually happening. And this will help a lot later when you go to read code and make modifications. Let's recap. Functions encapsulate program functionality, which leads to more maintainable code. Functions have parameters which define the type of input data. Functions are used by calling the function and supplying arguments to the parameters. Functions can return multiple values and an underscore can be used to ignore a returned value if you need to.
00:57:30.510 - 00:58:10.668, Speaker B: In this demo, we'll be creating and utilizing some functions. Once you're ready, fire up visual studio code and let's go. Once visual studio code loads, navigate to your demo folder. We're on the functions demo, so click on the functions folder here, and then finally double click on functions. Go. Once that's loaded, you're ready to go. So the first function we'll be creating is a function that doubles a number.
00:58:10.668 - 00:58:44.190, Speaker B: So we'll call it double and it's going to take a single parameter and it's going to be an integer parameter and it's going to also return an integer. We're just going to return the number plus itself. That way we can double it. We'll then create a second function named add and that we're going to be adding two numbers together. So we have a left hand side, a right hand side, and both are going to be integers. Since we're using the same type integer for both left hand side and right hand side, we don't need to specify it two times, so we can just use a comma and use int once. And both of these here will be integers.
00:58:44.190 - 00:59:27.480, Speaker B: The add function is going to be returning an integer, so let's return left hand side plus right hand side. Next we'll make a function called greet and that's going to display a message. This function has no input parameters and no output data, so we can just use parentheses with nothing in it. And we'll just use a blank space right there in our greet function. We'll use the format package and we'll do a print line hello from greet function we go down in our main function. We can start utilizing these functions we just created. So the first function we'll use is a read function to call the function all we need to do is type the name of the function and our two parentheses.
00:59:27.480 - 00:59:59.970, Speaker B: The next function we'll use is the double function. So I'm going to create and assign a variable named dozen and we're going to take the double function. We'll double the number six, and that'll give us twelve, which is a dozen only to print out this result. That way we can see that we get the correct number. Next up, we'll create a baker's dozen. So a baker's dozen is 13. So we'll use the add function and we're going to add our dozen that we already have.
00:59:59.970 - 01:00:32.132, Speaker B: We'll add one to it and we'll print that out as well. So what we're doing here with the add function is we're adding the value of dozen and one. Here in our double function, we're doubling six, which is twelve. That'll get placed into dozen. We're then going to add the dozen from here. That's going to be twelve, and we'll add one to it. And it's going to place 13 into Baker's dozen.
01:00:32.132 - 01:01:13.620, Speaker B: So Baker's dozen, we'll have 13. And finally, we're going to have both functions call at the same time. So we'll do another baker's dozen and that will be the result of add and double, and then we'll print that out. So here we're nesting functions. We have the add function and the double function. This double function is going to be called first and we'll get a twelve back. Once we have that twelve, we'll take the twelve and the one, add them together in this function, and then return a 13 into another baker's dozen variable.
01:01:13.620 - 01:01:56.260, Speaker B: Once you have all that in, let's save our work and hop into a terminal and see if we get the right answers. To run this demo, we'll use go run demo functions. And so here we have hello from REIT function. A dozen is twelve, a baker's dozen is 13, and another baker's dozen is also 13. This concludes the demo on writing and utilizing functions. I'll see you in the next presentation. In this coding exercise, we're going to be working with functions.
01:01:56.260 - 01:02:22.382, Speaker B: Once you're ready, fire up visual studio code and let's go. Once visual studio code loads, navigate to your exercise directory. We're working with functions, so click on the functions folder and then double click on functions. Go. As always with the coding exercises, give it a go on your own. First with the video paused. Then, once completed, resume the video for my implementation.
01:02:22.382 - 01:02:45.084, Speaker B: That way you can see alternative solutions to the problem. Alright, let's go. So in this exercise we're going to be working with functions and utilizing them in different ways. The first thing I'll do is copy the requirements down into the coding area. So since we're writing functions we can do them in any order we like. So I'm going to start with this one down here. So we're at a function that returns any two numbers.
01:02:45.084 - 01:03:06.790, Speaker B: So I'll just call it two twos. So I can return any two numbers that we want. We need to return two separate numbers. So our return value is going to be in parentheses and then we have two integer values. That way we can return two numbers. I'm just going to return two twos. Next we can write a function that returns any number.
01:03:06.790 - 01:03:35.684, Speaker B: So in this function I'll just name it five and we'll return an integer and we'll return five. Next we'll do this requirement. So we need to write a function to add three numbers together supplied as arguments and return the answer. So I'll call this function add three. So we'll have an a, b and c. Since we're working with all numbers we can just use integer right there and all three of these will be integers. We are going to return an integer since we have to add them together.
01:03:35.684 - 01:04:15.744, Speaker B: And we're just going to return a plus b plus c. Next we need to write a function that accepts a person's name as a function parameter and displays a greeting to that person. So I'll name this function greet person. We'll have a name and that's going to be a string since names are going to be strings because they consist of letters and numbers. Then going to use the format package and just do a print line, say hello, name. Next, we need to write a function that returns any message and call it from within format print line. So what this means is we're not going to be able to use the print line function within this one.
01:04:15.744 - 01:04:38.620, Speaker B: So we have to return the data itself and then it'll get printed later. So we'll call this one hi there. It could be any message we want. So mine's just going to say hi there and it's going to return a string. So the string is the type that we want to return. Since we're working with messages and we're just going to return hi there. In our main function we can start utilizing the functions that we created.
01:04:38.620 - 01:05:18.964, Speaker B: So the first thing I'll do is greet person and we'll have this person be named alice. The next thing we'll do is format printline our hithere function. So this fulfills the requirement up here where we need to write a function that returns any message and call it from within format println. So we're calling our hither function within format println. So hi there is going to go here. We're going to return a string and hi there will be placed into the println function and print out on the terminal. We then need to add three numbers together using any combination of the existing functions.
01:05:18.964 - 01:05:47.450, Speaker B: So I'm going to do a and b and we'll get our two twos that we created earlier and I'm going to have the answer and we'll add three. So we'll have the five function and our a and our b. So we're going to add our two, two and five together. So we should get nine as our answer. So our answer should be nine. And finally we need to print the results. So just use format dot print line and we'll print out the answer.
01:05:47.450 - 01:06:19.590, Speaker B: So I'm going to go ahead and run this and we'll see if we get all the things that I hope we get. We'll run this exercise using go run exercise functions. And so we have hello Alice which is our name that we supplied. We have hi there, which is just the greeting that's within the print line. And we have nine, which are all the functions returning numbers and added together. This concludes the exercise on working with functions. I'll see you in the next presentation.
01:06:19.590 - 01:06:55.900, Speaker B: In this video I'll be talking about operators. I'll be discussing what operators are going over arithmetic operators and logical and relational operators. Operators are used to perform calculations and comparisons. Here's some examples. We have a lesson operator and we have a subtraction operator. Operators work on operands. Here we have an example.
01:06:55.900 - 01:07:22.022, Speaker B: We have the plus operator and it's operating on the operands a and b. Here's a listing of the arithmetic operators that are available within go. We have addition, which is plus subtraction. As a minus multiplication is a star. Division is a forward slash and remainder. Division is a percent symbol. You'll see on the right here we have the operators and an equal sign.
01:07:22.022 - 01:08:05.406, Speaker B: And what that does is it takes an existing variable performs this operation and reassigns the result to that variable. So you'll see that a lot in code that you can use that to increment numbers or add some value to an existing variable. Let's take a look at how to use some operators. So, for using arithmetic operators here we're creating a variable named total and we're just using three plus three. So our operator here is plus our operands are three and three and that'll be assigned to six and it'll be placed into the total variable. To use arithmetic assignment here we're creating variable a, setting it to the value of one. We're using plus equals with three.
01:08:05.406 - 01:08:36.820, Speaker B: And so that will take the existing a and add three to it. And then a will now be equal to four and that's the same as doing a a three. So this is a shortcut for doing that. We also have increment and decrement operators. So these are very common in loops. Here we have a variable I. If we do, we're just going to be adding one to the I and if we do minus minus, we're going to be subtracting one from the I.
01:08:36.820 - 01:09:21.426, Speaker B: Whenever you're working with arithmetic operators, it's always going to be returning a number. So you're not going to get any errors or any strings back. You're always going to get a number that you're working with. Let's take a look at the relational operators we have less than, less than or equal to, greater than, greater than or equal to, equal to, and finally not equal to. Relational operators always return a Boolean. So whenever you're using in this example, greater than and also equal to, you're always going to get either true or false back. So in this case, if a is bigger than b, because we're doing greater than, then that would be true.
01:09:21.426 - 01:10:00.459, Speaker B: And if x was equal to y, that would also be true and the x is equal to y case. If they're not equal, then you're going to get a false. And in the a greater than b. If a is, for example, zero and b is two, then you're going to get a false back on that one. Now we'll take a look at some logic operators we have and which is two ampersands or which is two bars. The bars are above the enter key, below the backspace on most keyboards. And we also have not, which is an exclamation point and that'll invert a value.
01:10:00.459 - 01:10:28.100, Speaker B: So let's take a look at how to use those. So what you can do with the logic operators is combine true and false things. So in this example we have, these would all be booleans. So we have authorized and authenticated. So both of these need to be true because we're using two ampersands. So if both of those are true, then the return value will also be true. If either one of these is false, then the return value will be false.
01:10:28.100 - 01:10:52.310, Speaker B: Here we're using or with the two bars. So if we have red or blue, if either one of these is true. So if red is true and blue is false, we're still going to get a true back, and that's because we're using or. So we only need one of these things. And there could be a, there could be many. You can keep going with as many as you want. If any one of those is true, then you're going to get a true back.
01:10:52.310 - 01:11:24.920, Speaker B: And with the exclamation point you're going to invert whatever you have. So if heavy is true, once you apply the exclamation point, it's now going to be false. Let's recap. Operators operate on operands. Arithmetic operators enable calculations. Arithmetic assignment can calculate and assign to a variable in a single statement. Relational operators enable comparisons, and logic operators enable combinations and negation.
01:11:24.920 - 01:12:14.884, Speaker B: In this video we'll be taking a look at if else. I'll be discussing flow control using if else with operators and statement initialization. So first we need to talk about flow control. Program code executes line by line and flow control is a way to interrupt this line by line process. We can have different lines of code that can be executed based on different conditions, and these conditions are programmer defined and you can make as many conditions as you need in order to get your program to run and the job completed. So this is what an if and an if else looks like. We have the if keyword and then some kind of condition.
01:12:14.884 - 01:12:41.860, Speaker B: The condition must evaluate to either true or false. If it's true, code will be executed inside this block and so you can do whatever you want in here. Here we have an if else. So same as above. We have if some condition, we'll do some code here. If that's true, if it's false else, then we'll do something else in here. So the first block is the truth condition and the else block is the false condition.
01:12:41.860 - 01:13:15.306, Speaker B: Let's take a look at an example. Here we have if some username, which will be a string. If it's not equal to a blank input, so there is a name, then we'll process it. And if the if the input is blank, then we'll display some kind of error message. And on the bottom we're just doing something similar without the else block. So we only are interested in processing the username and we don't do anything else. On the bottom example, it's also possible to nest else ifs.
01:13:15.306 - 01:13:50.100, Speaker B: So what we're doing here is we're checking someone's age. So this entire thing here is going to evaluate to either true or false. Remember that relational operators determine true or false. So if somebody's age is greater than or equal to 21, if that's true, then we'll permit their entry to a venue. If this is false, we're going to go down to the next block here. So else we use the keyword if again. So else if we have parental approval and if that happens to be true, then we'll permit entry again.
01:13:50.100 - 01:14:20.530, Speaker B: So if that's true, that'll be executed. If this one is false and this one is false, then finally this last block will get executed and we'll have a some kind of code where they cannot enter the venue. You can have as many else if blocks as you want for whatever conditions you're trying to test for. So you can have one, you could have none. You can have five or six, you can have 20. All of that's okay. Now let's take a look at how we can use if with some logical operators.
01:14:20.530 - 01:14:59.340, Speaker B: Here we have if has ticket and ticketvalid. So this has to be true and this has to be true. Then we'll execute the code here in this block. In this example here we have if the funds are greater than the cost. So this whole thing will evaluate either true or false and the account is active. So if that's true and this is true, then we'll enter into this block here. In this third example, if we're either using a debit card or using a credit card, then we'll enter this block since we're using or either one of these can be false.
01:14:59.340 - 01:15:31.960, Speaker B: So if this is false, that's okay. And if this is true, we'll still enter. If both of these are false, then we won't execute the code here. So as long as one thing is true with all of these expressions, then we'll be able to use the if block here. And finally here at the bottom we have a negation. So if the quiz is not complete, then we're going to display an incomplete submission. Warning, this quiz complete here, that's going to be a boolean, so that's either going to be true or false.
01:15:31.960 - 01:16:14.900, Speaker B: We can also use if statements with functions. So here we have our if keyword and we're calling the temperature function of the freezer. So we're checking the temperature on a freezer and if that temperature is greater than zero, we'll display an alert and we can use multiple functions here. So if the temp in the freezer is greater than the preferred temp in the freezer, then we can display an alert as well. And just like with the previous slides, you can use or and to combine multiple different function calls. Go has a feature called statement initialization. And what this allows us to do is it allows us to create a variable and do a comparison at the same time.
01:16:14.900 - 01:16:49.662, Speaker B: So here in this first example, we're creating the variable named I using the create and assign operator, and we're assigning it to the value of five. We then have a semicolon and we can do a logic check. So here we're creating I assign it to five. We then check to see if I is less than ten. If this evaluates to true, then the block will be executed. If this evaluates to false, then we'll go down into the else block and do something else. In the second example, we're using the rank keyword and we're getting the userrank function.
01:16:49.662 - 01:17:29.720, Speaker B: And this rank function will determine if they're an admin or user or guest. If rank happens to be admin, then we'll be able to do administrative things here. If the rank is manager, then they can do manager things. And finally, at the bottom we'll display an error message because for this particular functionality they're not able to do anything unless they're an admin or a manager. Remember, with statement initialization we need to have the if keyword followed by our initialization statement, a semicolon, and then our comparison at the end. The comparison should always refer to the variable that you created in the initialization statement. When you do so, you'll be able to access this variable.
01:17:29.720 - 01:18:06.900, Speaker B: Within this block, something closely related to control flow is an early return. An early return is simply using the if statement to validate some data. When the data is validated, you're able to continue with the function. If the data fails validation, you return early from the function. You want to do this because it maximizes performance and once you've checked all the data, you're able to use it without having any issues. This leads to cleaner code and reduces the amount of bugs that you have in your program. Let's take a look at an example.
01:18:06.900 - 01:18:41.408, Speaker B: Here we have a get session function and it returns a session token or an error. The first thing we want to do is use if to check the error. So if the error is not nil, remember that nil is nothing. So if it's not nothing, meaning we do have some kind of error, then we'll return immediately out of the function. That's because this token will not be valid because some kind of error occurred. The same thing down here with getcart. So here we use our existing token and our get cart function, and if that's successful, then we get a cart.
01:18:41.408 - 01:19:17.340, Speaker B: However, if we have an error, we need to check that and if we get an error back, then we should return from the function. If both of the error from get session and git cart, if both of those are nil, it will end up down here at the bottom and we'll have valid token data and valid cart data. This makes it okay to process a shopping cart. This if error is not equal to nil. We'll see that a lot in your go code because when functions return an error, you always need to check to see if that error value exists. And if it does, you want to return from the function. And you can also perform logging in here if you like.
01:19:17.340 - 01:20:08.534, Speaker B: Let's recap. Flow control is a way to change which lines of code execute. If else can be used to conditionally execute code. And we can also use else if for testing multiple different conditions. If statements can be used with return values from function calls and logical inequality operators can also be used with if statements. Statement initialization allows for a variable to be created and tested within the scope of an if else block, and early returns should always be used when possible for efficiency and code clarity. In this demo, we'll be creating a program that utilizes if else statements.
01:20:08.534 - 01:20:50.470, Speaker B: Once you're ready, fire up visual studio code and let's go. Once visual studio code loads, click on your demo directory and we're doing if else. So click on if else, and then finally double click on if else go. So we have some existing functionality here and we're going to be utilizing it within our program. So the first thing we'll do is create some quiz scores. So we'll have quiz one, quiz two, and quiz three, and we'll set those scores to nine, seven, and eight. Next, we're going to create an if statement.
01:20:50.470 - 01:21:40.748, Speaker B: So we'll have if quiz one is greater than quiz two, we'll print a message. We'll then continue with an else if. So, if quiz one is less than quiz two, we'll print a different message. Finally, we'll have an else keyword, and then the last message will be the scores are equal. So this first check checks to see if quiz one is greater than quiz two. The next one is quiz one less than quiz two. And the last one will cover any other cases.
01:21:40.748 - 01:22:33.170, Speaker B: Since we all already covered greater than and less than the last case, we'll be checking to see if it is equal to next we'll do. We'll call our average function. So if the average of quiz one, quiz two, and quiz three is greater than seven, then we'll print out a message. And if it's not greater than seven, we'll print out a different message. When we run this program, we should get the output here. So quiz one scored higher than quiz two because quiz one is greater than quiz two. And we should get here acceptable grades printed out for the average because the average of these is going to be higher than seven.
01:22:33.170 - 01:23:09.318, Speaker B: Let's hop into a terminal and give it a go. We'll run this one with go run demo slash if dash else. So there we go. We have quiz one scored higher than quiz two and we have acceptable grades. This concludes the demo on if else. I'll see you in the next presentation. In this coding exercise, you'll be creating a program that utilizes if else.
01:23:09.318 - 01:23:32.886, Speaker B: Once you're ready, fire up visual studio code and let's go. Once visual studio code loads, navigate to your exercise directory. We are working on if else. So click on if else. Finally, double click on if else. Go to load the exercise file. As always with encoding exercises, give it a go on your own.
01:23:32.886 - 01:24:03.686, Speaker B: First with the video paused, then once completed, resume the video for my implementation. That way you can see an alternative solution to the problem. All right, let's go. So in this program we're going to be restricting access based on the day of the week and what kind of role a user has. I'm going to copy these requirements and we'll paste it into our main function. You'll see that we have some existing data. So we have some variables created here, some roles created here, and we also have a few functions available.
01:24:03.686 - 01:24:27.970, Speaker B: We're going to be using all of this pre existing program data within our own program. So we don't need to modify any of the existing code. We're only going to be focusing here on the main function. So if we hop down into main and we paste in the requirements, we can start working on the program. So the first thing we'll take care of is the admin and manager because they can access anytime. So we'll have the role. We'll check to see if it's admin or if the role is a manager.
01:24:27.970 - 01:25:00.160, Speaker B: Then we'll use the access granite function. Next up, we have contractors, so contractors can access only on weekends. So we need some way to determine whether or not it's a weekend. First, before we do this check, let's write a function to make that determination. If we scroll up here on the days of the week, we can see that they're numbers. So we'll create a function and I'll just call it weekday, and this will return whether or not it's a weekday. So we'll take the day, which is an integer.
01:25:00.160 - 01:25:28.414, Speaker B: So all these are integers. So we see that there's zero through six, Monday through Sunday. And so our function down here requires an integer. It's going to return a Boolean, and that will just determine whether or not we're on a weekday. So we can just directly return a comparison. So if the day is less than or equal to four, we'll just return that. So we can see that Friday is four and everything less than four is also a weekday.
01:25:28.414 - 01:26:16.980, Speaker B: So if we just return whether or not the input day is less than or equal to four, we'll know whether or not it's a weekday. And if we want weekends, we can just use an exclamation point to invert whatever answer we get back down on our main function. We can do our if check, so we'll do an else if. So, if the role is a contractor and it's not a weekday, then we can grant them access. Next up, we have members, and members can access on weekdays. So if the role is a member and it is a weekday, then they're going to get access. Finally, for guests, we'll use a role equals guest.
01:26:16.980 - 01:27:16.210, Speaker B: And if the day is Monday, Wednesday, and Friday, so if the day is Monday or Wednesday or Friday, then we'll give them access and everybody else is going to get denied. Now with this one here, I'm going to add parentheses because usually with these logic operators and an or, you want to use parentheses because sometimes they can get hard to read. So if we put parentheses around this entire chunk here, we can see that the role must be a guest and anything here must be true. So here we're using or so only one of these needs to be true. So if it's not Monday, that'll be false. And let's say today is Wednesday true and Friday false. Since we have one true, that means this entire chunk will be true.
01:27:16.210 - 01:28:08.060, Speaker B: So we'll have a guest, this whole chunk would be true, and we can get access granted. And of course, if all of these fail, so if we have a. If we're a contractor and it's not the weekend, remember, it's not a weekday and if we're a guest and it's not one of these three days, then we'll get access denied because there's no other options. So we can see with the initial code we have today and role set to Tuesday and guest so we don't have anything that handles that. So we should get access denied if we try that out. So I'm going to run the program and we'll see what happens. I'll hop into a terminal and to give this one a go to go run exercise if else and there we can see we have access is denied because it's Tuesday and a guest.
01:28:08.060 - 01:28:43.770, Speaker B: If we jump back into our code we can try a different combination. Let's try Sunday and a contractor. So we know if we have a contractor we'll go in here because we have contractor and if it's a not the exclamation point. If it's not a weekday then we should get access granted. So have contractor Sunday so we should get access granted for this particular scenario. Back in our terminal we can run it again and as we can see we have access granted. This concludes the exercise on if else statements.
01:28:43.770 - 01:29:35.960, Speaker B: I'll see you in the next presentation. In this video I'll be talking about the switch statement cover basic usage case lists and fall through behavior. First, a little bit about switch switch is used to easily check multiple conditions and it's an alternative way to do if else blocks switches execute from top to bottom and they optionally have a default action. Let's look at a basic example. On the left we have an X and that's been assigned to the value of three. We then use the switch keyword and we switch on X. Next we have the case keyword.
01:29:35.960 - 01:30:13.800, Speaker B: In the case that X is equal to one, we'll print out one. In the case that X is equal to two, we'll print out two. And in the case that X three, we'll print out three. We then have the default case. So whenever the case is not covered, instead we'll execute the default and the default case for this particular switch is to print out other and the value of X. It's always a good practice to have a default case, and that's just in the event that you forget to check for a case, at least you have something that will be executed. We're not limited just to switching on integers.
01:30:13.800 - 01:30:34.340, Speaker B: We can also switch on strings. So here on the right we have a string example.com and we're switching on this URL variable that we created right here so we can do the case of example.com comma, we'll print out test. In the case of google.com comma, we'll print out live and in any other case. So the default case is any other case we'll print out dev.
01:30:34.340 - 01:31:11.476, Speaker B: We can also have conditional cases. So in this particular switch statement, we're creating and assigning a variable, and then we're going to switch on it. So we're creating a variable name results using create and assign. We're assigning the value of calculate and the function argument of five. We then use a semicolon our curly braces, and then within those curly braces we have our cases. Our first case will execute when result is greater than ten. Our second case will be when our result is equal to six, then this will execute.
01:31:11.476 - 01:31:54.850, Speaker B: And the last case, if the result is less than ten, then this one will execute. We can also have case lists. So case lists allows us to check for multiple things in the same case. So if we switch on X, which would be an integer on this first case, if it's either one, two, or three, we'll execute some code. In the second case, if it's 1020 or 30, we'll execute this code. Case lists are useful if you want to take the same action for multiple different values. The default behavior for switches in Go is to automatically stop executing once one of the cases matches.
01:31:54.850 - 01:32:44.240, Speaker B: What this means is if we have a letter and it's a space, then this case does nothing and none of these will be checked. However, if we use the fall through keyword, then automatically the next case will be executed. So, for example, if we have the letter be equal to I, this case will be executed because I is present here, we'll print out a vowel, the follow through keyword is encountered, and we're going to automatically execute the next case, even though it's not equal to any of these. So we'll print out a vowel and vowels are great. The fallthrough behavior can be useful if you want to always execute some code regardless of which case was matched. Let's recap. Switch can be used to easily check a variable for different values.
01:32:44.240 - 01:33:24.376, Speaker B: You can use commas to check multiple values on a single case. Expressions are also allowed as a case. You can include function calls, mathematical operations, and logic. Within these cases, the follow through keyword will automatically execute the next case even if it doesn't match. In this demo, we'll be creating a program that utilizes the switch statement. Once you're ready, fire up visual studio code and let's go. Once you're in visual studio code.
01:33:24.376 - 01:33:51.208, Speaker B: Click on the demo folder. We're on the switch demo, so scroll down to the switch folder and then double click on switch. Go. So you'll see we have a little bit of code here already. We have a price function which returns one and some constants. We have an economy, business, and first class. We haven't covered const very much, but it's just like a variable except you can't change it.
01:33:51.208 - 01:34:16.890, Speaker B: So const is just short for constant. In our main function, we're going to create a switch statement. So we'll switch on p and we'll create that variable and we'll create the value from the price function. We'll then create some cases. So we'll use case expressions. So when the case is less than two. When P is less than two, we'll print out a message.
01:34:16.890 - 01:34:55.516, Speaker B: So we'll have a cheap item for the message. If the case is less than ten, we'll say that it's moderately priced and the default case will be expensive item. So remember with cases they're checked from top to bottom. So if it's less than two and this executes, then this one here will not execute. So you won't get cheap item followed by moderately priced item. That won't happen. So if we have the case of p and the price is one, for example.
01:34:55.516 - 01:35:39.010, Speaker B: So if we scroll up, we'll see that our price function does return one. So this case will be executed first and then nothing else gets checked after that. We're going to create another case. So we'll create a ticket and this will be an economy seating ticket. We'll then switch on the ticket. In the case of an economy ticket, we'll print out economy seating. In the case of a business ticket, we'll print out business seating and in the case of first class will print out first class seating.
01:35:39.010 - 01:36:07.864, Speaker B: Any other tickets will have a default. I'll just print out other. We're using the word economy here because that's defined as a constant here. So it's like I said, it's just like a variable. So we have economy, business and first class, zero, one and two. So we're just working with integers. So when we switch on the ticket, if the ticket is economy, we'll get economy seating.
01:36:07.864 - 01:36:46.220, Speaker B: It's business, business seating, first class, first class seating, anything else? Then we're going to get other seating. If we take a look at our code, we'll see that the first thing that prints out should be cheap item because our price is actually equal to one when we call the function and we have an economy ticket and so we should get economy seating printed out. So it should be a cheap item followed by economy seating. Now I'm going to hop into a terminal and we'll give it a go. You can run this with go run demo switch. And there we go. We have a cheap item and economy seating.
01:36:46.220 - 01:37:23.670, Speaker B: This concludes the demo on the switch statement. I'll see you in the next presentation. In this coding exercise, you'll be creating a program that utilizes the switch statement. Once you're ready, fire up visual studio code and let's go. Once visual studio code loads, click on the exercise directory. We're on the switch exercise, so scroll down to switch. Click it once to open, then double click on switch.
01:37:23.670 - 01:37:45.424, Speaker B: Go. As always with the coding exercises, give it a go on your own. First with the video paused. Then once completed, resume the video for my implementation. That way you can see an alternative solution to the problem. Alright, let's go. So in this exercise, we need to use a switch in order to print out information based on somebody's age.
01:37:45.424 - 01:38:10.146, Speaker B: So I'm going to copy these requirements and stick them in the main function. Next I'll be creating the switch statement. So we'll switch on age and we'll create that variable right now and we'll set it to be equal to zero. Remember to include a semicolon at the end. That way we're able to create a variable right here. In the first case, we'll check the newborn requirement. So the age has to be zero.
01:38:10.146 - 01:38:51.146, Speaker B: So when age is equal to zero, we'll just print out a newborn. Toddlers up next. So when the age is greater than or equal to one and the age is less than or equal to three, then we'll print out that we have a toddler. Next we have child. So when the age is less than 13, we'll print out child. Next we have 18. So this is teenager.
01:38:51.146 - 01:39:33.998, Speaker B: So as long as we're younger than 18, we got a teenager. And finally, if they're over 18, we'll print out adult. So when we're working with switches, the first case to execute will abort the rest of the processing on the switch. So if the age is equal to zero and that checks out, then none of this gets executed. Again, that's how we're able to have an age of zero. And it's okay right here. Even though zero is still less than 18, we won't get teenager because this will get triggered first up here and nothing else will be executed.
01:39:33.998 - 01:40:07.436, Speaker B: So the first one, we'll check for zero and we'll get newborn. The second is between ages one and three, we'll get toddler. If they're under 13, we'll get child. They're under 18, we'll get teenager, and any age that's 18 or older will be adult. Let's run this we have age set to zero right now, so we should get newborn when it's printed out. So let's hop into a terminal. We can run this program with go run dot slash exercise slash switch and see we have newborn.
01:40:07.436 - 01:40:37.920, Speaker B: Let's try another one. So if we'll change the age, we'll try teenager. So we'll just say that they're 14, and if we give this one a go, we have teenager. As you can see, switches are a little bit more concise and sometimes easier to read than having lots of else if blocks. So if you have a scenario with lots of things you need to check usually youd want to use a switch. This concludes the exercise on the switch statement. Ill see you in the next presentation.
01:40:37.920 - 01:41:35.660, Speaker B: In this video, ill be discussing loops. Well cover basic loops while loops and infinite loops. So when you're writing programs, it's often required to repeat actions in code more than once or to iterate over the items in a collection. And these tasks are accomplished by using loops in go there's only one keyword that we use for looping, and that is the for keyword. Let's take a look at the basic c style loop. So we have the for keyword followed by the initialization statement, a condition check, and the post loop statement. Each one of these portions is separated with semicolons, so you have three initialization, condition, and post.
01:41:35.660 - 01:42:09.190, Speaker B: So we create our loop with the for keyword. In our initialization statement, we would typically create a new variable, and it's usually named I for iteration. Generally you start at zero, but you can start at any point you want. We're using the create and assign operator to create I and assign it the value of zero. Our condition portion of the loop will be checked before every iteration. So what's going to happen is we'll create this variable I. It's then going to be checked to see if it's less than ten, and then if it is, we're going to enter into this loop.
01:42:09.190 - 01:42:50.150, Speaker B: So then all the code in here will get executed. Once execution completes, we'll go back up to this post statement and I will be incremented by using the operator just adds one to I. So on the first iteration, I will be zero I is less than ten. Because it's zero, the code will execute, then I will be incremented by one and then we'll check again. So is I less than ten? It'll be one at that point. Yes it is and we'll execute and this will continue until finally I is equal to ten. Once it's ten, this check will fail and it'll be false, and then we'll exit out of the loop and continue executing code.
01:42:50.150 - 01:43:25.410, Speaker B: Go does support while loops. However, we can only use the for keyword in go since there's only one looping keyword. So to create a while loop, we'll just use the for keyword and a condition. Note that the condition must have the variable created beforehand, so I needs to exist prior to using this loop. If this happens to evaluate to true, then the loop will execute. One thing to note with this style of looping is you'll always want to adjust the loop counter within this loop. Otherwise it'll just go on forever.
01:43:25.410 - 01:44:07.870, Speaker B: We also have support for infinite loops, so if we want an infinite loop, we can just use for and then nothing else. All we need is our curly braces right here, and then the code within is just going to execute over and over and over. In order to exit an infinite loop, we'll have to use the break keyword. Usually you would check. So in this case we're checking. If something happened is true, then we'll break, and if it's false then we'll just keep continuing on forever. Since this is an infinite loop, loops like this will be used for something like web servers or if you're reading data from some kind of data stream, and then you would choose the condition on which to break.
01:44:07.870 - 01:44:44.446, Speaker B: We also have the continue keyword, which can be used to skip the current loop. So we have a typical for loop where we're setting I to zero. As long as it's less than ten, we get a loop and we're incrementing one time each iteration. Within our loop we have an if statement and we're checking the I with remainder division of two. And if that's equal to zero, we'll continue. So what this will do is this will skip every iteration where I is an even number. That means as soon as continue is hit, we'll go straight up here and we'll do the condition check again.
01:44:44.446 - 01:45:19.370, Speaker B: So this code will never get executed down here if the continue is hit first. However, if we have an odd number, then this will be false and continue will not be executed, and therefore we will print out the odd numbers. Let's recap. The for keyword creates a loop. We can use the break keyword to exit the loop on a specific condition. The initialization variable can be used only within the loop block and the post statement executes every iteration. We have three styles of loops.
01:45:19.370 - 01:46:06.650, Speaker B: We have the typical loop where you get to set the variable, the condition, and how much it changes. We have the while while loop where we have a variable created previously, and as long as that variable is less than the value supplied here, then we'll execute the loop. Always remember to increment that within your loop, otherwise it'll go on forever. And then we have the intentional infinite loop where there's nothing. Right here we just have four and our gorilla braces and that will just go on forever. In this demo, we'll be creating a program that utilizes looping. Once you're ready, fire up visual studio code and let's go.
01:46:06.650 - 01:46:35.840, Speaker B: Once visual studio code loads, click on the demo folder. We're on the loops demo, so scroll down to loops. Click that and then double click on loops. Go. We'll be creating a basic for loop and we'll take the iterator value and add it together to create a sum. So the first thing we need to do is create a sum variable and we'll set it to be equal to zero. We'll then do a print line.
01:46:35.840 - 01:47:11.370, Speaker B: That way when we run the program, we know what the sum is. When we start the program, we'll then create our for loop by creating a new I variable and set it to the value of one. As long as I is less than or equal to ten, we'll increment it by one and run the loop. Within the loop, we'll take sum and we'll add I to it. Each loop iteration, we'll print out sum is and we'll print the sum. So in our code we're creating a new I variable for this for loop and we're setting it to be equal to one. And as long as I is less than or equal to ten, we'll execute the body of this loop.
01:47:11.370 - 01:47:44.786, Speaker B: Whenever this loop body executes and gets the end, I will be incremented by one and it'll be checked again for this condition. And once I is greater than ten, this will evaluate to false. Then we'll exit out and continue running the program. Within our loop body. We take the sum which is initially zero, and we add I to it. I starts at one, so first will be plus one, then plus two, then plus three all the way until I is ten. Before we continue, let's run this program and we'll see what kind of output that we get.
01:47:44.786 - 01:48:18.090, Speaker B: I'm going to hop into a terminal. We run this program with go run demo loops, and we can see the output starts at zero, one, three, and then eventually we end up at 55. We hop back into the code. We're now going to create another loop. And as long as the sum is greater than ten, we'll take the sum minus equals five, and then we'll print it out. And we'll also note that we're having a decrement operation. That way we know that which loop that we're in.
01:48:18.090 - 01:48:44.926, Speaker B: So with this loop, we don't create a new variable at all. All we're doing is checking if the sum is greater than ten. We know from the last run that the sum was 55, so it's definitely greater than ten. And this will check out as true. We'll then enter into this loop. We'll take the sum which is 55, we'll minus five from it, and then it'll get reassigned back into sum. We'll then print out a message that we're decrementing, and then the loop will continue.
01:48:44.926 - 01:49:27.568, Speaker B: And this condition is going to keep being checked until sum is finally less than ten, or less than or equal to ten. So let's save and run this program, and we'll see what we get. So here we have, at the top, it went off the screen, but we start at one and then we end up at 55. And now we decrement five at a time. So 50, 45, 40, all the way down until the sum is ten. One particular thing to remember about this loop down here on the bottom is we aren't changing the sum within the loop statement itself. So here in this for loop, this first one, we have the I at the end, which modifies this I, which eventually affects this condition.
01:49:27.568 - 01:50:05.626, Speaker B: None of that is present here on this bottom loop. So if we forget to subtract or add to the sum, then this will just go on forever because 55 is greater than ten, and so this is always going to be true, and this will just be an infinite loop. So always remember to have something that modifies this expression. That way the loop eventually terminates. This concludes the demo on loops. I'll see you in the next presentation. In this coding exercise, you'll be creating a program that utilizes loops.
01:50:05.626 - 01:50:36.120, Speaker B: Once you're ready, fire up visual studio code and let's go. Once visual studio code loads, navigate to your exercise directory. We're on the loops exercise so click on the loops folder and then finally double click on loops. Go. As always with the coding exercises, give it a go on your own. First with the video paused, then once completed, resume the video for my implementation. That way you can see an alternative solution to the problem.
01:50:36.120 - 01:51:17.168, Speaker B: Alright, let's go. So for this exercise we need to implement the classic fizzbuzz interview problem using a for loop. So I'm going to paste these requirements into the main function. So we'll need to make a for loop and we'll start at one because we need to print out one. And as long as it's less than or equal to 50, we'll increment it by one. So the first thing that I'm going to do in my version is I'll see if the number is divisible by three. So if it's divisible by three and to do so we use the remainder division and we could do by three.
01:51:17.168 - 01:52:00.430, Speaker B: So this is also called a modulo operation. And if that's equal to zero, that means it's divisible by three. And if we can do divisible by five as well, just by changing this to five. And now all we need is an if else block. So if it's divisible by three and divisible by five, then we'll print out fizzbuzz. Next, if it's divisible by three, then we'll print out fizz. And finally, if it's divisible by five, we'll print out buzz.
01:52:00.430 - 01:52:38.620, Speaker B: Lastly, if none of these check out, then we'll just print out the number. We're creating a for loop and we starting at one. And as long as it's less than or equal to 50, we're going to keep looping. Each iteration we're going to increment by one. We use the modulo operation to determine if the value of I is divisible by three, and if it's equal to zero, that means it is divisible by three. And the same thing goes for five. So if it's equal to zero here, then it's divisible by five.
01:52:38.620 - 01:53:08.978, Speaker B: If it's both divisible by three and five, we'll print out fizzbuzz. If it's just divisible by three, we do fizz and just divisible by five, we'll print buzz. Otherwise we print the number out. We have to make sure that this one comes first, because numbers can be divisible by both three and five. And if for example, we did divisible by three. And if that was first, the number 15 would trigger this one. And then this would get ignored.
01:53:08.978 - 01:53:35.366, Speaker B: And this would get ignored. So we have to make sure that we have it in the correct order. I'm going to save this and run it and we'll make sure that it runs properly. I'll run this exercise by doing go run exercise slash loops. And so if we start at the top, we see we have one, two and then fizz. So this would be three, which is divisible by three. Four, five, buzz.
01:53:35.366 - 01:53:55.232, Speaker B: Divisible by five. And here we have nine, etcetera. And here, here's 15. This is our first number, divisible by both three and five. So our program is working properly and we go all the way up to 50 down here, which is divisible by five. So we print buzz. This concludes the exercise on loops.
01:53:55.232 - 01:54:39.790, Speaker B: I'll see you in the next presentation. In this coding exercise, we'll be creating a program that reviews some of the topics that we've covered so far in this section that includes control flow and looping and creating variables. Well also be using some new standard library packages to retrieve the system time and generate random numbers. To access the go package registry, you can navigate to this URL right here. Pkg dot go dot de v std. Open up your browser and navigate there now because we'll be using that shortly. Once you're ready, open up visual studio code and let's go.
01:54:39.790 - 01:55:36.202, Speaker B: Once visual studio code loads, navigate to your exercise directory. We are doing the SR dice project, so click on that and then double click on dice go. Before I hand off this exercise to you to do on your own, let's take a quick look at the go package library on the Internet here I've navigated to PkG dot gov dot dev std and std is just short for standard. This page is a listing of all the standard library functionality that's provided with the go programming language. The standard library is just a set of tools you can use to make it more easy to create programs. For this particular exercise, we're going to be needing random numbers for the dice rolling. So you can go down to the math module right here and then click on rand.
01:55:36.202 - 01:56:13.724, Speaker B: And rand just helps generate random numbers. If we scroll down in our rand package, you'll see that there is an overview section and a few examples that you can click on. We also have the package index right here which lists out all the functionality available within the back within the package. So let's click on the example code. It also has some code comments and so it tells us that we can seed our random number generator. And seeding just sets the initial value. And then once our random number generator is seeded, we can use the rand dot int n function to select a number within a range.
01:56:13.724 - 01:56:44.760, Speaker B: So if we scroll down to the int n function right here and click it here, we have int n. This is the function that you'll need to use within your code in order to complete the exercise. All it does is pick a number between zero and n. The parenthesis means it does not include n. So if you have the n as equal to five, for example, and you want to include it, you'll need to have n be six. That way you can get your five out. We also have example code and it shows you how to use this function.
01:56:44.760 - 01:57:23.980, Speaker B: Now that you have that information, let's hop back into visual studio code. Even though we are covering a few new topics in this exercise, I would still give it a go on your own first with the video paused and once completed, resume the video for my implementation. That way you can see an alternative solution to the problem. Alright, let's go. So in this exercise we're going to be creating a dice rolling program and we're going to print out information based on what the roll is. One thing to note about this program is we have to be able to handle any number of dice rolls and sides of. So we're not going to just be able to pick a number between zero through six or one through six and then just print out the answer.
01:57:23.980 - 01:57:59.306, Speaker B: So we have to be able to handle multiple dice, multiple rolls and any number of sides. So the first thing I'm going to be doing is importing the packages that we need. So we also need the math slash rand package and the time package from the standard library. Once those are imported, we can go down into our main function and start working on the program. The first thing we should do is seed the random number generator. What seeding does is it sets the initial value for the random numbers. So if you use the same seed value whenever you run the program, you will get the same random numbers back.
01:57:59.306 - 01:58:29.716, Speaker B: We want to have different random numbers. So to do so, I'm going to do rand seed and the seed value is going to be the current time. So we can use the time package, the now function, and then get the Unix nano function. The Unix nano function will get the number of nanoseconds since the start of the Unix epoch, which is in the 1970s. So since every time I run the program, it'll be a different nanosecond. Hopefully. Unless you can run it really, really fast, then the seed will be different.
01:58:29.716 - 01:58:58.754, Speaker B: And every time we run the program, the random dice rolls will be different. Next, I'll set the number of dice that we have and the number of sides on each dice. So I'm going to go with two dice and each one has twelve sides. I'm also going to set the number of rolls that we'll be doing. So we'll set it just one roll for now. Next, we need to create a loop. And so since we have multiple dies and multiple rolls, we should have the rolls be the outer loop.
01:58:58.754 - 01:59:27.970, Speaker B: So I'll use the variable r to be the outer loop for the number of rolls. As long as that's less than or equal to the number of rolls, we're going to keep going. So one of the requirements is to print out a message if our roll total is equal to a certain number. So we'll need to keep track of our roll total. So I'll just make a variable named sum and we'll set that to zero. We're now going to need an inner loop, and the inner loop will take care of each dice that's in this particular roll. So I'm going to use d for the dice counter.
01:59:27.970 - 01:59:58.930, Speaker B: I'll set it to one, and as long as d is less than or equal to the number of dice that we have, we'll increment it. Since this will be our dice rolling loop, we need to make a function that actually rolls the dice. So we're going to create that. Now, I'll name the function roll and we'll just specify the number of sides that we want. It's going to return the roll that we got back. We'll then return rand and we'll use the int n function that was mentioned in the beginning of the video. We'll take the number of sides and we'll add one to it.
01:59:58.930 - 02:00:21.460, Speaker B: The reason we need to add one to the number of sides is because the int n function starts at zero. But dice don't have a zero number. They always start at one. So we just add one to whatever the result is. Go back down to our dice rolling loop. We'll create a variable and that will be whatever the roll happens to be. So we'll roll and we'll roll the number of sides.
02:00:21.460 - 02:01:00.082, Speaker B: We'll then add to our sum whatever we happen to roll. We're going to print out a message. So this will be the terminal message that displays what role number we're on, what dice number we're on and what the role actually was. So here we have r, which is our current roll number. Right here. We have die number d, which is right here. And then we have the value that was rolled for that particular die, which is calculated right here.
02:01:00.082 - 02:02:11.280, Speaker B: When we call the roll function, the next thing we'll do is print out the total sum for this particular dice roll. We're now going to switch on this sum and we're going to print out different messages based on what the total is. I'm going to pull in the program requirements so we know exactly what totals we're working with. This first one will be snake eyes. Next we'll do lucky seven. After that we'll do even. And finally we'll do oddity.
02:02:11.280 - 02:02:41.212, Speaker B: We're not going to have a default case because if there's a default case, we don't want to print any additional information since that's not part of the requirements. So this should be our program completed. Now we've hit all the requirements. We print out all the necessary information. We add up the sum and we print out messages based on what that sum is. So let's run it. Remember, we have two dice and we have a both of them are twelve sided dice and we're going to do one roll.
02:02:41.212 - 02:03:15.822, Speaker B: So what we should be getting is we should get a roll number printed out along with two dice rolls, which side was rolled and the total. I'm going to go ahead and save the file and now hop over into a terminal. We can run this project with go run exercise sr dice. Make sure in the correct folder, gotta be in the lectures folder and we'll try that again. So here we have our roll number. So both of these dice are for roll number one. And we have the first one and the second one.
02:03:15.822 - 02:03:42.964, Speaker B: The first one rolled a three, the second rolled a five. And the total is eight. And that is an even roll. I'm going to change the number of rolls to make sure that we do handle multiple roles. I'm going to change the number of sides to just a typical six sided die. So maybe we'll be able to hit some of these cases easier back in our terminal. And here we have our second roll.
02:03:42.964 - 02:03:55.400, Speaker B: Down here we did roll a seven. And so we got the lucky seven printed out. This concludes the section review exercise on the fundamentals portion of the course. I'll see you in the next presentation.
02:04:04.120 - 02:04:33.874, Speaker A: Before anything else, let me congratulate you. Go. Is by no means easy to learn and you've already made it a significant way through Jason's full course. So for that, make sure to pat yourselves on the back, but don't put your feet ups just yet, because if you're serious about mastering go. Your learning can't stop here. In fact, now's the time to turn it up and take the rest of Jason's complete go boot camp course, where there's plenty of more exercises waiting for you. Plus a very cool pixel project, if I do say so myself.
02:04:33.874 - 02:04:53.860, Speaker A: You can check it out in the description below, or just watch the video right there on your screen to see everything you'll learn in the rest of the course. One last thing, if you enjoyed this crash course, the least you could do is show Jason some love by dropping this video a like and letting him know your thoughts in the comments below. Alright, that's it for today, and I look forward to seeing you in inside the zero to mastery academy.
