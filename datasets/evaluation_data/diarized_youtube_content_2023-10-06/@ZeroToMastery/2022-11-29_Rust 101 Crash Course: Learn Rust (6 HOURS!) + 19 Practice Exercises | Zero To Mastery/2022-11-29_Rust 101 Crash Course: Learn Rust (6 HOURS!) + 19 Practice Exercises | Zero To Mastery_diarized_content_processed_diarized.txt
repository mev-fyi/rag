00:00:04.360 - 00:00:38.658, Speaker A: What is going on, peeps? It is Aldo from zero to mastery and today I'm excited to introduce to you our latest crash course, Rust 101 by Jason Lennon. You can check out our other crash courses on react and python, and more to come soon on our main channel page. There's so much I can say about Jason. I really don't know where to start. But let me say this. Jason is an outstanding instructor who started his journey as a self taught developer, and from there he transitioned into a university student. But why is this important, you ask? Because this gives Jason a dual perspective that most instructors out there simply do not have.
00:00:38.658 - 00:01:26.298, Speaker A: Jason understands the struggle of being a self taught developer, but at the same time, he recognizes how difficult it can be to understand complex matters as a university student, which is what makes him so great, his ability to break down complex topics in a fun and digestible way. And now you're getting to learn Russ from him for free. You better be excited. Now youve heard me talk about what makes Jason such an excellent instructor, but how does he actually help you understand these difficult topics? Well, Jason is a huge believer in the concept of learning by doing, and thats what you guys are going to do in this video. Jason is going to start from the very beginning and teach you the complete fundamentals of rust from scratch. From there, youll have the ability to work on numerous different activities to really help cement those topics. There are 19 activities in this crash course alone.
00:01:26.298 - 00:02:01.990, Speaker A: If you end up liking this video and want to dive deeper into more complex rust topics, then I highly recommend you check out his complete rust bootcamp course, where there are a lot more activities for you to get your hands on. But not only will you be working on activities with this bootcamp, you'll build two massive projects, one being a billing application, the second being a clipboard web service that includes handlebar template rendering, state and cookie management, and even database connections. You can check it out using the link in the top right hand corner and in the description down below. But enough chitchat for me. Let me hand it over to Jason so you can start learning Rust. Enjoy.
00:02:04.770 - 00:02:35.500, Speaker B: Welcome to the Rust course. If you want to write blazing fast programs that are easy to maintain, fun to write, and almost never crash, then you are in the right place. In this video, I'll be going over some basics about the course and what you can expect. Why Rust? Rust has high level language features without any performance penalties. The language design allows program behaviors to be enforced by the compiler. This greatly enhances program reliability. It has built in dependency management similar to the NPM registry in JavaScript.
00:02:35.500 - 00:03:17.240, Speaker B: There is a quickly growing ecosystem of libraries that can be used in your programs, and there is a fantastic developer community that is friendly and generally welcoming to new contributors. Here are a few features that set Rust apart from other languages. Rust has first class multi threading support. It is actually a compiler error to improperly access shared data. This makes writing threaded code easy. It has an advanced type system that is powerful enough to help uncover bugs at compile time, makes refactoring a breeze, and reduces the number of tests needed to ensure your code is correct. Rust has a robust module system with flexible rules that allow you to separate your code as much or as little as you like.
00:03:17.240 - 00:04:05.378, Speaker B: Adding a dependency is just one line in a configuration file. All that is needed is the name of the library and a version number. Once these are added, the library can be used in your project, and it will be automatically downloaded and linked on the next compilation. Lastly, Rust comes with tools to generate documentation, lint your code for common problems, and automatically format your code to conform to consistent style used across all rust projects. Here's a little bit about the course. Rust is different than many languages by design, and using concepts and idioms from other languages like Python, C sharp, or JavaScript will result in frustrating errors. To alleviate this, I employ a clean slate approach in the course and assume each topic as a brand new, never before seen concept.
00:04:05.378 - 00:04:47.646, Speaker B: So the topics start at the most basic level and slowly build upon each other into a coherent whole. This is important because subtle language differences determine whether you are learning rust or learning how to fight the compiler. Finally, there are over 40 coding exercises to help become familiar with writing programs in rust. I hope you enjoy the course, and I'm looking forward to teaching you rust. In this video, I'll be explaining what data types are in programs. I'll give you some examples of basic data types, and I'll explain how programs use binary to store any type of data. Memory only stores binary data.
00:04:47.646 - 00:05:26.362, Speaker B: However, anything can be represented using binary. Usually the programmer works at a higher level than binary, so you generally don't need to worry about the underlying binary data. Programs determine what this binary data represents, and the code that you write is automatically converted into binary representations. Basic types that are universally useful are provided by the language itself. However, we're not limited to just these types that are provided. You can create your own types that you need for your specific problems, and we'll be covering that in later videos. The basic types provided by the rust programming language is the boolean type.
00:05:26.362 - 00:05:50.908, Speaker B: The boolean type is either true or false. The next type is an integer type. Integers are just whole numbers. Some examples are one, two, and 50 negative numbers are also covered by the integer type. Double or floating point numbers are decimal point numbers. 1.15.5 are both examples of double or floating point numbers.
00:05:50.908 - 00:06:30.900, Speaker B: Characters are just single characters that you see on your keyboard. Capital a, capital b, lowercase c, the number six, and a dollar sign. Note that with characters we surround them within a single quotation mark, and the character six is separate from the number six. So if you want to use the number six, you would do so without the quotation marks. But if you want the number six to be displayed as a character, you would use the quotation marks. The difference is when we have the quotation marks. This means that this character will be displayed to the user without the quotation marks.
00:06:30.900 - 00:07:04.020, Speaker B: It is now suitable for usage in mathematical operations. Lastly, we have the string type. Strings are just a string of characters. We use double quotes to denote strings, and you can have any number of characters between the double quotes. To recap, anything can be represented with binary data. The basic data types are boolean, integer, double, and float character, and string. In this video, I'll be covering variables.
00:07:04.020 - 00:07:51.688, Speaker B: I'll be explaining what variables are, how they help programmers, and how to use variables in your programs. So what is a variable anyway? Variables are a way to assign data to a temporary memory location, which allows the programmer to easily work with memory. So I know we've covered memory in the previous videos. However, all of that can be abstracted away using variables which keep track of all that for you. This makes it much, much easier to reason about your programs, since all you need to do is create a variable name and everything happens behind the scenes. So variables can be set to any value and any data type. By default, variables are immutable, but they can be made mutable.
00:07:51.688 - 00:08:36.788, Speaker B: Immutable means the data cannot be changed once the variable is created, and this is the default because it makes it easier to reason about programs and less likely to make programming errors. Additionally, the language is able to increase the speed of your program when you have immutable data because it doesn't need to check if anything was changed, because nothing can change since it's immutable. And conversely, immutable just means you can change it later. There are some examples. This is also the first time we're seeing rust code, so this is actual code that you would be typing if you were to be making a program. So let's start from the beginning. First, we have the word let.
00:08:36.788 - 00:09:00.468, Speaker B: This is a keyword in the rust language, and it's used for creating variables. Next we have the variable name. This one is name two. We use a single equal sign to assign a value to the variable. Next we have the number two. This is the data that's being assigned to the variable. Lastly, we end the statement with a semicolon variable.
00:09:00.468 - 00:09:56.470, Speaker B: Assignments always end with a semicolon because you're taking a single action. We're just creating a variable and then we're done. The semicolon indicates to the language that we need to move on to the next line, but whenever the semicolon is encountered, it will move on to the next. So if you were to read this in plain English, you would say let some variable named two be assigned the value of two, and so the two will then be within that variable name two, and you'd be able to use it throughout your program. Next we have let some variable named hello be assigned a string hello. So if you recall strings use double quotes. So this data is a word and it is going into the hello variable.
00:09:56.470 - 00:10:47.506, Speaker B: Let some variable name j be assigned the character j. This is a character because we have single quotes, so we can put one character into the j variable. Let some variable named my half we assigned the value of 0.5. Variables can have more than one word in their name, so you'll use an underscore to separate words within a variable name. This can be useful to make variables easier to read versus placing all the words smashed together. Next we have let a mutable variable named myname. We assign the value of bill.
00:10:47.506 - 00:11:27.248, Speaker B: So again we have another string. This time, however, we have a mutable variable. So this variable, my name, can be assigned a different value later, but right now it has the value of bill, but later on we can change it to a different name. Let quit program be assigned the value of falsehood. So this is a boolean variable, and it's named quit program because perhaps it determines whether or not the program ends. It's really useful to name your variables in a way that represents what they are supposed to be accomplishing. This helps later on when you go to read the program.
00:11:27.248 - 00:12:02.660, Speaker B: It helps you follow the logic of your program much, much easier. Last, we have let your half be assigned the value my half. As we can see, my half is not a boolean value. It's not a string or a number or a character. So what's going on here? So let's walk through it. If you'll notice, my half down here is the same as my half. Here, what we're doing, we're actually assigning your half the same value as my half.
00:12:02.660 - 00:12:31.030, Speaker B: So let's walk through each step on the way to see how that occurs. So in the my half variable, we have 0.5, which then gets assigned to my half. Here, down in your half, we have the my half variable. So this will then get assigned to my half. So that is 0.5, and then it in turn gets assigned to your half.
00:12:31.030 - 00:13:21.422, Speaker B: The end result is both your half and my half have the value of 0.5. As you can see, this can get pretty complicated pretty quickly. We only have a few lines of code here, and already there's lines kind of scribbled all over the place. So in the next video, we'll be covering how to keep all this organized in a way that is easy to follow, versus having a block of seven or eight variables all in one place. To recap, variables make it easy to work with data and in turn memory. Since you don't need to memorize any memory locations, the variables take care of all that for you. Variables can be assigned to any value and any data type.
00:13:21.422 - 00:13:55.484, Speaker B: This includes the value and types of other variables. By default, variables are immutable. However, you can use the mut keyword to make them mutable if you need to change it later on in the program. In this video, I'll be going over functions. I'll be explaining what functions are, how to make functions, and how to use functions. So what are functions? Functions are a way to encapsulate program functionality. They can optionally accept data, and they can optionally return data.
00:13:55.484 - 00:14:20.340, Speaker B: They're utilized for code organization, and they also make code much easier to read. Let's take a look at the anatomy of a function. So here we have a function. It's composed of many parts, which I'll be breaking down. First, we have the fn keyword. So fn begins a new function. Next we have the name of the function.
00:14:20.340 - 00:14:57.190, Speaker B: The name could be anything, as long as it does not start with a number and is not an existing keyword. So we can't make a function that's named fn because fn is already a keyword in the rust language. Next we have the function parameters. So the function parameters dictate what kind of data this function works with. Function parameters always begin with an open parentheses and end with a closing parentheses. The a and the b are variables that will be used within the function. After the variable name, we have a colon.
00:14:57.190 - 00:15:34.596, Speaker B: After the colon, we have the type of the parameter that is accepted for this function. The function parameter type can be any type that's made by you or that's part of the rust language. In this case, the I 32 is just a 32 bit integer. You can also have multiple function parameters. You separate them with a comma and then they follow the same pattern name of the variable colon and then the name of the type. Usually with functions, you'll accept some data through the parameters. You'll then do some calculations, and then you'll return some data.
00:15:34.596 - 00:16:05.010, Speaker B: To return data, we create an arrow. The arrow is composed of a dash and a greater than symbol. We then specify the type of data that we're returning. In this case, we are returning a 32 bit integer from the function. Once the data gets returned from the function, it will be able to be used elsewhere in the program. Lastly, we have the function body. The function body is surrounded by an opening curly brace here and a closing curly brace here.
00:16:05.010 - 00:16:40.020, Speaker B: Everything between these braces is called the function body. The function body for our particular function is just a plus b. So this function is going to add together an a value and a b value. We know from the function parameters that the a is a 32 bit integer and the b is a 32 bit integer. And so these 32 bit integers are represented by a and b. And within the function body we have the a and the bhiddeen. Now that we know how to make a function, let's see how we can actually utilize it in a program.
00:16:40.020 - 00:17:17.010, Speaker B: So here at the top we have our add function that we just created, and we also are creating some variables down here. So we'll take a look at this first one here we're using let x. So we're creating a variable named x. We're setting it equal to the value returned by this function additive. So when we want to use a function, it's known as calling a function. So what we're doing here, when we have add, we're calling this add function. We're calling it with the values of one and one.
00:17:17.010 - 00:18:10.510, Speaker B: So when you call it, you have to have parentheses along with the values that are going to take the place of the parameters. These values that are provided to the function, they're called function arguments. So the argument for the a parameter is one, and the argument for the b parameter is also one. So when we call this add function, this one here will go into this a, this one here will go into this b. Once the function begins executing this a, we'll go here, this b will go here, and we'll get one plus one. That's because our a value here is a one and our b value here is also a one. After this one and one get added together, we'll get a two.
00:18:10.510 - 00:18:49.560, Speaker B: And since we reach the end of the function body here, there's nothing past this point. This two is going to get returned, and two is an integer. So it's valid for an I 32 integer. The number two is going to return here, and then the two will get assigned to x. So you can think of calling add with the values of one and one. You can just think of this whole thing as the number two, which is then placed into xdev. So our x will now be equal to two.
00:18:49.560 - 00:19:26.358, Speaker B: Let's go ahead and do another one. We'll take a look at let y equals. We're going to let the variable y be equal to the value of the function add with function arguments three and zero. So when we call this add function, this three will come up here to the a, so that will be three. This zero will come to the b, and that will be zero. Once execution enters this function, we have our three and our zero there. So the a will come down to the a variable, the b will come down to the b variable.
00:19:26.358 - 00:19:52.760, Speaker B: Then we'll get three plus zero is equal to three. There's nothing left in the function. So this will return as a three. That will then replace this portion here. So now this will be equal to three, and then it will be assigned to the variable y. So y will be equal to three. And let's take a look at one more.
00:19:52.760 - 00:20:32.418, Speaker B: So we have let some variable z be equal to the function add. And now instead of adding numbers, we're adding another variable. So we're adding the value of the x variable with the number one. Just a moment ago we had the x set to the value of add one and one. And we know that this ends up being two because we're adding one and one together. So x is equal to two. When we call add with the variable x, this two from x will come over here, be populated into this x, so this will be equal to two.
00:20:32.418 - 00:21:02.450, Speaker B: And so then we're going to add two and one together. So the x is a two at this point. That's going to go into the a value, one is going to go into the b value. So that will be two and one. So we have two, one that will go into a. B will go into b, so get two plus one equal to three. We then return the three that comes down here.
00:21:02.450 - 00:21:39.530, Speaker B: This will get replaced with a three, and z is now equal to three. It may seem a little bit convoluted and confusing the first few times you see it, but calling functions and using functions and writing functions is fundamental to programming. So everything you make is going to be inside a function or using a function of some sort. So once you do three or four functions, you'll have the hang of it, no problem. To recap, functions encapsulate functionality. They're useful to organize code. Functions can be executed by calling the function.
00:21:39.530 - 00:22:23.452, Speaker B: The function parameters determine what data a function can work with. Functions optionally return data, and that means data gets sent back from the function to be used elsewhere. In this video, I'll be covering the printline macro. Macros are similar to functions, except instead of running code, they expand into more code. The println macro prints or displays information to the terminal. This would mean when we use printline, it expands into additional code, and that code will print information onto the terminal. And this could be useful for debugging here in this code example, we're creating a variable named life and setting the value to 42.
00:22:23.452 - 00:22:56.770, Speaker B: We then use the print line macro println with the exclamation point at the end. The exclamation point indicates that we're using a macro instead of a function. We then have parentheses, just like we do with the function, and then our data. Inside our data, in this case is the string hello. So this means when the println macro is called hello will be printed to the terminal. Next we have a print line with this sequence of tokens. This sequence of tokens indicates that we're able to take some external value and include it within the macro.
00:22:56.770 - 00:23:46.590, Speaker B: So what we're doing is we're taking this variable life, placing it right here, and then it's available for usage here in this specific token. All of the tokens start and end with curly braces. So we have the opening curly brace and the closing curly brace. We use a colon followed by a question mark to indicate we want to do a debug print. And a debug print is just whatever text that you want to see as a developer, and it's not meant to be seen by end users of your application. We're able to use the debug print as many times as we like, and so here we're using it twice, and then we use the variable life both times. This means that our third invocation of the print line macro, we'll print out 42, followed by a space and then 42.
00:23:46.590 - 00:24:31.402, Speaker B: It's possible to mix and match any characters that we would like so here on this last invocation, we're going to print out a short phrase. The meaning is, and then this will be 42 because we're pulling 42 out of the life variable. It's also possible to directly use variables within our string here. So instead of having to have a comma and then additional things, we can just include the variable name, our colon, and then our question mark. And here on our second invocation, we don't have a colon question mark, but that would indicate that this is printing out the end user display version instead of the debug version. So colon is for debugging, and then you can just take that part off for end user display. Let's do a quick recap.
00:24:31.402 - 00:25:21.360, Speaker B: Macros use an exclamation point to call or invoke. When you invoke a macro, additional rust code will be generated. To print things onto the terminal, we can use the print line macro and to supply variable data to the macro we can use the opening and closing curly braces, and within it we can have a colon question mark, or we can use the variable name followed by in this video, I'll be going over control flow using the if statement. If statements can be used to add logic to programs and determine which line of code will execute next. When running a program, code is executed line by line. Actions are performed and the control flow may change. Specific conditions can change this control.
00:25:21.360 - 00:25:51.480, Speaker B: For example, if else and else if. Let's take a look at a simple control flow. On the left we have a flowchart, and on the right we have some rust code. In this example, control is linear and doesn't branch off. To begin, we start with the program. We have a variable named a, which we set equal to one. We then have a variable named b set to two, and a variable named c set to three.
00:25:51.480 - 00:26:21.690, Speaker B: After that's completed, the program ends. Translated to code, we have let some variable named a, we assign the value of one. We repeat the process with b and with c. Now we're going to introduce some logic. We'll start with the flowchart on the left. So the program begins and we assign the value of 99 to a. We then go down here to the diamond.
00:26:21.690 - 00:27:05.500, Speaker B: Diamonds and diagrams usually indicate that a decision is being made. Here we're checking to see if a is greater than 99. If it's not greater than 99, we're going to print out small number, and if it is greater than 99, we're going to print out big number. In both cases, we're going to end the program after a message has been printed. So let's see how this translates into code. First, we create a variable named a and set it to a value of 99. Next, we perform what's called an if statement.
00:27:05.500 - 00:27:36.630, Speaker B: So an if statement goes something like this. We use the keyword if and then have a condition. The condition evaluates to either true or false. If it's true, this first portion will be executed. If it's false, the second portion will be executed. You can see that these portions are enclosed within curly braces. And we also have this else keyword in between.
00:27:36.630 - 00:28:17.100, Speaker B: If some condition is true, do this. Otherwise, do this. In our example, if a is greater than 99, we're going to print out big number just as indicated by the flowchart. Otherwise, we're going to print out small number just as indicated here. Now we're going to take a look at a nested if else statement. We'll start with the diagram on the left. The program begins and we set the variable a equal to 99.
00:28:17.100 - 00:28:56.020, Speaker B: We then check to see if a is greater than 99. If so, we perform another check to see if a is greater than 200, and if it is, we print huge number. If it is not, we print big number. Either case results in the program ending. If a is not greater than 99, we'll simply print small number and end the program. Now let's see how that translates to code. First, we set the variable a to 99.
00:28:56.020 - 00:29:57.520, Speaker B: Then we have our check is a greater than 99 is that's represented by this code as the previous example we have. If some condition is true, we will then enter this block of code. In this case, we're checking to see if a is greater than 99, and if it is, we'll perform another check here and we'll see is a greater than 200. If so, we enter this block of code here and we'll print huge number. If it's not greater than 200 and this evaluates to false, control will then go to this else statement, and we'll execute the code here. Print big number. If the first if statement evaluates to false where a is not greater than 99, control will go to this else statement.
00:29:57.520 - 00:30:31.770, Speaker B: Enter into this block here, and print out small number. Let's take a look at another program that uses the same flowchart but slightly different code. We'll be using the if else statement instead of just nesting if statements. Before we get started, let's talk real quick about how else if statements work. So first we have an if statement and a condition is checked. That condition evaluates to false. Then the next else if statement will be checked.
00:30:31.770 - 00:31:31.620, Speaker B: If this condition is also false, then the next one will be checked, and the next all the way until you end up at the else statement, in which case it will be executed, assuming all the other checks failed. When evaluating these statements, if either one of these evaluates to true as usual, the inner part will be executed, and then once execution is complete, it will then jump out of this else block in both cases, and this will never be executed. So let's see how that actually works when we're using the flowchart. First we'll set a to 99. Then immediately our flowchart diverges from our code. As we can see, in our flowchart, we check 99 first and then 200. However, in our else if statements, we check 201st and then 99.
00:31:31.620 - 00:32:21.260, Speaker B: But why do we do that? If we take a look here at the bottom where it's commented, this will not work. Let's see what happens if we use the same order as the flowchart. So let's say we have a number 100, and we check to see if it's greater than 99 and it is. So then big number will print. After that flow will then be redirected to outside the if else chain. However, if we have a number that, let's say 300, 300 is greater than 99, so it's still going to print big number and then it will exit the if chain. But as we can see, we want to print huge number if it's greater than 300.
00:32:21.260 - 00:33:02.790, Speaker B: So we need to check the largest number first and then check lesser numbers subsequently, which is what we're doing here in the original code. So this will not work as intended. So first we check to see if a is greater than 200. If so, we'll print out huge number. Control would then end up here if the statement evaluated to false. If a is not greater than 200, we then go to this else if and we check to see okay is a greater than 99. And if it is, we'll print out big number and then exits the block.
00:33:02.790 - 00:33:43.624, Speaker B: If a is still not bigger than 99, then we just go down here to the else statement, which will take all cases regardless of the number size, and it'll print out small number. To recap, code executes line by line. This can be changed using the if statement. Try to always include else statements unless there truly is no alternative case. You want to do this. That way all cases are covered and you don't end up in a situation where you're missing a case and your program doesn't behave as expected in this video. We'll be taking a look at repetition.
00:33:43.624 - 00:34:30.290, Speaker B: In programs specifically, we'll see how to make loops that perform actions multiple times. So in programming we usually call repetition, looping, or iteration. There are multiple types of loops available in rust. The first one we'll take a look at is the loop keyword, which creates an infinite loop, and the second one we'll be looking at is called the while loop, and that creates a conditional loop. The infinite loop will go on forever until it encounters a situation where it breaks out of the loop, whereas the while loop will automatically check some condition, and then once that condition is met, the loop will terminate. So let's look at the infinite loop. First, we'll take a look at the flow chart on the left.
00:34:30.290 - 00:35:07.300, Speaker B: Here we have the program start, and then we assign the variable a to the value of zero. This variable is what we'll be using to determine whether or not the loop should continue. We then have a conditional statement. We check to see if a is equal to five. In rust, we use two equal signs to check if a value is equal to a variable. So if a is not equal to five, we're going to print that value. We're going to increment that value, which just means add one.
00:35:07.300 - 00:35:34.490, Speaker B: Then we're going to check it again. If it's still not equal to five, we'll then repeat the process. Once it is equal to five, we'll end the program. So let's see how that looks in code. First, we make our variable notice that we set it to be mutable. We do that so we're able to change the value of a within the loop. That way, we can eventually break out.
00:35:34.490 - 00:36:16.290, Speaker B: If we don't do this, then the loop will go on forever until we manually kill the process. Next, we have the loop keyword and some curly braces. This creates a new block of code which will be executed each time the loop iterates. We then close the block using a closing curly brace. Within this block, we have our check if a is equal to five, and that is here. So if a is equal to five, we're going to break out of the loop. Remember, with if statements, it also creates a block that's enclosed within curly braces.
00:36:16.290 - 00:37:05.280, Speaker B: So once this condition a is equal to five evaluates to true, we're going to break out of the loop. Once we encounter a break statement, execution will automatically advance to just outside the loop and execute the next line. In this case, there are no more lines, so the program will terminate. However, if a is not equal to five, for example, on the first iteration, it's equal to zero. So this will evaluate to false, and it won't be executed. That means execution will continue to after the curly brace, and then we'll print line with the value of a indicated in the flowchart. The next line will increment a.
00:37:05.280 - 00:37:47.280, Speaker B: In order to do that, we assign a the value of a plus one. So all we're doing is increasing a by one. Next, once the end of the loop block is encountered, we then return back to the beginning and perform the same thing again. So we'll do the check. If it's false, we'll go here again, execute this, increase the value, it'll then be two. By this point, go again, and it repeats until a is finally equal to five, in which case we break, and then, as previously stated, we exit the loop. Now let's take a look at a while loop.
00:37:47.280 - 00:38:29.580, Speaker B: We're using the same program for the flowchart, so let's just jump right into the code of first we have a equal to zero. Just as with the previous program, we're using a mutable a because we're going to be changing it on each iteration of the loop. Next, we have the while keyword. The while keyword creates a loop based on a condition. In this case, the condition we're checking is to see if a is not equal to five. In rust, an exclamation point followed by an equal sign means check to see if not equal. In our particular case, a is equal to zero at this moment.
00:38:29.580 - 00:39:19.770, Speaker B: So this will evaluate to true since a is not five, since it evaluates to true. We will then enter the block of the while loop and begin execution of the code. So first we print the value of a as indicated by the print line macro. Next, we increment a by reassigning a to itself plus one. On the first iteration of the loop, a will be set to one. Execution will then reach the end of the loop, return to the conditional check, and it'll be checked again. So on this iteration, a will be equal to one, which is still not equal to five, and so this will be true.
00:39:19.770 - 00:39:52.558, Speaker B: We'll then enter into the loop again, perform the same thing. A will then increase to two. Two is still not equal to five, and this will continue until finally a will be equal to five. After adding plus one enough times, this will evaluate to false, and then the loop will exit. The loop exits. There's no more code available, so then the program ends. To recap, repetition can be performed by using loops.
00:39:52.558 - 00:40:38.270, Speaker B: There's the while loop, which has a condition that's checked on each iteration of the loop. And then there's the infinite loop, which requires the programmer to insert a statement to check to see whether or not the loop should be exited. Both types of loops can be terminated by using the break command. In this video, I'll be going over how to download and install the tools necessary to build rust programs. For Windows users, we'll be needing three things, Rustup Visual studio code, and the MSVC C build tools. Rustup is a tool that manages Rust installations. It will download and set up the Rust toolchain in order to work on your system.
00:40:38.270 - 00:41:33.216, Speaker B: Visual Studio code is a development environment that's compatible with the Rust programming language, and the MSVC C build tools are needed to build rust programs on windows. Rust is compatible with Windows, Mac, and Linux, so if you're on Mac, you can use the homebrew tool to install the Rustup init package along with Visual Studio code. If you're on Linux, you can use the curl command to download Rustup and then set it up automatically. Or you can use your package manager and see if it has the rustup tool present. If so, you can use it to download and install the Rust toolchain. If you're on Mac or Linux and have used the package manager to install the rustup tool after the installation, run Rustup toolchain install stable this will download the compiler and set it up for you. If you're on Windows, continue watching for a step by step tutorial on how to get everything set up on the Windows platform.
00:41:33.216 - 00:42:12.880, Speaker B: So the first thing you'll want to do is open up your web browser and then navigate to rust dash lang.org dot. Once there, you'll want to click on install and then click on the download rustup init exe. After the executable is downloaded, open it up and it will prompt you on the installation options. In most cases, you can just proceed with the default installation, which is number one, so just type in one and hit enter. After you hit enter, the rust toolchain will be downloaded and installed. This may take a few moments.
00:42:12.880 - 00:42:50.932, Speaker B: Once the installation is completed, you'll get a message indicating that rust is now installed. Next, we'll install the Microsoft C build tools. You can access the build tools by clicking on the link that's on the install rust page and then clicking on download build tools. Once you click on download build tools, the download will start automatically in a moment. After the build tools are downloaded, go ahead and open it up and you'll be prompted with some installation options. If you've already downloaded the build tools and installed them before, go ahead and update if needed. Once the installation is complete, click on modify on the right.
00:42:50.932 - 00:43:24.900, Speaker B: You want to make sure that the MSVC is checked and the Windows ten SDK is checked. These are both required in order to build rust code. If it's not checked, go ahead and check it and click modify in the bottom right. Once installed, you can close the installer because that portion of the installation is now complete. Next, we're going to download the visual Studio code editor. The visual Studio code editor can be accessed at code dot visualstudio.com. once the page loads, just click on download for Windows and the download will begin momentarily.
00:43:24.900 - 00:44:17.910, Speaker B: After the download completes, open up the setup file. You'll need to accept the agreement and then click next. The installer default options work fine, but for my case, I just checked all the boxes. Once you're ready, click next, and then click install. Once the installation completes, we're going to uncheck the launch visual studio code checkbox because we need to either log out of our computer or restart the computer. After logging out or restarting, you can open up visual studio code and go to terminal new terminal what we're going to be doing is testing to make sure that your rust installation was completed successfully. Once the terminal opens, type in cargo init hello, you should get a message saying that there is a new binary application created.
00:44:17.910 - 00:45:02.310, Speaker B: Go to File open folder, click on hello, and then click on select folder in the bottom right. The editor will reload. Once the editor reloads, you'll see that we have a main rs file with some rust code in it. Go ahead and click on terminal new terminal type in cargo run and the program should compile and run and you should see a message indicating hello world. Once you see that message, you know that your rust installation is complete and working properly and you'll be ready to write rust code if there are any errors. When you attempt to execute cargo run, please see the video description for possible workarounds and fixes. Otherwise, you're ready to get started.
00:45:02.310 - 00:45:38.910, Speaker B: In this demo, I'll be going over code comments and how they can be used to increase the understanding of your code for yourself and for future developers. So here we have the initial program that's created using the cargo build tool. When you make a new project, it simply prints hello world to the console. Let's add some comments to enhance the readability of this program a little. In order to add comments, do two forward slashes followed by your comment. I left a comment. This is the entry point of the application.
00:45:38.910 - 00:46:15.280, Speaker B: The entry point of an application is simply the very first function that's ran. When your program gets executed, I want this to be two lines long. That way it fits better on the screen. To do that, we can have an additional line with two slashes, and that completes our code comment for the main function. Next, I'm going to add a comment above the print line macro to display the reason why we're doing this print line. So I'm going to state display a message. So this comment could use a little bit of improvement.
00:46:15.280 - 00:46:50.360, Speaker B: Judging by the print line macro, we can assume that it's probably displaying a message. So this comment seems like it may be a little unnecessary. I'm going to add more context so we know why we're displaying a message. Now. The comment reads display a message to the user. So now when we encounter this particular print line macro, we know that we're both displaying a message and the target of the message is a user. In multi user scenarios, there could be guest users, administrator users, manager users.
00:46:50.360 - 00:47:41.626, Speaker B: However, we now know that this is just being displayed to a typical user and we can adjust it accordingly in future iterations of the code, usually with code comments, you want it to enhance the code that you've already written, and the code should generally speak for itself. In many cases, comments are unnecessary as the code should be clear enough to where you can read it and understand what's going on. However, sometimes code gets a little complicated and it helps to have comments in those cases. Let me give you an example. I'm going to make a variable called a, and I'm going to assign it the value of red. Now, as we can see, we know that there's a string value of red, but we don't know what it is being used for or the purpose. And we know a is just a letter of the Alphabet.
00:47:41.626 - 00:48:19.756, Speaker B: It doesn't describe anything particular, and we're not sure how this could be used in the program. Red could be the color of a program, it could be the color of a cardinal, it could be a signal light to stop cars. We just don't know. So if we add a comment, my favorite color, we now know that the a is my favorite color. However, we can do better than this. Let's just delete this comment and simply rename the variable. Now we know that this red is actually my favorite color.
00:48:19.756 - 00:48:58.990, Speaker B: So now we avoided putting a code comment and we let the code speak for itself throughout this course. You may notice that I try to use descriptive variable and function names and this is the reason because you want your code to speak for itself and avoid using comments when you don't need to. This concludes the video about comments. I'll see you in the next presentation. In this activity, we'll be creating our own functions and utilizing them in a program. Once you're ready, let's hop into visual studio code and get started. Once visual studio code loads, navigate to your activities directory.
00:48:58.990 - 00:49:28.250, Speaker B: We are on activity one, so double click on a one rs. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Okay, let's get started. So this activity is about functions. So we'll probably be making use of functions in this program.
00:49:28.250 - 00:50:08.240, Speaker B: If we go down to the program requirements, we can see that we need to make a program that displays both your first and last name. Now, this can be accomplished easily just using a single print line. However, we do want to make use of functions as indicated in the notes. The notes state that we should use a function twice to display your first and last name. So we're going to need two separate functions, one to display your first name and one to display your last name. What I like to do is copy the notes. I'll copy the first two lines and use these as guides on how I should structure my program.
00:50:08.240 - 00:50:29.222, Speaker B: Here we have use a function. So here I'm just going to make my function. So we have fn for the function keyword. So fn creates a new function. I'm going to name this function first name. We don't need any function arguments because all we're going to do is print out my name. We also don't need to return any values.
00:50:29.222 - 00:50:58.884, Speaker B: So I'm going to use the curly braces immediately. Next, we need to print out the first name. I'm using the print line macro. I'm going to put my name in there and end the line with a semicolon. Remember, when dealing with strings you want to use double quotes, and when using the print line macro you want to terminate the line with a semicolon. Let's go down here to the other comment. So we have use a function to display your last name.
00:50:58.884 - 00:51:22.342, Speaker B: I'm going to use the fn keyword to create a new function. I'll call this one last name. Again, we don't have any arguments and we don't have any return values. So I'm just going to use the curly braces. I'll then call the print line macro and type in my last name. I'll then finish up the line with a semicolon just as before. As we can see, we have our functions that look like they should work properly.
00:51:22.342 - 00:51:59.670, Speaker B: However, if we take a look at the main function down here, we're not actually using these functions we just made. So if we were to run the program, there's nothing in the main function, so nothing will actually happen. So we need to go down here and call our functions that we just made. So remember, to call functions, we type in the name of the function and then the parentheses for any function arguments. We don't have any, so we don't include anything in the parentheses. We then terminate the line with a semicolon so that we'll call the first name function. And then we need to call the lastname function in order to fulfill the program requirements.
00:51:59.670 - 00:52:20.780, Speaker B: We also call the last name function. And there we go. Here's our complete program. Before we execute it, let's walk through the code and see how it should work. And then hopefully it works as we think it should. So first the program starts at the main function. We then go down to the first name function call the first name function.
00:52:20.780 - 00:52:56.208, Speaker B: Call will go over to here first name and then the first line in the firstname function is a printline macro, so it will print out JSON onto the terminal. There's the end of the statement with a semicolon. There's no other lines available in the function, just one print line macro. So after that executes, it will then return to where it left off. Here we have the semicolon so there's nothing additional. After calling the first name function so this line is then complete. Then we go on to the next line, lastname.
00:52:56.208 - 00:53:16.664, Speaker B: So we'll call the last name function. We'll go over here. The println macro will then get executed. That's the end of the statement. There's nothing else. Control then returns back to the last name line. Again, this is the end of the statement, so there's nothing left to execute so that one will be done.
00:53:16.664 - 00:53:55.640, Speaker B: We then go on to the next line since there is no next line, as we can see here, there's only two lines. The program will then terminate and it should be completed. So let's run this and see if it actually executes as we expect. So the way we'll be running programs for these activities is using a terminal. To do so, go up to terminal at the top and then click on new terminal. A new terminal will open up at the bottom of the screen and you'll have your terminal prompt. Your terminal prompt may look different than mine, and that's totally okay because everybody has different terminal prompts and you can customize it to whatever suits your needs.
00:53:55.640 - 00:54:24.966, Speaker B: To run the program, we will type in cargo, which is the rust build and package management tool. Run to run the program, and then two dashes bin for binary. So the binary is an executable program. Each activity is considered its own binary. So we need to also type in the name of this binary. So this one is a one. As you can see up here, this is binary, a one.
00:54:24.966 - 00:55:07.176, Speaker B: We type in the same thing here. We do not need the Rs portion because everything is always going to be an rs with the activities. Once you hit enter, we should see some status messages informing us of the build process, and then our program will run automatically, as we can see, the program ran. And here is the output. So we have my first name followed by my last name, just as stated in the program requirements. Before I finish up this video, I want to point out these steps taken by the cargo tool. So first we have compiling this would be the step that takes your code and turns it into machine instructions for the cpu to execute.
00:55:07.176 - 00:55:53.100, Speaker B: Once it's done, we get a message saying it was finished, the amount of time it took, and then we get a message saying that the program is running. If you don't want to see these messages every time you run the program, you can pass a special flag into the cargo tool called Dash Q. So let's give it a try. So if we type in cargo cargo, run Q bin for your binary, and then your activity number, it will run the program without those status messages. This can be useful if you're just making small changes, and you don't need to know how long it took to compile the program, nor do you need to know whether it was in debug or release mode. This concludes the first activity video. I'll see you in the next presentation.
00:55:53.100 - 00:56:43.052, Speaker B: In this demo, I'll be showing you how to use basic arithmetic operators in the rust programming language, including addition and subtraction, multiplication and division. So here we have an empty main function, and I'm going to be adding some different operations, so I can show you a few of the things that are available in the rust programming language. So first we'll do some addition. We'll make a variable named sum, and we'll add two numbers together, two plus two. So sum will contain the value of two plus two which is equal to four. That will be placed into the sum variable and also do subtraction. Let's call this one value.
00:56:43.052 - 00:57:12.608, Speaker B: We can do ten minus five and that'll be equal to five. Let's division. We can have ten divided by two, which will also equal five. We can also do multiplication. We'll do five times five, which will be equal to 25. Remember, we can also do functions. So I'll make a function to subtract two numbers.
00:57:12.608 - 00:58:05.350, Speaker B: We'll call it subvert subtract. It'll accept an a and a b, both of integer with 32 bits, and it will return an integer with 32 bits. And all we do is simply a minus b. That will then be subtracted and the difference will get returned as an I 32. So if we were to use that function, all we would need to do is type in five and we'll subtract eight and three, which will give us five for our value. So we'll call the function eight will go into a, that will be eight. We'll put the eight there, and then three will go into b.
00:58:05.350 - 00:59:16.190, Speaker B: We'll then have eight minus three equals five. That will get returned as an I 32 and be placed into five as the value of five. There's one more mathematical operation that I want to show you that proves quite useful depending on what you're trying to do. It's called remainder division and it uses the percent symbol in order to perform the operation. So if we do six remainder division three, we'll get a value of zero because three goes into six and even number of times with no remainder. If we do rem two and we'll do six remainder division four, we'll get a value of two because four goes into six one time with a remainder of two. This can be used to determine whether or not a number is odd or even, since you can use remainder division of two to determine the odd or even value based on the remainder.
00:59:16.190 - 00:59:58.320, Speaker B: So if you do remainder division of two, you will have zero as your remainder if the number is even, and one if the remainder is odd. That's all for this video on basic math operations. I'll see you in the next presentation. In this activity, we'll be creating a program that utilizes basic mathematical operations as well as utilizing functions to perform those operations. Once you're ready, open up visual studio code and we'll get started. Once visual studio code loads, navigate to your activities directory. We are on activity two, so double click on a two.
00:59:58.320 - 01:00:31.670, Speaker B: Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Alright, let's get started. This topic is about basic arithmetic. The program requirements are to display the results of the sum of two numbers. Our notes indicate that we need to use a function to add two numbers together. I'm going to use a function to display the results.
01:00:31.670 - 01:01:08.430, Speaker B: We also have a note that says we can use this specific token in the print line macro to display the result. The first thing I'm going to do is copy in some notes into the program area. That way I have something to work with as a guideline. So the first note says that we need to use a function to add two numbers together. So I'll create a new function with the fn keyword and I'll call the function sum. It will take an a, which is a 32 bit integer, and it will take a b, which is also a 32 bit integer. We then will return another 32 bit integer.
01:01:08.430 - 01:01:57.870, Speaker B: I use the curly braces to create a function and within the function body I just put in a plus b which will be automatically returned as an I 32 value. Next we need to use a function to display the result. So I'll call this function display results and it will just take a variable named results and that'll be in 32 bit integer. We don't need to return anything since we're just printing out information. I'll then use the curly braces to create the function body and we need to use the print line macro. This token here will display information so we can use the curly braces that surround a colon question mark. And then outside of the double quotes we put a comma and the variable that we wish to display.
01:01:57.870 - 01:02:38.824, Speaker B: In this case the variable name is result, so we'll type in results. We aren't returning anything from this line so we need to add a semicolon at the end of the line. Finally, in our main function we need to actually call our functions so they can be utilized. I'll create a new variable called result and we'll call the sum function with the values of two and two. I will then call the display result function passing in the value of the result which should display the result. Before running this program we'll take a walk through and see how each line of code works. Here's our main function and the first line of code that will be executed is this one here.
01:02:38.824 - 01:03:47.720, Speaker B: So we're creating a new variable using the let keyword and we're giving it a name of results. We're setting it to the value of this function, which is sum, and this function is being passed the values of two and two. This two will be the a value and this two will be the b value. Once this function is called, execution will jump over here, and then the a will be two and the b will be two. Since that's the arguments that we provided to the function, we then will go into the function body, which will take a, which is a two, and add it to b, which is a two, and that will then be equal to four, and that'll be automatically returned as four, which is a 32 bit integer. This four will then come back here to this section, and since there's nothing else remaining after this function call, since we have the semicolon, the value of four will then be placed into result. We then call the display result function, and now that our result value has four, it will be placed here as a four.
01:03:47.720 - 01:04:28.204, Speaker B: So the display result function will be called. We'll have a four here that is a 32 bit integer, and within the function body we call the print line macro, which prints information to the terminal. This special token allows us to substitute information, so we're substituting in the results, which is a four, and so it'll print out for when we run the program. To run the program, we'll go to terminal, new terminal. We'll then type in cargo run queue bin run activity two, so type in a two. Remember that cargo is the rust build tool and package manager for the rust programming language we use. Run.
01:04:28.204 - 01:05:01.366, Speaker B: To run the program, Q will just suppress the output that we're not really interested in, and dash dash bin selects a binary. Each file listed on our activities is a binary. So these are all binaries, and we want to make sure we select a two, since we're currently on activity two. Once this is typed in, press enter and your program should compile and run. And here is the result of four. As we can see, two plus two is four, and our program is running correctly. This concludes the activity on basic arithmetic.
01:05:01.366 - 01:05:46.876, Speaker B: I'll see you in the next presentation. In this demo, I'll be showing you how to use if and else expressions to control your program flow. I'm going to be creating a short program that can be used to determine someone's age and if they're allowed to make a particular purchase. I'll start by creating a variable named age, and we'll just set them to be equal to 15. Now I want to check to see if they are at least 21 years old. That way they're allowed to make a particular purchase. To do so, I'll use the if keyword and I'll just put in the age variable, and I'll also include greater than or equal to 21 within the body of the if expression.
01:05:46.876 - 01:06:26.788, Speaker B: I'll just print out okay to purchase. So what's happening here is we're using the if keyword to begin an if expression. We then check, is age greater than or equal to 21? And if so, we'll enter into the body of the if expression here. The body of the if expression is defined by these curly braces. So if the age is greater than or equal to 21, we'll print out okay to purchase. In our case, the age is 15, so we will not get this message because 15 is less than 21. I'm going to add an additional print line macro.
01:06:26.788 - 01:07:10.200, Speaker B: That way we can print out a message if it's not okay for this person to make a purchase. To do so, I'll use the else keyword and then we'll just print out a quick message. Now, what'll happen is if this condition here is true, so if the age is greater than or equal to 21, we'll print out ok to purchase. But if it's not true, we'll enter into this else block that is defined by the second set of curly braces. So when you have the else keyword, that just means if this first part is false, then we'll do this thing here. So in this case, we'll print out cannot purchase. We can see in our demo that the age is set to 15.
01:07:10.200 - 01:07:38.960, Speaker B: So this first expression is not true because 15 is not greater than or equal to 21. So this part of the expression will not be executed. We'll then enter into the else of the expression, into this body, and then print out cannot purchase. Let's run this just to confirm and we can see our message here. Cannot purchase. This concludes the demo on the if else expression. I'll see you in the next presentation.
01:07:38.960 - 01:08:18.506, Speaker B: In this activity video, we'll be going over how to control the flow of your program by using the if and else statements. So go ahead and fire up visual studio code and let's get started. Once visual studio code is open, navigate to your activities directory and then locate the a three a activity file. Once you've located that file, double click to open it. As you can see, this topic is about flow control. Using the if else statement. As usual with activities, attempt to do this on your own before continuing.
01:08:18.506 - 01:08:58.039, Speaker B: So go ahead and pause the video and I'll see you shortly. All right, let's go ahead and get started. So as stated, we need to use if else to demonstrate what we know about flow control. Our program requirements are to display a message and it has to be displayed based on the value of a boolean variable. When this variable is set to true, we want to display hello, and when it's set to false we want to display goodbye. The notes indicate that we should use a variable and it should set it to either true or false. And we need to use an if else block to determine which message should be displayed.
01:08:58.039 - 01:09:23.320, Speaker B: I'm going to copy these requirements into the main function. It looks like we don't have to use functions in this program. However, we could if you wanted to. I'm just going to use the main function. So we need a boolean variable. So I'm going to call mine my bool and I'm just going to set it to true to get started. So when this variable is set to true, we should display hello.
01:09:23.320 - 01:09:59.662, Speaker B: So when the variable is set to true, we want to use an if statement. So if my bool is equal to true, then we want to do something to go over the if statement again real quick. We have if some expression evaluates to true, then we're going to do whatever's in this part of the code. We also want to include the else statement. So else do something else. So when my bool is true, we want to display hello. So we'll do that using the print line macro.
01:09:59.662 - 01:10:40.630, Speaker B: So I'll put in a print line hello and if it's false, which is our else statement, we're just going to print goodbye. So I'll use the print line macro again and then we'll print out goodbye. And that should be everything we need to run this program. Let's walk through it really quick. We're creating a variable named my bool. This can be named whatever you like. We're setting it to true and we're checking is my bool equal to true? And if it is we're going to print hello and if it's not else, we're going to print out goodbye.
01:10:40.630 - 01:11:15.202, Speaker B: Let's run this and see what happens. To run programs using the terminal, navigate up to terminal, click on new terminal, type in cargo, run q bin, and then your activity number. We're on activity three a. So your binary is a three a, three a. Hit enter. And as you can see we have hello displayed because our bool is set to true. If we were to change this and set it to false, it should display goodbye.
01:11:15.202 - 01:11:37.720, Speaker B: So let's give that a go. I'll change that to false. Rerun the program and as you can see, we have goodbye. In the false case, we set false into my bool. We checked. Is my bool equal to true? No, it's not. In this case, we go to the else statement and then print out goodbye.
01:11:37.720 - 01:12:14.748, Speaker B: That concludes this activity video. I'll see you in the next presentation. In this activity we'll be creating a program that utilizes control flow using the if and else if expressions. Once you're ready, let's hop into visual studio code and get started. Once visual studio code loads, navigate to your activities directory. We are on activity three b, so double click on a three b. Once the activity file loads, review the topic and program requirements.
01:12:14.748 - 01:12:58.090, Speaker B: Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Alright, let's get started. As we can see, this topic is about flow control using if else, if, and else. The program requirements are to display a message based on the value of a variable if it's greater than, less than or equal to five. Our notes indicate that we need to use a variable set to any integer value. We need to use an if else if else block to determine which message should be displayed and we should use the print line macro to display the messages to the terminal.
01:12:58.090 - 01:13:36.608, Speaker B: We don't need to create a separate function for this particular activity, so I'll just make everything within the main function. The first thing we need to do is create a variable set to any integer value. I'll just call my variable n and I'll set it to the value of seven. Next we need to use an if else if else block to determine which message should be displayed. I'm just going to go in the same order as the requirements so the order shows greater than, less than, and then equal to five. So we'll start with a greater than five. So I'll type in the keyword if the variable that we're checking n.
01:13:36.608 - 01:14:16.592, Speaker B: We're checking if n is greater than five, so we'll use the greater than symbol and then five. We use the curly braces to begin the body of this particular condition and then use the print line macro to display the message. So we'll display greater than five just as indicated in the requirements. We use a semicolon to end print line macros. Next we need to use else if. So we do else in the event that n is not greater than five, then we'll go down here to the else, and then we add the if keyword to further constrain the conditions. So now we're on the less than five condition.
01:14:16.592 - 01:14:58.972, Speaker B: So if n is less than five, we'll just do another print line macro less than five. And finally we'll do else again, except this time we're not constrained by condition. So if n is not greater than five and it's also not less than five, then it must be equal to five. We'll then create curly braces and print out equals five as indicated by the requirements. We'll step through line by line. We have our main function, and the first line executed is creating a variable. We're creating the variable named n and setting it to the value of seven, so that'll be placed into n.
01:14:58.972 - 01:15:54.370, Speaker B: We then check, is n greater than five? If so, we'll print out greater than five. If it's not greater than five, we'll check to see if it's less than five. If so, we'll print less than five, and if it's also not less than five, then we won't check anything, and we'll just say, okay, it's not greater, it's not less, then we're just going to do this. In this scenario, it means that it would be equal to five, since if it's not greater than five and not less than five, it must be five. Seeing as how we set n equal to a value of seven, we should get the first if block here executed, which is greater than five, let's run the program and confirm that's the case. To run the program, go to terminal, new terminal. We are on activity three b, so type in cargo run queue bin a three b.
01:15:54.370 - 01:16:41.138, Speaker B: As we can see, greater than five printed out, as expected. Since seven is greater than five, if we try changing this to something less than five, like four, we should get less than five printed out. And as expected, we got less than five. And just for completeness, we'll set this to five to confirm that equals to five prints out. As we can see, when we set n equal to five, we get the result of equals five printing out on our terminal. Generally, when you're using if and else, if I, it's a good idea to also include the final else block. That way any condition that was not checked in the if and else will result in this occurring down here.
01:16:41.138 - 01:17:25.752, Speaker B: The reason you'll want to do that is because including the else allows the rust compiler to check your work in specific situations, which we'll be covering in future videos. This concludes the activity on if else if else. I'll see you in the next presentation. In this video, I'll be showing you how to add logic to your programs using match expressions. Match expressions are similar to if else expressions. However, there's one key difference that I'll be going over, so match expressions are used to add logic to your programs. They're similar to if else and else if chaining.
01:17:25.752 - 01:18:11.546, Speaker B: However, the main difference between match and if else is that match must be exhaustive, which means every possible option must be accounted for in your code. Let's take a look at an example. So here we have a boolean value named somebool and it's set to true. We then use a match expression on some bool. So this is read as match some bool. Within the curly braces, we must list out every possible value that some bool may be. As we know, booleans are either true or false.
01:18:11.546 - 01:19:07.160, Speaker B: So there's only two options here. So if the boolean value is true, we are then going to perform some action, which is to print out its true. If it's false, instead we're going to print out it's false. So each condition must be listed followed by the equal sign and the greater than symbol. This is also called a fat arrow and then the expression that should be evaluated. Notice at the end we use a comma instead of a semicolon. Since match works on expressions, not statements, the key difference is a statement ends a line, whereas a comma in this case ends this particular expression, which is this entire line right here.
01:19:07.160 - 01:19:35.420, Speaker B: So whenever some bool is true, this gets executed. But if it's false, then this will get executed. Let's take a look at another example. Here we have a match on an integer. So we have some integer with a value of three we're matching on some integer. We enter into the match block. And here we're testing out three possibilities.
01:19:35.420 - 01:20:16.516, Speaker B: So if it's one, we're going to print it's one. If it's two, we're going to print it's two, and if it's three, we're going to print it's three. Now, integers in computing can go pretty high up into the billions, but you don't want to list out every possible combination into a billion. What we do is we use an underscore. An underscore just means everything else. So if it's not one, two, or three, it must be something else, and then we'll print out it's something else. So how does match compare to else if.
01:20:16.516 - 01:21:35.944, Speaker B: Well, with match every possibility will be checked by the compiler and if you forget one then the compiler will tell you. Also, if a new possibility is added then you will be notified in order to handle this situation. As an example, you may have some data that contains colors and if you add a new color the compiler will tell you hey, you need to handle this new color, but if using else if this will not occur. So in the same example, if you add a new color, you may forget to update the else if in your code, and then when that new color pops up, you won't know it until your program ends abruptly or gives you incorrect results. To recap, prefer match over else if when working with a single variable, match considers all possibilities, which leads to more robust code. When working with data that has a lot of different possibilities and you only need to handle a few of them, use the underscore to match anything else, which would be the rest of the possibilities. In this demo, I'll be showing you how to make decisions in your programs using match expressions.
01:21:35.944 - 01:22:16.420, Speaker B: Match expressions consider all possibilities when making a determination on what your code should do next. So here we have an empty main function. I'm going to create a string variable called my name. I'm going to set it to Bob. Next I'm going to match on my name and my name is Jason. So I'm going to do a one possibility and print out that is my name. And if the name is Bob, I'm going to print out not my name.
01:22:16.420 - 01:22:48.906, Speaker B: And I'm also going to try Alice, and Alice will say, hello, Alice, any other name we're going to print. Nice to meet you. Okay, so let's walk through this. We're creating a string variable. As we can see by the double quotes, it's called my name and we're setting the value to Bob. We're then performing a match expression. We're matching on the variable, my name.
01:22:48.906 - 01:23:15.804, Speaker B: So what we're doing is we're checking to see what value is within my name. We know that it's Bob, but when the program runs, it has to make that determination. So we match on my name. We check to see if it's Jason. We know it's not, it's Bob, so this line will not get executed. We then check to see if it's Bob. It is so this will get executed.
01:23:15.804 - 01:23:45.810, Speaker B: It will print out not my name. Once that occurs, it'll exit out of the match statement. If we had entered the name as Alice, then it would print hello Alice and any other name is just going to print out. Nice to meet you. So in this particular scenario, we should see not my name printed the console. When we run the program, let's give it a try. As we can see, it says not my name.
01:23:45.810 - 01:24:05.170, Speaker B: Let's change the name and see what happens. We'll change it to Jason. The first match is JSON, so it should print out. That is my name. Let's give it a go. As you can see, that's exactly what has been printed. That is my name.
01:24:05.170 - 01:24:34.354, Speaker B: We'll try a different name, Bill. So in this statement, we don't have a check for Bill. We have Jason, Bob, and Alice. So the last case is the underscore, which we'll consider any other possibility that hasn't already been listed. So this code should display nice to meet you. Let's try it out. And there we go.
01:24:34.354 - 01:25:03.072, Speaker B: The code says nice to meet you. That's the end of this video. I'll see you in the next presentation. In this activity video, we'll be using match expressions to control the logic of a program. So go ahead and fire up visual studio code and we'll get started. Navigate to your activities directory and open up a four a. So this is activity four a.
01:25:03.072 - 01:25:43.450, Speaker B: Just double click and the file should be displayed. So as we can see, this activity is about decision making using match. As usual with activities, attempt to do this on your own with the video paused, and then once you're completed, resume the video to see how I did the implementation and to gain any insights on the lesson. All right, let's get started. So this topic as mentioned, is about decision making using match. So the program requirements state that we need to display two separate things. We should display it's true or it's false based on the value of a boolean variable.
01:25:43.450 - 01:26:09.730, Speaker B: And our notes indicate that we should create a variable and set it to either true or false. So we can pick whichever we like. And we need to be using a match expression to determine which message should be displayed. I'm going to copy these notes into the main function. So we need a boolean variable. I'm going to name it mybool. And I'm going to start with false.
01:26:09.730 - 01:26:42.188, Speaker B: So that's our variable. We need to use a match expression to determine which message to display. So to create a match expression, we use the keyword match, then the variable that we're matching on. In this case, it is my bool. We then have curly braces. At this point, we need to list out all possibilities that the my bool variable may possibly contain. Since we know that booleans are either true or false, we only need to list out two separate conditions.
01:26:42.188 - 01:27:17.006, Speaker B: So when my bool is true, we are going to do a print line and print out its true per the instructions. Once we're done with that possibility, we finish it with a comma. The next possibility is false, and then we're going to do a print line. It's false. We can then end with a comma just as before, and our program should be complete. So let's take a look at how this works. First, we create a boolean variable named my bool.
01:27:17.006 - 01:27:49.810, Speaker B: We set it to the value of false, so my bool contains a value of false. We then use match on my bool. So when you're matching something, you're checking every possible condition that my bool may be in. Since it's a boolean and it can only be true or false, we check for true and we check for false. When the code executes. If my bool is true, then it'll print out its true. Whereas if my bool is false, which it is in this case, then it will print out its false.
01:27:49.810 - 01:28:18.184, Speaker B: So let's run this program and see what happens. To run the program, go up to terminal, click on new terminal. Then you can type in cargo, run q bin, and the activity number. This is activity four a. So I'm going to enter a four a and then hit enter to run the program. As we can see, its false is displayed. Since we set the variable, we're checking to the value of false.
01:28:18.184 - 01:28:58.930, Speaker B: If we were to go back and change it to true, then it should display it's true. So let's give that a go and confirm that's the behavior we get. We'll rerun it and we see now that the output is it's true because the my bool variable is set to true, and when we use the match expression on it, we see that it is true and it prints out it's true. This concludes the activity video on basic match expressions. I'll see you in the next presentation. This activity video is on basic match expressions. Match expressions are a great way to add logic to your programs.
01:28:58.930 - 01:29:34.126, Speaker B: Go ahead and hop into visual studio code and we'll get started. So to begin, open up the a four B file. As this is activity four b, double click to open it and you'll see that the topic of this activity is decision making with match. As usual with activity videos, pause this video and attempt to implement the solution on your own. Afterwards, return to the video to see my implementation and to gain any insights on the topic at hand. Okay, so let's go ahead and get started. As mentioned, this activity is about using the match keyword.
01:29:34.126 - 01:30:26.618, Speaker B: The requirements state that we need to display one, two, three or other based on whether a variable has the values of one, two, three, or anything else. We need to use a variable and we can choose any value we wish in order to run the program, and we have to use a match expression to make this determination. So we don't want to use if else. We want to use match. Also, in the notes we have a note that tells us we can use the underscore to match on anything else. So if you recall, match is an exhaustive technique, which means we have to account for every single possibility in order for it to work properly. Since numbers in computing can go up to 2 billion, if we're working with an I 32, we would need to list out all 2 billion numbers in order to use it successfully.
01:30:26.618 - 01:31:06.968, Speaker B: That's why we have the underscore to take care of that for us. So we can just match on one, two and three, and then the underscore will take care of the other 2 billion numbers. I'm going to copy these notes into the main function and I'll start writing some code. Here we have our notes, a variable set to any integer. So I'm going to call mine mynumber and I'm going to set it to two. Next, we need to use a match expression to determine which message to display. So we'll type in the match keyword we want to match on my number, and we need to list out the numbers that we need to be checking.
01:31:06.968 - 01:31:45.290, Speaker B: So the requirements state that we need to check for one, two and three. So I'll start with one. So one is if my number is equal to one, then we're going to do a print line macro and just display one for the instructions. And then two we'll do the same thing. So we'll have a print line macro display two, and then for three other print line macro will display three. Each possibility ends with a comma to denote the end of that particular possibility. Now we need to use the underscore to match on anything else.
01:31:45.290 - 01:32:14.010, Speaker B: Since we're only concerned with one, two, and three, anything else underscore we're going to print out. As the requirements indicate, we're going to print out other. So we'll print out other. Now our program looks complete. Let's take a quick walkthrough. So if we zoom in, we can see that we have my number, and that's set to the value of two. So my number is equal to two.
01:32:14.010 - 01:32:38.016, Speaker B: Next we want to match on my number. So that means we want to check the value of my number. We're checking. Is it equal to one, is it equal to two, is it equal to three? Or is it equal to some other thing? In our case, my number is equal to two. So then this line will get executed. Print line two. So two will be printed to the console.
01:32:38.016 - 01:33:18.546, Speaker B: And then as soon as that's done, we'll return outside of the match block. If we had my number equal to one, then this line would print. So let's run this program and see what happens. To run the program, go to terminal, new terminal. Type in cargo run q bin. We are on activity four b, as you can see at the top. So we want to type in a for b to run the program, and the result prints out two, as expected, since my number is equal to two, if we try changing my number, let's change it to eight, so we'll walk through real quick again.
01:33:18.546 - 01:33:37.162, Speaker B: So we're checking to see if my number is equal to one of these values present. Right now my number is an eight. So is eight the same as a one? No. So this will not be executed. Is it a two? Nope. Is it a three? Nope. It's something else right here.
01:33:37.162 - 01:34:01.860, Speaker B: We don't care what it is, we just know it's not a one, two or three. So we're going to print out other in this case. So let's run it and confirm that that's the case. We run it and as expected, other gets printed out. Since there's no case for eight, it has to be the underscore which catches everything else, and we print out other. This concludes this activity video. I'll see you in the next presentation.
01:34:01.860 - 01:34:47.106, Speaker B: In this demo, I'll be showing you how to perform repetition in your programs using the loop statement. So when you want to repeat a task multiple times, the loop statement is one option. By default, the loop statement loops forever until you manually break out of it based on some condition. So let's create a simple loop statement that prints out a message. So here we have the loop keyword, followed by open and close curly braces. And the body of the loop has a single statement which is print line. If I were to run this program, it would just print out hello forever and ever and ever.
01:34:47.106 - 01:35:16.172, Speaker B: However, we don't really want that in this case. We want to break out at some point. In order to do that, we use a break statement. So if we include a break statement, the loop will begin executing. We'll get a print line one time, a break will be encountered, then it will break out of the loop and the program will end. Let's run it and give it a try. As you can see, it printed out.
01:35:16.172 - 01:36:02.688, Speaker B: Hello, one time I'm going to modify this program so it prints out a countdown and then prints done when the countdown is completed. To do that, we'll first need a mutable variable. So I'm going to create a mutable variable called I, and I'll set it equal to three or countdown starting from three. So remember, a mutable variable is one that can be modified at a later date. We'll need that in the loop. Within the loop, we'll print out the value of this variable. To do so, we use the special token for the print line macro, which will allow me to print out the value of any variable as indicated here.
01:36:02.688 - 01:36:42.114, Speaker B: So in the first iteration, I will be equal to three, and then this will print out three, since I is three. Next, we will decrement the value of I. That way it acts as a countdown, so I equals I minus one. All we're doing here is we're taking the current value of I, which on the first iteration is three, we're subtracting one. One minus three is two, and that will be placed into I. Next, we need to check to see if I is equal to zero. In this program, we want the countdown to display three, two, one, and then done when it's completed.
01:36:42.114 - 01:37:16.024, Speaker B: So we don't want it to display zero. So if I is equal to zero, that is when we will perform our break. After this break statement is encountered, it will break out of the loop and proceed down to this line. So this is where we will add our print line statement that indicates the program is done. Let's go down here and we'll print line done. Before we run this program, let's walk through it real quick. First, we're creating a mutable variable with the value of three.
01:37:16.024 - 01:37:44.896, Speaker B: So we have a mutable I set to an initial value of three. We then create a loop, and within that loop we have a block of statements that will be executed on each iteration of the loop. Immediately, the value of I will be printed. Because we're using this special token for print line. In the first iteration, I is three. So three will be printed. I will then be reassigned to two.
01:37:44.896 - 01:38:21.430, Speaker B: Because we're taking three minus one, which is equal to two, we then check is I equal to zero in the first iteration of the loop, I will be two. This will not execute since I is not equal to zero. We then will return back to the beginning of the loop and repeat the process. On the next iteration, I will be set to one. I is still not equal to zero. So then we continue again. In the next iteration, the value will be zero, and then this will be true and we will break.
01:38:21.430 - 01:39:02.070, Speaker B: After we break, we exit out of the loop, and then this print line will be executed and done should be displayed on the terminal. So let's run it and see what happens. To run, go up to terminal, click on new terminal, and I'm going to run it with cargo run q. As we can see, we have three, two, one, and then done. This concludes the demonstration on the loop keyword for the rust programming language. I'll see you in the next presentation. In this activity, we'll be performing repetition using the loop keyword.
01:39:02.070 - 01:39:54.170, Speaker B: To get started, open up the a five activity by double clicking. Once the activity loads, you'll see that the topic is looping using the loop statement as usual with activities, pause this video and attempt to complete the activity on your own first, and then resume the video to see my implementation and to gain any insights on the activity. Okay, so let's get started. As we can see, our topic is looping. Using the loop statement, our program requirements are to display one through four in the terminal. In order to do so, we should use a mutable integer variable. We should also use the loop statement, and within that loop statement we should print the variable.
01:39:54.170 - 01:40:38.200, Speaker B: We also should use the break keyword in order to exit the loop. If we don't do so, the loop will go on forever, and that wouldn't be so good. So let's copy some of these notes into the main function, and we can start writing our program. So first we need a mutable integer variable, so I'll call mine n and we'll start with one. Our instructions indicate we should display one through four, so we should start off with the number one. Next we need to use a loop statement, so that's easy enough. We just type in loop and we have our loop block ready to go.
01:40:38.200 - 01:41:23.716, Speaker B: Next, we need to print the variable within the loop statement. To do so, we should use the print line macro, and we can use the special token to print out variables. So colon, surrounded by curly braces, will print out the variable that's indicated after the comma. Next, we need to use break to exit the loop. So if we just type break, what will happen is we'll do a print line with the number one. Since n is set to one, then we'll exit the loop and our program will be finished. However, if we take a look at the requirements, we need to display one through four.
01:41:23.716 - 01:41:55.540, Speaker B: So right now it only displays one. We want to display one through four. So in order to do that, we need to increase the value of our variable. But variables are immutable by default, so we need to make this variable mutable. Use the mut keyword in order to do that. Next, we need to add some logic in order to determine when the loop should be exited. As we can see at the top, we need to display one through four.
01:41:55.540 - 01:42:24.110, Speaker B: So what that means is we need to check to see if the variable is a certain number and when it is, we'll exit. So we want to print out four. So that would be the last one. So we'll check to see if n is equal to four, and if so, we'll break out of the loop. So on the first iteration of this loop, n will be equal to one. We'll print it out. And then if n is equal to four, we'll break.
01:42:24.110 - 01:43:07.060, Speaker B: One more thing that's needed in order to complete this loop is we need to actually increase the value of our mutable variable by just setting it to itself plus one. This is also called incrementing. So we're incrementing this variable by one. And now each time the loop iterates, each time this whole block executes, we'll print out the value, check to see if it's equal to four. If so, break. If not, we increase the value and then return to the beginning and repeat the process. Eventually, because of this line here, the value will increment from two to three to four.
01:43:07.060 - 01:43:38.462, Speaker B: Once it's four, this will evaluate to true. The loop will break, execution will exit out of the loop. So let's give it a go and see what happens. To run this program. Go to the terminal by going to terminal new and then typing in cargo run queue bin and then the activity number. We're on activity five a five. So type in a five.
01:43:38.462 - 01:44:08.576, Speaker B: We'll run it. And as we can see, we have 1234. Just as the requirements states, display one through four in the terminal. This concludes the activity video. I'll see you in the next presentation. In this demo, I'll show you how to implement repetition in your programs. Using the while keyword repetition allows you to repeat actions multiple times within your programs.
01:44:08.576 - 01:44:44.970, Speaker B: For this demo, I'll be creating a program that just counts one, two, and three, and I'll do so that utilizing a while loop. The first thing I need to do is create a mutable variable that will be used as the counter for our program. I'll use the let keyword followed by the mutable keyword. Mutable just means we can mutate it or change it later in the program. I'll call my variable I, and we'll set it to a value of one. Since we're counting from one, then two, then three. We then use the while keyword, and the while keyword will execute code in the body based on a condition.
01:44:44.970 - 01:45:18.210, Speaker B: And the condition we want to check is the size of I. So while I is less than or equal to three, we want to do some things. The thing we'll be doing is printing out information, and we just want to print out the number. In this case, I'll use the debug token within the println macro, and we'll print out I. The next thing we need to do is increase the value of I to do. So we'll take I, and we'll just set it to itself plus one. So this will just increment the value by one, and that should do it for this program.
01:45:18.210 - 01:45:42.070, Speaker B: I'll walk through line by line so we can see how this program works. We first create a variable named I. It is mutable so we can change it later. And we use the let keyword to actually create the variable. So one is assigned to I initially. We then have the while keyword, which creates a loop, and it will loop based on some condition. That condition is supplied right here.
01:45:42.070 - 01:46:20.040, Speaker B: So first we check is I less than or equal to three? And if it is, we'll enter into the body of the loop, which is delimited by these curly braces. This part in here is the body. So these two lines here are the body of the while loop. In the body we call print line macro, which will print out the value as seen here. I will be substituted in this token. We then increment I in this line by taking I setting it to itself plus one. So on the first iteration, I will be one, and then we'll take one plus one, which will be equal to two.
01:46:20.040 - 01:46:51.910, Speaker B: So then the value will be set to two, and then the next iteration will be set to three. And then the next iteration will be set to four. And then when it's four, I will be four, which is not less than or equal to three. So when the value is four, this will no longer execute, and then the program will exit. Let's run it just to confirm that we get a counter going from one to two, then to three. I'll run the program with cargo run. As we can see, we have one, two, and three.
01:46:51.910 - 01:47:45.982, Speaker B: While loops are an easy way to ensure that your loop will automatically terminate based on some condition, as we see here versus the infinite loop, which requires you to break out manually, the while loop is generally a little bit easier to work with since you can change the value of the condition inside the loop easily, and then it'll terminate automatically once the condition is no longer true. This concludes the demo on the while loop. I'll see you in the next presentation. In this activity, we'll be creating a program that uses repetition with the while statement. Let's hop in the visual studio code and get started. We're on activity number six, so double click on a six to open up the activity file. Once the activity file is open, you can go ahead and read over the topic and program requirements.
01:47:45.982 - 01:48:31.530, Speaker B: Pause this video and attempt to create the program on your own. Once you have finished your attempt at the program, resume the video to see my implementation and to gain any insights on the topic at hand. Alright, let's get started. So this topic is about looping and we're using the while statement to do our looping. The program requirements state that we should count down from five all the way to one, display the countdown, and then print done. When the countdown is complete, we need to use a mutable integer variable to accomplish this. We also need to use the while statement, and we should print the variable while we're within the while loop and we cannot use break to exit the loop.
01:48:31.530 - 01:49:11.740, Speaker B: So it's possible to use break when you're in a while loop. However, for our program we should use the conditional check on the while loop to break instead of using the keyword. So let's copy some of these notes into our main function and then we can start writing some code. So we need a mutable integer variable. So I'm going to use counter for my variable name and we want to count down from five. So we should start with the value of five. So I'll set my counter variable equal to five, make sure that it is mutable because we will be mutating it in the while loop.
01:49:11.740 - 01:49:43.194, Speaker B: We then need to make a while loop. So while the counter is greater than or equal to one, we will execute our loop. The first line of our loop should contain a print line statement. We will print out the value of the variable. In this case, the name of the variable is counter, so we will print that out. Remember, when we're using the debug print as part of the print line. It prints out whatever variable is stated here.
01:49:43.194 - 01:50:21.520, Speaker B: So it's going to print out the value of counter. Next, I'm going to decrement the counter by one. So to do so, counter equals counter minus one. So each iteration of the loop, the counter is just going to get smaller by one. Since we're doing the current value minus one. Then hopefully once we get down to zero, the counter variable will no longer be greater than or equal to one, in which case this will not get executed. And then we will exit out of the while loop automatically and continue on with the program.
01:50:21.520 - 01:50:58.964, Speaker B: Lastly, we need to print done when the loop is complete. So to do that is quite simple. We just use a print line, print out done, and then hopefully everything works out correctly. Let's walk through this code and make sure it would work before we execute it. So first we create a mutable variable named counter. We set it to five, as long as counter is greater than or equal to one. In this case that's okay, because we're at five, we're going to print out the value of counter, so it's going to print out five.
01:50:58.964 - 01:51:34.720, Speaker B: On the first iteration, counter will then get reassigned to five minus one, which is four, so it will get reassigned to four. At that point it'll get checked again, and then four is still greater than or equal to one. That's true. So we go into the loop again and continue on until finally counter will be set to zero. Once this is zero, zero is no longer greater than or equal to one. So that's false. This will come out and then we print line done, and it should be good.
01:51:34.720 - 01:52:08.570, Speaker B: Let's run this program and see what happens. To run the program, go up to terminal, new terminal, use cargo run queue min. We are on activity six, so type in a six and hopefully the program runs properly. As we can see, the output is 54321. And then done. This concludes the demo on the while loop. I'll see you in the next presentation.
01:52:08.570 - 01:52:56.526, Speaker B: In this video I'll be talking about how to work with data. Specifically, I'll be covering the enum keyword, which allows you to work with data in a type safe manner. So enum is short for enumeration, and it's simply a piece of data that can be one of multiple different possibilities. Each possibility is called a variance. Enumerations provide information about your program to the compiler, which will result in more robust programs. Here's an example. On the left we have an enumeration created using the enum keyword to create an enumeration, we use enumerated, followed by the name we want to give it.
01:52:56.526 - 01:53:50.234, Speaker B: And then each entry here is called a variance, which are also names that I decided to give this enumeration. Each variant is ended with a comma, and the comma is optional on the last variance. What this means in rust code is that this direction enumeration can be one of four different possible pieces of data. On the right, we have a function that uses match on this enumeration to demonstrate how it could be used in a program. So we have a function called which way? A variable called go as the function parameter, and we're giving it a direction to go. So this is our enum here, being fed into this function as direction. We then perform a match on this variable, which is a direction.
01:53:50.234 - 01:55:08.160, Speaker B: And to match on an enumeration, you use the name of the enumeration, two colons, and then the variance. After that is standard match syntax, using the fat arrows, and then the action you wish to perform. We have to account for every possible variance of this enumeration since we are using a match keyword. This is how the program is able to be more robust when we combine enumerations and match. Since match requires all possibilities to be satisfied, we have to list all possible variants of the enumeration. If we were to add a new variance to this direction enumeration, for example, forward, then what would happen is when we try to run the program, this match statement will no longer satisfy the condition that it has to check every single possibility, since we did not check for the forward possibility, this allows you to change every instance in your code where the direction is used, which helps increase your reliability of the code, since no bugs will creep in, because every possibility will always be checked. To recap, enums can only be one variant at a time.
01:55:08.160 - 01:55:44.558, Speaker B: They result in more robust programs when paired with the match keyword. They also make program code easier to read. That way you can pass around enumerations instead of just numbers and strings. In this demo, I'll be showing you how to use the enum keyword to create enumerations in your code. So I'm going to be creating an enum that is used to go either left or right. So to create an enum, use the enum keyword. Notice that it's outside of the main function.
01:55:44.558 - 01:56:13.462, Speaker B: So we have a main function, then we have our enum here. So you're going to create this outside of your main function. I'm going to call this direction, and we're going to have either left or right. Then to use this we create a variable. I'll call this go. So which direction we should go. To assign the variant that I want to assign, we type in the name of the enumeration and the variant.
01:56:13.462 - 01:56:54.118, Speaker B: So I'm going to go left. Next I'm going to perform some action based on the direction. So we'll use the match keyword on the go variable. So remember, right now we're checking all possibilities of the go variable, which is a direction. So we need to check for the direction that goes left and the direction that goes right. To do that in a match, we just simply type in the name of the enumeration, which is direction. And we start with left and I'm just going to print line and I'm going to say go left and then we do the same thing for the next line.
01:56:54.118 - 01:57:18.466, Speaker B: So we need to cover the right variance and I'll print out go right. So now we've covered all possibilities of directions. We have two directions. We can either go left or right. Every possibility has been considered. In this case we have left and we have right. So if we execute this program, we can see that go has been assigned to the left direction.
01:57:18.466 - 01:58:05.630, Speaker B: So when we check our match statement on the go variable, we'll see that left will get executed. So go left should be printed. So let's execute it and see what happens. As we can see, the output states go left. I also want to demonstrate what happens if you make a change to your enumeration, but don't change the match expression that it's used with. So if we add another direction, let's say up to our enumeration, and then attempt to run the program, we should get an error. As we can see, we get an error and some instructions, non exhaustive patterns up is not covered.
01:58:05.630 - 01:58:42.960, Speaker B: So it tells you right here that we did not cover up in our match up not covered in this specific match statement on line nine. Additionally, the compiler gives you some help. It says ensure that all possible cases are being handled, possibly by adding wildcards or more match arms. And so in order to fix that we simply go to line nine as indicated, and then we add the direction for up. So we'll add direction up. Front line go up. And now the program should compile and run.
01:58:42.960 - 01:59:25.524, Speaker B: And here we have go left just as we had previously, because we assigned the direction left to go. If we assign up to the variable, then we should have go up printed. So if we rerun it, we'll see that the output states go up. This concludes the demo on enumerations. I'll see you in the next presentation. In this activity, we'll be creating a program that utilizes a custom enum. Enums are used to create your own type in rust and provide increased code robustness and make your code easier to read.
01:59:25.524 - 02:00:00.492, Speaker B: So let's hop into visual studio code and get started. We are on activity seven, so double click the a seven rs file to open up the activity. Once the activity file loads, review the topic and program requirements. As with other activities, attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Alright, let's go ahead and get started. So our topic for this activity is working with an enumeration.
02:00:00.492 - 02:00:31.140, Speaker B: Our program requirements are quite simple. This time all we have to do is print out the name of a color to the terminal. We could simply accomplish that with a print line statement and be done. However, the notes add on some restrictions that we should follow. We need to use an enum with different color names as variants. We need to use a function to print out these color names. The function must use an enum as the parameter, and we have to use a match expression to determine which color name to print.
02:00:31.140 - 02:01:12.092, Speaker B: We have quite a few things we need to implement, so to get started, I will copy the notes and use them as a guide. So the first note indicates that we should use an enum with color names as variants. I'm going to name my enum color. So to create an enum, we use the enum keyword right here and then the name of your enum. The name could be anything, as long as it's not an existing keyword in the rust language and it does not start with a number. We then use the curly braces in order to begin typing our variants. I'm going to use red, yellow, and blue as my colors.
02:01:12.092 - 02:01:46.978, Speaker B: You can have as few or as many colors as you like. Just keep in mind that you have to have each color accounted for in your match statement. So if you have too many colors, then your match statement will become longer and longer. Next, we need to use a function to print the color name, and the function must use the enum as a parameter. So to do that, we use the fn keyword to create a new function. I'm going to name my function print color. It's always good to use a descriptive name for both your functions, variables, and enums.
02:01:46.978 - 02:02:29.540, Speaker B: That way somebody reading your code knows what it does simply by looking at the name the variable name that I'll be using for the function parameter will be called my color. We then use a colon to separate the name of the variable or function arguments with the type of that variable. So this type is going to be a color type. So note that the type here is the same as your enum. So when you make an enum, you're making your own custom type. So these must be the exact same name. Since that's what we're working with, we don't need to return anything from this function, so we can just jump straight into the function body.
02:02:29.540 - 02:03:07.082, Speaker B: Next, we need to use a match expression to determine which color name to print. So to do that, we use the match keyword we're going to match on mycolor. So the function will get called we have my color, we then match on mycolor. And remember, since color is an enumerated, the only possibilities are red, yellow, and blue. So I'll type those in. So we have red and then we have yellow, and then we have blue. Next, we need to print out the name of the color.
02:03:07.082 - 02:03:49.474, Speaker B: So use the fat arrows and print line, and I'll just print out the name. So we'll print out red, and this one will print yellow, and finally the blue one will print out blue. Once that's done, we simply need to call our function with a color. It should then print the color and our program should be complete. So to call the function, we just type in the function name, and we have to pass in a color. So in order to do so, we type in the name of the enumeration, which is color. So this name here is going to be down here as a color, and I'm going to choose blue.
02:03:49.474 - 02:04:16.992, Speaker B: So I just type in blue and then end the statement. And the function should be called with the color blue. That will then go over here. My color will be blue. This then gets matched, and since we know it's not red, we know it's not yellow, we do know it's blue. The blue will get printed and our program will be completed. So let's run this and see what happens.
02:04:16.992 - 02:04:52.626, Speaker B: Remember, to run the program, go to terminal, new terminal, type in argo, run Q bin, or an activity seven. So type in a seven. We then run the program and we get the output of blue just as expected. You may notice that there are some warnings that were emitted. So we have two warnings that are emitted. So we have variant is never constructed two times red and yellow. All that simply means is that we have a enumeration here.
02:04:52.626 - 02:05:33.950, Speaker B: We have our color enumeration, we only used blue, so we didn't use yellow, we didn't use red. And the compiler is just telling us like, hey, you didn't use red and you didn't use yellow. You might want to look into that. This is one of the great features of the rust compiler is it always informs you if something is either wrong or is potentially wrong based on how you're writing your code. This concludes the activity on enum. I'll see you in the next presentation. In this video I'll be going over the struct keyword, which allows you to create a data type that contains multiple pieces of data.
02:05:33.950 - 02:06:04.430, Speaker B: So struct is short for structure. It is a data type that contains multiple pieces of data. Structures are all or nothing. Each piece of data within the structure must be populated. You cannot have some part of a structure and not the others. Each piece of data within a structure is called a field. Structures make working with data easier because similar data can be grouped together in your program and travel together to different parts of your code.
02:06:04.430 - 02:06:33.950, Speaker B: Let's take a look at an example. On the left we have a structure for a shipping box. To create the structure we use the struct keyword followed by the name we want to give the structure. I'm naming this structure shipping box. It has a depth, width and a height. Each one is a 32 bit integer. The fields are enclosed within curly braces.
02:06:33.950 - 02:07:29.426, Speaker B: To use this structure, we can take a look at the code on the right. I'm creating a variable named my box. I'm assigning it to a shipping box, and that shipping box has a depth of three, a width of two, and a height of five. Notice that all these fields are all present here. If I was to try to create a shipping box and did not include one of these fields, it would be an error by the compiler and it would not let me run the program. We can also access individual fields within the structure by using a dot. So here on the bottom we're creating a variable named tall, and we're assigning it the value of my box, which was created here, and we're just accessing the height field.
02:07:29.426 - 02:08:31.768, Speaker B: So this variable tall is only going to have the value of five, since that is the field that's being accessed here, the height, and then we will print out the height using the print line macro, and it will display the box is blank units tall. Since we know that tall will be populated to this token, we know it has a value of five, and so it will print out the box is five units tall. To recap, structs deal with multiple pieces of data. All fields within a struct must be present in order to create the struct. Fields within the struct can be accessed using a dot. In this demo, I'll be going over the struct keyword which is used to create data structures that contain multiple pieces of data. So I'm going to be creating a structure that represents an item within a grocery store.
02:08:31.768 - 02:09:26.290, Speaker B: So I'll be using the struct keyword and I'll name my structure grocery item. Remember, with structs we use the struct keyword followed by the name you would like to give the structure. We then have curly braces, and within these curly braces we will list out the fields for this structure. So I'm going to have a stock field which represents the number of items in stock, and a price field which represents the price for this particular grocery item. We'll use f 64, which is a 64 bit floating point number and that's also known as a double. So if you need to work with decimal points, you'll want to use f 64. Next, I'm going to create a grocery item in my main function.
02:09:26.290 - 02:10:22.842, Speaker B: So I'll have one called serial and I will assign it the value of a grocery item and the serial will have ten in stock and we'll price it at 299. Make sure to end this let expression with a semicolon, otherwise you will get a compiler error. I'm going to print out the stock and the price separately for this grocery item. I'll use the print line macro and we'll say stock. We use the debug print token along with serialization dot stock. So whenever you want to access a single field within a struct, you use the dot notation and the name of the field. So this ten value will be here in serial stock which will then be placed here.
02:10:22.842 - 02:10:51.542, Speaker B: When we access the print line macro, I will also print out the price. So we'll change this to price. And now the stock and the price for the serial will be printed out. So let's execute this code and see what happens. To run the program, I'm going to go to terminal, new terminal. Then I'll do cargo run queue. And there we go.
02:10:51.542 - 02:11:22.996, Speaker B: We have the stock listed as ten, which is the same as our code and the price is 299. Just as expected, this concludes the demo. I will see you in the next presentation. In this activity we'll be creating a program that utilizes structures using the struct keyword. Once you're ready. Let's hop into visual studio code and get started. Once visual studio code loads, navigate to your activities directory.
02:11:22.996 - 02:11:56.860, Speaker B: We are on activity eight so double click on a eight rs. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Alright, lets get started. As we can see, our topic is about organizing similar data using structs. The requirements are to print out the flavor of a drink and its fluid ounces.
02:11:56.860 - 02:12:35.334, Speaker B: Our notes indicate that we need to use an enum to create different flavors of drinks. We need to use a struct to store the drink flavor and fluid ounce information. We need to use a function to print out the drink flavor and the ounces. And finally, we need to use a match expression to print the drink flavor. I'll start my program by creating the enumeration needed for the different flavors of drinks. Remember, with enumerations we use the enum keyword followed by any word you want to call your enumeration. As long as it doesn't start with a number or is an existing keyword, then you can use it for your enumeration name.
02:12:35.334 - 02:13:07.150, Speaker B: I'm going to call mine flavor. I'll have three different flavors for my enumeration. I'll have sparkling, sweet and fruity. The next thing I'm going to do is use a struct to store the drink flavor and fluid ounce information to create a structure. We use the struct keyword and the same restrictions apply to it as the enumeration. So we can use any word we like as long as it doesn't start with a number and is not an existing keyword. In the rust language, I'm going to call my structure drink.
02:13:07.150 - 02:13:34.904, Speaker B: The fields we'll use in the drink are flavor and fluid ounces. So we'll have a field name flavor. That will be a flavor type. And then we'll have fluid Oz, that will be our fluid ounces. We'll use an f 64 for this data type since that allows decimal points. So what we're doing here is we're using the struct keyword followed by a name to create a structure. The structure consists of multiple different fields of data.
02:13:34.904 - 02:14:08.260, Speaker B: We have a field here and a field here. This first field is named flavor and we're giving it a type of flavor. This type is defined here and that's a type that we created and it's an enumeration. We then have the fluid oz field, which is our fluid ounces. And we're just giving that an f 64. That way we can use decimal points for the amount of fluid ounces. Now that our flavor enumeration and our drink structure is created, we need to use a function to print out the drink flavor and ounces.
02:14:08.260 - 02:14:34.250, Speaker B: I'll create a function. Remember, to create functions, we use the fn keyword. I'm going to name my function print drink. And it's going to accept a drink, which is a drink structure. We're not going to return any information since we're just printing out something to the terminal. We then need to use a match expression to print the drink flavor. So we'll use match on the drink.
02:14:34.250 - 02:15:08.928, Speaker B: Now, in order to access the flavor here within the drink, we use a dot. So this drink here is the entire drink structure, and we're accessing just the flavor within the drink. That way we can print it out. We'll just type in drink flavor. And now we know that the flavor field here within the drink is a flavor type. And that flavor type is an enumeration. What this means is that we need to account for all three possible flavors that are available.
02:15:08.928 - 02:15:42.340, Speaker B: So I'll do so now. So for that flavor, we'll just print out sparkling. And then we'll do the same thing for the other two variants. Now that we have all three variants accounted for, we can also print out the fluid ounces. We use a print line macro. I'll just put in Oz and we'll access the drink dot fluid oz. Just like with the flavor here, we can access the fluid ounces by using a dot and the name of the field, which is fluid ounces.
02:15:42.340 - 02:16:07.352, Speaker B: So we have our drink type again, which is here. We're accessing the fluid oz field, which is present right here. And we just need to use a dot to access any of the fields within the structure. I'm also going to add the word flavor here on each one. That way we know what's being displayed to the user. The last thing we need to do is make some drinks and print them out. So I'll use.
02:16:07.352 - 02:16:28.920, Speaker B: So first I'll create a sweet drink. I'll just call it sweet. And that will be a drink. The drink consists of a flavor, which is a flavor type. And this is the sweet flavor. And then we have the fluid ounces, which is. And we'll give this one 6oz.
02:16:28.920 - 02:17:01.520, Speaker B: Remember that f 64 is a decimal point number. So we have to include zero to tell the compiler that we're working with decimal points. When we create structures, we just have the name of the structure and the two curly braces along with each field that the structure needs to be created. So here our drink structure has a flavor and fluid ounce field. So that needs to be reflected when we create the structure. Down here in the main function. I'm now going to print out this drink and we'll make one more drink.
02:17:01.520 - 02:17:33.003, Speaker B: We'll do a fruity drink. We'll change the flavor to fruity. And this one can be 10oz. We'll then print that one out and also make sure we have a separate variable name. And that should complete our program. I'm going to walk through this program line by line so we can see exactly how it works. The first thing we're doing here on the right side is creating an enumeration named flavor.
02:17:33.003 - 02:18:07.949, Speaker B: We're giving it three variants, sparkling, sweet, and fruity. We're then creating a structure named Drink. We're giving it two fields, one named flavor, one named fluid Oz. The flavor field is a flavor type which is indicated right here. It's not necessary to name the fields after the enumeration name as long as the name of the field is clear on this purpose. In our case, the name of the field happens to be the same as the enumeration. However, that's not always the case as we can see here with the fluid ounces.
02:18:07.949 - 02:18:38.542, Speaker B: That's just an f 64, so you can use whatever name you want as long as they are descriptive. Next over here on the left, we have our print drink function, which has a function argument of drink. And the argument is a type of drink. This drink type is defined here as a structure. And so we know that we'll have a flavor and a fluid ounce available within our function. We then use a match expression on this drink. So this drink will come into the function we match on it.
02:18:38.542 - 02:19:08.331, Speaker B: We access the flavor field by using a dot in the name of the field. The name of the field is flavor. So we're accessing this flavor enumeration. And that flavor enumeration is defined here on the right. And it has three variants which all must be accounted for since we're using a match expression. So here we account for each flavor and print out an appropriate message. Finally, after the flavor is printed, we print out the fluid ounces on the last line of the function.
02:19:08.331 - 02:19:51.238, Speaker B: By accessing the fluid oz field within the drink structure in our main function, we're creating a drink and assigning it to the variable named Sweet. The drink is created using the name of the structure two curly braces and all the fields required of the structure. In the sweet drink case, we're creating a drink with a flavor of sweet and a fluid ounces of six. We then print out the drink by calling the print drink function and using the sweet variable name. So this variable is going to come into here. Next we create another drink named fruity. And we just set the flavor to fruity and set the fluid ounces to ten.
02:19:51.238 - 02:20:11.820, Speaker B: And then again call the print drink function with this fruity drink. When we run the program, we should have flavor sweet followed by 6.0 printed. After that, we should have a fruity flavor printed and then 10.0 for the ounces. Let's run it and see what we get. To run the program, go to terminal, new terminal.
02:20:11.820 - 02:20:42.706, Speaker B: Type in cargo run dash q dash dash bin. We are on activity eight right here. So type in a eight. And as we can see, we have our sweet drink with that 6oz as we can see here, followed by our fruity drink at 10oz, which we can see here. This concludes the activity video on structures. I'll see you in the next presentation. In this video, I'll be covering tuples.
02:20:42.706 - 02:21:34.270, Speaker B: I'll explain what they are and how they can be used to manage data within your program. A tuple is a type of record, and records can be thought of as a line of information on a piece of paper. Tuples are essentially a way to access each piece of data within that line or within that record. They store data anonymously, and there's no need to name the fields in your tuples. Unlike a struct or an enum, where each field or variant has to have its own unique name, they are useful to return pairs of data from functions, and they can also be destructured easily into variables. So let's hop into an example and see what all this means. Here we have multiple pieces of data being created in order to help illustrate the example of tuples.
02:21:34.270 - 02:22:18.250, Speaker B: First, we have an enumeration being created called access with a single variant named full. Next we have a function called 123, and we're returning three separate values within a tuple. So right away we can see that we have 32 bit integer three times, and it's a tuple because it's surrounded within parentheses. And as we can see, we return one, two, three as a tuple because it's surrounded in parentheses. So let's see how that works. If you were to use this function on this line, we're creating a variable named numbers. We're setting it to the value of this function, one, two, three.
02:22:18.250 - 02:23:04.834, Speaker B: So this function returns a tuple with three values and they will be populated into the numbers variable. On this next line we have what's called destructuring. We take these three pieces of information from this function and we put them into individual variables. One, two and three will be populated into x, y and z. Here we can see that we're printing out the values of the variables x, y and z are present just as right here. And that will print out one, two and three. And in order to access the data from this numbers variable, since it's only one name, we use the dot notation.
02:23:04.834 - 02:23:37.040, Speaker B: So the name of the variable dots, and then a number. The number is the index of the tuple. And indexes start at zero. So the first index is zero, meaning it'll access this first piece of information here, which is a one. So that'll be one. The next piece of information is number one, and the last piece of information is number two. Lastly, we have two variables being created, one named employee and the other named access.
02:23:37.040 - 02:24:27.420, Speaker B: The employee variable is being set to the string jake, and his access level is being set to full. So here you can see we can mix different types of data when working with tuples. To recap, tuples allow for anonymous data access. They're useful when destructuring information into multiple variables, and they can contain any number of fields. However, you will want to use struct when you're working with more than two or three fields, as this will help keep your code a little more organized. In this demo, I'll be showing you how tuples can be used to organize data within your programs. So to get started, I'm going to create a cartesian coordinate, which is simply an xy points on a plane.
02:24:27.420 - 02:25:11.662, Speaker B: So I'm going to call it coordinates, or chord for short. I'm going to assign it the tuple of the values two and three. So here I have just created a tuple with values two and three. They get assigned into this coordinate variable, and to access them we would do, I'll do a print line so they can print out. If you wanted to print them, we can use the debug tokens and then type in cord zero and cord one. So they're accessed by index using the dot notation. So the name of the variable dot, then the index number.
02:25:11.662 - 02:25:55.958, Speaker B: So this is index zero, this is index one. And if you had more, they would just keep on going to however many you had. And here is number one. So this will print three, and then this one will print two. And that would be how you can use a tuple using a single variable name. Next, if you want to destructure, which I usually recommend if you're working with tuples to destructure, you would do parentheses around the variable names that you want to assign, you create your tuple. So in this case we created the same tuple with the values two and three, except this time the two is assigned to x and the three is assigned to y.
02:25:55.958 - 02:26:38.680, Speaker B: So we don't need to access them using any dot notations. So if we were to create another print line statement to demonstrate how it would work, you can just type in X and then Y, and then it would print out just as the previous one did. And so this will print out two, this will print out three. Since now we have them assigned to individual variables, you can also mix and match data types. So I'm going to create a variable called userinfo, and then I'm going to put in some user information. So I'll put in a username, put in Emma, and then we'll put in their age. We'll say they're 20 years old.
02:26:38.680 - 02:27:45.796, Speaker B: Now, as you can see, we have a string and a number being created within a tuple. Since we have the parentheses and they're both being assigned to this userinfo variable, and they would be accessed using the dot notation just as previously shown. So it'll be userinfo, zero and one to access this. Now here's why I recommend destructuring, because as you can see, if you were to use this userinfo variable later on your program, then you might be confused about what zero means and what one means. So what you can do is instead of giving it this user info variable, you can do name, age, and now you have two pieces of information that are descriptive and are easy to determine what they are and what they mean. So there's one more thing I wanted to go over, and that is keeping the amount of data in your tuple concise. So let's give a bad example first.
02:27:45.796 - 02:28:13.200, Speaker B: So we have, we'll have favorites. This could be like someone's favorite stuff. So we'll have their favorite color can be red, favorite number be 14. Their favorite state can be Texas. Their favorite food is pizza. Favorite tv show is tv show. And we'll say that their favorite place to be is at home.
02:28:13.200 - 02:29:00.348, Speaker B: So now we have 123456 pieces of information, and they would all need to be accessed using a number. So here we have index zero, then 12345. So if you wanted to figure out later in your program their favorite state, you would have to do that. State equals favorites dot two. So that would be their favorite state because Texas has index two and the same thing with their, their favorite place to be. That would be their home as we can see up there. So let place is favorites dot and then we're going to count it.
02:29:00.348 - 02:29:57.740, Speaker B: 012345 so favorites five. So if you were to list all these out, it could become confusing later on, especially if you have more than like five, maybe even ten things. So in this case, where you have all these different pieces of data which are similar because they're someone's favorite things, you would want to create a structure and give everything a name because these numbers here start to become pretty ambiguous once you get more than like three, even four I would say is probably too many. I usually just keep my tuples at three values instead of more than that. That way you don't end up in a situation where you have lots of different things and maybe they have strange names and you not sure what TX means. Like maybe that means transmit information or maybe it's Texas. You know, it might be hard to tell, but if you create a structure with all the field names, then it'll be much, much easier to understand later.
02:29:57.740 - 02:30:43.320, Speaker B: That's the conclusion of this video and I'll see you in the next presentation. In this activity video, we'll be creating a program that works with tuples and it will demonstrate how you can use them to organize your code. So let's hop into visual studio code and get started. Once visual studio code is loaded, navigate to your activities directory, your SRC bin directories, and load up the a nine rs file. Since we're on activity nine, double click. Once the activity file loads, review the topic and program requirements. As with other activities, attempt to implement a solution on your own with the video paused.
02:30:43.320 - 02:31:36.520, Speaker B: Once completed, resume the video and I will demonstrate my implementation as well as provide some insights to the activity topic. Alright, let's go ahead and get started. As we can see, our topic for activity nine is data management using tuples. Our program requirements are to print out whether the y value of a cartesian coordinate is greater than five, less than five, or equal to five. Our notes for this activity we must use a function that returns a tuple. We want to destructure the return value into two variables and we want to use an if else if else block to determine what should be printed. So when I start my programs I always like to copy the notes into the program so I'll copy those in so I have something to work with.
02:31:36.520 - 02:32:39.264, Speaker B: So the first note states that we need to use a function to return a tuple so we know we're working with cartesian coordinates. So I'm going to name my function coordinate and it's not going to have any input parameters and we're just going to return a tuple as indicated by the note and it's going to be 32 bit integer return values in a tuple and it doesn't state what the coordinate should be. But we do know that we're dealing with just the y value so I'm going to do mine greater than five and then I'll change it later just to make sure everything works. So I'll have the first value be one, that's the x value and then the y value. I'll set it to seven. So this tuple will get returned as a tuple with 232 bit integers. Next I'm going to hop into the main function and we need to destructure the return value into two variables.
02:32:39.264 - 02:33:28.370, Speaker B: So we need two variables so we use our let binding and then we have x and y will be my variables. Remember to destructure we use the parentheses when we're creating our variables. Next I'm going to call the coordinate function to get my tuple. So when I call the function this tuple is going to get returned here and placed into the x and y variables. Next we need to use an if else if else block to determine what to print. This is similar to a previous activity where we use this similar style to print different messages. So if the y value, remember we only are concerned with the y value.
02:33:28.370 - 02:34:13.058, Speaker B: If the y value is greater than five then we're just going to print out greater than five. And then if the y value is less than five we're going to print out less than five. And finally, if it's not greater than or not less than five it must be equal to five. So we're just going to print out equal five. And so that should cover the program requirements where it prints out if it's greater than, less than or equal to five. And we also use the if else if block as seen here. I also noticed that I just missed the if.
02:34:13.058 - 02:34:50.298, Speaker B: So I'll add that in and now it should be complete and run properly. So before we run the program, let's just walk through it really quick. We're creating two variables by destructuring the return value of coordinate. So the coordinate function is going to return a tuple as 232 bit integers. Each one then goes into the appropriate variables. We then ignore this x value because we're only concerned with the y value. We then check to see if it's greater than five.
02:34:50.298 - 02:35:23.840, Speaker B: If so, we'd print this. If it's less than five, we print this, and if it's equal to five, which would cover the else, we'll print out equal to five. Let's run this and make sure it works. I'm going to go to terminal, new terminal. I'm going to run this with cargo run Q bin. We are on activity nine, so a nine, and hopefully everything runs as expected. As we can see, we get a message that prints out.
02:35:23.840 - 02:35:54.580, Speaker B: It indicates greater than five. Our Y coordinate is seven, and so it's working properly. Let's change this y value to one, and just to make sure it prints out less than five, when it actually is less than five, I'll rerun it. And here we can see it printed out less than five. And just to for completeness, I'll set it to five and it should print out equal to five. And here we have equal to five. So the program is properly working.
02:35:54.580 - 02:36:23.690, Speaker B: This concludes the video on this demo. I'll see you in the next presentation. In this video, I'll be explaining expressions. Rust is an expression based language. This means that most things are evaluated and return some value. These expression values then coalesce to a single point. As a result, expressions can be used for nesting logic.
02:36:23.690 - 02:36:59.600, Speaker B: Let's take a look at an example to see what I mean about coalescing. In this example, we're creating a variable named mynum and setting it to three. We then have a let binding, and the let binding is set to the value of an expression. The expression we're setting it to is the if expression. So we're setting is lt five to the results of this expression, which extends all the way here. So if my num is less than five, we'll set the value to true. Otherwise, we'll set it to false.
02:36:59.600 - 02:37:44.860, Speaker B: Once this if expression is evaluated, either true or false will be set to is lt five. In this case, mynum is equal to three and three is less than five. So true will be set to is lt five. A shorthand for this situation. Since this part here evaluates to true or false, we can just assign it directly to a variable. As we see on the bottom, we can achieve the same results without using an if expression by just supplying minum less than five, that'll either be true false, either of which will be set into this variable. We can also do this with match expressions.
02:37:44.860 - 02:38:22.080, Speaker B: Again, we have my num being set to the value of three. And then we have a new variable named message. The value of message is the expression evaluation of this match block. So here we're matching on my num, which is a three. So if my num is one, we'll get hello, and if it's anything else, we'll get goodbye. Since my num is equal to three, we'll take this match arm and goodbye will be placed into the message. It's also possible to nest expressions, so you can nest them as many times as you want.
02:38:22.080 - 02:38:54.530, Speaker B: It could become a little overwhelming if you nest them too much. So in this example we have an enumeration that just has burgers, fries, and a drink. We have some variables created here, and then here we have a really large let binding and we're assigning it to the value of multiple expressions. So first we're matching on the item. In this case it's a drink. In the match arm, we're checking if we have a drink within the body of the match arm. We then have another expression, an if expression.
02:38:54.530 - 02:39:51.990, Speaker B: This time we check to see if the drink type as indicated here is water, and if so we'll return true, otherwise we'll return false. Perhaps this means that the restaurant only has water available, so maybe they'll cancel the order. If the drink is anything except water, we then have the rest of the enum variance, which will return true. So no matter what, the order placed variable will have either a true or a false value, because this match expression will eventually evaluate to either true or false as indicated by the if expression. But as I mentioned earlier, you don't want to nest these too far because it's really easy to get lost in the code. To recap, expressions allow nested logic. If and match expressions can be nested, but it's best not to use more than two or three levels of nesting because the code can become convoluted.
02:39:51.990 - 02:40:48.384, Speaker B: In this demo, I'll be showing you how expressions can be used to nest logic in your code. I'll be making a program that determines whether or not somebody has access to a certain resource. So you could use something similar to this if you're writing a server and you want administrators to access one section, but guests would not be able to access it. So to get started I need to create a few data types. So I'm going to create an access data type and this will be admin and then we'll say manager, user, and we'll have guest. So each one of these access levels has permission to access different parts of the program. So what we'll be doing is simulating access restrictions on some file.
02:40:48.384 - 02:41:28.146, Speaker B: So we'll create a fake user and a secret file that they may or may not be able to access, depending on their access level. So we'll create a secret file. Let's use a code comment secret file, admins only. So only admins should be able to access whatever we happen to be making. We're going to create a user and their access call access level. Their access level is set to guest, so they probably don't have much access to the system. We'll then create another variable called can access file.
02:41:28.146 - 02:42:03.028, Speaker B: And remember, we're dealing with a secret file, that's admins only. So only admins should be able to access the secret file. And we're going to use a match expression. So we're assigning, instead of just assigning a value like we did here to a variable, or we just assign this to here, we're assigning the value of an expression to can access. And this is either going to be a true or false. Now, you aren't limited to just true and false. When you do expressions, you can return anything you like, but I'm just going to do true or false.
02:42:03.028 - 02:42:38.894, Speaker B: So we're going to match on the access level of our user, and if their access level is admin, then we'll return true. If it's not, we're just going to return false. And remember to always include the semicolon here at the end of your let binding. That's part of the syntax. So now that we have our code set up, let's walk through it really quick. We're creating an enumeration called access. We have four variants and they just represent different user accesses.
02:42:38.894 - 02:43:21.876, Speaker B: We have admins, managers, users and guests in our program. We're creating a secret file and we're setting it to admins only. We're not actually doing the code and logic to perform those actions. This is just a conceptual exercise. So we're just saying that our program already has a secret file and all the mechanisms are already in place to set which access level is allowed. And we're saying that our user here has an access level of guests and we're determining whether or not that they can access this file. And to make that determination, we use a match expression.
02:43:21.876 - 02:44:37.540, Speaker B: We're matching on the user's access level, which is right here. So if the user has the access level of administration, then we'll just set it to true so they would be able to access the file and any other access level, they're just going to get denied because it's false. So if they were a guest, for example, in our case they are a guest, false would then be populated here. So when we run the program, we know that we have a guest, they're not an admin, so this wouldn't be executed. There's something else guest in this case, so false would then get returned here and eventually end up in the can access file variable and they would not be able to access the file. So if we wanted to then print out our results, just to confirm, we can do a print line and we'll just print out a quick message and the value, so we'll say an access and it'll print out either true or false. I'll run it in the terminal by going to terminal, new terminal, and then I'll just run the demo.
02:44:37.540 - 02:45:04.110, Speaker B: And here we go. So we can see that the message states can access is false. So our access level is guessed and we know that we have to have admin access in order to access it. So the value is set to false. And as we can see, can access here is false. So this concludes the demo. I'll see you in the next presentation.
02:45:04.110 - 02:45:52.910, Speaker B: In this activity, we'll be encapsulating our logic within expressions in order to make our program easier to follow and more robust. So once you're ready, fire up visual studio code and we'll get started. Once visual studio code is loaded, open up the a ten activity file so double click and the activity file will load. Once the activity file loads, review the topic and program requirements. As with other activities, attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Okay, as we can see, our topic on this activity is working with expressions.
02:45:52.910 - 02:46:50.396, Speaker B: Our program requirements are to print out its big if a variable is greater than 100, and its small if a variable is less than or equal to 100. So the requirements aren't too bad. As we can see in our notes, we need to use a boolean variable set to an expression that determines whether the value is greater than 100 or less than or equal to 100. We need to use a function to print out the messages, and we also need to use a match expression to determine which message to print. I'm going to start by copying in some of the notes into the main function for the variable with the value that we're checking. I'm just going to call it value. I will set it to 100 next, we need a boolean variable set to an expression so it doesn't say what type of expression that we can use, we can use.
02:46:50.396 - 02:47:32.760, Speaker B: If we can use match, I'm actually going to use neither. I'm going to show you a shortcut we can do for the situation. So I'm going to create my variable. I'll name it is gt 100. So is, and then GT will be short for greater than 100, and I'm going to set it to value greater than 100. So far in the activities, we've been very verbose about how it's being implemented with the if expressions. So if value is greater than 100, we would have true and otherwise we would have false.
02:47:32.760 - 02:48:14.018, Speaker B: Now remember, when we have an if statement, we have if something evaluates to true, then you go into this block. Otherwise you go into this block. Well, since rust uses expressions, we know that this itself is an expression. So value greater than 100, that's either going to be true or false because we're using it right here with the if expression. So we can just extract that out. And this will either be true or false, which will solve our goal of determining whether it's greater than 100. So we don't need to have this entire thing at all.
02:48:14.018 - 02:48:59.034, Speaker B: And usually if you have something simple like this where you're just checking the value, you can just pop it in straight like that and it'll be either true or it'll be false. So we don't need this whole entire block of if else expression. Next, we need to use a function to print the messages. So I'm going to create a new function called printmessage. Now, it's going to need to accept some function parameters in order to determine which message to print. So I'm just going to name my parameter gt 100. That's just going to be a Boolean because down here we're checking is greater than 100, value greater than 100.
02:48:59.034 - 02:49:26.692, Speaker B: That's going to be true or false. So we need to deal with a boolean value. I'm not going to return anything since it's simply just printing out a message. As also we can see with our notes, we need to use a match expression to determine which message to print. So now we need to use match. So we're going to match on the parameter which is named GT 100. And we know that's a boolean.
02:49:26.692 - 02:50:00.790, Speaker B: So the only options here are true and false. So when it's true, it's going to print out its big. As we see up here in the requirements, it's going to either print its big or it's small. So when the value is false we're going to print out its small. Lastly, we need to actually call the function. That way our message gets printed. So we'll call our function with our variable and this should complete our program.
02:50:00.790 - 02:50:43.150, Speaker B: Now that our program is complete, let's walk through it and see if we can figure out how it works before we actually run it. So here we have our value that we're going to be testing. We're going to use 100. Next we have a variable named is GT 100, which is short for is greater than 100 and it's being set to an expression and that expression just determines whether or not a value is greater than 100. So if the value is greater than 100, this will be true. And if it's not greater than 100 and then this will be false. In our case the value is 100 and it's not greater than 100.
02:50:43.150 - 02:51:23.536, Speaker B: So this is going to evaluate to false. So this false will then be populated into this variable here, which then gets passed into the printmessage function we call printmessage with this value which we know to be false. In our particular program, the false then gets matched here. So we match on Gt 100, which is our variable, which we know is false. So is it true? Nope. Is it false? Yeah, we are going to print out its small per the program requirements. Control then returns back to the main function.
02:51:23.536 - 02:52:03.442, Speaker B: There's nothing left here and so then the program is complete. And so I'm going to run this program now to verify that it works as we expect it to work. I'm going to go to terminal, new terminal. We are on activity ten, so I'm going to run it with the binary as a ten. As we can see it printed out it's small and our code has the value set to 100. The value is not greater than 100 so it prints out its small. If we change this value to, let's say 999, we should get a message of it's big.
02:52:03.442 - 02:52:33.888, Speaker B: So I'll rerun it. And here we see it's big because 999 is greater than 100. This concludes the activities video on expressions. I'll see you in the next presentation. In this video I'll be covering some intermediate memory concepts, including memory addresses and offsets. So a quick refresher about memory before we dive in. Memory is stored using binary.
02:52:33.888 - 02:53:10.780, Speaker B: It's stored using bits which are either zero or one. A bit is also the smallest unit of memory that can be stored. Computer hardware is optimized to work with bytes. One byte is equal to eight contiguous bits, and the entire memory in the computer can be thought of as one contiguous string of bits. All data in memory has something called a memory address. These addresses are used to locate data in memory. Addresses are always the same, only the data at the address will change.
02:53:10.780 - 02:53:58.350, Speaker B: Normally when you're writing programs, you won't utilize addresses directly, and instead you'll let variables do all the heavy lifting for you. Memory offsets can be used to locate items at a specific address. Offsets always begin at zero, and they represent the number of bytes away from the original address, similar to addresses. You usually don't deal with offsets directly. Instead, you'll deal with indexes, and the compiler will automatically calculate how many bytes away you are from the original address based on the index. Here we have a basic diagram showing computer memory with addresses and offsets. Each one of these squares represents one byte.
02:53:58.350 - 02:55:03.490, Speaker B: Here we have the offsets, and here we have the addresses for this particular demonstration of memory. Each byte here can have a memory address. This would be address 012-34-5678 910 and so on, all the way up to address 20. If we wanted to access this particular piece of data, it would be at address four with an offset of one. So address four, offset one, and when you're working with your program, you would usually have a variable name. I just use data as a placeholder, and you would use the index number surrounded by square brackets. If we wanted to access, for example, this piece of data, it would be at address 16, offset three, so we can access that with a variable name, and then three.
02:55:03.490 - 02:55:43.320, Speaker B: Remember that the variable name will automatically take care of the address, and the index will automatically get mapped to an offset by the compiler. So you don't need to know that each one of these squares is actually one byte. When you're working with programs, maybe each square is ten bytes or 20 bytes. That's not something that you need to be concerned with because the compiler will automatically calculate that for you. To ensure that you arrive at the correct memory location and have the proper data. To recap, memory uses addresses and offsets. Addresses are permanent, but the data at the address differs.
02:55:43.320 - 02:56:40.140, Speaker B: Offsets can be used to index into some data, so when you have a list of items, the index can be used to access individual items within that listen, in this video I'll be talking about ownership. Ownership is what allows rust to execute code in a performant manner and helps ensure that compiled code executes correctly under various circumstances. All programs must track their memory usage. If they fail to do so a memory leak occurs. A memory leak is when a program fails to track which memory is being used, and so then it has to reserve new pieces of memory. All programming languages utilize their own method of managing memory, and rust utilizes what is called an ownership model. In the ownership model, the owner of the memory is responsible for cleaning up the memory, and an owner in rust is simply a function.
02:56:40.140 - 02:57:12.290, Speaker B: In rust, the memory can either be moved or it can be borrowed from the owner. Let's take a look at an example. So far in our programs, we've been moving memory, so let's break that down. In this program, we have a light enumeration with two variants. We have a function that displays the light. It simply matches, and depending on what kind of light it is, it displays an appropriate message. In our main function, we create a dull light, assign it to the dull variable, and then display the light two times.
02:57:12.290 - 02:57:54.390, Speaker B: There is a problem with this program, however, and that is since we're calling display light twice, the program will not compile even though everything looks fine. There is an error. The error is due to the ownership model. When we create this new light and assign it to the dull variable, it is owned by the main function. So anything between these curly braces is owned by the main function. When we call display light with our dull light, this dull light is being moved into a new function. So this dull light here will get moved to display light and be placed up here into the display light function.
02:57:54.390 - 02:58:58.650, Speaker B: Now that the data has been moved into the display light function, it is now owned by this function, and any function that owns data is required to delete the data once the function completes. This means that the light which has been moved from main over into display light will get deleted once the display light function finishes. So the function will take the light match on it and print out an appropriate message dull in this case, and then once this match block completes, we'll reach the end of the function, in which case this light will be deleted. Once the light is deleted, it's no longer available for use again in the same function call, so everything works fine. On the first function call, this light gets moved into the function. After the function executes, this dull light is no longer available because the display light function, which is the new owner, deletes it. We then attempt to call the function again with the dull light, but the dull light is gone because it was previously deleted.
02:58:58.650 - 02:59:41.160, Speaker B: The compiler will tell us about this error, and it will also explain that our dull light was moved into this function, and we're not able to use it again in the same function call because it's already been deleted. The key thing to remember is wherever you create a variable that becomes the initial owner. So this dull variable is owned by the main function. And once you call another function with that data, the owner then is changed to that function. So we change the owner from the main function to the display light function. On this first function call. In order to fix the error where we're unable to use this display light function twice, we have to do what is called a borrow.
02:59:41.160 - 03:00:20.720, Speaker B: Here's the same program again that's been modified to use borrows instead of moving. It looks almost identical, except in our display light function, we have an ampersand, and within our function calls, we have ampersands as well. The ampersand symbol in rust indicates that we are borrowing data. This is also referred to as a reference. So we're referencing data or we're borrowing data. So what happens now is we create our dull variable just as we did, and the main function will immediately become the owner, so it's allowed to delete it. We call the display light function, and we let the function borrow the dole light.
03:00:20.720 - 03:01:02.046, Speaker B: So this dole light will go up here just as before, and we see that it's borrowing the light. The owner is still the main function. The display light function will match, it will print out dull, since it's a dull light, and then we will return from the function back to the main function. Since the display light function is borrowing this light, it's not allowed to delete it since it is not the owner. The main function is still the owner. So once control goes back to the main function, we can call display light a second time with the dull light, because the dole light still exists. It's still here because the owner has not deleted it yet, because we have not reached the end of the function yet.
03:01:02.046 - 03:01:51.430, Speaker B: So display light will be called twice, it will print out dull two times, and then our program will properly compile and run. Remember with ownership that when you create a variable within a function, that function will own it. We create the dull light here in the main function. So that function owns this dull light. When we use the ampersand symbol, as we see here in the function call and the function signature, that means that this function here, display light, will borrow the data, and if it's borrowed, it's not allowed to delete it, as only the owner is allowed to delete the data. Since we're borrowing, we can call the display light function as many times as we want to recap memory must be managed in some way to prevent memory leaks. Rust uses an ownership model to accomplish memory management.
03:01:51.430 - 03:02:37.198, Speaker B: The owner of the data must clean up the memory, and this will automatically occur at the end of the scope, which is the end of the curly braces. The default behavior when you're calling functions is to move the memory to a new owner. And if you just want to borrow data, you'll use an ampersand symbol to allow code to borrow memory, specifically to allow functions to borrow memory. In this demo, I'll be showing you how ownership works in the rust programming language. Ownership is Rust's model of memory management and is used to keep your programs running fast and free from memory leaks. Here we have a demo program. There is a struct called book.
03:02:37.198 - 03:03:17.732, Speaker B: It consists of number of pages and a rating. For the book, we have two functions. The first just displays the page count by printing out the number of pages by referencing the pages field. The second function displays the rating by accessing the rating field. In our main function, we are creating a single book with five pages and a rating of nine. All data in a program is owned by some other part of a program. If we take a look at this book variable, it is owned by the main function because that's where we created the variable.
03:03:17.732 - 03:03:47.460, Speaker B: It's the responsibility of the owner, in this case, the main function, to clean up the memory. And when it cleans up the memory, this is called a drop, so they're dropping the memory. Memory gets automatically dropped once the end of the block is reached. So this is the block for the main function. So once execution reaches here, this book will automatically be dropped. This is code that you don't have to write. It gets added automatically.
03:03:47.460 - 03:04:34.710, Speaker B: This code between the curly braces is also known as a scope, so you can refer to it as a scope or as a block. Now, let's call one of these functions. I'm going to call the display page count function, and we'll call that with the book. Now, what's happening here is that ownership is being transferred. So as we can see, we created this variable inside the main function, as we can see by the block. Once we call this function, ownership is transferred into this function. So we take this book, we're calling the function by giving the book to the display page count function that then gets moved here.
03:04:34.710 - 03:05:19.130, Speaker B: And this function becomes the new owner of this book, and it has its own scope or its own block. And once this block finishes executing, the book is going to get dropped because the owner is responsible for cleaning up the memory. So the display page count function is going to drop the book. What this means is once this function is executed, the book will no longer be available later on in the program. In our current program, that's not an issue. But if we were to try to use the book again, let's say we wanted to display the rating. This program will no longer work because we transferred ownership of the book into this function.
03:05:19.130 - 03:05:54.140, Speaker B: Then the function finished executing and dropped the book. And so the book no longer exists once we get to this line, because this function here got rid of it. So let's try to run the program and we'll see what happens. Here. We can see we get a compiler error, and the error indicates that we used a moved value and it gives us a description of what happened. So the value was moved into the display page count function, and then we tried to use it again in the display rating function. So let's try to fix that.
03:05:54.140 - 03:06:31.602, Speaker B: In order to fix this, we need to do what is called borrowing. So instead of moving the ownership into these functions, we're going to have these functions just borrow the data. So when a piece of data is borrowed, the function is not allowed to drop it because the owner is still the original owner. In order to borrow data, we use the ampersand symbol. So here, the display page count function is now accepting a reference to a book. This is also known as borrowing. So they're just borrowing this book and then they're going to give it back.
03:06:31.602 - 03:06:52.170, Speaker B: We'll do the same thing for our rating function. And now to call the functions, we also supply the ampersand. And now everything should work correctly. So now let's walk through it again. We have a book. It's owned by the main function. We are letting the display page count borrow the book.
03:06:52.170 - 03:07:33.430, Speaker B: And so since the main function still owns the book, the display page count function cannot delete it. We then let the display rating function borrow the book here, and then it will display the rating and it won't get dropped because they're just borrowing it. And so now our program should compile and we should get the page count and rating displayed. So let's try it and see what happens. And here we go. We have the number of pages and the rating displayed for our book. The reason we need to do all this is for efficiency and memory management.
03:07:33.430 - 03:08:22.662, Speaker B: If we had a data structure that was large, like several megabytes, if you were to transfer ownership of that structure to different functions, it would require copying all that data each time you use a function. But if you just let a function borrow it instead, then it performs much quicker because the data stays in one place and the function can simply borrow the data and then give it back. So there's huge performance implications to having borrowing versus transferring of ownership. The bookstruct that we made is pretty small. It just has two pieces of information. So this would be something that would be okay to copy around and move ownership of. This concludes the demo on ownership.
03:08:22.662 - 03:09:05.920, Speaker B: I'll see you in the next presentation. In this activity we'll be creating a program that demonstrates ownership. We will be using moving and borrowing in order to execute functions and automatically manage memory. Once you're ready, let's hop into visual studio code and get started. Navigate to your activities directory and we are on activity eleven, so double click on a eleven to load the activity file. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused and once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic.
03:09:05.920 - 03:09:39.730, Speaker B: Okay, let's go ahead and get started. We can see that this activity topic is about ownership. The requirements are simply to print out the quantity and id number of a grocery item. Our notes indicate that we need to use a struct for our grocery item. This direct needs to contain two I 32 fields, one for the quantity and one for the id number. We need to create a function to display the quantity and a function to display the id number. I'm going to copy the notes into the code so I have a starting point.
03:09:39.730 - 03:10:15.570, Speaker B: So we need to use a struct for the grocery item. So I'll create a new struct and I'll call it groceryitem. We then need two I 32 fields for the quantity and id number. So I'll have one named quantity and id. Next we need to create a function to display the quantity. So I'll call my function display quantity and it will accept a grocery item as a function parameter. We also need a function to display the id number.
03:10:15.570 - 03:11:05.120, Speaker B: I'll call that display id and it will also accept a grocery item. Now all we need is to create some print line macros and this will be the quantity and we need to reference the quantity field within the grocery item and then in display id. We're just going to change this to ida and now we have our functions set up. Now we just need to create a grocery item and then call the functions. I'll call my grocery item myitem and it is a grocery item. I'm going to have three of those and I'm just going to give it an id of 99. Next we need to call the functions.
03:11:05.120 - 03:11:28.900, Speaker B: I'll display the quantity of my grocery item and then I'll display the id of the grocery item. So far so good. So let's run this and see what happens. We can run it by going to terminal. Click on new terminal. We then do cargo run q bin. We are on activity eleven, so type in a eleven.
03:11:28.900 - 03:12:01.466, Speaker B: As we can see we have an error. We used a moved value, so we moved the grocery item into this function and then we tried to use it again later in this function. So we moved it here and then we try to use it again here. And we can't do that so we need to fix that. If you recall, when we create a variable, it's owned by its enclosing scope or block. So this is the scope or the block of code. So my item is owned by main.
03:12:01.466 - 03:12:49.490, Speaker B: When we called display quantity here on line 33, ownership changed to the display quantity function. This means that once this block is completed, the grocery item will then be dropped by the display quantity function and the memory will no longer be available. So once display quantity is called, my item is no longer in use. So when we try to use it again here, we can't because it was deleted in a display quantity function. To get around this we have to borrow the information. So I'll modify my display quantity function and use the ampersand to indicate we're just borrowing the grocery item. We're not taking ownership, we're just borrowing.
03:12:49.490 - 03:13:23.366, Speaker B: I'll do the same thing for display id. Then when we call the functions we want to indicate that we are letting these functions borrow the grocery item, so they're borrowing it with the ampersand. It's also called a reference. So we're referring to this item here, but we still keep the owner as main. Let's save it and run it and it should run correctly. And here we have the quantity displayed and the id number displayed. As we expected, this concludes the activity on ownership.
03:13:23.366 - 03:13:53.058, Speaker B: I'll see you in the next presentation. In this demo, I'll be showing you the impl keyword. IMPL allows you to implement functionality on specific enumerations and structs. This greatly enhances the organization of your code and makes your programs easier to follow. Here we have a sample program created. We have a struct name temperature. It stores degrees in Fahrenheit.
03:13:53.058 - 03:14:30.170, Speaker B: We have a function named showtemperature which accepts a temperature as a function parameter and it just prints out the degrees in Fahrenheit. And lastly, our main function, we create a variable named hot. We set it to a temperature with a degrees f of 99.9. We then call the showtemp function with our hot variable, and that would cause the print line macro to display the degrees in fahrenheit. I'm just going to run it really quick so we can see that it does display the degrees in fahrenheit. Here we have 99.9 degrees fahrenheit.
03:14:30.170 - 03:15:24.630, Speaker B: Something we can do to improve this program is to move this showtemp function and make it part of this temperature structure, since it's only really relevant when you're dealing with a temperature. To do that, we create an impl block. So we create an implementation block using the impl keyword and we type in the name of our struct, which is temperature. We then use curly braces to define the scope of our implementation block. So we have the impl keyword followed by the name of your structure or enumeration. Implementations are used frequently, so we have a nice shortened version impl, similar to fn for function. Now all we need to do is move our showtemp function into the implementation block as such.
03:15:24.630 - 03:16:15.160, Speaker B: And now to call the function, instead of just typing show temp, we have to type in temperature, then use two colons and then show temp. So when you're accessing a function within an implementation block, you have to use the name of the structure or enumeration followed by the two colons, and then the function that you wish to call. If we save and run this, we should get the same result. As you can see, we have the same result, 99 degrees fahrenheit. Now our code is a little bit more organized. We have the temperature related functions within our implementation block for temperature. So whenever you want to deal with a temperature, you can go straight to this implementation block to work with the code within this block.
03:16:15.160 - 03:17:06.402, Speaker B: We can improve on this, however, by doing what is called taking a reference to self. To do that, we change the function parameters here. So instead of having a temperature being passed in as a function parameter, we type in reference to self. If you'd recall, the ampersand is used to mean borrowing, and it also is referred to as a reference. So referencing self and self is just a temperature or whatever implementation block you happen to be using. It just refers to this structure or enumeration. We have to change our temp variable here since we deleted that, we don't have anything here except for self, so this is just going to get changed to self dot degrees Fahrenheit.
03:17:06.402 - 03:17:55.966, Speaker B: So self is referring again to a temperature, and within this temperature structure we have degrees Fahrenheit. So you can think of this just as a temperature, and we access the field as we did before, and it will print out degrees f. So why did I do that? I'll show you right now. Before we had to type out temperature, then the two colons and then showtemp function and then pass in the temperature as an argument. Now, instead of doing all that, all we need to do is type in our variable and type in showtemp. So we can call the function directly by using a variable name and the dot. The rust compiler knows that the hot variable is a temperature, and we implemented some functionality on this temperature.
03:17:55.966 - 03:18:32.584, Speaker B: We implemented the Showtemp function. When we refer to a reference to self compiler knows that you can call the function on variables that are of a temperature type. So we can type in the variable name a dot, and then once we type that dot, we have all the access to these functions within the implementation block. Let's run that again and confirm that it works properly. As you can see, 99.9 degrees f is again displayed. We can also use implementation blocks to create specific types of temperatures for us.
03:18:32.584 - 03:19:13.820, Speaker B: So let's create a freezing temperature. So we have make a new function called freezing. Within the implementation block we're going to return a self with a capital s. So the difference between this capital s self and this lowercase self is the lowercase version indicates that we already have a temperature created somewhere in the program. The capital s in this one indicates that we don't have a temperature somewhere and we're creating a new one. Or we are just referring to temperature as the name. So you can think of capital self just as the word temperature.
03:19:13.820 - 03:20:03.908, Speaker B: I will then create a new temperature structure by using self, and we will set the degrees to 32.0. So self can be thought of as referring to whatever struct or enum that you're implementing. You can also just type in temperature instead of self and it will work the same. The only issue with that is if you decide later to change this name to something else, then you're going to have to change the implementation functions as well. So if you use self, you don't need to do that, and it'll always refer to whatever you happen to implement. If we were to change this to temperature hot internally, we don't need to change anything since we use self and automatically it's going to refer to the proper name. I'm going to leave it at temperature.
03:20:03.908 - 03:20:38.520, Speaker B: And so we're creating a freezing temperature, returning a new temperature within the block. We're creating a new temperature, setting it to 32 degrees fahrenheit. Let's see how that can be used in your main function. So we'll create a new temperature called cold and we will call the implementation function. So we have freezing, and then if we type in cold showtemp and run the program, we'll see that we have 99.9 degrees and 32 degrees. And there we go, just as expected.
03:20:38.520 - 03:21:18.474, Speaker B: So what's happening here is we have our temperature structure. We use the two colons to identify an item within the implementation block. We then identify the freezing function. Here. We call the function with our parentheses, and then once the function is called, we return a temperature and we create a new one within that function with 32 degrees f. Next we call the showtemp function that's implemented here by using the variable name dot, then the function name. We then use the parentheses to call the function.
03:21:18.474 - 03:22:07.310, Speaker B: There's no function parameters. The self is implied when you use the dot notation so it knows that there's going to be a self. Here we are taking a reference, which means that we can call the showtemp multiple times, but we want to call it four times. It'll still work without issues because if you'll recall a few lessons ago, we covered ownership and borrowing, so we're just borrowing self so we can use it multiple times if we wanted to. We can create another function. We can just call this one boiling and we'll return a temperature with degrees of 212. And now just like the cold temperature we can create one called boiling and just call the boiling function.
03:22:07.310 - 03:23:01.620, Speaker B: And now we have a boiling temperature that will be displayed. So as you can see, implementing functionality on structures and enumerations if you like, provides easy ways to manage your code because all the temperatures are here in one place and it makes it convenient for creating standardized functions for creating new structures. So here we have our freezing and boiling. So whenever you need to have a freezing or boiling temperature you can just use that function instead of having to type in the numbers throughout your program. This concludes the demo on implementing functionality on your structures and enumerations. I'll see you in the next presentation. In this activity we'll be creating a program that utilizes the impl keyword to create functionality implementations on structs and enumerations.
03:23:01.620 - 03:23:46.244, Speaker B: Once youre ready lets hop into versus code, open up your activities directory and navigate to a twelve were on activity twelve so double click once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Alright, let's get started. As we can see, this topic is about implementing functionality using the impl keyword. Our program requirements indicate that we must print out the characteristics of a shipping box. We have to include dimensions, weight and color in our notes.
03:23:46.244 - 03:24:23.572, Speaker B: We can see that we need to use a struct to encapsulate the box characteristics. We need to use an enumeration for the box color and we need to implement functionality on the box struct to create a new box. We also need to implement functionality on the box struct to print the characteristics of the box. So we'll be able to use functions however, they have to be done as implementations on our structure. I'm going to start by copying in some notes into the program. So first I'll create the enum for the box color. So we use the enum keyword color.
03:24:23.572 - 03:24:56.610, Speaker B: It doesn't indicate how many colors we need, so we'll just have the typical brown box and I'll have a red box for fun. Next we need a struct to encapsulate the box characteristics. So we use the struct keyword. I'm going to call mine shipping box and we need the color. We also need dimensions and weight. As we can see here, we need dimensions, weight and color. So the weights can be an f 64 and for the dimensions I'm going to actually make another struct.
03:24:56.610 - 03:25:44.266, Speaker B: So for the dimensions we'll have another structure called dimensions and that will have a width and we'll set that to an f 64. We will also have a height and a depth. Next we need to implement functionality on the struct to create a new box. So we'll copy both of these in. I'll create the implementation block using the impl keyword and we're going to implement functionality onto our shipping box. So we're going to create a new box first. So we'll have new current naming conventions and rusts indicate that we should use the new function when we're implementing functionality to create a new structure or enumeration.
03:25:44.266 - 03:26:26.184, Speaker B: So I'm naming my function new. It's going to accept awaits as an f 64. It will accept a color and it will accept dimensions. I will then use the self keyword to return a shipping box and we'll create the shipping box using self with the weight color dimensions. So the self keyword always refers to whatever you're implementing. So this refers to a shipping box for both of these selfs. The fields here have the exact same names as the actual structure, so I don't need to indicate which field I'm referring to.
03:26:26.184 - 03:27:15.378, Speaker B: So I don't need to put in color and then set it to the color variable. So that doesn't need to be done because if you have the exact same names as the struct fields, then it'll automatically put the data into the correct locations for you. Now before I implement the functionality to print out the characteristics of the box, I'm actually going to implement functionality on the dimensions and color data for the color. I'm going to implement a function to print out the color. So I'm going to use the impl keyword and the name of my enumeration. I'm going to call this just print. It's going to take a reference to self, it won't return any data and it's just going to print out the color.
03:27:15.378 - 03:27:52.760, Speaker B: So I'll match on self. And if we have a color of brown we will just print out brown. And if we have color of red we'll print out red. In this implementation block we're simply borrowing self, which is a color that was created somewhere else. We're matching on the color. There's only two variants available, so we have color brown and color red. I'm also going to be implementing functionality onto the dimension structure in order to print out the dimensions.
03:27:52.760 - 03:28:36.432, Speaker B: So I type in the impl keyword followed by the name of the struct, which is dimensions. And then I'm going to create the same function name as I did on color and it's also going to be a reference to self. So again we have a function implemented on dimensions. The ampersand followed by a lowercase self indicates that we're referring to a dimensions that has been created elsewhere. I'm going to place a series of print line macros that display the information as needed along with the debug tokens. So for this one we have the width where you can access self, which is a dimensions. Dimensions has three fields.
03:28:36.432 - 03:29:16.410, Speaker B: I'm referring to the specifically the width field for this print line statement. We then just need to deal with the height and the depth. So we'll change this one to height and then the next one will be depth. And now we have a function implemented on dimensions which prints out all the information needed to display a dimensions structure. Now that I've implemented that functionality, I can go back to the shipping box and actually print out all the information. To do so, I'm going to create another function called printhead. And it again is going to take a reference to self.
03:29:16.410 - 03:29:50.744, Speaker B: And then I'm just going to call self dot color dot print. Now here we have a reference to self, which is a shipping box. Within that shipping box we're accessing the color field. And then within this color field we're accessing the print function. So let me split the view and we can see how it looks. So this is a color within the shipping box. And then we're here, we're accessing the dot print function within that color.
03:29:50.744 - 03:30:18.858, Speaker B: So we're accessing this function to print out whether it's brown or red. Next I'm going to print out the dimensions. So I'll do self dot dimensions, dot print. And that's the same thing as the color. So referring to self, which is a shipping box right here, we are accessing the dimensions field. Here. The dimensions field is a dimensions type.
03:30:18.858 - 03:30:58.252, Speaker B: And if we look at our implementation of dimensions, we can see we have a print function. So this dot print refers to this print function, which will then print out the width, height and depth of the dimensions. Lastly, we want to print out the weight. So I'm just going to do a print line and we'll have weights with the debug token. Again, self dot weight. On this one we have self, which is a shipping box. And we are referring specifically to the weight of the box, which is right here as an f 64 field.
03:30:58.252 - 03:31:28.662, Speaker B: Now that the implementation is completed, all we need to do is create a new box and then we can print it out and see what happens. In order to create a new box, we first need to set the dimensions. So we'll create a small box. Small. We'll call this small dimensions. So we have dimensions and we have a width and that can be 1.0. We have a height and that could be 2.0.
03:31:28.662 - 03:31:54.590, Speaker B: And we have a depth and we'll set that to 3.0. Always end your let bindings with a semicolon. Here we're creating a dimensions. As we can see in this dimension struct. It has three fields and we have our three fields there. We will then create a new box. So we'll call our shipping box small box.
03:31:54.590 - 03:32:32.238, Speaker B: That is a shipping box. I'm going to use the new function that we implemented on the shipping box to create the shipping box. So instead of just creating the structure directly like I did with the dimensions, I'm going to use this function to create it instead. So we have shipping box, then we call the new function I'm going to pass in a weight of 5.0. The color can be red and the dimensions will be the small dimensions that we created. As you can see we have our small box. We access the shipping box information.
03:32:32.238 - 03:33:06.420, Speaker B: The implementation block here we call the new function by using the two colons. New function calls are always in parentheses. Our function has a weight, a color and a dimensions. And here we have our weight, our color and our dimensions. So our dimensions were created here as small dimensions that will go right there. And finally, now that we created our box, we can actually print out the information. So if we call smallbox print, our information should all print out.
03:33:06.420 - 03:33:36.270, Speaker B: Remember we have a reference to self here in our print function. So we can use the print notation on the variable small box. I'm now going to run this program. So to run the program go to terminal, new terminal. We are on activity twelve so you can type in cargo run q bin a twelve. So here's our information. Up here we have our width, height and depth of one, two and three.
03:33:36.270 - 03:34:00.536, Speaker B: We have a red box and its weight is 5.0. So as long as everything is coded properly, we should have that information displayed to the terminal when we run the program. So let's give it a go. As we can see we have a red box. Its width is one, its height is two, its depth is three. So that looks good. And then our weight is 5.0
03:34:00.536 - 03:34:33.890, Speaker B: as we can see here. Im going to do one last walkthrough of the entire code so we can see exactly how it works. I want to split the view so we can see all the code at the same time. Alright, so we're creating first a small dimensions. We're creating a new dimension structure with a width, height and depth of one. We are then creating a smallbox variable using the shipping box new functionality. This functionality is implemented here on our shipping box.
03:34:33.890 - 03:35:21.962, Speaker B: We call the function with five for the weight, red for the color, and then for the dimensions we use the small dimensions that was just created here. That will be the dimensions. We use the self keyword to refer to this shipping box. And then we create a new shipping box using the weight, color and dimensions that were supplied down here in the main function. We then call smallbox printed print is provided by creating a function implementation using a reference to self. So self refers to a shipping box. And since we have the ampersand, that means it's referring to a shipping box created somewhere else.
03:35:21.962 - 03:35:58.670, Speaker B: In this case, it was created right here on the previous line. In this print function, we use self dot colorization. Remember that self is a shipping box. And as we can see here, a shipping box has a field named color. So when we do color, we access this color enumeration. So this color enumeration is up here, and it has its own implementation of print. So here on the left, we're accessing color printhead, which is this function here.
03:35:58.670 - 03:36:32.732, Speaker B: We then refer to self with an ampersand, which is a color. And that means we have a color created somewhere else, which was created when we made our new shipping box. We then match on the color. We have two variants, brown and red. We account for all of them, and then we just print out whether it's brown or reduced. After that prints, we return back to our print function in the shipping box. And then we access the shipping box dimensions.
03:36:32.732 - 03:37:11.428, Speaker B: So the dimensions are here, and that is a dimensions structure. The dimensions structure has three fields, and it also has an implementation of its own version of the print function. We access the print function and the dimensions by having a reference to self, which refers to a dimensions created elsewhere. Again, that was created here in our new, which was initially created right here. We then print out self width. So self is dimensions, and it has a width, height and depth. We print out the width, height, and depth.
03:37:11.428 - 03:37:46.336, Speaker B: Control then returns back over here to our print function. Finally, we just print out the weight, referring to self. Wait. This self refers to shipping box, which has a weight field of f 64. So we access it using weight. Finally, control then returns to the end of the main function, and the program terminates. My implementation of the activity may seem slightly convoluted with the arrows going everywhere, but this is how you'll see most of the code out in the wild.
03:37:46.336 - 03:38:41.410, Speaker B: And in order to write maintainable code, this is normally how you would want to do it. You can encapsulate different pieces of information and then in turn implement functionality within those pieces quite easily. If we were to implement all the functionality just on a shipping box, things can start to become complicated later on. But if we do it this way, where everything is a small piece, where we have small color, small dimensions, and then our box, everything composes together nicely and is isolated. So later on, when you want to make changes to, let's say, the color, all you need to do is just change information here and the rest of your program, you can just ignore it, because everything's encapsulated in this thing as same thing with dimensions. So all of our dimension information is handled right here. We don't got to worry about the shipping box, and we don't have to worry about the color either.
03:38:41.410 - 03:39:19.704, Speaker B: And of course, the same thing with the shipping box. All the shipping box information is here and here. So we don't need to worry about our colors, we don't need to worry about our dimensions. All we need to know is we can access our color dot print and our dimensions dot print, and that's the only thing that actually goes outside of the shipping box itself. And this is just a good practice for code organization. Just break everything up into really small pieces and then compose it all together into one working program. This concludes the activity video.
03:39:19.704 - 03:39:56.150, Speaker B: I'll see you in the next presentation. In this data structures video, I'll be talking about vectors. A vector is a data structure that allows you to store multiple pieces of data. The data must be of the same type. So you can store numbers, you can store strings, you can store an enumeration or structure that you make in your program. They're used for lists of information. So if you have, for example, a grocery list, you can store a list of all your groceries within a vector.
03:39:56.150 - 03:40:37.484, Speaker B: Vectors allow data to be added and removed, and you can also easily traverse the entries of a vector to work with the data. Here's an example. We are creating a vector called mynumbers by utilizing the vec macro. When you use the vec macro, you surround the items you wish to add into the vector with square braces followed by the data you wish to add to the vector. Remember that the data must all be of the same type. So here we have all numbers. Alternatively, you can create a mutable variable, name it whatever you wish, and then use vec new.
03:40:37.484 - 03:41:24.658, Speaker B: So you use the new function that's implemented onto the vec struct with the double colons to determine the function that we're calling, which is new. You can then call the variable name dot push to add a new item to the vector, so you're pushing additional data onto the vector. Here we push one, two, and three to create the same vector as the vec macro created initially. We can also call the pop method on the vector. The pop method just removes the last item we added. So in this case, pop will remove this three from the vector. The len function is short for length, and it will return the number of items within the vector.
03:41:24.658 - 03:42:01.540, Speaker B: So we have one, two, three items. We remove the last item with the pop function, so the len will return two, because there's only two items remaining. After we remove the third from the pop function. We can also access an item from the vector using slice notation. So when we have these square braces around an index number, we're slicing into the vector. Vector indexes start at zero. So this is index zero, index one, and index two.
03:42:01.540 - 03:42:45.492, Speaker B: When we have my numbers and we slice to index one, we will get the number two, since this is at index one. If you recall, macros in rust expand to actual rust code. So this Vec macro will expand to something similar to this. So if you just want to make a vector with some values in it or any type of data, you can just use the Vec macro if you like. You can manually type out everything needed to create the vector. But the VEc macro is usually more convenient if you just want to create a vector with some information. Let's take a look at an example of iterating through the elements of a vector.
03:42:45.492 - 03:43:22.270, Speaker B: So here we're creating a new vector called my numbers. It has three elements, so each one of these is called an element. We have the one, two and three for our elements. You can also refer to them as items. Next, we have a for in construct. So a foreign is essentially a loop that is specific for collections. This could be read as for some variable in the collection my numbers, we want to perform some action that's in between these curly braces.
03:43:22.270 - 03:44:08.690, Speaker B: So the block of code in here will get executed on every single element in the vector. Before and in keywords are required in order to perform this action. So this whole thing can be read as for each number inside my numbers collection, we want to do a print line with the number and so on. The first iteration number will refer to one and then two and then finally three. So print line will be called three times to print out each number. To recap, vectors contain multiple pieces of similar data. Data can be added or removed from vectors easily.
03:44:08.690 - 03:45:01.840, Speaker B: The VEC macro can be used to easily make vectors in your code use for in to iterate through items in a vector. In this demo, I'll be showing you how vectors can be used to organize similar data within your code. I'll be creating a program that tracks test scores. So to get started, I'll create a struct and I'll just call it test and we'll have a score and we'll set it to be a 32 bit integer. I will then create a vector so my scores and that's going to be a vector. We're going to add some scores to this vector, so we'll have a test score. We will use a percent scale.
03:45:01.840 - 03:45:46.848, Speaker B: So we'll have 90 and we'll add a couple more. Have an 88, a 77 and a 93. So there's our test scores. If I want to display each score, I can use the four in keywords to go through each test score and display it. So I'm going to type for each test in my scores, I'm going to call the print line macro and I'll say score equals the test score. With for loops, you can name this variable. Anything you'd like.
03:45:46.848 - 03:46:35.546, Speaker B: Usually something descriptive is best. As with all other variables, this must be a collection. Our collection in this case is a vector and it consists of four items or four elements. Within the for loop we have a printline macro that's going to print out the test score. We know that tests is a type of test because we created it here and we know that the test has a field called score as shown here. And so if we print and run this program, we should see the four scores listed out in the same exact order as we indicated in the code. Vectors always maintain the same order, so they should print out 90, 88, 77 and 93.
03:46:35.546 - 03:47:04.280, Speaker B: Let's give it a go. And as we can see, we have 90, 88, 77 and 93. This concludes the demo on vectors. I'll see you in the next presentation. In this video we'll be creating a program that works with vectors. Vectors are useful for storing similar items in a list. Once you're ready, open up visual studio code and we'll get started.
03:47:04.280 - 03:47:40.730, Speaker B: Navigate to your activities directory. We are on activity 13, so double click on a 13. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insight to the activity topic. As we can see with this topic, we are working with vectors. Our program requirements indicate that we should print out 1020, the word 30 and then 40 from a loop.
03:47:40.730 - 03:48:17.136, Speaker B: We also need to print out the total number of elements that are in a vector. Our notes indicate that we should use a vector to store four numbers. We should iterate through the vector. Using a four in loop, we should determine whether to print the number or print out 30 inside the loop. Finally, we should use the len function to print out the number of elements that are in the vector. To get started, I'm going to copy in the notes into the main function. So our first note indicates that we need to use a vector to store four numbers.
03:48:17.136 - 03:48:54.250, Speaker B: I'm going to call my vector mynumbers. I'll use the vec macro since it's easy to use, and I'll put in the numbers. Now, even though the requirements state that we need to print out the word 30, we're not able to store that within this vector because vectors can only have a single type. In this case, the vector has a integer type since I'm using numbers. So if I tried to put this 30 as a string right here, it wouldn't work. So we're going to have to check that using match or using if else. Next, we need to iterate through the vector using a for in loop.
03:48:54.250 - 03:49:33.280, Speaker B: So the for in loop is constructed using the keyword for a variable. Name the keyword in and then the name of the collection to iterate through. So this is read as for a number in the collection, my numbers do something. So for each thing inside this thing, do some stuff within this loop, we need to determine whether to print the number or print 30. I'm going to use a match block for this. So I'll match on the number. If the number is 30, I'm going to do a print line and we'll print out the word 30 per the requirements.
03:49:33.280 - 03:50:13.158, Speaker B: If the number is anything else, we're just going to print out the number. So this particular bit of code will work for any numbers, not just the 1020 and 40 that we need. Since we're only putting in 1020, 30 and 40 in our vector, it will satisfy the requirements though. Lastly, we need to use the dot len function to print the number of elements in a vector. To do that, I'm just going to use the print line macro with a helpful message. Number of elements. I'll use the debug token and we'll have my numbers dot lena to get the length of the vector.
03:50:13.158 - 03:50:43.420, Speaker B: The length of the vector contains the number of elements. So here we have 1234. So this will be four when the code executes and it'll be placed here. And the message printed will be number of elements equals four. Before we try running this program, let's step through it from the beginning. We're creating a vector called mynumbers using the Vec macro. Alternatively, you can use vector new and then push each element one at a time.
03:50:43.420 - 03:51:04.240, Speaker B: However, the vector macro is very convenient. So we're placing 1020 and 30 into that vector. We're then iterating through each element within the vector. So for each element we're giving it a name called num. Inside my numbers. We're going to execute this code here. We then have a match block.
03:51:04.240 - 03:51:18.898, Speaker B: So we match on number. On the first iteration it's ten. We then check is it 30? Nope. So it's just going to print it out because this is catches everything. On the next iteration it'll be 20. So it's not 30, it's something else. Print it out.
03:51:18.898 - 03:51:40.440, Speaker B: It'll then be 30. This matches, so we'll print out 30. Next 40 will get checked. It's not 30, it's something else. We will print it out. Finally, after all that's done, this for loop will terminate. Move on to the next line which will just print out the number of elements and the len will be four.
03:51:40.440 - 03:52:30.020, Speaker B: Since we have four elements that'll go there and it'll print out. If you tried implementing it the same way I did with the for loop, followed by the length of the vector, you may have run into a compiler error. And the reason for that is when you create a for loop, you're transferring ownership of the information. So initially my numbers is owned by the main function. When you create a for loop, you're transferring the ownership here into this for loop. What that means is the for loop will execute and then after all the elements have been iterated through the for loop ends. We can see here, once the for loop gets here, after it's been through all the elements, the my numbers will get dropped because the for loop owns my numbers now.
03:52:30.020 - 03:53:03.950, Speaker B: At that point my numbers is no longer available and if you try to get the length, it won't work because it was dropped by this for loop. Let's take a look at the compiler error. So we try to run it and we get a compiler error. The error indicates that we are trying to borrow a moved value. Here we see that the my numbers was moved into this loop and then we tried to use it later on to fix this. We're simply just going to borrow my numbers instead. So we use an ampersand to borrow.
03:53:03.950 - 03:53:35.230, Speaker B: Now this for loop is simply borrowing my numbers. The owner is still the main function. The for loop is just borrowing it really quick and then giving it back. And then my numbers will be able to print since it's still owned by the main function and won't get destroyed until we get the end down here. So let's run it one more time and see if it works. And there we go. We have our 1020, the word 30 40, and the number of elements printed out.
03:53:35.230 - 03:54:06.910, Speaker B: This concludes the activity on vectors. I'll see you in the next presentation. In this video I'm going to be explaining string types. Strings are used to store text information such as names and words. There are multiple types of string available in rust, and the two types that are most commonly used are the string type with the capital s. The string type is an owned data type. That'll be an important distinction in a moment.
03:54:06.910 - 03:54:39.910, Speaker B: We then have the reference to str. This is a borrowed string slice. You can say this as a string slice. If you want to store a string data in a struct, you must use an own string. You can't store a slice in a struct, at least not yet. When you want to give string data to a function, you want to use a string slice because it is more efficient to do so. Let's first take a look at an example of how to pass string data to a function.
03:54:39.910 - 03:55:23.862, Speaker B: Here we have a function named printit, and it accepts a string slice as some data, and it simply prints out the data using the println debug token. We call this printit function using a string slice. If you'll notice, we have the double quotes and the words a string slice between the double quotes. By default, when you create a string in this way, it's automatically borrowed. That's why we're able to use the printit function with the data type string slice, because when it's borrowed, it is a string slice. If we want to create an own string, we can do so in multiple different ways. I have two listed here.
03:55:23.862 - 03:56:21.112, Speaker B: First, we have the own string as a string slice. We then call the dot to own function on it that creates a owned string. Another way to do so is type in string and then call the from function that's implemented on the string data type and then enter in your string slice and it will create an owned string. To then use the own string with this function, we have to borrow it because as you can see, the string slice is borrowed data as indicated by the ampersand. So when we borrow this own string in both of these scenarios, it will call the function properly because it expects borrowed data. Here's an example of a struct and we're attempting to store a string slice within the struct. As just mentioned, when you create a string in this manner, it's automatically borrowed.
03:56:21.112 - 03:57:16.892, Speaker B: If we try to store borrowed data in a structure, it won't compile, and the reason is, when this structure is to be dropped at the end of the scope, the structure is responsible for cleaning up its own memory. However, since we have borrowed memory here, the structure is not allowed to clean it up because it doesn't own this data. So it results in a compiler error and it'll inform you that you cannot store a string slice in this manner. If we take a look at how to fix this, all we need to do is change the type from a string slice to a string with a capital s. To save the string data within the structure. We can use either the toown function on a string slice or the string from function on a string slice that will create owned data and then the own data is transferred into the employee structure. So the employee then owns this name.
03:57:16.892 - 03:58:06.160, Speaker B: And when this structure eventually gets dropped and near the end of the program or wherever it happens to be dropped, it will be allowed to clear this memory and therefore the compile will succeed. To recap, strings are automatically borrowed use to owned or string from. To create an owned copy of a string slice, use an owned string when you're storing string data in a struct. In this demo, I'll be covering usage of strings and string slices. So here we have a struct called line item. It represents a line item on a receipt. Each line item has a name which is a string, and a count which is the number of items purchased for that particular item.
03:58:06.160 - 03:58:39.672, Speaker B: I'm going to enter into the main function and create my receipt. I'm going to create a vector using the vec macro. Within the vec macro, I'm going to create my line items. So the first one will be a serial and I use the dot to owned function. In order to create owned data for the serial, we'll have one and I'm going to create a another line item. This one can be a fruit. I'll use the string from function for this one and we'll have three fruits.
03:58:39.672 - 03:59:29.374, Speaker B: So here we can see that the line item takes a string and to create a string we can use toown or we can use string from on these string slices. If we were to try to create the line item and not include this part here and just send in a string slice, we would get a compiler error because the line item requires an own string and it requires an own string. That way when the line item gets deleted, it has permission to drop all the data. Next, I'm just going to iterate through each item using a for loop. So for item and receipt, I'm just going to print out some information about the item. So we'll have the item name and we'll also print out the count for the item. We can reference the name and the count.
03:59:29.374 - 04:00:13.398, Speaker B: So if we were to run this program, we would get the items. Here we have a cereal and there's only one fruit and we have three. And that corresponds to our cereal there's one, and our fruit there is three. I'm now going to create a function that prints out a string slice and I'm going to use it to print the name of the line item. So I'll name the function print name. It will accept a name which is a string slice. We don't return anything, so we're just printing information out and then call the print line macro and I will supply the name as a debug token down here in my loop.
04:00:13.398 - 04:00:50.712, Speaker B: I'm going to call that function name with the item name. And then now the count can just be by itself. Now, if you recall, the structure has a string data type as the name. This is an owned string. However, this function requires a borrowed string slice because it's borrowed because we see the ampersand. So in order to use this function properly, we can't just send in the item name because that is a string. So instead we simply need to borrow the name field like that.
04:00:50.712 - 04:01:16.086, Speaker B: And so now we're borrowing this field here, the name field, and that is going to create a string slice from this string. Now, if we run the program, everything should work as expected. We have the serial one, fruit three. We'll do a walkthrough. We're creating a receipt which is a vector. It has two line items. The first one is serial.
04:01:16.086 - 04:01:48.878, Speaker B: We use toown to create owned data because we require an own string. We set the count to one. We have a second line item. I'm using the string from function on this string slice called fruit because we need a known string just as before. That's set to three. We then iterate through each item on the receipt. So for every item that's in the receipt, we're calling the print name function and we're borrowing the name field that then comes up here as a string slice.
04:01:48.878 - 04:02:13.300, Speaker B: We can see it's borrowed. It then prints it out using the debug token. And it also has a print line on the count field of the line item, which is here is just an I 32. It then repeats for each item in the lists. We have two items, so it'll print two times and then our program will end. This concludes the demo on strings. I'll see you in the next presentation.
04:02:13.300 - 04:02:53.460, Speaker B: In this activity, we're going to be creating a program that works with strings and string slices. Once you're ready, open up visual studio code and we'll get started. Once visual studio code loads, navigate to your activities directory. We are on Activity 14, so double click on a 14. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic.
04:02:53.460 - 04:03:23.760, Speaker B: All right, let's go ahead and get started. As we can see, our topic is about strings. Our requirements are to print out the name and favorite colors of people age ten and under. Our notes indicate that we need to use a struct to store the person's age, name and favorite color. The color and name should be stored as a string. We need to create at least three people. We need to iterate through the people using a for in loop.
04:03:23.760 - 04:03:55.116, Speaker B: We need to use an if expression to determine which person's info should be printed. So people age ten and under the name and colors should also be printed just using a function. To get started, I'm going to copy the notes down here a little. Our first note indicates we need to use a struct for a person's age, name and favorite color. So I'm going to use the struct keyword. I'll name the structure person. They're going to have a name which has to be an owned string.
04:03:55.116 - 04:04:15.390, Speaker B: They're going to have a favorite color that's also going to be a string and their age. And I'll use a 32 bit integer. Next, we need to create and store at least three people in a vector. That can be done. In the main function. I will create a vector named people. I'll use the vec macro to do so.
04:04:15.390 - 04:04:56.138, Speaker B: Within the vec macro we can create the people that we need. So I'm going to create my first person. I'm going to use the from implementation on the string structure and create a person called George. Their favorite color is going to be green and their age will be seven. I can then copy this and create another person. So this can, this person can be Anna, her favorite color, and be purple and she is nine years old. And lastly, we should have somebody who's over the age of ten.
04:04:56.138 - 04:05:20.810, Speaker B: That way they don't show up when we run our loop. This person can be named Katie. Her favorite color is, is blue and she is 14 years old. Next, we need to iterate through the vector using a for in loop. So we use the four keyword, create a variable name. I'll use the name person. We use the keyword in and then people.
04:05:20.810 - 04:06:08.146, Speaker B: So this is read as for each person in a collection of people. Do something here that's something is to use an if expression to determine which person's info should be printed. I'm going to split the view so we can see all the code. So we need to check if a person's age is at least ten years old or younger. So here in the person struct we have an age field that we can check if we type if person age to access that field less than or equal to ten. Then here we're going to print out their name and their favorite color. To do so, we need to use a function.
04:06:08.146 - 04:06:46.930, Speaker B: So I'll write a function here. I'm just going to call it print. It's going to accept just any data, and that data will be a string slice. Nothing needs to be returned since it's just printing out information. I'll use the print line macro with the debug token to print out the data. We can then utilize this function here by calling the print function with a person dot name and a person dot save color. Notice here in our person struct we have owned strings for the name and favorite color.
04:06:46.930 - 04:07:29.680, Speaker B: Our print function, however, takes a string slice which is borrowed as we can see, since there is an ampersand symbol. So in order to properly call this function, we need to borrow their favorite color and borrow the name. So now that we've borrowed the strings, they will get turned into string slices and our print function will work properly. This should satisfy all the requirements of the program. So I'm going to walk through it and then we'll run it and see if it executes as expected. So first we have a variable called people, which is a collection. Specifically, it's a vector being created by the Vec macro.
04:07:29.680 - 04:08:11.588, Speaker B: It contains three people as defined by the person struct. Each person has a name, a favorite color, and an age. I'm using the from implementation on string to transform a string slice into an owned string. This is being done three times for each person. After that's completed, we iterate through each person using the for in loop or each person in the people collection. We perform the action in this block. We then check if that person's age happens to be less than or equal to ten.
04:08:11.588 - 04:08:54.020, Speaker B: Then we're going to print out their name and their favorite color. The print function is defined over here, and it accepts a string slice which is borrowed data as seen by the ampersand. Our structure has owned data, so in order we have to borrow each field in order to properly use the function so we can borrow individual fields, we're borrowing name and favorite color. Those are both going over here to the print function and where they will be printed. Once those are printed and we iterate through every single person listed here. So this loop will be called three times. Once that's done, we'll exit the program.
04:08:54.020 - 04:09:25.442, Speaker B: Let's go ahead and run it and see what happens. To run this program, I'm going to go to terminal, new terminal. I'll type in bargo, run dash q dash dash bin. We are on activity 14, so type in a 14. I'm going to scroll a bit so we can see our data here. Looking at our data, it looks like George and green should be printed and then Anna and purple should be printed. Katie is 14 years old, so her information should not be printed.
04:09:25.442 - 04:10:06.270, Speaker B: Let's run it and see what we get. As you can see, we have George and green printed and then anna and purple printed. This concludes the activity on strings and string slices. I'll see you in the next presentation. In this demo I'll be showing you how functionality can be automatically implemented for your enumerations and structures by using what is called a derive macro. Thus far in the lessons, if we wanted to print out this enumeration, what we would need to do is match. On each possibility we have manager, supervisors, worker.
04:10:06.270 - 04:10:45.302, Speaker B: Then we would print line some information about that variant. There is an easier way, however, to do that automatically. What we can do is derive functionality for printing out information. To do so, we enter a pound sign followed by square braces and then the word derive. Then put some parentheses and we type in debug. So derive is a special macro that is applied to enums and structs. It allows you to automatically implement some sort of functionality.
04:10:45.302 - 04:11:26.060, Speaker B: In this case we're implementing debug printing functionality. Now that we have derived that functionality on position, we can delete this entire block of code and then just print out the position directly. We use the debug print token. I'll put me dot position for the employees position. We can run the program and we'll see that position worker will get printed. Now we can see that worker has been printed because we set the position to a worker. We can also use this derive functionality on the employee struct.
04:11:26.060 - 04:12:13.386, Speaker B: This will allow us to imprint the entire employee structure. So if we just want to print out all the information about that employee, we can do so by deriving debug on the employee and then just printing out the variable for employee directly. Let's give it a go. Now we can see we have an employee with their information. We have the position which is a worker and the work hours, which is 41. Important note, when you're deriving functionality this way, all fields within the structor enumeration also have to derive that functionality. So if I was to delete this functionality from position, I will get a compiler error because the debug implementation does not exist anymore.
04:12:13.386 - 04:12:44.940, Speaker B: On position, let's see what happens. Here. We see that it says the position cannot be formatted using the debug token, and it also gives you some help saying that we can add derived debug onto our enum. So let's add it back. And now if we run the program again, it'll happily print. There are two more derives that are extremely useful for your programs. They are called clone and copy.
04:12:44.940 - 04:13:42.542, Speaker B: When you apply the clone and copy derives to a piece of data such as this enumeration, it informs the compiler that it is allowed to automatically make a copy when you're storing it into a struct or a function. What this means is ownership is no longer transferred. When you move the position enumeration into a function structure, a copy is made instead. So whenever a move would normally occur where the ownership would change, ownership no longer changes because a copy is made and now you have two copies of the data instead of just one. Just as with the debug derive, if you set, clone and copy to this employee structure, and if you didn't set it to the position structure, you would get a compilation error because employee has position within it. In our case, clone and copy is set onto both. I'm going to demonstrate how it automatically copies.
04:13:42.542 - 04:14:28.870, Speaker B: Now to do so, I'm just going to create a function, I'll just call it printemployee. It's going to accept an employee, it won't return anything, and it's just going to do a print line with the employee. Notice that we don't have an ampersand here, so we're not borrowing this function takes ownership of an employee. Now if I call this function and I put the me variable in there and call it twice, what will happen is this me variable. It won't change ownership when print employee is called. Instead, a new copy will be made and placed here. So this will be a copy and this original one still exists.
04:14:28.870 - 04:15:18.866, Speaker B: Then when printemploy is called again, we get a second copy, that'll be another copy, and then printemploy will again run properly. Let's run it really quick so we can see it working. And as we can see, we have it print twice because there was two copies created. If we were to remove this clone and copy derive from the employee struct. Then we'll get a compiler error because ownership will change from the main function to the printemploy function when we first call with the me variable. As we can see, the value was moved into printemploy the first time we tried to use it again with the same value, but it's already been moved into this function because ownership has changed. One last note.
04:15:18.866 - 04:16:04.130, Speaker B: If you're automatically deriving clone and copy is to only apply that to structures which are small in size. So usually you would only have maybe four or five entries in your struct. If you start to have a lot of data in your struct, you don't want to automatically derive those because then you'll make expensive copies throughout your program and you won't realize it because it happens automatically. This concludes the demo on deriving functionality. I'll see you in the next presentation. In this video I'll be going over some additional information about type annotations. As you know, type annotations are required in function signatures.
04:16:04.130 - 04:16:29.568, Speaker B: Usually types are inferred by the rust compiler. However, you are able to specify types in certain locations. When you do so. This is called explicit type annotation. Here's an example. At the top we have a function which has type annotations. This entire part is called the function signature, and within the signature we have two types.
04:16:29.568 - 04:17:12.060, Speaker B: We have a string slice and a 32 bit integer. Functions are always required that we specify the type using these type annotations. Next we have a mouse enumeration for use in the example down here. Next we have a let binding with a variable called num. We then use the type annotations that are familiar from function signatures to specify that num is a 32 bit integer. Normally we don't include this because the compiler is able to figure that out by looking at the data. It is useful, however, if you want to be sure that this is always an I 32.
04:17:12.060 - 04:17:57.510, Speaker B: If you were to set this number to a value that is too large to fit within an I 32, then you would get a compiler error. Next we have the variable a. It's being set to the character type, and here we have a character. Just as with the numbers, if you were to type a string here instead of a character, you would then get a compiler error because you told the compiler that hey, I, this is supposed to be a character. Lastly, we have the left click variable. We're telling the compiler that it is a mouse type which is here in enumeration and we're just setting it to the left click variant of the mouse type. Again, this part is optional.
04:17:57.510 - 04:19:02.624, Speaker B: There are some instances where it is required when that happens, that usually means the rust compiler was unable to figure out the type of for your variable, and the error message will indicate to you that it could not figure this out and you should provide a type when that happens. That's when you'll need to specify the type annotation. Here's an example using generics so a vector is what is called a generic data type. It's a data type that contains other types, and it can contain any other type. Normally when you're making a vector, you can just use the macro as such and specify the information within, and the compiler can figure out that it's a vector of I 32s. If, however, you want to store a vector in a structure, you will then need to know how to specify the signature. When creating a vector, you can specify the type of items within the vector using the less than and greater than symbols in the letters variable.
04:19:02.624 - 04:19:43.862, Speaker B: We're creating a vector of character, and as we can see, we have our characters here. And then for the clicks variable we are creating a vector of mouse, which is the enumeration we saw on the previous slide. We have three elements of type mouse, a left click, a left click, and then a right click again. The compiler is able to figure this out most of the time. Occasionally it needs some help, so you would need to specify it. It is required, though, to specify the exact type when using a structure to recap type annotations are mostly optional within function bodies. Occasionally they are required if the compiler cannot infer the type.
04:19:43.862 - 04:20:36.640, Speaker B: When this happens, the compiler will inform you that it was unable to infer the type, and you'll have to manually specify using type annotations. You can also optionally specify type annotations when using let bindings. However, it's usually easier to just let the compiler figure it out. In this video we'll be taking a look at the enum again, and I'll be explaining an additional property of enumerations that helps working with data and managing your code much easier as a quick review, an enumeration is a type that can represent one item at a time, and each item is called a variant. However, enum is not limited to just plain variants. Each variant within the enum can optionally contain additional data. Let's take a look at an example.
04:20:36.640 - 04:20:59.312, Speaker B: Here we have a new enumeration called Mouse. We have a left click, right click, and middle click. These should look familiar. They're just a single identifier, nothing special. Now let's take a look at Scroll. Scroll has additional data associated with it. You can associate additional data by using parentheses and then a data type.
04:20:59.312 - 04:21:46.210, Speaker B: In this case, scroll would represent the mouse wheel scrolling, and the 32 bit integer would represent how much and which direction the mouse wheel scrolled. So we have up and down, that would be positive numbers, maybe plus one or two, and then that would be up, and then down could be minus one, minus two, and that could be represented by this 32 bit integer. Next we have the move variant. It has two pieces of data associated with it. The first one could represent the x position of the mouse, and the second one could represent the y position. That way we would know exactly where the mouse is on the screen when the mouse move occurred. Here's another example.
04:21:46.210 - 04:22:17.120, Speaker B: We have two enums in this case. Our first one is a promo discount, so we can have a new user discount and a holiday discount. The holiday discount has some associated data. The string could represent the holiday name or some other special instruction for the holiday. Next we have a discount enum. This has a percent discount with f 64 as the data associated with that variant. This could be the percentage discount to give.
04:22:17.120 - 04:22:53.110, Speaker B: We have a flat discount. Maybe this is just a flat dollar amount to remove off a purchase price. We then have the promo discount, which is just named promo. And we have another enum being referenced within this variant. So this promo references this promo discount enum. So as you can see, we can have enumerations within enumerations. Lastly, we have a custom discount with a string, and this one would be special instructions to the cashier on what kind of discount should be applied in that particular scenario.
04:22:53.110 - 04:23:42.720, Speaker B: One thing to remember with enumerations is whenever you have data associated with a variant, it has to be actually there, so you can't just have percent and then nothing. So there's always going to be a value with this percent, whether it's zero, one, or whatever. Same thing with the promo and the promo discount. Whenever you create a promo variant of discount, you also have to specify the promo discount. So you're going to have to pick new user or holiday. If you pick holiday, you're also going to have to provide a string with instructions or the name of the holiday that applies for all enumerations that have additional data on the variance. The additional data is absolutely required when you're creating the variant.
04:23:42.720 - 04:24:30.930, Speaker B: To recap, enum variants can optionally contain data. The data for the variant can also be another enum it's possible to mix plane identifiers and variants that contain data within the same enum. More than one piece of data can be associated with a variant. In this demo, I'll be showing you some examples of advanced match functionality. This functionality will allow you to match on data associated with enums as well as structures. Before getting started here we have an enumeration and a struct. The enumeration just represents a discount, and we can have a percent discount and a flat discount.
04:24:30.930 - 04:25:07.830, Speaker B: The struct represents an event ticket. We have an event which is a string, and that's the name of the event, and we have the price of the ticket as an I 32. To start off, I'm going to create a new number. I'll match on the number. And previously we would do something like this where we can just print out something if three matches, and anything else, we would just kind of print out number and n. This is what we've been doing. We're matching on n.
04:25:07.830 - 04:25:46.240, Speaker B: If n is equal to three, we print out three. If it's anything else, we'll just print out the number. And we're using the n variable, which was here, here, and here. Normally in rust, when you have the underscore, that means ignore the information. So we want three and we want to ignore everything else. We can, however, see that we care about the number because we print it out here, and referring to it in this manner is not the best way to go about it. Instead, what we can do is change it from underscore and give it a name.
04:25:46.240 - 04:26:16.896, Speaker B: In this case, I'll just name it other. And now we can refer to other within this expression, so it reads just like it did before. If it's three, we'll print line the word three. If it's something else, we'll give it a variable name, and then that variable name will be accessible within this match arm. This is just a way to make your code more clean and easier to read. Next, I'll create an enumeration that's a discount. I'll just do a flat discount.
04:26:16.896 - 04:26:53.050, Speaker B: That will be a discount with the flat variance. Then to specify how much I'm discounting, we use the parentheses and then the value of the discount. So the syntax looks exactly like the variants. We have the word flat parentheses, a value, close parentheses, same thing here. And that's how you create a variant with extra data. Now, when we want to match on enumerations that have extra data on their variance, you do it as such. You type in the enumeration name, just as we have been doing, and then you type in the particular variance.
04:26:53.050 - 04:27:29.408, Speaker B: After that we have the parentheses and we have a few options here. We can use the underscore to ignore any value that happens to be there. We can match on a specific number, like two, so that'll match only if the discount is flat and it's two. Or we can give it a variable name, just as we did with the previous match expression. So I'm going to give it a variable name, I'm going to call it amount. And so now we can do whatever we would like to do with that. So I'll print out flat discount of and then have the amount.
04:27:29.408 - 04:28:35.356, Speaker B: So now when we have a flat discount, it will match. On this first one we match the enumeration name, the variance, the amount, which can be anything since we just have a variable name, and then this is accessible in the arm of the match expression and we can print it out as usual. I'm also going to match if the flat discount is two, and I'll just put a different print line statement. What happens here is we're matching on the flat variable and it has to be a discount. If it is a flat discount with a value of two, we will use this arm here, and if it's not two, if it's something else, then we're going to use this one here. The same rules apply as if you're just matching a number. So if we were just to remove that match arm completely and only match on two, we will get a compiler error indicating that we need to also match on every other possible flat value, because it only matches two and there's nothing else to match it.
04:28:35.356 - 04:29:01.846, Speaker B: So I'll put that back. We can then ignore everything else. So in this case, when we're matching, we're only matching on flat discounts. The percentage discount is being completely ignored by this code. The underscore just means we're ignoring it. You can also use a set of parentheses to just mean that you're returning nothing. All these print line macros, they have the same scenario, they return nothing just like that.
04:29:01.846 - 04:29:34.670, Speaker B: It's just implicitly done and you don't really see it. So if we compile and run this program, it should print out the word three and flat two, because we have n three match on the n, it's a three and we have a flat discount with a value of two. Flat discount, value of two. That'll execute. I'm going to run it really quick just to confirm that it works. And there we go, the word three printed and then flat two. Finally, I'm going to show you how to match on a struct.
04:29:34.670 - 04:30:00.620, Speaker B: It's similar to matching on an enumeration that has data with their variance. So I'll create a new struct. We'll make a concert ticket. So remember, when you're making strings in this manner, it's a string slice, but our struct needs an owned string. So all we need to do is type in to owned. Now we can store it in our struct. We'll set the price to 50.
04:30:00.620 - 04:30:41.680, Speaker B: I'll then create the match block. I'll match on the concert ticket. So to match on structures, we use the name of the structure just as we do with enumerations. We then use curly braces. So this is telling rust, hey, we're matching on a structure, I'm going to match on the price of the structure. So I'll do price, and I'm not concerned what the event name is, I just want to know the price. So if you want to ignore everything else in a structure, you use two dots, and then we do print line, and I'm just going to print out of price equals, and then I will have the price.
04:30:41.680 - 04:31:18.120, Speaker B: What this is telling the compiler is we're matching on a ticket and we're concerned with the price and nothing else. So the two dots just mean any other fields ignore them. We can also match on a specific price. So if we do price 50, then what would happen is it'll match only when the price is 50. In this case, I'll also get the events name. And so we already know the price is 50. So this will just be events at 50, and that will be equal to that.
04:31:18.120 - 04:31:52.712, Speaker B: Now we're matching any ticket that's $50. We're going to get the name of the event and print it out that the event is dollar 50. And here's the event name. And then if it's not $50, then this will get executed, we'll get the price, whatever it may be, and then print out the price. And here we can see we're ignoring the event name. So in that case, we don't care about the event name. So if we were to run this again, we will see that the previous information will print, and we'll get event at 50 equals event name printed.
04:31:52.712 - 04:32:26.256, Speaker B: In addition, as we can see it printed out, and it is a concert ticket that covers it for this demo. I'll see you in the next presentation. In this activity, we'll be creating a program that utilizes advanced match functionality. Once you're ready. Let's hop into visual studio code and get started. After visual studio code loads, double click on activity 15. Once the activity file loads, review the topic and program requirements.
04:32:26.256 - 04:33:02.780, Speaker B: Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Alright, let's get started. This activity topic is about advanced match functionality. The requirements are to print out a list of tickets and their information for an event. The tickets can either be backstage, vip or standard. Backstage and vip tickets include the ticket holder's name and all the tickets include the price.
04:33:02.780 - 04:33:46.232, Speaker B: In our notes we can see that we need to use an enum for the tickets and there needs to be data associated with each variance. We need to create one of each ticket and place into a vector, and then we need to use a match expression while iterating the vector to print out the ticket info. I'll start by copying some of the notes into the program space. We need to use an enum for the tickets. So I'll call my enum ticket and we need to have backstage, vip and standard tickets. The first variants I'll just use standard. Next we'll have backstage, and last we'll have vip.
04:33:46.232 - 04:34:38.580, Speaker B: It's a good practice to order these alphabetically, so I'm just going to switch up the order and put backstage first. Next we need to include the ticket holder's name for both backstage and VIP tickets. To do so, I will use a string data type as data that's associated with that particular ticket. So we'll do that for the backstage and for the VIP ticket. We also see a node that indicates all the tickets include the price. For the price I will use an f 64, which is a 64 bit floating point number, and floating point just means you can have a decimal point. So we'll add that to each variant to account for the price.
04:34:38.580 - 04:35:16.720, Speaker B: Seeing as all of these include a price, it would be a good idea to have the price first and then any additional information can come second. So I'm going to change this to have the f 64 first and then the string second. Next we need to create one of each ticket and place into a vector. I'm going to create the tickets within the vector itself. So I'll create a new vector, I'll call it tickets. I'm going to use the Vec macro, and within that vec macro I'm going to create new tickets. So the first one will be a backstage ticket.
04:35:16.720 - 04:35:54.552, Speaker B: Remember, to access enum variants, you use the double colons to access this section. Backstage includes an f 64 for the price and the ticket holder's name. So for backstage ticket we'll say it's $50 and the person's name will be Billy. Remember, we have to have a own string in our enumeration. This by default is a string slice. And if we use dot to owned we'll create an owned string that's suitable for our purposes. Does it for our backstage ticket.
04:35:54.552 - 04:36:35.498, Speaker B: I'll then create a standard ticket and a standard ticket will be $15. And lastly I'll create a VIP ticket which can be $30 and this ticket holder's name will be Amy. We now have our vector of tickets created. Next we need to use a match expression while iterating the vector to print the ticket info. To iterate the vector we use the for in keywords. So for ticket that could be any variable name in our vector which is tickets. We're going to do something as a review we have for each thing inside a collection.
04:36:35.498 - 04:37:16.990, Speaker B: So the collection is tickets and each thing are these individual tickets. Here the for in construct will execute this code operating on the ticket which will be one of these on each iteration of the loop. Now we need to match on our ticket in order to print it out. So first we'll match on backstage tickets. Here we need to make sure we include variable names to capture the information on a backstage ticket. So a backstage ticket has an f 64 for the price and a string for the ticket holder. The price I can just use the variable name, price and ticket holder.
04:37:16.990 - 04:37:56.536, Speaker B: I'll just use the variable name holder. We can then use the print line macro to print out information and we'll say holder and we'll use debug print and price. We can also use debug print and then we just use the variable names to refer to those print line tokens. So holder will go here, price will go here and we will print out the information needed. These holder and price variables come from here. So this price is here, the holder is there. We're going to do the same thing for standard and vip, so I'm just going to copy and paste.
04:37:56.536 - 04:38:47.912, Speaker B: Standard doesn't have the ticket holder's name, so it only has a price. So we'll print out just the price, we'll take out the reference to the holder variable. Lastly, we have the VIP which has price and holder. We also want to include which variant we're printing. So this is a VIP ticket and this will be backstage ticket and this one is a standard ticket as we can see our lines are getting a little bit long over here. I'm using an automatic formatting tool called rust format, and it'll format the code in a way to prevent the lines from extending too far off the side of the page. So once I save this program, it'll automatically format my code.
04:38:47.912 - 04:39:37.522, Speaker B: And here we see it changed this line to have curly braces instead of just being a single line. So as we can see, this one was not too long, so it left the line how it is, but this one and this one were a little bit long, so it changed it automatically for me. And as you can see, you can either have just a single expression here followed by commas, or you can have curly braces to create a scope which would allow you to do multiple things within a single match arm. In our case, we only need to do one thing, so we'll just leave the code as is. Before I run the program, let's take a walkthrough. We have our enumeration called Ticket. It has three variants, backstage, standard and vip.
04:39:37.522 - 04:40:14.820, Speaker B: The backstage variant has some data associated with it, an f 64 for price and a string for the ticket holder name. The standard ticket has a price associated with it. The VIP ticket has a price and a ticket holder name associated with it. Remember that any data associated with the enumeration must be filled in. You can't omit any data. So if you make a VIP ticket, you have to include a price and you have to include the ticket holder name. Here we have our main function and we're creating three tickets using the VeC macro.
04:40:14.820 - 04:40:50.030, Speaker B: We create a backstage ticket at $50 with the ticket holder named Billy. We then create a standard ticket at dollar 15, and lastly a VIP ticket with the holder named Amy. After that we iterate through all the tickets using the four in keywords. So tickets is here and that's a vector which is a collection. So we can iterate through it using for in this variable name is arbitrary. You can name it whatever you want, but it's always best to be descriptive. That way you can read it even more easily later.
04:40:50.030 - 04:41:21.284, Speaker B: We then perform a match expression on the ticket which is one of these enums. Here we have to check for each possibility. We have three here, one, two, three. We check for each one. To check for a variant, we type the name of the enumeration e two colons, and then the name of the variants. Since we have to account for data for this particular variant, we also have to include variable names. Here you can optionally use an underscore if you want to ignore a particular piece of data.
04:41:21.284 - 04:42:03.940, Speaker B: In our case, we want all the data, so we are going to give each one a variable name. We then use the fat arrow to indicate the beginning of the action we want to perform. Once this match arm is taken, we can use curly braces and list out multiple things to do within the curly braces. We only have one thing we're doing, which is printing out the ticket holder information and the fact that this is a backstage ticket. Next, we're matching on standard and vip, and the same rules apply to standard matching where you have to match on each variant. So we have the standard to match the VIP to match. Both have data associated with them and both simply print out the information.
04:42:03.940 - 04:42:46.322, Speaker B: I'm going to run this and we'll see what happens. To run it, go to terminal new terminal, type in cargo, run Q bin. We're on activity 15, so type in a 15 once it runs. We have a backstage ticket holder named Billy who paid $50. The standard ticket price is 15 with no name because we don't track the names of the ticket holders, and then a vip ticket with the ticket holder named Amy and a price of 30. All this information coincides properly with what we've specified in our program, and our program is complete. This is the end of the activity video.
04:42:46.322 - 04:43:27.830, Speaker B: I'll see you in the next presentation. In this video I'll be explaining how optional data is managed using the option type. The option type is a type that may be one of two things. It may be some data of a specified type, or it may be nothing. It's used in scenarios where data may not be required or is unavailable at the time. Some examples are you're unable to find something, you may have run out of items in a list, or you may have a structure with forms, and the forms aren't completely filled out. Before we dive into some examples, let's take a look at the definition of an option.
04:43:27.830 - 04:44:15.556, Speaker B: The option type is part of the rust programming library, and it is defined as an enumeration with two variants. The first variant is named sum, which represents sum data. The second variant is named none, which represents no data. This syntax here may be familiar. When we have worked with vectors, it simply states that option contains some type and we don't know what type it is. So we use capital t as a placeholder. So this just reads we have an enumeration named option and it contains some data, and it the data type is just some type of data and the t is just a placeholder that can be used in the variance and with the variance.
04:44:15.556 - 04:44:51.070, Speaker B: For some data we have associated information which is a t. The t is just whatever type that was specified when you wrote the program. Let's take a look at an example so we can see how this works. Here we have a structure named customer. They have an age and an email. The age is optional data and the data type, if they provide it, is a 32 bit integer and the email is simply a string. So this structure may be used if they submit for an email newsletter and they didn't provide their age.
04:44:51.070 - 04:45:40.644, Speaker B: For example, the first customer we have is named Mark and they did provide their age. As we can see, they provided their age as sum and then they have their age as 22. Normally with enumerations we have to use the two colons along with the name of the enumeration and the variant in order to actually use the variant. However, options are so commonly used in rust that the variants are exposed for usage directly without typing the word option each time. That's why we're able to just type in sum to represent the variance within the option. For Becky, she did not provide her age, so we place none as her age and this will represent no data for Becky's age. Both also have emails which must be provided.
04:45:40.644 - 04:46:22.910, Speaker B: As we can see, it's a string. We have our string slices and we change them into owned strings. To access data within an option, we can do so with a match expression. In this case, we're matching on Becky and we're checking her age using age. Both variants are accounted for, some and none, which are the variants available in an option. So in the case where they did provide an age, I created a variable named age and then if that occurs, we will print out the customer is blank years old as defined by the age. If no age is provided, no data, none, and we'll just print out the customer age not provided.
04:46:22.910 - 04:46:51.728, Speaker B: In Becky's case, she did not provide an age. So when her age is matched here, this will not be executed. We will then match on none and we'll print out that the customer age is not provided. Here's another example. We have a grocery item struct with a name and quantity. The name is simply a string and the quantity is an I 32. We then have the function named findquantity, which accepts the name of a grocery item as a string slice.
04:46:51.728 - 04:47:19.870, Speaker B: It then returns optional data. The optional data returned is a 32 bit integer which will represent the quantity of the item if we do find it at all. Within our function, we have some groceries made using a vector. We have three items. We have some bananas, eggs, and bread, and they each have a quantity. What we do in the function, we then check for a specific item as indicated by the name. We do so using the for loop.
04:47:19.870 - 04:48:11.706, Speaker B: So for each item in the groceries, if the name of the item is equal to the name that we provided here in the function, then we're going to return some data. So this would be optional data and it's returned as an I 32 since we have an I 32 as the function signature. Return value this word here is a rust keyword and it allows you to early return from a function. So far, we've just been implicitly returning at the end of functions and within our code. However, if you want to return early, you use the return keyword. I'm doing so in this case because if the user runs this function and they provide the name of bananas, we'll only need to go through this loop one time. So the first item will be bananas, we'll find it and then we'll return the quantity.
04:48:11.706 - 04:49:17.150, Speaker B: When we return, this function will just exit and we're done. Without this early return, I would have to go through every single grocery item, even though bananas was the very first one, and that's not very efficient. In the event that the user provides a name that's not in this grocery list, then we'll check each one, we'll discover that it wasn't found, so this will never be true, and then we'll just implicitly return none because we didn't find any grocery item with that name. Option is useful in this case because we'll find out if the grocery item is present at all in the list, and if so, we'll know how many of the quantity of that grocery item is present. To recap, option represents either sum data or nothing. Sum data is represented by the enum variant sum, and no data is represented by the enum variant of none. It's useful when you need to work with optional data such as form fields, and when you want to specify an optional data type within your struct or function, you use option and then the type name within the less than and greater than symbols.
04:49:17.150 - 04:49:56.142, Speaker B: In this demo, I'll be showing you how option can be used to make your code easier to read when working with optional data. The program I'm going to be creating will be a survey program, and it's going to simply print out the responses to a survey. Not all questions in the survey will have answers, so option is the perfect data type to use for the situation I'll start by creating a survey struct. And the survey will have multiple questions. Each one will have optional data. So first question will have numeric data. The second question will have Boolean data.
04:49:56.142 - 04:50:19.748, Speaker B: So this maybe is a checkbox. The first one's perhaps like an age or something. And the third question will have string data. So this might be a multiple choice question in our function. I'm going to create a new survey, I'll just call it response. It'll be a survey struct. The response for question one will be sum.
04:50:19.748 - 04:50:45.244, Speaker B: So they answered question one because we're using sum. Whenever we use sum, that means there's some data, there's something there and it'll just be twelve. Question two will also answer the question. So this can just be true. So maybe they check the box for they like the survey, they check the like survey box. Lastly, we'll have multiple choice and we'll just say that it is a. So they picked a.
04:50:45.244 - 04:51:27.268, Speaker B: So whatever happened, whatever a happens to be, that's what they picked. We're then going to match on each response in the survey. To do so, we use match expressions. So I'm going to match on question one and if there is some response I'll call it ans for answer. Then we'll just print it out. So question one and then we'll put the information and our variable name and if there's nothing, we're going to print out q one, no response and so let's just make sure this works fine before we continue. So let's run this and it looks like it works so far.
04:51:27.268 - 04:51:56.170, Speaker B: So we have twelve as our response, which as we can see is sum. So that's working just fine. Now all I'm going to do is just copy and paste this a few times and then we can have question two. And then for question three we'll do the same thing. Now that these are all set, we can run the program and see all the information. So here we have question one is twelve, two is true, and then three is a. Just as expected.
04:51:56.170 - 04:52:38.496, Speaker B: Now I'm going to change some of these values and then we'll follow the code each time I change it. That way we can see exactly how it's working with optional data. We'll start by looking at Q one. So we are creating a survey and q one has sum data and that data is twelve. When we match on q one, we will see that the sum variant will be selected because we have some data. The twelve will be populated into the answer variable and then we will print out the message q one and then the answer, which is twelve, and then for q two some data. Q two, same thing.
04:52:38.496 - 04:53:06.496, Speaker B: Q three, same thing because we have some data. So let's change this, let's say question one, let's assume they didn't answer it, so now they have no answer there. So on Q one we have none or nothing. So when we get to this first match block here on q one it's going to check is there some data? We have none. So no, there's not some data. So there's no data. It'll print out q one, no response.
04:53:06.496 - 04:53:41.270, Speaker B: Let's confirm that by running the program again. As we can see, we have q one, no response. If we then change q two and q three to none, we'll have the same effect because each match block is the same. So q two and q three, the none variant, will be hit and then we'll get no response. For everything we can mix and match these. So question two, let's do some false. And again, this may be like a checkbox and as we can see, q two is false.
04:53:41.270 - 04:54:13.854, Speaker B: This concludes the demo on optional data. I'll see you in the next presentation. In this activity we'll be creating a program that utilizes optional data. Once you're ready, load up visual studio code and we'll get started. Once visual studio code is loaded, go to your activities directory and double click on Activity 16. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused.
04:54:13.854 - 04:54:53.580, Speaker B: Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Okay, let's get started. This activity topic is on the option data type. The requirements are to print out the details of a student's locker assignment and that lockers use numbers and are optional for students. Our notes indicate that we need to use a struct containing the student's name and locker assignment, and the locker assignment should use an option containing an I 32 integer. I'll start by copying some notes into the program area. We need to use a struct containing the student's name and locker assignment.
04:54:53.580 - 04:55:29.920, Speaker B: Use the struct keyword to create a new structure. I'm just going to call it student and I'll put their name as a string and their locker as an option I 32. So since locker assignments are optional for students, it makes sense to use the option keyword because maybe they don't have a locker at all. And in that case we don't need to know the locker number. Next, I'm going to create a student and then print out the student's information. I'll just call the student Mary. I'll put her name as a string.
04:55:29.920 - 04:56:24.700, Speaker B: Remember to use two owns to create an own string. Since by default strings are slices and Mary's locker number will be number three. I will then print out Mary's information. So for her name I'll just do a print line statement and I'll say students and then we'll have Mary name and then we'll match on her locker number. So we'll match on Mary Locker and if she has a locker number we will call it num and we'll print out locker number that would be num and if she does not have a locker number, we will print out no locker assigned. Before running this program, let's get a walkthrough. We're creating a data structure named student.
04:56:24.700 - 04:57:01.926, Speaker B: The student consists of a name and a locker. The name is an owned string which represents the name of the student, and the locker is an optional I 32 integer. Not all students have lockers, so option is appropriate in this case. If every student was required to have a locker, then we can just do this as an integer, but since they're optional, option is a good choice. In our main function, we're creating a new student and assigning the student to the variable Mary. This student's name is Mary. We use toown to create owned data for the string slice.
04:57:01.926 - 04:57:37.536, Speaker B: Remember that strings by default are slices and borrowed. When you create them using double quotes, the locker number is being assigned to locker number three, and then we use the sum variance of the option to do so. We then print out the student's name. In this case, we get it with the dot name field within the student structure, we're getting Mary's name. So this variable and this name then is populated in the token. Finally, we match on this student's locker number. If the student has a locker number.
04:57:37.536 - 04:58:11.590, Speaker B: If there's some data there, we assign it the variable num and then print out. The locker number is num. If there is no locker number, no data, then we just print out no locker assigned. Since we created a student that has some locker data, when we run the program, we'll get student and it'll be Mary and this branch will be executed. Since we have some data here and it will also print out the locker number assigned, let's run it and see what happens. To run the program, go to terminal. New terminal.
04:58:11.590 - 04:58:49.552, Speaker B: We're on activity 16, so type in cargo run q bin a 16 as we can see, the student's name is printed out. Here we have Mary and her locker number is three just as indicated in the code. If we want to see what happens if we set the locker to no locker assigned, we take a look at the code. It should print out no locker assigned. So we'll rerun the program to verify that's the case. As we can see, student is married and no locker has been assigned. This concludes the activity on option.
04:58:49.552 - 04:59:34.610, Speaker B: I'll see you in the next presentation. In this demo, I'll be showing you how you can generate documentation for your programs. Here we have some source code that contains an enumeration, a structure and a function. We can utilize the automatic documentation function of the rust toolchain by using three forward slashes. So normally comments are two slashes, but when we use three slashes, this will be included as part of the generated documentation. I'm going to add a quick description for this function. This type of comment is called a documentation comment since it will specifically be displayed in the documentation and it will be displayed because we have the three slashes.
04:59:34.610 - 05:00:12.720, Speaker B: I'm going to also document the structure and enumeration that are present in this program. Now that I have added documentation comments to the program, we can generate the documentation using the cargo build tool. I can open up a terminal type in cargo dock. Cargo Doc will generate documentation for your program. If you pass in the open flag, it will automatically open your documentation after generation. Here we can see the documentation has been automatically opened and our structures, enumerations and functions are listed here. We can then click on one of these to get additional information.
05:00:12.720 - 05:00:54.148, Speaker B: We can see our description here. A piece of mail along with the fields our documentation also exists on the fields the destination address. We can expand this section to see the declaration of the structure if we want to. We can also take a look at the enumerations and it shows the enumerations along with the variance. Lastly, we have our add function and as we can see it adds two numbers together. When we click it, we get to see the function signature and we can also view the source code for this function by clicking on the SRC button. And now we see that our source code is highlighted here for the particular function.
05:00:54.148 - 05:01:38.024, Speaker B: It's always a good idea to document your source code. That way other developers or yourself in the future are able to more easily manage the source code and know what's happening. Generally when you create large programs over time, it's easy to forget how they work and the documentation will be an invaluable source of information to rediscover the program. This concludes the demo on documentation. I'll see you in the next presentation. In this demo, I'll be showing you how to access the Rust standard library API documentation. Before we jump in the documentation, I'm just going to create a quick program, and I want to determine whether or not my vector here has any numbers in it.
05:01:38.024 - 05:02:24.686, Speaker B: We can see that it does have numbers, but it is possible that there are no numbers if we were to modify this vector in the future. The Rust standard library has a function to do this for us that we'll check to see if there's anything in the vector. In order to access this documentation, we can go to terminal. New terminal type in rustup doc once you hit enter, a web browser will load with the rust library documentation. We're going to go straight down to the extensive API documentation, although I do recommend going over some of the other documentation that is available. Once you click the link, we're navigated straight to the API documentation. The documentation has multiple sections, and I highly recommend reading this first page on your own.
05:02:24.686 - 05:03:07.408, Speaker B: We're going to go straight down to the vector module right here. And within the vector module we have the vector structure which is located right here. So I'll click on that. And we're specifically looking for a functionality that will tell us if there are any elements within the vector, because I want to know if there's any numbers in my vector. On the left side of the screen we can see all the methods that are available on the vector structure. I'm specifically interested in the isempty function right here. When you click on a function, it will highlight the function right here, and it simply returns true if the vector contains no elements.
05:03:07.408 - 05:03:41.880, Speaker B: We also see that there are examples showing you how this function can be used. We can see that it's fairly straightforward to use. We just have the vector and then type in dot is empty, and that'll let us know if we have any elements or not. So this is the function that I'm interested in. I'm going to go back into my program, we'll close this terminal. All I'm going to do is match on numbers. Dot is empty, and if it's true, meaning we don't have any elements, then we'll just print out no numbers.
05:03:41.880 - 05:04:41.148, Speaker B: And if it's false, we'll just print out as numbers. If we run this program, the isempty function will evaluate to false and we'll print out as numbers. Let's just run it to ensure that's the case and as we can see as numbers is printed. As mentioned earlier, there is a lot of functionality available in the standard library that can be utilized to write your programs. The search bar at the top allows you to easily locate functionality that may be needed for your programs, and the examples provide an easy way to implement the functionality within your code. To demonstrate this, we'll just type in VEC and we can see all the instances where vector appears within the rust documentation. If we want to specifically find the function that we just use is empty, we can see that there are a lot of instances of isempty and we want ours for vector.
05:04:41.148 - 05:05:11.916, Speaker B: So we can just click on this and jump straight to it. So if you have an idea of what you're looking for, then the search bar is a great tool to attempt to locate it. This concludes the demo on the Rust standard library documentation. I'll see you in the next presentation. In this activity we'll be creating a program that utilizes standard library functionality. Once youre ready, start up visual studio code and well get started. Once visual studio code loads, navigate to your activities directory.
05:05:11.916 - 05:05:50.492, Speaker B: We are on activity 17 so double click on a 17. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. All right, let's get started. This activity topic is about browsing the standard library documentation requirements are simply to print a string in lowercase and uppercase. Our notes indicate that we need to utilize standard library functionality to transform the string to uppercase and lowercase.
05:05:50.492 - 05:06:29.660, Speaker B: We can use the Rustup doc command. In order to open up the standard library docs, we should navigate to the API documentation section and then search for functionality that can help us. We're given some keywords to try to uppercase and to lowercase. So the first thing I'm going to do is open up a terminal. By going to terminal new terminal, I'll type in rustup doc to open up the standard library documentation. Once the documentation loads, I'm going to navigate to the API documentation section. The API documentation section can be searched directly in the search box or you can click here to go to the homepage.
05:06:29.660 - 05:07:16.400, Speaker B: Once I'm in the standard library documentation, I'm going to search for the uppercase and lowercase functionality. Our notes indicate that we can search for two uppercase, so I'm going to search for that first. Here we have multiple results for touppercase we want to work with strings, so I'm going to use the STR link. Once it's clicked, it'll automatically navigate to the touppercase function so we can see that it returns the uppercase equivalent of this string slice as a new string. And here we have some usage examples. If we take an existing string that's assigned to this s variable, we can use s dot touppercase to get a uppercase version. Now that we know how to use it, we can go back to our program and utilize it.
05:07:16.400 - 05:07:40.906, Speaker B: I'll create a new string. I'll call it mystring. I'll just say this is my string. I will then print it out first in uppercase. So here we're calling the touppercase function on the mystring. The uppercase version will then be placed into our debug token and printed out as uppercase. We also need to find the to lowercase function in order to print it out in lowercase.
05:07:40.906 - 05:08:19.190, Speaker B: We can see in the documentation that the to lowercase function is right next to the touppercase function and it operates exactly the same. I'm going to copy this line and just change this to lowercase. I also change this to all caps here. That way we know whether or not the lowercase and uppercase functions are working properly within our program. Let's run this and see what happens. We can run the program with cargo run q bin we are on activity 17, so type in a 17 and here we have uppercase and the string has been transformed to all uppercase. And here we have lowercase where the string has been transformed to all lowercase.
05:08:19.190 - 05:09:03.160, Speaker B: In this activity we covered basic searching of standard library functionality. Remember that there is a ton of functionality that's included within the standard library, and it's good to browse it to find new functionality. Using standard library functionality will allow you to rapidly create new programs without needing to create everything from scratch. This concludes the activity. I'll see you in the next presentation. In this video I'll be explaining how to work with functions that may fail under certain circumstances, and how the result data type may be used to handle these types of situations. A result is a data type that contains one of two different types of data.
05:09:03.160 - 05:09:36.620, Speaker B: It either contains successful data or it contains error data. It's used in scenarios where an action needs to be taken but has the possibility of failure. Some examples are copying a file. Perhaps the file was previously deleted before we tried copying it and that would result in an error. Another example is connecting to a website. Maybe the website's down, the network is down, or maybe the Wi Fi connection isn't that great. A result can be used in all of those scenarios to detail the error on why you'd be unable to connect to a website.
05:09:36.620 - 05:10:26.138, Speaker B: Here is the definition of a result similar to an option. A result is simply an enum which contains two variants. It either has an ok variant which represents the operation was successfully completed, so it's ok. And then there is the error variance, err for short, and that means the operation failed and there's some error that occurred. Also similar to the option, we have the t type, which is a placeholder for any type you like, and then we have e, which is another placeholder. The letters used for these t and es are arbitrary. T just means any type, and we use e for any type as well in this case, and e would just be short for error.
05:10:26.138 - 05:11:01.384, Speaker B: So a result can either be okay with some data, or it can be an error with some other data. Let's take a look at an example here we have a function named getsound. It retrieves some sound data based on the name of a sound. The name is passed in as a string slice. It then returns a result. The result if it's okay, it will contain some sound data. If an error occurs, trying to load the sound data will return a string that details why the error occurred.
05:11:01.384 - 05:11:37.060, Speaker B: Sound data is a fictional data type created just for this demo, and is used just to conceptually show how a result would work. Within our function. All we're doing is checking to see if the name is equal to alert. So we only have one sound and it must be called alert. If the name supplied is alert, then we're going to return okay, so this means the function was successful. We return OK by creating some new sound data using this alert information. If the name is not alert, so it's something else, then we're going to return an error.
05:11:37.060 - 05:12:20.158, Speaker B: So err is short for error. We're going to return an error with the message unable to find sound data. We then turn it into an owned string since we need owned data for this function. Similar to the option, the OK and error variants are always available for use, so you don't need to have the double colons to get access to it. To use this function, we will just try to get the sound. So we'll get an alert sound, and whether or not it succeeds or fails, that's going to go into the sound variable. We then match on the sound variable if it was OK and we have sound data, then this branch will run and all we're doing is printing out that we located some sound data.
05:12:20.158 - 05:13:07.100, Speaker B: In this case we're ignoring the sound data because it's not relevant to our example. If an error occurs, then we do want to know what the error message is. So the e is the error and we are just going to print line that we have an error and we'll detail what the error message is, which is an e. In this case, alert is available here, so it'll be an okay and the OK will print out sound data located. If we had supplied something that was not alert then we would hit the error and it would say error, unable to find sound data. To recap, a result represents either success or failure. The OK variant indicates that the operation was completed successfully.
05:13:07.100 - 05:14:09.846, Speaker B: The error variant indicates that the operation failed to this is useful when you're working with functionality that can potentially fail to use results. You use the results with a type that's for success and a type that's for an error and that can be used in structures and in your function signatures. In this demo, I'll be showing you how result can be utilized with functions that may possibly fail. For this demo program, I'll be writing a program that simulates a menu and the menu will have multiple choices. The user will be able to enter some text that corresponds to one of the choices and if it fails then the user will be notified the reason it failed. Internally we're going to use an enumeration for each menu choice and we will utilize a function that returns a results in order to transform the user input into the enumeration. To get started, I'll create the enumeration.
05:14:09.846 - 05:14:40.922, Speaker B: I'll call it menu choice. We'll have a few options here. We'll have main menu start and quit. I then I'm going to create a function called getchoice and it will take in some user input as a string slice. It will then return a result and the results. If it is okay, it will be a menu choice and if we get an error, it will be a string. If you'll recall, the result enumeration consists of two variants.
05:14:40.922 - 05:15:23.860, Speaker B: There is an ok variant and an error variance. So the first type here is the ok variant and the second type is the error variant. This means that this function needs to return either an ok or an error. The menu choice return value will be wrapped in an okden and the string return value will be wrapped in an error. I'm now going to implement the functionality needed to map the string into a menu choice. The user types in main menu, they will get an okay with a menu choice of main menu. I'm now going to implement the rest of the functionality.
05:15:23.860 - 05:15:57.882, Speaker B: So here we are matching on the user input. If they input main menu, they'll get an okay with the main menu choice. And if they enter start, they'll get the start choice. They enter quit, they'll get the quit choice. Next we need to cover the situation where the user enters something else besides these three here. To do so we use the underscore, which is just a catch all. So the underscore will cover anything besides these three.
05:15:57.882 - 05:16:47.114, Speaker B: And we use an underscore because we're just ignoring the input. We don't really care in this program what the input is, we just know we only want these three and anything else is garbage. So that just that captures it and ignores the value. To return the error we do err, because that's the name of the variant in the result for errors. I'm then going to input a quick message for the user or programmer indicating to them that their menu choice was not found. I then type in to owned to create an owned string because we need to have an owned string for our results and that should complete this function. Now remember the ok variant, these all map to this first right here, this first type.
05:16:47.114 - 05:17:32.322, Speaker B: And as you can see all of these are a menu choice which corresponds to the type here, which is a menu choice enumeration. The last one, the error variant, is a string and that corresponds to the second type which can easily be printed out later on. If we need to do so, I'm going to go ahead and implement the rest of the functionality. I'm also going to derive functionality on the menu choice enumeration. That way we can easily print out the data. When we derive debug functionality on an enumeration or structure, it allows us to print out these variants on the terminal without having to manually match on each one. It'll automatically print for us.
05:17:32.322 - 05:18:15.798, Speaker B: If we hop down here we can just do a print line and I'll just put choice equals debug print and we'll put the choice in. We're starting off with the main menu as the first choice. So when the function gets called this match arm should be hit and we should get an okay back with the main menu variant of the menu choice. Let's run this and see what we get. As we can see, we have the choice is equal to the main menu variant and that's wrapped within an ok. I'm going to write an additional function that can be used just to print out the menu choice. So I'll call it print choice.
05:18:15.798 - 05:19:02.956, Speaker B: It will take in a choice and we'll just borrow a menu choice. No return value is needed. We'll do a print line and do choice equals and then have the choice. Now I'm going to comment out this function and we'll replace it with the print choice function. Now, what happened when we printed out the choice originally? We have an okay choice, so it's a results instead of just the main menu. We take a look at our print choice function. We'll see that it requires a menu choice, but our get choice function returns a result which may be a menu choice, but it may also be a string which represents an error.
05:19:02.956 - 05:19:50.850, Speaker B: So let's run this and we'll just see what the compiler tells us here. We have a mismatch types error and it's telling us that our when we try to borrow choice that they expect a menu choice because our function takes menu choice, but instead we have a results. And that's expected because our function here returns a result instead of just a menu choice. So we need to get access to this menu choice in order to properly utilize this function. To do so we can use a match expression so we can match on the choice. And I'll add some type annotations here so we don't forget that this is actually a result. Remember that the underscore means anything and ignore it.
05:19:50.850 - 05:20:34.390, Speaker B: So we're just going to let the compiler figure out that this is a string, because we already defined it as a string here, so it's able to figure out the proper type for that. We'll match on this choice, and if it's okay, we will then call our printchoice function and now we have access to the choice. I'll rename this just for clarity. We'll call this inner choice, and if there's an error, we'll print it out. What we're doing here is we have our result, which may be a menu choice or some type of error. We then are matching on that result. So the ok variant and error variant are both covered.
05:20:34.390 - 05:21:23.930, Speaker B: Those are the only ones that are available in results. If the function was called successfully, we'll get the okay variance. We then access the inner data, which is the menu choice, and then we can call our print choice function, since the inner data here is a menu choice which corresponds to the proper data needed to call that function. This is how rust is able to guarantee that your programs run properly. Because this menu choice data is wrapped within a result, and if you try to use it without getting the inner value you get a compiler error, as we just saw. So in order to account for that, we have to match on the choice to get the inner data. Then we can call the function with our inner data.
05:21:23.930 - 05:22:13.930, Speaker B: However, if there's an error, we'll then get our error data and just print out that there's an error and we'll be unable to call the printchoice function because the data is error data. So let's run this program again and we'll see what we get. Now we can see that our choice is the main menu. We have gotten rid of the results portion here, and now we just simply have the main menu information that we need to run the existing functionality, which is print choice. I'll change this to something that's not present in our current options. So we'll just type in leave instead of quit and we'll see what we get. We get an error and the error indicates that the menu choice was not found and that corresponds to our error here.
05:22:13.930 - 05:23:11.588, Speaker B: And in this case the get choice will be an error, so it'll be results with error data. And since it's an error, this won't get executed and it instead prints out that we have an error. There is actually a shorter way to access data instead of having to match on the result. What we can do is use what's called a question mark operator, and that's automatically going to handle some things for us. I'm going to create a new function that utilizes the question mark operator so I can demonstrate how it works. I'm going to call this function pickchoice and it will take a string input and it will return a result and the ok variant is going to be nothing. So if you want to return nothing from a function, you can use what's called the unit type, and that is just open and close parentheses.
05:23:11.588 - 05:23:48.134, Speaker B: That's called the unit type and that just represents nothing. So this function, for example, it doesn't return anything here, so it implicitly returns this unit type. So sometimes you need to specify that you want to return that type, and in this case we need to do so because the result requires both the okay and the error type. So the okay type is just going to be nothing and the air type will be a string. I'm then going to make a choice. So the choice will be get choice and it'll take the input. Then we're going to use the question mark right here.
05:23:48.134 - 05:24:57.090, Speaker B: What this is doing is we're calling the getchoice function just like we did here, and instead of returning a result like it did before, the question mark will automatically perform a match operation. And what will happen is if the result is an okay variance, then that inner data will get placed into the choice, and if it's the error variance, then the error is going to get automatically returned as the error variance from the function, so it'll be a result error if it's an error and if it's not an error, then we'll just get the inner data automatically. This is useful because we can chain multiple function calls using the question mark, even though all of them may return results and could possibly fail. So if any one of them fails, then the function will just return automatically and we don't have to use a bunch of match blocks in order to check each one. I'll add some type annotations here so we know what working with. So this is a menu choice type. Next we can just do a print choice and we'll borrow the choice.
05:24:57.090 - 05:25:37.402, Speaker B: And finally we'll return an okay. Remember that the okay variant of the result just means everything's fine. I and I'm returning nothing which is just the open parentheses, close parentheses which is known as the unit type. Now down in our main function, I'm going to just change all this. This will just be called pickchoice and we'll try it with start. Let's run this program and see what we get. As we can see, our choice equals start to walk through, we call our pickchoice function with the start data that's placed here as the user input.
05:25:37.402 - 05:26:25.716, Speaker B: We then create a choice which is the menu choice type by calling getchoice. The getchoice function expects a borrowed string which is here as the input. So that will then come over here. We then match on it as we did before and return a result. Now the question mark will evaluate, is this result an okay or is it an error? It's going to check now. If it's an error, then it's just going to return the results and it's going to return the error variant. If it's the okay type, then the inner data which is the menu choice will then just get returned into the choice and we can easily access the choice with other functionality as we just did here.
05:26:25.716 - 05:26:59.680, Speaker B: Let's try this with a menu option that is not present. I'll type in end. We'll give this a variable name, we'll call it choice and then we'll do a print line. This here is always going to be a result because this pickchoice function always returns a result. Now this result only has either nothing or an error. So if we send it a menu choice of end, we should get an error back because and is not covered in our match. Let's give it a go.
05:26:59.680 - 05:27:52.950, Speaker B: And here our choice value is error menu choice not found because the question mark automatically returned the results and then this never got executed. So it's impossible to execute this line of code unless this function is successfully ran. Working with results is a little more complicated than some of the other things we've been working with. However, once you get the hang of using question marks within your code, it becomes quite natural to just call a bunch of functions that return results using the question mark operator and then when you're done you just check at the end to see if it failed or not. This concludes the demo on the result type. I'll see you in the next presentation. In this activity we're going to be creating a program that utilizes results.
05:27:52.950 - 05:28:25.532, Speaker B: Once you're ready, fire up visual studio code and let's get started. Once visual studio code loads, navigate to your bin directory. We are on activity a 18, so double click on a 18 rs. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Alright, let's get started.
05:28:25.532 - 05:29:07.700, Speaker B: This activity topic is result and we're going to be using it to restrict the creation of a structure. So the first thing we'll do is create a structure named adult and it needs two fields, a name and an age. Put the age first. We'll use a u eight since that goes up to 255 and there shouldn't be any people that are older than 255. We need to implement debug print functionality that we can print out our structure. So now here's where the meat of the activity comes in. We need to implement a new function for the adult structure that returns a result.
05:29:07.700 - 05:30:06.350, Speaker B: So we're going to give an age and a name that's going to return a result. So with our return type being a result, the okay value will be self, which refers to our implementation of adult, which means we're going to get an adult structure back if everything is okay. And if we get an error back, we'll get a reference to a stir and this will just be a message indicating why we couldn't create the adult structure. So we'll check the age so the person's only supposed to be age 21 or older if they're an adult. So if age is greater than or equal to 21, we'll make a new structure. We'll include the age and then the name. We'll use tostring to convert the STR to a string and anything else which would be under 21.
05:30:06.350 - 05:30:37.638, Speaker B: Or turn an error with a message. Age must be at least 21. So what's happening here? We'll enter into the new function. The age is immediately going to get checked, and if it's greater than or equal to 21, we'll return an okay. And within that okay, we have self, which just like this self here refers to. So we'll have, okay adults, and we'll set the age and the name. And if they're under 21, we're going to return an error instead.
05:30:37.638 - 05:31:28.950, Speaker B: Both okay and error are variants on the result type, so everything will check out. As far as the type checker is concerned, we'll hop down into our main function. So we need to instantiate two adult structures. One should be under 21 and one should be over 21. We'll make a child, we'll make a 15 year old named Anita, and then we'll make an adult. And this adult will be 21, and we'll use Sanjay. We then need to match, so we'll match on the child first.
05:31:28.950 - 05:31:59.920, Speaker B: It says we can print out any message that we want. So I'm just going to print out the person's name and the age. We'll do child name, child age. If we get an error, we'll print out the error. Then we need to use the same thing, comma, right here. We do the same thing for the adult. So let's copy this whole block.
05:31:59.920 - 05:32:30.590, Speaker B: So this will be, we'll match on the adult and this okay variant here. When we destructure it, we can name it anything we want. So I'll name it a, this will be the same thing. So this will be a name, a age. And again, we'll print out the error. So we'll walk through this before we run it. The first thing we're doing is we're creating a child who's going to be 15 years old named Anita.
05:32:30.590 - 05:32:57.690, Speaker B: If we look at our function parameters up here, we'll see that the age comes first, followed by the name Anita. Her age will be checked, and if it's greater than or equal to 21, will get back self, which is an adult and is wrapped within an okay. And if she's under 21, we're going to get an error back. Since Anita is 15 years old. We're going to get an error when we try to run this code for a child and then the same thing for adult. So we're going to create an adult. Adult's going to be 21.
05:32:57.690 - 05:33:35.758, Speaker B: This one should be an okay because Sanjay is 21 or older. And then when we print out the message, we should get the okay message. When we print out the child message we should get the error message because we're getting a result back and we'll have the error variant for child because Anita is only 15 years old. So let's run this code and we'll see what we get. I'm going to hop into a terminal, we can run this code with cargo run bin a 18. So here's our first message. Age must be at least 21 and that's the error variant of or Anita.
05:33:35.758 - 05:34:21.490, Speaker B: And then we have Sanjay who is 21 years old and that's the okay variant. We look at our messages, we'll see that we have the error and that's printed out as age must be at least 21. And then we have our okay and then Sanjay is the 21 years old. When we create new functions for creating structures and we utilize result, this is a great way to ensure that the structure always has valid data. So we perform all of our validation here in this new function and then whenever we get an adult back, it's always going to be the okay variant. So anywhere in our code that we have an adult, we already know it's been checked so we don't need to perform any more checks. And this is a good thing for optimization and makes the code easier to work with.
05:34:21.490 - 05:34:56.078, Speaker B: This concludes the activity on results. I'll see you in the next video. In this activity we'll be creating a program that utilizes results and the question mark operator. Once you're ready, fire up visual studio code and let's get started. Once visual studio code loads, navigate to our bin directory. We are on activity a 18 b, so double click on a 18 b rs. Once the activity file loads, review the topic and program requirements.
05:34:56.078 - 05:35:35.452, Speaker B: Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. Alright, let's get started. We have a program here and it already has some code and we're supposed to write the body of the authorize function here as indicated in the requirements. So I'm going to copy these requirements down into the authorize function and then we're going to write the code needed to complete the function. So we go down to authorize. So we need to put our code in this function and then once it works, we'll see here at the top in our requirements.
05:35:35.452 - 05:36:14.408, Speaker B: When we run the program, we should see ok, allow, ok, deny and then error. Catherine doesn't have a keycard and we need to make sure that we're using the question mark operator. With an authorized function, it is possible to do this activity without the question mark, but we want to use that just for practice. So it says the steps to authorize a user are to first connect to the database. So if we go up here to our database structure, we'll see. To connect we just need to call the connect function and that's going to return a result which has a database structure or a string for an error. We'll see that all these results use string for error.
05:36:14.408 - 05:37:00.640, Speaker B: So we'll be working with strings as part of our error message. So step one, connect to the database. Step two is to find the employee with the findemployeedatabase function. So we'll use our database findemployee and we're going to use the employee name that was passed to the authorized function. Step three is to get the key cardinal. So once we have the employee information we can use the getkeycard function to retrieve the keycard. And then finally we can check the keycard's access level to see if they're allowed to access the current area.
05:37:00.640 - 05:38:12.920, Speaker B: The access level is going to be present in our protected location. That's the authorization being checked for. So we'll look at protected location first and we'll see up here we have as an enumeration there's all office and warehouse and we can use the required access level function to determine the actual numeric value for each one of those locations. We'll see here in our requirements that high numbers can access lower level numbers, but lower level numbers cannot access higher levels. So we're just going to do a basic greater than or equal to check. So we'll get our key card, check the access level, and if it's greater than or equal to the required access level of location, then we'll authorize them. We'll change the authorization status and that will be allow, and if they don't have the required access level, we're going to return an okay and we'll do authorization status and then we'll deny access.
05:38:12.920 - 05:38:51.390, Speaker B: So we look at keycard from our getkey card function. The keycard structure has an access level built in, so we already know the numeric value of the keycard and we're just comparing it to the access level required for the protected location. So now we've done all the steps. First we've connected to the database, then we try to find the employee and then we try to get the key card. And we also checked the access level. Let's hop into a terminal and run this and see what we get. We can run this with cargo run bin a, 18 b.
05:38:51.390 - 05:39:10.640, Speaker B: And so it looks like we got some errors. Let's start from the top. So we'll see here that it indicates that we have no method named findemployee for enumeration result. So it points to the code. We're trying to call the findemployee method, but the data is resolved. It's not the actual database. So we need to fix that.
05:39:10.640 - 05:39:35.862, Speaker B: So if we go up here to the database connect, this returns a result. So there's lots of ways to get the data out. If we use unwrap, that's fine. But if the database connection fails, then the program will crash. So we don't want that. It's also possible to do something like this. We can match on the database connect and if we get an okay, we get the database back.
05:39:35.862 - 05:40:07.040, Speaker B: We can just place that into the variable. And if we get an error back we can return the error and that works too. But then we have to do that for findemployee because that returns result and also get keycard. So then our code is going to increase by a lot. So if we try to see how much, we'll see that our code is going to look something like that. And that takes up a lot of lines and starts to become hard to read. So instead what we're going to do is we're going to go up here to the end of the database connect function and do a question mark.
05:40:07.040 - 05:40:47.256, Speaker B: Now this question mark is going to turn this line into this one right here automatically for us. So that way we don't have to actually write all this manually. We can just forget all that, use the question mark and then we'll get our database back. And if something goes wrong with the database connection, it's going to automatically return an error from the function and then the program can continue with whatever else it was doing. So I'm going to delete this and we know that define employee that also has a result. So we'll do a question mark and we'll do a question mark. So now for steps one, two and three, each one of them can possibly fail.
05:40:47.256 - 05:41:21.580, Speaker B: We handle that. That potential failure scenario with the question mark, and we'll get an appropriate error back at each step of the process. Once we get to this point down here, we have access to a keycard and we can just check the access level. And again, if the access is good, if it's greater than or equal to the location, then we'll return an authorization status of allow. And if their level is too low, we're going to return deny. So now that we've added question marks, we'll save it and hop back into a terminal. We'll run it again with cargo run bin 18 B.
05:41:21.580 - 05:42:13.560, Speaker B: And so now we'll see that we have okay, allow, okay, deny and error Catherine doesn't have a key card. We go back to our requirements, we'll see that we should have ok, allow, ok, deny and error Catherine doesn't have a keycard, so it looks like our output matches the requirements. I'm going to go down to the authorize function really quick. So as you can see, using the question mark operator is a great way to encapsulate error handling within a single character in your codebase. One quick note before finishing up. Whenever we have a result and we're using question marks, each one of these operations needs to return the same error type, so all of them return string. If we have different error types that are being returned, it's still possible to use the question mark operator, but additional functionality needs to be written in order to handle that which we'll be covering in a future video.
05:42:13.560 - 05:42:50.902, Speaker B: This concludes the activity on using the question mark operator with the result type. I'll see you in the next video. In this video, I'll be explaining a data structure called the hash map. Hashmaps are useful for storing information and retrieving information when you know exactly what you're looking for. A hashmap is a collection that stores data as key value pairs. Data is located using the key and the data itself is the value. It's similar to definitions in a dictionary.
05:42:50.902 - 05:43:24.060, Speaker B: When you're using a dictionary, you know which word you're looking for and you're trying to figure out what it means. A hashmap is the same concept. You know what the key is, but you don't know what the value is at that key. Hashmaps are very fast to retrieve data when you're using the key. Let's take a look at an example here. We're creating a new hashmap using the new function that's defined on the hashmap structure. When creating new hashmaps, you'll need to use a mutable variable because we'll have to manually insert the data within the hashmap.
05:43:24.060 - 05:44:00.780, Speaker B: Here we can see that we are calling the insert method that's defined on the hash map structure, and we're inserting some data. The first piece of data is called the key, and that's what we'll use to find the data later. The second piece of data is called the value. In this case, I'm inserting people's names and some numbers. These numbers represents the person's age. Here we can see we can remove data from the hashmap quite easily as well. All we need is the key, and then it will automatically remove the data.
05:44:00.780 - 05:44:35.860, Speaker B: Here we are trying to retrieve some data from the hashmap. Here we're matching on the people structure and we are using the get method defined on the hashmap. Get will retrieve data based on the key. In this case, the key is ed, and as we can see, we have ed in our hashmap. So the value that should be returned is 13. We're using a match on here because it's possible that the key you look for does not exist within the hash map. So if it does exist, we'll get some data.
05:44:35.860 - 05:45:08.034, Speaker B: In this case, it'll be an age. We will print out that the age equals whatever it happens to be. If we search for a key and it doesn't exist, we'll get none back, which indicates that we search for a key and the key was not found within the hashmap. We then will print out not found. Let's take a look at another example. In this example, we'll use the same data from the previous example where it has people and their age. Here we're going to be iterating through the data.
05:45:08.034 - 05:45:52.186, Speaker B: I'll use the for in loop to do the iteration. So this first one here iterates through both the key and the value. To do that, I just call the dot iter method that's defined on the hashmap structure, which iterates through both key and value pairs. The dot iter method returns a tuple, as we can see here, by the parentheses, with the first part being the key and the second part being the value. We can then print out each person and their age that's present within the hashmap. In this second loop, we are just looking at the keys. So if we do the keys method on the hashmap, we'll just get the keys.
05:45:52.186 - 05:46:31.542, Speaker B: In this case, it's just a person's name, so we can print out each person within the hash map. And finally we're here. We're just iterating through the values which are the ages, so we can go through each age in the hashmap and print out just the age. One important thing to note about hashmaps is the data is stored in random order. So if you insert one, two, three, you may get back 321 when you iterate through it. This differs from vectors, where everything comes in the same order as it was placed into the vector. To recap, hashmaps store information as key value pairs.
05:46:31.542 - 05:47:21.456, Speaker B: The key is used to access the value. They're very fast to insert and find data when you have the key, and they're useful when you need to find information and know exactly where it is, meaning you have the key. In this demo, I'll be showing you how a hashmap can be utilized to store data based on keys. The program I'll be creating for this demo simulates lockers like student lockers or a locker room. Each locker will be given an id number and the lockers will have contents. I'll be using a hashmap to store the locker number and what each locker contains. A hashmap is a great data structure to use for this situation, since lockers can be accessed in arbitrary order based on who shows up to open up their locker.
05:47:21.456 - 05:48:03.166, Speaker B: Before I start writing code, I'll be taking a look at the rust standard library documentation, so we can see how a hashmap can be utilized in your program. Here we have the documentation, and the hash map is a type of collection. I'm going to scroll down to the collections module. Here we see we have collections, so I'll click that. Next we see the collections that are available. And here we have the collections along with documentation on what collection you should use in which situation, and the performance trade offs for all the collections. I know I want to use a hashmap, so I'm just going to click on hashmap.
05:48:03.166 - 05:48:49.576, Speaker B: Here we have information that we need to properly utilize the hashmap. As you can see at the top, we are at std collections hashmap. So in order to access this hashmap, we're going to need to use another keyword in rust. And if we take a look at this first example, we'll see it right here. So we need to have the use keyword in our code, and we need to use this path here, which is also shown at the top. So whenever you're browsing rust documentation, even if there's no example provided, you'll be able to access whichever item you're reading based on the top because it'll always show you your current location within the documentation. So let's add this to our code.
05:48:49.576 - 05:49:33.470, Speaker B: That way we can use a hash map. To do so, I'd simply type in use std collections hashmap. Hashmap will now be available in my code and I can get started writing my program. So for the locker numbers, I'm just going to use an I 32, and for the contents, I'll use a struct. The contents of the locker is just going to be a string, and I'm using a structure just in case I want to specify exact contents later in the program. Like suppose I want to make it so lockers can only have certain things. Then I'd be able to easily list those things within this structure here instead of having to rewrite portions of the program.
05:49:33.470 - 05:50:07.770, Speaker B: Next, I'm going to create some lockers that we'll have some lockers and that will be a hash map. New so we'll create a new hashmap. Remember to make it mutable, otherwise we won't be able to add anything to the lockers. Next, I'm going to add some content to the lockers. So we'll use lockers dot insert and this will be locker number one. And we'll add in some contents and the content will be stuff. So we'll put stuff in this locker and then I'll make a few more lockers.
05:50:07.770 - 05:50:50.082, Speaker B: And this locker will have a shirt, and this locker will have gym shorts. Once that's done, we can print out the lockers and their contents using iteration. So I'm going to print out both the locker number and the contents. So I'll call it locker number content in lockers iter. If we jump back to the documentation real quick, we can see if we click on iter, we can iterate through all key value pairs. And remember it's in arbitrary order, so it may not be in the same order that you placed in the hashmap. And the usage is right here.
05:50:50.082 - 05:51:32.366, Speaker B: So for key value in the hashmap iter, you can take some actions. So we're going to print out the locker number and the content. Before I run the program, I want to make sure that I can actually print out the contents. To do that, I need to derive functionality. To do that, I need to derive the debug functionality, which will allow everything within the contents to be printed out using the debug print token within the print line. Now I'll just run the program and we should have locker number one with a content of stuff. Locker two with a shirt.
05:51:32.366 - 05:51:58.550, Speaker B: Locker three will have gym shorts. Now remember, they may not print out as one, two, three, it may be two, three one or three one two. Or it may just coincidentally print out one, two, three. But there's no way to know ahead of time. So I'll save this, we'll run it. And here we have locker 132 and the content for each locker. So locker one has stuff.
05:51:58.550 - 05:52:27.410, Speaker B: Locker two has a shirt. Locker three has gym shorts. And that's how you can iterate through a hashmap. Hash maps are quite easy to use and they're fantastic when you know what the key is and you want to access whatever's within that key at any time. This concludes the demo on hashmap. I'll see you in the next presentation. In this activity, we'll be creating a program that utilizes hashmap.
05:52:27.410 - 05:52:57.120, Speaker B: Once youre ready, open up visual studio code and well get started. Once visual studio code loads, open up your activities directory. We are on activity 19 so double click on a 19. Once the activity file loads, review the topic and program requirements. Attempt to implement a solution on your own with the video paused. Once completed, resume the video and I will demonstrate my implementation as well as provide insights to the activity topic. All right, let's dive in.
05:52:57.120 - 05:53:39.328, Speaker B: This topic is hash map. The requirements are to print the name and number of items in stock for a furniture store. If the number of items is zero, print out of stock instead of zero. The store has five chairs, three beds, two tables, and zero couches. We also need to print the total number of items in stock. Our notes say that we need to simply use a hashmap for the furniture store stock. To start out, I'm going to use the hashmap data structure by typing in use std collections hashmap.
05:53:39.328 - 05:54:15.828, Speaker B: That will give us access to the hashmap. I'm not going to have any functions in this program so I'll just stick with the main function. I'm going to create a hash map called stock which will represent the items that are in stock and that will be created using hashmap new. I will then insert the items that the store has stocked. Okay, so that should cover the store stock as we see up here in our program requirements. Next, we need to iterate through each item and print out the information. I'll use a for loop for that.
05:54:15.828 - 05:55:09.076, Speaker B: We're going to iterate through the key value pairs so this can be item and I'll use Qty for the quantity of items in stock iter, when we use iter on the hashmap, iterates through the key value pairs. So we get a tuple that contains the key and the value. One thing to remember with the requirements is if the number of items is zero, we need to print out of stock instead of zero. To facilitate this, I'm going to use a string that specifically just contains the number of items or the out of stock message. And then I'll compose that with another string that will then print out the entire statement that we need to print. To do that, I'm going to create a new variable. I'll call it stock count, and that will be an if expression.
05:55:09.076 - 05:55:57.410, Speaker B: So if quantity equals zero, we'll just return a string that indicates out of stock. We'll need to use an owned string in this case. And if the stock is greater than zero, then we will just print out the stock using the format macro, and that will have the number of items, which is Qtye, as we see right here. The format macro. It's similar to the print line macro, except instead of printing the line on the console, it's just going to put it into a string instead. So you can type your tokens in here just as you would with the print line macro. But instead of printing it and just throwing everything away, we can save it into a variable.
05:55:57.410 - 05:56:32.716, Speaker B: In this case, we're saving it into the stock count variable. That way we can use it later. Next, we just need to print out the information item equals and then I'll just print out the item name and stock equals and we'll print out the stock. One last thing we need to do is print the total number of items in stock. So we need to keep a running total and we iterate through this. To do that, we need to make another mutable variable. I'll just call it total stock.
05:56:32.716 - 05:57:12.606, Speaker B: We'll set that to zero. Each time we go through this iteration, I'm just going to take the total stock and I'll set it to itself plus the quantity. And then once the loop is finished, we can print out the total stock. Before running this program, I'm going to walk through it so we can see how it works. So the first thing we're doing is we're using the hash map data structure from the collections library. In the standard library, then have our main function. We're creating a mutable variable named stock and setting it to a new hash map.
05:57:12.606 - 05:57:46.466, Speaker B: We then insert the items that are in stock for the store. We have chairs, beds, tables and couches, and each one has its own quantity. The names are the keys, and the quantities are the values. We then track the total number that are in stock with a mutable variable. We set it to zero, and we're just going to add to this number each time we go through the loop. That way we get the total stock. This type of variable is also called an accumulator because it just accumulates data.
05:57:46.466 - 05:58:28.052, Speaker B: In this case, it accumulates a number into a bigger and bigger quantity. Next, we have our for loop, so we iterate through the key value pairs of stock. So the item is the key and the quantity is the value. We then increment the total stock by taking the total stock plus whatever quantity we may have here. Next, we create a string that indicates either the message out of stock or a number which represents in stock. So we check here. If the quantity is equal to zero, we'll have a string out of stock.
05:58:28.052 - 05:59:27.060, Speaker B: Otherwise, we're going to create another string using the format macro, and we simply use the quantity into this token, and it will display the quantity as a number. And remember, the format macro saves it into a string instead of printing it out directly like the println macro does. So the stock count will contain a string either out of stock or the number that's in stock. Next, we simply print out the item and the stock. So the item is taken from here on, the iteration that's the key, and the stock count is this string that we created right here, which is out of stock, or the number. This will go through every single item that's in this hashmap, so it'll execute four times. Once that's completed, we'll then print the total stock by printing out the total stock variable which was created here and was increased in value on this line here.
05:59:27.060 - 05:59:56.304, Speaker B: Let's save this and we'll see what happens. As we can see, we have an error. We are unable to compare a reference to an integer with just a plain integer, as we can see on line 29. Here's our error, so we can fix that. We go to line 29. We can see the error occurs right here. Now, the reason we got that error is because when you iterate through a hashmap, these right here are automatically borrowed.
05:59:56.304 - 06:00:34.214, Speaker B: So all we need to do is borrow our zero, and then it'll work just fine. So now let's run this. We are on activity 19, so you can do q bin a 19, and as we can see, our stock has been printed out along with the total number of items that are in stock. We can confirm this by checking the information here we see that chairs is five, that's good. Tables is two, it's good. Bed is three, we're good. And the couch is zero, so it printed out of stock instead.
06:00:34.214 - 06:00:47.530, Speaker B: And the total stock is ten. So we have five, plus two is seven, plus three is ten. That checks out as well. That concludes this video on the activity about hash maps. I'll see you in the next presentation.
06:00:50.790 - 06:01:12.090, Speaker A: Aldo here again, what do you think of the video? Drop us a comment to let us know. Also, if you did enjoy this rust crash course, make sure to check out Jason's full rust, the complete developers guide boot camp course, where you'll go a lot deeper and gain the skills to get hired as a rust developer. More information on that in the description below. Or watch that video right there on your screen to see what it's all about.
