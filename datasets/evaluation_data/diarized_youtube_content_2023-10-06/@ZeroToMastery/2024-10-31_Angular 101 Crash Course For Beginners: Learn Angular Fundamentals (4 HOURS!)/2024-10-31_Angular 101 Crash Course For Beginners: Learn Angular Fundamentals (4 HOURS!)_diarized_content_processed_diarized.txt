00:00:04.360 - 00:00:50.635, Speaker A: Thinking of learning Angular? Well, by sheer luck or the grace of the YouTube algorithm gods, you've landed on the perfect video. This crash course is the first four hours of Luis Ramirez zero to Mastery Angular Boot Camp course, which I can absolutely guarantee is the most comprehensive and up to date Angular course online. The full Bootcamp has 25 hours of additional lectures and you'll get to the point where you'll be building enterprise level projects and have the skills to get hired as a full time Angular developer. Click the link up here or in the description to see for yourself. Plus, in a second I'm going to tell you how you can win free access to the full bootcamp. But first, who the heck is Luis Ramirez? Well, if you haven't heard of him, it's probably because he's not spending his day to day self promoting. He's busy in the trenches with over 10 years of experience as a software engineer.
00:00:50.635 - 00:01:08.851, Speaker A: But let me cut to the chase. What you guys really want to know is how you win access to the faux bootcamp. No. Well, it's super easy for a limited time. Luis is giving free access to his full bootcamp to one lucky person for every 50 comments left on this video. That's right. All you have to do is like this video and drop a comment.
00:01:08.851 - 00:01:31.445, Speaker A: I mean, it can't get easier than that. Ideally we would want the comments to be feedback or questions that Luis can respond to, but even saying hey Luis, you're beautiful counts. We'll post a pinned comment when the giveaway has ended and who knows, maybe we'll throw in a special discount code in there for everyone else. Alright, that's enough chit chat for me. Let me hand it over to Luis so you can start learning Angular. Enjoy.
00:01:40.945 - 00:02:18.489, Speaker B: In this section, we're going to dive into the Angular framework. I know you're excited to get started, but before we get into writing some code, I want to talk about why Angular is completely different from other frameworks. The purpose of this lecture is to give you a proper expectation of what Angular brings to the table. It stands out from the competitors. Let's take a step back for a moment. Frameworks are common in every programming language. They exist within C Sharp, Java, C Go, Python, and almost any other language you can think of.
00:02:18.489 - 00:02:51.715, Speaker B: Typically, we can put frameworks into two categories. There are configuration over convention frameworks and convention over configuration frameworks. Both types of frameworks have their advantages and disadvantages. Some developers prefer one over the other. A configuration over convention framework focuses on providing you a minimum setup for starting a new Project. Less boilerplate means a smaller learning curve. For that reason, these types of frameworks are more popular.
00:02:51.715 - 00:03:32.019, Speaker B: These frameworks are extendable. So if you need to add more features, you'll be able to do so with ease. Since these types of frameworks are popular, third party developers will frequently provide open source solutions for problems not solved by the framework. Features like form validation, authentication, storage, etc. On top of being extendable, these frameworks give you complete freedom over the structure of your projects. File names, variables, classes and directories can be organized how you see fit. React and Vue are examples of frameworks that are configuration over convention.
00:03:32.019 - 00:04:02.009, Speaker B: They focus on interacting with the view of the application. If we need additional features, we need to install and configure external libraries separately. For example, React doesn't come with state management. You need to install either Flux or Redux to fill in that hole. Despite their popularity, there's one glaring issue with these types of frameworks. It can be challenging to scale. At some point, you will need to have standards in your project.
00:04:02.009 - 00:04:29.299, Speaker B: Carelessly throwing code wherever you want can lead to tech debt. That doesn't mean these frameworks are terrible. Far from it. On the contrary, there's a reason they're popular. Developers can develop complex and scalable apps if they're careful every step of the way. If the community of the framework puts in the effort, these problems can be avoided. The next type of framework is convention over configuration.
00:04:29.299 - 00:05:00.155, Speaker B: Instead of configuring everything yourself, these types of frameworks are configured out of the box. The framework will help you with deciding how classes and files are organized from within your project. Another benefit is the suite of features that come with these types of frameworks. Need routing? You're covered. How about state management? Not a problem. What about a solution for working with forms? That's also covered. It's a batteries included type of framework.
00:05:00.155 - 00:05:23.519, Speaker B: There's just one problem. A convention over configuration framework has a high learning curve. There's a lot to memorize. As a result, it can feel overwhelming to beginners. For that reason, most beginners tend to shy away from these sorts of frameworks. Angular is considered a convention over configuration framework. It stands out from the crowd.
00:05:23.519 - 00:06:03.109, Speaker B: For this reason, the developers behind the framework wanted to create a framework for large sized applications. The reason I'm mentioning this is because of how intimidating the framework can be to beginners. A beginner can get started with React or Vue with a few lines of code. It's another story for Angular. Instead of a few lines, we're given dozens of files for A starter project it's not possible to get started with Angular with one line of code. It's because Angular is not meant for small apps. If you're interested in creating small widgets, Angular is probably not the best choice for you.
00:06:03.109 - 00:06:43.741, Speaker B: It's aimed at creating medium to enterprise level apps. There's a high learning curve, but don't worry, that's why you're taking this course. Together, we'll walk through every file to get an understanding of what's going on. Now that we know what we're getting into, let's get started. In this lecture, we're going to install the Angular cli. Building an application is going to require dozens of tools. It's never a pleasant experience configuring various tools.
00:06:43.741 - 00:07:22.779, Speaker B: However, it's a step we must take if we want to debug, build and deploy our project. Luckily, we can skip this step altogether with the Angular cli. The Angular CLI is an official tool by the Angular team for configuring the tools required for running an Angular application. By using this tool, we can start working on our application right away. The CLI is capable of automating other tasks too. It can build our project, start a development server, run tests, and deploy an app. It's one of the most exhaustive tools Angular has to offer.
00:07:22.779 - 00:07:58.869, Speaker B: As you will see, there are hundreds of options for managing our project with the cli. Let's briefly talk about how the CLI works under the hood. During the development of our application, we're going to have dozens of files. They can range from TypeScript files to images and fonts. As we write our code, they'll be processed through the Angular cli. In reality, the CLI is a tool that manages other tools, just to name a few. The tools are Webpack, Babel, Sass, and TypeScript, along with other tools.
00:07:58.869 - 00:08:28.435, Speaker B: You don't need to know how these tools work to be able to work with Angular. That's one of the perks of using a framework. It handles the configuration for these tools, thus saving you hours of time. The purpose of running our code through these tools is to produce a bundle. The bundle is the application code that's been optimized for production. These files can be uploaded to a server. Overall, the CLI is a utility tool for managing projects.
00:08:28.435 - 00:09:09.907, Speaker B: In the Resource section of this lecture, I provide a link to the documentation page for the Angular cli. Everything we need to learn about this tool can be found from this section of the documentation. If you want to learn more about commands for testing or deployment, you will Find documentation links for those specific actions. The section we're interested in is called Local Setup. If you scroll through the page, you're going to find a command for installing the cli. Copy the commands to your clipboard. Next, switch over to the command line paste and run the command we copied earlier.
00:09:09.907 - 00:09:40.305, Speaker B: If you're on a Mac or Linux, be sure to add the Sudo command before installing the package. The installation may take a while. Be patient. The installation should be complete. If you get a couple of warnings, that's completely normal. We can verify if the installation was a success by typing the NG version command. This command will output the version of the package we've installed.
00:09:40.305 - 00:10:17.463, Speaker B: In addition, it'll provide information on the environment we're running in. It's likely the versions of your environment will be different than mine. That's perfectly fine as long as the CLI tool is working on your machine. The NG command we've typed was created when we installed the CLI package. Anytime we want to work with the cli, we need to type NG followed by the sub command we'd like to run. The version command is just one of the many commands from this tool. The CLI has another command for viewing a list of commands and options.
00:10:17.463 - 00:11:13.243, Speaker B: Let's check it out. Inside the command line, we will run the NGHELP command. This command will immediately output a list of commands available from the Angular CLI package. We can perform actions such as deployment, running tests, or creating a new project. Feel free to explore these commands in the next lecture, we're going to use the CLI to install a fresh Angular application. In this lecture, we are going to explore the process of upgrading an Angular application. Angular experiences fresh updates every six months While not fun, we should always take the time to work with the latest version of Angular.
00:11:13.243 - 00:11:45.071, Speaker B: Major updates imply breaking changes. So where do we go for upgrading an Angular application? Luckily, Angular is known for making the upgrade process as painless as possible. Let me show you the process of upgrading an Angular app. You do not need to follow along with me. If you've been following along, your app should already be using the latest version. As of this course, we are on version 18 for demonstration purposes. I've taken the time to downgrade the version to version 17.
00:11:45.071 - 00:12:27.557, Speaker B: On this page, the Angular team will guide you through the process of upgrading your project. Just follow the instructions and you're good to go. In my case, the steps for migrating from version 17 to 18 are running a single command. You may experience different steps if you're on different versions. This command will update the packages to the targeted version. After you've got it in your clipboard, switch over to the command line of your project paste and execute the command. During the update process, you will be asked if you're OK with proceeding.
00:12:27.557 - 00:12:59.821, Speaker B: Let's continue with the update. This process may take a few minutes. Be patient after a few moments. Everything should be working as long as Angular says Migration completed. You good to go? We've successfully migrated from version 17 to 18. You shouldn't have to perform this step since you're probably on a newer version of Angular. I'm including this lecture to demonstrate the process of upgrading Angular to a more recent version.
00:12:59.821 - 00:13:38.213, Speaker B: All you have to do is follow the steps recommended on their site. As long as you follow the instructions, you shouldn't have much trouble. Let's continue our journey in the next lecture. In this lecture, we're going to create an Angular application with the CLI tool. We previously saw a list of commands with the NG Help command. One of the commands is called New. This command will create a new application for us.
00:13:38.213 - 00:14:17.205, Speaker B: In the command line, add the NG New command Before running this command, it's considered good practice to check out the available options for a new command. In addition, we should verify we're not missing important details about this command. Otherwise, we may break our application. We can view information about a specific command by adding the Help option. The Help option can be applied to sub commands, too. It's important to add the two dashes. To understand why, let's scroll to the top of this long list of options.
00:14:17.205 - 00:14:52.245, Speaker B: The new command requires us to give our app a name. For this reason, we need to add the two dashes to the Help option. If we didn't add these characters, the CLI would have assumed the name of our app is Help instead of giving us information about the command. As for the other options, they're entirely optional. We don't need to include these options. Unless we want to alter the default installation of a new project, we won't need these commands, but it's always good to know what our options are. Let's create a new project.
00:14:52.245 - 00:15:24.947, Speaker B: In the command line, we will run the NG new command again. This time, we will give our app a name. The name of our app will be called Angular Basics. After running this command, the CLI will ask us a series of questions about our project. These are options to customize the project further. The first question asked by the CLI will be our CSS preference. If you're familiar with SAS or less, feel free to choose these options.
00:15:24.947 - 00:15:57.545, Speaker B: We won't be using either of these languages, Plain CSS will work for our purposes. The next question is asking us if we would like to enable server side rendering or static site generation. These topics are interesting to explore, but not something we'll be diving into. For this section of the course, select no. After selecting our options, the CLI will begin creating our project. It'll scaffold files and install a few packages. This process may take a while.
00:15:57.545 - 00:16:26.515, Speaker B: The project has been successfully installed. During the installation, you may have gotten the following LF will be replaced by crlf. If you did, it's safe to ignore this warning. It's a formatting issue that the CL line will resolve for you. Let's look at our new project. In the file tree, we will find a new folder called Basics. It holds the same name we inputted in the command line.
00:16:26.515 - 00:17:07.937, Speaker B: Taking a peek inside, there are dozens of files. It can feel overwhelming, but we will walk through these files in an upcoming lecture. Before moving further, let's test if the application is working. First, I'm going to quickly move into this folder with my editor. After moving into the folder, we can start the server. Let's explore how to start the server in the next lecture. In this lecture, we're going to start the server for our application.
00:17:07.937 - 00:17:34.777, Speaker B: Angular will provide us with a development server to locally preview our app in the browser. It's important to note that this server is for development purposes. It's not suitable for production. You may be questioning why we need a server in the first place. Ultimately, Angular is a front end framework. A server is optional. We can open files directly in the browser without a server delivering files.
00:17:34.777 - 00:18:06.961, Speaker B: However, it will be incredibly helpful when we start developing the master project for this course. Browsers impose limitations on applications open directly in the browser. We won't be able to make requests, upload files, or add progressive web app features. Therefore, it is better to serve an app with a server. We don't have time to code a server, nor do we want to pay for one. Luckily, we don't have to. Angular provides us with a server that works on our local machines.
00:18:06.961 - 00:18:32.545, Speaker B: Only we have access to this server. Other developers won't be able to see what we're working on, which is fine during the development stages of an app. The server has other features. It can monitor our files for changes. If we change a single line of code, the app in the browser will refresh. It's a time saver from having to do so ourselves. This process happens lightning fast.
00:18:32.545 - 00:18:52.325, Speaker B: It comes with additional tooling for debugging an App. The best part? We don't need to configure the server. It works out of the box. This lets us focus on developing the application. There is one downside to the server. It's not meant for production. It can work well for one to a few developers.
00:18:52.325 - 00:19:20.555, Speaker B: Once we start receiving significant traffic, it won't scale as well. In a future section, we we will look at our options for servers when deploying our app. For now, the development server will work for our purposes. We can start the server with the cli. Let's turn it on. Be sure that you're inside your Projects directory. The command will search for a valid Angular project before turning on the server.
00:19:20.555 - 00:20:00.811, Speaker B: Inside the command line, we will type the NG serve command. In some tutorials, some developers will recommend starting the server with the NPM start command instead of the NG serve command. Both commands are 100% identical behind the scenes. The npm start command will run the ngserve command. Feel free to use either one. Before running this command, let's check out additional information about it and the help option. Once again, we're presented with an exhaustive list of options.
00:20:00.811 - 00:20:27.725, Speaker B: We can modify the port, enable ssl, or target a specific browser. We don't need to provide this command with additional information. We can run it as is. Let's run the command without the help option. After a few moments, we we're presented with information about the server. The most important piece of info is the URL to the app. Let's check out the app in the browser.
00:20:27.725 - 00:20:52.861, Speaker B: Congrats. We've got a functioning Angular app. You may see something slightly different than me. The default start page usually changes in future versions of Angular. Regardless, the app should be viewable in the browser. If everything works, we can view the app via a URL called localhost. Localhost is a special domain that points to your machine.
00:20:52.861 - 00:21:25.439, Speaker B: The browser will know to send the request to your machine. Where Angular's development server will intercept the request, it'll send back the page we see in the browser. Alternatively, the app can be visited with the IP 127.0.0.1. Either URL works after the domain, we have a port. The port is written with a colon followed by the port number. You can think of a port as a door to a house. Homes have multiple entrances.
00:21:25.439 - 00:21:49.731, Speaker B: In a similar sense, computers have numerous entrances. Programs can be assigned ports for accessing them. In our case, we are accessing the app via port 4200. Let's learn how to turn off the server. It's simple. Switch Back to the command line. We can terminate the server by pressing Control C on our keyboards.
00:21:49.731 - 00:22:25.485, Speaker B: If you're on a Mac, you can press Command C instead. Great. For the rest of this course, you should always have the server running. Unless I state otherwise. We've got everything we need to start writing an app. In the next lecture, we're going to explore the files generated by the cli. In this lecture, we're going to review the starter files generated by the Angular cli.
00:22:25.485 - 00:22:48.171, Speaker B: The CLI downloads dozens of files. It can be overwhelming deciding where to start. Therefore, I think a tour around the application will give us a good idea of where to start. This review won't be super comprehensive. It'll give you a general idea of what each file does. Let's begin. We're going to start with the root files.
00:22:48.171 - 00:23:17.073, Speaker B: The editor config file is a configuration file for editors. That can be surprising. Why would we need a file for configuring a text editor? It's for teams. If you're working on a team, chances are everyone will be using a different editor. Their editors may be configured differently than yours. This difference in configuration can lead to formatting issues during commitments. Most editors can detect the editor config file if present.
00:23:17.073 - 00:23:53.957, Speaker B: The configuration options in this file will override the current settings of the editor, thus saving us time from manually making the changes ourselves. In addition, it's a great way to keep formatting consistent across multiple editors. At the top of the file, there's a link to the documentation for various configuration options. If you're using Visual Studio code, the editor config plugin is not supported. You need to install a separate extension. Check out this link to download the extension. For this course, we're not going to be using this tool.
00:23:53.957 - 00:24:24.975, Speaker B: It's OK to ignore it. The next file is called Gitignore. The Gitignore file will tell Git to ignore a list of files when performing commitments. Angular has adjusted this file to include files and folders that don't need to be committed. We won't be modifying this file. The next file is called Angular JSON. This file configures the workspace of our project.
00:24:24.975 - 00:24:51.819, Speaker B: We can change how Angular builds our project for production and development. Unlike the other files, I want to dive into the options of this file. I'm going to fold some of these options for readability. The first option is called Schema. The Schema option prevents us from making typos in this file. As you can see, this file is pretty big. Angular is very customizable.
00:24:51.819 - 00:25:19.521, Speaker B: However, Editing this file can lead to errors. If you make a typo, the schema points to a file with rules on how this file can be edited. So let's look at an example right below this option. There's an option to change the version if we make a typo, such as forgetting to type a letter. Visual Studio code immediately tells us of our error. Hover your mouse over this option. According to our editors, the option does not exist.
00:25:19.521 - 00:25:51.675, Speaker B: I'll revert the option its original name. This feature is incredibly helpful to reduce the likelihood of errors. Speaking of the version option, this option will contain the version of the configuration we are currently using. Version one of the configuration. If the Angular team decides to change how the configuration file is formatted, this value would be higher. Afterward, we have the new Project root option. Believe it or not, we can manage multiple Angular applications at once.
00:25:51.675 - 00:26:32.735, Speaker B: You may want to do this if you have a large app that needs to be broken down into several smaller apps. For example, you may have an application for customers and another for administrators. Code related to administrative actions shouldn't be loaded with customer actions. Both apps may feed into the same API, therefore they share a relationship. We can break this type of app into two apps. The new Project root option will be the name of the directory for hosting additional apps. For example, if we create a new project from within this Angular project, it'll be placed inside the Projects directory.
00:26:32.735 - 00:26:56.405, Speaker B: The next option is called Projects. It'll contain a list of projects currently registered with Angular. We've created one app so far, which is the Basics app. Inside this object, we'll have more configuration options for this specific project. We won't go over every one of them. It's not necessary. The most crucial option is called Architect.
00:26:56.405 - 00:27:32.317, Speaker B: I'm going to quickly minimize the children's properties. The Architect option contains a list of commands for building the project. Building is the process of compiling our code. For example, we need to build our TypeScript code into JavaScript code if we want to run our app in the browser. Angular needs to build our project differently based on what we plan on doing with the app. If we want to develop the application, we will use the Serve command. If we want to ship our app to production, we would use the Build command.
00:27:32.317 - 00:28:04.691, Speaker B: As you can probably tell, each of these objects correlate to a command in the cli. These commands will build the project differently. If we want to configure the building process, we can do so through the respective option. The Build command will build the project for production. The Serve command will build the project for development. The extract I18N command will extract translations from a project. Lastly, the Test command will build the project.
00:28:04.691 - 00:28:32.451, Speaker B: For testing. We aren't going to be running through every command provided by Angular. However, it's always good to know where you can modify the behavior of a command. There isn't anything else worth mentioning, so let's move on to the next file in our project. The next file is called package JSON. You should already be familiar with this file. It contains a list of dependencies for our project.
00:28:32.451 - 00:29:06.947, Speaker B: If we look inside the Scripts object, we'll find some commands for starting and building the project. As I've mentioned before, the Start command runs the NG Serve command. Behind the scenes, they both turn on the development server. The next files are the TypeScript configuration files. There are three configuration files. They're the tsconfig app JSON, tsconfig.JSON, and tsconfig spec.JSON
00:29:06.947 - 00:29:40.307, Speaker B: files. It feels redundant to have various configuration files for TypeScript. However, they do serve a purpose. The tsconfig app JSON file runs when we're compiling our application, whereas the Spec file runs for tests. Both files extend the tsconfig JSON file. If we look inside either file, we'll find a property called Extends. The Extends option allows us to import settings from another file.
00:29:40.307 - 00:30:12.885, Speaker B: As you can see, these files import the TSCONFIG JSON file as a base. If there are conflicting settings, the file importing the configuration file will have priority. We aren't going to be modifying the TypeScript configuration for this project. It's been optimized for Angular that wraps up the files in the root directory. You may have noticed one thing about the files in this directory. They're all configuration files. Not a single file contains code for the actual application.
00:30:12.885 - 00:30:47.949, Speaker B: It's because the application code can be found inside the source directory. The CLI will compile the code inside this directory. We're going to start exploring the code in this directory in the next lecture. I'll see you there. In this lecture, we're going to briefly talk about the main entry file. Every application has one. It's the first file in our application to run.
00:30:47.949 - 00:31:16.425, Speaker B: Therefore, it's the most critical file in the entire application. There are two responsibilities the main entry file has. First, it needs to load the Angular framework. Our app won't be able to function correctly without Angular. The second responsibility is to load our app's code. It's important we load Angular before loading our app. The main entry file can be found inside the source directory.
00:31:16.425 - 00:31:51.205, Speaker B: It's called Main ts the code inside this file is already performing these steps for loading Angular and our application. Regardless, I think it would be a good idea to write the code for this file. This way we can genuinely understand why Angular has decided to write this code for us. Let's empty out the entire file. Our app will temporarily be broken. That's to be expected since we removed the entire file. Let's check out the browser.
00:31:51.205 - 00:32:35.513, Speaker B: The page is completely blank. Perfect. In the next lecture, we're going to start rewriting the file to get a better understanding of what's going on when Angular starts our app. In this lecture, we're going to talk about the compilation strategy Angular uses to compile our app. We talked about how we need to load Angular's code in the main entry file. It's the first step we must take. But what exactly are we loading? Why do we need to load Angular first? To answer this question, we need to talk about compilation.
00:32:35.513 - 00:33:05.589, Speaker B: Compilation is common in every programming language. It's the process of transforming human readable code into machine code. This is not always true. For example, TypeScript is compiled into JavaScript. Both languages are human readable. Compilation is a very broad term for transforming code from one language to another. So why am I bringing up compilation? Browsers do not understand the inner mechanics of an Angular app.
00:33:05.589 - 00:33:35.921, Speaker B: There are features in Angular not understood by the browser. These features need to be compiled. A new problem arises with this step in the process. When do we compile our code? That's a very important question. It can impact the performance of an app. Angular provides two compilation strategies called Just in time compilation and Ahead of time compilation. Both strategies will compile our code from TypeScript to JavaScript.
00:33:35.921 - 00:34:03.465, Speaker B: It's not a difference of what, but when. Let's dive into Just in Time compilation first. This strategy will compile our code in the browser. The browser will compile our code when the files are downloaded in the browser. Let's look at how this works. First, the server will compile our TypeScript code. This process happens regardless if we're using Just in time or Ahead of time compilation.
00:34:03.465 - 00:34:33.799, Speaker B: Once that's finished, the browser will download our code. This includes the compiler, which is very big. There's a lot of code that needs to be processed. The browser doesn't understand features like templates, services and modules. These are features we will be exploring in a future lecture. Angular needs to take the time to help the browser understand these features. After compilation is complete, the browser will finally be able to run our app.
00:34:33.799 - 00:34:58.455, Speaker B: It's a complicated process. We don't need to understand how it works underneath. Having a high level overview will suffice. Let's look at the next strategy, which is ahead of time compilation. This strategy will compile our code on the server. This process has been moved from the browser to the server. All the browser needs to do is download the code.
00:34:58.455 - 00:35:29.259, Speaker B: Here's an overview of what happens. The CLI will compile our TypeScript code into JavaScript. After it's finished compiling our TypeScript code, it'll move on to compiling the templates, services and modules. After the compilation is complete, the browser will download the app. It'll be able to run the app immediately. The compiler doesn't get downloaded either. Both strategies are available in Angular.
00:35:29.259 - 00:35:57.615, Speaker B: Which should we use? Let's compare them side by side. The file size difference between both strategies is significant. With just in time compilation, the file size is large. It's because the app needs to be shipped with the compiler. It's almost half the size of the app itself. In comparison, the browser doesn't need to download the compiler with ahead of time compilation. This difference impacts performance.
00:35:57.615 - 00:36:27.253, Speaker B: Not only does the browser need to download the compiler, but it has run the compiler. Otherwise our app won't work. On the other hand, the app can run in the browser with AOT compilation. After it's finished downloading, it's much easier. Lastly, errors appear at different times. We won't spot an error until the app is running in the browser. With JIT compilation, AOT compilation will show the error in the command line.
00:36:27.253 - 00:37:03.091, Speaker B: As you can probably tell, there is one superior strategy. In most cases, we will want to use AOT compilation. So why does Angular include JIT compilation? AOT compilation is relatively new. In the beginning, JIT was the only option we had. Somewhere around Angular 9, the team introduced the AOT compiler. It slowly became the default compiler for production and development builds. The JIT compiler is kept around for those who are still running on the old compiler.
00:37:03.091 - 00:37:51.593, Speaker B: However, it's recommended we always use AOT compilation. For the rest of this course, we're going to be using AOT compilation. Let's start applying this knowledge in the next lecture. In this lecture, we're going to bootstrap our application with the help of Angular. In an earlier lecture, we talked about how Angular needs to load first before our application's code. Otherwise our app won't work. But how do we guarantee that? And how do we make sure every part of Angular is loaded? Luckily, this process is easy because Angular provides a function that takes care of all those problems.
00:37:51.593 - 00:38:23.411, Speaker B: First, we must decide on A platform Angular is an agnostic framework. We can run it on browsers, mobile devices, and on the desktop. The dev team designed Angular to run on various environments. A platform is a word to describe the environment Angular will run on. Before we initialize our app, we need to provide a platform. The job of the platform is to help Angular understand the environments. We will be working inside the main TS file.
00:38:23.411 - 00:39:04.231, Speaker B: Previously, we emptied it out. As we discussed before, we need to load a platform before loading Angular. For this course, we're going to develop apps for the browser. Angular comes with a function for loading an Angular application in the browser. At the top of the file, import a function called bootstrapapplication from a package called Angular Platform Browser. Let's call it below the import statement. As you might suspect, the platform browser package contains code related to setting up an application inside a browser.
00:39:04.231 - 00:39:48.441, Speaker B: The function we're importing will make sure Angular's code loads before our app's code. All we have to do is call it. When calling this function, we must provide a component. Components are a feature in Angular for teaching the browser a new HTML tag. It's important that you understand this concept, as we'll be using Components heavily throughout the course. I won't go into any more details because we'll be digging deeper into components in a future lecture. For now, you can think of a component as a custom HTML element, so why does this matter? A component is required to bootstrap an application.
00:39:48.441 - 00:40:21.543, Speaker B: Behind the scenes, Angular is going to inject this component into our browser. We haven't created a component. Luckily, the default project provides us with a component in the source directory. Components are organized into folders. The component defined by CLI is called Application. If you look inside this folder, you're going to find a few files, which can feel overwhelming. The only file you should care about is the one ending with the component TS extension.
00:40:21.543 - 00:40:59.277, Speaker B: This is always considered the brain of a component. Upon opening this file, you're going to find quite a few lines of code, which we'll be digging into in a future lecture. Let's go back to our main TS file at the top. Import the App component variable from the app slash App component TS file. The app component variable is what's exported by this file. Next, pass this variable onto our function. The component we've loaded will be loaded on our browser.
00:40:59.277 - 00:41:28.381, Speaker B: There's one last step. The Bootstrap application function returns a promise. You can hover your mouse over this function for the function's return value. As you Learned from the TypeScript section, the code written after the parameter list is the way we can specify the return values type. Based on that information, we're told our function returns a promise. We don't need to deal with a response. However, we should make sure we aren't given errors.
00:41:28.381 - 00:41:57.167, Speaker B: Logging errors into the browser's console will be helpful for debugging. Let's chain the catch function. We will pass in an arrow function with an argument to accept the error message. Lastly, we will log the error message with the console error function. We're finished. Let's check if our app is working in the browser. Great.
00:41:57.167 - 00:42:19.059, Speaker B: We've got the same functioning app we had before. We're finished working on the main TS file. Hold on a moment. Wasn't there more code than what we've written? You're absolutely right. Here's the original file code. It's a bit different than what we've written. So what's the big idea? The additional code is for enabling routing.
00:42:19.059 - 00:42:46.517, Speaker B: At the moment, we're focused on learning the basics of Angular. Routing is a feature that's ahead of where we're at. Don't worry, this course definitely covers routing. It's just not something we need right now. For that reason, we're not going to bother looking at the code for configuring the router when it comes time to talk about routing. We'll go back to our main TS file to explore the configuration. That's all I wanted to mention.
00:42:46.517 - 00:43:23.505, Speaker B: In the next lecture, let's look at one more thing before getting into components. In this lecture, we're going to learn about components. They're a central core feature in the angular framework. I'm 100% positive you will be working with components the most in an Angular app. So let's jump into it. We can think of components as custom HTML tags. The browser has dozens of tags.
00:43:23.505 - 00:43:52.313, Speaker B: Some of them are basic for rendering text. For example, paragraph, div, and span tags will render basic text. There are other tags with complex behavior. The form button and input tags are some examples. We have a wide range of tags available. In some cases, we will need to teach the browser new tags. We may want to create a tag for displaying products, users, modals, etc.
00:43:52.313 - 00:44:28.945, Speaker B: If we teach the browser new tags, we can reuse them. That's where components come into play. Angular makes it extremely easy to teach new tags to the browser. We have complete control over the behavior of the components we create. This behavior can range from rendering text to authenticating users. We can even render other components. Angular will supply us with a custom component in the default project, we can find a file called App Component ts under the Source App directory.
00:44:28.945 - 00:44:57.345, Speaker B: The file name for a component has the Component TS extension. It's not a required name, but common practice. We will follow this practice throughout the course. It helps developers identify this file as a component. When opening this file, we're going to be greeted with a lot of code. Let's do what we did last time. We're going to remove everything from this file.
00:44:57.345 - 00:45:46.275, Speaker B: We will begin the process of recreating this file in the next lecture. In this lecture, we're going to create our first component. Angular needs at least one component to run. When we created our project, Angular provided us with a component called Application. We will be working inside the App Component TS file. Inside this file, we will export a class called AppComponent. Next, we will need to import a decorator called Component from the Angular core package.
00:45:46.275 - 00:46:20.185, Speaker B: Angular mainly uses classes for creating components. If you're familiar with the concept of components from other frameworks, it may feel awkward. Because most frameworks use functions. Components are not the only thing created with classes. A lot of features in Angular require classes. For this reason, Angular doesn't know the purpose of our class. Is it for a component, service module, or pipe? To help Angular understand our classes, we can apply decorators.
00:46:20.185 - 00:46:53.589, Speaker B: Decorators simply tell the compiler what kind of class we're creating. Let's apply this decorator to our class. We need to configure the component by passing in an object to the decorator. There are three required options for a component. First, we must provide a selector. Add this option with the following value. The value for the selector option is a custom tag name for our component.
00:46:53.589 - 00:47:25.489, Speaker B: The name of the tag must be a valid CSS selector value. We can't use spaces or special characters in the name. Aside from a dash, the name should be all lowercase with dashes to separate words. We want to be consistent with other HTML tags. We can't override other HTML tags, otherwise the browser will get confused. We should have unique and custom names. The next option we will add is called Template.
00:47:25.489 - 00:47:59.825, Speaker B: Its value will be a template string. The template option can contain the HTML markup for our component. We can add whatever we want. For this example, we're going to add a pair of paragraph tags with some text. The last option we must add is called Standalone with a value of true. Components can be grouped with another feature from Angular called Modules. We're not using modules, which can be a bit of an issue.
00:47:59.825 - 00:48:33.475, Speaker B: By default, Angular assumes we're using modules to tell it we're not using modules, we can set the standalone option to true. If you've worked with Angular before, you may be used to modules. The idea of standalone components is a recently new development. Angular is starting to lean away from modules. For that reason, we're going to use standalone components to build our applications. So we'll always add this option to our components. We've created our first component.
00:48:33.475 - 00:49:04.727, Speaker B: Let's take a look at the main TS file. We're passing in this component to our bootstrap function. The browser will be able to understand how to render the component. We're only allowed to pass in one component, which will be considered the root component. The root component is responsible for loading other components. When we create more components in the future, they'll be loaded through our app component. That's the only way we can add them.
00:49:04.727 - 00:49:41.487, Speaker B: Since the bootstrap function only accepts a single component, there's one last step we need to take. In the source directory, open the index HTML file. The index file is a standard HTML file. The index HTML file is the file running in the browser. When we view the app, you'll notice there aren't script tags. The development server will automatically inject our app into this file when delivering it to the browser. It does not need to be manually included in the document.
00:49:41.487 - 00:50:10.531, Speaker B: There's nothing special about it besides this one line. Inside the body tag. Inside the body tag, we're loading the app root components. Using components is similar to using any other HTML tag. It's the name of the tag surrounded by angle brackets. Components have opening and closing tags. During initialization, Angular will insert the content of the component inside this tag.
00:50:10.531 - 00:50:32.515, Speaker B: We have complete freedom over where our app is placed. We won't be doing anything with the tags. We'll leave them be. Let's check out the browser. The app is entirely different from before. It's not rendering the page we had in the default project. It's cause of the template we had in the component.
00:50:32.515 - 00:50:56.825, Speaker B: The code from the template option gets rendered on the browser. Mission accomplished. We've successfully created and loaded our first component. Everything is starting to come together. We're almost at the home stretch. In the last few lectures, we're going to explore the last few files. By the end, we will have recreated the default project.
00:50:56.825 - 00:51:45.077, Speaker B: Let's continue in the next lecture. In this lecture, we will look at how to further organize a component. By splitting our component into different files, we can centralize everything in one file. The business logic, HTML and CSS can be written in a single file. However, this Approach may not be the best way to write a component. Before we dive into splitting our code into files, I think this would be an excellent opportunity to talk about the MVC pattern. The MVC pattern is popular among programming languages.
00:51:45.077 - 00:52:13.801, Speaker B: It's especially popular with convention over configuration frameworks. It stands for Model View Controller. It's a pattern for how an app should be structured. This pattern can be applied to our components. The words in MVC describe each piece of a component. It sounds complicated, but it's not. Once you know what each word is describing, the word model refers to the data in a component.
00:52:13.801 - 00:52:42.585, Speaker B: For example, let's say a component renders the user's profile information. The data for the user can be considered the model. If we're rendering a list of blog posts, the blog posts would be regarded as the model. The model can feed and manage data for a component. The word view refers to HTML and css. It's the appearance of the component that's pretty much it. It's self explanatory.
00:52:42.585 - 00:53:13.857, Speaker B: Lastly, the word controller refers to the business logic of the component. The responsibility of the controller is to manage the view and model. The controller will ask the model for data. It'll then give the data to the view. If the view changes the data like a form submission, the controller will provide the updated data to the model. You can think of it as the middleman between the model and view. It controls the logic of the component.
00:53:13.857 - 00:53:53.433, Speaker B: In Angular, the controller code would be written in the methods of a component class. Angular makes it extremely easy to break our components into separate files. We are going to continue working inside the app component file. At the moment, we're writing the template in the component class. Thus, we're not applying the MVC pattern inside the configuration object. We're going to add a property called Template URL. The template URL property can be added to point to an external HTML file.
00:53:53.433 - 00:54:28.445, Speaker B: This file will act as the template for the component. Typically, the value for this property is an HTML file. Conveniently, the default project comes with a template file for our component. In the Source App directory we have a file called App Component HTML. There's a lot of code in this file. We don't need to keep it around. The comment at the top says the the content below is only a placeholder and can be replaced.
00:54:28.445 - 00:55:11.947, Speaker B: Delete the template below to get started with your project, let's completely delete this template. Next, let's add a pair of paragraph tags with a message same as before. It's time to load this file back in the component Class. We're going to set the template URL property to the app.component.HTML the. And slash characters will tell Angular to search for the template in the same directory as the class. Before we check out the browser, let's learn how to dynamically add styles to a component.
00:55:11.947 - 00:55:40.189, Speaker B: In the configuration object, we will add a property called StyleURLs. The value for this property is an array. We can apply multiple stylesheets to a component. The array must contain a string of paths to the style sheets. Like before. The default project comes with a style sheet for the app component. It's called app.component
00:55:40.189 - 00:56:11.845, Speaker B: CSS. This file will be empty. Let's change the paragraph element to the color orange. We're changing the element to test if the style sheet works back in the component. We will add the app component CSS file to the style URLs array. Alternatively, we can add a property called Styles to the component configuration. It's also an array of styles.
00:56:11.845 - 00:56:44.211, Speaker B: The array can contain multiple inline styles. We're not going to be applying inline styles. We're going to comment out the template and styles properties. We can't use the template and templateUrl property at the same time. We must use one or the other. The same rule applies to the Style URLs and Styles properties. Angular will throw an error if we try to add both properties.
00:56:44.211 - 00:57:06.615, Speaker B: Let's refresh the page in the browser. Ta da. We've got a functioning component. It displays the message where the text color is orange. We've separated the HTML from the component class. Another way of saying it is separating the view from the controller. We haven't had the opportunity to discuss how to create models.
00:57:06.615 - 00:57:47.577, Speaker B: This topic will be discussed in a future section. We're mainly going to be focusing on the controller and view. In the next lecture, we will wrap this section up. In this lecture, we're going to review the last few files in the source directory. We've gone over the most critical topics in this section. The rest of the files will either be revisited or briefly discussed in this lecture. Let's begin in the Source directory, create a folder called Assets.
00:57:47.577 - 00:58:23.791, Speaker B: The Assets folder can store static asset files. As we discussed before, the Angular CLI will process the files in our project. However, there's one exception to this rule. The files stored in the Assets directory will be copied over to the final build during compilation. This directory is perfect for storing images, fonts, or any other static file you want to be included in your project. It's not a directory for storing css. Instead, we should store CSS in a component's respective stylesheet file.
00:58:23.791 - 00:58:52.859, Speaker B: The following file in the list is the Styles CSS file. Initially, this file will be empty. It's where we can add global styles to our app. Normally, you should add CSS to a component. However, if you need to apply styles on a global level, you should add them here. With that being said, we're finished reviewing the default project. There's so much going on under the hood.
00:58:52.859 - 00:59:36.673, Speaker B: By running the NG new command, Angular generated this entire project. Thus, we have the bare minimum for starting an Angular project. In the next section, we're going to spend some time on components. Writing components is mostly what you're going to be doing during the development of an Angular app. Apps are mostly built with components. When you're ready, I'll see you in the next section. In this section, we're going to learn about TypeScript TypeScript is a programming language primarily used with Angular.
00:59:36.673 - 01:00:03.901, Speaker B: It's completely optional to use TypeScript, however, I highly recommend learning it. A majority of projects, tutorials, and examples are written with TypeScript. It's hard to escape. So if you want to learn Angular, learning TypeScript is a must. If you already know TypeScript, feel free to skip this section of the course. I'm not going to be teaching anything groundbreaking. As long as you know the basics, you should be good to go.
01:00:03.901 - 01:00:35.497, Speaker B: Otherwise, let's learn TypeScript together. So what is TypeScript? TypeScript is a superset of JavaScript. It is a language built on top of the JavaScript language. If you know JavaScript, you know TypeScript. Features such as variables, conditional statements, and functions are written the same way in TypeScript. We don't need to learn an entirely new set of syntax rules for getting started. In fact, we can rename our files to TypeScript without modifying the original source code.
01:00:35.497 - 01:01:05.679, Speaker B: Our JavaScript code would still work. Instead, TypeScript adds features to improve the developer experience. Notice how I said developer experience. TypeScript doesn't add features for enhancing the performance or security of an app. Instead, it's a language designed to help developers debug and design their applications. It accomplishes this goal by introducing static typing to the language. As we know, data types are categories for our data.
01:01:05.679 - 01:01:29.963, Speaker B: We have strings, numbers, booleans, and objects. These are just some examples of data types. For the most part, we never have to worry about the data type of our variables. JavaScript is a dynamically typed language. We have the opportunity to change the data type of our variables at any point in our application. Here's an example. We have A variable called price.
01:01:29.963 - 01:01:55.133, Speaker B: The data type starts as a number. On line 2, the variable is updated to a string. Behind the scenes, the environment will change the data type on our behalf. It won't complain if we attempt to do something like this. This feature is convenient. It's one of the reasons why JavaScript is beginner friendly. While suitable, there are some pitfalls beginners can fall into in a large application.
01:01:55.133 - 01:02:21.927, Speaker B: Data is constantly flowing through different files, objects, and functions. Let's say we're developing a checkout system. The user will want the grand total for their purchase. However, before we present them with a total, we may want to run their purchase price through several functions. For example, what if they're using a coupon? We should apply the coupon to the price first. Not so fast. We need to calculate taxes.
01:02:21.927 - 01:02:49.301, Speaker B: Don't forget to add the cost of shipping during this entire process. The price will be passed around through a couple of functions. It's possible that the data type may change during this process. If it does, we may get unexpected behavior. Our functions assume the price will be a number. What if it changes to a string? JavaScript won't throw an error. It'll allow the data type to change even when we don't want it to.
01:02:49.301 - 01:03:20.849, Speaker B: We'll only find out if the data type changes by testing the app in the browser. Wouldn't it be convenient to catch this type of error in our code while writing it? That's possible with TypeScript. We'll get into TypeScript in a moment, but let's see how this error can happen in our script. I've prepared a little example. It's a single file called example js. In this example, I have a function called addshipping. It has two arguments called price and shipping.
01:03:20.849 - 01:03:47.555, Speaker B: The price argument refers to the price of the product. The shipping argument refers to the cost of shipping. Inside the function, we're logging the two arguments after they've been added together. The function should log a number below the function definition. We're calling this function with the numbers 10 and 5. Let's try running this script in the command line. I'll run the script with the following command.
01:03:47.555 - 01:04:21.609, Speaker B: As expected, we got 15. Perfect, right? What if we pass in a string instead of a number back in our file? I'll wrap the first number with some quotes. Next, I'll rerun the script. This time we got 105. If I were a customer, I'd be turned off by this calculation. This type of error occurred because of how we've written our code. We passed in a string when we meant to pass in a number.
01:04:21.609 - 01:05:06.507, Speaker B: TypeScript is designed to catch errors like these. It's a language that can check the data types of our variables. It's much stricter than JavaScript, but worth it. In the end, we can improve the developer experience by switching to TypeScript. Let's dive into TypeScript in the next lecture in this lecture, we're going to install a compiler for TypeScript. That sounds strange, doesn't it? Normally we would be able to write JavaScript right away. We wouldn't need to worry about compiling the code ourselves, since the browser will interpret our code for us.
01:05:06.507 - 01:05:36.737, Speaker B: However, it's a different story with TypeScript. Most browsers don't support TypeScript. Therefore, we need to compile our TypeScript code into JavaScript. After we've compiled it to JavaScript, we'll be able to run our code in the browser or node. Luckily, this process is painless. In the Resource section of this lecture, I provide a link to TypeScript. Everything you'd like to learn about TypeScript can be found here on this page.
01:05:36.737 - 01:06:02.197, Speaker B: It'll recommend some installation methods. TypeScript can be installed with NPM. Let's give it a try. Copy the command from the documentation inside the command line. I will paste and run the command. If you're on a Mac or Linux, you may need to add the sudo command before running it. It'll give you proper permissions for installing packages.
01:06:02.197 - 01:06:24.865, Speaker B: Otherwise, running the command as is will work fine. For this installation. I'm working in the same directory we were in in the last lecture. This installation should take a few seconds. We're installing TypeScript locally. We have the option of installing it globally, but but that won't be necessary. It's enough to have it installed locally.
01:06:24.865 - 01:07:01.331, Speaker B: After installing TypeScript, we can begin to write TypeScript code. The first step for writing TypeScript is to create a file. In our project, we're going to rename the example JS file by changing the extension to TS. TS is short for TypeScript. After changing the file type, we've written our first TypeScript file. As I've said before, TypeScript syntax is the exact same as JavaScript syntax. Every syntax feature from JavaScript is supported in TypeScript.
01:07:01.331 - 01:07:37.243, Speaker B: Therefore, we don't need to learn an entirely new set of syntax rules. After We've written our TypeScript code, the next step is to compile it into JavaScript. We can use the compiler we installed to help us with that step. In the command line, we can run TypeScript by adding the NPXT command. NPX is a command created by npm in the Node JS ecosystem. Some packages add commands to the command line. The NPX command allows us to run those commands that come from those packages.
01:07:37.243 - 01:08:14.465, Speaker B: For example, TSC is a command defined by the TypeScript package. NPM will take care of searching for the Command in the TypeScript package. After typing the command, we need to provide the file's name we want to compile from TypeScript to JavaScript. Let's pass in example TS. Afterward, we'll run the command. After a few moments, the command will finish running. So what happened? If we look in our project directory will find a new file has been generated called example js.
01:08:14.465 - 01:08:36.265, Speaker B: Let's take a look inside. We have the exact same code we had before. The problem we had before persisted. At this point, it doesn't feel like TypeScript isn't helping us. In the next couple of lectures, we're going to explore the syntax added by TypeScript. By doing so, we'll be able to fix our issue. I'll see you there.
01:08:36.265 - 01:09:14.813, Speaker B: In this lecture, we're going to explore a concept called type annotations. They're a new syntax feature available in TypeScript. To fix our problem, our function's argument should be constrained to numbers. If we attempt to pass in a string or boolean, an error should be thrown. We can implement this behavior with type annotations. Type annotations are a way to describe the data in our application. We can annotate almost anything in our code.
01:09:14.813 - 01:09:52.419, Speaker B: We can annotate variables, functions, arrays, and objects. Let's start with functions. In the add shipping function, we're going to annotate the function's parameters. We can annotate a parameter by adding a colon after the parameter name followed by the data type. For the price parameter, we're going to set the data type to number. We'll use the same type for the shipping parameter. By adding these annotations, TypeScript will restrict the type of values we can pass onto this function.
01:09:52.419 - 01:10:26.185, Speaker B: Notice how I'm using the lowercase version of the word. It's important that we type number with lowercase n instead of and uppercase n. Otherwise we may confuse the application with the data type. Let's see what happens when we attempt to compile our code. In the command line, run the NPXTSC example ts command, an error has been produced. The error is telling us we have a problem. On line five, it's saying we're passing in a string when it's expecting a number.
01:10:26.185 - 01:11:00.054, Speaker B: By adding annotations, we're able to catch Errors like these, we can think of type annotations as a way to document our code. The compiler will read our documented code and determine if we're doing something out of the ordinary. Let's fix this issue in the file. I'm going to remove the quotes from the first argument. After doing so, I'll compile the code again. This time our code gets compiled without a problem. Let's check out the JavaScript file.
01:11:00.054 - 01:11:33.365, Speaker B: The annotations we've added are gone. TypeScript will remove its features so that our code can run in the browser. The purpose of using TypeScript is to help us debug our application before running it in an environment. If the compiler can successfully compile our code, we should be safe from type errors. Imagine if we were building a checkout system. A checkout system involves a series of steps. We wouldn't be able to catch this error until after the user has provided their shipping information.
01:11:33.365 - 01:12:04.771, Speaker B: With TypeScript, we're able to catch the bug before opening the browser. That's the beauty of TypeScript. Let's take our example a step further. We can annotate the return values of a function. At the Moment, in the TypeScript file, we're logging a message in our function. Let's change this line to return the value. It would be nice if we could tell the compiler will always return a number after the function's parentheses.
01:12:04.771 - 01:12:39.185, Speaker B: But before the curly braces, we'll add a colon followed by the data type. In this example, we'll set the data type to number. The syntax for type annotation is the same syntax for adding type annotation to parameters. It's a colon followed by the name of the data type. This piece of code will tell TypeScript the function is only allowed to return numbers. Let's see what happens if we attempt to return a value with a different type. Inside the function, we will return a random string.
01:12:39.185 - 01:13:11.355, Speaker B: Next, in the command line, we'll try to compile the file. We get an error. It's telling us we're attempting to return a string instead of a number. Our editors also highlight this error. If you're using Visual Studio code like me, there will be a red squiggly line below the return statement. We can hover our mouse over this to read the same message. Let's fix this problem by reverting our changes to the original solution.
01:13:11.355 - 01:13:51.545, Speaker B: Next, we'll compile the script. The compiler successfully compiled our code. Let's check out the JavaScript file once again. The annotation has been removed from our code. It's a step performed by TypeScript that about wraps it up. In the next lecture, we'll continue exploring TypeScript. In this lecture, we're going to look at how to annotate variables.
01:13:51.545 - 01:14:27.465, Speaker B: For this demonstration, let's work inside a new file. I'll create a file called variables ts. Inside this file, we will create a variable called myname. We'll set this variable to a string. Variables can be annotated with the same syntax we used for annotating function arguments and return values. After the variable name, we will add a colon followed by the data type. Since we're storing a name, it makes sense to set the data type to string.
01:14:27.465 - 01:15:06.275, Speaker B: It's as simple as that. You may be wondering what types can we use in type annotation? Every primitive type is supported in type scripts. I'll add a comment above to list them. The following types are string, number, boolean, null, and undefined. By annotating variables, we can't reassign the variable to a different type. If we ever reassign the variable, the value must be of the same type. For example, if we were to update the MyName variable to a number, we would encounter an error.
01:15:06.275 - 01:15:43.045, Speaker B: If we hover our mouse over the reassignment, we will get an error telling us we can't use a number. This is because we're restricted to strings. If we were to change the value to another string, the error goes away. One of the cool things about TypeScript is type inference. Admittedly, adding type annotations can make our code seem cluttered. They're incredibly helpful, but we should take every opportunity to make our code simple and clean. TypeScript is intelligent to detect the data types of our variables.
01:15:43.045 - 01:16:18.277, Speaker B: This feature is called type inference. Let's remove the type annotation from the variable. Even though we have removed the annotation, TypeScript will set the variable's data type to a string. If we hover our mouse over the variable name, the editor will tell us the type is set to string. How is this possible? It's because of our value. If a variable is initialized with a value, TypeScript will infer the type based on the value. In this example, we're setting the my name variable to a string.
01:16:18.277 - 01:16:51.727, Speaker B: Therefore, TypeScript will infer the variable is a string below. If we were to set the variable to a number, we would get the same error as before. This feature is incredibly convenient. We should always take advantage of this feature whenever we can. It's redundant to set the type if TypeScript is capable of inferring the type for us. For the rest of this course, if TypeScript can infer the type, we will let it set the type. There are some limitations.
01:16:51.727 - 01:17:30.355, Speaker B: Firstly, it only works if the variable is initialized with a value. If we were to omit the value, TypeScript would not infer the data type. For example, if we remove the value and then hover our mouse over the name, the type is set to any. The Any type is given to a variable. When TypeScript isn't sure what data type to use, it allows for a variable to store any type of value. We can store numbers, strings, objects, etc. If we were to switch between different data types, TypeScript wouldn't throw an error.
01:17:30.355 - 01:18:04.845, Speaker B: To be clear, this data type is exclusive to TypeScript. In some cases, you may want this behavior. However, most of the time we want to be strict with our data types. I'll revert this variable to its original value. The second limitation we should be aware of is that this feature is not available to function parameters. Let's switch over to the example TS file for a moment. Next, we will remove the type annotations from the parameters.
01:18:04.845 - 01:18:45.059, Speaker B: After removing them, TypeScript will annotate both parameters with the Any type. Even though we're passing in numbers, TypeScript still doesn't know what data type the parameter should be. I'll add the annotations back to the function. That's about it for variables. We'll continue in the next one. In this lecture, we're going to learn about a feature called Union Types. They give us more flexibility with annotating data.
01:18:45.059 - 01:19:25.577, Speaker B: We've seen how TypeScript can restrict the type of a variable, either by explicitly setting the Type or letting JavaScript infer the type. Up until now, we've been stuck with a single type. What if we want to allow multiple types? For example, we may want to retrieve the name from an API. The initial value for the name may be null until the API request is complete. After receiving a response, we'll update the variable to a string. In this scenario, we would get an error because TypeScript will not allow the data type to change. One solution would be to add the Any type.
01:19:25.577 - 01:19:58.359, Speaker B: The Any type is a custom type by type script. You can think of it as a get out of jail free card. We aren't restricted to a specific data type with this type. Unfortunately, we miss out on the benefits TypeScript brings to the table. There wouldn't be a point in using TypeScript. That doesn't mean you should never use the Any type. It should be considered as a last resort option that Leads us to the question, what alternative solution is there? We can add union types.
01:19:58.359 - 01:20:39.383, Speaker B: A union type is when multiple data types are given to a variable, excluding the any type on our variable. Instead of letting TypeScript infer the type, we can add the string data type back in. We can add more data types by separating them with a pipe character. After the pipe character, we will add the null data type. We can add as many data types as we'd like. After adding the data type, let's try changing the variable to null. As expected, TypeScript doesn't throw an error.
01:20:39.383 - 01:21:11.447, Speaker B: If we want to use multiple data types, we must add the types to the variable. TypeScript will not infer union types. It's up to us to add them in. Otherwise we may be restricted to one data type. One advantage of union types is being able to use them anywhere we can add them to functions, return values, arrays, and objects. We're not limited to adding union types to variables. For example, let's switch over to the example TS file.
01:21:11.447 - 01:21:37.775, Speaker B: It's possible the shipping function may fail. We may want to return a boolean value for the developer to handle the error. If it does. As of now, we're limited to returning numbers. If we want to return numbers and booleans, we'll need to add a union type. We'll update the function by adding the pipe character after the number return type. Next, we'll add the boolean type to the list of types.
01:21:37.775 - 01:22:23.307, Speaker B: Just like that, we'll be able to return either a number or boolean from the function. Union types are powerful because of the flexibility they provide. Let's continue in the next lecture. In this lecture, we're going to learn how to annotate arrays and objects. Up until now, we've been focused on primitive types and functions. It's time to shift our focus to more complex types. The syntax for annotating arrays and objects is similar to annotating anything else in TypeScript.
01:22:23.307 - 01:23:16.151, Speaker B: In our file, let's add a section for this demonstration, we will create an array called items with some string values. If we define an array with some values, TypeScript will infer the type of our array. According to our editor, TypeScript is inferring the array will store strings. That's great, but what if we wanted to initialize an empty array? If our array were empty, type inference wouldn't work. By removing the items in the array, the type of the array has been set to any. In that case, we can explicitly annotate the array like we would any other variable. After the name of the variable we'll add a colon followed by the type of values the array will store.
01:23:16.151 - 01:23:42.805, Speaker B: Finally, we'll set the type to string. Despite setting the type, we'll get an error. The error will tell us the value is invalid. The problem is how we've annotated the variable. There's one extribute of code we need to add. After the type, we'll add a pair of square brackets. By adding the square brackets, TypeScript will assume the array will be filled with strings.
01:23:42.805 - 01:24:22.905, Speaker B: We can take this a step further by adding union types. If we need to store an array of different types of values, we can add a union type we will add onto the annotation by including the number type. There's one important note I want to add. The square brackets are being added to both types. If we didn't include the square brackets to the number type, TypeScript would not allow us to store an array of numbers. Instead, it'll think the variable can hold an array of strings or a single number. Therefore, these square brackets must be applied to both types.
01:24:22.905 - 01:24:51.351, Speaker B: One last thing. TypeScript can infer union types. For example, we can get the same union type if the array is filled with strings and numbers. So let's remove the annotation. Next, let's add a number and string to the array. The array stores two types. If we hover our mouse over the variable, the editor will tell us we have a union type.
01:24:51.351 - 01:25:29.267, Speaker B: That's very convenient. We don't have to worry about TypeScript accidentally adding the any type which we should avoid. Let's move on to objects in the following lecture. In this lecture, we're going to look at how to apply types to an object. Working with objects in TypeScript is interesting. We can add optional properties, interfaces, and work with nested structures. Let's take it one step at a time.
01:25:29.267 - 01:26:00.173, Speaker B: Below the array, we will add an object called Account. The account object will represent a bank account. We'll keep it simple by adding two properties called name and balance. The name property has a string value. The balance property has a number value. We haven't annotated the object. Luckily, type inference kicks in since we're initializing the object with some values.
01:26:00.173 - 01:26:44.645, Speaker B: If we hover our mouse over the object, TypeScript will correctly infer the types of our properties. It's also possible to explicitly define the types for an object. After the variable name, let's add a colon followed by a pair of square brackets. The syntax for annotating an object is similar to creating an object itself. The annotation should be an object with a list of properties that can be found within the object. If we decide to annotate properties in our object explicitly, we must set a type for every property. If there's a property inside our object that's not annotated, TypeScript will throw an error.
01:26:44.645 - 01:27:18.705, Speaker B: Inside this object, we'll add the name and balance properties. They'll be set to string and number, respectively. In some scenarios, you may want to make a property optional. For example, let's say we had a property called status. The type for this property will be set to string. After adding this type, an error is thrown by TypeScript. Taking a closer look at the error, it's telling us the status type is missing from the object.
01:27:18.705 - 01:27:55.379, Speaker B: It's possible we may want to add this property at a later point in our application. We can get around this error without adding the property in our object by making it optional. In the annotation object, we will add a question mark symbol. After the status property, we're adding the symbol to the annotation. It's not being applied to the value itself. It can be confusing with this syntax since the annotation and value are formatted the same. After adding the symbol, the error has disappeared.
01:27:55.379 - 01:28:26.595, Speaker B: Great. Before I end this lecture, there's one more thing I want to mention. It's not uncommon to have to combine arrays and objects. For example, instead of a single account, we may need to work with multiple accounts. Below this variable, we will declare another variable called accounts. For the sake of simplicity, it won't have a value. We will annotate this variable by adding curly braces followed by a pair of square brackets.
01:28:26.595 - 01:29:07.479, Speaker B: This Syntax will tell TypeScript the variable will store an array of objects. That's all there is to it. In the next lecture, we will look at how we can clean this up by using interfaces. In this lecture, we're going to look at how we can use interfaces to make our objects more readable. The syntax for annotating an object kind of looks ugly and messy. I'm not a huge fan of it. We have two objects being annotated.
01:29:07.479 - 01:29:39.499, Speaker B: Let's clean this up by using an interface. An Interface is a TypeScript specific feature for creating types for objects. It's an alternative syntax to what we're currently doing. Let's explore how an interface is created. Hopefully, once we've written an interface, it'll become clear why you may want to use them. Above the objects, we will type the interface keyword. The interface keyword allows us to create a custom type for an object.
01:29:39.499 - 01:30:11.815, Speaker B: Instead of directly adding the Types on the variable. We can extract the types to an interface. After typing the interface, we need to provide a name. While not required, most developers like to use Pascal casing for their interface names. In addition, some developers will add a capital I at the beginning of their name, which is short for interface. It helps other developers identify this as an interface. For this example, we will set the name to iaccount.
01:30:11.815 - 01:30:37.295, Speaker B: Next, we can add the types for the object. We've already done so. Below. We will cut and paste the object annotation from the account variable. A couple of things worth mentioning the interface cannot hold values. Interfaces are not a replacement for objects. They're a feature for helping us outsource the typing of an object.
01:30:37.295 - 01:31:12.453, Speaker B: Another thing worth mentioning is that they don't get compiled into JavaScript. When we compile our code, the interface will be completely absent from our JavaScript file. Similar to how primitive types are removed from variables, interfaces get removed too. Let's make our interface more interesting. Objects can have methods, so let's add a method. The method will be called deposit. It's completely acceptable to add methods, but there's one thing to keep in mind.
01:31:12.453 - 01:31:37.943, Speaker B: We can't have business logic in our method. It's up to the object to implement the business logic. However, we can add the parameters and return type. For this example, we won't have parameters. The return type will be void. The void type is a special type for functions. Sometimes you may not want to return a value from your function.
01:31:37.943 - 01:32:11.293, Speaker B: If that's the case, you can annotate a function with the void type, which means no return value. One last thing. We will make this method optional. Let's use our interface. We can apply the interface after the name of the variable. Instead of adding an object, we can pass in the name of the interface, we have another variable called accounts, which is basically an array of accounts. It would make sense to apply the interface here too.
01:32:11.293 - 01:32:51.229, Speaker B: We will replace the object with the name of the interface. The square brackets can remain. This syntax will tell TypeScript we will have an array of accounts by using an interface. Our code looks so much cleaner. I recommend using interfaces whenever working with objects. In the next lecture, we'll look at an alternative syntax for creating objects. In this lecture, we're going to learn about classes.
01:32:51.229 - 01:33:18.885, Speaker B: You should already have an idea of how classes work in JavaScript. Classes in TypeScript work the same way. However, there are some additional features worth mentioning. Let's go through them one by one. First, let's create a class. Below the objects, we will define a class called investment Account at the end of the day. Classes are blueprints for objects.
01:33:18.885 - 01:33:47.449, Speaker B: We can add interfaces to them. The syntax is slightly different. After the class name, we need to type the implements keyword. This keyword will tell TypeScript we're trying to add an interface to the class. We can follow this keyword with the name of the interface. We'll set the interface to iaccount. After adding the interface, our editor will throw an error at us.
01:33:47.449 - 01:34:20.421, Speaker B: It's telling us we need to implement the properties and methods required by our interface. Let's try adding them in. There are two required properties, which are name and balance. It's optional to initialize the properties with values. We can leave them empty as long as we're adding them to the class. TypeScript is happy. In addition, we can initialize these properties by adding them to the constructor function in our class.
01:34:20.421 - 01:34:58.895, Speaker B: We will add the constructor function inside the arguments of the constructor function. We will add both properties to this function. So far, so good. The last step is to add the public keyword to the parameters. The public keyword will allow our properties to be accessible outside of the class. If we add the public keyword to the constructor's parameters, it's the same as if they were initialized. Like above, we can remove this part of the code.
01:34:58.895 - 01:35:33.565, Speaker B: This shorthand method of initializing variables is common in Angular. We'll be using this feature frequently. Speaking of public properties, we can make properties private. For example, let's add a method called withdraw. Let's say we don't want the withdraw method to be called outside the class. We can add the private modifier before the method name by adding this keyword. The method can't be called outside the object.
01:35:33.565 - 01:36:09.437, Speaker B: It must be called by another method from within the class. It's a great way of preventing yourself from accidentally calling the wrong method, or preventing a library from calling it. If we don't make a property or method private, they're public by default. We don't have to add the public keyword to most properties and methods. The exception to this rule is the constructor function. If we were to omit this keyword from the parameters, they will not be initialized as properties to the class. Classes are heavily used in Angular.
01:36:09.437 - 01:36:48.747, Speaker B: We'll get a lot of practice with them, as well as learn some features along the way. In the next lecture, we'll move on from classes to learn about generics. In this lecture, we're going to learn about generics. They are a feature frequently used in Angular. They allow functions or Classes to be strict and flexible at the same time. Generics function similarly to parameters, but with data types. Sounds confusing.
01:36:48.747 - 01:37:23.153, Speaker B: Let's look at an example and the motivations behind generics. They're super simple once you see them in action. For this demonstration, let's work inside an empty file. We will create a new file called generics ts. Inside this file, we we will create a class called queue. In this scenario, let's pretend this class can handle a collection of items. It'll manage removing and pushing items into the class.
01:37:23.153 - 01:37:59.147, Speaker B: That's already possible with array functions. However, you may want to replicate this behavior if you're interested in having refined control over how items get added or removed from an array. For this example, we will restrict the data type that can be added or removed from the array. First, we will create a property called data. It'll be a private property. Privatizing the array will prevent external code from interacting with the array. We are being very strict with our array.
01:37:59.147 - 01:38:38.301, Speaker B: Next, we will define a method called add. This method will accept an argument called item. This argument will be pushed into the data array with the push function. Lastly, we will create a method called remove. The remove method will remove the first item in the array. Inside this method, we will call the shift function on the data array. The current implementation has a couple of problems.
01:38:38.301 - 01:39:07.915, Speaker B: The biggest problem is how we're adding and removing values. At the moment, any value can be added or removed. Let's look at an example below this class, we will create a new instance of the class called name Q. Our queue will hold an array of names. Let's try pushing two names by calling the add function. The first name will be a string. The second name will be a number.
01:39:07.915 - 01:39:43.729, Speaker B: We're pushing in two different data types, which we may not want. We're not restricting the type of data that can be pushed into the object. One solution would be to add annotations to the parameters of the function. Let's try that. In the Add functions parameters, we will set the type to string by adding this annotation, TypeScript will throw an error. It's not letting us push a number, which is great. It helped us catch an error.
01:39:43.729 - 01:40:05.815, Speaker B: Let's change this value to a string. So far, so good. Right? Let's try creating a new queue. The new queue will be called number queue. Unlike the first queue, this queue will store numbers. Let's try adding a new number. With the add function.
01:40:05.815 - 01:40:35.631, Speaker B: We'll get an error. Even though we have a different queue, we can't use another type. Our queue is restricted to Storing strings. We may want to restrict our array to a single data type, but the data type should be flexible from queue to queue. How do we get the best of both worlds? One solution would be to duplicate the class. One version for strings, another for numbers. Unfortunately, that's not scalable.
01:40:35.631 - 01:41:06.905, Speaker B: If we want our class to be reusable, developers should be able to use it without modifying the original class. We can tackle this issue by using generics. A generic is a placeholder for data types. After the class name, we will add a pair of angle brackets. Inside these brackets, we will give the placeholder a name. We will use the letter t. Next, we will update the add function by setting the parameters data type to T.
01:41:06.905 - 01:41:38.653, Speaker B: Afterward, we will annotate the data property to be an array of the T type. Lastly, we will add angle brackets to both new instances. They must be placed before the parentheses. The first instance will have string. The second instance will have a number. Let me break down what's going on. The generic is the letter T in the angle brackets.
01:41:38.653 - 01:42:13.063, Speaker B: It's a placeholder for the data type. The letter T can represent any data type. This can be strings, numbers, booleans, or custom types. By defining this generic, we can use it anywhere in our class. In this case, we're adding it to the item parameter in the add function. If this generic is set to string, the item parameter will be restricted to strings. If it represents the number type, the item parameter will be restricted to numbers, so on and so forth.
01:42:13.063 - 01:42:46.093, Speaker B: We can configure the data type when we create a new instance, which we're doing in the code below. For example, the first instance is setting the type to string. Therefore, only strings can be pushed into the array. We can prove this by removing the quotes from one of the values in the add function. An error gets thrown by the compiler. It's telling us the type must be string. Despite the string data type not being present in the class.
01:42:46.093 - 01:43:16.793, Speaker B: TypeScript can intelligently restrict the values to strings. In the second instance, the array is restricted to numbers. By using generics, we can have type safety while allowing our class to be flexible. For any type. You may be wondering why the letter t? Truthfully, we can use any name we'd like. For example, we can swap this name with the word baseball. This class will still work.
01:43:16.793 - 01:43:51.415, Speaker B: However, it's common practice to use the letter t, which is short for type. It's not required, but standard among developers. In most documentation and examples, you will find developers like to use the letter t. At the end of the day, it's up to you to decide if you want to follow this naming convention. Generics can be applied to functions and class methods. They're not exclusive to classes. The first example shows how the t generic can be used for our parameters and return type.
01:43:51.415 - 01:44:29.485, Speaker B: The same goes for the class method. Throughout this course, generics will pop up. It's not common to create them, but it's always good to know how they work under the hood. In a similar sense, decorators are another feature we'll be using but won't be writing. It is still good to know how they work, though. We'll learn about Decorators in the next lecture. In this lecture, we're going to discuss an experimental feature called Decorators.
01:44:29.485 - 01:44:59.605, Speaker B: Every feature of TypeScript we've explored so far has been related to type safety. TypeScript does an extremely good job of helping us verify the types of our data. Type safety is the main selling point of TypeScript. There's another side of TypeScript we haven't had a chance to explore. It allows us to write next generation JavaScript. JavaScript is constantly evolving. There's an official committee responsible for deciding what features get added to the language.
01:44:59.605 - 01:45:26.055, Speaker B: This committee is called TC39. Their discussions are open to the public. We're able to view what they're working on. Typically, features go through a process. The first stage in the process is called Straw Person. During this part of the process, members of the committee may propose a new idea. If members like the idea, they'll move on to the next stage.
01:45:26.055 - 01:46:01.479, Speaker B: Next, one of the members will begin drafting a document of the proposal. This document will include an extensive description of how the feature will work in the JavaScript language. At this point, members will discuss if there are problems with this proposal. The draft will be revised dozens of times throughout this process. In the next stage, members will begin writing the syntax rules for the feature. The team works with another team called Babel to make this feature a reality. Babel is a library for writing next generation JavaScript.
01:46:01.479 - 01:46:43.025, Speaker B: In our applications, developers can test new features before they become available in browsers. After feedback has been implemented, the next stage is where members discuss any last issues with the proposal. If there aren't, the feature is moved onto the last stage, which is to make the feature an official part of the language. In the resource section of this lecture, I provide a link to the official list of TC39 proposals. As you can see, the list is almost endless. The feature we're interested in is called Decorators. As of this video, you should be able to find it under stage three.
01:46:43.025 - 01:47:11.755, Speaker B: Decorators are an upcoming feature in JavaScript. It's a feature heavily used in Angular. If we want to learn Angular, learning decorators is a must. We have two options for working with decorators. We can use Babel, which would require additional setup. Luckily, Typescript supports decorators. One of the extra benefits of using TypeScript is being able to access newer features in JavaScript.
01:47:11.755 - 01:47:38.049, Speaker B: So what are decorators? Why does Angular use them? Decorators are functions for extending business logic or adding metadata. Sounds cool, but doesn't really explain what decorators are. Let me give you an analogy. Let's imagine we had a Christmas tree by themselves. Christmas trees are plain and boring. That's why we add decorations to them. Decorations can liven up a tree.
01:47:38.049 - 01:48:11.875, Speaker B: It doesn't matter how many decorations you've added to the tree, it's still considered a tree. In a similar sense, decorators work the same way. They allow us to modify an existing piece of code. After the decorator has made its modifications, we're returned the same piece of code, but with the modifications. Let's look at an example of what problems decorators solve. We have two classes with the same property. Imagine if we had two classes with dozens of similar properties and methods.
01:48:11.875 - 01:48:41.135, Speaker B: We should avoid repeating the same code whenever possible. This problem is as old as time. Avoiding duplicate code is an issue developers face. Throughout the years, developers have come up with solutions for fixing this issue. We can use high order components, composable functions and closures. You may be familiar with these solutions if you worked with React or vue. Each of these solutions works, but there are some drawbacks to each of them.
01:48:41.135 - 01:49:21.191, Speaker B: Decorators resolve a lot of the issues with these other patterns. One of the advantages of decorators is that we can apply them to classes, properties, methods, accessors and parameters. Thus, they can reach certain areas in our code where other patterns can't. Alright, enough talk. Let's start writing some code. We'll get started in the following lecture. In this lecture, we're going to configure TypeScript to support decorators.
01:49:21.191 - 01:49:59.537, Speaker B: Here's the interesting thing about decorators. In TypeScript, there are actually two different versions of decorators supported in the language. As we know, there are different stages a feature goes through before being officially introduced into the language. When decorators were added to TypeScript, decorators were in Stage 2. When decorators were promoted to Stage 3, the way decorators were written changed heavily. Therefore, TypeScript decorators were incompatible with Stage 3 decorators. To resolve this issue, TypeScript now supports Stage 2 and Stage 3 decorators.
01:49:59.537 - 01:50:32.595, Speaker B: The reason they support Stage 2, despite being outdated, is to add backward compatibility for projects using the older version. For this course, we're going to be using Stage three. If we want to use Decorators, we need to configure TypeScript to enable them. We can configure TypeScript by creating a configuration file. This file can be created manually. Alternatively, the TypeScript package adds a command for creating a basic configuration file. Let's give the package a try.
01:50:32.595 - 01:51:07.379, Speaker B: In the command line, run the following command and pxtsc init. After running this command, TypeScript will have created a file called tsconfig JSON. Let's open this file out of the box. TypeScript will recommend dozens of settings for configuring the library. Luckily, we won't have to configure them all. The default settings will work for most situations. When we switch to Angular, it'll configure this file for us.
01:51:07.379 - 01:51:41.065, Speaker B: It's not essential to learn every option. To make things simpler, let's empty the Compiler Options object. They're not necessary for what we're trying to do. The option we care about is called Target. Add this option with the following value ES2022. The target option can tell TypeScript what version of JavaScript we're using. If we set it to 2022 or higher, stage 3 decorators will be enabled.
01:51:41.065 - 01:52:05.095, Speaker B: That's it. We've enabled Decorators. If you're interested in learning the other options, check out the link in the resource section of this lecture. This page will document every option in detail. As you can see, TypeScript is very flexible. In the next lecture, we're going to begin writing Decorators. I'll see you there.
01:52:05.095 - 01:52:43.025, Speaker B: In this lecture, we're finally going to write a decorator. For this demonstration, we will be working on a new file in your project. Create a file called Decorator ts. Let's say we were creating a restaurants application. Restaurants need menus. I think it would make sense to create a class for each item on the menu. For our first menu item, we will create a class called Pizza.
01:52:43.025 - 01:53:16.501, Speaker B: We will create another menu item with a class called Hamburger. Both classes will have a property called ID with the string type. Great. We've got a couple of classes for our menu, but neither have an id. Without an id, it would be difficult to identify our menu items. One solution would be to add properties directly to our class. However, another solution would be to use Decorators.
01:53:16.501 - 01:53:49.465, Speaker B: Decorators have the power to override the class definition. Let's try using them to assign IDs to our classes. A decorator is written as a function above the two classes define a function called Menu item. The name of our decorator is pascalcased. It's not necessary to write the names of decorators in PascalCase, but it is standard practice. Two parameters must be added to your decorators. They're called value and context.
01:53:49.465 - 01:54:31.513, Speaker B: Decorators can be applied to classes, methods, or properties. The value parameter stores the value of the definition it is applied to, whereas the context parameter contains information of the definition itself, such as if the decorator was applied to a class or method. The next step is to return a value. As mentioned earlier, decorators can override values. In our case, we're overriding the class. The return value of the function is based on the type of definition it's been applied to in our code. Since this decorator will be applied to classes, we must return a class return.
01:54:31.513 - 01:55:05.053, Speaker B: The following class extends value. In most cases, you're most likely not going to override the entire class. Sometimes you might want to extend the existing class to define additional properties or methods. Whatever is returned by our function is going to be applied to our class. Let's give that a try. Decorators can be applied by adding the symbol followed by the name of the decorator. We will apply the menu item decorator to the pizza class.
01:55:05.053 - 01:55:38.425, Speaker B: Decorators sit on top of the class they're applied to. Just like that, we've created our first decorator. It doesn't do much, so let's modify the ID in the class from the decorator function. We're going to set the ID property to ABC by adding properties to the target object. They'll be applied to our classes. Let's test if this is true at the bottom of our classes. Let's log a new instance of the pizza class.
01:55:38.425 - 01:56:12.945, Speaker B: During this process, your editor may be throwing an error on the line of code where the decorator was applied. It says something about being unable to resolve the signature. This issue lies with Visual Studio code, not your code. Currently, we're using the latest version of TypeScript behind the scenes. Visual Studio code installs its own version of TypeScript to perform validation. We can view the TypeScript version by opening the Command palette. Navigate to the View Command Palette option.
01:56:12.945 - 01:56:49.401, Speaker B: Next, search for the Select TypeScript version option. As you can see, the TypeScript version of Visual Studio code is older than the version installed on our machines. Decorators are a relatively new feature, only available in the latest version of TypeScript. Unfortunately, there isn't an easy fix, aside from waiting for Microsoft to update their editors to use the latest version. For now, you could ignore the errors thrown by the editor. We can verify our code is working by compiling it. Switch over to the command line.
01:56:49.401 - 01:57:23.405, Speaker B: Let's compile our script with the NPXTSC decorator tscommand. Everything should work after compiling the script, let's test our script by running the Node decorator command. The ID has been set to abc. Our decorator modified this property. As you can see, decorators are very powerful. They allow us to modify and add properties to a class. We can take this a step further by passing on values to our decorators.
01:57:23.405 - 01:57:46.865, Speaker B: At the end of the day, decorators are just functions. Like any other function. We pass in values to configure the behavior of the decorator. Back at the top of the file, we're going to modify our function. We need to use a closure for accepting properties. Let me show you what I mean. The menu item function will return the function for modifying the class.
01:57:46.865 - 01:58:32.001, Speaker B: The outer function will be responsible for accepting values, whereas the inner function will be responsible for interacting with the target. In our outer functions parameters, we can accept incoming data. We will have one parameter called item ID with the string type. Next, in the inner function, we will set the ID property to the item ID argument. After modifying our decorator, we will get an error from TypeScript. It'll tell us we are calling the menu item decorator incorrectly. We need to call it like a function inside the parentheses.
01:58:32.001 - 01:58:57.507, Speaker B: We can pass in whatever value we'd like. In the case of our menu item decorator, we need to pass in a string that'll act as an id. Let's pass in abc. Interestingly, decorators are reusable. Let's apply the same decorator to the Hamburger class. Give it any ID you'd like. With the help of decorators.
01:58:57.507 - 01:59:27.027, Speaker B: Both classes have their IDs set by the decorator. We have a simple example. But imagine if we wanted to add dozens of methods and properties to multiple classes by using a decorator. Extending a class is easy. Hopefully it's becoming clear as to why you may want to use decorators. They allow us to extend a class with properties and methods. Another benefit of decorators is being able to apply them directly to properties, methods and accessors.
01:59:27.027 - 01:59:57.565, Speaker B: We don't have to apply them to the overall class. The syntax is different based on the target. For that reason, we won't be diving into how to create decorators for different targets. The main point of this lecture is to understand how decorators work. They're heavily used in Angular. It's unlikely we will be writing decorator functions Instead, we will be using decorators defined by Angular. The decorators from the Angular framework will cover most of our needs.
01:59:57.565 - 02:00:22.385, Speaker B: As long as you understand what decorators do, you should be good to go. This is the last lecture on TypeScript. There are so many features in TypeScript that we haven't got to cover. However, these features will be enough to get you through the Angular course. As we progress through the course, we will cover additional features. I can't wait to get started with Angular. I'll see you in the next section.
02:00:22.385 - 02:01:00.839, Speaker B: In this section, we're going to dedicate our time to learning the features revolving around components. It's one of the most powerful features in Angular. Furthermore, we will be working with components a majority of the time in this course. As a result, there are a lot of features to unpack. To begin, we're going to focus on signals. First, we should learn about reactivity in the JavaScript world. Applications are designed to respond to user actions.
02:01:00.839 - 02:01:38.205, Speaker B: These actions can range from submitting a form, clicking on a link, or typing text in an input box. When these events happen, our application's job is to react to these events. Reactivity is a concept where your application reacts to these actions. When these actions occur, you may want to update data, load a different page, or display an error. Technically, you don't need a JavaScript framework to add reactivity to a page. However, frameworks like Angular make the process a whole lot easier. Angular provides a set of functions to add reactivity.
02:01:38.205 - 02:02:18.635, Speaker B: That leads us to our first feature Angular introduces for adding reactivity to an application, which are signals. A signal is a value tracked by angular. Whenever defining a variable, it's not guaranteed to be tracked by angular. If a value isn't tracked by angular, you're going to have a hard time updating your application. For example, if a user logs in, you may want the page to change, so you would define a variable to keep track of the user's logged in status. By converting this variable into a signal, your application will be able to respond when the user logs in or out. That's the power of signals.
02:02:18.635 - 02:02:45.423, Speaker B: Enough terminology. Let's put what we've learned into practice. We will continue working on the Basics project we created. In the last section, open the app.component.ts file inside the class. Let's create a property called name with a random value. Components can store data.
02:02:45.423 - 02:03:21.875, Speaker B: Data stored in a component will be isolated from other components. If we are using the same component multiple times throughout an application, each component will have a property called name. If this property changes in one component, the changes won't be reflected in other components. By default, variables in our classes are not signals. To make them into signals, we must import a function from the Angular core package. We're already importing the component decorator from this package. Let's add onto it by adding a function called signal.
02:03:21.875 - 02:04:01.103, Speaker B: Next, wrap the name variable's value with this function. The signal function is pretty simple to use. We just call it pass in a value and store it in a variable. By following these steps, Angular will keep track of this variable's value. If it changes, our application component is notified of that change. Let's try rendering the name in the template. Switch over to the app component HTML file In between the paragraph tags, we will replace the static text to output the name property.
02:04:01.103 - 02:04:31.935, Speaker B: The name of the property must be wrapped with double curly braces. A couple of things worth mentioning about this syntax. The curly braces help Angular identify when we're writing an expression, we can't simply write the property in the template. Otherwise, Angular will interpret this expression as static text. Angular loves its terminology. Words like interpolation and expressions come up frequently. Here's a quick refresher on expressions.
02:04:31.935 - 02:05:01.245, Speaker B: A JavaScript expression is a single line of code that can be evaluated to a single value. The value can be a number, string, or logical value. There are all kinds of expressions. Here are some examples. Arithmetic operations, basic string manipulation, and logical comparisons are considered expressions. All three examples will evaluate to a single value. To add more clarity, here are some examples that aren't considered.
02:05:01.245 - 02:05:36.455, Speaker B: Variable declarations, conditional statements, and function declarations are not expressions. We can add expressions directly inside a template. The process goes something like this. Angular will search through our templates for expressions. An expression can be inserted into a template by writing two pairs of curly braces with the expressions inside the expression can be whatever we want. It'll process the expression. Whatever gets evaluated will be outputted on the template by replacing the curly braces with the evaluated value.
02:05:36.455 - 02:06:10.907, Speaker B: Angular handles the majority of this process for us. Another word for describing this process is called string interpolation. These two phrases can be interchangeable at times, but there is a difference between them. Expressions are the code inside the curly braces, whereas string interpolation describes the process of replacing a placeholder with a string value. Therefore, you can say the expression name is interpolated into john. The terminology can be confusing. Sometimes developers will throw around both words.
02:06:10.907 - 02:06:43.697, Speaker B: It's important to know what they mean when they use these terms. So, back to the template. We can write expressions by using the double curly bracket syntax One thing you may notice is that we are writing the property name without the this keyword. Including it is not necessary. Angular is smart enough to know where to find the property in the class. It'll establish a connection for us, which makes our templates look cleaner. Templates have access to the components properties.
02:06:43.697 - 02:07:13.205, Speaker B: When trying to access a signal, you must call it as a function. If you were to omit the parentheses, you're going to see an object get rendered on the page. That's important to understand. All signals must be called as functions from our template. Before we test our code, let's explore what else we can write in expressions. Expressions can contain method calls. After the name property, let's chain the touppercase function.
02:07:13.205 - 02:07:47.097, Speaker B: Next, let's try creating a method in our class for outputting the name. Switch back to the class in the class. Define a method called GetName. It'll return the this name property. Once again, when trying to use a signal, you must call it as a function. Otherwise you're not going to have access to the value but an object. Back in the template, we will make a copy of the paragraph tag.
02:07:47.097 - 02:08:20.395, Speaker B: Instead of outputting the property, the expression will be replaced with a method. Once again, we don't need to add the this keyword. Angular understands we're trying to call a method from our component class. Methods are publicly accessible to a template. Let's try adding one more expression. We will add one more paragraph tag for rendering an age. Instead of outputting a property or method, let's try performing an arithmetic operation.
02:08:20.395 - 02:08:43.795, Speaker B: One last thing. The text of the paragraph tags will be orange for readability. We should remove this change. Open the app component CSS file. We're going to remove the stylings we had inside this file. That'll do it. Refresh the page in the browser.
02:08:43.795 - 02:09:27.109, Speaker B: The expressions we've written have been interpolated into the browser. Angular gives us a lot of flexibility with the types of values we can output to the document. It's common practice to keep the template as minimal as possible for the age, we're performing an arithmetic operation. It's not the worst thing in the world, but if we can help it, we should perform operations in the class. The template's job should be to simply output data. To recap, interpolation is the process of replacing placeholders with string values. We can output properties using double curly braces in our templates.
02:09:27.109 - 02:10:00.065, Speaker B: The code inside the curly braces must be an expression. The evaluated value from the expression is what will get outputted. Angular will replace the curly braces with the evaluated value. There's one more thing I want to show you before ending this lecture. If you're using Visual Studio code, there's an extension for assisting us with writing templates. Back in the editor, go to the Extensions tab. Search for an extension called Angular Language Service.
02:10:00.065 - 02:10:25.125, Speaker B: We're going to install this extension. It's an official extension by the Angular team. This extension will help us write expressions by giving us a list of properties and methods in the class. Let's try it out. Switch over to the template. We're going to rewrite the expression for the name. As we do so, the editor will give us a list of properties and methods inside the class.
02:10:25.125 - 02:11:12.639, Speaker B: This feature can be beneficial for quickly writing templates. We don't have to switch back and forth between the class and templates. In the next lecture, we're going to continue exploring other component features. In this lecture, we're going to explore a feature called property binding to manipulate attributes on an element. So far, we've learned how to output data. Angular provides us with interpolation for rendering data from a components class. This feature is not the only option at our disposal for manipulating the document.
02:11:12.639 - 02:11:42.695, Speaker B: Attribute values can be tied to signals from our class. This feature is known as property binding. Through this feature, we can do some exciting things. For example, our attributes can store values from our component class. Let's give that a try. We will continue working in the App component class. Inside this class, we will create a property called imageurl with a value of a link to an image.
02:11:42.695 - 02:12:23.405, Speaker B: Don't forget to wrap the value with the signal function. If you want to link to this image, check out the resource section of this lecture. We are going to dynamically load this image in the browser. It's a common type of action you may perform in a regular web app. In some cases, you may not be able to load an image immediately. Therefore, you won't be able to set the source attribute to a valid image URL Images may be given to you from an external resource, such as an API. After receiving the image, we may want to load it in the document.
02:12:23.405 - 02:12:58.215, Speaker B: Angular allows us to modify a template's attributes with a feature called property binding. Property binding is being able to change the document with properties from a class. If a property in our class changes, Angular will update the document with the new value. This is the change detection system I mentioned in the last section. Angular will automatically watch our properties for change. Those changes are communicated throughout our app. We can apply property binding to any attribute in our document.
02:12:58.215 - 02:13:36.075, Speaker B: Let's try using property Binding. To load our image, switch over to the app template file above the other tags. Let's add an image tag. Next, we're going to add the source attribute. We can bind a property to this attribute by surrounding it with square brackets. The syntax for property binding is the attribute name surrounded by square brackets. During the change detection phase, Angular processes our templates.
02:13:36.075 - 02:14:11.903, Speaker B: During this process, we saw an example of how it processed our template for rendering the name. If Angular comes across an attribute with square brackets, it'll process the attribute before rendering the components template. The value of the attribute is treated as an expression. That's important to note down. The value of this attribute is no longer static. It's interpreted as an expression. Whatever value is evaluated from the expression will be used as the value for the attribute.
02:14:11.903 - 02:14:44.209, Speaker B: Let's set this attribute to the image URL property from our class. Just like with expressions, we must use this property as a function. So be sure to add the parentheses after the name. We have access to the property and methods in our class. Angular will bridge the gap between the template and class. Let's check out the app in the browser. The image should be a puppy.
02:14:44.209 - 02:15:21.179, Speaker B: Awesome. The feature we're using is called property binding. It allows us to apply properties from a class to an attribute's value. The component, class and template are tied together. In the next lecture, we're going to learn how to update the image with event binding. In this lecture, we're going to learn how to listen for events in our template. At the moment, the image will always remain the same.
02:15:21.179 - 02:15:57.075, Speaker B: I think it would be cool if we could dynamically swap this image with another image. Let's try giving it a shot. Open the app component template in your editor, elements can emit various events. Normally, we would listen for an event by selecting the element with a query function. Afterward, we would attach an event listener to the element. Angular provides an easier way to attach event listeners on elements. Actually, I would even go as far to say it's better than vanilla JavaScript.
02:15:57.075 - 02:16:20.857, Speaker B: The syntax is easier to read and write. All browser events are supported in Angular. We can handle clicks, form submissions, keyboard events, etc. Custom events are supported too. We'll look at how to create custom events in a future lecture. For now, we're going to focus on browser events. Above the image.
02:16:20.857 - 02:16:51.375, Speaker B: We're going to add an input element through this element. We will allow users to change the image. Before we move forward, let's add some spacing. Open the app style sheet file. We will select the input element. The display property will be set to Block. The margin property will be set to 10 0.
02:16:51.375 - 02:17:23.237, Speaker B: That'll give us some good spacing. Let's go back to the template. On the input element, we are going to listen for an event called keyup. Events can be written like attributes on an element. We need to wrap the event with a pair of parentheses. If we omitted the parentheses, Angular would interpret this event as a regular attribute. It's important to wrap the event with parentheses.
02:17:23.237 - 02:17:54.825, Speaker B: At this point, you may have started to notice a pattern. HTML template files are not regular HTML files. Angular enhances templates with additional syntax for interacting with the document. This set of features are why developers love Angular. Our components, template and logic are separate at the same time. They're not entirely decoupled from one another. We can apply special syntax to our templates to bind properties and events.
02:17:54.825 - 02:18:23.051, Speaker B: Without Angular, the browser wouldn't know how to handle this syntax. Back to the task at hand. Normally, events are prefixed with the word on. We can safely omit the on keyword from the event name. This applies to all browser events. Angular automatically attaches this keyword to your event bindings. The key up event will fire after a key has been released.
02:18:23.051 - 02:18:46.636, Speaker B: We can use this event to help us detect changes in the input. The value of this event can be an expression. We're going to instruct Angular to run a method. We will run a method called ChangeImage. With the event object passed in. On the one hand, we could handle the logic in the template. However, that's not recommended.
02:18:46.636 - 02:19:12.505, Speaker B: We should outsource complex logic into the class. The template should listen to events. Afterward, it can pass on event handling to our class. Angular will provide us with an object called event in the template. We can pass it onto our components methods. Let's help the user by providing the initial URL to the image. Try this as an exercise.
02:19:12.505 - 02:19:36.885, Speaker B: I want you to set the value attribute to the URL in the class. Pause the video and good luck. Welcome back. If you are able to tackle this problem, that's great. If not, that's fine as well. Let's tackle it together. On the input element, we're going to bind the value attribute to the image URL property.
02:19:36.885 - 02:20:13.585, Speaker B: Be sure to wrap the value attribute with square brackets. Otherwise, Angular will not be able to process the expression in the attribute's value. There is a distinction between binding events and properties. Property binding is performed with square brackets. Event binding is performed with parentheses. Moving along, let's write the method for handling the event. Back in the component class, we're going to define the method we're going to accept the event argument as E.
02:20:13.585 - 02:20:49.183, Speaker B: This argument should be annotated with the keyboard event type. We're annotating the argument with the keyboard event Object to help TypeScript understand the object. If you were to look around, the keyword event type is not defined in our class. Luckily, we don't have to define it. Angular has configured TypeScript to include types for the DOM. This includes types for browser events. The keyboard event type can be annotated on objects that represent keyboard events.
02:20:49.183 - 02:21:40.235, Speaker B: Remember, we want type safety in our application. We want to make sure we're receiving the correct type of object when calling this method. The key up event will give us a keyboard event object Inside this method, we're going to set the image URL property to the event target value property. Directly updating signals is not allowed. When creating a signal, we're returned an object containing the original value. If we attempt to update the variable directly, we would be overriding the object completely. So how do we update a value in a signal? Instead of using the assignment operator, we must run a function called set with the new value passed into the function like so.
02:21:40.235 - 02:22:14.795, Speaker B: It's critical to understand this concept. Throughout the course, we're going to be frequently updating our signals. If we want to do so, we must always use the set function. After saving the file, we're going to receive an error in the console. The error is telling us the value property does not exist on the event target object, which doesn't make sense because we aren't using this object. Or so it seems. In the following lecture, let's explore this issue in depth.
02:22:14.795 - 02:23:05.353, Speaker B: In this lecture, we're going to explore the error thrown by TypeScript. Continuing where we left off, let's examine the issue in our component. We are trying to update the image URL property to the event target. According to the error, we're trying to access a non existent property called value. In regular JavaScript, the browser exposes the value of an input through the value property. Technically, if TypeScript weren't so strict, our code would work perfectly. So what's the deal? The issue we're encountering stems from TypeScript, not angular.
02:23:05.353 - 02:23:48.167, Speaker B: To better understand, let's hover our mouse over the e object. If you're using Visual Studio code, the editor will provide you with information on the data type. For example, our editors will tell us the e object is annotated with the keyboard event type. Let's check out the data type of the target property. This time the editor is indicating the data type is set to event target in the resource section of this lecture. I provide a link to the documentation page for this interface. The event target interface is defined by TypeScript on the right side.
02:23:48.167 - 02:24:26.055, Speaker B: The documentation will provide you with the path to the file. If you're interested in the definition of the interface, let's scroll to a section called Index. The index section contains a list of properties and methods. Immediately you'll realize the interface does not define a property called value. Hopefully, the error is starting to become apparent. TypeScript isn't aware there's a property called value on the target object. This behavior can be helpful because it can prevent us from accessing properties that don't exist on an object.
02:24:26.055 - 02:25:06.965, Speaker B: However, the value property does exist on the target object. Input elements expose the field's value through the value property. So why did the development team decide not to add the target property to the interface? Let's think about this for a moment. Keyboard events can be emitted on various elements. They're not exclusive to input elements. If a keyboard event was emitted on a non input element, the value property would be undefined. For this reason, the interface does not guarantee the value property will always exist on the target object.
02:25:06.965 - 02:25:58.425, Speaker B: This type of problem can appear from time to time. Sometimes a property or variable can be annotated with an incomplete interface. Luckily, TypeScript offers a feature called Type assertion. Type assertion allows us to change the type from the compiler's perspective. I'll explain more in detail, but first let's check out the syntax switch back to the editor. We can fix this error by wrapping the e target property with parentheses. Next, we need to add the following as htmlinputelement the AS keyword will force the TypeScript compiler to assume a different type for an object or property.
02:25:58.425 - 02:26:32.375, Speaker B: This behavior is known as type assertion. It's a way of helping the compiler understand the value. Technically, the event target interface is correct, but the htmlinputelement interface is more accurate. This interface should be applied to input elements. On this interface, the value property is defined. After asserting the type, the error has gone away. If we hover our mouse over the target property, the type is being set to event target.
02:26:32.375 - 02:27:00.321, Speaker B: Switching over to the value property, the type completely changes. The type has been changed to HTML input element. Our new type has been asserted before accessing the value. TypeScript is happy. Let's check out the app in the browser. The app is rendering a text input. It's pre filled with the property from our class.
02:27:00.321 - 02:27:36.695, Speaker B: We can change the image to whatever we want. In the resource section of this lecture, I provide a link to a tool Called Pixum, it's a tool for delivering dummy images for apps. It's super convenient if you need a random set of images. Feel free to browse through the list of images. Below every image, there's an ID we can use to reference an image back to our app. We can change to a different image by changing the first number in the URL. For example, let's change the number to 1025.
02:27:36.695 - 02:28:16.437, Speaker B: We will get another picture of a dog. Great. Our event is working as expected. Event binding is a powerful feature for listening to events on elements. In some cases, we may need to help the compiler understand the value's data type by asserting the type. We will continue working with components in the next lecture. In this lecture, we're going to learn how to create a component.
02:28:16.437 - 02:28:46.455, Speaker B: Up until now we've been working on a single component. It's recommended we break an application into several components. As we discussed before, components are a feature for teaching the browser new HTML tags. Therefore, components can be structured like a tree. It's similar to the DOM tree. The app component is typically the root or parent component of all components. The job of the app component is to load other components.
02:28:46.455 - 02:29:18.937, Speaker B: In this diagram we have a hierarchy of components where the app component is the parent. The product components are the children of the app component children. Components can load more components. There isn't a limit on the depth of the tree. It's similar to HTML where we can have a deeply nested structure of HTML tags. Typically, components should focus on one feature. In our example, the product component would never render information about users.
02:29:18.937 - 02:29:50.435, Speaker B: It should focus strictly on products. Throughout this course, you'll get a feeling for how components should be structured. We have two options for creating components. We can create them manually or use the cli. We've already seen how to create components manually. I think this would be a great opportunity to learn how to use the CLI to help us generate a components files. It will save us the trouble of manually creating and configuring a component.
02:29:50.435 - 02:30:40.501, Speaker B: We can create a component with the NG Generate Component command in the command line we have the app running. So how can we generate a component while having the app running? We can open a new command line by pressing the plus button. By the way, if you don't see this option, that's probably because you haven't moved the command line as a tap. Let me show you how to put the command line as a tab in Visual Studio code. Go to Terminal New Terminal when selecting this option, the terminal should appear below to the right. You can Click on the button that says powershell or Command Line to drag it as a tab, like so. I recommend having two command lines open for the rest of this course.
02:30:40.501 - 02:31:14.269, Speaker B: One for running the server, another for installing packages or creating files inside the new command line. We're going to write the NG Generate component command with the Help option. It's always good practice to check out what our options are for a new command. The description will tell us. This command will create a new component. The most important section is called Arguments. Unlike the other pieces of information, the values for the argument list are always required.
02:31:14.269 - 02:31:52.843, Speaker B: Based on this information, we must provide a name for our component. Inside the command line, we will run the following NG Generate component post. After a few moments, the CLI will give us a list of files that were created or updated. Inside the Source App directory, we have a new folder called Post. Components should be placed inside a separate directory. It's a common practice we adopt. Angular will generate a class template, stylesheet, and test file.
02:31:52.843 - 02:32:21.977, Speaker B: The stylesheet and template will be very basic. There's nothing interesting happening in these files. As for the test file, we're going to ignore it. Testing is not a topic covered in this course. Let's check out the class file right away. We're going to be greeted with an entirely different starter file from the App component with a single command. The CLI generated this entire file for us.
02:32:21.977 - 02:32:49.077, Speaker B: It has the same settings as the app component, with some exceptions. Inside the components decorator, there's a new option called Imports. The Imports option is an array of components that can be used by this component. At the moment, it's empty. I'll show you how to add components to this option in the next lecture. Other than that, everything in this file should be familiar to you. Congrats.
02:32:49.077 - 02:33:25.321, Speaker B: You've created your first component. In the next lecture, let's update it to display our image. In this lecture, we're going to render our image inside the Post component. We have a couple of options at our disposal. We can move the template and properties to the Post component. Alternatively, we can move just the template. The URL for the image can be left inside the app component.
02:33:25.321 - 02:33:58.077, Speaker B: Instead, we can feed the post component the image. Why would we do this? Our goal should be to develop reusable components. For example, let's say we're developing a blog. If our blog has hundreds of posts, would you rather create a component for every post or a single component? I bet you would want to create a single component. It's much more efficient. Instead of hard coding data into A component. We can create components to accept data from a parent component.
02:33:58.077 - 02:34:31.171, Speaker B: The post component can allow the parent component to tell it what image to render. By sending the image to the component, we can reuse the post component with different images. The responsibility of supplying the image will be the job of the parent component. If we hard code the image inside the post component, the same image will get rendered. Angular makes it super easy to pass down data from component to component. Let's get started. Open the app template.
02:34:31.171 - 02:34:59.925, Speaker B: We're going to cut the image tag. Next, switch over to the post template. We will paste in the image tag. The editor will throw an error. It tells us the image URL property does not exist in the post component class. This is important to understand. We don't have access to properties in other classes.
02:34:59.925 - 02:35:31.635, Speaker B: Templates have limited scope to the class they are associated with. We should tell Angular this property should come from the parent component. Before we move on, I want to rename the property to postimage. This step is optional. In my opinion. I think it would be confusing if we had the same property names in different classes. By renaming the properties, it should give us clarity as to which property belongs to which class.
02:35:31.635 - 02:36:08.605, Speaker B: The property will be called postimage in the post component. In the app component, the property name will remain image URL. They will both hold the same value. Let's open the post component class. Inside this class, we will add the postimage property with an initial value of an empty string. The property will be initialized with an empty string. The goal is to update this property with the value passed down by the parent component.
02:36:08.605 - 02:36:35.553, Speaker B: This is where things get tricky. Angular will prevent external code from changing this property. It can only be configured from within this class. That's a good thing. We don't want to allow other classes to change the properties in this class without permission. It's the default behavior of Angular. However, in this specific case, we want to permit other components to set this property.
02:36:35.553 - 02:37:07.851, Speaker B: A property can update it externally by explicitly setting it as an input. Angular provides us with a function for creating inputs at the top of the file. Update the import statement for the Angular core package. Add a function called input. When importing this function, make sure you're importing the version of this function in lowercase letters. There's another variation of this function that is capitalized. That would be the incorrect version to import.
02:37:07.851 - 02:37:47.175, Speaker B: After importing the function, wrap the post image variables value. With this function, we don't need to pass in configuration options to this function. You can even call this function without providing A value. If you do provide a value, the value will be used as the default value for the input until it's overridden from the parent. After adding this property, we're ready for the last step. We need to add the Post component to the App Components template. Before we do, take special note of the selector property in the Components configuration settings.
02:37:47.175 - 02:38:23.961, Speaker B: The selector for this component is App Post. By default, Angular will prefix our component selector names with the word app. It's considered good practice to prefix selectors. This prefix prevents our custom components from clashing with default HTML tags. Back in the App template, we are going to add the App Post component. After adding this component, we can start passing on the image. Believe it or not, we can reuse a feature we learned in an earlier lecture.
02:38:23.961 - 02:39:00.131, Speaker B: Passing down data can be accomplished through property binding. Properties can be configured through attributes. On a component tag, the attribute's name must be the same name as the property in the class accepting the data. In this example, the name of the property is called postimage. The postimage attribute should be set to the Image URL property. By default, attribute values are not processed as expressions. Luckily, Angular supports property binding on components.
02:39:00.131 - 02:39:34.683, Speaker B: Let's wrap this property with square brackets. The attribute's value will be set to the Image URL property. After adding this property, we're going to be given an error by our editors. You can hover your mouse over this line of code for more info. It's always considered good practice to read errors and understand what they're trying to say. Angular does a pretty good job of providing information for debugging your errors. According to the error, it states the App Post element is not known.
02:39:34.683 - 02:40:12.985, Speaker B: This means that Angular has no idea what element we're using. Below this message, we're given a list of options for fixing this error. For the first solution, we're told that if we're trying to use a custom component, it must be added to the App Components Imports option. So let's head on over to the App Component class. To use a component, we must import it at the top of the file. We can import our new component by its class name, which was Post Components. Visual Studio code should be able to complete the import statement for you.
02:40:12.985 - 02:40:44.415, Speaker B: Next, in the Components Decorator, add an option called Imports. This option is an array of components that can be available from our current component. Add the Post Component class. Just like that, our component will be accessible from the template. If you head back to the template, the error should go away. We're finished if we did everything right. The image should appear in the browser.
02:40:44.415 - 02:41:21.647, Speaker B: Let's refresh the page. The image is appearing. Awesome. We are able to communicate data between components, which is necessary for any app. Data can flow from a parent component to a child component. We will continue learning about data flow in components in the next set of lectures. In this lecture, we are going to make our input required for the post image.
02:41:21.647 - 02:41:48.675, Speaker B: Let's take a look at the class for the post component. In this component, we have a property called postimage. Its value is the input function, which allows for this property's value to be set by the parent component. At the moment, the input is completely optional. Let me show you what I mean. Open the template for the app component. Let's remove the post image attribute.
02:41:48.675 - 02:42:33.231, Speaker B: By doing so, our application is going to continue working. But what if that isn't what we want? What if we want to make it a requirement for passing in a post image? In that case, we can use a variation of the input function. Switch back to the component class. Instead of setting the postimage variable to the input function, set it to the input required function. The required function does the exact same thing as the input function. The main difference is the input becoming a required attribute. If the postimage attribute is not added to the element, angular is going to throw an error.
02:42:33.231 - 02:43:01.935, Speaker B: After using this function, you may receive an error. When using the required function, you cannot provide an initial value. That makes complete sense. If the value will be supplied by the parent component, there isn't a reason to have a default value. Let's remove the string from the function. After doing that, our component is good to go. If we switch back to the template, angular is going to throw an error.
02:43:01.935 - 02:43:28.725, Speaker B: Hover your mouse over the app post element. According to the error we must provide the postimage attribute. Angular is going to tell you what inputs are missing from an element. Let's add the value we had previously. After doing so, any errors related to the element are gone. Awesome. Making inputs required is a great way to make sure there's always a value.
02:43:28.725 - 02:44:11.747, Speaker B: Not every input has to be required. It'll depend on your component. For our case, it makes sense for the image to be required since the entire purpose of this component is to render an image. That's all for now. Let's continue in the next one. In this lecture, we're going to explore communication between components with a feature called outputs. At the moment, the communication between parent and child components is one way parent components can send data to child components with inputs.
02:44:11.747 - 02:44:48.105, Speaker B: What if we want to send data from a child Component to a parent component. If we want to communicate with parent components, we can emit custom events. Communicating from a child component to a parent component is similar to parent to child communication. We can send data to a child component by using the input function. Similarly, we can send data back up to a parent component using a function called output. There are a couple of steps we need to take, but overall the process is still the same. Let's try it out.
02:44:48.105 - 02:45:26.515, Speaker B: For this demonstration, let's inform the parent component. If the image was selected, we will be working inside the Post component class. The first step to creating an output is to import the output function. This function can be imported from the Angular core package. Add it to this import statement. After adding the function, we can move on to the next step, which is to create a property responsible for sending data to the parent component. Let's create a new property in our class called Image Selected.
02:45:26.515 - 02:45:57.781, Speaker B: Normally, events should be prefixed with the word on. However, Angular advises against that. In the Resource section of this lecture, I provide a link to this guideline. Angular recommends we omit the word on. It's redundant and inconsistent. As we saw with the key up event, Angular removes the on keyword from the event name. We should follow their lead for consistency.
02:45:57.781 - 02:46:28.777, Speaker B: Let's go back to our editors. The value for this property will be the output function. Essentially, by calling this function, we've created a custom event. Through this property, we can emit the event whenever we want. Before we do, we should add type safely to our event. We have complete control over the data emitted by our event. At the moment, the data can be anything.
02:46:28.777 - 02:47:03.203, Speaker B: We can send numbers, strings, objects, etc. If we hover our mouse over the property, it'll tell us the type of data emitted from this event. The type is set to void, which means nothing is emitted by our event. If you don't intend on sending any data, that's perfectly fine. On the other hand, if you want to send data from our event, this type may not be desirable. For this example, we're going to send the parent component the URL of the clicked image. The URL is a string.
02:47:03.203 - 02:47:30.705, Speaker B: We should add type safety to the values we emit. We can add type safety by using generics. After the name of the class, we will add a generic. The type will be set to string. Let's hover our mouse over the property again. This time the type has been set to string. We've successfully added type safety to our custom event.
02:47:30.705 - 02:48:02.253, Speaker B: Events are the primary way of communicating from a child component to a parent component, which Makes sense. That's how HTML elements communicate data with us. Angular simulates this behavior for our components. There are two more steps we need to take before we're finished. The next step is to emit our event at the moment we've created it. But it will not automatically get emitted. Let's try to handle this part of the process.
02:48:02.253 - 02:48:40.805, Speaker B: Open the post component template on the image tag. We're going to listen for the click event. Remember to wrap the event with parentheses. Otherwise, angular will interpret this event as a regular HTML attribute. Next, inside the value, we're going to call the emit function on the image selected object. The event emitter object has a method for emitting an event called emit. By calling it, we're triggering the event.
02:48:40.805 - 02:49:04.283, Speaker B: We can send data to event listeners by passing in the data to the emit method. Let's send the postimage property. After adding this value, we may receive an error. Hover your mouse over the value. The error states the value's type is unknown. However, Angular expects the type to be a string. That makes complete sense.
02:49:04.283 - 02:49:31.645, Speaker B: Angular has no idea what type of value will be stored in the post image input. It could be a number object or a string. Our custom event expects a string. So how do we make this work? Let's go over to the component class for the post. The input required function can be annotated with a generic. By adding a generic, we can specify the values type. Let's set it to string.
02:49:31.645 - 02:50:01.973, Speaker B: The post component is ready. The last step is to listen for the event in the parent component. Let's switch over to the app template file. On the app post component, we're going to add a pair of parentheses. Our editor will automatically recommend our custom event. That's one of the perks of using the angular extension. It was able to intelligently detect our custom events.
02:50:01.973 - 02:50:29.265, Speaker B: Let's select it from the list. Next, we will run a method called logimage. The logimage method will log the image sent by the component. This method doesn't exist in our class. We should define it. Before we do, we should provide this image with the data emitted by our event. Data emitted by an event is stored in the event variable.
02:50:29.265 - 02:51:03.269, Speaker B: The event variable is not the typical event object we are used to working with. We will see what it looks like in a moment. Let's move on to defining this method. Open the app component class. We will define the logimage method with the event object as an argument. The type for the event object will be a string. The value emitted from our event is a string.
02:51:03.269 - 02:51:34.975, Speaker B: Therefore, we don't need to set this argument to an event object like we did last time with our change text method. Lastly, we will log the event object. Alright, let's refresh the page in the app. The app is still working. If we open the developer tools, there shouldn't be errors in the console. Let's try clicking on the image. As we do, the URL of the image is being logged.
02:51:34.975 - 02:52:11.215, Speaker B: It's not very exciting. All we're doing is sending the data back and forth between the parent and child components. However, it does show how we can communicate data between components. So you may have noticed the value of the event argument. Unlike last time, the event argument is not an object with dozens of properties about the event. It doesn't include information like the name of the element we clicked on. Whenever we're creating custom events, we have complete control over the event argument.
02:52:11.215 - 02:52:39.495, Speaker B: We can choose to send simple data. It depends on the needs of your event. Keep that in mind when working with custom events. That wraps up this lecture. We've learned how to communicate between components. It's one of the most common ways to work with data in components. In the next lecture, we're going to look at an alternative option for passing down content from the parent component to the child component component.
02:52:39.495 - 02:53:19.303, Speaker B: In this lecture, we're going to add content projection to our post component. The post component displays an image. Captions can accompany images. We should add an option for adding captions to our images. The caption should come from the parent component. So far we've learned how to pass down data from the parent component to the child component. We can add an input to a property in the post class to allow the parent component to configure it.
02:53:19.303 - 02:54:03.785, Speaker B: However, it may not always be the best way to pass down content. What if we want to pass down HTML content? Our caption can be as simple as a paragraph tag to a complex structure of elements. We can use inputs to accomplish this task, but I'm not a fan of writing HTML inside my classes. Instead of using inputs, we can accomplish this task with content projection. It sounds scary, but I promise it's not. Content projection is the process of loading content inserted into a components tag. Let's open the app component template File components are written with opening and closing tags.
02:54:03.785 - 02:54:28.411, Speaker B: Like other HTML elements. Elements defined by the browser can have content inserted in them. For example, our paragraph tags have content. If we want, we can add more tags. This would create a nested structure. We can do the same thing with our custom components components. Receiving content can load content anywhere in the template.
02:54:28.411 - 02:55:03.265, Speaker B: By default, Components will ignore the content inserted in between the tags. We need to tell Angular where to insert the content. This process is called Content projection. Let's pass in a pair of paragraph tags with some dummy content inside the post component. Next, open the post template file. We need to tell Angular where to load the content. Angular creates a custom element for handling most of the work.
02:55:03.265 - 02:55:34.365, Speaker B: Below the image tag, we will add the NG content element. The NG content element will search for content inserted into our components tags. If it finds something, the element will be replaced with the content. If nothing is found, the component won't render anything. Inserting content is completely optional. Even if we have the NG content component inside our template. Let's check out the browser.
02:55:34.365 - 02:56:20.679, Speaker B: The caption has been added to our template. By using Content Projection, we can pass down HTML content from the parent component to the child component. It's another option at our disposal. Many libraries will use content Projection for creating skeleton components. We can extend these libraries by inserting HTML content. In the next lecture, we're going to shift our focus to lifecycle functions. In this lecture, we are going to learn about lifecycle hooks.
02:56:20.679 - 02:56:50.065, Speaker B: Throughout this section, we've seen how we can interact with components. Angular gives us the option of having refined control over the changes in our components through lifecycle hooks. They are functions that run during events in our components. Specifically, they run when components are experiencing changes. There are a lot of lifecycle hooks in Angular. Some are more common than others. Let's start with the simpler hooks.
02:56:50.065 - 02:57:18.995, Speaker B: The first hook is the constructor function. We will be working inside the Post component class. Inside this class, add the constructor function. Technically, this is not a hook run by Angular. Instead, it's a default hook in the JavaScript language. It gets called during the initialization of our component. It is the first function that will run whenever we use our component.
02:57:18.995 - 02:57:53.271, Speaker B: Inside this function, let's log a message. There's another hook for when our component is initialized. It's called the ngoninit function. Inside our class, we will define this function like before, we will log a message. We can write the ngoninit function in our component without a problem. However, it's not considered good practice. There's a better way to write this function.
02:57:53.271 - 02:58:34.687, Speaker B: We can implement an interface. We learned about interfaces in the TypeScript section of this course. They are blueprints for objects to help the compiler understand the properties and methods inside an object. Angular defines a set of interfaces for lifecycle functions in a component. There are two benefits to adding them to our component let's look at what those are at the top. We can update the Angular core package to include an interface called oninit. Previously, we learned how to apply interfaces on objects with curly brackets.
02:58:34.687 - 02:59:11.901, Speaker B: Syntax we can apply interfaces to classes by adding the implements keyword after the class name, followed by the name of the interface. Let's implement the one interface to the class. After adding this class, we're going to get an error. The error we're receiving is the first benefit of implementing an interface. The error is telling us we haven't properly added the ngoninit function to the class. It might be confusing at first, but it's not. Once we look at the error carefully.
02:59:11.901 - 02:59:46.713, Speaker B: I've purposely misspelled the function. The letter o is capitalized. After updating the letter, the error on the class is gone. Implementing an interface can help us catch mistakes like these. Typos are a common problem in programming. You may be thinking, what if we misspelled the interface name in the import statement? For example, I'll change the o from uppercase to lowercase. After doing so, TypeScript will throw an error.
02:59:46.713 - 03:00:12.135, Speaker B: It's telling us this interface does not exist. Therefore, it's practically fail proof to misspell the interface accidentally. I'll undo this change. One last thing to point out. Let's hover our mouse over the ngoninit function. The editor will give us a description of this function. It's a great way to learn more about a function in case you forget what it does.
03:00:12.135 - 03:00:56.735, Speaker B: By implementing this interface, we can avoid typos and we are given a description of the function. It's always considered good practice to implement an interface for lifecycle hooks. In the resource section of this lecture, I provide a link to the Lifecycle Hooks documentation page. This page will provide us with detailed information on the various Lifecycle hooks in Angular. If you scroll through the page, you're going to come across a complete list of lifecycle functions. I recommend checking it out if you want more information about each hook. Let's go back to the editor.
03:00:56.735 - 03:01:34.101, Speaker B: The ngoninit function will run when the component is initialized with the data. It's completely different from the constructor function. The data will have changed from both functions. To better understand, let's update our log statements to include the post image property. What do you think will happen? Do you think we will see the same values? Let's find out. Refresh the browser with the console opened. After refreshing the page, our application is broken.
03:01:34.101 - 03:02:06.993, Speaker B: The error message summarizes the issue on top of providing an explanation. A link To a page with more information is provided. This is another interesting feature of Angular. If we are experiencing errors, Angular provides links with detailed information as to why the error is occurring. Let's check out the link. The error is called Required input is accessed before a value is set in our code. We're trying to access the PostImage input from the constructor function.
03:02:06.993 - 03:02:38.685, Speaker B: At this point, the postimage variable is not ready. Angular is trying to tell us this signal cannot be used from our function. Understanding this behavior is crucial. Angular does not guarantee a value is ready immediately when the class is created. If we attempt to access input data, we should wait until the data is ready. To fix this issue, we must go back to our editors. We're going to remove the post image signal from the console statement.
03:02:38.685 - 03:03:09.951, Speaker B: Next, refresh the page. Great. Our app is working. If we look in the console, the ngoninit function is executed. The value from our input is logged. The ngoninit function runs after binding has occurred. If we need the data from the parent to be available when the component is initialized, we should use the ngoninit function just like the constructor function.
03:03:09.951 - 03:03:48.921, Speaker B: This hook runs once. It's a great hook for making the changes to our component after the data has been sent down. Let's explore the other hooks in the next lecture. In this lecture, we are going to explore the other lifecycle hooks. Before we begin, I don't recommend stressing over every hook. It's likely you won't need every hook. I'll be sure to point out the most common hooks in Angular applications.
03:03:48.921 - 03:04:26.263, Speaker B: The constructor and ngoninit hooks are some of the common hooks you may come across. They're so common the CLI adds these hooks to a generated component. We will start with the ngonchanges and NG do check hooks. First, we should implement their interfaces. We are continuing to work in the post class at the top of the file. Update the import statement for the on changes and do check interfaces. You may need to format the import statement.
03:04:26.263 - 03:05:03.077, Speaker B: It is starting to get long. Next, let's implement these interfaces to the class. We can add multiple interfaces to a class by separating them with a comma. Lastly, let's define both functions. The name of the functions is ngonchanges and ngdocheck. Inside both functions, let's log some messages. Both functions have similar behavior.
03:05:03.077 - 03:05:41.191, Speaker B: Unlike the ngoninit lifecycle hook, these two functions will run multiple times for different reasons. The ngonchanges function will run whenever changes are made to the component. For example, let's say we update The URL to the image. This function will run whenever that happens. In fact, it's guaranteed to run once in our component. Keep in mind the postimage property is set to an empty string. After the data has been passed down from the parent component to the child component, the postimage property will be updated.
03:05:41.191 - 03:06:17.775, Speaker B: Therefore, Angular will run the ngonchanges function, moving on to the next function. The ngdocheck function runs after a change detection cycle has occurred. We've talked about change detection before. It's the system Angular uses for synchronizing a component's data with its template. Angular is not picture perfect. It's possible it may overlook an area in our app during change detection. The purpose of the ngdocheck function is to perform updates that Angular may miss.
03:06:17.775 - 03:06:57.973, Speaker B: Rarely will you need this function, but it is available whenever Angular fails to update your component properly. The ngdocheck function can be useful for performing changes when Angular doesn't want to. Let's test out both functions in the browser. In the console, the ngonchanges function runs once. Take special note of the order of the messages. This function runs after the constructor function, but before the ngoninit function. It makes sense since the ngonchanges function happens immediately after changes.
03:06:57.973 - 03:07:32.857, Speaker B: In our component, the ngdocheck function runs twice. As a reminder, the change detection system in Angular will run twice to check for errors. Therefore, we can expect this function to run twice. It'll continue to run whenever change detection is triggered. For example, I click on the image, the ngdocheck function gets called. Even though our component isn't changing, this function will still run. There are four more hooks we need to talk about before we get into them.
03:07:32.857 - 03:08:11.831, Speaker B: We need to distinguish between the view and content in a template. In Angular, content is placed into two categories. They can either be view or content. The view refers to the content inside the template file, whereas the content refers to the projected content from the parent component. Angular processes both categories of content separately. To better understand, let's check out the app template file inside the post tags. We are inserting content into the component.
03:08:11.831 - 03:08:51.747, Speaker B: This process is called content projection. Even though we're inserting this content into the component, we don't have access to the properties from the post component. For example, the post component has a property called post image inside the projected content. We can't access this property. If we were to write an expression for the post image property, we would receive an error. The postimage property is inaccessible. Since we're in the app component, Angular will Process the template in the app component before sending it to the Post component.
03:08:51.747 - 03:09:22.293, Speaker B: That's important to understand. The Post component is not expected to process the content. Expressions or bindings in our projected content will be processed from the parent component. Next, the template is sent to the child component. After it's been sent to the post component, Angular will begin processing the expression and bindings in the post component. These are two separate events. The projected content is called Content.
03:09:22.293 - 03:09:43.677, Speaker B: The content in the components template is called View. With that information in mind, there are four lifecycle hooks. Two for the content and another two for the view. Let's explore all of them. Switch back to the Post class. Let's go to the top of the file. We will need to import their interfaces.
03:09:43.677 - 03:10:25.371, Speaker B: They're the following. After contentinit After Content checked. After View init After View checked. Next, let's apply these interfaces to the class. Lastly, let's define the functions required by these interfaces. The names of the function reflect the names of the interfaces. They are prefixed with the letters ng Inside each function.
03:10:25.371 - 03:11:01.371, Speaker B: We will log a message to identify them in the console. In total, you should have defined four functions. Be sure to pause the video so that you have what I have. Let's go through these functions one by one. The first function is called ngaftercontentinit. As you can probably tell by the name, this hook refers to the projected content from the parent component. It runs after the content has been initialized.
03:11:01.371 - 03:11:33.235, Speaker B: The expressions and bindings have been processed. At this point, the projected content has been inserted into the child component. The second function is called ngaftercontentchecked. This function runs after the content has been checked for changes. The third function is called ngafterviewinit. This function runs when the components template has been initialized. The last function is called ngafterviewchecked.
03:11:33.235 - 03:12:07.975, Speaker B: This function runs when the components template has been checked. The View, init and ContentInit functions run once they run before their checked function counterparts. It is the first time the content has been processed. The content checked and viewchecked functions can run multiple times. They will be called whenever Angular's change detection system runs. Let's refresh the page in the browser. In the console, we will find four messages.
03:12:07.975 - 03:12:42.795, Speaker B: Notice how the content function runs before the view. The projected content functions will always run first. These hooks are not commonly used, but they are available if you need them. There's one last hook we will discuss. Switch back to the editor at the top of the post class file. We will update the import list one more time, we will include an interface called OnDestroy. Next, we will implement this interface.
03:12:42.795 - 03:13:20.699, Speaker B: Afterward, we will define the ngondestroy function in the class. Lastly, we will log a message. The OnDestroy hook will run when the component is destroyed. We can remove components from the page when we don't need them anymore. If the component is being removed from the document, Angular will run this hook. It'll give us the opportunity to remove functionality to prevent memory leaks. Unfortunately, we won't have a chance to test this function.
03:13:20.699 - 03:13:55.483, Speaker B: We haven't learned how to destroy components yet. That wraps up the lifecycle. Hooks for this lecture It's a lot of hooks to work with. Luckily, you won't need every single one of them. At most, you will probably use two or three hooks in a single component. The most commonly used hooks are the constructor, ngoninit, ngonchanges, and ngondestroyhooks. Before we move on, there's one last warning I want to give.
03:13:55.483 - 03:14:41.637, Speaker B: Hooks that run multiple times can impact the performance of your app. If you need to use these hooks, make sure you're not performing an intensive action. Otherwise, the performance of your app may suffer. In the next lecture, we will continue learning about components. In this lecture, we are going to discuss how Angular treats CSS in components. You may be surprised behind the Scenes Angular treats component CSS differently than global css. Being aware of these features will prevent you from running into problems.
03:14:41.637 - 03:15:25.121, Speaker B: Let's dive in. We have two options for applying CSS to a component. We can add CSS to the source styles. CSS file styles added to this file are applied globally to an app. However, we should add styles for a specific component in its respective stylesheet file. For example, our post component has a CSS file called Post component CSS styles created in a component CSS files are scoped. What this means is that styles can only affect a components template.
03:15:25.121 - 03:15:53.583, Speaker B: Our styles cannot affect other components. To better understand, let's look at an example. Inside this file, let's select the image tag. We will apply the width and height properties to the image. Both properties will be set to 200. Let's check out the app in the browser. The image has been resized without a problem.
03:15:53.583 - 03:16:31.095, Speaker B: However, there's something else happening behind the scenes. Let's inspect the element of the image in the developer tools. Angular has added a special attribute to the image tag. It's an ID for preventing the styles from being applied to other images. If we look to the right, the selector has changed too. Angular has modified the selector to include the custom attribute attached to the image tag. By adding this id, it can adequately select the image tag without selecting other image tags.
03:16:31.095 - 03:17:00.335, Speaker B: Our CSS has been encapsulated. If we have images in other components, they won't be resized from this component's styles. This behavior is incredibly beneficial to us. We never have to worry about having conflicting styles. If we look back at the Elements panel, we will notice something else. The template is being wrapped with the custom component tag. Our image is wrapped with the app post component.
03:17:00.335 - 03:17:43.755, Speaker B: Angular does not replace the component tag with the template. Instead, it inserts the template into the tag. In some cases, we may want to select the tag. For example, we may want to select the app post component tag. If we're going to apply styles to the app post tag from the post component CSS file, we will need to use a special sudo selector Switch back to the editor. Let's say we want to increase the font size of all text inside the component. Unfortunately, we can't select the elements inside the component with the app post selector.
03:17:43.755 - 03:18:27.829, Speaker B: Instead, we need to replace it with a pseudo selector called host. This selector will tell Angular to apply the styles to the component tag wrapped around the template inside this selector. Let's set the font size property to 24px. Refresh the page in the browser. The caption we added to the image has been enlarged. Even though it comes from the app component, it's a part of the Post component through content projection that wraps up this section. We've learned so much about components.
03:18:27.829 - 03:19:10.711, Speaker B: Angular gives us everything we need to render data, handle events, communicate with other components, and apply stylings. In the next section, we're going to begin looking at how to dynamically change the output of our templates with directives and pipes. When you're ready, I'll see you there. In this section, we are going to start focusing on transforming content. Angular provides two features for helping us transform content. We can use pipes or directives. We will start with pipes.
03:19:10.711 - 03:19:35.289, Speaker B: They're the simplest to learn. A pipe is a function for transforming a value in the template. It's as simple as that. We pass in a value to a pipe function. The pipe will return a new value. This value will be rendered in the template. You may be thinking, how is this different from defining a method in a class? Pipes are not bound to a specific component.
03:19:35.289 - 03:20:06.411, Speaker B: We can define a pipe once, use it everywhere. If we are creating functions for changing a value in the template, we should use pipes. It removes clutter from our component class. This way, our component can Focus on handling other logic. Another feature worth noting about pipes is that they don't change the original value. The purpose of a pipe is to transform the value for the template. The original value will remain the same in the class.
03:20:06.411 - 03:20:38.885, Speaker B: It can be convenient to use a pipe instead of the alternative. For example, let's say we are storing the price of a product. We may want to store this value as a number. However, we may want to prefix the price with a currency symbol in the template. Even though it's one character, we would need to change the property type to a string. Currency symbols are not supported in the number type. One solution would be to create two properties to store the price.
03:20:38.885 - 03:21:27.387, Speaker B: However, this duplication can clutter our code. Instead of storing the same property twice, we can create a pipe for adding the currency symbol in the template. The property would remain a number in the class. Pipes are helpful because they help us change the appearance of a value for the template without changing the original value. In the next lecture, let's get started with pipes in this lecture, we're going to start exploring some pipes. Angular comes with a couple of pipes built into the framework. We have the option of creating custom pipes too.
03:21:27.387 - 03:21:52.765, Speaker B: We will start with Angular's pipes. They should cover most cases. Let's view the documentation for Angular. Let's take an opportunity to talk about navigating the documentation. On the sidebar, there are links to guides, tutorials and a playground. On this page, we're given a list of all available classes and functions from Angular. Above the list, you can filter the results.
03:21:52.765 - 03:22:24.039, Speaker B: Let's click on the Pipes option. As you can see, we are given a complete list of pipes shipped with the framework. I find Angular to be heavily documented. Almost every corner of the framework has been documented for you. Before checking out the documentation, we should verify we're viewing the latest version. Angular regularly pushes updates. This means there are different versions of the document for each release.
03:22:24.039 - 03:22:51.305, Speaker B: We should always check reviewing the documentation for the correct version. Otherwise, we may be working without dated information. On the sidebar, we can select the version. By default, the documentation will select the most recent stable version of the framework. Let's shift our focus back to the list of pipes. We will be exploring most of these. From this list, click on the title case.
03:22:51.305 - 03:23:24.765, Speaker B: Pipe Class this is the first pipe we'll be using. When trying to learn a new pipe, there are two crucial pieces of information you should check out. The first step to using any pipe is to import it. It's not automatically available in our components. When importing a pipe, you must import it from the correct package. Every class provides the package name at the top of the documentation page. For the Title case pipe, the package is called angular Common.
03:23:24.765 - 03:23:54.007, Speaker B: The second most important piece of information is the class name. If you scroll to the API definition, we're given the class name. When importing the class from this package, you must use this name. So what does this pipe do? This pipe will capitalize the first letter of each word in a string. Any other characters will be lowercased. The goal of the Title case pipe is to output. It works for names too.
03:23:54.007 - 03:24:26.137, Speaker B: This pipe can be helpful for providing consistent formatting for titles and names. Let's apply this pipe to our name in the app component. Open the App component class at the top of the file. Import the Title case pipe class from the angular common module. After importing the class, we must register it with our component. We can do so from the imports array. We're not limited to importing components.
03:24:26.137 - 03:24:59.353, Speaker B: Pipes can also be added to this array. Let's add the Title case pipe class to the array. After adding the class, we can start using the pipe. Next, let's open the app template file inside the first paragraph tag. We are going to update the expression. We can apply a pipe by adding the pipe character followed by the name of the pipe. Finding the pipe character can vary from keyboard to keyboard.
03:24:59.353 - 03:25:30.425, Speaker B: Typically it can be found above the enter key while holding the shift key. For this example, we will apply the Title case pipe. Pipes are applied after the expression has been evaluated. Whatever value gets evaluated from the expression will be passed onto the pipe. The pipe will return a formatted value. The formatted value will be outputted onto the page. Let's check out the page in the browser.
03:25:30.425 - 03:25:53.457, Speaker B: The name has been properly title cased. Perfect. You may notice the name below hasn't been changed. If you can recall the second expression will use a method for returning the property. Pipes do not directly modify properties. This is very important to remember. The purpose of a pipe is to transform the output.
03:25:53.457 - 03:26:36.769, Speaker B: The value in the class will remain unchanged. Pipes are incredibly helpful for formatting a value before rendering it on the page. The value for the name property will always be lowercase, even after running it through a pipe. Let's continue our journey in the next lecture. In this lecture, we're going to take a break from pipes to learn about the Angular dev tools. It's an official tool from the Angular team for debugging applications applications in the browser. It's a relatively new tool from the Angular team.
03:26:36.769 - 03:27:14.377, Speaker B: In the resource section of this lecture, I provide a link to this tool let's give the development tool a try. On this page, there should be a link for installing this extension. You have the option of installing the extension for Firefox or Google Chrome. If you're using another browser, you may need to switch on the store page. Install the extension the extension should have created an icon at the top right corner of the browser. By default, the icon will be black. If we click on the icon, the extension will tell us it hasn't detected the Angular app.
03:27:14.377 - 03:27:43.997, Speaker B: Let's switch over to our app almost immediately. The icon will turn red if we click on it. Angular has been detected by the extension, however. Where are the tools? The developer tools must be opened for viewing the new tool. There should be a new panel called Angular. On this panel, we will find a hierarchy of components for our application. We can select the components to view its data.
03:27:43.997 - 03:28:16.491, Speaker B: For example, if we click on the Post component, we can check out the properties inside the component. Not only will the tool show us the component's properties, but it'll also categorize the properties. It makes it easier to sort through our data. The properties are not read. Only we can freely modify these properties. Any changes we make to the properties will be reflected in our app. The main reason I'm showing the Angular dev tools is to show how pipes affect our properties.
03:28:16.491 - 03:28:46.197, Speaker B: Switch over to the app component. The value for the name property has not changed. It remains lower case. Even though we've applied a pipe to this property in our template, the pipe did not change the value in the class. The developer tools are a great way of verifying this behavior. Pipes do not change the properties, they change the output in the template. We'll be using the dev tools from time to time to help us debug our application.
03:28:46.197 - 03:29:24.289, Speaker B: In the next lecture, we'll jump back into pipes. In this lecture, we will learn how to customize the output of a pipe through parameters. At the end of the day, pipes are functions. Pipes can have arguments to modify the behavior or output. You can refer to the documentation of a pipe to learn more about its arguments. Not all pipes are configurable. For example, the title case pipe does not have parameters.
03:29:24.289 - 03:29:56.065, Speaker B: We'll have to explore a different pipe. For this demonstration, we are going to learn about a new pipe called Date. The date pipe will format a valid date object. This pipe can be useful for rendering friendlier dates to users. It gives us complete control over the formatting of a date. Unlike the title case pipe, the date pipe has a parameter for modifying the date format. To get started, let's Create a date object Open the App Component class file.
03:29:56.065 - 03:30:28.371, Speaker B: We will create a property called Current date. We want this property to be a signal, so let's set the value to the signal function. We're also going to give this signal an initial value. Its value will be a new instance of the date object. The date pipe can work with three types of values. We can use numbers, strings, and date objects. I think working with a date object will be the easiest.
03:30:28.371 - 03:31:18.125, Speaker B: By default, new instances of the date object will store the current date and time. We can avoid trying to guess the current date with a string or number. In addition, it's clearly impossible for a date object to store a value other than a date, whereas a string may have a typo. If we attempt to pass an invalid value to the date pipe, we may encounter unexpected behavior. In most cases, I recommend applying date pipes to date objects for the most accurate results. This let's switch over to the App template file. At the bottom of the template, we will add a paragraph tag with the following Current date Let's switch over to the browser.
03:31:18.125 - 03:31:51.975, Speaker B: Date objects can be rendered in a template. However, the formatting isn't appealing. Ideally, the format of a date should be the month, day, and year. At the same time, we shouldn't modify the date object. In some cases, you may want to work with date objects for sorting. JavaScript allows for arrays to be sortable with dates. In this scenario, applying the date pipe will allow us to format the date without directly modifying the date object.
03:31:51.975 - 03:32:22.415, Speaker B: Let's fix the formatting with the date pipe. Switch back to the class file in the editor. To use the date pipe, we must import the class, which is also available for the common package. In this import statement, include a class called datepipe. Next, add it to the Imports array. Great, we can start using the date pipe. Switch over to the components template.
03:32:22.415 - 03:33:01.305, Speaker B: We will add the date pipe after the current date expression. By default, the date pipe will format the date by displaying the month, day, and year. Everything else will be removed. It's possible you may see a different format based on your current environment or when you're taking this course. For a consistent format, I recommend passing in a format. The date pipe's first parameter is the format for the date. We can add a parameter by adding a colon after the name of the pipe followed by the value.
03:33:01.305 - 03:33:43.941, Speaker B: A parameter for a pipe is the equivalent of passing in a value to a function's argument list. In the Resource section of this lecture, I provide a link to the datepipe class. On this page, there's a tab called Usage Notes this section provides an extensive list of formatting options. If you scroll through the page, you're going to come across a table called Custom Format Options. Under the format column, there are various placeholders available. These placeholders will be replaced with their true value from the date object. The date type will take care of replacing the placeholders with the appropriate value.
03:33:43.941 - 03:34:14.335, Speaker B: For example, let's say we want to output the month and day according to the table. We have five formats for displaying the month. Angular does a good job of accounting for various formats. Let's use the MMM placeholder. As for the day, we will stick with the D placeholder. Back in the editor, we will pass in the placeholders. The value of the placeholder must be passed in as a string.
03:34:14.335 - 03:34:46.585, Speaker B: Be sure to wrap the values with quotes. As for the arrangement, the month should appear before the day. If you'd like, you can reverse the arrangement for a different format. Feel free to explore the various formats at your disposal. Switch over to the browser. The date has been properly formatted according to our specifications. Choosing a format is a powerful feature, but there is an alternative solution for those who prefer to let Angular format dates.
03:34:46.585 - 03:35:23.233, Speaker B: The value of the format does not need to be a series of placeholders. Alternatively, Angular provides a set of predefined formats. Let's switch back to the documentation page. On this page, there's a section called Predefined Format Options. Instead of passing in a format, we can pass in a predefined format. Angular will format the date based on the rules in the equivalent to column. The Angular team provides these formats for the most popular date formats in the community.
03:35:23.233 - 03:36:14.059, Speaker B: You may prefer to use predefined formats as a shortcut. It'll save you time from scrolling around the documentation for outputting the desired format. For example, we can use the short option instead of typing the same format with placeholders, Angular will be able to format the date regardless of the absence of placeholders. According to the table, the format renders the month, day, year, and time. We're going to wrap up our discussion of the date pipe. In the following lecture, we will explore some more pipes. In this lecture, we are going to learn about two pipes for formatting numbers.
03:36:14.059 - 03:36:44.795, Speaker B: They're the decimal and currency pipes. Both can format numeric values. Formatting numbers is a common problem you'll encounter in app development. Let's start with the currency pipe. The currency pipe will format a number by adding a currency symbol before the value. On top of adding a currency symbol, the currency pipe can format a number with a fixed decimal Size. If our value requires decimals, they will be added automatically.
03:36:44.795 - 03:37:14.185, Speaker B: First, we will need to create a property for storing a number. Open the app component class file. Inside this class, we will add a property called Cost. Set the value to the signal function. Whenever we create new properties, they'll most often be signals. Since we may need them to be reactive, let's give our signal an initial value. Its value will be 2000.
03:37:14.185 - 03:37:49.045, Speaker B: This property will hold the cost of some imaginary product. After defining this property, we're going to output it with a currency pipe. First, we'll have to include it at the top. Update the angular comment package to import a class called Currency Pipe. In addition, let's also import a class called decimalpipe. We'll be using this pipe in a few minutes. After importing those classes, add them to the imports array.
03:37:49.045 - 03:38:28.921, Speaker B: Let's update the app component template to output the price with the correct currency symbol. Below the other paragraph tags, we will add a paragraph with an expression. The expression will be the cost property with the currency pipe. Next, let's refresh the page. The currency pipe has transformed the output. It's prefixing the number with the dollar sign symbol. Two decimals values have been appended to the output.
03:38:28.921 - 03:39:01.335, Speaker B: This is the standard formatting for rendering US Currency. Neither the symbol nor decimal values were a part of the original value. Angular was able to apply the correct formatting to our number. We may want to change the currency. The currency pipe has a parameter for modifying the currency. We need to provide this pipe with the currency code. In the resource section of this lecture, I provide a link to a list of standard currency codes called ISO 4217.
03:39:01.335 - 03:39:36.295, Speaker B: This page contains a comprehensive list of currency codes. Angular supports various currencies by their codes. For example, let's say we want to change the currency to the Japanese yen. We can pass in the code to the currency pipe to modify the current currency. Back in the editor, we will pass in a string with the currency code. The currency code for the Japanese yen is jpy. Switch back to the page in the browser.
03:39:36.295 - 03:40:05.145, Speaker B: The pipe will format our value correctly. There is one thing to keep in mind about this pipe. It will format our value, but it will not convert the value. There's a difference between formatting and conversion. Currencies constantly change value. You will need to make sure the currency is properly converted before formatting it. For example, 2000 USD is not equal to 2000 yen.
03:40:05.145 - 03:40:27.705, Speaker B: Let's move on to the next pipe. The other pipe is called Decimal. It functions similarly to the currency pipe. It deals with numeric values. We can use it to format numbers by adding or removing decimal values. For example, we may want to output the temperature. Calculating the temperature may result in a decimal value.
03:40:27.705 - 03:40:59.139, Speaker B: Typically, it's not common to output the temperature with a decimal value. A lot of apps stick to outputting whole numbers. We should strip the decimal values from the temperature if they're present. Switch over to the app component class. Inside this class, we will add a property called temperature. Set the value to the signal function. Our signal's initial value will be 25.3.
03:40:59.139 - 03:41:33.243, Speaker B: The 0.3 portion of the value should be removed from the property during the rendering of the template. This is a good opportunity to apply the decimal type. Switch over to the template file. We will add another set of paragraph tags. Inside these tags, we will create an expression for the temperature property with the number pipe. The name of the pipe is completely different from the class name.
03:41:33.243 - 03:42:03.361, Speaker B: If you ever look up the documentation for this pipe, the official name is called Decimal. Typically, the class name is the same as the pipe name. In this case, the names are not equal. Keep that in mind whenever you're working with pipes. The class names are not used as the pipe names. By default, applying the number pipe to a property will output the number without formatting. It's almost as if you didn't apply the pipe.
03:42:03.361 - 03:42:28.205, Speaker B: In most cases, you will want to configure the formatting. The number pipe can be configured by passing in a string. The format for the string is a bit funky. Let's think about the format of a number. Numbers are formatted with whole numbers and decimals. These portions of a number are separated by a dot. Angular allows us to format both portions separately.
03:42:28.205 - 03:43:10.887, Speaker B: The beginning of the format will apply to the whole number portion of a numeric value. It's the minimum number of digits that should appear on the left side of the number. Angular will append zeros to compensate for the desired length if the number falls short of the specified length. For example, if we input 5, Angular will prefix our number with three zeros to reach the desired length. For this demonstration, we are going to set the length to 1. If the length exceeds the specified length, angular will not do anything. Next, we can add a dot to start configuring the decimal portion of the number to the dot's right.
03:43:10.887 - 03:43:46.175, Speaker B: We can set the minimum and maximum number of digits for the decimal value, respectively. Let's pass in 00. The first number will set the minimum. The second number will set the maximum. By setting both numbers to zero, angular will not allow the value to have Any decimal values, the number pipe will strip them away from the value. Let's say we change the minimum and maximum to 2 and 5. This value will tell the number pipe to output a number with at least two decimal values.
03:43:46.175 - 03:44:13.665, Speaker B: If the value has more than five digits, the additional decimal values will be stripped out. Time to refresh the page as we wanted. The temperature will display a whole number. The decimal values have been taken away from the value. Perfect. We've successfully learned two more pipes for formatting numbers. Let's move on to more pipes in the next lecture.
03:44:13.665 - 03:44:52.705, Speaker B: In this lecture, we are going to talk about one more pipe for helping us debug our applications. It's called the JSON Pipe. In the resource section of this lecture, I provide a link to this pipe's documentation page. According to the description, it was added to help with debugging. It's not meant for production apps. The JSON pipe will output an object or array onto the page. Let's create an object to output in our template.
03:44:52.705 - 03:45:25.125, Speaker B: Open the App component class file. Just like any other pipe, we must import it. If you were to look at the documentation, it states the JSON pipe can be found from the Angular Common module. Update this import statement to include the JSON pipe. Next, let's update the imports array from the component decorator. Add this class to the array. To test this pipe, we're going to create an object.
03:45:25.125 - 03:45:51.315, Speaker B: Create a property called pizza. Set the property to the signal function. The initial value will be an object. It will have two properties called toppings and size. The toppings property will be an array of pizza toppings. Feel free to add your preferred toppings. As for the size property, we'll set it to large.
03:45:51.315 - 03:46:31.543, Speaker B: Next, let's output this property. Open the app template file. Underneath the paragraph tags we will add some pre tags. Inside these tags we will add an expression for the pizza property with the JSON pipe. Without this pipe, the browser would not output the object. Let's check out the page in the browser by using the JSON pipe. We have another way of viewing the contents of an object outside the developer tools.
03:46:31.543 - 03:47:10.733, Speaker B: It's great for debugging, but it's not useful other than for development. We will be using this pipe to help us debug our app from time to time. Be sure to remember it. In the next lecture we will move on to the next topic for transforming content. In this lecture we are going to start learning about directives. You can think of them as custom attributes for transforming content. Browsers have various attributes for affecting the behavior of an element.
03:47:10.733 - 03:47:50.649, Speaker B: For example, the target attribute on an anchor element can change how a link is opened in the browser. Browsers define dozens of attributes to alter an element's behavior. In some cases, we may want to create custom attributes instead of creating an entire component. Angular gives us this power through a feature called Directives. We can apply directives to native HTML elements or custom components. They're more flexible than regular attributes. In the Resource section of this lecture, I provide a link to an official list of directives defined by Angular.
03:47:50.649 - 03:48:42.453, Speaker B: If you cannot see the list of directives, you can filter the list by selecting the Directives option. We are going to put our focus on the directives defined under the common package. The other directives will be explored in other sections of the course. Angular refers to these directives as attribute directives. Attribute directives focus on changing the appearance or behavior of an element. For example, if we want to dynamically add styles to an element, this type of directive would be considered an attribute directive. In this lecture, we are going to learn our first directive called the NG class directive.
03:48:42.453 - 03:49:11.955, Speaker B: It's an attribute directive, therefore it'll change the appearance of an element. The NG class directive allows us to change the classes of an element based on conditions dynamically. Let's give it a try. Before we start exploring this directive, we should make some room in our component. It's starting to get cluttered. Open the app component template file. At the top of the file, we will add an HR tag.
03:49:11.955 - 03:49:51.345, Speaker B: Next, open the app style sheet file. We will select the HR tag with some margins to give our template some spacing. Alright, let's begin using this directive. For this demonstration, we will create a button for toggling a class. We should define a class for changing the background and text color of an element. Inside this style sheet, let's define a class called blue. This class will change the background color to blue and the text color to white.
03:49:51.345 - 03:50:30.385, Speaker B: Next, open the app component file. Before we can toggle the class, we should create a property for managing the state of the class. We will create a property called blue class. Set the property to the signal function. Its initial value will be set to false. The property we've created will be used as the condition for toggling a class. If the blue class property is set to false, the blue class should not be applied to an element.
03:50:30.385 - 03:50:59.003, Speaker B: Vice versa, if the property is set to true, we should load the blue class on the element. Let's begin Dynamically binding this class to an element. At the top of the file, we must import the directive. The class directive can be found from the common module. It's called NG Class. We could add this class to our imports array. However, you may have noticed that our import statement is becoming large.
03:50:59.003 - 03:51:33.905, Speaker B: There's nothing wrong with importing each individual class into our components. It's perfectly fine. On the other hand, things are starting to become cluttered. If you find yourself using a lot of directives, pipes, and components from Angular, you may want to consider importing the module. The common module can be considered a shortcut for importing all directives, pipes, and components offered by Angular. Let's replace these values with a class called Common Module in our Imports array. Replace everything with the Common module class except our post component.
03:51:33.905 - 03:52:05.497, Speaker B: For for custom components, we must continue importing them manually. Alright, let's start using our directive. Switch over to the template. Add a button element before we apply the directive, we should toggle the property. The button we're creating should listen for Click events. Bind the Click event on the button. Remember to add the parentheses around the event name.
03:52:05.497 - 03:52:39.893, Speaker B: Otherwise we won't be able to run an expression after the event is emitted. Inside this expression, we're going to call the blue class set function. To update the signal, we're going to set the signal to its opposite value. In an earlier section, I mentioned how logic should be outsourced to functions. This recommendation still holds true. However, we are not performing complex logic. Clicking the button should toggle the property, nothing more.
03:52:39.893 - 03:53:13.963, Speaker B: If we have something as basic as toggling a property, it's much quicker and easier to write it inline. You can consider it an exception to the rule. The last step is to dynamically add the blue class to the button. The NG class directive is designed for this task. We can add directives by writing them like attributes. We will add the NG class directive to the button element. The blue class should be added to the button if the property is set to true.
03:53:13.963 - 03:53:44.075, Speaker B: At the moment, we can't bind this class dynamically. If we were to pass in the blue class, Angular would add the class to the element. It's the same as using the class attribute. Dynamically binding classes to an element requires property binding. Surround the directive with square brackets. The NG class directive supports various formats. The most common type of format is an object.
03:53:44.075 - 03:54:20.659, Speaker B: Object syntax allows us to add multiple classes dynamically. The property name will represent the class we'd like to add to the element. The value will be processed as the condition. Therefore, we can add the blue class to this object. Its value will be blue class property. If this condition evaluates to true, our blue class will be added to the element. If the class already exists, but the condition evaluates to false, Angular will remove the class.
03:54:20.659 - 03:54:54.741, Speaker B: You can add as many classes as you'd like. Let's refresh the page in the browser. If we click on the button, the blue class gets toggled on the element. It's working perfectly. One question you may have is why don't we bind the class attribute? That's a good question. Unlike the NG class directive, binding, a regular attribute does not support object syntax. If you were to bind the class attribute to the same value, the class would not get toggled.
03:54:54.741 - 03:55:46.617, Speaker B: The Angular team has introduced the NG class directive for easily toggling classes on an element. That wraps up our discussion on the NG class directive. It's a very powerful directive for dynamically binding classes to an element. In the next lecture, we will look at an alternative solution to the NG class directive. In this lecture we are going to explore another attribute directive called ngstyle. This directive allows us to dynamically bind CSS properties through the style attribute. The syntax for the NG style directive is very similar to the NG class directive.
03:55:46.617 - 03:56:27.979, Speaker B: It's a great directive for changing one or two properties on an element instead of applying an entire class, let's give it a try by changing the font size of the button in our template. First, we should store the font size in our components class. Open the App component class. Inside this class, we will create a property called font size. As usual, set the property to the signal function. Its value will be 16. The next step is to bind this property to the button's font size with the NG style directive.
03:56:27.979 - 03:56:56.837, Speaker B: Let's open the app template file. On the button. We will add the NG style directive with property binding. Once again, we're binding the directive. By default, directive values are not interpreted as expressions. Binding a directive will allow us to bind the value to properties in our class. Otherwise, we won't be able to bind it to the font size property.
03:56:56.837 - 03:57:33.209, Speaker B: We will pass in an object with the font size CSS property. Notice how I'm formatting the name of the CSS property in the object. Previously, we didn't wrap the name with quotes in the NG class directive. However, the font size property is multi worded. For multi word properties, we need to wrap them with quotes. Next, let's bind this CSS property to the font size property in our class. This solution won't work yet.
03:57:33.209 - 03:57:56.815, Speaker B: Keep in mind we are modifying a CSS property. Font sizes must have a unit of measurement. We have two options at our disposal. We can add the measurement as a string. Or we can add it to the property. Adding it to the property is the shorthand way of adding the measurement. After the property name, we will add a dot followed by the measurement.
03:57:56.815 - 03:58:25.671, Speaker B: Angular will append the unit of measurement to the value. There isn't an advantage to using this syntax. It's all preference. In my opinion, it looks a whole lot cleaner than appending the measurement to the value as a string. Let's refresh the page. As you can see, the font size for the button has increased. In our app, we don't have a way to increase the font size.
03:58:25.671 - 03:59:01.021, Speaker B: Luckily, we don't need to create such a feature. We can use the developer tools to verify if the directives are working as intended. Open the Angular Developer Tools under the Components section. Angular has added additional information about our components. Previously, we would only see a list of components. However, the button element has been added to the list. Despite our app component containing other elements, Angular will show us which directives are on the element.
03:59:01.021 - 03:59:31.047, Speaker B: If we apply directives to an element or component, don't be alarmed. If you find elements that aren't components, it may have a directive on it. In the component list, we will select the app component. Next, we will modify the font size property. After making those changes, the button has enlarged. Angular is capable of updating our elements after they've been rendered. This is the power of directives.
03:59:31.047 - 04:00:17.049, Speaker B: We have two directives for changing the appearance of an element. Angular gives us flexibility for interacting with elements. In this lecture, we are going to dynamically render content with the if block. With the introduction of Angular 18, a new way of rendering content was introduced, called blocks. Blocks are not going to replace directives, but they are recommended over directives when possible. The if block can add or remove HTML elements from a document based on a condition. The if block functions similarly to an IF statement in JavaScript.
04:00:17.049 - 04:00:51.775, Speaker B: It'll execute code if a condition is true. In this case, we will display a piece of the template based on a condition. We will continue working on the app template file in our template. We can add the if block by typingif parentheses Curly braces All blocks, not just the if block. Start with the character. Just like JavaScript, we can add an expression inside the parentheses. Let's set the expression to the blue class variable.
04:00:51.775 - 04:01:27.891, Speaker B: As a reminder, this property will hold a boolean value for determining if a class should be added to a button. We are going to be using the same condition inside the curly braces. We can insert HTML. Any HTML inserted inside this block will be rendered when the condition is True. Let's add a paragraph tag with a simple message. Let's check out the app in the browser. If we press the button, the message appears in the developer tools.
04:01:27.891 - 04:01:53.493, Speaker B: We can clearly see the element. The if block is not present in the document. Angular will take care of removing the if block for us. Thus, we don't have to worry about ruining the integrity of our document, which could lead to CSS errors. We can continue to act as if it was never there. Overall, the if block is super easy to use. We're not limited to static templates.
04:01:53.493 - 04:02:33.589, Speaker B: Angular gives us the power to dynamically render content with the help of a few blocks. In the next lecture, let's look at another block for looping through an array. In this lecture, we are going to explore one more block called for. It's a block for looping through an element with an array. It's common to perform this type of action. If you think about it, a majority of apps are made up of lists. A list of users, posts, products, menu items, etc.
04:02:33.589 - 04:03:06.567, Speaker B: Everything we do revolves around lists. As it stands, if we want to output multiple posts, we need to copy and paste the post component. The problem compounds if we need to make adjustments to a specific post. It would be nice if the template could output the current number of posts without updating it as often. We can cleanly loop through an array by using the for block. This block will loop through an array in the template. The element it is applying to will get outputted on each iteration.
04:03:06.567 - 04:03:39.895, Speaker B: For this demonstration, let's try looping through an array of images. We're going to reuse our Post component. First, let's create an array. Open the App Component class file. Below the Image URL property, we will create an array called Images. When creating this property, make sure it's a signal. To keep it simple, the array will store the same set of images.
04:03:39.895 - 04:04:10.007, Speaker B: We will reuse the image we're storing in the image URL property. About three copies should do it. Next, let's open the App template file in the template search for the Post component. To use a four block, we can wrap the component with it. Inside the parentheses, we can provide a few expressions. You heard that right. Multiple expressions.
04:04:10.007 - 04:04:42.625, Speaker B: Throughout this course, we've been dealing with a single expression for each directive. For the for block, we can supply multiple expressions. It's because loops can be quite complex to work with. Let's go through some of what we can add inside the parentheses. Add the image of images in this example, we are creating a variable called image. Next, we need to Provide an array. We can specify the array by adding the of keyword.
04:04:42.625 - 04:05:25.035, Speaker B: Afterward, we can reference the array on each iteration. Angular will assign the current element in the iteration to the image variable. In this example, the image variable will hold the current post in the iteration. Another expression can be added by separating them with semicolon characters from inside the parentheses. But why would we want to do that? Well, if you noticed we're grabbing the element from the array but not the index. What if we want the index to grab the index for the current item in the loop, we must add another expression. Add the Let IDX equals dollar index.
04:05:25.035 - 04:05:56.131, Speaker B: The dollar sign index variable is always available in the for loops expression. If we want to access it inside our loop, we must create a local variable which we're calling idx. Let's add one more expression. Regardless of how many expressions you add to the block, there are two required ones. The first is the expression for the array of items to loop through. The second is a tracker. Looping through items is not as easy as it sounds.
04:05:56.131 - 04:06:31.677, Speaker B: What if you want to add interactivity to each item in the loop? In that case, Angular needs help tracking each item in the array. Therefore, we must provide a tracker which is just a unique id. To add a tracker, we can add the track keyword followed by the unique value. Let's use the IDX variable. It's important that the value is unique to each item in the array. If you're looping through an array of objects, this could be an id. However, we're just using a simple array, so the index will suffice.
04:06:31.677 - 04:07:01.605, Speaker B: We should update our component to accept the new data. Currently, the component will throw an error. Instead of passing in the imageurl property, we can pass in the image variable. The image variable is accessible in our loop. This includes the component itself. Therefore, we can pass on the image variable to the component. Overall, it's much more efficient to use the 4 block.
04:07:01.605 - 04:07:31.045, Speaker B: We don't have to copy and paste the same component multiple times. Angular will always output the correct number of posts, no more, no less. Before we verify if our loop is working, we should verify the image is unique. At the moment, we will see the same image and caption. Fortunately, we have access to the index. Let's try outputting the index inside the caption. We will add an expression for the IDX variable.
04:07:31.045 - 04:08:01.313, Speaker B: Let's test our app in the browser as desired. The image has been rendered three times on each iteration. The caption will contain the index of the current iteration. Since arrays are zero indexed, the first image will have an index of zero. We've successfully looped through the array. We're finished learning about directives and blocks. It's time to move on to the actual project.
04:08:01.313 - 04:08:51.045, Speaker B: I think you would agree with me in saying our project is starting to get cluttered. If we're going to learn more features, we should be working with an actual project we can add to our portfolio. Let's get started with a new project in the next section. It's time for the most exciting part of the course. We haven't had the chance to explore every feature in Angular, however, we've covered most of the fundamentals. If we're going to continue further, we should work on a realistic project. By working on a real project, we will get a chance to learn the best practices for structuring a project.
04:08:51.045 - 04:09:36.733, Speaker B: So what are we going to build? We will develop a project called Clips, a platform for uploading and sharing gaming highlights. Features include authentication, routing, video processing, state management, and so much more. One of the most interesting features is running a web assembly file to process video files with ffmpeg. We will be playing with cutting edge features which will surely impress recruiters. On my screen I'm showing the static design of the app we will be developing. It doesn't look like much, but believe me, it's going to take a lot of work to convert this template to a functioning app. Once we're finished with our project, we will be deploying it.
04:09:36.733 - 04:10:15.487, Speaker B: Throughout the development lifecycle of this project, you will be surprised by how helpful Angular can be. First, we need to create a new project. Open the command line in your editor. We'll be working in a completely new directory. We aren't going to be installing our project with the Basics app we worked on previously. Inside the command line, run the following command ng New Clips the CLI is going to ask us to select an option for a CSS format. We're not going to be using a preprocessor.
04:10:15.487 - 04:10:46.375, Speaker B: However, feel free to choose a preprocessor if you are familiar with any of them from this list. Afterward, we're going to be asked if we would like to use ssr. That's not something we'll need. Select no. After selecting our options, the CLI will begin creating and installing the project. This installation may take a while. After the installation is complete, let's move into the new project.
04:10:46.375 - 04:11:17.505, Speaker B: Now. The question is, where do we begin? What's the first step we should take for developing an app? It can be a daunting task to get started. From my experience, I like to start by Importing the static design. We already have the template in hand. We should start adding it to our project. In the resource section of this lecture, I provide a link to the template for the homepage. It's completely static.
04:11:17.505 - 04:11:47.163, Speaker B: I haven't done anything to this template. To prepare it for Angular. We are going to make it functional from top to bottom. Copy the entire HTML template to your clipboard. Next, open the app component HTML file. We will replace the components of this file with the code we've copied inside this file. I've added dozens of comments.
04:11:47.163 - 04:12:21.497, Speaker B: These comments will help you navigate the sections of the project. I will be referring to them whenever we need to work on a particular section. I'm going to minimize some of the sections. The home page has a total of four sections. We have the header, intro, main and authentication sections. You may be thinking, why are we adding this code to the index HTML file in the source directory? We want to make this content dynamic. Therefore we need to store our template in a component.
04:12:21.497 - 04:12:51.903, Speaker B: Otherwise we won't be able to apply pipes, directives or anything else. We need to make a template dynamic. After pasting in the contents, let's turn on the server with the ngserve command. Next, let's view the app in the browser. The app is completely broken. It looks nothing like the static design. That's to be expected since we didn't load the CSS for this template.
04:12:51.903 - 04:13:01.815, Speaker B: The template uses a framework called Tailwind, which requires a special installation process. In the next lecture we will dive into Tailwind.
04:13:11.835 - 04:13:46.495, Speaker A: Congrats on finishing the first four hours of Luis Ramirez Angular Boot Camp course. Make sure to show yourself some luck because most people, they don't make it here. But don't get too comfortable. There's still over 25 hours of additional lessons, plus a massive enterprise level project that you'll be building that'll help you master Angular. Oh, and the best part, by joining Zero to Mastery, you get access to our private Discord community where you can get help from experts like Luis and the rest of our instructor team. One last thing, if you enjoyed this video, please help me show Luis some love by dropping it a like. And of course, don't forget to leave your comments down below.
04:13:46.495 - 04:13:50.695, Speaker A: Alright, that's it from me and I look forward to seeing you inside the Zero to Mastery Academy.
