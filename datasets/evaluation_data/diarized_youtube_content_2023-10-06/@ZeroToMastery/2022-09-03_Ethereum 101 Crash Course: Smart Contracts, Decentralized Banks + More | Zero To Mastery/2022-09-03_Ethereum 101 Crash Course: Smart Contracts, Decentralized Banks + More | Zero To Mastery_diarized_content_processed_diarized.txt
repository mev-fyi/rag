00:00:04.280 - 00:00:50.694, Speaker A: What is going on guys? It is Aldo from zero to mastery and I am excited to introduce to you this Ethereum 101 crash course by Marcus Vass. In this video, Marcus will dive straight into the heart of Ethereum and smart contracts. By the end of this video you'll know all about decentralized banks smart contracts, including how to interact with them and visualize them. Bitcoin automation versus Ethereum automation Ethereum virtual machine and gas fees if you like this video, youll absolutely love Marcus full Ethereum bootcamp course. He goes much deeper and teaches you exactly how to become a solidity blockchain and Ethereum developer. If youd like to check it out, click on the link in the top right hand corner or in the description down below. Again, thats enough talking for me.
00:00:50.694 - 00:00:54.620, Speaker A: Let me hand it over to Marcus so you guys can get into the fun stuff. Enjoy.
00:01:00.880 - 00:02:01.510, Speaker B: Alright, so we know how bitcoin works now. It's a super cool, never ending stream of transactions organized in a chain of blocks. The blockchain distributed across every single bitcoin network participant a decentralized digital currency. Isn't that all we want? Are we done? Well wait, isn't there this Ethereum thing? The name sounds cool, right? But what actually is it? Well, a lot of things between bitcoin and Ethereum are actually the same. Ethereum also has a blockchain and a continuous stream of transactions, and those transactions are bundled in blocks as well. And they are also put together as this immutable chain of blocks, the blockchain. Okay, so then Ethereum came around and said, that's not good enough.
00:02:01.510 - 00:02:41.110, Speaker B: But why? Why is it not good enough? Well, I can show you best with a simple example. Think back to digital money. With banks, you dont trust banks, so you rather put your money into bitcoin. But is that all that banks do? No, obviously not. Banks these days have all kinds of services that go far beyond just managing deposited money. For example, pretty commonly you can borrow money from banks. And since banks want guarantees to get their money back with interest, you usually have to give them some security.
00:02:41.110 - 00:03:29.010, Speaker B: This could be a house, or even your stock market investments, which are then used as so called collateral. And if you don't pay back your loan according to your contract, the bank will take control of those assets. For example, they will take you home. So you see, bitcoin only solved one aspect which banks do, allowing digital money transfers but nothing else. Ethereum, on the other hand, now enables one to truly build decentralized banks. And even more than that, not just decentralized banking applications, but any decentralized application. So what's the idea? Let's talk about it in the next chapter.
00:03:29.010 - 00:04:24.534, Speaker B: New in ethereum is the concept of smart contracts. And hey, this concept is the whole reason this course here exists to begin with. So it must be pretty important. And indeed, this concept is so important, not only is it the reason for this course, it also powers a multi billion dollar industry with hundreds of thousands of users. Okay, now youre curious. So what is a smart contract? How can a contract be smart? Is it a contract made by a very clever lawyer? Is it just a very cleverly designed contract between two entities? No, not quite. The smart means something else.
00:04:24.534 - 00:05:09.170, Speaker B: So what is it? Well, the contract is smart because it's actually smart itself. It has its own brain and is making sure the rules of the contract are enforced correctly. So kind of like a contract with artificial intelligence. I like to think of smart contracts as essentially automated accounts which are immutable and verifiable. Automated, immutable and verifiable. Okay, well, what does that mean? Let's start with automated. Think back of bitcoin for a second.
00:05:09.170 - 00:06:14.220, Speaker B: Here. We have all these people sending transactions like, hey, I send you one bitcoin, then I send that person half a bitcoin and so on. And so behind every transaction is a person sending out this transaction, sending it from his bitcoin address to someone else's bitcoin address. But now imagine a bitcoin address is not a person anymore, but controlled by computer software. Who says it needs to be a person? Right? I mean, we are talking about digital money. So of course software could be behind automatically sending out transactions. And now, what does verifiable mean for software? When you have software on your computer running, do you know what exactly is actually doing? Probably not, right? But what if you developed that piece of software yourself? Well, now all of a sudden, you do know exactly what it's doing.
00:06:14.220 - 00:07:12.878, Speaker B: And now imagine you upload the source code to something like GitHub. I'm assuming you know GitHub, but for the few that don't, it's a website to share the software source code with others. And now when you share a source code like that, everyone who wants to can download the software, look at the source code and understand exactly what it's doing as well. That's what we mean with verifiable. And now what is immutable software? It means software that doesn't change its behavior once it's running. Okay, well, what does that mean? Well, when you run software on your own computer, how do you know its behavior is not suddenly changing? Unless there's a hack or there's an autoupdate function, you probably know it's not just going to change on its own. So it's kind of immutable.
00:07:12.878 - 00:07:49.900, Speaker B: But of course you could just stop the software and install a new version. Now it just changed. So really not that immutable after all. Don't worry, this might all still be kind of confusing. So far, it sounds like we could just have all automated, verifiable and immutable software for bitcoin, and that's actually true. But there is an important distinction here. So next we'll look at what that distinction is and what is so unique about Ethereum's solution.
00:07:49.900 - 00:08:50.824, Speaker B: Okay, so automated, immutable, and verifiable software is somehow quite different between bitcoin and Ethereum. What does it mean for bitcoin? Let's imagine I run a computer software that automatically trades bitcoin. You might call it a trading bot, but you could think of it also as an automated account. It listens to external input, things like who is sending me, how much money, what is the current price of bitcoin, etcetera. And it reacts by sending bitcoins to some other addresses. Where does the software run? On my computer, nowhere else. Who knows the behavior of this software? Only me.
00:08:50.824 - 00:09:25.310, Speaker B: I haven't uploaded the source code or executable binary, meaning the compiled software anywhere. So other people have no idea what my bot is doing. Only I can know. So it's verifiable, but only for me. And lastly, who can change the behavior of this software? I can personally, of course, change it. I can stop the bot, compile a new piece of software, and then run the new version. So it's actually not immutable.
00:09:25.310 - 00:09:59.906, Speaker B: So let's compare that to an Ethereum smart contract. Just like our trading bot. It listens to external inputs and reacts by sending ether. Ether is what the funds of Ethereum are called. In bitcoin, for whatever reason, we call the network and the funds the same, just bitcoin. But in Ethereum, they have two different names, Ethereum as the network and ether as the currency. Where does the software run? Not on my computer anymore.
00:09:59.906 - 00:10:48.910, Speaker B: Instead, it's a distributed software which is part of the Ethereum network. Who knows what the software is doing? Everyone. Because it's distributed, everyone has open access to it and can look at the source code to figure out what it's doing. So it's verifiable, not just for me, but for everyone who can change the behavior? Nobody. The software is running on every Ethereum node and in many cases for all eternity, as long as Ethereum exists. So it's immutable, and no one, including myself, can change that. Let's talk an experiment about what it means for the software to be distributed in Ethereum.
00:10:48.910 - 00:11:38.410, Speaker B: Like, do we have one part of the software on one machine, another part here? And then when you run the software, it has to be taken from all these different places? No, exactly the opposite. The full software exists in one piece, but is replicated on every single participant of the ethereum network, called an ethereum node. So a participant is called a node. If every single node is running the software, it's of course not very efficient. But that's the price we pay to get full verifiability and immutability. So that's a smart contract in a nutshell. An automated account that is immutable and verifiable because it runs on every node of the network.
00:11:38.410 - 00:12:21.162, Speaker B: Okay, what can we do with that? Think back to our bank loan example. Well, now you can have a smart contract which states the terms of the loan. Then a user could borrow money by putting in collateral and paying back the loan over time. But instead of a bank giving him the loan, every person can be a lender and earn interest. The borrower will only get back his collateral once the loan is paid back. If he fails to pay it back, the collateral is used to cover the loan costs. And yes, you've guessed it.
00:12:21.162 - 00:13:06.100, Speaker B: We can do all of this in a smart contract. And because it's immutable and verifiable, you don't need to trust the other people. The contract defines the rules, and those rules will be cryptographically enforced. And with that, my friends, you can build decentralized banks, decentralized applications, decentralized autonomous organizations. Your imagination is the limit. We have one problem now. We are replicating software to be run on every node of the network.
00:13:06.100 - 00:13:54.676, Speaker B: That's great. It's now fully immutable and verifiable. But if every node of the network runs the software, how is that even possible? One node might run Linux, another one macOS, and another one, even windows. They all need to run the software and come to the exact same result. But even small differences in the operating system could mean nodes are getting different results. And then we have a consensus problem again. How can we ensure that the software runs one to one identically on every machine? Well, maybe you've heard of the Java virtual machine.
00:13:54.676 - 00:14:48.754, Speaker B: The same concept applies for Ethereum. Here we have the Ethereum virtual machine, in short, EVM. And rather than running the software natively on the operating system, we create an additional abstract layer. This layer, as the name suggests, is its own machine, but you guessed it, a virtual one. And as any machine, this virtual machine also has its own stack, memory, program, counter storage, and the executable code. Okay, you don't have to understand all the details of this, but the concept is the same as for any other normal machine. When you run software on your computer, only now with a virtual machine you can run it on any operating system.
00:14:48.754 - 00:15:36.542, Speaker B: And because they are all simulating the same virtual machine, the results for everyone will also be the same. So you have your compiled smart contract code here, which is immutable as we already said. This executes as a number of so called EVM opcodes. Those perform machine code operations like XOR and add sub etcetera. And if you're wondering what those operations are, they are the smallest unit of computation done by a cpu. This is fundamentally what all software breaks down to and what your cpu is actually executing. For example, let's take Xor.
00:15:36.542 - 00:16:29.190, Speaker B: Xor stands for explicit, or let's take a single bit to explain it. Zero x or zero is zero. Zero x or one and one x or zero is one. And lastly one x or one is zero because for explicit or you may only have one of the bits as one but not both. So only if the bit is different, the result is one. And you can do this for long bit numbers where you do each bit comparison individually. You don't need to understand all the details though, this is just for you to understand that all the code you write for smart contracts fundamentally breaks down to these small operations inside of the Ethereum virtual machine.
00:16:29.190 - 00:17:32.340, Speaker B: So the EVM has these cpu operations as well, the EVM opcodes. But on top the EVM also has a number of operations which dont make sense for normal cpu's. Those are specifically added for blockchain operations. This could be, for example an opcode for retrieving the ether balance of an account like the number 31 balance opcode here, or also the latest block hash. So that's how the virtual machine operates, executing these opcodes and reading data from the memory, which is just data that's temporarily stored. And of course we need actual permanent storage called state. Each smart contract on ethereum has its own state that it can read, but it's sometimes even possible for a smart contract to read state from other contracts, as long as those other contracts support it.
00:17:32.340 - 00:18:14.894, Speaker B: Okay, so now we know how a smart contract is executed. But so far we've made one simplification of smart contracts so that it's easier to understand. Next, it's time to clear up this simplification. We have so far compared a smart contract to a trading bot. But there's one more important difference to a trading bot that you need to know. When the trading bot is running on your computer, it's basically running nonstop. At any point in time, you could take a look at what the software is doing and you would get an answer.
00:18:14.894 - 00:18:48.340, Speaker B: Like right now it's sending out bitcoins. Right now it's requesting the bitcoin price from binance, etcetera. So at every point in time, the software is doing something. Even if that something is just a timeout sleeper function waiting for x amount of seconds, that's still doing something. But that's not the case for smart contracts. They are only ever running when you interact with them. Imagine the trading bot as a real time game like Fortnite.
00:18:48.340 - 00:19:33.890, Speaker B: Even if you don't move your mouse or press any buttons on your keyboard, the game obviously is still running. Other players are moving around, things are happening even without you. And you can imagine the smart contract more like who wants to be a millionaire? Youll get four answers presented, and only when you decide on an answer, the game proceeds and youll get your response if you were right or not immediately. And now, what does it mean to interact with a smart contract? Okay, listen carefully. It means sending a transaction to it. I know your mind might be blown. Now what? Just sending a transaction to it means interacting.
00:19:33.890 - 00:20:19.700, Speaker B: So I only have to send some ether to this address and I just interacted with it? Kind of. It depends on the contract. If the contract supports that you send ether to it, then yes, you indeed only need to send ether to it. But a smart contract with only one functionality would be pretty boring, right? So that's why in Ethereum, when you send a transaction to a smart contract, you don't have to send ether. You can alternatively just send any arbitrary data instead. This data is then used to determine which functionality of the software to execute and what data should be used as input. It's possible to send invalid data.
00:20:19.700 - 00:21:13.182, Speaker B: In this case, you might be trying to run a functionality that's not actually supported by the smart contract. Maybe you accidentally put a wrong address or you confused the functionality. But don't worry, in this case, your transaction is simply reverted, meaning it's ignored and never put into any blocks. But what happens if the functionality exists? Well, now the code is executed inside the Ethereum virtual machine. And what happens during the execution? Well, anything that happens just in the memory doesn't really matter because once the execution is finished, all memory data is deleted. So the only thing we care about is the state. And that's why you could think of Ethereum also as a distributed state machine and a state machine as a theoretical construct in computer science.
00:21:13.182 - 00:22:27.190, Speaker B: To describe such mechanisms, it's easy to imagine as a game where you might have three states, game over, game paused, and game running, and whatever the player clicks moves the game into a new state. If you want, try to create a state machine diagram like this. But for who wants to be a millionaire? Now, for Ethereum, every transaction will bring the network in a new state. New state refers to the whole Ethereum network state, basically all storage, who owns how much ETH, and all data stored. In all smart contracts, each transaction will work on the current state and move the network to a new state, or rather each block where transactions run sequentially. Since that's what happens in a blockchain, right? We always get a new block which moves us to a new state, even for bitcoin, only that in bitcoin, the data stored is simply this address has this balance. And in Ethereum, a smart contract could store any data at once.
00:22:27.190 - 00:23:14.170, Speaker B: So let's go through an example of how you would interact with a smart contract next. So, okay, smart contracts might still sound very confusing, and I have to admit it's a weird concept. But let's go through an example. One smart contract you might have is a simple escrow. For this example, let's assume it has only three functions. First, assume you are buying something online, but you are not trusting the seller. Quite often the case, right? But now with the smart contract, you can deposit your payment in the form of ether for the seller address on the smart contract.
00:23:14.170 - 00:24:00.750, Speaker B: But there is a catch. The seller cannot withdraw the money, yet neither can anyone else withdraw the money, including you as the depositor. Now, the seller sees the funds in the contract and knows those funds cannot go anywhere but to his own address later on. Second, once the seller has sent the product in the real world and you have received it, you as the buyer can enable the withdrawal for the seller in the smart contract by calling unlock. And thirdly, now the seller can call the withdrawal function to receive the ether. So that's what will happen on a high level. But what does happen on the blockchain? The seller sends out a transaction that looks like this.
00:24:00.750 - 00:24:54.180, Speaker B: So the transaction is sent with the smart contract address as recipient. Because remember, smart contracts are just automated accounts and have their own address and the data inside the transaction. Rather than usually saying something like send ten ether to Bob now instead tells the smart contract, here is ten ether, please execute the deposit function. Oh, here's also the seller address who this deposit is meant for. And now remember, this is a transaction and transactions will be bundled up together by miners in blocks. So once a miner has included this transaction in a new block, the block will be distributed around the network again. And this is when the code is actually executed.
00:24:54.180 - 00:25:41.040, Speaker B: The nodes receiving a new block will have to go through all transactions inside the block, one after another. And when they receive the deposit transaction, they initialize a new Ethereum virtual machine for our escrow smart contract. Load up the state for it, run the deposit transaction, which will change the state by storing the deposit amount for the seller address. Okay great, so now we have a smart contract which has stored ten e certs for the seller. Bob, what happens if the seller tries to get the money now? He would send a withdrawal transaction. But wait, stop. The withdrawal flag has not been set by the buyer yet.
00:25:41.040 - 00:26:20.544, Speaker B: So during execution inside our Ethereum virtual machine, this would be detected and the transaction rejected. And so eventually the buyer enables the withdrawal and the same thing would happen. The transaction is included in a block and will change the state by setting the withdrawal flag. And now the funds are unlocked. And when the seller now sends a withdrawal transaction, it doesnt revert anymore. And the smart contract sends the funds, in this case ten ether, to the seller. Bob Great.
00:26:20.544 - 00:27:22.870, Speaker B: We now understand how smart contracts work, but theres still one major security problem we havent solved yet. Lets explore this in the next chapter. So a smart contract can only be interacted with by sending a transaction. But you might have realized that the whole thing is anything but efficient. Not only is the smart contract execution happening on every single node in the ethereum network, but also whenever you store, for example, a single number in a smart contract, this number will be stored on every single node in the ethereum network. It would be incredibly easy to make the Ethereum network unusable by storing lots of data and loading the required storage space for nodes. And also what would happen if our smart contract execution had an infinite loop? It would completely hang the network.
00:27:22.870 - 00:27:56.360, Speaker B: All of this is actually another reason for why the Ethereum virtual machine exists. And it all has to do with gas. Gas, that's right. And indeed quite similar to what you would get at a petrol station. It's the fuel for the Ethereum network. Every transaction needs it to run like a car needs petrol. Each opcode in the Ethereum virtual machine has a gas cost attached to it.
00:27:56.360 - 00:28:45.140, Speaker B: Most of them are fairly cheap, but some in particular reading and writing smart contract states are more expensive. Here on the EVM codes website is a great overview of all opcodes and their gas costs. You can see here. Most of them are fairly cheap, but some are more expensive. And in particular the opcodes that are reading or writing to permanent state are more expensive. Especially storing new data is expensive because now this data has to be stored in every node taking up hard drive storage. Now when running a smart contract with an infinite loop, eventually it would run out of gas.
00:28:45.140 - 00:29:19.950, Speaker B: Just like a car driving infinitely in a circle would eventually stop because the tank is empty. And if you want to store data, it will cost you a lot of gas. So it would be very expensive for you to bloat. The Ethereum network nice. So how do we get this gas? You can get the gas by using ether. So how much gas do you get for one ether? That depends on the transaction. You can configure this conversion rate by setting a so called gas price.
00:29:19.950 - 00:30:04.070, Speaker B: The higher the gas price, the more likely miners are to include your transaction in a new block. So you see here, the gas prices are fluctuating from day to day. The more transactions people are sending, the higher the gas prices will be. And you usually denote gas prices in gigaway, which stands for o and then eight zeros, one ether. So quite a small amount of ether. But remember, this is what we pay per single gas unit used by the transaction. So for example, you have a gas price of 100 gigaway and your transaction costs 21,000 gas.
00:30:04.070 - 00:30:45.630, Speaker B: This is, by the way, the smallest gas cost any transaction can have in Ethereum. And now the cost in ether would be gas used times gas price. So in our case here, in total 0.0021 ether. And then you can convert this to us dollar or any other currency you want to figure out how much the transaction is costing you. And so why are the gas prices fluctuating? Because the miners are the ones actually receiving the transaction fee. So of course they are going to prioritize higher gas prices to get more ether.
00:30:45.630 - 00:32:01.640, Speaker B: Setting an extremely high gas price, miners will immediately try to include it in a new block. Setting an extremely low gas price, miners will just ignore the transaction. Actually, at least it used to always be like this, up until the Ethereum network upgrade called London. This upgrade included a new transaction type which introduced a new gas price mechanism known as EIP 1559 instead of sending transaction fees to the miners, they are simply burned and a baseline for the gas prices in a given time is calculated by the network itself based on demand. This gives users a better guarantee on what to set a scarce price for that transaction to actually be included in the blockchain, rather than randomly guessing one and hoping the transaction will make it through. So since the ethereum will be burned, it could actually mean that ether as a currency becomes deflationary as long as the burned amount for fees is greater than the newly minted tokens from proof of stake.
00:32:03.540 - 00:32:36.910, Speaker A: Aldo here again, what do you think? Drop us a comment to let us know. Also, if you did enjoy this tutorial, make sure to check out marcus full Ethereum bootcamp course where you wont just be watching tutorials. Youll actually learn by getting to create your own ERC 20 token, build your own stablecoin and even build your own decentralized casino. If you want to gain the skills to confidently apply as a solidity or blockchain developer then this course is for you. And if you dont end up liking it, you can take advantage of our 30 day no hassle money back guarantee. Check out the link in the description below to get started.
