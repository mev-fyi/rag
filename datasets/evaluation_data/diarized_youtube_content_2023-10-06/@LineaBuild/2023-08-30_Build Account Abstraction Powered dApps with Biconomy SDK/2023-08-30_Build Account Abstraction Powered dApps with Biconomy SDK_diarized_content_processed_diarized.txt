00:00:00.330 - 00:00:00.638, Speaker A: Hello.
00:00:00.724 - 00:00:29.366, Speaker B: It is a little past 5 minutes, but that's because Rahat was doing so well preparing for you guys. But I always forget to start with introductions. Okay. Hello, I'm Emily. I do developer relations for Linea, if you don't know, run these workshops every week, basically talking and highlighting the cool projects that are happening in the ecosystem. So enough about me. I'm not interesting.
00:00:29.366 - 00:00:35.640, Speaker B: Our guest is the most interesting person in the entire world, my very good friend. Please introduce yourself.
00:00:36.730 - 00:01:00.874, Speaker A: Hey all. Thank you for having me on. Emily, I actually do think you're interesting. Cool. So I'm Rahat, head of developer relations for biconomy. I'm here to tell you a little bit about account abstraction and how you can start building with aa or account abstraction on linear. So yeah, like I said, I'm Rahat.
00:01:00.874 - 00:01:28.982, Speaker A: I usually look like one of these two pictures. So usually the pixelated version of me is what you'll probably see online, and the real ish looking version of me is what you'll see in real life. At some point I'm hopefully going to look more like the pixelated version, though. These are the different things I've done over the past several years. Been in the front of an engineer, founder, hip hop artist. I will not be rapping today. I have retired.
00:01:29.046 - 00:01:32.540, Speaker B: I did not know about this. About you. Okay. Wow.
00:01:33.550 - 00:01:36.650, Speaker A: I just wanted to set expectations from the start. Yeah.
00:01:36.720 - 00:01:41.870, Speaker B: Okay, cool. But post stream. Post stream, you only been giving me a private concert.
00:01:44.050 - 00:02:08.774, Speaker A: Awesome. Yeah. So going kind of like diving into things really quickly. Wanted to sort of discuss the current UX of web3. To put it in one sentence, it sucks. Or two words, I guess there's a fear of losing your private keys. Right now.
00:02:08.774 - 00:03:12.858, Speaker A: If you go in and onboard onto web3, you have to go through create a wallet, or we'll refer to it as like an EOA externally owned account that's like your regular metamask wallet wallet that you would use on a regular daily basis that you might be used to right now. That requires you to set aside your seed phrase or protect your private keys, and there's a fear of losing them and fear of having someone else access your account. The fear for me is very real. It has actually happened to me. So it's a thing that happens. It's unfortunately something that we have to kind of deal with. You have to save your private keys or your seed phrase in a secure manner, and expecting a regular person to do that is probably not ideal, because even folks, I like to think of myself as pretty security conscious and understanding of web3 security.
00:03:12.858 - 00:04:05.450, Speaker A: And I still got drained. So there's still a lot of possibilities for you to get your seed phrases and things like that leaked in different ways. Overall, web3 UX is pretty complicated. The process of just onboarding onto a Dap if you're just like a brand new user, involves a setting up your wallet, b going to an exchange, onboarding some funds into whatever network or first through eth and then bridging and then sending that money over to your account. There's just like several different friction points that you have to go through before you can even start thinking about using adapt at times. And then there's paying too much gas fees. A lot of that is being solved by layer two solutions like linear.
00:04:05.450 - 00:05:16.062, Speaker A: But how can we take all of these different things and actually improve the actual web3 user experience? So incomes, this thing called account abstraction, what exactly is it? Account abstraction in a sentence is the ability to add arbitrary logic to the process of validating a transaction. A lot of big words. So it's really just like looking at a specific transaction and asking yourself, okay, what is some logic I can add here? Before I allow this transaction to actually process? Maybe I want to do something like sponsoring the gas for this transaction. Maybe I want to allow the user to pay for gas in a non native token, stuff like that, right? So when we're looking at these transactions, we're actually looking at them through a different lens. Instead of being called like traditional transactions, they're known as user operations. So user operations is just like a new way of looking at transactions through the account abstraction flow. So user operations exist in what's called like an alternative mempool.
00:05:16.062 - 00:06:12.638, Speaker A: And these are all handled or executed eventually by an entry point contract. An entry point contract is just a single tin contract that is deployed on every single chain that allows the full ERC 4237 or account abstraction flow to actually execute. And we're going to look into a diagram of that full flow in a second. But the way that all of this is actually achieved is through something called a smart account or smart contract wallet, depending on how you want to call it. So these are just wallets that are secured by code instead of the ECDSA. So your regular wallets that you're used to right now are generally secured by ECDSA. Meaning it's just like a signature algorithm that is pretty much standardized across all different wallets that allow you to sign different transactions.
00:06:12.638 - 00:07:19.470, Speaker A: So rather than just being governed by that one strict algorithm, you now have a wallet that is secured by code and because it's secured by code, you can use ECDSA, you can use other types of signature algorithms. So now you open up the ability not only to control transactions through a wallet, but being able to control transactions through pass keys or session keys or anything like that. In the case of something like a pass key, you could control your transactions using the biometrics on your phone face id to execute a transaction or sign off on one, things like that. It allows your transactions to become more flexible in that manner, so allows for additional types of authentication. So I mentioned the face id as one of them. The main thing you want to ask yourself is here is how do you want to authenticate a transaction? Aa can probably help you with whatever answer you eventually find. So this is a diagram that shows you kind of like the full flow going through each of the different parts.
00:07:19.470 - 00:07:58.022, Speaker A: So the green box starts off with your smart contract wallet. This is what's going to send your initial user operation, which again I mentioned is basically a transaction. It's just a new way of looking at transactions. So that goes into a user op mempool. Mempool is just a place where all of these different user ops exist. And most user ops user ops will contain all of the eventual information that you need to actually execute a transaction. So it'll have the traditional fields like from, it'll have your call data, it'll have your nonce, it'll have all the different gas elements that are needed to actually execute it.
00:07:58.022 - 00:08:41.314, Speaker A: But it will also have some additional information, such as it can have information about a paymaster. A paymaster is just a smart contract that can choose to give you. One moment. Excuse me, I'm good. So a paymaster is just a smart contract that can help you with sponsoring gas for your end user. It can help you with doing things like instead of sponsoring gas, allowing the end user to pay for gas and ERC 20 tokens. Maybe they want to pay in USDC, maybe they want to pay in Deutsche coin or something like that.
00:08:41.314 - 00:09:05.020, Speaker A: I don't know if Deutsche coin is still like all the rave, but whatever meme coin is all the rave right now, we'll use that. So all of that exists inside of these user ops in this mempool. And then we have a bundler. A bundler is just a service. It can be written in typescript, it can be written in rust, it can be written in CSS. It cannot actually be written in CSS. Don't do that.
00:09:05.020 - 00:10:27.686, Speaker A: But it looks at your user ops in your mempool and sends those user ops over to the entry point contract to actually execute. Technically, you could send all of your user operations directly from your wallet to your entry point contract, but this infrastructure allows you to bundle together different user ops to save money on transactions to just have a faster, better experience. Overall, the entry point contract is going to have a couple of different methods, but the main method that is going to be working all of this magic is the handle ops method, which is going to handle the user operation. It's going to check to make sure that it came from a valid place, from a valid smart contract account. It's going to check to see if the actual user op needs to be sponsored by, let's say, a paymaster, or if it simply just needs to be executed normally. Eventually that goes into this execution phase, and that is the full lifecycle of transaction on the account abstraction flow. But I mentioned a bunch of contracts, a bunch of services.
00:10:27.686 - 00:11:26.434, Speaker A: You probably don't want to code all of these things yourself for every single thing that you build. So our solution comes into play here, the biconomy SDK, which allows you to plug and play into different parts of the ERC 437 infrastructure that is provided by us. So we provide you with Paymasters, bundlers, as well as a package to create your own smart contract accounts. So the accounts package allows you, like I said, to deploy the accounts as well as create the user operations easily so you don't have to think through constructing that entire user op object. We take care of most of that work for you so that you can execute your transactions more easily. There's the Paymaster package, which allows you to do different things like sponsor gasless transactions, or allow users to pay gas with ERC 20 tokens. Both flows are enabled with our Paymaster service, and then the bundler package.
00:11:26.434 - 00:12:17.282, Speaker A: You can interact with our bundler for eventually sending the user operations to the entry point contract to execute the final transaction. The cool thing is, although our SDK gives you access to our Paymaster and bundler, you can actually use any Paymaster and bundler with our packages. All you have to do is go to whatever third party service that you want to use, grab the URL endpoint for their bundler or Paymaster, and supply it to our SDK. As long as it's four three seven compliant, you're good to go. You'll be able to use any other of those services with our SDK. For now, though, let's dive into some code. So for this example, kept things kind of basic.
00:12:17.282 - 00:12:29.270, Speaker A: Just to give folks an idea of how we're building things out. I have a smart contract here that I deployed earlier called the linear Bico NFT.
00:12:30.290 - 00:12:31.920, Speaker B: Can you zoom in a bit?
00:12:32.530 - 00:12:33.134, Speaker A: Yeah.
00:12:33.252 - 00:12:36.800, Speaker B: Plus all good. Okay. Yes.
00:12:37.650 - 00:13:12.780, Speaker A: Cool. Yeah, so I'm incredible at naming things, so we named it the linear Bico NFT. It's just a super basic Erc 721 NFT. All it does is allow you to mint an NFT and it keeps track of the token id. Nothing more than that. It doesn't have a picture, nothing fancy. This is just really just to give you an idea of how you can interact from the SDK to a NFT smart contract, or really any smart contract at all.
00:13:12.780 - 00:13:48.840, Speaker A: I'm going to grab the NFT address, have that saved here and you'll see. Let me just open that up on the block. Think this is it? Yeah. So this was a verified contract. Thank you to the awesome documentation on linea for helping me to verify this this morning. Pretty smooth process there. So yeah, it doesn't really do much.
00:13:48.840 - 00:14:42.902, Speaker A: It's got a few mints already. When I was furiously testing to make sure that things work for this workshop, but everything went smoothly and let's take a look at the actual how to interact with it on the front end. So when I created the workshop code for this, I was following this next js full stack tutorial, which is available on our docs. So everything that I go over is also available on this tutorial on Docs economy IO. For now, let's go into the code and we'll take a look at first the index, the home page. So just a bunch of imports here. Most of this is copy and paste from the tutorials, but there's a few packages that you need.
00:14:42.902 - 00:15:29.906, Speaker A: There's the biconomy account package, which will give you the smart contract deployment capabilities, well as using the user ops and everything. There's the biconomy paymaster and there's also the biconomy bundler. Additionally, we're going to be using the biconomy particle auth package for a nice smooth social login widget that you just kind of get out of the box. You can choose to use this. Choose not to use this. I'm looking at this from the perspective of like, I want a user who has just never used web3 before to be able to come to this step and just start using it right away. They don't need to onboard onto a wallet.
00:15:29.906 - 00:16:01.150, Speaker A: They don't need to have any funds either to get started. This is going to be like a free nft mint. So we're onboarding just someone who has never interacted with web3 before onto their first NFT on linear. So just a bunch of state variables holding the address. There's a loading state, the smart account state and our provider. You'll see here that I'm using particle auth. There's just a configuration object that you need to configure.
00:16:01.150 - 00:16:36.140, Speaker A: If you want to use these project ids, feel free. They only work on Testnet, so if you want to actually go on prod, you have to get your own keys. But this will help you just get set up with particle network. You just need a project id, client id app id. All of that is set up on their dashboard. So that's at dashboard. At particle auth network you can just log in, create an account completely for free and get all the keys that you need.
00:16:36.140 - 00:17:09.026, Speaker A: But we won't focus too much on that for now and then. Interacting with the bundler and the paymaster instances are pretty easy. All you have to do is create these configuration objects which hold like the URL endpoints for each of the services. And these are things you can get from the biconomy dashboard. Like I said, the bundler URL can be anything you want it to be. So if you want to use an external service for using a different bundler, you can just pass the URL here. Same for the paymaster.
00:17:09.026 - 00:17:45.610, Speaker A: You can pass the paymaster URL here. And for here we're just like setting the chain id, which is going to be linear testnet. And you can set your own entry point address if you want. Or you can just use our own default entry point address, which is just an enum that you can get from one of our packages up here. Next we'll take a look at the actual connection function. So this is pretty simple. Particle auth gives us a login function which as you might expect, gives you a nice little login widget.
00:17:45.610 - 00:18:28.702, Speaker A: We'll go through the actual demo of this in a second. So what I'm doing is just like logging in. When you log in, you get back like a user information object. So depending on how the user has logged in, maybe they decided to log in via email, maybe they decided to log in via Google, Auth, Facebook, Twitter. There's like a whole bunch of different social options there. Whatever they decided to log in with, you can get some public information about that in this user info object if you wanted to. Next, we're just taking the provider that is given from particle and using the ethers provider to get the signer for it.
00:18:28.702 - 00:19:14.410, Speaker A: The way that this particular setup works is that you can use any kind of authentication method. You can use something like particle. You can even go as simple as using ethersjs and doing like a connect wallet button. The main thing that you just need to actually configure your biconomy smart account is the signer. So the signer can just be gotten from whatever ethersjs object is spit out by whatever your authentication provider is. So it's flexible enough so that if you don't want to use particle, if you want to use your own, or if you want to use like magic, you want to use any other type of auth system, you can do that without much issue. So this part here is like subjective.
00:19:14.410 - 00:19:36.580, Speaker A: Up to you. However you want to handle authentication, as long as you get the signer. That's all the biconomy smart account configuration needs to actually get set up. Because what happens here is that particle auth is actually giving you an eoa that is going to be the owner of the smart account. So you just need some eoa to own the smart account. It can be any eoa at.
00:19:38.550 - 00:19:51.100, Speaker B: Cool. So quick question to interrupt. I guess this portion somebody was asking what environment is that? I'm not entirely sure what he means by the question, but maybe you.
00:19:53.790 - 00:20:06.000, Speaker A: So not 100% sure what they're referring to. So I'm building out like an XJs app on my local host. Nothing like special there.
00:20:06.530 - 00:20:14.770, Speaker B: Okay, cool. As they have more questions, I guess they'll expand on it. Sorry for interrupting your flow.
00:20:16.230 - 00:21:00.880, Speaker A: Yeah, if there's any more questions, happy to answer along the way. And then the account config just takes the instance of the bundler and the paymaster. And again, these are all just like Larry Copy and paste from the documentation, so you don't really have to think about this too much, just making sure you send the proper arguments as they're needed and just make sure you're on the right chain. Id. In this case, it's linear. Then we initialize the smart account and just save that to state, as well as get the smart account address so that we can actually display it on the page. And the other thing that I'll just go over really quickly is like the actual minting process.
00:21:00.880 - 00:22:05.880, Speaker A: So to mint your NFT, it works very similarly to if you were going to interact with a contract via ethers. There's just like a couple extra steps to make sure you're going through the biconomy SDK flow. I just have again this address of the NFT, just some typing for typescript not too important. I'm connecting to the contract how I normally would through like an ethers JS instance. So just with the NFT address, the ABI which I saved earlier, and passing down the provider. This is just a little toast I have just for some UX stuff, but that's not too important. The main things that you want to focus on for how you want to actually execute a transaction is going to be looking at the contract and using the populate transaction ethers method, which is going to essentially help you construct a raw transaction object.
00:22:05.880 - 00:22:54.020, Speaker A: So you don't want to just call the actual function directly. We want to have it go through the biconomy SDK flow. So this creates a signed raw transaction of the actual function that needs to be executed. We just pass it whatever parameters it needs. In this case, safe mint just needs to be sent to our address. And then we start building out our actual user operation. The only parts of the user operation that you have to theoretically build out yourself is going to be this NFT address, like the address that you're interacting with and then the data of the raw transaction that you created over here.
00:22:54.020 - 00:23:43.570, Speaker A: I had some content logs in here just because I was debugging some stuff, but don't think we need those anymore. And next thing here is interacting with our Paymaster. So before we actually interact with our paymaster, there's a couple of things you need to set up on our biconomy dashboard. So I'll go through that here really quickly. So first, if you go to dashboard byconomy IO, you can log in, register and create your own Paymaster. I created a paymaster already, but just to show you the steps, you would click add Paymaster, name it, something, choose your network and choose a version. There's not a huge difference between these two versions.
00:23:43.570 - 00:24:17.390, Speaker A: One gives you like an expiration field if you're using the API. In our case, we're not using the API, we're interacting with the SDK. So it doesn't matter which version you choose this version, it only matters if you're using our Paymaster through the API. So you don't really need to worry about that. You hit register. Once you've registered, you'll be able to add funds to your gas tank. In this case, I added some small amount of funds that are going to be used to cover the gas expenses for our end user.
00:24:17.390 - 00:25:01.120, Speaker A: And then in the policies tab, you just need to add your smart contracts. So in this case, if I hit edit here, you'll see that I added the smart contract. Address it automatically populated with the ABI because it was verified and I can approve specific methods that I want to make sure are eligible to be sponsored by the Paymaster. In this case, I only want savement to be sponsored. I don't want any of the other functions to be sponsored at all. So this will help you with setting some limitations on what functions can actually be sponsored and what cannot be sponsored. Cool.
00:25:01.120 - 00:25:29.750, Speaker A: So I've got that set up. Let me make sure everything here is good. Cool. All right, last thing is going to be I'm just going to go to my terminal and get this running. One moment, 1 second. I don't know why it stopped sharing.
00:25:51.470 - 00:25:52.220, Speaker B: It.
00:26:08.930 - 00:26:36.866, Speaker A: Cool. So let's go to the actual implementation refresh, make sure that works. Cool. So not the most exciting app in the world. I'm not a designer so I'm not going to try to wow you with any amazing front end, but we're just going to demo account obstruction on linear connect and mint your aa powered NFT. Hit the connect to web3 button. So this is the particle auth package that we installed.
00:26:36.866 - 00:27:15.214, Speaker A: All we did was install, set up that configuration and we now have this login widget that's going to create a wallet for us. You can go through and see all of the different options for social login. I'm just going to do like an email one time code thing. So I'm going to use this email that I use for some of my demos. Feel free to spammerhot@gmail.com I will receive a one time password. I will receive a one time password.
00:27:15.214 - 00:27:44.714, Speaker A: There it is. Okay, so particle network just sent me a one time password that I can use. 72665. Pretty sure it's not invalid. Okay, that wasn't new. Did I not spell this correctly?
00:27:44.762 - 00:27:45.360, Speaker B: Maybe.
00:27:47.170 - 00:28:26.202, Speaker A: As you can see, I've gotten this code before. Yeah, I spelled something incorrectly. There it is. 7414 280. So now I'm loading a smart account in the background and now I have an ethereum address without ever needing to onboard onto a wallet. Don't need to go through that process at all. This is now like an in dap wallet that just exists for me.
00:28:26.202 - 00:28:47.210, Speaker A: But I don't have to think about it. Just like as a brand new user to web3, one friction point has been completely removed from me. Entirely. The next thing I'm going to do is mint an NFT. So I didn't go to an exchange. I didn't onboard any fiat. We did set up the paymaster in the background.
00:28:47.210 - 00:29:26.318, Speaker A: So let's hit mint NFT particle author is going to give me this little nice little UI for me to actually sign the message. So I confirm that I want to do the mint and in the background it is minting. And once the minting is over, I will get a transaction. There's always the awkward part of waiting for the transaction to actually go through. There we go. Yes. What I should have done is created a link.
00:29:26.318 - 00:29:55.542, Speaker A: Next time I will make sure to do that. I think I console logged in that transaction has, yes, did that at least. All right, so go to the actual transaction and you'll see that this went through here. I minted the linear bico SDK NFT. You'll see the other couple of times I did it as well. But there are now three, two addresses hold. There should be three.
00:29:55.542 - 00:30:55.926, Speaker A: Maybe it just needs to refresh later at some point. But there are three handle ops that were minted. So rather than seeing the actual mint NFT function as the method being called, you'll see that it's the handle ops method that was called because the bundler actually interacted with the entry point contract and gave it the information for the raw transaction of the NFT mint. And that actually handled the NFT mint itself. So rather than seeing the mint NfT method being what you probably normally be used to, you'll just see the handle ups method and you'll see the actual mint transfers and functions kind of like on the transaction here itself. So cool. We were able to go through, we were able to have a user sign up using an email address, get onboarded to a wallet, and then without paying any gas mint their very first NFT.
00:30:55.926 - 00:31:40.546, Speaker A: So this is just like one very basic user experience flow that you can unlock using the biconomy SDK. There's several other things you can do. I had mentioned a couple of different times of know the paymaster not only can do sponsorship of the user operation, but allow the end user to just pay for the gas using USDC, using any other ERC 20 token that we do support. You can find out more about those in our docs. There's other tutorials there of how to update those flows. A little bit of alpha for folks. Between this week and next week we'll be releasing an update to the SDK that allows for additional modules.
00:31:40.546 - 00:32:35.458, Speaker A: So if you want to unlock other UX experiences like signing once for a transaction and then just using an app with like a web two like feel, and not having to keep signing over and over again, we have a session keys module that is coming out. So you'll be able to do unlock other experiences like that. So if you wanted to create your own social web3 social application on linear, you'd be able to do something like that where the end user doesn't have to sign every single time they want to make a post or like or comment on something. All those can be blockchain interactions without having to feel like blockchain interactions. It gives you a nice complete out of the box web two like experience without having to compromise, not having to put things on chain. Everything is still on chain, but it feels like web two. And that's really what the point is of stuff.
00:32:35.458 - 00:33:14.630, Speaker A: Of a lot of the things that go on behind the reasoning behind why we need account abstraction. It's really just to make things easier. It's not really just for users who are brand new to web3 folks like me who have had security issues with our private keys, we also benefit from it too. You don't have to manage your private keys. You don't have to manage seed phrases anymore. I've seen a bunch of people work on really cool stuff in Defi. One of the things that you can additionally do when you're minting the NFT.
00:33:14.630 - 00:33:49.554, Speaker A: You'll see here that when I built the user op, I just passed the transaction into an array. I can actually continue doing that. I can add more transactions. In this case, it's just the same transaction over and over again. This is called batch minting or batch transactions. So I just batch multiple NFT mints into one transaction. But think about different experiences where you take other transactions and batch them together into one.
00:33:49.554 - 00:34:48.082, Speaker A: I recently did like a uniswap demo where you could approve and swap a token swap in one transaction rather than doing two. So it would be really cool to see awesome stuff built on linear like that where you're batching different transactions together, creating nice and awesome one click user experiences. Those can benefit not only non web3 native, but web3 native folks who might not be as well versed on the DFI side of things, just making DFI a little bit easier to use. The example I gave was pretty basic, but you can look at more complex stuff like adding liquidity to a pool, et cetera, things like that. So it would be awesome to see really cool user experiences like that on different dapps that you're building on linear and yeah, would love to open it up, I guess, to any questions or anything like that for the last so.
00:34:48.136 - 00:34:55.910, Speaker B: We had a question about can I only use the Paymaster for EOA accounts rather than contracts.
00:34:56.650 - 00:35:58.570, Speaker A: So the paymaster flow is really only for smart contract wallets. The reason for that is if you think about the user operations that we had mentioned, the reason that you're able to actually use a paymaster for a transaction is because of the way that the user operation is set up. So the entry point contract is going to validate first that it came from a smart contract account, and then from there it'll handle doing everything for you on the paymaster side. So that flow is only really possible from a smart contract account. If you wanted to do like gas lists without a smart contract wallet, you'd have to go through the ERC two seven one flow, which is something, a separate SDK that we have that allows you to do that gasless with EOAs. But this would be specifically the account abstraction flow. That's how you would use the Paymaster.
00:35:59.870 - 00:36:23.202, Speaker B: Okay, cool. I had a few questions as well. Maybe there's a narrative, I think, coming up, and feel free to say you haven't thought about it, but I think the next battle, I don't know, that's kind of too incendiary, right? Is like MPC wallets versus account abstraction wallets. Are you familiar with?
00:36:23.256 - 00:37:09.220, Speaker A: Yeah, I don't think it needs to be either or to be honest, it could be account abstraction wallets that are secured by NPC. So like I mentioned, you don't necessarily need to secure your wallets in this case. In my example I did, I had an eoa that was just an externally owned account over this. But you can have NPC based solutions and use them along with your smart accounts. I don't think they necessarily have to be exclusive to each other. They can definitely work together.
00:37:10.390 - 00:38:04.980, Speaker B: Good answer. Okay, so I think one thing I wanted to talk about is looking forward towards the future. East Global NYC is happening, right? So the New York hackathon, at least on the linear side, we have a bounty specifically for building account abstraction dapps, of course, which by economy would be a great kind of entry point for that. I was wondering, and you kind of briefly mentioned this already, cool use cases or maybe biconomy out in the wild to kind of seed ideas. What are you guys looking for when it comes to judging your dapps built with biconomy? And then maybe one last thing of a really cool project that you've seen built at a hackathon before.
00:38:06.390 - 00:39:25.014, Speaker A: Yeah, definitely. In general, in the wild, like I mentioned, we've seen a couple of people dabbling in how DeFi can be just more user friendly for people and not necessarily like I said, just for non web3 natives, but for folks who are just not as well versed in Defi. For me, I really personally, really like seeing creative uses of the transaction batching. How can you just make defi easier to use or I don't have to swap, do this approval, go sign something else, do another transaction, bridge something here before doing the actual whatever end outcome that I want to do. Just like making a lot of those steps a little bit easier. Just like let your user know these are the different steps that this one click is going to do and then do them. Just make it as easy as possible for people to participate in providing loans on chain or being able to access different parts of defi.
00:39:25.014 - 00:39:32.240, Speaker A: I'm a Defi noob myself, so if I sound like I don't know what I'm talking about, probably don't a little bit.
00:39:33.170 - 00:40:10.842, Speaker B: No. I love that it's important to be transparent about. We're not like the be all, what do you call it? Subject matter experts on everything. I'm curious too. For me, when I think a lot about these improved UX experiences, transaction batching, sponsored thing, what kind of traction have you seen in other verticals? Right. I know gaming is really picking up along that vein too. I don't even know what I'm asking here.
00:40:10.842 - 00:40:28.000, Speaker B: Right. But I want to say something that doesn't just result in a yes or no, but how abstraction in gaming, have you seen it? Do you feel like it's getting bigger, having a pulse kind of on the space?
00:40:28.370 - 00:40:30.480, Speaker A: Yes. Okay.
00:40:31.170 - 00:40:36.740, Speaker B: No, I was hoping by saying I don't want it to be a yes or no question.
00:40:37.910 - 00:40:39.300, Speaker A: I can give an example.
00:40:40.810 - 00:40:42.360, Speaker B: Shot myself in the foot.
00:40:44.730 - 00:41:35.186, Speaker A: I would say. Yeah, absolutely. Has actually during ECC, a really cool project that we saw someone do was there was this card game that they created on chain and at that point we didn't have our session keys module deployed, so they actually took the implementation that we had shared. One of the challenges we had was like take this implementation of session keys and actually put it into an app. It's going to be very hard to do, so if you do it, we'll pay you the top price. But they managed to do it and it hadn't at that point been integrated into our SDK. But what they were able to do was basically a card game where each of the different actions were like on chain interactions.
00:41:35.186 - 00:42:42.150, Speaker A: But it didn't feel that way because it's just like a web two ish game of going through and doing all the different game actions without signing every single time. And I think account abstraction does a lot to help you take on chain games and give them that fluid, regular gaming experience. So I think gaming is probably like one of the best use cases. Just point blank for contraction, just like on chain games. I feel like they're fun to an extent, but do you really want to sit there and wait for every single transaction to be signed, approved and go through every single time? Probably not. So if you're going into more fast paced games, you're going to need something like this where all of the signing the transactions are just happening in the background. You're not thinking about them and they're not interrupting your overall game flow.
00:42:42.150 - 00:42:51.920, Speaker A: Right. So an example of that was we did see at ECC and I'm excited to see more complex games being built in that way.
00:42:52.770 - 00:43:07.106, Speaker B: Awesome. Thank you so much. I don't think there's anything else. Usually people start watching more on the later end. Everything is live, but that's fine. Okay. This is really cool.
00:43:07.106 - 00:43:13.430, Speaker B: I had so much fun. I will see you in two months. End of September.
00:43:14.730 - 00:43:16.182, Speaker A: That's like a month away.
00:43:16.316 - 00:43:16.902, Speaker B: Is it?
00:43:16.956 - 00:43:19.602, Speaker A: Oh no, it's the end of August. It's almost September.
00:43:19.666 - 00:43:37.050, Speaker B: Oh my God. Sorry. I thought October came before August. 1 month away. Start thinking about how you can improve ux through faster and cheaper transactions. And then also at that point, account abstraction capabilities.
00:43:37.470 - 00:43:39.718, Speaker A: Yes. That's kind of fun.
00:43:39.824 - 00:43:48.426, Speaker B: Yeah. Okay, well. Oh yes. How do people get in contact? Learn more about biconomy, stuff like that.
00:43:48.468 - 00:44:12.140, Speaker A: Yeah, best way to learn more probably the docs. Docs economy IO. You can also tag me on Twitter at rahatcodes. You can also tag biconomy at biconomy. We've got a discord link as well that's available on the website. So you can hit us up in the tech channels in there as well.
00:44:12.830 - 00:44:22.410, Speaker B: Okay, we have another question. Since the paymaster can only be used for smart contract accounts, what happens of the address if user calls contract.
00:44:25.970 - 00:44:26.334, Speaker A: Such.
00:44:26.372 - 00:44:30.560, Speaker B: As when I'm using transaction origin? What's the origin? The smart account.
00:44:31.010 - 00:44:46.500, Speaker A: Yeah. So the origin of the transaction would be the smart account itself. So the message that sender, all of that is going to be the smart account address, that's where the original transaction comes from.
00:44:47.750 - 00:45:05.660, Speaker B: Okay, cool. Oh, I actually had a question about smart contract wallets. A common critique I've heard is kind of having different addresses across different chains. Do you have thoughts on that?
00:45:06.670 - 00:45:57.610, Speaker A: Our addresses are all the same on the different networks. That's achieved through using the create two upcode. So the create two upcode gives you what's called like a counterfactual address so that you know the address before even having the smart contract deployed. So before that contract is deployed, before that wallet is like, I guess, quote unquote active, you already know what the address is. You can start sending funds to it on your first transaction is when the deployment actually happens. So there's a little bit extra gas on that first transaction. So because of that, because we know the address before it's even deployed, it can be the same across the different networks.
00:45:58.110 - 00:46:09.390, Speaker B: Okay, cool. We have another question. I think this is probably a follow up from the question that you asked before. What about smart contracts that use transaction origin instead of message sender?
00:46:13.170 - 00:46:37.480, Speaker A: That's not something I can answer at this moment. I would have to just look into that a little bit more. I don't think transaction origin is like the most recommended way of going about things, at least from my understanding. But it would still be the smart contract account, I believe.
00:46:40.250 - 00:47:11.620, Speaker B: Okay, cool. Yes, I do realize there is a live stream latency, so I will count from ten and if nothing comes up, I will end this stream. So let's awkwardly count together. I don't know how to do this. Ten. 987-65-4321 okay, cool. Well, again, thank you so much.
00:47:11.620 - 00:47:17.630, Speaker B: I don't know how to end these ever. So we're just going to wave goodbye as I click the words end stream.
