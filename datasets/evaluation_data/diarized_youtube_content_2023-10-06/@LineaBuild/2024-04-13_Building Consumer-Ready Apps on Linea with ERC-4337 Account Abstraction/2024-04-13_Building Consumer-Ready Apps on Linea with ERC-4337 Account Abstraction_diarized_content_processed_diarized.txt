00:00:01.080 - 00:00:15.062, Speaker A: Hello. Hello. We are live with the. I guess. What number is this? 33. I've done a lot of these developer workshops, highlighting all the developer tools on Linia. I'm really excited to, I guess introduce.
00:00:15.062 - 00:00:26.594, Speaker A: I'm not going to introduce you for yourself, but this is where I start. I'm Emily. I do devrel at Linia. Lovely guest. Please introduce yourself and what you're working on.
00:00:27.074 - 00:00:51.466, Speaker B: Sure. Yeah. So my name is Tabasco, although that's not my real name. My real name is Ethan. I do develop relations at particles, so I handle all of our documentation and all of our technical videos and go to events and of course you stuff like this. I've been doing developer relations now for a little bit over two years. Been kind of full time in this space now for, I think, getting closer to four years previously.
00:00:51.466 - 00:01:38.908, Speaker B: I was at an RPC provider called Chainstack and I led developer relations over there for about a year and a half and then I joined particle back in September. And we've kind of done a lot since then. The quick cl dot and I'll get into it a little bit later. But particle network, we basically do a lot of different UX facing technology. So things that kind of simplify the onboarding and interaction experience for end users and infrastructurally set the stage for what we hope at least to be sort of like a large scale of onboarding in terms of creating an environment in which it's kind of approachable for new users to get into the space. So we do this a lot through social logins and account traction and things that kind of help people get into web3 and then start using in a way that's pretty simple. So we've been around now for two or three years and we've kind of grown pretty quickly to be one of the largest traction providers on linea, as well as a few other EVM chains.
00:01:38.908 - 00:01:45.180, Speaker B: So super excited for this. I think that there's a cool. A few angles here that we can kind of get into and start exploring the counter traction space.
00:01:45.332 - 00:01:58.784, Speaker A: Yeah, awesome. I mean, that was kind of the first thing I wanted to talk about. I don't know if this is what you've already addressed in your slides and we can pull that up or you would just want to, you just want to chat, but. Yeah, I don't know. Give us the rundown.
00:01:59.364 - 00:02:34.104, Speaker B: Sure. Yeah. Let me move over to my monitor here. Yeah. So what I wanted to go through today, at least in the context of what I just established, is this idea of building consumer ready applications on linea leveraging account abstraction. So for a long time we've always had this idea as a space of building applications that are ready for consumer onboarding. But what does that necessarily mean? I think it starts almost always at the initial point of getting into an application and then even extending past that into the actual process of interacting with that application.
00:02:34.104 - 00:03:15.624, Speaker B: This is where ERC 437 and traction tying this in with social logins comes in play. Because as we'll get into a moment, the ideal user experience is whenever a user can log in in two clicks into a smart account, start leveraging the application. Ideally they don't even pay gas fees, sometimes they don't even actually sign transactions. And at this point you start approaching this user experience. A user doesn't really know that the applications they're using is actually web3. This is really, at least as an industry, what we want to get to. It's users should be able to leverage Dapps and leverage the benefits of web3 without the friction and new tooling that is usually associated with using web3.
00:03:15.624 - 00:04:08.372, Speaker B: Users can manage in a way that feels very familiar, feels very web two. Like this is what account abstraction and social logins enables to pretty significant degree. So I have an introduction slide, but as I mentioned, I do develop relations here at particle and I've been doing it for a little while and pretty excited to dive in here into a few of these concepts. First of all, what I want to do is establish an overall term that typically addresses this idea of onboarding into an application via social login. And as we'll get into tying in a kind of structure into this flow, this term is called wall as a service. Now you might have heard of this before, there's a lot of different providers creating wall as a service products in the space, primarily with the ultimate goal of allowing user to onboard your application using their social account. This is the common denominator between all wall as a service products.
00:04:08.372 - 00:05:09.024, Speaker B: It's like how do you get a user into an application as fast as possible using means in which they're already familiar with? For example, going into an application using my Google account or my Twitter account or my email, and then actually from that onboarding process, the same process that I'd be doing in web two, actually having a wallet that I can then use and interact with the application with. This is actually a pretty cool dynamic within applications that's been popping up recently. Of course, we're not the only ones who do this. You might be familiar with web3 auth or privy or other organizations that also do wallet as a service in the context of through some mechanism or another, having users onboard into custom made wallets through the means of social logins. These are usually secured by some sort of alternative key management mechanism. In our case, we use MPC TSS, which basically just generates a private key, splits it into multiple shares and saves shares in a user storage location as well as a service storage location. Then, long story short, basically independently leverages these shares to generate signature.
00:05:09.024 - 00:06:06.294, Speaker B: You have a few other wallet service providers that do similar things in terms of taking a private key and distributing it across different locations and then reunifying it to sign a transaction. All that said, the idea behind what actually makes it possible to, in two clicks, log in with Google and then have a wallet that you're going to use, it all comes down to how you actually generate and manage that private key. There's a lot of really cool mechanisms today where you can do this in a way that's still non custodial and gives users a lot of control over their wallet, the full self sovereignty and everything, and of course without the risk attached to a custodial approach. In our case we use MPC TSS. But there's a few other cryptographic mechanisms of enabling this key distribution that then thereby allows you to log in via social login. This is the idea of wall as a service. It's using alternative key management mechanisms to allow users to using their familiar web two accounts, log into an application and start using it with an embedded wallet.
00:06:06.294 - 00:06:42.006, Speaker B: Speaking of an embedded wallet, this is when you're using metamask or phantom or anything like this. Like typically what you're going to be doing is using the wallet extension on your browser to then interact with the application. Or if you're using your mobile app, then using the application interface on your phone. But like in a scenario where you're logging into an application using your social login and you're having a key that's distributed and it's kind of generated for you on the backend, you don't really know what the seed phrase is. By default, you're just using the wallet. In this case. How as a user, do you actually have a wallet interface with all your balances and everything? Well, there's two ways that you can do this.
00:06:42.006 - 00:07:51.278, Speaker B: The first is that of course applications can manage this themselves. There's a lot of applications that use wallet as a service do social logins and then they do all of the balance displays and all of the address displays on their front end. I'll actually showcase an example of this in a moment. Alternatively, another pretty common denominator between wallet service products is this idea of embedded wallets actually having an interface that's natively embedded in the application itself that allows you to interact with the wallet and leverage it as if you were to have metamask install or something like that. So this is quite important because this means that you can have an experience that's pretty parallel to any typical extension based wallet or app based wallet. But of course, in this case, through the means of just social logins, this is a pretty big removal of the barrier to entry for end users, because just imagining the onboarding process between wallet based onboarding and social login based onboarding is that, for example, with a typical wallet, you download the extension, you create a new wallet, you have a seed phrase, you have to write the seed phrase down, you place this into a secure location, like physically. Then you have this wallet, you go to an application, you connect it, you sign transactions through this wallet extension.
00:07:51.278 - 00:08:51.154, Speaker B: This is a difficult process for a lot of new users to grasp. Alternatively, within the mechanism of wallet service, which is again, this term that refers to this overall technology, rather, a user goes to an application, they sign up with a Google account, they have an address that's given to them, they don't need to manage the seed phrase, because again, they're using this alternative key management mechanism. Then they have this embedded interface that they can use to interact with the wallet, to view all their balances, to view their address, and that's it. They don't need to download anything, they don't need to learn how to use a different wallet interface, they don't need to write down the seed phrase, it's all done for them. And of course in this case, the goal is to ideally create an experience that feels very parallel to web two and removes a lot of the additional friction that's typically associated with web3. This is very commonly attached to account abstractions we'll get into in a moment, and unified in a way that makes it very easy for developers to integrate, which we'll also get into. But yeah, the idealist scenario here is that a developer integrates it in five or ten lines of code they add into their application.
00:08:51.154 - 00:09:23.062, Speaker B: They have full compatibility for it, which then therefore allows users to interact with that application via their social account. This is quite an important component. This is a visual example of that tangent that I went on, which is just this idea of, in this case, onboarding via my Google account, in this application. As you can see, this is an application called Apex Pro. This is just a standard example that I typically use because they're a perpetrating DeFi platform. As you can see here in this GIF. What I did is I onboarded via my Google account.
00:09:23.062 - 00:09:46.534, Speaker B: This then brought me into their application. I have my address there in the top right, so you kind of see the GIF loop back around here. So I select that account and now into the application, I have my address there. I can view my assets, my total assets in USC. I can deposit transfer assets, stuff like that. Or I can click the manage button which then pops up the embedded wall interface from particle. There's a lot of really cool implications here.
00:09:46.534 - 00:10:40.564, Speaker B: Of course, this whole interaction that I'm doing right here, no downloads. This is two clicks essentially, and quite simple. This is a pretty big removal of the typical barriers that you might find with Ux because again, this is what would be a 1020 minutes process, getting a wallet set up and creating an account versus in this case basically 30 seconds to log in with your social account and therefore start using a wallet. So this is a pretty important dynamic for developers, especially when you're creating an application that is consumer ready or consumer facing in any regard. So if you're creating a game or a DeFi platform or anything that you want general consumers to be able to access, social logins can be a pretty significant kind of enabler of these consumers to use your application. I mean, even myself, whenever I go to an application, I see social logins as one of the options. A lot of times I'll choose that over my wallet because it's just easier.
00:10:40.564 - 00:11:25.600, Speaker B: This is a pretty big unlock for applications that want to have this more consumer facing nature. And this is of course why wallet service exists. And this has been our focus for a long time at particle. But wallet service as a base product has a lot of limitations because what you're doing at the end of the day is you're onboarding a user into an externally owned account, which for some context, externally owned account is bound by a private key. In the case of walls of service, it's a distributed private key, typically like I mentioned, but it's bound by a private key. It's a very standard, very rigid account structure that you can do a very set, you know, limited number of things with. So you can do standard peer to peer transactions, you can interact with contracts, you can kind of hold assets on your account, and that's about it.
00:11:25.600 - 00:12:47.544, Speaker B: These accounts aren't programmable, they aren't very flexible. You know, there's a lot of limitations in terms of what you can do. So while it's easy in this scenario to onboard a user into an account through walls of service, through social logins, you instantly hit a wall where it's like, okay, well, now that we have this in the account, I mean, they can do standard transactions, but still we lack a lot of the Ux kind of features that we need to actually achieve what you typically would consider a truly consumer facing application, which requires more than just this single step onboarding because you need more features such as gases, transactions and pop upless transactions and programmable wallets to customize the user experience to your specific application, and things that can further remove the web through experience from the end user and make it feel even more web two native. This is the principle and the idea behind smart walls of service, which is the same thing as wall service. But as I have here in this graphic, rather than just having user login have a private key generated by MPCTSs, which is the key management mechanism, then leveraging the eoa that results from that. What we actually do is we have that same process, but instead of ending there with the eOa, we then assign a smart account implementation, such as economy or alchemy's let account or simple account or something of this nature. Then the user actually leverages a smart account implementation that's attached to the eoa generated by social login as their main interface with the application.
00:12:47.544 - 00:13:40.984, Speaker B: Maybe a little bit complicated there, but the idea here is that user two clicks the onboard into an application. We generate a private key bound account, an eoa. Then we take this eoa, we assign it as the signer, the owner of a smart account, and the user leverages that resulting smart account within the application. Of course it unlocks a lot of really cool things, because now that they're leveraging a smart account, not the eoa, they can do things like gases transactions and pumpless transactions and introduce modules into their account. And the developer has a ton more flexibility in terms of what you can do with these accounts within your application. You could even go to a scenario where you actually create a custom smart account for your application with custom features or custom modules that are tailor made to make the experience of your application better and more web. Two like this is really where you start getting into the interesting UX implications of using account abstraction, using smart accounts rather than EOas in the context of walls of service.
00:13:40.984 - 00:14:16.784, Speaker B: So from a programmatic perspective, actually doing this is very simple. Like when you're creating an application and integrating social logins, the actual process of onboarding via social login and getting user into your application. Kind of like what I showed with Apex in terms of just like, you know, logging in via Google or Twitter. This is actually just one method through one react hook, and this is the connect method as I have here, you choose a social type that you want to connect with the chain, in this case linea. Then you can establish a smart account. We have a full SDK just for using account instruction. Or you can use bikonomy's SDK or alchemy's SDK or anything like this.
00:14:16.784 - 00:15:00.654, Speaker B: You then decide what smart account you want to use. Then you apply this to something like a, for example, EIP 1193 provider object through ethers or through j's. Or you can use this object directly to execute transactions and so on. Basically in less than 20 lines of code. You can set up the whole onboarding process for users into your application via social logins and extend this even further to account abstraction. Do things like gases transactions, pop upless transactions and so on, really without much lift programmatically. So this is a 1 hour addition to your project at max that can have some pretty significant UX implications and of course make your application feel much more web two like, and kind of remove a lot of the typical complexity that's associated with web3 from your application.
00:15:00.654 - 00:15:56.208, Speaker B: So understanding this, understanding kind of the idea of onboarding into an application via social login, into an EOA, which then gets assigned to a smart account, which then users kind of use as the interface with their application. This is kind of an outline of how we structure this idea of smart wall as a service. So kind of the concept here is that we kind of have this very modular implementation where if you're familiar with the kind of structure, there's a ton of infrastructure that exists out there to make account possible within your application. There's a lot of different smart account implementations from, like I mentioned, iconomy, alchemy, safe, zerodev, et cetera. A lot of different types of paymasters, a lot of different types of bundlers. Each of them have kind of different pros and cons, different types of implementations and so on, different types of efficiency, especially with bundlers. So as a developer, like at particle, we believe in this modular approach where you can basically use whatever infrastructure that you want to, you don't have to use our infrastructure.
00:15:56.208 - 00:16:31.714, Speaker B: Now, we do have our own paymaster and our bundler. We have the particle omnichain paymaster and the particle bundler, which we use in all of our applications by default, but you have full freedom to use biconomies, bundler or Pemico or stockup, same thing with the Paymasters. And for smart accounts you can use any smart account implementation that you want. By default, within our SDKs we support biconomy, simple account, cyberconnect, alchemy Lite account and so on. But if you want to, you can plug in your own smart implementation or really any other that exists out there. So it's quite simple in that case. And of course, because this is again tied in with social logins, which is what we call particle auth.
00:16:31.714 - 00:17:10.162, Speaker B: This has a full embedded account extraction wallet. So that wallet modal on the application itself for users to interact with the wallet and all of the benefits of social logins and that kind of web two native onboarding functionality. So this graphic showcases the dynamic between all these different components and this modular approach of making it very plug and play, but also retaining the ability to use whatever infrastructure that you want. We believe this to be very important because as a developer there really isn't a one size fits all solution. So when you're creating an application, you really want to hone in on the UX. It's clear that social logins make a pretty big impact to this. Account structure makes a pretty big impact to this.
00:17:10.162 - 00:18:26.364, Speaker B: But the specifics of how you achieve this in terms of what Paymaster am I using? What Bundler am I using? What smart account am I going to be using? How am I displaying the embedded wallet modal? Am I displaying the embedded wallet modal? These different core configurations, these are all very malleable and up to you as a developer to create a very unique and non cookie cutter experience. This is how we formatted this whole idea of smartwall as a service in the context of our SDKs. Like I mentioned, we do have this very modular approach, but at the same time basically have all the infrastructure ourselves. If you just want this very simple solution, we also run, like I mentioned, around Bundler Paymaster Smart account. We have the whole user interaction side covered as well as the key mentioned side of via MPC. These are things that you could take particle and like I mentioned earlier, 20 lines of code have a full implementation ready to go where you're still using the core benefits of account abstraction through our standard plug and play solution, using all of our infrastructure, using social logins, and so on. So this is a pretty cool kind of dynamic that we've also been quite focused on in terms of creating something that is not only as simple as possible for users and developers to integrate, but also flexible enough to be able to add in any of these other pieces of infrastructure that we have here on the list.
00:18:26.364 - 00:19:18.964, Speaker B: And this is where this second showcase graphic comes in. Whereas while the UX benefits here are clear as the, the kind of sustainability of such a solution very much depends on the modularity and kind of the ability to implement external implementation. So this kind of graphic showcases that we have our native implementation, which is our own bundler, either by economy or our own paymaster. A number of different types of smart accounts, of course, assigner being the EOA generated by social login, or if you want to, you can use any other kind of combination of paymasters, bundlers, smart accounts. So that's kind of like hammering the point home there where we believe kind of smartwalls of service as an idea to be a very long term solution that will drive a lot of core adoption. And as a result, the flexibility has been built in here to make sure that that's possible and not locked into us as a single vendor of all the infrastructure. So that's quite important.
00:19:18.964 - 00:20:00.624, Speaker B: As I mentioned, this whole process, this modular implementation of smartwatch service social logins, plus I can abstraction the whole process of actually onboarding you to this mechanism. It's all very simple, and actually the overhead for the programmatic complexity is very low in this case. What I have here on the GIF is actually a full application. It's around 120 lines of code, that's including all the JSX and everything. This whole application handles all the onboarding, all of the balance, fetching and display, handling, two different types of user operations or transactions, and so on. This is quite a complex application, and all of it's built in under 100 lines of code. The actual usage of RDK here spans less than ten lines of code.
00:20:00.624 - 00:21:07.708, Speaker B: Very simple and very easy to integrate as a developer, with of course added flexibility of being able to use any infrastructure that you want to use and customize the implementation to a pretty deep level. So this is the idea behind smart walls of service. Now, with all that said, that kind of pretty deep explanation of how that works and the actual implementation of the SDK usage of different infrastructure, what I also want to highlight is that at particle we see smart walls of service and the onboarding of users via social logins into account abstraction wallets via MPC to be the first step in a larger goal of simplifying web3 user experience. Actually, what we're focusing on and building right now at particle is this idea of a universal account, which a universal account, very simply put, addresses a lot of the multi chain complexity. So when you look at web3 and then the dynamic of UX, we see it in two different parts. So the first part is UX as it relates to onboarding and kind of low level account interaction. This is addressed by account abstraction and social logins.
00:21:07.708 - 00:22:09.880, Speaker B: Everything that I just talked about addresses the first half of this problem, which again is onboarding and kind of low level interaction. So getting user into an account as easily as possible, as quickly as possible, and then kind of using the application through a flexible means, like I mentioned, this is what smart accounts through account abstraction enables. So with this already being solved with smartwatch service, this half of the UX problem, or the UX dilemma in web3 is already complete. Applications that integrate abstraction and social logins have an onboarding flow that is very much parallel to web two in terms of the underlying complexity. And it's been proven in terms of all these applications that use it, including a lot of applications on linea that use rsdks and other providers as well. They onboard a pretty significant number of consumers and they have no problem doing this. But the issue is that once you start looking beyond the onboarding process and into the actual cross chain interaction and using multiple applications across the ecosystem, this is where the experience breaks down pretty significantly.
00:22:09.880 - 00:22:54.622, Speaker B: Because even if you can onboard a user in two clicks into a smart account, into by using methods that they're familiar with in a way that secure, non custodial, super flexible, that's all great. But if the user, as soon as they actually try to go and use applications across different chains and even across different applications, and what they originally onboarded into, this experience breaks down. So now if I want to go, for example, if I'm onboarding to an application on linea, I want to go to an application on arbitram, for example, or base or something of this nature, I have to go find a bridge. Linea has some really good bridges. But even then, as a user, I have to go find this bridge, I have to manually bridge, I have to do the transaction myself. I have to wait a little bit of time and sometimes costs quite a bit of gas. I mean, it just depends on network conditions.
00:22:54.622 - 00:24:08.008, Speaker B: This is a complicated user experience. And even past the need for manual bridging, I need to just cognitively be aware of and manage multiple balances across different chains. So I have to say, how much ease do I have on linea? How much ease do I have on base? How much each do I have here and here? This limits the growth potential of chains ultimately, and applications within it, because it means that users that are willing to bridge your chain or bridge your application and that are maintaining a balance in this environment, they're your user base. So you're locked off from a big chunk of the ecosystem that doesn't want to do this manual bridging process and move liquidity over to the chain and the environment in question. So this is a pretty big problem because onboarding users is fixed, but actually getting users to interact across the entire ecosystem is not doable for consumers because of the inherent complexity with multi chain interaction. So like, how do you solve this? How do you actually take what we just discussed with this initial implementation of social logins and account abstraction and tie it into a solution that takes a more holistic approach to Ux, that also solves a multichain problem simultaneously. So particle, our big focus is kind of number one, tying in all the components I just talked about a moment ago as it relates to social logins and account abstraction into this umbrella term of wallet abstraction.
00:24:08.008 - 00:25:05.244, Speaker B: So we want to make it clear that it's easy to onboard via any account that you want to, any wallet that you want to into a smart account, and do so in a way that kind of is falling under this term of wallet abstraction. So this is clear. But wallet abstraction, this idea, social logins and account abstraction, this ties into what we're building at the moment called a universal account. Now universal account, simply put, basically as an account structure, it's kind of an extension of ERC 437 account obstruction wallets that allows you as a user to actually maintain one address and one balance across every chain. So I can have one ethn base and the same ethno that I have on base I can use on linea and I can use an arbitram I can use on ethereum and I can use anywhere because it's my balance. If I can have USDT on base or on linea, I can use that same USDT anywhere else. So this means as a user, I actually don't even need to be aware of what chain the application is that I'm, you know, that I'm using.
00:25:05.244 - 00:25:53.744, Speaker B: If I'm using a git application that's on linea and I have my liquidity on base, then I don't need to be aware that this application is using linea or that my balance is nonlinear. Because I just use the application. I can leverage the unique benefits of linia without needing to go through the whole process of bridging or being aware of this multi chain lack of parity. This represents a pretty interesting scenario for users because now we have this experience where ideally user onboards by social login into a smart account. They use a smart account across any chain, any application that integrates it, and they don't need to be aware of the balances they have between chains, they just simply do transactions. Use applications and that's it. This not only makes it easier for end users, makes it easier for consumers, but also changes the whole dynamic for applications.
00:25:53.744 - 00:26:48.974, Speaker B: Because now applications aren't competing for a very limited amount of users in a given ecosystem or a given chain. Rather the ecosystem is much more open. Chans can onboard more users into their applications. Applications have a huge pool of users now that span the entire web3. Ecosystem growth overall becomes much easier for everybody without this inherent fragmentation. The future that we see is that using universal accounts, which are again an extension of smart contract wallets that are onboarded to via social logins or typical wallets, users will be able to onboard two clicks and be able to use applications across the entire ecosystem without needing to manage multichain balances, ideally in a way that actually feels like web two and feels like web3 is invisible in this sense, or the complexity associated with web3 is invisible in the sense. This is basically the removal of all the main problems that we have with UX today.
00:26:48.974 - 00:28:06.644, Speaker B: This is really our focus at particle kind of what we're trying to achieve here in terms of taking what we've already built with social logins and account traction and moving into this user experience. That is a full addressal of web3's points of friction from the onboarding side into the second half of the problem, which is the multi chain complexity, the cross chain complexity and the overall interaction process. This visualization here encapsulates what I'm talking about here, where we want users to have one wallet, one point of interaction, one set of assets, they can use any application that they want and achieve their goal through a very straightforward process that feels as natural as if they were using web two rather than the current process, which is very complicated and pretty difficult. This is the future that we imagine what we're using as an extension of all the technology that I just talked about a moment ago, but of course that's still being built out. What I want to talk about is the, the base technology that I talked about in the first half of the presentation, which is social logins and account abstraction. What I'm going to do is actually go through a walkthrough programmatically how it's possible to integrate these SDKs and actually integrate social logins plus smart accounts in your application in less than 2030 lines of added code. This is going to be pretty interesting that I'll go through here.
00:28:06.644 - 00:28:37.004, Speaker B: This QR code is actually going to directly lead to the application that I'm going to be showing the code for. If you scan this, this will lead to deployed applications. I have, you can log in by your Google or your Twitter account, do transactions on linea. These will be gases transactions, like a very simple showcase of the SDK. But let me go ahead and move my screen share here to my other screen. 1 second. Here we go.
00:28:37.004 - 00:28:56.864, Speaker B: All right, so first I'm going to go through the application itself. Then I'll go through the code that backs it. Let me screen share here, screenshot the whole window. Let's see if this works. There we go. Cool. So let me actually go and help open the application.
00:28:56.864 - 00:29:32.954, Speaker B: I'm going to go through two demos here. The first is going to be a demo using what we call our auth core SDK. Our auth core SDK is the base SDK that enables social logins and account abstraction across the entire stack. So this will kind of allow you to do very direct, just like onward by Google, Twitter, stuff like that, and of course into any smart implementation that you want to. So we have of course two options. We have a lot more, but for the sake of demonstration, I have two here, sign up with x. If I choose to sign up with Google here, what I'll do is it'll open up my Google authentication menu.
00:29:32.954 - 00:30:11.742, Speaker B: I'll select this account right there and two clicks here. I'm now into my wallet on linea. Um, so that was basically 15 seconds. I select my Google account, I'm into my wallet, I can see my balance in eth, I can open up the particle embedded wallet model right here, which is optional. But this is a pretty core thing that developers typically choose to include because it's one button that I can click, I can see all my balances on linea, all my nfts, my activity, I can send and receive, I can even do on ramping and so on. So very simple metamask like interface that allows you to manage your wallet. So now that I'm into this wallet through social login, I can of course use it as if I were to be using any other wallet.
00:30:11.742 - 00:30:35.530, Speaker B: And of course this is without any downloads, it's in two clicks. Super simple. So what I'm going to do here is actually execute a transaction that is completely gasless on linease nupolia. So I'll do execute user operation here. This will then open up a quick modal that I can go ahead and confirm. So if I confirm this then I believe I should have a transaction hash here in a moment. Once it gets confirmed.
00:30:35.530 - 00:30:55.258, Speaker B: There we go. We have the transaction hash that is basically now confirmed on Linux Apollia. So this is a gasless burn of around 0.001 Eth or something of this nature. So this is a full transaction. As you can see the actual confirmation was handled within the application itself. So I don't need to open any other windows or any other kind of extensions or anything.
00:30:55.258 - 00:31:22.134, Speaker B: It's all within the application contained here by the SDK. If I refresh you can see that I have burned a little bit of eth. Super simple. That was 2 seconds. I can open up my wallet modal here and see the changed balance reflected here as well. This is the idea behind particle auth core. Particle auth core basically just allows you to enable this very direct onboarding social login into smart accounts.
00:31:22.134 - 00:31:49.792, Speaker B: As you'll see here. Programmatically it's very very simple. This is relet. Now if you guys have used relet before, it's my favorite tool for doing browser side cloud based application hosting and whatnot. Basically what I have here is I have this cloud application that is react based. Super simple. What I'm actually doing here is I'm handling my application in two different sections, one of which is in the index TSX section.
00:31:49.792 - 00:32:24.798, Speaker B: The index of TSX basically has our core react component that actually configures particle auth. What we have here is just simply some API keys for authentication. We're choosing the smart account implementation that we want to use and of course the chain that we want to be supported on the wallet, in this case lineage apolia. Then I'm wrapping my main application component right here. Then within my application component in app TsX I'm importing a few different react hooks. Use ethereum, use connect, use auth core from our auth core SDK. I'm then using these react hooks to do things like for example connecting to the social login provider.
00:32:24.798 - 00:33:10.034, Speaker B: If this is all handled within this function right here, it's one call, this call to the connect function. It initiates a connection with whatever Oauth mechanism I want to use. Google, Microsoft, Twitter, LinkedIn, Discord, whatever you want to do, it's all handled right here. I'm defining this within social type and of course defining the chain that I want to onboard into as linear sepolia. I have the same disconnect function all in one call. I can pull the user's address, even their actual web two information so we have direct access to their potential, their name in terms of the accounts they connect with, email, stuff like that. What we also have here, which is quite important, is what's powering this entire application, which is an EIP 1193 provider object.
00:33:10.034 - 00:33:51.206, Speaker B: If you're familiar with this standard with EIP 1193, what we can basically do is through this Ethereum provider object, we can plug this directly into the smart account object here, which is from our account abstraction SDK right here through the means of this. What we're doing is we're directly introducing our eoa generated by social login into a smart account implementation, which is defined here by the smart account object. Again, we're throwing in some API authentication keys. We're defining the smart account that we want to use. I'm using a simple account instance which is just the standard smart account from the Ethereum foundation. This is all initialized now with this smart account object. I now have a full smart account instance created through the EOA that we just generated through social login.
00:33:51.206 - 00:34:32.434, Speaker B: All handled basically here, one react, hook, call and then one configuration of the smart account object. Then I'm creating a ethers provider right here using the smart account object. Also very simple. What we're just doing here is we're throwing the smartcat implementation into a standard ethos call configuring ether provider, then using this ether provider and then getting the addresses balance. I can send transactions the same way as if I were to do any transaction, any other application. Same syntax, same actual developer flow with ethers. It's just that of course in this case it's being routed through SDK and through a smart account.
00:34:32.434 - 00:35:11.614, Speaker B: This is all handled through just very simply throwing in the provider object and creating the smart account object, and then of course creating an ethers provider as a result. Super simple stuff here. This entire application is in around 95 lines of code. If you remove all the JSX, it's 59 lines of code. The idea here is that as a developer you can add this functionality, this social login functionality, especially if you're already using ethers or one, three js or vm, you can add this functionality in less than 30 additional lines of code. So it's super simple in that case. Alternatively, what I also want to showcase is the second example here, which I can actually open up right here.
00:35:11.614 - 00:35:52.162, Speaker B: This is another SDK that we have, which ties pretty closely in with this idea of using any wallet to get into a smart account called particle Connect. Particle connect is essentially our flagship rainbow kit like SDK that allows you to connect either, I think it's not. Let me actually run it here. You can connect metamask or wallet Connect, Rainbow, stuff like that, alongside social logins within the same modal, very rainbowkit like modal, and then actually use this for a smart account. So I'll just connect right here. As you can see, I have a more traditional connect wall button right here. And within this interface I have all my social logins.
00:35:52.162 - 00:36:48.504, Speaker B: So email, phone, Facebook, google, Apple, stuff like that. Then right below that, in the same interface, I have all my wallets. So OKx wallet, bigget, math wallet, metamask, stuff like that. So I can, as a user choose if I have metamask, I want to use that, I click this, I can log with my metamask, or if I only social login, and I prefer that, then I can use it here within the same interface. This is quite important because now you're offering more, I guess, experienced users, a method of onboarding within your application, as well as more consumer facing users that maybe aren't familiar with the wallet process within one SDK and one interface. This is also contributing to our idea here of having one SDK and one core mechanism of onboarding users into smart accounts, which of course will then through SDK be eventually converted into universal accounts, which as I mentioned a moment ago, will span the entire ecosystem. But for now, what I want to do here is I can go ahead and select Google again.
00:36:48.504 - 00:37:14.128, Speaker B: This will go through the same process as before. I can sign with my Google account right here through the particle connect interface. Then, as we have here, same bounce as I had before, I have my address, same embedded wallet modal. I think my ripple went down. Let me launch it back up again. Let's see here. Maybe replace.
00:37:14.128 - 00:37:15.204, Speaker B: Can you still hear me?
00:37:16.734 - 00:37:17.454, Speaker A: I can hear you.
00:37:17.494 - 00:37:58.514, Speaker B: Yeah, I think there we go, replace back up. Sometimes my Internet goes down for a few seconds and this can happen. But let me give a chance just to come back up here. But while I'm waiting for replay to launch again, what I'll do is showcase actually particle connect in this case, which gives you more functionality than particle auth. In this scenario, where you want to use both traditional wallets and social logins, it's actually easier to implement programmatically. So that whole process, that connection process is implemented again through a pretty standard react based component configuration. We're doing again some API keys, throwing in Lenny's Apollia as our desired chain, deciding what wallets do we want to support within the modal.
00:37:58.514 - 00:38:35.234, Speaker B: So do we want to support every EVM wallet? In this case we're just throwing in our wallet connect project id here. Then we have ten different wallets that we support. Choosing the smart account implementation that we want to use. That happens after onboarding. Actually, whether I onboard with social login or metamask doesn't matter, because still what's going to happen afterwards that I'll be onboarded into a smart account so I can use that regardless of if I'm using metamask or social login or any other wallet, because again it's handled by the SDK reflected through the SDK. And then of course within the embedded wallet model as well. Then I'm also defining Linux depolia as the chain supported with within the wallet interface.
00:38:35.234 - 00:38:57.102, Speaker B: Then same thing here. We're wrapping our main application component. We can go to that over here. Very similarly to the same application that we just looked at a moment ago. We're pulling the EIP 1193 provider object right here. We're throwing this into a smart account instance with our account abstraction SDK. We're then creating an ethos provider object, same thing.
00:38:57.102 - 00:39:59.170, Speaker B: Fetching the user's balance executing a transaction is actually the exact same syntax I just looked at a moment ago. But in this case we're just rather than handling social logins through distinct functions, we're just throwing in a very simple connect button react component right here, which handles all the connection itself. This is actually less we can see here we have two functions here, but if you look at removing the second function around 57 lines of code for the same functionality as last application, because we don't need to handle social logins ourselves. It's all done by the SDK in the backend. Users can onboard by any mechanism into a smart account, start using Gaston transactions and pop upless transactions and so on super easily. This is really a user experience that we've been advocating quite a bit for, because as you can see, I'm here now, I could open up my wallet model right here. Again, same thing, see my balance and Ethan linea I can do transactions, same mechanism as before, which will open up a pop up right here on the application and go click on confirm and it'll be done on chain.
00:39:59.170 - 00:40:38.984, Speaker B: Of course, if I had metamask connected here, then it would be requesting this on my metamask. But still super simple stuff. And of course this is all within. Basically in the case of particle connect, closer to 15 lines of added code versus 20 to 30 for particle auth core. Particle auth core gives you more flexibility over do you want to facilitate social logins directly and have a custom interface for this and build your own ux logic around that? Or you can have it all be handled by us, just have a single connect button. Social logins, wallets tying into account obstruction wallets, all done in 15 lines of code. This is a very powerful user experience that we're quite excited about.
00:40:38.984 - 00:41:29.356, Speaker B: We think that of course with the implications of this is that in the future what's going to happen is that this user experience, this same flow of I choose my social login or choose my typical wallet. This will then lead into a universal account, which is a type of smart account that as a user I won't know what chain I'm using, I won't know where my balances are, I won't need to know. I mean I'll have the ability of knowing, but the knowledge of this will be unnecessary because I'll just use whatever application I want to use across the entire ecosystem, maintain a constant balance. And this is where you start getting into the idea of users no longer have the onboarding complexity. They can choose whatever mechanism they want, two clicks if they want to, by social logins. They then get into a smart account which is intrinsically flexible. You can do a lot of low level account flexibility, things like transactions and so on, and then extending this even further into the multichain issue, which now you have no issues across chains.
00:41:29.356 - 00:42:21.836, Speaker B: You can have one balance for every different chain. Leverage applications as if they're all in one chain, automatic bridging, stuff like this. And this is where you start getting into this user experience that really will, we hope, propel web3 into this scenario where it'll really be like viable for consumer onboarding. Because right now all the problems I just mentioned are really the main blockage for us on a consumer level in terms of the viability of getting people into web3. With these solved, we think that this is where we're going to see some pretty significant onboarding and hopefully the space as a whole will start to move in a much more mainstream direction with the ability of onboarding users and such fashion. So this is of course something that we're very, very excited about. And we think that with the advent of universal accounts, which we actually just today, around 2 hours ago, had the testnet launch for our universal accounts, and we're going to have like a full mainnet within a quarter or two.
00:42:21.836 - 00:43:05.428, Speaker B: We think that this is going to contribute pretty significantly to the mass onboarding of web two and web3. And actually even further than that. I think the idea of onboarding web two and web3 is interesting because hopefully what we're going to see is actually there won't really be any intentional onboarding. We're not going to have to onboard people because they're going to start using web3 applications and actually not really know that they're using web3 application. It's going to be seamlessly integrated into the existing Internet landscape and of course propel web3 into, like I mentioned, this mainstream environment. As a result, we see social logins, account abstraction and chain abstraction as being these kind of three core technologies that will play a significant role in that. So that's what I want to go through in terms of the programmatic side.
00:43:05.428 - 00:43:39.112, Speaker B: Very quickly, before closing out here, I'll show you just a quick two kind of things on the last slides. Let me share my screen one more time and then open this up right here. 1 second, just for reference. 1 second. There we go. All right, so let me go back here to the last slide. So the second demo, if you want to try that yourself, we have the second demo available here through this QR code.
00:43:39.112 - 00:44:00.584, Speaker B: Let me open this back up so you can scan this QR code. This will actually open up again. The deployment of that second demo that I went through using protocol connect both of these, you can try yourself. Super simple, the same mechanism that I just showed you. You just have to get some support ETH for Linea and you can do transactions. Try it out yourself. Then, of course, if you want to learn more about particle, you have our twitter there and our website right there.
00:44:00.584 - 00:44:43.574, Speaker B: Like I mentioned, our main goal here is to improve user experience and sort of set the stage from multiple different angles, from social logins to account abstraction to chain abstraction, to set the stage here for mass consumer onboarding. Of course, Linea has been one of the main chains we've supported for quite a while, and we are one of the largest providers on linea. We've done some pretty big campaigns on Linea in the past and we support a lot of the kind of top projects that are building linear as well, which we're very excited about, and that we've been very happy to support the linear ecosystem with these kind of tools and hopefully contribute in our own way to bring Linia to the mainstream as well from that perspective. So yeah, that's kind of about it for me in terms of understanding the landscape here and the programmatic implementation of these technologies.
00:44:45.474 - 00:45:05.360, Speaker A: Woof. That was a fire hose of information, but actually super interesting. There's a lot of sexy pieces. I was, I mean, you're talking about the universal account thing. I was super excited. I was like, does this exist yet? So it's good to know that you guys just launched testnet. I think like one housekeeping thing is for all the, I guess, QR codes.
00:45:05.360 - 00:45:18.336, Speaker A: Do you also have like the hard links to like GitHub, repos and things like that that we can store and like flash on the screen? Because I guess some people might be watching through mobile so they can't really scan. Sure, yeah.
00:45:18.400 - 00:45:24.592, Speaker B: I should be able to actually throw those links maybe into the YouTube chat or something of that nature.
00:45:24.728 - 00:46:11.524, Speaker A: You can send it in the private chat and then I can blast it everywhere. That is the power of this multi streaming platform. Yeah. So I was going to ask a few questions just to like, I feel like you covered this, but this is more of a, how do I put this? Like, I think there's a lot of like, smart contract or like wallet providers that do a really good job of creating that seamless experience for web two devs or users. Right. But I think the flip side that I've had a lot of struggle with, why is this not posting? This is weird. Okay.
00:46:11.524 - 00:46:47.846, Speaker A: Maybe restream will fix itself. Okay, you know what? I don't know. I'll post it in a recap post. What was I saying? Oh, yes. Okay. So I run into an issue where it's like I want to do all of these logins, or let's give an example, right? So like, ticketing ticketed events, I think is a really popular kind of new use case of like, we want to do NFT tickets, but a lot of events have non web3 native users. Let's use social logins to make it easy.
00:46:47.846 - 00:47:46.284, Speaker A: Right? The problem that we run into, I think, is like the two pieces, right? It's either completely custodied. So I don't like, it's not easy for me to figure out how to like, keep that information. Or maybe it is self custody, I don't know. And like, the other piece is like, okay, well, now I have this new thing, but I actually wanted to use my metamask wallet that I already have rather than going through like, this whole like, automatically created account for me. And I think that tails into the question of like the universal account as well. Like, when I first heard universal, I was like, oh, does this mean now I can like link up all of my random wallets that I have everywhere to control all at once? You know, because that's the interface that I want and that's, I guess, something that's very relevant for a web3 native user, but not super relevant for someone who's just onboarding because they don't exist in my world. Okay, well, now how do we pull together?
00:47:46.744 - 00:49:08.268, Speaker B: Yeah, yeah, it's a, it's a pretty interesting kind of like, I think a big part of the problem at the moment is that there's just like not really a unif, I mean, I don't mean to say the word universal again, but there's not really like a unified standard, I guess, in terms of like how wallets are managed. And like, I think a lot of these applications that they have good intentions in terms of using social logins, but a lot of them, especially ticketing platforms, are things that they really want to interface with consumers. What happens sometimes that they actually focus too much on consumers and forget about web3 natives, like you said, maybe when you use metamask or waltz, they have their funds on already or they want the NFT to be on. I think this is where, for example, hopefully what we see is that there's going to be this movement, ideally in this world where the lines between web two and web3 are blurred. The really only differentiator is going to be that whenever you log into a web3 application, you just have this added section of connect your wallet. The actual standard onboarding process will be the same for web two and web3 through social logins. But in terms of these specific additional onboarding functionalities, you'll have for all these web3 applications, the ability to connect my metamask or my phantom wallet or whatever it may be, this is kind of the reason we built particle connect SDK is to be an implementation of that to some degree, because we really do encourage developers to build with that because I mean, it's just a lot more equitable.
00:49:08.268 - 00:49:47.892, Speaker B: And even if they are building with particle auth for exclusive social logins, we almost always encourage them to build a modal where it's like have social logins and you need to have a mechanism for people to onboard via normal wallets. This goes for all applications. If you're just building a DeFi protocol, usually that's more self explanatory. But if you're building a very consumer facing application like an NFT ticketing platform or anything of this nature, then I think it's very important to make sure that you're catering towards both audiences. But you also do have the problem of wallet fragmentation. This is something that we've also thought a little bit about in terms of how do you solve this idea of. I have not just different balances across different chains, I have different wallets across different chains.
00:49:47.892 - 00:50:43.366, Speaker B: I'm using Phantom for Solana, I'm using metamask for ETh. I'm using kepler for cosmos, using uNICEf or bitcoin. And what do I do here? So, one thing that we've understood, I think it's in terms of the way that we see it, is we do see a lot of it more from the standpoint, like you mentioned, of new users that are getting into web3 that have a fresh perspective, a fresh state of zero, whereas when they actually create a universal account, one idea that we have is that they really should just use the mechanism that they onboarded through for everything. So if they onboard through metamask, then they should use metamask for every chain. They shouldn't have to download different wallets. So, for example, they go to Solana, they should be able to use metamask for Solana, they should be able to use it for bitcoin, they should be able to use it for Cosmos, and they shouldn't have to worry about, does this wallet support, this different chain? And they should just have one wallet with one address for every different blockchain, and have one balance that spans every different blockchain. So what we're actually going to be doing is.
00:50:43.366 - 00:51:46.782, Speaker B: I didn't mention this, but universal accounts will also have this mechanism of using actual MPC nodes, kind of similar to chain signatures. A little bit, kind of what NiR is doing, if you've ever heard of that. But basically, for us, we're going to have users be able to leverage accounts on these non EVM chains with social logins, an EVM wallet, or even a non EVM wallet. And you can basically have your main address, you have your bounces on EVM chains, and through the same wallet modal, you can see, for example, your BTC on bitcoin. But when I'm doing a transaction with that BTC on bitcoin, actually in the backend, what we're doing is we're leveraging an address that is computationally tied to your overall address that you still own through the proxy of that computational being tied to your address. Then you, through that nature, actually have that balance within your universal account. Of course, it's on a different address or different account, but it's still bound to you and then we can handle how we actually do transactions in that sense on the backend, it's all removed from the end user.
00:51:46.782 - 00:52:30.794, Speaker B: But the idea here is that they can leverage the single wallet interface, whether it be social logins or any wallet they want to use, and then as a result be able to leverage wallets and different mechanisms across every different chain, EvM or not. This is the idea where we want to have this experience where users don't need to manage multiple wallets, multiple bounce across different chains, and of course have the option of simple social logins and whatnot. We hope that for new users specifically, this will be a pretty big point for getting a web3. But there's definitely still the issue of web3 natives. It's hard to do a lot of this retroactively. I think this next generation web3 users are going to have it much easier than what a lot of us do at the moment.
00:52:32.354 - 00:52:39.894, Speaker A: Yeah, that's fair. That's fair. I shouldn't make everyone make tailored solutions for our little small club.
00:52:41.594 - 00:53:08.774, Speaker B: Much more than most people think. I think there's very few people in web3 than most people think. It's much bigger than it actually is. I think there's this report, it's pretty good by, I forget the organization, electric Capital. I think in total they measured about 25,000 developers in the space. And it's like, it feels like there's a lot more than that. But I think web3 styles a long way to grow in terms of developers, in terms of users, and hopefully this will play a little bit of a role in that.
00:53:09.194 - 00:53:34.156, Speaker A: Okay, awesome. Well, this was super informative. Oh my God. I think my brain is slightly broken. You guys are doing a lot of different things. I didn't realize you guys had the whole component also being plug and play, which was super cool. I really like, I think especially in the wallet account abstraction space, I guess I haven't played very deeply with any of them.
00:53:34.156 - 00:53:51.104, Speaker A: I always feel like I'm like, okay, well, I have to choose one and decide between how everything works together. But I found it interesting that you guys can pull in biconomy and all these other services. If I remind me correctly. Is this specifically for the Paymaster component?
00:53:52.864 - 00:54:27.804, Speaker B: You can use for Paymasters? Kind of the three pieces of modular infrastructure that you'll typically look at things that can be swapped out. You look at the smart account implementation, which is the actual wallet that you're using, the contract that you're using for your account. This can be biconomy cyber connect Alchemy's lead account, simple account, Safecor, zero dev, stuff like that. Then for pay masters you can also use other providers like biconomy, stock up and so on. Then for the bundlers you can also use a multitude of other providers. We have our own infrastructure for this, but we have a lot of users that they want to use biconomy because. Awesome.
00:54:27.804 - 00:54:38.852, Speaker B: So they can use them or they can use alchemy or anything like that. So that flexibility is we found to be pretty important for a lot of developers, just this principle of being open and being modular in terms of the stack that you can use.
00:54:38.988 - 00:55:08.784, Speaker A: Yes, I love to hear that. That's amazing. Okay, we are around time, so I will, I guess we can end things here and then post the information everywhere for people who weren't able to attend live and I guess hear from you. I guess maybe the last piece is like, how do we. Is anything interesting coming up for particle ways for people to interact? Like, are you gonna be irl anywhere?
00:55:10.204 - 00:55:32.836, Speaker B: Sure. Yeah. You know, we were just, of course in, we were in Korea, then we were in Hong Kong. And then originally we were going to do this session a little while ago in Dubai. But it was crazy. I was stuck in this mall and water was falling through the roof and I couldn't get back to my hotel. I ended up, after we canceled it, like a two hour trek through the flooding back to the hotel because there was no ubers.
00:55:32.836 - 00:55:58.410, Speaker B: It was a crazy experience. But that was the last event that we attended. We did a bunch of stuff out there and now we're getting ready for consensus. So I'll be out there. We're doing a few kind of events with, we're going to do one with Agora and a few other guys that are kind of in the same account chain abstraction space. So we're going to be doing that later this May. We're also going to be at ECC, we're going to be at Token 24 nine Singapore, probably going to be at Devcon later this year, stuff like that.
00:55:58.410 - 00:56:16.954, Speaker B: So we're kind of all over the place. You can usually find me wearing a particle shirt somewhere. I'm definitely always happy to chat. And we have a lot of pretty crazy things happening over the next, really just two months. Of course, we just did testnet for universal accounts. We're going to be doing another phase of Testnet which expands functionality even further. Really just in two or three weeks.
00:56:16.954 - 00:56:39.410, Speaker B: Then going into the rest of this year, we're going to be doing mainnet and a bunch of other things and we're hoping to end off q three with a full main implementation of universal accounts, having this start to be influenced across the ecosystem. So you can expect a lot of us in that regard as well. So yeah, pretty excited again. Thank you for having me on. I always love these sessions. I watch these all the time. I was watching the one from covalent just the other day and they're always super solid.
00:56:39.410 - 00:56:43.114, Speaker B: So glad that we had the opportunity to kind of go through this today, and I appreciate it.
00:56:43.194 - 00:56:56.106, Speaker A: I'm like, oh no, please don't watch my old stuff. I'm embarrassed. Yes. Okay. And one last piece Linia is kicking off. It's what our may dev cook off. So I don't know if you know this tabasco, but we started monthly hackathons.
00:56:56.106 - 00:57:31.998, Speaker A: We just closed off our April 1 and we had like 40 submissions, which is pretty cool. So for May, we're starting a new one. And if you read the instructions, you have bonus points for integrating partners. I think adding particle would be a super like smooth brained way of capturing the bonus points, improving your dapps, things like that. So keep in mind, I don't think I've released registration information, but yeah, if you know, it's coming up. Submissions are due May 31. Integrate particle and then I have the GitHub link that I'll post and edit the things.
00:57:32.126 - 00:57:32.366, Speaker B: So.
00:57:32.390 - 00:57:42.614, Speaker A: Yeah, okay, cool. Thank you so much. I'm going to wave goodbye and hit end stream and we'll see you wherever, I guess. Consensus and all the conferences that are basically coming up.
