00:00:00.090 - 00:00:27.334, Speaker A: We're live. I never check, so if things go wrong, that's fine. I have a recording and we can figure it out afterwards. But anyways, I guess to start off, this is another developer workshop. I'm really excited today, bringing on a good friend from Axelr. He presented, I guess, like he's bringing on a full code walkthrough, which is really exciting. I'm super, I guess, happy to learn, but I'm going to stop talking because I'm not important here.
00:00:27.334 - 00:00:31.320, Speaker A: This lovely individual is. So please introduce yourself.
00:00:32.730 - 00:00:56.720, Speaker B: All right, thank you so much. Hi, everyone. My name is Idris, Idris Olubisi. I'm a software engineer and a technical writer, currently working as a developer advocate at Acceler. And I'm really, really excited to be here to talk about things and also how to build a full stack in touch in Dapp and also deploying on linear and then doing crosschain messages with.
00:00:57.250 - 00:01:07.780, Speaker A: Yeah, awesome, awesome. So I guess the first question I'm going to dive into and I feel like you probably have slides for this is what is Axelr? How does it.
00:01:08.710 - 00:02:06.710, Speaker B: So, yes, just to summarize, I'll be going through that during the presentation. Right, what is Acceler? And then accelerate stack and how Acceler is solving the interoperability between chains. Right. So basically, Axela is a cross chain communication protocol built on the Cosmos tendermint SDK, and it helps facilitate cross chain communication between chains. So either within the EVM ecosystem or from the EVM ecosystem to the cosmos ecosystem. And I'll be sharing, like use cases how everything started and then why acceler and some of the things that the tech stack, the accelerate tech stack and the GMP messages, which is a feature from Acceler that help you to move, send messages cross chain and how to do that with a single click as a developer and also from the user perspective.
00:02:08.090 - 00:02:16.758, Speaker A: Very cool. Yes. I'm excited. We did a panel in what city was it? Paris. Together.
00:02:16.844 - 00:02:18.070, Speaker B: Paris, yeah.
00:02:18.220 - 00:02:23.420, Speaker A: So many hot ticks. That was really fun. I might ask you to repeat everything you said because it was really interesting.
00:02:24.190 - 00:02:24.842, Speaker B: Yeah.
00:02:24.976 - 00:02:33.294, Speaker A: Guys, there's a lot of expertise and knowledge we have here with us today. Okay, cool.
00:02:33.492 - 00:02:34.240, Speaker B: Exactly.
00:02:35.010 - 00:02:37.920, Speaker A: I don't know if you want to dive into it.
00:02:38.290 - 00:02:57.542, Speaker B: All right. Okay. Yeah. I'm sharing my screen already, so let me just present and then we get started. Okay. So I still hope you can see my screen anyways, so, hi, everyone. Welcome again.
00:02:57.542 - 00:03:54.646, Speaker B: Thank you all for joining. Today we'll be talking about building a full stack interchange dap on linear with Acceler. And I will try my best to make you an expert building a cross chain application through this presentation and also doing an Anton coding session where we'd see how to implement all of these things we talk about from the smart contract to deploying the smart contract and then connecting it to a front end Nest Js app and testing out the application. So my name is Idris Olubisi. I'm a software engineer and a technical writer, currently working as a developer advocate at Acceler. And also you can find me on all social media platform as Olanetsoft. All right, so today we'll be going through how everything started with web three and in the web three space, what happened initially and then gradually how things evolved over time.
00:03:54.646 - 00:04:59.974, Speaker B: And then I would also be spending more time on Asella tech stack, what happens behind the scene. And I would also mention how you can send tokens, cross chain and also the general message passing and some of the use cases that you could leverage when you're building with Acceler. And then of course the demo, the font part where we create the magic of building the smart contract, deploying the smart contract and testing out the smart contract from our front end application. So now how did everything started? In 2009 we have the first cryptocurrency launch, which is bitcoin, and it was introduced by the anonymous Satoshi Nakamuto. I know everyone might have heard about that. And then this decentralized blockchain itself utilizes the proof of work consensus mechanism and we gradually see more and more blockchain spin up. In 2014, Vitalik Buterium proposed Ethereum which introduces smart contract and enabling decentralized application on the blockchain.
00:04:59.974 - 00:06:06.606, Speaker B: So now you don't just use the blockchain as P to P, but also build your own application and a smart contract and then deploy on the blockchain which is also a way for providing and enabling decentralized application on the blockchain. And we also see the likes of Ox blockchain, we see the likes of Uniswap. And then gradually things moved, things start to change. From the era of 2017 to 2020, we have more and more solution, more and more network blockchain come up. Layer two solutions, the likes of Polygon, the likes of Avalanche and some other protocols that is helping to scale the Ethereum ecosystem, which means they already identify things like the transaction throughput, finality and all of those things. Right? A way for you as a developer to build an application and also improving the response time and also transaction throughput generally within your decentralized application. So we also see the likes of enterprise adoption grew up as major country explore solution around industries like finance, the healthcare system and supply chain.
00:06:06.606 - 00:07:07.266, Speaker B: We also see decentralized application finance being built on the blockchain. And of course exploding smart contracts within the era of 2019 to 2020 gained more visibility and also more traction within the space. And then it didn't stop there. We start to see more and more application, more and more protocols, trying to solve the problem of scaling, solve the problem of interoperability within the space. But ideally, how do we scale? Or how do we scale when we get to add more and more protocols, right? How do we scale? How do we provide more capabilities and features? How do we make the process seamless for new developers to get onboarded quickly? Of course, we know users have different needs. Some would consider privacy, some would consider cost, some would consider security. But every DAP with different use cases means that when there's more daps, you tend to see more chains.
00:07:07.266 - 00:07:55.830, Speaker B: But all of these chains are working in silos, they have different ecosystem. Which is why we need an interpretable technology that would connect all of this system together. And this is where Axela comes in, right? Axela is a decentralized interoperability network that securely connects different blockchain and allowing assets, application and users on various chains to seamlessly interact. So this solves that major pain point in blockchain adoption. So the fragmentation across different chains accelerate. Trustless inter blockchain communication protocol enables this composability without compromising security or control. So the network is blockchain, agonistic and agnostic rather, and currently connects major chains and we have over 45 chains connected.
00:07:55.830 - 00:09:42.722, Speaker B: And this means that all of these chains could connect and communicate with each other seamlessly. So now let's talk about the Axela stack, what is happening behind the scene? And then how is acceler doing this? So this is what the stacks look like. Like I mentioned earlier, Axela is a proof of stake blockchain itself built on the Cosmos SDK that enables cross chain communication between the blockchain. So we securely use validator to securely process and validate these cross chain messages that I mentioned by collectively voting on their validity. In this diagram that you have, we have the application layer where you see the like, know the different ecosystem, the cosmos ecosystem, the Ethereum ecosystem, Polkadot, the Avalanche and the likes. This also falls in the category of where you as a developer, you build your decentralized application and your users interact with them, but then it gather, moves on to the accelerate API layer where acceler provides API for developers to incorporate crushing capabilities with the accelerate SDK on the contract and also the front end and the layer one gateway shows individual gateway on each ecosystem, right? So gateway on each chain serve as an entry point for caution messages within that ecosystem. Right? And then we have the accelerate network.
00:09:42.722 - 00:10:48.890, Speaker B: So accelerate validates all of the events happening from the relayers to ensure the integrity and security. So this is where validation happens and the consensus, we have consensus agreements voting to verify on chain events and multiparty computation. So in summary, it means that on the source chain you initialize a message on the source chain, it gets routed and acceler sends it to the destination chain after meeting consensus, right? So moving on, I mentioned earlier that we're going to talk about descent token function. Axela provides, right, number one here is, as I would like to call it, descent token superpowers. First we have deposit addresses. We have sent token and we also have interchange token. I'll be explaining this in a couple of minutes, right, where we understand what deposit addresses function can be utilized for and how it works, and also send token and also interchange token.
00:10:48.890 - 00:11:58.100, Speaker B: Right. The first one on the list here is deposit address, right? Deposit address is a temporary special address created and monitored by the Axela relayers on behalf of the requester. So what you need to do is to install the Axela SDK and then initiate the asset transfer, setting the environment to testnet or minnet, and then you can declare, create a generate a deposit address, because this is a temporary social address, but it allows you to embed every information that is required for you to send assets to your destination chain. So here we're passing in the source chain, which is the from chain, passing the destination chain and also the destination address and the asset that you're trying to send. So it means that whenever this address is being generated and any font gets sent to this address, it will be routed to the destination address. So now it's already been configured by default, and then acceler handles the rest for you. The other one here, which is also part of the token transfer functionality, is send token function.
00:11:58.100 - 00:12:53.182, Speaker B: This is in acceler Gateway EVM contract that facilitates the token transfer between EVM and cosmos chains. It's as simple as calling this function within your contract and then passing in the destination name, passing in the destination address. The USDC, in this case, the asset here is USDC is just an example. So you can pass the asset, you can check out the astral docs for all the assets that we support and the amount that you're trying to send. So calling this function triggers this call between any of the protocol and then you already specify the destination chain so you understand the destination chain. You have the destination address and also the asset symbol and the amount that you want to transfer. The last but not the least on the token transfer function is the acceleration token.
00:12:53.182 - 00:14:06.102, Speaker B: So this allow you to send token crosschain, build your own asset bridges, and then build asset transfer into your interchange, decentralized application and many more. So how is this different from descent token and deposit addresses? So this allows you to create a standardized ERC token on multiple chains via the interchange porter, which I'll be sharing a screenshot in the next slide. And then it also allow you to build custom token on every chain with a built in method for sending this token. It allow you to upgrade an existing token if you have already deployed your token somewhere and you want to make it an interchange token. It allow you to upgrade an existing token by deploying a wrapper on every chain and it doesn't stop there. It also makes interchange tokens executable alongside GMP, which is general message passing any of these GMP messages for enhanced functionality. So for GMP messages, I will be talking about that in a few slides for you to understand what exactly it is and what are the features you can benefit from leveraging the general message passing provided by Axela.
00:14:06.102 - 00:15:05.210, Speaker B: So these are the things that you should understand and also how this is different from the interchange token. So now this is the interchange token service portal and you can scan this QR code to redirect you to this portal where you can create a brand new interchange token, deploy it on, register it on your origin chain, and then deploy it remotely across any chain of your choice. And you also have the ability to search for existing token and then make that token an interchange token. So in this screenshot I selected polygon, but this is not limited to polygon. You could select any chain and then search for it by entering the token address and then make it an interchange token. So now let's talk about the general message passing I mentioned earlier. Send token transfer is one feature which is part of what we discussed and what Axela provides.
00:15:05.210 - 00:16:04.334, Speaker B: So now the accelerate messaging passing message passing rather so send message. This is what I often refer to as like send messages superpowers, right? And we have two main functions here, the core contract and the core contract with token. I will explain this one after the other, and also be seeing core contract in action during the demo session on how you can use it, you can implement it in your code base, right? So general message passing. The first option here, which is the core contract, is the accelerator general message passing. What it does is to enable developers to build on one chain and then call any function on another chain. And this also opens a way for you to interact or send messages cross chain. So by calling this function called core contract within your contract, and then passing destination chain, the destination address, the contract address, of course, and the payload.
00:16:04.334 - 00:17:37.022, Speaker B: So the payload in this case could mean you be your array, a string, an integer, JsON, whatever you want to encrypt in a payload, and then execute function which gets run automatically on the destination chain, takes in the source chain, the source address, and also the payload that was sent from the source chain. So this is how you could create magic, sending messages, cross chain, leveraging, the accelerate the general message passing, and then the core contract function. The other one is core contracts with token, which also give you the general messaging functionality, with more ability. With improved ability, right? Not to send only message, but also send messages with token. And here, if you check the argument or the parameters that needed to be passed here, similar to core contract, but if you watch closely, you realize that we have the token symbol here and also the amount. So you're not just sending a message, but you're also adding token and assets to that message that you're sending. Right? And then we have the underscore execute token function that runs on the destination chain automatically, which also takes in the source chain, the source address, the payload, and the token symbol that you want to send.
00:17:37.022 - 00:18:29.050, Speaker B: And of course the amount that you want to send. So all of these things makes it easier for you to send messages cross chain and also attach token to that message that you send cross chain. So now demo time. So let's try to implement and build a full stack decentralized application. So what are we going to do here? We clone a simple next JS UI and write the smart contract. Deploy the smart contract on linear and then wire or connect like the smart contract to the front end that we cloned earlier, and then test the application. So after deploying on linear, by testing, the application would test the application by sending message from linear to optimism.
00:18:29.050 - 00:19:29.994, Speaker B: So you see how all of these things work. If you want to follow along, you can just use the bitly link linear workshop with acceler to redirect you to the repository where you can see the project clone. And not just that, on the readme, you find a step by step guide on how you clone the project, what is required for you to install and also step by step guide for you to write the smart contract, deploy the smart contract, create environment variables, connect your front end application. So now let's get right into it. Sorry. All right, so I will be sharing my screen now. So what we want to do right here is to first clone the project from the project repository.
00:19:29.994 - 00:19:36.322, Speaker B: So I've already cloned the project here, which you can see on my terminal. This is linear interaction workshop with Axela.
00:19:36.386 - 00:19:39.542, Speaker A: Can you zoom in a bit so you can bigger?
00:19:39.606 - 00:19:41.660, Speaker B: Yeah. Okay, thank you.
00:19:44.110 - 00:19:46.700, Speaker A: Perfect. Yes.
00:19:48.030 - 00:20:17.630, Speaker B: All right. All good now. Thank you. All right, so now we clone the project like I mentioned earlier, which I already did here. So what we just required for us is after cloning the project we do NPN install and then it would install all of the dependencies in the project and I already installed it. I just wanted you guys to see it. But let's see, after installation we run the project locally.
00:20:17.630 - 00:20:57.734, Speaker B: All right, good Claire. So now we can run using NPM rundev. So what this is going to do is to spin up this application for us in sjs application and our browser, which is available on port 3001. Yeah, so we can access that now browser saying 1 second it's loading. All right, okay so this is what it should look like. Let me just disconnect. We have the same experience.
00:20:57.734 - 00:21:32.846, Speaker B: So this is what you see by default. You see this UI and also an impute field for you to enter your message. I want to send crosschain and then you also see this button and a waiting for response. So this is literally expecting a message. After we successfully deploy and then interact with our smart contracts, this message will be retrieved on the front end. So we see what we send on the destination chain. Right? So for connect wallets, the project you clone already installed and implemented the rainbow kit installation.
00:21:32.846 - 00:22:06.094, Speaker B: So you don't need to do anything extra. All you just need to do is to connect your wallet when it's time for you to write to the smart contract. So we have this implemented already using WAgme. Wagme is a collection of react hooks that makes it easier for you to interact with Ethereum. So as a frontend developer this is also very useful for you to learn how to integrate all of this together. So now moving on, we have this settled already and this is what the project repository looks like. Right? So now we have this here.
00:22:06.094 - 00:22:55.590, Speaker B: But if you remember, our agenda is to write a smart contract. So after cloning the project, what we need to do is to write this smart contract but before we write this mass contract, what we need to do first is to create a project here, going back to this place and see a second screen on. All right, sorry, let me just navigate the project repository then. Yeah. All right. So we are here in the same repository, so we can clear this. And then what we're going to do right now is to create a new folder called Truffle.
00:22:55.590 - 00:23:24.946, Speaker B: So we'll be using truffle here as a tool for us to build, write, build, and deploy our smart contract. So I can just make it right. So this is up to you. You can call this back end, you can call this smart contract, this project, this directly name is really up to you. So once we create it, make sure you see the into the directory. And then now we are inside the directory. So what we need to do now is to install truffle globally if you don't have it.
00:23:24.946 - 00:24:12.078, Speaker B: So one thing you need to understand here is that truffle is the suit that is available for you to build, deploy, and compile your smart contract. If you're already familiar with Adhart, you can proceed to use Adhart. It's pretty much the same experience, but of course, different command line, but you still have the same experience to build and deploy your smart contract. So I already installed truffle globally, but this is what you need to do to install it globally, saying NPN install underscore g, then truffle. And then since I already have that installed, you can just proceed to initialize a new project. So by saying truffle in it. And then what this would do is to spin off the project inside the truffle directory that you just created.
00:24:12.078 - 00:24:43.314, Speaker B: So now you can also do NPM test. Right, sorry, truffle test. Just to be sure everything is fine and no errors during the solution. So I'm trying to test it now. Run the command truffle test and say zero passing, nothing fails, right? We don't actually have anything there, but yeah, let's proceed. All right, so I'll be going to the project directly. Now, if you check the project directly, we have the truffle folder created.
00:24:43.314 - 00:25:18.562, Speaker B: It includes the contract folder, the migration folder, the test folder, and also the truffle config. This is very important. We'll be spending some time here to configure when we want to deploy a linear, because we set up an RPC that will help us achieve this. So inside the contract folder, which is where we're starting with, you can create a new file. Of course we want to write a smart contract. So I'll call this send message. So the name here is up to you, right? If you want to name it anything, like maybe custom messages or anything, it's left to you.
00:25:18.562 - 00:26:06.290, Speaker B: In my own case, I named this file send message soft just to keep the name simple. So what we want to do right now is for us to write this smart contract. First we need to bring in solidity version, and here we'll be using anything greater than 0.8. And then we need to import all the accelerates that require for us to write, compile and build the smart contract here. So we have a couple of them, the acceler executable, the acceler gateway, the accelerator, and also the ERC 20 token that we are importing. Right. So now, defining the contract, it's as simple as saying contract.
00:26:06.290 - 00:26:51.342, Speaker B: Um, contract. Then you can call this send message. So the name is also up to you to define what you think would be best for you if you want to create the same thing or you're calling to be following along during this tutorial. So yeah, seller executables, which is what we reported just now, and then you open a closing bracket. So we need to add a couple of things. But to start with, don't mind copilot. So to start with, right, we define three variables and I would explain why we need them in a minute.
00:26:51.426 - 00:26:57.370, Speaker A: Could you also make this a little bigger? And I think you spelled XLR executable incorrectly.
00:26:58.750 - 00:27:10.060, Speaker B: Okay. Oh, thanks for catching that. So it runs into that error during compilation. Yeah. Okay. All right. Sorry.
00:27:10.060 - 00:27:16.322, Speaker B: Is it clear right now? Is it clear?
00:27:16.496 - 00:27:18.146, Speaker A: It's clear. And then.
00:27:18.248 - 00:27:18.754, Speaker B: Okay.
00:27:18.872 - 00:27:22.034, Speaker A: I think you spelled XLR with an e instead of an a.
00:27:22.232 - 00:27:23.122, Speaker B: Exactly. Yeah.
00:27:23.176 - 00:27:23.810, Speaker A: Right. Yeah.
00:27:23.880 - 00:27:26.740, Speaker B: Trying to change it, but I don't know.
00:27:28.950 - 00:27:33.830, Speaker A: They're not letting you time. I don't know what's so weird.
00:27:34.810 - 00:27:55.114, Speaker B: Yeah, but I'm not sure. But yeah, let's see. One sec. All right. Hopefully it's back. Okay. I think it's still trying to zoom in and has messed up with my old formatting, but yeah, it's fine.
00:27:55.114 - 00:28:38.010, Speaker B: So don't mind this underscore. I think this happens when you coding on your visual studio code. You write in solidity, just highlight it for some weird reasons and then doesn't mean that you have an error or something. So what we're doing to do next is to create an acceleras service because of course we want to send cross stream message between our source and destination chain. So you need to pay for gas, but we are doing it once. So there's already a service that you could leverage, which is the accelerator to help you pay that gas once with your native chain, and then you can proceed to do your question interactions, right? I'm not sure why this color. I like this.
00:28:38.010 - 00:29:11.934, Speaker B: But wait, let me just crucify and try to. Now something straight is happening. All right. Okay, now, so we created a constructor, right? And also passing the gateway and the gas receiver here. And then what we need to do next is to create a function that actually does the sending of the message. This function will take in the destination chain, destination address, and the value we are sending. So all of these things are dynamic.
00:29:11.934 - 00:29:56.050, Speaker B: You need to pass them in and this will be really useful for us. You see all of these things in action when we're trying to send things from the front end. So what we are doing here basically is to create a function here called send message. And then we pass in the destination chain, like I mentioned earlier, the destination address, the value that we're sending, and we're requiring to ensure that gas payment is done for this transaction to get stock or fail for any reason. Right. And then you now need to encode this payload, which is the value that you're sending. And then calling the pay native gas or call contract during this interaction, which is in the address, the destination destination address on the gas service.
00:29:56.050 - 00:31:02.898, Speaker B: This is directly on the gas service to pay gas for this particular interaction. And then you call the core contract I mentioned earlier during the presentation that actually does transfer, ascending from the source chain to the destination chain. So we pass it in the destination chain, the destination address, and the payload that we want to send alongside this particular interaction. Right? So last but not the least here is to add our execute, underscore execute function that I mentioned earlier that runs automatically on the destination chain. So basically what it does is similar, since we already have the source chain, we have the source address added and also the payload. And then this, decode the payload automatically and assign it to the message variable that we created earlier, which is here. So this message variable, why we're creating it and saving it here is for us to be able to retrieve it at the end of the day on our front end, because we want to be able to read the message that was sent from the source chain.
00:31:02.898 - 00:31:36.500, Speaker B: And also, if you can see here, we are also setting the source chain and the source address to ensure, or just to know where that message is coming from, and to also display it on the front end as part of the statistic or the stats for this interaction to tell you hey, this is coming from this chain. And this is the address. And also this is the assets or the message that gets sent from the source chain. Right. And that's it. That's all we need to do here in our smart contract. Let me just add this formatting here to make this.
00:31:36.500 - 00:32:17.230, Speaker B: Okay, it's already added. All right, good. So going back to the solidity file here, this is all you need to send message cross chain, and also all you need to retrieve those messages based on the state variables that we created earlier on. Right. So what we need to do now, since we've already created this, we need to just proceed to deploy our contract. But first, before deploying, we need to make sure everything works fine by compiling our contract. So we can just head back to a terminal and type in truffle compile.
00:32:17.230 - 00:32:57.066, Speaker B: So if you're doing this with Adhad, you should be able to also compile this. So let's compile contract so you can see the error we have in here. It says bugatti contract here, solidity line twelve. Okay, so I think we missed a column here. So which is why we have that change color coding. Right, so which is a good way for you to verify that you have everything impact before you try or attempt to deploy your contract. So now we have it, we can just go back and then run truffle compile.
00:32:57.066 - 00:33:25.382, Speaker B: I'll just clear my terminal. And it did. So it says compile successfully and just do that once again. So it sees clearly compiling so there's nothing to compile and everything is up to date. So there are no errors and we can proceed to set up our RPC. But first, what we need to do here to set up our RPC is to create a env file inside. So now let's close this so that you see where we are.
00:33:25.382 - 00:34:21.378, Speaker B: So currently under the truffle directory. So what you just need to do is to create a env file under this directory. So now what do we need to add? Under this directory is our mnemonic phrase from our wallet and also the project id that we can get from the infrared project id. So how do you get the project id? You can just go to infrared IO, you go to infrared, IO, you create an account, set up a project, you'll be able to get an API key and get this access to your API key. And of course you can also see we can get RPC to all of these keys, right. That is where you could literally get your info, project id and also your private key. And it's clear that you should not share this private key with anyone and make sure the env file is part of the git ignore file.
00:34:21.378 - 00:35:12.966, Speaker B: I already added that if you clone this project and you try to work with it. So I will just do the same right now by adding my EMV file. All right, so I just added mine, which added my private key and also the Inferra project id so you could get that like I already showed. So now let's proceed. Now we've completed the process of setting up our environment variable. The next is to go inside the trophy config JS so that we can set up. So if you go inside the trophy config JS, you find out, like a lot of comments just to guide you on how to do it.
00:35:12.966 - 00:36:05.782, Speaker B: But yeah, first, what we need to do here is to uncomment a few things that we'll be needing in this guide to set up our RPC, which is the first one here, would uncomment this to be able to read from the environment variable so that we can get access to an mnemonic and also the project id. And then we also uncomment the HD wallet provider, which allow us to create a provider to connect our private key. Right. So you have this option, if you are deploying locally, you can enable this development environment is already set up there. Just on commencing it, you'll be able to run it locally. But since we are not doing it locally, we're deploying on the linear network. This is a testnet on Testnet, right? So we don't need to enable this, right? If you can see, you see the advance, you see if you're deploying to Guli network and all of that.
00:36:05.782 - 00:36:44.974, Speaker B: But yeah, in this case that we are not doing all of this. So let's just set up for linear testnet and also the optimism. So remember I mentioned that we are deploying on linear and then send the crossing message to optimism, right? So we need to configure for both of them. So first, to start with, we start with linear goalie, of course. So what we're doing here in enabling the mnemonic phrase and then linear goalie network, we got this URL from our inferior. Then you are adding the project id. And of course very important for you to set the network id, which is 59140 for Testnet.
00:36:44.974 - 00:37:34.878, Speaker B: And the other one is the optimism RPC setup, which is the network id is four 20. And we can just do the same thing the way we did for linear. And then that's what we need to do here to set up our RPC and then to be sure, we can deploy our application or we can compile and deploy our smart contract successfully. So next, what are we going to do next? We're going to deploy our smart contract. So now we can navigate to the migrations folder and then create a new file called underscore. So you can call it deploy underscore contract JS. So now this is our deploy script.
00:37:34.878 - 00:38:11.390, Speaker B: So one thing we want to do here, remember, we want to deploy to linear and inside our contract here, let me just go back there. It is very important you don't skip this step. Remember that in our constructor we are passing two variable, which is the gateway and the gas receiver. This is acceler gateway and also gas receiver. So in our contract, we'll make sure that we pass in these two arguments to ensure our contracts get deployed safely. And also everything is set correctly. So with that, it's very simple for linear.
00:38:11.390 - 00:38:57.518, Speaker B: So for linear, this is all you need to do to get like the active arts from the directory and then the gateway address. So for linear, we have this gateway, and then the gas service, we have this. So if you want to get the gas service, very simple, just go to the docs accelerate. Under testnet, you can find what is required for you, the chain name and for all the chains supported. So for linear, we have the gateway contract. You can just copy this and then go back here and then paste, then go back to the docs and then get for gas service contracts. And that's it.
00:38:57.518 - 00:39:32.674, Speaker B: So now we can safely deploy our smart contract to linear with all of this setup. We've compiled our contract earlier. What is required for us now is to deploy this contract. So now go back to terminal and then type in truffle. So truffle migrate. So network in this case, because you're deploying to linear. To the linear underscore goalie, this is the name we gave.
00:39:32.674 - 00:39:56.870, Speaker B: Let's go back to the truffle config. You can see the name here is linear agony. That's why I'm mentioning Linear goalie here. So now you can deploy, sorry, it's truffle, not the other way around. All right, so I'm currently deploying now to Linear.
00:39:58.090 - 00:40:06.220, Speaker A: You also spelled network as net rock. Yeah, also zoom in a bit too.
00:40:06.590 - 00:40:10.154, Speaker B: Okay, let me just zoom in. Thank you.
00:40:10.272 - 00:40:11.930, Speaker A: Tell them that's misspelled.
00:40:12.910 - 00:40:33.486, Speaker B: What's happening? Yeah, all right, one sec. Okay. Truffle network. Thanks for spotting that. Yeah. So let's see things. Well, and then we compiling our contract.
00:40:33.486 - 00:41:18.606, Speaker B: Actually, we didn't change anything after the last compilation. So. Yeah, just go ahead and deploy. So you can see the network name is Linear goalie and then the block name is this. So you say deployment failed? She's strange. All right. Okay, see, is there anything wrong here? All right, some bridging things.
00:41:18.606 - 00:41:52.740, Speaker B: Everything is fine. I'm not sure. It's currently compiling. Compiling and trying to deploy. It's an invalid op code we're trying to deploy. So this actually satisfies all of these? Confirm we have everything set up here in the trophy config.
00:41:53.640 - 00:42:07.564, Speaker A: Did you say you already deployed this before? Yeah. I wonder if something weird happened. I know Lenny is going through some changes right now. Also, truffle has had some weird things too.
00:42:07.682 - 00:42:08.060, Speaker B: Okay.
00:42:08.130 - 00:42:12.380, Speaker A: I was going to ask you why you chose to use truffle, actually, just out of curiosity.
00:42:13.840 - 00:42:18.156, Speaker B: Yeah, I realized kind of connection between inferior truffle.
00:42:18.348 - 00:42:19.776, Speaker A: Yeah, I don't know, that makes sense.
00:42:19.878 - 00:42:34.660, Speaker B: I just wanted to use like the old stack. Also you can use adhart, of course, to do this really fast. But I've tried this even this morning. I deploy like twice with the same process, following the same process. I'm not sure why happened.
00:42:34.730 - 00:42:35.428, Speaker A: I'll check.
00:42:35.514 - 00:43:11.330, Speaker B: Yeah. All right, so one thing we can do deploying these is let's try to. Okay, let me just try to deploy to optimism and see what happens. We just be sure. Okay, all right, almost there. Compiling. Let's see.
00:43:11.330 - 00:43:55.450, Speaker B: I'm not sure. Oh, we keep the same reason that there's something wrong. Just give me a sec, let me see if we miss out anything. I think this happens mostly with demos. Okay, give me a sec. Oops, click the wrong button. But give me a second, I'll be back on track.
00:43:55.450 - 00:45:11.460, Speaker B: All right, fine. Yeah, I'm just trying to cross check if I might have missed something out. Yeah, I think. I'm sure I did not miss anything. This. Okay, so it, I'm not sure why deployment is failing. Show why deployment is failing while trying to deploy and then she range it does happen.
00:45:11.460 - 00:46:10.336, Speaker B: Okay, give me a second. I think should see what might happen. Q. Wait, is the compiler. It's not even the compiler. I'm not sure it's compiler because it sets anything from a. If you're using any development tool like Adhart, I think you can also follow the same process to deploy.
00:46:10.448 - 00:46:15.610, Speaker A: Does it deploy locally? So if you run like truffle, develop?
00:46:18.300 - 00:46:20.712, Speaker B: Yeah, I don't have the ganache instance running.
00:46:20.766 - 00:46:29.020, Speaker A: Oh no, so you don't. So there's an instance of ganache within truffle so if you run truffle space develop in your terminal.
00:46:29.600 - 00:46:35.230, Speaker B: Give me a second here.
00:46:37.600 - 00:46:53.030, Speaker A: That should run an instance on I think 9545. And then you can do a migrate here. Just like migrate. Oh, can you uncomment development in your config though?
00:46:56.090 - 00:46:58.120, Speaker B: Did I enable it? Oh my God.
00:46:59.290 - 00:47:16.790, Speaker A: Okay so then if you just type migrate. Oh wait, but you're using existing contracts, right?
00:47:17.560 - 00:47:19.676, Speaker B: Yeah, I'm using existing contracts.
00:47:19.728 - 00:47:24.644, Speaker A: So you'll also need a fork and you can't fork through truffle so you would have to download.
00:47:24.772 - 00:47:25.450, Speaker B: Yeah.
00:47:27.260 - 00:47:28.040, Speaker A: Never mind.
00:47:28.110 - 00:47:33.870, Speaker B: This isn't, but this works locally. I'm not sure why.
00:47:36.160 - 00:47:54.050, Speaker A: I feel like it works, but it's like fake addresses right. So it's not really interacting with it. But if you had forked ganache but you don't have it on your thing. Live debugging. This is fun.
00:47:54.500 - 00:48:45.410, Speaker B: Yeah, just give me a second. The error is pointing to. Let me try and see what the error is. I think I've gotten something similar before about three days ago. And then I realized that, I realized it was versioning across the error, which is why I actually specify to use this. Okay, let me confirm another thing here on some of our packages that was installed. Yeah.
00:48:45.410 - 00:49:39.680, Speaker B: Okay. Just try this second. I'm pretty sure, like sure I'm getting this and I need to update book of para and then yeah, um. Oh my God. It's a compiler version. Fixed it. So it's currently deploying.
00:49:39.680 - 00:50:21.196, Speaker B: So that's one strain thing happening, right? Yeah, so we have, so we have it deployed now on linear testnet. So you can see we have our contract address and also you can verify this on the explorer just to be sure everything is fine. Also keep track of it. So this is not the address. Let me paste the new one that we just deployed locally. So we have it here. So you can see just deployed successfully 7 seconds ago.
00:50:21.196 - 00:50:55.692, Speaker B: So now we good. So we can go back to, yeah, we can go back and then, okay yeah, it's very important that we note the contract address that we just deployed to. Right. So one thing I usually do is to come back to the migrations folder and then under deploy commit. So I can add a comment here saying linear, sorry, let me go back. So just add comments here. Linear.
00:50:55.692 - 00:51:22.530, Speaker B: And we can drop the contract address. Yes, because we'll be needing this for train interaction later on. Right. So now we can deploy to optimizing just pretty much the same process. Nothing have changed. Believe we don't face any error again, but it's part of the process anyways. 1 second.
00:51:22.530 - 00:51:53.544, Speaker B: Okay. All right. It's also deploying and yeah, there we go. Successfully deployed to optimism. So what we can do again is to just note this optimism and then let's add it here. So now we successfully build, compile and deploy our smart contracts. What next? Let's wire up.
00:51:53.544 - 00:52:24.128, Speaker B: Let's see something in action. Let's test it on a testnet. Right? So now we're done with anything inside the truffle environment. That's the truffle folder. In your own case, maybe you're working with hard hat it still works the same way, or you're working with foundry to work the same way for you to build, compile and deploy your smart contract. So what we're doing next, now, after we done deploying, you need to go back to the root folder and then create env file. Env local.
00:52:24.128 - 00:53:07.070, Speaker B: So what we want to add here, we want to add what we just deployed. And then we also want to add an RPC URL for optimism. Right? So basically the RPC URL is here. You see that in action on front end where we're trying to read message from optimism. That's what we initially sent and we're trying to retrieve it back from the blockchain. So another one here is the linear contract address that we just deployed. So you can just copy earlier and just go back to where is this? Okay, yeah, cool.
00:53:07.070 - 00:53:40.888, Speaker B: Yeah, so I can enter the address here and go back to the deployment and copy for optimism. And that's it. You set up your front, your local development. So now we can head over to the index js file because that's where we have tons of things happening. But before then, I think I almost missed out something. This inferior IO VC contain the project ID. So this is similar to the project id you copied from the dashboard, from your dashboard on infria earlier on.
00:53:40.888 - 00:54:24.292, Speaker B: So I'll just go ahead and then add mine. So of course it's free. You can create an account, you create an account for free and then come back here to utilize project id. So now let's go back to our project inside pages folder, then inside index JS. So inside index JS, you see all of these things already set up. Like these are mostly styling, no functionality yet. And also we implemented the react switch for making dark mode and lights mode, the rainbow keys for collecting your wallet, and also the wagmin setup and the accelerator on the front end, which will be using to get our gas estimates.
00:54:24.292 - 00:55:04.020, Speaker B: Because of course for every chain there's different gas utilization. So for you to get the estimate. When you're trying to facilitate or send messages cross chain or sending assets cross chain, you need to get an estimate. And then when you get an estimate using the SDK, you can just pass that into do a right functionality into your application. But to start with. So what we're going to do here is to import all of our environment variables that we have created and also import our contract. Abi, so let's go ahead to import the contract here.
00:55:04.020 - 00:56:12.152, Speaker B: So send message now case, it's called send message contract. And what we're doing is navigate into the truffle directory inside the butte folder under the contract directly and then pointing it to send message adjacent. And we are also importing the nest public linear contract address that we added and the optimism contract address and also the optimism URL. So to start with, we are going to do a read functionality where a user can impute a message and then click send to write into the linear blockchain which would end up get sent by the acceler network to the destination chain, which is our optimism in this case. So to start, we will set a couple of state variables for both messaging and also the gas fee, similar to the way you do. It's very simple. You're sending a new message state variable and then the accelerator query API, setting it to testnet and of course create another variable to get the gas fee and then setting the gas fee default to zero.
00:56:12.152 - 00:56:54.788, Speaker B: Then next what we do is to get this gas estimator. So we want to get the actual gas fee for us to initiate this transaction so that it doesn't fail. And of course we don't add code, a specific fee since the gas fee varies based on network. Right? So creating a simple function here that gets a gas fee and also pointing it to linear, it takes in a couple of methods, a couple of parameters here you could see like the source chain id in our own case here, it's linear, so you just need to point to it. It's already been provided by the SDK. Just point to it by saying EVM chain linear. And then the destination chain here is optimism.
00:56:54.788 - 00:57:19.952, Speaker B: Optimism. And then the token symbol is if, of course. And of course these two fields here are optional, but here you can have it. This is a gas. You can find all the details here, actually. So this is the gas limit. In this case I'm using thousand and then the gas multiplier, which help you to buffer the gas times two so that just to ensure that the transaction doesn't fail at any point.
00:57:19.952 - 00:57:55.550, Speaker B: Right. And then you have a gas enough for you to pay for this transaction fee. So now let's proceed to write function. So this is like very important part and I would like everyone to concentrate here when we try to write into our contract address. So write on the linear blockchain rather. So what we're doing here, we're using use, prepare contract, write hook. And it takes in the linear contract address, the ABI, which is our send message contract ABI that we imported earlier on.
00:57:55.550 - 00:58:59.740, Speaker B: And then the send message function, right? This is what we created earlier on in our smart contract. And if you remember that the send message function here, let me just quickly go back to the contract here. Send message takes in accepts destination chain, destination address and the value. So going back to the front end here, we are also passing the destination chain, which is optimism. We're passing the optimism contract address that we deployed into, because this is from our environment variable and also the message that we're sending from our front end. And then now we're passing the gas fee, which is generated or estimated by the gas fee estimator using the accelerate SDK. And then what we're doing here is to write passing in the config and wait for the transaction to succeed, so that we can keep track of sources and then show something very nice for user as a feedback to let them know, hey, your message is currently being sent.
00:58:59.740 - 00:59:40.956, Speaker B: Or hey, your message has been sent successfully. Right? So next, what we need to do is to create a very simple function that will be calling in our send button. This is very simple. This takes in our rights that initiate the contract call which we get from the use contract rights. All of these things here that you're seeing here are ways for you to write to a contract using Wagmin or the rainbow kit, right? So now we have the toast information here. This is just showing toast. After you initiate the call to write, it says send messages, sending message, right? And then that's all you need to write the message.
00:59:40.956 - 01:00:33.116, Speaker B: So next, what we're going to do is to call our gas estimator and use effect. So once the component mounts, be able to get a gas estimator and make sure it's ready. So before you send the transaction, you already have an estimate of what the gas looks like. And then here also to keep track of after the transaction has been sent and it's successful, we want to give user feedback saying, hey, your message is sent. Or maybe if you run into an error, say, hey, your transaction did not send for some reason, transaction error. So we can just listen to its success, which is something we already have access to from the Wagme hook, and it keeps track and message sent after it has been sent successfully if it's success. And then if it fails it says error sending message.
01:00:33.116 - 01:01:09.960, Speaker B: And we can also keep track of the use contract rights data and also use weight for transaction data. So all of these hooks are coming from Wagmeho. You can look it up on how to interact with this with contracts from your front end application. This is how simple it is to interact. Right. So now we've set up the functionality, now let's call it in the actual impute message. Let's grab the impute from the text area, let's grab whatsoever any user is typing into the impute and also call the on click function.
01:01:09.960 - 01:01:48.468, Speaker B: So here we do unchange. Then we can pass in the set message, the evalue to the set message state variable that we created earlier on to update the message variable. So now we can also do the same for send button here, which in this case it's a button. So it's going to be an on click handle message. So this is what we need. So we can safely go back to our application here. And if you want just to refresh and be sure everything C works.
01:01:48.468 - 01:02:23.356, Speaker B: Nothing good. Yeah, so I have my linear connected, so if you want to see that again, right, this happens like by default, but let me just connect it again, which is the experience you see if you loan your project for the first time and you run through this process. So now I can click on metamask and it gets connected. So I can enter a message saying hello world. Hello world. Right. Which is the first thing we do most times.
01:02:23.356 - 01:02:50.550, Speaker B: That's the programming language, right? So hello world. And then we click send, so it says sending message which is notification that we enabled earlier on the toast notification. And then we click confirm. You can see transaction here. And then we confirm the transaction. We go back to our application and then wait for some few seconds. We should get a feedback after the message is sent.
01:02:50.550 - 01:03:54.500, Speaker B: Yes, this is message sent, right. And of course in a few seconds we should get a confirmation from Metamax indicating our message has been sent successfully. Okay, I think this it, yeah, should be all right, so this is it, message sent successfully. So we can head over to track this movement to see how this moves from what is happening behind the scenes during this process. Sending this message, you can go to testnet Ascalascan IO and then enter the transaction ash for that interaction. You can copy it from the metamask and then we just want to see what is happening and also during the process how it's moving from linear to optimism. So yeah, you can see, right, it gets tracked here, it's sent already and also gas paid successfully and it's waiting for finality.
01:03:54.500 - 01:04:30.900, Speaker B: So here is the thing, right. Crosschain transaction needs to be finalized on source chain before they can be settled. So this requires acceler to wait for an approver. And in this case you can also track the minutes that you need to wait for this to get finalized on the network before it will be approved and then executed on the destination chain. So, which is approximately 30 minutes. So yeah, we can't wait for 30 minutes, of course. But for now I already have like a sample that we can check out to see how this works.
01:04:30.900 - 01:05:08.400, Speaker B: Just give me a second. And what I need to do is just quickly update the environment variable here. Give me a second. Okay, so I'll be updating with this here and then this here. Okay, so now saving this and then going back to our application, this is still going on. And it says 28 minutes, 31 seconds. Keep counting down where you could keep track of what is happening.
01:05:08.400 - 01:05:50.072, Speaker B: And then if you come back to this application and then refresh this page because now I've changed the contract address to an address that already sent this transaction. This finality depends on different chain. Different chains has their own finality period. And then, so you don't need to wait for testimony for every chain. This is also determined by what is happening within the network, congestion and all of that. So now I can change to optimism so that we can read the message that we get sent that was sent earlier. Right? So remember that we haven't implemented the read functionality.
01:05:50.072 - 01:06:24.520, Speaker B: So let's do that quickly in our code base. So I would just go back to the index js we only implemented for write. So now let's time for us to implement, for us to read message from the blockchain. So what do we need to set up to make this happen? First we need to create a state variable that holds the value that we want to read from the blockchain here. In this case from optimism, which is where we send a message to. So let me just copy that here. And then now we're done with this.
01:06:24.520 - 01:07:08.468, Speaker B: Then we can proceed to create a very simple function to read that message. So we'll also be utilizing the hooks provided here for us to read message. And then you see that in the action. Okay, 1 second. All right. So what we're doing here basically is to create a provider using the etas and then connect to the optimism RPC URL we added earlier into our environment variable. And then we pass in the optimism contract address, the send message contract API, and also the provider that we created earlier on.
01:07:08.468 - 01:07:51.110, Speaker B: And then we created a function which is called readestination chain variables. Here we are reading the message on chain, and also we're reading the source chain to be sure where the source chain, that's the message we sent is coming from. And then we are setting the value here and setting the source chain here. So these are the things that we reuse in our front end to display the message here. But then after creating it, let's proceed to call this function when the component mouse, which is redesignation chain variables. Right. So now we can now update our UI to reflect these changes.
01:07:51.110 - 01:08:23.656, Speaker B: So what we need to do here is here we have created value earlier on, right here in the state variable. Let me scroll off so that we can see what I'm talking about. So we created this value. So I'm calling that value on the UI. I'm checking if it contains the value, it should return the source chain. The network here is optimism. These are just UI changes, has nothing to do with the contract.
01:08:23.656 - 01:08:52.652, Speaker B: And also you should display the message, if not, it should show waiting for response when we click save. Now, because we updated the contract address earlier on, we should see the changes here. So here we go. So you can see the response says linear from linear and also to optimism. And then hello from linear. This is the message we sent from the source chain to the destination chain. Hooray.
01:08:52.652 - 01:09:27.984, Speaker B: We have it, we retrieved it. And this is the similar process that you can follow for you to build your own full stack interchange decentralized application from the contract side, write the contract, compile the contract and then deploy it. Then come to the front end and connect to this contract. So don't worry about the steps in the project repository here. We already have each step for you to take to achieve this. All true when you are going through this on your own, so you can follow through to understand. So now let's go back to presentation.
01:09:27.984 - 01:09:41.992, Speaker B: There's one more thing I would like to show us before we end this, which is so, okay, hopefully I think you can see my screen here.
01:09:42.126 - 01:09:42.810, Speaker A: Yes.
01:09:43.260 - 01:11:02.748, Speaker B: All right, so now one last thing here want to do is to talk about the accelerate examples, right? It's very important because you can find tons of examples there, not just for sending messages, but also sending messages with token using core contract. Core contracts with token, you can see basic functionalities that you could do like sending token transfer, sending costume messages using call contracts, using core contracts with token and all of these things. And additionally you can find some advanced example. Also like for you to use an NFT linker, for you to use send arc function that allow you to send message and also send back an acknowledgment when the message is received right on the destination chain. So there are tons of things that you can play around with using this and also building your own project thinking through how you can make your project crushing project. It's easy to build interchange native Dao to honest leveraging the Axel ISDK and we don't just allow you to build and just build, just building alone. We also provide just four seven support on our discord server where you could join the developer channel and post your bug.
01:11:02.748 - 01:11:34.712, Speaker B: If you are facing any bug or you have question or you need clarity on anything, we're happy to help you. So thank you very much for your time. And you can stand this survey to give me feedback on what you think about the presentation and how the presentation has helped you learn something and also how the presentation will make you an utilizing stellar SDK to deploy on linear and then send a cross chain message to optimism. Thank you very much.
01:11:34.846 - 01:11:49.292, Speaker A: Wow. Thank you. That was so thorough. I have lots of questions actually. Okay, so a few things. Right. I think talking to you, this is around the first time I've heard the words interchange.
01:11:49.292 - 01:11:56.370, Speaker A: Can you differentiate that from like cross chain and multi chain for people out there who don't know the difference?
01:11:56.980 - 01:12:23.260, Speaker B: Yeah. So I think interchange and cross chain is similar. Kind of same thing. It's just we utilize interchange at the accelerate team to position ourselves kind of, but ideally behind the scene when you say interchange, also similar to what crosschain does. So you're just facilitating crosschain communications between chains.
01:12:24.080 - 01:12:43.010, Speaker A: Okay, cool. And then when you were talking about the finalization of, I guess, settling the information on the source chain. So like ethereum layer one, for example, does that mean for optimistic chains it's going to take seven days because that's how long they take to finalize, right?
01:12:45.540 - 01:13:25.004, Speaker B: Yes. So I think the finality time, it depends on the block height, right. So this varies from chain to chain. Right. But it depends on how one thing accelerates all about is for us to ensure that that particular transaction gets settled and finalized on chain before we can proceed to approve the transaction and then send it cross chain. So all of these things depend on the protocol itself and also how they are handling it. So I don't really know what happened behind the scene for optimism stake.
01:13:25.004 - 01:13:31.488, Speaker B: Right. But yeah, this is my understanding on how the caution works.
01:13:31.654 - 01:14:01.492, Speaker A: Okay, cool. Yeah. Because I was thinking with optimistic roll ups, the thing that I guess their drawback is like from l two to l one, at least like withdrawals of eth. For example, they have the seven days for fraud proofs before actually finalizing. So that's interesting. I mean, there's immediate liquidity pools that sometimes they leverage. So that might be how they might get around it with axilar.
01:14:01.492 - 01:14:20.080, Speaker A: I'm not sure I'd be curious. The other piece that I think is really interesting, I actually see a lot of examples of send message with just like strings. Right. Can you give me some examples of using send message in kind of a more real context kind of flowing?
01:14:20.580 - 01:14:51.928, Speaker B: Oh, yeah. So send message. This is just an example to introduce what it's all about. But during the presentation, I mentioned it's a payload, right? You can send a string, you can send integer, you can send array, and also you can send like a JC. So this all depends on you as a developer what you want to move from one protocol to the other. So you can encrypt all of this as a payload to that particular transaction call. So it depends on you, what you want to say.
01:14:51.928 - 01:15:24.660, Speaker B: So one very good example here is the core contract with token, right, where squid, I don't know if you heard about squid. Yeah, they help with swaps and all of this. So under the hood they utilize acceler to do all of this. So you can see this interaction in action and also doing all of these swaps from one asset to the other with a single click. And everything just happens super fast. So that's one use case. We have some other use cases like the one for junkyard NFT.
01:15:24.660 - 01:15:27.552, Speaker B: I don't know. Have you heard about junkyard NFT?
01:15:27.616 - 01:15:29.124, Speaker A: I'm not familiar with that project.
01:15:29.242 - 01:15:51.176, Speaker B: Oh yeah. So I know you have nfts. You have some nfts that you don't use. What? Less nfts? Right. There are some very still useful. Yeah. So what you do is to get all of those nfts that of no value, and you kind of dump them into ethereum, and then you fish a valuable one on polygon.
01:15:51.176 - 01:16:13.232, Speaker B: So that interaction between the Ethereum and polygon is facilitated by acceler network. So they allow you to do all of this so you can dump your worthless NFT and then get more valuable ones. So that's another use case for you to see what they are actually using under the hood. Is discussion messaging, know?
01:16:13.286 - 01:16:13.516, Speaker A: Yeah.
01:16:13.558 - 01:16:14.404, Speaker B: Demoed right now.
01:16:14.442 - 01:16:25.416, Speaker A: I guess a lot of things people usually pass are like contract addresses around as an example. Because I guess that's just a string, right?
01:16:25.598 - 01:16:28.504, Speaker B: Yeah. So that's why I said it's a payload, right?
01:16:28.542 - 01:16:28.744, Speaker A: Right.
01:16:28.782 - 01:17:03.350, Speaker B: It could be anything, basically, you know, string. So if you have like a use case for you to decode one thing and then encode one thing on the source chain and then decode it on destination chain, so you are free to pass it. So the good thing is that with the general message passing, you have the option to send message, which is anything. And we have the option to send message and token. Right. But if you want to do like native transfer, you can still utilize the send token for you to move only assets from one protocol to the other or make swaps and the like.
01:17:03.960 - 01:17:30.652, Speaker A: Okay, cool. I'm curious, because I've seen you at a few hackathons, if you have something really interesting that you wanted to highlight or project you've seen at a hackathon, because I'm curious, I feel like cross chain or really interesting interchange applications are a little bit more complex to build and I'm curious what people are achieving within two days.
01:17:30.706 - 01:19:01.796, Speaker B: Yeah, that's why we exist, right? That's why acceler exists. So we don't want you to go through the hassle of building, try to reinvent the wheel, provide SDK for you. So one of the projects I would like, which is like, I think they won a bounty from the recently completed Paris, I think they called themselves, I can't really remember the name, but something pay, what they do is they create merchant's wallet on safe. And then you as a user, if you enter any store and you want to pay, what you just need to do is to scan a QR code, right? So of course this solution exists on one chain. I think we've seen example of the likes of binance pay and some other ones, right? But yet what they were doing under the hood is to utilize acceler to facilitate cross chain. So even if you are paying, maybe you have asset on polygon or you have asset on linear and it that's the only thing you have, right? You can just scan it, they will deduct your native currency and then credit the merchant in any currency that he wants or he prefers, right? Because under the hood they receive the funds with any native that you're paying with anything native to your own currency. So either you are using polygon linear or you're using any other chain or you have assets somewhere.
01:19:01.796 - 01:19:41.060, Speaker B: You don't need to be restricted to use one protocol for you to be able to benefit from scanning and paying their QR code, which is like one very good real world use case that also make this process of payment seamless, and even the user does not need to think about, oh, but I'm not using this chain. How do I sign up? How do I do this? All they just do is to scan and they pay with their crypto wallet, and that's the only thing they know that's happening. But under the hood, acceler facilitates that kind of interaction to make sure that the merchant gets credited the amount he or she wants in our wallet.
01:19:41.640 - 01:20:09.280, Speaker A: So Axela is very good for, like, I think when we talk about Defi and multi chain and cross chain and everything, liquidity fragmentations, usually an issue, but I guess this kind of solution is what allows us to leverage multiple. Um, I am curious, though, does this also run into the issue of that finalization piece? Right, because sending the token would take some time if you're doing it between a bunch of chains.
01:20:10.020 - 01:20:19.200, Speaker B: Yes. The truth is that for a transaction on chain to be considered trustless.
01:20:19.280 - 01:20:20.310, Speaker A: Right. Yeah.
01:20:20.920 - 01:20:48.344, Speaker B: Speed is. You don't need to worry about speed if you really want to get. But another thing we provide is what we call the express token transfer. This is based off request. Right. So if you want to speed up the process, we can allow that to happen. But there are always things to check and balance to see why the need of doing aspects.
01:20:48.344 - 01:20:51.516, Speaker B: And also, why not just wait for this to happen.
01:20:51.618 - 01:20:52.270, Speaker A: Right.
01:20:53.520 - 01:21:07.772, Speaker B: So different protocols are also thinking on how to scale and make their finalization really fast. So I think over time, that will just work seamlessly. But there's protocols that so rigid, in fact, ethereum is also, like, you need to wait.
01:21:07.846 - 01:21:15.030, Speaker A: Absolutely. You can't do anything. Yeah, it's on the protocol side. That's 100%.
01:21:18.920 - 01:21:36.812, Speaker B: You just. Yeah, like, you just have to wait if you truly want it to happen on chain, unless you want something to happen off chain, which at the end of the day, you realize that, oh, now this is defeating the goal. Know, trustless, transparent, and all of those things.
01:21:36.946 - 01:21:49.010, Speaker A: Okay, cool. Makes sense. Wow, thank you so much. I learned so much today. This is really awesome. Are you going to be in New York for eth global? Or, like, is Axelar sponsoring? Do you know?
01:21:50.900 - 01:21:56.944, Speaker B: I don't know, but I think someone from the team should be there, maybe not me.
01:21:56.982 - 01:22:26.220, Speaker A: Okay, cool. Very awesome. So I'm excited to see. I know I've talked into a few linear teams that are using dapps on linear, that are using XLR. So very appreciative you guys are deployed so that other dapps can be enabled to build. But yeah, sure. If you have nothing else to add or if you have anything else you want to say, speak now or I'm going to end the stream.
01:22:27.520 - 01:23:14.110, Speaker B: Okay. Yeah, so, feels good, right? And also debugging live to see what happens. This is what we really try to go through during presentation or demo or trying to make things. Yeah. So I encourage everyone to check out what linear is doing and also how you can build and deploy linear and then at the same time check out what we're doing at Acceler to make it easy for you to facilitate crushing communications. And of course you want to extend the capability of your decentralized application to every, like all ecosystem, don't restrict yourself to one ecosystem. So with the acceler SDK, you could just tap in, connect it with a single click.
01:23:14.110 - 01:24:01.184, Speaker B: You can facilitate this transaction between the chains seamlessly. And don't forget on our discord we have the developer forum. We are always there to help you. And we also provide like on the accelerate examples, we provide tons of examples for you to start with because we know we understand what it means to get started building. So we provide all these examples for you to just quickly start and then try to play around with things even before you start building the reward solutions. Play around with things, see how acceler works, see how we're doing our cross chain interaction, and understand why the need of a completely decentralized system for you to be able to do this cross chain interaction.
01:24:01.312 - 01:24:02.668, Speaker A: Okay, cool.
01:24:02.754 - 01:24:03.756, Speaker B: Yeah, so thank you.
01:24:03.858 - 01:24:06.280, Speaker A: Thank you. Okay, I'm going to end the stream.
01:24:06.440 - 01:24:07.530, Speaker B: Three, two.
