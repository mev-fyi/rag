00:00:00.410 - 00:00:22.750, Speaker A: Live today. This is our very first workshop in a series of exploring, kind of the developer tooling that's going to enable people to build really cool dapps on linear. So I guess starting off with introductions, if you don't know me, I'm Emily. I'm the developer advocate for linear. I'm here today with Christophe from Himlico. Christophe, do you want to give yourself an introduction?
00:00:23.970 - 00:00:37.160, Speaker B: Yep, sounds good. In fact, why don't I start off with the presentation? And I tried to make the first slide or two. Just about giving a nice intro to me and to the project.
00:00:37.470 - 00:00:41.420, Speaker A: Definitely take it away. I'll let you control the show from now on.
00:00:42.110 - 00:00:54.240, Speaker B: My screen sounds good. All right, let me know if you guys can see my screen.
00:00:56.290 - 00:00:58.800, Speaker A: Okay. We can see it. Yes.
00:00:59.810 - 00:01:00.366, Speaker B: Awesome.
00:01:00.468 - 00:01:02.590, Speaker A: It's a little blurry.
00:01:03.090 - 00:01:04.590, Speaker B: A little blurry.
00:01:05.330 - 00:01:13.346, Speaker A: Yeah. Weird. This happens every time. We tested this, like, right before. Oh, there we go. That's good. We're good to go.
00:01:13.368 - 00:01:45.466, Speaker B: All right, let me know if it comes back. Yeah. So, yeah. Great to meet everyone and thank you for joining the call. This is what I was looking to make this sort of workshop about. I'm trying to keep it very low key, very casual in a way, showing off some code, just going over some basic explanations about account abstraction, about Pimlico, about some of the things we've built, about some of the things that you can build. So, yeah, as Emily started us off, quick introduction.
00:01:45.466 - 00:03:04.280, Speaker B: My name is Christoph. I am one of the co authors of the ERC four three seven proposal, which I don't think it's an unfair thing to say, is by far the most popular proposal to achieve account abstraction and the benefits of account abstraction on Ethereum and EVM chains like linear. I'm also the founder of Pimlico, and our mission really is to accelerate Ethereum's adoption of smart contract wallets, making Ethereum usable for the average person. So that's a bit about me and about Pimlico, I would say. Many people here, I'm sure, might have heard of the words account abstraction, right, but might actually not be super familiar with what it entails, practically speaking, and how it works under the hood. So I was thinking of just taking a few minutes to go over the basics. So what is account abstraction? I threw together a few images for you, which you might not understand too much of yet, but hopefully by the end of this slide, you'll get a better idea.
00:03:04.280 - 00:03:46.470, Speaker B: Account abstraction solves a fundamental limitation, if you can call it that Ethereum and EVM chains have, which is the way that their account system was designed from scratch. Right. The way accounts work on Ethereum is that there are two types of accounts. There are the private key controlled accounts, things like metamask, things like rainbow, where you associate one private key with one address. It's very simple. And the other one is the smart contract account. Now, the smart contract account is not controlled by a private key.
00:03:46.470 - 00:04:38.622, Speaker B: It is controlled by its code, with the code you deployed with. And it seems initially like a fair distribution. But the more you look into it, the more you realize that these private key owned accounts, they are very hard coded in how they work, right? So some of the hard coded things are the way you decide whether a transaction is correct is like, signed correctly or not. You have a single private key, which, if it signs the message, it's valid. If it doesn't, it's not, right? So there's no limited access you can get to your account. It's either all access or no access. And this is, for instance, not something that we typically expect from the financial tools that we have.
00:04:38.622 - 00:05:42.970, Speaker B: We expect to have limited access, which allows us to get things like fail safes in case we lose access to our keys. Other hard coded parts are things like the way gas fee payments work. So with these private key control accounts, you pay all the gas, the maximum possible gas that can be spent on the transaction at the start in ETH, and you get refunded the unused gas in ETH at the end of the transaction. And so these are some of the bigger things. And these pose quite a few limitations for end user experience, which I'll go over in a bit. But basically, what account abstraction is trying to do is it's trying to, as name suggests, abstract away the difference between these two accounts. Practically speaking, it's trying to give more power to ethereum accounts and make it so that we don't have these very arbitrary restrictions on the way our account system works on Ethereum.
00:05:42.970 - 00:06:44.426, Speaker B: So just a bit on what aa is, what we shorten account abstraction for, typically, what actually looks like. There have previously been proposals to achieve account abstraction on Ethereum. Many years ago, none of them really gained widespread adoption because they required a hard fork on Ethereum. They required the whole Ethereum core developer group to basically go through the EIP process. And that takes several years. Often the way this newest ERC, ERC 4437, tries to innovate on this is by really achieving all the benefits that a can abstraction gives without requiring any protocol level changes. So how does it actually work? Right with account abstraction, we get the benefits of smart contract vaults.
00:06:44.426 - 00:08:12.250, Speaker B: And instead of the smart contract vault having to define the whole flow of the transaction from scratch or rely on protocol level changes, we have the so called entry point smart contract, which we delegate the transaction flow management to. Right? So you might have your wallet contract if you see my mouse here, and you might have some intent that you want to do, say, like make a swap. So you create this special struct called a use operation, and you submit it to a bundler, a third party relayer to be included on chain and to go through your smart contract wallet and to execute what you wanted to execute on your behalf. So this is very technical, but basically what it means is that instead of making any changes to the protocol itself, we manage the entire transaction lifecycle via on chain smart contracts. But let's move forward into some of the sort of end user benefits that we get now. I think it's worth mentioning that the terms smart contract wallets and account abstraction tend to be quite interlinked, and sometimes, I have to say, muddled up. And I made that mistake myself too, occasionally.
00:08:12.250 - 00:09:49.170, Speaker B: So what do smart contract wallets often powered by the benefits we get from account abstraction? What do they actually give us that current accounts don't give us? Part of it is new ways of paying and managing gas fees. So with ERC four four seven, instead of you having to pay the gas in ETh for your transaction, you can actually delegate the gas repayment to third parties. Say like a DAP can sign up to sponsor transactions on your behalf. And that means you might not even need to pay any transaction fees to start using the DAP you want to do. Right? There's no need for that multi step onboarding process where you either bridge some funds to your world or you have to on ramp some funds using a third party onboarding service like Coinbase finance or ramp one of these services. So it can save a lot of steps for many users. You can also pay for gas fees in different ways that you're not typically used to, right? So the idea of paymasters, which is the ERC four from seven native way of managing gas fee payments, it allows you to pay gas fees in ERC 20 tokens, right? So you might have USDC on your account and you're a normal person, you don't want to have to swap around all the time for ETH.
00:09:49.170 - 00:11:03.440, Speaker B: So you can transact with ERC 457 and these new generation of smart contract wallets, you'd be able to pay all your transaction fees in ER, 70 tokens like USDC and this leads to a much smoother experience for end users. Now, a big thing I mentioned before is the way you're able to really decide how you authenticate into your account. As mentioned before, with private key accounts, it's a very straightforward process. If your private key signed the transaction, it's valid, if it did not, it's not valid. But it turns out people typically want different authentication mechanisms. Some big ones that have come about in the past few years are multisig schemes like from Gnosisafe, and things like social recovery schemes from companies like Argent. Just to give an example, social recovery schemes allow you to have one account that's designated as an sort of executor that can make many actions, that can do many actions on your account.
00:11:03.440 - 00:12:04.660, Speaker B: But for any admin actions, you have to get the approval of so called guardians that you select. Either that or you have to wait a certain time lock mechanism for that to elapse. Now, because you're able to code your smart contract world with custom evm code, anything you can think of you can really implement for your account mechanism. So another example is spending limits, the ability to say have two keys, one being an admin key and one being an everyday key. They both give you access to your account, but say that this everyday key, it only allows you to spend a maximum of 100 USDC per day. Anything above would require you to use your admin key. So you can imagine how this leads to a lot smoother experience, especially when you're trying to use crypto in the real world.
00:12:04.660 - 00:13:05.320, Speaker B: And the final thing I mentioned, there's many more. But the final big one I'll mention is a pain many of us experienced, I'm sure using ethereum, which is the lack of bashed transactions. When you use an app like uniswap compound anything, you often have to approve your tokens before you can spend them. And so because you're able to code from scratch how your account works, you're able to implement batching mechanisms so that the ability to batch multiple use operations, multiple intents into one end transaction. And so many, if not most companies building on AA have been implementing very user friendly ways to batch multiple transactions into one. One of my favorites recently has been fluvy. Definitely check them out.
00:13:05.320 - 00:14:27.690, Speaker B: So I mentioned a few of the end user benefits, but many of us are devs here. And so what does actually give for the wall developers? Previously, in order to make a wallet a smart contract world, you had to go through a lot of complexity and build a lot of separate systems from scratch to make it work. So for instance, you had to create the actual smart contract vault itself, but you also had to create modules that manage the flow of transactions verifying before executing. And you also had to create completely separate systems to actually relay transactions into users smart contract vaults. Now what this meant is that while creating smart contract wallets led to a way better user experience for the end user, it also meant it was significantly more difficult to create and to maintain for wallet developers. And I think that's part of the reason why we've seen so not enough momentum in the smart contract wallet space yet. A final part I'll mention is the entry point.
00:14:27.690 - 00:15:39.126, Speaker B: The entry point is a very special singleton smart contract, which manages the flow of these operations. It's a very complex smart contract, but the reason that's really great is that because it's so complex, it allows smart contract wallet implementations, building on top of it, to be relatively simple. Most of the complexity of these walls is outsourced to the entry point, which if you trust it's been audited several times, it's quite battle tested already. Then you're able to really simplify the process of making new walls. So let's actually quit out of this presentation for a second and go over what we're actually building. I've talked a little about the candlestraction. How does Pimlico fit in to this vision? What we're building is really a bunch of tooling that's going to allow these new generation of smart contract wallet developers to really speed up their process of building and maintaining these new wallets.
00:15:39.126 - 00:16:32.650, Speaker B: So to give an actual better example, by far the biggest focus for us right now is allowing wall developers to make use of these parts of ERC 457, like paymasters, like bundles that this ERC theoretically provides. So I'm just showing you here our docs. Right, this is docs. You can visit this on your site too. On your browser too. A few of the things that I'd like to showcase are one are bundles. So bundles, as mentioned before, are these off chain entities which take user operations that come from smart contract vaults and actually include them and relay them on chain.
00:16:32.650 - 00:17:52.834, Speaker B: So you'll see that we're live on actually lost count somewhere along the lines of 15 different chains. And this bundle is really crucial to build a smart contract world. Now just go a bit way it actually works under the hood is that we see user operations coming in from these users, and abundant maintains a special mempool that's able to store these user operations now over like every few seconds, it will take these operations it has in its mempool and bundle them into a single transaction, submitting it on chain. Now what I'd like to do actually is I'd love to show you off just for a few minutes, the entry point and how it actually works. I've talked a lot about it, but I think it's very beneficial to get a practical overview of how it actually functions. So what bundles do is that they call the handle ops function when they want to bundle use operations. Can you zoom in a bit, as you can see? Oh yes, that's a good idea.
00:17:53.032 - 00:17:54.100, Speaker A: Thank you.
00:17:55.850 - 00:19:15.760, Speaker B: As you can see, it takes in an array of use operations and does not really return anything. But you also give it a beneficiary address which actually takes and receives any fees that are made in the process of bundling. So you see, what happens in the entry point is that we loop through all these operations and we validate each of them. We make sure that in the process of validation they actually pay the bundle enough money in order to compensate them for the onchain cost of including these user operations. Practically what this means is that bundles kind of function like MeV searches in the way that they make a slight profit on every single user operation that is included. Now, after all these operations have been validated, we again loop through every single user operation and we execute the custom call data that each user operation provides. Right? So this might be whatever you want to do on chain swap, transfer, borrow, lend, use this on chain game, anything like that.
00:19:15.760 - 00:20:17.970, Speaker B: And then finally the bundle gets paid, as we mentioned before. So what actually happens during validation? That's a great question. So if you go back a bit, I can give you an example of a very, very simple account, often called the base account, right? So during validation what actually happens is that the validate user op function of the smart contract vault gets called. And this really should do just a couple of things. So first one is it checks, it comes from the entry point, right? Because the entry point is trusted to only take payment if it actually executes the user operation afterwards. It means we must limit calls to come from the entry point. Then it does the custom signature validation that the smart contract world implements.
00:20:17.970 - 00:21:24.230, Speaker B: So this might be something like ECDSA that we have for private key accounts. It might be some multi Sig scheme or social recovery scheme, know, different account permission scheme, anything you can imagine that you can code in solidity. And finally, is it validates any sort of nons or any other conditions that you wish to do. And then as a last step, it pays the entry point and in effect, the bundle for actually putting these operations on chain. Now, this is how the bundle works, right? And so something else that we've built we're very proud of is our verifying Paymaster. So, erc four three seven allows you to obviously define your own smart contract wallet, but also allows you to put inside your user operations so called paymasters. And these paymasters are quite simple in nature.
00:21:24.230 - 00:22:09.330, Speaker B: What they allow you to do is to decide as a paymaster whether you want to sponsor the gas fees for a user operation or. And so this can be very simple. It can also be very complicated. An example of a verifying that we've built is our verifying Paymaster. So this is very simple. You'd sign up to Pimlico and you'd deposit some funds off chain with us. And anytime you'd want to have an on chain user operation sponsored, you'd simply ask us through our API to sponsor this user operation on your behalf on chain.
00:22:09.330 - 00:22:51.186, Speaker B: And in exchange, we deduct some of your off chain balance that you have with us. Right. So what this means is you're able to provide for your end users a very smooth experience when using your wallet. No need to worry about onboarding about on ramping any of these things. And you also don't have to worry about maintaining your own paymasters for this. So that would include deploying your own paymaster contracts, maintaining them with enough eth having to go through the trouble of on ramping the actual native tokens that are used for sponsorship. We'd really handle all that for you.
00:22:51.186 - 00:23:48.680, Speaker B: And we've seen many, many worlds really benefit from that, which is amazing. Our second type of paymaster that we have that we're very proud of is our ERC 20 paymaster. So with this paymaster, we give you a very straightforward way to. If I can show you the contract. Yeah, we give you a very straightforward way to pay for user operations with ERC 20 tokens. So the way it works is that the standard function that's called on paymast to ask them to check if they want to sponsor these operations. Is this validate paymast user op? And this, what it will do is it will literally just take the maximum amount of tokens that this user operation can possibly spend.
00:23:48.680 - 00:24:58.198, Speaker B: And afterwards it says, yes, I've taken these tokens, now I'm willing to sponsor this user operation. And finally, after the execution is done, it actually measures how many tokens have really been used and what it does is it refunds the difference between the amount of tokens used and the amount initially taken. So we've seen people building demos on top of this. And so the part of the reason we're really proud of our ERC 20 paymaster implementation is that it's the very first fully audited and fully permissionless ERC 20 paymaster. So this means there's no need to go through our API, there's no need to sign up to public or anything. It's all on chain. And we've also provided a very nice EOS master SDK which you can use if your project is written in typescript.
00:24:58.198 - 00:25:50.830, Speaker B: And so this gives you a very nice interface to actually do all the things you'd want to typically do with Paymasters, which are essentially my paymaster. Right. So these are some of the things that we're building. Right. So bundles paymasters, two very big parts of the smart contract world stack, allowing these world developers to outsource a lot of the work that goes into making a world like this. Now, what I'd like to do is actually showcase a demo of how you can restart leveraging Pimlico. And again, we all know how live demos work, but I'm still going to give it a shot.
00:25:50.830 - 00:26:45.482, Speaker B: So this is a Pimlico example, GitHub repo that we've spun up. And this really goes through the flow of deploying a wallet and actually making deploying a smart contract wallet and making a simple transfer with that smart contract would leverage that. This actually leverages Pimlico's paymaster verified paymaster and also leverages our bonder. So it kind of shows you how much we've tried know smooth out the process of building your smart contract vault. So just a quick overview of the repo, you'll see we have two main files. We have the run op file, which provides a ton of scripts.
00:26:45.626 - 00:26:51.390, Speaker A: Oh, are you sharing code right now? I feel like you're still on your slides.
00:26:52.450 - 00:26:53.262, Speaker B: Oh, am I?
00:26:53.316 - 00:26:59.780, Speaker A: Yeah. Did you click like share screen? One screen only.
00:27:01.430 - 00:27:17.896, Speaker B: I'm. Let me, let me try and figure this out. Let me try and share again. Can you see it now?
00:27:17.998 - 00:27:30.008, Speaker A: Okay, we are on the restream screen. So like the backstage? Yes. Okay. Now I can see your code, but now it's super blurry.
00:27:30.184 - 00:27:33.008, Speaker B: This is a vs. Code, right? You can see vs. Code?
00:27:33.094 - 00:27:33.730, Speaker A: Yeah.
00:27:36.180 - 00:27:42.050, Speaker B: Can you read this type?
00:27:42.820 - 00:27:45.110, Speaker A: It is. Can you zoom in a bit?
00:27:46.440 - 00:27:57.672, Speaker B: Yes, it. Let me try. Share again.
00:27:57.806 - 00:27:58.490, Speaker A: Okay.
00:28:00.540 - 00:28:07.930, Speaker B: Apologies. Let's see. How about now?
00:28:10.400 - 00:28:12.430, Speaker A: Yeah, we are on vs. Code.
00:28:13.760 - 00:29:01.470, Speaker B: Fantastic. Now, my biggest fear is that I put a private key somewhere where I didn't, where I should not have, but let's hope it goes well. So there's two main files to pay attention to. One is the hard hat config file, and the other is the run up file. The task we care about the most is the test paymaster flow. So the way this flow works is I'll just walk you through it on a high level first, and then I'll show you this more in depth code. So what it does is it takes in a private key and the corresponding address.
00:29:01.470 - 00:30:07.730, Speaker B: And this private key represents the owner of the smart contract world we are going to deploy. So what we do is we take the smart contract world implementation we're going to be deploying, and we determine whether it was already deployed or not based on a deterministic address. The actual deployed smart contract wallet address is represented by the sender variable. Now, if we see that the sender is not deployed, we also generate the required init code that we will put into the use operation to deploy it. Otherwise, that's not required. What we do then is we fill up all the other use operation variables that we will need. So as we mentioned before, we have the sender and the init code, but we also have the actual call data.
00:30:07.730 - 00:31:00.508, Speaker B: So we're actually going to do with this user operation. And for the time being, we just make a zero way transfer. So it's quite simple. Next, we have these operations created. What we need to do is we need to sign it, right? So we get the signer, we get the signer and we request the Paymaster data from the Pemlico paymaster. So just to go over what we're actually doing, we have these operation and we don't want to pay for it, right? We were like, okay, we don't want to make the user onboard gas fees. We want to sign up to Pimlico, put some balance on Pimlico, and then have it be sponsored by Pimlico.
00:31:00.508 - 00:32:16.520, Speaker B: And then we can actually eventually pay off chain for that hassle. The way it works is that you would request this PM sponsors operation JSON RPC request specifying these operation and the entry point, and it would simply return to you the signature that you would have to put into the Paymaster and data field of the user operation. And finally, after we have the Paymaster data, we're actually going to sign the user operation with our owner's signature that we previously generated. And then we take the Pimlico bundle URL and we send the user operation to it so that the bundle actually includes it on chain. And finally we just query for receipts. So this is the actual flow about how it works on a higher level. And so this really showcases that while yes, it is slightly more complicated to create and manage smart contract wallets than it is to manage pure private key wallets.
00:32:16.520 - 00:32:58.650, Speaker B: By using third party services like Pemlico, you can really take a lot of things off your. And so it really simplifies the flow in the. Let's actually do this. I have got to. Okay, let me, let me just stop sharing for a second. Awesome. Okay, let's go back it.
00:32:58.650 - 00:33:58.890, Speaker B: Fantastic. So we're going to do is we're going to call the hot hat task, we're going to specify the owner address, and we're going to specify the network that we're going to deploy our smart contract world on. And you'll see that we have this n example which shows you what things you need to fill out for this to work. So you need a pemlico API key which you can get from us. You need an inferior key for RPC requests. And you need to specify the mnemonic or the private key that corresponds to the account that's shown by the owner. And that would be inside of mnemonic txt if you have these things.
00:33:58.890 - 00:34:14.270, Speaker B: Let's hope this works. We specify the network. Let's do. What network should we do? Well, let's do the Naya test then.
00:34:16.100 - 00:34:17.650, Speaker A: You picked the right one.
00:34:28.060 - 00:34:51.356, Speaker B: I'll explain everything. What happened? Perfect. Live demo worked. I'm so happy. Amazing. So what do we do here? Let's just go over it. We created a user operation.
00:34:51.356 - 00:35:24.396, Speaker B: This is completely unsigned. We found the sender address and we figured out that the init code and that the actual wall did not exist yet. So we need to deploy it with the init code. We specify the call data we actually call, and we put some other parameters like the gas variables and the nods that we're going to use. Then we ask Pimlico to sponsor this use operation. And so we basically sign over the use operation. We deduct some balance from you.
00:35:24.396 - 00:35:48.176, Speaker B: I put some balance on my API key previously. Okay, we get it back and we put this on the Paymaster and data field. Right. Then we actually sign it with our own private key. And then we submit this user operation to our bundler, which is live on Linnaeya. Perfect. It gives us back the user operation hash.
00:35:48.176 - 00:36:29.212, Speaker B: And then every few seconds we query the receipt to make sure it actually, to figure out when it actually gets included on chain and so now it returns us the receipt, which is perfect. So let's take a look. Let's take a look what actually happened. We have the operation hash. To query it, let's transaction hash. We're going to go to our browser. We're going to go to Lineascan, put the transaction hash into linear scan.
00:36:29.212 - 00:36:32.576, Speaker B: Oh, hello. And you will see.
00:36:32.678 - 00:36:34.770, Speaker A: Okay, cool. We're still on vs. Code.
00:36:35.480 - 00:36:44.260, Speaker B: Oh, no. Let's try this again. All right, are we back?
00:36:44.410 - 00:36:45.830, Speaker A: Yes, we're back.
00:36:47.080 - 00:37:42.916, Speaker B: We're so back. I just put the transaction hash that I took before, and you will see that it's been successfully included on chain. If we go to the logs, this contract actually on the name is not verified, which we should verify it. I'll do it after the workshop. But you'll see that two minutes ago, our bundler, which is represented by this address called the handle ops method, which has this Abi encoding on the entry point, which is the zero x five ff contract. And so if you actually went to the event, if it was verified, you could see all the information about the user operation that was included. But you can also see that I have to share again, you can also see that in vs.
00:37:42.916 - 00:38:34.500, Speaker B: Code, right? So you can see here the block number from tube, how much gas was actually used. You can see if it was successful or not. Right. That's very important. And you should be able to see the Paymaster, I believe. Anyways, I must be missing it somewhere. But if you check the paymaster address, you'd also see how the Pimlicos paymaster actually sponsored all the gas fees for this deployment.
00:38:34.500 - 00:39:04.770, Speaker B: And you'll have noticed that the address we used, it never had any balance. Right. I mean, we can check this right now. This is the signer that I used. There's absolutely zero balance in any of it. Let's go back again to sharing my other screen. All the gas fees were sponsored by the Paymaster, which I think is really amazing.
00:39:04.770 - 00:40:34.912, Speaker B: So that was an example flow of how you might go about using our paymasters and bundlers to deploy a smart contract world and to use a smart contract world on linea, which I think is amazing. So there's a lot of things you can actually build with Pimico and with account abstraction in general. Now, naturally, the thing that really stands out the most when it comes to Pilmico is building a wallet. So the ability to leverage our bundles and paymasters to create a very simple wallet implementation for yourself and to re outsource all these adjacent tasks to us, we've seen many people build really cool world implementations in hackathons and we'd love to definitely see more. Some of the things which are really cool are user operation explorers. So going back and taking these events and these user operations that are bundled to the entry point address and getting useful information out of them, analyzing which payments are used, how much they sponsor, how much balance they have, which wallets consume the most gas, all these things. That's definitely very in demand and kind of abstraction space.
00:40:34.912 - 00:42:34.012, Speaker B: Right now, some other things are developing new types of paymasters, right? That's very interesting. So for instance, ZK paymasters, this would allow you, for instance, to trustlessly withdraw from things like tornado cash or similar applications, but also the ability to pay with any mechanism you can think of for transaction fees, right? So previously we had a hackathon project which created a Paymaster that paid for your transaction fees if you had a pass or like a token, right? So imagine you did a linear quest, for instance, and by doing a linear quest you were airdropped or one linear Paymaster token. And so you could use, say that token for five different use operations you make on chain. And if you put the paymaster address as your paymaster, as designated paymaster, it would check you have a token, it would take one from you, it would sponsor these operation on your behalf. There's so many things you can do and I think that the counter structure space is very new still. One which I definitely love to show off is Patchwald, actually. So Patchwald, there's a quest going on where they've deployed on air and Patchwall allows you to really shows off an amazing ux that you can get by leveraging account abstraction, right? So for instance, it allows you to sign in with your Twitter account, right? And I see my Twitter account and it automatically generates a wallet for you.
00:42:34.012 - 00:43:02.040, Speaker B: No need to manage private keys, no need to manage any seed phrases. So what I would do is I just click start. For instance, I'm already logged in. You'd have to log in if you didn't do this before. And I'd select an MFT to mint. And let's do milady. I would mint this NFT and just waiting, just waiting.
00:43:02.040 - 00:43:09.970, Speaker B: Let's see.
00:43:19.750 - 00:43:30.966, Speaker A: Your other live demo. Perfect. So this one had to, I imagine it's probably a little slow right now because of all the linear voyages going on right now. Yeah, oh yeah.
00:43:30.988 - 00:44:06.260, Speaker B: No worries. Anyways, I've done this before. It's worth every single time. Basically you can generate an NFT and you can send it to someone. It's all powered by smart contract wallets under the hood. I definitely recommend checking out Patchwallet Linnea patchwall.com yeah, I feel like there's so many more things it'd be cool to show off, but I think this gives a really good introduction to what account abstraction is what ERC four four seven is.
00:44:06.260 - 00:44:41.534, Speaker B: How Pimlico is trying to accelerate the adoption of ERC four four seven and smart contract wallets. Some of the end user benefits that we can get if we really adopt this new paradigm of accounts. And of course, some of the example things that you can do as a developer and as an end user when you use Pivaco and when you use smart contract wallets. Thank you so much. It's been a pleasure. I'd love to take any questions to this time.
00:44:41.572 - 00:44:51.150, Speaker A: Yeah, so there is one question here. Any thoughts on b two b wallets and possible approaches to integrating such wallets for clients?
00:44:54.530 - 00:45:19.530, Speaker B: Any thoughts on b two b wallets and possible integrating such wallets for clients correctly? So when you say b two b wallets, do you mean like wallets for enterprises? So say like a replacement of fireblocks? Is that what you're referring to? I'm not sure what exactly mean by b two b in this specific instance.
00:45:20.990 - 00:45:23.050, Speaker A: He asked us quite a while ago.
00:45:23.120 - 00:46:18.830, Speaker B: So I don't know if online integrating such walls with clients. I would say if it's a b two b, I'm assuming that's what you mean. Crypt if I'm wrong. In that case, I would say integration is very similar to if it was an EOA, if it was a private key account, partly because the flow of actually getting your wallet set up and transferring funds is much the same, except for the fact that you can actually save them many steps of having to go through these random hoops of onboarding ETH, as well as what they're already onboarding. So I think it makes enterprise integrations easier as well, and also more safe because you're able to leverage on chain multisig schemes, so you're able to provide that enterprise level safety that many of them desire.
00:46:19.890 - 00:46:42.450, Speaker A: Okay, cool. Here's another question, let me see. How do you implement so this is from Golzar Ali. I'm not entirely sure what he meant by this, but how do you implement the key on the smart contract?
00:46:42.610 - 00:47:18.930, Speaker B: Yeah, right. So if you're referring to the example implementation, just 1 second, I'm going to pull something up. The example that we deployed with this pinnacle example flow, as well as the example walt I showed for the validate use operation. It uses a very, very naive, simple key management system. Right. So the way it works is. I'm just sharing.
00:47:18.930 - 00:47:56.978, Speaker B: Here we go. Awesome. Let's see. Yeah, perfect. So, the way it works is that it still uses an ECDSA signature like normal private keys do, but it just basically encapsulates that into a smart contract. You can use this for production if you wish, but this is just the simplest example of a well functioning smart contract wallet that you can give. So, you see, the key would be private key whose owner is stored on chain.
00:47:56.978 - 00:48:30.470, Speaker B: And so when you check for only owner, you would just check that the sender of the message is the owner, or that if you check the signature, you check that the owner has signed the hash of the user operation. So this is how you'd manage the key for this specific smart contract vault instance. But again, you can choose any implementation you wish that you can code in. In solidity. There's really no limit to the creativity you can employ for creating these new generation of accounts.
00:48:31.930 - 00:48:47.920, Speaker A: Okay, cool. And I think there's probably one last question. Here we go. Oh, this is my very good friend from Goplus security. But what do you think about the importance of security and risk assessment in user experience?
00:48:49.970 - 00:49:27.766, Speaker B: Security and risk assessment in user. That's quite a broad question, I would say, if I had to tackle a part of it. Security and risk assessment. Honestly, this is a personal view. This is not, like, not a fact whatsoever. I think the biggest hurdle for many walls to jump through is not really the technical problems that they have to solve. It's not often not even the end user ux.
00:49:27.766 - 00:50:29.870, Speaker B: It's really that trust that they accrue. So I think part of the reason metamask has been so successful and is so successful, despite a lot of walls trying to innovate very fast in the space, is that metamask has a lot of trust behind it. Many people trust a lot of their life savings inside metamask, it's been battle tested like no other world ever. And so I think that's a really underlooked, really overlooked part of how people decide to use Walt. So any new Walt that really wants to take the limelight away from metamask is going to have to not only build a better user experience, but make it so good that it overshadows the trust. These really big and really old wall, really long time walls like metamask have accrued.
00:50:31.330 - 00:50:45.010, Speaker A: Okay, cool. We actually have another question that came in. Cool. When Pimlico offers verifying Paymaster and ERC 20 payment services. Curious about the fees that Timlico charges.
00:50:48.150 - 00:51:35.742, Speaker B: Awesome. Yeah. So specifically verifying Paymaster and ERC 20 paymaster. So the ERC 20 paymaster is completely on chain and that means there's no sort of back end, no off chain charge that we make. If I can show off the contract, any and all charges that we make are completely transparent. If I show you the smart contract, you will see that we have a price markup, right? So when you translate the price, because we have to actually sponsor with native tokens like ETH while taking money, taking the fees in ERC 20. So we apply a price markup on the ERC 20 that we charge.
00:51:35.742 - 00:52:31.442, Speaker B: And so this price markup by default is 10%. And so what this does is it compensates us for a few things. It compensates us for the exchange rate risk that we incur when we swap the tokens back to native tokens so that the paymaster can keep sponsoring it compensates us for the slippage risk. By actually making the swap, we change the price. And finally, because of our permissionless nature we actually are not able to get the oracle price during the validation phase of these operation and we have to get it afterwards. And so if there is not enough usage at any given point in time, someone, and that can be us, that can be someone else, has to come in and actually update the price manually. Right.
00:52:31.442 - 00:53:11.520, Speaker B: This isn't always the case, but only if there's like this little usage at any given time. And so for actually coming in and maintaining that infrastructure, that's also part of the reason we have this price mockup. So you see it's just 10% for that. This is all on chain for the verifying Paymaster. We try and do a volume based pricing, right? So any gas that you sponsor through us would take a small percentage on top of the gas price being sponsored as a fee. And that's basically our model.
00:53:13.170 - 00:53:25.640, Speaker A: Okay, cool. I don't think we have any more questions. Can you send us the link for your GitHub? Is that the demo? Is that public?
00:53:27.930 - 00:53:30.790, Speaker B: I will upload it right after the presentation if that works.
00:53:30.860 - 00:53:39.500, Speaker A: Okay, yeah. Awesome. Oh, I guess like one last call to action. How do we get in contact with Pimlico? You learn more.
00:53:41.390 - 00:53:58.418, Speaker B: Totally. So feel free to reach out to me on. I'm going to share my screen again so many times, why not once more? Let's see, how does it work? Can you see my screen?
00:53:58.504 - 00:53:59.460, Speaker A: I can.
00:54:04.230 - 00:54:28.250, Speaker B: So you can reach out to me on Twitter. Either my personal Twitter or pass better ideas. Is our Pimlico Twitter. So pimlico HQ Twitter. Same for our telegram. We have a telegram channel where you can reach out. Again, it's just Pimlico HQ.
00:54:28.250 - 00:55:15.350, Speaker B: You can visit our website, pimlico IO and you'll find some more information there. You can go to docs Pimlico IO and you'll find a bunch of information know getting started. And actually we give you a very nice example flow that we take you through, which people have liked so far. We give you an example flow for the ERc 20 paymaster, some faqs, of course, and of course, all the references for all the endpoints for our paymasters. Introduction to account abstraction, ERc 20 Paymaster information bundle information, all these things. And if you'd like an API key again, feel free to reach out to us. Currently we're in private beta.
00:55:15.350 - 00:55:18.380, Speaker B: We're opening up to public beta very soon.
00:55:19.150 - 00:55:42.606, Speaker A: Yes, which is a good point. Fun things to note, linear will be at East Global Waterloo this weekend. So I'm really excited. I hope people, I guess, build with Pimlico. The other piece is, I believe one of the Pimlico employees started this little group here, the Lineans group. I know. I think I was speaking with him recently.
00:55:42.606 - 00:56:12.380, Speaker A: He was specifically looking know creating a community building, like focusing on smart wallets and account abstraction on linea. So if you guys are curious, dm that group, let's start a revolution. But anyways, thank you so much. Kristoff. This was actually really informative. Super exciting to hear, like get the whole overview, I guess. There was one last question that says, was patch wallet implemented with Pimlico? I think the answer is yes.
00:56:12.380 - 00:56:23.690, Speaker A: Right. Okay. Unless you have anything else you want to share, I think we can hop off and I will be waiting for your demo upload afterwards.
00:56:24.750 - 00:56:27.826, Speaker B: Sounds amazing. Thank you everyone for listening and. Ah, yeah.
00:56:27.848 - 00:56:28.034, Speaker A: Okay.
00:56:28.072 - 00:56:30.160, Speaker B: Thank you. There's any questions? Okay.
