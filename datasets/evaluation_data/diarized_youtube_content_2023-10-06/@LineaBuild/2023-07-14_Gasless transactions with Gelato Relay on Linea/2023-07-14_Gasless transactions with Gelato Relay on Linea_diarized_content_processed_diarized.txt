00:00:02.410 - 00:00:10.990, Speaker A: Okay. Okay. Very cool. So this is developer workshop. I can't count. We've been doing too many. So, yeah.
00:00:10.990 - 00:00:35.414, Speaker A: Hi, Emily here, developer advocate for Linea. For those of you who don't know, we've been running dev workshops for the past. Again, I can't count. So many weeks. Basically to empower the builders in the linear the system, as well as help our current virtual hackathon participants that are happening right now with consensus. So that's not a virtual hackathon. You can find that online.
00:00:35.414 - 00:00:46.118, Speaker A: But anyways, that's a really brief introduction. What you guys actually care about today is our wonderful guest, Ben from Gelato. Ben, do you want to give us an introduction?
00:00:46.294 - 00:01:05.470, Speaker B: Yeah. So first of all, thank you for having me, and thanks everyone for tuning in. So my name is Ben, and I do developer relations at Gelato, which among other things involves exploring exciting use cases and also helping projects integrate gelato services. And this workshop is about one of those services, which is gelato relay.
00:01:05.630 - 00:01:36.166, Speaker A: Yeah, yeah, I'm very excited. I think Hilmar came on our community call in. What are the months? Two months ago? Last month, I think it was two months ago, specifically talking a little bit about gelato relay. It's really cool project. I am super excited about it. I'm glad that you get to kind of dive in deeper and show our devs how to use it. So let's start from the very basics, like what is gelato relay?
00:01:36.358 - 00:01:56.926, Speaker B: Yeah. So gelato relay, in a nutshell, is a decentralized network of relayers, which allows users to submit transactions and have them executed on their behalf. And this enables a truly gasless experience where the user is not required to cover the gas cost upfront using native tokens. And that opens up the door to a huge number of possibilities.
00:01:57.118 - 00:02:15.880, Speaker A: Okay, cool. Let's actually dial into that a bit, because we have an audience of all variations of kind of, I guess, developer background. So you kind of just started off with gelato is a network of relayers, but for those of us who are new, what is a relayer even?
00:02:16.250 - 00:02:30.780, Speaker B: Right, so a relayer is someone who puts a transaction on chain on somebody else's behalf. So in this case, the relayer would execute the transaction and incur the gas cost. Meanwhile, the user is not executing the transaction and subsequently also not incurring the gas cost.
00:02:31.230 - 00:02:41.214, Speaker A: Okay, cool. I guess basically dive into maybe how it works. I think you mentioned you have slides to kind of give us a better.
00:02:41.412 - 00:02:50.226, Speaker B: Yeah, exactly. Okay, I'll share the slides now. Can you see this all right?
00:02:50.328 - 00:02:50.980, Speaker A: Yes.
00:02:51.830 - 00:03:16.538, Speaker B: Okay. Perfect. So the way we'll start is by I'll first introduce the four different types of relay transactions. And this might seem like a lot, but they're all very similar. So beginning with sponsored call, it is a relay transaction, like I mentioned earlier, and it's paid for using one balance. So now you're wondering what one balance is. Onebalance is our multi chain payment solution for all of our services.
00:03:16.538 - 00:03:46.020, Speaker B: So not just gelato relay, but also others. And it unifies a user's balance. So there's no need to bridge tokens to different networks and no need to, for example, top up individual balances. Then we have call with sync fee, and we can dissect the name a bit here. So it's a normal relay call, but sync fee stands for synchronous fee payment. So in this case, the transaction pays for itself rather than being sponsored using one balance. And this opens up some really cool use cases, one of which I'll mention later.
00:03:46.020 - 00:04:32.382, Speaker B: And then before moving on to the next two, it's important to remember that relay transactions or metatransactions, are executed by a relayer and not actually by the user. And the implication here is that the contracts using message sender will get the address of the relayer rather than the actual user. So the problem here is we can't, for example, mint an NFT to a user if we don't know who the user is. So one solution you might think of initially is if we just pass, for example, the user address as an argument to the mint function. But the issue here is that anyone can now impersonate any arbitrary user by just passing an arbitrary user as an argument. So how do we really address this problem? And the answer is by using cryptographic signatures, which can be signed off chain. So still no gas is required.
00:04:32.382 - 00:05:09.886, Speaker B: And contracts on chain can then verify these signatures and recover the original signer. And by doing all of this, we preserve this notion of a message sender and we don't sacrifice security. And this standard is called ERC two seven one for anyone who wants to sort of dig into it further. And it's the secure protocol for native metatransactions. And I'll show a little flow diagram on the next slide, just to clear up any confusion. But with that out of the way, we have sponsored call ERC 2771, which is the same as sponsored call up here, just that the user is now signing an additional signature. And the same goes for call with sync fee ERC 2771.
00:05:09.886 - 00:05:46.490, Speaker B: It's a self paying transaction, but the user is signing the transaction off chain. So for the flow, this is a demonstration of a sponsored call, ERC 2771. So again, the transaction is paid for using one balance and the transaction is assigned off chain. Since we're using ERC two seven one, there's an important separation here, which is the difference between the off chain world. So all of the stuff on the left happens off chain, and the on chain world. So this all happens on chain. So for example, we have a wallet which has no ethereum or no native tokens, so it's not able to transact on the network.
00:05:46.490 - 00:06:18.040, Speaker B: But what we can do is we can build a mint transaction. We can build this locally, and then we can have the wallet use its private key to sign this transaction. We then send this transaction to Gelato's backend using the relay SDK. It makes it super simple. And then one of Gelato's decentralized executors will then put the transaction on chain. So here we move from the off chain world to the on chain world. And the executor doesn't actually call the NFT contract directly, but rather it calls this relayer first.
00:06:18.040 - 00:06:55.230, Speaker B: And in ERC two seven one, the contracts verifying the signature are called trusted forwarders. Trusted because they are trusted by the recipient contract, which in this case is the NFT contract, and forwarders because they verify the signature and they also extract the original signer and then forward all of that to the NFT contract. So once we've extracted the original signer, which is the wallet here, and the NFT contract has all this data now. So it has the original transaction. It also knows who signed the transaction itself. And now it can mint the NFT to the user's. And, yeah, that's pretty much it for the flow.
00:06:56.370 - 00:07:16.486, Speaker A: Okay, very cool. I realized I should have flipped this a little bit. I mean, this is super interesting, but actually, let's take a step back. We started at a high level of what is gelato relay. We kind of know how it works. Why should we use them? Right? Why should we use it?
00:07:16.668 - 00:07:45.730, Speaker B: Right. So the idea, or the end goal is to improve user experience. So gas's transactions can, for example, allow user to transact and sort of get started with, for example, the blockchain for the first time without requiring native tokens, which can be a hassle to acquire. So if we're talking about a game, for example, the user can have his transaction sponsored for him and he can start participating in the game, for example. But he doesn't need to, for example, go through an exchange, get Kyc'd, and then get native tokens into his wallet.
00:07:46.230 - 00:08:01.240, Speaker A: Okay, so I guess to dial in on that too, gas is still required as part of the whole transaction lifecycle goal. But that burden then is taken on by the actual developer of the DaP, for example.
00:08:01.770 - 00:08:19.740, Speaker B: Exactly. And that gives us more freedom for how to handle the payments. So we could either have the payment completely sponsored, maybe an NFT project wants to sponsor all the mints for the NFT, or we can have the transaction self paying. So rather than paying in, for example, native tokens like Ethereum, we can pay using USDC or other.
00:08:20.350 - 00:09:02.790, Speaker A: Okay, yeah, yeah, that makes a lot of. So gelato is here to improve ux. I think we've talked a lot about, or let me backtrack. So when we talk about linear, right, or scaling and how it improves ux, we're talking about reducing gas costs, speeding up transaction times gelato relay feeds into that even more where it's like the user themselves don't even see the gas costs. I talked to Hilmar a little about this, but where does it fit in with transaction times gelato? How do they, I guess, make that more efficient? Is that something the DAP developer needs to think more about separately from gelato solutions for improving along those lines?
00:09:03.530 - 00:09:23.198, Speaker B: Yep. So all of this, the idea is it's meant to be abstracted away so the developers can really focus on developing rather than for example, implementing their own solutions. And in terms of speed, the backend is very optimized, it is decentralized, so it scales very well. And yeah, we've had pretty positive feedback regarding the transaction times themselves.
00:09:23.364 - 00:09:45.382, Speaker A: Yeah, okay. Yeah, very cool. So I think things that we are also dialing into as well. I keep using dialing, I need to come up with a new vocabulary word, but I guess for our devs out there using gelato relay, it's really powerful. With regards to. You guys are optimizing speed already. Gas is covered, so users don't see that.
00:09:45.382 - 00:10:34.198, Speaker A: I think Hilmar mentioned something about lens using gelato. And when you build your dapps, right, it's more of like a forward thinking type of experience. So I guess the UI represents what's going to happen. It's like, I guess optimistically saying this is your new state, so there's no degradation in the user experience. While Gelletto is handling the actual transaction finalization in the background, obviously with a lot of speed, but probably, I guess the UX or the actual interface that people are interacting with will optimistically handle that as well. So tidbit for those of you developing using gelato and then integrating that into like a front end or something. But yeah, very cool.
00:10:34.198 - 00:10:49.980, Speaker A: So this is all about user experience. Let's actually talk about some use cases. Right, so gelato relay out in the wild, if people are interacting, what are some examples that kind of hid in the background? It's like you've been using gelato all this time.
00:10:51.070 - 00:11:27.458, Speaker B: Yeah, I have a few examples of people using gelato live. I could also showcase a little example, sort of like a very simple use case. I have one slide prepared. Okay, that first. And then we dive into the projects that are also using gelato right now. I'll screen share quickly again. So one very simple use case, just to sort of clear up any confusion, is gasless NFT minting using an ERC 20 permitted token, like for example, USDC.
00:11:27.458 - 00:12:03.154, Speaker B: So this example is simplified a little, but in this case we're using call with sync fee. So it's a self paying transaction. So for example, let's imagine the user's wallet has 100 USDC, but it doesn't have any ethereum, so no native tokens to transact. It can sign an ERC 20 permit signature approving the NFT contract to spend the USDC, and then we can relay a mint transaction. The NFT contract can then transfer for example 99 USDC to itself and then one USDC to a fee collector. And that pays for the transaction. So this is sort of what I was alluding to earlier with having transactions self paying.
00:12:03.154 - 00:12:42.510, Speaker B: So in this case we didn't use ethereum, but the transaction costs were still covered within the actual transaction. Yeah, in terms of actual implementations. So our most recent integration, I would say is Tigris, which is a Defi trading platform, and they use really under the hood to enable gases transactions. And that just provides a nice ux. They also have something very cool called browser wallets. And when you combine these two, you essentially have a trading experience like you have in tradfi traditional finance, where you can just sort of click a button and the trade goes through. But at the same time you still benefit from decentralization.
00:12:42.510 - 00:13:03.670, Speaker B: Another example is the Conex bridge, which does cross chain transfers, and they use relay to eliminate the need for a second transaction on the destination chain. So usually you have to transact on the source chain to deposit tokens and then also withdraw the tokens on the destination chain. But in this case we can completely eliminate the second transaction.
00:13:04.170 - 00:13:28.160, Speaker A: I see. I'm really glad you mentioned connects, because I think that was something that was happening with our linear voyages. Connects was one of the, I guess, projects that was featured. And then I think Gelato Severley was like, whoa, our contract's like going insane. The volume is. That's really cool. I see that makes sense.
00:13:28.160 - 00:14:25.902, Speaker A: I'm glad you highlighted kind of defi and bridging use cases because my first instinct when I was thinking about gelato relay was like, gaming. Right. That's probably more near and dear to my heart. So when you're talking about minting nfts or having these sort of seamless experiences, immediately, I think gelato is a really cool use case for that because no one wants to be approving transactions and paying for gas in the middle of their game. Right? So I guess to get into that, right, so that's gelato out in the wild. We are focusing on hackathon developers or maybe like just people interested in using gelato in general would love to get your kind of expertise and opinion on what people could potentially explore, maybe with regards to kind of each vertical. So you gave some examples of, like, defi, but there's a lot of other stuff if you want to inspire the masses.
00:14:25.902 - 00:14:26.660, Speaker A: I don't.
00:14:30.790 - 00:15:12.510, Speaker B: Actually go off the thing that you mentioned, the whole bridging use case. This is like for a hackathon idea, for example, and to give some context, first circle released something called CTP, which is their cross chain transfer protocol, and that essentially allows for the transfer of native USDC between chains. So it's not some sort of bridged variant like you'd see with other bridges. So a cool hackathon idea there would be to integrate gelato relay to enable that to be completely gasless. And it's very similar to the connect use case I mentioned earlier, where you have a transaction on the source chain and then also one on the destination chain. So that could all sort of be abstracted away from the user.
00:15:14.070 - 00:15:30.774, Speaker A: Okay, very cool. So obviously we know why you should use gelato. How it works. Can we get into. Actually, I think. Did you say you had a demo of some sort? How devs can get started?
00:15:30.972 - 00:15:32.120, Speaker B: Yeah, exactly.
00:15:37.530 - 00:15:38.242, Speaker A: It.
00:15:38.396 - 00:15:39.900, Speaker B: Everyone can see this. All right.
00:15:40.270 - 00:15:42.074, Speaker A: Yeah, it's a little small.
00:15:42.192 - 00:15:43.514, Speaker B: Yeah, I'll zoom in a bit.
00:15:43.632 - 00:15:47.900, Speaker A: I always forget you're young, you have good eyes.
00:15:49.150 - 00:16:38.202, Speaker B: I have good quality on the screen at the moment as well. And just to answer any sort of questions around, if there's a different integration process for linear, like, is it different from, for example, deploying on Ethereum or gaseously minting on Ethereum? And the short answer is no. So yeah, this is a hardat project, and the process is exactly the same for adding any chain. So here we have like Mumbai, which is the polygon testnet, and here we have linear. The only thing that differs is the chain id and the RPC provider. And now to dive into the actual is, I should probably make it clear that this showcase, it's a showcase of gases NFT minting, and the transaction is paid for using one balance. So our transaction is, or our contract is two things.
00:16:38.202 - 00:17:20.970, Speaker B: It's an NFT contract. So an ERC seven two one contract, in this case implemented by open zeppelin. And it's also an ERC two seven one context. And it's important to note here that the ERC two seven one context is not responsible for actually verifying the signatures like I mentioned earlier, but rather whitelisting a trusted forwarder that handles that for us. So in our constructor, we initialize the NFT contract. So ERC seven two one, we call the constructor passing the name of the NFT and a symbol which is like a shorthand. And we also initialize the ERC two seven one context, passing our trusted forwarder, which in our case is gelato relay.
00:17:20.970 - 00:17:59.654, Speaker B: And before we discuss the mint function, I'll quickly discuss the overrides below, just to clear up any confusion there. The reason we need these overrides is because both of these contracts that we inherit from implement their own message sender variant. So there's ambiguity as to which we want to use, and the way we resolve that is by making it explicit, by overriding, by overriding the function. And in our case, we want to use the ERC two seven one context implementation of message sender. That's what we call. And we can also quickly check out the implementation, if it's not too technical. Do you think it's worth checking out or not?
00:17:59.692 - 00:18:00.840, Speaker A: Yes, no, definitely.
00:18:04.650 - 00:18:39.940, Speaker B: All this does is it checks if the call is coming from a trusted forwarder. And if that's the case, we can just extract the signer, which has been appended to call data by our trusted forwarder. And if not, we call the superclass message sender, which in our case, the superclass is this context contract. Also open zeppelin. And all that does is return our message sender. So this is nice, because we get the best of both worlds. If we relay the transaction, we end up with the signer who signed the transaction, and if we just call the contract from a traditional EOA, so your metamask wallet, we end up with that wallet address.
00:18:39.940 - 00:19:20.826, Speaker B: So the transactions don't have to be relayed to interact with this contract, but they can be. And it's a nice abstraction because we can just use message sender everywhere and everything. The rest is abstracted away for us now into the main functionality, which is the mint function. There's not too much to it, but we call safe mint which is implemented by ERC seven two one. Again, and this expects the recipient address, which in our case is the message sender. And it also expects a token id, which in our case is just the supply at the time of mint, and then we just increment it. So yeah, that's everything that happens on chain and now to cover everything that happens off chain.
00:19:20.826 - 00:19:45.414, Speaker B: So this is just a hard hat script which we will actually run to mint the NFT. So we'll just go through this quickly. We instantiate a wallet, all we need for that is a private key and we need a provider. So RPC provider. We also get the address of our deployed gases NFT contract. We then instantiate an NFT instance. And here's the interesting part.
00:19:45.414 - 00:20:19.154, Speaker B: So we build the call data, but we don't actually call this mint transaction on the NFT contract. We just construct the call data which we can use later on. And here we construct the relay payload which expects a target address, which in our case is the NFT contract. The data we pass is just the call data. The chain id is the current chain id we're on. So we can get that from our provider and the user is just the address of our wallet. Then we instantiate a relay instance and then we call relay sponsored call ERC 2771.
00:20:19.154 - 00:20:51.600, Speaker B: So in this case the call is sponsored and we'll want to be signed the transaction, which is why we use ERC two seven one. And this expects the request which we constructed here. It expects the wallet which it will then use to sign the transaction. And it also expects a sponsor key, which is our one balance sponsor key used to actually pay for the relay transaction. And then afterwards this returns a task id which we can then just print and we can get the status of the task from the API. So I'll demonstrate, I guess. I don't think there's much else to explain.
00:20:51.600 - 00:21:18.226, Speaker B: So we have the actual task which we can open. Can you still see this or did I not screen share?
00:21:18.408 - 00:21:20.262, Speaker A: It's there, but it's small.
00:21:20.316 - 00:21:45.626, Speaker B: Again, this is not too important. This is just the actual API itself, so it's not super human readable. But we can just quickly get the task from here to see when it's finished. So the transaction is executed. We can get the transaction hash, or we can just check whether the NFTs are minted. We just check on a block explorer. We're looking for ERC seven two one tokens.
00:21:45.626 - 00:21:57.970, Speaker B: So nfts. And we see 32 seconds ago, this is gel. NFT was minted to our address and we didn't pay any gas. I should have probably showed the balance before and after, but, yeah, we didn't pay any gas.
00:21:58.630 - 00:22:22.970, Speaker A: Nice. Okay, so I have kind of a few questions. Right, so I think in the process of working with gelato relay, you're working with gelato contracts, you're working with one balance. How do people actually run this? Can they run this locally? Do they need to do this all on linear? What's the development flow like?
00:22:23.120 - 00:22:50.420, Speaker B: Yeah, so you can test everything locally. So you can, for example, emulate what the relayer contracts would do and get all of that behavior locally. You can also fork network state. So that just enables you to test locally as well, using hard hat, for example, or foundry or truffle. So, yeah, lots of possibilities to test off chain. No need to deploy the contracts over and over again. And we also have lots of docs available, a great support community on Discord, if there's any questions or anything's going wrong.
00:22:51.510 - 00:22:54.434, Speaker A: Okay, cool. Do you have links I can send out?
00:22:54.552 - 00:22:55.682, Speaker B: Yeah, offhand.
00:22:55.746 - 00:22:58.082, Speaker A: And I'll just post them in the chat.
00:22:58.226 - 00:22:59.670, Speaker B: Should I put them in the chat as well?
00:22:59.740 - 00:23:01.426, Speaker A: Yeah, or you could put them in the chat.
00:23:01.538 - 00:23:16.040, Speaker B: Okay. Um, I'll send them to you, I think. Okay, these are docs, and I will send a discord as well.
00:23:19.690 - 00:23:49.926, Speaker A: I. Nice. So these are our two places. If you have more questions, head over to discord. I've used gelato before, and you guys are, like, way too responsive at all hours of the day. So I guess good thing, bad thing for the employees. We're not going to get into that.
00:23:49.926 - 00:24:21.502, Speaker A: Yeah. Okay. Yeah, very cool. So, just to kind of reiterate, for those of you who are new, you off handily mentioned, like, emulating, forking, truffle, hard hat foundry. What that actually means is, I guess the flow is you have your local development chain, you can fork it by basically copying state. I know for truffle specifically, it's just like a ganache fork. I don't remember what it is off the top of my head for hard hat and foundry, but it's probably similar.
00:24:21.502 - 00:24:51.960, Speaker A: You can find that in the docs. The other piece I do want to mention, and you confirm if this is true, right? You guys could just fork like Gurley or Ethereum and test it all there. And then at the last step then deploy to linear and it should be the exact same that. Do you have anything else you want to talk about? Introduce. Otherwise we're good to wrap up here.
00:24:52.650 - 00:25:00.362, Speaker B: I think that's pretty much everything. I think you covered most of it. Okay, I can quickly show the hard hat config if that's interesting, sort of how to fork the network state.
00:25:00.416 - 00:25:02.570, Speaker A: But yeah, that would be helpful.
00:25:02.730 - 00:25:31.414, Speaker B: Okay. Because it is really very simple in hardhat as well. So again, it's just the hard hat config. And then up here in networks, we can specify the hard hat network, specify forking, and then we can provide a RPC provider. So just an RPC URL for the fork network. And you can also specify block number here if you wanted to. So if you want to fork the network state at a certain block, that's all it is.
00:25:31.612 - 00:25:58.560, Speaker A: Cool. That makes sense. So just to reclarify, right? If we didn't do any forking and you're developing this locally, I guess the local blockchain it brings up is like zero. There's nothing on it, nothing to interact with. So yeah, gelato is not there. So if you want to deploy locally, do this. Also, you don't use actual test eth or any of that stuff.
00:25:59.730 - 00:26:05.738, Speaker B: And also, it's worth noting, we have lots of sort of unit tests, example repos that you can run to test all of this locally.
00:26:05.914 - 00:26:10.880, Speaker A: Oh, yes, I was going to ask. So does the documentation have all this code?
00:26:11.250 - 00:26:42.350, Speaker B: Yeah, but I can also link some GitHub repositories because there's one. Good 1 second. This is a good point, actually. It's just this repo, this sort of gets you started with like a unit test environment where you can use all four relay methods I demonstrated. So call with sync fee, sponsored call, et cetera.
00:26:43.250 - 00:27:01.154, Speaker A: Okay, cool. I love that you mentioned unit testing, guys. Test driven development. I'm definitely guilty of not doing this sometimes. The hackathon is two months. We have time to write. Yeah, yeah.
00:27:01.154 - 00:27:26.706, Speaker A: Okay, very cool. Well, thank you so much for joining, Ben. This was super fun. Very interesting. This is live now. I do believe this is being broadcasted to our hackathon participants a little bit later. But all this information will be available online and in this video and in discord.
00:27:26.706 - 00:27:28.280, Speaker A: And you guys will be.
00:27:30.450 - 00:27:36.586, Speaker B: Right. Exactly. Thank you so much for having me. Really interesting. I was really excited.
00:27:36.778 - 00:27:42.654, Speaker A: Yeah. Okay, well, have a good day and I'll see everyone later.
00:27:42.772 - 00:27:44.170, Speaker B: Bye bye, everyone. Bye.
