00:00:00.170 - 00:00:11.840, Speaker A: I do Devrel for Linea and we have a very beautiful guest today talking and I guess telling us about what Layer Zero is all about. So yeah, please introduce yourself.
00:00:12.210 - 00:00:36.946, Speaker B: Yeah, GM, everybody. My name is Matt. I'm currently the developer relations engineer at Layer Zero Labs working on omnichan messaging. Super excited to be here. Thanks for the shout out, Emily, and just for inviting me on. I'm super, I think, stoked to go through and explain a little bit about what layer Zero is, what an oft is, what cross chain messaging actually means, and kind of simplify all this stuff that I think has been jargonized for forever.
00:00:37.138 - 00:01:07.650, Speaker A: Yeah, I'm really excited for that because I feel like people have just created, I don't want to say it's arbitrary, but it kind of feels arbitrary prefixes to the word chain, like omni inter. I'm going to put you on the spot later just to kind of explain the differences, at least to me. Yeah, I usually start with like a basics, what is layer Zero? But I think you have slides that explain it. So I'll let you, I guess, hop into it.
00:01:07.800 - 00:01:49.310, Speaker B: Let's jump into it from a high level. So again, to kind of jump into it, I'm from layer zero. If you don't know what layer zero is, hopefully this presentation will kind of give you a good feeler for how omnichain messaging works and why we feel that we're different in the space. But yeah, let's kind of go through kind of the agenda for the day. I think high level, what I want to end up doing in this presentation is kind of give you an idea of where we think layer Zero fits into the blockchain space, why interoperability matters. Kind of a high level overview on how that ties into just your basic knowledge of smart contract tokens. And then we'll get into the messaging piece of how everything works under the hood.
00:01:49.310 - 00:02:54.590, Speaker B: So to kind of jive and jump right in, I think that one of the big things we talk about when we're building cross chain messages is working up from first principles. And so we're very familiar, I think, here, hopefully, with bitcoin and Ethereum, the idea of peer to peer value transfer with bitcoin and then peer to peer applications with Ethereum. But there's a really interesting thing that's noted. After Ethereum launched, which is when applications started actually getting built on the blockchain, it became very apparent very quickly that not every blockchain was perfectly suited to serve every single application. And over the last few years, we've seen kind of an explosion of different blockchains getting built for different purposes. And I like to think of this as like the Internet of blockchains, the idea that there are tons of different chains being built depending on what your use case is and what your application is. And there should be some way in theory to kind of communicate between all these chains, because not every application needs to be in a silo.
00:02:54.590 - 00:04:08.186, Speaker B: I think that there's actually a lot of really interesting use cases that can kind of get built out by enabling different chains to be used, for example, for data availability, for settlement, for depending on your use case, whatever you may need, and using that kind of ledger as a way to store state in one part of the chain, but also communicating out to other chains for whatever your use case may be. And so we see layer zero as a way of transporting both data or value between all these chains. And I think this kind of cross chain reality has become more and more obvious. If you guys saw the electric capital report that came out a couple of weeks ago, it's becoming more and more obvious that developers are trying to build for more than one chain. This number has been steadily growing year over year. And it makes sense if you think about intuitively why a developer might want to be on more than one chain, because you're constantly making trade offs and your users are making trade offs based around speed, cost, security, as well as your own individual use case on what chain you deploy on. And so when we think about kind of the application space in the industry, we see this kind of specialization getting built out.
00:04:08.186 - 00:05:23.940, Speaker B: But one thing that I think that we, at least at layer zero, are super bullish about and hopeful that this kind of becomes more of a reality is this idea of a global ledger where a smart contract can exist in multiple different forms on multiple different chains, and you're able to tailor that application based on the strengths and weaknesses of that chain and also have easy ways of communicating with both the community on those chains as well as the specific feature sets that are on that chain. Diving in, I think a little bit closer to how this actually works. Let's go back to first principles and look at just what a token smart contract is. So if I'm deploying ERC 20 token on linear, the main way it works under the hood of that smart contract is really when I say I'm transferring tokens, all that's actually happening is I'm updating balances under the hood on the ledger itself. So when I send tokens from a user, I'm updating that user's balance to deduct the amount I'm sending. And then on the receive side, I'm updating their balance to receive those tokens. And this is fairly straightforward because you're operating with just one smart contract on one chain, and that ledger is correctly displaying the state of information for the chain itself and for the application.
00:05:23.940 - 00:06:35.210, Speaker B: But this gets a little bit more complicated when we kind of jump to two separate chains. Let's take linear and ethereum, for example. If I want to move assets from linear to ethereum, there's a really good question here, which is, how do I actually notify the other chain that something at all has happened? And the simple way to think about it is I can still have a transfer function that I call from the source chain, and that function will notify the destination. And from there, there can be some type of receive logic that updates on the destination chain. But there's something kind of critical missing in the middle here. And that is, how do we actually, one, make sure that the person who's delivering that message is someone we trust or someone that we don't think is malicious? And two, how do we make sure that this happens in a timely manner without violating the security principles that brought us to blockchain in the first place? The way this kind of developed over time was there would be one monolithic security model. And when I say monolithic, all I want you guys to think about is basically there's one provider that's helping deliver that message.
00:06:35.210 - 00:07:54.420, Speaker B: Now, that one provider could be a middle chain, that one provider could be a collection of signers, that one provider could be essentially anyone. The idea is, though, that as bridging became more and more popular, there was someone in the middle that would basically guarantee, hey, you executed this function on the source chain. Let's go and execute this function on the destination now and make sure that the message is verified. But a really critical question that kind of popped up here was what happens when that monolithic security fails? What happens when either the signers go rogue, when the bridge goes down, or there's a vulnerability that allows for an exploit and kind of jumping even a little bit further into that idea of attack vectors. Another kind of critical issue that we saw, at least when we were looking at how to build layer zero, was that if you're signing on to one bridge that has exactly the same security for every single application built on top of it, it means that you can no longer tailor your application to its specific needs. You're kind of locked into a one size fits all model. And so if your application depends on fast message delivery, you might be stuck paying for more security and time than you'd actually be able to reasonably have in your application.
00:07:54.420 - 00:09:40.178, Speaker B: Other questions came up about how do you manage your pathways on different chains? How do you know when to call the destination chain? How do you prevent these malicious attacks from happening? And to look at kind of the concrete outputs of that, you can have really real problems where let's say a user spends 100 tokens on a source chain, but that message is never delivered. Now that user has effectively burnt tokens out of existence and there's no restitution mechanism for them. Similar problem can happen where let's say the message does actually get verified and delivered to the destination chain, but the message fails to execute. How do you have the message retried and in a way where anyone can go and retrieve their funds if necessary? And the worst problem that we're probably all very familiar with, what happens when your security flat out fails and someone's able to instantly mint tokens on a destination chain? These all sound like just random hypotheticals, but if you look at the five largest crypto exploits in the entire industry, four out of those five were all due to this type of bridging problem, the idea that one security mechanism flat out failed and collapsed in on itself, leaving users and developers with their funds at risk, and usually with not many restitution mechanisms available to them. So going back to that idea of crosschain is a reality people are going to keep building on different chains. We expect developers to be able to make trade offs dependent on each of their use cases. Why should you not be able to configure your cross chain messaging in a way that also has those trade offs and meets your use cases? This kind of brings us into the idea behind an oft.
00:09:40.178 - 00:11:03.998, Speaker B: An omnichain token for us, really focuses on you having ownership over your smart contracts and being able to use this global ledger safely and tailored to your own individual use case, jumping into kind of what this actually looks like in practice. This is the same example we were showing earlier where we were moving tokens between Linea and Ethereum. The difference here is that we now have an oft contract deployed on each chain here and here. What's really happening in this contract is that it's still an ERC 20 token, but we have some debit logic that we've included that basically triggers every time I want to send a token, it will debit the amount of tokens to expect some slippage amount in case things go wrong, and then a destination chain and communicate with the protocol interface itself at the smart contract level to emit a message from that source chain. When that message is emitted, it actually uses your application's configured security stack. So we have a selection of providers that have built decentralized verifier networks for you to communicate with. And what these modules effectively do is they listen for a message being emitted from that transfer, will verify it using their own security setup, and deliver that message to the destination.
00:11:03.998 - 00:12:27.098, Speaker B: So what that effectively looks like is anyone now can send a message using the protocol interface using your custom configuration, your selected security stack. So whichever trust assumptions you have about security, you can use those modules to secure your cross chain message. Once that message has been verified and delivered to the destination, it's received in the message library, which then can be executed either permissionlessly by any caller on the destination chain, or use an automatic caller that will execute this for you and handle all the gas and everything that you would need basically on the destination chain. And so what this effectively gives you is a smart contract setup where you can have multiple tokens that exist on multiple different chains that are all connected together. And in that worst case scenario, where an entire monolithic security stack fails, you now have, one, a way to configure it away from that provider. And two, you're not putting your entire contract and your entire application at risk. Instead, you're able to customize and say, hey, I want two out of these three security networks to verify my messages, or you can set arbitrary confirmation times for them to wait to make sure that you're able to effectively configure your application in the way you expect.
00:12:27.098 - 00:13:10.060, Speaker B: And so zooming out the way that we see kind of the layer zero tech stack is that you can take any application use case that you want to build, use contract standards that either we provide directly, like our omnichan fungible token standard or omnichain app standard, communicate with our protocol smart contract interface, the endpoint here, and then actually be able to tailor and customize your application depending on what your application needs. That's the security networks it gets verified by, the type of execution you use, how gas is handled on the destination chain, and so much more. So happy to kind of, I think, pause there. I threw a lot of information at you guys and take some questions.
00:13:14.430 - 00:13:39.010, Speaker A: I am muted. Yes, I personally have some questions just around, like, I don't want to say practicality is the right word, but let's say there's a lot of existing projects that do things like token gated channels or other things, would they out of the box support onfts?
00:13:39.910 - 00:14:39.142, Speaker B: Yeah. So the interesting thing here is that all of the kind of custom configurations related to the actual bridging of data itself, that's all done via the OAP standard. And so going back to this visual, you can pass essentially any arbitrary data through. So existing applications could just deploy an OAP contract. And really what we're showing here is that you can pass any arbitrary bytes from the source blockchain and then just decide what to do with those bytes on the destination. So you could take any smart contract standard like a token gated channel, and do something with it essentially on the destination chain. There definitely is some logic that you have to add to connect from whatever standard you're using on top of OAP, but there's not necessarily like a lock in that you have to do for any one particular type of token or any one particular type of standard.
00:14:39.142 - 00:14:44.040, Speaker B: It's very open in what kind of data you pass, and there's no real limitations there.
00:14:45.050 - 00:15:15.082, Speaker A: Okay, so just to make sure I button up my understanding right, it's more so on, I guess, us as the deployer side, making sure that data is emitted in a way such that any Dapps that just normally, let's say, detect regular ERC 720 ones on linear, for example, can understand. But the consumer Dap doesn't have to make any changes they can process as usual.
00:15:15.226 - 00:16:11.380, Speaker B: Exactly. I think one of the things that helped me understand it when I was first getting introduced to the ecosystem was we had the sushi swap team, for example, come in and they were trying to get oracle price feeds on certain chains that they were on, they didn't have available for their cross chain swaps. And so they were able to use layer zero by literally taking the price feed information and then sending it as a message cross chain so that they can use that price feed on a chain. It's not supported. We saw hackers do something similar with Worldcoin when they first were rolling out with proof of identity. They would take proof of identity from one chain and then basically port it over using layer zero so that you had that confirmation on a chain. And basically the idea is that as a developer, you now can move any arbitrary information or data that you need to use on whatever new chain you go to.
00:16:12.070 - 00:16:30.460, Speaker A: Okay, cool. And then I guess the other question maybe is from a choice point of view, do you select which chains your onft supports or is on? Okay. And then is that changeable over time, like, oh, I want to add like XYZ. Now it's popping. Okay.
00:16:30.990 - 00:17:02.274, Speaker B: The way it kind of works is that from this stack view, basically any chain that has a layer zero endpoint, you can deploy this oft contract on. And kind of the idea for us is that if you want to only be on two chains, great. You have an endpoint on these two chains. You can network them together. But from a high level view, any chain that has a layer zero endpoint will be able to be used for cross chain messaging. So you can move to as many chains as you want or every chain that we're on.
00:17:02.392 - 00:17:21.658, Speaker A: Right. Okay, cool. Oh, yeah. I guess to circle back to the question that I was asking, right. I guess at this point, I have a pretty clear understanding of difference between omni and cross chain just from like, whatever. But have you heard of interchain at all?
00:17:21.824 - 00:17:22.650, Speaker B: I have, yeah.
00:17:22.720 - 00:17:26.940, Speaker A: Okay. I don't want to put if you haven't. And I'm just like, what's the difference there?
00:17:28.590 - 00:18:11.066, Speaker B: I think a lot of people come up with similar words for the same concept, right, of just moving messages between. I think for us, we refer to omnichain because you have this ability to use a bunch of different security to verify your messages in flight. For example, we have our decentralized verifier networks going back to this image here. Some of the dvns that we have available, for example, are adapters. So we have these security modules that route through CCIP or axilar. And part of the reason why we offer those is that we at layer zero don't want to make any assumptions on behalf of the developer. Right.
00:18:11.066 - 00:18:44.100, Speaker B: When you're building an application, it should be super unoppinionated on what security you use, on what messaging speed you use, because it all depends on your individual use case. And so if you have a trust assumption and you say, oh, I feel that a middle chain is more secure for these reasons, you should still be able to use that using layer zero. For us, it's really about more giving developers a marketplace of different solutions that easily plug into the same predictable interface so you don't have to go and reinvent the wheel for every new chain that you go on.
00:18:45.110 - 00:18:52.200, Speaker A: Cool. We have a question about supported chains, I guess. Does bitcoin support layer zero?
00:18:52.570 - 00:20:09.562, Speaker B: There is no bitcoin endpoint at the moment. It's tough because there's not actually like a smart contract that you can deploy on the bitcoin ecosystem. But there was an interesting project that launched like a week ago which I believe is doing like an inscription service for BRC 20s. So they will natively convert your oft to BRC 20, not directly via layer zero, but they're using their own process through the back end to do that. So it's interesting because as you get into more and more of these non EVM chains, the process of messaging becomes a lot more difficult because you're trying to basically preserve the same kind of tech stack, but on a completely different language. So when we went to Aptos, for example, for the first time, it was a really big design challenge for our team to figure out how do we kind of fit the core principles of what we think layer zero should be and how you should interact with it in a chain that, for example, doesn't have dispatch runtime when you use it, and is a lot more, I think, optimized in certain ways and different in other ways to the EVM. So good question, but we're hoping that over the next, I think, few months, you'll see a lot more rollout.
00:20:09.562 - 00:20:13.890, Speaker B: And number one thing, I think priority for us is exploring non EVM.
00:20:14.950 - 00:20:22.740, Speaker A: Cool. I forgot, did you say maybe you could walk through some code? We don't have to do anything like live.
00:20:23.750 - 00:20:45.546, Speaker B: No, what I'll do is, I was saying we have, like, I'm going to say this is alpha because we're still building this out. So this package is live. You can go ahead and use it. There are a few bugs that we're actively working through, but it's more of, like, bugs related to just the tooling and the package. What I'll do here is kind of.
00:20:45.728 - 00:20:51.980, Speaker C: Switch tabs really quick and we can jump in here.
00:20:52.290 - 00:20:54.560, Speaker B: Are you able to see my screen okay?
00:20:55.090 - 00:21:07.250, Speaker A: Yes. Though there is an extra question. Maybe I just want to answer them as they come so they don't forget. If we want a token to be omnichain, do we have to deploy with a new smart contract?
00:21:07.750 - 00:21:41.870, Speaker B: Yeah. So the way it works is if you have either, if you want to do a new deployment, you'll basically deploy a smart contract on every chain you want to go on. The oft is an ERC 20. So if you're going to new evms, you'll have a new oft contract on each of the chains that you deploy to. If you have an existing ERC 20, you can use what's called an oft adapter contract. And basically that contract will act as like a lockbox. So whenever you send a token gets locked in the box, emits a message to destination chain to mint, a new token.
00:21:43.010 - 00:21:43.566, Speaker A: Okay.
00:21:43.668 - 00:22:05.140, Speaker B: But, yeah, let's jump into the coding really quick. So, I'm super stoked for this, because I think, especially working with crosschain, it's hard to have everything tangible and right in front of you. And this tooling package that we're working on right now makes it a lot easier, I think, to just get started with a project.
00:22:05.690 - 00:22:09.400, Speaker A: Can you zoom in a bit? My old lady eyes are.
00:22:10.410 - 00:22:12.630, Speaker B: Yeah, you're good. This good enough?
00:22:12.780 - 00:22:16.600, Speaker A: Yeah, I think so. At least for me. I'm still young.
00:22:18.330 - 00:22:49.300, Speaker B: Yeah. So for those of you who didn't see, I'll actually just restart here. So I'm just running MPX, create lzoapp. And what this will do is essentially kind of like hard hat spin up, kind of like a choose your own adventure for where you want to start your project. We'll ask you, hey, do you want to start with the oft contract or the OAP contract? In this case, we'll do oft ask what package manager you want to use, and then go ahead, install all the dependencies you need.
00:22:50.710 - 00:22:51.586, Speaker C: What happened here?
00:22:51.608 - 00:22:53.570, Speaker B: Oh, because it's asking about NVM.
00:22:55.130 - 00:23:03.698, Speaker C: I bet it is. Let's do NVM 18. Nice. And we'll start this from scratch.
00:23:03.794 - 00:23:43.170, Speaker B: But basically what this will do, and hence why I said alpha, it'll spin up essentially like a sample repo for you to start your project out, of, which I think is super handy, because obviously people are choosing between hard hat foundry, a lot of different developer environments. This will kind of give you an all in one that has already some OAP and oft contracts in it will give you an idea of how to start building with an oft, give you some really handy configurations for setting up all of these kind of messaging pathways that I talked about and really just get you started with your toe in the water, which I am stoked about, especially for, like, hackathons.
00:23:46.250 - 00:23:48.600, Speaker C: So let's see if that gets going here.
00:23:53.050 - 00:23:55.800, Speaker A: Cool. And all this is in the docs, right?
00:23:56.250 - 00:24:27.810, Speaker B: Yeah. Awesome. And we're good to go. So let's zoom in a little bit. Super normal project layout, you get provided with a contracts folder, deployments folder, and some testing. And basically, if we look at kind of what an oft contract actually is, you can see here that all an oft is, is just a contract standard we provide. You're defining very similar to ERC 20, the token name, the token symbol.
00:24:27.810 - 00:25:04.122, Speaker B: But there's two new fields here. This one is your layer zero endpoint. So this is the actual protocol interface that I was talking about. This is the contract that whenever I want to send a message via the protocol to a destination chain, you're communicating with this contract, and then the delegate is essentially the owner of the application. You can think of this as the contract owner that's in charge of managing all these configurations. Right? So you might want this to be yourself with normal opens up lin ownable. You might want it to be a multi sig, you might want it to be a dow.
00:25:04.122 - 00:25:39.158, Speaker B: Whatever it may be. This is kind of your setup. But what's really cool about this repo is that if we pop over here into terminal and you run MPX hardhat. Oh, I need to actually, I don't want to do this. And I want to go one level deeper. So when we run MPX hard hat, you'll get all these LZ related commands. And we've tried to make it very simple where we make it straightforward for you to pull, for example, like the default configuration between two networks.
00:25:39.158 - 00:26:18.550, Speaker B: Wire your contracts together, be able to decode any errors that pop up during deployment. It's super handy. And the other thing you might notice it's a little different, is there's normal hard hat config has your networks defined here. There's this Eid field here. And what this EID actually is, is your endpoint id. So if I jump really quickly here over to our docs, every chain that we're deployed to basically has this endpoint contract name and then an identifier number for it. That's all that's pulling.
00:26:18.550 - 00:26:35.194, Speaker B: But the neat thing is basically, once you kind of set up your networks and you plug in, hey, I want to deploy on Sepolia avalanche polygon or linear. You could do the same process here for linear endpoint id. Endpoint iD.
00:26:35.392 - 00:26:39.994, Speaker C: And then it would be ZK consensus. I think for us, once you do.
00:26:40.032 - 00:27:15.602, Speaker B: All of that fun stuff, you can go in here, this layer, zero config that was generated for you and then define what contract you're actually going to be deploying in this case oft. And then actually choose each of the connections here. So you can see that we have a contract for Fuji, Sepolia Mumbai. You can see that this part here is from Fuji to Sepolia. And then a little config selector. I think I have another config stored around here somewhere. But basically this will allow you to kind of define what I showed here in this slide deck.
00:27:15.602 - 00:27:32.682, Speaker B: The different configurations that you have for sending and receiving your dvns in this case. And then also all of these custom configurations here. But I think what might be more useful is kind of just walking through a super simple example. I don't know. Do you think we have time for that, Emily?
00:27:32.746 - 00:27:44.290, Speaker A: Yeah, no, we have an hour, though. I do want to also interrupt. Right, yeah. So we have a break. We have some more questions. How does layer zero compare to chainlink CCIP?
00:27:44.630 - 00:28:51.030, Speaker B: Yeah, so kind of going through the slide deck that I showed you before, we view layer zero as a way to have full customization over what your messaging actually looks like. CCIP, you are limited in kind of what CCIP provides you in terms of security. One of the big selling points that they have right now is that, hey, you should trust us because we have a secure oracle network. And I don't disagree. I love chainlink oracles, but I do think that when it comes to messaging, we've seen huge partners before have really big security vulnerabilities that get introduced, and cross chain messaging should be something where you have a lot more control as a user to know, hey, my application is running on this security model, this security model, and this security model. So I think that from that standpoint, layer Zero offers more customization to your application and also just provides you with, I think, more out of the box contract standards. We've tried to make it really kind of seamless where if you want the bare minimum, you just deploy two contracts, wire them together, and you're up and running.
00:28:51.030 - 00:29:02.540, Speaker B: Or if you want to build something incredibly custom and build it out of the box, you're free to run your own security, run your own execution, kind of take it as far as you want to go, basically.
00:29:03.710 - 00:29:10.410, Speaker A: Awesome. Here's another question. Will oft make bridging between multi chains easier?
00:29:11.070 - 00:29:57.366, Speaker B: Yeah, you can think about it as layer zero itself isn't necessarily a bridge, but the oft contract. Actually, let's just look at the oft contract. I think that might give us some more clues at what's happening here. So jumping into the oft contract from a high level, what's happening on each chain is basically whenever I want to send a message, I'm burning tokens on network a, minting them on network b, and this is all being done via the layer zero protocol itself. So what this means is that you can go and deploy these two contracts today. You could deploy an oft instance like this on your source chain and then deploy another on your destination. Effectively, that's your bridge.
00:29:57.366 - 00:30:48.460, Speaker B: Now you're able to natively move tokens from one chain to another with no real limitation. It's very similar to ERC 20 where there isn't kind of someone owning the token in the middle between you, you are effectively controlling your security setup, how that token is built, et cetera, and what it's used for. So we see it as being really interesting because you can build obviously bridging protocols on top of that, that do cross chain swaps, that do cross chain staking, things like that. But it's really kind of up to the developer to decide what they want to do with these tools that we provide them. I think just to kind of show messaging off here, what I'll do is jump into our getting started guide. So this is all alive in our docs right now. What I'm going to do is just open a remix instance on both these.
00:30:50.050 - 00:30:50.800, Speaker C: Nice.
00:30:52.690 - 00:30:55.680, Speaker B: And yeah, we'll have destination contract here.
00:30:56.050 - 00:31:12.322, Speaker C: And this should open up in a second here with believe source or did I click destination twice? I might have done that. Let's check this one more time. Nice.
00:31:12.376 - 00:31:14.722, Speaker B: So yeah, we have source here and.
00:31:14.856 - 00:31:16.600, Speaker C: Destination on this side.
00:31:18.330 - 00:31:20.514, Speaker B: Remix is a little slow though, and buggy.
00:31:20.642 - 00:31:25.686, Speaker A: I think you're sharing only like a tab right now or something.
00:31:25.868 - 00:31:33.818, Speaker B: Oh yeah, it might be. Let me fix that. Good catch. I'm new to the streaming game. I feel like I got to up my game right now.
00:31:33.904 - 00:31:44.880, Speaker A: Yeah, no worries. All I do is stream because video editing scares me. Authenticity. I'm a real person. I'm not AI. That's kind of where I'm going.
00:31:45.250 - 00:31:48.480, Speaker B: Dude, we need more people like you. For real.
00:31:51.490 - 00:31:54.962, Speaker C: Let's see what's going on here. Just close this and then get this on.
00:31:55.016 - 00:31:57.490, Speaker B: Any other questions coming through too. In the meantime.
00:31:59.590 - 00:32:23.420, Speaker A: Feel like you get the standard token questions. If you feel like you're allowed to say anything. I think maybe something that might be meaningful is like layer zero, v two without. I'm not familiar with zero tokens. I don't know if you see this one. Like what?
00:32:24.990 - 00:32:27.018, Speaker B: What's the difference between v one and v two?
00:32:27.104 - 00:32:27.740, Speaker A: Yeah.
00:32:29.470 - 00:33:15.782, Speaker B: From a high level, I would say let's see if this is going here from a high level. What's changed is that basically in v one, there was our first approach to kind of this protocol interface for moving any data between chains. What's basically happened is that our team has learned a ton of experience from that first deployment and kind of the problems that we saw teams run into. So we've kind of renovated the protocol interface, I think made it clearer and easier to interface with. The actual gas cost is lower compared to v one. There's been a lot of optimization work done under the hood in terms of configurations. We've tried to double down on this idea that we want people to be able to configure things easily.
00:33:15.782 - 00:34:21.726, Speaker B: I believe with our previous oracle and relayer setup, the big meme was, oh, it's a two of two multi sig, right? Nowadays what we want is really to have the maximum level of customization. So for these dvns, at least for this protocol interface that we have right here, the max number of dvns that you could have verifying messages goes up to 255. Whether or not that's feasible for your application, up to you to decide. But we've really tried to kind of future proof the whole protocol so that you have more access to whatever security mechanism you want. Execution has become permissionless, where anyone can come and permissionlessly deliver their message if they want to, or use our executor, which will just automatically deliver the message using the gas you paid for. On the source chain, there's higher message throughput, we're no longer blocking anymore. And I think just in general, it's become a lot easier to kind of build out these new abstract implementations on top of layer zero.
00:34:21.726 - 00:35:29.560, Speaker B: One of the ones that I'm super excited for is this concept of composability. So basically what happens here is normally when you're trying to compose a message or have some type of application use whatever you've delivered to the destination chain, you have to kind of bundle all of your contract logic into one function block when it's called on the receive side. And what ends up happening is that if, let's say I'm minting a token on the receipt, I'm staking that token on the receipt, and then I'm getting some staking token back on the receive side. If any part of those three steps fails, the whole transaction reverts. And so it became just a huge pain for debugging and I think for scalability with v. One of how do I actually make these messages composable and able to interact multiple times on the destination chain. So we introduced something called horizontal composability, which is basically the idea that when I receive a message I can have some logic executed, and maybe what I'll do here is actually show this live.
00:35:29.560 - 00:36:16.360, Speaker B: I have some contracts locally that I can deploy for this, but basically separate your receive logic. So what's happening in this function block is it's just storing a string that was sent from the source chain. This function will execute, be confirmed on the blockchain totally fine, and in this step basically send a separate message that is handling all of the composed logic. So for example, in that state where I said, you mint a token and then stake it, your minting side could happen totally fine. But if the staking side fails, you've still minted the token and you know that that was successful. So that's kind of like the high level intro to it, but happy to kind of dive in deeper there.
00:36:18.570 - 00:36:26.258, Speaker A: Okay, cool. I think that's everything so far with regards to questions about layer zero. Sweet.
00:36:26.434 - 00:37:15.154, Speaker B: We can just jump in here then. So kind of walking through this contract, all we're doing in this side is literally going to be sending a string to store on the destination chain. So way this works is pretty straightforward. We can jump onto our injected provider here. I think in this case I have some gas on Avalanche and Sepolia, so I'll just do that really quick. But the way this would work for linear is exactly the same. You'd go through to our developer section here, hop into the endpoint addresses, you can grab sepolia for your endpoint, jump in here, throw in the endpoint for the constructor argument, grab your contract address as the owner, transact here, it will just take a second to confirm gas fees.
00:37:15.154 - 00:37:39.086, Speaker B: Go ahead and deploy it. And then I will do the exact same thing over here once this confirms through. And this is kind of the same case for oft, for any token, for any contract really that is using layer zero. So sweet. We're deployed here. Jump on over to our destination contract. Hop on over to a chain that I have gas on.
00:37:39.188 - 00:37:55.010, Speaker C: It's identical everywhere. Let's see what we got. There we go. Nice and same thing. Dope.
00:37:57.850 - 00:38:34.738, Speaker B: Yeah. And really the deployment process here that I'm kind of walking through, it's pretty similar for every deployment. Part of the reason why we built the tooling that we're kind of rolling out over the next couple of weeks. And stay tuned before we denver because that's really when I think this stuff will be available. We built all this stuff because managing contracts on multiple different chains with multiple different gas tokens can be super annoying. Like this for example with remix. So what I think I'll do is I'll jump to a contract I've already deployed really quick.
00:38:34.824 - 00:38:51.480, Speaker C: 1 second and it let's do this really quick. Ch.
00:38:54.490 - 00:38:57.110, Speaker B: How'S the streaming been going in the meantime?
00:38:57.470 - 00:39:04.090, Speaker A: Oh, we have another question. Could we append a request header in transit?
00:39:06.430 - 00:39:18.080, Speaker B: Yeah, it depends on what you mean. If you wanted to, for example, append that this was touched by a certain verifier or a certain executor. You can definitely do that.
00:39:19.810 - 00:39:25.810, Speaker C: Let's just jump over here and do this. Sweet.
00:39:27.190 - 00:39:46.322, Speaker B: Yeah, so what I'll do, I think, is walk through this contract code. So this is a contract I deployed a few weeks ago, kind of going through that composed example I was talking about from a high level. This multi composed OAP is just using our OAP contract interface.
00:39:46.466 - 00:39:49.340, Speaker C: Let's see if we can zoom in here for people in the back.
00:39:50.750 - 00:40:42.300, Speaker B: What's happening is we're basically just defining a string in the beginning in our constructor, deploying nothing too special here, just defining our endpoint owner, all that fun stuff. And then we have a quote function. This quote is super interesting for us because it's basically a way to quote the full cost of your message when you're sending it cross chain. So from for example a gurley to linear, you'd be able to calculate the total cost it would take to execute the message on the source chain plus the destination chain, which I think is sweet because it gives you just a lot more developer tooling and how to actually handle messages and make sure they're successful on the destination chain from there. This send function is also super standard boilerplate. The only thing that's different here is that you basically have a destination endpoint id. You're sending the message that you want to send.
00:40:42.300 - 00:41:24.710, Speaker B: But this new field here is interesting composed addresses. So this is an address array. And basically what we're defining in this send call is, hey, I want you to take this arbitrary message that I want to send out into the destination and these array of addresses that I want to deliver it to. And so what's happening here is I'm encoding it to bytes, packing that bytes into the payload here as the actual message and then shooting it off when I call send. And so when we look at some of the transactions that have come through here, we can go transactions, look at the send call. And what's great is we have this layer zero block explorer.
00:41:25.370 - 00:41:27.234, Speaker C: Let me switch over to this tab.
00:41:27.282 - 00:42:14.886, Speaker B: Here where if we take this transaction that we posted on Testnet, you can get a ton of information about it. But the nice thing is here, let's pop over destination. You can see that this send call was successful. Basically what's happening here is on the destination side, we can decode the input data. What's happening is the executor is calling that lzreceive function. So you're delivering the data that I want to send and decoding it and then from the actual app level, if we jump back over here to our contract, this is our endpoint contract, you can see that that LZ receive is being called, but I actually want to.
00:42:14.908 - 00:42:34.302, Speaker C: Jump to our destination application. 1 second here. Sick. So I'm going to jump over to this explorer. Nice.
00:42:34.436 - 00:44:20.782, Speaker B: So what you can see happening basically in the contract logic here is that when we call receive, we're basically decoding that message payload. So taking that string and that array of addresses back out and then storing that data again in our variable and then basically taking whatever the amount of addresses I want to send it to via for loop and then calling this send compose function, which for us is really interesting because it's able to then basically propagate that message to all these receiver contracts that I have super high level and might have gone a little overkill showing this contract. But basically the idea here is that we're now able to send a message from a source chain, have that data stored on destination and then have it propagated out to multiple different destination points on that chain, which can be super handy for if you need fast dispatch of data, for example, or if you're trying to move like price feeds or sensitive data that you need to update in multiple contracts all at once. I can share these actually after the chat too, if you guys dm me or I can put them on Twitter after. But basically from a high level, what you're able to do with layer zero is kind of up to your own discretion. You can move arbitrary data, have it move through multiple different chains, have recursion within layer zero where your receive logic calls another send call and continues to move messages across the blockchain. It's really interesting, the high level that you can kind of build out from here, and I think I might just cut off with that.
00:44:20.782 - 00:44:26.226, Speaker B: I got a little shorter on the time than I thought, but happy to answer any other questions that people have too.
00:44:26.328 - 00:44:42.230, Speaker A: Yeah, no worries. I kind of wanted to dial in on what you said at the very end. I think it's super helpful for people, especially beginners, to get an idea of use cases layer zero out in the wild just to frame.
00:44:43.530 - 00:44:56.106, Speaker B: Yeah, so really interesting. That actually came out this week. Boobar. Our buddy released clusters and clusters are built on top of layer zero right now.
00:44:56.208 - 00:44:57.210, Speaker A: Are you showing.
00:45:00.190 - 00:45:54.286, Speaker B: Actually jump? Let's jump to their site really quick. So clusters were super interesting in that they're built on top of layer zero, but they were trying to solve the problem of having namespace across multiple chains. So the main problem is that you have tons of different chains right where you're trying to get a consistent wallet address at. And the tricky thing is that with Ens, a lot of times it's like a bid per ens instance on each of the chains to try and get the chain name that belongs to you. With clusters, they basically built it as a way to store state about what wallets you own on every possible chain that layer zero supports. And so if we go in, let's see if we can find like FUBAR here. You can see FUBAR basically linked twelve different names on this account.
00:45:54.286 - 00:46:17.094, Speaker B: But the idea behind it is that now, instead of needing one wallet address per chain that you go to, this links all of your chain names under one common account. You're able to easily find your wallets that way. You're able easily send them to other people for transferring payments. Another one that's really interesting, that's built on top of layer zero.
00:46:17.212 - 00:46:28.780, Speaker C: Let's jump here really quick. Jump to 1 second here.
00:46:35.310 - 00:47:23.626, Speaker B: Yeah, this one we can jump over to radiant really quick. Yeah, radiant is a really interesting example too. Like being able to basically do cross chain borrowing and lending at the same time. So they use our oft standard as well for moving, I believe, between ETH and arbitrum. And kind of the idea is here that you're able to efficiently do bridging where you're just using the oft standard for moving assets. But the interesting thing is that they're able to kind of expand on this for if you wanted to do like cross chain lending and borrowing, you're able to have those contracts interact with an oft easily transfer assets to destination, chain lock on source lock on destination. Another interesting one that I can think of is like bitcoin b.
00:47:23.626 - 00:48:10.410, Speaker B: This was one of the abstractions built on, I think, avalanche subnets, but basically was a way to have a bitcoin, I think, derivative or asset built on top, that is omnichan. So being able to move this representation of bitcoin between multiple different chains, that layer zero supports and have that interact basically with common dexes lending protocols, you name it. So there is, I think at the moment a big push for DeFi because it makes sense being able to tap into other liquidity markets and other applications there. But I think the one thing I'd love to kind of see people explore it, like the hackathons that we do in the future and things like that is this kind of concept of data availability.
00:48:12.750 - 00:48:24.560, Speaker A: Awesome question about resources. Any resources for new coders? I think the concern everything you showed was like, wow, there's a lot of information.
00:48:25.970 - 00:48:39.460, Speaker B: Well, I think in general, if you're just talking about web3, I love the alchemy learn course. I think that was a great one that was built out and done really well. The guys at learn web3 dow, they're huge.
00:48:40.230 - 00:48:42.660, Speaker C: I can see if I can pull these up really quick.
00:48:45.110 - 00:49:18.480, Speaker B: And in terms of layer zero specific, there are a ton of new resources that are going to be coming out. I recommend our docs. I think the docs will be your best place to go to learn about everything layer zero related for the developer side and kind of making these more abstract ideas concrete. But if you want to just learn about kind of the whole space, I think there's a ton of really good free resources out there. There's another one called, what is it?
00:49:19.970 - 00:49:25.794, Speaker C: Web three boilerplates, I think web3.
00:49:25.832 - 00:49:58.860, Speaker B: Starter kits maybe, I think they have on their website. Yeah, this learn section. And you can go through courses, tutorials. Oh yeah, cypher updraft is really good. There's a ton of stuff you can jump into here. I think that's like if you're interested in development jumping through either, whatever you're passionate about. So whatever you find interesting to start and then probably like the most fundamental stuff that you can get that'll help you kind of make all these super advanced protocols or super advanced implementations a lot easier to understand.
00:50:00.830 - 00:50:08.190, Speaker A: Cool. Yeah, I guess probably it'd be really helpful to actually get the docs link. What is it? Docs? Layer zero.
00:50:08.260 - 00:50:19.634, Speaker B: Oh yeah, let's send that over right now. It is docs, layer zero network. I don't know if I can put anything in chat though right now.
00:50:19.832 - 00:50:39.000, Speaker A: I'll post it. Layer zero network. Sweet. Okay. To account for lag, I'm going to count down from ten and if there's no more questions I will let you go.
00:50:39.770 - 00:50:40.566, Speaker C: Awesome.
00:50:40.748 - 00:50:41.480, Speaker A: Cool.
00:50:42.830 - 00:50:43.194, Speaker C: Yeah.
00:50:43.232 - 00:50:45.514, Speaker B: Thanks so much for having me on. This was super fun.
00:50:45.632 - 00:50:49.350, Speaker A: Yeah. Oh, I guess. How do people get connected with you? You have like Twitter forecast?
00:50:49.430 - 00:50:53.310, Speaker B: Oh yeah, I am at uncrackable on Twitter.
00:50:54.050 - 00:50:59.070, Speaker A: Okay. You can send it in the private chat probably, and then I can just post.
00:50:59.140 - 00:51:00.400, Speaker C: Yeah, let me do that.
00:51:02.210 - 00:51:11.714, Speaker B: Yeah. And I will be at East Denver, so if you guys are planning on heading out there, feel free to reach out. Happy to kind of meet up in person and explain all this stuff too.
00:51:11.832 - 00:51:14.340, Speaker A: Are you guys sponsoring the hackathon at all?
00:51:15.430 - 00:51:20.566, Speaker B: Not this time, but we will be at some of like I think the side hacker houses. So stay tuned for that.
00:51:20.668 - 00:51:25.094, Speaker A: Okay, cool. Well, linear is so build with linear and layer zero.
00:51:25.292 - 00:51:28.842, Speaker B: Do it. You're going to have awesome projects that come out of it. For sure.
00:51:28.976 - 00:51:59.310, Speaker A: Yeah, absolutely. Okay, cool. I'm going to try counting again. Ten. 987-65-4321 okay, I think we accounted for lag, so thank you so much again. I guess if you want to get connected uncrackable on Twitter, you guys are going to be at East Denver floating around hackathons. And then what? Last piece, docs.
00:51:59.310 - 00:52:02.194, Speaker A: Layer zero network. Check it out.
00:52:02.232 - 00:52:02.622, Speaker C: Sweet.
00:52:02.686 - 00:52:07.780, Speaker B: Thank you, guys. And Emily, huge shout out for all the awesome stuff that you're doing with.
00:52:08.150 - 00:52:21.080, Speaker A: No, no, I just bring people on and amplify them. My catchphrase is linear is just block space. Secure block space. But layer zero is far more interesting.
00:52:21.530 - 00:52:24.854, Speaker B: Yeah, we're just multi chain or omnichan block space.
00:52:24.972 - 00:52:31.280, Speaker A: Yeah, that's okay. You're just more interesting. I guess what you can.
00:52:32.610 - 00:52:34.298, Speaker B: We're blockface with an accent.
00:52:34.394 - 00:52:45.162, Speaker A: Yes. And then eventually we'll actually land on use case. I'm just kidding. Okay, cool. Well, have a great rest of your day. Thanks so much for joining.
00:52:45.306 - 00:52:45.900, Speaker B: Yeah. See.
