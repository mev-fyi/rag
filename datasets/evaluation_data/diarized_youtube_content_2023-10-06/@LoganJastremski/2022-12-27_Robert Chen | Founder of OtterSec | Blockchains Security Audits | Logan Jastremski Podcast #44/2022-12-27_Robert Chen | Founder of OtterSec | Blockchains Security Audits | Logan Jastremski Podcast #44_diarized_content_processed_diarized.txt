00:00:01.080 - 00:00:23.490, Speaker A: Awesome. Well, welcome to the show, Robert. Thank you so much for coming on the podcast. I've been looking forward to this for quite some time. We've had to reschedule a couple times, so definitely appreciate your patience, but excited to have you on the podcast and hear all your words of wisdom. I'm a big admirer of what you do and so excited to have the chat.
00:00:24.030 - 00:00:25.390, Speaker B: Yeah, thanks for having me on.
00:00:25.470 - 00:00:51.240, Speaker A: The perfect. Well, I do think more broadly, you probably have one of the more interesting backgrounds and upbringing in crypto. And so id love to start the podcast just with how you got into crypto and your unique story from college to dropping out to going crypto full time.
00:00:51.980 - 00:01:33.958, Speaker B: Yeah, I think got into crypto because of a friend, started out with some mev stuff, and then gradually did more crypto security. So I think did some bug bounty stuff like that. And then earlier this year, early 2022, did a couple audits, and from there, kind of, I think once you do a few audits, you kind of get hooked. Right. I think people see what you can do and then it gets pretty easy to close next few. But I think once we did the first few, market conditions are also pretty good. Back then, it was still kind of the bull market.
00:01:33.958 - 00:01:36.330, Speaker B: Then just go from there.
00:01:37.910 - 00:01:45.290, Speaker A: Did you initially get in in the last 2020, 2022, or did you get in prior to that? In the last cycle?
00:01:47.210 - 00:02:04.470, Speaker B: I think late 2021, early 2022? Around then. Got in and then. Yeah. So just, I think just before or just after? I think the peak of the market. Right. The peak was around September or so.
00:02:06.010 - 00:02:15.460, Speaker A: Wild. And so you said you were doing Mev. Was that initially on ethereum? Solana avalanche. What change did you start on?
00:02:16.040 - 00:02:17.260, Speaker B: Slot, actually.
00:02:17.640 - 00:02:18.144, Speaker A: Okay.
00:02:18.192 - 00:02:33.664, Speaker B: I think, yeah. When I was looking at chains, I think EvM looked pretty crowded. It seemed like a lot of people were already building on there. I mean, I think the chain selection was relatively arbitrary. Right. There wasn't too much thought put into it. Yeah, I mean, Sauna seemed.
00:02:33.664 - 00:02:45.842, Speaker B: Seemed like there was less competition there. Seemed like it was a pretty cool chain. I also wanted to learn rust. Right. Like, I figured, worst case, if everything doesn't work out, at least I know rust now. Yeah.
00:02:46.026 - 00:03:05.864, Speaker A: That's awesome. So you got in through Mev, you started on Solana, and you started doing security audits. Could you talk a little bit more kind of about, like, did you, like, do hackathons? Did you discover a bug? Give us the background and all the context. Yeah.
00:03:05.912 - 00:03:42.090, Speaker B: So I guess the first really interesting bug we found was one against the Svana stable swap implementation. So that was with Sabre. They had like a rounding issue in their stable swap, which meant that you could extract one base unit of value each time you did a swap. So in other words, like when it was supposed to give you four tokens, instead give you five tokens. And these tokens are like the base, like atomic token values, not like real UI token values. So I think we did the math. In the end, it was only really profitable against bitcoin swaps.
00:03:42.090 - 00:04:16.640, Speaker B: But Sabre did have, I think, a couple million dollars of bitcoin swaps, or I think it was, I think it was like 74 million, or is some non trivial amount, and then if you do that, you can actually plausibly extract a decent amount of value. So, yeah, reported that to Sabre. I think we did the write up for that, and I think that's kind of what got a lot of that initial attention. I think that was probably one of the more interesting bugs that we found, actually, over the course of our time.
00:04:18.060 - 00:04:40.370, Speaker A: So maybe even backing up a little bit before finding some of these interesting bugs. You're in university, how did you get into kind of bug bounty and, like, finding these bugs? You were just studying computer science and you're like, one day you woke up and you're like, I want to find bugs in Solana smart contracts.
00:04:40.870 - 00:05:25.436, Speaker B: I guess I did a lot of security beforehand, so I guess for around one and a half years prior, I worked at a vulnerability research shop. So that's like finding bugs in specifically mobile devices, I guess I worked on the Android team, found bugs in Android devices, so like Chrome and other like, relatively hardened targets, I guess before that, or I guess concurrently a little bit before that. I also did a lot of bug bounties, so, like going to websites. So, for example, did a lot of work against GitHub because they have a really nice bug bounty program. It's fun. Like a number of interesting bugs on GitHub. So, like most, mostly web two stuff, and then saw that there was large hacks in web3.
00:05:25.436 - 00:05:42.240, Speaker B: And I mean, to be honest, it's not like that much more, it's not that much harder to have. I mean, you have companies in web3 pushing out code, which they haven't really spent that much time looking at, and decided to give it a shot.
00:05:43.340 - 00:06:04.552, Speaker A: Awesome. So ultimately you ended up dropping out of school. So could you kind of talk or walk us through that progression of, like, you find some bugs, maybe you build up some client base, and then ultimately you're like, all right, this is going well. I'm not going to do school anymore?
00:06:04.736 - 00:06:42.150, Speaker B: Yeah, definitely. I mean, I think it's pretty hard to be hard to divert your interest in two parts or pretty hard to focus on two things at once. Right? So even so, I guess my first or spring semester of 2022, I was doing it part time, like doing school part time and then doing this company part time. It was pretty hard to balance that out. So I figured I kind of wanted to just focus on one thing at a time, right? And it doesn't like if I really wanted to, I could always go back to school. Right? So it seems like there's not that much downsides dropping out. And I guess the company is going pretty well.
00:06:42.150 - 00:06:54.730, Speaker B: We had a decent amount of a relatively established client base. I figured I wouldn't be wasting my time if I dapped or dropped out. So it seemed pretty logical, decided to do it.
00:06:55.110 - 00:07:25.730, Speaker A: That's awesome, and congratulations. It's always a hard decision. I think I always admire kind of people's stories. It's hard to make the decision in the moment. But looking back on it, if you're successful, everybody will say it was easy and it was obvious, but at the point in time, it was definitely not. Obviously, definitely applaud you for making the jump. Could you talk a little bit about Ottersec and your company more holistically?
00:07:26.550 - 00:08:03.800, Speaker B: Yeah. So I think, I mean, at its core, we do smart contract audits, right? So we read code and we try to figure out what bugs exist in the code. I think that's like very high level overview, I guess. We also try to figure out patterns in code that people mess up on. So we try to figure out what are the recurring mistakes that people make. And also we try to figure out new mistakes, new bugs that exist both in people's code, but also maybe in their dependencies. For example, some of the interesting bugs we found are framework issues.
00:08:03.800 - 00:08:45.260, Speaker B: They use some portion of the SDK incorrectly, or maybe the SDK is even written incorrectly. And I think that's really about just having, like, our philosophy is really about having a deep understanding of the entire ecosystem, right? So not only the code that we're reading, but also all of its dependencies. And ideally, as deep as it goes, right? So ideally all the way down to, like, the VM run time. I think that's kind of where we try to focus our expertise. So, like the core protocol code, all the SDKs, and then the VM itself, you know, if you have a good understanding of that entire stack, I think you probably have a pretty good shot of finding all the bugs, or at least a very high percentage of the bugs that there do exist.
00:08:46.560 - 00:09:17.910, Speaker A: That makes sense, understanding all the dependencies you laid out? A couple, maybe. I think I always try to get technical people to explain things in a non technical way. How would you maybe just walking us through those again, how would you, at a high level or, and from your technical understanding, how would you explain kind of those, each levels of the stack that you must be core competencies to the honorsec team to a non technical person.
00:09:18.410 - 00:10:11.864, Speaker B: Yeah. So I guess, you know, you have a smart contract and it relies on some code, right? So usually you write your smart contract in some language, like for example, rustler move or solidity, and then it has dependencies which compile it down into, or I guess, which allow it to interact with the chain it runs on. For example, you probably have a compiler somewhere that turns your higher level code into bytecode that the chain can process. So for example, for Solana, they have their own LLVM implementation from move. They have their own compiler too. And then you also sometimes have framework code. So that's code that is written in the same language as your code, but is written by external library developers.
00:10:11.864 - 00:10:53.528, Speaker B: So someone else wrote it, other people use it too, which is the difference from your code, but it may or may not be secure, or there may be subtle issues when you try to use it. So I guess the general idea is that when you write code, you have your application and you write that code, but you're also bringing in probably tens of thousands of lines of code written by other people, and it's probably not possible to fully understand all that code. I guess the idea, or our thesis is that understanding as much of that as possible is probably going to let you find more interesting issues in the.
00:10:53.544 - 00:11:16.660, Speaker A: Code that you read out of those core components. What has your team found as the highest exploits or the highest number of exploits, and those dependencies or core competencies? Then what do you enjoy personally deep diving in those core competencies?
00:11:17.320 - 00:12:04.966, Speaker B: Yeah, that's a good question. I guess it differs between chains, I think, at least for newer chains, I think there's a lot of relatively easy denial of service area. So in the VM, it's usually easy, or it's usually possible to construct malicious byte code that will bring down the chain. And I think that's a function of a couple of things. One is that I think a lot of new chains, very heavily optimized, fast, cheap transactions. Right? Like one of the, one of the pitches is that we're going to make a blockchain that is very, very fast and very cheap for everyone to use. And the issue with that is in order to make fast, cheap transactions, you need to actually have cheap transactions, which means that someone could potentially, potentially, you're mispricing the compute cost.
00:12:04.966 - 00:12:35.240, Speaker B: Potentially, someone could spend like a dollar to force you to compute a, you know, 10 billion, 10 billion edition operations or something like that. Right. And at that point, you know, your chain goes down. Like, there's no feasible way for a computer to compute 10 billion additions, or actually, maybe additions is a bad example. But 10 billion non true operations in like ten milliseconds. Right. Like there, there is some fundamental compute requirements.
00:12:35.240 - 00:12:55.210, Speaker B: Yes. I mean, I also personally enjoy looking at that area a lot. I think. I really like looking at the virtual machine layer. So, like, processing bytecode, I think there's a lot of pretty interesting attack surface there. And it's interesting seeing also how different chains compare with each other.
00:12:55.550 - 00:13:16.166, Speaker A: Yeah, you touched upon two things there. How, in your opinion, kind of you said, like, the newer chains, and what, in your mind are these newer chains and how do they compare to older or legacy chains? Let's start there, and then we'll get into the virtual machines, because I also really like virtual machines as well.
00:13:16.358 - 00:13:38.360, Speaker B: Yeah. I guess the newest one, probably, that we've worked with would be apps. I think they launched a couple months ago. I think suite is also launching pretty soon. They'll be the newest one in a bit. I guess Solana, I think, is comparatively, or actually, I think Solana is relatively old. I guess it's like comparatively new compared to some EVM.
00:13:38.360 - 00:13:45.100, Speaker B: Like Ethereum. Yeah, I guess off the top of my head, probably just be aptos and sweet.
00:13:46.120 - 00:14:01.300, Speaker A: And how would you kind of compare? I guess being very, having done a lot of work on Solana, starting to do some work on aptos. And have you audited smart contracts on Sui as well?
00:14:02.220 - 00:14:03.880, Speaker B: Not yet, but we're talking.
00:14:04.820 - 00:14:28.990, Speaker A: Okay, well, then, comparing Solana and Aptos, what are some of the biggest things that you've seen? One, from, just like, the core code itself for the layer one and then two, how the code compares when evaluating more rust to a move programming language.
00:14:29.690 - 00:14:56.000, Speaker B: Yeah. So I think both Aptos and Solana are written in rust. So both the core layer one code is written in rust. When you write smart contracts on them, you write into different languages. But the core layer one code is relatively similar, I think for Appos, they're a bit newer. I guess we did find more denial of service issues, I believe. I think the core code is pretty solid.
00:14:56.000 - 00:15:51.468, Speaker B: I think both Athos and Sauna are pretty great teams to work with. Not too many complaints there, I guess, in terms of the layer one code move versus sauna ruff, I think overall we seem to find less recurring issues with move when we do move audits. So I guess something pretty interesting. Yeah, like when we do move audits, most of the issues that we find are going are probably application specific. So issues with the business logic, they messed up some calculation somewhere, but usually they're not recurring issues. Like sometimes you see on Solana, there's no reentrancy vulnerability class, or there's no missed checks of account information like we see on Solana a lot. Yeah, I think at least initially.
00:15:51.468 - 00:16:06.000, Speaker B: So I think eventually we'll find some sort of like, recurring issue, at least initially. It seems like move seems to be a safer language, or I guess more accurately, people seem to write safer smart contracts when they use move.
00:16:06.740 - 00:16:21.380, Speaker A: That makes sense. Could you compare kind of Ross Solana to move or like the non technical people and why you were seeing less kind of security vulnerabilities when contracts are written in move?
00:16:21.920 - 00:17:20.461, Speaker B: Yes, I think move is much higher level language. I guess the typical flow for a spawn rush program is they get input data in the form of byte arrays, so unstructured bytes or unstructured data, and then they run some deserialization on that data. So they have to first parse it out into data structures that the program understands. Then it does some sort of manipulation of those data structures, and then it writes it back into memory versus move. You just get past this high level struct immediately. So you don't need to do any of that deserialization that's already handled for you by the VM, and then you can just operate directly on those data structures, and then you get past a pointer or a reference, so those changes also automatically persist into memory. So you don't need to worry about serializing, you don't need to worry about any issues of potentially serializing the data wrong or double serializing it twice or something like that.
00:17:20.461 - 00:17:35.969, Speaker B: There's overall less attack surface. I mean, I guess, I think move is somewhat comparable to anchor in Solana, where it's a high level interface, which abstracts out a lot of the, I guess, more tedious parts of the smart contract writing.
00:17:38.560 - 00:17:57.060, Speaker A: Makes a lot of sense. Have you seen once the teams on Solana that use anchor, do they have, in general, less problems with their code from a security standpoint, from just like basic Solana rust?
00:17:57.680 - 00:18:23.710, Speaker B: Definitely. I think we strongly prefer to audit teams who use anchor. Out of the teams we've audited, I believe only one has not used, or I guess in the past few months, probably like one or two haven't used anchor. I think. Yeah. Writing code in anchor makes it much less likely to have vulnerabilities. I guess the issue with anchor is there's still a number of.
00:18:23.710 - 00:18:53.988, Speaker B: Okay, so there's a couple issues, and actually there's an anchor rewrite happening. So I don't think these issues are unsolvable. I think that eventually they will be solved. I guess the issue. There are a couple issues with the current implementation of anchor. I think one is that there's always a way to use unsafe accounts. So there's this thing called remaining accounts on anchor, and you can always fall back to the unsafe mode.
00:18:53.988 - 00:19:42.514, Speaker B: I guess you can always decide that you're going to write out the parsing yourself. So because there's that fallback, some people use it and some people don't fully understand the implications and shooting themselves in the foot. I think also just this notion of accounts is relatively hard to reason about, where you have lots of different resources or lots of different data that you need to enforce relationships between. Right. So, for example, if you have like, a lending protocol and a user position, you need to enforce that. The user position belongs to that lending protocol, and that needs to be an explicit check somewhere in the code. But a lot of people don't verify that or they sometimes miss that verification.
00:19:42.514 - 00:20:24.294, Speaker B: I think there's, I'd estimate maybe like ten to 20% of the bug that we find are due to that, you know, missing relationship check between two critical pieces of data. And, yeah, it's pretty hard to catch that all the time. And I think that's, I guess the way you would solve that is, and I think this is happening in the right is you would define that relationship at creation time. So you would define that the position must always belong to a lending market, and more specifically, it must always belong to this particular lending market. And then when you pass in the lending market, you just automatically associate the two. And I think that solves a lot.
00:20:24.302 - 00:21:11.920, Speaker A: Of these issues out of kind of. Well, I think you've answered the first one. Solana Russ, to anchor versus kind of now move. What is your kind of personal favorite to actually, maybe a better question is what do you think the end game is? Because we're now getting into different levels of abstraction. Solana Rust, very basic, but a lot of freedoms. Armani building on top of that with anchor and now move being the next iteration how, in your opinion, does it continue to evolve?
00:21:12.420 - 00:21:49.706, Speaker B: Yeah, I mean, I think move is a pretty good close to endgame, I would imagine. I think my only complaints with move are it's a bit clunky to work around with. For example, they don't have dynamic dispatch. So all your calls must be defined at compilation time, which means that it can be harder to write, for example, arbitrary flashback programs or you have less guarantees when you write those kinds of programs. I think something move like where you have like a very high level language with resources that you're like. The user should never have to worry about. Deserialization, for example.
00:21:49.706 - 00:21:56.790, Speaker B: Right. A higher level language like that. I think SlaN is also considering porting move.
00:21:57.770 - 00:21:59.778, Speaker A: It is, yeah.
00:21:59.794 - 00:22:05.750, Speaker B: I'm not sure how far along they are with that, but I heard there's some progress being made in that front.
00:22:06.100 - 00:22:23.220, Speaker A: Yeah, it would be definitely interesting to see if move kind of becomes the de facto standard out of all these high performance chains. Have you ever interacted with Ethereum smart contracts or do Ethereum audits?
00:22:23.380 - 00:22:31.400, Speaker B: Yeah, we do a couple. I'm not as familiar, but I do have some level of understanding there.
00:22:32.110 - 00:22:46.870, Speaker A: And why is it just like the team wasn't as interested or you want to develop more of a deep technical understanding and kind of these newer chains? I'm curious, why not Ethereum?
00:22:47.030 - 00:23:18.820, Speaker B: Yeah, I think we wanted to, I guess focus on what we're doing first. So I wanted to make sure that we could do a really good job there first before even considering moving on to other chains. I think now focusing a lot on move, making sure we can do a good job there as well. I think Ethereum is actually pretty interesting. It's a very old ecosystem and there's a lot of nuances that you have to understand when you're doing automotive there. I think that part is pretty cool. For example, all the token contracts and all the differences between.
00:23:18.820 - 00:23:46.386, Speaker B: Subtle differences between each token contract. I think that, for example, is really cool. Also the bytecode, it's also pretty interesting. There's like a whole. Because EVM gas is so expensive, right? Or Ethereum gas is so expensive. So there's this whole group of people, or subset of people who are devoting themselves to golfing bytecode, right? Which I think is pretty fun. I mean, I think there is a lot of interesting stuff to explore in Ethereum.
00:23:46.386 - 00:23:51.470, Speaker B: Just in the past, haven't really had the time and just starting to do that a little bit now.
00:23:51.980 - 00:24:24.690, Speaker A: That makes sense, maybe on that topic, let's talk about virtual machines. There's the Ethereum virtual machine, which is single threaded. And then we have the newer, more modern virtual machines being parallel processing with flana and aptos. Could you talk from your technical expertise to maybe each of them and compare and contrast them and then we'll get into how you would compare and contrast them from a security standpoint?
00:24:25.710 - 00:24:52.192, Speaker B: Yeah, I guess they're all different. They all have their own byte code, I guess. For example, Solana's BPf, Ethereum has its own bytecode move aptIs. We both run the move virtual machine. They both run on, I guess, a comparatively higher level bytecode. So I guess that's probably the main difference. I think Ethereum, EVM and Sauna both operate on relatively low levels.
00:24:52.192 - 00:25:19.070, Speaker B: They have a stack machine and they are, I guess Ethereum has a stack machine. Sauna has BPF, which is registers in memory. So they both operate on very primitive structures, just like registers, unstructured data versus move. You have vectors or structs at the bytecode level itself, which I think is pretty interesting.
00:25:20.730 - 00:25:23.430, Speaker A: Interesting in what aspect?
00:25:24.170 - 00:26:01.970, Speaker B: I guess it's different, at least as far as I'm aware. I think move is one of the first crypto blockchains to have a higher level bytecode or such a high level bytecode. I think there's pros and cons there. I guess pros are you can have a much more succinct bytecode format like you don't need to. I think, for example, move binaries or move programs are a lot smaller than slaughter programs. You don't need to spend all this time sterilizing, deserializing stuff. Vector operations are a single bytecode instruction.
00:26:01.970 - 00:26:37.910, Speaker B: I guess the downside is I think it moves a lot of that complexity into the virtual machine itself. So if there are bugs, there's a good chance that it might be in the virtual machine, which means that it would affect everyone. I guess the counterpart to that is I think these chains need to, and I think they do actually after this, has been spending a lot of effort into this. They spend more effort making sure that the VM is actually secure.
00:26:39.970 - 00:26:52.430, Speaker A: I guess by not having a secure Vm. What are the downsides of if someone was to develop or exploit a vulnerability there?
00:26:52.850 - 00:27:19.310, Speaker B: Yeah, so I mean, every program depends on the VM. We talked a little bit about these dependency chains. I mean every program would depend on the VM. So if you had a bug in the VM, you could theoretically use that to, you know, to exploit any program. So I mean, depending on the bug, depending on the implications. But I think there are plausible exploit scenarios where you could, you know, exploit the entire chain, which would be pretty bad.
00:27:20.450 - 00:27:55.340, Speaker A: Yeah, maybe going back to Ethereum real quick. Ethereum was the first to ultimately add smart contracts, and I always applaud them for doing that. I think on the virtual machine side, it's been interesting that they started with, I mean, I think because they were the first, they started with a more simplistic virtual machine being single threaded. Could you talk about the differences in your point of view from only doing transactions with a single threaded virtual machine to a virtual machine that can do parallel processing?
00:27:56.190 - 00:28:24.716, Speaker B: Yes. I'm not super familiar here, but at least from my understanding, I think the main constraint is explicitly specifying data dependencies. So, for example, on Solana, you have to pass in all the accounts, and that's the only data that you can ever access in that particular execution versus Ethereum, you just call a contract. They can call whatever contract they want. They have arbitrary dynamic dispatch. You can load data from anywhere. Ethereum is pretty easy to single thread because you specify the data dependencies.
00:28:24.716 - 00:28:49.384, Speaker B: You can, I guess, like programs with differing data dependencies. Don't need to, can be ran, can be ran in parallel. Right. You know, if you have a program that only accesses in this coin versus another program that only accesses this other coin, you can run them completely in parallel. You don't need to worry about any sort of conflict. I think this is similar. I believe Solana is similar to sweat.
00:28:49.384 - 00:30:00.486, Speaker B: I think SuI actually has a slightly different consensus model. But Sui also has explicit data dependencies that you pass in after this uses something interesting called blocksTM, which I'm only vaguely familiar with. I think the idea is you run transactions, and then on conflict, you roll back the transaction, which I think is pretty interesting. It means that you don't need to explicitly specify these data dependencies, which I think actually is a reasonable cause. Or it's like part of the reason why people mess up, or it's like going back to the vulnerability classes on SLAA. A lot of that is because people inaccurately specify those data dependencies they pass into accounts, and they don't properly ensure the relationship, the relationship between the two. I think Aptos has this interesting model where they just say, we're going to run all the transactions, and then we're going to figure out the conflicts, and then hopefully there aren't that many conflicts, and then we'll try again after all the conflicts, which I think is fine, it seems, I don't know if it's been tested in Maine, actually, I believe they had NFT mints with thousands of tps and it seemed to go fine.
00:30:00.486 - 00:30:06.610, Speaker B: So it seems to, it probably seems to work. Yeah, it probably seems to work decently.
00:30:07.840 - 00:30:33.740, Speaker A: It is interesting how both Solana and SWE are using stating contracts upfront and then Aptos using block STM to run those. And then if they can't run in parallel, then they just rerun them serially. Do you have a preference or do you think from a performance standpoint one is better than the other?
00:30:36.420 - 00:31:26.336, Speaker B: Well, I think explicitly specifying your data dependencies is probably going to be more performant because you don't ever have to rerun anything. You have all the information at the start. You know exactly what data this transaction can touch. I guess on the flip side, I think it's also probably less secure because I think at least in the past, people seem to mess up specifying that a lot. Or it's like when you have to explicitly specify everything, it's harder to ensure the relationship between everything that you're specifying versus. I think Aptos has pretty clean patterns in terms of passing in data. So, for example, one common pattern on aptos is you'd pass in the address and then you would load the structure from that.
00:31:26.336 - 00:31:54.108, Speaker B: Um, so, so this way you can, um, there's no way to mess it up, right. Like you only pass in this address and then the only structure that you can load is from that pass in address. Right. It's very hard to make a coding mistake there versus if you pass in like a structure or some piece of data, and then you also pass in the address and you have to like manually check that the data belongs to the address. That's like potentially missing checks somewhere that you manually ensure every time.
00:31:54.164 - 00:32:23.710, Speaker A: I. Yeah, the virtual machines are super interesting, maybe going from just comparing and contrasting them to talking about the different security functionalities from your point of view. I know you haven't done too many security audits on SWE, but from Solana Aptos, because they each have their own flavor of virtual machines. What have you seen from the security side?
00:32:25.220 - 00:32:37.000, Speaker B: Yeah, I guess there's two separate parts. One would be the virtual machine itself, and then the other would be apps building on a virtual machine. So I guess. Which one are you asking about?
00:32:38.060 - 00:32:49.716, Speaker A: Let's do the virtual machine itself and compare those from the security. And then I do want to get into applications building on the virtual machines as well.
00:32:49.868 - 00:33:29.890, Speaker B: Yeah. So I think Appis and sie use similar virtual machines. They both use move Sui has its own fork and they remove functionality and they also add more functionality. But I think overall, sweet probably has more attack surface. I guess the parts they remove are related to. So Sweet has its own storage model, and the parts they remove are related to storage access in the move virtual machine. So, like borrow Global, I guess for anyone who's technically minded, like borrow global or global view, like those, those instructions are actually explicitly disallowed in the sub virtual machine.
00:33:29.890 - 00:34:07.200, Speaker B: But I think, you know, most of the attack surface remains probably the same, I think, compared to slot, at least. I mean, slot has a relatively simple BPF interpreter. Actually, if you look at the code, it's basically just like a single loop. It's like a big for loop or a big while loop, and then there's a big switch statement, and then each switch statement, just like, you know, operates on some registers. Or I guess that's the, that's the interpreter branch. They also have a just in time so JIt compiled version, which I think does introduce more tax surface. But, yeah, I think Solana is pretty simple.
00:34:07.200 - 00:34:23.250, Speaker B: Yes. I think Apple's and sui have a more complicated virtual machine, and as a consequence, they probably have more attack surface. And at least there seems to be more bugs, at least from what we've seen.
00:34:24.470 - 00:34:30.610, Speaker A: So how does that then translate to applications building on each of these virtual machines?
00:34:30.910 - 00:35:11.206, Speaker B: Yes, I guess the converse is probably true. Right? I think if there's more bugs in the virtual machine, hopefully that means just let's bug some applications or else, you know, worse off. Worse off for everyone. But I guess the way I think about it is you have bugs and they're going to probably appear somewhere. And I guess in this case, Apple, since we decided we're going to make them appear in the VM, and hopefully we'll be within a constituted effort to patch all those issues. Right, versus Solana opted for a simpler virtual machine where I guess they don't have the hindsight of, you know, all this, of the past three years of smart contract development or so. So I don't think it's their fault per se, but they have a simpler virtual machine.
00:35:11.206 - 00:35:41.224, Speaker B: And then I think as a consequence, applications which are writing code on Solana tend to have more issues. Or. This is definitely true if you use the Solana Rust SDK or the Solana C SDK. Yeah, definitely if you use the CSDK. Thankfully, we haven't had to audit that many c contracts. Probably still true if you use anchor, although not as much makes sense.
00:35:41.312 - 00:36:10.920, Speaker A: Yeah, it's all fascinating. It's kind of moving the problem from one point to another, and who will bear that burden going forward? What is your take on, how can we say, automate these things? How can we overall just make programming in web3 more simplistic and bring in more web tube devs?
00:36:12.140 - 00:37:04.472, Speaker B: Yeah, that's a good question. I guess automation is an interesting question because I think, at least from our perspective, the point of automation is to get rid of dumb bugs, right? Like you shouldn't be making the same bugs again and again. And automation is really great at detecting these recurring issues when you're programmed. So I think there's two ways. Like one, you could write a tool to find these bugs, right? You could find, write some sort of static analyzer to detect missing checks. Or you can write your, or you can write like a framework that makes it harder to write these bugs in the first place, right? So for example, with anchor on Solana, you don't need to do all these account checks anymore, you don't need to do as many account checks, and that eliminates a whole bug class. It could also be detected through static analysis.
00:37:04.472 - 00:37:54.310, Speaker B: But I think the better way, or the more productive way is to really just write a framework to make it structurally safer language, to make it harder to make these mistakes. And I guess it seems to me at least that in order to get more people to use these languages, you kind of need to make the languages safer, right? Like you can't really convince Web two developers to pick up web3 if there's a 25% chance that they're going to lose all their money if they write code in this language. I just think that's kind of unacceptable, or it's very hard to make that pitch. It's very hard to tell them that. If you want to write a smart contract, you better study for three months or six months or twelve years before you write any code, or else there's a good chance that you're going to screw something up really badly.
00:37:54.970 - 00:38:04.030, Speaker A: So that's kind of headed towards something like move or kind of removing those complexities overall.
00:38:04.410 - 00:38:39.360, Speaker B: Yeah. So actually I have a blog post that I wrote on move. Well, I think, I guess move is like the best example of such a language right now, but I do think that there are, I do think other languages will become more like it. Yeah, I think I call it like structurally safer languages in the blog post, you know, languages that remove entire vulnerability classes that make it, that remove like these entire swaths of dumb mistakes that programmers repeatedly make. I think those languages will come out on top eventually.
00:38:40.100 - 00:38:58.640, Speaker A: Definitely makes sense if you can eliminate it altogether from developers. Purview definitely would push this face forward. What are your thoughts around formal verification of smart contracts at the base layer?
00:38:59.700 - 00:39:47.420, Speaker B: Yes, I think formal verification is a really nice buzzword. I think it has uses. I guess to be clear, formal verification is just the formalization of certain properties of code, right. It's saying that we can use some sort of, sure, we can use some sort of program to prove that this condition is always true or that this property is always true. But the issue is like the properties that you're proving have to be very formulaic, right? So you can't really prove, for example, or it's very hard to prove, for example, that a lending protocol or like a swap never loses money. Because, for example, you probably should lose money if someone withdraws funds. If someone's trying to withdraw money from a lending protocol, the lending protocol probably should be losing money.
00:39:47.420 - 00:40:07.322, Speaker B: I guess you could. At its core, it's very hard to think about what you're actually trying to prove. There are actually instances where, you know, people formally verify contracts and there, it still gets hacked. Right. Because. Well, I think. I think they tend to get hacked less.
00:40:07.322 - 00:40:42.058, Speaker B: But, you know, you could prove the wrong thing, or you could prove something wrong, or there could be even, there could be a bug in the VM or there could be a bug in your proof engine, all of which, you know, aren't really covered. I mean, I do think formal verification is generally useful. I think it probably eliminates certain classes of vulnerabilities. I don't think it's 100% security. I think a lot of people say formal verification as gold standard. Your contracts will be 100% secure. I would say it's probably more like 99%.
00:40:42.058 - 00:40:50.510, Speaker B: I think it's pretty good. I think it's probably better than just doing an audit. But I don't think it's possible to get 100% security.
00:40:51.140 - 00:41:16.116, Speaker A: Makes sense. Yeah. Always hard to hit that mythical 100%. Always a challenge. How do you think about. So I think the last couple of years have been interesting, to say the least. Some of the biggest things that emerge were bridge attacks and exploitations in bridge code.
00:41:16.116 - 00:41:27.340, Speaker A: Why does it seem like bridges more holistically are targeted from the security standpoint or have been victims to these thefts?
00:41:28.000 - 00:42:12.380, Speaker B: Yeah, I think the main thing is that bridges are really hard to do properly. I think when you write a bridge, your engineers need to have a strong understanding of dozens of chains or however many chains you deploy your bridge on. Your engineers need to have a strong understanding of each of those chains versus if you write a lighting protocol or swap, you only need to master one chain. You only need to understand the nuances of one chain. So I think that diversity of environments is what really makes bridges hard. When you deploy on Solana versus when you deploy on Ethereum versus when you deploy on Polkadot, all those chains are completely different. It's very hard to understand all those nuances when you write code for them.
00:42:12.380 - 00:42:51.532, Speaker B: And I think a lot of bridges didn't fully understand that, or they were pushing code too fast and then they missed something and they lost all their money there. I guess also, it seems that a lot of people actually, I should probably double check this, but it seems like a tv. All of bridges is generally higher than other programs. It seems like more people put money into bridges when they're moving assets, cost chain. So, yeah, it seems like they also, like when they do get hacked, more people notice because it's such a big number.
00:42:51.716 - 00:43:14.790, Speaker A: Do you feel like bridges ever will iron out all the bottlenecks that exist today or properties that allow these hacks to occur to. So the code will harden over time where we'll read less about these? Or do you think this is a continued problem that will surface again and again?
00:43:15.770 - 00:43:35.170, Speaker B: Yeah, I definitely think they'll. I think. I definitely think it'll go down. Right. I mean, I think bridges can basically only get hacked once, right? There was only one bridge that has been hacked or has been hacked. It has not immediately died. But I definitely do think that, you know, you can't lose $320 million twice, right? I think.
00:43:35.170 - 00:44:17.470, Speaker B: I think these bridges do recognize this and they are making efforts, right? Like, at least the bridges that we work with, it seems like they are very security conscious now. Rightfully so. And I guess as long as you aren't pushing more code, right. Like, if you're just staying on the same chains intuitively, you know, you probably can't mess up that badge, right? I think when you start pushing new code, that's when it gets a little bit more interesting. But at the same time, there are mitigations in place that I think bridges are exploring that makes it less likely that there will be these catastrophic hacks moving forward.
00:44:19.170 - 00:44:58.720, Speaker A: Yeah, I hope so. No more hacks. I know they'll continue to occur and we'll never or hopefully trend down in the number of attacks that occur yearly. But, yeah, always not fun seeing those big numbers appear on such and such chain got hacked. Yeah. So you spend the vast majority of your time pretty much all day coming through these different smart contracts and different ecosystems. And you've seen a lot of kind of common mistakes that these engineers make.
00:44:58.720 - 00:45:16.360, Speaker A: If you could talk with like, or give a talk on kind of security and best practices, what would you tell to engineers about security and how to think about it more broadly when they're writing these smart contracts?
00:45:16.740 - 00:46:08.266, Speaker B: Yeah, I mean, I guess probably the best tip that I would give is just give yourself more time to read the code yourself. Right. I mean, to be honest, I think writing comprehensive tests will get you very, very far right. Covering thinking about all the possibilities or trying to think about all the possibilities, and writing test cases to cover them in all the different scenarios is probably going to cover, I'd say, 50% of vulnerabilities that we find. It's kind of amazing how many times you get code bases that are clearly untested that was going to get pushed to production, but thankfully did not. Yeah, I mean, I think just thinking closely about what the edge cases are like. For example, if you have a swap program, what if someone tries to swap millions of dollars through, or like, writing a test case for that is probably a good idea just to make sure you have that covered.
00:46:08.266 - 00:46:32.270, Speaker B: What if someone tries to swap like the minimum amount through? Or what if someone tries to swap zero tokens through? Like if they swap zero tokens, hopefully they get zero tokens back. Right. Which was not true for some programs. Yeah. So, yeah, just writing comprehensive tests, I think is probably in giving yourself more time to write those tests, like an extra two weeks after your, after your code is finalized is probably good.
00:46:33.490 - 00:47:18.830, Speaker A: Yeah, definitely good words of wisdom there. I guess you personally wouldn't be surprised, but I think the list on nurse would be surprised by how quickly, I mean, the space moves. And because of that, people wanting to just get code to production as soon as possible, which can sometimes be good and sometimes very badly. Yeah. Awesome, man. How maybe in your experience, are there any common exploits that come up more often than not or things that you recurringly find?
00:47:20.210 - 00:47:49.680, Speaker B: I think those are probably chain and protocol specific, so. Chain specific. I think there's issues that come up for chain, like Solana account issues, like reentrancy, for example. I think there's also protocol specific issues, for example, lending protocols, they often mess up, for example, flash zones. Right. They might mess up the implementation there, I guess. Yeah, I guess move flash zones specifically.
00:47:49.680 - 00:48:07.920, Speaker B: These sometimes get messed up, but I don't know if there's a broad thing that applies to every chain, every protocol. I'm not sure. Yeah, I don't think there's any super broad vulnerability classes like that.
00:48:11.890 - 00:48:44.230, Speaker A: That makes sense. Interesting. Maybe going forward, I think web3 more broadly is idealistic around self custody. What are your thoughts on self custody of assets and people owning their assets? Do you think that's. Yeah, I guess, like kind of. What are your opinions and what are, like, your point of view on that going forward?
00:48:45.370 - 00:49:15.670, Speaker B: Yeah, I mean, it seems, it seems ideal. I guess it also feels hard to onboard people if we have, you know, if we force everyone to learn all this private key, public key stuff. Right. I feel like at least for non technical web two people, it seems pretty hard to justify, like, oh, you should. You have to learn all this stuff in order to use this new application. Right. It just seems like a very hard sell or like a very high barrier to entry.
00:49:15.670 - 00:49:47.972, Speaker B: I mean, I think self custody in the ideal world is great. I guess it also opens up, like, if you self custody, you also take responsibility for it. Right. So if you lose it, it's on you, which, I mean, maybe for a couple thousand dollars it's fine. But like, even I wouldn't really trust myself to self custody, you know, tens of millions of dollars. I'd rather it be FDIC insured somewhere, you know, in the bank. Yeah.
00:49:48.036 - 00:50:32.470, Speaker A: It's definitely interesting to watch how the space will continue to evolve and engineers hopefully will continue to abstract some of those complexities. But at the end of the day, if you're self custodying, you're self custodying. So I hope there's better solutions going forward, and I'm definitely watching those closely. Maybe since you have kind of. This was like your first fight cycle in crypto, what were your thoughts of the last year, two years, and the ecosystem? Anything that surprised you, anything that caught you, got off guard or. What were your thoughts the last couple of years?
00:50:33.050 - 00:50:58.980, Speaker B: Yeah, it seems like there's still a lot of activity in crypto. I guess I was a little bit cynical. I thought everyone would have left by now after, after the markets crashed, I think, after FTX crashed. Right. I think that was really, really big for everyone. I know lots of, lots of my friends personally, too, lost a lot of money. But I mean, it seems like they're very resilient still.
00:50:58.980 - 00:51:12.520, Speaker B: Seems like they're still building, which is really exciting. I mean. Yeah, I think hopefully we'll be here for a while. Hopefully there's no more FTX like, like caches.
00:51:12.980 - 00:52:15.180, Speaker A: I agree. They're not fun. Yeah. Last couple I joined in 2017, kind of in the ICO boom, and learned a lot in that kind of bear market, and so definitely took a lot of learning lessons to this last kind of cycle. What is your kind of opinion on whether, I guess today web3 more broadly doesn't have too many users? We're starting to onboard more engineers and I think a lot of that is due to these upcoming simplicities with smart contract languages and developers being able to write better apps. What do you think is needed to onboard 10 million users, 100 million users into the ecosystem? Is those more engineering? Is it better layer ones? Is it better applications? Is it all three?
00:52:15.520 - 00:52:33.104, Speaker B: Yeah, I think it's more on the application side, I think. Well, I guess a couple things. I feel like there needs to be a non technical way for users to join. Even installing chrome extension is a bit much. I feel like generating keyphrase. Definitely. It's extremely opaque.
00:52:33.104 - 00:53:02.350, Speaker B: What this stuff actually means to someone who's non technical. I think some sort of better interface, like if you get on board with a credit card or a debit card. I think that would be ideal. I think also more genuine use cases. I think a lot of crypto applications right now are very financialized. I mean, they're essentially just financial games for people to play. But I don't know if there's a huge amount of utility for someone who's a.
00:53:02.350 - 00:53:27.432, Speaker B: A normal web two user. There's no. Yeah, it seems hard, like if you're not here to make money, like all of defi becomes kind of pointless, right? I mean, like all of Defi is like trading money around. And I just don't think. I think that appeals to some people. I think that subset is pretty limited. Yeah, not, I think.
00:53:27.432 - 00:53:43.180, Speaker B: I guess gaming seems to be a pretty big thesis that people have. Seems like a lot of l one sdhe especially, are trying to get more games onboarded. So I think that seems pretty promising. Yeah. Maybe some other application that just generally appeals to normal users.
00:53:44.200 - 00:54:01.558, Speaker A: Is there any specific ecosystem that you're looking forward to the most for? I'd say in general, just in usage and personally with the company, um, particular ecosystem?
00:54:01.654 - 00:54:07.950, Speaker B: I'm not super sure right now. I mean, I think. I guess. Are you talking about chain or like game?
00:54:08.070 - 00:54:15.010, Speaker A: Yeah, chain. If you had to pick a favorite child?
00:54:15.430 - 00:54:43.526, Speaker B: Pick a favorite child, yeah. I'm not super sure. I think. I think each ecosystem seems to be doing different things well, I guess I think different ecosystems claim to be better at different things. I haven't like, looked too deeply into them. Right. So, I mean, you know, for example, I think the move chains seem to claim that they've got a lot of gaming interest which seems pretty nice.
00:54:43.526 - 00:55:02.686, Speaker B: I think Solana also mentioned some of that, although, like, to be honest, I haven't looked too deeply into, like, whether these claims are true or nothing. Yeah, I mean, I'm not super sure. I guess we'll kind of have to wait and see to see which one ends up on top. Right?
00:55:02.878 - 00:55:18.890, Speaker A: Yeah, it's definitely interesting as a company, how big is your team now and then? Kind of. What are some of your big goals for the next year or so?
00:55:19.610 - 00:55:50.360, Speaker B: Yeah, I think we have around 20 people now and then hoping to. Yeah, I mean, hoping to survive this bear market and. Yeah, we'll see. I mean, I think we're trying to certify relationships in the existing chains that we work on and maybe consider exploring a little bit into other chains, although not really as actively. Yeah, I think just doing, continuing to do well at what we already do, hopefully.
00:55:51.060 - 00:56:03.560, Speaker A: I like it. What would you describe otter sex like vision? When you talk with the team or talk about bringing new people on board, what is your big selling point to them?
00:56:04.580 - 00:56:27.700, Speaker B: Yeah, I think we have a lot of really smart people. I think we do cool work. We try to dig deep into places that other people haven't really looked at and. Yeah. Hopefully build a tight knit team, hopefully build a pre, you know, a really strong understanding of these ecosystems and then use that to find interesting bugs.
00:56:28.240 - 00:56:44.850, Speaker A: Nice. Maybe just kind of wrapping it up. What are some, like war stories that you had finding some of these interesting bugs? You don't have to name names, but interesting bugs that you and the team have found?
00:56:45.630 - 00:57:06.172, Speaker B: Yeah, I mean, actually, most of them, we try to be pretty public with them. Most of them are, I think, on our blog post. On our blog. So go there. You can find a couple. I guess there's a couple that we haven't published, mainly out of respect for our clients. I think sometimes we find issues that are pretty big.
00:57:06.172 - 00:57:11.856, Speaker B: Our clients prefer not to publish the audit report, which is okay. I mean, it's their choice.
00:57:11.888 - 00:57:15.064, Speaker A: Are these on Mainnet or are they still like Testnet?
00:57:15.232 - 00:57:25.940, Speaker B: Oh, definitely mainnet. Yeah. I mean, if it's. I think it's tough that people don't really care, but I think there's a couple mainnet programs which probably should not happen on Mainnet.
00:57:26.360 - 00:57:28.368, Speaker A: Hopefully those get patched pretty quickly.
00:57:28.504 - 00:57:29.540, Speaker B: Yeah, of course.
00:57:30.000 - 00:57:31.140, Speaker A: Okay, good.
00:57:31.560 - 00:57:36.960, Speaker B: Those are teams you work with? Are. Yeah. They're not trying to rug people. Right. They just, they push code a bit too fast.
00:57:38.420 - 00:58:22.480, Speaker A: Definitely makes sense. Yeah. Now it's, it's, it's amazing to watch the industry. It's really cool to be able to see people like yourself and Autosec team step up to kind of fill a gap in the ecosystem that is desperately needed in such a fast growing industry. And so definitely applaud your team for doing so. Taking the hard jump of kind of leaving college and deciding to do your own thing. It's not easy, but no, just appreciate what you do for all these different ecosystems and helping keep our application safe.
00:58:22.480 - 00:58:28.890, Speaker A: Hard work, but everybody appreciates it.
00:58:29.790 - 00:58:32.086, Speaker B: Yeah. Thank you. Thanks for having us on.
00:58:32.278 - 00:58:42.110, Speaker A: Yeah, yeah, thanks again. Where can people find you? Maybe plug your blog post so people can go read about all the hacks that you've discovered and.
00:58:42.270 - 00:58:50.070, Speaker B: Yeah, yeah, I think it's OSeC IO blog or it's just on our website. I'm not sure if you can link it somewhere.
00:58:50.230 - 00:58:51.844, Speaker A: I can put it in the show notes.
00:58:52.022 - 00:59:07.060, Speaker B: Yeah. Oscillation blog. Yeah, I think it's mostly technical writing, so I'm not sure if it'll be super interesting or. I think it requires some level of technical understanding to understand, but hopefully it's relatively readable still.
00:59:07.920 - 00:59:31.320, Speaker A: For sure. I think you did a great job of kind of explaining some of the deeply technical stuff and ways that people can understand, and I always find that as a superpower, the people that can communicate the hard technical things in simple, non technical ways is a big skill to have in the space.
00:59:31.820 - 00:59:40.600, Speaker B: Yeah, definitely. Yeah. I think sometimes you get a little bit caught up in like the technical beats, but hopefully some of those understandable. And if you have any questions, always ask me.
00:59:41.220 - 00:59:50.970, Speaker A: Perfect. Well, thank you again, Robert. Really appreciate your time. Glad we could make this happen, but yeah, appreciate all your work and thank you again. Yeah.
