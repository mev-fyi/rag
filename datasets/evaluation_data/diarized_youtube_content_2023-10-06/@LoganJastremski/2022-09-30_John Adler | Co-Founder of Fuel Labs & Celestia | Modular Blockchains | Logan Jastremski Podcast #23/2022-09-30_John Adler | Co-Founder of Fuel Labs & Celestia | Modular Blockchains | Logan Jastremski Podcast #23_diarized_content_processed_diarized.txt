00:00:00.240 - 00:00:07.622, Speaker A: Welcome. John. Thank you so much for taking the time during the Stanford blockchain conference to chat about fuel.
00:00:07.806 - 00:00:09.970, Speaker B: Glad to be here and thank you for inviting me.
00:00:10.510 - 00:00:42.670, Speaker A: I had an awesome chat with Nick, flew to New York specifically just to learn more about Slesia, what you guys are building there. And we had an awesome conversation kind of breaking down Celestia from first principles. But I think outside of just Celestia itself, one of the coolest things that he mentioned was the virtual machine that you guys are building. Super excited to talk about fuel and what you're building there.
00:00:42.970 - 00:00:45.018, Speaker B: Great, let's get to it.
00:00:45.114 - 00:01:14.050, Speaker A: Awesome. Cool. Maybe just on a super high level, I think most people probably know who you are, but maybe just a little bit. Your background, how you got into crypto, you've done several things since you've kind of been in the crypto industry. You've really pushed the space forward and so maybe just kind of talk about how you got into crypto and. Yeah, start from there.
00:01:14.830 - 00:01:46.230, Speaker B: Yeah. So I guess the origin of the story might be a little bit long, but I guess we can get started. Let's do it. So I was doing my graduate studies at the University of Toronto. Formal verification of hardware. My research group at the time was kind of involved in the early days of ethereum. I do remember things like just walking outside with my research group and them chatting about how Ethereum had risen three x from thirty cents to a dollar, and how everyone was freaking out at this amazing pump and stuff.
00:01:46.230 - 00:02:56.440, Speaker B: And I'm like, ethereum, what is this? I didn't really know anything about blockchains at the time, nor I looked into it and stuff. One thing that particularly hooked me on blockchains and that I found particularly interesting was a lot of overlap with one of my interests, which unfortunately I didn't have. I didn't do any formal research in this area, but it was compilers and also virtual machines, closely related topics, because I found that a lot of what was going on in the Ethereum space specifically, not blockchain or bitcoin or investment stuff, but in the Ethereum space specifically, was this notion of smart contracts. You have a language, you compile it down, you have to deal with the virtual machine with different gas prices and stuff. I found out to be super interesting because it was directly aligned with one of my primary interests was compilers and virtual machines. So about one year into my PhD, I left to join Consensys to do general scalability research, L2 stuff basically. Then a few months after I joined was unfortunately when the great crash happened in early 2018, and then the snap happened where half of consensus just poofed and lost their jobs.
00:02:56.440 - 00:03:50.638, Speaker B: But anyways, I happened to stay on board, kept doing my research. And one particular paper that influenced me a lot in the research direction that I was going in was Mustafa's paper on fraud and data availability proofs, which was actually published, if I remember correctly, very shortly after I joined Consensys, which was around September 2017. Although don't quote me on these dates, because it all blurs together. Yeah, it all blurs together. Reading that, I'm like, oh, wow, this solves so many things. You can have this thing called fraud proofs, you can have this thing called data availability proofs. And the reason that I found it and kind of hooked me is that before seeing that paper, I had in my head that fraud proofs were something that weren't possible because I was kind of indoctrinated by the bitcoin core maximalist, the hardcore bitcoin maximalist crowd that fraud proofs just weren't possible.
00:03:50.638 - 00:04:28.260, Speaker B: They weren't a thing. Then I read the paper and I'm like, wait, they are. There's the paper here describing a formal model for fraud proofs. They are actually possible. That got me on the path of always questioning what I read and looking between the lines, looking at what are people really saying when they bring up new research or whatever, or bring up old research, you know, what are they really saying? And kind of trying to find the facts for myself. I think that kind of was like a big jolt in my mentality when it came to blockchain. Anyway, shortly thereafter, Mustafa also published a paper called Lazy Ledger.
00:04:28.260 - 00:04:58.720, Speaker B: And there's actually a funny story around this paper, which is that back then, I was going on ETH research quite a bit. For those of you who aren't aware of it, it's an Ethereum research forum, hence ETH research. Nowadays, it's basically a graveyard. No one uses it anymore. But back in the day 2017, 2018, people were using it all the time to talk about research, especially plasma stuff. That was the hot topic at the time. And then I saw Mustafa Post on ETH research, the lazy ledger paper.
00:04:58.720 - 00:05:19.220, Speaker B: He describes the lazy ledger posting here. The lazy ledger paper is published here. The short description of it. I skimmed through the post. I click on the paper, I skimmed through it. And then, because I was doing research in this direction, and I've been thinking in this direction for months prior to this, I'm like, oh, my goodness, this solves so many problems. This is exactly it.
00:05:19.220 - 00:05:45.630, Speaker B: This is it. This is the thing. And then I go look up on his twitter and he hasn't tweeted about it, despite the fact that he's active on Twitter. So I'm like, oh, okay, well, if he hadn't tweeted about it, I guess someone has to get this thing. It's so amazing. It's so revolutionary, right? So I go on, I go like a good boy on Twitter and I start typing out my tweet. And then after I tweet it out, I refresh my feed and I see my tweet is at the top, and then directly under me is his tweet.
00:05:45.630 - 00:05:54.390, Speaker B: In other words, just like he published it seconds before mine. In other words, while I was writing my tweet about the lazy ledger paper, he was also literally writing his tweet at the same time.
00:05:54.430 - 00:05:55.170, Speaker A: That's wild.
00:05:55.470 - 00:06:42.290, Speaker B: Yeah, it is. Later on, then we got together and along with our other co founder, Ismail, we co founded Celestia Labs. Well, I guess back then, lazy Ledger Labs to develop the celestia protocol. I also co founded Fuel Labs with my co founders, Nick and Sam to develop fuel, kind of tackling the scalability problem from two different angles. Now, kind of the story around fuel labs and optimistic rollups is that while I was at consensus, like I was saying, I was doing research in this direction, like L2 scalability, thinking about fraud proofs and stuff. That's where I kind of created the technique that people now call optimistic rollups. There were some groups that proposed a technique that they called optimistic roll up with those two words together.
00:06:42.290 - 00:07:15.226, Speaker B: But that technique wasn't actually optimistic rollups as we know it today. They just strung those two words together. It was a completely different technique. It was an optimistic exit game for plasma, but it was still a plasma. But the first person to publish the very specific technique that we now know as optimistic rollups was myself, with the help of my colleague Makiro bad crypto bitch on Twitter. And let's see, the specific eth research post, for those of you who want to know. A little bit of history was called minimum viable merged consensus.
00:07:15.226 - 00:07:50.572, Speaker B: Merge consensus because it doesn't involve an entirely new consensus process. One of the points of rollups is that you can use the base chain as a timestamping mechanism and therefore you don't actually need a full consensus process. Ironically, it was minimally viable because that was essentially the first iteration of where I thought this would go and not a final iteration. And indeed, in subsequent years, we came up with potentially better techniques such as sovereign roll ups, which I'm sure Nick talked about during the podcast with Celestia. Sovereign rops are an example, and leveraging Celestia directly are an example of something better than minimally viable.
00:07:50.716 - 00:08:00.384, Speaker A: Awesome. That's amazing. It's done a lot. And that was only within the last three years or so.
00:08:00.472 - 00:08:16.232, Speaker B: Well, that was prior to the last two and a half years or so. That was before. That was leading up to me co founding these organizations to develop these blockchains. Since then, I guess you can say there has been a decent amount of work and stuff that has been done, but we haven't talked about it yet.
00:08:16.336 - 00:08:18.784, Speaker A: But I guess we will throughout the.
00:08:18.792 - 00:08:19.632, Speaker B: Rest of this podcast.
00:08:19.696 - 00:08:56.760, Speaker A: Yeah, I think it's a fascinating story. It's awesome that you're at the point in time where people were talking about Ethereum at astute enough to realize that this is something that could be big and unique and continuing to do a deep dive, ultimately getting involved in the crypto space at consensus and then going heads down on optimistic rollups and creating those, and then ultimately leading you to where you are today with Celestia and fuel labs. That's a lot.
00:08:57.620 - 00:09:01.428, Speaker B: Thank you. Well, it was a long journey until then, but it's been even longer since then.
00:09:01.524 - 00:09:09.452, Speaker A: Yeah, no, I'm sure crypto years are like ten years. So you've definitely earned your stripes.
00:09:09.556 - 00:09:16.764, Speaker B: Yes. Especially during those several months of lockdowns that was definitely. They all blur together.
00:09:16.932 - 00:09:44.988, Speaker A: Yeah. Awesome. I would love maybe just to stick on some of your background briefly. What I think probably the vast majority of people are kind of familiar with optimistic roll ups, but for those that are not, could you just like, explain why you were so excited about those and what they ultimately unlock from like the scalability standpoint?
00:09:45.164 - 00:10:22.062, Speaker B: Yeah. So I can explain why I was excited about them, although it'll be kind of ironic that despite the fact that the thing that I find so exciting about them is not something that people are currently using them for that much, except for, I guess, field apps. But one of the nice thing about optimistic rollups, I guess, for those of you who aren't familiar, is it's a sidechain and the original work that I was branding it under was a trust minimized side chain. It's a sidechain with a two way bridge so you can move assets to and from the side chain, and it's trust minimized. So you don't actually have to trust any. You don't have to trust an honest majority of anything. Right.
00:10:22.062 - 00:11:04.004, Speaker B: And the way to achieve this is well, you need two components. One is data, some mechanism for data availability, and then some mechanism for knowing that the chain is valid or not, right? Fraud proofs are something you can do, you can do to, you can also use validity proofs. Fraud proofs are one thing you can do, and that's one of the reasons I was so excited about the paper, is that it enabled these trust minimized like clients. It enabled trust minimized two way bridges without full validation, with fraud proofs and for the data availability, you can do various things. One of them is you post all the data on Ethereum. Other things, maybe Ethereum has some protodank sharding or something. You can post the data there, there's all the things you can do that approach, that level of security guarantees.
00:11:04.004 - 00:11:46.628, Speaker B: Like you can post the data to Celestia, for instance, and bridge it to Ethereum with a quantum gravity bridge. For those of you who want to look more into that, I gave a couple talks about celestiums and the quantum gravity bridge and so on. And the thing that this enables is the fraud proofs are actually general purpose in the sense that you don't have to fraud proof the EVM. You can fraud proof anything. You can fraud proof a Turing complete virtual machine as long as you can verify it in the EVM, which you can, because the EVM itself is verifiable. Now, there's obviously certain constraints around the gas cost of verifying a fraud proof. There's also, if you use validity proof, there's certain constraints around the gas cost of verifying a validity proof, along with things like the maximum bytes you can have in a single Ethereum transaction, and so on.
00:11:46.628 - 00:12:43.540, Speaker B: But modulo those constraints, you can verify a lot of things in Ethereum that aren't EVM, even if the Ethereum itself only has the EVM. So one thing this unlocks is experimentation with novel virtual machines and transaction processing protocols. One thing I proposed, I think the paper that I published on this topic was building scalable, decentralized payment systems. It was focused around a very high throughput on the same cost to run a full node specifically for payments. So using things like Utxos and whatnot to enable parallel transaction validation, better state access patterns, the removal of a global state tree, again through using Utxo based fraud proofs. So not the EVM, something that is different than the EVM, that has better properties in some ways, better for certain applications, it may be worse for others, but it may be better for some. And it turns out that you can actually make virtual machines that are essentially strictly better than the EVM.
00:12:43.540 - 00:14:00.190, Speaker B: One example of that is when we're building a fuel labs, the fuel transaction processing model and the fuel virtual machine, which are technically slightly different things. There are two components of the entire fuel fuel protocol. This virtual machine, which I guess we'll talk about later as well, is somewhat similar to the EVM Turing complete virtual machine and so on. But it brings with it many performance improvements, and it doesn't really have any constraints like certain other different execution environments that bring with them things like, oh, instead of using integers, you have to use field elements and other weird stuff like that, and you can't use a SHA 256 hash. The fuel VM is a normal VM everyone knows and loves and can use very easily, and it's basically the EVM in terms of expressivity and stuff, but it's going to be much more performant than the Ethereum virtual machine, much more flexible, et cetera. So you can in fact make things that are strictly better. And this is the really interesting thing you can do with optimistic rollups and ZK rollups to a certain extent, although having ZK proofs for arbitrary computations, let's say it's still a bit early days, we'll see how the three four all equally first ZK evms do.
00:14:00.190 - 00:14:26.548, Speaker B: But it's unfortunate that, well, I guess the majority of you say three, but it's unfortunate that the current state of affairs among a number of optimistic roll ups is not experimenting with innovations and improving on the Ethereum virtual machine, but is rather stagnating and saying, we are going to take the EVM as it exists today and put it into our roll up. And now you have all the bottlenecks, you have all the shortcomings of the EVM.
00:14:26.684 - 00:14:50.208, Speaker A: Yeah, that's a great explanation. Yeah, I'm personally, I used to be more of an Ethereum maxi. Then I started deep diving in the EVM and how that works and just the general scalability of it, and ultimately become more of a parallelization. Maxi on the virtual machine side, on.
00:14:50.224 - 00:16:05.356, Speaker B: The topic of maximalism, actually, one thing I want to potentially also no Maxis, but one thing that I don't want to potentially, you know, like pop the veil that some Ethereum maximalists have, which is that a lot of people think that a lot of ethereum maximizations that I see on Twitter and other forums and so on, think that Ethereum is equal to the EVM as it exists today. And since, you know, they're Ethereum maximalist, then they say the only virtual machine that can exist and that will win is DBM, as it exists today. And the only language that will win is solidity, because, well, first of all, they don't know that Viper exists and you can compile it down to the EVM, or that all their smart contract languages exist that compile down to the EVM. And they associate Ethereum only with EVM because they're not aware of the fact that, like I said, you can experiment with differential virtual machines, all without losing security from Ethereum. You can share security with Ethereum by using either fraud or validity proofs, with Rops, with modular execution layers. So to kind of like break the Max evil, Ethereum is not the EVM, right? The Ethereum. Ethereum, the network can also support modular execution layers that share security with it.
00:16:05.356 - 00:16:37.128, Speaker B: And those do not have to be tied to the EVM. They do not have to be tied to solidity. And you don't have to think that the EVM and solidity will win to also think that Ethereum will win. Ethereum can win even if the EVM solidity lose and are never used again and people forget about them. And even if the Ethereum chain cannot upgrade its evm to improve, it doesn't have to, because Ethereum as a network also supports execution layers on top of it. So that is where you should be looking. Innovation in the execution layers.
00:16:37.224 - 00:16:55.916, Speaker A: So you can do like the L2, whether it's the optimistic or ZK flavor in parallel transaction execution, or whatever type of flavor of execution or virtual machine environment that you want and still settle to Ethereum l one, without having to change either the security or the EVM. Necessarily.
00:16:56.068 - 00:17:08.680, Speaker B: Exactly. Obviously it would be good if the Ethereum EVM changed, but let's face it, you just have to look at the history that EVM is probably mostly ossified right now. Don't expect major changes to it, ever.
00:17:10.380 - 00:17:55.760, Speaker A: No, I think it's super interesting. We're definitely getting into the weeds or starting to maybe to back up a little bit, um, holistically. Uh, I try to like the other, like Maxi that I try to be ish of, is like first principles. Um, and so I really would love to kind of understand before we kind of get more deep into fuel and what you're building and how it is unique from other execution environments is kind of, in your words, state, like, what are the current bottlenecks of blockchains, um, and, uh, why or how those problems can kind of be overcome from the first principle standpoint.
00:17:56.220 - 00:18:29.906, Speaker B: Yeah. So there's a few bottlenecks that are, some are direct bottlenecks and some are like indirect bottlenecks. One bottleneck is the ethereum virtual machine. The Ethereum virtual machine on a. If you, like, fix the computer you're running it on. The Ethereum virtual machine can only process so much gas per second, in other words, so much transactions per second. And that number is not actually very high and in large part is because the EVM as a virtual machine is just not exactly very performant.
00:18:29.906 - 00:19:04.372, Speaker B: It's also single threaded, so you're not really using all the cpu cores that are available on modern computers. Now, this isn't saying, oh, go out and buy a 256 core cpu with two sockets and whatever. No, this is saying, you have this laptop here, there's eight cores or something, right? And seven of those eight cores are just unused completely. Your disk is going to be hit and stuff like that, but your cpu cores are completely unused and they could be used. Imagine going from one to eight. That's an eight x increase. That's almost an order of magnitude, even on a not so great laptop.
00:19:04.372 - 00:20:15.852, Speaker B: This is a consumer laptop, and you're already ten xing of the throughput with basically no work, just if you enable parallelism. So the single threadedness and the not so great by design virtual machine, along with potentially not so great implementations, there's some implementations that are still in progress that are improving things like Aragon that apparently is quite performant. But regardless, the virtual machine is a big bottleneck. Now you might say, well, are you sure it isn't consensus? That's a bottleneck, because if you run an ethereum virtual machine on, let's say, maybe not, this laptop is brand new, but let's say, a few years old laptop, like a mid range laptop, not the high end ones, maybe you get a few hundred, 500 transactions per second, but Ethereum runs 15, so why do you have 15 and not 500? Why isn't Ethereum running 500? Surely it must be the consensus protocol. It must be because of Nakamoto consensus. The analogy is you're carrying whatever baskets of apples, and you can only carry so many apples. Right? I heard someone use that flawed analogy.
00:20:15.852 - 00:21:15.742, Speaker B: Anyways, this kind of subtle invisible bottleneck, sorry, the subtle invisible bottleneck is that we as a community of node runners have imposed on the Ethereum network a much lower gas limit than we can run on that target hardware. Because we want to be able to run a phone, though, that catches up to the tip of the chain. We could have as a community through social agreement, as there's nothing to do with the consensus protocol agreed that instead of having a gas limit such that you have 15 transactions per second, you instead have 490. But it means that as soon as your node. If you had some particular target hardware, as soon as your node got kicked offline for, let's say, a minute, now, suddenly you can't fully synchronize the chain anymore. You're done. You have to trust now that an honest majority of miners you have to trust that a majority of miners are honest and have been honest.
00:21:15.742 - 00:21:19.934, Speaker B: Otherwise, the chain could be invalid and you wouldn't know. Right.
00:21:20.022 - 00:21:24.770, Speaker A: That's just because the throughput of the overall chain is higher than it was in the past.
00:21:25.190 - 00:22:06.530, Speaker B: Well, if you make the throughput of the chain close to the physical limit of what your node can run on the bandwidth side, on anything, on anything, if you make it close close, then that means if you stop running it for even a little bit, now suddenly you're behind and you'll always be lagging. You'll never actually be able to catch up. That's why Ethereum does 15 transactions per second. There's nothing to do with Nakamoto consensus. We could have chosen a much larger gas limit. And you can see this by seeing Ethereum forks of either Ethereum or of geth that take the same software and that's run more TPS, right? So. And some of them use Nakamoto consensus.
00:22:06.530 - 00:23:02.438, Speaker B: So how can you possibly say it's the consensus protocol is the bottleneck? And clearly you can see all the forks that use the same other chains that use the same software, right, that run the same consensus protocol and that have ten times the tpS, right? So that's another bottleneck. And this is one of those things where is this a bottleneck or is it a constraint? Right? Could this last a bottleneck and more like an actual, like, intentionally imposed constraint? Certain blockchains, like Solana, for instance, run it very close. They don't have this large multiplicative factor of, let's say, 30 or whatever to catch up. So it's basically as soon as your Solana node drops for a minute, now you have to do a trusted sync. Now why don't we want to do a trusted sync? Why don't we want the trust that a majority of validators or miners are honest? I actually did give a talk about this at the science and engineering of consensus workshop that happened this past Sunday, right before SBC called proof of stake in the model of accountability. You can go check it out. It's probably online by now.
00:23:02.438 - 00:23:38.076, Speaker B: I would hope, depending on when this airs. But essentially, we don't want to trust that a majority of them are honest because then a majority of them could screw you. As the user, you want to be self sovereign, you want to know that your money isn't getting stolen from you. And the way to do that is you run know the chain is valid. I was about to say you have to run a full node, but you don't, because with fraud and validity proofs, you don't have to run a full node. Right. You can trust not a majority of validators.
00:23:38.076 - 00:24:18.824, Speaker B: You can trust that there's one node out there that will create a fraud proof, or you can trust, wait, that there's one node out there that'll create a validity proof, but you don't have to trust anymore. An honest majority of miners are validators. And that's where fraud proofs and validity proofs are very powerful, because it means that now the game changes. Now it doesn't matter if a majority of miners or validators decide to insert an invalid transaction that steals everyone's money into the blockchain. You can catch it even if you don't run a full note. So the kind of model of, oh, you know, we have, we have the trust that a majority of miners are validators, are honest is a bad model. It's low security, and it's not the one that blockchains, like ethereum, like Celestia, like fuel, make.
00:24:18.824 - 00:24:50.060, Speaker B: These blockchains make fundamentally the assumption that users will run their own nodes, or if they don't run their own full nodes, then at least we'll have fraud or validity proofs so that the user knows that the blockchain is valid. All the blockchains who shall not be named, they just say, okay, we just trust that a majority of validators are honest. And if they happen to be dishonest for whatever reason, maybe we can make it harder. But if they happen to be dishonest even once, all your money is gone and there's nothing you can do about it, and that means your money isn't actually owned by you. Your money is owned by a majority of validators.
00:24:51.160 - 00:25:13.034, Speaker A: Awesome. Lots. Unpack. So the biggest, again, bottlenecks per se, it's not consensus. It's really kind of the execution environment, the trust assumptions, and then ultimately kind of that social consensus of what you want it to be, in your opinion.
00:25:13.202 - 00:25:47.692, Speaker B: Yeah, although some of those are constraints last and bottlenecks, we should say something like the ratio of something. The target hardware is not a bottleneck, it's a constraint it's not a bottleneck. Because you signed up as social consensus, the ratio of you can validate the chain x times faster than it's produced. That's a constraint, not a bottleneck. Given these constraints, what is the bottleneck? The bottleneck would be the application logic. In other words, the virtual machine transaction processing model bottleneck. Given those constraints, which I guess I should probably talk about more.
00:25:47.756 - 00:26:20.936, Speaker A: Let's do it. So, yeah, we talked about the evm, we talked about the overall bottlenecks. Let's talk about fuel. Fuel initially started off as a sidechain, and I think it was to increase the Ethereum scalability. Correct me if I'm wrong, maybe could you talk more about why it initially started out as a sidechain? What maybe actually backing up. Let's do what is fuel? And then why it originally started out as a side chain and what it's now morphed into today.
00:26:21.128 - 00:26:50.074, Speaker B: Okay, so I should take a step back and correct that. Fuel started out as well as branded as a trust minimized side chain or a side chain with a trust minimized bridge. And another word for that is a roll up. Right? Because roll up is literally a sidechain that has trust minimized to a bridge. So fuels started out, and the reason that consensus, and then co founded Fuel Labs to build fuel, was to bring this notion of an optimistic roll up to life. And in fact we did. Fuel v one was the first optimistic roll up to be deployed to mainland Ethereum.
00:26:50.074 - 00:27:21.930, Speaker B: In fact, to this day, it's the only optimistic roll up, or it's the only roll up period of any form that has some validity mechanism, in other words, fraud or validity proofs, and is permissionless and has no upgrade keys. All other roll ups are missing one or more of those components. Roll ups are missing one or more of those components. Either they don't have fraud proofs and never did. Or maybe something like fraud proofs are whitelisted. Or maybe they have upgrade keys that can upgrade the contract immediately, even without any delay. There will be a mass exit issue, but it may still be something.
00:27:21.930 - 00:28:10.510, Speaker B: A lot of them have immediate upgrade keys and so on. A lot of them are closed source, so users can't even run the software to verify or prove anything. Fuel V one is the only one that has an actual roll up. So it's actually the only roll up that exists on Ethereum today. Now, where are we taking fuel? We're kind of taking fuel in the direction of what we call a modular execution layer, which is rather than having the target goal of an Ethereum smart contract being able to know whether or not some claim on some state on the roll up is valid or invalid. And that's it. We're building an execution layer that is designed for the modular stack and that allows users to run trust minimize like clients off chain.
00:28:10.510 - 00:29:01.208, Speaker B: So as an example, if you don't have this constraint of users being able to run like clients off chain, you could just not do certain things in the smart contract. Things like figuring out a, a merkle route of transaction so that you can tell users, hey, is your transaction in the block or is it not in the block? Right. An example of this is various ZK. I don't want to say ZK Roth, but let's say ZK systems, various ZK systems that will post not transaction data, but state diffs on chain, which you may have heard as a particularly interesting quote unquote, compression. Or it's not really compression because it's lossy, if you want to call it compression, and you definitely don't want lossy compression. But whenever anyone says compression with rollups, that triggers me, because rollups are not compression. But anyways, that is.
00:29:01.224 - 00:29:06.152, Speaker A: How would you classify rollups if you don't think they're compression?
00:29:06.216 - 00:29:40.018, Speaker B: I would say they're moving execution off chain. That's it. Anyways, these validity systems that have state diffs instead of actual transactions, you might say, how do I know I'm sending a transaction? Alice is sending a transaction to Bob. How does Alice actually know her transaction was included on chain so that she can prove to Bob that she paid him? And a very trivial example of this is, let's say Alice pays Bob and Charlie pays Bob. Both of them pay Bob. Right. Now Bob sees his balance increase by, let's say, two units, and Alice and Charlie both have their balances decreased by one unit.
00:29:40.018 - 00:29:58.400, Speaker B: And that's all we post on that state diff. How can Alice prove to Bob that she paid him? The answer is she can't. So you don't actually have full knowledge of what's happening inside the system. You know the state def. Sure, but you don't actually know everything that's happening. And that's where this modular execution layer comes in. Right.
00:29:58.400 - 00:30:37.382, Speaker B: It's about users being able to run a trust minimized lite client as it exists for, I guess, no layer one today, but it's about users being able to run a trust minimized lite client off chain. They just run the node software and they can get proofs and whatnot. And they have full introspection the transactions and state effects and so on, and of the modular execution layer, because we have that additional constraint, that additional need of. You need to actually be able to have a commitment to everything in the blockchain, not just the minimal amount to prove to a smart contract on Ethereum that some state route is valid. That is not sufficient for a modular execution layer.
00:30:37.486 - 00:31:04.518, Speaker A: Gotcha. Maybe talking specifically about some of the innovations that fuel has come up with specifically on the parallel processing and why parallel processing? I think you touched upon it, but maybe you go a little bit deeper. Why parallel processing, in your opinion is a requirement and how fuel is doing this on the virtual machine side?
00:31:04.654 - 00:31:59.572, Speaker B: Ok, so there's kind of two actually. We're not doing it on the virtual machine side. And this is why I said at the beginning earlier, there's a distinction between the transaction processing model and the virtual machine itself, which we'll get to in a second. I don't know about, say, innovations in the sense that a lot of what we built with our virtual machine and transaction processing model, a bit of it is new and innovative, sure, but a lot of it is actually implementing eips that were proposed over the years, but that didn't manage to get included into Ethereum. If we have time for it, I can potentially go through Kami, who is leading our devil efforts, compiled a very nice list of, sorry, 30 of them or something. So if we do have time, I can go through a few of them. But regardless, you basically implemented a bunch of erps that had been proposed over the years but could not be implemented on Ethereum in the EVM because they needed to be backwards compatible with the Ethereum state.
00:31:59.572 - 00:32:03.604, Speaker B: Because Ethereum is not just the eVM, it's the ethereum state plus the evM.
00:32:03.652 - 00:32:41.394, Speaker A: Yeah, maybe touch on a couple of the high level ones that you think are most important to that Ethereum did not implement, and then the interesting ones that fuel has taken inspiration from and then implemented. I've always been fascinated though by the Ethereum virtual machine and how difficult it is once the blockchain is up and running and having that previous state to change the virtual machine. And I know Celestia is doing something interesting there as well, but yeah, love to hear more on the inspirations.
00:32:41.522 - 00:33:22.830, Speaker B: Yeah, and before I dive into the list of these, this falls under what I was discussing before around the amazing thing about rollups is they allow you to innovate on the execution layer because you're not burdened by that state. You start a new chain basically from scratch. There's no state, there's a blank slate. Why on earth would you be, why would you be constrained by the baggage of the Ethereum state when you yourself don't have that state? Throw it away. Be free. Innovate in ways that, well, people have imagined before because they proposed ideas for this for the last five years. Just innovate and implement these amazing improvements that have been proposed and some that haven't.
00:33:22.830 - 00:33:58.480, Speaker B: And don't be tied down, constrained by that baggage, because they'll bide you in this. So a few things that have been proposed over the years. One of them was parallel transaction execution. There's a few eips for this. One of them was EIP 648, easy parallelizability. It proposed as parallel transaction execution by having transactions specify access lists. In other words, they would specify a list of elements in the state that were accessed by the transaction, either read from or written to.
00:33:58.480 - 00:34:55.929, Speaker B: We do this by using Utxos. The way our Utxo model works is that contracts are represented as Utxos, and similar to how in bitcoin you have to specify what Utxos your transaction touches and spends. So do we. So that when you have a fuel transaction, it will actually list out the contracts that the transaction will touch. And before anyone freaks out and say, well, I mean, this will introduce contention or something we actually use. And this is, this might be actually where some innovation happens, which is that in most blockchains the block producer will collect transactions from the mempool, from users as they are, some exact sequence of bytes, and they'll take them and they'll put them into the block in a particular order, and that's all they do. But what we do is something different, which is that the block producer collects transactions, they put them in a block, and then once they put them in the block, they're allowed to start changing some of the fields in the transaction.
00:34:55.929 - 00:35:21.890, Speaker B: One example of this is the easiest one is probably, let's say the change in bitcoin. You can have some change after transaction executes. Although, okay, bitcoin is maybe not good, because there's no execution of bitcoin, there's just verification. Ethereum, okay, ethereum does some change. You spend some gas from your account, and after that you have some change. It's implicit in this transaction. There's nothing explicitly listed there.
00:35:21.890 - 00:36:10.320, Speaker B: How much do you actually get back? How much do you get back? There's an ocean of gas used, but there's no actually field there that tells you the final amount you get back. You could do it, but in an ethereum transaction, you wouldn't be able to do it because that field is not known by the user, because they don't know how much gas they spend. If you don't know how much gas they spend, you spent during execution. Because it could be the transaction reverts, it could be one branch is taken instead of another, so the user doesn't know how much change they're going to get, but the block producer does because they've executed the transaction. That's an example where you can have a field that can actually be malleated by the block producer using this. This allows us to do things like when the user specifies which contracts their transaction will touch, they do not specify the exact Utxo. They specify only the contract.
00:36:10.320 - 00:36:51.080, Speaker B: By certain consensus rules, each contract can only be represented by one Utxo at a time. It's kind of like, here's the Utxo at the state of the contract before the transaction executed, and then after. It's kind of like a state transition. And this allows us to avoid the contention problem that Cordano had. Cardano had the contention problem where since users were signing on the exact UtxO, which was the exact state of the contract at a particular slice and time, it means if someone else interacted with the contract first, now that Utxo no longer existed, it got spent. For us, users don't do that. They sign over the contract identifier and then the block producer goes in and the transaction and fills in the utxoids.
00:36:51.080 - 00:37:06.976, Speaker B: So this notion that the block producer can actually start changing fields in the transaction and in the block is something that we use almost to the point of abuse in fuel. And I don't think basically any other blockchain does this. And it unlocks things like this, that you can have a Utxo model without contention.
00:37:07.088 - 00:37:29.068, Speaker A: Yeah, I think the Utxos are extremely interesting, but I don't know if the vast majority of people actually understand what they are. So could you maybe just, and I know you just kind of walked through it, but maybe just do a little bit deeper dive on Utxos? What are they and why they're unique for kind of the things that you just mentioned?
00:37:29.204 - 00:38:10.116, Speaker B: Yeah. For this particular thing, in the sense of it's an access list. It tells you which contracts your transaction will touch. If you know which contracts your transaction will touch, then contracts, transactions that touch different sets of disjoint sets of contracts can obviously be executed in parallel because they don't have any dependency between them that is not unique to UTX. Sorry, is not unique to Utxos because you can also do it with access list directly on an account based transaction. But Utxos give us all the properties as well, which I can cover in a second. But for those of you who are uninitiated, Utxos are essentially this paradigm where transactions have a set of outputs that they generate.
00:38:10.116 - 00:38:55.006, Speaker B: Each output represents some state, it could be some coin, in the simple sense, in the specific case of fuel, it can also be something like a contract. So like a contract with some byte code, it has some storage slots, it has some balance, right? So it's either a contract or it's a coin. And then each of these outputs can be spent once and exactly once or at most once a UtxO is spent, it is gone, but the transaction can create more outputs. So a TXO is a transaction output. A Utxo is an unspent transaction output. I so all the unspent transaction outputs, that's the thing. Since they're unspent, it means they can be spent, which again, they can be spent at most once, and once they're spent, they're gone.
00:38:55.006 - 00:39:27.894, Speaker B: You can't spend them again. This gives this nice, it gives like a more functional, pure approach to how you deal with this, because of the fact that you don't have to worry about updates since a Utxo is destroyed once it's spent. And then sure, a new Utxo can be created, potentially with the same value, the same owner and everything, but identifier changes. And the fact that you don't have this notion of updating the same identifier means you don't have to worry about a bunch of things that Ethereum now currently has to worry about. Things like having global state route and other sequential bottlenecks.
00:39:28.022 - 00:39:33.382, Speaker A: Awesome, cool. Maybe continue on a couple high level eips real quick.
00:39:33.446 - 00:39:49.262, Speaker B: I'll do a couple more. One of them that was also proposed was EIP 3074. For those of you who aren't following that effort, please do. By Sam Wilson it's absolutely amazing. It should happen, but it's been pushed a few times. It's unfortunate. This is auth and auth call.
00:39:49.262 - 00:40:40.824, Speaker B: It allows things like some notion of getting close to account abstraction in that direction, essentially allowing you to have some logic to control transaction validity or execution and stuff is ultimately what enables. So what fuel does is we have a few things. One of them is scripts. And in fact scripts, believe it or not, are borrowed from Libra or I guess diem or Novi or Aptosui. Nowadays, whatever name they choose next. So in Ethereum, if you want to call a contract, your transaction can do a few things. It can send money to someone, it can create a contract and it can call a contract.
00:40:40.824 - 00:41:33.866, Speaker B: And when it calls a contract, it calls one contract once, and that's all it does. So if you want to do something, let's say an approve then a transfer from in a single transaction. You can't actually do that because a transaction can only call one contract once, right? Very primitive. What these other aforementioned blockchains plus fuel do is they have this notion of a script in the transaction, and the script is just bytecode instead of the entry point is I call a contract, the entry point is start running the bytecode in the script, some bytecode, just start running it as if it were any other contract where you just take the bytecode and you start running it. Therefore it allows you to actually embed logic directly in the transaction without having to first say deploy some multicolored contract. But then you have to worry about the message sender being in the contract and not yourself and so on. This gets very complicated.
00:41:33.866 - 00:42:25.382, Speaker B: You can actually do atomic calls to multiple contracts within a script and also have things like logic and branching based on the return values and so on. So very powerful but very flexible. So you can do things like an atomic approved, then transfer from in a single transaction. Now ironically, you never will actually need to do that specific thing in an atomic approved, then transfer from for a fungible token on fuel, because fuel also supports multiple native assets. So for any of you who have written a smart contract and have had to deal with the hell of safely transferring or dealing with safe token transfers, and still to this day, maybe don't know how you're in luck, because on fuel, transferring tokens has exactly the same first class citizen properties as transferring ether. You can push a token with a call, and contracts can own balances of all tokens, including the base asset, which would be ether in this case.
00:42:25.476 - 00:42:26.150, Speaker A: Awesome.
00:42:27.770 - 00:43:04.862, Speaker B: That's one thing we have, and another thing we have, which I think is very important, is predicates script. And we predicates and contracts. So predicates allow you similar to bitcoin. Bitcoin also is predicate. They call it bitcoin script, but it's really predicate, which is unfortunate naming collision given that our scripts are actually transaction scripts. But anyways, so the bitcoin predicates and fuel predicates allow you to define spending conditions for a coin, and the spending conditions actually affect transaction validity, not execution. In other words, if a predicate is not satisfied.
00:43:04.862 - 00:43:55.544, Speaker B: If it's false, then the transaction itself is invalid. And if it's invalid, it won't be included on chain, and therefore it won't consume block space and it won't spend gas, right? So the user doesn't have to worry about spending gas. This is very powerful because it enables you to do a bunch of stuff programmatically, that if it fails, won't affect the chain whatsoever because it won't actually enter the blockchain. And this actually has another name for this predicate is actually stateless account abstraction. And in fact, the most powerful form of account abstraction that is not a denial of service vector. There are other blockchains that tout account abstraction. And what they're calling account abstraction is stateful account abstraction, one in which the validity conditions for a transaction are defined in a smart contract that can read and write state.
00:43:55.544 - 00:44:29.436, Speaker B: In other words, the validity conditions can change based on the state of the chain. Predicates are completely stateless. They're pure. So the validity conditions only depend on what information you pass into it as a pure function. Now the issue with stateful account abstraction is then I'm going to put it like this, which is determining the validity of a transaction based on the state of the chain. And not just the state of the chain, but the state of the chain going through arbitrary logic. Because obviously the validity of a transaction that's a simple payment, is obviously dependent on the state of the chain.
00:44:29.436 - 00:45:18.662, Speaker B: It needs your nonsenior account balance, but that's trivial to check. But something like an actual smart contract execution is non trivial. That's what I mean by stateful account abstraction. Now you may have been on Twitter during the big debates around Ethereum censorship, right? Surely, surely you saw that. And for those of you who weren't there, plenty of people in the Ethereum community were saying, well, validators can't censor transactions, because if they censor transactions, that's a denial of service vector. And the reason it's a denial of service vector is they would have to go through, and they would have to figure out which transactions are valid or invalid according to their own validity rules, which are basically the Ethereum rules, plus maybe some more like some censorship list. And that doing this check would be stateful because it would have to go through arbitrary logic.
00:45:18.662 - 00:46:06.138, Speaker B: It would have to go through smart contract, smart contract execution, some state that is exactly the same description I gave for stateful account abstraction. These two things are actually the same thing. So if you think that Ethereum validators cannot censor because of the denial service vector, which to a certain extent is true, then stateful account abstraction is equally as a Nile service vector. So any chain that touts to have account abstraction is basically saying, well, it's either denial of service vector and they're hiding it, or it means they're saying the Ethereum validators can in fact and will censor the chain. So pick your poison. But fuel provides state loss, account obstruction, which is the strongest amount of account obstruction you can get without it becoming a denial service vector or some censorship issue or anything like that. Got you through predicates.
00:46:06.194 - 00:46:49.270, Speaker A: Very cool. I think ultimately, obviously you guys have done a lot and are obviously extremely in the weeds on the technical nuances of the different eips, but which ones ultimately add value to the execution environment and users maybe for the people that are not technical in some of the things that you've been describing from the user standpoint, and I think you've been talking mostly on the developer side, how does it fuel affect the end user? Either just by increasing transaction throughput or lower latency. In your words, how do these technical innovations affect the end users?
00:46:49.430 - 00:47:46.922, Speaker B: Yeah, so there's kind of two end users that we may want to talk about. I guess I've talked, I mean, a lot of the protocol changes I've talked about here enable more flexibility for developers, but that's not the whole story. So how about we talk about end users first, then we revisit developers? It's a very important part of our culture and our ethos. So for end users, one thing that when we talk about fuel and its properties, one thing that we strive to never do, which other projects do all the time, is never advertise fuel as being able to provide cheap fees or low fees. This is obviously the one thing that users probably care about the most. The reason we don't do this is because no blockchain in the entire world can guarantee cheap fees, because supply is finite. There's some target hardware, the implantation, yes, you can optimize it, but only a certain amount.
00:47:46.922 - 00:48:27.410, Speaker B: There's only so much you can optimize software, then beyond that, then you're stuck with whatever, whatever architecture you chose with your virtual machine. And even if the field virtual machine is 1000 times more performant than the ethereum virtual machine, that's still some finite number, right? Well, demand can essentially be infinite for block space, and when demand exceeds supply, you get a fee. Market fees can rise to whatever they want, right? So that's why we never ever say that fuel will provide cheap fees. It may start by providing cheap fees when the demand is less than the supply. I mean, yeah, sure, so will any blockchain, though. But it cannot guarantee gps forever. And this is something that basically every other project gets wrong.
00:48:27.410 - 00:48:52.338, Speaker B: What we can provide is the highest flexible throughput and the greatest security. So flexible throughput as a term, complete smart contracts, ethereum style churn complete smart contracts. So it's not just simple payments. We maximize that for a particular target full node. And we also have the greatest security in the form of. Well, it's a modular execution layer. Can share security with the space layer.
00:48:52.338 - 00:49:17.130, Speaker B: It has fraud or validity proofs. We are currently building towards fraud proofs, but we're not against validity proofs. If they prove mature enough and ready, then sure, why not? It's a validity mechanism, so we'll use whatever's best. So that's essentially what end users will have. They'll have high security and they'll have high throughput, at least in the beginning. Sure, they'll have cheap fees, but that can't last for any blockchain.
00:49:17.250 - 00:49:34.754, Speaker A: That makes sense because it is doing the parallel processing. How do fee markets work? Is it global? I know some blockchains are now moving to fees per state. What are you guys exploring on that front?
00:49:34.842 - 00:50:02.862, Speaker B: Yeah, I did some collaboration with Guillermo and Tarun and the other guys, some of the main capital. They published a paper a month ago or something. It was fairly recently on female grids with different resources. Their context was, I guess, more general in the sense that, okay, just any number of orthogonal resources. But in our context, those orthogonal resources would be things like multiple parallel execution threads. So I helped them. Well, I shouldn't say I helped them.
00:50:02.862 - 00:50:29.666, Speaker B: Okay, I contributed to reviewing the paper a little bit, but that's kind of this general direction that we were thinking. Rather than having a single threaded execution model where everything is piled together, you effectively have some multi threaded execution model, a multi threaded fee model where hotspots ultimately off transactions that all touch the same state, or some hotspot of state will essentially have to pay more through the protocol.
00:50:29.738 - 00:50:34.090, Speaker A: Gotcha. It will be dynamic per state ultimately.
00:50:34.250 - 00:50:53.620, Speaker B: Well, I don't want to say will. I'll say that we're looking in that direction. Gotcha. This won't become a problem for a while, for the aforementioned reason that, yes, blockchains do have cheap fees when demand is lower than supply. And yes, while I expect a lot of people to be using fuel once we're out TBD.
00:50:53.660 - 00:50:57.880, Speaker A: When any approximate timelines?
00:50:58.220 - 00:51:01.492, Speaker B: Well, it depends. When are those podcasts coming out. Maybe in the past.
00:51:01.596 - 00:51:03.828, Speaker A: Maybe by the time this happens.
00:51:04.004 - 00:51:40.578, Speaker B: Okay, well, maybe by the time this happens, they'll all be in the past. So we're talking to you from the past. Unfortunately, since we probably don't expect, even on a moderately modern machine, you can probably run many transactions per second if you actually unlock the full potential of your cpu cores, and you make the virtual machine more optimized. So this isn't something we're not expecting demand to exceed supply, at least for a little while. So there's a bit of time to figure out and model and come up with a nice rigorous models and studies and stuff about how to do this properly. We're not in inherent rush.
00:51:40.674 - 00:51:46.770, Speaker A: Okay, very cool. And then coming back to the developer side and rounding that out.
00:51:46.890 - 00:52:19.960, Speaker B: Yes. So, in terms of developers, one of our ethos is, while the engineering of a protocol matters very much, which surely you've gathered, the engineer matters potentially even more than the engineering of a protocol. The developers who will build on your protocol and their experience matters even more than the technology or the protocol itself. We do not want developers to eat glass. We want developers to eat cotton candy. And we will eat the glass so you can eat the cotton candy. I like that we are building.
00:52:19.960 - 00:52:58.870, Speaker B: Sure. I talked about all the amazing things, non exhaustive list of all the amazing things of our virtual machine and our transaction processing model and all this stuff. But the developers don't actually need to see most of this. A lot of this happens behind the hood. It's fundamental engineering improvements to the protocol itself. The engineer, what they will see is things like, what smart contract language do you use? How does the smart contract language interface with a virtual machine? What kind of optimization and security passes does it do? What tooling do we use to develop? Are there things like a formatter and a debugger and all this other stuff? That's what the developer sees and cares about. This is where fuel labs is unique.
00:52:58.870 - 00:53:42.826, Speaker B: We're building out not just a new blockchain, we're building out a unified tool chain centered around what we call fork, the fuel orchestrator, but with some other peripheral stuff. And we're also building out a new high level language to develop smart contracts, both for our own virtual machine, the fuel VM. And eventually we've started work on this to the EVM called Swaydeh. This new high level language is based on rust. So it takes a lot of learnings around rust for its type safety, its expressivity, things like exhaustiveness and whatnot. Learns from all that. And injects smart contract specific additions, and the most important ones are contract storage and cross contract calls.
00:53:42.826 - 00:54:17.620, Speaker B: Those are the two things that the EVM defers from a regular virtual machine from, so it just adds those two. The rest is very similar to rust, so it's easy to pick up. If you know solidity, you can pick this up in literally an hour. It's very simple, nice. It's not like you have to know Rust and the borrow checker and all that, because the execution of a single contract, a single virtual machine instance, single fuel virtual machine instance, is single threaded. Our parallel transaction execution happens across transactions and within a transaction, so developers don't have to care about async or multithreaded or anything like that. They write contracts exactly like they do on Ethereum.
00:54:17.620 - 00:55:29.230, Speaker B: And the nice things about this language is we can do things that people have been asking for, or not even asking for, because they didn't know the compiler should be able to do this that haven't been done in solidity. A lot of things like moving checks from runtime into compile time, something known as zero cost abstractions in solidity. For instance, there was a meme going around the solidity optimizers on Twitter a while back, a few months ago that people were just adding payable to everything this payable keyword, because adding the payable keyword means that solidity would auto generate some runtime code to check that the amount sent to a function is zero, or I guess non zero. So there's add payable keyword everywhere because they'll prevent the generation of runtime code and make everything cheaper, both contract deployment and and actually runtime, which is not good if the language has this whole keyword and people are abusing it and not using it properly. Because using it properly would mean everyone has to pay more gas. That's why you move things from runtime into compile time. So things like the payable for instance, is going to be elevated into the sway type system such that all the checks happen at compile time.
00:55:29.230 - 00:56:12.798, Speaker B: Interesting other things we can do. We actually have a prototype branch for this. We're going to have a good eventually and have an amazing error message, but it's in development. There are other higher priority things like actually shipping actual features instead of a few security checks, because there's no real money at stake yet. But before mainet you can be 100% sure this will be out because we want this before anyone touches real money with sway is reentrancy checks by the compiler. Even as recently as earlier, this summer people were losing money to bugs in smart contracts that were reentrancy bugs. The solidity compiler had six years or whatever long, however long it's been in development to add some checks for reentrancy.
00:56:12.798 - 00:56:44.550, Speaker B: You can do very solid reentrancy checks in the compiler. Maybe they're not quite 100% exhaustive, but they can cache 99% of the cases and they have not. We can do that, and we'll do that directly in the compiler. So if you violate the check effects interaction pattern, there'll be a warning. Of course, if you do things properly in CI, all your warnings should actually be errors, so they should never pass your Cihdeen. So there's little things like that. These things will greatly improve developer experience and things like our tool chain.
00:56:44.550 - 00:57:30.620, Speaker B: Our tool chain is based on cargo. For anyone who's trying to develop a solidity project and you had to use something NPM to manage dependencies, or God forbid you had to use git sub modules to manage dependencies, we have something that dependency management similar to cargo, where things downloaded to your home directory, things are indexed by hash so that you don't have duplicates. And all this stuff, you don't have a local node modules folder, it's all deduplicated, similar to how they do it in cargo. Yes, it took us a lot of time, a lot of effort, a lot of manpower, but we are willing to put in that effort and put in the manpower because we know it'll have outsized returns on the developer ecosystem growth. We have the entire tool chain. Things like building. We don't have debugging quite ready, but it has, it's already in progress.
00:57:30.620 - 00:57:31.864, Speaker B: We have an enshrined formatter.
00:57:31.972 - 00:57:32.620, Speaker A: Nice.
00:57:33.360 - 00:57:48.340, Speaker B: And then we have things like SDKs. We don't have a block explorer. We're going to build a wallet. Going to. We have started building a wallet along with our full nodes. The entire stack is being built. Another one amazing product we're building is an indexer.
00:57:48.340 - 00:58:43.360, Speaker B: If you're familiar with the graph, Irish allows you to write some wasm logic and then index some stuff. We're actually building that in house into our node so that you can do similar to what you do with a graph. You write your indexing logic for your application, you can distribute it with your application or your fuel app. Then anyone can effectively run that indexing service locally. They don't have to have some heavy process or whatever like paid GRT tokens, they just run it locally. We're essentially building out the entire development stack, single unified iOS like stack that's going to be maintained, that's guaranteed to be compatible with itself and other components of the stack, and that isn't fragmented because a lot of the solidity development stack is fragmented. And this is, again, to reiterate the point that solidity does not need to be the only language that wins, that exists, that people use for Ethereum to win.
00:58:43.360 - 00:59:14.344, Speaker B: Ethereum can win with other languages because other languages exist, one of them being sway. And I fully expect sway to be the most used smart contract development language within a few years because its features and security guarantees and its expressivity along with its tool chain are way above anything any other blockchain has. Even today, even in its immature state, which is not even close to where we want it to be, it is still more mature than where many other blockchains are, including solidity, including rust, and including things like move.
00:59:14.512 - 00:59:59.652, Speaker A: Interesting. Thats a very big claim. No, I think ultimately what youre building with fuel, if I can just resummarize it, is the high throughput with maximum security guarantees, a kind of full sac entire suite from the developer experience that allows them to take advantage of the high throughput chain and remove a lot of the bugs that we've seen today that unfortunately do cause people to lose a lot of money. But it's very exciting. It's a lot of work. A lot of work on the execution environment side, a lot of work just to get it up and running. Yeah, it's a big, tall order.
00:59:59.756 - 01:00:29.792, Speaker B: It's a lot of work. But fortunately I have an amazing team. We have about 60 engineers and counting, about 70 people in total contributors that are working on this. Probably the smartest people that I have, I won't say I ever met in my life, but I guess I met some pretty smart people in my life. So the smartest people that I've ever directly worked with, other than of course the celestial team. I love you guys too. So if you guys want to join us to contribute to the fuel protocol, we are of course hiring.
01:00:29.792 - 01:00:39.184, Speaker B: And if anyone wants to for instance, build sway applications, we are actually providing grants for developing applications built in sway or in fuel.
01:00:39.312 - 01:00:57.882, Speaker A: Awesome. That's amazing. What are your overall? I know it's a high throughput chain, but do you have any estimate or beginning guesses of what the overall TPS or throughput will be with fuel?
01:00:58.066 - 01:01:50.050, Speaker B: Yeah, so that's also something we've tried to avoid. I'm going to pull up my numbers now to kind of give us some comparison, but something we've tried to avoid in a certain way, similar to a certain extent, for similar reasons to why we tried to avoid things like talking about in this case, not because you would be completely alive to say that, but rather because it could be misrepresentation that's very hard, that give a representative number. For instance, there's a blockchain that claims up to 160,000 transactions per second as advertised. But if you go look at the actual paper on this, what it's really doing is, well, it's doing simple payment transfers. What machine is it doing civil payment transfers on? This is something I want to dig into your heads. Whenever you see a number like this, this number is irrelevant. It's irrelevant in isolation.
01:01:50.050 - 01:01:57.816, Speaker B: It can only become relevant when you know two things. At least. One is what kind of transactions are they? And two, what is the target machine?
01:01:57.888 - 01:01:58.360, Speaker A: Yeah.
01:01:58.480 - 01:02:01.424, Speaker B: Without those two numbers, the actual number of TPS is irrelevant.
01:02:01.552 - 01:02:02.500, Speaker A: I do agree.
01:02:02.800 - 01:02:35.390, Speaker B: So this blockchain that reports up to 160,000 transactions per second that shall not be named, does it with simple payments? Simple payments are not. Well, I mean, that's simple payments, right? It's not like a smart contract here, right? Simple payment. Even Ethereum can do quite, quite a bit of those, right? That's not something inherently hard. It's very easy to paralyze their benchmarks, which you can also read in their paper. Actually, anyone can download this paper and read it. I'm not making this up. I have it in front of me right now.
01:02:35.390 - 01:02:56.430, Speaker B: It's simple payments and also they don't fully execute the transaction. I believe they say something along the lines of they don't actually persist the changes to disk. Obviously, if you don't persist changes to disk and you keep everything in Ramdhenne. Well, I mean, yeah, no shit. You're going to do a shitload of TPS because you just have everything in ram. You're not persisting at the disk. That's the slowest part.
01:02:56.430 - 01:03:36.732, Speaker B: A lot of what we do at fuel is things like we don't have a global state tree. We use utxos that allow you to have fraud proofs. Without a global state tree, a global state tree is, well, a having global state tree would straight up make things slower. It would increase the size of the working state and it would mean that you have to hit disk more. Right. So we do a lot of stuff to optimize around state accesses because one of the ways fuel differentiates itself from a lot of these other chains that are coming out is fuel learns from the mistakes and the shortcomings of blockchains that came before it. It does not show up out of nowhere and say, hey, we came up with this amazing new thing without any attribution of why this amazing, why does it fix.
01:03:36.732 - 01:04:10.576, Speaker B: You can go again on our list of, we have fixed up exactly the links to the docs right now. It's not showing, but you can look at the source for the docs and prevention. I can provide it to you as well. So you can link it. The list of all the eips that have been proposed to Ethereum that we effectively implement either directly like exactly as specified in the EIP, or in spirit. So there's a progeny for why we do what we do. So this new blockchain for instance, and again it says it doesn't persist into the disk, simple transfers and it runs on a c five, a 16 x large Amazon AWS instance.
01:04:10.576 - 01:04:24.978, Speaker B: For those of you I am looking it up right now, I know how much it costs. It costs approximately $22,000 per year to run this node. Okay, that's like a non trivial, I mean, hey, that's more expensive than Atlanta node, I think, right? Even a slanted note is cheaper.
01:04:24.994 - 01:04:27.554, Speaker A: I think it's slightly cheaper, but okay, there slightly cheaper.
01:04:27.602 - 01:04:37.362, Speaker B: Anyway, so yeah, anyway, so this is, the specifics of this instance are an AMD EpyC cpu with I think 128 threads and 128gb of memory, right?
01:04:37.386 - 01:04:38.632, Speaker A: So what are the specs again?
01:04:38.706 - 01:05:19.160, Speaker B: An AMD Epyc cpu, which I think has 128 threads, but don't quote me on that. And 128gb, sorry, of ram. So this is like, this is a pretty big machine. Now, can a consumer afford this? And this is where I'm going to actually side with those lana folks here and the big blocker folks, which is that, I mean, yeah, sure, a consumer could afford this. So this is not out of the realm of a consumer running a full node. What it is out of the realm though is all of the user base, potentially billions of users, being sovereign. Because those users have to now choose on this new layer one that is 160,000 transactions per second.
01:05:19.160 - 01:06:02.832, Speaker B: Either run a full node and spend $20,000 a year, a lot of money if you're living in Africa, or trust an honest majority of validators. That's where fuel being a modular execution there gives you the maximum security with fraud and validity proofs. It allows you to have that third option. You can have a trust minimized like client, you can have a lite client that basically has the same security as a full node because of the fraud proofs. Because this is still within the range of prosumers that can afford this. People that are reasonably well off can afford this and will run this if the chain is sufficiently utilized, and you only need one of them to be able to submit a fraud proof. This would be an okay amount of money to spend on a full node if you had fraud proofs, but these new layer ones don't.
01:06:02.832 - 01:06:21.480, Speaker B: And if they had fraud proofs, it would greatly hurt their performance, because they weren't built around having fraud proofs in mind, they cut everything out that wasn't strictly necessary to have just this number. So, yeah, so again, whenever you see a TPS number, you always have to think what is the target node and what is the type of transaction?
01:06:21.560 - 01:06:25.296, Speaker A: So what is your target node and what is the expected throughput?
01:06:25.408 - 01:06:40.540, Speaker B: So that is where we haven't yet ran benchmarks. We're still in the process of developing some of the more performance tuning of our node. And until we have benchmarks, we won't say anything because we don't want to mislead anyone.
01:06:42.720 - 01:06:50.864, Speaker A: So that would also no leaks on the finality expectations either.
01:06:51.032 - 01:07:34.340, Speaker B: We can talk about finality expectations a bit, but I was going to bring up one more point, which is that once we do have benchmarks, one thing we do believe in is representative benchmarks. So once you do have benchmarks, anyone in the world will be able to take some code from some repo, be able to follow readme the scientific method style, and be able to reproduce these benchmarks, which the chains don't do. They give these numbers, but it's like, what transactions did you actually run? You say you ran XYZ, but I can't actually reproduce this. We will make reproducible representative benchmark. Well, it's up to you to judge of the representative. A lot of the subjective, for instance, simple token transfers, you can say, well, I mean, that's half of the guest used on Ethereum at a certain point it was. Right.
01:07:34.340 - 01:07:57.174, Speaker B: The tether transfer is one of the most used thing is like an exchange on uniswap. That's still fairly simple, right? And that was still uses. It's a huge gas guzzler. So you can say a gas is representative. So that's whether it's representative enough or not. I will not actually say that. It's up to you, the viewer and the runner of this benchmark to decide to, but the very least will give you reproducible benchmarks.
01:07:57.262 - 01:07:58.302, Speaker A: Okay, awesome.
01:07:58.406 - 01:08:38.882, Speaker B: So in terms of finality, now this is something that is less relevant for a modular execution layer. The reason being is that a modular execution layer can use a base layer as a timestamping mechanism, share security with a base layer, and inside the modular solution layer you can actually provide soft confirmations to end users. Things like the block producer at a particular slot is going to say, yes, I'm going to include your transaction here. These are the expected effects. I'm even going to sign. I'm going to sign some claim, and if I happen to lie, ok, you can slash me. The worst that can happen is I guess your transaction reverts and you slash the guy for a large sum of money.
01:08:38.882 - 01:09:03.377, Speaker B: Why would he even do that? There's nothing to gain by doing this because it's not like he can profit off your trade. If he profited off your trade, he would just profit off it. He wouldn't claim anything to you. Soft confirmations are things users are okay with. I'm okay with as well. Because again, why not? There's literally nothing to gain by someone violating the soft confirmation. And because of that, you don't actually need very quick time to finality.
01:09:03.377 - 01:09:41.112, Speaker B: To very quick time to finality. Just in general time to finality in the order of 30 seconds to a minute or whatever is something very easy to achieve. You don't need five second time to finality. And all the overhead that introduces, especially if you want to build things like a trust minimized like client. To have a like client, like client needs to think block headers, which means fewer lock headers, is actually cheaper to run a lite client, right? You can say, oh sure, I have a time dependent 1 second, but now you're doing so much more work for your trust minimized like client. But these blockchains that report fast finality don't care about like client, so they don't care about this.
01:09:41.216 - 01:09:52.298, Speaker A: Got you. Interesting. Very cool. That makes sense. And I'm guessing MeV works as any other kind of blockchain tool.
01:09:52.394 - 01:10:13.854, Speaker B: It's a smart contract blockchain trying to complete smart contracts. The fact that the Utxos are there from the perspective of using it for both users and developers, it's like a theorem. The Utxos don't exist. There's access lists now if you want to use Utxos, if you want to use predicates and define some really complex spending conditions, you have the flexibility, but the average end user isn't going to use that. They're just going to call contracts.
01:10:13.902 - 01:10:14.286, Speaker A: That makes sense.
01:10:14.318 - 01:10:18.406, Speaker B: And the contacts exactly the same Ethereum, the same mev thing as Ethereum.
01:10:18.478 - 01:10:39.044, Speaker A: Nice awesome. Very cool. No, it's very exciting work that you guys have been working on in regards to. I know obviously there's very close relationships between Celestia and fuel. Is the plan ultimately just be Celestia focused, or will this be able to be kind of more chain agnostic?
01:10:39.212 - 01:11:16.432, Speaker B: No. So one of the beauties of being a modular execution layer and not just a roll up in Ethereum, is that the way we build the protocol, the guarantees it provides, and so on, are agnostic to the base layer. So if we do want to launch an instance of the fuel network across multiple chains at once, including, for instance, as a sovereign roll up on top of Celestia, on top of Celestia, then it'd be very easy for us to do our initial plans, since Celestia is still in development, for our fuel is to launch on Ethereum, to be a modular execution layer on Ethereum. But once Celestia is live, then that's certainly something that we'll very much be looking forward to.
01:11:16.496 - 01:11:47.760, Speaker A: Got you. That makes sense. Very cool. Yeah, awesome, awesome stuff. I know we touched upon the unnameables briefly. I think ultimately the industry is always kind of comically narrative driven, and I think right now the narrative is kind of the new meta or Facebook chains, Sui and Aptos. What would you kind of say? Both of those also doing parallel execution in the virtual machine or execution environment.
01:11:47.760 - 01:11:58.860, Speaker A: What would you say are the biggest differences? I don't know if you've looked into them too much, but maybe on a high level kind of comparing and tracing.
01:11:59.280 - 01:12:03.000, Speaker B: Between move based blockchains and fuel, sure.
01:12:03.080 - 01:12:21.814, Speaker A: We can do move. I'm guessing maybe. Are there any big highlights that you would call out from the execution environment standpoint? And then maybe also, obviously, you guys are building sway and then comparing that to maybe move, the programming language.
01:12:21.992 - 01:13:10.538, Speaker B: Yeah. So in terms of execution, I guess so. The fundamental underlying VM for these movies, blockchains, such as Sui and Aptos and the other five or whatever, is the move virtual machine or some variant thereof, instantiation, I forget the exact word. And the issue with the moviem is that it wasn't necessarily designed to have maximum performance, and it wasn't designed with learnings from other virtual machines that came before it. It was designed to have certain formal guarantees around certain very specific ways of modeling asset transfers, hence moving assets. The issue is doing all these checks, doing all this stuff means that you're sacrificing performance. It wasn't designed to squeeze out every last bit of performance.
01:13:10.538 - 01:13:53.806, Speaker B: The fuel VM was basically the state of the EVM. It's a virtual machine whose model is, okay, we understand it. Let's implement all these improvements, and let's optimize the hell out of this design. Things like using registers instead of stack, other stuff like that, changing some instructions so that you don't have to call 100 instructions, but you just call one and so on. It's a very counterintuitive model, actually, how we designed the instruction set of the fuel virtual machine, because for the longest time, people were thinking, well, let's reduce the instruction set, let's make it simpler. A lot of early talks about the ethereum virtual machine were saying, oh, it's so simple, reduce instruction set. And that's actually the wrong thing you want.
01:13:53.806 - 01:14:30.364, Speaker B: That's actually the exact opposite of what you want to do in a blockchain. The reason being is that for every instruction you execute in a blockchain, you have to pay gas. You have to do gas accounting. You have to submit the gas, then compare it to see if you have enough. If not, then you have to break out, and so on. And, and this gas accounting adds overhead for every instruction executed. In other words, if you could execute something in 100 simple instructions versus one more complex to implement instruction, your virtual machine should actually have the one more complex instruction, which is the exact opposite that people have been building virtual machines and potentially arm based cpu's for the last x number of decades.
01:14:30.364 - 01:15:04.996, Speaker B: People have been trying to make instructions that simpler. Blockchain VM, because of that very high overhead of gas accounting. You actually have to make the instruction set more complex, more expressive, to reduce the number of instructions you execute, because that overhead is just so high. Greg Colvin, people call him some wizard or something. He deals a lot with very low level implementations of the Ethereum virtual machine. He calls the EVM a gas accounting machine that does computation on the side, because the gas accounting is just so, the overhead is so damn high. So things like the movie and weren't designed to squeeze out that performance.
01:15:04.996 - 01:15:38.800, Speaker B: They were designed to have certain security guarantees under a very specific and obtuse model of doing asset transfers. And this bleeds up into the move language. So, similarly, the move language wasn't designed to be easy to use. It was designed to move assets around in a very specific way. And there's a lot of things that you can't do with the move language and the move virtual machine. Things like, okay, there's a formal prover, there's a formal approver of certain properties of your program, but to know all the properties of your program. You need to know all the other programs that your program can call into.
01:15:38.800 - 01:16:08.080, Speaker B: If not, well, then just like an FFI, just a big black box. That thing can do anything. This means you have certain restrictions. For instance, you can't call contracts that were deployed after yours, because then you wouldn't actually know the program code when your contract is deployed and the move prover wouldn't be able to work. Think about a smart contract wallet, for instance. I would like my smart contract wallet to be able to interact with contracts that were deployed after my smart contract wallet. You can't do it with this move.
01:16:08.080 - 01:16:41.700, Speaker B: You also can't do things like reentrancy. Now you might say, why would I ever want to do re entrancy? There's potentially a few reasons why you might want to do it, but you can't do this in move. Just fundamentally, the language does not allow you to do it. And sway, you can do it, it'll warn you. But if you want to allow reentrancy, or if you want to have reentrancy for whatever reason, it allows you to do it because the language doesn't restrict you in these ways and the virtual machine doesn't restrict you in these ways. There's also the fact that the move, now I guess we talk about the language last, the virtual machine. The move language is still very immature.
01:16:41.700 - 01:17:05.172, Speaker B: You can't really do much with it. Things like they don't have generics. You can be generic over assets in the sense that, okay, I can build a smart contract that accepts multiple coins, that's generic over assets. But the actual types, they have no generic type. So you can't do things like make a vehicle that's has different colors or something. They don't have that. They don't have exhaustive pattern matching, which is actually non trivial.
01:17:05.172 - 01:17:26.950, Speaker B: To implement, you can check out our amazing compiler engineer, Emily, who has various talks about this way language that you can find online. She implemented our exhaustive pattern matching algorithm, which is the same as rust. Sway is based on rest. No surprise there. They don't have that. Also, we have a very extensive standard library. It's growing by the day and we want to make it even more extensive.
01:17:26.950 - 01:18:24.092, Speaker B: One of the things we can do, due to the memory model of the fuel VM, which is rather than the linear memory of the EVM, we have a stack and heap based fixed amount of memory. This means you can have heap types, things like vectors in memory, hash maps in memory sets, things like this that you can't have in solidity really, unless you want to go really hacky into the non assembly and stuff. We can write these very easily in sway, actually, and we have a implementation of a standard library, vector in Sway. It's entirely written in software in Sway and compiles down to bytecode and stuff, but it's entirely in software for move. It actually requires support from the move virtual machine, which I don't know if you said hardware, but I guess virtual hardware requires support from the move virtual machine for vectors. And that's basically the only collection they have in their standard library. The one thing, they don't even have things like signature recovery in their standard library.
01:18:24.092 - 01:18:33.316, Speaker B: What can I do without signature recovery and without generics, they can't have results for anyone who's used rust. Have you used rust?
01:18:33.468 - 01:18:34.412, Speaker A: I have not.
01:18:34.556 - 01:18:37.720, Speaker B: Have not. Okay. Have you used go by any chance?
01:18:39.020 - 01:18:49.100, Speaker A: I've kind of taken a step back. I try to focus now mostly on just kind of more like the product experience.
01:18:50.360 - 01:19:25.324, Speaker B: We're talking about product experience here for developers. So rust has this notion of a, some types, and b, generics that allow you combine together allow you to have this thing called a result in the rust standard library. And we also have a result. And the trick about a result is it kind of wraps a result. So it'll either say, okay, you have an okay value or an error value, and if you want to actually get to that value, you have to unwrap it. And by unwrapping it, you kind of have to explicitly handle either case. This avoids things like returning some magic value in case something failed.
01:19:25.324 - 01:20:09.708, Speaker B: The kind of common thing that this will show up in the Ethereum land is in solidity. If you try to recover a signature, verify a signature, but it's invalid, it won't crash, it won't revert to, it won't return some results because results don't exist. It will return zero. If you don't check for this magic value, you don't read the documentation and manually check for this magic value, which the compiler won't warn you about, first of all, which is the compiler should probably warn you about that you should check that value against zero, but it doesn't. If you don't check against zero, you could do things like someone could spoof there the address zero by just providing any invalid signature. Boom. They're spoofed at address zero.
01:20:09.708 - 01:20:33.320, Speaker B: If address zero is your burn address, congratulations. Now someone has access to all those coins with sway and things like rust, it actually wraps the return type in this result. And if you want to unwrap it. You have to explicitly handle either case. And if it's their case, then you can do things like revert, but it has to be explicit in your code. And if not, your code just doesn't even compile. So we have things like this that the move language doesn't have.
01:20:33.320 - 01:21:21.790, Speaker B: Fun fact, when we started looking into developing our language because, okay, we need a better experience than solidity, that is for sure. We don't want to touch the solidity compiler because it's c, and those guys are fairly opinionated about what goes into the compiler or not. We looked into move, we looked into move like two years ago or something, about two years ago and we looked at it and since from then to now it has changed very little, which is very disappointing. We created a whole damn language and a whole tool change from then to now. And the move language has very, it's barely changed, right? And again, it's missing all these features that we have managed to implement ourselves. Things like sum types and things like generics, things like exhaustive pattern matching, an actual standard library, a software implementation of vector. We've implemented all these things and they're still lagging behind, so we're ahead of them already, despite them being in development for like four years or something.
01:21:21.790 - 01:21:25.830, Speaker B: I don't know, when did Libra come out? And that gap is only going to widen in the future.
01:21:26.890 - 01:22:12.216, Speaker A: I'm very interested to. I mean, it's obvious that you've put a lot of thought into all the holistic developer experience and all the minutias that make smart contracts difficult to code. I'm super excited over time to see how everything unfolds and what developer platforms or programming languages people ultimately choose to pick up. But it's super exciting. There's obviously always something crazy and different happening in crypto, but I'm excited that you guys specifically are trying to address these very hard problems.
01:22:12.328 - 01:22:53.860, Speaker B: Yeah, and I think a lot of it has to do, again, to reiterate yet again, is learnings from the mistakes and shortcomings of existing blockchain development tools and the blockchain vms and so on. And that's because I wrote a number of smart contracts. My co founder Nick wrote the whole damn fuel v one all on his own, like in a cave with a box of scraps he had to use. He actually had to create a new language called Uoplus because it was so terrible and he didn't want to use it. And Uoplus was basically just some syntaxic sugar on top of you all. But I still a slight extension to you. So he basically wrote the whole contract in Yuel fuel vue on it, actually, the whole contract, fun fact fits into one contract, the whole thing, anyways.
01:22:53.860 - 01:23:40.714, Speaker B: And the fuel protocol was built not by people who just came in out of nowhere from a separate industry saying, hey, I have industry experience building hardware. I was at Qualcomm or like, oh, you know, I have some programming language theory PhD, right? I know how to write a new programming language that has XYZ properties. Fuel was created by people who built on Ethereum, such as myself and Nick, for people who have built on Ethereum, not just exclusively, but we know and we have experienced personally the pain of developing on Ethereum. And we do not want other people, especially new entrants into the space, to have to experience that pain any longer or again. And that's why we're building what we're building, learning from the pain that we've had in the past.
01:23:40.802 - 01:24:03.470, Speaker A: Yeah, I think it's beautiful. Excited that you guys are building it. Maybe just a couple closing thoughts. And then I normally try to end the podcast with what I call spicy takes. But do you think ultimately, unlike a high level, most virtual machines, or all virtual machines will be parallel in the future?
01:24:05.540 - 01:24:39.598, Speaker B: I expect a lot of the virtual machines that people introduce into the future and new innovative virtual machines that come out to be parallel, the general purpose ones. I also expect a number of application specific chains that don't necessarily need parallel virtual machines or even general purpose virtual machines in general, because application is specific. But in terms of general purpose virtual machines, I very much do expect all the new ones that come out to be parallel for the simple reason that you just have cpu cores sitting there doing nothing. And modern cpu's year over year aren't getting that much faster in single threaded performance.
01:24:39.694 - 01:24:40.158, Speaker A: Exactly.
01:24:40.214 - 01:25:12.452, Speaker B: But they are getting like, damn, way more cores. And my phone has, I mean, maybe not this one, this one's five years old, so maybe not this one. But like, modern phones that easily have, you know, eight cores or whatever, 16 threads, something along the line. Even phones, you know, computers have, have way more. The notion of, you know, 16 cores being out of reach is like not out of reach anymore. These things are the even, like, not even prosumers, even regular consumers can easily get 16 cores. So it is absolutely the case that I think anything new that comes out, if it doesn't have a parallel transaction execution, you just throw in the bin because it means clearly they haven't been following what's been happening.
01:25:12.516 - 01:25:34.888, Speaker A: Yeah, no, I fully agree. Maybe some thoughts on, I mean, I think we've touched upon it a lot, but just maybe in 1 minute high level on maybe sharding or kind of Ethereum's roadmap, and then one, two minutes on Celestia as well.
01:25:35.064 - 01:26:18.442, Speaker B: Well, with respect to Ethereum's roadmap, I mean, it changes so much, so it's hard to tell. I mean, for those of you who aren't familiar with Ethereum's roadmap, actually I was involved in a decent amount of eth two research back in the day at consensus before I left start the things. So I have been around the block. So I've kind of seen it back in the early days. There was definitely a lot of back and forth around various ideas, which is good, it's good to explore and stuff. But that being said, the notion of sharding, as people thought about it three, four years ago, whatever, doesn't exist anymore in the Ethereum roadmap, sharding is not a thing. They have completely removed the notion of execution sharding.
01:26:18.442 - 01:26:44.990, Speaker B: It's no longer even on the extended roadmap, on the near term roadmap, in other words, in the next five years or so, they're looking at this thing called dank sharding. But dank sharding is not sharding. It's a proper noun. It's not actually sharding. It's a single blob with data availability sampling. In other words, it's fundamentally the same paradigm as Celestia. They do various things with committees and whatnot, which is a bit debatable about the security, but I won't get into that.
01:26:44.990 - 01:27:09.210, Speaker B: But it's not sharding. Sharding does not exist on the Ethereum roadmap anymore. It's purely just the same model as Celestia. With this, I don't want to say monolithic, but a single blob that you do data availability sampling over. That's the TL, Doctor, Ethereum's roadmap. Now they are planning to do various things in the interim before getting to that within a five year period. Things like merge to bring proof of stake finally.
01:27:09.210 - 01:27:40.652, Speaker B: And then I can finally buy a new graphics card when the prices crash. I've been waiting for this. My old graphics card may or may not die. Who knows any isn't that there's various things they're doing in between. Then there's a proto dank sharding, which is not the same thing as dank sharding. That could also increase the throughput of data availability on the Ethereum chain. So that's kind of my thoughts about the Ethereum, or should we say, what is it now? Okay, the consensus layer, roadmap, that's taboo now.
01:27:40.676 - 01:27:52.728, Speaker A: No more eth two, and then maybe some kind of high level thoughts, one to two minutes on Celestia and the work that they've been doing as well, and maybe the synergies on fuel.
01:27:52.824 - 01:28:45.162, Speaker B: Yeah, so obviously I'm a bit biased, but I think the work that Celestia doing is also absolutely incredible. Some of the smartest people I've ever met in my life and that I'm working with and pleasant people that I've had the pleasure of working with. It's taking the approach of minimizing everything and going straight to this notion of data availability sampling that gives you a very, very high throughput of just bytes per second. Now the problem is bytes per second are not transactions per second. And this is where a lot of the synergy in the two projects that I'm working on comes in, which is that a scalable data layer without an execution layer on top of it to actually use those bytes per second, well, it's kind of worthless, right? The whole point of the block. Well, there's a few points for blockchain, but one of the main points of the blockchain is that we have shared state. But if you don't have state, because you don't have, if you don't have shared state, because you don't have any state, then you don't have that use case.
01:28:45.162 - 01:29:19.760, Speaker B: So you need some mechanism to get shared state, and that's called an execution layer. So you need an execution layer on top of your very scalable data layer. And you ideally want an execution layer to be thing the dev properties like composability, composable atomic contract calls, and you want it to be scalable. So to solve the scalability problem and to really get end users that very high throughput and that very high security, you need both a scalable data layer and you need a scalable execution layer. And that's where the projects that I'm working on synergize, because they're essentially tackling the scalability problem from its two sides.
01:29:20.100 - 01:30:07.976, Speaker A: Nice. Hopefully in the future or past, whenever this podcast comes out, we'll, I'm just excited for Celestia and also fuel to be live. So very excited for both of those things and kind of the scalability and the different approaches that they take to scaling. Super interested in it all. Maybe just to wrap it up. We've been talking for almost an hour and a half. What are maybe some spicy takes, what are outside of celestia, and fuel some blockchains, maybe one blockchain that you think is scaling uniquely well, and then one that you think is just like.
01:30:07.976 - 01:30:11.752, Speaker A: Like doing it very poorly, one that.
01:30:11.776 - 01:30:17.528, Speaker B: Does it uniquely well, unfortunately, you excluded the project that I'm working on.
01:30:17.584 - 01:30:19.752, Speaker A: But that's why it's spicy.
01:30:19.816 - 01:30:54.716, Speaker B: Yeah, that's why it's spicy. When that is uniquely well. Solana is not inherently bad, right? They have certain issues. Well, they definitely have certain devx issues with respect to, you know, they want developers to e class their account the way they do Solana accounts and stuff is very cumbersome. But that being said, they do have a non trivial number of performance implementation optimizations that I've talked to Anatolia before about. Those. I think the no execution podcast, episode zero, the special episode, you guys can go find it on the Celestia website, whatever.
01:30:54.716 - 01:31:13.708, Speaker B: Celestia podcast, where I had a conversation with Anatoly about this, and I praised him back then, which was a couple of years ago, and I'll repeat it now, which is, I think they've implemented a number of very interesting implementation optimizations, largely in part due to their background being engineered as. Was it qualcomm or something like that?
01:31:13.724 - 01:31:14.156, Speaker A: Qualcomm.
01:31:14.228 - 01:31:35.352, Speaker B: Qualcomm. There you go. So they've implemented a number of these optimizations that are very clever, very neat, very performant, very good. But as before, the entire blockchain as a whole is not just performance optimizations. You also have to worry about things like developer experience. And that's why I think things like fuel will shine. Now, in terms of which blockchain is.
01:31:35.376 - 01:31:36.888, Speaker A: Doing things uniquely bad.
01:31:36.944 - 01:31:46.248, Speaker B: Uniquely bad? Well, I mean, there's so many of them. Which one is doing it uniquely bad? Well, I mean, I could talk about Cardano specifically.
01:31:46.344 - 01:31:49.336, Speaker A: Okay, you're gonna upset the Cardano Maxis.
01:31:49.368 - 01:31:52.352, Speaker B: But let's do it. Okay, well, I mean, I have to upset someone, right?
01:31:52.376 - 01:31:54.696, Speaker A: So it's either Cardano Maxis.
01:31:54.728 - 01:32:15.600, Speaker B: Yeah, sure. It's either the red triangles or it's the Cardano graphics. Okay, so we'll go with Cardano guys today. That's red triangles. You get your turn tomorrow. So, because Cardano, you know, they're talking about, oh, they're all scalable, you know, this new smart contract language and all that stuff. I mean, first of all, the smart contract language is garbage, right? Because it's, like, based on Haskell and no one uses functional problems.
01:32:15.600 - 01:32:47.672, Speaker B: This is one of those things where again, it's someone coming in from the outside as opposed to from learning from the pain. They're coming in from the outside and saying, oh, from PL theory, functional languages have XYZ properties. They're the best. I mean, yeah, but no one uses them for a reason. And I don't even have to explain to you what the reason is. The fact that no one uses them tells you everything. They should not be used for smart contract development because it means you're gonna have two smart contract developers, right? I mean, Solana had one who was pretending to be eleven and like, I guess he did multiply their TVL by quite a bit.
01:32:47.672 - 01:33:38.940, Speaker B: So I guess two is good enough. Anyways, the issue with Cardano is that, which I briefly mentioned before, is that they have this issue of contention, which is that, okay, you have, say, uniswap style contract. If someone else goes in front of you and does the swap mutate or spends that Utxo, it doesn't exist anymore, which means now the user is not, that they have to retry their transaction, it's not their wallet can automatically resend their transaction. They have to fetch the new Utxo set, find that, you know, find that contract, and re sign a transaction and then attempt to spend and then attempt to send the transaction. And that whole process is like, it shouldn't take a gigabrain to figure out that is absolutely not going to work. Right. As soon as you have anything with like, you know, even a bit of users, there's no, there's no way like a user will actually be able to use this.
01:33:38.940 - 01:34:16.814, Speaker B: And, you know, there's various like, talks on Twitter about this. And that's where I'm like, guys, like, I solved this problem like years ago. They talk up about the peer review and all the science stuff, but it's like, I published literally a solution to this exact problem years ago, but they didn't know it existed. So that is really the worth of their pure view of their science that they can't even look at the research that I'm doing. So they're doing things uniquely bad because the problems are already solved and I solved it for them. They just don't know about. Other ones at least are doing different stuff where I can't say I've done research in this exact area and they should just, just read my damn research and then they figure out how to do it.
01:34:16.814 - 01:34:20.414, Speaker B: They're doing all their stuff, so they're not as uniquely bad from my perspective.
01:34:20.502 - 01:34:42.810, Speaker A: Gotcha. Awesome. Well, no, I really appreciate it. John. I'm very excited for what you are building with fuel, and fuel labs is building. Excited for the work that the slacia team is continuing to build and more holistically. Just very excited for more users to come into this ecosystem.
01:34:42.810 - 01:35:06.522, Speaker A: Everybody that I've talked to is brilliant. They're building amazing things. But ultimately, if these applications do not scale or these protocols do not scale, it will only be a small handful of users. So I'm very excited that your team is specifically focused on the scaling problems and trying to bring more engineers and more users into the ecosystem. It's much needed. So thank you again.
01:35:06.666 - 01:35:07.586, Speaker B: Thank you for having me.
01:35:07.658 - 01:35:08.290, Speaker A: Awesome. Thanks, John.
