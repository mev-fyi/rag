00:00:15.480 - 00:00:35.530, Speaker A: Well, hello. Hello, everybody. Thank you. For all those that are tuning in. Really excited for today's episode. We have some very special guests. Sam, the co founder of Move and also one of the co founders at Misin Labs, and Rushi, who is the co founder of Movement Labs.
00:00:35.530 - 00:00:51.462, Speaker A: Really excited to have you on both gen one. Maybe just before we dive into all the nitty gritty on the tech side, can you just do a brief intro? I think, Sam, you've been on the podcast now a couple times. Maybe if we could kick it off. Rush, you just do a quick intro and then we'll pass it over to Sam.
00:00:51.606 - 00:01:24.540, Speaker B: Yeah, I'm a first timer, so thanks for having me. Yeah, I'm co found movement labs. My background is engineering, so been a nerd since I was a kid. Always was involved with distributed systems, systems at United Health Group, gone to crypto, started entering here and there, stumble caused this move language thing, which I was like, wow, the Facebook and the DM project is putting so much resources. Got really excited. I actually built the first Dex in Aptos. My co founder built the first yield aggregator in Aptos and really wanted to extend adoption and move and make it a standard for future of smart contract development.
00:01:25.280 - 00:01:26.180, Speaker A: Amazing.
00:01:26.960 - 00:01:27.344, Speaker B: Cool.
00:01:27.392 - 00:02:05.590, Speaker C: Yeah. I'm the co founder and CTO of Mist and Labs and the creator of Move. I started off my career as a programming language of the static analysis and verification researcher. Did a PhD working on building scalable static analyzers, went to Facebook and worked on stack analysis of Facebook for a number of years. While doing that, finding lots of bugs, developed a lot of opinions about how to create safer languages that avoid bugs by construction. Got the opportunity to join Libra and create move and then work on a lot of the execution layer and tech behind Libra, and then hopped out with a number of my colleagues who found Mistin Labs in 2021. And we launched SWE in 2023, May of this year.
00:02:06.250 - 00:02:31.246, Speaker A: Perfect. Well, maybe, Sam, to start it off, why kind of start a new programming language? Why not use solidity rust? Kind of started to gain some of the popularity for high performance blockchains. What was the thought process behind creating a new programming language that you just found that you the gap in the market that you really needed to fill?
00:02:31.438 - 00:03:01.350, Speaker C: Yeah, it's a really good question to ask because I think basically creating a new programming language is something that you should almost never do. It's definitely sort of like an anti goal. There's this funny, I'll send it so listeners can see afterward, like checklist of reasons why you don't need to create this language and then it'll have all these things. So when I joined Libra, actually my, I've been playing a lot with rust, and my instinct was actually like, oh, let's use rust. It has a lot of the properties that you would want in a language for smart contracts. It has this notion of scarcity. It has this distinction of borrowing versus ownership.
00:03:01.350 - 00:03:33.940, Speaker C: These are all things that are very relevant with real assets. The reason we ended up not going that direction is that, well, these properties hold at the source level when you're playing with the rest compiler, but when you're actually going to run the code, it compiles into LLVM and then the machine code, and you're not going to run the rust compiler on chain. That's going to be quite expensive, and it would have to be deterministic as well. You want something that has properties like that, but these properties can be checked at the bytecode level, not just at the source level. Then the other thing is that rust is a general purpose language. It's used for the low systems programming. You can use it to write applications.
00:03:33.940 - 00:04:08.748, Speaker C: You can do all sorts of things with it. They don't have a specific niche that they're trying to hit, whereas smart contracts are a very, very idiosyncratic and much smaller program. They only do a few kinds of things. You transfer, create and share assets, and you check access control properties. That's it. You're not going to be writing compilers, you're not going to be building a system, and you're not doing file I o. So really like you want to build a language, I think, and this is a good time to create a new language where it's like you have an emerging application domain, you don't have something that really fits what programmers in that application domain are trying to do, and you have an idea of how you can express those fundamental abstractions better than what's out there.
00:04:08.748 - 00:04:22.650, Speaker C: And so that was, the solidity was out there, but we felt like we see what folks are trying to do with this. This isn't done in a way that's as safe or as productive as it can be. And so we're going to take some of these rust ideas with what we've seen people try to do with solidity, and that's where move came from.
00:04:23.030 - 00:05:11.350, Speaker A: And I think, I mean, we've kind of talked about this a good amount in our past podcast definitely recommend those that have not listened to them to check them out. But it's really like there's a lot of brilliant people within crypto, a lot of brilliant people within web3 on the engineering side. And some of these kind of reentrancy bugs happen over and over again. Uh, and they're very hard to kind of abstract because they're just not baked into like the core programming language, maybe passing it over to you. Rushy, was there anything particular that caught your eye about deciding to build movement labs and using the move programming language or moviem as well when you decided to check out the different landscapes and really decide what you wanted to contribute to the industry?
00:05:11.880 - 00:05:51.594, Speaker B: Yeah, I think I come from a point of view where I was just a lowly engineer and just like tinkering with different blockchains, and I was like Billy on Ethereum at one point. A, the fees were so ridiculous for I was trying to build a paralyzed or book, and b, there's obviously like no paralyzed vms on Ethereum at the time. This was like a year and a half ago, I want to say. And like, the gas fees were so high, but on the security side, I was like, didn't have a lot of capital. I was like a college kid, like eating ramen in my basement. So I was like, I can't afford these auditing fees to even get my app on main net. And then b, when I'm trying to deploy these apps, if you look at the Kyber attack, it was like a 0.001%
00:05:51.594 - 00:06:55.850, Speaker B: chance you could pick that up. And now you have a Kyber dictator on that running the entire app. So when you think about the landscape of, okay, if I'm trying to spend resources and actual time on building a defi app, a gaming app, and pushing it to mainnet me as like a single developer without like a big team, I'm probably not going to be able to catch all these different edge cases and solidity that like an Aave, one of these big blue chip protocols can. And even in those situations, we've seen like major defi hacks, like curve attack, the Kyber attack, pretty much every big attack is crippling the industry. So the thesis, when people ask, like, why move? Why are you so bullish on, like, because you need to, right? If you're ever going to buy this thesis that like millions of people are going to use blockchains and like, you have millions of developers come to ecosystem, they're not going to write solidity because the barrier to entry is so high. When you look at any consumer apps that are built on web two, you could push code things like Zuckerberg and his college dorm you could push go and not have to necessarily worry about getting hacked and losing millions of data with movies. Finally a solution for that where you can increase the production of velocity production.
00:06:56.550 - 00:07:22.430, Speaker A: And maybe to that. One of the criticisms that I hear of new virtual machines or specifically new programming languages is like solidity already has moat. All the engineers that are interested in web3 are building on solidity. Maybe to both of you, what is your pushback? Or answer to the question that solidity has already won?
00:07:22.930 - 00:07:51.058, Speaker C: So I think these network effects are overstated just because the overall web3 developer community is so small. I think if you look at say electric Capital's numbers, which are the best ones I know of, I think there's 16,000 full time web3 developers. That is a tiny, tiny number compared to conventional developer communities. If you look at the iOS developers, I think there's 12 million. If you look at JavaScript development, there's 16 million. This is many orders of magnitudes larger than the web3 community. All of us are interested in increasing the number of web3 use cases.
00:07:51.058 - 00:08:23.518, Speaker C: There are growing the community of users, growing the community of developers. If this is going to become a real thing, we're going to need a lot more than 16,000 developers. If we get to hundreds of thousands of developers, millions of developers, that 16,000 is a rounding error. And then also there's a better technical solution like, or obviously very biased. But I think move is more productive, I think it's safer. And I think a lot of solidity programmers are very interested in it and are just stuck with the baggage of being on these existing platforms where that's the only choice they have. So I think both of those things make me think that it is not even close to too late to change things.
00:08:23.654 - 00:08:30.158, Speaker A: I think 16,000 is even less engineers that meta has directly, a lot less.
00:08:30.334 - 00:09:18.882, Speaker B: Yeah, I think when people say like the EVM has won, I'm like okay, what do they win? Like you got like five apps, you got like five users on chain like 10,000 developers. Like if in this hundred year landscape of like blockchains it's very very small and minutes. I think the way we address it is with we built a transpot essentially that takes Soli op, Soli script, Soli opcodes and maps it to the movie similar to like Solang Aslanae. And that's also like an area of collaboration potentially with the swede system where we can bring even compatibility to the move network to solve for the short term network effects, especially in bear markets where resources are difficult. I think the concept of network effects and sticky liquidity is a bear market principle. Obviously, Swede launched in the bear market. Moo is actually launched in the bear market and still is doing really well.
00:09:18.882 - 00:09:36.848, Speaker B: I think it's very forgotten. Yeah, we launched after FPX went down. Right. Probably not the best situation. And even then, we're seeing people actually speaking the language. So especially in bear markets, when time is tough, like experimentation is limited. So in those events, people are going to flock to the EVM and say the EVM has won.
00:09:36.848 - 00:10:05.430, Speaker B: But when there is liquidity system, when you look at a ten year landscape, there's more experimentation, which is actually what the module thesis allows, which I'll get more into later. But essentially the way we approach it is the short term. Sure, EVM compatibility, not the exact way we want to go about it, but it's how you get over the stubborn people on Twitter and like the mind share. Right. And long term, we're working with SWE, working with other folks to really establish move as a dominant execution environment for the next ten to 20 years.
00:10:06.130 - 00:11:00.034, Speaker A: And I think maybe that's a perfect segue. Ultimately. Historically, I feel like the entire blockchain industry has really been focus on the Ethereum virtual machine, which I think everybody in this kind of livestream can probably appreciate is not the most optimized. There's a lot of things to ultimately be desired. But I think today what is amazing is the conversation is really shifting to single threaded virtual machines that cannot do parallel processing to parallel processing virtual machines. And I think within that move has kind of become front and center, as well as kind of the Solana virtual machine. But within that you can even go even deeper into the different types of kind of move programming language, even the move vms, maybe.
00:11:00.034 - 00:11:13.130, Speaker A: To Sam, can you talk a little bit about specifically the SW move and what kind of advantages that suemove has versus others, or maybe even compare and contrast there.
00:11:13.550 - 00:11:33.182, Speaker C: Yeah, so I think the easiest way for this is to start with the story of like, how move evolved to where it is today. So, you know, the language started in 2018 at Facebook. I was a creator. We added a bunch of folks as part of diem. We evolved move. Diem was supposed to be a compliant payment system. We added a lot of features that were for generic programming.
00:11:33.182 - 00:12:20.218, Speaker C: We had a lot of features that were somewhat specific to that use case of implementing a compliant payment system. When I hopped out to start Mistin with my co founders in late 2021, we took a look at launching Diem as is, and we looked at, well, this is a compliance payment system we want to build that is supposed to run on a single box. We want to build a horizontally scalable smart contract platform that allows arbitrary programmability. So we took a from scratch look at all the aspects of DM and then included Moo. Like, you know, which parts of this do we want to keep? Which parts of this do we actually want to change? Given that, like, the goal of what we're trying to build is different with move, we mostly like what we saw. The one part that we thought the one part that we wanted to do, the one part that we decided to change at this point, was originally move had this data model that was address. Like, the global storage is keyed by this pair of address and type.
00:12:20.218 - 00:12:56.086, Speaker C: And this lets you, if you're trying to do. And then, so there's no notion of built in transfers, like the program has to handle them. And this lets you implement all these restrictions we need. In a DM, there were capital controls, certain kinds of addresses weren't allowed to have, certain kinds of assets enforce that by construction. Whereas in typical web3 programming, like, you want everything to be transferable everywhere and, you know, to be usable everywhere, that's where, that's where composability comes from. And so we're like, you know, if we started again with a different goal, what data model would we use? And this is where this object data model that we're using now comes from. So the object data model, there's a number of advantages.
00:12:56.086 - 00:13:27.038, Speaker C: So the first is that you have native ownership. In other smart contract languages, including older versions of move, ownership is just whatever the code says, who can access it? That's what it is. But it's to even understand that you have to run the code and see, or it's part of a particular standard. Maybe ERC 721 would have an is owner field, but something else would define ownership differently. Now we have native object ownership. The global storage consists of objects, and each object has an owner field on it. That could be an address, it could be another object.
00:13:27.038 - 00:14:13.032, Speaker C: It can say this is shared, which means anyone can interact with it. This really improves security, because if you have an object that's owned by a particular address, it's not even possible to send transactions from a different address that touched that. A lot of web3 hacks come from stealing assets, and so you take the option off the table to implement ownership incorrectly, then you get much, much better security, and you just get a lot of things better at construction. That's very fitting with the core values of safety by default. If there's something where I, it's a problem where someone can introduce a mistake and you can take that thing off the table entirely, then of course we want to do that. This is, I think, by far the biggest advance we've made in move since the early days. The other thing the object data model lets you do is you can have explicit object inputs with move.
00:14:13.032 - 00:14:48.182, Speaker C: If you're calling a move function from another move function and you've got an object on the stack, of course you can pass it to that function, and of course you can return it. This is one of the big advances over solidity, and we've always had that. But before things were very different at the transaction level. It used to be that transactions have to take pure arguments like integers, bytes, booleans, whatever, but you can't just call a function and pass an object to it directly. But now with the object data model, you can do that. There's no difference from calling a function at the transaction level or inside of move. If you're going to call a function that transfers an NFT, you just pass the object and then it transfers it.
00:14:48.182 - 00:15:07.200, Speaker C: Then from the programming experience perspective, your code starts off by having the objects you want sitting right there in the arguments and you start writing your business logic. Instead of, oh, my code starts off by I read the object from somewhere, I check some, I do some access control checks, and then I'm off and running. It makes your code a lot shorter and it eliminates the possibility of mistakes.
00:15:07.700 - 00:15:10.520, Speaker B: And then finally, go ahead.
00:15:10.900 - 00:15:12.412, Speaker C: No, jump in. Richie.
00:15:12.436 - 00:15:52.380, Speaker B: Yeah, I've been, a question I had from an outside perspective is, do you guys have numbers for how much more secure sweet move is compared to solidity or other styles of rust based programming languages? It's something that we're focusing on right now because I think it's qualitatively it makes sense, like why move is better. But one thing to like the broader Ethereum communities, or even like sonic communities or general communities, is when you can say like, move is x percent safer than solidity. It solves x amount of attacks, making you able to deploy your code x percent better. That's a clear pitch that I don't think I've seen visualize anywhere. So wanted to know if you guys started any of that, and if not, happy to work with you on that.
00:15:52.500 - 00:16:02.160, Speaker C: So these things are hard to quantify, but the number I would focus on is zero, which is the number of smart contract attack, smart contract hacks on SWE, you know, of course like, this isn't going to last forever.
00:16:03.300 - 00:16:07.092, Speaker B: Don't take yourselves, don't change yourself, and.
00:16:07.116 - 00:16:35.170, Speaker C: Prevent programmers from writing unsafe code. You know what happens. Something like the Kyber attack, like move doesn't prevent that, right? Like this rounding, you know, route. Like, you know, we have lynchers against rounding, but like, you know, if someone's going to round in favor of the attacker instead of the program, that's very, very hard to prevent. So I think, like the, you know, it's hard to quantify these things, but I think you gotta, like, the best number I could think of is like, look at the number of attacks, look at the amount stolen. Maybe average that over the amount of time the platform has been live. And I think you're gonna see another platform doing better.
00:16:36.070 - 00:17:03.982, Speaker A: Do you think, I mean, particularly the kind of object oriented model a lot of technical people do watch this. But for the non technical people, is it just, how would you translate that? Is it easier for engineers to write smart contracts? As you've kind of communicated, the ability for security is higher. But what does that relate to, to the user standpoint or someone that's not as technical to understand some of these concepts?
00:17:04.166 - 00:17:45.022, Speaker C: Yeah, that's a good question. I've been describing mostly from the programmer's perspective or even the language design perspective. Ultimately, the question here is, who really cares? What is the user are going to get out of it? So I think one of the things at the design and program perspective that you get, but then it's going to translate to something better at the user perspective, is better composability. I think there's two ways. And Swede, we particularly use this in an interesting way, and new kinds of standards. One that we've just talked about recently is called closed loop tokens there. The problem that we're trying to solve is that if you're a real world asset issuer, you're going to need a lot of restrictions on your assets beyond what crypto native assets need.
00:17:45.022 - 00:18:36.590, Speaker C: If you just use a typical coin standard, you can't say something like, oh, I only want to trade my assets between nine to five on weekdays. Or you can't say, everyone who's going to own this asset is going to be KYC, or you can't say, I'm going to put restrictions on the amount that can be transferred. These things are just very, very hard to do because the standards are designed around crypto assets that are open loop and no holds barred. And the utility of blockchains comes from how many interesting assets there are in chain and how much programmability there is. So you really want to improve that and make sure that there can be more things. So this closely token system is leveraging the way that objects work. To have a special object where it always has to be held at the top level, an account, it can't be wrapped, and whenever it's transferred, the issuer of the asset can apply custom restrictions on properties that need to be satisfied before the transfer goes through.
00:18:36.590 - 00:18:58.610, Speaker C: All of the things that, all of the things I mentioned above, you can also put restrictions like this on smart contract usage. You can say, actually this can't be used by any smart contracts or it can only be used on this, on this deck. So we have an exclusive partnership with and things of this nature. So that's one thing I think that was definitely useful for the customers of SWE that's enabled by this object data model.
00:18:59.340 - 00:19:02.396, Speaker A: Maybe passing it? Yes, go ahead Ruchi.
00:19:02.548 - 00:19:51.548, Speaker B: I think one thing I noticed is when we're talking to web two audiences, the goal for any blockchain or new programming language or new execution environment is to bring in new developers. So we've done a lot of outreach, just folks from web two backgrounds like Sam obviously came from Facebook. And comparing sludity and JavaScript, Sludy is way far away from what they're picking up in universities or hacker bootcamps, whatever. When you come across moves like concepts like Scarcity, it's very similar to JavaScript even. I think there's an article from Bixon that's moves the JavaScript to web3. I think that kind of framing allows people to come into web3 and you actually get more developers because if it's similar to what they're learning in hackathons or university classes, it's more intuitive for them to pick up. It's also much more secure.
00:19:51.548 - 00:20:13.800, Speaker B: If you're writing solidity, you only spend hours debugging your code and then not having the proper resources and not having anything to compare it to with move. It's pretty similar to JavaScript, it's object oriented, the principles underneath it are pretty similar. It came from web to inspiration, obviously. I think it's just a much more intuitive language to pick up for onboarding new developers.
00:20:14.660 - 00:20:26.650, Speaker A: For those that are using movement, or the movement L2, Rushi, are they using the swee version of move or the Aptos version move? Or do you guys have a custom version of move that you're using?
00:20:27.070 - 00:20:59.370, Speaker B: Yeah, so when we started off, this is probably only Aptos live. The underlying VM is Aptos move vm, which is more derived from the DM original project. What we're working on right now is making the VM more universal, adding SWE bindings into it. I think SWE is actually live on Devnet right now, but we want to work in the cat models and make it more one to one parity. So we're looking at a ZK movie and potentially that can take was on script from both move on Aptos Moveon suite and then EVM compatibility and as well as other compatibility as well.
00:21:00.150 - 00:21:29.066, Speaker A: And maybe to Sam for you is there, I mean, for those that are trying to just wrap their heads around, what is the core differences between like the Aptos version of move and the swee version of move? Is the Aptos version of the move in your mind kind of that original design that was created at meta and that the sui move has expanded upon it? I don't want to fill your words for you, but just expanding upon kind of the differences in your mind particularly.
00:21:29.218 - 00:22:07.420, Speaker C: I mean, I think we've said as a fair characterization, the other parts of how movies evolved that I had mentioned besides the object data model or that we have dynamic fields. And so this is the feature that if you have an object, you can attach other objects to it. And this allows you to create rich hierarchies of objects. Like I've got a character in a game and now they're going to have a sword and a shield that are also objects. And maybe like the sword itself has a scabbard that hangs off of these sorts of things. And then programmable transaction blocks. If dynamic fields are giving you object and data composability, then programmable transaction blocks will give you contract and function composability.
00:22:07.420 - 00:22:37.646, Speaker C: In diem, we originally had scripts for this, or so called transaction scripts, where it's like, okay, you publish smart contracts for use cases that are common, and then you write a one off script. If you're trying to do a one off thing. The problem that we found with that is that you can't really write a script. Often when you're trying to do these one off things, you're trying to do it from a front end or from an application. And you're not really going to write move source code from a front end app, not typically. Then you'll have to run the compiler. Usually if you're writing fresh source code, you have to audit it to make sure it's correct.
00:22:37.646 - 00:23:20.314, Speaker C: And these sorts of things, not the sort of thing you want to doing on the fly. So with programmable transaction blocks, what we've done is you can have a transaction that calls a move function, and then that it returns some objects and it pipes the outputs of the first call into the next call. And then you can do that again and again. And you can sort of have part one of the programmable transaction block has an output that goes into the third call that you make. And so that allows you to have this really rich ad hoc composition between contracts that don't have to know about each other or be aware of each other. You call a Dex and you get some coins from that, and then you're going to go do an Arb on something else, on some other Dex that you didn't know about. And then neither of those have to write code, they're explicitly calling each other.
00:23:20.314 - 00:23:44.700, Speaker C: There's no callbacks or dynamic dispatch in the way. It's just the fact that you have these objects as building blocks, as legos, that you sort of snap the different building blocks together makes this very, very rich. So I think those are the main differences, is that we have this object data model, we have dynamic fields, we have programmable transaction blocks. There's also a difference in the package upgrade model. I can talk about that, but I've again been monologuing for a bit.
00:23:44.820 - 00:24:24.910, Speaker A: No, you're good. I love the depth. I think honestly, being able to compare and contrast people want to understand these individual ecosystems, but then I always get the questions that are like, all right, how does this compare to this other thing? And maybe Tarushi passing it to you in terms of maybe, can you just go into a little bit more of what movement is? I think everybody's favorite conversation is really in the blockchain landscape around modular versus these integrated high throughput chains. Can you touch upon why movement has decided to really go down the modular rabbit hole and focus there?
00:24:25.370 - 00:24:57.930, Speaker B: Yeah. Comes back to my background in building move and apps in general, like building the first Dex on app dot. So I co found build the first aggregator when I was deploying testnet ready to go mainnet. I had three assets on my Dex. It was like the native token and two other tokens that were alive, which made it really difficult to track users. Because if you only have three tokens, that when a new chain is launching, aren't the most speculative of assets that are going to get people excited, especially at this time. This was November, December of last year, so not the best time to be deploying a new app domain.
00:24:57.930 - 00:25:44.000, Speaker B: It was really a challenge for me as a builder and as a team because we were building essentially a Dap that no one really wanted to use besides forming an airdrop. So then the module thesis really stuck out because you had permissionless innovation. In a sense, we could take the movie and really enshrine all the benefits that Sam and a few other folks have been pushing out and bring it to the broader Ethereum community and bring EV and liquidity specifically to the ecosystem. So now we're working with Dexs, working with lending protocols. They're able to list native ETH into a protocol off the bat, their BDCB through a snowman bridge from the Aventurine that we built. So you have bitcoin now into essentially these we move and app to smooth apps, and a lot more EVM assets can be listed. So one of our liquid staking protocols is Benki.
00:25:44.000 - 00:26:36.626, Speaker B: They're able to just deploy directly Avax stake Avax, which obviously, especially now, is doing pretty well. So the ability for us to bring EVM liquidity to next gen environments is kind of the thesis behind movement. The first module move vm, bringing the movie VM to Ethereum, leveraging celestial free DA on the da side, what we saw is cool. You can bring in next gen VM to Ethereum, you can provide alternatives, but the bottleneck, especially for fees, is the DA level. So talking to all these da folks, Celestia Eigenvale, they really propose a solution where you can cut down like 80 90% of fees at scale and provide a low gas fees environment. And the last step in the Rubik's cube essentially is fixing the broken evm. Sure you can have low gas fees, but then you have an arbitrage situation where network fees spike during high network activity.
00:26:36.626 - 00:27:04.910, Speaker B: Now, arbitrary is pretty much unusable. When we have a next gen paralyzed runtime, now we can mitigate that. And when we saw the pith airdrop on Solana, right, it was able to handle those high volume users and didn't like blink at all. Same thing. When Swe is going through this transformable phase right now, getting a lot of users on chain, it's not bringing up gas at all. So really able to combine the EVM liquidity, that kind of sticky, if you will, and bringing it to the next gen environments was the thesis of bringing the first move l two on Ethereum.
00:27:05.030 - 00:27:38.922, Speaker C: So Ruchi, I want to dig in on the liquidity point for a second, because I feel like there's something that I don't understand here. So there's a lot of EVM liquidity flowing from Ethereum to swe these days via wormhole. I think it's actually the most bridged destination, more than even Solana. We're also working on a native bridge. So if you're a builder and you're trying to decide like should I build on Swe or should I build on an l two that's using the same move that swe does. So how do you actually get better native liquidity on avalanche? Is the idea that avalanche has better bridges than Swe does, or is there something else that makes it fundamentally easier?
00:27:39.116 - 00:28:25.932, Speaker B: It uses Ethereum as a trust minimized bridge for the ZK rollup that bridges the execution environment. So you have move VM execution, ethereum settlement, and actually Snowman, which is from the Avogadro, is a decentralized sequencer. So primarily in the past with arbitrary base, there's a huge sequence of downtime issues and lack of financial incentivization to actually decentralize it. Because we're able to use a fast finality century sequencer network, we can a provide value cruelty native token, and b have a decentralized sequencing which is better for uptime and decentralization or not. On the liquidity side, because of the trust minimized bridge, we can essentially have native eth flowing from the ethereum ecosystem. And also because we have even compatibility at the move level, we can have EVM apps deployed directly on top of the move vm.
00:28:26.116 - 00:28:37.516, Speaker C: So if I'm an Ethereum user and I've got some liquidity, I wanted to end up on movement. Can you walk me through the steps of how, how that gets there? Like, you know it's going to hit some smart contract on Eth. Then what happens? Yep.
00:28:37.548 - 00:29:14.176, Speaker B: So you essentially have the trust minimalist bridge from Ethereum to a network. So for example, when you're launching scroll, I'm using one of these new l two s, you're able to directly bridge the ETH that you have onto this new ethereum L2. We saw that with a blast when they were able to get like 800 million Tvl in like a week. Whatever strategy is sure not the best. But the point is you're able to jumpstart liquidity off the get go. So when we're walking through user, let's say you have eth on native Ethereum, you have scrolls, ek sync, whatever. You simply use the metamask compatibility that you have put in the theme Jason RPC bridge over the Ethereum and now you have ETH on move runtime.
00:29:14.176 - 00:29:35.440, Speaker B: And then you can use your favorite evm apps like Benki. Now targeting the blue chip ev maps and onboarding apps from arbitrary optimism. So essentially arbitrary optimism. And these l two folks at the moment have a large amount of users using definitely. We essentially allow them to deploy directly and move runtime, have all the benefits of move and bridge the ETH directly to a trust minimized bridge.
00:29:37.700 - 00:30:10.644, Speaker A: Is it strictly. I've also been very interested in this debate. I think when you integrate all these pieces together, it's my thesis that they'll work better and there's less fragmentation. It's kind of like the more, in my opinion, fragmentation that you have with these different l two s, the more that we go back to the traditional web two standards. But I'm curious, particularly, obviously, the move virtual machine is great. It does parallel execution. You need high data throughput.
00:30:10.644 - 00:30:39.104, Speaker A: I don't think anybody detests that. I'm curious, though, from the modular standpoint, is there any particular part of the stack that you want to customize or like today, or is it just down the line, you think that there's going to be customization? Maybe potentially something like what dy DX has done and doing kind of the mempool and RAm. Is there anything interesting there that is just like not possible today on these high throughput systems?
00:30:39.232 - 00:30:39.512, Speaker C: Yeah.
00:30:39.536 - 00:31:11.702, Speaker B: For example, like when I was building Aptos, the bridging, I think it was only wormhole at the time, and layers you're eventually added. We wanted to use hyperlink at that time because we like the tech and like we would have to wait a, for aptos to do the integration with Hyperlink and B, for it to get audited. It was like I was talking to the team. It was like a six month process, and we're like, all right, this could take forever. We were able to permissionlessly build a bridge to hyperlane. We built the first move module directly, a, connecting us to IBC. So now move is fully IBC compatible, and then b, now we can directly route liquidity.
00:31:11.702 - 00:31:43.700, Speaker B: Cosmosis live on Celestia and have tia running through our token, which at the moment is 10 billion. So it's great for our users. So I think the bridging is the first example of like, if we were on a monolithic l one environment, we're at the kind of mercy of a foundation and their roadmap to innovate. Whereas a, if I was app, I can launch my own custom app. Roll up, move, roll up, integrate permissionlessly with hyperlink, use whatever oracle I want. Maybe I don't use piv, maybe want to use like, origami. Oracle, maybe want to use another provider, maybe I use a different indexer.
00:31:43.700 - 00:31:53.280, Speaker B: So like these kind of changes are only possible. Correct me if I'm wrong with the modular thesis, whereas if I'm building monolithic environments, I'm kind of the mercy of like whatever is available.
00:31:56.140 - 00:32:35.460, Speaker C: So I guess, you know, I think you're saying if you build your own environment, if you build your own, l two say like, you can choose like now you're the foundation, so you can choose what bridge partnerships you want to prioritize. I don't know, someone, there's a different foundation who's going to prioritize their bridge partnerships. But I don't see how that makes it so that you will have better bridging stories than out ones. Maybe here's a way to frame the question, which is let's ascend display for a second and let's pretend both Aptos and suite have amazing bridging stories. Let's say just as good as, just as good as any other l one or l two. Then what's the value proposition of building on movement networks?
00:32:36.120 - 00:33:02.024, Speaker B: So in that world where bridging is all equivalent, great. Every bridge like layer zero, wormhole, IBC, they're all equivalent. Then there essentially l one would have the best value prop at the moment. But at the current stage, like if I'm building on these l one environments, I don't have that. If I want to use IBC on aptos and suite at the moment it's not available. So I'm completely shut out of the causes network and I have to wait until you guys prioritize it. If I want to use hyperlink, not possible.
00:33:02.024 - 00:33:23.800, Speaker B: If I use Oracle provider, not possible. So I would say in that world where all bridging, all oracle on all infrastructure are equivalent, and the l one at the time chose the best providers and partners, then sure it'd probably be a better experience to build an l one, but in the current state of blockchain environment programming, that's not the case. I tried to build a Dex and it was pretty painful.
00:33:24.300 - 00:33:33.320, Speaker C: Yeah, got it. Okay, I think that makes sense, really. The movement thesis is you all can execute on bridging better than l one s that are using the same execution environment.
00:33:33.780 - 00:34:03.320, Speaker B: I think we're able to execute on customizations faster. We brought obviously to move users, which is something that we've heard a lot from. There's move on Cosmos now coming out. We're able to bring custom Oracle, so you can choose whichever Oracle you want. Different bridge providers, obviously liquidity thesis bringing native ETH into the protocol and BCB was something that we heard from a lot of defi builders. I would say we can move on customizations faster than monolithic chains.
00:34:05.400 - 00:34:32.898, Speaker A: And maybe for Sam, I got rushy to articulate the modular side of the thesis. I think you and I kind of are definitely on the other side of this kind of path dependent world, but where do you ultimately see these ecosystems ending up? Obviously, Swe is integrated. Can you kind of talk about the thought process there and why you think integrated perhaps is better over the long term than the modular?
00:34:33.074 - 00:35:23.148, Speaker C: For sure. I mean, to me, my view is very, very simple, which is just, there's an equation for the utility of a smart contract platform. That equation is, it's the number of useful assets on that platform times the amount of programmability you provide. And so if that sort of suggests that you want to put as many assets, as much, state as much programmability in the same place with no barriers between them, and I think it's an easy case to make that this is the best user experience, this is the best developer experience. You don't want to notice the difference between I'm interacting with contract a and it's very seamless, but now I'm going to interact with contract b and it's across and it's on a different l two, or it's on a different subchain, or these sorts of things. Now, I think one could make an argument that this approach is just like, it's very desirable, but it's just not possible. So that's why l two s are sort of a pragmatic compromise.
00:35:23.148 - 00:35:45.846, Speaker C: But I think the. When this debate starts, I always try to have folks admit this is the ideal, this is the thing we would have in the world that we. That we would really want. And if you don't think that we should be doing this, it's not because you don't agree with the ideals, it's because you think for some reason this is impossible or you have to sacrifice something from it in order to something untenable in order to get there.
00:35:46.038 - 00:36:13.448, Speaker A: I think they've had other, I've had other large ecosystems and parties, to your point, Sam just said that when they started off, they didn't think it was possible, and that's why they went down the roadmap that they had. And if it was possible that you could put this all in one integrated ecosystem, they could do so. I think a lot of those individuals still have a hard time conceptualizing what that world would look like, at least from my understanding in all the podcasts that I've done.
00:36:13.544 - 00:36:24.740, Speaker C: Yeah, I think there's a ton of status quo bias from exactly that thing. Like, you start with a world that works one way and you're sort of conditioned to believe that the better world is impossible. And then when you discover that it is, it's.
00:36:25.450 - 00:36:27.690, Speaker A: There's some rude awakening.
00:36:27.850 - 00:36:53.714, Speaker B: I think the analogy I like to use is like, if you go on the assumption of blockchains or websites, right? Ideally there's one website that I can do everything on. I can shop on Amazon, I can browse Google, I can use OpenAI, I can transact, I can have a super app that never need to leave and go to different websites. But obviously I have 30 tabs up open right now. I'm using a lot of different websites right now. There's a lot of different use cases. Obviously, there's Google, which I use most of the time. Amazon, which I use most of the time.
00:36:53.714 - 00:37:30.260, Speaker B: Those are the three main websites. I think that's where monothe chains end up. Like, you have Ethereum, you have appasui, you have Slana, where there's a lot of user activity, but it's also gonna be websites that have custom use cases that need to move quicker, that can't live on monothe chains, until that super app, until you have one main website that can do everything. I think in today's blockchain environment, there's not a Google yet, there's not Amazon yet. So we're not even close to that. And even in that world, there is still going to need this, still going to be a need for custom app chains and custom execution environments.
00:37:32.520 - 00:38:33.410, Speaker C: So I always find this metaphor a bit difficult, because I think what two and what three are difficult, but if we force ourselves to say, what is a website most like in the crypto space, I think it's a lot more like a smart contract than a blockchain, if one was going to say, what's the problem with websites today? The problem is that there's no native interoperability layer between two websites. It's something that folks have to build ad hoc on a case by case basis. And that's why the web ends up being these series of walled gardens instead of this beautiful thing where I can move my data from one provider to another, or I can move my finances from one provider to another. And there's not barriers, and I don't have this lock in. And if that's the view you take, then you actually want there to be interoperability, and the same level of interoperability and frictionless interoperability between as many websites or smart contracts as possible. So under that view, I think it looks like the integrated view makes sense because when you start to have different kinds of interoperability, because maybe my smart contract's on a different l two or my state splintered, then you can't have as good of an experience or as richer interoperability than if they're in the same place.
00:38:35.110 - 00:39:35.400, Speaker A: I think with the websites, it's interesting going back to solidity as JavaScript. In the JavaScript analogy, a lot of that JavaScript was executed on client side, so it by definition scaled because it's run on your individual computer. I think blockchains are different and how they're scaling on the backend and the node architecture maybe. Sam, back to you again, like is there a better analogy? I think some people, especially kind of the modular ecosystem or even like the Dy DX's of the world have said look, they need to customize some parts of the stack. Do you think majority of blockchain applications or smart contract platforms? Smart contracts apps will predominantly be run on one of these high throughput blockchain ecosystems. And then down the line theres more custom cloud computing that these ecosystems exist, they just have much smaller market share.
00:39:35.700 - 00:40:31.130, Speaker C: Yeah, I think they will be run on one infrastructure or one comm architecture. And I think a lot of the need to customize your execution environment aspects of chain comes from limitations in the programmability or in the native platform features that are provided. As a platform designer, something I think about a lot is how can we give folks as much control as they need and not have them run to some other chain to do that? Going back to say this example of closed loops tokens that I was talking about earlier, that's our attempt to say we know folks need to do these things. We see that when they do them elsewhere, they're forced to say launch an avalanche subnet because they want all the users to be KYC and you, you can't do that if you're going to launch on the avalanche main chain. We're like well people are asking for this, they clearly won't be able to do it, but they shouldn't have to launch a new change just to do that. They should be able to have a smart contract feature where they can set that up and add whatever other restrictions they want. That's the way I think about it, is you definitely need customization, but you want these to be native features and you want them to be provided at the platform layer as much as possible.
00:40:32.070 - 00:41:04.000, Speaker A: Yeah, totally makes sense. One of the additional, and I would like to hear your thoughts around this on Rishia as well, is that L2 rows can have kind of faster finality because they're kind of, by definition, running less nodes or more powerful nodes. Is that kind of soft confirmations something that you think is beneficial? How do you view that in terms of, like, soft confirmation versus, like hard confirmations defined by the layer one?
00:41:05.970 - 00:41:53.678, Speaker B: I'm looking for an end user point of view, and I don't think it changes the user experience. If I'm using a Dex on my roll versus a layer one, what you're really looking at from a user point of view, is it going quickly? Is it confirming quickly? I think the soft confirmations help in general there, but I think it's overstated. I do prefer the monolithic ones where it's, it's more secure. I think it doesn't matter much to me. I think what mostly about thesis gets me excited is when you talk about users. If I'm building, if I'm used to Ethereum using MS and you ask me to leave to different chain, use different wallet, use different APIs, completely leave my community. I think that's been the struggle that we're focusing mostly on, for example, metamask.
00:41:53.678 - 00:42:19.950, Speaker B: As much as we hate metamask, it has the most amount of users. So how can we get metamask compatible? I know like sweet is working on snaps, but snaps aren't the greatest. You probably want to be like, we are focusing on having Ethereum based RPC fully compatible with all consensus tooling. It works out of box. Infuria, metamask, that's kind of the focus we're going on. I think when you talked about soft and hard finale to the average user, they don't really get it, nor do they actually care.
00:42:20.810 - 00:42:24.150, Speaker A: Sam, do you think soft finality has any merits?
00:42:25.450 - 00:42:29.890, Speaker C: Soft finality. So I'll tell you my understanding of the term, because I think it's kind of new.
00:42:30.010 - 00:42:31.430, Speaker B: Yeah, that's what I'm like.
00:42:31.730 - 00:42:34.170, Speaker A: We like new terminologies in crypto.
00:42:34.290 - 00:43:08.644, Speaker C: Yeah. So I think this originally came up because on l two is right, the true finality takes a very long time, sometimes hours, sometimes days. It sort of depends. But from a user perspective, you're probably not going to hit submit and then wait for hours or days to set back a confirmation, or you have to do something else. And as someone marketing an LTE solution, you don't want to advertise that long settlement time. You want to have a different thing and so that's where this soft finality distinction comes from. It's like, oh, it's the time that takes for the sequencer to confirm your transaction, and then that happens a lot faster because it's a single machine, you just, so many requests doing some stuff.
00:43:08.644 - 00:43:44.022, Speaker C: And then, so I think, but then other folks start to adopt this. Like, you know, Merd is one of my favorite crypto presence is like, you know, oh, if you have durable nonsense, you know, which Solana does, which sweet does, you have instance off finality, because as soon as you sign a transaction that has a durable nonsense, it's finalized. And so I think these definitions are tricky, really, anything to do with finality. I mean, to rush his point about, you want to be thinking about what they care about. I don't think the user really cares about that. Usually the whole finality narrative came from chains that had reorgs. I think what users care about is, I send a request, when do I get back the response? And to end latency.
00:43:44.022 - 00:43:59.670, Speaker C: That's what we should really be talking about when we're talking about chain responsiveness and, like, what we should be offering for our system designers. Of course, if you get back a response and, like, it becomes invalidated because you have reorgs, like, that's no good. We don't want to have that either. But I think, like, really, we should move beyond that and talk about latency.
00:44:00.890 - 00:44:48.640, Speaker A: Yep, yep. Fully agree, I guess. I mean, one interesting thing is, as this kind of modular, as modularity not starts to gain hold, but as you can swap out some of these components, like the moviem, you can start to, because these are permissionless systems, there's really no one stopping you from, say, using a L2, if you want, which could effectively just make the layer ones such as swe a data availability layer. Can you kind of talk about, like, swe being a data availability layer, how you think that will progress over time versus some of these other solutions, like Celestia, that are trying to pursue, or even Ethereum trying to pursue just data availability layers and of themselves.
00:44:49.100 - 00:44:49.412, Speaker B: Yeah.
00:44:49.436 - 00:45:34.510, Speaker C: So it's not something that we've really thought too much about or focused on. I mean, the one thing I'll say is storage on suite is really, really cheap. So if you wanted to use it for that, I think it could be a good candidate. But I think really, data availability layers are more for like, a platform like Celestro, where the platform in itself isn't really doing a lot except trying to facilitate creating L2s or roll ups or alternative execution environments on top of it or similar with some of the changes that are coming to Ethereum to make it easier to support roll ups. I think if you're designing with this as a goal in mind, it's always going to be better than something that is in design with that goal for sweat. Our goal is to build the world's best smart contract developer platform with all the state, all the contracts in one place and make it as low latency as possible. So it might work for that, but it's not our focus.
00:45:35.490 - 00:45:44.270, Speaker A: And Ruchi, are you deploying to multiple data availability ecosystems or do you have a core focus initially?
00:45:44.930 - 00:46:18.630, Speaker B: Well, Celestia is the only one that's live right now and other ones are pretty far behind in terms of coming to mainnet and announcing roadmaps. The media answers deploy and Celestia for the mainnet solution. But what we're trying to focus is on, we have some interest from apps to launch our own app specific roll ups. They want their own customizations like I touched on, have their own oracles, have their own indexers, run their own environments. So for that we're trying to focus like a move stack where anyone can use their own sequencer, use whatever DA you want. So we partner with all the DA layers and have integrations with them. Use whatever role stack.
00:46:18.630 - 00:46:40.656, Speaker B: So Zkstack, LP, Stack, you name it, just like any of those. And use the movie as the ultimate execution environment. We're pretty agnostic to whatever tooling and infrastructure the app wants to use. Um, there's financial incentives, there's technological incentives, um, and we don't want to cater to all of them. Um, but for our main solution we're focused on ethereum settlement, um, and slashes.
00:46:40.688 - 00:47:07.460, Speaker A: Yeah, okay, excellent. I guess maybe to both of you. Uh, we have kind of gone through this pretty long, painful process of kind of the bear market in crypto. Unfortunately, prices affect quite a bit. How has your kind of thoughts changed, if any, towards the next like three to six months as activity starts to pick back up?
00:47:09.160 - 00:47:43.160, Speaker B: I think on my side, it's like the network effects that everyone's been saying that EVM has are going to quickly go up way. Like obviously SLA is ripping right now and people are like, oh, if you folks in the EDM are screwed, um, I think that's like what we're going to see over the next three, six months is like people realize like the EVM isn't that sticky. Like we saw Stanley tweet about this as well, where it's like people can recognize, like, even if you, like, where you modular, monothe, whatever, the EVM ultimately sucks. And we're all here to try and like, remove it and burn it. Yes.
00:47:43.200 - 00:48:20.314, Speaker C: I mean, I think it's slower times. There are some things that are quite nice and that like the folks who are sticking around, like, you know, their, they're building with long term goals in mind. Like, you know, they have ideas for the value proposition. They're like, really dedicated to this. Whereas the advantage of the faster times that there's a lot of attention, a lot of new user attention, a lot of developer attention. And so, like, I think the thing that I think about, that we really think about is like, how do we channel that attention productively? How do we convert folks that are just taking a look at this because it's hot and turn them into people who see the, who see the value proposition or building, building stuff for the long term and just, you know, redirect that energy to feed our mission 100%.
00:48:20.482 - 00:49:02.080, Speaker A: In terms of piggybacking off some of your comments, Ruchi, I do think Solana is having its Ethereum 2018 2019 moment. I think at the end of the day, whether it's modular or an integrated stack, whether it's cosmos or Aptos suite, say, any of the blockchain architectures, we're all competing for developers. And to your point, Sam, like that interesting state, being able to kind of touch, that is the very thing that at least most blockchain platforms are trying to strive for. What would you say to, like, engineers to build in your tech stack versus the other?
00:49:05.940 - 00:49:07.612, Speaker B: I can go first.
00:49:07.716 - 00:49:09.844, Speaker C: Sorry, I thought it was the director of Rishi first. Go ahead.
00:49:09.972 - 00:49:35.122, Speaker B: And I think for us, we're looking at us. Look, if you are going to like, live on Ethereum, you really want to stay with an even liquidity, just don't use the EVM. It's been hacked for $4 billion every year. We literally have a chira dictator. I'm looking for the next six months. I do not want another Kyber dictator. I want genuine apps, genuine defi apps, gaming apps to be built in Nexon execution environments.
00:49:35.122 - 00:50:04.916, Speaker B: You can use whatever settlement layer, I don't care. You can use Ethereum and avalanche finance, I don't care. My main focus and the focus of movement is expanding adoption move and making a superior programming language breakthrough. And the way we're angling is like in the past has been done through sweet and app dots and other groups. And it's been kind of like isolated approach where people are like, you're either building Ethereum or you're building elsewhere. I think we're working on bridging the gap. You may argue that the tech is worse, tech is better.
00:50:04.916 - 00:50:18.060, Speaker B: Um, that's not what we're here to discuss or what I'm here to kind of promote. I'm like saying I want move to win. And then we can discuss on like soft finale with the hard finale, what that means for users. Um, I just don't want to get hacked for 4 billion every year.
00:50:18.760 - 00:51:00.776, Speaker C: Yeah, I can definitely get on board with that. I mean, yeah, I guess what I would say is I think we've talked about a lot of the selling points of highlight for Swigger already. Of course we've talked about move, we've talked about extremely low latency, we've talked about horizontal scalability. But I think the problem that we're really focused on, that maybe other folks aren't thinking about as much, or at least like, aren't doing as much to bake solutions into the platform, is just thinking about user features for user onboarding. And basically, what is the tam of your crypto power app? The way we think about this is, okay, you build something amazing, let's say it's useful to everyone in the world. How many people are actually going to use it? I would say the answer at best is 60 million, because that's how many people have installed a wallet across all of crypto. And you basically can't do anything interesting on any chain without a wallet installed today.
00:51:00.776 - 00:51:45.396, Speaker C: It's like, okay, that's going to drive away serious builders. That's going to limit your success, even though you built this thing really useful. So how do we turn this into a tech problem, and how do we make it so that Tam is a lot bigger? And so that's really what we're focused on. Suite with ZK Login, you now no longer need a wallet installed to do anything. You send transactions directly from web, two accounts, and now your Tam is everybody who has a Google account, a Facebook account, these sorts of things. And then with features like sponsored transactions, which we're baking into the transaction format, you get rid of the other big friction, which is going to coinbase, scanning your passport, waiting for days, and all of this stuff. It's just like, you know, you can send a link to someone who's like one of your friends, like one of your parents, one of your relatives, and like, they can just try out your crypto powered app on tweet right away.
00:51:45.396 - 00:51:52.520, Speaker C: So I think that's why we're really just thinking about knocking down all these fundamental barriers and, like, putting this at the platform level so everybody can take advantage of it.
00:51:53.060 - 00:52:29.110, Speaker B: I also think it's often like a discussion like monitor versus monothic. I think it's, and like, I think if anyone, like, if you're trying to build a payments app, it's obviously like, if you're trying to build the next vendor, you need to build where it's very simple. You just have APIs. There might be a higher barrier to entry, probably raise a little bit of capital, but the next payments app for the next three months and going forward should be on environment. But there's also other use cases that unlock L2. We're focused on. We're focused on Defi right now, and we're hearing a lot of interest from EVM apps that never would have touched apptos or suite or any next gen chain, for that matter.
00:52:29.110 - 00:52:34.080, Speaker B: And now they're deploying because even compatible, they can live and be in Ethereum.
00:52:34.780 - 00:52:36.160, Speaker A: You got to be aligned.
00:52:36.900 - 00:52:57.942, Speaker B: Whether you argue that it's good or bad, it's genuinely like, when you do bd to like these EVM apps, I'm sure, sam, you come across like they're like, okay, I still want to live on Ethereum. I still want to be aligned. Is that good or bad? Like, that's to be discussed. But I think there's a world where both can coexist, especially now, where we need to band together, because the ultimate goal is to, like, removing the old.
00:52:57.966 - 00:53:46.814, Speaker A: Dinosaur, I think for me, and the reason why I got so excited in the industry in 2017, when I got involved, was kind of that, well, at the time, it was Ethereum's ethos of, like, banking the unbanked and getting people into crypto. And I think the reason why I got so excited about kind of the high performance, high throughput paralyzed chains is because I realized, oh, this future will actually get us there much sooner. And I think it's been sad to me, just that the industry has not scaled to really where I've wanted it to. And the best thing that we can point to on the application side, to your point, Rushu has really been like, USDC payments and, like, web transfers. It's kind of sad, but we're getting there. And I think these high throughput blockchains are really that. Next up in the frontier.
00:53:46.814 - 00:54:27.390, Speaker A: And that's why I'm excited that Solana is having its moment. I think Swe will have its moment. I think these high throughput blockchains are going to be the next frontier. And that limelight is now shifting outside of the EVM and the Ethereum focus. Maybe to touch on the topic. Maybe you can start with you, Sam. For those that are not as familiar, what are the key features that you would highlight on comparing the Solana tech stack to Swe? There's the move programming language, there's the SWE Fastpath consensus, there's the object data model.
00:54:27.390 - 00:54:34.750, Speaker A: What key features do you think are really the differences between these two ecosystems versus all the others?
00:54:35.170 - 00:55:03.854, Speaker C: Yeah, so I think you mentioned a lot of the good ones. I think Zklogin, which I just spoke about, would be. I really think that's an extremely important feature to have and have at the platform level, because this is really just like the difference between having a very small audience for your app and having a worldwide audience. So beyond, so beyond that at the tech level. So I think you mentioned almost all the ones that mentioned the tech level. I think Solana also has sponsored transactions, although they work somewhat differently. That's important for SWE as well.
00:55:03.854 - 00:55:44.740, Speaker C: I think latence, I touched on this earlier, but I think latency, like the fast path latency for SWE, is the best in crypto, working on the research project, this Mistoseti project, for bringing the latency on shared objects down more. And then I think there's the difference in the scaling approaches, like horizontal scalability versus vertical scalability. We're really focused on. We want to be able to scale by adding more cores and adding more machines, and to do that in an elastic way so you can keep operating costs low. And Solana, Solana's thesis famously, like, you know, Moore's law is going to come, is going to proceed a pace and going to make sure that as capacity grows, like hardware, will always grow faster. Of course, we will benefit from that as well. But I would say those are some of the other differences.
00:55:45.560 - 00:55:56.976, Speaker A: To dive into that just slightly more briefly, are you specifically talking to the entra validator sharding, where you can add more compute and that acts as one giant node?
00:55:57.128 - 00:56:11.800, Speaker C: Yeah, that's right. We want this to be opaque to users and to developers. And it's just operationally, your validator could be a single machine, it could be a small cluster, it could be a cluster of two and expand to ten because traffic is very heavy today, and then go back to a single machine or cluster.
00:56:13.060 - 00:56:16.680, Speaker A: Can you do that at the application level or is it just at the network level?
00:56:17.060 - 00:56:31.378, Speaker C: This is just at the validator software level, where it's like you think of a validator as a black box. And you don't care about what sort of machine configuration is inside, or how it splits up its state, or how it farms out transactions to workers and any of these things.
00:56:31.524 - 00:56:57.956, Speaker A: I see. And maybe to you, Ruchi, you have been talking high level on, like, these parallel processing virtual machines. Solana was the first move came and I think expanded upon really making programming as safe as possible. Can you talk about, did you look at other parallel processing virtual machines when deciding to build movement? Or did you specifically just say move? Is it, we're doubling down on the movie ecosystem?
00:56:58.118 - 00:57:13.152, Speaker B: Yeah, I've been enduring, like probably eight. Like, I was, like, a lot. It was beating a fuel at one point. Love, like, the environment, like, really gone a sway. I played around with Monad, like, right to the docks recently. I think that's like, gonna kill it as well. An opposite.
00:57:13.152 - 00:57:55.640, Speaker B: Sweet. And Solana. I actually built, like an NFT project or a marketplace on Solana too, just like the fun of it. I think what ultimately got to me was like, I really love the formal verification built into the movie and move language, because when it's always, like, Solana or a few programming languages, I still had to rely on auditor to make sure I'm not getting hacked or not destroying my entire protocol. For us, it was like, okay, I can build on move and have a lot of these registry debugs. All the vectors we're seeing in solidity and other programming scripts cover for me. So if I want to deploy opt Mainnet, my barrier to entry is next to nothing, versus even other next gen environments, there's still a decent barrier to entry.
00:57:56.660 - 00:58:08.600, Speaker A: Perfect. And we're approaching time. So maybe as we wrap it up, share the things that you're most excited about for, say, the 612 month timeframe.
00:58:10.340 - 00:58:43.176, Speaker C: Yeah, so, I mean, I can start on that. Like, the one of the, I think, topics I originally had to talk about today was the future of smart contract programming. So I'll talk specifically about what I'm excited for the next couple months and with move. And so I think the first five years of move, that's pretty young by programming languages standards, pretty old by crypto standards. We've really been focusing on building strong foundations in the bytecode format and the verifier, because these are the parts that are really hard to change once you've got thousands of contracts deployed on your platform and they all work a certain way. Like, it's very, very. You can't really go back and get rid of old things or add them, or you can, but it's quite, quite difficult.
00:58:43.176 - 00:59:12.928, Speaker C: So we're really focusing on improving now. We feel the foundations are quite solid. We're focusing on improvements up the stack, so making lots of improvements at the source language level in package management and the supporting tooling in the source language. We're adding in nums, there's method syntax, there's going to be macros. You can refer to packages by name instead of by id. In the package manager we call this kill all hashes or kill all object id is everything in web user friendly names. I think it'll be in the next couple of months.
00:59:12.928 - 00:59:46.946, Speaker C: One thing is clearly going to change, not just the smart contract. Program experience. Like the program experience everywhere is integrating LLMs in the tooling stack. I think like already, like the copilot like experience, pretty much table stakes for an ide that works well, but moves a language where there's not a lot of code that's out there and not a lot of code that's existed before the training cut offs of a lot of these models. I think helping foundation models understand move better, figuring out like how do we, how do we fit this into the programming stack. I don't necessarily mean like you write English and then an LLM writes a smart contract. I don't think think that's a good idea.
00:59:46.946 - 01:00:10.110, Speaker C: I'm thinking more along the lines of you write a smart contract and that's actually expressing a lot of intent. How to use that to do code generation, how to use this to build other parts of your app, how do you use this to tweak the end of experience and just extract a lot more productivity from the care you needed to do, and expressing your smart contract and getting it right the first time.
01:00:11.290 - 01:00:17.070, Speaker A: Perfect. Rishi, what does the modular future look like in the next six to twelve months?
01:00:17.560 - 01:00:59.284, Speaker B: I think from a technical point of view, the biggest issue is if you buy this thesis, that's going to be hundreds of roll ups. There's no way to connect them. If you want to do atomic swaths between different roll ups, it takes forever. It's a pain in the butt. So what we're working on is a bringing paralyzed runtimes to different systems and using a decentralized sequencer set to essentially enable one to two block atomic swaps, which should get up a lot of the issues we're seeing with or books and some of the Defi primitives. And on the narrative side, we're really trying to go pretty hard in the next three to four months, capitalize on the market and see this alt VM next gen vm narratives really heating up. So we're really focused on, like, attacking the Ethereum community, saying, like, move is here, next gen vms are here.
01:00:59.284 - 01:01:09.720, Speaker B: It's living on Ethereum. We're playing your alignment games. Sure, we're here. We're mammals compatible. Now, what's your reason not to use move? Do you want to get hacked? So, yeah, just being very aggressive on the marketing side.
01:01:10.070 - 01:01:27.310, Speaker A: I can tell. Well, I hope you can keep pushing the market forward, Richie. I have kind of laid down on that tracks a couple times and happy to pass off the baton, but really appreciate both of you for coming on the podcast. Ruchi and Sam, thank you so much.
