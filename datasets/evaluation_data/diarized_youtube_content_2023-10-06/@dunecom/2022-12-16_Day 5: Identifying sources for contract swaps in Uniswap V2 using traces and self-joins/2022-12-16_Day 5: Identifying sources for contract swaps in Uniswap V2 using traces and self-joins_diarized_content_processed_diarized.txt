00:00:00.280 - 00:00:17.206, Speaker A: So yesterday we looked at identifying bot and mev arbitrage transactions and swaps in uniswap. And today we're going to take it a step further and try to figure out what contracts or addresses are calling the pair.
00:00:17.278 - 00:00:17.486, Speaker B: Right?
00:00:17.518 - 00:00:25.770, Speaker A: So this means going more than just one layer deep in the call traces. I'm going to let Jackie explain the logic and run through the query.
00:00:26.160 - 00:01:01.594, Speaker B: Thank you, Andrew. So, to get the frequency and the volume for the swaps, we already know the drill. We just need to look at the Paracallswap table, and then we grab the transaction hash for frequency with the count function. Then we grab the amount zero and amount one per usual to calculate the USD volume later. And we know we need the prices that UST table to adjust for the USD price. Okay, so now the hard part. Identifying the sources, identifying if the originator of the swap is actually a contract or a externally owned account or the wallets.
00:01:01.594 - 00:01:57.048, Speaker B: Remember, in day three we looked at the router problem, right? So we saw that a lot of times the uniswap router actually routes the swapping costs for you to find what pairs to call to conduct the swap. If we look at only one level above to see who called the swap, a lot of time that's going to be the routers, right? So if we want to truly analyze the actual originator of the swap cost, we have to look further. We not only have to look at the caller of the swap, we have to look at who actually called the caller that caught the swap. We need to do two joins on the traces. First time join to identify the color of the call swap, second time to identify the color of the caller of the swap. Once we identify the originating swaps, we're going to find if the address exists in the creation traces table. If not, then it's an externally owned account.
00:01:57.048 - 00:02:27.628, Speaker B: If it is, then it's a contract. And then we can use the contracts label to identify the address further. And then we'll be able to conduct our analysis on the frequency and volume of the sources. All right, let's get into it. Let's start with setting up our CTE. So with swaps us, and per usual, we are going to select from the swap call table. So going to find the name of the table.
00:02:27.628 - 00:03:09.882, Speaker B: Unit B, two pair, search for swap. Okay, so from this aliasing as us, let's just set up the time already because we know that we need that. So date truncating by minute because. Because we know we need the minute data to join to find the USD price later on. So we will do a callblock time this time. Okay, so next we know that we need to perform joins on the traces, right? Because we need to find the color of the color of the swap. To find the color of the swap directly, we can join by the transaction hash as well as the call trace address.
00:03:09.882 - 00:03:56.618, Speaker B: So each internal calls in a particular transaction would have a unique trace address. And then to find that particular internal transaction, we can use the trace address to join and then find that. And then once we have that, we would be able to go one layer both to find what we need to find. So trace address is a pretty useful field when we are playing with traces table. Okay, so before we even go to joining on the traces, let's just think through the logic that we need to do this. Self joining on the traces, essentially joining on the traces table twice to find the color of the color of the swap, right? So I'm gonna start a commenting block. You can do a block commenting by doing this on the screen like you can see.
00:03:56.618 - 00:04:23.262, Speaker B: So here we're gonna just find the color of the color of the swap, right. Okay, step one. Let's just like set this up. How would this look? So it would have two layers of from two, right. So this is more top layer. And then this is like the lower layer, which is like actually closer to the swap. So here, this too would be the actual pair contract address.
00:04:23.262 - 00:04:42.238, Speaker B: So this would be like our USDC and wrapped eth contract address. So pair contract for swapping. Right, for swapping. And then, so this from would be the address that actually caught the swap. So the direct color of the swap. Right. So this is the color.
00:04:42.238 - 00:05:12.860, Speaker B: So if we go on one layer above, ideally what we would want to grab the two would be the from. So these would both be the color, the direct color of the swap. And then this from would actually be the actual color of the color that we're interested in getting. Right. So this would be the color of the color. Okay, so that's what we want. And then, so in terms of joining this, we're going to just call it the first trace address table that we're joining.
00:05:12.860 - 00:05:48.786, Speaker B: Because this is the trace table that we're going to match directly with the swap cost trace address. So we're going to identify it that way. So let's just put it here. So essentially what this would be, would be the traces. One dot trace, trace, trace address would equal to the swap calls call trace address. So that's how you can identify this particular record. And on top of that, if you want to identify this particular record.
00:05:48.786 - 00:06:20.058, Speaker B: What we need to do is. So this would be the second traces, right. Second traces we're trying to join. So essentially what we're saying is traces one dot fr om is equal to traces two dot two, right. Because we're trying to match this two with this from. Okay, so that's one of the things we need to do. Then there's one more thing we need to do, because structurally we can see that this row should always come before this row.
00:06:20.058 - 00:07:01.690, Speaker B: How do we identify that? So when we look at the call trace address, right, it could look like 0051, right. So this is what it could look like. So what comes after it would look like either this or it could look like, you know, with one more. So whatever comes out later would always have either the same length word, like a longer length. Right. So that's what we also need to do. So make sure the array length of this particular record is always equal or smaller than the array length of this call.
00:07:01.690 - 00:07:36.312, Speaker B: So we could do that. So let's say. So it would be like the cardinality of trace two trace address. I guess instead of saying just make it a function. So this is always going to be less than or equal to the cardinality of trace one. Right. Based on this like structure visualization we're looking here.
00:07:36.312 - 00:08:17.640, Speaker B: Okay, so I think we're ready to perform this join join. So let's get into it. So we are going to do a left join on Ethereum dot traces t, which we're going to call t one. And then we are going to join on t one dot transaction, right, because we want to make sure it's actually the same transaction equals to us call transaction hash. Right, because joining on the same transaction. And then what else? Let's join also on the time. Why? Just to make sure we're querying more optimally.
00:08:17.640 - 00:09:10.570, Speaker B: And the query is cycling through like less data. So let's get the time match going and then let's get the trace address going. Right. So we know that the trace address in this trace should exactly equal to the call trace address in our swap call table. Right? So basically here we are able to join the first trace and then let's do the second trace joint. Okay, so here what are we doing? We want to make sure that these two, because we want to join the traces one and traces two together, right. We're performing a self join, so we want to do trace hash is equal to t two dot trend transaction hash.
00:09:10.570 - 00:10:03.350, Speaker B: Ok, what else? Again, we're going to just join on the time to make it cycle through last data block. Block time. Okay, what else? We are going to do this part of the logic, right? So we're gonna do, and t one dot fr om. We need to, this is like a special reserved keyword, so we need to put in double quotation is equal to t two dot two. Okay, and what else? Sometimes there would be cases where, you know, t one's from and t two's from are the same. So we need to also filter that out. T one dot from is not equal to t two dot fr om.
00:10:03.350 - 00:10:36.440, Speaker B: And then we need to then go to our last condition, right on the cardinality. Sometimes cardinality could be zero, right? If then a rate of could be null. Sometimes cardinality could be null. So if the array has nothing, then it will be null. And we don't want to have errors. So we're going to just do a coalesce here. In case it's null, then we're going to put zero, but in case it's not null, then we're going to get the cardinality of t one's trace.
00:10:36.440 - 00:11:20.874, Speaker B: I guess we set t two dot trace address is always going to be smaller or equal to another coalesce function, right? If it's no, then we put zero. Otherwise we're going to get the cardinality of t one dot trace. T one dot trace address. Okay, cool. So we are good on the self join. We're going to double check if there's an error after we set up the rest of the query. Okay, now we need to consider some of the filtering condition as well as make sure we grab all the columns that we need.
00:11:20.874 - 00:11:51.606, Speaker B: So let's start the where clause for the filter condition. So here I'm just going to do a one equals to one just to make our commenting a little easier later. One is always going to be equal to one. So whenever you want to do more, and right, you can always come easily comment out the end condition. So that's what we're doing here. Okay, so first of all, we're going to get like a lot, a lot of data. So we want to just filter for the time in the past, like let's say eight months.
00:11:51.606 - 00:12:32.310, Speaker B: So call block time is greater than or equal to now. Actually, to start with. Let's just like filter for, honestly, we can like filter for the past one day and start making sure it's correct and then go more. And we also want to make sure, like, we are looking at the USDC wrapped eth pair, right? So we want to make sure the contract address is what we care about. So here we're going to introduce a parameter. As usual, we are going to find the default address, USDC wrapped Eth. USDC eth by default.
00:12:32.310 - 00:13:02.126, Speaker B: Okay. And then we also want to make sure that the traces are successful, the costs are successful calls, right. Because sometimes you initiate a transaction and it's not necessarily successful. So we're going to do make sure that it's success and t two dot success. They are boolean. So you don't have to say anything if it's true, that it's going to be true. And we also want to filter out static calls on these traces.
00:13:02.126 - 00:13:28.634, Speaker B: So t one dot call type is equal to call because when it's a call type, it actually changes the state. Otherwise if the static call doesn't do anything. So we want to make sure we filter for the right type of call type. Okay, cool. So these are our filtering condition. So, so what do we need? We need the, this particular from, right. That is out our ultimate goal.
00:13:28.634 - 00:13:44.226, Speaker B: So we're going to do t two dot from. This is our raw source. So this is the color of the color of the swap, right. The double color. We're going to just call it double color and then t one dot from is the direct caller. So the direct source. All right.
00:13:44.226 - 00:14:20.060, Speaker B: There's actually something more that we need to do here. This is like our logic, right? We want to get the color of the caller. So from, of the from. But sometimes there could be rows where like in the same transaction there would be like this, right. So there would be multiple rows that would satisfy our requirement even if we filtered for, hey, let's look for cardinality of this row less than this row because anything comes before technically would also satisfy our requirement of this. Right. The traces two is less than the traces, one's cardinality or array length.
00:14:20.060 - 00:14:52.846, Speaker B: So we are going to apply a window function row number to make sure that we are indeed looking at this closest one to this run. So we're indeed getting this from, instead of any other from. Okay, so we're going to do row number. So we're just trying our best to find the originator of the call. It might not be 100% bulletproof, but I. This is our approach. Definitely let us know any other approach that you have.
00:14:52.846 - 00:15:41.158, Speaker B: So we're partitioning by the p two transaction hash because we're looking at within each particular transaction what is happening. So we're ordering by the cardinality of the traces, the trace address. Right. And then we're ordering it in a descending order. And then we're naming it as Ron. Okay, so essentially what this does is that the longest trace address array, so the one closest to this row would have the row number being one. And then we are interested in grabbing the, this particular row that's closest to this row instead of any other.
00:15:41.158 - 00:16:13.642, Speaker B: So that's our ronum that we have set up. This is the hard part, right. This is done. So the easy part. We already know that we want the call transaction hash for frequency and also as an example later transaction hash. Okay, so this is for, and then we need to grab the same amount zero amount one as before. So we like can calculate the volume, right.
00:16:13.642 - 00:16:48.122, Speaker B: So for volume. And then we are just going to do our usual case statement. So case when we're going to cast the amount. So when amount zero out as double is equal to zero, then we're going going to basically use amount one as the raw amount. So we're gonna just cast it so we can use it more easily later. Amount one out. Honestly, I'm just gonna amount one out.
00:16:48.122 - 00:17:22.084, Speaker B: I'm gonna just use the copy pasting here. So cast amount zero out as zero. Then we're gonna take that. Else we're gonna take, oh, forgot to ask. Double. So else we are going to take amount zero out as double and then we're going to end the case statement as the raw mount. Okay, what else? We want to grab the token address, right, for these token so that we can adjust for USD later.
00:17:22.084 - 00:18:16.682, Speaker B: So in order to do that, we would need to, to perform another join with the pair creation, right? We already know that from before. So go into factory and then go into event pair created PC PC dot. This would be the pair address is equal to s dot contract address I believe. Yes, contract address. Okay, so now we got the pair. So case when I'm gonna copy this part down and then change this to be the token address. Okay, so here if it's, if token, if amount zero is, is zero, then we know we want to token one as the address.
00:18:16.682 - 00:18:44.760, Speaker B: Otherwise it would be token zero. Awesome. Okay, cool. So that should be all for our first part of the query. Let's give it a try to, you know, test out if this indeed worked. So let's do a limit 100 and see. Okay, there's an error.
00:18:44.760 - 00:19:06.188, Speaker B: PC left join on. Aha. Forgot to. Alright, let's take a look at an example transaction. So let's take this one where the row number is two, two c. So copy the transaction hash 408. And then we're actually gonna just use the ethereum traces table on dune, do the investigation.
00:19:06.188 - 00:19:28.856, Speaker B: So we're gonna paste the transaction hash overdevelop and take a quick look. We have the results for this one. So now we have the results, right. We want to look at the from and to. And here we're going to just copy paste the swap pair address to, to filter it down. So like we can search for it even more easily. So let's just search from the UI directly.
00:19:28.856 - 00:20:06.404, Speaker B: Okay, we can see that this is the call that called the swap directly. So this would be, be the direct color of the swap, which is seven a 25. Right. Which let's filter for this particular transaction, hush. So we don't get super confused, which matches up our expectation. And then let's again filter for the seven a 15, no, seven a 25. And then we can see, okay, indeed this is the caller of the caller, right? So eight B c.
00:20:06.404 - 00:20:28.172, Speaker B: And then here we can see eight BC matches up our expectation. And here all of the raw source is the same, but sometimes it could be different. But we know that we want the closest internal transaction that called the caller of the swap. So it would be like row number equals to one. Yeah. So sanity check all works out. We are good to go here.
00:20:28.172 - 00:20:46.530, Speaker B: Let's delete the limit to 100. And let's put this back. Let's also put that back. Okay, we are ready to continue. This is the hardest part. If you're here, you're already 80% there. Let's filter for row number equals to one.
00:20:46.530 - 00:21:14.810, Speaker B: Right. So we're going to call this inter swaps for intermediary step. And then we're going to do select star from swaps, basically where row number equals to one. So we're basically taking the CLo, the closest color of the color. So like from, from, right. Next step we're gonna, we already know how to do this. We're gonna just like label the addresses.
00:21:14.810 - 00:21:52.618, Speaker B: So we're gonna call this labeled swaps. Okay, so we're doing select from inter swaps aliasing this again as us, some obvious things we would need. We definitely need the time and then definitely still want the transaction hash. And then definitely want to keep the raw amount and then the token address. Definitely need these. But now we would like to label our raw source, right. That's essentially what we would like to do.
00:21:52.618 - 00:22:18.764, Speaker B: To do that, we can do two things. One, we can join on the ethereum creation traces. So let's do that. Creation traces. We're going to call this c on. So the raw source that we care about, the address is going to be equal to the creation address. We already know this.
00:22:18.764 - 00:22:52.350, Speaker B: This is checking if it's a contract or an eoa. Checking if it's a contract or eoa. Right. If it's an eoa, then it would not exist here. If it's contract, then it would exist here. And then another thing is if it is a contract, we can use labels the contract to further using labels contract to label the contract address, right. So we can do a left join on that, but so we can directly do labels dot contract.
00:22:52.350 - 00:24:12.244, Speaker B: Okay, on the raw source equals to the we're going to alias this as l l address, right? And then also on l making sure address not l address, making sure the blockchain for l is ethereum, so contains l dot blockchain is ethereum. Why are we using it contains instead of equal? Because here for the labels contract table, we know that the blockchain column is of a array type. So. Yep, so now we've got the labels table. So we now can do the transformation part. So what are we doing? We're basically saying when the address is null, so when the raw source cannot be detected in the creation traces table, then we're going to label it wallet or externally owned account, right. It is a contract and then we can try to use the label name label label table.
00:24:12.244 - 00:24:56.250, Speaker B: So we can see if there is a name associated with it. If not, we're going to just simply label this as other contract and then we're going to end it as our labeled source. Okay, let's do some sanity check here again to just see. Okay, it should be, let's see a bunch of wallet and externally owned account. Okay, so let's take a transaction and check if it is indeed a wallet. So let's go to Etherscan and see. Okay, let's go there.
00:24:56.250 - 00:25:35.328, Speaker B: It's really weird. Normally there is an internal transactions table, but let's just check from our own traces table. Normally I would go to Etherkin scan to see what's going on, but today's kind of weird. First we need to grab our okay, so first let's make sure we're only looking at this transaction and then let's grab our call swap. Sorry. Let's grab our USDC wrapped eth address. And then so we can see six eight b three initiated this and who caused six eight b three? That is not six eight b three.
00:25:35.328 - 00:26:00.380, Speaker B: Right, because we want to see it is BFF two and BFF two is an address. Okay, wonderful. So sanity check passes. We're going to delete this one more time. Great. Labeled swaps. Next step, we labeled it, we are going to adjust for the USD amount.
00:26:00.380 - 00:26:18.546, Speaker B: Gonna call it enriched. Enriched pairs. Okay, so we're selecting the time because we always need the time, right. And then the source that we just adjusted. And then transaction hash. And we already know this. So we are getting the row amount.
00:26:18.546 - 00:26:37.066, Speaker B: So before that, let's just set it up. So from label swaps. Okay, so let's alias this maybe. No, I think that's okay. From raw amount. Okay. Divided by ten to the whatever decimal.
00:26:37.066 - 00:27:09.200, Speaker B: So in order to get the decimal, we need to join on the prices. So let's do that. Prices dot USD. Wonderful. We're joining on the minute equals to the time. And then also we want to make sure the token address matches right. So the prices dot contract address is the token address is the token address.
00:27:09.200 - 00:27:45.610, Speaker B: And also we want to only look at the Ethereum chain data for the price. And then one more thing we want to filter for the time. And then right now, since we're filtering for one day, let's just keep it consistent. One day let's actually change this into inner join to filter out any token that does not exist. Any prices that USD table. So we cannot adjust for the price. So then we can do dot decimals basically.
00:27:45.610 - 00:28:17.436, Speaker B: And then after that we can do the price time. The price as the USD. Okay, we are good to go here. So let's write the last part of the query. Final part of the query is where we're gonna start aggregating up by the weekly. So let's set up select from this enriched pairs. Beautiful.
00:28:17.436 - 00:29:05.664, Speaker B: And then we're gonna truncate it this time to week. So time as time. And then we're gonna just use the source, right? And then we are going to aggregate up the count of the transaction hash, right. As example hash. And then we're going to sum up the USD or amount to USD amountUsD as this sum amount USD. Actually let's do something else as well. So we're going to call this detailed source because in terms of readability for the graphs, we want to just simplify things a little bit.
00:29:05.664 - 00:29:51.122, Speaker B: So we're going to only identify a few prominent contracts. So case when, if the source is just wallet, were you a. Then we're going to keep the source. But also when source looks like some sort of uniswap, right? Like when the label, the name of the contract is some sort of uniswap, then we're going to call it Uniswap. Regardless of what kind of uniswap it is. So when source are like zero x, then we are going to just caught zero x. Similarly, another source that, you know, let's just take a look at could be one inch.
00:29:51.122 - 00:30:13.564, Speaker B: Then it would be one inch. And then. So when source is like paraswap, then we're gonna say paraswap. Okay, let's stop there. And then else we're gonna call it other contracts. Now we're gonna end the case statement. So this will be like our source.
00:30:13.564 - 00:30:36.244, Speaker B: Otherwise we can look at the detailed source so that it's our pair. And then let's apply one more aggregate function to get the arbitrary transaction hash to be used as an example later. Sorry. This is the frequency. That's the example hash. Um. All right, cool.
00:30:36.244 - 00:30:51.560, Speaker B: So let's just get the group by going. Group by one, two, three. Okay, so let's see what's gonna happen. Okay, so forgot to put the eyes on. So let's do that. But also, we don't need this part. Okay, beautiful.
00:30:51.560 - 00:31:13.820, Speaker B: Let's just create a visualization to double check this part. Looking at the sum group by the source. Okay. It's something. In terms of wallet, this looks pretty okay to me. Obviously, we won't have one day data. That's why it's like that.
00:31:13.820 - 00:31:50.700, Speaker B: Let's get going with the last part. So select. We want the time for sure. We want the frequency, we want the source. Okay, let's do it like this doesn't really matter, but. Okay, so sum amount, USD, and then we're gonna do the same thing that we did before to make the example hash clickable. Honestly, I'm just going to copy paste from the previous days because it's a lot to just rewrite it.
00:31:50.700 - 00:32:09.190, Speaker B: Going to literally copy paste this. Then we're gonna copy paste this. Beautiful. Okay, so I think it's literally called example hash. Okay, cool. And then we're going to copy paste this from final as well. Yeah, let's get this going.
00:32:09.190 - 00:32:32.120, Speaker B: Oh, let's stop this. Let me find the day. One day. Yep. Okay, so let's replace that with the past eight months so we see, like, a bit more pattern. Okay, let's get this going. What's wrong here? Oh, let's do this.
00:32:32.120 - 00:32:55.038, Speaker B: Eight month. Okay, looks like we have some answers. Take a look at some of them. Let's see. So this one, internal transactions. Wonderful. Okay, so it looks like either scan is back.
00:32:55.038 - 00:33:14.610, Speaker B: Okay, so b for e one. B for e. One is here. And then seven something is basically called by this person. So this is a contract. This is another contract. This is what we're.
00:33:14.610 - 00:33:32.354, Speaker B: Yep, this is what we are expecting. Okay, so let's get the bar chart going. Source Yep, that is what I want. So we're going to enable stacking. So this would be our USD, right? This is our USD volume. USD volume. Okay.
00:33:32.354 - 00:34:03.680, Speaker B: And then we're going to create another one for frequency. Source. Nope, frequency group by source enable stacking. And then we're going to call this frequency. We can already see predominantly it's just wallet or externally owned account here. Most of the caller of the caller of the Uniswap raft eth call is actually from externally owned account or like our wallethead, which makes sense. Okay.
00:34:03.680 - 00:34:18.224, Speaker B: So that is the answer for day five. This is not a bullet proof situation to see the actual originator of the call, but we're trying to get it to the true source of the actual swap call.
00:34:18.352 - 00:34:27.168, Speaker A: Thank you, Jackie. Great walkthrough. As per usual. For the bonus points, try and see if you can categorize the sources even further.
00:34:27.264 - 00:34:27.544, Speaker B: Right.
00:34:27.592 - 00:35:07.440, Speaker A: So you'll see a bunch of aggregator contracts. C theme can categorize things into aggregator or multisig even like mev, like adding on the love mev. So you should be able to get even more high fidelity categories. For tomorrow we're going to have the ultimate query for the usage section. We're going to try and take everything that, all the variables that we've already created in the last week and put them into one query across all pairs containing USDC token so that we should be able to see a cluster of different USDC pairs and almost be able to rate them based on their usage values.
