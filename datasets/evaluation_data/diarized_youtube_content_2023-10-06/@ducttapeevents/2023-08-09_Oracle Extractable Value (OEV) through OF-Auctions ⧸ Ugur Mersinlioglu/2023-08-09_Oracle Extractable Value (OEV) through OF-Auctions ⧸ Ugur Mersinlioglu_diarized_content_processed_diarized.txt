00:00:02.720 - 00:00:25.854, Speaker A: Thank you. Test, one, two. Perfect. Hi, I'm Ugur. I'm a product owner at API three and I'm going to be presenting something that we've been working on for quite some time. Oracle extractable value through order flow auctions. Before I get started, I typically like to ask, how much do you know about oracles? Does everyone here know how an oracle works? Raise of hands.
00:00:25.854 - 00:00:50.692, Speaker A: If you do perfect quite some people. So the next slides then will be pretty boring, but I'll go over them anyway. So why oracles? Pretty short. A blockchain is essentially isolated in itself. You can't simply make API calls. So if you need some type of information, like the weather, you need some entity bringing that in for you. I typically like to take the example of price feeds.
00:00:50.692 - 00:01:27.400, Speaker A: How is data being brought on chain? Price feeds are essentially price information that is maintained on chain according to certain conditions. And it is according to certain conditions because we have a cost limitation. We cannot simply update data each and every single block. Imagine an ethusd data feed on ethereum mainnet. You simply cannot pay that much money to update it with every single block. And there are two dominant architectures, namely pull and push oracles that are currently being used to consume price information. I'm going to go into the first one, push oracles.
00:01:27.400 - 00:02:08.784, Speaker A: People might know this from Chainlink. So data points are essentially updated according to certain triggers, namely deviation and heartbeat. So for instance, every 1% move, if we have an on chain price of 1000 ETH, we know the next update will be 1010 or 990 or heartbeat. If there hasn't been an update in the last hour, please update the price. The goal of push oracles effectively is to reflect the real world on chain whenever it matters. To save costs and whenever it matters is typically defined as a certain price move or no update in a while. The good thing about push oracles is that a price is maintained on chain.
00:02:08.784 - 00:02:58.614, Speaker A: You can simply consume it, you don't need to think about getting it or whatever. You simply read price for from storage problems. With push oracles, everybody always wants the latest price, and it is because of that that they are pushing for very low deviations. Like you want to be as close to the real world as possible, but that low deviation threshold is increasing cost exponentially. So you're basically, the lower you go, you're striving for every block, which again makes it unaffordable to do so. So we got to ask ourselves, who pays for that granularity? Is it the chains themselves, which some do? Is it the Dapps rarely Dapps pay for oracles. Is it the oracles themselves that subsidize it? Another major disadvantage is that a typical push architecture, the update is only triggerable by the oracles that are defined in a data set.
00:02:58.614 - 00:03:37.214, Speaker A: For instance, again, if you look at something like Chainlink, there are 30 nodes in the efUsD price feed and they update according to 1% and 1 hour. You cannot pay them, you cannot do anything to force an update. That is what you live with. Which brings me to pull oracles. So pull oracles. Something like PiF does this, they maintain essentially the price somewhere else on their own chain, and you can pull it onto the chain that you want to consume it on whenever you need it. For instance, a user could be opening a leveraged position 20 x long on ETH on Quanta, and for that they want the latest price and they pull the price on chain with opening their position.
00:03:37.214 - 00:04:09.176, Speaker A: Or a searcher could be updating a price to liquidate somebody on a lending market. The goal here, similar to push oracles, is to reflect the real world on chain whenever it matters. Just that, whenever it matters here is defined differently. We actually take the actual interactions when a user uses the protocol. When a searcher wants to liquidate someone, that's when the oracle events happen. Which basically brings me to the bottom point. The data is not being maintained on chain and needs to be written every time it is needed.
00:04:09.176 - 00:05:15.972, Speaker A: But anyone can do so as long as you pay for the transaction costs. The problems with oracles. So since there is no maintenance of price information on chain, you literally have to pay every time you want to use it. So you pay every time for the Oracle, who pays for this? Namely users and searchers. And there was a really interesting discussion about this in the AaVE forums lately, where one of the core developing teams of AAVE basically said that from a technical standpoint, it's not really possible for them to change AaVE from a push to a pull model, because it has two great implications on UX and the protocol. Just imagine you want to take a loan on AAvE and not only paying for the contract interaction now you also have to update the price every time. Funnily enough, I think one of the solutions that was suggested is that somebody just runs a quote unquote price pusher to take the price from there and update according to 30 minutes, heartbeats and 0.25%
00:05:15.972 - 00:06:20.198, Speaker A: deviation, which effectively just turned this pull architecture into a centralized push architecture, which makes little sense, which effectively brings me to the this major disadvantage. It is a new architecture that is not as proven as push oracles yet and requires major changes to the protocol design at UX. So people simply currently don't want to do it. Which brings me to what is MeV? So all of you probably know MEV stands for maximum extractable value and it is a hidden fee that is imposed on blockchain users by more strategic third parties that are extracting value from their transactions. The best example for this is probably the sandwich attack on a decentralized exchange. You want to buy 50 ETH worth of Pepe, somebody sees that in the mempool, they buy before you, they sell after you, they extract value from you. What does this have to do with oracles? So oracle extractable value is basically a subset of MeV that is related to how Oracles function.
00:06:20.198 - 00:07:18.136, Speaker A: Dapps use oracles to determine prices on their supported assets, which means that any update to a data feed or even the lack of such an update can create opportunities for value extraction. This could be front running. For instance, you do something before an oracle update and after it could be arbitrage. The off chain exchange is further ahead than the on chain equivalent, so you arb the difference or liquidations. So effectively similar to MEV, OEV just describes the value extraction by more strategic third parties, but related to oracles. A quick example I think that everybody here will understand this was last October, the GMX front running Oracle updates example, which triggered them to make some changes to their protocol. So effectively, GMX for those of you who don't know, is a derivatives protocol that is based on oracles instead of an order book.
00:07:18.136 - 00:08:08.080, Speaker A: So you can open a position directly at Oracle price and close directly at Oracle price. The problem is you can monitor the mempool for Oracle prices, so you know when an update occurs, you can buy before the update, you can sell after the update, you profit and you can repeat this indefinitely. There's nothing they can do to stop you. And that effectively led to approximately 10% of their entire protocol revenue or profits being extracted by MEV bots over 40 days, which led to $260,000 being essentially just siphoned off. So oev awareness, most of the blockchain industry acknowledges oev. We've been talking about it I think for two or three years. However, neither Oracle solutions or dapps today are really oev aware.
00:08:08.080 - 00:09:09.590, Speaker A: And what I mean by that is that they don't do anything significant to stop losing value to third parties. A band aid solution typically is ask for more granular feeds, but as I explained in the push oracle scenario, you can't do every block on every asset. There's just simply not enough money in this ecosystem to pay for that. So how do we solve this problem? We need a solution that effectively eliminates or retains most of the oev that we lose to third parties, while at least maintaining current user experience. What I mean by that is there is reluctance to switch from the known push model by simply reading data to something like a pull model. While we also do not jeopardize the integrity of data feeds. We were effectively building such a solution for quite some time and we looked what is currently already out there in the MEV industry, and the typical thing are order flow auctions.
00:09:09.590 - 00:10:04.256, Speaker A: You as a user can redirect your order flow if you create transactions, they might be related or they might create MEV, and you can route your transactions effectively to a private mempool that promises not to gossip your transactions, extract the MEV and distribute it back to you. Good examples for this are MEV blocker or flashbots. MEV share. The problem mainly is, and there are quite a lot why we can't route Oracle updates through there. The biggest one is that these auctions introduce latency, and Oracle updates shouldn't deal with latency because that is jeopardizing the integrity of the data feed. You can't just effectively update a data feed 30 seconds later because you're waiting for an auction result. So what we needed was an order flow auction that is specialized for oevolution.
00:10:04.256 - 00:10:52.054, Speaker A: So we were thinking that we need the oracle nodes that effectively update the data feed based on deviation thresholds on the public mempool. So there's no delay, there's no auction, nothing we need to wait on. So the classic model that maintains it. But in addition to that we run an order flow auction. Basically oracles getting updates and allow searchers to bid for these updates. So effectively, whenever there's something, some value that they can extract, they make a bid for it, they get it through a meta transaction and then they're allowed to update the data feed. This design effectively maintains the security guarantees that the data feed has, while allowing to generate value that oracle order flow generates to be auctioned off.
00:10:52.054 - 00:11:54.556, Speaker A: What allows this is what we call the OEV relay. So this right here and what that does is it's effectively collecting signed data from all oracles that are within a data feed, and then the auctions are auctioned off in a sealed bid auction. Sealed bid means somebody makes an offer of 900, but they don't see what everybody else bids. So everybody bids what that update is worth for them. The winner then gets a meta transaction with that contains the information of how much they bid and all the signed information, and they can use that to update the data feed and net all of the rewards that come with that. One big issue that we still had with that is if somebody updates because they can liquidate somebody on Aave, that price update might actually also cause OEV, for instance, on synthetix. How do we deal with that? Which effectively brought us to data feed proxies.
00:11:54.556 - 00:12:36.768, Speaker A: So instead of everyone reading a base data feed, we thought it might be wise that every Dapp has their own data feed proxy. These proxies are effectively reading the base data feed, but are updatable through the OEV relay. An update is only accepted when the meta transaction and the payment are made to the proxy. And since each Dap has its own proxy, you know precisely where the OEV was generated. So for instance, a searcher makes a bit on ETH USD specifically for Aave. That has nothing to do with what happens on synthetix, so they can exactly know their bidding to update. For Aave, the big picture is then effectively this.
00:12:36.768 - 00:13:23.850, Speaker A: I'm going to start on the right side. We have the Dapp. The DAP reads their Dapp specific proxy, and that proxy underlying reads the base data feed that I talked about. This data feed, similar to something like Chainlink, is updated by a bunch of oracle nodes on the basis of deviation. So this could be at 1000, and we know the next update will be at 1010 or 990. But if there's a searcher that says it's 999 and I want an update now because I can liquidate somebody, they can make a bid, get signed data from all of these and update this Dapp specific proxy. And this proxy essentially prefers the more recent update, which is determined on timestamp.
00:13:23.850 - 00:14:23.124, Speaker A: So they then essentially pay directly to this contract, update it, and with that update they can extract everything that they want. Simple example, which makes it maybe more appealing to everyone. Everyone knows AaVE, I hope AaVE uses oracles to determine the value of assets, and borrowers are for instance, liquidatable on the basis of said data. One big issue that dapps face, or let's say one big thing that dapps do, is they give people a liquidation incentive to liquidate somebody. And the typical problem we face there, because there are a lot of lending Dapps trying to optimize for this, is this incentive is typically percentage based. So when there's a $1,000 liquidation and you liquidate somebody, the searcher gets like $20 for it. You have to keep this rather high in order to be incentivized enough to do this on low amounts of money.
00:14:23.124 - 00:15:20.304, Speaker A: But when we are looking at something like this, you suddenly are paying somebody ten k for simply liquidating somebody, which when we spin larger gets pretty inefficient. Not only are you essentially giving them too much credit, you are taking away more collateral from the borrower than you should be. Which brings me to Aave push, the classic how Aaver currently works with push oracles. Imagine we have an ethusd price feed with a 1% deviation and the on chain price is currently $1,000. We know, as I said five times, probably already, the next update will be 990 or ten, but there is a user position that is liquidatable at 995 in this current Aave model. We need to wait for the oracle update to occur in order to liquidate the position. We can't do anything, we just wait for the oracles.
00:15:20.304 - 00:16:03.906, Speaker A: Once updated, the value is essentially being extracted by external players. Nothing flows back to AavE. The user gets essentially liquidated and the value just goes to the external people monitoring for such liquidations. And to top it all off, due to this update mechanism, the user is actually not getting liquidated at 995, they are getting liquidated at 990. So they are losing more collateral in the process than they should be. What if we use the pull oracle model on AAve? A pull oracle model would actually be better when it comes to liquidations, because liquidations can occur directly at 995. The user gets efficiently liquidated directly when they should be.
00:16:03.906 - 00:16:47.180, Speaker A: But the big issue is that the value is still being lost to these third parties, and we're speaking more of the bigger liquidations. So you're effectively because somebody is liquidating them, having to give them ten k out of your pocket. If we talk about a half million liquidation. And like I mentioned in the slides as well, the overall ux implications of switching from a push to a pull model are currently simply too high. Which brings me to Aave on an OEV data feed model that we have been working on. So with the OEV data feed model, we focused on maintaining the typical push infrastructure that is out there. Aave doesn't need to do anything different, they simply read price.
00:16:47.180 - 00:17:54.196, Speaker A: The users don't need to bring oracle updates on chain. The protocol doesn't need to change anything you simply read from storage. On top of that, liquidations can occur at 995 because searchers can simply go to the OEV relay make bits, take those signed data updates, update the oracle and effectively liquidate the person the user gets, like I mentioned, efficiently liquidated because they are getting liquidated at 995 instead of 990 and because searchers actually compete. Searchers already compete when we talk about MEV, but the main difference is that these proceeds go to validators with OEV auctions. We actually bring the auction process itself to the Oracle and we as API three similar to MEV blocker or flashbots MEV share have a 90 ten model where we redistribute 90% of the proceeds back to the Dapp. So effectively AVA retains more value through competition among the searchers. The value doesn't go to the searchers and validators that they bribe.
00:17:54.196 - 00:18:43.172, Speaker A: The searchers are actually paying back the Dapp for the value that they bleed. So why use OEV data feeds? I've been on vacation the last two weeks. I have been told it is now called OEV share, if I'm correct. Yes. So similar to Mev, the users demand that Mev that there are solutions to MeV extraction. We know about Mev Blocker, we know about stuff like Carl swap, we know about flashbots, Mev share, and OEV is actually nothing different. Just like users want something to block MeV being extracted from them, dapps are slowly and more frequently demanding that value that they're bleeding away due to Oracle updates gets minimized or eliminated entirely.
00:18:43.172 - 00:19:24.634, Speaker A: And with OEV data feeds, we effectively wanted to create an opportunity for sustainable revenue for the oracles while helping Dapps users and chains retain value that they're bleeding away currently due to oracles that simply update without thinking about what actually happens due to their updates. And that is pretty much it. We have a bounty today, so just check out the hacker manual. I believe it is. And there are also some t shirts for everyone that wants some and otherwise I am open for questions if there are some.
00:19:36.514 - 00:19:42.174, Speaker B: Any questions. Okay, I guess.
00:19:42.754 - 00:19:48.002, Speaker A: Perfect. All right, thank you. Oh, I think there was one.
00:19:48.098 - 00:20:40.490, Speaker B: We do. Okay, thank you. Just one question. If we have trading protocol for example, or lending protocol which relies on oracle data and we want to avoid that value is extracted based on updates and we know that the update is every 0.25%, for example, wouldn't it be then the easiest way to just charge as much fees so that the update, if it's only by that value, will basically cause the loss for the difference for the searcher, for example, for the searcher.
00:20:40.682 - 00:21:22.626, Speaker A: The problem is if you're charging money, you're making your protocol in one way or another more inefficient due to the fact that the oracle is not optimized for your use case. So what you're going to do is you're going to charge the searcher more, which in effect might endanger smaller liquidations. Like smaller liquidations are already a big problem because you have to incentivize searchers to actually take them on because there's nearly no money in it. But while doing so, you're making the larger liquidations way too attractive. So if you're going to charge something on top, you're just going to make the problem on the smaller and bigger, and people are just not going to liquidate those people anymore, or barely.
00:21:22.810 - 00:21:29.454, Speaker B: Okay, makes sense. Thank you. All right, last question.
00:21:32.674 - 00:21:47.364, Speaker C: So how large is this problem? I mean, you gave an example saying that 250k was kind of dragged out of GMX and MeV is a really big problem. Is there a way to kind of quantify how large is the opportunity and the problem here?
00:21:48.384 - 00:22:42.230, Speaker A: Basically anything that in one way or another uses an oracle is somehow creating OEV. And in some cases it is just accepted, for instance, the liquidation example. And in some cases there are protocols effectively running their own searchers and limiting who can liquidate on their platform or who can arbitrage on their platform because there's MEV bots and others coming in and simply taking value out of it. And we're not talking only about front running oracle updates or liquidations. There are bigger market makers or entities arbing the difference between off chain and on chain values. And there's nothing that the protocol alone without the oracle helping can do about that. And maybe also like one thing, we're currently in the alpha with this, and we have, I believe, currently five dapps that are alpha testing this with a bunch of searcher groups where they can essentially do that.
00:22:42.230 - 00:23:24.186, Speaker A: And what happens is just that, like the value is not eliminated, it is still there. You're just making it so that these searchers, similar to something like MeV blocker or whatever, they're competing with each other. And instead of this money that they are currently paying to validators for priority, they're actually paying to the auction host, in this case the oracle operator. But we effectively, similar to MeV Blocker, redirect almost all of it back to the Dapp. So it's not gone. We're just making it so that the money stays in your pocket. I think our co founder likes to say, imagine you have a leaky pocket and when you walk there's something falling off and every $0.90
00:23:24.186 - 00:23:28.374, Speaker A: you drop or every 100 cents you drop, we give you 90 back. And we keep ten.
00:23:30.894 - 00:23:33.294, Speaker B: Thank you, Ugger. Perfect. Thanks.
