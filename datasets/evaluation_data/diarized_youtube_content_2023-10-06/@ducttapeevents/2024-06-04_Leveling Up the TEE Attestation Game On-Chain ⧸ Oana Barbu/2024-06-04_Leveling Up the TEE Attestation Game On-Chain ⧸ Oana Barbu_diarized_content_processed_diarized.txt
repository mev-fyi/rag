00:00:08.560 - 00:00:21.634, Speaker A: Okay, let's continue and greet Oana Barbu, and she's going to talk about leveling up the tea attestation game on chain. Round of applause, please. Thank you.
00:00:30.834 - 00:01:47.394, Speaker B: Hi everyone, I'm Juana and from automata and I'm going to tell you how we can make the decision costs cheaper on chain. But before I talk about the attestation, I would like to ensure that we both have this. We all have the same understanding of what Tes a Te, or trusted execution environment, is a memory enclave within hardware that prevents unauthorized access to the data and code store inside it. Neither the operating system kernel nor the hypervisor can tamper with the enclave's memory. This is achieved by having the cpu encrypt the enclave's memory to protect its privacy and provide computational integrity, and it also ensures that only the enclave is able to decrypt its memory. Common implementations of tes are intelligent and IntellectdX, Amdsuv and AWS Nitro Enclave. We believe that tes are very suitable for blockchain applications.
00:01:47.394 - 00:03:31.534, Speaker B: Chances are that if you think about privacy and security for blockchains, you are most likely to think about zero knowledge, fully homomorphic encryption, or multiparty computation. However, despite notable progresses in these technologies, they often come with high latencies, complex implementations, and computational overheads, and some applications may not be able to tolerate this. On the other hand, Tes do not rely solely on the elegance of math, but they are faster, cheaper, and more practical, and these characteristics make them very attractive for applications. Today we can use T's to implement roughly all we can implement in a standard computing environment, and we do so with minimal overheads that usually come from encrypting and decrypting the enclaves memory, at automata, we leverage tes to build co processors. Te co processors, for instance, we built the co provers for rollups. Co prover enhances the security of a roll up by independently computing the state transition and ensuring that the state transition that the roll up is proposing is correct. Therefore, if both the Te coover and the roll up agree on what the state transition is, then we can have more confidence that the state transition was computed correctly.
00:03:31.534 - 00:05:11.424, Speaker B: However, a fundamental challenge when we deal with Te coovers, or Te co processors in general, is how can we ensure that the application we interact with is indeed running inside the Te. It is essential that we ensure the legitimacy of a TE before interacting with it to be able to accept the result it produced, or maybe sharing sensitive information with it. So if we imagine a scenario where two machines claim to be tes. How can I verify that the integrity of the Te before engaging with it? And luckily we don't have to blindly trust we can actually verify that the Te is authentic and this is done using remote attestation. Remote attestation is a security mechanism that enables the TE to prove its identity, integrity and configuration to another party. By engaging in remote attestation, any external party can verify the authenticity of the TE and ensure it is running trusted software and configuration. During remote attestation, the Te produces an attestation document containing details about its identity and configuration, and this document can be examined by the verifier to check that the tEA is following the established security policies and requirements.
00:05:11.424 - 00:06:14.184, Speaker B: Only a legitimate TE is able to generate a valid attestation document, and thus any malicious effort to impersonate the TE will be detected. So let's take a look at what the attestation document contains to understand why that is the case. So the structure of the Te document might differ depending on what tea technology is being used, but all documents will have these three elements. So the first element is, is the enclave's identity or the public key. This public key is linked to the tea manufacturer and its private counterpart is inside the hardware and only the enclave itself can access it. Besides this, we also have the enclave measurements. These are the details about the enclave state, including the software that the enclave is running, its configuration firmware and others.
00:06:14.184 - 00:07:33.944, Speaker B: And lastly, we have a digital signature that's produced using the TE's private key, and this ensures that the enclave identity and measurements are authentic. The next natural question is how do we know that the public key of the text is legitimate and recognized by the TE manufacturer? I'm going to use intel in this example, but a similar process applies to the other TE technologies as well. So we do this. We ensure that the TE is legitimate by having a chain of trust linking the TE public to its manufacturer. In this case, the chain of trust is an X 509 certificate. I'm not going to details of what this X 509 standard is, but it's basically the same technology that allows you to verify that the website is authentic when you land on it. And the X 509 certificate used by intel uses the SCP 256 r1 algorithm for digital signatures.
00:07:33.944 - 00:08:53.576, Speaker B: So if, let's say we want to verify the attestation document on chain, part of this verification will be to verify all the SCP 256 one signatures that are part of the X 509 certificate. And unfortunately the EVM does not support SCP 256 are run natively and this operation is quite expensive to do on chain. More precisely, a naive verification of an intel attestation documents cost about 3 million gas to do on chain, out of which half of is spent on verifying SCP 256 r1 signatures. And considering how much this operation costs, it seemed like a good idea to try and optimize it. So we tried to answer the question how can we make SCP 256 one verification cheaper? We thought about using precompiles. Incidentally, SCP 256 r1 is the popular curve and the precompiles for it are being adopted at least on l two s. But there are other cryptographic primitives that are used in te attestation which are not as widely adopted.
00:08:53.576 - 00:10:05.954, Speaker B: For example, AWS nitro enclaves uses elliptic, the P 384 and shard 384. It's attestation document, and we don't know if and when these precompiles are going to be widely available. So we also considered using rollups. But a significant drawback of optimistic roll ups is that they use fraud proofs, and fraud proofs have a finality time of up to seven days, and this is a very long time for waiting on a TE attestation. As I mentioned before, one of the many benefits of using TE is their speed, and having to wait seven days to establish whether a TE is legitimate is a very long time. And Zk roll ups also come with their own limitations. Validity proofs are notoriously difficult and time consuming to compute, and they largely limit the functionality of Zk roll ups to simple transactions like transfers and trait.
00:10:05.954 - 00:11:09.784, Speaker B: However, zero knowledge is particularly useful for compressing computation. So we decided to look closer at using zero knowledge to reduce computation, the computation required to do on chain to validate the signature. So instead of trying to verify the signature on chain, we wanted to offload this computation off chain and create a ZK proof that shows the signature has been properly verified. This proof is succinct and efficient, and typically ZK proofs are fast to verify. But the question was can we build a ZK proof that is cheap enough to verify on chain? So we tried a couple of approaches. This is a summary. We started with a baseline of 330k gas per signature verification.
00:11:09.784 - 00:13:00.604, Speaker B: This was achieved using dymos P 256 verifier contract, and we shaved a third of the computation cost by using a basic CK circuit, and we were able to further reduce this cost by using aggregation. And with aggregation we were able to get to 120k gas per signature verification. So roughly what ZK basic does is we have a ZK circuit. We feed the SCP 256 r one signature into it to produce a proof, and then we verify this proof on chain and with aggregation. We have this aggregation circuit that takes in multiple SCP 256 r1 proofs and generates a aggregated proof that we later verify on chain proof aggregation is a method that basically allows several proofs to be combined together and produce a new proof that proves all the validity of all the initial proofs. So in our case, verifying the aggregated proof costed about 480k gas, meaning that one signature verification was about 120k, which is a third of the initial cost. But then we thought, what if we can offload the whole attestation verification to a ZK circuit? Building a circuit capable of proving the whole attestation document is a very challenging task, so we did not do it ourselves.
00:13:00.604 - 00:14:19.974, Speaker B: Instead, we decided to use a ZK VM for the task. Zkvms are specialized virtual machines designed to ensure computations are performed correctly, and they are also capable of handling general computation. So therefore all we had to do was write the rust program that verifies the attestation document and let RISC zero VM generate a proof for us. And to our surprise, verifying this proof on chain only costed about 330k gas. So what this all means? By using ZK vms, we were able to make the attestation verification ten times cheaper, meaning that is that much cheaper to verify that we are talking to a Te attestation is extremely important for te enabled applications, so this is quite a good result. But beyond this, I also want to share two more general lessons. The first one is that abstraction is a very powerful thing.
00:14:19.974 - 00:15:44.968, Speaker B: Zkvms are general, and perhaps not as optimized as dedicated circuits could be, but they're more optimized than what most people can design. The ZK VM logic is written by experts in the field that know the inside out of the ZK, and it turns out that this universal circuits are more efficient than dedicated circuits written by layman. To put things in perspective, as I said, for our aggregation circuit we were able to verify the proof in using 480k gas, and that was just for the signature verification, whereas with the ZKVM circuit we were able to do everything in 330K gas. And moreover, ZK vms removed the need to learn complicated mathematics and cryptography that are required to design ZK circuits. And the second lesson is related to the importance of using the right tool to achieve good performance and efficiency. At automata. We are generally in the TE camp and our coover showcases how tes can help ZK applications.
00:15:44.968 - 00:16:28.080, Speaker B: But this time around, it was ZK that helped. And generally we think that while ZKN tes are seen as competing technologies, we believe that they are both useful tools to have in your toolbox. If you want to learn more about automata, these are our socials. There you can learn more about our multiprover AV's, our T blockbuilder and other projects. Thank you for your time. And I think I can, I have some time for questions.
00:16:28.192 - 00:16:47.724, Speaker A: Thank you very much. Yes, if there are any questions, please, we still have some time. Looks like everyone is tired today, so thank you very much. Round of applause. And at 06:30 oh, there is a question. Great.
00:16:52.344 - 00:17:05.084, Speaker C: Hello. I just have a simple question. Is any of these decentralized, or is like automata running all the hardware for these services? How does it work? Is it a decentralized protocol?
00:17:06.064 - 00:17:09.468, Speaker B: So I'm not sure I understand the question.
00:17:09.516 - 00:17:19.780, Speaker C: Can you, if it's decentralized, the automata protocol, like does it take requests for, for doing this trusted te stuff? Yeah.
00:17:19.812 - 00:17:27.584, Speaker B: So you have a contract that will verify the attestation document and that contract is deployed.
00:17:28.324 - 00:17:38.874, Speaker C: But who's doing this? Is just automata, the company? Or are there other participants in the, is it like a network where anyone can, can participate? How does it work?
00:17:39.334 - 00:17:49.354, Speaker B: We just implement the algorithm for verifying the attestation on chain, but once it's on chain, it's decentralized.
00:17:49.734 - 00:17:51.594, Speaker C: Okay, understood. Thank you.
00:17:55.814 - 00:18:16.934, Speaker D: Hi, I just saw that you been having a token since 2021, and I guess I wanted to understand a bit more how the token interacts. And how does the token accrue economic value or transmit economic value in your ecosystem?
00:18:19.154 - 00:18:36.144, Speaker B: Currently we don't use the product that we have with our token. So this is currently deployed on arbitrum, on Cepholia, on the testnet. So we don't deploy this on our.
00:18:36.804 - 00:18:39.516, Speaker D: This particular te that you've been using.
00:18:39.540 - 00:18:41.772, Speaker B: Yeah, yeah, and, yeah.
00:18:41.868 - 00:18:53.504, Speaker D: And then the token accrues value from other things that automata has done in the past, or how does that work? How does the economic kind of incentivization work?
00:18:55.784 - 00:19:12.604, Speaker B: To be honest, I'm not the most capable person of answering that question, but I think it's the product that we try to build, maybe help us gain more popularity.
00:19:13.024 - 00:19:14.324, Speaker D: Okay, thank you.
00:19:15.424 - 00:19:16.644, Speaker A: And one more.
00:19:17.504 - 00:19:44.302, Speaker E: Hello. Thank you for the talk. Like for, if the hardware manufacturers, if they allow for signature schemes that are compatible with blockchains like ED 250 519, will there any need to have ZK verification on chain. We could just directly verify the digital signature schemes. Right?
00:19:44.398 - 00:19:53.082, Speaker B: Yeah. So you can do it directly on chain, but because it's not supported, you basically spend a lot of guess trying to compute the verification.
00:19:53.218 - 00:20:02.854, Speaker E: Right, right. But if it comes to be possible, then we don't need this. Right? I mean, I guess for aggregation, ZK is still useful.
00:20:03.514 - 00:20:17.242, Speaker B: Oh yeah, absolutely. Like if, let's say SCP 256 one is being adopted in the EVM, then you don't need to do that. You don't need to do the offload of the computation anymore.
00:20:17.378 - 00:20:22.738, Speaker E: Right, right. But I think aggregation still makes a lot of sense, actually. Yeah. Thank you.
00:20:22.866 - 00:20:34.374, Speaker B: Yeah, yeah. Actually you like once, instead of verifying a single attestation at a time, you can also verify multiple attestations in the future, let's say by aggregating them. Yeah.
00:20:34.674 - 00:20:54.594, Speaker E: And actually, so you mentioned that you have used, how was it, Risc zero or. Yeah, right. Have you tried with other more like specialized circuits for like other more performant proving systems or just Risc zero?
00:20:55.654 - 00:21:00.374, Speaker B: We try to use sp one as well, but we are still working on that.
00:21:00.454 - 00:21:02.354, Speaker E: Okay, cool. Yeah, thanks.
00:21:04.334 - 00:21:08.754, Speaker A: Thank you. Good.
