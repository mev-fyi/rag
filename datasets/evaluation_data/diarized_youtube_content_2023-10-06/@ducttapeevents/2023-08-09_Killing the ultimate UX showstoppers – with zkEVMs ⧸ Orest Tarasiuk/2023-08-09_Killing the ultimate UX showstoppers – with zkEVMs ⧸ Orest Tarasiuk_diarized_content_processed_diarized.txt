00:00:00.320 - 00:00:32.804, Speaker A: Hello. Hello. I'm orrest. I'm with scroll, and I am here to talk a bit about UX, but from a rather technical perspective, I'm here with scrolls. So all we do are ZK evms. And so I'm gonna try to convince you why going for a ZKE EVM is something that can also help to resolve the UX issues that people are seeing today, that users are seeing today. And that also result in a bottleneck to Ethereum adoption and crypto adoption as a whole.
00:00:32.804 - 00:01:34.412, Speaker A: And so the number one, in my view, UX showstopper right now are actually high gas fees. And what results from this, like network congestion and developers focusing on gas, optimizing their contracts rather than working on something that the user themselves would be able to benefit from. And so in order to tackle this, we with scroll, set out on this journey to create a Zke EVM. And by a ZK EVM, we mean a roll up that uses zero knowledge proofs in order to add scalability to Ethereum. Now there's this kind of mystical element to ZKe evms, and so I'm trying to work towards uncovering that. And in order to adjust, I'd like to get a quick show of hands. Who would be able to define each of these terms that are of interest.
00:01:34.412 - 00:02:28.930, Speaker A: So zke EVM scaling, Ethereum rollups and zero notch proofs, who is able to define them roughly? Okay, so it's like maybe a third of the audience here. That's not bad. So maybe we can jump into some challenges when building Zke evms as well. And so still to the other two thirds, it might sound a bit scary. You have all those keywords and you don't really know how to apply this to your use case. You don't know where this leads to compromises. And so I'd like to start with a bit of a personal journey of entering the world of crypto and being exposed to all of those keywords and buzzwords and feeling kind of overwhelmed in order to show you that this is something that passes and it's not something that's unavoidable.
00:02:28.930 - 00:03:27.454, Speaker A: And next, we'll talk about Ethereum's trilemma choices briefly. I think most of you might be familiar with it. And then we'll jump right into solutions to those trailer choices, and we will follow a hierarchy going deeper every level along the way. And so we'll start with l two s, we'll focus on one type roll ups, we'll focus on one type Zkrollups, and we'll focus on one type of those, the ZKE EVM, and next a quick update where scroll is at with respect to this hierarchy and the progress on that pathway. And finally, if we have time, we'll talk about challenges. If anyone's interested in getting the slides we are trying to build in the open, not only when it comes to our GitHub repo, but also these slides are actually commentable. So feel free to also highlight whatever maybe keywords or definitions are not comprehensible.
00:03:27.454 - 00:04:02.342, Speaker A: And we are trying to be responsive even in our Google Slides threats discussion threads. And also feel free to hit me up. I'm an engineer working at Scroll. I might be able to help with some of the issues you might have encountered. And also we are having a hackathon and some bounties during this event. So hit me up on Twitter diemopen if you have any questions regarding that as well. Okay, so entering the world of crypto.
00:04:02.342 - 00:05:08.784, Speaker A: My background is classical computer science, and I created a mobile health startup before doing crypto. And then I was exposed to all of those weird buzzwords and I thought everyone around me was able to comprehend and define each and every one of them. And I felt really silly. And so I figured, let's see how these things work. And only upon talking to people and asking, hey, so could you tell me about how exactly this byzantine, fault tolerant property comes to be in this algorithm? Was it that you uncover it's very normal that people are actually struggling with anything that's outside of the daily business. And so don't be shy and ask people, use the opportunity, I guess, and just assume that it's okay not to know everything. Now, when talking about Ethereum, the first thing you might think about is that everyone is supposed to love it, especially when you are in your little bubble here in ETH Prague that has Ethereum in its name.
00:05:08.784 - 00:06:22.854, Speaker A: Obviously, everyone will love Ethereum, but then as soon as you Google Ethereum problems, you will very quickly stumble across this one magic number, or version thereof, of roughly 15 tps transactions per second. And that is basically the scalability issue that Ethereum is seeing. And so is it an Ethereum thing, or is it maybe something that has to do with blockchains overall? Well, as a computer scientist, I would say that actually has to do with database systems with dvss or dvs. And there's longstanding trilemma choices in distributed database design sciences, such as the Capp theorem, where you only get to pick two out of three very desirable properties. And so this kind of translates into something that came to be known as the blockchain trilemma a few decades later. And it basically says you have those three properties, decentralization, security and scalability, and you only get to pick two out of those three. What a dramatic decision to make.
00:06:22.854 - 00:07:27.664, Speaker A: And so Ethereum picked to sacrifice scalability in order to keep and be able to take advantage of the security and decentralization properties. That's where the 15 tps come come from. Now, my argument is going to be, did Ethereum really sacrifice this scalability? But first, let's think about alternatives briefly. Well, there is the alternative b, which is sacrifice decentralization. That's the, I guess, standard way of doing things before the blockchains. And that's like monolithic systems such as visa, or maybe a chain that requires high hardware requirements for running a node. Or the other alternative would be alternative c, sacrifice security, lower maybe the parameters that you require, and then you end up in some sort of multi chain ecosystem with risky bridges and assumptions when it comes to trust.
00:07:27.664 - 00:08:28.614, Speaker A: Now, did Ethereum really sacrifice scalability? I would argue not really, because the concept of l two s has been around for a long time, and this has kind of been expected to be this trapdoor out of the trilemma. And so let's talk about how l two's L2 solutions help to solve, or at least alleviate the issue of scalability. If you looked up the definition of NL two a year ago, you would have found this or these two. They are basically changing every week now. And if you follow crypto Twitter, you will know there's a big mess when it comes to terms. So I don't want to get involved with this too much. I guess the main rough intuition I would give you is an l two is some sort of a system that solves, serves to scale Ethereum while retaining some notion or some inheritance of its security and decentralization properties.
00:08:28.614 - 00:09:49.150, Speaker A: And so roll ups are one type of such l two s, and they have been touted as the end game by some people and have come into spotlight in the last year or two. And so what roll up types do we have out there? Well, we have optimistic roll ups, and they have the advantage of being a bit more simple, although still very complex, and they are still not even built out to the full extent, but because of being a bit less complex, they have more adoption out there. You might have used an optimistic roll up to get a ticket or two, but they suffer from the slow ll one finalities. So you need to wait, usually for a week before you get to use your funds in another layer. And the alternative ZK knowledge based roll ups are such that actually allow you to skip this period of seven days to withdraw. Because instead of having an optimistic economy, incentives based assumption, you have a zero knowledge proof to convince other nodes on the network that what happened in the roll up actually is according to the rules. And the problem with these is they are more complex.
00:09:49.150 - 00:10:44.290, Speaker A: There's less adoption. And a note here, Zk rollups are not Zk Zk rollups. That is to say, ZK rollups have nothing to do with the privacy preservation property of zero knowledge proofs. They only use the succinctness property, the s in snarks of zero mesh proofs. Rollups that use both are called ZK zkrollups. Okay, so what are zkrollups? Well, they replace the re execution, the necessity for every node on the network to re execute a suggested set of transactions by a cryptographic validity proof. And those proofs have this amazing property that they are actually faster to verify than rerunning the set of transactions that they are proving yourself.
00:10:44.290 - 00:11:35.054, Speaker A: So this is very interesting, right? It's very counterintuitive. And on top of that, there's no trust assumption with respect to the prover, the entity, during the heavy lifting of creating such a proof that is then so fast to verify. And so there's two big types, I'd say, of ZK rollups, application specific ones. That's rollups that you might have seen out there in the wild, where you maybe just are able to run swaps. And there's also an application agnostic ones. So general purpose roll ups, that's what we like to call the Zke VM or the Zkevm. So, a virtual machine, a system, a model for running arbitrary computation, and that computation is verified using ZK proofs.
00:11:35.054 - 00:13:08.914, Speaker A: And so why VM? Well, here you can see the model of the Ethereum virtual machine, and based on which layer of abstraction you are as a ZK EVM Zkrollup running your computation proofs, you may find yourself located in one of five options for compatibility with the EVM, the Ethereum virtual machine, which de facto means, depending on how close you are to the Ethereum virtual machine, the closer you are, the more of the Ethereum virtual machine designed systems such as dapps, or maybe debuggers, or maybe optimizations for gas use. Is your roll up able to take advantage of. So that translates to developer onboarding, developer go to market, and so on. But it comes at the cost of being more complex so where is scroll in this map? Well, we are headed towards being a type two ZkeVM right now. As far as I know, there isn't really any type two Zkevm out there. And that is supposed. The idea behind being a ZKE EVM type two is that it seems to be a good compromise when it comes to the complexity of designing such a system and running it, and compatibility with existing ecosystem players such as debuggers, dapps and so on.
00:13:08.914 - 00:13:44.244, Speaker A: So yeah, Zke VM type two. That's something you can google what exactly the properties are and the benefits of such an approach would be. First of all, we still get to reuse most of Ethereum's infrastructure. Deploying a block explorer with scroll for me looked like I don't even need to clone git clone block scaling. I literally reused the docker container that they built for Ethereum and put in a new RPC endpoint. That's it. It's really cool.
00:13:44.244 - 00:14:33.834, Speaker A: This also means that this complexity of ZK proofs is encapsulated and abstracted away from you, the developer. And lastly, it means that a lot of the security assumptions can be inherited from EVM. So the motto here is let's make devx boring. Let's make it such that developer doesn't even notice they aren't developing for Ethereum, but for a roll up. And why is it possible now? What changed? ZKP's have been around for now 40 years. 40. But it's only been the last couple of years where big improvements, improving systems led to many orders of magnitude of speedup.
00:14:33.834 - 00:15:38.684, Speaker A: There's been hardware acceleration that also provided several orders of magnitude of performance increase. And lastly, because of the attention of the ecosystem, de facto because of the influx of capital and the building and the open building with very clever minds in one community. De facto, at scroll, for instance, we are literally forked Ethereum Foundation's repo and we are basically working together with them every couple of weeks and synchronizing up and downstream. Because you have all of those clever people with triple phds working together. This is not becoming a reality. So what's the catch? Still, why isn't scroll live on Mainnet? Well, it should be very soon, but why not yet? Well, because there is those two fold complexity costs to this. The direct cost is the computational cost of creating proofs.
00:15:38.684 - 00:16:25.806, Speaker A: So right now we are talking about hundreds of gigs of RAM and GPU's when it comes to the meta level. There's also this cost of creating this complex system and being able to audit it, being able to find bugs in it, that takes a lot of time. So where is scroll right now? Well, we are in the process of preparing our mainnet launch, so stay tuned and check out scroll IO for details. And what is the vision? Well, the vision is to stay very closely aligned to Ethereum and the Ethereum foundation, the Ethereum ethos. That's why we're here at ETH Prague. I think it's a very adequate event to be part of. We care deeply about decentralization.
00:16:25.806 - 00:17:34.164, Speaker A: We will be launching with centralized components, still with so called training wheels, but we are working very actively on decentralizing that. And my colleague togrul will be giving a talk in two days about how we are thinking about separating the role of the prover and the sequencer, similarly to the PBS approach. And we also are striving to work on EVM equivalents. And in the end, we would like to contribute to the ZK snark or snark, everything in Ethereum. Okay, so challenges in building such a system have three categories. The first category is writing ZK circuits. It means de facto, how do you translate your program that contains some lines of code and takes some inputs and gives you some output into something that more resembles an integrated circuit board, such as a ZK circuit of this shape, where you just have inputs.
00:17:34.164 - 00:18:44.182, Speaker A: And the only kind of effect or output is, is this a valid combination of inputs? Are they compatible or are they not compatible? And so that's one challenge. And it comes with several technical intricacies to it, such as the word, the length of the word that such a circuit, such as ZK circuit would accept when compared to words used in the EVM, is just unfortunately not very well aligned because we have 256 bit words in the EVM. But our ZK circuits, because of the underlying math primitives that we are using, actually are two bit short. So we need to annoyingly pad those or split up those EVM words. Next we have the challenge of writing the Zke Evm. So if you think about an EVM itself, it consists of this main component that contains the executor that runs opcodes. We have a stack and we have a memory.
00:18:44.182 - 00:19:22.304, Speaker A: We also have storage for the long term storage. And we have bytecode that we are actually loading into memory and execute the opcodes. The inputs to the EVM are transactions. Now, if we go away from the EVM and expand towards the ZKE EVM, we will need to add several new components. So we need a separate circuit for proving stuff that the executor is doing the EVM circuit. We need a separate circuit for the RAM. This has to do with how ZK proofs deal with random access.
00:19:22.304 - 00:20:43.714, Speaker A: We need a separate circuit to prove that we are actually using the correct bytecode and the correct storage Merkel Patricia tree. In this case we need a circuit to prove that we are actually executing the transactions that we are supposed to the inputs. We need special circuits for the non ZK friendly operations such as elliptic curve curves operations and hashes, and more. And so all of these form the ZKE EVM, which is way more complex at beast and which is many, many orders of magnitude slower to execute than the EVM itself. And last, we have the challenge of building the ZK rollup. That means ok, what do we actually mean when we say sequencer in the layer one? The sequencer is a module that takes transactions as input and executes them. And when we think about L2 and how L2 and layer one interact, how the roll up process works is that we have de facto a copy of the geth that people are using on the layer one that executes transactions from users sent on the L2.
00:20:43.714 - 00:21:53.382, Speaker A: But it also needs to listen to events that the bridge contract and the main layer, the settlement layer, the Ethereum mainnet layer sends, and it also needs to be able to send back states about the updates in the l two to the roll up contract on DL1. And then on top of this we have the prover component, a separate entity that receives traces of execution and proves them. And now we care about decentralization. So we want to have several provers in our network, but then we also care about the decentralization of the sequences. So we want to abstract away all of those sequence specifics and have one component that can be run by anyone. And this is actually still an ongoing field of research that Togrul on Sunday is going to talk about as well. So yeah, our roadmap to Mainnet is basically working on resolving some of these issues.
00:21:53.382 - 00:22:05.394, Speaker A: And right now I'm open if you have any questions. And other than that, I encourage you to, to check out our resources and hack on our prizes. Thank you, thank you so much for.
00:22:10.694 - 00:22:18.310, Speaker B: Unfortunately we ran out of time for questions. However, if I'm correct, you guys have actually a booth here, right?
00:22:18.342 - 00:22:22.494, Speaker A: Yeah, we have a booth. Not sure where, but somewhere in this venue.
00:22:22.574 - 00:22:27.494, Speaker B: So feel free to stop by and ask any questions, including potentially when token.
00:22:27.994 - 00:22:30.714, Speaker A: Oh, don't ask that. Thank you.
