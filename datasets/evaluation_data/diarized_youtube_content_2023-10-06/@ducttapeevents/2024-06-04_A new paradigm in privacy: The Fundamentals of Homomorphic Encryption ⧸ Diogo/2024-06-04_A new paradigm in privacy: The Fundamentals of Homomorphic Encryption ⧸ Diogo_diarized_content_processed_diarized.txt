00:00:09.800 - 00:00:32.894, Speaker A: So, good afternoon, everyone. It's a little bit cooling down with amazing rain. Now we're going to have a very interesting session, very, very hot topic. Fhe I don't know if you have been following the trend, fully homomorphic encryption. So this is going to be, this time introduced by Diogo from Lightshift Capital. So please welcome our amazing speaker with a big applause.
00:00:40.034 - 00:01:25.304, Speaker B: So, hi, everyone. We are in 2024 and there's still massive data acts happening. 23 andme was just act with like thousands of data from users DNA being exploited by hackers. And so we are like taking rockets to space. We are building completely new financial systems on chain, but we still haven't able to secure users data online. I think that for me, homomorphic encryption can be a solution for that. And my goal today is to explain a little bit on the basics of what fag actually is.
00:01:25.304 - 00:01:58.390, Speaker B: From my conversations, I've been seeing a lot of misconceptions and so I wanted to share a bit more of the basics. I'm not a cryptographer, nor do I pretend to be one. So I'm just giving you the basics. Explain what the technology is and some of the challenges that he also needs to solve to actually become feasible in the blockchain space. And of course, the potential that I think it has so very quickly about myself. I'm from Lisbon. I work at white shift capital and I also organize it.
00:01:58.390 - 00:02:49.066, Speaker B: Lisbon. As for white shift, we are an Avista GC that joins forces and invests in companies building the future of decentralized infrastructure and getting to the weeds. What actually is fag, right? So very simply, fag, or fully homomorphic encryption, is an encryption method that allows one to do general computations over data that's encrypted while getting the same results as if we were doing it on decrypted data. So we can actually do data over. Sorry. We can actually do computations over encrypted data without having to decrypted. And so, as an example, let's say we have, like, some data, like the number two, right? And we want to, like, do some computation over it.
00:02:49.066 - 00:03:33.612, Speaker B: Let's say multiply it by two. If we were to use a regular PKE scheme, we would encrypt the number two, we would get some ciphertext, and then if we try to multiply that ciphertext by two, and then if we try to decrypt that result, we would get Gberish, we wouldn't get anything useful, and we certainly wouldn't get the number four. Right. However, instead of using PKE, if we use an FG scheme to encrypt the data, we can actually take the plaintext that's encrypted. With FHG. We can use that point text to do fully hemmamomorphic multiplication. And then the result we get is the same result that we would get if the data was encrypted.
00:03:33.612 - 00:04:07.718, Speaker B: In this case, we would multiply the ciphertext and after decrypting it, we will get the number four. And so basically we could actually compute the multiplication over encrypted data. And so maybe for a more practical example, let's take Alice. Alice is a psychologist. She has like thousands of notes from her consultations with patients, and she wants to run an AI model to try to find patterns within the patients. However, she doesn't have enough compute to do this, right. And so she knows her friend Bob.
00:04:07.718 - 00:05:18.128, Speaker B: Bob has a ton of servers and she thinks maybe Bob can actually run these AI models over my data. But Alex knows that this data is very private, is very sensitive, and so she can actually share it with Bob. And what does she do? She encrypts the data and sends a ciphertext to Bob. However, when Bob gets the data, he can't run the model, right, because the data is encrypted, and so he can't see the data, but he also can't do anything with it. And so the solution for this is for Alice to actually give him the key and to allow him to decrypt the data. But this actually defeats the whole purpose of encrypting it in the, in the beginning, right? And again with FFG, we could solve this, right? Because if always would encrypt her data with an effigy scheme, she could send the ciphertext to Bob, and Bob, again, he wouldn't see the data, but he could actually run the model over that data, right? And then you would actually also not see the output. So he could run the model, he wouldn't see the data, and he wouldn't see the output, basically solving the issue before.
00:05:18.128 - 00:06:02.028, Speaker B: And this sounds pretty cool, right? This sounds amazing, right? So like, why the hell isn't this everywhere? Why aren't we using this already? And the issue is noise, right? Because every time we do a computation over the encrypted data, we add more noise to it. So every multiplication that's done, every sum, adds noise to cipher text. And after a given number of operations, the noise becomes simply too big. And you can't decrypt the data. If you try to decrypt it, you just get random numbers and strings. So the noise gets exhausted very fast. And this is why we couldn't do fully homomorphic encryption.
00:06:02.028 - 00:07:05.424, Speaker B: However, someone found a solution with bootstrapping. And basically what bootstrapping does is that after a number of operations, it resets the noise level of the ciphertext, allowing you to do more computations. And so in theory, if you keep on bootstrapping, if you keep on resetting the noise, you can do infinite amounts of operations. Again, this is the theory. And once again, if we have a solution like, why the hell aren't we using this? And the issue is that because bootstrapping is too complex, it requires a lot of compute, it adds a ton of latency to systems, and so they become simply too unusable. So a simple multiplication would take weeks to be done, and that's simply not feasible in current systems. And it actually is very costly to run because, again, of latency and the amount of compute that it actually needs to make it happen.
00:07:05.424 - 00:08:05.988, Speaker B: And so a lot of people ask, why is f 3G better than ZK? But this is actually the wrong question to ask because I think, sorry, a much more interesting one is why is FPG different than ZK? Because there are different technologies. They are both encryption methods, but they serve different purposes. Zika is amazing, right? It's amazing for scalability, to do verifiable computations and to verify things and for some private use cases. However, Zika is not ideal for privacy solutions because you are always dealing with proofs. And these proofs are like, you can do a lot of things with it, but they are not very flexible. You can't do complex computations over that data because you are only dealing with proofs. Like, it's great if you actually can use a proof, but if you can, then you have no solution but use decrypted data.
00:08:05.988 - 00:09:03.952, Speaker B: And that's how FFG can enter the space and can complement the privacy stack. And so FFG, like Zika, is just another tool on the privacy stack. And so how can we actually make fat feasible, right? What are the actual challenges that need to be solved for fog to become feasible? And there's one of them, of course, it's a very new technology. Like two years ago, nobody in the crypto space actually knew what this was, not even me. Right? And so there's a lot of things that need to be solved. But first, I think in the blockchain space, we are all used to solving hard problems, and most of these problems are actually being solved in other technologies, technologies. And one of them is like you actually need to verify the input data, right? Because each FG model has some specifications for what data it can handle.
00:09:03.952 - 00:10:01.126, Speaker B: And so you need to verify that the user is inputting the right data. Otherwise you can break the system, and you can actually try to understand the private key from that. You also need to verify computation, because even if Bob with the servers, even if he doesn't have access to the data, only the encrypted form of the data, you actually want to make sure that he's doing the computations that you want him to do, because otherwise he could be trying to exploit the data somehow. Finally, you also want to decentralize the computation, because again, even if the data is encrypted, you don't want a single party to control your data. You don't want AWS to have all your encrypted data. Even if they can't really see the plaintext data, you also don't want them to have the encrypted data. And so we need solutions for this.
00:10:01.126 - 00:10:55.526, Speaker B: And that's how I think that Heiferg should be combined with other cryptography technologies like ZK, threshold signing, and solutions like that. And then, of course, as we all know that blockchains and cryptography technology software, we need to solve computation speed and efficiency. And so there's a lot of new schemes being developed to improve the efficiency and try to make them faster. There's also a lot of companies building hardware acceleration systems to allow FPG to be run on current hardware devices by GPU's. And then, of course, there's also companies developing Isaac. So special purpose hardware just for FG solutions. A lot of people call fog the holy grail of encryption.
00:10:55.526 - 00:11:51.442, Speaker B: I think this is a very. Yeah, a very aggressive term. I think Fog has a lot of potential, but like every novel technology, it also has a lot of challenges that need to be solved, right? And so it still needs to be proven that it can actually work in current environments, and we need to solve all those issues that I mentioned, right. And then, while Refigee doesn't solve everything, he also needs to be implemented with other technologies like ZK to verify computation and to verify input data, like threshold signing, to decentralize the computation and things like that. So F 4G by itself doesn't solve everything, and fog by itself actually can't be implemented in a permissionless system. And then I think the best is yet to come. We are just in the beginning of FFG.
00:11:51.442 - 00:12:35.154, Speaker B: I think we are where ZK was a few years ago, where everybody was talking to talk about it and trying to come with new ideas on how to use it. I hope I made you guys a little bit more excited to explore the, the topic in this brief presentation. And I'm giving you an article I've written about this, which go in much more detail on how the actual mathematics of all these work. And then there's a lot of resources for people that are much smarter than me that have been written, like master and PhD teachers is about FID. So feel free to check them out and, yeah, hope, let's create a new privacy paradigm. Thank you guys for the time.
00:12:42.374 - 00:12:48.274, Speaker A: I guess we already have a question from the audience immediately raising the hand. So let's.
00:12:49.054 - 00:12:49.954, Speaker B: Oh, really?
00:12:50.614 - 00:12:53.558, Speaker A: Ah, so, okay.
00:12:53.686 - 00:12:54.874, Speaker B: I can share after.
00:12:56.774 - 00:13:00.994, Speaker A: Cool. Any other questions? I see the hands there. The microphone, please.
00:13:02.364 - 00:13:11.268, Speaker C: So I want to ask, does, does this encryption, is it quantum resistant or.
00:13:11.436 - 00:13:35.374, Speaker B: Yeah. So FRG is based on mathematics. Like, basically it's like learning with errors mathematics. And the consensus is that it's quantum resistance, but, yeah, that's like theoretical consensus, but in theory it is. So, yeah, because it's based on what is mathematics. Yeah.
00:13:36.634 - 00:13:38.694, Speaker A: Yes. I can see another hand there.
00:13:41.834 - 00:14:07.454, Speaker C: I have a question that. Do you have any ideas on how to use FNG to index an array? Elements? To index element of array, the element of a list or data structure node of our data structure without. I mean that to use FNG to hide its index?
00:14:08.514 - 00:14:09.374, Speaker B: Index.
00:14:09.954 - 00:14:26.874, Speaker C: Index of the, of the array. Which means that the ordering of the arrays, the index of the elements in the array or the all the node in the data structure. How to use FFG to.
00:14:28.294 - 00:14:31.022, Speaker B: So you mean index or indent.
00:14:31.198 - 00:14:32.614, Speaker C: Index of the data.
00:14:32.694 - 00:14:33.366, Speaker B: Okay.
00:14:33.510 - 00:14:34.870, Speaker C: Structure. Okay.
00:14:35.062 - 00:14:37.806, Speaker B: Yeah. I actually don't know. Sorry.
00:14:37.950 - 00:14:48.146, Speaker C: I mean that. How to, how to hide the index of a node in a data structure or element in array. That's the same thing.
00:14:48.310 - 00:14:50.674, Speaker B: Yeah. I don't know the answer. I don't know the answer.
00:14:50.794 - 00:14:53.962, Speaker C: Oh, you don't have an idea to do that?
00:14:54.018 - 00:14:54.658, Speaker B: Yeah, no.
00:14:54.786 - 00:15:11.666, Speaker C: Oh, sorry. So currently, FSG can only encrypt the basic operation. Arithmetic or the comparison or logical comparison.
00:15:11.730 - 00:15:27.518, Speaker B: Yeah. So like most systems. Systems right now, they are all doing only like, sum and multiplication compute. Right. Because in theory, like, you can replicate like every logic system with just sum and multiplication.
00:15:27.686 - 00:15:28.014, Speaker C: Right?
00:15:28.054 - 00:15:32.606, Speaker B: So like, most systems today are just doing that. Does that answer your question?
00:15:32.710 - 00:15:33.394, Speaker C: Yeah.
00:15:35.414 - 00:15:44.490, Speaker A: Cool. Any other questions? So if not diogo. Oh, okay.
00:15:44.562 - 00:16:17.182, Speaker D: Yes, hi. I have a question, because currently there are already distributed networks like nilian or partisia that basically mask the data, distribute it among nodes and are able to perform computation on the data without encryption decryption. The nodes don't know what they're computing. And the approach is much more efficient than the homomorphic encryption, as it seems. So are you aware of these systems or how do you compare it?
00:16:17.278 - 00:16:50.142, Speaker B: Yeah, so like NUin is based on multiparty computation, right? And so FNG is a subset of multiparty computation where basically there's only two parties, right? So like, yeah, like there are zip skyls where Nuion is much more efficient. But if you actually don't need to decentralize the compute, then in theory you could do it with fag. So, because again, Fag is a subset of operations done with MPC. I don't think I answered your question.
00:16:50.278 - 00:17:14.612, Speaker D: So what would be if you compare it in some real world examples, let's say I have private data or medical data or something in which, where it would be more effective to use fully homomorphic encryption compared to some multiparty computation network.
00:17:14.748 - 00:18:08.964, Speaker B: Yeah, exactly. So like if you actually don't need, so if you actually don't need to like decentralize the compute, right. If you have, like, again, the example I gave with like Alice and Bob, then multiplier computation is less efficient, right? Because you are decentralizing the compute without the need to actually do it, right. And maybe in the blockchain space MPC is more efficient. But like for web two use cases, for example, where you're just like doing on a specific server, then FSG becomes more efficient because you don't need to be distributing the compute across nodes, because that also adds latency, right. Because every time these nodes have to communicate with themselves, exciting latency to the system. Again, I'm not a cryptographer, so I'm just giving you what I know of the research I've been doing.
00:18:10.264 - 00:18:11.160, Speaker D: Thank you.
00:18:11.312 - 00:18:13.324, Speaker A: I see another question coming along.
00:18:15.624 - 00:18:39.766, Speaker E: Actually. Sorry, it's a comment, actually, there's a difference in security between fhe and MPC. Fhe, basically you have a certain, if the scheme is secure, then basically it's secure in MPC. If the nodes actually the participants in MPC collude, they can break the encryption. So it's a different security model. Also, it's not just the efficiency.
00:18:39.870 - 00:19:04.214, Speaker B: Yeah, and another point to that, which is like, if you actually want to like share the data encrypted, you can't do it with MPC, right? Because MPC just, this centralizes the compute and makes the compute itself private, not the data, right. So like if you encrypt your data and you want to share with different parties that are not communicating with each other, you can't do it with MPC.
00:19:05.434 - 00:19:18.944, Speaker D: There are some approaches that attempt to do this, but it's still not. It's still not in Mainnet, so.
00:19:21.444 - 00:19:21.756, Speaker B: It'S.
00:19:21.780 - 00:19:42.556, Speaker D: Still not in production. Yes, but the idea is to make it so that the data is masked and to sort of eliminate the possibility of collusion, or at least to minimize. Probably. You cannot always mitigate all risks. 100%.
00:19:42.700 - 00:19:56.880, Speaker B: Yeah. Right. Even ethereum. Right. If everybody's cooling, it breaks ethereum. Right. So, like, I understand that, but to your point, like, MPC has a lot of great use cases, but I don't necessarily think that it's the best solution for every.
00:19:56.880 - 00:19:58.964, Speaker B: For everything. Yeah.
00:19:59.744 - 00:20:00.624, Speaker D: Thank you.
00:20:00.784 - 00:20:32.184, Speaker A: Interesting discussion. Any more questions? Yes, it's like a too hot topic in the space, right? I think it's evolving technology. We're gonna have always a lot of. Of discussions on trade offs, even, like, fhe being expensive. Recently, I saw some talks that people talking about hardware acceleration gonna happen in 2026. So let's see which one gonna be winning your main net or fhe. But please give applause to Diego for providing us wonderful insights, and we will see soon.
