00:00:00.440 - 00:00:20.262, Speaker A: So, yeah, hi everyone. Glad to see you here. And today's talk is about fuzzing. First of all, it's not a talk, it's a workshop. So let's make it interactive. And if you have any questions, just raise your hand. Feel free to interrupt me, ask questions and so forth.
00:00:20.262 - 00:00:46.204, Speaker A: And my name is Andrei Babushkin. Let me introduce myself. So it's me. I think because we are tech people, it's very difficult to find a good photo. And I was stressed really to put it there because it's my only good photo there. I'm an auditor in ekiblokchain. In the company we do audit smart contracts and we do audit of solidity smart contracts on Ethereum and on Solana.
00:00:46.204 - 00:01:15.926, Speaker A: So also we develop security tools. Maybe you have already heard about wake up. Wake is our product and it's an open source tool that finds bugs in your code, that finds some vulnerabilities. And also we onboard new developers. We provide school of Solana. We also do studies in the czech technical university for students. So we educate.
00:01:15.926 - 00:01:56.470, Speaker A: Also our partners are these companies. I guess many of you heard about some of them. One inch lido, monarium XLR. And we have received several grants from Ethereum foundations, Coinbase and Solana foundation. And let's talk about fuzzing first. What is fuzzing? I think you already, some of you know, fuzzing is like putting random input data into contracts. Why? Why should we do it? Because it sometimes helps to find uncovered bugs and vulnerabilities.
00:01:56.470 - 00:02:29.220, Speaker A: Why? Because when we write unit tests, we think about very usual ways how the contract will be used. However, we may miss some edge cases. And these edge cases only can be found by either hackers, unfortunately, or fuzzers. And these edge cases are extremely, extremely important to test. However, unfortunately, fuzzing is often overlooked in development. There are not so many contracts that has fuzzing implemented. And that's a problem.
00:02:29.220 - 00:02:46.226, Speaker A: That may be a problem. And actually there are several examples, because yesterday there was a talk about decimals, about floating point arithmetics and problems with rounding errors. Kyber. Kiber? Kyber. I don't know. Kyber. Balancer, raft Weiss.
00:02:46.226 - 00:03:16.954, Speaker A: These are extremely known hacks. Companies lost millions of dollars, like tens of millions. And it can be extremely, extremely dangerous. For example, one example from the web two world. There is a Google project called Oss Fuzz. It's a project that tests several open projects with fast test. It runs fast tests and these projects found more than $10,000.
00:03:16.954 - 00:03:50.494, Speaker A: Developers are clever, developers are smart. However, they often miss some edge cases and this is a problem. So in my talk description, I wrote that we would have a highly optimized Yule contract. However, I changed my mind a bit. I want to introduce something more interesting to you. It's a real use case, from our experience, and it's lido. If you know what Slido is, I will introduce this company later.
00:03:50.494 - 00:04:09.704, Speaker A: So we'll explore the use case. What went wrong? We'll understand how the code works. What is the architecture? Fly those songs. Next, we will write some fast tests in python. If you want to follow me alone, no problem. I will show everything. I will be quite.
00:04:09.704 - 00:04:32.486, Speaker A: I'm not going to be fast, so you'll manage it. Next, we will identify a vulnerability in the code. Of course we'll fix it. I will show how fuzzing helps. And of course we will have to enjoy the rest of your day after this talk. So let's go on for now. Any questions? Not okay.
00:04:32.486 - 00:04:59.824, Speaker A: Great. So what is Lido stocks? As you may know, Lido is a very big company. Actually, its evaluation is about three billions of dollars. And it's the same as gross product of Andorra, for example, the whole country. And Lida is an extremely, extremely large company. It's a dao, actually, and it was our client. And they introduced stonks.
00:04:59.824 - 00:05:23.544, Speaker A: Stonks is a smart contract. It's like a set of contracts. And I will explain everything, don't worry. So how stunks work? Like the treasury, it's a dao. So there is a treasury. They want to sometimes exchange some staked ether, their own coin to some stablecoins and back. They want to do it automatically.
00:05:23.544 - 00:05:53.212, Speaker A: When Lido creates a new swap, they need to initialize stunks. This is the first step. When DaO proposal is accepted, it automatically initializes stonks. Next, stonks creates an order. Order is an order, a swap order for the cow protocol. It's a swap protocol, actually. And the order contract emits an event and off chain components.
00:05:53.212 - 00:06:23.972, Speaker A: Read this. Event and off chain creates a new transfer to cow protocol. When cow swaps this, it sends swap tokens back to treasury and the order calculates data calculates the price based on chain link fins. So this is how light works. Actually, it's a very simple set of contracts. It's a very small application. Of course, we'll not test everything here.
00:06:23.972 - 00:06:59.084, Speaker A: Calprotocol is very difficult to explain. Chainlink also. It's not difficult. However, there is a lot of code, so we'll simplify things a bit. First of all, we don't use lid dao, of course, we just write tests for this just creates new stocks. Next, as for Chainlink, it's just omitted and we create a very, very simple contract that just always reports the same price with some deviations. Next, we don't have calprotocol because it's, again, we don't need it.
00:06:59.084 - 00:07:18.152, Speaker A: So actually we are interested only in two smart contracts. It's stungs and order. And we will write a test for this. We will verify that the event order created is complete. It's correct. So it's going to be this simple. And actually this is it.
00:07:18.152 - 00:07:53.052, Speaker A: So this is the introduction and I want you, if you want to follow me, just scan these codes. This is the GitHub repository with everything we need and get getwake is a website for the wake tool. We will be using it. We will write tools in versus code. So we will write tests in versus code and getting to get ready, just prepare the versus code. If you don't have installed, please, and let's switch to GitHub. I will show you right away what we're going to need.
00:07:53.052 - 00:08:30.474, Speaker A: I described everything here. This, do you see everything? So the font is good. Okay, great. So the, sorry. Okay, so this is it, just, yeah, I'll give you some time to scan it. So GitHub repository, when you're ready, just tell me. So good, everyone's ready.
00:08:30.474 - 00:08:56.562, Speaker A: Great. We go, we can go on, I think so. This is our repository. It contains all the code. And for now just clone it. Everything is described over here. Actually everything that I described is over here and with a bunch of links for you to follow later, for example, if you want to, the agenda is very simple.
00:08:56.562 - 00:09:42.114, Speaker A: So we'll clone this repository. Please use recursive modules because I have a foundry toolkit. I will show the test written in foundry and I will rewrite this test in week. I will show you why it matters and just enter this directory if you want. So I will give you some time and I will switch to the versus code. So again, let's open the link here for newcomers. For example, if you want to follow, I'll give you some, yeah, you don't have to install wake for now.
00:09:42.114 - 00:10:17.548, Speaker A: Just be sure that you have versus code and be sure you have python because wake is based on Python. If you don't, just go to python.org, comma, I think, downloads or something like that, and install python please for your system, because the installation may differ from system to system, of course. So does anyone need some time, some more time? No good, great. So here it is. Here is the repository. The repository is simple.
00:10:17.548 - 00:10:58.448, Speaker A: First of all, you do not have to understand the code, really. This is the power of fast testing actually. And testing, it's like there exists test driven development, actually there exists test driven auditing because you don't have, have to understand code. You can write tests to right away when you bounce into some, for example, problem, okay, you look at the code, you try to fix it. However, you just read the documentation, describe some use cases and write tests for these use cases right away with fuzzing. I will show you. And here's the versus code.
00:10:58.448 - 00:11:18.906, Speaker A: Let's just explore the main contracts. Actually there are two of them. First of all, it's stonks. The stonks contract, as I said, just creates orders and that's it. This is a very simple contract. We just somehow, somehow we create this contract. Somehow we do some magic here, we don't need it.
00:11:18.906 - 00:11:41.954, Speaker A: And then there is a function, it's called place order. We will test this function today. So otherwise there are some estimate trade outputs again to calculate the price of the swap. Again, again, we don't need it, just skip it, no problem. And some other view functions. Again, we don't need it. And the order contract.
00:11:41.954 - 00:12:01.314, Speaker A: So the order works like this. It's a big bigger contract. However, again, we skip everything. We just see that the constructor needs some parameters. Okay, we will find them, no problem. So then we will go to initialize. This is the main function here, because when the contract is initialized, it's MSD event.
00:12:01.314 - 00:12:26.230, Speaker A: And we will test this event. So we see that there are some initializations techniques. Okay, something's going on here. So some mathematical, okay, no problem, just GPT, some structure maybe, I don't know what the structure is. And some other parameters like approve in Emmet the event. So great. And that's it, that's all what I need.
00:12:26.230 - 00:12:49.114, Speaker A: For example, if I was looking at this code for the first time, I just said, okay, I understand this structure because I understand what's going on. However, I don't have any suggest, any idea how it works. I don't need it for now. So I will start writing the test for now. Just skip the foundry part. We don't need foundry for this. I will show you the foundry test because it's our reference.
00:12:49.114 - 00:13:16.114, Speaker A: However, it's not that important to understand, it's not important to know foundry. It's not important to just write this test. It's already pre done for you. However, I will explain how it works. So this is the contracts. The first foundry thing is that we write tests in solidity. So we write new smart contracts to test our existing smart contracts.
00:13:16.114 - 00:13:28.454, Speaker A: Maybe that's a good thing. However. Yeah, I will show you why this matters. So we just define several initialization. Just again, skip it. I just wrote this code. No problem.
00:13:28.454 - 00:13:56.584, Speaker A: We have a setup function. What setup does? It's before every run. I will explain to you before every run. Foundry calls this setup function, what this setup function does. You can deploy contracts, for example, you can set up these contracts, just prepare the environment. What are runs? When you try to fast test, you create a lot of input data. Like a lot.
00:13:56.584 - 00:14:30.838, Speaker A: For example, you generate, I don't know, several thousands of input data vectors, I would say. I'm from AI, sorry, I don't know, it's math. So you just create several vectors of data and you test every use case again and again and again and again with random data. And you verify that the data that is outputted from the contract is what we expect to see. And so in this setup function, we just create an agent. This parameter is just a random address. A manager is a random address, no problem.
00:14:30.838 - 00:15:21.894, Speaker A: So we need something to randomize. So here we randomize using, as you may know, there is a problem with random data and solidity. However, there are things that we can use, and one of them is block prevandao. It's like, I don't want to explain it, and just a timestamp, it's like a source of our randomness. So we just define the order duration, how order is, how much time can this order is valid? And we define the margin. Margin in stocks is like, how much much fee do we pay for these operations of swapping? And price tolerance is like to prevent spikes in prices. So we don't sell for very unfortunate values.
00:15:21.894 - 00:15:46.068, Speaker A: So yeah, we create the amount converter. Amount converter is a very abstract class. It's very simple. It actually replaces the chain link. It's a contract that is extremely, extremely simple. These contracts just set the conversion rate. It just returns the conversion rate and calculates the price when you put one token to another.
00:15:46.068 - 00:16:01.084, Speaker A: It's very simple. I just do everything manually here. I don't need any real data here for testing. So. Yes, and that's it. I think we can go back to foundry. So it's in tests.
00:16:01.084 - 00:16:23.624, Speaker A: Foundry. So we initialize, we create stonks. Stonks is created for every trading pair. For every pair. So USDC for USDT, staked ether for USDT, several stonks contracts. So for every pair here for sell tokens, buy tokens. These are variables defined here is just addresses of smart contracts existing on chain.
00:16:23.624 - 00:16:51.496, Speaker A: We create a stunks contract, and that's it. This is a setup function, actually, everything goes on here. We just create some contracts, we prepare the environment with some random data already. So next, there is a mint function. Because we don't have our treasury, we have to mint, we have to mint some tokens to use them. And this function does a very simple thing. It changes the storage for the contracts.
00:16:51.496 - 00:17:21.450, Speaker A: Because we fork the chain, we can change the storage right away and to use the change values. So this function just does this thing. It just reads the storage and changes the values of the storage without calling the mint function, actually, of course, you cannot do that on chain. Of course you cannot. For testing purposes. Yes, we can. And so this is a min function, some mathematics, in fact, it's a copy paste from the contracts, from the stonks, or order, as you remember, actually.
00:17:21.450 - 00:17:55.290, Speaker A: And yeah, here is the function test, place order. So, foundry needs test. These tests are functions that have tests in the name of the function. And so here we does it. So we calculate some input parameters when we specify input parameters for the test. Foundry uses this as a fast test because these parameters are random. When foundry runs the test, it just specifies random parameters to these arguments.
00:17:55.290 - 00:18:27.004, Speaker A: So however, we need to bound these parameters. Of course, we cannot use them right away because, for example, if we need an index in a field, in an array, we need only indices in this array. So we bound these parameters, impute data. And yes, we specify the sell token, the buy token to stonks. We need to obtain the correct stonks contract. So we make some assumptions. So the sell token is not equal to buy token.
00:18:27.004 - 00:18:56.054, Speaker A: If they are equal, foundry just skips this data because it will not work. And then we define some mathematical stuff. Again, you don't have to understand this. And, okay, mint tokens, we compute the buy amount, the minimum buy amount. It's for the minimum price, for the price. So it's, again, it's a protection against spikes in prices. And so here it is.
00:18:56.054 - 00:19:18.386, Speaker A: Yeah, we just specify test use cases. For example, if the sell amount is less than ten, the contract should revert. Why? Because these are dust trades. It's maybe insecure for stunks. It's just the logic of stonks contract. Just take it as it is. So next, if the amount without margin, again, margin is the fee.
00:19:18.386 - 00:19:49.708, Speaker A: If the amount without margin is equals to zero, so again, it should revert. Next, we obtain logs from the foundry. We obtain logs, we check everything. So VM logs foundry is very strict again, why? Because it's statically typing typed language. Because we write in solidity. You have to specify all the input data. You have to specify all types of every variable.
00:19:49.708 - 00:20:43.854, Speaker A: You have to specify this long, long string to compute the correct signature of the event, because you need to find these events in the locks. And when you find the correct lock, you just check that everything is right. And here are these checks. So first of all, you expect the amount that we want to sell and the amount that we want to buy our computers correctly, first of all. Next, we try to recover tokens from the contract when the duration of the order is still valid. That means that the order is not still yet executed. If we try to take these values from the, take the tokens from the order, it should revert because the order is still valid and it should revert here.
00:20:43.854 - 00:21:23.960, Speaker A: Next, we set the timestamp to order duration plus one. That means that this order is not valid anymore and it should not revert. In this case, we can extract tokens from the contract. And so yeah, VM startpronk, it's a very weird name in my opinion. However, we change the caller address. So when next time we call contract, it will be called with message sender equals to random actor here, just some random value. And yeah, we call order, recover token from, it should not revert here because the order is invalid.
00:21:23.960 - 00:22:03.376, Speaker A: And that's it. So again, what happened here, I know that's much really, you do not understand the code. However, you don't have to. What? We checked that we just took the initialized tungsten contract with some values with, for example, with some random duration of the order we created the order. We checked that this order has some correct data in it and these, that the functions inside the order are valid. I mean these functions represent the correct state of the contract, for example, because of the duration, of course we can check many more things. However, I think it's enough.
00:22:03.376 - 00:22:34.224, Speaker A: I think it's enough. So this is the foundry test. It's long. It took me some time to write it, really, because it's foundry. I will show you how easy it is to write in Python and I will explain it later. And for now just please, if you have the clone repository, if you have the versus code open, and if you have opened the project, so please install the extension. The extension is called tools for solidity.
00:22:34.224 - 00:23:00.064, Speaker A: Tools for solidity is the extension from Eki blockchain here. This tool installs wake up this framework we will need it because we need to test with this framework, the code. So we'll install the tools for solidity. It automatically installs wake. Wake is based on Python, so be sure that you have Python ready. And that's it. Let's just do that.
00:23:00.064 - 00:24:02.230, Speaker A: So I'll wait for you before. So if you install these tools, if you have everything, right. So for those who follow, just please do that and I will wait if you still follow. Of course, the tested contract is the. No, no, it doesn't inherit. We just take the contract, that's just the system of light of songs, and we just create another contract that implements this logic of instantiation, of initialization. And we create some new insight in these variables inside these tested contracts, we create some variables for songs, and against these instances of these stunks contracts, we verify if everything was correct.
00:24:02.230 - 00:24:40.164, Speaker A: So there is actually no inheritance between these contracts. So we don't have to do that for foundry. And for example, like, for example, when I showed the mint function, it's like mocking, like mocking. For example, I got rid of chain link, I mocked, I just created another contract. It's like mock also. So it depends on the use case, what to mock and whatnot. Because for example, for stocks and for the order, I didn't mock anything because I don't need to.
00:24:40.164 - 00:25:28.718, Speaker A: Yes, these contracts, yeah, these contracts are tested in the local chain. So it uses wake, uses anvil. As for foundry, I'm not sure, maybe anvil too, I guess handle two. So yeah, these are local test chain contract. There is no such a tool. And in order to look at a particular slot, I need to write some. Yes, you can do that.
00:25:28.718 - 00:25:49.994, Speaker A: However, you can just modify the storage right away. Because it's a local chain, you can do anything you want. Of course you can change some logic. However, you don't have to, at least in this case. For a more complex logic, maybe you will have to. So, other questions? No. Okay, so I guess everyone has tools for solidity installed.
00:25:49.994 - 00:26:32.992, Speaker A: So let's start coding. And what I'm going to do here, I will open the foundry test. I will put it here and I will open the test fast. It's for Python and I will split the screen here. So why do we use Python? Let's be honest, solidity is made for smart contracts. It's a great language, but it's made for smart contracts, it's not made for testing. And the first issue that you may experience is that solidity has the limitation on the stack size.
00:26:32.992 - 00:27:06.448, Speaker A: You cannot have more than 16 local variables. It's not very fortunate. When you create a large test, you cannot do that, and this is a problem. Next, as for solidity, you will have to. Sometimes you want to test the arithmetics. Solidity does not have floating point values, and every dev will do one thing. Devs just copy and paste the code with arithmetic from the source contract to the test contract.
00:27:06.448 - 00:27:41.300, Speaker A: It does not test anything. It's called differential testing. When you provide at least two different implementations and you compare the outputs. When you use Python, it's very straightforward, you just rewrite the logic, but with using floating point numbers, it's much more precise. And next, when you want to iterate over arrays, when you want to use some algorithms, for example, just like for iterating over arrays, good luck. Solidity does not have it. You just need a lot of boilerplate code.
00:27:41.300 - 00:28:12.720, Speaker A: For solidity, you cannot use algorithms. Python is a very, very general purpose language. It just takes, it took a lot of time of other developers to develop tools that we can use with one line of code. Solidity, again, it's very difficult. So actually Python is just more general purpose language. And solidity is specific to smart contracts. And our time of developers is expensive, extremely expensive.
00:28:12.720 - 00:28:36.344, Speaker A: Python is more easier to learn. So let's have a look how the Python test works. So it's over here we have the min function. It's actually the same. Absolutely the same. We have some defined contracts, as you can see. We just take the addresses of these contracts and use them right away.
00:28:36.344 - 00:29:01.440, Speaker A: Wake, the framework, pulls the code from Etherscan and uses it. So it's like real actual contracts of staked ether DAi, USDT, USDC. So we just need this address for the songs contract. It's for cow. Again, we don't need it. So as for the min function, it's absolutely the same. As I explained this tungstest.
00:29:01.440 - 00:29:41.404, Speaker A: Again, wake runs sequences and has flows. What is sequence? Sequence is just one pass of a fast test. The flow is just one call of a function. In these fast tests, when wake sees several functions that wake can up call, these functions are called in a random manner with different random data, and you can specify how many flows you want. For example, you will have in one sequence, you will have several hundreds of flows, and you can have, for example, several hundreds of sequences, just runs of these tests. And pre sequence is like a setup function is foundry. It's actually the same.
00:29:41.404 - 00:30:15.176, Speaker A: And again, here we create an agent. It's just a random account, just new account. So default chain accounts is for the testing chain, we take the accounts, the first account, it's the main deployer and we'll say that this account is a manager. And here's the thing, random int, it's like true random int, it's like random. So in python it's very simple. You just specify from which integer you want the random number, to which integer you want the random number. It's very simple.
00:30:15.176 - 00:30:42.438, Speaker A: So we specify some random values here and other parameters. We set the amount converter. As I said, it's a very simple contract that just specifies all the time specifies the same price for every pair market is a contract that just is connected to amount converted. It's not important here. So yeah, here we deploy a sample order. We need this in the stunts constructor. And again, it's very simple.
00:30:42.438 - 00:31:16.124, Speaker A: Here it's the same, here it's nothing changed. Yes. Here we have a normal iteration over inline array. We'd like doing this in solidity. So yeah, we specify if Celtoken is equals to by token. We just skip the test, we don't need it, and we create a stungs contract. Again, we have a nice dictionary here, it's like a mapping mapping, but we can iterate over a dictionary, which is a nice thing because we use python, it's a general purpose language, and we deploy a contract, it's absolutely the same like in foundry.
00:31:16.124 - 00:31:43.320, Speaker A: So here is these functions that compute the price based on decimals, based on the price. And these contracts, these implementation is rewritten using Python. So we can use differential testing here. It's much more secure, I would say, from the testing point of view. So we rewrite these functions using python. It's actually the same. And here we place the order.
00:31:43.320 - 00:32:21.446, Speaker A: So again we choose a random token here, staked ether for sell tokens, for buy tokens. And again we can use these nice python features like a set that we can skip the parts with ifs. It's very quick here. And as for cell decimals, again we compute the price. So we take the random integer here, and here we call these functions, we compute the price that we should expect. Here we min some tokens. Again, we compute the cell amount again, you don't have to follow it really.
00:32:21.446 - 00:32:45.474, Speaker A: I just explained how it works. It doesn't matter if you don't remember it in 1 minute, no problem. And so we compute the by amount. So, random integer, okay, so yeah, and here is the code. We will rewrite this online, like from foundry to solidity. Oh, from foundry to python. I'm sorry, my bad.
00:32:45.474 - 00:33:32.794, Speaker A: So I have it prepared here so I don't make things up okay, so let's have a look. First of all, we want to test for dust trace, how it works. So, wake has a very nice feature. We can say that with must revert, we do stunks. So this is our contract, minimum possible balance not met. And this is a nice feature actually, because in foundry, you cannot write this at all. In foundry, when you write these expect reorders, you can specify the selector of the correct error.
00:33:32.794 - 00:34:51.434, Speaker A: However, if this error contains some parameters, you have to compute the catch up of this error with, with these parameters. Good luck doing this if the logic is very complex in terms of math, because, for example, if one of parameters has some weird number in it, you have to compute it. So actually, you specify in foundry, you specify that it should revert, but you cannot specify with which error it should revert. In wake, we can do that. So with must revert, we saw that we call the function self stonks, and of course it's cell token, it's by token, and we call the function named sorry, call the function place order, and this function with min by amount, and that's it. So if we compare again, it's almost the same, almost. However, there is a problem with solidity.
00:34:51.434 - 00:35:26.734, Speaker A: You should specify a very precise catch up. So we return, we tested this use case, I believe it's in other. So let's delete this data. If the expenses by amount is zero, so we compute this. And how do we do that? Self compute by amount without margin. Again, cell amount. Sell amount price.
00:35:26.734 - 00:36:08.558, Speaker A: These parameters sell decimals. Price decimals by decimals, equals to zero. If this value is equals to zero. So we do again with must revert. Again, we can specify a very precise error here. Amount converter invalid, expected out amount. And again we call selfsongs with these values.
00:36:08.558 - 00:36:39.410, Speaker A: So it's very simple, and otherwise everything is good. So we tested two use cases here. Otherwise it's good. We can go on. So, first of all, we want to call the function the correct function. We say transaction, so it's transaction data returned by wake. So we say self against tongs, sorry, selfstonks, and sell token again.
00:36:39.410 - 00:37:17.460, Speaker A: Sell token by token. Again, we call the function, it's a correct function, and place order with mean by amount. So this is the call, it should work, it should not revert. That's why we don't use must revert, and we validate the events. So let's have a look what we have here. So it's actually the same as you can see here. So in foundry, we had to specify log arrays and order hash, again with types and so forth.
00:37:17.460 - 00:38:04.316, Speaker A: We don't have to do that here and we just do events. And again, we use python. Very nice python feature. So next, e for e event for event in transaction events, in all events that is returned by the transaction. If we use instance, is instance e order or order created. Just have a look how simple that is that we iterate over all events here. That is the instance of order, order created.
00:38:04.316 - 00:38:51.204, Speaker A: And that's it. To craft this string, it took me like a couple of minutes to obtain all the parameters that I needed, so it just took some time. Here we just need the declaration. And here we specify order, order e order. So we took the order from the events. Again, it's very simple here, we don't need to use this one. It's very weird, you know, so, okay, and we compute order hash, and specific to stones, e order hash, we just extract it from the events.
00:38:51.204 - 00:39:08.292, Speaker A: That's it. We just extract several values from the events right away. And we use the type order here. It's very, very simple. Here it is very straightforward. What you need to do. Next, we compute several amounts.
00:39:08.292 - 00:39:46.344, Speaker A: Cell amount is equal to e order data. Cell amount. Again, we extract these from the events, and by amount equals to maximum. Again, we use differential testing here. Self compute by without by amount. That's correct. And so we use sellamount price, sell decimals.
00:39:46.344 - 00:40:20.528, Speaker A: Price decimals by decimals. Again, it's very straightforward here. Yes. And we check in Python. It's very, very, it's very simple. We just called it assert, assert that by amount is correct, and e order data by amount. You know, I just realized why I don't have code completion, because I didn't run the wake init command.
00:40:20.528 - 00:40:58.440, Speaker A: So because we use Python, and because we need to generate some classes from solidity to python, we use wake init pyth. And what is by types? It's types. It's python types for solidity contracts. And we can use these like classes. We use them straightforward. So we call, if we open the terminal and we call wake init py types. So it compiles the contracts and it generates py types.
00:40:58.440 - 00:41:33.470, Speaker A: What is py types? Let's have a look. Py types is a very special for wake up. It has the same structure, and as you can see, we have the same contracts here. So for example, if I open the order, it has every, every single function from the order contract. So I can use it with Python, for example, these events. And if I scroll down, for example, I have this function is valid signature initialize, so get order details and so forth. So py types allow me to use solidity classes in Python like in a straightforward manner.
00:41:33.470 - 00:42:11.570, Speaker A: And so now I guess it should work because it's going to be much more quicker. So validate the signature. So again, assert sorry, assert we validate. The order is valid signature order hash. It just bytes from hex. And this is a magic number. Actually it's very simple here.
00:42:11.570 - 00:43:09.124, Speaker A: It just, I can take it right from the contract if I open the order. It's over here. It's from the implementation, this byte string, it should be this. So the order is created and not expired. So we should revert with must revert order again, we can use the expired the error with order expired order recover recover from token recovering token from sorry, recover token from so must revert. Great. So we now just have to do one last step is just to set the block timestamp to a new value and check if everything is correct.
00:43:09.124 - 00:44:00.174, Speaker A: So we mine a new block default chain, mine lambda. It's an inline anonymous function here, lambda I will explain in a second what this does. Block timestamp timestamp plus self order duration plus one. What does it mean? So we mine a new block and this lambda function is just a callback. This callback sets a new, it's an optional callback, actually. However, it just sets a timestamp for the next block, and the next block timestamp is like transaction block timestamp. The current timestamp that we already have, plus order duration plus one.
00:44:00.174 - 00:45:08.454, Speaker A: So it's actually the same as here, it's the same line, so and we check that everything works. I will just copy paste this with must revert order order not order expired already. Okay, order is valid. Signature order hash again, bytes. So I'll check this the same and order recover token from from again, give me a second run account. So again, this is the wake part. We just specify in every call, we can specify from which account we want to call this function.
00:45:08.454 - 00:45:29.846, Speaker A: We don't use vmpranks and we don't prank anyone here. So we just specify from which account we call this function. We call this recover token from from the random account. Straightforward again. So that's it, that's much of it. I understand. However, let's just do one thing.
00:45:29.846 - 00:46:11.262, Speaker A: So first of all, let's try to run the foundry test. So we fork the main net using the public node, and if you still follow, you can use this public node URL. So ethereum rpc publicnotes.com and we will use it in wake and we run the test, it should fail. It should fail. It takes some time to compile, so init pytefs was extremely quick in comparison with this. So compiler unsuccessful.
00:46:11.262 - 00:46:36.256, Speaker A: Okay, so the test reverted. It was not successful. We'll have a look. Why. However, if we have a look, we have a stack trace here and we see all these function calls. And in wake we just write wake test, test fast py. Or we can just skip this part.
00:46:36.256 - 00:47:10.918, Speaker A: Wake test, because in our test we have already written the public note. Again, we don't specify this on command line interface. It may be problematic because it's not reproducible. We just specified here that we, for the default chain, we use these fork URL and we run one sequence of 100 flows again. So the order create function will be called 100 times and one for one sequence. And if it's reverts, we just print the host. Coltrace it's very simple actually.
00:47:10.918 - 00:47:33.634, Speaker A: Again, everything is written in code. You just have to run wake test and that's it. Now it should fail if I wrote everything correctly. So no events. Let's have a look. Events. So it's here.
00:47:33.634 - 00:48:14.234, Speaker A: Int object is not a turbulent oh, you see if as instance, it's over here. Bimount max compute biomount. Oh yeah, I see, I forgot to use which wiz with which maximum. So it's over here. Validate the signature. Validate the signature. Where this is I'm dumb.
00:48:14.234 - 00:48:34.862, Speaker A: Update values. Yeah, I see. Mean by amount. Mean by amount. So live coding is not simple, you know, I'm sorry for this. So yeah, wake also reverts it's correct. And we see the stack trace, the whole stack trace.
00:48:34.862 - 00:49:17.794, Speaker A: It's very easy to follow because for every contract, Wake tells you which function was successful and which reverts. With this checkmark, we see that stung's estimate trade output was successful. That's great. Get expected amount was called somewhere in the contract, but then something happened. Let's have a look what happened. As for the order, I have it here. After we compute, estimate trait output and generate data here we see that devs wrote the just normal approve function for ERC 20.
00:49:17.794 - 00:49:59.850, Speaker A: It works. Generally it works. However, there are some tokens like USDT. Unfortunately, they were introduced in very early stages of ethereum, and they behave in a very weird way sometimes. And sometimes you cannot set a new allowance for the address without nullifying it before. For example, if you have a set allowance for one token for one address, you have to set it before to zero, and then to set to a new value, it's like prevents fronts running. However, it's a very weird case.
00:49:59.850 - 00:50:33.914, Speaker A: And these tokens just revert in this case. So here is the bug, actually, wake helps to find it. And if we rewrite it to force, force a proof is a very simple function from safe ERC 20. This function does that. It forces the approval through the nullifying it before and through the force approve. We can fix this error. Actually, this was an error, a mistake in Stone's code.
00:50:33.914 - 00:51:23.806, Speaker A: And if we regenerate py types again, because we need to compile this, we init py types, we recompile the project and we run the test. So wake test. Yeah, it takes some time, of course, because we are running a fast test again, we generate 100 inputs for this. And yeah, it's running, it should finish, I think. I guess, sometimes, I guess again. So what I wanted to show here, I know this is pretty much for the code, and if you are interested, because lido is a very big protocol, I would say if you are interested, take a look at the readme, take a look at the code. It's very simple, you will learn from this.
00:51:23.806 - 00:51:45.410, Speaker A: And yes, sequence passed. As we can see, wake finished successfully. So the error is fixed. And what I wanted to show to you, why I used foundry before. Foundry is a very, very cool testing framework. Really, it works great. However, the main problem here, so I think we have stopped the test right now.
00:51:45.410 - 00:52:36.890, Speaker A: However, the main problem with foundry, the tests in foundry are written in solidity, and I have already enumerated many problems of solidity in general. It's not, for example, why should we care about gas in tests? Why should we care about local variables? Python is a very straightforward language. It's just a main advantage of wake, and it's very simple, it's very straightforward, it works faster. Actually, if you visit the talk today, it is faster than foundry and it's highly extendable. For example, I can show some features of wake in the code. If we set it back, approve and delete this magic line, that's just disable the test, because I wanted to show it to you. Wake underlines.
00:52:36.890 - 00:53:27.356, Speaker A: Because of tools for solidity, wake underlines, underscores this code and says that, first of all, it's possible reentrancy here. Be careful, because you m at the event after call in the external function, and next you see that Wake suggests that it's an unsafe variant of ERC 20 call. So wake detects this vulnerability right away in the code. When you write the code and tools for solidity displays it in your ide. It's very, very, very convenient. And here we have an output of different vulnerabilities, potential vulnerabilities. And as we saw right away, this unsafe function call, unsafe variant of ERc 20 call is a real vulnerability that is detected by Wake, if only lie.
00:53:27.356 - 00:54:03.824, Speaker A: The developers used wake before, now they use it, I guess. So let's get to the question part. I know you may have a lot of questions. I know that these codes are very difficult to understand right away, in 1 hour. I tried my best, but my main goal was to compare, to give it to you the information about using different testing frameworks. So if you have any questions, I'm happy to help. I'm happy to answer what the steps we do, if I understand it correctly.
00:54:03.824 - 00:54:54.084, Speaker A: Firstly, we take some points and after that we try to sell it. We take tokens from the treasury or from our mins function. We swap them. No, we don't swap, we just calculate through the chain link feed, we calculate the price of the swap, we calculate the amount that we want to buy, and we create an order. Okay, we created an order. And after that order is completed, no, after that. For lido songs, for the actual implementation, an off chain component reads these events and creates an order for the cow protocol where the swap actually happens.
00:54:54.084 - 00:55:25.506, Speaker A: We didn't swap here, we just calculated prices here, we just throw it away. Yes, yes. And we calculate the prices. Yes, yes, exactly. We calculate the prices because we don't care actually about real swapping, because we will swap for these prices that we calculated here. We will swap for these amount of tokens that we calculated here. The swap is actually just one more step.
00:55:25.506 - 00:55:59.976, Speaker A: It just swaps for these amounts and just sends tokens back to this treasury. Okay, in this case, we emulate creation of order. Yes, yes, exactly. That's it. We just created because we had to calculate it correctly. Yes, exactly. This is the problem and why I say that these bugs are really, really difficult to find because it's a very straightforward line.
00:55:59.976 - 00:56:55.284, Speaker A: You just approve the token. It's a correct line, actually. However, when we audit, for example, the codes, you know, with auditors, not every auditor may just know or developer may know that the USDT token is very weird. So we just, with random data, with random pairs of tokens, we just specify the buy tokens, sell tokens, and we find that with random pairs for where USD figures. So we find that this is a problem. And for example, if we had a problem with math and solidity, because the test in foundry is just a copy paste of the same math. We wouldn't find this problem if we had a problem with math and we used the implementation in Python, we will find that these values are not the same.
00:56:55.284 - 00:57:37.144, Speaker A: Something is wrong. This is the power of differential testing. So, questions? More questions? Yes, of course, yes. No, Hardhat is just another language. It's just in typescript and JavaScript. So you will have to rewrite it to another language. Yes, we can insert a local node, run hackath in order to deploy all set of controls.
00:57:37.144 - 00:58:15.408, Speaker A: Yes, I guess it's possible, because you can reuse the already deployed local. Net local chain and the deploy contracts over there. You can use it. However, you know, from my, just my personal opinion, not from ek blockchain, you know, I just tried to use Hardhat, I tried to learn it, I tried to use it. So much boilerplate code, really, you have to write so much code to test a very, very simple function. And personally only in my opinion, I just don't use, I don't like hard hat. And for me, foundry is a good choice.
00:58:15.408 - 00:58:43.740, Speaker A: However, it has limitations. Wake is the best choice, in my opinion, not because I'm shilling it, not because I'm selling it, really. I try these frameworks because I'm an auditor, I'm not a developer. I have to test every framework to be effective, to be productive. For example, what if wake doesn't do anything? It doesn't do something. I tested these frameworks. Does it somehow compile into foundry or.
00:58:43.740 - 00:59:11.804, Speaker A: That's completely different. It's a different thing. Pytab actually is. So wake compiles contracts, it deploys on the local. Net, and also it creates for you to use these contracts in Python, it creates py types, so it's like classes representing these contracts. And when you call a function in python, so these py types just wraps this function, call and send to the local. Net.
00:59:11.804 - 00:59:46.870, Speaker A: So any more questions? I will publish it, no problem. I will publish it right away because I didn't want to spoil or to create spoilers. I will publish it, of course. Actually, the whole code for whole songs is there. It's a link for. It's open source too. Like for the whole protocol.
00:59:46.870 - 01:00:01.560, Speaker A: We've written the fastest. However, yeah, the simplified version is here too. So if you don't have any questions. No more questions. Yes, so please follow us. So I'm trying to start my twitter, you know. Please follow me.
01:00:01.560 - 01:00:30.050, Speaker A: I will be very grateful. I try to post something interesting from my experience, from auditing, from some contracts. So it will be helpful. I don't shit post, I promise I hate social networks, but we need it in today's realities, you know? And this is the Twitter of eke blockchain. Also, follow us. You'll find many, many interesting things over here. So if you don't have any more questions, we're running off time, so.
01:00:30.050 - 01:00:33.674, Speaker A: Yeah. Thank you. Thank you. And see you at the bar if you have questions. So, yeah.
