00:00:07.360 - 00:00:11.126, Speaker A: Awesome. Thank you. Just make sure this works.
00:00:11.310 - 00:00:11.870, Speaker B: Great.
00:00:11.982 - 00:00:54.934, Speaker A: Perfect. Okay, so today I'm going to be talking about decentralized infrastructure in a multi chain world. I know this is an ethereum conference, but I'm kind of here to convince you that the future is multi chain. So let's start. Let's kind of take a step back in time. 1994, Nick Szabo publishes a paper where he defines what this idea of a smart contract is. And what he basically says is that smart contracts are computerized transaction protocols that execute the terms of a contract.
00:00:55.354 - 00:00:56.094, Speaker B: Right.
00:00:57.194 - 00:01:38.994, Speaker A: Just completely, completely visionary. In that same paper, he also creates this idea of a token, which. It's a little more abstract in the way that he describes it, but I think you'll find it sounds very familiar. And he says that these new securities are formed by combining securities and derivatives in a wide variety of ways. Very complex term structures for payments can now be built into standardized contracts and traded with low transaction costs. So this was 1994. I mean, before some of you were even born, by the looks of the audience here.
00:01:38.994 - 00:02:54.688, Speaker A: So what can we say then? Well, in 2013, then when Nick Zavo says something, we should probably listen. And so here in 2013, you have Nick Zabo basically saying that there's going to be this polycentric blockchain ecosystem, that the future is going to be multi chain, that we're going to have a diverse array of functionality, security characteristics that would be difficult to achieve all on one single almighty mono chain, and that a polycentric system is more resilient to pressure. And then it's also more innovative because competitive pressures will cause these chains to evolve, evolve and evolve. Okay, so Nick Zaba was right. In the decade that followed, we have this hugely diverse array of blockchains. Don't kill me if you don't see one of your favorite chains, they're not in any particular order. I just needed to get the logos on the page and kind of have them line up.
00:02:54.688 - 00:03:13.044, Speaker A: So we're not maxis of anything here. But now what are we living in this kind of like, multichain utopia? Like, have we solved all of the problems? Well, not quite.
00:03:13.164 - 00:03:13.824, Speaker B: Right.
00:03:14.364 - 00:03:17.504, Speaker A: We kind of have new challenges that we need to address.
00:03:17.804 - 00:03:18.544, Speaker B: Right.
00:03:19.924 - 00:04:02.964, Speaker A: So with a show of hands here, who has used more than one blockchain? Amazing. So let me. Let me pick on someone. You sure? Which. Yeah, you. Looking back, which chains have you used? Okay, so which one was first? Bitcoin. Okay, so when you switch from bitcoin to, I'm guessing maybe Ethereum was the second one.
00:04:02.964 - 00:04:10.880, Speaker A: Were there any, like, challenges that you encountered, anything new that you needed to learn?
00:04:10.952 - 00:04:11.160, Speaker B: Was.
00:04:11.192 - 00:04:32.824, Speaker A: Was it difficult to use it the first time? Exactly. Do we have any developers in the room?
00:04:34.924 - 00:04:36.260, Speaker B: Ah, okay, great.
00:04:36.412 - 00:04:59.312, Speaker A: So any developers that have worked on, like, multiple blockchains. Okay, you, sir, which change did you start with? Ethereum. And then what came after polkadot substrate. Okay, you dropped it. Okay. No, that's interesting. You dropped it very fast.
00:04:59.312 - 00:05:10.000, Speaker A: Why? Why? Like, what was different about what you could do on Ethereum? And then, like, how was the developer experience different?
00:05:10.152 - 00:05:45.504, Speaker C: Well, the entry level was way more bigger. So because you have to learn rust, which is very different from solidity and substrate as a framework. I think that was 2019. So it was like very early ages of Polkadot and substrate, and it was not ready yet for building production. Ready stuff. I just realized that is way higher, and I would get more money by just.
00:05:46.184 - 00:05:50.272, Speaker A: Yep, 100%. Amazing.
00:05:50.408 - 00:05:50.704, Speaker B: Right.
00:05:50.744 - 00:06:01.368, Speaker A: So I hope you're starting to notice some common themes here, right. That there are certain characteristics of different chains.
00:06:01.496 - 00:06:01.904, Speaker B: Right.
00:06:01.984 - 00:06:07.444, Speaker A: That present challenges both to users and to developers.
00:06:07.784 - 00:06:08.312, Speaker B: Right.
00:06:08.408 - 00:07:16.324, Speaker A: And so, you know, there's certain chains have taken certain strategic approaches. We sometimes classify chains as being like EvM or non EvM. And as a developer, if you have worked on an EVM chain, it's incredibly appealing to be able to jump to a new chain and not have to redevelop your smart contracts to be able to recycle a lot of the developer tooling. So maybe on a newer chain that's not EVM, you don't have some of the advanced stack traces and stuff. It's great to be able to use simulation tools, like tenderly or auditing tools. So there's incredible synergies when we have this standardization of, of infrastructure between these chains. In the few instances where we have this synergy, this kind of standardization of infrastructure, it's proven really useful.
00:07:16.324 - 00:08:07.498, Speaker A: As a user, if a chain doesn't use metamask, I can tell you most people just will not use that chain. It's just too different from what they know. The ability to recycle your keys and not need to have different keys for different chains, this is all very, very useful, and we need to do more of this kind of stuff. So in light of that, these are kind of like the three takeaways of what I think we need to aim for in decentralized infrastructure. We need to be compatible, we need to be interoperable, and we need to be verifiable. So let's kind of walk through each of these. So we want infrastructure that's going to be compatible across all chains.
00:08:07.666 - 00:08:07.970, Speaker B: Right.
00:08:08.002 - 00:08:30.154, Speaker A: We don't want to have to reinvent the wheel. It's a waste of time and resources and it throttles the most important thing, which is that we just want to get on with our lives and make the Dapps and innovate. Two, interoperability, right, blockchains need to be able to talk to each other. They need to be able to talk to the outside world.
00:08:30.234 - 00:08:30.594, Speaker B: Right.
00:08:30.674 - 00:08:39.026, Speaker A: That's the only way that you're going to take this, like fragmented islands of, like, pockets of functionality and utility and liquidity.
00:08:39.130 - 00:08:39.490, Speaker B: Right.
00:08:39.562 - 00:08:40.666, Speaker A: And merge them together.
00:08:40.770 - 00:08:41.010, Speaker B: Right.
00:08:41.042 - 00:08:43.506, Speaker A: As this interoperable kind of property.
00:08:43.570 - 00:08:43.770, Speaker B: Right.
00:08:43.802 - 00:08:49.466, Speaker A: That's really useful. And third. Right, we need the infrastructure to kind of have provable integrity.
00:08:49.570 - 00:08:50.214, Speaker B: Right.
00:08:50.754 - 00:09:18.914, Speaker A: We need. And we need the transparency for everyone to be able to verify this integrity. Not just some fancy computer or developer. You as a user should be able to have understand these integrity guarantees. So breaking down compatibility a little bit.
00:09:18.994 - 00:09:19.614, Speaker B: Right.
00:09:20.834 - 00:09:48.214, Speaker A: There's reasons why we talked about the EVM. There's reasons why many chains adopt the EVM. It's not that the EVM is the greatest virtual machine in the world. It's really not, actually, if I'm being honest, it's quite poor. But it's really useful for bootstrapping your chain. You get all the developer tooling. Users don't need to generate new keys.
00:09:48.214 - 00:10:19.652, Speaker A: You get things like Metamask, so the interfaces for users to use applications. You get all of this stuff for free. You can quickly bootstrap your ecosystem. Developers can just port their existing contracts onto your chain. There's a lower barrier to entry. You talked about this lower barrier to entry to being a developer and moving to a new EVM chain. It's easier for the developers of that chain to find talent because there's already a skilled workforce.
00:10:19.652 - 00:10:59.996, Speaker A: So these are very natural, organic forces that push us in this direction. And they're good, they're not bad. Going into interoperability a little bit more. What makes DeFi so powerful is its composability. Has anyone here used one inch before? Do you remember the first time you used one inch? That wow factor of like, I don't have to go check for the best price anywhere, I just use this application and it just. Magic happens. That feeling, that magic happens, that's composability.
00:10:59.996 - 00:11:46.534, Speaker A: It's the ability to stack all of these primitives on top of each other. Even something like yearn. Instead of trying to cycle your funds between compound and Aave, any of these other yield generating protocols, urine would just rotate you to wherever the best rate was. These are really powerful network effects that are only possible because of composability. Now, when we talk about multiple chains, we need composability across these chains. That's where interoperability comes into play. Interoperability, the ability for chains to communicate with each other, is what's going to enable multi chain composability.
00:11:46.534 - 00:12:00.402, Speaker A: Oh, sorry, I guess I forgot to switch the slide here. But anyways. And the last one, right. Is verifiable.
00:12:00.498 - 00:12:00.730, Speaker B: Right.
00:12:00.762 - 00:12:03.154, Speaker A: We need this infrastructure to be credibly neutral.
00:12:03.274 - 00:12:03.674, Speaker B: Right.
00:12:03.754 - 00:12:11.920, Speaker A: And have the transparency right for people to be able to verify the integrity of this system.
00:12:12.072 - 00:12:12.816, Speaker B: Right.
00:12:13.000 - 00:12:37.872, Speaker A: There's too many infrastructure services that right now both users and applications rely on that are complete black boxes or they're totally centralized and we don't have strong integrity guarantees there. Others claim to behave in an unbiased manner, but we have no way of verifying that.
00:12:37.968 - 00:12:38.604, Speaker B: Right.
00:12:40.104 - 00:13:33.554, Speaker A: You know, just to get into a few, like recent examples, right. Relatively recently, right. Tornado cash was sanctioned. And you may or may not have very strong feelings about, you know, your ability to use tornado cash, but it should be your choice. And the way that we've designed our applications to be dependent on these more centralized infrastructures has disenfranchised us of that choice. So to give you an example, flashbots, when tornado cache was added to the sections list, flashbots would only generate OFAC compliant bots, right. And this is really dangerous, right.
00:13:33.554 - 00:13:47.722, Speaker A: Because, you know, deciding, you know, what goes in or does not go into a block and like censoring on the block level. Right. This is really, really, really low level, right. Censorship.
00:13:47.898 - 00:13:48.614, Speaker B: Right.
00:13:49.354 - 00:14:32.658, Speaker A: It's, I'm not trying to argue, right. That we shouldn't, as an industry, right. We shouldn't comply with our compliance obligations or that we should. What I'm just saying is that it shouldn't be that far down the stack. It should be something that happens on the application layer where each application, according to its own circumstances, or even the users according to their own circumstances, choose and not have it be way down the stack. And we risk, the more we use some of these centralized services. For example, infura also write banned any transactions involving tornado cash.
00:14:32.658 - 00:15:25.884, Speaker A: They even do it today. So if you are using metamask, you're implicitly using infura. You will not be able to do a tornado cash transaction today because it's being censored on the infrastructure layer. So it's very important that we have infrastructure that is credibly neutral and that we can verify its neutrality. Okay, so with that, I want to get to you that all of these challenges of having infrastructure that is compatible, interoperable and verifiable is why I created Chronicle. So chronical is building decentralized infrastructure that is compatible and interoperable among all blockchains. And we want to do it in this transparent and verifiable manner.
00:15:25.884 - 00:16:29.034, Speaker A: And so you might be thinking that you've never heard of Chronicle. We're probably some new protocol. Well, actually we're one of the oldest and most battle tested protocols in pretty much like blockchain history. So we spun out of Makerdao, and I was part of the team that launched the first, I would say one of the first. I think Oracle beat us to the punch, but one of the first oracle protocols in all of Ethereum and really just one of the first protocols, period. So we launched this in conjunction with the launch of Protosi, which was the precursor to single collateral die. And since then we've been securing all of the assets and loans that were extended from maker, which currently today is $10 billion.
00:16:29.034 - 00:17:28.956, Speaker A: And in previous years, during the bull run, this number was even substantially higher. So that actually puts us, in terms of total value, secured as the second largest oracle provider right after Chainlink. And this is sourced from Defi Lama. You can check it yourself. Ok, so I want to talk a little bit about the architecture that we've made. And I hope to be able to describe to you why we're compatible, why we're interoperable and why we're verifiable, why you should be able to with your application or as a user using applications that use chronicle, why you should be able to trust those applications and those services. So we start with this concept of feeds and feeds.
00:17:28.956 - 00:18:39.706, Speaker A: You can kind of think of it as validators or signers of a multi sig. The point is that you want to have this distributed consensus being made and you want these feed clients to be run in a distributed fashion. You don't want any point of centralization or coordination, centralization either. And what these feeds do is that they're constantly just querying data from, let's say, if you have a price, oracle querying data from exchanges, querying data from on chain. If it's an oracle for powering a bridge, you may need to know what's happening on blockchain A and report that to blockchain B. But again, the way that you query data, you need to have redundancy and resiliency within this process as well. So we don't actually just have one tool for querying data.
00:18:39.706 - 00:19:21.922, Speaker A: We actually have multiple implementations. So in this chart, it's described as gopher and setsr. So gopher and setsr are completely independent implementations that implement the same kind of data standard. And the idea is that if one tool were to fail, we still have fallback on a different tool. And that's very important, building up this resiliency. So one bug, one failure, just doesn't take down the entire network. So what do these feeds do? Well, after they get the data, they do some data processing according to a data model, and then they sign it.
00:19:21.922 - 00:20:04.264, Speaker A: And once they sign it, they broadcast this kind of this message to what we call a transport layer. And transport layers are peer to peer networks, so there's no centralized server or anything involved. There's no bootstrapping nodes or something where if someone's not running one of these that no one can connect to the network, they're completely open networks. So you could try to connect to any of these networks right now. So we have Lib P, two p, we have secure scuttlebutt, and actually, we just last week implemented a third one. You may have heard of it. It's called Tor.
00:20:04.264 - 00:21:17.750, Speaker A: So between these three different networks, all of the messages, all of these signed messages are broadcast to all three of these networks. And in the future, we could even add additional networks. And the idea is, even if there's a zero day in one of these networks, even if there's a DOS kind of attack, even if there's a way to compromise one or more of these networks, that the architecture is kind of that the data is kind of like water, right? It will just flow through the path of least resistance, and the data will get through in some way. So this idea of resiliency behind the infrastructure is incredibly important to us. And then on the other end of this network, you have what's called relays. And relays are essentially just homologating all of these batches of messages from these independent feeds and compressing them into a single transaction, which then gets pushed on chain to a smart contract. Relays are permissionless.
00:21:17.750 - 00:21:58.276, Speaker A: Anyone can run a relay. You can run a relay right now, even without running a relay, a user could just go to our website, push the button, say, update. I want to update the price, and the price will be updated. You'll sign the transaction and pay the gas. But it's important that this evening that even without incentives, that this is like an open, kind of like permissionless role. And so one of the things that I want you to notice about this architecture is most of it is off chain. It's not on chain, right.
00:21:58.276 - 00:22:55.264, Speaker A: It's not specific to one particular blockchain. And this is what gives us that compatibility feature in that only the last mile has anything to do with the blockchain. And so it's really, really simple to deploy this infrastructure across multiple blockchains, because the only thing you need to change is, well, which RPC is the relay you're pointing at. On the topic of interoperability, right? Is this architecture interoperable? Yes, because the data source can be anything. It can be, yes. It can be an exchange like binance or Coinbase, but the data source can also be another blockchain. And so if you are gathering data from blockchain A and relaying that data to blockchain B, attesting to blockchain B, that, hey, something happened on blockchain A.
00:22:55.264 - 00:23:43.594, Speaker A: That is how you get interoperability. That is how something can happen on blockchain B based off what happened on blockchain A. And the last is verifiability. Oh, sorry. Well, we'll talk for a second, 1st, about the feeds. You might be wondering, well, who the hell is running these feeds? Why should I be trusting these people? So the feeds right now are run by the projects that you see behind you. Most of them have been running their feeds since, I want to say, over 24 months now, most of them right around the time of the launch of multicollateral Dai, which was in December of 2019.
00:23:43.594 - 00:25:18.084, Speaker A: So we have some great partners. We love working with them, and we're constantly looking to add more. And essentially what we look for is we want someone that has high credibility and a high reputation in our ecosystem, because essentially these feeds who are the entities that are reaching consensus, and they're effectively staking their reputation. So if, for example, let's say, maker were to try to participate in some kind of order, oracle attack, I mean, it would be suicide, right, for maker's reputation. And Maker might lose a lot of their users, because why would anyone want to ever use or interact or benefit a protocol that is a bad actor? Essentially, the trust model here is that maybe you don't trust, individually, one of these protocols on here, but the consensus of all, all of the protocols in our industry, the community consensus, that's harder to argue with, especially when you use some of these applications every day and already implicitly trust them. Okay, so this is kind of this idea of verifiability in that we don't just want cryptographic liability, but we also want verifiability, right? To like the layman user. So very frequently you'll see an oracle and just be like, here's the price.
00:25:18.084 - 00:26:33.934, Speaker A: And you're just like, how did that price come about? Or maybe I understand theoretically how it came about, but I cannot track the steps from here is where we got the data and here's how we transformed it, and that's how we achieved this number on chain. So kind of below the chart, right, we basically have a list of all of the feeds that were used during the consensus process for reaching the canonical price of the oracle. And then if you were to click on any one of these feeds, you'd be able to see the exact data sources of how each individual feed arrived at that price. So here you can see that we pulled the ETH tether pair from binance us, we pulled the ETH USD pair from bitstamp. We used an on chain source. I believe that one is uniswap V three. We used Coinbase and the feed took all of that data and decided that after crunching it through the model, the closest was this one.
00:26:33.934 - 00:27:00.942, Speaker A: That's what it ended up reporting. All of the feeds individually do this, and now you can use different types of consensus models. So in this case we're using a median. But there's no reason why you can't use a TWAP. A VWAP, you can transform the data in any way you want. It's just based off the definition of the data model that you plug in. And these data models are also on chain.
00:27:00.942 - 00:27:51.324, Speaker A: So there's an on chain register where these data models are defined. So when we say, well, how do you decide? How does a feed decide what the price of ethusd is? Well, you can go check in the on chain register. Here is the data model, and the feeds are querying this on chain contract to get the data model right. So it's not like some pre programmed thing where we can just slip in some hard code where the developers overwrite the rules of what ethusd is. We cannot do that. I mentioned earlier that this architecture is compatible with any chain. EVM is super, super easy because it's really just.
00:27:51.324 - 00:28:55.574, Speaker A: Even the smart contract is just deploying the same contract on every chain. But even non EVM is not difficult. You have things like Solana, you have things like cosmos, and the only thing that you change is you change the implementation of the smart contract, but everything else stays exactly the same. So we're publicly live on arbitrum, optimism and ethereum, but we have six other blockchains that we're kind of doing in secret right now, and that will be announced in the next couple of months. We're going to have a particular focus on the L2 s, but some of the more popular layer ones will be in there as well. So if you were interested in what I talked about here today, and you want to find out more or you want to stay updated, you can follow us on Twitter or join our discord. There's an easy link by going to our website.
00:28:55.574 - 00:29:41.546, Speaker A: If you would like to use Chronicle in your applications, you can reach out to me on Twitter or reach out to me on our discord, and we'll be happy to get something set up with you. And even if you're interested in working for chronicle or working on Chronicle, we're always hiring. We don't care where you are in the world. Right. You know your salary is not going to be regionalized or any of that crap, right. We just want the best people and we have, like, a remote distributed team that's basically across, I think, 14 different countries right now. So come talk to me, or even if you see me here, come talk to me.
00:29:41.546 - 00:29:50.534, Speaker A: Come find me. Let's talk. Thank you. All right.
00:29:51.034 - 00:29:54.414, Speaker B: Thank you very much, Nick. Do we have any questions?
00:29:58.394 - 00:30:00.734, Speaker A: First question here. Hey.
00:30:01.234 - 00:30:13.814, Speaker D: Hello. So I have a question about the transport layer. So you had two independent kind of modules in the transport layer, which is leap p, two p and secure scuttleboard, right?
00:30:13.854 - 00:30:14.334, Speaker A: Yep.
00:30:14.454 - 00:30:23.374, Speaker D: Why? Why? And you also mentioned that you have the third one in a way. Why to have three independent, like, modules. Are they independent?
00:30:23.414 - 00:30:23.958, Speaker B: Firstly?
00:30:24.046 - 00:30:25.614, Speaker A: Yep. They're completely independent.
00:30:25.694 - 00:30:25.934, Speaker B: Right.
00:30:25.974 - 00:30:29.062, Speaker A: And because one could get hacked, right.
00:30:29.238 - 00:30:33.558, Speaker D: Why not three of them can be hacked then? Like, if one can be hacked, they.
00:30:33.646 - 00:31:34.508, Speaker A: Could, but probabilistically, the more you add, the more, the less likelihood that all of them can be hacked at the same time. These are all open source protocols. So you would imagine that over time, if they are compromised, that they will be fixed and they will become hardened protocols and they will build up some Lindy. You could even add a centralized server there if you wanted to. We actually had an internal hackathon where someone actually created this cool concept of, like, what if we just threw the data up on Twitter, right? And it's like, oh, well, Twitter's like, you know, terms of service doesn't let us just, like, put up Json, you know, into a tweet, right? You would get banned. And so what we ended up doing is we just said, it's art, and we just encoded bitmaps with the data. And so you would just have feeds tweeting, like all of these pretty bitmaps.
00:31:34.508 - 00:31:55.864, Speaker A: And we just said that they're like AI generated art or something. And so it's okay. But right now they're all peer to peer distributed, decentralized protocols. But you could still gain extra resiliency by using centralized services as well, as long as you're not reliant exclusively on centralized services.
00:31:56.764 - 00:32:03.922, Speaker D: And who currently run the notes of these peer to peer services? Who operates the nodes of these products?
00:32:03.978 - 00:32:08.042, Speaker A: So the networks are composed of the different participants on the network.
00:32:08.098 - 00:32:08.634, Speaker D: Yeah, true.
00:32:08.714 - 00:32:09.334, Speaker B: Right.
00:32:09.954 - 00:32:28.754, Speaker A: So again, right, there's no bootstrap node that we run that everyone connects to us. No, they're peer to peer. So everyone is just connecting with each other. So it's the feeds, right, that are part of the network. It's the relays that are part of the network. It's people that just want to monitor the activity of the or performance.
00:32:28.874 - 00:32:29.130, Speaker B: Right.
00:32:29.162 - 00:32:33.834, Speaker A: That are part of the network. They're open networks. Anyone can be part of them and join them.
00:32:34.894 - 00:32:43.274, Speaker D: Are there any incentives for someone who wants to run the node in the transport layer, other incentives for it?
00:32:44.254 - 00:32:54.198, Speaker A: Currently, no. We may add those incentives in the future to make the network more resilient and robust, though it's definitely something to think about.
00:32:54.366 - 00:32:54.878, Speaker D: Thank you.
00:32:54.926 - 00:33:02.530, Speaker A: Another question from the audience. Cool, thank you. No questions. Great.
00:33:02.602 - 00:33:03.434, Speaker D: Thank you very much, Nick.
