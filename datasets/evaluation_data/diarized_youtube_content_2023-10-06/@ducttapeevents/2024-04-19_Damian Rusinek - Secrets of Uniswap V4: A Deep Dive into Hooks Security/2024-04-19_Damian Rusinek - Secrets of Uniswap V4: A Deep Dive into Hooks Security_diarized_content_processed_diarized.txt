00:00:04.040 - 00:00:32.734, Speaker A: Hi all. Thank you for this great introduction. I actually didn't know that you're going to read all that, so. Hi, I'm Damian. I simply run composable security company and we have protected both centralized and decentralized projects for millions now. And also we have created the first smart contract security standard that's on the market. And today I'd like to talk about Uniswap V four.
00:00:32.734 - 00:01:03.122, Speaker A: So I'll show you the architecture, and also I'll mainly focus on the security threats and try to show you how to protect yourself if you wanna, if you consider building a hook. So let me start with this equation. Who knows this equation? Raise your hand. Yeah, almost everyone. That's uniswap V two, right? So the first great project by Uniswap, the first big success. And it's great because it's simple, very simple curve. However, it is also its downsides.
00:01:03.122 - 00:01:34.004, Speaker A: So one of them, the biggest one, is the inefficient liquidity. And that problem was solved by some other projects, like for example, curve. But Uniswap wanted to do something more like to have a better approach that is not only for stablecoins. So they started with, started working on V three. And V three is a bit similar. So the curve is the same. But the main thing, the main change that was here was the concentrated liquidity.
00:01:34.004 - 00:02:14.324, Speaker A: So basically, you didn't have to put your liquidity on the whole range, but you could specify the price range that you want to put your liquidity in. However, on the other side, of course, there is always the other side. The complexity has risen a lot because of this liquidity pool token, which was not fungible anymore, like simple ERC 20, but it was NFT. So it made it quite complex to manage. So let's look at the architecture of V three. You've got this factory that allows you to deploy new pools. So each pool is actually a separate contract.
00:02:14.324 - 00:03:19.818, Speaker A: And then you as the liquidity provider can call some functions directly on the pools, but usually you will use those contracts that are your helpers. So in this example, for a liquidity provider, you have that non fungible position manager. This is contracted by Uniswap Labs that will allow you to add liquidity or remove liquidity. So you as the liquidity provider are talking with this contract, and this contract calls, let's say, mint function on some specific pool contract. And then there is a callback mechanism here. So this uniswap pool makes this callback function to the non fungible position manager, which takes care of all the future flow of this operation, and it works similarly for swappers. So they also make these calls on this helper contract which is called swap router, which then calls swap on pull contract.
00:03:19.818 - 00:04:08.838, Speaker A: And there is that callback which is called Uniswap v three swap callback. And the swap router takes care of the rest. So you have to use this mechanism. But due to the concentrated liquidity, those swaps are much more efficient and the slippage is much lower. However, after two and a half or almost three years when the v three was published, there is still plenty of liquidity into v two. And what's more, about 90% of pools deployed today are still v two, not v three. So this doesn't sound like a big success of v three, right? So there is a v four coming, which is going to solve these issues.
00:04:08.838 - 00:04:28.858, Speaker A: The main goals are first gas optimization. So you want to make it as gas optimized as possible. Have you seen the latest tweet from Hayden who was asking whether it's worth to remove all events to get 1% fee less?
00:04:28.946 - 00:04:29.626, Speaker B: Right?
00:04:29.810 - 00:05:09.964, Speaker A: So yeah, I'm leaving this up to you. But the other big change is the customization. So v four is gonna be like very new. A big amount of possible opportunities for liquidity providers and for builders that will use this and build on top of that. And they are also trying to attract lp's to v four. So they started that grant that will allow you to. The idea behind the goal of this grant is to make a frontend that will make those liquidity providers migrate from v two to v four.
00:05:09.964 - 00:05:45.568, Speaker A: And there are some changes. I'm going to show you those on the architecture, on the diagram. But the first one is the transient storage, which is quite noisy recently. So there was that Denkun that introduced this tstore and tload opcodes that are simply very cheap ways of something similar to storage management. Let's start with this singleton architecture, like singleton pattern. Sorry. So now in v four, there are no more separated pools.
00:05:45.568 - 00:06:14.180, Speaker A: Each pools are managed in one contract called pool manager. So you can, like anyone can initialize new pool by calling this initialize function on the pool manager. Next thing is the pool operator. So that's the contract. We call it pool operator because it simply operates on the pool manager on behalf of the user. And there is no really difference between swapper and liquidity provider provider. And I'll show you in a second why.
00:06:14.180 - 00:06:50.408, Speaker A: So this callback mechanism is still there, but it works a little bit different. First, your pool manager, which is like your helper contract makes this unlock call to unlock the pool manager, then pool manager calls back with unlock callback. And from now on, the pool operator can make many different calls on pool manager managing, like doing those operations on multiple pools within this one contract, within this one pool manager contract. And that's what is called flash accounting.
00:06:50.456 - 00:06:51.044, Speaker B: Right.
00:06:53.144 - 00:07:34.684, Speaker A: And the second, well, the biggest change are those hooks. So hooks are contracts that are called by the pool manager before and after operations being made on the pools. So for example, as you can see, there are multiple functions. Actually, you cannot see that much, sorry. But before initialization, adding liquidity, removing liquidity, swapping and donating. And also after all those operations, the pool manager is able to call the hook contract and you as the initiator of the pool will specify what's the hook contract. So you control this contract.
00:07:34.684 - 00:07:54.504, Speaker A: And what's more is that the hook that is called by pool manager can also be the pool operator. So basically, you as the user can start your flow on the hook. The hook will call pool manager, pool manager will call hook functions. And that's how it goes.
00:07:54.544 - 00:07:54.744, Speaker B: Right.
00:07:54.784 - 00:08:28.064, Speaker A: So like the hook now is quite big contract. I mean, it can cover your whole interaction with pool managers simply with all pools. Sorry, can we. Yeah, no. Operator is this helper contract. So the user is the swapper, liquidity provider. So you call this on this pool operator, and pool operator operates on the pool manager on your behalf.
00:08:28.064 - 00:08:59.046, Speaker A: Can we come back to questions after? Yeah, sorry. Because the time is quite limited, so we can talk later. So how it works, how the flow works, basically each pool has those flags. And if the flag, like for example, for after, for before swap, we have a flag. If this flag is set, the pool manager will call this before swap function on the hook. If it's not set, it will not call it. So now let's move to the security threats.
00:08:59.046 - 00:09:30.050, Speaker A: So the main thing of this presentation. So we have identified some security threats for this architecture. However, I'm going to focus due to the time limit on a few of them. And the first one would be protecting the hook functions. So here's an example of a hook. It's a full range hook created by uniswap Labs, if I remember correctly. And here you can see the before initialize function.
00:09:30.050 - 00:09:46.838, Speaker A: This is the hook that is. So this is the function that is called right before the pool manager initializes new pool. And it's external because the pool manager has to call it on the hook contract. So it has to be external.
00:09:46.886 - 00:09:47.474, Speaker B: Right.
00:09:48.094 - 00:10:40.054, Speaker A: And here is the flow. So anyone can call this initialize function on the manager, on the pool manager and poolmanager will call this function. However, as you can see, there is no any protection on this function. So like anyone can call it. So what happens if somebody like some kind of attacker calls this function directly? If you look in this function, it does. Well one main thing, whenever you initialize a pool, it creates an ERC 20 token that tracks the balances of the liquidity that was added to this pool. So when you try to withdraw your liquidity from the pool, it simply tries to burn this contract, ERc 20 contract, and give you your liquidity, give it back to you.
00:10:40.094 - 00:10:40.750, Speaker B: Right.
00:10:40.942 - 00:11:16.234, Speaker A: However, if I call it again, this, as you can see on the bottom, it will create a new pool token, new pool liquidity, pool token, a new ERc 20, and that will lead to the overwrite of this pull token, right, so now there is new ERC 20 and you as the liquidity provider don't have any tokens of this contract because this is a new one. So when you try to withdraw your liquidity, it will simply revert because you cannot burn tokens that you don't have.
00:11:16.274 - 00:11:16.854, Speaker B: Right.
00:11:17.314 - 00:11:51.844, Speaker A: So how to protect from that? It's quite simple. You have to make sure that all hook functions can be called only by the pool manager. Right, very simple solution, but we don't need to focus only on the hook functions. But we also have to check the pull operator because this is the unlock callback function. So this is the function from the pull operator, you as the user. Let's imagine there is a case where you can withdraw as the user. So you call this withdraw function on the pull operator.
00:11:51.844 - 00:12:37.704, Speaker A: Pull operator prepares some data that is passed to the pool manager in the unlock function. And this data is sent back to the pool operator in the unlock callback function. So here you can see that the pull operator takes the message sender, so you as the user and forwards this to the poolmanager and pullmanager bounces it back. So now pull operator can do all those operations on behalf of the user. That was get from the pool manager. And so, yeah, so this is how it works. But what happens if you try to call this unlock callback function directly as some kind of attacker and you of course will pass some different parameters.
00:12:37.704 - 00:13:21.330, Speaker A: User would be the victim, but withdraw two address would be your address. So this is the case where we can jump in into this business flow and do some kind of malicious input, some malicious parameters. So how to protect that? Very similar to the previous one. So you can simply make sure that the call to unlock callback function comes only from the pool manager. The next one seems a bit similar, but stay with me. We again have the, we've got some dynamic fee hook, but it doesn't really matter. There is that before initialize function.
00:13:21.330 - 00:13:53.046, Speaker A: And of course this hook has to know something about the pool that it operates on. So it stores the pool key, the last price and the last block number. As you can see, it's protected. There is that pool manager only, so we are safe. The first thread is covert, and then this hook is also your liquidity manager. So it's also your pool operator. So you can add liquidity or remove liquidity.
00:13:53.046 - 00:14:01.070, Speaker A: And as you can see, it works on this pool identified by the pull key that you just saved in the initialization.
00:14:01.222 - 00:14:01.914, Speaker B: Right.
00:14:02.214 - 00:14:21.884, Speaker A: So what happens if we try to initialize another pool but with the same hook? We will simply call this function, sorry, call this function again, but with different pool, so different pull key.
00:14:22.004 - 00:14:22.524, Speaker B: Right.
00:14:22.644 - 00:14:58.056, Speaker A: So from now on, this hook thinks that it works on a different pool, right? So when it tries to withdraw tokens from this new pool, there is no tokens there, right. This is new pool. So again it reverts. So it's a simple token lock. How to protect from this one, simply use mapping. So if you want to make a hook that works only with one pool, you have to check that. Like you can revert on the initialization if the pull key is already set.
00:14:58.056 - 00:15:33.280, Speaker A: But if you want your hook to work with multiple pools, and that's probably the most typical case, keep all those data that is assigned to the pool in the mapping, right. And then you're fine. Next one is the impersonation of the sender. And again, we are talking about this process. But let's look first on some example of a hook. This is a hook that has that after swap hook function. And as you can see, this after swap hook function has a parameter called sender.
00:15:33.280 - 00:16:06.680, Speaker A: So you would imagine this is the sender that was trying to swap, right? And this particular hook does some checks on the sender. Well, in this example, it was like the sender cannot have too much tokens after the swap. So that you cannot have too many. Doesn't really matter. That's your business case, doesn't matter. But if you look at this flow, you will see that you, as the sender, is swapping on the pool operator. The pool operator calls pullmanager.
00:16:06.680 - 00:16:55.184, Speaker A: So the swap function, and poolmanager gets the sender, sets the message sender as the sender parameter in this after swap hook. So in this case, you would imagine that you, as the hook, would imagine that the user is the sender, but actually the pool operator is the sender. So they are checking whether the pool pool operator has more than like 30% of tokens in their case. So this is wrong. So simply their hook doesn't work correctly. But how to make it work? Well, the pull operator can send some. Sorry.
00:16:55.184 - 00:17:06.530, Speaker A: So pull operator can send some hook data. So this is simply a parameter that you can send to the pullmanager. And Pullmanager will pass it to the hook.
00:17:06.642 - 00:17:07.346, Speaker B: Right?
00:17:07.530 - 00:17:47.886, Speaker A: Okay, so let's do it. Pull operator takes the message sender, which is the user, sends it to the pool manager, and pool manager passes it to the hook. So hook can see who is the real sender. But what if, what if we are calling this, we are using different pull operator and we can control these different pool operators. It's code. So we can make it set the hook data as the victim. So the pullmanager will pass it to the hook.
00:17:47.886 - 00:17:58.568, Speaker A: And if the hook doesn't verify whether this data comes from the trusted source, they will simply make all those operations on behalf of the victim.
00:17:58.656 - 00:17:58.880, Speaker B: Right?
00:17:58.912 - 00:18:13.696, Speaker A: So we can make operations on behalf of anyone who uses this hook. Like for example, you can make the hook call some transfer from function, and if it's approved by anyone, you can simply steal their token.
00:18:13.760 - 00:18:14.032, Speaker B: Right?
00:18:14.088 - 00:19:13.484, Speaker A: So this is a typical scenario here. Number five is dynamic fees. This is a new thing that came to v four, and it's quite interesting, but also it has some security implications because in the p four swap hook, you can update the fee on the pool. So actually there is one limitation. And the limitation is that the fee cannot be more than 100%. So what happens when it's 100%? Well, basically, whatever you are trying to swap will be taken from you because that's the fee, right? So you as the user should watch out for those hooks. But there is even more because some hooks have real business cases that needs that, right? So there might be correct hooks that have 1% fee, 100% fee.
00:19:13.484 - 00:19:54.512, Speaker A: But what happens if the fee gets higher than 100%? Let's say you have some calculations. You calculate the fee and there is an edge case where it goes to 100%. What happens then? It simply reverts. So if you cannot reverse it, your pool is now dosed, right. Nobody can swap on it because each try to do some swap will end with revert because of this too high fee. And last but not least is quite easy. So upgradable hooks.
00:19:54.512 - 00:20:25.824, Speaker A: So you can imagine what can happen if you have an upgradeable contract, you can change its logic in any way. There are some protections, but still you, you can do a lot. Like if your hook is also a pool operator, you can simply withdraw the money. So watch out if you are a builder, don't use upgradability. If you are a user, watch out for upgradable hooks. For pools with upgradable hooks. So to sum up, here are some ideas how you can protect yourself.
00:20:25.824 - 00:20:51.318, Speaker A: And, yeah, I'm not going to read that because you can read that or you can simply take a picture. And I'll also encourage you to check out our series. Yeah, it will be back in a second. Okay. Our series on our blog about the security of uniswap hooks. So we can check it out on our blog and. Yeah, here it is again.
00:20:51.318 - 00:21:17.264, Speaker A: And if you have, like, any questions regarding Uniswap v four hooks and its security, or security in general of smart contracts or web3 projects, you can find me on Twitter, on Telegram. That's my handle. You can scan it and. Yeah, and actually, that's it from me. Thank you. Thank you very much. Damien, any questions? We can have one question.
00:21:22.044 - 00:21:31.344, Speaker C: Very insightful presentation. Thank you very much. Do you have a special program on bug bounties for your version four or any of the.
00:21:31.464 - 00:22:06.858, Speaker A: Well, actually, I'm not from Uniswap. We've been working with Uniswap foundation and security research, but it's not yet, because it's simply not yet published. So now they're working on. Actually, I think they've already frozen the code and it's gonna be published within like two or three months, I guess, because now they have to go through all those rounds of audits, etcetera, but. Well, the question is whether there is bug bounty already for v three. To be honest, I'm not sure. Does anyone know if there is bug bounty on Uniswap? There is.
00:22:06.858 - 00:22:11.010, Speaker A: So for sure there will be as well for V four.
00:22:11.162 - 00:22:11.610, Speaker B: Yeah.
00:22:11.682 - 00:22:26.834, Speaker A: Thank you. Any more questions? Yeah. Okay, sorry, wait, three. Thank you.
00:22:27.214 - 00:22:33.158, Speaker D: I have, I guess, a bit of a. More of a general question about Uniswap before and.
00:22:33.286 - 00:22:35.554, Speaker A: Sorry, can you say a bit louder?
00:22:36.174 - 00:23:07.956, Speaker D: So I have more of a general question about Uniswap before and how these. How the protocol is going to work with these kooks, because these are additional functionality that the user has to want to interact with. So is there also a universal router that can also route through pools? And is this possible because you need the user's approval? In a way.
00:23:08.100 - 00:23:20.344, Speaker A: Let me rephrase to make sure if I get your question correctly, you're asking whether the simple user can feel safe using v four without all those sophisticated hooks, right?
00:23:20.644 - 00:23:24.308, Speaker D: Yes. Without knowing if they're there, right.
00:23:24.356 - 00:24:07.294, Speaker A: So now the answer is no. But it's because it's not live yet. But we also did some, and it's on our blog, some research on possible future security measures that they can do, they can implement. And one of them was that, let's say a dashboard of pools that Uniswap would confirm would say that they are safe because you can simply write a universal hook. Sorry. Universal router can be also a hook. It would be a pull operator, so it can also be a hook.
00:24:07.294 - 00:24:35.108, Speaker A: So I'm pretty sure that Uniswap will create their own pool operator, which is going to be this router. And then they can only allow you to make operations on selected pools because in the end it's the pool that you choose that is associated to some hook. So you don't select the hook, you select the pool and it may or may not have some hook with it.
00:24:35.196 - 00:24:35.684, Speaker B: Right.
00:24:35.804 - 00:24:48.584, Speaker A: So if you have a list of pools that are, let's say, blessed and considered safe, then. Yeah. Then you can feel like safe if you trust those who say that it's safe.
00:24:50.124 - 00:24:51.064, Speaker D: Thank you.
00:24:53.844 - 00:24:58.948, Speaker A: Okay. Thank you. Thank you. I see. Last question. But we can talk later.
00:24:58.996 - 00:24:59.196, Speaker B: Okay.
00:24:59.220 - 00:25:02.464, Speaker A: Because I was. Yeah, yeah, we can talk outside.
00:25:03.484 - 00:25:03.924, Speaker B: Thank you.
