00:00:02.000 - 00:00:25.914, Speaker A: All right, so, hi everyone. I'm super excited to be here. My name is Michael Psoratio. I'm the lead developer of security tooling for Ethereum at Ekibo chain, and I'm also an auditor. We are an auditing company, mainly focusing on projects built on Ethereum and Solana. And except for that, we are also open source tooling builders. And Wake, which this talk is all about, is just one of them.
00:00:25.914 - 00:01:35.122, Speaker A: We work with many well known projects, like, for example, lido, one inch axar or safe, and we've received a grant from Coinbase. So what is wake? First of all, wake is a framework. It's a framework for testing, so anyone can write a simple unit test. Testing a simple case, like a test a case from solid code. So anyone can test just like a simple one feature of solid code, they can also do fuzzing, which is like a special technique, quite different from unit testing in a way that it generates random data, it generates random transactions, and it runs those random data and random transactions. So each time someone runs the fastest, they observe a completely different behavior because of that randomization. They can be also used for integration testing, so that anyone can fork a mainnet or maybe a testnet, and then start with that forked chain and then deploy their contracts to that fork chain.
00:01:35.122 - 00:02:26.620, Speaker A: So they have already pre deployed contracts from the forking. Vic is also a static analysis tool, which means that there are some detectors that can detect common issues in the code, like vulnerabilities or just code quality issues. There are also printers that are very similar to detectors, but still different. And the difference is that they just print anything or extract information about the code, so they analyze the code, so there's some compilation behind, and then there's data extraction, and that's the difference from detectors. Bake is also a language server, so that anyone who wants to write and study the code, they need to install an extension for versus code, because versus code itself doesn't support solidity. And there are many extensions out there. Tools for solidity is just one of them.
00:02:26.620 - 00:03:10.602, Speaker A: And bake is used like a back end for the extension for the tools for solidity extension. So tools for solidity is just the front end for wake. And if you wonder which extension for versus code is just the best for you, you should definitely visit our talk, which takes place right here after my talk. And like the talk is named a swiss knife to Ethereum tooling. And I think that the table quite explains why we call awake a swiss knife. We've taken a well known, like I would say tools or maybe frameworks and compare them to wake. The second one from the right is founder.
00:03:10.602 - 00:04:00.380, Speaker A: I haven't found the logo with foundry text. So there's foundry, there's hardhat, there's of course wake, there's ape framework, slitter and so on. And we are comparing the main features, like testing. I've added fuzzing because I think that fuzzing can be really useful, detectors, language server, and if the tool is maintained or not. And I think that there's a huge advantage for developers because they can use just a single tool to do everything, so just a single tool to rule them all. But Wake is written in Python, and you may wonder, why would you use Python in 2024? I would like to give you a few good answers for that. First of all, machine time is less expensive than the human time, so I think that's generally true.
00:04:00.380 - 00:04:48.994, Speaker A: And at the same time, the most time spent in development is spent, or should be spent on testing and debugging of issues found in the testing phase. And Wake has got a pretty nice debugging feature, and it's given by the fact that wake is written in Python. And Python itself is a very good tool or language for debugging. There's an interactive debugger, so anyone can just stop at any line of the testing code in Python and then interact with any variable or anything. And I think this is like a huge advantage. There's the console log support, so anyone can just insert console logs into solid code, recompile the project, and then see those logs like in the terminal. So anyone can debug even the solid code itself.
00:04:48.994 - 00:05:21.830, Speaker A: And there are very, very nice call traces. I've got an example on the next slide, so let's move to the next slide. And this is an example of a call trace. So this is a call to a function called executevote. It's an example from the Lido project, which actually forked from Aragon. And we are calling that function, we are calling it through a proxy. As you can see, Wake has properly detected that we are calling that through a fallback function.
00:05:21.830 - 00:05:57.884, Speaker A: There's a status next to each call trace which says if the call failed or succeeded. If it failed, there's an error that better describes why the call failed. So it's right here. And there are also names of the functions and names of the parameters and so on. And I think this can be pretty useful when debugging an issue in the code. And this is another example. Let's say we are debugging some project and our test failed on a reverting transaction, and we need to debug that reverting transaction.
00:05:57.884 - 00:06:42.114, Speaker A: So we can print anything about some data in the project, like a vote. We are voting in a project. We can print the address of a voter, like here, the address of a delegate, because a delegate votes for a vote for a voter. We can print that error that occurred in the transaction, and we can print the cold trace for a transaction. And I think this is very useful when you don't know why your test failed. So, yeah, there's the cold trace, and then we can just check that the balance of a voter was zero, and this is the reason why the transaction failed. So I think this is a very nice example of an interactive debugger, which is built into wake.
00:06:42.114 - 00:07:22.028, Speaker A: As I said, human time is more expensive than the machine time, but when it comes to execution times, it's also very efficient. We took the Uniswap v three core project. It already contains tests written in hard hat. We took those tests as a reference, and we've written 271 tests into ape framework, into wake framework, and into browning framework. And we run those tests and measured the complete time for all the tests. And the results are in the table. So, as you can see, bake is pretty fast.
00:07:22.028 - 00:08:14.894, Speaker A: It managed to run all those 271 tests in less than 4 seconds, which is, in my opinion, amazing. Another reason for using wake is differential testing, or python in general, is differential testing. Let's say that you are building a very complex project that involves math, and you cannot follow the math directly in the solidity code. And the reason for that is that it would be super expensive, like super gas expensive. In this example, there's a formula that is used to compute some floating interest. It's not that important what exactly it computes, but it's needed to multiply multiple exponential values. And this cannot be done in every transaction, because it would be very expensive.
00:08:14.894 - 00:08:49.114, Speaker A: So the project we were auditing, which is called iPor, took a quite different approach. It does the same, but in a different way. Also, there's some value computed, and there's division. And our advantage in python is that we can use floating point numbers. So we can just use floating point. We can compute the value just by following the formula, and then we can compare that value computed to the value that is in the contract and contract, and see the difference if it's huge or if it's okay for us. And this is the power of differential testing.
00:08:49.114 - 00:09:28.678, Speaker A: Wake stubbed hacks. This is an example, like an incomplete table of all findings that were found using wake, it was found using fuzzing, using differential testing. And there are quite high or critical vulnerabilities and also projects that are well known, like Brahma, which is a very nice project built on slave, or for example slide. I believe many of you know sleide. There's also Axlr, which just like cross chain solution for interchange transfers between multiple chains, or for example ido. But there's more. In the testing framework module wake supports fuzzing.
00:09:28.678 - 00:09:44.318, Speaker A: As I said, it's a useful technique. When we generate random data, we generate random sequences of transactions. We run those tests again. Again. And we are trying to find some issues in the code. And there's a workshop. The text takes place today, don't worry.
00:09:44.318 - 00:10:42.064, Speaker A: There's a QR code at the end of the presentation, so you will be able to scan the QR code and see all of our talks and workshops so you won't miss anything. There's also fork testing support, so anyone can fork the mainnet, the testnet with pre deployed contracts and then deploy their own contracts that interact with those pre deployed. And there's a nice feature which is Etherscan integration. And it means that when interacting with those pre deployed contracts and printing called traces, the names of those pre deployed contracts and the functions and everything will be just resolved because of the Etherscan support. So they can automatically fetch the source code from Etherscan and show the names of the pre deployed contract. There's also coverage analysis support, so the tests can be run in coverage analysis mode, and then the coverage can be analyzed in versus code, right, directly in versus code. You can see the lines that were covered using the testing.
00:10:42.064 - 00:11:04.804, Speaker A: There's cross chain testing support that was heavily inspired by Axelar. We needed to test a project that uses cross chain transfers. And there's a support for multiple chains in the testing module. And I think this is quite unique. Like not every framework supports cross chain testing. There's also the possibility of reproducing the test using random seed. Random seeds.
00:11:04.804 - 00:11:57.604, Speaker A: This is especially useful in fuzzing when we need to generate random data and we need to reproduce the issue that we've discovered again and again. And this is possible thanks to random seeds. So anyone can just use the same random seed and observe the same behavior in testing. And then there's also parallel execution, so anyone can run just a single test multiple times, or maybe different tests. And this is especially useful again with fuzzing, so that anyone can just generate multiple random seeds and then launch them in parallel, so it executes multiple transactions at the same time at multiple cpu cores. There's also the static analysis framework and I think the main feature here is detectors. So we've decided to take quite a different approach from other static analysis tools.
00:11:57.604 - 00:13:13.924, Speaker A: By the way, if you don't use any static analysis tool, I really recommend using one because it can be super useful to detect like early bugs in the code. But we've decided to take a quite different approach and we've decided to make better quality of the detectors over quantity. Based on our analysis, around 20% of detectors in slitter are for outdated versions of solidity or they are already covered by source c, which means that solid compiler already reports the issues in the code. There's also the user experience page and we are trying to make the best user experience as possible. So there's a GitHub actions integration so anyone can just push the code to GitHub and those vague detectors can be automatically run and the detections can be seen in GitHub UI and if you are pushing to different branches then you won't have duplicates in that UI because they are merged thanks to the GitHub integration. Also, if you're using an extension called tools for solidity which uses wake in the background, the detections are automatically highlighted in the code, so it's pretty easy to find them, to debug them and so on. And they are automatically reloaded.
00:13:13.924 - 00:14:01.056, Speaker A: So whenever typing some code in solidity those detections are reloaded, which is pretty nice. It's not needed to click on something or something like that. So it's straightforward, very easy, and there are also comments, so we are trying to achieve the best precision as we can. But still there may be some false positives and it's possible to ignore those false positives thanks to comments that can be added to the code. There's of course an API for creating custom detectors, so anyone can create like single purpose or maybe general detectors that can be used anywhere with solid code. I've got a very nice example here. So this is an example of a detection on the command line, and as you can see there's a relative path to the detection.
00:14:01.056 - 00:14:35.830, Speaker A: Actually if the terminal supports a feature like links then anyone can just control click on this path and it will open versus code just with this line of the code. So it's possible to more inspect this single detection. I think it's very nice. There's also the severity of the issue and the confidence of that issue. And of course the label like the title that describes that issue. So I think this is a very nice user experience. And this is another example, and this is like from the programmer's perspective.
00:14:35.830 - 00:15:19.064, Speaker A: So let's say, say that we have some project that follows some invariants, I would say, so that we have some unsafe functions and they should always have the only on the modifier. So we want to detect if really all the functions use these, use the only on a modifier. So this is like the only code that has to be different from a template. So if we want to detect these issues like that only owner is not used in unsafe functions, we just need to type this. It's super easy, I would say. So we need a function definition visit function. So this node contains information about a single function in the code.
00:15:19.064 - 00:15:54.604, Speaker A: We can check the name of the function, we can convert it to lowercase. So we've got the lower case name of the function, we can check if unsafe is in the name of the function, and then we probably want to check the visibility. So if the visibility is public or external, and if it's so, then we check all the modifiers that are attached to that single function. And if there's none that would have the name onlyowner, then we have found an unsafe function that doesn't have the only owner modifier. So I think this is very easy. Very nice. Example.
00:15:54.604 - 00:16:45.074, Speaker A: Example of detectors there are also printers that are used for source code extraction. So the API is basically the same, it follows the same logic as detectors, but it can be used for data extraction and not for detecting some issues. And what can be extracted from the code? Perhaps graphs like inheritance graph, like control flow graphs, like cross reference graphs, things like that. It can also be an API of a contract, it can be a storage layout, it can be some interesting statistic like numbers, for example, lines of code, number of functions, things like that. And there's also a language server integration. And I'd like to see, I'd like to explain that on an image, on an animation. And of course there's an API for creating custom printers.
00:16:45.074 - 00:17:30.071, Speaker A: This is an example of a storage layout printer, which shows how really nice can the printers be? It's very user like, the user experience is really nice, I would say. And it shows a storage layout of a single contract. And yeah, it's basically the storage layout. And this is an example of a custom printer. And as you can see, the logic is almost the same, like it follows the same principles in a way that we define a visit function. This time we want to visit a contract definition, because our goal is to print all public and external functions, including those inherited ones in a contract. So we've got a contract, a single representation of a contract.
00:17:30.071 - 00:18:39.000, Speaker A: We can iterate over all base contracts, then over each function in the contract. Then we can check out the selector of a function that should be somehow unique, and then we can just check if we've seen the selector, or if the selector actually exists, if we've seen that selector, if the function is implemented, and if the visibility is public or external, and we can just print the name of the function. And this is that example of versus code printers, and it does the same in that it shows all the public and external functions, but the presentation is quite different. So we won't print anything to the terminal as a text, but instead we can just show the names of the functions right in versus code, and anyone can click on those references and go straight to the references of the public and external functions. And this is the feature that we have released just yesterday for Ethereum trick. And there's a workshop that shows how to create our own creative buttons that do something. And you can just scan the QR code, which is right on the next slide.
00:18:39.000 - 00:18:45.364, Speaker A: So you can visit all our talks and workshops, and that's pretty much it. Thank you for your attention.
00:19:11.324 - 00:19:24.424, Speaker B: Hi, thank you for the presentation. Maybe I might have missed, but is there a local testnet node during the development in the wake framework?
00:19:24.544 - 00:19:51.244, Speaker A: Yeah, you can use a development chain. We are using Anvil in most cases, because wake is highly optimized for anvil. So it's highly recommended to use Anvil, which is the part of foundry project. And that's basically the best node, like a development chain that can be used for testing. And if you need fork testing, that you would fork a mainnet or a testnet, then you can use any node, but there's no bundled in vague, you can use any, any notes you want to.
00:19:56.784 - 00:20:06.664, Speaker C: Any other questions? Did that answer your question? Okay, perfect. Anyone else have a question from the audience? No? All right then please give another big round of applause to Michael.
