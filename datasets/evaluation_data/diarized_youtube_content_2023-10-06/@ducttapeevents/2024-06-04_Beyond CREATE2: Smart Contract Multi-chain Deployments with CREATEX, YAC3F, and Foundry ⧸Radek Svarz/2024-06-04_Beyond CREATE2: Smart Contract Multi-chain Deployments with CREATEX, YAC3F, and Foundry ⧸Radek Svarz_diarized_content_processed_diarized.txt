00:00:10.360 - 00:00:32.000, Speaker A: Welcome everyone. Last session of the lift stage. Today we're going to end with amazing session going beyond crate two. Smart contract multi chain deployments with CraidX, yEC, three F and foundry. Our speaker gonna be Radek, who is system architect. He is also the organizer of the beerfi. So if you love beer, perhaps you want to talk to him.
00:00:32.000 - 00:00:34.984, Speaker A: So please welcome Rodek to the stage with applause.
00:00:35.764 - 00:01:06.368, Speaker B: Hey, I have my mic. Okay, thanks a lot. Thanks for the intro. It's awesome, right? The e frac now and all the sidelines which are here, that's really, you know, energizing, I would say. But I hope that I will not make you asleep because we will go like quite technical for some of the people who were showing this. They said, okay, I will not come to this session. So I hope that you guys are technical and that you will enjoy it.
00:01:06.368 - 00:01:56.192, Speaker B: Because we will talk about the multi chain deployments and the necessity of doing that, and how it is being done, what are the risks and what are the issues and what are the ways how to do that, and what was like the progress since last year. A little bit more about me as I was introduced. I am architecting the things. I am highly involved in smart contract development, create a check stablecoin and I organize that before meetup for the developers, which is like the monthly one. I'm also listening to the mass market. That's what Lefico is mentioned here, because I want to hear about the users, what are their troubles and most their fears, like the blind signing, for instance. And I'm also involved in some sort of the decentralized science like non fungible brain, which will introduce this Sunday.
00:01:56.192 - 00:02:32.364, Speaker B: So you are really welcome to come on Sunday on the lighting talks, when we will talk about the brains and things like that. I've been coding since eighties, since late eighties. And I very enjoyed the ERC discussions on the Ethereum magicians, because I feel that we are forming what will be impacting the solutions that would be in the future. For this case. I am the creator of the public good, which is called yet another create refactory. And I also created the Creatix foundry package. And we will talk about that a little bit later.
00:02:32.364 - 00:03:28.932, Speaker B: One of the issues when you think about the fungible tokens, for instance, and not only that, but any interaction which is there with the contracts, there are many, many attack vectors. And the ideal outcome is ideal for the attacker is that they can do the. They can forge the recipient, for instance, which is very common, you know, many are sending out like some USDT or something, and they will try to phish you and basically forge the recipe. And at a certain moment that you will send those USDTs towards the address, or they can try to forge a contract, or they can try to forge the allowance. That's very common with the approvals. Right. This we discussed last year on some of the sessions and events, which were mostly focused on the blind sign, which I'm highly also involved in, do that, how to mitigate those things.
00:03:28.932 - 00:04:43.594, Speaker B: And there was a conclusion at the DCX PrAC regarding this topic. It was that any minor improvement in any of those steps that would mitigate some of those particular attack vectors, where you can see that there are many attack vectors over here. So any minor step which can be here that could like mitigate some of those, or avoid some of those attack vectors, that helps. And by the way, with introducing the account obstruction, we are like enlarging this scope of the attack vectors, because there will be many more, the larger surface for that. And specifically, there's a very new one, there's 7702, that people will be able to execute a bytecode on their eoa. So this is about one minor improvement, which we concluded that it's necessary. Just imagine the stable coins when you have major stablecoins like here is USDC, it's hard to guess which address is correct if it's, for instance, forged by the attacker, because the circle deploy that on these addresses here on Ethereum, ending like this and on test.
00:04:43.594 - 00:05:40.140, Speaker B: And address is also different. Then on the optimism, it's very different address, very different address. The same for the arbitram, again, different addresses. So you as a user, and neither technically the wallet could know that, but as a user, you cannot guess that this is USDC contract. So if the attacker just gives you some other address, you just go there because you don't care about those addresses. Even if you're like numberphile and you know, and you feel the numbers, you cannot guess whether the contact address is correct or not. So this is easy attack vector and should be easy to fix because it's only about deployment to the same addresses, right? And that's what we concluded with the checkstablecoin, that to deploy those checkstable coin contracts, that it would be necessary to deploy them on the same address on any EVM chain.
00:05:40.140 - 00:06:32.432, Speaker B: So whether it's on the Ethereum layer one, whether it's on arbitrum, optimism, polygon, gnosis, any other EVM chain where it's possible to do it. So we can forget about some ZK special roll ups that's not possible to do that there. But on the others, on most of the EVM chains, it's possible to deploy it on the same EVM address. And it helps not only to avoid and mitigate that attack vector, but it also helps DevOps. So those like mishaps that they devop just in the configuration, just, you know, something is wrongly typed there because there are different addresses and they forget that that was for the testnets and not for the production. If you have the same address to deploy to on each chain on the production, on the testnet, and you don't need, then you don't know, you don't do that mistake as DevOps. Right.
00:06:32.432 - 00:07:21.880, Speaker B: In the configurations. So there are a few more things. Why to have the same address, so known configuration issues. People are not confusing the testnet addresses and production addresses with sending funds that happened that they knew well, when we had those addresses of the USDC, they had the information about the address from the testnet and they used that address on the production and they send their production money or try to interact with that. And it was somewhat stupidly misused by the phishing spam recognition because the phishing contracts would have to be deployed on the different addresses. So when you have one address which is clear, then it's much more easy to recognize. Right.
00:07:21.880 - 00:08:07.590, Speaker B: And there are a few more things. This is mostly for user facing contracts like ERC 20s. So from fungible tokens, and it's very important for the registries. So like EIP 1820, which is used by 777. So the other, the technical norm for the, for the fungible token, but also for the account obstruction registry, it needs to be on the same address on each chain, otherwise you know, it has a problems. So for the registry, it's very important to have this capability. How it is being done now, now it's deploying that normally is that you need to manually take care about synchronizing nonsense.
00:08:07.590 - 00:08:43.632, Speaker B: And that's what explained here. I don't know how many of you are here like solidity robbers or that they would somehow know what this means. Yeah, for the rest of the guys over here, we will go in more deep now. But anyway, this is the most common way. And the point is that from the DevOps perspective, you need to carefully manage the nonce on each chain. So once you make the wrong transaction, you make the mistake, it's gone. You can never deploy it onto the same address.
00:08:43.632 - 00:09:41.154, Speaker B: Once you have a different nonce, you lose. So for that particular chain, you lost. And also the private key from the deploying account, you must not lose it. Once it got lost, you do not have a chance to deploy it on the same address because it's derived from the sender address and the sender nonce and it's happening. Projects often fail to maintain the same address on different blockchains that they support. So in 20 1718, I think the cre two of course, was created or proposed how that should have solved it, right, because creating a new can with associated codes at predictable address, so you can have like deterministic deployments. Well, it's important to understand that actually opcodes can only be called via smart contract.
00:09:41.154 - 00:10:12.614, Speaker B: So you cannot directly do the same as what you did with the creation of the contract, that you would say, okay, create two and created on this particular address. So that's not possible. And in that case, the create two factory was born. That's the next factory which is used mostly. That's the ENS guy and you can see the URL down there. It's also easy in the foundry. I don't know how many guys over here know the foundry framework or somehow use that.
00:10:12.614 - 00:10:30.436, Speaker B: Yeah, hardhat. Almost no one. Hardhat. So it's already shifted to foundry. Yes. Anyway, so in the foundry you can use it like this because it's like they support it a lot. The nuns are not reflected, so that's good.
00:10:30.436 - 00:11:08.834, Speaker B: That nonce disk is mitigated. However, it has some more issues. Some other issues. The first issue is whether the factory itself, the next factory is deployable on each chain and whether it already exists there. It exists on most of the chains, but at the moment, when I was researching that last year, I realized that there are a few chains where it is not deployed and even some chains where it is not possible to deploy it. Why? Because the deployment of nix factory is being done by the transaction which is pre signed. So you replay the transaction on each chain where you want to deploy it, that factory.
00:11:08.834 - 00:11:59.772, Speaker B: And if that chain has denies actually replaying of the transactions from pre signed transactions from the different chain, then you cannot do that. So it disallows the legacy transactions basically. And those chains are there. And there was quite a real example on that, that the account abstraction colleagues over here, they had to convince some of the chains to pre deploy this factory in order to be able to deploy their registry. So it's like headache basically. So that's one issue. The other issue is that address depends on the bytecode, you would say that's not that much problematic.
00:11:59.772 - 00:12:38.136, Speaker B: I create a smart contract, so there is a byte code and it's the same all the time. It's not true because once you compile it with a higher solidity version, then the bytecode changes. The very recent, well, recent it was last year. The significant change was jump from zero point 819 to 20 something. That was that 19 ls did not have the push zero code and 20 and higher or they compiled into push zero codes. So your bytecode changes quite significantly. And also when you change the comments in your code, then your bytecode changes.
00:12:38.136 - 00:13:16.160, Speaker B: Well, not the whole one, but the metadata part. So in fact, the bytecode changes. So the changes are normal there of the bytecode. And since the address is derived from the bytecode, then you lose. Then there is a third issue, and that's the out of gas situation or some problems when you execute a transaction. There is again, example, a living example on the chain, and that's gnosis safe. You will not be able to deploy that common address of the gnosis safe on gnosis chain because they tried it, they failed.
00:13:16.160 - 00:13:54.724, Speaker B: Out of gas done. So you lose for that. So basically, to remedy these issues, there was like an enormous wave of creating the factories that would mitigate it. And those are called create three factories. Some of them are like in the solmate, for instance. I'm not sure about open zeppelin, but definitely on soulmate and solidity they are there. And some common projects which work cross chain like layer zero XLR and the others they do have create three factories for themselves.
00:13:54.724 - 00:14:18.224, Speaker B: But then you depend on them if you use their factories. And when I was researching where we want to deploy other things, I realized, okay, cross checking the chains. They are here, here, here. They are not there. I was asking them, are you planning to deploy the factory there? Yeah, you know, our support engineers, blah, blah, blah and so on. Three months left and nothing. So you are depending on the third party, basically.
00:14:18.224 - 00:15:31.998, Speaker B: So the last year was not that much about creating this mechanism, but about having this mechanism available for anyone on almost any chain. But anyway, here's describe how this factory works. Basically, when you have eoa and you call the deploy method of the factory, the factory itself, it's always on the same address. So that's why it's crucial to have this factory on the same address on each chain. That factory calls the create two, which means that nonce risk is mitigated because it doesn't depend on your nonces from EOA and creates the temporary secondary factory with always the same bytecode because that's actually written here in this factory contract. So this mitigates that issue of changing the bytecode because it's always the same. So based on the salt which you provide, this temporary factory is always on the same address, depending on your salt, and then it calls create normal create opcode, which is then creating your final contract.
00:15:31.998 - 00:16:16.104, Speaker B: And there the nonce is always one, because once you create the contract in solidity, it receives the nonce as one. And at that time that bytecode of this becomes irrelevant. So that's like a two step or three step process. Basically it looks like this when you run it. So try to find like ten differences there. It's like some ZK game, right? Anyway, the point to show over here is that basically what you see, the numbers, those are the collateral of the bytecode of the final contract which you want to deploy, and it's being called twice. That's one of the disadvantages of that mechanism.
00:16:16.104 - 00:16:52.564, Speaker B: So for these create three factories, I created one, which is called yet another create three factory. A funny name, because I was like, any additional one and I realized that we need to create something that would be available for anyone. What is it good for? We already discussed, right, for those issues to mitigate. It's very good for the singleton contracts. You can see on this URL. So you can, if you are interested in it, you can go ahead and see it on GitHub. Anyway, it's written in half.
00:16:52.564 - 00:17:30.694, Speaker B: How many people over here knows? Half? Silent one. Ah, okay, opcodes. Awesome opcodes. The point about. Oh, is that you are actually working very tangibly with EvM. So what you write there is exactly done as what you designed. That's very different to solidity, because when you write the solidity, sometimes you are starting to fight about the gas optimization security practices on there.
00:17:30.694 - 00:18:39.718, Speaker B: So you basically fight with the compiler of the solidity. When you go on the deeper level and you use the opcodes or half, then you are really exactly, what you design is exactly executed. So that's why, that's the advantage. Of course there is the disadvantage. If you have some more complicated business logic, then it's not that much readable in the opcodes, but for the factories, for registries, for something that just stores the things and just execute some things, I would say I would prefer the half, because you would be much more certain what it does and how it does it. That's the reason why I created for the factory, because for your contract, when you want to deploy it, you want to make sure that factory that is deploying just does what it's supposed to do, that it doesn't like add any additional phishing, scamming some extra codes there to where it's your final contract which is on chain. Someone is like, it couldn't be possible.
00:18:39.718 - 00:19:36.294, Speaker B: Yes it could but yeah. Anyway, so that's one of the reasons. The second reason is that it's very light because you just need like 100 bytes. So if anyone wants to deploy this factory on any chain, even if it is very expensive chain to deploy 100 bytes is much cheaper than to deploy like twenty k. And the factory itself has the feature that in fact it either deploys that provided contract, your contract or reverts. So that issue of the gnosisafe is mitigated basically there are still issues and the deployment of the factory itself because I was researching the keyless deployments that we have those problems with those chains where you cannot replay those transactions and the consequences that some factories would not be able to exist everywhere. So we need to find some other way.
00:19:36.294 - 00:20:45.096, Speaker B: And I was desperately looking for some NPC or some other like cryptographic solution where the community would just somehow align on deployment on the different chains since basically it's public goods. So I thought that we could find something as a large community and then it could work there. I was researching that and meanwhile I was discussing with the other create three factory creators. And finally during Christmas time last year, 2023, Createx was deployed. And this is a contract deployer which has features like create two and create three. It's done by Pascal and Matt. So I would say very representative people of the Ethereum community and values and where we are able to discuss some key risks like the risk of loss of the deployer's private key and so on.
00:20:45.096 - 00:21:51.564, Speaker B: So all those issues which you mentioned and the risk at the beginning we were like discussing how they mitigate it and whether they have a fallback. So basically what they do is that they do have pre signed transactions which you can replay on those chains where it is allowed and for the cases where it is not allowed, they have their private keys and so they serve as some sort of the fallback. So basically for these like I don't know, 5%, 3% of the chains you are depending on them if it is not already deployed. So it's like a little bit like lesser risk than the other cases. But still the overall question is when you're at a project and you think I want to deploy anywhere and even in the future, and you really need to think about that risk, will I be able to deploy it there onto the same address as I did it on 60 other chains and behave accordingly. So that Createx is already deployed on 70 chains, on the production chains and some additional test network chains. So quite large network.
00:21:51.564 - 00:22:34.556, Speaker B: That was at the end of the year and since it was that, I would say it gets such momentum. I created a foundry package for easier deployment and testing with these Createx factories, which is easy like this. As you can see, you just import it in your script. For those guys who work with a foundry, there is a script, the foundry script, to make the deployments. So you just import this createx script and then you use it in the run part and it's setup that you save is createx. And in the run part you say that you want to compute the address of the deployment and then you just, just say deploy it here. And you just add like that.
00:22:34.556 - 00:23:23.684, Speaker B: You want to, sorry, you don't see it. It's above me that you want to design some solve, which is like protecting that for the front running and so on. So all these features are there and you just execute. And it has that feature that if you are trying to test it and it's not deployed on that test. So basically locally, when you do the local testing and you run the anvil, then it just like hs that create x factory there, so it detects etches, so it's easier to test and easier to deploy. Some issues remain, so there is still dependency for those few cases of some chains, I would say. And then the other case is that the factory bytecode is solidity.
00:23:23.684 - 00:24:02.406, Speaker B: Even though in solidity you write that you want to have it optimized, I would consider any output of the solidity is highly unoptimized. What you see there, how the solidity compared what it does, it's unbelievably unoptimized. So it's very heavy. I don't know, it might have twenty k the factory itself. So compare it like 20k towards 100 bytes, and it does almost the same for the user. So for me, as the czech stablecoin designer, I need yet to perfectly analyze this createx factory. You know, what it does and what are the outcomes.
00:24:02.406 - 00:24:37.132, Speaker B: I started to do that, I cannot show it now because I haven't finished yet. And the key one though is that create three is call it a heavy. That's what I was showing before that. It's like twice sending that bytecode on chain. So you are paying more of course during the deployment, but that's one time. But overall, for the whole community and the ecosystem, we are just doing this and putting more data on the storage. I mean the correlator storage.
00:24:37.132 - 00:25:32.234, Speaker B: So not really good. So my question at the time was, what if we could have precompile that would enable stateless runtime code etching onto the address which is derived from the runtime bytecode? Why? It would help. Just imagine that you had some sort of registries or something like that, or some sort of the other kind of factories, ideally the stateless factories. In that case, it doesn't matter who deploys that. It might be me, it might be you, it might be somewhere else in the middle of this room. It just would not matter. So why not to allow that and do it like without any conditions that someone could deploy particular contracts which we like carefully mentioned, make clear that this is stateless, that there is no initialization or ownership just by etching.
00:25:32.234 - 00:26:21.400, Speaker B: That would enable us to even like clone the contracts from the different chains towards the other chains when you want to just copy paste the whole solution from one chain to the other chain. So I realize that I am pretty much missing the sort of the code. Yes, I am at the end. So one more conclusion is do not use create three in Eips of the EOF which was mentioned there. But since we are already using the create three free terminology, then it's like clashing. Then the other announcement is effective starting June 30. For the old guys who are from Europe, the mica is becoming effective, and we already discussed that a few times somewhere.
00:26:21.400 - 00:26:28.204, Speaker B: And thank you. On the next bill fight, June 25, you are welcome to come and discuss some coats and beer.
00:26:29.204 - 00:26:29.944, Speaker C: Nice.
00:26:33.084 - 00:26:44.384, Speaker A: Okay, so given that we are running out of the time, perhaps only one question will be received. Otherwise you will have a chance to mingle outside and asking more questions. Anybody have a question?
00:26:46.204 - 00:26:48.332, Speaker B: Come on. At least you guys who coach, you.
00:26:48.348 - 00:26:50.852, Speaker A: Know, you can ask, what is Hof?
00:26:50.948 - 00:26:56.404, Speaker B: At least the huff guy or you.
00:26:57.864 - 00:27:02.504, Speaker C: I'll say I know huff in the sense that I'm familiar with it, not that I've used huff before.
00:27:02.664 - 00:27:03.400, Speaker B: So what?
00:27:03.512 - 00:27:07.104, Speaker C: I'm familiar with Huff, but I haven't used it personally before.
00:27:07.224 - 00:27:07.924, Speaker B: Yeah.
00:27:08.904 - 00:27:13.084, Speaker C: What do you think of Viper, for example, when compared to solidity?
00:27:14.824 - 00:27:50.434, Speaker B: I haven't researched the viper that much, even though I was among some people over here in this country were like setting up the python community, so I didn't tend to go that road. I would rather see some compiler there and making sure that at least on the compilation level, we can throw away some mistakes. I'm not sure whether Viper is really how it is being done there, so I cannot really literally answer on that. Yeah, at the end there is also a question. It could be. Fast question, fast answers. Two minutes.
00:27:51.694 - 00:27:54.074, Speaker A: So one last question perhaps.
00:27:55.454 - 00:27:56.758, Speaker B: Who. Where is it?
00:27:56.886 - 00:27:58.914, Speaker C: How does Huff compare to Yule?
00:27:59.534 - 00:28:00.446, Speaker B: Sorry, what?
00:28:00.590 - 00:28:02.806, Speaker C: How does Huff compare to Yule?
00:28:02.950 - 00:28:48.494, Speaker B: Ah, yeah, Yule is much more abstract and specifically, and there are two differences. When you use Yule, just itself. And when you use Yule in solidity. When you use Yule in solidity, then you have limitations and you cannot manipulate stack. When you have it in solidity, in the methods, when you use it itself, then you have many more options. But still, huff is literally, it's just like when you use the macros on the opcodes and it still tries to optimize some things. So you need to think how it compiles while you just write it as it is.
00:28:48.494 - 00:29:02.774, Speaker B: So I would say when you think about opcodes, then half is that it just gives you some convenience of the macros. And U is above from the abstraction perspective.
00:29:03.714 - 00:29:17.592, Speaker A: Very interesting. So if you have more questions, rather going to be around and then you can easily find them obviously with a mask. So please bother him asking more questions and give big applause to Radek.
00:29:17.768 - 00:29:18.424, Speaker B: Okay, thanks.
