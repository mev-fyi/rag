00:00:00.480 - 00:00:40.934, Speaker A: Okay, guys, in this talk, we are going to explain what an evolving curve is, what it's good for, and then we're going to do a demo of how they work. But first, let's pop over to the shell app and do a quick. Oh, yeah. So we're going to pop over. We're going to do a quick sneak peek right now. It's kind of like a sandwich demo. Okay, do you want to narrate this?
00:00:41.594 - 00:01:17.396, Speaker B: I'll full screen it. Yeah. Hi, everyone. So, for the demo, we are going to showcase how the price of an NFT in an nifty based amm decreases over time. So the example that we're taking in is a token, and token is our dominant select. So I'm just going to show you the current price, and then once the presentation ends, we will see how the price has decreased over time, and we'll also, like, dive into the code part and such things as well. Okay? Yeah.
00:01:17.396 - 00:01:50.364, Speaker B: Okay, so I'm just gonna select one here. So this is the shell interface, and I'm gonna select one to ten nft that I want to buy. Right. And the price I'm getting in, the price I'm getting in right now is 0.006,430. So now I'll head it over to give it back to what? Over how an evolving EMM works, and then we can come back how the price should decrease over time and go into the same.
00:02:00.704 - 00:02:39.574, Speaker A: How do I get this in presentation mode? Do you know how to get this in presentation mode? Okay, whatever. I'll just start. Yes, please. Okay, so let's start with some big questions. Big brain questions. What does launching a new NFT collection have in common with managing your uni v three lp position? Well, both can be solved with an evolving bonding curve.
00:02:41.914 - 00:02:43.614, Speaker B: Yeah, if you can do that.
00:02:45.474 - 00:03:09.354, Speaker A: All right, we're going to go over what an evolving bonding curve is, what it's good for, and how it works. I promise. Let's just do it like. Yeah. Yeah. Okay. So, quick review of amms.
00:03:09.354 - 00:03:49.774, Speaker A: The most well known amm is the constant product amm. This algorithm is good for low volume, high volatility token pairs. These curves never run out of reserves, and they always have liquidity regardless of the price. So the formula is x times y equals k. The product k of the two reserve assets is constant before and after every swap. So you can visualize the bonding curve like that. However, it has some big limitations.
00:03:49.774 - 00:04:37.080, Speaker A: First of all, poor capital utilization. So suppose a pool has 100 x tokens and 100 y tokens. Alice wants to swap ten x tokens with the pool. This swap will actually move the AMm's price by about 20%. Therefore, only small trades are viable, which means only a small percent of the AMm's capital can be used at any given time. So instead, we encourage you. Basically, you can concentrate your liquidity over a narrow price range, and instead of offering swaps at any rate, you can focus on swaps, for example, between $1 and $1.25,
00:04:37.080 - 00:05:13.434, Speaker A: or whatever you want to optimize for. Instead of using only 10% of the pools capital for the swap, you can now use almost 100% of the liquidity. Concentrated liquidity was uni V three's big innovation. Congratulations. We've just reinvented it. And by letting LP's concentrate liquidity in active price ranges, the AMM can actually achieve much higher capital utilization. However, prices don't stay constant, they move around.
00:05:13.434 - 00:05:44.162, Speaker A: So what do you do if the price changes? And that brings us to limitation number two. Well, one of the limitations is like, it's really difficult to hook up a laptop to a screen. Okay, we got it. No. Okay, I'll just keep going. So, in Univ. Two, liquidity was evenly spread across all possible prices, but with Univ.
00:05:44.162 - 00:06:15.134, Speaker A: Three lP's need to move their position as the price changes. This is difficult because it makes you vulnerable to Mev attacks, and also it's expensive. It costs gas every time you want to make an update. So there's a need for an Mev resistant way to update liquidity. Concentration, concentration. However, there is yet another limitation of static amms, like constant product and uni B three. I will pause here for a second.
00:06:15.134 - 00:06:46.154, Speaker A: Is everyone having a good conference? This always happens to me. It's probably my fault.
00:06:46.934 - 00:06:49.914, Speaker B: It should not be me.
00:07:18.434 - 00:07:53.414, Speaker A: Shall I just keep going? No stress. I appreciate you. Okay, so the third limitation, these static curves are bad for launching new tokens. When you launch a token, three things matter. The first is price discovery, so figuring out what a token is worth. The second is making sure that the launch is fixed to retail traders. And the third thing is, make it so that their project can raise capital efficiently.
00:07:53.414 - 00:08:22.110, Speaker A: Constant products like Univ and Univ. Three fail on all three counts. The implicit value of reserves in a constant product pool is split 50 50, so the value of the x tokens would equal the value of the y tokens. And at least according. Yeah, that's at least according to the AMm's internal prices. However, you won't know what the token is worth before you launch. And you don't.
00:08:22.110 - 00:08:30.990, Speaker A: We're assuming you don't have much east to pair with the token. So you end up starting your pool at token launch with like, a token that is grossly underpriced.
00:08:31.062 - 00:08:36.802, Speaker B: So it's a project to program. It's a problem with a projector.
00:08:36.958 - 00:09:27.004, Speaker A: It's the projector. It's not our fault. Yeah. Okay, where was I? God, you should see all the wires back here. Okay, so you end up starting your own pool at token launch with a token that is grossly underpriced. So if you only have ten k ETH, then all the supply of tokens in the pool are implicitly worth only ten k. Initially, MeV bots come along snipe the initial liquidity, causing prices to spike.
00:09:27.004 - 00:10:10.644, Speaker A: These bots turn around and dump on retail traders who want to support your project. The retail traders lose out because they can't buy the tokens at a fair price. So the project in the end loses out because they don't raise as much as they could. Maybe I could just show, like, my laptop. Our solution is called Proteus. Proteus is an AMM engine. Proteus solves all the three problems.
00:10:10.644 - 00:10:43.754, Speaker A: Okay, so how does it work? Proteus is an algorithm that can replicate any shape bonding curve. It works by deforming constant product curves to be bigger or smaller, depending on how we want to concentrate liquidity. So when we stretch the curve to be bigger, we're concentrating liquidity in that region. When we shrink the curve, we're reducing liquidity concentration in that region. Mathematically, this is equivalent to Univ. Three. So that's how it solves the capital utilization problem.
00:10:43.754 - 00:11:09.544, Speaker A: However, the implementation with Proteus is very different from Univ. Three. Um, there's an equation that I would show you. Um, okay, there's an equation that we'll get to. It's not a very difficult equation. I could read it to you. Okay.
00:11:09.544 - 00:11:55.092, Speaker A: Um, maybe you can share the slides. Yeah. Should I just send you the link? Is the Internet working? We're mega struggling with the Internet today, so. Well, how should I share the link with you? Okay. All right, guys, I'm Aliza Grox. Oh, that's a good idea. Okay, wait, but I don't know if I have the share link on my phone.
00:11:55.092 - 00:12:08.024, Speaker A: Okay, wait, hold on. I can do this. I mean, we could also, like, all huddle up around the laptop, you know?
00:12:11.064 - 00:12:11.804, Speaker B: Um.
00:12:30.144 - 00:13:55.244, Speaker A: Okay, well, where was I? I don't even remember. All right, guys, it's in the main chat. Prague defi summit. That's the right telegram chat right. This isn't live streaming, right?
00:14:00.144 - 00:14:00.884, Speaker B: What?
00:14:01.584 - 00:14:19.684, Speaker A: It's recorded. Okay. I don't remember where I was.
00:14:21.654 - 00:14:24.910, Speaker B: So in the meantime, how is your Internet connection in the meantime?
00:14:24.982 - 00:14:50.474, Speaker A: Prog defi summit. You got it. Okay. Add youth, Prague, 2023.
00:14:50.594 - 00:14:51.334, Speaker B: Yep.
00:14:52.234 - 00:15:42.654, Speaker A: Okay. Yeah. Awesome. I feel like we all deserve po ops for this. All right, where was I? As soon as I remember what slide I was on. Okay, maybe skip to slide number ten. What? Sorry.
00:15:42.654 - 00:16:08.086, Speaker A: Oh, the equation. Yeah. Let's go to the slide with the equation. Okay, so this is the equation for a Proteus curve. Using only one constant product slice, it's possible to have over ten slices. As you can see, the equation uses two parameters, a and b, to determine the shape of the curve. Oh, my God.
00:16:08.086 - 00:16:50.738, Speaker A: We're back. Okay, JK, if we want to change the shape of the curve, we change the values of a and b. Why is this a big deal? Recall that the shape of the bonding curve determines the liquidity concentration. So if we want to move our concentration along with market prices, we can simply adjust a and b. But wait, can't we already move our concentration with Univ. Three? The key is that Proteus lets us evolve the values of a and b continually. Every block.
00:16:50.738 - 00:17:22.390, Speaker A: Basically every block. The curve, and hence the liquidity concentration, will change slightly. Moving liquidity concentration through many small changes turns out to be mev resistant. In other words, it's a lot easier and cheaper to evolve your curve over time than to make big and sudden changes. Because every time there's a big sudden change in your amms behavior, the mev bots will smell an opportunity. Yeah, basically. Key point, Proteus lets Lp's evolve their liquidity concentration gradually.
00:17:22.390 - 00:17:54.860, Speaker A: Every block, which protects them from mev. Okay, let's talk about auctions. Now, what does any of this have to do with token launches auctions? Here's a wonderful definition from investopedia. An auction is a sale in which buyers compete for an asset by placing bids. Auctions are used when we have something where we aren't sure what the price is. We solicit bids from potential buyers. Whoever bids the most wins the auction.
00:17:54.860 - 00:18:33.714, Speaker A: Type relevant to this talk is a dutch auction in which the price of a token starts high and then decreases over time. The first person to bid will win the auction. This ensures that buyers are competing with each other, because if you wait too long for a lower price, someone else might buy the token before you do. We can, it turns out, use Proteus like an involving Proteus Amm to run a dot off auction. How does this work? So we start by concentrated liquidity at a high price range. Then we evolve our concentration, progressively lower. The standard dutch auction does exactly this, except it concentrates all the liquidity at a single price.
00:18:33.714 - 00:19:22.554, Speaker A: Why does this matter for token launches? So, if you recall the three objectives of a token launch, price discovery. So, figuring out what the token is worth, make it fair for retail traders, and efficiently raise capital. The AMM Dutch auction will ensure price discovery. That is the whole point of an auction, figuring out what buyers are willing to pay. Because we sell the tokens at the price buyers are willing to pay, we can ensure that the project doesn't leave too much money on the table when selling their token. And buying the token is as fair for retail traders as doing any swap with slippage protection. So all three objectives are accomplished.
00:19:22.554 - 00:20:17.986, Speaker A: Okay, so what about like, things like balancers, liquidity bootstrapping pools? Don't they accomplish the same thing? The big difference is that with Proteus, you can evolve with concentrated liquidity. So lbps are liquidity bootstrapping pools. They're super cool. In the first example of using an evolving EMM as a dutch auction, however, they're generalized versions of constant product. Therefore, they do not concentrate liquidity, but instead spread it out across a wide range of prices. So if a buyer tries to make a large purchase during the auction, they'll move the price a lot. With Proteus liquidity concentration capabilities, we can customize the auction parameters to result in a better experience for buyers, which is basically the same reason why Univ three was such an improvement on uni v.
00:20:17.986 - 00:20:52.400, Speaker A: Two. Okay, let's do a quick review. Evolving Proteus fixes the following three shortcomings. Improved capital utilization. So by concentrating liquidity, we can allocate our capital where it matters most, updating the liquidity concentration over time. Because Proteus can gradually evolve over time, so LP's can move their concentration without having to worry about mev attacks and launching new tokens. Proteus can be used to create a dutch auction, which leads to better price discovery.
00:20:52.400 - 00:21:06.260, Speaker A: And it's fair for retail traders who want to support the protocol. And now we'll show you a demo of how evolving Proteus works. So. Oh, wait, we have to open.
00:21:06.332 - 00:21:07.664, Speaker B: Oh, okay, sorry.
00:21:11.044 - 00:21:26.044, Speaker A: That's, you know, very important. Slide. So let's set up the scenario. We want to do an NFT. Yeah, basically we want to launch a new token, but we're scared of like, Mister Gensler. So we don't want to launch a governance token. We want to launch an NFT.
00:21:26.044 - 00:21:51.114, Speaker A: And we can use evolving Proteus actually to launch nfts by using an NFT. Amm. Let's discuss the behavior that we want. We want the NFT price to decrease over time, which is actually the scenario that was set up at the very beginning, before all the crazy stuff happened. So let's go back now.
00:21:51.194 - 00:21:51.802, Speaker B: Can you.
00:21:51.898 - 00:21:52.974, Speaker A: Yeah, sorry.
00:21:55.954 - 00:21:57.094, Speaker B: Chrome tab.
00:21:57.834 - 00:21:58.854, Speaker A: There we go.
00:21:59.354 - 00:22:23.706, Speaker B: Yeah, guys, so before we started the presentation, the price for one to ten NFT for this NFT pool was 0.006,430. Now let's see what the price is now. So it should have decreased over time. And now I'm just gonna see. Yeah, check. Yeah. So voila, the price has decreased from 0.006
00:22:23.706 - 00:23:08.734, Speaker B: to 0.005 without us updating the balances of the pool. So as, so basically we set up, set a duration through which the pools gonna evolve, the curve is gonna evolve, and then NFT starts at a higher price and it will decrease over time. And you can, like, we can configure the parameters whatever way we want. In this example, like Aliza mentioned, we configured it in such a way that the price of the NFT will decrease over time. Now I'm going to dive into the code part a bit and then just show how do we, what parameters that we used and how does the smart contract looks like. Can I go to the GitHub?
00:23:09.294 - 00:23:13.874, Speaker A: Oh, yeah. Okay.
00:23:16.974 - 00:23:50.688, Speaker B: Yes, I'm gonna. Yeah. So the prices that we, the prices that we used are from line 15 to 18. So as you can see, there are like two axis. Of course, the y axis asset is ETH. So that price, we have kept it as constant for the curve. But if you notice the x axis price that is decreasing over time, so the initial value that we use is pretty high, and then the final value that we have is low.
00:23:50.688 - 00:24:42.784, Speaker B: Right? So the idea is that the NFT price, which is on the NFT asset, which is on the x axis, that price should decrease over time. And that's how we configure. And the duration for evolving the pool that we've used is 8 hours in this case. So basically what this means is that the curve will evolve up till 8 hours from deployment, and after that the price is going to be constant. So after 8 hours, the price won't decrease, the price will go to a minimum and it will stay there. Now I'm just going to go into the code side of things. Yeah.
00:24:42.784 - 00:25:23.402, Speaker B: So if you see, this is our constructor, how our constructor looks like. These are the five parameters, like I mentioned, that we were using while we deployed the pool. So, if you notice, in this contract, we are not using any storage. So all of the computation, because of the dynamic curve, happens real time. So we are not storing anything on chain per se in this contract. So that's why we save on the gas costs as well, because we do the computation real time with the equation that Elisa mentioned before. So we have a library here, which is this where all the equations are defined in.
00:25:23.402 - 00:26:11.224, Speaker B: And if we. Yeah, if we go here. So you have the a and b values that we have mentioned here, which are derived again using the equation that we mentioned in the slides. So basically what this means is whenever any swap or any, you know, trade have any liquidity addition happens or withdrawals happen, we update, we calculate and compute a and b real time, which are the, which basically define how the curve evolves. And then basically you can do any operation, all the operations that are done on the pool basically modify a and b real time. And we use those values to identify what the curve looks like now. And then calculate the LP amounts or the amounts you get on swap accordingly.
00:26:11.224 - 00:27:01.618, Speaker B: So all these functions that you see swap or deposit, everything uses the a and b values internally and. Yeah, so everything uses a and b values, right, like I mentioned. And we determine the final point in the curve, the price, during that, you know, after the transaction ends, I mean, at the end, we determine the price or the position in the curve and the curve evolves accordingly. So this is how this devolving produce pull words. And like we mentioned before, this is only one slice. So we have only one curve, which evolves over time. And after that duration, it evolves over a duration, and after that it stays constant.
00:27:01.618 - 00:27:06.134, Speaker B: So yeah, this is evolving. Produce. Happy to answer any questions.
00:27:11.774 - 00:27:13.474, Speaker A: I think that's it, guys. Thanks.
00:27:25.174 - 00:27:31.234, Speaker B: Thank you both for this in depth session about Shaw Burko.
