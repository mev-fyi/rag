00:00:11.360 - 00:00:56.606, Speaker A: Oh, can y'all hear me? Okay, good. Well, my name is Pablo, I work at santiment, and today I'm going to talk about using on chain data to be smarter about liquidity provision in Uniswap v three. So, overview of Uniswap v three and its liquidity pools. So, Uniswap v three is an automated market maker. It allows trustless token swaps between swappers and the pool itself. With the new thing about v three is concentrated liquidity. So the concept of concentrated liquidity, I think, makes more sense if we look at uniswap v.
00:00:56.606 - 00:01:35.494, Speaker A: Two and what Uniswap v. Two did, or it still does. So in uniswap v two, liquidity providers provide liquidity to the whole spectrum of prices. What does that mean? So if you provide liquidity to a unisol v two pool, what you're doing, you provide liquidity to. In an ethusdt pool, for example, you're providing liquidity to the case of 0.01 usdteth and 100 million usdteth, which is great in the sense that every single price can be traded. But it also has some issues which we're going to look at here.
00:01:35.494 - 00:02:08.394, Speaker A: So the problem is that you assign liquidity to unlikely prices. So we can all agree that in the medium term, short term, ETH is not likely to be worth 0.01 USDT or 100 million USDT. So there's liquidity there and it's not getting used. And then where the price action is happening, there could be more liquidity. We could be using that liquidity from the edges and we're not using it. And that's pretty inefficient because that's making for more slippage.
00:02:08.394 - 00:02:51.630, Speaker A: So big swaps are moving the price more than they realistically should. So incomes concentrated liquidity, which fixes that. What concentrated liquidity does is when a liquidity provider provides liquidity, they have to set the price range for the liquidity. So going back to the exact same example, instead of providing liquidity essentially from zero to infinity, you could provide liquidity from 1500 to 2500. So now your liquidity is more concentrated. It's a lot more useful because it's a lot closer to the price action. And since you only make money when the price is within your range, then everybody sort of wants to provide liquidity where they think the price is going to be.
00:02:51.630 - 00:03:59.634, Speaker A: They want to provide liquidity close to price action. And that's great, because now there's a lot more liquidity at price action and there's less slippage. So everything's fixed, right? Not so much, because if we look at this entirely from a liquidity provider's point of view, it makes liquidity provision a lot more complicated because previously in v two, you pick the pool you're going to provide liquidity for, you provide liquidity and that's it. And now with V three you have to pick the pool and now you actually have to make the most important decision, which is within what price range do I provide liquidity? And that's not all that trivial. So first we're going to talk about some of the risks of providing liquidity, among them platform risk. So something could go wrong with the smart contracts, impermanent loss, maybe you provide tokens that throughout your liquidity provision lose value and then opportunity costs. Of course, maybe you could have done something better with your tokens, made more money.
00:03:59.634 - 00:04:50.304, Speaker A: So since there are risks in liquidity provision, then we kind of have to look at as an investment, right? There's got to be some return on these risks for it to be worth doing. Like nobody's going to do this just to be nice. So normally when you think about an investment, you know what the risks are, hopefully. And you say okay, how much return do I need to realistically want to take those risks? So you want to have an expected return to compare to these risks. And a big parameter, whenever you compute expected returns is generally a historical return. That's a really good starting point. So now we're going to look at how we would compute that for uniswap.
00:04:50.304 - 00:06:12.404, Speaker A: So for v two it's really simple, right, because the returns on these pools are just the fees that you're going to make from the swap. So mv two is simple because since everybody provides liquidity to the whole range, then whenever a swap happens, the fees for the swap just get distributed to everyone. So you just, yeah, take the fees divided by essentially the total amount of liquidity in the pool and well you get the return for that swap and that's really straightforward. But for V three it's a lot more complicated because not everyone provides liquidity for every swap and the liquidity is also not constant. So how do you compute that? So first of all, because not everyone provides liquidity to the whole range, the liquidity is not constant and you have to divide the pool right into different parts, which luckily uniswap already does that for us, ticks are, pools are divided into ticks where each tick is 0.01% higher price than the previous tick. So good, now we have ticks and if you think about it, each tick is sort of its own investment vehicle, where previously, in V two, the whole pool was one investment.
00:06:12.404 - 00:07:27.832, Speaker A: Now in V three, each tick is its own investment, because each tick could have its own liquidity, and swaps happen at specific ticks. So it's the tick that gets the fees on its liquidity, so itself, it's kind of its own unit. So, calculating tick returns, what we have to do is find for a swap what ticket took place at how much fees there was. We divided by the liquidity and the ticket, and now we get the returns for that swap, which seems pretty straightforward. But thing is that swaps don't always happen at single ticks. So you could have a swap that starts at tick zero and it ends at tick four. Right? And first of all, when we look at on chain data and we look at how we know what tick swaps take place at, we look at swap events, and the swap event only tells you which tick the swap finishes at, which is already a problem.
00:07:27.832 - 00:08:38.494, Speaker A: But let's say that we can look at previous swaps and we can infer that, well, if the previous swap finish at Tick Zero and this one's finished at tick four, then we know it started at zero and finished at four, and that's good. But the problem is that when a swap happens across multiple ticks, what's realistically happening is that there are several swaps taking place. So a swap comes in and the pool kind of looks at how much needs to be swapped and how much liquidity there's left going in that direction at this tick. And if the swap volume is bigger than the liquidity that's left at that tick, then it swaps as much liquidity as it's left at that tick, and then moves on to the next one, and so on and so forth. And because ticks, as we covered earlier, kind of vary in liquidity, then we don't know from the swap event how much of that swap happened at each of those ticks. So we don't know how to assign the fees of the swap to each tick, like how much goes to each tick. So that's where this concept of data is covering through back testing comes about.
00:08:38.494 - 00:09:44.072, Speaker A: The concept is we essentially take a new pool and we look at the on chain transactions that have happened with that pool, and we essentially recreate its history transaction by transaction. And what we're trying to do, essentially, is take snapshots of its state at every point in time. That way we always know how much liquidity is at every tick and then when swaps take place, if it's a multi tick swap, then we know how much liquidity is being used in each tick. We know what fees are going to each tick, and we can actually compute the tick returns for each swap, for each tick. So that has quite a few applications. First of all, we can do time series to turn on ticks, so we can split this pool into ticks. And we now know what the returns are on every swap.
00:09:44.072 - 00:10:32.424, Speaker A: We know when these swaps happen. So we can essentially, for any window, have a time series return on these ticks, which is great for getting a sense for what ticks are making money and how much money are they making. And then we, by reconstructing the state in that way, we essentially know how, like, what the liquidity is at every moment. So we know how the liquidity changes. We can kind of look at a time variance of the liquidity. We can compare it to swap volumes, and that can also give us a lot of intelligence as to how these pools behave, how the market behaves. And of course, it is a backtesting approach.
00:10:32.424 - 00:11:24.274, Speaker A: So another nice part about it is that we can use this exact same infrastructure to actually back test signal based investment ideas. So let's say that we use the first part of the pool history to analyze the data. We came up with some idea on how we can trade these pools. Well, now we have the rest of the history of the pool that we can actually, you know, ment the liquidity in the way that we think was a good idea, and we can run these real transactions over that time period and see how did we do. You know, we thought our expected return was going to be x. How far off was it? And was that good? So thank you. Here are some information to reach me if you want to talk.
00:11:32.374 - 00:11:42.934, Speaker B: So we have some time for questions. Thanks for the interesting talk. Are there any questions from the audience? One is up there.
00:11:50.874 - 00:11:51.346, Speaker A: Thanks.
00:11:51.410 - 00:12:07.638, Speaker C: Hey, Pavel, question on I guess, the ticks, are you rewarding? I guess the liquidity providers who invest in the ticks that are more further out from the price, greater than the ones who kind of.
00:12:07.826 - 00:12:08.054, Speaker A: Do.
00:12:08.054 - 00:12:13.994, Speaker C: You know what I'm trying to get to? Like, how are you creating an incentive system to reward the guys who take on the more risk?
00:12:14.574 - 00:12:44.474, Speaker A: Okay, so what happens is that whenever someone provides liquidity within a range, they're normally providing liquidity to several ticks, and it gets spread out pretty evenly. And when a swap happens at that tick, then the fees for that swap get distributed to everyone that provided liquidity to that tick. Proportional to the amount of liquidity that they provided.
00:12:49.574 - 00:12:56.078, Speaker C: What if I provide liquidity, though, in like a tick? That's like way outside the range of the price, right. And like, I'm like, on the edges.
00:12:56.126 - 00:13:19.540, Speaker A: There, you see that? Like, that's, that's why, that's why this data is useful, because you can kind of look at, so obviously you want to provide liquidity to take that get action. That's why this data is useful, because use this data and you kind of see that, you know, this is where you should be providing liquidity. If you're providing liquidity, like way out, way out here, then your returns can be zero. You're just, you know, permanent loss.
00:13:19.612 - 00:13:24.076, Speaker C: So there's going to be no action, I guess, outside the heavy action ticks.
00:13:24.140 - 00:13:26.384, Speaker A: Yeah, yeah, I mean, okay, cool. Absolutely.
00:13:30.104 - 00:13:32.672, Speaker B: I think there is another question there. Yes.
00:13:32.848 - 00:13:33.136, Speaker A: Yeah.
00:13:33.160 - 00:14:00.414, Speaker D: I was wondering if you actually do this backtesting, what kind of insight did you gain? Because I guess there's a certain trade off between rebalancing often and choosing smaller ranges, which costs more gas fees for all the rebalance actions and choosing broader ranges, but rebalancing less often. So I was wondering what was, like, the insights that you gained when doing these backtests.
00:14:02.234 - 00:14:52.804, Speaker A: I guess it depends on your strategy, right? Basically, that's the whole point of the backtest that you kind of see that if you were rebalancing a lot, like, basically, like, if you think about it, if you rebalance, you better have made enough money before the rebalance, because otherwise it wasn't worth doing. And that's where the back testing comes in, because maybe you come up with a strategy that on paper looks great and you think you crack the code, and then when you actually try it, just like the gas fees set you up. Yeah, you were in range all the time, so technically you were getting returns for absolutely every swap. You know, the gas fees for actually burning the liquidity and then re minting it just killed all your returns. Maybe you even lost money.
00:14:53.744 - 00:14:54.924, Speaker D: Okay, thanks.
00:14:57.704 - 00:15:06.544, Speaker B: Is there any other question? If not, then let's thank Pablo for the great speech. Let's thank him again.
