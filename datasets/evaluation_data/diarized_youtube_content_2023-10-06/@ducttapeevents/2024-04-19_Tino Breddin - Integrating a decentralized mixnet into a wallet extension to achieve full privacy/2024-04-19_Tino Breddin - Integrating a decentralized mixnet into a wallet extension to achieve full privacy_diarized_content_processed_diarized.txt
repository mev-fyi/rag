00:00:00.600 - 00:00:58.884, Speaker A: Good afternoon everybody, my name is Tino, I'm from Hopper, the Hopper project. At Hopper, we are building a decentralized mix net, which anybody can use to gain better ip privacy for the applications or as users specifically. But today I don't want to talk about the mixnet per se. As a core product we are building, but a product product we are building on top of it, which is called RPCH. So I'm going to show you how you can use RPCh to integrate our mixnet into a wallet. So, Adap, in order to gain better privacy as a user, when I'm talking about a wallet, in this specific case, the wallet is not necessarily the only use case, really. As I already mentioned, this applies what I show you today to any Dapp which is making RPC requests.
00:00:58.884 - 00:01:48.262, Speaker A: So when you follow along, or when you're developing an application in the web3 space, feel free to try this out and try to integrate it the same way I do today. It should work out of the box, and if it doesn't, you can contact us and we can take a look together. So, as I mentioned, I'm from Hopper, but I didn't really conceive this workshop. I only stand in today for my colleague Michal Jadach, who is product developer at HopR. He cannot be here today due to logistic reasons, so I took over. So this workshop is new for me as well, so we can kind of go through it together and see whether I break stuff. But Michael wasn't the only one who worked on all the stuff which is involved in here.
00:01:48.262 - 00:02:42.644, Speaker A: Also, my colleague Ronnie Estelos, who is part of our products team, has built very important parts of RPCH, the underlying infrastructure and the integrations into SDKs, which I'm going to show off today. So with RPCH, we try to make it as developer friendly as possible to gain that improved level of privacy on an application level. But there's obviously lots of complexity underneath, which we had to solve over the last 18 months or so, which we now are able to hide away. By the way, whenever you have questions asked, right away you can also follow along. I'm going to do quite a bit of coding. Okay, so for today's workshop, we chose the wallet encryption. Some of you might already know it.
00:02:42.644 - 00:04:06.904, Speaker A: Encrypt is a fairly commonly used web wallet, so it's running in the web browser as an extension, which makes it very suitable for the integration I'm trying to do here, because we have a JavaScript SDK which can be directly used by the wallet without much integration hassle. So the wallet itself is open source, so we can directly use the source code, which makes it also obviously very easy for us to integrate otherwise. We already did some other wallet integrations as proof of concepts for closed source wallets, but then obviously we have to get in touch and work together with the development teams of those wallets. So for this presentation, it's really cool to have an open source wallet as a target. But before we get started, you have to understand what the wallet integration, the integration of RPC into encrypt is actually meant to achieve, because somehow you need to measure the level of success of the integration. And for that we are going to use DErp, which is a tool which we created like two years ago or so when we first started looking into RPC privacy, RPC endpoint privacy for users. And DErP is able to show you the calls your wallet is making while you're using it.
00:04:06.904 - 00:05:06.984, Speaker A: So you can see that your wallet is getting balance information or trying to send transactions and so on to the endpoint. And then obviously at the end, once we are done with the integration, you should not see that anymore, because as I mentioned already, we want to achieve IP privacy. So DErp shouldn't see anymore that my IP is making all of those requests. This should be totally hidden away from DErp, while I can still use the wallet, as usual. So let me just quickly show you Derp. So you can also use that easily yourself while you're doing some normal testing or if you just want to see how your wallet behaves, because obviously every wallet is different. Some wallets make very small amounts of RPC requests, some wallets make lots of requests, and this influences obviously the level of privacy you might gain.
00:05:06.984 - 00:06:21.144, Speaker A: So Derp is really easy to set up. I'm going to skip over a little bit of the pros here, but what you ultimately need to do in your wallet, you just have to take for whatever network you want to use, DIrP for the RPC URL, and copy it into your wallet configuration for that particular network. And then all the requests will go through Derp, and Derp will relay it to the actual RPC endpoint later and therefore be able to show you what requests are being made. So in that sense, it's kind of a transparent proxy for your RPC endpoint requests. So in order to get started, let me first, let me uninstall encryption so we can start with a clean slate. It doesn't really help. Everything is set up already.
00:06:21.144 - 00:07:29.514, Speaker A: Okay, so whenever we look at integrations you obviously have to understand the target. For some of you who want to do that integration for an application, you know, it might be easier because you already know your own application, but then also you have to look at the documentation for RPCh. We try to make it really easy to integrate RPCh by targeting the commonly used client libraries for RPC requests in the JavaScript space or typescript. So there's integrations for obviously vanilla JavaScript that works out of the box. But ethers Vmwagme is very new web3 ETH is what we are going to look at today because it's partly used by Encrypt and also JSON RPC 2.0 is also used by encrypt. So we also touch that.
00:07:29.514 - 00:08:36.854, Speaker A: So we have examples for all of these, which are most of the time actually looking at RPC, at wallets copy paste example. So you can very easily go from a normal wallet to an RBC enabled wallet within half an hour or so. It's very important to note though that this doesn't support websocket. Right? Some wallets use Websocket as their default interface to an RPC endpoint. RPCh only supports HTTP for now because it has to route all of that information, all of the requests, through a plethora of nodes within the mix net. And having a stateful Websocket connection through, let's say five intermediary nodes is for one very difficult to do from an architecture perspective, and also has very strong privacy implications. So we opted to support HTTP only initially, and in the future we might look at supporting WebSocket, but it's not the case yet.
00:08:36.854 - 00:10:01.994, Speaker A: Okay, so obviously we want to extend encrypt, so we have to clone encrypt to get the code locally and set up and build it. So that's what I'm going to do next. And I did already a little bit of preparation so I don't have to download the entire Internet when I do this. So Ancrep being a JavaScript based project, you always have to do yarn first to get node modules set up, which I did before. So this is normally taking most of the time, and then you just build the libraries normally on a clean clone. This is going to take a lot of time, but I did that just before the workshop, so this is pretty fast. So now that we have the code, we actually have to identify how we are going to integrate RPCh, which integration is needed, which client library is being used by the wallet.
00:10:01.994 - 00:11:01.656, Speaker A: So in encrypt's case, this is, as I mentioned, web3 ETH, and we already have one integration ready for that. So that's easy to do for encrypt. If that weren't the case, we would have to do a lot more work initially to get all the plumbing in place. But here we are, good to go. So we just have to look for all of the occurrences of where that library is being used so we can figure out where RPC calls are being made from the wallet. And here you can already see that the wallet is using Websocket, possibly as default or optionally. So in that case we always have to make sure that it's also switched over to HTTP when we integrate RPCH and that there's no reliance on Websocket specific features.
00:11:01.656 - 00:11:53.404, Speaker A: Normally when a wallet uses web3 or ethers or these, these client libraries, this is okay because they abstract a lot of this away already. So to the wallet it all looks the same. Websocket is just a little bit better performing, but for RPCH integration it should be fine. So as I mentioned, we want to verify that our integration is working by using DIRP. So what we're going to do first is actually not integrate RPCH, but we will integrate Derp as the default endpoint into encrypt. Then we can verify that the endpoint calls are being made and we can see them actually. And then we're going to integrate RpCh.
00:11:53.404 - 00:13:13.024, Speaker A: And at the end we shouldn't see any calls anymore because they are hidden away. So let's do that. Okay, first I'm going to build for Chrome because I will show all of this working in Chrome. So now we just have to wait for the extension build. Then I'm going to obviously load the extension into Chrome and then show that Derp is not able to pick up anything because I have not yet integrated Derp. So we go step by step. Okay, so because I'm lazy, I'm just going to use some pre made password.
00:13:13.024 - 00:14:46.174, Speaker A: I can copy and paste all the time, don't use that account, I'm going to dump it afterwards. So we have encrypt setup. Okay, so I have dirp loaded in my web browser and if Derp would be able to pick anything up, it would be shown here. Right. So this is the log of requests being made which Dirp sees. And if I just use my wallet, there's nothing happening. Derp is not able to pick up anything, which is what I would expect because I didn't link it yet.
00:14:46.174 - 00:15:57.634, Speaker A: So what we're going to do now is we're going to configure the wallet to use Derp. In encrypt's case, we have to find the provider configuration for Ethereum. And in that configuration you have the endpoint set up as a websocket endpoint to Mewapi IO. So probably some internal internally hosted endpoint. And instead of that we are just going to point to Derp and Derp is going to relay the requests for us. Okay, rebuilding. And then I'm going to reload the wallet.
00:15:57.634 - 00:17:08.964, Speaker A: And we should actually see requests going through DIRP. That will be step number one in making sure that we can later verify that our integration works. Okay, billing is done. We can reload our wallet code, authenticate again. Okay, so here you can already see encrypt made its first request, right? So we can see one log entry. So not much actually happened yet. It just tried to load the balance for my particular account in the wallet, which is great, exactly what I expected.
00:17:08.964 - 00:18:19.264, Speaker A: Now all the requests being made by Encrypt for Ethereum mainnet will show up here so that we can verify later that RPCH works. And important to note, obviously if I go to Polygon, Polkadot, all the other chains, Derp is not going to show anything because we didn't configure the encrypt to do so. Right. Encrypt is still using their default RPC endpoints for those chains. But if we go to Ethereum, this is what we actually did configure, then Derp is getting the requests. Okay, this is what I already did, so we can glance over that. Quick question, who here has actually developed extension before for the web browser? Cool.
00:18:19.264 - 00:19:28.824, Speaker A: One, do you know this trick which my colleague actually referred to here because it was new to me, that you can open the extension in a new tab and that way have the extension being available all the time. You did not. Great. Then we just show this because it's actually quite useful indeed. So you just go in here because it's obviously always difficult to debug an extension view because later we want to look at the network tab and this is very easy to do here. That just doesn't show the network part. Okay, now it does.
00:19:28.824 - 00:20:43.344, Speaker A: Cool. All right, so let's move on. Now the main piece of work starts, we want to integrate RPCh. So as I mentioned, we want to replace the direct use of web3 ETH with an RPCH adapter such that we don't have to change too much code in encrypt itself, so it should be really easy for me as a developer. But all of the requests should go through the decentralized mix net instead of directly to the RPC endpoint. So in order to do that we obviously first have to install RPCh SDK and then we can use it in our encrypt wallet. So the RPCH packages are available under the RPCH organization on NPM.
00:20:43.344 - 00:22:06.844, Speaker A: Just have to check what else we need. While we are waiting. I'm going to open the RBCH docs for reference, which is not working. Yeah, that was the wrong domain, right? So in the documentation you can also find lots of background information on the architecture of RBCH, which I'm not going to cover today. So if you are interested in all of that, feel free to look at the documentation or talk to me afterwards. I'm happy to tell you more, but today we are going to integrate a web3 wallet. So basically what we are going to do is very similar to what is outlined here because most of the stuff is copy paste and we just have to adapt a little bit to how encrypt initializes their RPC endpoint.
00:22:06.844 - 00:23:07.184, Speaker A: So in order to this is a little bit now getting into code quality because we don't just want to add 50 or 100 lines of code into the encrypt codebase. So reviews would be really hard for the encrypt developers. So that's why we're going to create separate files which will hold the new code and then just refer to those. And this will make the life of the reviewer easier. You don't have to do it that way. This is purely to be nicer when submitting a prime because what we are going to do in the end, we are going to submit a pr to encrypt. Maybe they are going to merge it or not, but you can always just add everything into one file if you wanted to.
00:23:07.184 - 00:24:40.498, Speaker A: So what we need is actually in Sourcelib, a new library and an index file in there. And this is what I mentioned. All we have to do initially is just copy the example from our documentation into the encrypt into our new file and then we can adapt it as needed. It. Oh my goodness, that copying didn't work so nicely at least. Yeah, all the comments, that's not a problem. Actually wrote it out beforehand.
00:24:40.498 - 00:25:38.124, Speaker A: So we're just going to copy it that way. Okay, cool. So we have all the necessary setup. Let me just quickly go through this file to give you a sense of what we are doing here, because obviously it's more than just five lines of code. So first we are getting our SDK component. We already installed it, so that's easy to do. We have to also use the web3 core abstract provider, because ultimately we want to call into, into that or expose the same API.
00:25:38.124 - 00:26:19.184, Speaker A: We have some checks for supported RPC providers. So here you can already see if an RPC provider uses websocket. We are just going to use it as is. But if we are using an RPC provider which is HTTP based, we can go through RPCh. You could make this less dynamic or a lot more obvious than this setup. This is purely as an example. Then we have to load a couple of configuration variables for RPCh.
00:26:19.184 - 00:26:59.806, Speaker A: The first one is a secret token. In order to use RPCh you have to have a token which identifies you. So you have quote quota to be able to send messages through the mixnet. I'm going to show you in a little bit how that works. Then you have to set up where the endpoint of the platform is of the RPCH platform you want to use, which is called the Discovery platform. I'm also going to show that, and then you have to tell RPCh how many hops it actually wants to make in the mixnet. And this is an important one.
00:26:59.806 - 00:27:59.002, Speaker A: So a mixnet is set up in a way where the more hops you make, so the more intermediary nodes you have and you send your packets over, the better your privacy is supposed to be. So that's a very simple explanation. Obviously there's lots of factors which play a role in there, but for simplicity purposes, you could say more hops equals better privacy. So in order to start out with our integration, we first want to test fast instead of having the best privacy ever, because even the most simple configuration here will be better than what we had before. So that's why we use the configuration force zerohop, which tells RPCH to only use the start and the end nodes in the mix net and don't have an intermediary node. So that means. Hold on.
00:27:59.002 - 00:29:16.584, Speaker A: That means that compared to your previous setup, you already have two extra hop like extra nodes, right? So the privacy gained is already better. For a production setup, you might want to have like two or three hops. So then you could change this so it actually uses even more intermediary nodes. Go ahead. I'm not sure you can compare it that way. So obviously within the mix net, on the peer to peer level, we're using gossip like protocols to share information. What happens in RPCH's case is RPCH sends a request to a so called entry node in the network.
00:29:16.584 - 00:30:18.312, Speaker A: So the entry node is the node which can talk RPC to the outside world. So no, see the Ethereum RPC protocol, but can also talk the hopper protocol to hopper nodes. So it will actually then turn that HTTP request into hopper packets, and it will use discovery mechanism for the path in order to send packets through the network. So every packet is actually going over a different set of nodes, ultimately depending on dynamic internal and time based parameters. So you cannot really tell in advance which path for which packet is going to be taken. So that's where the privacy part comes in. You have one HTTP request which is going to turn into, let's say, ten packets, and these ten packets will then at response time figure out the path which is not equal for each packet through the network.
00:30:18.312 - 00:31:20.004, Speaker A: They will end up in different order at the exit node. The exit node will then put it into the right order again and recreate the HTTP requests, and then actually execute it to the RPC endpoint. So that way anybody in between, any node in between which is relaying a single packet, only sees where that packet's coming from, not the originator, and also doesn't see where the other packets are going and doesn't even know that there are ten packets. It's only concerned about that single packet, I guess, the end point or the last node to then talk to another protocol that is not RPC. Sure. Yeah, you could link at that point, you could daisy chain it with VPN, the Tor network. Exactly.
00:31:20.004 - 00:32:23.426, Speaker A: Yeah, you can. At that point, as long as your exit node supports whatever you want to connect to, you could daisy chain that again and do something else. Yeah. All right, so obviously some general check that the secret token is provided, the options we set for our, for RPCH component, and then we set up a single class which is then being used later to send RPCH requests. And this is very simple too. You pass in the options you have, or expose a send function which is taking the request parameters, it checks that the SDK is set up. If it is set up, I can already send the request.
00:32:23.426 - 00:33:34.404, Speaker A: If it isn't set up, I have to initialize it for the first time and that's it. So a singleton, being a singleton, has to be initialized once, and then from there on I can use it for all my requests. And at that point RPCH itself is usable and ready to go, but not yet usable by the wallet because the wallet expects something like an abstract provider. This is what encrypt uses. So that's why we now have to hook in RPCH into that API. And we set up the RPCH provider code which implements that interface abstract provider which is being used by encrypt. And what it does is ultimately whenever a function, sorry, a RPC request is sent out through the sendasync function, it will invoke the RPCH singleton send instead of sending directly or making a HTTP request directly using fetch or the like.
00:33:34.404 - 00:34:48.044, Speaker A: So this way we get RPCh hooked into encrypt very easily, and then there's a little bit of error handling involved when the request fails. So comparatively easy, a little bit verbose for this example, but usable out of the box. Any questions so far? Okay, just maybe quick question, more on the comments. Very good question. Let me postpone this for five minutes, because we're getting to a point where I can answer that more easily. Okay, so we copied the relevant code and now we actually getting to the point where we have to generate a secret token. I mentioned already we have to configure it.
00:34:48.044 - 00:35:35.972, Speaker A: So we have to get it first. And that's what you do on our developer site, dgen dot rpch.net, where you can basically get a particular packet which gives you a particular number of RPCH calls you can make in a certain timeframe. And this is what you kind of refer to from a developer's perspective. You care about RPC requests being made through your app or wallet. So then you just get an account here and generate the code and then you can use that right away. Now internally though, an RPCH request is not packed through the mixnet.
00:35:35.972 - 00:36:13.984, Speaker A: Right. An RPCH request is basically an HTTP request being sent to an RPC endpoint, which could end up being 100 packets. So in the mixnet there is a different incentivization going on. You actually pay per packet and what we do in the infrastructure side. So on the back end of RBCH, this is where we then translate. Whatever is being paid through these accounts is being used to fund the mix net so that the mix net will then relay the packets as needed. Right.
00:36:13.984 - 00:37:44.144, Speaker A: For a wallet, let's say there's an incentive to integrate that natively. So then the wallet would have an account and pay that if you have a DaP, you would create an account yourself and use it that way. Say again as a Dapp developer or on the mix net as a Dapp developer. For now it's a recurring payment through a payment processing platform, but we are looking to integrate it more tightly with native web3, obviously, so you could have better integration and more automation through that. Yeah, but for our example here, we've created a code, so you are free to use that code ETH Zurich, which I'm going to do now because I need now I'm on the wrong side. So let's see, need to do that in our browser here. Yes.
00:37:44.144 - 00:38:46.800, Speaker A: I'm just going to blind sign everything today. Okay? Yeah, so through this code I get half a year of free rPCH usage. So depending on my integration, this could be a lot. And once I redeemed that one, I can generate as many secret tokens as I want to. So a secret token obviously would be good to be used only for one particular app, but you could also share it through apps. There's additional information on this dashboard. If you as a developer want to run RPCH and debug more deeply how your app is using it, then you can also run the RPCH server locally through Docker.
00:38:46.800 - 00:39:54.954, Speaker A: And obviously you might want to use various networks. So we have some examples here which you can easily add to your wallet so you don't have to figure out the parameters all the time yourself if you are using it the way we do. Now, in order to replace Ethereum mainnet usage, we also have baked in mev protection on Ethereum mainnet, so this you can enable disable also here so that you can, you know, if you don't need it, use it without it, and if you need it, you can use it out of the box. So I'm just going to use a token and I'm lazy, so I'm just going to put it right into the source code. Yeah, feel free to use the same code. It's valid as of now. We might disable it the next couple of days.
00:39:54.954 - 00:40:46.804, Speaker A: So anybody who's here and has used it is free to leverage half a year of RPCH usage. Say again? It's really easy to remember actually, but yeah. Okay, you can ask me later as well. All right, so I already mentioned it. The secret token I put in clear text. We are using the default platform, so we don't care too much about that parameter and we set zero hop to true. This is what you can set to false later, but we will set it to true for presentation purposes.
00:40:46.804 - 00:41:57.354, Speaker A: Okay, so now we have to check where web3 e is being used, right? And figure out all the places and then actually replace. And this is the beauty of our integration. Ultimately in all the other code, you just have to replace two lines, or replace one line, add another one. You have to import the getsupported RPC provider function, and you have to replace the direct use of this node on web3 ETH with a wrapper which uses that function. And this one will figure out that it's going to use RPCH or not, depending on whether RPCH is supported or not. So in all of the occurrences of web3 ETH, we just change this particular line and we are done. So once you've done the setup with the copy paste and you created your configuration, the rest is comparatively simple to do.
00:41:57.354 - 00:43:35.950, Speaker A: Let me just do that right away. I just have to figure out what is it called? ETH, hardly copy pastable. Okay, so this one supported RPC provider. Yes. So that's line number one and now and number two. So we do this in like 123456 files and we should be good to go. So let me just do that.
00:43:35.950 - 00:45:54.904, Speaker A: This was API E 35 U 35. Next one, send transaction index view. This must have been the wrong one. Verify transaction index view. And just look at some nodes here. Ethereum Uis and transactions. Okay, so we did this one, this one sent transaction verify transaction index field.
00:45:54.904 - 00:47:36.284, Speaker A: Okay, action views swap index UI. Okay, so let's see whether I got all of these building again. So what we did now is we replaced all of the normal RPC endpoint uses with RPCH enabled usage. So that the simple getbalance call should actually not be shown anymore in Derp. Once we load all of this, it's being built. I can load it, we can test it. Durp should not see a getbalance call anymore.
00:47:36.284 - 00:48:48.524, Speaker A: Okay. Right. So let's see where the arrow is. Super provider. Hmm. Anybody able to fix that fast? Let's see, what did we do wrong here? Abstract provider does not work like that. Maybe you could use an older version.
00:48:48.524 - 00:50:19.632, Speaker A: Yeah, it might be a version problem. So let's see, I'm going to check, I'm going to cheat and check the pr I tested actually and see whether that works or what we did differently in here because we're running out of time anyway. Okay, so this pr is doing the exact same thing, which we just did, copy pasted that one big file and replaced all of the uses. So what I'm going to do is I'm going to load that pr so I can show you how that ultimately is going to work before I'm running out of time. Okay. Might have to download something. As you said, different versions could be the problem, but that BR did exactly the same thing.
00:50:19.632 - 00:51:44.072, Speaker A: So you can basically, as you can see, it just replaced the various uses of web3 ETH. Okay, that compiles great. So might be different versions. It. All right, compilation worked. I can reload. Actually, I might have to, since it probably deleted the disk folder, I might have to reinstall my wallet.
00:51:44.072 - 00:52:45.864, Speaker A: Let me quickly do that. Missing RPCH secret token. Right, so the secret token we already generated. Okay, racing against time. So two more minutes. I'm not sure we're going to make it. Okay.
00:52:45.864 - 00:54:46.024, Speaker A: Oh, is it only coffee break? Okay, cool. Let's see whether we can make it. Reloading. Okay, that worked. So creating the wallet again. Okay, so as we can see, the wallet is working. It can fetch actually my balance, but Derp is not showing anything.
00:54:46.024 - 00:55:33.484, Speaker A: So our initial test works. Durp cannot see my IP anymore, which I'm using. The RPC request is funneled through RPCH, so the IP ultimately will be different. And therefore, even though I have Derp set up here, it cannot see anything and I'm fully or more private than I was before. So it's transparently using RPCh. And because we didn't configure it for Polkadot or Polygon, Derp wouldn't show anything in here anyway. But the requests, and that's important are also going through RPCh what the wallet is doing.
00:55:33.484 - 00:56:30.070, Speaker A: It's basically telling RPCh, this is my endpoint polkadot API.com. Please use that when you make the request, but send everything through the mixnet first to achieve better privacy. And that's it. So if you want to go and take this even further, to conclude, there's even more things you can do in the wallet, because most wallets actually do more requests than the simple RPC requests. And encrypt is no different. So in order to complete all of this, you would have to replace a couple more uses of of RPC endpoint API usage, but it's again, very similar. Copy paste examples are available, and then ultimately you'd be done.
00:56:30.070 - 00:57:11.016, Speaker A: You could test, and that's it. With that, I want to conclude the little adaptation of encrypt to use RPCh. If you want to do this yourself on another dapp, feel free to go. As I mentioned on djen dot rpch.net and get your pass durp. I always refer people to Derp because it's a really useful utility if you want to check if a dapp or a wallet is doing lots of requests, and especially which requests it's making and our main website. If you're interested in what we do with the decentralized mixnet, the Hoppernet, check out hoppernet.org
00:57:11.016 - 00:57:43.984, Speaker A: and there's plenty of information. And you can also obviously get in touch with us on Telegram and the Hoppernet channel, or with me directly via email. Tinohoppernet.org dot thanks. Thank you Tino. Any questions? Yes, have integration. I would like my wallets to do this by default.
00:57:43.984 - 00:58:35.034, Speaker A: That's a really good question. I mean, obviously from a business perspective we want that as well. So we actually did already quite a few integrations for a couple of wallets where we are then talking to the wallet development teams on how best to integrate it in the UI, because it's always two things you have to consider. One is the actual code integration, which we did here, which for most of the wallets is more or less simple. But then every wallet has a different UI and you want to expose it to the user also, right? Because it's such a valuable feature and it's being paid for. So some users might not want it all the time. Some users might want it all the time on or off.
00:58:35.034 - 00:59:46.644, Speaker A: So then the development teams go in and do their UI research and try to figure out where to put the toggle for it. So yes, hopefully we can get that integrated into a few wallets by default. The PRS already for the integration itself already submitted to some upstream wallets, but nothing has integrated it out of the box yet. Yeah, can you repeat that a little bit louder? Is the guide for all the iterations? Yes, for encrypt specifically, I'm not sure, is there a way to share slides? But if not you just ping me and I can send you the slides. But all this really did is figure out how to build encrypt. So yarn build all and yarn build chrome and then follow the guide for web3 integration on our documentation here. Yeah, just a question.
00:59:46.644 - 01:01:09.776, Speaker A: Are you guys actually running like web3 providers like the nodes themselves, or are you just having to match them and then you're connecting to someone else? Really good question. We do run some endpoints ourselves, but for RPCH this is irrelevant because actually what is happening, and I mentioned this only briefly at the end, is the wallet already has an RPC endpoint, right? Pre configured for most of the chains for the major networks. So the wallet basically when calling RBCH, gives it a parameter which is called RPC endpoint, where it passes its own endpoint and then this will be passed through. Obviously encrypted and chucked up through the mixnet so that at the end the call can still be made to the right endpoint. Right. So if you have a super performant, you know, high capacity endpoint, that one is still going to be used or, you know, so all of this is basically transparently tunneled through the mixnap. Any more questions? All right, yeah.
01:01:09.776 - 01:01:28.024, Speaker A: If you are interested in the code bits, you can talk to me afterwards. I'm happy to show you some more details. Otherwise, feel free to get in touch and test out RPCH. We are always happy if we get feedback on how we can improve the developer experience. Specifically.
