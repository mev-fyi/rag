00:00:00.520 - 00:00:57.914, Speaker A: So hello everyone. My name is Mattia, so I go by the nickname Yorix evolve on Twitter. Just a quick intro about myself. I was previously at Makerdao working on the Starknet core unit for basically the past year, which I recently left to focus my whole time building pragma, which is decentralized oracle solution built on Starknet natively, and that will be extended to multi chains in the future. So today I'm basically going to talk about how can you make an oracle that is actually provable, meaning that you remove a bunch of trust assumptions that current oracles have, especially how you aggregate the data. So let's jump into it. First, a little disclaimer about ZK proofs against validity proofs.
00:00:57.914 - 00:01:54.640, Speaker A: Most people are often confusing in talking about ZK proof, when in reality most of the roll ups and the tech is validity proof. And there are a few exceptions. Remarkably, Astec that really uses ZK proof, so they use the privacy part of these proofs. But when what we care the most about actually is the succinctness of the proof, and that's what we'll be leveraging to build this some to remove all the trust assumptions in the oracle system. Okay, so now that this first disclaimer is done, let's talk about the oracle problem. So an oracle, as most of you might know, is a way for you to put off chain data on chain and make sure that smart contracts are able to query and access that offshore data. So it could be mostly like financial data.
00:01:54.640 - 00:03:01.404, Speaker A: So liquidity data, prices of assets, order book def and all kinds of data. And you could go even further and have these data feeds or more complex aggregation of data. But yeah, the question is, how do you put this on chain without sacrifying a few properties? So the first one is the trustlessness. You don't want that system to add a layer of trust assumption to your DApp, which might already have a few, and especially like the smart contract risk. You want your oracle to be unstoppable, you don't want it to stop at some point and it's not providing any data to the depth anymore, and it could lead to a bunch of pretty bad issues. And finally, ideally, you want this oracle to be transparent. So you would want to know what's happening at that network and not it being like a black box, which is pretty much the case right now due to the current technology and the fact that everything is built as an off chain network.
00:03:01.404 - 00:03:58.954, Speaker A: And actually, we have a pretty good solution to the three of these properties. And it's a blockchain so in the past, there have been many experimentation to build these off chain networks, but it's hard to have these three properties, whereas blockchains give you these properties out of the box. So it kind of makes sense when you think about it. You have your oracle network built as a blockchain, and we will see how Starknet, Starx, and a few other cool tools make this actually possible. Okay, so let's first talk a bit about Cairo. If you're not familiar with Cairo, Cairo is a programming language invented by Starkware, which is meant to make it easy for you to write programs that are actually provable. So by provable, we mean that you, as a developer, you write your program.
00:03:58.954 - 00:04:51.648, Speaker A: So it's a Turing complete language. You can write anything, basically. And then when this program is executed, it generates a trace, a trace which you can send to some prover, and the prover will be able to generate the stark proof out of it. So Chiro stands for basically their cpu. So, for a bit of history before Cairo, the Starcore team used to write these polynomials by hand to, for instance, DyDx or these kind of applications. But at some point they wanted to have something general and not having to restart from scratch every time they want to build some kind of new provable application. And that's where Carol was born, and it's now getting pretty mature with Carol one and a bunch of people using it.
00:04:51.648 - 00:05:53.866, Speaker A: And. Yeah, so a good example we like to take is, so with Cairo, you can write your program, and you can actually do a lot of computation in your program. If you're used to building any depth, you know that you be careful about the computation you're doing, you'll try a bunch of optimization. And there are even things that smart contract developers right now do not think about, because it's not how solidity was designed, the EVM was designed, but caro kind of changes this whole paradigm. Now you're able to write way more computationally intensive programs, and it's fine because you're not going to be the one that run this program, right? In the end, it's going to be the prover that runs this very expensive computation. And then on Ethereum, when you sell the proof, everyone just verifies it, and it's way, way faster and cheaper. So how this is about a bit of context about Cairo.
00:05:53.866 - 00:06:54.540, Speaker A: You can see that it's a very, very powerful tool to do very computationally intensive algorithms without losing any trust in your system. Okay, so now I'm going to talk a bit about storage, proofs, bridging. So especially Herodotus, which is like a starknet native company doing that. So what do we mean by storage proof? If you're familiar with the cosmos ecosystem and IBC, it's kind of same ideas that you want some protocol that is able to unchart a firm like right now, it's quite sharded. You have this bunch of chains, and you have more and more chains as time progresses. So you want to really unchart the state and unify the state of all these roll ups that exist or will exist in the future. A cool priority is that you actually, with storage proof, you get synchronous data reads between layers.
00:06:54.540 - 00:07:44.024, Speaker A: You could read some data from optimism or arbitram on Ethereum and in the synchronous manner. And that's very, very powerful. One other very cool property is enabling historical data access storage proof are actually, when you use storage proof, you decide a block number. You just take a snapshot of a state at a certain block number, and that makes it easy to, let's say, access state from, let's say, you want to know what were the if balances of some account back in the do hack. You can do that. And you don't have to do any fancy magic. It's just, in the end, it's just verifying some mercury proof of the state tree of the block.
00:07:44.024 - 00:08:32.130, Speaker A: It combines a bunch of cryptographic primitives, snarks, darks, and MPC. But I won't dive too much into details for this presentation. We could really talk about it for hours. Okay, so let's introduce a new stack that stark in the starknet ecosystem we've been developing for a while. It's called Madara. The name is a lot of anime names in Starknet, you will quickly realize, but Madara is basically some equivalent, I would say, in some way to the op stack. It's a way for you to create your own custom stocknet in some way.
00:08:32.130 - 00:09:16.586, Speaker A: So it's still at the, let's say, proof of concept stage, but have done quite a lot of progress. And now we're running ephemeral testnets and getting a lot of traction there. So Madara can be defined like this. You have, as the modular stack implies, you have all these different layers, and the most important here is the execution layer. It's where you have Cairo, and you don't really want to put anything else here, or you lose everything I've talked about in the beginning. So the ability to write these provable programs, the second thing is the settlement Asciro is compatible with stock provers you could have. So sharp right now is like the most optimized stark prover run by starkware.
00:09:16.586 - 00:10:01.454, Speaker A: But there are over provers being developed in the wild. Then the sequencing is handled by Madara. So Madara is built on substrate. If you're familiar with frontier or moonbeam, we kind of did the same thing. So we took the Cairo VM and we put it into substrate. So it's a starknet compatibility layer for substrate. And why substrate, you might ask, and why not Cosmos SDK or roll kit or let's say over SDKs? So it was mainly because of rust, like the whole starknet ecosystem, the VM, the blockifier component that handles the state transition logic is written in rust.
00:10:01.454 - 00:10:40.538, Speaker A: So it was very straightforward and it took us only like four months to reach a quite usable state of madara. And it's very, very performant. We really don't lose anything. We keep the safety. Substrate is also battle tested software, right? It's been there for years and years, securing billions of values with substrate, we're able to create these decentralized networks out of the box. And that's very, very nice, especially that in the world we are in right now. Most sequencers are centralized, right? But here you have a decentralized sequencing layer out of the box for free.
00:10:40.538 - 00:11:01.802, Speaker A: We didn't have to do anything. It came out with substrate. Then you could custom, also choose your own data availability layer or even governance. So there are a bunch of tools there, but we won't dive too much into it. Okay, so that's the second thing. Yeah, just so here is the QR code. If you want to take a look at the Madara repo.
00:11:01.802 - 00:11:57.168, Speaker A: We already have, I think, around 50 contributors and like a bunch of people from different ecosystem contributing. We're very glad to see that it took so much traction and everything. So, yeah, feel free to come and you'll be proud to be among these amazing contributors. Okay, so now that we have talked about the three ingredients, the Karovm substrate, so Madara and Herodotus, we can actually combine these three things together to get verifiable data. So let's see exactly how this combines together and you will see that actually pretty straightforward when you think about it. Okay, so this is basically what we're developing at Pragma. We have some version is live on Starknet mainnet for eight months now.
00:11:57.168 - 00:12:56.280, Speaker A: But we wanted to have higher frequency updates for Oracle and have the ability to make these data feeds available cross chain. And we came up with this design basically it's some kind of pool based oracle. If you, as a user, if you want to access some data, you query Herodotus to get the storage proof, will handle the proving and the verification of the storage proof, and then you can just access the underlying data. So the chain is, the roll up is basically a custom roll up built with Madara just talked about and is heavily optimized for. Herodotus are basically changing the storage layout, the hashing functions and everything to make it as snark friendly as possible, such that Herodotus has, I would say the best time generating these proofs, and it's actually cheap to verify them. That was very important. Yeah.
00:12:56.280 - 00:13:48.384, Speaker A: And it will eventually settle as an l three on top of Starknet, so that we can basically settle way more often on the L2. It's way cheaper. We don't necessarily have to put data availability off chain. And yeah, it's actually a pretty cool property. All right, so what can you do with that? Why even bother? Are there any cool things that you can build with this that you just couldn't build before? And the answer is actually yes. Here I just listed a bunch of new use cases that don't exist in DeFi or are done with some off chain infrastructure right now. So mainly volatility oracles risk oracles dynamic collateralized deb ratios, you could have like dynamic fees, dynamic spreads, dynamic debt ceiling.
00:13:48.384 - 00:14:36.320, Speaker A: So in the end you have a bunch of parameters in a lot of DeFi protocols that are just updated manually through like cumbersome governance processes. And you will find that in a lot of DeFi protocols. And it's fine, I mean, it's how it's done right now because we just don't have the tools to set these parameters dynamically because we wouldn't need complex models that take into account a lot of inputs and we just don't have the computation power to run these complex models on chain. So as I said, there are some people doing that off chain, but again, that's not really what we want to achieve there. And if you remember, that's why we have Cairo, Cairo. We're able to write these very complex things. So you could write some volatility index.
00:14:36.320 - 00:15:42.074, Speaker A: We have live on Starknet non chain yield curve, a realized volatility. These are things that just didn't exist before. And when you think about it, just unlocks a new whole wave of new use cases. So we're trying to basically work with a few DeFi protocols to see how this can be actually be used in production in the safest way possible. Ok, so what next for pragma? The main thing is a hackathon that is being organized actually starting tomorrow. So I know that if there are people here that just finish the hackathon from here, from ifPrag, you can jump right away in another hackathon we have around 80,000 of price pools with basically all the different starknet projects and you can just hike a bunch of cool things, madara for instance, or basically anything. Experiment with Cairo one and with these new complex models.
00:15:42.074 - 00:16:25.194, Speaker A: So here's the QR code. If you want to go on the hackath website, then the next thing will be a demo that we'll do at starknet cc of this whole system running and finally the implied volatility feed. So my co founder Mateo gave a talk about the methodology that we use to compute implied volatility with this model and it will soon be live and pouring a few amazing options. Protocol building on Starknet. Yeah, that's what's coming next. Here are a few links if you want to dive a bit deeper about everything. And I guess I'll just take some questions now.
00:16:25.194 - 00:16:37.234, Speaker A: Thank you. Are there any questions?
00:16:46.554 - 00:17:06.654, Speaker B: So I understand the proofs have to have some kind of input and how do you actually prove that the data taken from the exchanges that are used as the input to volatility calculation, liquidity calculations are right. Is it done through the proof of stake layer of substrate or some other way?
00:17:07.674 - 00:17:10.014, Speaker A: The question is about the security.
00:17:11.994 - 00:17:16.730, Speaker B: Basically how do you make sure that input data to the calculation that is.
00:17:16.762 - 00:17:52.086, Speaker A: Then proven is correct? Yeah, so that's a fair point here. We didn't talk about how do we get the raw data that we're using to compute these complex models. So right now the raw data comes from, it's a permission manner. So we have market makers and exchanges, also people in the ecosystem like argent equilibrium, Spaceshar, nevermind, and a bunch of great people that run nodes. So we have both first party data and third party data, that's actually very important. We could dive into it as well. But yes, we got these two things the idea is to like.
00:17:52.086 - 00:18:36.364, Speaker A: So when I have around ten to 20 sources and the idea is to have more and more sources. And if you want to make this permissionless, yes, it will be some proof of stake mechanism. So actually leveraging the default substrate proof of stake mechanism, but customized in different ways to ensure some kind of crypto economic security for identify protocols consuming the data feeds. That's another field of research that we'll be taking to make this whole system permissionless, but at first it will be permission with actors just putting their reputation at stake. And the more sources we have, like this risk goes down very, very low. Actually.
00:18:39.584 - 00:18:50.044, Speaker C: Maybe I missed it seems like all of the applications were financial in nature. Are there other fields where you plan to apply this technology that.
00:18:50.104 - 00:19:35.674, Speaker A: Yeah, so right now we think that there is a big use case in financial applications, that we're really focusing on these financial use cases, especially because there are a bunch of complex models like henchmen or Tradefi is just running on four years and decades even, and we don't even have in defi yet. So we found that there is, it was like the most important thing to tackle. But then if we once we will make all of this permissionless, basically you'll be able to have any kind of data providers coming and providing the data and people writing these models on top of the raw data. Yeah. So definitely in the future there will be different data types, but for now, mostly financially.
00:19:35.974 - 00:19:51.108, Speaker C: And earlier you said we only care about the succinctness of ZK proofs, not necessarily the privacy aspect. Do you think that's driven by, let's say, I won't call it, I'll call it fear of regulation, or is it just that that's like a second order thing?
00:19:51.156 - 00:20:37.782, Speaker A: So, yeah, so we're actually playing also to have some kind of privacy because these complex models, especially if we're trying to get these hedge fund models to run on chain, sometimes these people just don't want these models to be transparent. Right. So you need some kind of privacy there and how it will work. So in substrate there are, people have been doing work for quite some time on encrypted transactions. So privacy will be there. It won't be at the proof level, but it will be at the, on the chain itself. That's again like a cool thing you get when you're building this network as a blockchain, is that you benefit from all the research that has been done in the blockchain field and by all the substrate chains and everything.
00:20:37.782 - 00:20:53.224, Speaker A: So, yeah, it will be basically encrypting the transactions themselves so that no one can just see what's happening, like how the data feeds look like and everything, but you can still consume it in a trustless way. So that's. Yeah.
00:20:53.524 - 00:20:54.404, Speaker C: Thank you.
00:20:54.564 - 00:21:11.704, Speaker A: Welcome. All right, thank you. Ah, perfect. Thank you very much.
