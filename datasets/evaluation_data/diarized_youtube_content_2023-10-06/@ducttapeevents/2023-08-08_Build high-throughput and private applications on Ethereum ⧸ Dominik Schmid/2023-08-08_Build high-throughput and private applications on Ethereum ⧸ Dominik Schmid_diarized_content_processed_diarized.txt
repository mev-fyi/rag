00:00:01.920 - 00:00:13.750, Speaker A: Hello. Hello. Hello. Nice. Okay, let's check. Okay. Yeah, I'm Dominic, I'm from Polygon Maiden.
00:00:13.750 - 00:01:06.534, Speaker A: Basically, like polygon has three different ZK products and one of it is Polygon maiden. We are more of a research project, I would say. But on the, we are getting testnet next October and it works quite different to other products, I would say. But yeah, basically what are we actually doing? So Ethereum, we think is still our best bet, as you all know. Basically when you look at the amount staked and the number of professional active developers, then you can see that all of those chains, basically they are quite the same. But Ethereum is outstanding. So Ethereum is by far the safest chain in the pos.
00:01:06.534 - 00:01:57.646, Speaker A: Like I don't want to get into that discussion now. And it has the largest developer community, so it would be stupid not to build, not to tap into that ecosystem, not to build on that. However, the EVM, so the underlying backbone of Ethereum is limiting the applications that we can build so far. So Ethereum, basically the EVM processes state changes sequentially. So one transaction at a time, one block after another, but all with always a global lock. So actually it's like sequential processing. And if PayPal would have been built on top of Ethereum or using Ethereum, then you would all see that, like this is my personal PayPal account.
00:01:57.646 - 00:02:31.933, Speaker A: So the EVM is very hard on privacy. So you can try to get around that. But from its like internal structure, the global account states it's very hard to get privacy on the EVM. And so yeah, that's our thought process. So the EVM is somehow limited. It's not suitable for applications that require very high throughput. Complex computations are quite costly, and transactions and accounts are always publicly available and visible.
00:02:31.933 - 00:03:55.564, Speaker A: So, but real world use cases like, let's think of a Dex or, yeah, a Dex that should work somehow, like a stock exchange or simply buying coffee in the morning with crypto need very fast and cheap transactions. We probably need parallel execution. We needed to have at least partial privacy in the sense of privacy as we have it in PayPal at least, and way better wallet security and good user experience. So the question obviously is, how can we use Ethereum but not EVM for us? And the answer kind of is obvious, I think too, since the rise of the roll ups. So we have polygon maiden here as an example of a zero knowledge roll up that can tap into the Ethereum ecosystem, but with different features. So basically we are zero knowledge roll up with not running on the EVM and the goal is that you can create applications that are at the moment infeasible on Ethereum or EVM like systems. And how we do it basically is we prioritize in our virtual machine the zero knowledge protocol over the usability.
00:03:55.564 - 00:04:23.560, Speaker A: So that's it. But I will explain how it is. What is actually new? I think most important is client side proving. So basically the MiG users will be able to create zero knowledge proofs on their machines. And with that we almost have it. So with that you get privacy. Obviously when you use a zero knowledge proof of your own state change, then no one knows what, what's happening on your own state.
00:04:23.560 - 00:05:06.892, Speaker A: They just will always know everything is correct, but they don't know what's happening. And it also enables very low cost computations. Because if I use a zero knowledge proof, then like in contrast to a normal blockchain, the state does not need to be recomputed by every node in the network. They all just check a proof. That's actually quite cool, because then I can run very complex computations that are super cheap. I get concurrency and that hopefully leads to high throughput applications. And in maiden you can update and recall transactions that we think leads to user friendly dapps.
00:05:06.892 - 00:06:01.504, Speaker A: But let me explain you how it works and then I can show you, or we can create some zero knowledge proofs together. So basically, what's different on maiden to other systems? On Maiden, there are counts and nodes and accounts you can think of as in Ethereum, like an Ethereum account. And nodes are quite like banknotes. And both can carry assets, right? And those accounts, they send notes to each other when they want to exchange assets. This is much like cash works, right? So I give you a banknote, and then this banknote basically carries the value when I hand it over to you. And these accounts, they can do that asynchronously. They can asynchronously produce and consume notes.
00:06:01.504 - 00:06:38.150, Speaker A: And when an account consumes or produces a node, we call that a transaction. And that is actually quite different. But this is why we can create user generated zero knowledge proofs. Basically, when you look at that, that's what we mean with a transaction. So Alice here, she has ten matic and five ether, and she wants to consume a node of five ether. And for these five ether she needs to pay five matic, which is quite a nice exchange rate given that today's. Yeah, but whatever.
00:06:38.150 - 00:07:39.394, Speaker A: So, okay, so she consumes these nodes and this is her account state in the lower right. And the transaction basically, which is defined as a state transition of one single account. So as a result we have Alice account in a new state having five matic and ten ether, and she has produced a node with five matic. And that goes probably to the sender of the first node or whatever, we don't know. But like this is a transaction, right? And the important point here is a transaction always involves only one account. And because for every transaction in maiden, there's always a stack proof, there's always a zero knowledge proof for these transactions. Now you can combine these things that basically, because it offers only one account, the stack proof can be created by the owner of the account alone, because he doesn't need information of these states of the others.
00:07:39.394 - 00:08:37.286, Speaker A: Like when I produce a node single handedly, or consume it and create it, I can create a zero knowledge proof of it. And these zero knowledge proofs can be created by the users in parallel, and then they get batched together using recursive verification and put into a block. But this is basically as it works with other zero node show ups as well. And then at the end you have one big proof on ethereum that proves the global state of the network. But different to other zero knowledge rollups is that these transaction proofs basically can be done by users and not only by one single centralized entity or so called approver. And that's how you can keep, you can stay private basically. Yeah, like let me check the time.
00:08:37.286 - 00:09:19.354, Speaker A: Okay, so my actual time is over, but I would want to show you, I also started a bit later. Can I, what's my time? Okay, so maybe I can show you this. So you can take out your phone and can scan this. And this is our playground basically I want to show you how it works. So this is the mydinvm in the browser. Basically the mytinvm works in, is written in rust, can be compiled to wasm, and so let's create a zero knowledge proof together, meaning that it looks like this. It's a bit hard to use at the moment.
00:09:19.354 - 00:09:59.014, Speaker A: We are working on a cool compiler for move or rust 1 second, so, and when you scroll down, this is the program that we are going to prove. It's a super simple program and it's way simpler than a transaction, but just as an example. So in this language that we have at the moment here, it adds one and two together with zero inputs. And I can now prove it like this runs in a browser and it should be done okay, in 200 milliseconds. I don't know, like is someone over 1 minute on your mobile phone. When you prove it, you click proof. Nice.
00:09:59.014 - 00:10:14.914, Speaker A: Okay, so how long was it? 400. Yeah. Okay, so it should be quite quick. And this is the result. So it's three, the result of adding one and two together and then you can. Now you can verify the proof. Okay, verification failed.
00:10:14.914 - 00:10:48.434, Speaker A: Never do a live demo. 1 second. I think I just checked something. Okay. So now you can verify it and you can look at the proof. So it's actually like a super long hex thingy. But this is basically how we envision in the future that also people can in their browser create their own proofs, like their proofs of consuming and producing a set of nodes and then only sending this proof.
00:10:48.434 - 00:11:22.084, Speaker A: Yeah, this proof here to the verifier. And this is how we basically get very high throughput because these can be done in parallel and privacy at the end and. Yeah. Happy to discuss or take questions or I can show you more slides of the design or are there any questions? Cool. Then thanks a lot and have fun at the conference.
