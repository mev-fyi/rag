00:00:11.440 - 00:00:20.314, Speaker A: Okay, it's time. Let's welcome Lucas Toxinki. We'll talk powering up intent in Defi. Go for it.
00:00:21.414 - 00:00:49.820, Speaker B: Hello. Hello. Does that work? Yes. Hi, everyone. My name is Lucas Stochinsky, and we're talking about powering up intents in Defi. So I'm head of business development at mimic, and we're going to talk about how we have powered up intents in our protocol, in our product to improve the way we interact with Defi today. So, to start up, I'll introduce mimic a little bit.
00:00:49.820 - 00:02:06.518, Speaker B: So, we are a startup, operating since 2022, and we have started building our automation tool, initially as a help for our friends from Balancer and Paraswap, where they needed some help with conversion of the fees, and we started automating them for them. So, over the time, we have noticed that there is a huge demand for automating various Defi operations. And since then, we have had two different iterations of our product, and now we're heading to a third one, to a fourth home, actually. And we're being an automation tool for the top industry projects in managing their assets. We're working with some of the top leaders in the industry, and we have helped them process over three point billion dollars in assets to date. So, to start with, I would like to get this to ensure that we are all on the same page and we've with what we mean by intents. So, the traditional way of operating in DeFi is that we have to both define what and we have to define how.
00:02:06.518 - 00:03:10.600, Speaker B: So if we have in this example, for example, eve on the mainnet, and we want to receive USDC on optimism, which is our what, we have to define the how and go through two different protocols. So we have to first bridge it from Mainnet to optimism, and then we have to swap it from ETH to USDC, which are usually two on chain transactions that we have to perform, obviously we can revert them. There's some protocols that are improving this, that you can do it in a one transaction already. But still, the mental model here is you have to sign an on chain transaction and execute it at the same time when you're performing that, when you want to perform this transaction. So the difference with intents is that we only have to define what so intents are. In a way, they're assigned messages that only accept the defined end state and the potential constraint. Then don't defy how the transaction is executed.
00:03:10.600 - 00:04:29.904, Speaker B: Finding how is usually in the hands of the third party, which is called solvers or fillers. So coming back to this example, we define our what. So we define the source and destination chain, the source and destination token define what sort of amount in, amount out we want to receive, and then we sign an off chain transaction, which is usually gasless, and then the solver is executing the transaction on our behalf. So we have seen so intents are in general an improvement already from the traditional way, how we operate with defi. And since this concept was introduced, we've seen some impressive implementations, mainly from Uniswap X, one infusion called protocol. But from our learnings, we can see there's still certain improvement margin here for improving how the intents are, because there are some common challenges that we have identified. So today, most intent based protocols, they're isolated proto intent systems, meaning that if you create an intent with a certain protocol, it can only be executed in that same protocol.
00:04:29.904 - 00:05:19.624, Speaker B: There's so far incompatible standards. Each protocol is creating their intent infrastructure in their own way. There are some attempts to standardize it with things like anoma's intent machine, or the recent ERC 7683 from across and Uniswap, but we're still far away from having a compatible standard that everyone's going to be using. There's also cross chain limitations, and those intents are not really suitable for automation. So we have introduced the. Oops, sorry, the four different features that will power up those intents. And these are so our intents in mimic.
00:05:19.624 - 00:06:02.282, Speaker B: They're authorizable, they're programmatic, they can be automated, and you can add hooks to them. So let me put this to this example. So imagine you are a treasury manager, and you have a smart account on arbitrum. You're receiving various token rewards. That wallet that you want to convert to USDC, because you just need a cache for operational processes so you don't have time to do it yourself. So you want to authorize your employee to do it. So you can create, you can authorize your employee to create intents on behalf of that wallet that you're receiving the funds, but they can only be limited to certain ways.
00:06:02.282 - 00:07:03.344, Speaker B: So they're not going to receive the full access to that wallet, they're only going to be able to perform that given operations. So the employee has got the authorization over the account. But now we want to be more specific, and we want to make sure that they don't do any other transactions than what we intend. So what we can do is we can specify the predicates under which they can create indents, so we can say that the only destination token is going to be USDC, that the minimum threshold, the minimum amount that they can swap has to be $1,000, because we don't want them to swap small amounts to be gas efficient. And we can also define the maximum gas, which is going to be 20 way. So, by programming those intents, our employee will only be able to perform transactions that are specified by this preset. And those intents, obviously will be filled by solvers.
00:07:03.344 - 00:08:38.482, Speaker B: So next, our organization scales, and our employee is not able to perform so many transactions or create so many intents on their own. So what we want to do is we want to automate the whole process so we can authorize a bot that will be creating those intents on behalf of that smart account, which will get solved with solvers. So bot, what we need to remember, because obviously some people can think, okay, we're authorizing a bot. What if it hacked? What if it gets hacked? Or if there's any security risks? So, by authorizing bot to this very limited, like, to this specific predicates, we're making sure that the bot can only perform that certain transaction, and no other transaction can be performed in that account. So the last improvement that we have introduced is adding hooks to the intents. So what we can do is, for example, whenever our bot is swapping, or is creating an intent to swap the token to USDC, we want to add a hook so it withdraws wallet to, so it withdraws funds to the hardware wallet of the company, so we can create that hook. So every time the intent is solved, then another intent is going to be created that will withdraw those funds to a destination wallet that we're going to specify.
00:08:38.482 - 00:09:28.754, Speaker B: And what's important to note, hook could be any defire transaction in this case, or any on chain activity. It could be bridge, it could be stake, it could be lending. So you can build very complex sequences of intents that will be performed automatically. And another thing to remember is those hooks can be created both before the intent is created or after the intent is created. So it gives you a lot of flexibility in the way how you program your intents. So all of this is composing into a mimic engine that is currently plugged into DeFi protocols. So we have got various integrations on different networks.
00:09:28.754 - 00:10:22.944, Speaker B: And this setup allows users to interact with non intent protocols across several networks. And basically you can create intents and get them solved within nonintent protocols. We're already utilizing this SAP in a few use cases, which I'll mention two of them. So the first use case is fee collection. So we have an application that wants to convert assets to USDC on all networks and transfer them to a treasury wallet on the mainnet at the end of the month. Usually when the fees are collected from different applications, they're usually from swap or other defi activities, and they are always collected in the cell asset. So those applications end up having multiple tokens on multiple networks that they have to do something with them.
00:10:22.944 - 00:11:28.912, Speaker B: So what we actually, what can we create? So we can create this infrastructure where we set those three presets, we can also call them master intents. So the first one is that we authorize a bot to swap all tokens to USDC on all supported networks with a minimum threshold, with a gas limit, with a maximum slippage, we can create those predicates. The preset number two is we authorize the bot to bridge all USDC from all the L2 s to mainnet once a week. And the preset number three is withdraw all the USDC on the mainnet to a destination wallet. So what's going to happen is throughout the month, the bot under the precept number one, it's going to be creating various intents for swapping assets. So whenever there is, let's say ten aave, they're going to sell it for 1000 USDC or wherever the equivalent of AAVE of 1000 USDC is going to be. The bot is going to create automatically an intent and the solver is going to solve it.
00:11:28.912 - 00:12:25.412, Speaker B: Same for any other assets. And once a week it will create an intent to bridge all the USDC on various L2s to domain it. So we start accumulating everything on one network under the preset number three, at the end of the month, let's say it's like an end of a period, the bot will create an intent to withdraw all the USDC from Mainnet to a treasury wallet. So in the end, this application, instead of having fees in the very diverse tokens on different networks, they're receiving everything on Mainnet in USDC without doing anything. You set it once and then it operates automatically. The use case number two is swap as a service. So an application wants their users to swap tokens while protecting them from too high slippage and charge them a percentage fee.
00:12:25.412 - 00:13:23.524, Speaker B: So what we can do, so the application can preset this mother intent, which is allow any user to swap all tokens with a slippage that's below 20%. And then we want to add a hook to charge a 1% fee on each swap and transfer it to any account where we're going to be collecting those fees. So what we're allowing here is any user of this application, under the master intent, they will be able to create their own intents for swaps. In this case like swap 100 array for a minimum of two eth. They're going to be able to go more specific in terms of the gas, in terms of the slippage, in creating those intents. And obviously those intents will be filled by solvers and after that the fee. So 1% of whatever the amount was sold is going to be then transferred to a separate wallet as a fee collection.
00:13:23.524 - 00:14:22.186, Speaker B: So what is the bigger picture here? So basically, the way applications integrate with DeFi today is very cumbersome. What we want to do is we want to improve this way of integrating with DeFi. Because to give you this example, if an application wants to offer their users a swap, they're going to integrate like a Dex aggregator for bridges, they're going to integrate bridge aggregators. If they want to offer them lending or staking, they'll most likely have to integrate the decentralized protocols themselves, like Lido maker, Aave, etcetera. So what we want to build is we want to have a single integration to access all DeFi operations. So mimic protocol will consist of three main components. So we're going to have the intent based engine that we have discussed already.
00:14:22.186 - 00:15:05.684, Speaker B: We're going to have a network of solvers and our in house integrations directly with DeFi protocols. And then we're going to have a platform which is going to be the front face of that, which will have reporting, monitoring, notifications. It's all going to be accessible through API and SDKs. It's going to be obviously fully audited, trustless and non custodial. So the single integration, so like who do we build it for? Oops, sorry. So we're already, as I've mentioned before, we're already working with various customers. Mainly these are Daos wallets and Defi applications.
00:15:05.684 - 00:16:29.342, Speaker B: And we see that this use case is going to be applicable also to other customers, fund managers, any treasury managers, various financial institutions, and basically any consumer application that will want to integrate with DeFi. Because instead of integrating all those different protocols, as I've mentioned previously, they'll be able to have a single integration with mimic, and they're going to be able to allow their users interacting with DeFi. Some potential services like use cases that we can see here, is building complex trading strategies, doing treasury management, rebalancing, exiting and entering different positions, fee collection, as we've explained before block trading. So if a protocol wants to sell their native token, but they don't want to have too much impact on the price. Yeah. So block trading. So if they don't want to have too much impact on the price or on the slippage, but they need to sell tokens, they can do that.
00:16:29.342 - 00:17:12.654, Speaker B: And they can also offer their users things like swap, bridge, lend, or stake, or all of them together through a single integration. So, as I mentioned in the beginning, mimic started operating over two years ago, and we already have a working infrastructure and a product market fit. We're a team of 13, and we have processed over $3.5 billion in total volume. We have executed 6.2 million transactions, which 117,000 of them were automated. And then we also did 110 million simulations of those transactions.
00:17:12.654 - 00:17:24.174, Speaker B: Yeah. So that's everything from me. If you've got any questions, feel free to chat with me after the presentation, and thank you very much for listening.
00:17:27.534 - 00:17:38.574, Speaker A: Thank you very much, Lucas, for that awesome presentation. Do we have any questions for Lucas? No questions. All right. Thank you very much.
00:17:38.734 - 00:17:39.134, Speaker B: Thanks again.
