00:00:00.160 - 00:00:16.150, Speaker A: Thank you very much. So thank you for joining me in this workshop. I won't even dare to read all, like the title. It's super huge and it's like super long. So I will just skip. Oops, I'll just skip to my introduction. My name is Mikhop Sabratjal.
00:00:16.150 - 00:00:59.524, Speaker A: I'm the lead developer of security tooling for Ethereum at Ekiblockchain. I'm also an auditor and we are an auditing company, but we are also developing open source tools, and Wake is one of them. We'll be using Wake today. We'll be using tools for solidity, which uses wake in the background. And we are also onboarding new students to Ethereum and to Solana through school of Ethereum and School of Solana. We work with many well known projects, like for example, Vinch, Lido, safe, Axlar, and we've received a grant from Coinbase that actually started the vague development. Now, just in case you wanted to download my presentation and follow the presentation, you can just open this link.
00:00:59.524 - 00:01:43.884, Speaker A: In the meantime, how many of you are developers? Cool. Amazing. So we've got some newcomers, so a few developers maybe somehow. And how many of you know Python, or at least saw Python? Good. That's very good. Amazing. All right, so I guess I can continue.
00:01:43.884 - 00:02:38.700, Speaker A: But before the coding, we will need to do some preparations, so I will need to make sure you understand what will be going on here. But first of all, let's talk about wake. I don't know if you've been to my previous talk, but just in case you weren't, I will quickly introduce wake. It's a testing framework, so anyone can write unit tests using Python, interact with contract test some invariants on the contract. So I think this is pretty useful. There's also the fuzzing engine, so anyone can generate random data, they can generate random sequences of transactions, and then they can execute those transactions and observe how the contract behaves and maybe find some bugs because of the random generating. There's also a possibility of creating integration tests.
00:02:38.700 - 00:03:30.736, Speaker A: So it's possible to fork the mainnet or the testnet with pre deployed contracts, then deploy own contracts that interact with those pre deployed contracts and do some integration testing after fuzzing, or maybe unit testing. It's also a static analysis framework. Anyone can create their own detectors that should detect some issues in the code and maybe code quality issues too. And there are also printers, and I think that not many of you are familiar with parentheses because it's somehow special to make. Maybe, but it's very the same as detectors in a way that it analyzes the code, but it doesn't show some issues in the code. But it's used for data extraction, so anyone can extract useful information from the solidity code using printers. It's also about static analysis, and there's the language server.
00:03:30.736 - 00:04:01.296, Speaker A: So when someone wants to write something in solidity, they will need an extension for versus code because, because versus code itself doesn't support solidity. And there are quite a few, some extensions for versus code, and tools for solidity is one of them. And tools for solidity actually uses wake in the background. So wake is a backend for tools for solidity. And. Yeah, so that's pretty much it. But we'll be focusing today on the static analysis part we'll be creating.
00:04:01.296 - 00:04:38.210, Speaker A: Maybe I may show you some detectors if you want to, but we'll be focusing mainly on the printers today. So wake is a static analysis framework. First of all, I need you to understand what abstract syntax trees are. And it's a compilation artifact. So whenever you compile the solid code, you can get the bytecode that you can deploy. That's quite obvious, I would say. But there are some more interesting artifacts from the compilation, and abstract text trees are one of them, and they are pretty useful.
00:04:38.210 - 00:05:11.552, Speaker A: They are like, it's the most important artifact from compilation. For static analysis, there's a relation that every single file has exactly one abstract syntax tree. So when there are 20 files, like 20 solidity files, there will be 20 trees in the compilation output. Those trees are composed of edges and nodes, and those nodes have ids. Each node in the tree has an id, which is a number. That's the type. Like every node has a kind.
00:05:11.552 - 00:05:43.984, Speaker A: I will talk about that more later. And there are some extra data in each of the nodes, and there's the mapping. So each node in the tree can be mapped to, to the original source code. So it's possible to say like what the node in the tree defines in the solid code or how it is related. So there are 56 different solidity ASD nodes. Like St is the abbreviation for abstract syntax trees. So there are 56 different nodes.
00:05:43.984 - 00:06:15.052, Speaker A: This can be divided into declarations. So there's contract definition node, which defines like a contract. There's function definition node, which just somehow shows information about the function. There's variable declaration that just defines a variable. There are expressions, expressions often have like should have values, so you can ask what the value is of that expression. There are many expressions. An example is a binary operation.
00:06:15.052 - 00:06:39.146, Speaker A: I think I can actually show you. I will give it a try. Yeah, it looks very good. So let's say that we have some code. For example, u is a variable declaration. It declares a variable. That simple.
00:06:39.146 - 00:07:23.318, Speaker A: It is. Then we may have something like that. When, I hope you can read it. It's un x, which may be. And if I showed you the same on this one, would it be better? Oh, I'm not sure if I can do that, but I can try. Definitely. Yeah, it's pretty dark.
00:07:23.318 - 00:08:14.164, Speaker A: I see. If you just can turn off this thing, I think it would be. Or just turn on the light. So for now I can write that on my laptop and then we can continue with the board maybe. I'm not really sure. I'm not really sure. It's better.
00:08:14.164 - 00:08:39.354, Speaker A: Thank you so much. Thank you so much. Amazing. So this is a variable declaration. It declares a variable this. I will finish it. So let's say it's seven plus three.
00:08:39.354 - 00:09:10.264, Speaker A: This is a variable declaration statement, because it must be like it may be a variable declaration, and at the same time it may be a variable declaration statement. I don't want to confuse you, but what's, what I wanted to say here is that seven plus three is a binary operation. I think it's quite obvious. There's the plus, there's the left side, like the left expression, the right expression. So it's a binary operation and it has a value. As I said, expressions have values, and it's got a value which is ten. It's ten in un.
00:09:10.264 - 00:09:48.334, Speaker A: There are more examples of expressions like a function call. I can also show you. So a function call may be a call to a function like foo. It can take some parameters x, but it doesn't need to be only a function call. It can be a typecast, it can be payable, payable message sender. So it may be a typecast too. All right.
00:09:48.334 - 00:10:38.074, Speaker A: But in general, there's the name of the function which is called, and there may be parameters in brackets. There will always, always be the brackets. And member access. I've got the member access example already on the board, which is message sender. It's an access too, like this is the member and it's a member of message. So this whole code is a member access because it accesses a member of something through a dot operator. There may be some meta nodes that don't belong in any other categories, so they are just, it can be like anything, like helper nodes.
00:10:38.074 - 00:11:22.194, Speaker A: For example, source unit, which is the root of the tree. So each tree will have the root, which is the source unit, node and there are some more examples. We've got statements. And the basic structure usually is that there is the source unit, as I promised, source unit, which is the root of the tree. Now typically there are some meta, like imports and things like that. Then there's the contract, contract definition. So we have some declarations behind, like below that source unit.
00:11:22.194 - 00:12:02.864, Speaker A: A contract definition may have a function definition as a child. So this is somehow meta, this is like the root, these are definitions or declarations. It's a definition of contract definition of a function. And then the body of the function is a statement, it's a block, it's a block of statements. It contains more statements. So now after like this function definition, we are in statement world statement. So there may be more statements, and in those statements there will be expressions.
00:12:02.864 - 00:12:41.594, Speaker A: So the structure is that there's a source unit, there are some declarations, inside functions and modifiers. There are statements, and inside statements there may be expressions. So anything that ends with a semicolon is a statement, but also a function body. These are like the brackets is a statement too, because it contains another statement. And inside statements there may be expressions like in this case that seven plus three is an expression. So this is somehow basic structure. How the SD works.
00:12:41.594 - 00:13:20.674, Speaker A: There are also typenames, and there are only a few nodes that are typenames, like array typename, elementary type name mapping, and there may be like one or two more. And the type name is this. It's the name of the, it's the name of the type. So in this case it's uint, it's a name of a type. That simple it is. There are 16 Julia ASD notes. Julia or Juul is an inline assembly language, so there are additionally 16 more notes, like kinds of notes.
00:13:20.674 - 00:14:05.954, Speaker A: I won't go too deeply into these because there will be too much, I believe. So there are some more notes and I'd like to show you something for the documentation, which is very similar to this. So I will open the link, let's see if. Yeah, and there's described basically the same. Can you see it? Yeah, I think it's very good. I will zoom it in and there's an example in solidity and this example, I've got a tree for this example. So it has been compiled and we've generated an ast tree using compiler.
00:14:05.954 - 00:14:34.208, Speaker A: And this is how the astronauts looks like for that simple. It's very simple code. There's pragma, it's a library math called math. And there's a single function that accepts a single parameter some keywords here, there's if condition, return, and there are two more function calls to the same function and the parameters. So it's very simple code. And the ast looks like this. It's not that complex actually.
00:14:34.208 - 00:15:06.374, Speaker A: It's very easy ast, but it may not look like that. I will zoom it in out a bit so you can see the whole tree hopefully. Yeah, this is the whole tree, and I think it should be somehow quite readable. So the root is the source unit, as I promised. Source unit here, source unit as the root. So the root is always the source unit. The source unit may have pragmas, like in our example, there's pragma solidity and it's represented by pragma directive.
00:15:06.374 - 00:15:35.682, Speaker A: And by the way, I've used the same color for the same kinds of nodes. So the green is used for declarations, the, I don't know, it's purple, maybe pink, something between. So this is for the metanodes, the blue one. The blue one is for type names, this is the purple. Okay, so this is for expressions. And that brown is for statements. So we've got a single contract here.
00:15:35.682 - 00:16:15.790, Speaker A: It's actually not a contract, it's library, but it's represented by contract definition node. And there's a kind inside the contract definition node that says that the kind is the library. I can show you, I can just click on that. So this is the documentation for contract definition node. We've got like the documentation for every single node that you may like encounter. And there are the attributes for each node, and there's the kind. So we've got the contract definition node, there's the kind, the kind is contract kind, and it may be a contract, an interface, and a library.
00:16:15.790 - 00:16:57.206, Speaker A: So a contract definition node can actually describe a contract, an interface, and also a library. Let's go back to that tree. Back, back, and inside that library there's a single function called fip, like a fibonacci. And it's possible, as you can see, there's a single node of the function definition kind that defines that function. There are two parameter lists. The first one is for input parameters. So the first parameter list describes this parameter list, and the second one parameter list describes these parameters.
00:16:57.206 - 00:17:27.803, Speaker A: Actually, the written parameters are also parameters. They contain variables, and those variables may or may not have names. There's the function body, so we've got function definition. There's the body, and the body is a block. So this part of the code is a statement and it's a block. The block contains more statements and yeah, there are statements. There is the if statement.
00:17:27.803 - 00:18:33.748, Speaker A: That if statement node represents this part of the code, like this one. So this is also a single statement that's nested in the block, and that single if statement contains the true body. And as you can see, there are no brackets like these ones, which means that there's no block inside that if statement, but there's directly a return statement. So this return is represented by this node, that return, and then we've got another return, this one, and this is represented by this return, and so on and so on. So this is how ast trees work. Was it too confusing or do you understand at least a bit what I'm trying to talk about and explaining the trees? Is it okay? All right, amazing. We won't go too deeply into Ast unless you want to or will to.
00:18:33.748 - 00:19:09.644, Speaker A: And we will go through function definitions mostly. So we will only go to declarations that are very easy to understand. But I wanted to show you how it works, like in the background, back to the presentation. Okay. And in wake we don't work directly with aSt, but with something called ir intermediate representation, which is something built on top of the ast. So it's the ast itself. But there are many versions of compiler that contain sometimes bugs.
00:19:09.644 - 00:19:47.874, Speaker A: It just happens. We don't want to see bugs in the generated white code. That would be pretty bad. But there may be bugs even in the exported ast, and it happens from time to time that there are some bugs and wake Ir fixes that bugs. So when you are working with ir you won't experience the bugs that were introduced in the compiler output. At the same time, references are resolved and I think that I might go back to the documentation of wake to explain more. Oops, not like that, like this.
00:19:47.874 - 00:20:46.384, Speaker A: So in this example there's the function definition called fibonacci, and we are calling Fibonacci again, and there are like, we would probably expect those fibonacci calls to be a function call load because it's a function call. So there should be like two, I believe two function calls. There's the first one and there's the second one. And the function call is composed of an identifier that defines the function that is being called. And of arguments we will need to focus now on the expression which defines what function is being called. And in our case the expression is an identifier, and an identifier is exactly this or this. So this part of code describes what function is being called, and an identifier has like an attribute or parameter or property, which is named reference declaration.
00:20:46.384 - 00:21:34.344, Speaker A: And in the raw asd it's a number. It's a number that points back to any part of the tree, because as I said, each single node has an id, a number, so that reference declaration is a number that points back to the tree somewhere. But in case of wake, those references are automatically resolved. So you don't need to resolve those numbers to nodes. It's all resolved, which is quite nice, I believe. All right, presentation, amazing. So you've got those references resolved, and there are some extra attributes that are not in the original ast, just because we found them quite useful.
00:21:34.344 - 00:22:31.446, Speaker A: Yeah, and there's also something that somehow related to the compilation before we, we generate that ast. I think that I've got an image here prepared, so let's say I will use the presenter. Let's say we have a common interface for two contracts, like two files. There's a contract, a contract b in two different files, and there's the third file, which contains an interface and those contracts inherit from that interface. But there's pragma solidity zero eight four in the first contract, but 0820 in the second contract. So it's not possible to compile these free files with a single version of the solidity compiler, because it needs two different versions of solidity, which means two different versions of the compiler. So we will need to compile it first, like maybe like the blue part.
00:22:31.446 - 00:23:17.764, Speaker A: So we will compile contract a and interface, and then we will need a different version of the compiler and the compiler interface, AI and the contract b. So we will compile that interface two times, and we will have two trees, two ASD trees that won't be the same. Like they will almost be the same, but not exactly. And the reason for that is that each ASD node has that id, which is a number. Those numbers in the first tree and the secondary of that interface won't be the same. They won't. So if you just worked with the ASD itself, you would have problem, because you would have two representations of the same interface and the same file.
00:23:17.764 - 00:24:09.568, Speaker A: It's not really nice to work with something like that, but in wake there's a unified model, which means that for each file in the project you have just one IR representation, and there's only one presentation of that interface. So it's very easy to work with projects like that that need multiple different versions of the compiler. So this is a huge benefit. Okay, now let's talk about printers. Printers are used for source code extraction, and they use that ir model or that ast. Those can be graphs like inheritance graph control, flow graphs, cross reference graphs, things like that. It also can be an API for a contract, it can be a storage layout.
00:24:09.568 - 00:25:00.014, Speaker A: It can be some interesting numbers about source code, like lines of code, number of functions, things like that. It can be actually anything that you can extract from that ASD, and not even ASD, but even from the bytecode, because when you compile a project, you've got that aSt and then some extra information, not only the aSt, but also the bytecode. So you can analyze the bytecode if you want to, and then you can print anything about the bytecode, like numbers, like a number of uses of push zero instruction. It can be really anything. There's the language server integration that this workshop actually is all about. I'm hoping I will get to this, just show you how super powerful it is. And there's API for custom printers, and we were doing that today that we will create our own custom printers.
00:25:00.014 - 00:25:58.954, Speaker A: There's an example of a printer, so we've got a function, and this graph can be generated using one of those printers. I think it may be useful for someone. It might not be, at least it's useful for debugging. You don't usually need that graph to be seen, but you may need to work with that graph in your printer or your detector for detecting some issues. For example, there may be some leaves that don't lead to the finish that the transaction would succeed. There may be some issues easily detected just from the control flow graph, and it's very useful to be able to print that graph to see if it works correctly. And maybe just give you a few examples before you start working on your detector for some issues.
00:25:58.954 - 00:26:02.634, Speaker A: Yeah, yeah, sure.
00:26:09.074 - 00:26:30.454, Speaker B: So in this case, two things. Number one, isn't what you're doing just about a step away from a translation software like I feel like with a couple modifications, if you can compile cross compiler versions, you're not that far away from being able to compile to a different language translation service.
00:26:32.554 - 00:27:07.264, Speaker A: Or did I get like. It's a good question. I think that it might be possible to transfer it to different language, but we are like heavily bound to the AST, which is produced by the solidity compiler. So we are strictly following the solidity compiler. And it might be possible, but we've tried to use that ir even for wiper. And the issue here is that VyPR is a different language that uses different syntax, and some syntactic things don't exist in VYPR and some may be different. So we are heavily bound to solidity.
00:27:07.264 - 00:28:09.714, Speaker A: It might be possible to come up with something like more abstract, but we are trying to focus mainly on solidity and make it easier for developer to see exactly the nodes and how they interact with each other. And if we created something more abstract, it would be harder to work with that model. I would say so it might be possible, but we are heavily bound to solidity. It's built in wake and it's a printer. I'm not absolutely sure it's a module in wake in that way it's built in, but there's a printer that uses that module and it exports the graphs. The API for generating the control flow graph is built in, and there's the printer that uses that module, which is actually also built in wake, but you could create your own. So it's built in, but at the same time you can work with it and you can use in your own custom printer.
00:28:14.134 - 00:28:31.414, Speaker B: How did you solve the bitwise operation problem? From my experience as an ether right now, it's a bit hard to get the visual compiler to understand the proper implications of bit operations. Does that make sense?
00:28:31.954 - 00:29:34.944, Speaker A: Sorry, what operations did you say? Bitwise operations. And why should it be a problem? Okay, yeah, I think I see your point. The control flow graph is based on statements, so we're not going deeper than statements. Yeah, because like statement somehow is a single atomic step that is always or never executed. Like there's the conditional, which is like an expression like if x is greater than zero, then we want, then we want three, otherwise we want seven. So there are still some conditions inside. This is like this is an, this is an expression, but we don't somehow branch this in the control flow graph, unless, unless there's some control flow logic inside this.
00:29:38.664 - 00:30:04.004, Speaker B: The graphic compiler properly display more complex logic. That is pretty simple still. But once you get to complexer logic, where multiple different logic pieces get together, that's where you compile usually based dissipation, which is a lot harder. Do you have that built in as a feature?
00:30:04.914 - 00:31:38.874, Speaker A: Yeah, there's no built in feature that would go deeper than statements in a way that we would analyze more the expressions, but we've got the ast, or that ir modal and itself is a structure that can be easily explored. Can I remove that from the board somehow? Use this one. Okay, so let's say that we have some more like a complex expression, like x plus seven multiplied by eight, or something else, a foucault, something like that. Then this is like that binary, or is like the top expression somehow. There's a semicolon, let's say. So we've got a binary expression that represents that binary, or there's the foucault, there's that multiplication, that multiplication can be divided into that eight and another binary expression which is that plus and that plus is composed of x and seven. So even the tree itself somehow describes how the expression is computed.
00:31:46.414 - 00:32:11.370, Speaker B: On level of stuff like pwms and relays and stuff like that, because I'm trying to simulate those digitally and I was also trying to get the documentation automated through the usual compiler. Right. And those are a bit more complex when it comes to the logical operators, but yeah. Is this open source or is this.
00:32:11.522 - 00:32:54.246, Speaker A: The tool hole is open source, so you can try it. There's the analysis module that contains that control flow graph module, so feel free to try it. Amazing. Okay, any more questions by the way? No? Okay, now this is an example of a very simple like minimal detector and very very simple printer. And maybe as you can see, there are not that many differences. Like it's a very simple code, so there are some obviously, but fundamentally it's very similar. So detector and the printer are always classes in wake in python.
00:32:54.246 - 00:33:38.734, Speaker A: So detectors detect from base class, which is called detector. Printers inherit from a base class, which is called printer. And the major difference is that detectors return some detections, like issues in the code. And printers can just print anything, so we need to collect somehow the detections. So there's a list, it doesn't need to be a list, it's just a template, but it can be a set, or you can just detect perhaps directly in the detect function, but this is the template and there's the list. So we need to initialize that list and then the detect function returns the list of all detections that we have found. And there's also the CLI function, I will talk about that bit later.
00:33:38.734 - 00:34:18.714, Speaker A: So there's the detect function in detectors and that should return a list of our detections. While in printers there's the print function, but you don't need to do anything in the print function you can print, there will be more functions that you will need to define and you can print just from those functions, but you can be sure that that print function exists and it's the last one called. So if you need to collect some information then you can just print the result in the print function. And as you can see, it doesn't return anything. And the reason for that is that you just print, you can use print. Or if you don't want to print, you don't need to print. You can just export anything.
00:34:18.714 - 00:34:43.500, Speaker A: You can export the graph as a file, you don't need to print it to the terminal. That wouldn't make sense. Or it might, but you can just export any files you want to. So it's just up to you. So this is the major difference between detectors and printers, and that's the only difference. Otherwise it's very the same. Is it clear? Okay, I hope I've got the link to the documentation.
00:34:43.500 - 00:35:11.804, Speaker A: It shows a bit more. So yeah, this is the same example that I showed you. And now let's talk about that ClI function. I will just go maybe just up. As you can see there's CLI function. It doesn't need to be named this way. But what's important is that there's detector command and there's printer command, and that name defines the name of the printer or of the detector.
00:35:11.804 - 00:35:51.924, Speaker A: So yeah, and we are using a library for command line interface which is called click. And it's really powerful and it can be used like this. So it's possible that there's the printer which is named my printer, and it's possible to define custom parameters for those detectors and printers. So the printer can accept an argument which can be somehow named. It perhaps needs to be a string, it's required. So anyone who uses that printer has to specify that modifier. And there's the help that is printed to the, to the console, to the terminal.
00:35:51.924 - 00:37:04.020, Speaker A: When used help, there can be also options that may be optional, there may be a default value if it's a flag or not, if it accepts an extra parameter like a number or something, or it's just a flag itself. There's also help. And this way it's easily possible to parameterize a detector or a printer. And it's not only through the command line, but it's also possible to fetch values for those arguments and options using environment variables and a config file, a tumblr config file. Ok, and now this is super important. So as you saw, there are two classes like detector and printer, and those classes are visitors. And visitors means that there are many functions defined in those printer and detector classes, and these are always called visit and something, and that something is that underscored name of a node.
00:37:04.020 - 00:38:18.584, Speaker A: So as I said, there are many types of nodes in DSD or Ir, and one of those nodes is is function definition, which is a declaration, it defines a function and there's a visit function, visit function definition function that is automatically called by wake and it gives you a single definition of a function and it's called automatically. So let's say that you want to collect all the functions that are present in the project and you don't need to go through all the files, through all the contracts, and then to all the functions, you can just define that visit function definition function, like override it. And you've got those functions right here, right now. And there are like, as I said, there's 56 slated node kinds plus 16 if I remember correctly. So there's 56 plus 16 different visit functions in those detector and printer classes. And it's possible to override all of them and collect all the information needed. Does it make sense? Is it clear? Okay, let's hope it is.
00:38:18.584 - 00:39:06.362, Speaker A: We will see better on examples that we will create. Okay, let's just, just continue now. Back from, back from detectors, back from printers to language server protocol. So what language server protocol is it defines a communication between a language server and a language client. That perhaps makes sense. So it's a communication protocol or a specification for a communication protocol between something called a language server and language client. And it defines a set of features that should be supported in integrated development environments like editors for example, versus code.
00:39:06.362 - 00:39:54.364, Speaker A: So it's possible to control click on something and it does something else. It's possible to move the mouse over something and it shows some boxes with some text and so on. So this is defined by the language server protocol? Yeah, as I said, go to definition or rename. So it's possible to rename an identifier in the code and it's renamed on all the occurrences that are present in the source code. There's the LSV specification, I won't open it, it's not that important. And why it matters or why I'm talking about that is there's these the extension tools for solidity, which is developed by a key blockchain. It's open source, it's free, I will install it actually later in the demo.
00:39:54.364 - 00:40:50.094, Speaker A: It's a versus code extension and it uses most of the LSP features or like it implements, it offers most of the LSP features. There's a custom UI with code quality and vulnerability detectors or deductions. And it's a language client. So it's a client in that LSP protocol. And there must be a server that serves like all the data, all the information, and those information come from the ASD or actually from that ir model. And in this scheme is the language server. So whenever someone installs that tools for solid extension in versus code, it automatically installs wake, which is a Python tool, and the extension itself is written in typescript or JavaScript, while Wake is written in Python.
00:40:50.094 - 00:42:15.604, Speaker A: So the extension automatically installs Wake as a language server, as a Python package, it launches Wake, and that Wake serves as a language server while the extension itself is a client. And now what are LSB or versus code printers? I showed you that printers can print anything or generate some files, but does it make sense to use it in LSP or versus code? You can print something, but not to the versus code or why would you do that? Or what does it mean? Yes, so LSP printers or versus code printers are a combination of printers and LSP, which means that it's possible to extract information from the solidity source code and somehow show them or visualize them in versus code. So this is like combination of these two features that are present in vague and tool source audited tooling. There are optional callbacks on click on something I will show you later in animations. And there are some commands that can be executed on that click. Those can be go to locations which just moves the user to some locations in the code. So it moves in the versus code somehow, automatically to some locations.
00:42:15.604 - 00:42:53.376, Speaker A: There are speak locations which is basically the same, but there are two options from versus code. So we just follow that. But it's somehow, it's very similar, or maybe almost the same. There is open URI, so it's possible from an LSP printer to open any like any address or any link just using LSP printers. There's copy to clipboard, which is quite useful. I think that it's possible to extract some information from the code and then just copy those information to clipboard. And that's pretty much it.
00:42:53.376 - 00:43:45.604, Speaker A: So we will use three different language server features that are somehow supported by LSB printers because it makes sense to support them. The first one is hover and it's just by moving the mouse over something in the code. And in this case the mouse is moved over an assembly, like an assembly call or instruction, and it shows help for that. In this case it's mstore. And as you can see it shows there's memory start, there's x, and there's also a comment stores word to memory. And this is achievable using LSB printers. So it's possible to define text that should be shown whenever someone uses mouse to move it over some text in the solidity smart contract code.
00:43:45.604 - 00:44:09.286, Speaker A: So this is the first feature that is supported by LSP printers. The second one is code length. The code lengths are like these clickable buttons, they can contain custom text. In this case it's number of references. But actually all of these are code lengths. The first one is for references. Second one is for generating control flow graphs.
00:44:09.286 - 00:44:55.206, Speaker A: So it's possible to generate control graph and then show it to the user. And these are the same. The first one is for the name of the function I believe, and the others are for parameters. This is why there are more clickable buttons for references. So it's possible to define a custom text, and it's also possible to create a custom callback that should be invoked when clicking on that library. It's not necessary, it's not necessary to define that callback, but it's possible, and it's possible to trigger some actions, and those actions can be I will move back these ones, at least for now, there will be more coming. But in the first release that we have released actually yesterday, these are the actions that can be invoked.
00:44:55.206 - 00:45:38.118, Speaker A: And in that example it showed some locations in the code and it was perhaps that peak locations command. Again it moves mouse, here it clicks, and these are some locations in the code. It can be clicked over those locations and it's just the peak locations command and it's done automatically in versus code. And the last one is it's called inlay hints. I'm not sure why it's called like that, but it is what it is. And what's that? It's very similar to codelens. I don't have an animation here because it didn't make sense, but it's basically an inline text.
00:45:38.118 - 00:46:19.276, Speaker A: So it's this like that colon and that address or this contract order. Something that's UN 32, UN 256. And this is just a simple example that shows like the type of a parameter in a function call. It's also possible to define a callback whenever someone clicks on that label, and it's also possible to create parts of that label. So there can be many parts like followed in a single line, followed one by each other. And not all of them need to have the callback defined. So only some of them may have the callback defined, others may not.
00:46:19.276 - 00:47:04.274, Speaker A: And this is the last feature that is supported using in LSB printers. And yeah, that's pretty it. So I think we can finally move to the coding session. So how many of you want to follow me? Ok, ok, I will be super slow to make sure that everyone understands what's going on, and I don't want to lose you. So do you have versus code installed? Amazing. This is the first step. If you don't have, then if you could please install versus code, which is an editor where you can edit any source code basically now.
00:47:04.274 - 00:47:23.546, Speaker A: All right, so anyone else trying to install versus code still? Okay, I think that I can continue. By the way, are there any questions? Yeah, I have a couple.
00:47:23.690 - 00:47:36.242, Speaker B: So when you said you have all of the notes that you can have in the ast, is that for every version of solidity, or let's say every change that has happened to the ast over time?
00:47:36.338 - 00:48:29.020, Speaker A: Yeah, first of all, wake generally supports solidity in versions zero, six two and greater. So it doesn't support like super old versions. And the reason for that is that the ASD wasn't, it contained too many bugs, that it wasn't possible to fix it, actually. So, yeah, so the minimal version supported is zero six two. And regarding some changes, each time there's a change in the source code, it has to be recompiled, unfortunately, because there's the mapping between the ast and between the source code, so it needs to be recompiled again and again after each change. We don't have like a JSON schema formularization. We are using ASd and we don't have JSon for that.
00:48:29.020 - 00:48:58.624, Speaker A: But we have an API reference. It's in the vague documentation. But if you want to get to vague documentation, it's best to visit Getvake IO. I have presentation, it's Getvake IO, I can show you getvike IO. This is like the landing page for wake. There's the latest version, there's. And the link to the extension.
00:48:58.624 - 00:49:41.254, Speaker A: And there's the link to the documentation. There should be an API reference section. It is here. And there's wake IR section and declarations, expressions. As I said, those are divided into common groups and let's see declarations, let's see function definition. And there's documentation for like every single node that may be present in the ASD, and it's the documentation for IR. But Ir is heavily based on the ASD and it's like 99% the same as for the ASD.
00:49:48.134 - 00:49:55.954, Speaker B: For the AST. So maybe you saw the experimental branch?
00:49:56.574 - 00:49:57.510, Speaker A: I haven't actually.
00:49:57.622 - 00:50:24.426, Speaker B: Yeah, there is an experimental branch. There will be a lot of changes in the code, the way the code is written, and it may bring in the future some, let's say bigger changes to formalizing. Trying to do that for some time, but we had some different realities. So I wanted to ask if that sounds interesting to you. Maybe we can talk after.
00:50:24.570 - 00:51:18.014, Speaker A: It's absolutely interesting. At the same time, honestly, I'm not very happy about that. DST will be changed a lot because we will need to update our model and it was quite a lot of work, quite a lot of understanding, quite a lot of examples. But if I believe it needs to be done, it needs to be formalized and we will need to update our model or keep two models like the old one, the new one, and I think it makes sense, it's just more work for us. What I'm doing right now, when there's new version of solidity, I just look to the commit log, like all the commits that were done in that version, and then check out the changes in the C code and trying to find all the changes that happened to the ASD. And it works, but it's not the best experience.
00:51:21.554 - 00:51:28.094, Speaker B: Are you modeling the language itself or the behavior of Solsi, since they have actually some differences?
00:51:30.714 - 00:52:15.264, Speaker A: We are just building above the AST, so we perhaps, I think so. We just don't do like, we don't interpret solidity, we don't have solid interpret. We are just working on DST, thank you very much. Any other questions? I guess no. So all right, let's go back to versus code. We should have, we spent 1 hour, so there's still half of an hour left for us. Now if you could please install the extension for VSCO, which is called tools for solidity.
00:52:15.264 - 00:53:04.726, Speaker A: Yeah, it's got that beautiful logo. It should be that simple. But I want to make sure that it's even possible to install it, because there may be some issues, just because there's the python tool which is behind that extension, and so on. It's complicated, so I will wait a few more seconds. By the way, the extension is quite nice. I believe it does the compilation automatically. It provides all those interesting features that solidity developers need, and it's heavily based on the ast on that IR model, and so it can quite easily resolve all the references across the code base and it can show all those locations of references.
00:53:04.726 - 00:53:56.846, Speaker A: It can also generate control flow graphs, it can generate inheritance graphs, and it shows findings from static analysis detectors automatically in the code. And there's a custom UI for detections. I won't have any here because I have an empty project. But yeah, there's a custom UI and it's pretty like for compiler warnings errors. And there's the second section, which is just for vague detections like code quality and vulnerability detections. So any issues with installation of the extension? Sorry I see, yeah. Do you have a question? Sorry, it's only for solidity.
00:53:56.846 - 00:55:00.794, Speaker A: Just for solidity, yeah, it's a good question, it's a good question. And I will create just an empty solidity contract to have some solidity code here. I'll call the demo, I will create a contract demo. Okay, that should be enough. And it already triggered the extension. And there are some warnings that come from the compiler, like there is the missing license, there is the missing pragma for the file. And I will wait a bit more, I can show you in the meantime that UI, so there's the UI and there are no detections because there is nothing much like there's nothing to detect, it's just an empty contract, but there are warnings.
00:55:00.794 - 00:56:02.944, Speaker A: And I was thinking maybe if I can make it abstract, there's a detection, and the detection says that there's abstract contract which is not used. And the reason is quite simple, because abstract contracts cannot be deployed, they are abstract and there's no contract that would inherit from that demo contract. So it's useless in our case it's just an informational detection, but it can be useful when managing like really large codebase. So it would show that there are some contracts that can be just deleted because they are useless, or at least not used for now. So how's the installation going? Is it good? Okay, and now, so I will just remove that abstract. No. Yeah, and it got automatically recompiled, the detection just disappeared and.
00:56:02.944 - 00:56:58.742, Speaker A: Yeah, so the extension gets activated every time there's solid code in the opened folder or directory. And you would see that by looking into this view. I can zoom it, oh, it should be quite visible, I think there's view, there's possible to click on that output, there's that output window and it can be switched between many extensions and there's tools for solidity. And it shows that it launched wake on the background, it launched the wake language server with some port. And there's the version of Wake which was actually released yesterday. And in case there would be an issue, it would be printed right into this output window. There may be issues, so if there are any, please just report them so we can fix them.
00:56:58.742 - 00:57:50.194, Speaker A: We are really trying our best to fix all the issues, but there may be some, and it's super helpful. It's when someone reports those issues. All right, so I guess I can continue. Ah, there's a question, sorry, I couldn't hear you. Yeah, while writing, there are automatically triggered compiling sessions, I would say, and you can define how much time you want to wait before the compilation triggers. So you are typing, then you may stop typing for like 2 seconds and then the compilation triggers. Or it can just trigger after like milliseconds after stopping typing.
00:57:50.194 - 00:58:29.874, Speaker A: So it's, it runs in the background, it can run more or less frequently based on your settings, but by default there's like zero delays. So it compiles, it keeps compiling and it keeps showing results. And when you start typing it just starts compiling again and again. So it's kind of live based on how the project Bic is. Yeah, that was my next question, right? Yeah, like the compilation is then slower, slower, and the user experience is not that good. But it's given by the fact that the compiler needs to recompile again. Again.
00:58:29.874 - 00:59:03.814, Speaker A: But what we are doing is that we split the code base into the smallest possible parts of the project that can be compiled independently. And as I showed you, if you remember that picture with that interface and do contract, it's possible to merge multiple compilations into a single model. So we are trying to minimize compilations in a way that we split the project into smallest possible sections, and those sections can be merged together thanks to the IR model. So we are trying not to compile too much.
00:59:10.334 - 00:59:15.134, Speaker B: Different compilation system. You have, for example, every 20 seconds.
00:59:15.174 - 00:59:17.030, Speaker A: You have the compilation of the smallest.
00:59:17.062 - 00:59:22.774, Speaker B: Possible part that is currently being worked on. Like every two minutes you have the general compilation of the project.
00:59:22.854 - 01:00:18.644, Speaker A: Or is it just, we just compile what is needed to be compiled. So anytime when you type something, then we start the compilation, we might wait and then start compilation. And we will compile only those files that were modified and like base files in terms of imports. So each like each file that imports, that file that was modified has to be recompiled also. So we are compiling only what's really needed to be recompiled. Some other questions? No? Okay, so we will start with this very simple printer and we won't be using LSB features, at least for now. You'll just start with the command line printer and there are actually more options, but let's use the simplest one.
01:00:18.644 - 01:00:59.324, Speaker A: There should be a shortcut to launch the commands panel in versus code. In my case it's f one on the keyboard, but it may be different on your system. I will try to find the command, which is right here. It should be, let's see how it's called. View command palette. Yeah, so it's right here under view, the first button. And when you click on that, there are many commands that can be executed and the one we are looking for is called new printer.
01:00:59.324 - 01:01:38.114, Speaker A: And there are two commands that match that string. The first one is that one that we need because it creates a local printer which is somehow bound or created in the local directory that we have just opened. So it's a printer specific for that project or for that directory that we have opened. So this is the specific one. And there's the second option, new global printer. It just creates a global printer that will be available in each project that you open later in versus code. Okay, so I will create a new simple printer.
01:01:38.114 - 01:02:27.888, Speaker A: I will give it a name, my printer, it's not that important what the name is. Enter. And there's logmessage. There's also one more log message that it says that it created a new printer, which is called my printer, and it created the printer in this path, and it automatically opened a template for a printer. And as I promised, the template should be the same as what I showed you previously, except for those imports that are somehow needed because it's python, but the template is the same as you saw. So it's a class I can, I think it should be quite fine, but I will zoom it in like a bit. So it's a class it inherits from printer.
01:02:27.888 - 01:03:15.244, Speaker A: There's the print function, there's the CLI, which we won't need. And so I have some solid code here. There's a contract called demo, and I will define a visit function, def visit definition, I will remove that line. And what we want to do is like we can print anything about the contract. Actually that simple. It is, you can just print note, dot name, save that. So are we all good or should I wait for someone? I will wait a few seconds.
01:03:15.244 - 01:03:54.952, Speaker A: So this is very simple structure of a printer. And yeah, there's our first visit function that can be used to collect some useful information. And in this case we are collecting information from a contract from contract definition node. And these visit functions are invoked automatically. You don't need to do anything, the project gets automatically compiled and that visit function gets automatically invoked or called. And it can be invoked many times based on how many contracts you have in your project. So if you have five contracts, the function will be invoked five times.
01:03:54.952 - 01:05:02.190, Speaker A: And you shouldn't rely on the order of those function invocations, you just shouldn't rely on the order of visit functions, visit function invocations in general. So I think that I can continue now. I will open my terminal, and what I want to do is I want to run vague print, and the name was my printer, I believe my printer, it needs to compile the project, as I said, it has to compile. We are caching the compilation artifact and there are two different compilation engines. The one which is used in the extension which is like language server compilation engine, and the second one which is meant for the command line. So there are two different compression engines, but it's not that important. As a user, you just type something in the terminal and it works when you use the extension.
01:05:02.190 - 01:05:36.314, Speaker A: It also works, but differently inside. And it compiled the project, it generated that ir model and it printed what you wanted to print, which was the name of a contract. So this output is related to that print function call. Makes sense. All good. It's super easy. Just the introduction was quite complicated because the thing behind are complicated, but I'm trying to show just like how simple it is.
01:05:36.314 - 01:06:17.424, Speaker A: And in the end we've tried to design the interface, so it's very easy to use our tooling. But these are just like normal printers, these are not language server printers. So I think that we can move on to language server printers because this is why we are here actually. Yeah. Any issues? Not getting any. And do you have solid smart contract in the project? Ah, how's that possible? So. Hmm.
01:06:17.424 - 01:06:44.884, Speaker A: There needs to be defined as visit function. Ah. Jan will help you, hopefully. Good. Amazing. Thank you. Amazing.
01:06:44.884 - 01:07:39.184, Speaker A: Yeah, typical issue. I always had that one too, because like yeah, the command line tool cannot see what's not safe on the disk. Amazing. By the way, there are also shell completions, so it should be possible to wake and then tap to fill in the remaining commands. And it should be possible to my, like my, and then click or tap, tap and it should just fill in the name of the printer, but it won't run automatically. It's needed to change the shell config file. I can show you in the vague documentation, as I said, you can get there through the webpage getvaek IO.
01:07:39.184 - 01:08:30.214, Speaker A: There's the documentation link. Now there's the installation section, and in the installation section there are instructions how to install wake using up pave. You don't need to do that because it was installed automatically with the extension. There's the link to the extension, there's docker image, GitHub action, GitHub actions, and there's shell completion sections, sections that show how you can enable those shell completions. So if you want those shell completions as well, you just needed to follow these instructions. Yeah, not exactly like the name of the printer. It's not based on the name of the file.
01:08:30.214 - 01:09:14.018, Speaker A: Like the template, like the template does. That way but the name of the printer is based on that command name because as I said, we are using the click interface like library for command line interactions and it, it uses this name. Okay. By the way, those detected printers and even detectors are detected based on the structure. There needs to be the printer's directory which was created automatically for you. Maybe you have not even noticed. And what's important, there's that init file in Python and it's needed to import some, it does need to be the printer actually, but it can be anything.
01:09:14.018 - 01:09:50.236, Speaker A: But it's needed to import the file that contains the printer. So we can detect that the printer should be imported and somehow used. So this was created automatically, but the printers are somehow detected based on those imports in that init file in the printer's directory. Now that would be it. Now we can move to language server printers. I believe I will close that one. I won't need it because language server printers won't interact with the terminal.
01:09:50.236 - 01:10:48.904, Speaker A: So I will just close it. And we need to change the execution mode to LSP. And the reason for that is that we don't want to run the printer on the command line, but instead we want to run it automatically in the versus code. So this is the first step. Let's check if it works or not. We won't see those prints because those prints are somehow printed to virtual console which is not visible because it's in language server now and we won't see that print. But what we can use, and hope, I just hope it works, is we can use self dot logger, dot something, maybe info and hello, hello and save that.
01:10:48.904 - 01:11:22.714, Speaker A: And it didn't do anything. That's sad. I'm sad. Maybe let's just change the level, like critical, it does nothing. Ah, finally. So I needed to change the level because probably info is not reported by default. So this way you can check that the printer was loaded in the language server and it's used in the language server.
01:11:22.714 - 01:12:08.394, Speaker A: So there's the logger, and that logger can be used to log some helpful debugging messages to that output window. As you can see, that output window is used for everything, like for logging issues in the language server compiler. Also for logging. Like that we have created a new printer, but also for logging for every single detector and printer used in the language server. Okay, now since we know that our language server printer works, we can continue with some interesting stuff, more interesting stuff. I will leave here the print function. Actually it needs to exist here, but it can be just empty.
01:12:08.394 - 01:12:59.014, Speaker A: So I will remove that line. And then we've got self lspprovider and we can use some functions on that LSp provider. Let's use there's the node that should be bound to that code lens. If you don't remember, colons is a link that is clickable above something, for example, above a contract definition, like a name of a contract. So we will bind our code length to node and we are in visit contract definition function. So we are binding our code lens to contract definition node. And in this case it should show that clickable button or just the text above a contract, our contract.
01:12:59.014 - 01:13:29.214, Speaker A: Are there any other parameters? There's the title. That's not optional. We need to define the title. By the way, I highly recommend when you're writing something in Python, to have Python extension installed in versus code. There's just, if you type Python, there's Python extension. I highly recommend using that one because it's super helpful. When writing something in Python, it can be anything.
01:13:29.214 - 01:14:19.504, Speaker A: And when you've got the extension installed, there's the bottom bar, there's Python, there are some brackets, and there's type checking off. And we don't want it turned off, we want to turn it on like this. And now it should say that we are missing that title. Well, so what can be the title for that? It can be anything, but let's use node dot name, which is the name of the contract. There's still some red underlined code. And the reason for that is that LSB, LSP provider is optional. It can be none and it will be none.
01:14:19.504 - 01:15:07.742, Speaker A: In that case, that execution mode is not LSP, which means that the printer is not intended for language server, but for the command line. But we know that the LSP provider won't be none, it won't be unsettling. So if we want just to remove that warning or error, we can just set that self LSB provider, it's not none, but it's not necessary. It will work even without this line. Let's just save that. And what I think is pretty nice, again, I hope it will work, is that when you save your language server printer, it's automatically reloaded by the language server. You don't need to restore versus code, you don't need to do anything, you just save your file like that.
01:15:07.742 - 01:15:36.350, Speaker A: And let's see our. Yeah, and it's here. So we've got our contract. These are like built in code lens from wake, but the left one, the most left one is from our printer. And as you remember, if you remember the title was set to note name. Note is the representation of our contract. Dot name should be the name of the contract, which is demo.
01:15:36.350 - 01:16:12.584, Speaker A: And the title in the code lens is demo. So it worked. It worked. So this is an example of code lens. Now let's define some functions in the contract to show you commands that can be executed. On clicking on the label, I will create like two dummy functions that won't do anything. Function foo public empty function bar public empty like that.
01:16:12.584 - 01:16:51.524, Speaker A: And it got automatically recompiled and, and new labels appeared. So as I promised, everything is done automatically, like the completion and everything. And let's just create a callback. Or should I wait for someone? We've still got some time, so it's not a problem. Yeah, I will wait for you, don't worry. So do you want me to go back to the python code or do you have any issues? Okay, okay, so back to our python. So I've defined two empty functions.
01:16:51.524 - 01:17:24.446, Speaker A: It's not that important how they are named. We just need some functions so we can interact with them. So back to my printer. Now there's the code lens and there's optional onclick. We will define a new method. Let's define like underscore on click self because it's a function inside a class. And let's just pass for now.
01:17:24.446 - 01:18:08.772, Speaker A: And the function expects the name onclick. So let's say that onclick is self dot underscore on click. Now we have defined a callback and we should see it right now because it got automatically reloaded as I promised. And the difference should be that, yeah, as you can see, it changes the color. Once I move my mouse above that label, it won't do anything because the callback is empty. But still, the difference is that you can click on it now and hope that it won't crash the language server, which it didn't. So it's good.
01:18:08.772 - 01:18:53.750, Speaker A: It does not do anything, but it didn't completely crash our tool, which is also good. Now let's define a callback. Let's move back to our python code, and we will use that LSP provider again. So self lspprovider, and we will use add commands because we want to execute some commands after the click. And for that we will need to import some commands that we can execute. That import is not very nice, at least for now. As I said, it was released yesterday, so we might choose better names.
01:18:53.750 - 01:19:44.212, Speaker A: But for now it's from bake core, lspprovider import. Let's import that, go to locations, command go to locations command. Nice. And that as commands function call expects a list. It's possible to invoke more than one command on clicking on that label, but we will need only one. But still we need to use a list. So let's just use these square brackets and in that list we want to create a new go to locations command, but we will use a helper function for creating new instance.
01:19:44.212 - 01:20:41.638, Speaker A: So we will use go to locations command from nodes. And what we need to do, we need to define where our focus in versus code will start when we click on that. And we want to start from that contract because we have clicked on a label that's above a contract. So our start will be on that contract. I can show you how it will behave if we change it to something else, but for now we'll just use that contract. But the issue here now is that we have lost the context. We know that we've defined the callback here, but we don't know what we were clicking on when executing that callback function, because there's onclick, but we don't have that node anymore, but we can just pass it to the function.
01:20:41.638 - 01:21:44.374, Speaker A: There are two options, I'm not sure which one is easier to understand, but I think that we can use partial, for example. So from, I think it's func function tools import partial. Yeah, because pilot exactly knows what I need. And using that partial, I can actually close that window. It's not important for us. Now we can say that onclick is a partial from that onclick method, I will just close the brackets and we need to accept that node, that node which is of that kind, ir dot contract definition and we need to pass that node from here to this function. We can do that by just adding, adding the node as a parameter.
01:21:44.374 - 01:22:36.864, Speaker A: So what has changed now is that we still need to define that callback, but we need to pass extra data to that callback from our current function. And it can be done in this way. Now that we have that function, like not the function, but the contract definition node, we can use it in the callback. So back to our from nodes function call, there's the start, the start where we want to have the focus in versus code. So we will start on that node which should be the contract node. Now this is important, locations, locations that we want to show when someone clicks on that label. And let's say that we want to show the locations of functions that are inside the contract.
01:22:36.864 - 01:23:22.894, Speaker A: And so we need to create those, like fetch those locations or find those locations in the IR model. And it's very easy actually. So it expects an iterable, it can be list, it can be tuple, but let's say it's listening. But basically we can use node functions. And what's that? It's a tuple, which is almost the same as a list, and it's a list of functions. It expects something else, it expects multiple, and it can be peak or go to, it's not as important now let's just use peak for now. You can just save that.
01:23:22.894 - 01:24:16.542, Speaker A: It should be reloaded automatically. And when we click on that and actually it changed the name or something like that, or there may be an issue in the code. Let's just see the output now. So maybe let's just restart versus code to see where the problem is. Yeah, it's back. I'm not sure why it disappeared, but it's back. That's good.
01:24:16.542 - 01:25:05.684, Speaker A: And when we click on the demo, it shows locations of functions that are inside the contract definition. So what happened here is that we have defined code lengths, like a clickable button with some title, and it's possible to click on that. There's the callback defined on click, and when someone clicks on that label, this part of the code executes and it defines new commands that should be executed. And there's only one which just says that we want to move to some locations in the code. And those locations are functions that are defined inside that contract. And as you can see, it just works. So this is what LsP printers are all about.
01:25:05.684 - 01:25:32.976, Speaker A: And I think that's pretty much it. So thank you for following me. Any last questions? Yeah, it's a helper function from Python. I can replace it, actually, I can replace it with lambda if it helps. I'm not sure if this will help, but let me try. So I will remove that line. I will comment out this one.
01:25:32.976 - 01:26:20.430, Speaker A: Let's use lambda lambda function, which is like temporal function created right here, right now. It doesn't have a name, it's just anonymous function. And we can use self unclick. And here we can just invoke that onclick function and it should, it is the same as the previous one, but partial is somehow a helper function from Python, while this is a different approach that does the same thing and I hope that it will also work. I see it didn't disappear, it just moved its location. It was the first and now it's the second. So the reason for that is we have too many labels defined for that contract.
01:26:20.430 - 01:26:47.814, Speaker A: And because of the recompilation and things like that. It moved its location, but it should be still possible to use it, and it works the same. So this is a different approach for calling a function with like custom data passed now using a lambda function. Any other questions? I don't think so. Okay, so thank you and see you later.
