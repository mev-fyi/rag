00:00:00.680 - 00:00:23.754, Speaker A: Thank you. And I love you too, even as much as she does. Especially for coming here at this time of the day, even though you probably all coded very hard until yesterday. Five in the morning, you know this type. So, yeah, I'm Klaus. I'm with Vega. So obviously the most interesting thing I can talk about today is that Vega is now live and mine, and people can use it, and it's totally exciting.
00:00:23.754 - 00:01:02.184, Speaker A: So instead, I will talk about policies, which is very appropriate. We are here at the Institute for crypto Anarchy. So what's a better topic in an institute for anarchy than to talk about policy enforcement? So next time I actually call the talk policy for anarchists. And maybe I get a really interesting audience. So a little background on who I am. I worked on consensus way too early when nobody cared. I did my PhD on that topic in 2001, and then we tried to sell it.
00:01:02.184 - 00:01:30.696, Speaker A: Nobody wanted any. So I abandoned the topic. I loved it. But I figured at some point I should do something useful with my life that people actually use. So I went into privacy hardware security, started securing electrical power grids. So if you want nightmares, invite me for beer later and we can talk about the security of the real infrastructure that we all use. And then finally, somebody had found a business case for blockchains, and I had caught on.
00:01:30.696 - 00:02:03.696, Speaker A: That actually happened. So I'm back now, and as I said, working with Vega in the plumbing department. So I'm trying to make sure that below the ground, everything works right so that our great finance guys and UI guys can do their job and don't need to worry about the blockchain experience. Loading. So that's enough about me. Let's talk about why we need validator policies. So when bitcoin started the good old days, and sort of the big cypherpunk vision is we have millions of students in their dorm rooms that secure bitcoin.
00:02:03.696 - 00:02:28.664, Speaker A: And that's actually what happened. And it worked and it flew, and then it got really successful. And being a miner started being a business. And the same is now happening with pretty much all other blockchain infrastructure. So Ethereum is trying very hard to keep the old vision and have a million of validators. But even on Ethereum, it's a serious business. So you now need serious people to do mining and validating.
00:02:28.664 - 00:03:15.754, Speaker A: And once you have serious people doing serious stuff, you get business decisions that maybe end up centralizing stuff. So bitcoin actually had this problem that at some point, over 60% of the mining power ended up in China because that's where energy was cheap. So why build a miner in Germany where energy is expensive if you can go to China? So there was a point that was, in the end, thankfully resolved by the chinese government by kicking them all out, where the chinese government essentially could have owned bitcoin with one single law. So that's not decentralized. We have other things, economy of scale. We have regulation that some countries are just nicer to run a validator in than others. Some clients are easier to use than others.
00:03:15.754 - 00:03:49.254, Speaker A: So once people start serious business, we actually have centralizing forces in there. And no, the screen failed. Thankfully. Masari has just published a story a couple of weeks ago that totally made my point. They looked at a couple of major blockchain implementations and how diverse they are on validators. So we see avalanche. Already 41% of all avalanche validators are in the Amazon cloud.
00:03:49.254 - 00:04:19.806, Speaker A: So if the Amazon cloud goes down, then avalanche stops. But even worse, if you go by stake, it's 67%. So if Amazon actually tries to own avalanche, they already have all the hardware, and that is through all the blockchains they looked at. So we don't have the numbers for ethereum, but from all we know, it's not really perfect either. So this is actually a total nightmare. And if you look at things like client diversity, it gets even worse. Geographic distribution.
00:04:19.806 - 00:05:00.634, Speaker A: Again, avalanche somehow seems to make a good job in being the least decent centralized. Us and Germany together already have pretty much own all of these blockchains. So if us and Germany make a law, we want you to censor certain transactions, or please stop doing that. Either people can move very, very fast or all these ecosystems will come to a grinding halt. So we do have a problem, and it's not very visible, but it's slowly becoming. Obviously we need more diversity among validators. And the whole, all the centralizing forces we have, they're getting pretty bad.
00:05:00.634 - 00:05:32.154, Speaker A: And by proof of authority, and I think I'm the only person here who does not use Vitalik as proof of authority. I'm going further back in history. This is Leslie Lamprod. He actually invented our field. This is the guy who coined the term byzantine agreement, who essentially invented consensus protocols, at least a byzantine ones. And even he already said, well, when I invented this, I never meant actually active attackers, I meant sort of random failures. And as soon as you have failure dependency, the whole model breaks.
00:05:32.154 - 00:06:24.486, Speaker A: So that's ridiculous what you guys are doing. So even the founder of our field is telling us we got it all wrong and please do it differently. And yeah, we had, I mentioned bitcoin, ethereum, at an early point, a client failure, where they found out almost everybody's running the same client, even though we have four. And the SEC has also tried to assist my point by essentially declaring ethereum an american citizen. So congratulations ethereum, here's your citizen. So the first controversy, and this is something I would actually love to discuss later on, that's semi enforceability. So if I want a policy around, say, where a validator is, how can I actually find out where validator is? So of course they can tell me, which is nice, but they could lie if they see a financial incentive in this.
00:06:24.486 - 00:07:04.584, Speaker A: And we can never really for sure measure where validator is. We can run policies. The Tor people have actually done fantastic work in trying to find out where Tor servers are, but we can never be totally sure. So my argument is try anyhow, because not trying at all because of fear of failure is just worse. And my standard example is I know my door lock at home could be picked or probably is right now, but that doesn't mean that I should just leave my door open and put my valuables on the street. It still does a good job. So even if he can't enforce it perfectly, just leaving it to market forces leads to the slides we saw earlier, and that's what nobody wants.
00:07:04.584 - 00:07:44.876, Speaker A: Interesting thing that came out in this conference, there is work on Ethereum and validator privacy. So how can we help validators hide where they are? So we now have two desirable goals that are completely contradicting each other, but that will make science fun. So in implementing it, easiest thing is economic incentive. So you add diversity, we give you more money. We probably should do this anyhow, but it's not the final solution. So for one, we have contradictory policies that I then need to put down into one monetary award. We have validator business models that we don't necessarily understand.
00:07:44.876 - 00:08:30.594, Speaker A: So in Ethereum, most of the validators are now living by selling off mev. So how can I financially motivate you if your money source is actually coming from the outside? So it is probably something we should do to increase diversity, but it's not the solution. So the solution that I want to talk about and discuss is putting it inside the consensus protocol so that if the chain progresses, it actually itself enforces. There was a certain amount of diversity in the validators. So this is where I probably lose everybody. So that maybe either is your knowledge, proof of competence, that in the end you believe I know something, but you will have learned nothing, or you will have an intuition why it works. But either way is good for me.
00:08:30.594 - 00:09:05.954, Speaker A: So there's a fundamental proof, already done by Lamport back then, that if you have a finalizing protocol, you need less than a third. You can only tolerate up to a third of failures, actually less than a third. And the proof is very simple, unless it gets explained by me. Suppose we have three validators, the two green ones and the red ones. The red one, of course, being the evil guy. So left green here's from red, they now need to terminate, because from their point of view, right green could be evil. So left green and red come to conclusion, create a block.
00:09:05.954 - 00:09:39.358, Speaker A: Right green and red, same story. Right green sees input from red, since left green could be either creates a block with red. And what we have is now two sets of validators that are only joined by the bad guys that have both created blocks. So if the bad guys send different messages to both to left green and right green, then we have a fork. So this is why we can't define realization and everybody is in trouble. And if this is not single validators, but groups of validators, so the left green is hundred, red is hundred, and right green is hundred. Same logic works.
00:09:39.358 - 00:10:37.876, Speaker A: So the proof then is, if I have a set of validators that can, I have two sets of validators that have enough voting power to actually create a block, they need to overlap in at least one honest party. So I can't have a full, and then you can do some math and you come and, oh, that exactly happens if the number of dishonest validators is less than a third of the number of validators. So this is very basic thing from 1980 buckering us ever since. Now, the idea of what I'm going to do is the same also holds. If I go away from actually numbers and I say I want to be more flexible, I allow you to write down all sets of validators that you want to be corruptible at the same time. So say set a is all validators that are in China. So I want to corrupt, tolerate that all of China is corrupt, even if it's 60% of my validators, or all of Germany, or all of the US.
00:10:37.876 - 00:11:27.364, Speaker A: So just write down all the sets of validators that I say. They could be corrupted together. They have dependencies, they have the same clients, the same country, the same whatever, and then I can actually run the same proof and my original, I can tolerate a third of the validators turns into property of the set that if I write down all these sets, no union of three of the sets must cover all of the validators. If I have this I can do consensus. If that's not satisfied, then my policy is too inhibiting and I can't do anything. So this is where the formula stops for those people who don't like formulas. So what I've done, essentially, I went from the threshold model or the stake model to a set model where you can freely write down all the sets of validators that can collude against you.
00:11:27.364 - 00:12:10.046, Speaker A: And as long as this one condition is satisfied, you can have consensus. So now we can think of nice policies like each group of codes that has the same country or the same client implementation, or less than 20% of the stake can collude against, may be corrupted, and I still want to have consensus. There's some minor formalities there, and the projector is very kind to not show you the formula. So that probably makes things easier for everybody. That's the attempt to put latex on the slide by anyone using latex here. La stands for less lumpur. So that's a I mentioned earlier.
00:12:10.046 - 00:12:44.810, Speaker A: So he not only invented byzantine agreement, but also the science tool that everybody is using. So look him up, he's cool. So we now have sufficiency, have necessities. So that was a condition that's necessary to have consensus. Is it sufficient? And the fun thing is yes. So if you look at most protocols, like this is a code line from now comet BFT, formerly tendermint, and there you also have thresholds like two f plus one. So wait until you hear f is there the number of tolerated failures.
00:12:44.810 - 00:13:37.584, Speaker A: Wait for two f plus one inputs, and there are actually essentially three thresholds in this kind of protocols, if you count longest chains like Ethereum four. And we can translate all these thresholds into set properties and then just verify the set property in the protocol rather than counting. So all tendermint would need to do is give me an interface where they take out the two f one, give me an external function where I can say wait for a set that has a property that here is, if I have two of these sets, they intersect in an honest party. And for most protocols you actually have a pretty automatic translation of both the protocol and the proof. So the good thing is, if I switch into this model, almost all the modern protocols still work. So it's a relatively easy thing. Of course, better still menu, you look at it afterwards, but it's a pretty straightforward transformation.
00:13:37.584 - 00:14:27.084, Speaker A: Ethereum is a little bit more complicated, because Ethereum is a hybrid of several methods. It still works. I don't have time for that now, but I have a paper, so if you ping me up later on, I can send you a paper that explains how it works. I wouldn't put it onto Ethereum mainnet yet, but I think nobody would let me anyhow. So we we are good there. So if you look at basically all the consensus protocols, or all the different ways of consensus protocols out there, which is my totally arbitrary choice of them, most of the finalizing we can do are longest chains we can do, but we should talk, and we should really talk before we put it into Ethereum. So this is one of my goals, to get actually some of the Ethereum people to talk to me about it.
00:14:27.084 - 00:15:20.012, Speaker A: So now we have arbitrary sets. The next step is this is getting a little bit unwieldy if I just write down all the sets of validators that I want to be able to collude against me, and I already mentioned all the properties. So that's we then do more systematically. We select a bunch of properties like geography, like client implementation, like cloud provider, and then we define a policy around it, like I want each of those properties plus 20% of the rest to fail and then still do consensus. Now, the fun thing here is the formula I presented before essentially gives me an upper bound on the policy complexity. So we can now prove how diverse we can be, and at which point I can't reach consensus anymore. So I may have to say client diversity is more important to me than geography.
00:15:20.012 - 00:16:16.686, Speaker A: So I drop geography if otherwise I could. Policy gets too complex. And that's of course the second thing I would love to discuss. And since we now can have an upper bound on policy complexity, we probably want a policy. But the community has to decide which policies we actually want, which different vectors of diversity do we want to really focus on, and where do we say, this is nice if we can manage it, but if we can't manage it, then nobody dies too? Or if we can't manage it, then we definitely should look for more validator or pay minority validators more, or find another way out. There's more research to be done, but yeah, there's fun papers on other properties you want in the validator policies that give me a lot of potential for future ease. Parks Denver's whatever's so I'll part here.
00:16:16.686 - 00:17:06.266, Speaker A: How much time did I use yet? Perfect. So, parting summary if we implemented the way we're doing now, we are in trouble. Economic incentivization for diversity works to some extent, but there again, we have some forces, like being paid by MeV or trying to put 50 properties into one number where that doesn't work. We have a way to put policies into consensus level. It is relatively easily implemented, of course, still needs to be done, and as everything there once you actually start to software architects, they will probably tell you the 50 things where it's not easy, but on a conceptually research level it is easy. And there's three things we need to discuss. One is which diversity policy we actually want.
00:17:06.266 - 00:18:03.074, Speaker A: The second one is measurement and enforcement of properties. So how much do we want to trust a validator? They say they're in Australia versus the protocol actually verifies and we slash them if point out they're not. And the other thing I just learned here on the conference, how does this interact with validator privacy? Do we want validators to be able to hide their location and thus completely eliminate our ability to put them in based on their location? Do we need fund zero knowledge proof that they get a location certificate? And then we do everything in some zero knowledge part which. And it's fun to work for cryptographers again. So this is open questions. My goal is to put out there are possibilities to fix this problem. Details like what policies, what to do about these things is something that shouldn't be done by a researcher, but by community discussion.
00:18:03.074 - 00:18:19.924, Speaker A: And of course I forgot to put my QR code. I mean, the QR codes are big security risks, so there is none. So you need to either write me an email or Twitter or ask me in person afterwards. Thank you.
00:18:21.424 - 00:18:28.984, Speaker B: Thank you, Klaus. Our next presentation is in about five minutes. Any urgent questions?
