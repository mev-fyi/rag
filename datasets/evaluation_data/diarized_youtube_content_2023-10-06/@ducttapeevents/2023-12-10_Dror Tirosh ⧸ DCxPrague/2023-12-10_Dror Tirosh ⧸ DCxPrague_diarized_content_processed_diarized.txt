00:00:04.080 - 00:00:56.156, Speaker A: Okay. Hello, my name is Droghti Oroch. I work with the serum foundation on current obstruction and specifically on the fourth route 37 ERc. I'm here to describe today the mempool, the mempool of account abstraction Mempool of 4337. And I'm doing it by explaining the Ethereum mempool and then do all the comparison with the ESC 4337 mempool. So the TLDR of this talk is that mempools are great for decentralization and that accounts, smart accounts are extensions of the OA. So we need a mempool for account abstraction.
00:00:56.156 - 00:01:48.952, Speaker A: And basically nothing changed except of all the details behind that we will see later. First of all, about the security, the security of accounts on the Ethereum network. So there are three basic principles for account security. First of all, an account needs to be authenticated with a normal account is done by signing your ECDSA signature. Your account is derived from the public key of this signature. Of course, this makes you the owner of this account, the only one who can sign transactions, so that malicious party cannot impersonate and generate its own transactions. The other trait is that we need to, we need to prevent replay of transactions.
00:01:48.952 - 00:02:26.010, Speaker A: For that we have a replay protection mechanism, which is a nonce. Each transaction contains a unique identifier we call nonce. It's incremented. But what is important that it is unique, which means every transaction signature is unique and you cannot reuse the same transaction. It will be already available on the network. And the third and most complex of them is denial of service protection. How we prevent the idea is that an attacker that cannot generate transaction and cannot replay existing transaction might want to prevent you from getting your transaction to the network.
00:02:26.010 - 00:03:20.374, Speaker A: So the network is decentralized. You have many nodes, so even if one attempt to censor you, you will send to another. But we need a mechanism to make sure that an attacker cannot overload the network with transactions, and by that making a legitimate transaction drop because the network is out of resource. The way Ethereum achieves this is that each transaction has to pay in order to be included not in the mempool. The mempool itself is free, but you get into the mempool and then into a block. Only if you agree in advance that once you get included in the block, you will pay for this transaction. The analogy is you go into a store and you get a service.
00:03:20.374 - 00:04:13.764, Speaker A: Some pre sale service, some customer service will help you choose the product you like, because you gave your intention to eventually buy something. If you spend too much time and you take too much resources from these pre sale services. They will ask you politely, or less politely, to leave the store because you prove you are not going to pay for the service you are buying. How does this help? Of course, in order to overload the network and perform a denial of service over the network, you have to pay for each of those transactions separately. So it's going to be prohibitively expensive to overload the network. And also the gas price will rise. So it will rise somewhat for legitimate users, but for an attacker, the price increase will make this attack less feasible.
00:04:13.764 - 00:04:55.108, Speaker A: The last item is that you agreed to pay, and once you agreed to pay, you pay regardless of the outcome. Even if the transaction fails for any reason, you still pay for it. It will be an on chain revert, because the agreement doesn't mean the outcome of the transaction is anything that you like. You agreed to pay for this amount. These are the principles of account. So let's look how the flow of such a transaction when you send it over a network, we have a user, the user creates. Whoa, that's difficult.
00:04:55.108 - 00:05:32.024, Speaker A: Okay, number one, the user creates a transaction, signs a transaction, and send it over an RPC to a node. These nodes first validate this transaction that is valid against the current block. Validation means it checks that you have the balance to pay for it, and you have the nonce. This is the state of your account. And of course it checks the signature, that the signature is valid, and then it propagates it into the mempool. The mempool is basically a set of nodes connected to each other. So they use a different protocol, a point to point protocol, and they broadcast this transaction over.
00:05:32.024 - 00:06:29.854, Speaker A: Each node in this network performs the same check. It checks that this transaction is valid, it's about to pay, if and when it will be included in the block. It propagates all over the memp, the nodes, and then sometime later, one of the block builders is elected to create the next block. It decides what transaction it like to put into the block, and it performs a second validation. This time it is against the now current block, probably few blocks passed since the time you put this transaction into the mempool. So it makes sure that this transaction is still valid, that the nonce didn't change, and you still have a balance. It checks all the transaction in the block and create the next block and put it into the chain.
00:06:29.854 - 00:07:27.584, Speaker A: Now we're switching to account abstraction into a 4337 account, and we look what is the difference? Again, we look at the same security principles for abstracted account or smart account and EOA. So in terms of authorization, instead of just signature check, we call a method. This is why it is abstracted account. We call a method validate useerop. And this method can do whatever it likes. The simplest of them is check the signature, but it can be a multisig, it could be multiple roles, multiple signatures. We have several separate talks about all the possibilities that can be built on top of account abstraction.
00:07:27.584 - 00:07:58.026, Speaker A: To check the signature, we have a ripple protection mechanism. It's a bit more complex than the sequence number, but for security purposes it is just the same. It's a mechanism to make sure that each transaction, what we call user operation, is unique. And then we have the denial of service protection. We have transaction fee, you pay for the transaction fee. There is a slight difference because it is the EVM. This validate function has to send this ETH.
00:07:58.026 - 00:08:27.824, Speaker A: There is no mechanism under the hood to subtract from the account. So the account itself perform ETH transfer. But it's okay, it can be done by Paymaster. But again, it's an entity that pays. And again, the same principle, that the mempool is free and you have and you will pay regardless of your execution, regardless if it reverts. There are some caveats that we'll see what we call sandboxing. We will explain in a moment.
00:08:27.824 - 00:09:00.824, Speaker A: Now this is the flow of a transaction through the ERTG 447 memple. Not surprisingly, it's quite the same. The user creates a user operation. It's not a transaction, it's a different structure of transaction with all the fields and signs it and send it through RPC to a bundle node. The bundle node performs validation. This time the validation is an EVM call. It is done.
00:09:00.824 - 00:09:36.584, Speaker A: It checks the state against the current block state. It calls the method validateuserop to validate. The transaction is valid. It is propagated through the mempool, through all the nodes in the mempool, and again, each one of them has to perform the same validation. When time comes and we need to create a bundle, this is what the bundle does. It collects a lot of user operation and creates a bundle. It selects all the user operation at once to create a bundle and performs a second validation.
00:09:36.584 - 00:10:33.424, Speaker A: The important thing is that we see the first validation here and the second validation this time. It's not so trivial that the second validation will succeed just like in the normal mailing pool. If someone is able to create a user operation that pass first validation but fails a second validation, it can actually perform a DNA service on this network, it will create one or 1000 or 100,000 user operation. They all pass the first validation, they all propagate through all the nodes but failed the second validation. So the tricky part in account abstraction has to make sure that if it passes the first validation, we want to make sure it passes the second. We can see again there are two differences between them. There's a state change because few blocks passed since the time you submitted the transaction.
00:10:33.424 - 00:11:35.844, Speaker A: And now you validate multiple user operation, because you validate the entire bundle, all the transaction, all the user permission in a bundle, we have to validate them together because we submit them together into the chain. So just as a comparison, this is not a real validation. This is assuming that ethereum node was written in solidity, because this is the language we write code accounts. But let's assume for a moment that we use solidity to create a node. How would a node validate off chain each transaction before it submits? So this is basically what would be the code. It will perform an easy recovery to find what the account is. Then it would check against a mapping of balances that the maximum price of this transaction is payable by this account.
00:11:35.844 - 00:12:20.204, Speaker A: And lastly, it will check that the nonce is, the existing nonce is what the nonce is of this account, and increment it so that next transaction will use a different nonce. This is basically the logic that will pass. If we can see what can change over time with this signature cannot change. So first validation and second validation can use the same. You don't need even to repeat the signature. Check balances. We know in Ethereum that account balance cannot decrease if you didn't submit a transaction.
00:12:20.204 - 00:13:28.244, Speaker A: So account balance, if it was a given balance at one block, you know, that's several blocks later, unless of course you submitted another transaction, the balance either will be the same or higher. And yes, so basically you need to check that the nonce didn't change. This is an optimization that Ethereum can do when it validates a second performance, second validation. But so one very important trait that Ethereum has is that the validation of each account is separate from the validation of every other account, or isolated from every other account with account abstraction. This is an example of how we can create, since validation of account abstraction is an EVM code, you can do whatever you like. So I give you an example. Let's say that my function, the validation function, is checking the block number.
00:13:28.244 - 00:14:20.920, Speaker A: If the block number is 123, this transaction is okay. I send this transaction to the mempool, it validates okay, and then later on we try to include this transaction. It would fail, obviously because the block number changed. So if we were able to create an account using this validation, it will be an attack on the mempool because we can create a million of such transaction. The mempool get overloaded, nobody gets paid because this will never validate on chain validating the second validation. So this is something we need to block. We came to understanding that validation, it can depend on the state of the block, but it is not allowed to depend on anything outside of the state, like the environment, which is the block number, timestamp, block hash.
00:14:20.920 - 00:15:11.744, Speaker A: There's a set of opcodes that extend outside of the memory and outside of the storage, so validation is not allowed to use them. The other issue is what we call isolation. This is not purely simplified solid decode. Let's assume there is a global contract, and now all accounts access this global contract and incremental storage. And if you run each one of them isolate in isolation separately, the global storage is zero and you increment it by one. It's okay, you allowed to do it and you check that it is zero. But if you take ten transactions, ten user operations that perform this validation, the first will succeed, increment this value, all the rest will fail.
00:15:11.744 - 00:16:27.964, Speaker A: So you submitted one transaction, so I submit 1 million transactions, one of them will get on chain and all the rest will revert again. I attacked the network very cheaply for a single transaction. I created a large number of user operations which all get dropped from the mapple. So we need to, so the second thing we do during validation is that we need to block, we need to isolate user operations so they can't use storage that is shared between a user operation where these steps, if I'll go a bit back. What we mean is that when a bundler performs the validation and validates, it not only calls this method, it calls the EVM code and performs a check on the executed code that it didn't execute, opcodes that are invalid, the opcode that are blocked, and the storage accesses that we prevent. We call these the validation rules. So there's a set of validation rules within ERC 437 and.
00:16:27.964 - 00:17:12.924, Speaker A: But these are not relevant only to ERC 437. We argue that they are valid to any account abstract system. So any account that the validation uses EVM code, it can be native account abstraction that we describe later. We talked about later or other. You have to perform this validation rule, these restrictions, otherwise you open yourself to denial of service attacks. Because mempool are built in a way that you need first validation, and later on when you include the second validation. Okay, this is the example I gave.
00:17:12.924 - 00:17:44.068, Speaker A: Now, if you look at this decentralization model, which is a. Sorry, one more thing. I forgot about the bundlers. Bundlers are a new entity we added because they need to create a bundle. And you can see that each bundler is connected to a blockbuilder. What is very important is that each bundler is connected to a separate block builder. Just think about these two bundlers.
00:17:44.068 - 00:18:35.004, Speaker A: If they both connect to the same blockbuilder, that is, they listen to the mempool, they create a bundle, and they both submit it into either a mempool or directly into the block builder. What will happen is that most likely, since they listen to the same MPU, they have the same incentive, they will include the same user operations. So one of them will surely fail. A bundler can only submit a bundle to the blockbuilder that is building the next block. And only one of them can be, it's not a member API. It has to be a direct API that we know that my bundle gets included. Otherwise there is state changes that I'm unaware of, and this transaction might fail.
00:18:35.004 - 00:19:49.294, Speaker A: Now, this model, this, as you notice, I didn't mention it before, the elephant in the room, the small elephant that's sitting on these diagrams, this all works great as long as you're using a mempool. All transactions go through a mempool. What we know is that we do have some centralization factor in that all the MEV, we have searchers. And basically, if the Ethereum network actually looks something like this, there is a mampo. Users submit transactions to the mampo. There is those big entities that look at the mempool and create a very profitable set of transactions. And block builders, instead of listening to the mempool, because the, they are not that heavy, they have that resource to create those very, to search for these very profitable blocks, they all access the same MEV providers that will create for them a very profitable blocks.
00:19:49.294 - 00:20:25.898, Speaker A: And because you need a lot of resources to perform this MEV, there are very few elephants. So there is a centralization vector. This is something that happens in Ethereum. What I argue is that it is the same with account abstraction. There's no difference because these elephants, now they're listening on the Ethereum transaction. Once we have ERC 4337 mempool, they will listen to the ERC 4367 mempool. They create a block containing a bundle inside it.
00:20:25.898 - 00:20:57.444, Speaker A: They will do whatever they do whatever they need to validate these transactions. I don't even. They probably, yes, they probably will perform the second validation, but again, it's only a small part of their logic and processing power they need in order to create those very profitable blocks. So, yes, they exist. They exist in Ethereum. And four through seven doesn't make a big difference. It's not a real.
00:20:57.444 - 00:22:21.024, Speaker A: It didn't make the system behave differently just the same. So whatever solution that the Ethereum finds to reduce the centralization of MEV will be the same when you use a kind of suction. Okay, thank you. That what I had for the talk. Any questions? Any question from Istanbul? Okay, thank you. You should have repeated the questions for the audience for recording.
