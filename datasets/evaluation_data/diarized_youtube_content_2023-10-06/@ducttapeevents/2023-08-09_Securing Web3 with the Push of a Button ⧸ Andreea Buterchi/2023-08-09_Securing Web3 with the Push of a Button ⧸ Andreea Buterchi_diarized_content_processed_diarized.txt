00:00:01.080 - 00:01:14.994, Speaker A: Today I'm going to introduce you to our security as a service platform and show how users can use it to secure their web3 project. But before I'm talking about our platform, let me give you an overview of what we do at Veridice. So there are two main components to Veridice's business logic, and one of these components is performing web security audits. However, what we do at Veridice is to go beyond auditing, and we are also building tools that can automatically detect bugs and vulnerabilities in webtree projects. And we build the security as a service platform for the general users. So what I'm going to focus on in this talk is the security as a service platform we've been building and show how the users can use it to secure their projects at each development stage. All right, so at a high level, the Veridice SaaS provides instant access to push button security analysis tools that are based on state of the art formal methods and that allow developers to get audit results in real time.
00:01:14.994 - 00:02:34.694, Speaker A: And the main question is here, what is formal methods? So formal methods is a set of mathematically rigorous techniques for automatically finding bugs and constructing proofs about software correctness. And we can classify these formal methods techniques as either dynamic or static. And in particular, the dynamic techniques execute the program on interesting input and monitor what happens and with the goal of finding a particular bug. While the static techniques don't run the program, but they analyze the program, basically stare at the source code and try to reason about all execution paths. All right, so now that we clarified what is the difference between these two formal method techniques, we can zoom in on our SAS platform and show how users can interact with it. So basically the users have to provide two things, the source code and a configuration file which indicates what tool to run and some additional parameters required by that specific tool. And under the hood, our SAS platform will run that tool and output a report that contains all the findings.
00:02:34.694 - 00:03:56.670, Speaker A: So before diving deeper, I would like to to highlight some salient features of our platform. First of all, it is powered by multiple security analysis tools with complementary strengths, as we will see in the next slide. And it offers support for multiple blockchain languages because it was built in this blockchain and language agnostic way, and it also allows checking for common vulnerabilities as well as custom specifications. All right, so on the next slide we will explore how formal methods tools can be useful for preventing the defi attacks. And for that we will use a case study which involves running this so called flash loan contract so for those of you that are not familiar with the flash loan term, it is a type of loan where a user borrows assets with no upfront collateral, and then they return the borrowed assets in the same transaction. And if that doesn't happen, namely the funds are not returned, the flash loan is supposed to revert. Okay, so let's start analyzing this flash on contract, which implements the ERC 21 56 standard.
00:03:56.670 - 00:04:58.464, Speaker A: So I will walk you through the relevant parts of it and we'll focus on this flash loan method first. So this method implements the key functionality of the flash loan contract, and it takes three parameters. The receiver of the flash loan, the token, the flash on currency, and also the amount to borrow. And let's see what this function actually does. So in this code snippet, this function checks if the amount to be borrowed is less than the balance of the flesh on contract. And if that's the case, then the receiver is approved to use their old allowance plus the requested amount. Next, this method invokes this on flash loan method, which allows the receiver to use the funds.
00:04:58.464 - 00:06:07.864, Speaker A: And finally, this method will check if the receiver returned the expected amount, which is basically the amount they are using within this on flash on method plus some transaction fee. All right, so this looks like a reasonable implementation of the flash loan contract. However, let's ask the very dice tools if this contract has bugs. Okay, so the first tool that we are going to use is vanguard, a static analysis tools that can check for common vulnerabilities such as reentrancy, flash loans and so on. And the users can can interact with it by providing the source code and the list of detectors. And then vanguard under the hood, will run the source code against this list of detectors and will output a list of potential issues. All right, so we prepared a demo of vanguard and let's see it in action.
00:06:07.864 - 00:06:51.174, Speaker A: Oh, really? Okay, that's because we are working on it. Okay, so here you can see the interface of our SAS platform. So what we do here is to run a re entrancy check using vanguard. Here we upload the source code and the user indicates here the path to the source file and to some dependencies, if any. We named the source code and upload it to SAS. And next is selecting the source code of the source files. And here we check for the reentrancy issues.
00:06:51.174 - 00:07:54.154, Speaker A: Okay, so now vanguard runs and we'll output some helpful information for the users while it runs. And in a couple of seconds we'll see the output of it. And it indicates that it found three intrinsic vulnerabilities all right, so let's see what Vanguard is telling us more precisely. So, it says that when the flash on currency is ERC 777, then the transfer from function of it invokes an unknown callback. And after this callback runs, then the balance use field is updated based on a potentially stale value. And we are asking if this is actually a vulnerability, because we know that this kind of tool, static analyzers, can also output false positives. And for that, we are going to use another tool, which is orca, to investigate further.
00:07:54.154 - 00:08:44.180, Speaker A: So, Orca is a specification guided fuzzing framework that can generate concrete evidence of exploitability. Users provide the source code and a specification, and Orca, if it finds a violation, will output this counter example, which consists of a set of transactions along with their inputs, that led to this violation of the specification. All right, so we also prepared a demo for Orca. So let's see it in action. We will check if the balances of this flash loan contract are preserved. So, the next step is to run Orca against the same codebase as we ran Vanguard on, and to provide a specification. We can provide a custom specification, or we can choose one from our specification library.
00:08:44.180 - 00:09:33.176, Speaker A: So, as you can see here, we have specifications for the most common ERC standard. So we will choose one of them. I will show it to you on the next slide. All right, so now we let orca run. During the execution, it will output some information regarding the remaining fuzzing time and number of transactions issued. And in the end, Orca informs us that it found a country example, and it provides us with concrete information about how to initialize the environment and what transactions to perform in order to reproduce the country example. Okay, so if you are wondering what find this countering example, well, this is the specification.
00:09:33.176 - 00:10:30.484, Speaker A: We provided it as an input, and it is written in a specification language developed at veridice called v. So, in plain English, this specification says that it's never the case that after a successful call to the flesh on function, the balance of the flash loan contract decreases. Basically, no one can still fund from the flash loan contract. All right, so that information you saw on the previous slide can be translated to this, to this attacker contract, and let's analyze it on the next slide. So basically, this, this is how Orca initializes the contract involved in this attack. And then it provides the flesh on contract with some tokens to loan, and then it deploys this attacker contract. So let's see what this attacker contract contains.
00:10:30.484 - 00:11:36.762, Speaker A: All right, so one important thing to note here is that it uses this ERC 77 token as the flashloan currency. And since the transfer from method of the ERC 777 makes a call to the tokens to send, if it is registered, we see that the attacker does that such that it can perform that call during the attack. And next, it. It initializes the attack and borrows 65 tokens from the flashlan contract. Okay, so let's see how these two contracts interact. We come back to the flashlan contract, and we see that it invokes the on flash loan method. And in this on Flash method, as I mentioned initially, the attacker is supposed to to use the borrowed funds in some way.
00:11:36.762 - 00:12:30.954, Speaker A: So let's see what happens in this method. If we go back here in the attacker contract, we see that the attacker does absolutely nothing with the flash loan, and it simply returns this callback success, which will bring us back to the flash loan contract. So we move to the next code snippet, and we see here that the flash loan method tries to transfer from the receiver the borrowed amount plus some fee. But if we remember, the attacker didn't do anything with the fund, and the amount that has to be transferred back is only the fee. Right. Also recall that the ERC 777 makes a call to the tokens to send off the attackers. So let's see what happens in this tokens to send method.
00:12:30.954 - 00:13:31.134, Speaker A: So in this method, we see that the attacker does something very sneaky and transfer 42 tokens from the flash loan to themselves. And this is successful because there is a bug in the flash loan contract. So, because the defeat to be transferred is less than the current balance of the attacker, which is 42. Now, because they transferred, they stole the money from the flash loan, the call succeeds, and the flash loan completes successfully. And, yeah, so the conclusion here is that the attacker stole 42 tokens because the allowances were not set to the initial value before the transfer from call. All right, so despite looking reasonable, this contract contained a subtle bug that was caught by our SAS platform. And just a recap of what we did today.
00:13:31.134 - 00:14:28.954, Speaker A: So we started by using two tools in the SAS platform to find this serious issue. And first, we used this inexpensive static analysis tool called Vanguard to scan for potential problems. And then we used a fuzzing tool called Orca to investigate further and generate a concrete exploit. So we anticipate that this will be a typical usage for our SAS platform in the future. The main takeaway here is that the automated formal method techniques can augment human intelligence and make it easier for developers and auditors to catch critical bugs. And if you are interested in testing our tools, we wanted to let you know that we accept beta clients for our SAS platform. So make sure you contact us after this call talk.
00:14:28.954 - 00:14:52.174, Speaker A: Okay. So don't forget that we are also performing audits. How we auditing in the past defis amms, stablecoins, wallets and also zero knowledge proofs circuit. And here is a list of our previous clients. Okay, that was all for today. Thank you very much. And if you have questions, I'm happy to address them.
00:15:04.234 - 00:15:30.304, Speaker B: Is it possible for the API tool, because this is basically an API tool, right? Is it possible for it to also detect the type of the contract? For example, I just upload a solidity file and it says, okay, this is a flash loan contract or this is some other sort of contract. Can I do that as well? Not checking for security vulnerabilities, but just for the type of the contract?
00:15:30.604 - 00:15:35.206, Speaker A: No, I don't think that it can do that right now. But it's an interesting feature. So.
00:15:35.340 - 00:15:40.214, Speaker B: Yeah. Are you looking into that? Because that, okay, yeah. Okay.
00:15:40.594 - 00:15:41.530, Speaker A: Okay.
00:15:41.722 - 00:15:51.134, Speaker B: And also what would be the, do you have an approximate cost estimation for the SAS tool? Like how much would it cost?
00:15:51.594 - 00:16:02.932, Speaker A: For now it's like it will be free for three months. Right. For the beta customers. But after that we'll figure out how much we will the customers for our services.
00:16:03.068 - 00:16:03.700, Speaker B: Okay.
00:16:03.812 - 00:16:09.788, Speaker A: Yeah. Based on the usage and so on and the complexity of the projects, there are many criteria.
00:16:09.916 - 00:16:14.748, Speaker B: And are you looking into publishing the public?
00:16:14.796 - 00:16:17.116, Speaker A: Yeah, some open source versions.
00:16:17.180 - 00:16:18.676, Speaker B: Okay. Yeah, that will be cool as well.
00:16:18.700 - 00:16:20.092, Speaker C: Because I used to use it a.
00:16:20.108 - 00:16:22.732, Speaker B: Lot and now you made it private and that's a big bummer.
00:16:22.868 - 00:16:32.080, Speaker A: Yeah, because we are working on it and we try to figure out which part, part of it would be open source and which part would be integrated with the SaaS.
00:16:32.192 - 00:16:33.364, Speaker B: Awesome. Okay.
00:16:36.064 - 00:16:37.484, Speaker D: Any other questions?
00:16:42.224 - 00:16:54.694, Speaker C: Can I, so if I will use your apwise, can I pause withdrawal contract?
00:16:56.434 - 00:16:58.414, Speaker A: I don't think I heard the question.
00:16:59.394 - 00:17:22.434, Speaker C: So suppose I run protocol and I subscribe to your service, SAS service, and I receive some alert message like can I pass my withdrawal contacts? If flash loan attack will be detected, another attack will be detected. Can I pass my withdrawal contact?
00:17:23.174 - 00:17:28.434, Speaker D: Is it possible to post the withdrawal contract if there is an attack?
00:17:29.414 - 00:17:41.270, Speaker A: I'm not sure. We are only detecting the issues. Our tools are not integrated with the main network, if that's your question. I think that depends on you. Right.
00:17:41.382 - 00:18:05.764, Speaker E: It doesn't run all the time, it doesn't run continuously, but you need to literally create the request for running the audit at a particular time on a particular contract, like it's not running in the background automatically. And once it detects the vulnerability, you're the one who actually needs to take action on the contract. And then you can pause it, I suppose, but. Yeah.
00:18:09.184 - 00:18:26.254, Speaker A: I see. So, yeah, that's the main purpose of our SaaS platform. Right. You can use it before deploying your contracts to secure your product, to make sure that once you deploy it, it will be secured and. Right. Yeah, I think that's my answer to your question.
00:18:29.754 - 00:18:31.174, Speaker D: Any other questions?
00:18:34.114 - 00:19:04.164, Speaker B: Just one question. Since this is entirely off chain, have you thought about maybe storing the data you retrieved by the API on chain? Because then you could use it on chain. For example, if you store the security of a, or the security of a flashlight contract that you audited on chain, then Aave could theoretically query that data and basically block any malicious contracts. Have you thought about that as well?
00:19:05.184 - 00:19:30.964, Speaker A: Not really. What we want to do is to, to basically clone the state. So basically we can also audit contracts that are deployed on the main network. Right. And we can clone that particular state and, you know, run our tools on those contracts. But we don't have these features like reporting potential issues existing on the main network already. But we are looking into that.
00:19:31.084 - 00:19:59.226, Speaker B: Yeah. Because that will be tremendous for the web3 ecosystem because right now smart contracts are entirely in the blind on chain when it comes to security. And you have off chain PDF documents which store audits, but they're entirely useless on the blockchain itself because you, if you could do that on the blockchain itself, you could actually, well, make a security ecosystem. Right?
00:19:59.370 - 00:20:00.226, Speaker A: Yeah, that's true.
00:20:00.290 - 00:20:00.938, Speaker B: Yeah.
00:20:01.106 - 00:20:02.334, Speaker A: Yeah. Thank you.
00:20:04.284 - 00:20:12.264, Speaker C: Just one thing. I heard there's a very nice tool in the making called Turtleshell XYZ. You can check it out.
00:20:14.444 - 00:20:24.824, Speaker B: It basically tries to do that. It basically tries to store that data on chain to make it workable. So, yeah, we'd like to.
00:20:30.094 - 00:20:43.774, Speaker D: Okay, so thank you, guys. That's all for nowhere.
