00:00:13.160 - 00:00:18.086, Speaker A: Hello. Hello, everyone. How's it going? My name is Max Lomoucho.
00:00:18.190 - 00:00:20.158, Speaker B: I'm David Leonardi. Nice to meet you.
00:00:20.246 - 00:00:44.804, Speaker A: We are from Connext. We are a bridge and interoperability protocol. We basically have to make blockchains, layer twos and domains composable in a very, very secure way. And so we thought today we're going to talk. We can talk a little bit about how we can scale Ethereum, how we can make interoperable between the different layers that are being created. But first thing first, Ethereum is scaling. That's the great news.
00:00:44.804 - 00:01:49.254, Speaker A: All the layer tools are finally finding some kind of product market fit, finally finding the right incentives, the right mechanism to attract dapps, and allowing Ethereum to kind of become less congested and bring a lot of the operations up to the layer twos. But there is a but this scaling has some issues, and this is fragmentations. This is how the scaling of Ethereum looks like a series of layers, a series of different roll ups that kind of start to fragment three things, the liquidity that is present on the different layers, the data and the users. And this starts to complicate things because all of a sudden you don't have a unified experience as you used to have in Ethereum, but we have multiple small chunks of bits. And so what happens is that the different layer twos are very well connected to Ethereum, arbitrary with Ethereum, optimism with Ethereum, and all the different layer twos, but are not really connected to each other. They're not really integrated with each other. So that's what Connext does.
00:01:49.254 - 00:02:51.200, Speaker A: We aim to really unify the experience across all the different layers, whether it's an l two or an l one. We according to connect 17 chains, 17 different domains, the Ethereum and the layer two s, the cosmos ecosystem, the Polkadot ecosystem, avalanche, phantom polygon, you name it. And we do it in a very, very secure way. So we then have to do a kind of premise on how do bridges work, right? How can we make it more secure than the others? So let's have a look at a different type of bridges that exist today, and then we'll explain how connext works. So the first one, the first type is we kind of define them as native bridges, and they are the bridges that are verified basically by all the validation, all the validators on the base layer, on the, on the, on the base chain. Let's say this is the case for the layer two s, for example, where all the validators of Ethereum verify the connections between Ethereum and Arbitram, for example. These are very, very secure.
00:02:51.200 - 00:03:29.624, Speaker A: That's why they took so many years of research, and that's why they're so effectively scaling Ethereum, which is great. But they have an issue. They are not extensible, meaning that they only work for the connection, if you want. They were custom created for, for example, the bridge between Ethereum and Arbitrum only works between Ethereum and Arbitrum. The bridge between optimism and Ethereum only works between optimism and Ethereum. And the same thing happens for other type of technologies, like IBC for Cosmos, where it's very effective and very secure within the cosmos ecosystem. But outside of the cosmos ecosystem, it doesn't work.
00:03:29.624 - 00:04:32.478, Speaker A: Then we have what we call externally verified bridges, which are very common today, across the different architectural bridges, where we have a third party that is normally a series of multi sigs, a series of validators that are in charge of verifying what happens on one chain and then say, okay, something else can happen on the other chain. These are the cases of, for example, multi chain synapse layer in image. What's the issue with that? Is that now you have to trust a third party. It kind of put in discussion everything that we did with blockchains, trying to make it more permissionless and decentralized. And now you have another third party that you have to trust if you want to move this information, these tokens from one chain to another one, so they're not secure. We have then locally verified bridges where the relationship to move, basically, the process to move tokens or data across chains is validated by just two parties. So the relationship is simplified by two parties.
00:04:32.478 - 00:05:23.196, Speaker A: This is the case, for example, for atomic swaps, which is how connext works today, where there is a liquidity provider on the other side, the user on the first side, they both lock their tokens and then they swap them at a time. These are good because they're very secure and they're very extensible to different domains or different chains. But unfortunately, they have some limitations, so they cannot pass any type of data and they don't have any optimal user experience. So we introduced the last type of bridge, the last type of bridge that we called optimistic bridges. This was a mechanism that was pioneered by nomad. And the guys at Nomad say, okay, by definition, it's impossible to verify that something that happened on one domain. Sorry, it's impossible to verify from one domain that something has happened on another domain because the two ecosystem are separated.
00:05:23.196 - 00:06:08.720, Speaker A: What we can do is to verify if something has not happened on the other domain with fraud proofs. So what happens basically with optimistic bridges, there is somebody, a relayer, that brings a message from one chain to another one. But then before the message becomes valid, there is a 30 minutes latency period. And during this period, any watcher can come with a proof and say, hey, this message is not correct and I can prove it from the origin chain. And so this is a way to keep the system secure, where any watch, there is an unlimited number of watchers. And we only need one good actor basically to keep the system secure, because anybody can come and say, hey, this message is fraud, this message is not correct. So all we need is one good actor, which is a fairly good assumption to make in the system.
00:06:08.720 - 00:06:44.336, Speaker A: It's a very extensible approach to different domains. But a trade off here is latency. So a user has to wait 30 minutes, which is not ideal. So how do we solve this? We saw that different bridges have different trade offs. How can we solve these limitations that each of them have? Well, the same way that blockchains are solving it with modularity, basically. So what we're trying to do now is to build a stack, which is called the model interoperability stack, where we have different layers. In our case, it's nomad and connext that do not compromise on security, but, but kind of try to balance the different trade offs.
00:06:44.336 - 00:07:27.860, Speaker A: So we have nomad on one side that is saying, hey, I bring you the information, I bring you some tokens from one chain to another one, from arbitrum to optimism. And this might take 30 minutes, but it's super secure. And on top of it, conduct says, hey, you, users do not have to wait for 30 minutes. I will give you the cash immediately so you can go and do whatever you want. And I will wait for this low refund in 30 minutes. So in this way, we are actually enabled a very secure system with very limited trade offs that can connect different chains and different domains. And this is important because once we are able to unify these different ecosystems and make them composable, we can actually change our mindset from a world that is multi chain, where the major protocols have deployed on the different domains.
00:07:27.860 - 00:07:59.084, Speaker A: Think about Aave, think about curve that are on different chains. But these domains, these instances are currently isolated. So it's a multi chain world, but it's not a cross chain world, yet we connect, we can actually think about as a unified ecosystem where the users do not need to know which chain is interacting with the applications. The protocol can basically interact on the background on the different domains. So David here is going to explain us how do we move into this cross chain world and building cross chain applications.
00:07:59.464 - 00:08:39.570, Speaker B: Thank you, Max. So let's take a look at how we can build X apps. But to understand that first, or to get to there, we want to first know what, there's a bunch of different applications that are ideal for this kind of scenario. So Dexs, for instance. So swap tokens across multiple bridges with the best price or yield aggregation or lending or governance, which is a super interesting one, where you can have a central hub and one chain that is very cheap in gas, and collect votes from a bunch of different chains, and perhaps execute some callbacks and maybe send some tokens or whatever back to different chains and many more. Right? So we're really looking to explore what the community and what the whole ecosystem comes up with. But fundamentally, it's a very flexible system.
00:08:39.570 - 00:09:47.870, Speaker B: So what are we building here? So we're essentially creating promises or asynchronous, asynchronous solidity. So on the original chain, we will have a contract which has a state of s, one at a specific snapshot and time. And on the destination chain we have a target contract, which will then have a snapshot of a specific time. And this allows us to send a message across chain and receive a callback when the execution has been successfully completed in a secure way on the target chain, and then execute a callback from the origin chain to complete all of our actions. So what does this look like? We have two contracts, as we said, one in the source chain or one in the sending chain, one in the receiving chain. And we have our magic sauce, which is xcall, which is pretty much the equivalent of the call method and the call method, or the Xcall method, which accepts an arbitrary amount of arguments, which fundamentally are the payloads and the token, the origin chain and the destination chain. Those then go and talk to the connext contracts, which then relay and transmits all of this information through our infrastructure, which does a bit of magic.
00:09:47.870 - 00:10:25.724, Speaker B: We'll get into that in a second, then relays this on the destination chain, and then finally onto your own contract. So there's a few different use cases. Let's take a look at token transfers. So we got into this quick explanation that we have this fast liquidity chain. So a canonical token can get sent via the relayers to a destination chain. And here we have these relayers that take the risk to relay the tokens from chain a to chain b, but they know that they have the guarantee of receiving the tokens from the optimistic bridge. So this transfer actually is executed in a very fast way, usually within a few minutes.
00:10:25.724 - 00:11:19.394, Speaker B: We then have the optimistic liquidity transfer in the case in which there is no liquidity for a specific token. And in this case, all of this actually goes through the bridge itself, in which a token, a canonical token, is locked. Assuming we are sending it from a region chain that hosts a canonical token, it's locked into the bridge. The bridge then mints out the destination token on the destination chain, and this is then passed on to the user or to the relayer to reimburse him for the transaction, or to pass it back to the user as needed. We can do the same thing with data. We can handle authenticated data, or specifically for permissioned calls. And in this case, because it's permissioned, and we need to make sure that the sender is validated, this needs to go through the bridge, through the optimistic bridge to be able to successfully execute this call.
00:11:19.394 - 00:12:06.222, Speaker B: In the case of unpermissioned calls, this can also happen through the relayer. So in the instance of a dex, the configuration for the payloads that needs to go out to specify what swap needs to be executed can be contained and transmitted via the relayers directly. So fundamentally we have two contracts via the bridge or the relayers, and it's as if you're just calling source contract or target contract from the source contract. The rest is really handled from our infrastructure in a very simple way. So let's take a look at code. So we have a target function that is update value on chain b that we want to call on chain a. And on the source chain we encode the target function and send it as a call data parameter.
00:12:06.222 - 00:12:53.988, Speaker B: And then we specify the other parameters that are truncated in the specific case. And what we really want to point out here is that we have xcall in the bottom, which is pretty much our equivalent of the call method. And we can also specify a callback, which, once the executed function on the target chain has executed, will then be executed on the source chain. This specific example on the rights is permissioned. You can see this because it has a modifier that is only executor. If we want to do this in a permissionless way, we can simply remove that modifier, and that's as simple as it is to get started. It's really simple.
00:12:53.988 - 00:13:39.106, Speaker B: We have a doc site which is complete with a bunch of examples. We're currently, this is a living document as we go and extend it with functionality and use cases. We also have a GitHub repo, which you can simply clone and really get started very quickly with a sample project to do some bridging in a very quick way. And you can definitely reach out to us on discord and Twitter and all the rest of the usual channels, and we'll gladly be there to help and support you through all of your, let's say, development journey and shameless shill. We also have a bunch of t shirts and swag if Cecil wants some. We have some of these amazing octopus bridging entities and some of the wolf. So if you would like some of those, come up to me and I'll gladly have some some of these out to you guys and that's it.
00:13:39.106 - 00:13:39.826, Speaker B: Thanks for your time.
00:13:39.890 - 00:13:40.154, Speaker A: Thank you.
