00:00:00.200 - 00:00:44.974, Speaker A: All right, thank you everyone. Not many people interested for some reason anyway. So how many people here know about functional programming in general? So people actually interested and want to hear this talk? So I hope today I can. The goal of today's talk is to demonstrate the possibility of limited kind of functional programming capabilities in solidity and show example of how to use this paradigm to build something called a super token. And also, if you are not yet make you interested in, let's say, functional programming. A bit about me, I'm meow, I'm super fluid and very happy to be here. Let's go to a quick example.
00:00:44.974 - 00:01:25.600, Speaker A: This example, the code into three sections, if you will. The first section is the reading data. The second section is transforming those data, like in memory data. Then the third section will be actually stored those data. So it's kind of, for example, how I would structure so called a functional programming. And so let's walk step by step to see what I mean here is functional programming. So functional programming is a style of programming to describe declaratively, if you heard of the word basically about defining more, what do you want as opposed to how to do it.
00:01:25.600 - 00:02:37.414, Speaker A: So describe step by step how things should be done, but you describe what should be the effect. So in practice, it implement as much as the code possible in data definitions, equations or logical formulas, which would have been called properties. And for this code, what could be helpful is to define so called strictly pure functions, which solidity has limited support, which I will mention in a minute, they are your friends, because something called a referential transparency, which means same input you will get with same input you will get the same output. That's one way to put it. With that, it's deferring the so called side effects. So what are the common side effects we're talking about here? Like in VVM, when you access the storage, meaning reading value values effects, when you interact with external code, interact with uniswap, right? And that's actually a side effect. External code code, for example like this, okay.
00:02:37.414 - 00:03:23.672, Speaker A: And computation strategy, which is a bit obscure, what do I mean? But that's actually in effect computation strategy, because when you define everything as what? Because there's no how component, right? So when do you execute what is actually a computation strategy in abstract sense. Right? So to make the code actually useful, the implement, the computational strategy is required, right? So most of language you don't talk about that because you just mix everything together. It's when you do insulated, when you do something equal to something you already defining the computation strategy, right. So it kind of taken for granted. That's why people talk about it much. Typically it's a sequential, right. In solidity, you're always dealing with things like sequentially, right from top to bottom.
00:03:23.672 - 00:04:15.024, Speaker A: So that's where the so called sequential programming, some people call it Monad scary, but I mentioned a bit later. But if you think broadly, there are different computational strategies, right, about concurrently or graphic, it's really good for distributed computing when you talk about things that are necessarily sequential but parallel. That's why there are proponents for Utxos, because things can be really computed in parallel like graph computing. And I think of a more maybe relatable example, think of the spreadsheets. So in spreadsheets you don't describe how what you do, you just define formulas. Things are actually compute as like graph computing in parallel. So graphic spreadsheet is actually a functional program language in a way that is a massive parallel computing in a sense, if you will.
00:04:15.024 - 00:04:58.294, Speaker A: So I describe what it is, but why we do this. So some of you might ask, I recommend this paper from John Hughes, a really old paper actually, but it's a really short and sweet paper. Describe all the basic principles and to the point. So one functional program matters from John Hughes. It's a great drug, I would say. One of the sentence I really like to quote is that as a software becomes more and more complex, it is more and more important to structure it well. And well structured software is easy to write, easy to debug, and provides a collection of modules that can be reused to reduce the future programming costs.
00:04:58.294 - 00:05:40.592, Speaker A: That was something very prescient said in 1989. Fast forward 30 years. So the keywords are really about better and less kind of cheaper maintenance cost, right? So this is my opinion, but I think I will show a little bit. Think so. But I think it is best way to structure smart contracts. With the limitations, we can still extract as much as possible from the language itself, right. So it is additional, we all do testing.
00:05:40.592 - 00:06:14.212, Speaker A: If we do serious smart contract, we do a lot of testing and perhaps also limited post production formal application. Some projects use Torah, for example, some small scope, toy example may use SMC checkers from the solidity compiler itself, but those are post production form verifications. But functional programming would be addition in my opinion. So addition to these. So it allows you to structure the program upfront better, as opposed to wait everything compiled and tested. Right. So two different approach.
00:06:14.212 - 00:06:59.834, Speaker A: I would say it is a good addition for building a better smart contract going forward. So in a way that people like to call construction. But I think we all know that it's people that in this space, in the correctness programming space, know that there's such thing called correctness by construction, because it's impossible at the moment, at least not easily. So I would like to just call it more correctness by construction. So finally, back to solidity. So, solidity, well, a disclaimer, there's nowhere near being able to express all the functional programming ideas, but we can emulate some ideas. So I'm going to show you a couple of techniques that I think is helpful for you.
00:06:59.834 - 00:07:37.806, Speaker A: So custom types something new that people tend not to like it because of the wrap and unwrap kind of spaghetti code. Sometimes it generates not spaghetti, but more like bit ugly, some people would say. But it is good abstraction device for you to actually make the type more strong. One of the things about functional programming that you probably would want a more strong type system, and custom type is one good avenue for that. And since solidity 8.19, there's also a support for operator overloading. So let me show you example here.
00:07:37.806 - 00:08:15.970, Speaker A: So this is part of the live code that we have at superfluid. The first line would be defining so called a flow rate. What do we do in fluid? Define it as inter 128. And as you can see, there's a pure function, which I'll mention in a minute. What does it do later? And I define, okay, there's this helper function for adding two flow rates together and returning a flow rate. And the last, the other is subtraction. And since solidity 19, you can do this rather bizarre syntax for rewriting the plus and minus.
00:08:15.970 - 00:08:48.534, Speaker A: So that makes unwrapping and wrapping less commonplace when you do the syntax slightly better. So that's one thing you can use in solidity. Solidity always does this. They only go halfway. So the things that you can't mix type, you can't mix flow rate or time. And if you want to do a multiplication, I can't define with two different types, unfortunately, I have to kind of define. The usual approach in solidity is you define a library, an internal function you use.
00:08:48.534 - 00:09:17.034, Speaker A: You say that therefore all the value of flow rate. I have a convenient function multiplication for multiplying flow rate and time. There are here. So what is a result of multiplying flow rate and time? Oh, actually the returns a value, so the type actually matches, which is great. So there's something called strictly pure function. Solidity is pure function is not very pure. I'm going to show you in a minute.
00:09:17.034 - 00:09:44.420, Speaker A: Pure function is really about a referential transparency. But solidity is kind of a mix of JavaScript, C, all the languages, right? So it's more similar to JavaScript. When you pass memory in, you can actually modify the input memory while you are calling it the pure function. So you, it's not really pure, right. So the approach I do the library that I create is that I always do clone. So I make sure that I don't touch the input. I always do a clone.
00:09:44.420 - 00:10:24.276, Speaker A: So you may argue you're wasting gas. In this case I would argue it's probably very negligible, but then you make your code more principled. So when I say pure function in solidity, I say strictly pure. I always copy clone the input. So that's something I would recommend also you to do if you start programming. Another thing some people may be curious is that can we define a more generic or polymorphic, some people might say version of the clone. Unfortunately I can't maybe solidify something generic programming the next version, so maybe I could do that.
00:10:24.276 - 00:11:15.114, Speaker A: But for now I have to define a clone function for each data type. So it's a bit of boilerplate, but it is what it is. So we have two functions, strictly pure functions. In this case. One is return a real time balance when you give the inputs and time, and you can calculate multiply the flow rate with time minus the delta time and plus the set to the value. So you get a pure function version of the real time balance and there is a settle function which you take the input a and you clone it, and you do some calculation, you set some fields and you turn the new value. So all these making sure that you don't touch the inputs ever, always clone and new result, that's the invalidity.
00:11:15.114 - 00:11:47.046, Speaker A: The last thing is something that you can also use in solidity is function pointers, which is a feature that not really people using a lot, but I have actually a very good example of how you can benefit from it. So in this particular case I do it for the test generations. So I define make it better in solidity bar. That's what I end up with. So I don't know what input operations, but I just define function pointers. So this is my test templates. So I do some operations and do some assertions.
00:11:47.046 - 00:12:28.598, Speaker A: Blah. Now I can generate four different tests with a few lines of code provide, okay, I need a shift operation for both op one, ob two. That makes flow flow flow shift and shift flow. So all the components in a way, basically four different test cases using this data function forgot to mention I'm using foundry here. So it's actually foundry generated random inputs here. So none of these, I'm specifying hard coded values, but you can generate all the test cases like this. So now I give you the overview of what building blocks you have in solidity that you could utilize to make your programming style.
00:12:28.598 - 00:13:01.204, Speaker A: So what's a playbook? How do we actually do it? Do I have time? Okay, so let's do a step, step by step. First, define data. This is trivial. You just define struct, and you also want to define clone functions, we said before. So for each structure, a clone function. Now we don't have mm copy, so we have to do this kind of silly way of doing it. Then you a function that is transforming those data structure defined, right, so, strictly pure functions in solidity.
00:13:01.204 - 00:13:28.470, Speaker A: Two examples. One is shifting value from a. Oops. Shifting value from a to, with a value, input x. So you just do the plus x, right? So input clone, do some calculation, return a new value, right? So never touch input data like mantra. Now, when you do the flow, it's the same. In this case, you just change the flow rate to a value, right.
00:13:28.470 - 00:13:58.176, Speaker A: So these are the strictly pure functions you can implement in solidity. Okay. Step is that you find these so called properties so that you can tests for, right, so now you define a bunch of function. How do you know if it works? Right. It's really property based, if you're familiar with the concepts. So, property, usually there are the mathematical laws, governs how these functions work together, right. And test it through the proper testing.
00:13:58.176 - 00:14:24.252, Speaker A: Foundry has good support now, right? So you can use foundry fuzzing test framework as a way to test that. I give you some examples. For example, I have the function showed you. I want to have these two formulas always satisfy, right? So I settle twice and I set it once and I check the timestamp. They should match t one equal to t one. And I set it twice with the same t one. They end up the same one.
00:14:24.252 - 00:14:50.288, Speaker A: So these are another property. How do I know? I have a function that works. I use foundry. I say, give me some random p, give me some random value, and I do this, settle and check if that works. Great. So that's how you test that in foundry, hard code, anything, you test everything that can randomize you for another example would be something seemingly very trivial. But it's important to test trivial things so that you can build stuff layer by layer, right? You don't miss any, you don't want to miss anything.
00:14:50.288 - 00:15:29.048, Speaker A: Sometimes it's very expensive to debug all the way to the bottom, right? So in this case, seemingly travel trivial associativity law. How to call this? Append to b, append to c equal to a, append to b to append c, but with different brackets, order. So how do I test? I say give me some random generated data structure, p one, p two. And somehow this is truncated, I think C, right. So ABC. And I do assertion, say if I append them in different orders, the value should be the same. So that's how you test it with different, and they should always match.
00:15:29.048 - 00:16:04.696, Speaker A: Now you have something you can trust to build something on top of it, right? So, okay, so now we have a beautiful function. Don't really do anything, right? You don't store anything, they don't have sequence of when to call which one, right? So now the last step is to stitch everything together using like Internet interact with code or storage access. So the m word is, you are familiar with functional programming. There's a word that no one can explain. It's almost like joke. So no one managed to explain what is Monad. Right.
00:16:04.696 - 00:16:45.364, Speaker A: But one use case I want to mention that maybe help to understand is Monad just a way of highly reusable code for side effects? Yeah. So a way to emulate concepts of monad in solidity is to use something called abstract contract. I think everyone use it, but I use it in a particular way to emulate the idea of monads. So the first step would be creating virtual function. So how do I know what side effects I want? Well, the solution is that you don't. So you define it as a virtual function. So you leave to the implementation to define what other side effects they want to actually implement.
00:16:45.364 - 00:17:20.600, Speaker A: So you leave it at the virtual function and then it has to be abstract contract also, right? So the second step would be actually implement an effectful function that call those virtual functions. So in this particular coding style, you say, okay, I want to retrieve some data. They are calling those virtual functions. I have no idea what those function is actually in the actual implementation. Doesn't matter to me because all I want is when I have those data, I call the data transformations. Remember, these are the pure functions. So I get a new value for a and b.
00:17:20.600 - 00:17:52.054, Speaker A: Then I apply the updating side effects as storage update. So read, calculate, store. In this case, I store something called index and store the flow value. And done. So I have a effectful function which leaves all the side effects, deferred the definition to the virtual functions. So that's one way to emulate so called monads. In this case, it's fancy word for how to stitch everything together in sequence.
00:17:52.054 - 00:18:22.640, Speaker A: Right. You sequentialize the strategy. So recap. So what we need to do for this coding style is to define the data, define the strict pure functions for the data, you find these and write tests for them. And foundry provide a very good framework. Now, I think I just switched to it for now. Maybe in the next year there's some new tools, who knows? But last step is stitching everything together with a strict separation of pure function artifacts.
00:18:22.640 - 00:18:49.872, Speaker A: So that's what you want. One way I would recommend is to create abstract contract. There's other technique which I would not mention in this talk, something called big effects. But if you are in that kind of thing, we can talk separately. So can I. Production, right? That's kind of, kind of misspelling rather. Can I use it in production? Yes.
00:18:49.872 - 00:19:02.116, Speaker A: And I give you example. So in superfluity, we have something called a super token v one. The version, one of the protocol. It doesn't use this because it. Let's go. If I would start now, I would do that. Right.
00:19:02.116 - 00:19:35.072, Speaker A: But for the upcoming new feature, which is called a GDA, which I should explain. What is Gda here? In the essence, it's a one to many stream of money, so you can actually stream into any number of participants on Ethereum. And GDA stands for general distribution agreement. All right, so we have also a v two implementation, stocknet. It's. Right, so it's chiral v zero, which is funny. They have v one.
00:19:35.072 - 00:20:03.152, Speaker A: Yeah. Anyway, so the v two is a stocknet prototype using this pattern too. So kind of demonstrating that this technique actually is universally applicable. No matter how crappy the language is, you can always emulate to some extent. So if you try, the v two version of token for EVM will be built from scratch using this paradigm. Right. So can we use it in production? Yes, because we are going to be production soon, at least for the first feature.
00:20:03.152 - 00:20:22.262, Speaker A: So we're going to have that. So that's it. Thank you for listening. Let's make solidity code better. Right. If you want to find the slides deck, you can go to our repo superfluid finance protocol Monorepo wiki area. You should be able to find the slides by searching function or solidity.
00:20:22.262 - 00:20:24.674, Speaker A: Yeah. Thank you. If you have questions, happy to answer.
00:20:34.654 - 00:20:35.078, Speaker B: Sorry.
00:20:35.126 - 00:20:37.074, Speaker A: I will check the other mic.
00:20:45.014 - 00:20:46.618, Speaker B: Yes, it's working now.
00:20:46.726 - 00:20:47.414, Speaker A: Yeah.
00:20:54.634 - 00:21:20.794, Speaker B: Thanks. Thanks for the intro into the new features of the solidity for the functional programming. Anyway, was then there or have you seen any analysis or insights into the gas costs of those features, how they are actually rendered into the bytecode and whether, you know, it's worth to use it, comparing to the, let's say, the older approach.
00:21:21.574 - 00:21:44.036, Speaker A: Yeah. So the pure, strictly pure functional part of the language. So the concern would be you are cloning the input data in memory data a lot, maybe unnecessarily clone. Right. So I did a little bit of measurement. There's, of course, I can't say there's no overhead, but there's a little bit overhead. But in the grand scheme of things that we're talking about, probably 50 to 200 for each actually clone is much cheaper.
00:21:44.036 - 00:22:10.220, Speaker A: So my claim is it's insignificant in the grand scheme of things. And I would even say that I have proof that this rail program actually made. A program generally looks shorter. So I don't know if that actually translates to less gas costs per se, because the way you organize program is slightly different. But I would say that it at least doesn't raise a yellow flag or alarm. That kind of wasting a lot of gas. So, no, I don't.
00:22:10.220 - 00:22:11.264, Speaker A: I don't think it's a problem.
00:22:14.644 - 00:22:16.144, Speaker B: And the size of the contract?
00:22:16.924 - 00:22:38.094, Speaker A: The size of the contract, again, I haven't done a numerical, detailed analysis, but nothing alarming raises actually probably even shorter. But it's shorter than the one we have in production is rather. Because it's not fully featured yet. Right. So there's certain feature gaps. So I can't really say at the moment. So if I want to compare, I would compare apple to apple.
00:22:38.094 - 00:22:49.006, Speaker A: Right. So I can't compare to apple to orange. But there's no alarming yellow flag to tell you that. Okay. The size is going to be explosive. No, actually it does make code shorter. Instinctively speaking.
00:22:49.006 - 00:22:51.734, Speaker A: I don't know if that actually translates to better. I don't know.
