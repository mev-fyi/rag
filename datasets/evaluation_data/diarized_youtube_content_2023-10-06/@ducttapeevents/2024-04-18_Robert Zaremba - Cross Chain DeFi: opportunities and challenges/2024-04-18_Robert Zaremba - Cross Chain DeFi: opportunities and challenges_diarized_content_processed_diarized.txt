00:00:00.320 - 00:00:00.920, Speaker A: Thank you.
00:00:01.006 - 00:00:22.142, Speaker B: Hey, everyone, I hope you have a good time. So a few words about myself. I'm leading. I'm a tech lead at Umi or Ux chain. We rebranded, we're one of the cosmos layer one chains. The biggest, in fact, money market, native money market in Cosmos. Yeah.
00:00:22.142 - 00:01:12.174, Speaker B: My background is for, I think, already six years in Cosmos before in Ethereum. I'm also part of the New York Contract Standards committee work group. I used to do lecturing at the University of Geneva, but I don't have any time anymore. That's my website, if you want to follow me. So I want to talk about this discrepancy between different chains. We talk about layer tools, we talk about chain abstraction, account abstraction, about layer ones, layer twos, layer threes, and so on. I want to start with this slide I think everyone is familiar with, because on average we want to launch another mem coin, another NFT, sell it.
00:01:12.174 - 00:02:17.042, Speaker B: And this replicates like, ok, maybe you can try on Ethereum, then maybe you can try on the base and on Solana and an avalanche or whatever is there and see your success. So for NFTs, for like this kind of images, yes, like maybe this strategy will work. Like, you don't use any, lose any efficiency, right? But there are many other mem coins. And then you can ask yourself, like, you know, how much sense does it make? Launch yet another mem coin and then you need to bridge it. Like now, how do you form this ecosystem? So this causes many problems, right? Like now, if you think from the financial perspective, for mem coins, it works, you can just launch yet another one, right? But nobody is using memcom for serious stuff. It's good to make money, but nobody will trade it in a traditional sense. So now abstracting from that way, how this works, you take the same smart contract, a template and then you redeploy it.
00:02:17.042 - 00:03:43.244, Speaker B: And maybe you just change the catalog of the images. If this represents NFT collection, if this is like a Dex, then probably you fork Uniswap or any other solidity contract, and then you redeploy it, rebrand it, you add maybe one more feature change, maybe the governance parameter, and voila, maybe you have another successful protocol. And then you do it for layer two, you do it for another layer one. Soon there will be layer freeze, all of it. Then if you apply it for the defi, yes, it obviously will fragment the liquidity because your uniswap pool on Ethereum. And then you need to bridge some tokens, you get the point, it fragments the liquidity and then it causes the liquidity wars, because how do you incentivize people to actually move the liquidity? So what's very often happening is that there are this incentives yield strategies and then, you know, all the degens will basically milk your incentives, the tokens you have, and as soon as the incentives are finished, most likely your protocol is dead. But who matters is like, you know, you made, I mean, probably few thousand if you are good, a couple hundred thousand if you are very good, maybe some millions, right? So you made the job, but overall, yes, like after a few months, your protocol will be dead.
00:03:43.244 - 00:05:15.704, Speaker B: So it's just like, you know, phenomena in the defi of today. Next thing is that if the protocol, like, let's say aave or uniswap, yes. Which is land on a few layer tools or an ethereum, and there is a brand, right? So they keep the value, but they lose on financial efficiency, right? So if you take for example, Ave, again, it's very important that the liquidity on the money market perspective is there, right? Because the money markets they are supposed to provide to be that, you know, that the very stable big source of liquidity to help other, other protocols and other protocols should be built on top of that. So there is a whole strategy, right. When and why the money market will have to be replicated or not, and how it works. So again, to make it efficient. And we have from a dex perspective especially, yes, we have a problem with, I mean, it only works when there is arbitrage, right? If you are on, let's say arbitrum, and you need to make some traits either, yes, you break it down into few traits until the arbitrage bots will, will equalize the price, which is not perfect from the user perspective, or you lose because the slippage will be bigger.
00:05:15.704 - 00:06:24.910, Speaker B: So the world of today is really depending on the branding, on the people, on the trust in the protocol, sorry, teams and the arbitrage bot stand, that will be efficient consequences. So reduced liquidity, of course, your protocol is less efficient, increased complexity, because now you either wait or again, you need to apply those arbitrage bots inefficiency in capital and resources allocation and uneven access to the information. So the arbitrage bots is a huge money to make, but it's really for sophisticated users only. So what I want to talk here is that we should, as a community, as builders, as innovators, thinking more on the bridge powered apps. So rather than fragmenting and copying the same solution, start thinking, especially now when ethereum is moving to layer twos. And there is no one layer two, many layer twos. They have to be connected, they need to work, they need to be interoperable.
00:06:24.910 - 00:06:53.546, Speaker B: So it's not only about the composability, right. But it's the connectivity. This is still like missing. If you think from the perspective, like again in Ethereum, that, you know, ethereum is the settlement layer, it doesn't bring what we really need, the interoperability between the protocols. Because interoperability is not about token transfer, it's really about remote procedural goals. So for that, yes. So, okay, token transfer is the basic one, but okay, we need to have the message passing.
00:06:53.546 - 00:07:51.164, Speaker B: We need to have a gas abstraction. Because let's say, if the money market will be, let's say on arbitrum, you don't want to again, replicate it to the optimism. You just want to quickly and efficiently talk to one another without having a user to rely on the gas and underlying complexities, interchange tokens and other things. USDC, how many USDC you have? AXLR, USDC, AVA, USDC, Axelar DC on polygon, Axelar USDC on arbitrum, on osmosis, and so on and so forth. So then you have all those 95 usdcs, at least it helps unification around it. I mean, those tokens have to be different because they, they carry and different risk. But the concept of interchange tokens is again, how we can leverage bridge to unify it somehow.
00:07:51.164 - 00:08:35.084, Speaker B: And finally, interchange authentication that comes with interchange accounts and chain abstraction. I did a lot of work, for example, with Axelr and a few other bridges. There are usually problems because when you have multihub bridge, you lose the proof who actually is the original sender, because the bridge will usually reproduce the sender from the last leg. So you need to think also about how do we do the authentication when there are multiple legs on your bridge. Chain abstraction. Internet computer is doing a great job with that. Started it, then they want to put it as a team of this year.
00:08:35.084 - 00:09:30.204, Speaker B: I think I have a slide about it. So it's more about that. Okay, you have your own wallet, and from that wallet you control all the other accounts on other chains. So the concept is that you use MPC. I'm not sure if Internet computer was going deep into that, but they have a lot of documentation and nice video, check it out. But very roughly that the subnets or here in case of near shard, will derive keys from your, let's say, NIR account here to construct transaction, to sign a transaction for other chains. That's from IC, but the idea is thresholds, cryptography and NPC, to basically solve it out.
00:09:30.204 - 00:10:06.950, Speaker B: So going back to bridges, right. Like this is from Axelar. The applications will be on the chains, multiple chains. Then you have many gateways, many bridges, right? And then how we can organize it. Yes, so all the bridges, I think they need to have the application layer, like in the TCP IP, right? So it's not only a communication, but application layer. Axelar allows for it, Warhol will allow for it, IBC will allow for it. And I will talk in a second.
00:10:06.950 - 00:10:25.434, Speaker B: Polygon. Polygon is doing like something similar, but in a different way. So they introduce that ag layer or interoperability layer, right. Where all the messages. Again, messages, not the tokens, right. Can transfer in a trustless way here. In this case, yes.
00:10:25.434 - 00:11:12.854, Speaker B: They require ZK proof. So that ag layer in this slide is interoperability layer will verify it. So you have a zero knowledge proof that the execution was correct, which is usually better than just consensus verification. Why it's important, again, because you can focus on developing on a single chain and leverage a fast interoperability layer to do it. In other words, it works. The disadvantage in case of polygon or CDK, in my opinion, is that, no, it only works with EVM. If you have some custom EVM, with custom opcodes, because you do more of the privacy stuff, then no, sorry, it won't work for you.
00:11:12.854 - 00:11:38.194, Speaker B: Here's another view how you can look at it. So some public chains, CDK chains, private chains, again, all of it. Then the proofs can be aggregated, merged into that concept of interoperability layer. Again, I don't want to talk about hero, about polygon, but about the concept. The concept works. A cosmos change IBC. IBC is perfect for developing applications on top of the bridge.
00:11:38.194 - 00:12:27.864, Speaker B: So who here is familiar with IBC? Okay, a few people. So IBC stands for inter blockchain communication protocol. So it really starts like from bottom up approaches. So you have the networking layer, you have the channels, connections, channels, same as, you know, you connect your web applications, web services, right? You have a server, the servers, the servers and the client establish a connection. Once the connection is established, you can have a channel there, multiple channels and multiplexing. And then in terms of IBC, these channels are important because each channel is bind to an application, to a specific protocol. They can then multiplex the packets between the same clients.
00:12:27.864 - 00:13:12.824, Speaker B: Crucial part is that it's open ended, so you can have any application on top of that. You don't need to change. I probably should be better if I would put her another slide like in Aussie stack, you don't need to change the channels. The concept of how the trust is established here, it doesn't require you for that. Think about from the CDK polygon perspective, if there is a limitation somewhere there, like the whole infrastructure doesn't work. Yes. So we will yet to see how if you will be able to enable more aggregation again, if you change the proof system, there might be some limitations.
00:13:12.824 - 00:14:01.162, Speaker B: IBC maybe is not the most efficient one today it's really focusing on the light kind of verification, but it's open ended. You can do any type of the verification is peer to peer. So you as a user, again, from a chain you can have kind of like a government or risk assessment to see with which protocols, with which chains you want to interoperate. And that's crucial. This is really the interoperability. Peer to peer, you reduce the risk and you can do it. So there are many now projects trying to leverage IBC to use the same concepts, use the same API about the packets channels, ports to apply for other stuff.
00:14:01.162 - 00:14:36.914, Speaker B: So for example, union recently they launched they connecting all cosmos chains with all the EVM chains. All the API is ABC compatible. So finally it's going open that you don't have one specific implementation between the cosmos chains, but you already have implementation for other chains as well. Not a bit. They are using zero knowledge validation for EVM chains. A few more slides here about whenever doing that, it's super important to think about the security. There's always risk.
00:14:36.914 - 00:15:16.454, Speaker B: So most of the bridges like warmhole before, now they have the new version of the wormhole connect. They were rather focused on the multisignature. We have already seen many vulnerabilities with that. MPC is kind of interesting. That's what I mentioned if you remember about IC and near. But it's still yes, that you don't have full verification. Validators could collude to forge a signature for you and they won't be slashed basically.
00:15:16.454 - 00:15:59.334, Speaker B: Then relate to another chain. So it's not the best one, but it's okay. Consensus verification and state verification this is what IBC and what I mentioned before about union provides the zero knowledge validation. Full zero knowledge validation is the last one. So you verify the state, you verify that operation is correct based on the latest state of the chain. So you fully reduce the risk here. So what we should really think and develop whenever you're making decision, building the applications with Axelr, with wormhole, with union, or other bridges that will come, or IBC in general, as a concept, yes, we need to really be here, don't use that.
00:15:59.334 - 00:16:42.986, Speaker B: And finally, I want to close here with few thoughts about DeFi and what we are doing. So, defi v one, it really fragments the liquidity that you have. Pool one, pool two, second pool, those pools, they don't talk to another one to another v two. Yes, you have a protocol on liquidity. It helps because then you have a protocol who can manage the different pools, who can do some assessment. Human is less involved into that, but none of them really solve the liquidity fragmentation problem. And in my opinion, maybe it should be v three or maybe v four.
00:16:42.986 - 00:17:32.858, Speaker B: I don't know how people would like to call it, but for a few years, we already talked about unified liquidity. And in my opinion, this is like building the apps with bridge in mind. From the first perspective, rather than copy pasting, there are a few solutions that already, let's say, leverage that interfluid staking superfluid. Staking superfluid is, for example, from osmosis. You can deposit into the pool some tokens. Those tokens will be locked, bonded, and automatically, let's say staked into other, I mean, if those are native tokens, superfluid is for native tokens. So tokens that are like layer one tokens that you can stake for your proof of stake rewards.
00:17:32.858 - 00:18:23.934, Speaker B: And then basically you boost your API meter. And there's also like experiment we are doing that's kind of like a bridge token that you can unify different accelerated from chain a to b to c and try to find a protocol of that. We released it a month ago. We still like need to think how to market it, but it's more like an idea and, okay, I cannot go back. I went back. Yeah. So I want to put as an example this me token, because check it out, I really want to promote visions or missions for anyone who wants to build with bridge in mind.
00:18:23.934 - 00:19:05.264, Speaker B: So with that, yes, I hope that this will be the right solution for DeFi. I mean, everyone in DeFi wants to have better speed, better quality, and lower costs. Just shipping your protocol from one chain to another is okay. It's like a short term, and there will be always better chains, but if you fragment it, just copy paste, it won't help you. You can always move your protocol from other chain. But still, we need to have the interoperability in mind. So if you start with interoperability and then you find that, okay, actually, for whatever reason, Optimus doesn't work for me because they don't have fraud proof.
00:19:05.264 - 00:19:34.154, Speaker B: I want to go for Sui or Solana because it's more sexy now. But if the whole stack or the whole API with all the connections will still work, because with bridge in mind, you will keep, you will improve the speed. You don't break the composability or interoperability. You improve the quality, maybe because the other chain will provide you better solutions and you reduce the cost. Thank you. That's all.
00:19:37.134 - 00:19:44.414, Speaker A: Thank you. Do we have like two minutes for one question? One question.
00:19:54.514 - 00:20:12.074, Speaker C: Really great presentation. One quick question. What's your view upon intent networks such as across Dbridge, DLN to abstract the need of even having a bridge and offsetting this one trade and one chain to another through solver networks?
00:20:13.414 - 00:20:17.566, Speaker B: I'm not sure I get a question. You asked about the intent. Yeah.
00:20:17.590 - 00:20:27.710, Speaker C: Like, what's your personal view of intent networks like DLN, DBridge, across, instead of even needing to have a bridge, set this to solvers.
00:20:27.862 - 00:20:56.634, Speaker B: Yeah, good question. So intent could be used like kind of a resolver. So, I mean, we have this chain abstraction is which I mentioned before, that, you know, you abstract how you can control from one wallet another account. I think that could be a good optimization for like a bridges or that. From a user perspective, right? It will. Or from the interoperability perspective. Yes, it will.
00:20:56.634 - 00:21:21.854, Speaker B: It will solve this because we will have some optimizers. There will be many bridges for sure. So from developer perspective, probably if there is like a good, there is a good product that will deliver bridge based intents and resolve all the routing. For me, keeping the interoperability. Yes, that's the future.
00:21:24.874 - 00:21:26.474, Speaker A: Thank you so much. Thank you.
