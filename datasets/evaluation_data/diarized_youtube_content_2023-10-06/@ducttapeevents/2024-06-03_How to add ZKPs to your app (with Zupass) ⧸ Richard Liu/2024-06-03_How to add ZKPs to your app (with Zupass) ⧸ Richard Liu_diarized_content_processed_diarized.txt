00:00:02.240 - 00:00:13.550, Speaker A: Hello. Next speaker, Richard. All good. Ready? Yes. Let's talk about CKA two pass. Yes, we'll talk about ZK and Zoopass. So, good afternoon, everyone.
00:00:13.550 - 00:00:43.660, Speaker A: I'm Richard, this is Ivan. We contribute to the Zoopass project, which is an open source ZK experimental tech. If you've noticed, your ticket has been in Zoopass when you checked in here. We'll go a bit more over. How do you actually use this technology to build your own apps? Right. And here we'll learn a bit about how to create ZK proofs with under 20 lines of code, even if you don't have too much ZK specific background. So without further ado, we'll begin.
00:00:43.660 - 00:00:47.144, Speaker A: And actually, I'll hand it off to Ivan to do a bit of intro as well.
00:00:47.764 - 00:01:05.164, Speaker B: Hello. I'm not going to be doing the workshop, I'm just sort of here to introduce myself. If you need help with any of the stuff we're going to present, or Richard's going to present, I will be in the back after the workshop and available on the Internet as well.
00:01:06.624 - 00:01:45.926, Speaker A: Cool, thanks, Ivan. So again, these are your tickets. They contain the tickets you need for registration, but what can they do beyond that? Right, well, I think some 200 or so folks have joined the telegram. And in the telegram, what you need to do is talk to a telegram bot, this bot, Zoocat friendly bot that manages zero knowledge proofs. And in here you have a screen where you have to prove that you own a ETH prog ticket in order to join. So for folks that are somewhat familiar with flow, you've already used a ZK proof. In addition, and this was announced a bit, the opening ceremony and the hacker manual.
00:01:45.926 - 00:02:39.244, Speaker A: But the zoo poll, or anonymous, the hackers and audience vote on Sunday. So after everyone submits, everyone's going to vote for projects that will also be through making a ZK proof for your zoo pass. And that essentially is sort of so we can have anonymous voting. So, you know, people sort of like bribing each other to see, you know, who voted on which. So these are two sort of examples of ways within the conference how zoo Pass and ZK authentication is used. So we have this common kind of screen here, right, of some kind of. Okay, I have a piece of data, in this case, my EtH prog ticket, and I'm making a ZK proof out of it, right? This is sort of, you can think of it roughly analogous to a metamask confirmation screen, right? You're signing a transaction, in this case, you're making a ZK proof.
00:02:39.244 - 00:03:14.474, Speaker A: And in this ZK proof, I'm revealing two things. In my ticket, I'm revealing my email and my name. In other ZK proofs, I'm revealing other things. For example, in Zoo poll, I'm not revealing my email or my name. I'm revealing a specific id or nullifier that indicates that I'm part of this Merkle group of the event. So I can go more into the details of that later. But just know that this screen represents different kinds of proofs and you can see sort of within the screen what exactly you are revealing in each of these proofs.
00:03:14.474 - 00:04:06.664, Speaker A: So you might be thinking, well, okay, this ZK stuff is cool and all, but isn't it super hard? Isn't it like moon math? You know, don't I need to be some kind of like academic to get started? So this is here is a language called circum. It's pretty complicated. It's actually like one of the easier of the ZK language that people use, and essentially it consists of writing code as math problems. So this is a pretty fun, interesting challenge. But it's not really convenient when you have two or three days to hack on something useful, or if you just want to get started on ZK for the first time. So although we love circum, we think that circum is probably too inaccessible to most developers. So we developed this library, this open source library called Zoo Auth.
00:04:06.664 - 00:05:02.980, Speaker A: And everything you need to request a ZK proof is contained within the lines here, right? So there's this one function await zoo popup in here you request, okay, I want the user to reveal their email, their name, and the event id. The fact that it's EtH prog, I can optionally submit some kind of watermark to commit to some sort of message. And I'm saying that I'm using the Eth prog tickets configuration. So this is less than ten lines of code to request a ZK proof. Okay, so that's a bit of a preview of what's going on. Again, we have zoo pass during the event, we have a bunch of different apps that request ZK proofs. Creating your own ZK app can be super, super simple, doesn't require any knowledge of math or deep ZK expertise.
00:05:02.980 - 00:06:17.644, Speaker A: So I'm gonna do a bit of a briefing of what is Zoopass? What is the actual architecture of it. One decision for Zoopass is that data is held locally on the device. So rather than it being stored in plain text on a centralized server, which is typical of things like Facebook or large companies that have these apps, data is held locally in your device, and we store end to end encrypted copy so that you can log into your zoo pass on different devices on your laptop and your phone. The data that's being exchanged is client to client, right? So if you remember in those examples, you had Zoopass talking to the Telegram bot, or you had Zoopass talking to zoo poll, or Zoopass talking to some ZK app of your choice that you hack on in ETH prog, the data is being exchanged between the Zupass client and that apps client. There's no sort of big server doing all that computation. And because of this, ZK proofs ensure privacy and data integrity, right? There's no need to trust a centralized server. There's, you know, the clients can just verify that the proofs are valid.
00:06:17.644 - 00:07:00.256, Speaker A: So you can kind of see that this is very analogous to what, like, some of these ideas are pretty related to what working on Ethereum enables, right? Except to work on this, you actually don't need to like hook onto hook on chain. You don't need to set up an RPC to infer or anything. You can just get started with those ten lines of code. And that's kind of what is the breakthrough here. We can start hacking on ZK proofs without needing to do all this setup. We do have some exciting on chain integrations, though, for folks that want to get more into it towards the end. Specifically, how do you verify ZK proof on chain? Cool.
00:07:00.256 - 00:07:33.978, Speaker A: So, okay, that was a text heavy slide. Just to give another sort of analogy on what's going on here. This was the setup. We had like one setup, we had a devconnect. So we had a developer from the Ethereum Foundation, Philip, who built this, Holosky. Holisky is also the name of the city, but Holisky is a testnet as well, and they have a faucet that issues testnet eth for developers. So if you proved ownership of a devconnect ticket, there's that proved screen over there.
00:07:33.978 - 00:08:40.860, Speaker A: You're revealing your event, your sort of zoo pass specific public key. Then you can log in with Zoopass, the faucet will authenticate you, and then it will, after you're authenticated, after you're validated, it'll send you that 500 whole leads. So essentially you had an app that was gated to having been to Devconnect. You can imagine adding complexity into this, for example. Oh, this app is, you have to prove that you have a devconnect ticket and get some eth you could add on, prove that you had a Devconnect ticket and you checked in and then get something else. Or prove that you have a devconnect ticket and you have an ETH prog ticket and maybe get like, you know, 700 whole ether sort of arbitrary predicates can be expressed through many of these like proof screens. So what actually happens during this process of authentication? So the first thing that happens is, well, you request a certain kind of proof.
00:08:40.860 - 00:09:33.854, Speaker A: So that's the different, you know, parameters on the screen here, right? You request what in this case, this specific proof Zked event, get PCD. It's kind of a mouthful, but it's requesting these two fields from you, email and name. And then after this proof is, after the user clicks, prove that proof is then sent to another client or server really anywhere that you want, and that ZK proof is verified. So essentially what's going on is you have an app that's again requesting a proof from your zoo pass, and that the proof is being sent to a different app which is verifying that ZK proof. Maybe I'll go to the following slide. Yeah, so verification again, proofs are verifiable. You don't need to trust any sort of third party API.
00:09:33.854 - 00:10:33.054, Speaker A: And it's cryptographic verification, so you can check the content of the actual data itself. Well, I'll just probably stay here actually. So there's one other thing, if you remember on that first screen of the ten lines of code, which is the watermark. So some proofs can contain an arbitrary watermark, which is kind of similar to a challenge in the web two world, or like a nonce in ethereum where let's say you want to avoid man in the middle attacks, you can have the client sign a certain watermark, you can have like client number two, or a server check that same watermark. And that way you can prevent somebody from sort of like, you know, who might intercept that request from, you know, interfering with this authentication. Yeah, and it also allows for credential replay attacks. So one thing you can do is put a timestamp in the watermark.
00:10:33.054 - 00:11:18.342, Speaker A: Cool. So going back to the screen again, we have um, the process of requesting a ZK proof through zoo pass. And the verification is actually even simpler. Um, you just need to call this authenticate function. And in here you post the actual, you know, PCD string pcdstr, which is the uh, which is the res, which is in this result here, um, towards the bottom. And then you uh, place your watermark and then finally the configuration. So again, having that watermark be the same, that watermark needs to match the watermark that you request in the client in order for this authenticate function to verify properly.
00:11:18.342 - 00:11:55.936, Speaker A: Otherwise it'll throw an error. Okay, so we're moving pretty fast here. But one extension of this, again here we're mostly talking about, this is all typescript again. So you can run in the front end, run it in a node server in the backend. But what if we want to do something on chain, right. You know, for example, there might be smart contracts that have, that want to sort of verify ZK proofs of, you know, anything from, as, from as small as ETH Prague attendance to in the future, right. Verifying, you know, government ids.
00:11:55.936 - 00:12:28.224, Speaker A: Right. Or like financial records. So I think getting ZK verification on chain is a pretty exciting primitive. Here's this QR code for a library that Austin Griffith from Bill Guild hacked on, which is essentially you can see in this diagram here what this process is. Maybe I'll actually show the video first, that'll give a better idea. Cool. So I'm going to full screen this.
00:12:28.224 - 00:13:20.864, Speaker A: So we have a Zoopass scaffold ETH two starter kit and one note is that I think this is, yeah, ETH Berlin tickets. But the principles are mostly the same besides that. So the first step is we request the ZK proof, right? So in this case it opens a pop up requesting from our zoo pass an ETH Berlin ticket. In this case Heath Berlin hacker ticket and it's requesting my email, the event and the product ids. So I go ahead and click prove, or I have two tickets. Actually I can choose the hacker ticket, I click prove and then I can just because we're going a bit fast here, I can verify first on the front end because there's that typescript library. I can verify within this react app here.
00:13:20.864 - 00:14:02.470, Speaker A: I then verify in the backend, and then after this, back after this. Or I send this to a server and then I verify that within a server using that same authenticate function. And then I send one eth to the address I'm connected to. And then finally the step four is sending the proof to a smart contract. And this smart contract takes that proof and verifies the proof on chain by doing some math operations. Essentially. Specifically it's like a sEMA, it's a, or it's a Grot 16 verification, but it verifies this and after doing so mints an NFT for the user.
00:14:02.470 - 00:14:54.136, Speaker A: So if we go ahead and click on the sample block explorer, we'll see that the latest transaction is like a mint item to the account we're connected to. And if you're curious, the watermark we mentioned from earlier was used to encode the address that I wanted to mint that NFT to. And that way that prevents, it's like I'm committing to, ok, I want this person to be minted in NFT to prevent sort of fraudulent transactions. Ok, so just to go over this again, we have the scaffold ETH two front end, which is everything you saw on the web page. The first step is requesting a proof from Zupass. Your data is stored locally in Zupaas. It sends the data back to the scaffold ETh front end where it's verified.
00:14:54.136 - 00:15:43.154, Speaker A: That's the step two here. Step three, it sends the PCD. The PCD is sort of the name for the ZK proof, sends the PCD to the back end of scaffold ETH where it verifies the proof and sends the ETH, returns it to Android response, and finally it sends the proof on chain where it's verified in this kind of big smart contract where it calls Groth 16 verifier verifiedproof, and finally mints the NFT. So three different way to or. Yeah, one way to request a proof from Zoopass, and three different ways to verify it on the front end, on a server and on chain. And yeah, all the code here, you can look through some of the examples to get a sense of what's going on here. And Ivan and I are also happy to help walk through any of the details.
00:15:43.154 - 00:16:49.704, Speaker A: Okay, so that mostly concludes the workshop. Again, the kind of key thing here is Zupass is software for creating, for easily requesting and verifying ZK proofs. You can create a ZK proof by writing these ten lines of code, by using the pop up on the client, and you can verify it with an authenticate request. We also have some libraries for on chain verification, and we have a sort of complete list of documentation for developers at this QR code here, if you're more curious. We also lastly have a telegram group where you can ask questions to some of the other zoopass contributors from around the world, and they can help out and debugging issues, helping you guys create a great hack. But yeah, that's mostly it. Yeah.
00:16:49.704 - 00:16:57.424, Speaker A: Thank you all and we'll take any questions. Thank you, Richard. Any questions?
00:17:03.204 - 00:17:21.453, Speaker C: Thanks. I love it. I think Eth Prague last year, we gave out some sbts on like a QR code. It was really rudimentary and I hated it at the time. And it's wonderful to see this this year runs really smooth. Yeah. In fact, there's so many more applications for this.
00:17:21.453 - 00:17:38.242, Speaker C: Right. It's much more general products than just authentication for getting into spaces, for example. Could you explore that a little bit? Like, what are you thinking in mind on the more generalized set of use cases in this?
00:17:38.418 - 00:18:09.100, Speaker A: Yeah, great question. So there's actually a lot of prior talks about the more kind of like, expansive direction this is. So I work for this organization called Xerox PARC that focuses a lot on this field called programmable cryptography, which is essentially. What are the new sort of possibilities that this essentially really powerful technology brings us. Right. And Zoo Pass is just really the tip of the iceberg. Authenticating tickets is just really the tip of the iceberg.
00:18:09.100 - 00:19:20.484, Speaker A: Right. So to go into that a bit, I think that you have, maybe I'll just sort of give a bit of a prelude and direct folks to watch some videos afterwards. But we have this world where we're moving from first generation capabilities cryptography, which is things like signatures encryption, to second generation cryptography, which is ZK proofs, and even more complex cryptography, such as multiparty computation, fully homomorphic encryption. A lot of these buzz words that you might have heard of. And the powerful thing about this is that, well, one, a lot of these protocols that were in first generation cryptography, we're mostly about like defense. It's like, I want to secure my data so that hackers can't exploit it, right? Or I want to keep certain things private, I want to communicate only with certain trusted parties, or I want to verify, or I want to show that this piece of data is signed by me. Right? And nobody else can claim that this category of second generation cryptography actually allows for a lot more like kind of offensive, like new things to be created as a virtue of things being hard.
00:19:20.484 - 00:20:42.314, Speaker A: I think blockchains are really the first, a good example of this, where you have some ecosystem like DeFi emerging, because all these contracts are composable, and the coefficient of creating a new application is super, super low. I think with ZK proofs, we're seeing a similar thing happening for existing data. So a lot of data exists out there in financial records, governments that can be signed and then created, shared between different end use. The world that one could imagine is one where you store all your data locally and you generate proofs of that data to certain consumers of that data. So I don't need to have an Equifax score, I just store all those that data locally in something probably a lot more complex than Zoopass, and then anybody can request some sort of part of that data. It's almost like a global API without needing to conform to all these very specific specs that we have in the current world. So I'll close off with directing folks, if they're curious, to see Gub sheep's talk at prog crypto about programmable cryptography.
00:20:42.314 - 00:21:08.724, Speaker A: So you can search this on Google, and that will give, like, a much broader view and more detailed view into what this world leads to. Any other questions? No? Silence. Thank you. Cool. How do we do?
