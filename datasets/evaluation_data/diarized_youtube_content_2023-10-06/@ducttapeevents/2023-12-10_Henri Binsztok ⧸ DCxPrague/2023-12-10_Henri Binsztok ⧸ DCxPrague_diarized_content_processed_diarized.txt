00:00:00.640 - 00:01:00.822, Speaker A: Hi. Thank you. So hi everybody. My name is Henry Henri in French and I'm the co founder at Okcontract, where we basically try to redo the front end stack differently for crypto. So the talk today is a path to decentralized front ends, and we'll see basically why we want decentralized frontends. Like we've been preaching in the desert for a couple years telling people it's very important to fully decentralize front end. But now there's some help coming in, and that help is, for instance, the mecca regulation in Europe, which let's say puts a strong incentive for DeFi projects especially to properly decentralize their front end, because they don't want to bear responsibility.
00:01:00.822 - 00:02:12.782, Speaker A: And to do this they must, let's say, prove that they are decentralized. And if you look at some of the articles that many people are publishing, there's a lot of, let's say, discussion about what it means being fully decentralized, because the law has kind of this kind of meaning. So if you look today at what many project does do, like dopex or liquitey, they use ETH limo, which is basically a way to properly support ens to ipns, to IPFS redirection for browsers that don't support it. Because hopefully one day we will have native Ens resolution in all browsers. And if we do so, of course that will be even easier to do the whole path. So in the end we have decentralized storage and we have a website which loads from decentralized storage. But the question is, what do we put exactly on ipfs? So what we put on IPFS is mostly the build artifacts.
00:02:12.782 - 00:03:26.216, Speaker A: So you have your whole front end code base, which is usually a complete message of libraries and NPM dependencies. A bit more about this later. Somehow you manage to build it successfully and repeatedly with reliability, and you say ok, this is what I'm putting on IPFS, and now my protocol has a decentralized front end, and we've seen a lot of projects mentioning this that way. However, if we just open the source code of the page, this is an example for Dopex on Iflimo. And basically we see very quickly in the code here in the middle there's appex IO, which is of course an API, kind of looks centralized. And in fact we had some discussions. So we asked some lawyers, they have different advice, and we asked the best lawyers of all.
00:03:26.216 - 00:04:08.832, Speaker A: No, I'm sorry, it's just a joke. So obviously even chat GPD is aware that probably if you have a single API endpoint mentioned in your decentralized storage, somehow a judge will say that it's not really decentralized. There's, I would say, one very simple litmus test. And that litmus test is basically if we somehow shut down or configure the network to block that centralized API. Is the decentralized website still working? And of course the answer is no. The Dapps don't load if you shut them from that API. I'm not a lawyer myself.
00:04:08.832 - 00:05:25.838, Speaker A: Obviously everybody has their own conclusion. So when you're a project, you, let's say have three GitHub repos, you have your contracts, you deploy them on evm chains, you have your frontend and basically your build activates, go to ipfs and you have your API, which is usually AWS or GCP. So basically is it decentralized? The contracts, yes. The front end storage, yes. But the API is not. So we say we're looking for solutions, we're builders here, and we say what's the best solution we can do? And we heard several times the idea of making a decentralized community of nodes of vms run by different people, different administrators, and all of these APIs would be quite diverse and they would form somehow a decentralized set of API nodes for each of the projects. The problem is, of course this is an ops nightmare, because the stack is completely heterogeneous.
00:05:25.838 - 00:06:26.264, Speaker A: There could be some node j's, could be some go, some rust, and each VM instance should be maintained maybe by a different operator. So there would be what guidelines, like a GitHub repo of guidelines on how to set up maybe repository of scripts, of Docker files. And the problem is that there's a lot of maintenance usually coming in to these nodes. So we thought that there could be one path, and definitely it's not the only path, it's just a path to rethink how we do the current implementation of frontends of a common, let's say decentralized node protocol. To do this, first I'm going to start with some bad news. The bad news is we won't be able to reuse the existing front end. There probably are ways to do it, but working on a more generic solution means that we need to standardize the build to decentralize the run.
00:06:26.264 - 00:07:05.104, Speaker A: But doing so, we changed the build. It gets back to when I started, okay, contract. Basically it was, we started with. One problem is the lack of precise semantics for front end. And if you look, for instance, at one, I would say state of the art front end implementation. And of course, it's so state of the art that now they even want to introduce fees for it. Basically, we look at just one page, ad liquidity, and ad liquidity is just cutting the story short.
00:07:05.104 - 00:07:52.504, Speaker A: 500 lines of code for just this single page. And those 500 lines rely on a very huge amount of components and libraries. So you'll see here you have a custom, of course, analytics package. There's react, there's web three G's, there's ethers as well, both of them. And web three react. There's a lot of dependencies, and then we have a lot and lots and lots of components and hooks. And we see, for instance, to calculate slippage, to calculate margins, to list the different contracts that we are interacting with, et cetera, et cetera.
00:07:52.504 - 00:08:44.076, Speaker A: And if we are concerned of extracting the actual semantics and extracting what is that, we are going to compute on that client. To perform the transaction on user behalf, we have to go dig deeper and deeper in different set of rules, which are usually interlined. So there's the components, and that code, again, is very well structured. It's one of the best implementation that we can find. A lot of definitions on getting the state of getting the transaction values, the format, compute, the formatted amount, compute the max amount, et cetera, et cetera. The lines go and go and go. And we still have basically the semantics of it, which is spread over these lines of code.
00:08:44.076 - 00:09:58.112, Speaker A: And it's only at the function OnAdD, which basically implementation begins like 200, that we are able to, let's say, send the transaction that we have computed and catching it. So why this? Because, so it's very complex, and our mission is how we can make it simpler and knowing that there's a lot of things that we should compute on the clients, we should compute wallet changes, react to wallet changes, our chain changes, be able to customize the interaction for the connected wallet, the balances, et cetera. And sometimes it's also more than one TX in that code, we see a lot of glue required to manage the approvals. And sometimes on other projects, there's a series of preparation that you want to do, like migrate liquidity from one pool to another. And coming next, of course, will be interaction with the 437 bundlers, which will change a lot the interactions. And right now, most of the bundles for 337s still have one ticks and all called multicode. So there's a lot of things that we can do better here.
00:09:58.112 - 00:10:51.396, Speaker A: But the front end code is so complex already. That it's hard to add them, and sometimes also, and maybe even beyond DeFi. But for DeFi as well, we need more than on chain data. There's this off chain data, for instance NFT marketplace who have off chain order books or data intensive operation that you cache on these API nodes. And all this needs to be put together. So the solution that we began to think of was how to solve, build and run by changing the build. So the build is first introduced a standard way to specify the smart contracts interaction semantics, which we think is lacking, and then an SDK to easily insert these transactions into any web page dapps without touching a gain that semantics.
00:10:51.396 - 00:12:05.408, Speaker A: And for the run then, since we are making, let's say a new clean sheet implementation of the front end stack, then we can think of decentralized nodes and make everything so that the SDK automatically uses a decentralized node protocol. So to specify the interactions, we introduced, in fact purely functional language which we call lambdaScript, and which is kind of let's say a low level intent of the transaction or a high level definition of the transaction. And just to give you one example, so I could do add liquidity as well. It's on the next slide. I skipped it because it's just a bit more complex, but not too much. For instance, if you want to swap, basically you just need to say who you swapping to the tokens, what's the path that you need to send to the contract functioned in the standard library that helps compute the deadline. And we also need for instance to compute the amount out min, which involves RPC calls to the getamountout function.
00:12:05.408 - 00:13:31.554, Speaker A: And this is a proper lambdaScript program which we can just take compile in advance into bytecode, being able to detect a lot of invalid specifications for the interaction, generating compile time errors in the middle. And then when we have this bytecode which represents, let's say a seemingly valid transaction, then we have a TX transaction engine which basically takes the user input and either gives a runtime error this time on the right, or outputs the transaction. So basically the runtime, the engine is a vm which is based on the reactive programming, so that the whole definition in fact is a reactive program. And wallet events on chain events change the foundational data and everything is recomputed automatically and it automates two things, the RPC access and as we'll see next as well, the centralized API access. So now we are working on the SDK that we should release in 2023. That's pretty soon, just after this talk, I will keep running code. No, I'm just joking.
00:13:31.554 - 00:14:30.654, Speaker A: So basically what we are building is so we have a way to specify interactions using an id, which is the hash of the interaction definition, basically, which you can as well visualize. So there will be a front end to visualize them. But most importantly how it works, you just import new TX from the next ok, contract SDK and you say ok, we want to do the transaction using that transaction id. And for instance we can set the value if we are swapping ETH to die here. So we just select the amount and basically from that point on everything will be automated. So for instance we can test that if we want to get the transaction from that high level specification. Then for the connected wallet it resolves to the estimated gas amount.
00:14:30.654 - 00:15:28.916, Speaker A: It says that's the wallet which is sending the transaction to the contract here. I think it's sushiswap on girly. The value that we specified, et cetera, and all the parameters are built and there's no errors. We also can generate some information which is readily available, for instance text or information bubbles or button names, or everything that you can put as a developer into your UI without having nothing to do with computing the complex parameters, formatting the amounts that you'll get, et cetera. So you can show this the way you want to the end users. And from that point on it's one line to just send the transaction. So we get a hash, and if we wait for the receipt then we get a successful transaction.
00:15:28.916 - 00:16:15.320, Speaker A: And that you can display and very easily. So it handles input detection, gas estimation updates, including USD error management and support as well. Multi step transaction, but that's beyond this talk. But getting back to the decentralized nodes part. So what we have right now is a way to properly define any kind of EVM interaction. So it could be defy swap. We have a lambdascript program, an id for that, staking some defi pools, adding liquidity or buying nfts, or accessing NFT utility or really anything, because it's pure turing complete, purely functional language.
00:16:15.320 - 00:17:21.278, Speaker A: So we can specify any kind of transaction. And once we have this, we have the opportunity to run one common set of decentralized nodes for every of these specified transactions. So that's how it works, basically the transaction engines is able to run any kind of program definition and connects to RPC and the backend API. And the only thing that we have to do, and that's kind of a joke only, is to decentralize the nodes themselves. So there are frameworks. So just adding the consensus and of course, making sure that the definitions of new interactions are properly written is something that is already taken care of by multiple frameworks. But here there's a bit of issue in the way the nodes give trustful information to clients.
00:17:21.278 - 00:18:20.834, Speaker A: And this is something that I will speak about a bit more on Saturday. But basically we're building this set of backend APIs which are decentralized, and I didn't say permissionless. So basically it's because if you want to make these backend APIs permissionless, then there's another level. But decentralized is doable with the following goals. So the first goal is to be universal, and that's already tackled in the way we define the semantics for any kind of transaction. Another goal is to be performant and being cost effective in terms of runtime. Ideally they should be, let's say, in an order of magnitude, no more overhead compared to current RPC nodes, private nodes that you may use for any kind of project.
00:18:20.834 - 00:19:37.094, Speaker A: And obviously we want to be compliant with coming regulation for being a decentralized protocol and a decentralized interface. And I think that in that area will be probably as fine as can be. The questions we have is how to balance performance and security, because we can always be more secure, but it has a cost and on the governance of the decentralized network as well. So there's a lot of things that we're thinking of, and if you have ideas or collaborations, happy to talk. And of course the sustainability of the ecosystem. So how it should work basically for the sustainability is we will have a community of node operators who will get API access fees paid by project. There's one thing that we can do is we can control, make sure that an API key is only used for, let's say, a predetermined set of interactions, which is something that is not easy to do with RPC nodes.
00:19:37.094 - 00:20:51.544, Speaker A: And also we can build partnerships with MaV or MAv sharing protocols, and maybe we can return one part of this to the users to be as fair as we can be, or we can share this with projects. And here those are really questions, and I think there's a lot of discussions that we can have this week on that topic. So basically that's one path where we can decentralize any front end. And as I said earlier, it's not the only path, of course there will be manually implemented front ends that everybody will try to run in a decentralized manner. And of course it's, let's say the closest way to do it compared to what exists today. But this is another path where we need to start anew with a definition which can be done, let's say, pretty quickly. And that will give a lot of benefits, like having another diverse implementation of frontends, which I think is of good value for protocol, to resist censorship for instance.
00:20:51.544 - 00:21:52.762, Speaker A: And also that will come with the benefits of being decentralized without too much effort, which I think is a pretty good value. So just to sum up a bit, the architectures that we discussed today, we'll build frontends and store the artifacts on ipfs just as we do today, to decentralize frontends properly. And that will give a user interface which includes the okay contract SDK and the okay contract SDK manages automatically connection to the RPC node, to wallets, and to the of course the decentralized API nodes of the OK contract protocol. So that will be the last slide. And how to contribute. There's several things that we can discuss as well. Formalization.
00:21:52.762 - 00:22:58.606, Speaker A: So right now we consider doing writing an EIP for the transaction specification, so mostly for the functional programming language, Lambda scripts, and the definitions of the standard libraries that we put in it. And I would say that's an opportunity for other protocols to be present, especially protocols that target front end developers somehow. We probably can integrate and making your features available at first level, and that's something that we can contribute on. Another thing is if you're a project, let's build interaction together for your protocol. And if people are running nodes for other protocols, of course let's talk and be a launch partner for the node runners so you can learn more. There's not yet too much public information, but on okcontract.com. And of course thanks for following us on X.
00:22:58.606 - 00:23:24.524, Speaker A: Now it's Okcontract and if you want to chat, I'm often responsive on X as well. Henry OK, I changed my handle name a bit too late. So thanks a lot and I hope that it was an entertaining way to begin the second day of Dev connective sprig. Thank you.
00:23:30.544 - 00:23:50.194, Speaker B: I have a few questions. The first one we saw the example of the prepared or to be prepared transaction and you had there like the response texts mentioned there, which would be like populating the UI. Do you treat there somehow localization and nationalization?
00:23:51.254 - 00:24:07.302, Speaker A: Yeah, so obviously it will be able to localize in the future, but for now the first version will be English only. But of course yeah, it's 18 n.
00:24:07.398 - 00:24:12.854, Speaker B: Do you think that would change the architecture significantly when you go like 118?
00:24:15.474 - 00:24:31.814, Speaker A: I hope not. I worked on previous projects where we internationalized the front end and that's peripheral. This is an extra module, in fact, added to the rest of the course. That should be easy.
00:24:32.314 - 00:25:09.440, Speaker B: The second question is, we are talking here mainly about the web front ends. Basically, since you were researching this field, have you also researched the fact that many users are actually moving to the mobile apps and how that could be applicable or whatever? There would be a way for the mobile apps, even though we know that due to the stores that there is some certain censorship or risk anyway. But is there any way for the mobile apps like you present, you presented for the.
00:25:09.632 - 00:25:22.336, Speaker A: Okay, thanks for asking this question. So, yes, the answer is definitely. And mobile was first, was first before any kind of implementation. So of course there will be a mobile SDK coming in.
00:25:22.480 - 00:25:23.444, Speaker B: Cool, thanks.
00:25:25.344 - 00:25:26.324, Speaker C: Any question?
00:25:30.664 - 00:25:47.660, Speaker D: It sounds like there are sort of, there are multiple things that you're packaging together that are probably useful independently. The setup that you have for decentralizing the API nodes seems relatively independent of what happens on the front end, right?
00:25:47.812 - 00:26:20.054, Speaker A: Yes, it's an added layer which benefits from the specification because the way, in fact we specify the interaction, make sure that we have common endpoints for any kind of interaction. So that's why basically it would be, I think, harder to adapt the decentralized nodes to the existing front ends, unless all the front end in fact change a bit the way they are implemented today.
00:26:21.634 - 00:26:22.414, Speaker D: Thanks.
00:26:28.234 - 00:26:45.012, Speaker C: Do you address another point of centralization, which is access to ipfs, actually like the gateway, because most users do not run their own nodes, so they have to use this f dot limo and it's still point of centralization. That's the first question. And I have another one.
00:26:45.148 - 00:27:04.164, Speaker A: Okay, so very good question. And so, no, right now we don't. There are several efforts in the protocol labs community in that regard, and we will build on whatever they're doing. And we already have enough problems on our own for now.
00:27:04.784 - 00:27:11.524, Speaker C: And second question, can lambda be used for creating some kind of command line interfaces?
00:27:11.984 - 00:27:25.624, Speaker A: Oh, yes. And in fact those tools do exist. And it started, so we started the core implementation with ClI. Thank you.
00:27:30.884 - 00:27:42.068, Speaker D: Yeah, at the beginning I saw you had like it would retrieve a widget with a code. Is that like a widget library? Is the intent that people will create widgets, put it on like a widget store or.
00:27:42.196 - 00:28:10.204, Speaker A: Yeah, definitely. So one of the thing, in fact, that we want to do as the, let's say, okay, contract parts, brand somehow, and this is how we chose our name, is to give confidence in the interactions. So we will have a set of these whitelisted interactions and which are part of the node protocol. So these interactions, in fact, are stored in the nodes.
00:28:13.304 - 00:28:14.804, Speaker C: Okay, that's all.
00:28:15.584 - 00:28:15.984, Speaker A: Yep.
00:28:16.024 - 00:28:19.728, Speaker C: Thanks to everyone in the questions and for the talk.
00:28:19.816 - 00:28:21.224, Speaker A: Yeah, thanks, everybody.
