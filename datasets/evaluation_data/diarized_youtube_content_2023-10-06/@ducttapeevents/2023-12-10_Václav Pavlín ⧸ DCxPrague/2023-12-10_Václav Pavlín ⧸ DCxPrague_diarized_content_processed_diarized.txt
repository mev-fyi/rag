00:00:00.760 - 00:00:49.034, Speaker A: Thank you very much. It's a great honor to be here in this space and to speak at this event. I haven't been able to join the previous two days because stuff, but I'm really excited to be here today, and I'll be here for a bit longer after the talk if you want to chat or ask questions. So my name is Vaslav Pavlin. I work for this project called Vaku and for status, which is a messaging super app that's just being reborn. You can go to status IM or status app for that, but I'll talk specifically about one infrastructure part of status, and that's waco. I'll explain what Vaku is, so let's take a look at the topic.
00:00:49.034 - 00:01:21.946, Speaker A: So protecting a network. It's a peer to peer decentralized network from spam using ZK magic. And I'll talk about how Vaku uses something called rate limiting nullifier, and I'll explain all those terms, hopefully. So we'll talk about Vaku because talking about how we protect the network without understanding the network does not really make sense. We talk about the ZK magic, and I use the term ZK magic because it's like magic to me. I don't know how it works. I know it's math, so I trust it fully, but still, it's magic.
00:01:21.946 - 00:02:18.073, Speaker A: And then at the end, we'll just briefly touch on what's next, what's coming for us, for Vaku, for the rate limiting modifier, and how it all will hopefully play together. Okay, so what is Vaku? Vaku is generally a set of protocols, and I'll use these form terms to explain more in deep what it does and how it works. So Waco is a set of protocols that are privacy preserving, decentralized module, and aimed for generalized messaging. Now. So what privacy preserving means basically for us because we are a messaging layer, a communication layer. Privacy preserving mainly means that you can't connect sender to recipient and then also you can't really know who the sender is or who the recipient is in general. And you cannot say these two messages are definitely related together.
00:02:18.073 - 00:03:01.294, Speaker A: There are some hints based on how you use Vaku, and you can leak a lot of information if you are not careful. But Vaku itself defines everything in a privacy preserving manner so that users don't have to worry about being tracked or anything. It's a peer to peer network which is decentralized by its nature, being peer to peer. And we are working towards higher decentralization right now. We have tens of nodes and obviously we would like to have thousands, like, for example, Ethereum. And with that goes another part, the modularity. So our goal is to be able to run on small devices as well as big servers.
00:03:01.294 - 00:03:59.082, Speaker A: And that's important because that helps the decentralization. So we are, everything we design, everything we do, we try to do in a way that it can run on mobile, it can run in a browser, it can run on raspberry PI at your home, or it can run on a backbone network, in a data center, in a massive beefy machine. And for that we have some set of protocols which allow users to either leverage the core backbone of the network, which I'll explain a bit later, called relay, but then also some high level protocols like light push and filter and store that allow you to use the mobile devices. Now, the last part is very crucial, because it's often, when you say messaging in web3, it often leads directly everyone to think about chat, like, yeah, sending messages. Obviously it's between people, right? There are no other messages. Well, there are, and there are use cases that are not related to chat at all. We can talk about them a bit more.
00:03:59.082 - 00:04:49.714, Speaker A: But basically, generalized messaging means that if you need, if you have two nodes, and nodes can be represented as a human or as a machine, they need to communicate anything in a privacy preserving manner in a peer to peer network, then that's what waku is for. And we can talk about those use cases based on the projects that use our infrastructure. So status, well, waku comes from status. Originally, status used whisper, which is part of the Ethereum trifecta thing, as a messaging, part of consensus, storage and messaging. But the whisperer used proof of work, and if you use proof of work on a mobile device, your mobile device is going to die. Sorry about that. So status came up with Vaku, and now we are at Vaku V two, which is complete rewrite of Vaku V one.
00:04:49.714 - 00:05:29.896, Speaker A: And it's basically this what I'm talking about, this network. Then there is railgun using waku, and Railgun is not chat at all. Railgun is a privacy transacting on Ethereum. So basically, if you need to send a private transaction to someone without revealing who you are and who is the recipient and what did you send them and how much and when and things like that, you can use railgun for that. And Relgon is using wacku in their relay network to kind of cut the link between the sender recipient and all these things. Then there is XMTP, which is another chat use case, and XMTP you may have heard this integrated into Coinbase wallet. So that's basically under the hood using waku as well.
00:05:29.896 - 00:06:16.730, Speaker A: So coinbase wallet under the hood is using waku through XMTP. And then graph is using us for something they called graph cast. If you are not familiar with graph, it's an indexing network for blockchain. So if you're emitting events from your smart contracts and you want to index them to easily query and have some overview of what people are doing with your smart contracts, you can use the graph and they have something called graphcast, which is a decentralized network of validators where they can share information about the subgraphs, about the actual indexes, so they can say, oh, this index is not indexable, or this subgraph is not indexable and it doesn't work. So don't even try. And then you can communicate. The nodes can communicate on this network and that's leveraging Vaku as well.
00:06:16.730 - 00:06:49.120, Speaker A: There is a link, Vaku.org comma. If you want to learn more, you can ask or you can just go there. Okay, so that's a general like what is waku? And I want to dig a bit deeper into just two things. So first of all, if you are a developer and you're developing a peer to peer network, you may be familiar with lip peer to peer. And lip peer to peer is a very common library to build peer to peer networks. And just to be clear, we are not rewriting leap peer to peer, we are based on leap peer to peer.
00:06:49.120 - 00:07:25.802, Speaker A: But I can give you r1 world example, which is about me. Before I joined Vaku, I had a project where I wanted to do some decentralized network where nodes would share information. And I found Vaku and I tried to do it with Vaku and it took me like 5 hours to get a PoC working. And I was like, that's awesome, that just works. But then the other day I was like, well, but Waco is using lippee to peer, so why would I use this level of abstraction? I should just use lippertopeer directly. So I tried, it took me two days and it still didn't work the way I wanted it to work. So that's why waku, because it abstracts a lot of complexities of literature.
00:07:25.802 - 00:07:56.278, Speaker A: Peer, it sets the nodes in a way that they are privacy preserving and work the way we think is best for a peer to peer communication network. And then I want to touch on relay protocol. I've mentioned it before and it's the core protocol of the whole network. And it's important because RLN, the ZK magic part, relays on that. Relays, relies on relay protocol. Sorry. So relay protocol is basically how Vaku works.
00:07:56.278 - 00:08:56.380, Speaker A: You send a message to a node or from a node in the network, and then every single node that you are connected to will relay that message, will send it forward to other nodes, and then to other nodes, and then to other nodes, and the message bubbles through whole network basically. And that's why we can, or it's how we can cut the link between sender and recipient, because you don't have to say who is the message for because it travels through whole networks, so every single nodes get it. And whoever understands it basically may be based on that it's encrypted with a public key and that node, or that the user has the private key to that public key, so he's the only one that can read it. One of the examples how you can figure out what the message is for you. When you get the message, you'll do something with it. If you are familiar with kind of traditional it or web two world, there are message buses, message queues, things like that, like kafka, SQs, rabidmQ, all these things. It's basically similar how vacuum works, but decentralized.
00:08:56.380 - 00:09:46.064, Speaker A: So you have a topic where you send messages, where you publish messages, and then there are subscribers who subscribe to that topic, and we have a standard pops up way of doing things. Now the thing is that we have this relay protocol, Vaku is completely permissionless. You don't have to go and I don't know, register somewhere to use waku. The problem with that is that you can very easily create new nodes very quickly rotate your key and span the network, and then all the nodes have problems. That's why we need some kind of rate limiting. Now this is kind of a break in the presentation. If you have questions, you can obviously ask right away or at the end, but if you want to just write the question down somewhere.
00:09:46.064 - 00:10:18.342, Speaker A: I've wrote this app, VAT app, on top of Vaku as an experiment, so if you want to try it, you can. There is also, there are free polls, free poll questions that you can answer. And it's another non chat use case over Vaku that I just wanted to try. J's Waku, the JavaScript line we have, and it ended up being this. So you can ask questions there and I'll try to answer them a bit later. So we want to prevent people spamming. So we need to first define what is spam.
00:10:18.342 - 00:10:59.174, Speaker A: So from Wikipedia, spam is food, canned pork, meat product. It's not what we care about here. And then there is spamming, unsolicited or undesired electronic messages, email, spam, messaging, spam. Okay, so we're doing messaging. So spam targeting users of, okay, so that's for chat, but okay, good enough. But there is one line that I think plays well with us, spam simply repeatedly sending the same message to the same user. Yeah, I mean we have the nodes which are basically users and then we're sending a lot of messages to them and they don't like it because maybe they don't have the bandwidth or maybe they don't have any other resources.
00:10:59.174 - 00:11:56.854, Speaker A: So how can people do the spamming? Or why is it even possible now today? So spamming remains economically viable because whoever the spammer is has no operating costs. And that's the same for vaku. Creating a new node, even if the other nodes will blacklist you or something, is very easy and it's very quick and very cheap from the resource perspective. So you can keep spamming. Oops. You can keep spamming, although you have been banned because you can create a new identity and it's difficult to hold senders accountable for the mass mailing. And that's especially true in a peer to peer, privacy preserving, decentralized network because if there is no global state of identity, so it's very easy to create a new identity and then it's very hard to keep you accountable for that.
00:11:56.854 - 00:12:31.460, Speaker A: Okay, so let's be very specific about spam. There are two types of spam, I think malicious messages. So things that may be hurting you if you act upon the message and then high volume of messages, the repeatedly sended messages. Repeatedly sent messages. So we don't care about the malicious messages because we are censorship resistant and we don't want censorship. We have no idea what malicious message is. Right? Like, I don't know if you saying pay me money is trying to scam someone or trying to actually get paid for some work.
00:12:31.460 - 00:13:10.172, Speaker A: So we don't care about malicious messages. We care about high volume of messages. And how can we prevent that? Can you use ZK magic? We basically need rate limiting. And for that the two groups, privacy and scaling explorations, which is a group funded by Ethereum foundation and then VAC, which is our deep research group, came up with something called rate limiting nullifier RLN. I'll share the slides after there are links to this, but you can also google it very easily. And what RLN is from kind of the tangible assets. It's a specification of how to define things and what do we need to provide as an information.
00:13:10.172 - 00:14:02.234, Speaker A: Then it's circuits, which is the ZK magic. It's the math for formulas and hashes and cryptographic approaches. As I said, it's magic to me. Then it's set of smart contracts which you need to keep a state of the identities, the membership, it's not really identities like you would be able to pinpoint who is who, but it's just to make sure that you know who is able to send messages. And those people need to be kind of registered or the users need to be registered in a smart contract. And then it's a set of client libraries so that you can integrate it easily into your application. Now how does it work? So the flow from the user perspective is that a user registers in a contract and what they do is that they have some secret which is basically randomly generated.
00:14:02.234 - 00:14:46.762, Speaker A: They create something called id commitment from it. And that's basically just a hash of that secret and maybe some other information. And they put it into a contract. And that contract has a miracle tree, which is a binary, binary miracle tree, binary structure where basically every single item on the bottom, the leaves are hashed together into one single mercury root. And we use that route and that membership in that tree for the user to generate proof and attach it to a message. So again, the message in Vaku is very simple. It's content topic, the kind of application identifier, the payload, the data I want to send and then timestamp and yeah, that's it.
00:14:46.762 - 00:15:45.724, Speaker A: There are some other metadata that you can attach, but you don't have to. But then also you have to attach this proof. And that proof is used in every single node on the relay protocol. When they get the message, they'll take a look at the proof, at the message and they validate the proof that actually that proof belongs to a user that is part of the membership set attached to this network and that the message is actually the one that the user sent, the user wanted to send. So from the user perspective, it's relatively easy. You register once and then the application will generate a proof from your message every time you send a message. Now how does it work in the network? So we have this happy path here and we have a decentralized peer to peer network where we can see with the arrows how the message will flow in the network because we know how the nodes are connected.
00:15:45.724 - 00:16:31.996, Speaker A: So we have this publisher here who publishes a message. It goes to the nodes that he's connected to and then they share it to, oopsie, they share it to other nodes and then it gets to the last one and then everyone knows about the message and everyone can do something with that. But the problem is that we also have the not so happy path where there is someone, we call them assholes. We call them assholes because we have a guy in the company who is leading one of the projects and he had a talk asshole resistant infrastructure. And that's what we are building because our problem is not with people that just want to use the decentralized stuff. People didn't want to abuse it and those are usually assholes. It could be also women.
00:16:31.996 - 00:17:24.310, Speaker A: So we need to find some gender neutral term, I guess. And he sends a message, well he doesn't send one message, he sends thousands of messages. And the thousands of messages travel to all the nodes same way as in with the happy path. But now all the nodes are on fire because they are trying to cope with those messages. And then you're burning through bandwidth, which is a problem for some devices that may not have, that may not be on the backbone of the network of the Internet, but then also it is a problem for some lower power devices because they can't process it. If I have a browser application and I try to process millions of messages that are not actually part of the application, my browser is probably going to be in trouble. So then we can invite this protector of the network called RLN.
00:17:24.310 - 00:18:00.464, Speaker A: So we have the example miracle tree here. So basically those are all the memberships the users registered RLN. I didn't mention it earlier. We keep coming up or we need to keep coming up with privacy preserving solutions. So the rate limiting is easy if you don't care about privacy because you just need to have some identity for the user or his ip or his email or something and then say whenever this user tries to send a message I'll just not allow him to send more messages. That's easy. But we don't want to have these identities here.
00:18:00.464 - 00:18:48.530, Speaker A: We want to have privacy preserving network where anyone, people don't have to share their private information. So by registering some secret that is random in that tree we can prove that we are part of the membership set and that we have sent some amount of messages per epoch. Epoch is like let's say 1 second so time window. So you can generate a proof which says I am a user that is allowed to send one message per second and I'm sending that one message per second. And then if you don't and the attacker is trying to send more messages. What happens is that a, the nodes will not forward those messages and b, there can be also slashing involved. So maybe the membership set has to register into the membership set.
00:18:48.530 - 00:19:50.716, Speaker A: You need to stake some amount of money, some economical value or some reputation or something. And if you do that and then you send too many messages, that can be slashed, so taken away, the economic value or something can be revealed about you. How Arlan works from that perspective, when you send too many messages, part of the proof is also part of that secret that you have in that membership tree. And as you send too many messages, you reveal too many parts of that secret, basically. And then someone can go recover that secret as a whole and can take the money that you staked or leak your secret or leak some information about you. And basically you reveal yourself by sending too many messages, which is the kind of key feature of Arlan. Right? So now the question is, does it actually work? Because in theory, I think this sounds good.
00:19:50.716 - 00:20:33.760, Speaker A: It sounds good to me if you have never thought about it. Maybe just boring, I guess. But does it work at scale? So we did some simulations in a network, hundreds of nodes running in a large machine, and we have been sending a lot of messages. So these are messages of different size. 50 is basically to prove whether, if you are generating the ZK proof, whether it's dependent on the size of the message. And it seems like it is not because the average is kind of stable around 150 milliseconds for proof generation. So when you are sending a message, it's going to take 150 milliseconds to generate that proof.
00:20:33.760 - 00:21:13.904, Speaker A: It's not too bad. I mean, unless you really like need to send a message now or someone will die. The 150 milliseconds should be, should be okay. And then every single node has to validate the message, which is also a problem, because if you have thousands of messages going through the network, utilizing the network to the max, you don't want to spend time on a note trying to calculate something for too long. So this, again, very similar graph on the top and at the bottom, you can see that the validation, the proof verification time is 15 milliseconds. So that should hopefully be fine and nobody's dying there. And then this is basically, this just shows how it works.
00:21:13.904 - 00:21:44.748, Speaker A: So we have all those nodes sending some amount of messages that, that are basically. So it's messages per minute. If we have one message per second, that would be like around 60 messages per minute. And they just send that and everything works and everyone chuggles along and it's awesome. You can see everyone is connected to many other nodes in the network. Amazing. And then suddenly one node, the orange one, which is twelve, starts sending excessive amount of messages.
00:21:44.748 - 00:22:22.340, Speaker A: So like 250, sorry, 2500, you can see that suddenly that node is completely disconnected from the network. It's basically like banned by other nodes because they don't like the guy anymore because he's sending invalid messages, which means too many messages with a proof over the rate limit. So they're like, nope, sorry, I'm not taking your messages anymore. And basically by that he's out. That's the asshole, the red one down there. Yeah. So we know it works, but it doesn't work completely.
00:22:22.340 - 00:23:02.304, Speaker A: And doesn't work completely. Awesome. It could be better. So when I talked here, what I talked here about was ARLn V one, and that's basically you have for whole network you have one rate limit. So once one message per epoch, so one message per second or ten messages per second or ten messages per minute, it doesn't really matter, but it's one setting for the whole network, right? V two is way smarter and you can set rate limit per user. So then you can maybe have a user that stakes more money have higher rate limit or something like that. So that's very useful.
00:23:02.304 - 00:23:32.836, Speaker A: And we need to update to rlN V two. And I believe if I'm not mistaken, RLN V three is in the works right now. So we're going to be updating forever. I guess then from Vaku perspective, it's integrated in our Golang client and our NIm client. But we're still working on the integration with J's waco client. Because the interesting part is that the Merkel tree is not physically, physically it's not stored anywhere as a data structure. We reconstruct it from blockchain events.
00:23:32.836 - 00:24:25.584, Speaker A: If you're familiar with smart contracts, they emit events, and those events are often used to build the information about what the smart contract has been doing since its deployment. So we use that and we build that Merkel tree from the events. But the problem is that you don't want to do that in the browser because you need a RPC node on the blockchain network and you need to sync with the node, and it will take from 30 seconds to five minutes depending on your speed and the node speed and how many events and things like that. It's not great if you open a website and have to wait for five minutes before you can do something with it. So we are looking at options how to actually optimize this and one of them, and we have this research topic here, basically use some l two instead of ethereum directly so that it's cheaper. And then store the whole tree on chain. Oops.
00:24:25.584 - 00:24:58.228, Speaker A: Store whole tree on chain which would allow the J's client to just download it from the chain in one go and just use it, which would be great. And then from RLM perspective, rate limiting the fire perspective, they are working on optimizing the proof generation and verification time. From my perspective, 150 milliseconds for generation and 15 milliseconds for verification is pretty good, but they are not happy with it. Okay, awesome. Let's make it better. They are trying to move to a different proof system again. ZK magic.
00:24:58.228 - 00:25:23.196, Speaker A: I don't understand it. They are experimenting with higher tree debt. So when I talked about this Merkle tree, these are technical details and I'm sorry if it's boring for you, but maybe it's not. The current Merkle tree debt is 20, which means two, because it's binary tree 220 which is like a million members. So you can have in one membership set, you can million people. So they are trying to get it to 32. So two to 32.
00:25:23.196 - 00:25:44.618, Speaker A: I don't know how much that is. I didn't check the calculation. But if someone can from Elaine, there's more for, what do you say? Billion? Yeah, 4 billion. Yeah. That's nice. I think that would cover almost all the users of the free, right. We have billions of people using blockchains right now.
00:25:44.618 - 00:26:25.298, Speaker A: Not really. Okay, so then they're optimizing gas usage. So right now that's not a big deal because we are just registering people and emitting that event. But if we store the tree or do want to do the verification of the proofs on chain that needs to be optimized. They are going through some audits and experiment with bolt epoch signaling. I believe that means that right now if you basically just start sending too many messages, you will get rate limited and potentially slashed or something. But if you could with this, you could basically borrow your rate limited from the future.
00:26:25.298 - 00:26:55.852, Speaker A: So you could say I will just send ten x messages, but then for ten epochs I won't send no messages, which could be useful for some applications, I guess. Okay, that's all I have. It's the end of the magical story again. My name is Vasilav Pavlin. You can reach out to me on this email. You can join us at discord to discuss things. If you have a project that could use some communication, some messaging, please reach out.
00:26:55.852 - 00:27:44.576, Speaker A: I'm a solution engineer for Waku, so you'll probably be talking to me at some point. And then if you have questions after the talk, there is still the quaku application that you can use. I'll take a look there. Actually, if there are any questions or anything, I'll reload it just to be sure that I didn't get disconnected. See, I still need to work on it a bit more because the UI is not always great depending on the size of your screen and if it loads. Okay, so seems someone answered great, someone heard about zero knowledge and someone uses communication. Awesome.
00:27:44.576 - 00:28:31.414, Speaker A: And yes I did. Thank you. I did get this and I'll just answer, I'll say yes. Do you need a blockchain here? It doesn't seem required for handling membership. So that's a good question, whether we need blockchain for the memberships. In theory you don't, but you need to make sure that all the nodes in the network have the same membership set because otherwise you could punish some users on one node and let them slide on another node. And that's a bad behavior because for reliability you need to make sure that all the messages get to all the nodes or not because then you would have some nodes knowing about some messages you would have split in the networks and things like that.
00:28:31.414 - 00:28:54.084, Speaker A: In theory, no, but you still need to figure out how to get that information to all the nodes. And for that consensus is kind of a good thing to have. Like all the people know the same thing because it's true. It's on blockchain. Right. So I think that's kind of the reasoning behind having blockchain there. But yeah, you can store merkle tree in any way.
00:28:54.084 - 00:29:43.474, Speaker A: You could have it on ipfs or wherever. You could just like send the messages over Vaku with new membership registrations and then reconstruct the miracle tree in memory. You could, but having the blockchain basically gives the membership set persistence. And if a new node joins, it's very easy to synchronize that blockchain, sorry, that state of the blockchain. What is the cost of registering as a sender? The cost is pretty low because it's very simple smart contract function. There is no, not a huge gas being consumed there. I don't know it from the top of my head, but in any case we are trying to move to some cheaper l two because we want to store it three on chain.
00:29:43.474 - 00:30:23.996, Speaker A: But it's a one time action. One way it can work is you don't potentially need all the users using infrastructure registered. You can also have kind of like an entry point node for your application where all the messages go through. You introduce some centralization and potentially privacy issues. But if you don't want people to have to register to some smart contract somehow and pay for gas and things like that. So a, you can pay for them and b, you can potentially use a single node to generate the proofs for users sending messages through that node. It has trade offs like everything.
00:30:23.996 - 00:30:45.744, Speaker A: So it depends. And I do, I'm sorry, I don't know the current cost of current gas. Cost of registering the. Come on. My words left me of registering the membership. Okay, any more questions from people right here? Yes.
00:30:47.224 - 00:30:49.964, Speaker B: Protected against civil attack if the cost is low.
00:30:53.664 - 00:31:55.738, Speaker A: Against civil attack. So, okay, so the question was, how are we protected against civil attacks if the cost is low? So you're right, like right now without any staking or, I don't know, like staking the reputation or staking the financial value. We are not really, because I can register multiple addresses and then instead of having one message per second, I can hand 100 messages per second. If the cost is low, it's a fair thing. Staking works with this. There is a version of a contract which allows staking. So you can enforce, like to register, you need to stake an amount of money, right? Or maybe the secret can be an email, right? Like you have to put your, you have to, you have to know something about yourself.
00:31:55.738 - 00:32:20.830, Speaker A: I mean email is stupid, but like some kind of valuable, valuable information leading to revealing yourself, right? You have to. So it wouldn't be reducing your privacy so it wouldn't be reducing your privacy because you will never, unless you break the limits, you will never reveal that secret, right? The goal is, no, you won't.
00:32:20.902 - 00:32:32.374, Speaker B: If I can simple attack, I can create 1000 accounts. It doesn't cost me much and I don't have to put stake and I don't have to put my email on each one of them. I simply create 1000.
00:32:32.414 - 00:33:03.376, Speaker A: That's how it send as many as I want. That's how it can work. Now you can create thousand accounts, but in the future there will be some staking involved which will prevent you from, well, potentially prevent you from doing that. But even if you do it, if you still do it by, if you still do it and you have thousand accounts and you send. Right. So what are you saying? Like if it's too, if it's too.
00:33:03.400 - 00:33:08.790, Speaker B: Cheap, if it's not privacy, because I cannot stake privately.
00:33:08.982 - 00:33:09.914, Speaker A: Why not?
00:33:10.814 - 00:33:16.390, Speaker B: How do I get the money in? Someone will know this address state?
00:33:16.582 - 00:33:47.894, Speaker A: Well, it depends. You could use some privacy focused chain like some ZK based chain, or you could use something like railgun to get the money into the potentially. Right, like we have to go one step at a time. You can also ask someone to register you because it's just about getting some information. The id commitment into the contract and the id commitment is based on some secret that you know. So you don't have to reveal the secret to me. But I can still register you.
00:33:47.894 - 00:34:07.234, Speaker A: So if you're building an application, you can let your user register through your application and you pay for them and then they are not losing privacy and you are the application that is running, that is doing things publicly, probably. So your privacy as an application is already kind of leaked so you can do it for the users.
00:34:08.294 - 00:34:36.970, Speaker B: The user will attack me. A civil attack. Still, you are letting a Sybil attack some entity, the network, the dapp. I want to understand how a malicious user, okay. Is blocked from sending messages because you didn't block anything. I didn't see a mechanism that can privately prevent civil attacks.
00:34:37.042 - 00:35:05.264, Speaker A: So your problem. So, okay, so your problem is that we have no way to limit the registrations a user and keep the privacy of those users. Okay. No, no, the address is not important.
00:35:15.744 - 00:35:18.164, Speaker B: I can say something.
00:35:27.024 - 00:35:54.916, Speaker A: Okay. No, it's, it's definitely an interesting point. I'm pretty sure that people from the PSE or Vac would be able to answer or give you some hints of what's coming maybe in the future. I don't have an answer for that. I'm sorry about that. Everyone is in Istanbul. If you can quickly jump to Istanbul, they are all there presenting way deeper talks than I am.
00:35:54.916 - 00:36:16.564, Speaker A: This was very short noticed, but I think I get what you have and if you. I'll try to summarize it and I'll try to ask and we can publish the answer somewhere or we can connect. I'll be happy to connect you with the right people to ask the question. I think it's a very valid question, but I don't have an answer. Sorry about that.
00:36:33.684 - 00:36:39.836, Speaker B: Like it was before, I just download status, it creates my address and I.
00:36:39.860 - 00:36:40.424, Speaker A: Just.
00:36:44.084 - 00:36:46.836, Speaker B: Have to register and pay money to use status.
00:36:46.980 - 00:37:28.022, Speaker A: Okay, so I'll say the question for the recording. If there is an application using Vaku and RLN like status, will every single user have to register and then based on that pay money to use the app? Fair question. I don't know what the actual plan of status is. I know that they are not using RLN right now. Because we are just including it into, or we have just included into Vaku. So they are still using some other ways to limit things, limit spam. As I said, one option is that every single user registers, but it can also be subsidized by the app.
00:37:28.022 - 00:38:39.238, Speaker A: So basically you generate locally the id commitment from your secret, and then you provide it to the app and the app does the registration. That would make sense to me from the perspective of applications that actually want to attract users so that the user doesn't have to pay. If you don't want to do this and you don't want to provide the information to that application, like the id commitment and the pairing between, basically between your account and the id commitment used in the membership set, you can do it and pay yourself. The thing is that then there is no, at least from the research perspective and the people developing RLN, there is no other way to keep users private when sending messages and not having them register somewhere, like having that membership set somehow defined so that we can limit how the messages travel through the network based on that. So if there will be different way, then I'm pretty sure that status and others will explore it. Right now this is kind of the way that Waco is taking. Yeah, but I think there are ways of getting around this so that the user doesn't actually have to pay the gas.
00:38:39.238 - 00:39:56.584, Speaker A: We will definitely try to search for some cheap decentralized l two or something where the cost of registering is not high, and for that the application can kind of subsidize that, which I think status will probably do, but I have no visibility into that. Honestly, what's the difference between reliable and unreliable broadcast? Okay, so the question is whether if I send a message to the network, whether I can be sure that the message reaches everybody. The message reliably reaches everybody who is online and connected at the point of message being sent. So all the peers connected together in a mesh will get the message. Like that's how the software works, unless it doesn't work, obviously. But if everything works, then every single node will get that message. But if the node goes offline and then comes back online and there were messages in between, then the node doesn't know about the messages.
00:39:56.584 - 00:40:40.446, Speaker A: There is something we call, it's called store protocol on top of Vaku, which basically allows particular nodes to store and cache all the messages that they received and relayed. And then other nodes can query those store nodes and get missing messages. So you can specify for this pub sub topic. And for this timeframe I would like to see all the messages that you know about. So if you go offline for five minutes, you can query one of the store nodes. I mean, you basically just send a message to the network and some store node will reply and you get the list of messages that they know about. But at this point in time, if that store node went offline for the same time you did, then they would not know about the messages.
00:40:40.446 - 00:41:16.114, Speaker A: We are working and you can go to Vaku.org research on GitHub and there are research topics and research issues. We were researching some sync protocol to make sure that if a store node goes offline and then comes back so that it syncs with other store nodes in the network, so that we have some kind of cohesive state of historical messages for some amount of time. Right. But right now that's the kind of limitation. And applications on application will work around this by querying the store nodes. So if you are not sure, you can query for the whole history, or you can query for the last five minutes or whatever.
00:41:23.474 - 00:41:24.654, Speaker B: History or.
00:41:30.034 - 00:42:06.554, Speaker A: So, the question is whether the messages persist on the nodes. So if you operate a store node, so enable the store protocol, you can choose how long the messages should be persisted. We have sqlite and postgres backends for that, for that archive, and you can choose whether to do the cleanup or the garbage collection based on time or the storage consumed. And there is one more number of messages in the archive. So what we do in our fleet nodes, we clean them. We clean the messages after seven days. For example, status has their own fleet nodes and they keep messages for a month.
00:42:06.554 - 00:42:43.170, Speaker A: But the more messages you get, the more storage you need for keeping data for longer period. One of the other research items is also figuring out incentivization. So when you query the store node, you may need to pay some money in the future. So maybe you will pay well, not maybe, but definitely will pay less if you query for last five minutes and pay more if you query for a month. But then that will incentivize people to actually run store nodes and provide a good service for that. But that's, again still in a research phase. But if anyone wants to contribute, go to the vaku.org
00:42:43.170 - 00:42:53.274, Speaker A: or go to the discord or vaku.org on GitHub and check the open issues there. And we are happy to get some ideas from the community. I think I'm out of time.
