00:00:11.680 - 00:00:45.170, Speaker A: Thank you. Hello, everyone, my name is Rick Weber, and I'm going to be talking today about fully homomorphic encryption and what all needs to happen in order for this to become a reality in web three. So just a quick survey. Has anyone here heard of fully homomorphic encryption? Okay, a few people then. You may have heard some of these rumors. You may have heard that it's kind of slow, you've heard that it's unusable, or that's kind of useless. Two of these, in fact, today are actually kind of true in web three, and one of them a little less so.
00:00:45.170 - 00:01:40.804, Speaker A: And hopefully at the end of the talk you'll know which is which. So, to start off, what is fully homomorphic encryption, also known as fhe? So you take a traditional public key encryption scheme, so you generate a public and private key, then you can use the public key to encrypt data, and you can also take a ciphertext and use a secret key to decrypt the data. But there's these additional operations you can do. So you can add ciphertext together, which will produce a new ciphertext that contains the sum of the messages in the operands. And similarly you can do the same with multiplication, producing the product. There's an additional operation called bootstrapping, and all fhe schemes today use a branch of cryptography known as lattice cryptography. This means that they are quantum safe, but they unfortunately have this side effect called noise.
00:01:40.804 - 00:02:27.264, Speaker A: And what noise is, is as you perform these add and multiply operations, you get more and more noise in the resulting ciphertext. If that noise exceeds some threshold, then if you attempt to decrypt this ciphertext, you get garbage. And so what bootstrapping does is it resets the amount of noise in a ciphertext. And using this technique, you can compute for effectively forever. And because you can do addition and multiplication, and you can do effectively an unlimited number of them, you can compute polynomials. Thus you can compute any function you want. So to give a kind of brief history of fully homorphic encryption, it came into existence conceptually about a year after RSA was invented.
00:02:27.264 - 00:03:16.484, Speaker A: It took about 30 years from there to come up with the first implementable scheme. This was done by Craig Gentry, where he introduced the idea of bootstrapping. This scheme was extremely slow, and in practice it was more academically interesting than practically interesting. A few years later, BGV and BFV were born, and these feature very fast arithmetic. But bootstrapping under these schemes is fairly slow. And so in principle, in practice, people don't actually use bootstrapping under these schemes, a few years later, we got ckks, which uses approximate arithmetic, and then we got TFHE, which uses binary arithmetic. And TFHE has the added benefit that bootstrapping is very fast, which means that you can effectively do it every operation.
00:03:16.484 - 00:04:41.724, Speaker A: Currently, if you were to deploy fhe, you could expect to see performance slowdowns of between a couple hundred thousand to a couple million, and you would further see memory usage increase by about that size too. And yeah, so why are we here talking about FhE? Fhe is a new tool in the toolbox that you can use to create new kinds of applications. You can have private auctions, you can have dark pools, and you can compute on private shared state if you also use multi party computation. Fhe by itself is not extraordinarily interesting in web three because people can just send random messages that aren't ciphertexts. You wouldn't be able to tell the difference and it would break everything. However, when combined with zero knowledge proofs, you can create robust systems. So how do we combine fhe and zero knowledge proofs in web three? There's two kinds of different models that you theoretically could use, so you can use honest majority, whereby every validator is running the fhe computation and validating proofs coming from users to show that the ciphertext they're getting are well formed and that the messages contained within them obey the properties of the system.
00:04:41.724 - 00:05:29.342, Speaker A: But you could also turn this into a roll up, where a validator can do everything that we just talked about and then additionally produce another zero knowledge proof showing that the proofs were validated correctly and the fhe computation happened correctly. This roll up today is kind of academically interesting, but in practice is too cost prohibitive to actually perform. So everything we're going to be talking about today, we're going to be talking about implementing things with honest majority. So you want to use fhe and web three. What do you have to do? Well, you have to pick an fhe scheme. We have three schemes to kind of choose from today. We have BFE, CK's, and TFHE, and so we have three schemes, but we actually only have two schemes.
00:05:29.342 - 00:06:09.066, Speaker A: CKKs uses approximate arithmetic, which if you've ever seen the movie office space, you realize may be a bad idea for financial transactions. As you get rounding errors, Bfe and tfhe, then Bfe you can perform fast computation. So addition and multiplications are very fast. You get lots of precision, way more than is needed for performing operations in a blockchain. Setting the keys in ciphertext are small. And yes, those are scare quotes, because everything is relative. Unfortunately, performing some computations with BFE is fairly difficult.
00:06:09.066 - 00:07:04.464, Speaker A: For example, if you want to compute the maximum of two values, this is very hard to do if not practical with BFV. Furthermore, bootstrapping is extremely expensive with BFE, and so in practice you don't do it, which means that the number of computations you can perform is finite. Tfhe, on the other hand, you can do a lot more operations because of the binary nature of it. So you can, if you want to compute the max of two values, this is possible to do in a reasonable amount of time. You can bootstrap on every operation, which means that noise in practice stays at a fixed level. Unfortunately, there's issues with precision. So if you want to use 32 bit integers or something of approximately that size, your arithmetic is going to be kind of slow and performance will be affected.
00:07:04.464 - 00:07:53.804, Speaker A: So you also have fairly large keys, and you can have large ciphertexts if you use tfhe. So now that we've chosen a scheme, depending on what we're trying to do, we need to set up the scheme. So with BFE, plaintexts are polynomials where every coefficient is modulo p. P here means plaintext coefficient, it does not mean prime as it usually does, and ciphertexts are polynomials modulo q. For the scheme to be correct and functional, we have to have that q is significantly larger than p. So working with polynomials is kind of annoying. So we want to encode data onto the polynomial, for example, an integer.
00:07:53.804 - 00:08:44.180, Speaker A: One way you can do this is you can ignore and zero all of the terms in the polynomial except for the constant term. And then when you add and multiply these, you're multiplying integer values, and this will behave correctly. But this requires a fairly large polynomial modulus or plaintext modulus in order to not have overflow problems. Alternatively, you can decompose your integer into binary and transcribe this onto the coefficients of the polynomial. So once we've chosen how we want to encode our data, we need to choose the scheme parameters. So we've already kind of talked about the plaintext modulus and the coefficient mod cipher text modulus q. But there are other scheme parameters as well, such as a polynomial degree.
00:08:44.180 - 00:10:05.418, Speaker A: And if you choose these parameters poorly, you can either have way lower performance than needed, or if you make the parameters too small, then you don't have enough computation to successfully decrypt the result. So choosing a larger value of the polynomial degree means you can do more computation because you have a larger noise budget, but it also increases the size of ciphertext and reduces the computation throughput. Finally, BFE has this relinearization operation that after a multiply ciphertext grow in size, relinearization knocks them back down. So the question is, when do you put these into your computation? So is fhe fast or slow? Well, it depends what you're trying to do. If you're trying to do something reasonable and you choose the appropriate scheme, fhe can actually be very fast. Furthermore, if you choose, you need to choose the parameters correctly suitable for your computation, and then you have to create a circuit that efficiently runs that computation. If we're looking at 32 bit precision and we want to compare BFE to TFHE, we see that key generation takes can take quite a while with TFHE, but this is often a one time cost.
00:10:05.418 - 00:11:03.504, Speaker A: So maybe it's not a problem, but the other areas where they differ is that you can see multiplication is significantly faster with BFV than with TFHE. And to kind of give some even more context, this BFV time was not multi threaded, the TFHe one was. Unfortunately, doing computation comparisons with BFE, as we've mentioned before, is extremely difficult, but it is possible with TFHE. Now let's look at what happens if we change the scheme parameters with BFV. So we see, if we change the lattice dimension from 2048 all the way up to 8192, then we see that the runtimes of various operations increases by maybe a factor of 16. So choosing the right parameters, this kind of highlights why it's important to do so. Everything gets slower if you make things bigger.
00:11:03.504 - 00:11:45.778, Speaker A: Conversely, with TFHE, if you change the amount of precision, you can see that if we 1.5 x the amount of precision, going from 32 to 48 bit, most things are about 1.5 x slower, except for multiplication, which is not. It grows by more than a factor of two. So what's challenging for fhe, you have to pick the right encoding. How you want to map your data onto the underlying plaintext values, you have to choose the right scheme parameters. You have to insert cipher text maintenance operations as appropriate, for example, relinearization.
00:11:45.778 - 00:12:53.220, Speaker A: With BFE, you have to choose the right amount of precision you want to use if you want to use TFHE, and then finally you have to make an efficient circuit that performs the calculation you want to do. So taking high level descriptions of programs and turning them into some kind of executable format is exactly what a compiler does. But unfortunately, today a lot of fhe compilers are not so great at this. So we're going to look at an application from this Sok paper, and this is a chi squared test. And if you were to implement this manually in Microsoft Seal with BFV, and you timed the key generation, encryption, computation and decryption, you can do this in about 50 milliseconds on a commodity laptop. However, a lot of fhe compilers, you just can describe this exact program and you get overheads anywhere from a few hundred fold to tens of thousands of fold. Two notable exceptions here are AVA, which is a Microsoft compiler that uses ckks.
00:12:53.220 - 00:13:37.064, Speaker A: And again, ckks is not so useful in web three, and then the sunscreen compiler which can do this with a 1.3. X overhead. So for a compiler to be useful in web three, it has to deliver performance. And then kind of the final step you have to do if you want to use fhe and web three, you have to prove that your ciphertexts obey the properties of the system and are well formed. So let's take this example. Alice wants to send some money to Bob. So the way you can do this is you have a ledger balance that's encrypted on chain, and Alice can produce a value that she encrypts under both her key and Bob's key.
00:13:37.064 - 00:14:29.374, Speaker A: And she has to show that both of these ciphertexts are well formed, so they're not just random garbage. She has to show that the amounts contained in the message that will be subtracted from her balance is the same as the message that will be added to Bob's balance, even though they're encrypted under different keys. She also has to show that the amount she's transacting is greater than zero, shows she's not stealing money from Bob. And she also has to show that it's less than her balance, so she's not printing money. So Fe on its own is actually not useful in web three because everyone can just print money and do all kinds of things that violate the system. So you have to have zero knowledge proofs to go along with it. And unfortunately, zero knowledge proofs are the expensive part of all this computation.
00:14:29.374 - 00:15:12.664, Speaker A: So the first thing we have to show is that ciphertexts are well formed, and there's a number of ways in which you can do this. We first attempted to use r one cs and then try to find a proof system supporting r one cs that met kind of the prover verify times and proof size needs. But we were unable to succeed in doing so. So we moved to something called the short discrete log proof. And this is not a general proof or purpose proof system. It is specifically for showing lattice relations. And so Alice, who knows s and the verifier knows a and t.
00:15:12.664 - 00:16:04.384, Speaker A: S contains your message and the noise used during the encryption process. T contains the ciphertext and a is just setting up the lattice structure and is public. So Alice can create a commitment to s and then prove that s in zero knowledge that as equals t. And if she does so, and also shows that the coefficients in s are sufficiently short or small, then she will have proven that this is a valid encryption under a specific key. So short discrete log proof has some problems in its when you implement it, the prover times are ok compared to other things out there, the verifier times are not. And the proof sizes are actually pretty good. They're under 2 kb.
00:16:04.384 - 00:17:01.804, Speaker A: So what we're working on currently is can we accelerate the operations used during verification? So we have scalar inversion, scalar multiplication, and guess what? Multiscalar multiplication. Everyone's trying to speed this up. We're trying to do it on curve 20 519 though. So now that we've shown that a ciphertext is well formed, we have to show that the messages contained in the ciphertext obey the properties of the system. So like you're not subtracting money from someone else. So we, to do this we use bullet proofs with r one cs. And even though we're using bullet proofs which has linear verification time, as the number of constraints increases, the number of constraints and multiplies you need to create these kind of circuits is not very large, you don't need very many of them.
00:17:01.804 - 00:17:56.524, Speaker A: So we have pretty reasonable prover times, reasonable verifier times, and our proof sizes are under 2 kb. But we have a problem. So the prover has created a proof to short discrete log proof and a proof to the bulletproofs, kind of in a vacuum. How does the verifier know that the inputs you gave to both of these proofs were the same? Well, it turns out both schemes use pedersen commitments at their core. And so what you can do is break these pedersen commitments into shared and non shared parts. And if you, the shared part contains the commitment to the inputs to the r one cs circuit and is also part of the short discrete log proof coefficients in s. So because you're sharing the same commitments, you, the verifier knows that these are the same inputs.
00:17:56.524 - 00:18:39.754, Speaker A: And so using a number of other tricks like using the same curve, permuting some generators and reusing the blinding factor. The verifier can be convinced that the inputs going into both proofs are the same. So when we initially set out, we started trying to prove all of this with r one cs because it would provide a nice interface. So we built a compiler because expressing this directly with the bulletproof library would be kind of tedious. So we built a compiler. This is currently ongoing work and we're kind of refining it. But the kind of general idea is you write a rust function, you put a little macro on it and pass it to the compiler and it will build a circuit for you.
00:18:39.754 - 00:19:14.602, Speaker A: Because everything is in rust, it's in a DSL. You can share your circuits with others using crates as you would anything else. In rust. You also get all the syntax highlighting and all the other nice things about the rust ecosystem. Today we support types, gadgets, and public and private inputs. And for R one cs alone, this API is very straightforward. You compile a circuit, you then can feed some inputs and generate a proof for it that satisfy that circuit.
00:19:14.602 - 00:20:15.134, Speaker A: And then you can give that proof to somebody and they can verify that it's correct. However, what happens when we bring short discrete log proofs into the picture? How does one specify that a matrix to set up the proof of ciphertext? Well, form this. And how do you specify what you're going to share between the two proofs? This is currently an open question, and we're still iterating on this. So if you want to build a compiler for web three, it has to do a number of things. It has to support BFE or TFHe, because these are the two schemes that are useful in web three. It has to build fast circuits, and then you need a runtime that can efficiently run the circuits. So using multithreading you need data types so users aren't playing directly with polynomials, and you need kind of efficient mechanisms under TFHe so that people can play with integers.
00:20:15.134 - 00:20:53.136, Speaker A: You need to automatically insert cipher text maintenance operations such as relinearization, because you don't want to have to explain to a developer what relinearization is. And finally, a lot of compilers today view fhe compilation as I'm going to compile this one circuit, I'm going to run some inputs through it, get a result, and then decrypt that. And that's the end of the story. But that's not really the scenario in Web three. In Web three you have a balance that's on chain. I send some money to you, your balance increments, you send some money to someone else. Now it decrements.
00:20:53.136 - 00:21:37.794, Speaker A: And so the ciphertext is going through multiple circuits. We call this program chaining, and this is a mechanism that will help inform what parameters you should use during compilation. Then finally, fhe is useless without zero knowledge proofs. So you kind of need a runtime that can marry the integration between zero knowledge proofs and fhe. So today, fhe is not actually usable in Web three. We need better tooling, and in particular, we need to marry fhe and zero knowledge proofs together. So now we've kind of talked about a number of problems with bringing fhe to web three.
00:21:37.794 - 00:21:58.954, Speaker A: We can hopefully start bringing some solutions to the table. So this concludes the talk. You can follow us at Sunscreentech on Twitter, or you can visit sunscreen tech. And that's our website, from where you can access our discord, our GitHub repository, and our blog. So at this point, I can take any questions.
