00:00:14.480 - 00:01:02.854, Speaker A: Hello everyone, and welcome to the Paranoid Developer's guide to safer smart contracts. My name is Baran, I am a former security auditor and I currently work as a smart contract developer at Mentalabs. So this talk is about paranoid development. This is not an official concept, but it is just a name that I came up with to my approach to smart contract development. And over next 20 minutes I will explain this concept. I will start with the mindset of the paranoid developer and then continue with the practice. And the mindset can be summarized as trust no one, nothing, and verify everything.
00:01:02.854 - 00:02:02.854, Speaker A: So before going into this approach, let's discuss the need for another approach. So how many of you are smart contract developers here? Okay, it's almost half. So I believe that we share the same challenge and that is crafting robust code. It is a fun challenge to have, but I mean, it's not that unique, right? All the developers out there want to do the same thing. But I believe we are separated from the rest of the group because of a very important problem. And that problem is asymmetry of resources and the incentives between us developers and our adversaries. So let's start with the good guys.
00:02:02.854 - 00:03:07.724, Speaker A: And we have the protocols on the site. And protocols usually operate under tight deadlines and strong product pressure. And protocols hire developers and the primary incentive of the developers comes from their salaries and occasionally from tokens which are weakly aligned with the success of the protocol. Once the features are done and you pushed your code to a repo, you hand off your project to an audit company or in some cases independent auditors. And you need to find a good audit company. And this is a really hard problem because the only metric that we have is the track record of the audit companies. And obviously past success doesn't guarantee future success.
00:03:07.724 - 00:04:11.096, Speaker A: Audits are usually brief and time box engagements and the payment is usually independent of the result. Again, we have an incentive problem here. And another problem here that we should think about is it usually takes months and in some cases years to correctly assess the quality of an audit. The next group of people is the bounty hunters. And bounty hunters usually have countless of projects to choose from and they usually don't have any guaranteed payments. So you should be incentivizing them really well if you want them to look into your code. Okay, next, let's talk about the bad guys.
00:04:11.096 - 00:05:07.574, Speaker A: And by bad guys I mean the black attackers and maybe even nation state actors like Lazarus group. They are heavily incentivized by the hundreds of millions of dollars and in some cases billions of dollars. And their success means direct monetary gain for them. They have unlimited resources and they have unlimited time, and they have freedom to employ any tactic. As you can see, there is an enormous imbalance here. On the one side, we have nation state actors, an army of highly incentivized hackers, and on the other side we have small teams of mildly incentivized developers. This asymmetry demands a shift in our approach.
00:05:07.574 - 00:06:08.584, Speaker A: We are like that guy over there, armed with a small weapon, and we are trying to fight a golite. And if we want to have a better chance in this fight, we need to be very well prepared and we need to master our weapons. So our approach can be summarized as we test, retest and verify everything under various conditions, using different techniques and on every possible environment. This test also ideally should be conducted by different people. We do not take security for granted. We do not assume it is just going to work. We do not assume what we missed is going to be catched by an auditor or one of our friends.
00:06:08.584 - 00:07:18.884, Speaker A: Our security depends on diligence at every step, and we need to establish a culture of proactive security. Okay, if you are going to remember, oops, if you are going to remember a single thing from this talk, it should be probably the slide. So practically, you need to question every aspect of your system. You need to assume every component could fail. You need to cover all your bases extensively and repeatedly, and you need to help external parties to do their job. So we were focusing on the theory and the mindset so far, and let's start talking about the practice. So, just like any other blockchain team out there, the foundation of our testing framework is unit and integration tests.
00:07:18.884 - 00:08:13.454, Speaker A: So we test basic functionality. We test each edge cases that we can think of, and we write positive and negative tests. Also, we check each structure, storage write, and each reverting condition. It's also important to ensure that your events are fired properly, and it's useful to integrate all of this into your CI CD pipeline to protect yourself from regression bugs. So the next technique that we daily use is, is fast testing. So it basically means providing random inputs to your functions and try to break them with them. It's a very useful technique, especially to catch edge cases.
00:08:13.454 - 00:09:06.344, Speaker A: So I can give you an example here. We have an emission contract in our core repo, and I'm not sure if you can read it, but we have a function here called calculate emission. This function is responsible for emitting mental tokens, and we use an exponentially decaying formula to calculate the amount that is going to be emitted at any given time. But as you guys know, solidity is not the best when it comes to work with exponents. And in order to work around that, we came up with an approximation of the original formula. But we had a subtle bug in this approximation. That bug was missed in unit and integration tests.
00:09:06.344 - 00:10:04.374, Speaker A: But luckily our first test was able to catch this, and the next is fork testing. So when you run a test on the background, your development environment spins up a fresh new blockchain and deploys your fresh contracts. On top of that, it is usually good enough. But as you can guess, the environment you are running your tests on is quite different than the environment that your contract is going to be run. So you can use fork testing to simulate real world blockchain conditions with live blockchain replicas. We have a dedicated repo for this purpose. It is open source, you can check it out.
00:10:04.374 - 00:11:14.852, Speaker A: And in that repo we have some fork tests that simulate user actions against our live deployed contracts. We run those tests automatically and periodically, and if something breaks because of the evolving blockchain state, or maybe an update to third party, we will get notified. Okay, now let's talk about less common and more sophisticated strategies that we use. And I will start with formal verification. So unlike traditional testing methods we discussed, which effectively you run, you execute your code with formula, you use mathematical models to prove the correctness of your code. So it is very useful because it can give guarantees that no other technique cannot. And it is a time consuming process by its nature.
00:11:14.852 - 00:12:23.964, Speaker A: And because of that we use it selectively at mental apps. But a prime example to this is we have a contract called stable token v two and we are a stable token protocol, and we use this contract for all our stable tokens. Since we are on celo blockchain where you can pay for gas using arc 20 tokens, you need to have this function. I'm not sure if it is readable, but it's called credit gas fees and you need to have this function in your token contract. As you can guess, this is a very critical function because a failure in this function might mean a disruption of whole blockchain. So we had a recent update on this function and we formally verified this function using sartora, basically to deploy with more confidence. Okay, one other thing that we like to do a lot is on chain monitoring, and it basically means continuously observing the state and activities on your protocol.
00:12:23.964 - 00:13:29.454, Speaker A: We mainly use two tools for this, and the first one is like a very popular one called dune analytics. You can create analytical dashboards with them, and the second one is our in house develop tool called Aegis. Aegis is designed to expose on chain view calls as Prometheus metrics, and you can ingest that metrics into your Grafana dashboard, and you can create very customized, very nice looking dashboards using that. You can also use that metrics as Prometheus alerts. So if one of your invariants broke or if there is something weird happening on chain, you will get notified in real time. This is an open source project and it is business logic agnostic. So go to our repo, fork it and start using it in no time.
00:13:29.454 - 00:14:43.044, Speaker A: And the last technique that I will mention here is the circuit breakers and circuit breakers we are talking about on chain circuit breakers here, and on chain circuit breakers are modeled after their traditional finance counterparts, so we use them to temporarily halt or limit trading under abnormal conditions. So we are a stable token platform and protocol, and we heavily depend on oracles in order to protect us from price manipulation, attacks or abnormal market conditions. We developed on chain circuit breakers and our circuit breakers are autonomous and decentralized. It is a little complex to fully explain the design of it, but it is a really cool piece of tech. If you want to learn more about it, please go to our blog. We have two amazing blog posts about it. One is about the theory behind it and the other one explains more like how we use it in practice.
00:14:43.044 - 00:15:52.124, Speaker A: But yeah, they are quite good posts, so please feel free to look for them. And yeah, okay, so one of the most beneficial things that you can do to support your protocol is to enable external security professionals. And that starts with a proper documentation. So I'm sure you all write comments for your code, but it's important to have very detailed documentation of your whole project. So by documentation I mean you should be explaining the intent of your project, and you should be explaining the decisions that you made, and maybe even explain each component and your design in detail. And the next is a readiness checklist. So I recommend this to everybody who's going to work with an external professional.
00:15:52.124 - 00:17:37.703, Speaker A: So it's basically a list of your internal efforts, and you basically go through that list before each external engagement, and you basically remind yourself that what you have to do before engaging with an external party, maybe the most important piece of your documentation is a handoff document. So before starting an engagement, you should be in code freeze, and this document should include the details of your code freeze, your final commit hash information about your repo, the detailed scope of the engagement of the audit, maybe your trust models and assumptions, and also you should be explaining the complex and novel parts of your system so that external professionals can spend more time on those parts. Okay. When you are done with your code and you prepare the detailed documentation, and you did your best with your tests and form of verification and everything, it is time to reach out to external professionals. What I usually recommend is every team should have one dedicated security person. That can be someone in your team who is security aware, or maybe someone external like an external consultant or a friend. And that person should be responsible for doing the initial review.
00:17:37.703 - 00:18:35.048, Speaker A: And in that initial review, they should check your project, they should check your code, and they should check your documentation, and they should basically be sure that you are ready for an external engagement. Audits are expensive and you should do your best beforehand to extract the maximum value out of that engagement. When your dedicated security person give you a call. Now you go out and find an audit company, hopefully a trusted partner that you work a lot, and you should start building a relationship with them. And you should also get to know the researchers who is actually looking into your code. Because in most cases you don't know who is looking into your code. But I think it's a mistake.
00:18:35.048 - 00:19:44.994, Speaker A: You should also form a certain type of relationship with the specific people who are looking at your code. Okay, once your traditional audit is done and you fixed all your issues and your fixes are reviewed, it's time to go for a contest. With a traditional audit, you only have two or three sets of eyes looking into your code and it is insufficient with a contest. You potentially have hundreds of people looking into your code and they will do their best to secure your protocol. So how I see this is once we deploy our protocols and once we are live with some TVL, there will be hundreds of malicious eyes directed at our protocol. So why we are not doing that before the deployment? For our own good. So there are different options here and they are more or less the same with some small differences.
00:19:44.994 - 00:20:41.164, Speaker A: You should compare the options. So we have c four, Sherlock hat and bunch of others. So you should compare them and choose the one that fits to your needs. And the last group of people you are going to be engaging with is the bounty hunters. And I strongly believe that you should have a bounty program ready before the deployment. I already mentioned this, but you should do your best to incentivize bounty hunters to help you with your security. And the program that you create for bounties should be transparent and clear with the rules, and you should be as fair as possible to the submissions that are sent to those programs.
00:20:41.164 - 00:21:35.424, Speaker A: So you can use a platform like unify for this or you can host your own bounty program. Okay, so remember, security might be a part time thing for you, but your enemies do over time every day. But don't be afraid. We are a community of very capable people and we have similar goals and we share the same enemy. So we should work hard. We should do our best to outsmart our enemies. So a very smart guy said this.
00:21:35.424 - 00:22:04.994, Speaker A: His name is Andy Grove. Only the paranoid survive. Thank you very much for listening me. If you want to discuss anything further, just send me a message or email at hyakkim IO. Or just scan this QR code to join our community at mental labs. If you have any, any questions, I think it's a good time to ask because we still have two more minutes.
00:22:11.694 - 00:22:20.714, Speaker B: Thank you so much for the presentation. What do you see in the AI space to automate some of the steps that you presented?
00:22:21.294 - 00:22:50.614, Speaker A: I think we are quite early at that because we all share the same tools and I mean, and not all those tools work really well, at least for now. I tried a bunch of tools, I don't want to name any of them, but they are all very on the surface level and they produce a lot of false positives. So I think they are not good enough for now.
00:22:51.574 - 00:22:52.514, Speaker B: Thank you.
00:22:52.894 - 00:23:08.174, Speaker A: Thank you for your question. All right, thank you everyone. And I will be right over there if you have any questions. Thanks a lot.
