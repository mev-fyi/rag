00:00:09.240 - 00:00:33.984, Speaker A: All right, this mic is not on. Check, check. Yes, there we are. Okay. And we are actually back with the program, so please find a seat and get yourself comfy because we are continuing with a lot of very nice talks. I know, that was intense. Please also stop any chit chat that you're having in the back because.
00:00:34.364 - 00:00:35.144, Speaker B: Hello.
00:00:35.524 - 00:01:02.144, Speaker A: That can be disturbing for the speaker. So, yeah, please find a seat and join us here. I am super excited to announce the next speaker. It's Avihu. He's the CPO of Starkware, and he will explain how recent breakthroughs with stark verification on bitcoin might actually allow to finally unlock large scale computation on bitcoin in form of a bitcoin L2. So please give it up for him.
00:01:09.794 - 00:01:23.654, Speaker B: Okay. Hi, everyone. I hope there is not too much echo. If there is, just mark me and I will do like this and not like this. Okay, great. So, hi, my name is Avil. I work at Starkware.
00:01:23.654 - 00:02:17.054, Speaker B: Well, thank you. Can someone take this out? Okay, so, today I'm going to speak about this weird topic that is how to build an l two on top of bitcoin. There has been a lot of discussions. This topic came back to be an interesting one, but at least for me, I haven't really seen something that is structured and explain how this can be done. And so this very short talk is going to try and explain exactly that. Okay, so what we will do is I will give very little bit of motivation on why do we need l two s on bitcoin? And then I'll just spend the rest of the time explaining you how this would work. I hope you stay with me.
00:02:17.054 - 00:03:42.564, Speaker B: I assume you have very little to no knowledge about bitcoin altogether. So don't worry if you don't remember what is a utxo? Okay. Nope. You want to click it for me? Maybe enjoy the silence for 10 seconds? Exactly ten minutes. Oliver, I hope you don't count this for me. It's working now. Okay.
00:03:42.564 - 00:04:12.094, Speaker B: Yes. Can we see the slides? Okay, we are back. So, one slide about motivation. I promise I'm not going to talk more about this. Why do we want l two s on bitcoin? So, I mentioned three things. All three are very, very important. The first one is very simple, and you could all guess it already.
00:04:12.094 - 00:04:59.724, Speaker B: When we talk about scalability, we want cheaper, higher throughput transactions of BTC. And that's something that you can't get on bitcoin today in a reasonable way. We want expressibility, which means, I don't know if you ever tried to write in bitcoin script. If you did, you would understand that this language is very incapable and very hard. And we want to enable bitcoin developers to write in a reasonably good language that can express logic in a reasonable fashion. So for example, we want to enable developers to use Cairo or rust on top of bitcoin. And the third point is maybe the most important one is flexibility.
00:04:59.724 - 00:05:43.262, Speaker B: So far bitcoin is being used for very limited number of use cases. And if you want like the more rich world of use cases that Ethereum has, you need more flexibility in what you can do on bitcoin today. Okay, I hope that I convinced you. And now we are moving to the slightly more technical part of how this can be done. Okay, so crash course about l two s. What do we need? What does an l two need from l one? So basically I would claim that it needs four things. It needs state agreement, which means it needs some ability from l one to agree on what is the l two latest state.
00:05:43.262 - 00:06:19.324, Speaker B: So l two state finality. That's the first one. It needs data availability. So it needs to know that the data of the l two is available somewhere for everyone who wants to interact with it or to progress this, it needs the l one to verify the state transition of the l two. So I need to know if I saw a new state, I need to know that it's a valid one. And I also would require a trustless bridge for l one native assets. So in this case I want to be able to move my bitcoin from the bitcoin network to my l two in a trustless fashion.
00:06:19.324 - 00:07:00.534, Speaker B: Next slide. Okay, if you don't know what is the sovereign roll up, it doesn't matter, just ignore it. All I'm saying here is that most of the l two s that you see today on bitcoin, they don't have all those four things together. They maybe have, some of them have one or two, and many of them are relying on a centralized or multisig or anything like that. And I'm going to focus on, mainly on talking about the state because we don't have so much time. But it was very important for me to show that those four things together define the l two on top of bitcoin. Let's move on.
00:07:00.534 - 00:07:43.374, Speaker B: Next slide. Okay, I'm also going to assume for the rest of the talk that it's possible to have star proof to be verified on top of bitcoin. I'm not going to talk about it at all. This is a black box because we're going to treat it as such. Okay, my jokes are, I was doing this presentation on very early morning on a flight, so expect these kind of jokes later. So we are going to assume that we have stark proof verification on top of bitcoin and we are not going to talk much more about this next slide. Okay, maybe you saw it when you were young, but I'm not sure you saw it ever since.
00:07:43.374 - 00:08:36.184, Speaker B: So what is the state of bitcoin? Basically, the bitcoin state is made up of what we call Utxo, which is unspent transaction outputs. In short, in bitcoin, this is a bitcoin transaction. And what you see here is there are some inputs and the nice white squares, they are the outputs of the transaction. And to create a transaction, you need to have inputs and outputs. And generally to have inputs you need to provide some information that only you know. For example, a signature to some locking script, this locker. And if you know this information, you will be able to provide it to the transaction, and you will be able to have inputs, and then you will generate new outputs and the whole thing.
00:08:36.184 - 00:09:29.094, Speaker B: When we say bitcoin state, it's very different from ethereum. We just think of unspent transaction output. So those white squares on the side, which is very weird, if I can get to the next slide, because when you think on Ethereum state, you usually think about smart contracts. And when you think about smart contracts, you, like a normal developer, you have persistent logic of the smart contract, and you have state, and the state is changing with whatever the smart contract is doing. But the logic of the smart contract remains, it stays at the same place. And it's always the same logic in bitcoin. We don't have, like we, we don't have a place where we store code that is persistent in one place and state that is changing according to this code.
00:09:29.094 - 00:10:19.926, Speaker B: We have like this weird unspent transaction output that doesn't work together with accounts. But what we really want to create in this talk is this. We want to create the. Can I get the next slide? We want to create this immutable, persistent logic. Okay, so what can I do with Utxo and what can't I do? Utxo means that you have one time logic and state. You have this transaction, you have these outputs, you spend it, bam, it disappeared, no state anymore. And you can enforce rules on who can spend this Utxo by the knowledge, but you really can't decide for them what they will do with it.
00:10:19.926 - 00:11:04.176, Speaker B: Think about the equivalent that I have in mind. It's a crazy one, but when you go to uniswap and you trade with Uniswap pool, you usually come to the pool and you say, I want to trade a for b. And okay, if you have a, the transaction will succeed, you will get b, but the pool will stay there. In bitcoin, if I take the equivalent, it's like if you create script that even implements some complex logic like a pool, then the equivalent is you call the script of the pool. But then you can do whatever you want with all the money of the pool. So it's not really enabling you to do anything smart, like smart contract in an easy way. It's like you can take the pool and make and turn it into a K mill.
00:11:04.176 - 00:11:35.564, Speaker B: It's not something that you can work with. And the problem is it's what written here, I don't know if you can see it, is that changing the state in bitcoin is based only on knowledge. Anyone who has the knowledge can change the state or their particular state to whatever they want. You can't enforce rules on how they change the state. And this is exactly what we want to change. Next slide. Next slide.
00:11:35.564 - 00:12:18.082, Speaker B: Yeah. Can you skip another one? Okay, so how do we do that? How do we create smart contract on bitcoin? I'm not going to get too deep into how this works. So just a little bit and let's see if I can explain it real quick in a reasonable manner. Remember, I want persistent logic, so I want to be able to control not only on who can spend a transaction, but also on how can they spend it. So here's the suggestion. Let's build something that we call covenants. Covenants works the following way.
00:12:18.082 - 00:12:51.732, Speaker B: This is the locker is the locking script. You want to spend it. Okay. One of the rules that the locker will have is that it will need to receive some information about every box that has a purple arrow pointing at it. The information about this box will need to arrive in the hint. So for example, I would like to know about those two boxes and those two boxes. And once the locker will get those four boxes information, it will enforce whatever logic it has on top of it.
00:12:51.732 - 00:13:36.510, Speaker B: And then we will have the ability to say, okay, output one, we want you to look that way. Output two, we want you to look in a different way. And this gives us the ability to say not just who can spend, but also how can they spend it. Next slide. Okay, so we understand that in order to create what we want, we need the locker, the locking strip to be aware of the transaction. Data. Now, how can we do that? So the idea is that the spender who wants to move the transaction to the next state, it has all the transaction data and it can provide it to the local.
00:13:36.510 - 00:14:25.248, Speaker B: Now the question is, okay, that's great, but how can we know that he provides the right data? What if he says that the right data is a and in fact the right data is b? So there is a trick which because of the time, I won't get to it almost at all. So you will have to believe me. But the nice thing is that we have signatures in bitcoin, and signatures, they're basically signed on the entire transaction data. So in particular, they have some attestation to what is the right data of the transaction. And if we can extract this information, we will basically be able to know that we have the right data of the transaction. Can I get a click? Next slide. Okay, this is some math.
00:14:25.248 - 00:15:00.574, Speaker B: If you don't understand what is behind me, it doesn't matter at all. What important to understand is that the transaction data is some part of the signature. So if I am able to read the parts of the signature, I'm able to verify the transaction data, which give me the ability to enforce it. Next one. Next slide. Okay, I know that this sounds weird, but this almost works. The main issue is that in bitcoin today, we have no ability to do any string or element concatenation.
00:15:00.574 - 00:15:59.454, Speaker B: So as weird as it sounds, we could get a transaction data and verify it's the right transaction data in bitcoin transaction. But the one thing that we don't have is string concatenation. And so we cannot really extract this information. We cannot say, here's transaction data, let me reconstruct the signature, verify it, and compare it to the real signature, because we don't have this concatenation. Okay, so why am I standing here and talking if this doesn't work, why am I showing it to you? Next slide. Because after a long time where bitcoin did not have this primitive of concatenating strings, there is now a proposal on the table, and it's also activated in signet that enables this amazing capability of concatenating two elements on the stack. Next slide.
00:15:59.454 - 00:16:57.364, Speaker B: When we show this was the reaction of one of our lead engineers, Shahr Papini, when he found out about this fact. So basically, it sounds insane, but if we get string or element concatenation, we would be able to do very beautiful things. Okay, next slide. So now I'm going to show you how I take all those ingredients, whether you followed or not and build some sort of smart contracts on bitcoin. So here's the construction. And it doesn't matter if you don't understand exactly how it is done because conceptually I think it is interesting to understand how it looks like. So here is an example of what I claim to be almost a smart contract on bitcoin.
00:16:57.364 - 00:17:41.440, Speaker B: How does it look like? We have this locker or locking script and the locker script? The locking script is basically the logic of the smart contract. Whatever you want to put in the smart contract will be in this locker. Okay? And the first thing that the locker will enforce is that the next transaction that spend it, the first output will be the same locker. So this already gives me persistent logic. Thanks God I don't need to delete my logic every time. Now I know that my smart contract will remain even after the next transaction, which is great. The second output I'm going to use for the state and this is changing.
00:17:41.440 - 00:18:21.224, Speaker B: So I know that I don't want to have the same state every time. What I want is that if I change the state, I want it to be persistent with the logic, right? So the next thing that the locker will enforce is that the relations between SNS tag are following the logic that exists in the locker. And there is also some technical details about the amounts that lives here. They also need to have some enforcement. I'm not going to get into that. We sometimes call it pay to waking or state kaboosh. But in fact this is really in my mind, this is already smart contracts on bitcoin.
00:18:21.224 - 00:18:52.858, Speaker B: The only thing that it doesn't have is that it doesn't have global state. Meaning. In order to call the smart contract, you need to know the smart contract state. So it can only be called sequentially. Okay, next slide. Now I'm going to claim that the previous smart contract was still bad. Why? Because it forces you to operate on the state with the script language of bitcoin, which is shit and we don't want that.
00:18:52.858 - 00:19:53.386, Speaker B: So here's a proposal to do it without ever writing script in your life again. And how this would work. The local script will need to know a start verifier. But if it knows a start verifier, then now I don't require the state to be stored, but in fact I only require some commitment on the state, some state route of America on the state. And the way I will enforce valid state transition will be now with a proof that incorporates all the logic of whatever smart contract I want to have and on chain it will be always the same covenant, always the same logic of covenant, always the same locker. But the only thing that will be different will be the program that the verifiers verify. So basically in this construction, you have a smart contract on bitcoin where you don't need to write script to progress its state.
00:19:53.386 - 00:20:38.636, Speaker B: The state sits off chain somewhere. And you can write the logic of the smart contract in whatever language you want as long as you can prove it. So for example, here you can write smart contract in Cairo on top of bitcoin without touching script, which is a powerful thing if you think about it for 10 seconds. Okay, last slide. This should be bitcoin there. So I'm going to go over one example which will be basically how an l two will look like. And I don't have time for questions, so come to me after if you want, and we can talk about it some more.
00:20:38.636 - 00:21:28.418, Speaker B: But basically it will look the following way. This is an example of how you progress a state of an l two transaction on bitcoin. It looks the following. You have the TVL, it sits always where the locker is, and the locker protects the TVL of the l two. So it can have a lot of bitcoins, but it's protected by the locker. And every time you want to progress the state, you need to show a valid proof that says, okay, my state now moved from, in this example, state t minus one to state t, or from state t to state t plus one and the state route change according to the rules of my l two. And in addition, if you want to, and you want to enable bridging, you can include deposits and withdrawals.
00:21:28.418 - 00:22:00.142, Speaker B: And the deposits and withdrawals will also need to follow the rules inside the l two. So inside the proof. So basically we will ask the locker to enforce both the amounts that the TVL nobody stole it except withdrawals that were allowed by the l two and enforce that the state transition was valid, meaning the proof was valid. And that's it. Now you saw that we have no more slides. You don't need to transfer anymore. Now you saw how conceptually here is a proposal to have an actual l two on bitcoin.
00:22:00.142 - 00:22:06.234, Speaker B: If you have just this small tiny thing of string concatenation. Thank you.
00:22:13.254 - 00:22:21.114, Speaker A: Thank you so much. Okay, we will be back as per usual in one to two minutes with the next talk. So stay tuned. It.
