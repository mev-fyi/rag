00:00:06.120 - 00:00:39.384, Speaker A: Thank you. Hello everyone, I'm Gil. I am a developer in the Cairo compiler team. If you don't know what Cairo is, don't worry, you'll know in a few seconds. So what is Cairo? I'm going to talk about today, about why we're doing Cairo. But I'll start a bit with what is Cairo? Cairo is our programming language to work in stockware in Starknet. To prove your computations on stagnet.
00:00:39.384 - 00:01:11.376, Speaker A: Let me start by telling a little bit about Cairo. As I said, it's a programming language. It's a high level modern language. We aspire to make Cairo as easy for you to use as possible. It's the sibling of Cairo Zero. If you had the pleasure to use Cairo zero, then you know that it was sketchy, I think is a good word language. It was not good.
00:01:11.376 - 00:01:37.428, Speaker A: Yeah, it was not good. So we dropped everything, we started from scratch and we built Cairo one. Cairo one is our new language to use in stocknet. It's a modern language, it's easy. And that's why I want to show you today. It's also open source, you can check us out. And we are always adding new features and new improvements.
00:01:37.428 - 00:02:18.210, Speaker A: So why do we need Cairo? Let me tell you a bit about Stagnet. Stagnet is our l two validity roll up over Ethereum. We scale the operations of Ethereum by using proofs. We are generating proofs of what we are doing on Stacknet. And then later down the chain, if you've seen Kineret talk about the proofer later down the chain. We are verifying it on Ethereum. But the question is, what can we prove? What do we prove? So we prove chasm code.
00:02:18.210 - 00:02:51.384, Speaker A: What is chasm code? Chasm is Cairo assembly. In our company, we developed this really unique and compact assembly language. That we can prove anything that is written in Kazem. But I don't want you to write in an assembly language. Right. So, on top of chasm, we want to achieve two things. We want to achieve a language that is safe and ergonomic.
00:02:51.384 - 00:03:24.404, Speaker A: I'll start with the safe part. How do we make a language safe? So we introduced another layer above Chasm, which we call Sierra, which is safe, intermediate representation. And Sierra is like really. It's more similar to high level languages, but it's not. And about Sierra, we can prove a lot of stuff. We can prove that every execution path can be terminated. Given that you have enough gas.
00:03:24.404 - 00:04:00.820, Speaker A: We can prove a lot of things about Sierra. And that is giving us the safety that we want. But I don't want to talk about Sierra, just know that it is what makes us safe. Above Sierra we have Cairo. Cairo is what most of you developers will want you to interact with. What is Cairo? Cairo is our ergonomic new language and that's it. This is our stack that we are working on today from Cairo to Sierra to Kazem to proving on Starknet.
00:04:00.820 - 00:04:40.862, Speaker A: And what I want you to see today is that Cairo is not that scary. Cairo is nice. If you develop in rust, it is very much rust like, so you should feel at home and let's see how Cairo is looking. So I'm going to show you a lot and lot and you'll get tired of it. Implementations of the Fibonacci function let's start with the first one. In here we have a really regular implementation of fibonacci function. Just if we are at the end, return a.
00:04:40.862 - 00:05:31.964, Speaker A: Otherwise do it recursively. Why do I show you this? You can see that we have this weird type we call felt 252. Well, felt 252 is shortcut for field element with roughly 252 bits. The prover technology underneath Cairo use elements of finite fields, in this case of size, roughly 252 bits. We don't want you as a developer to be exposed a lot to the underlying technology of proving when you are writing code. But you should be familiar with the Feldfig 252. Why? Because this is the most efficient and native type that we have.
00:05:31.964 - 00:06:10.054, Speaker A: It is essentially a type that if you add too much to it, you'll get wrapped around to zero. So we have default 252, but rather than this, it's really similar to any other language. If you don't want to use if you can also use match, which is similar to switch case. If you know from C or JavaScript, I think we can use match. We're matching on a and doing something accordingly. So if we are at zero, do a. Otherwise if we are at one, do b, do a plus b, otherwise do recursive call.
00:06:10.054 - 00:06:51.680, Speaker A: That's nice, but I am introducing match now to talk more about it later. It will be very much to you. It will be put in match to you later. But if you don't want to use fail 252, you don't know what this nonsense is about. So as I said before, we want to make Cairo as easy to use as it gets. You have all the types that you used to from last. If we use last notation, but you have u size int of 64 bits and this is an implementation using usize.
00:06:51.680 - 00:07:23.360, Speaker A: Now, if you use this type, you will need to pay a little bit of overhead for the verification that it is indeed fit in U 64. But it's a trade off that you'll need to make as a developer. It doesn't cost that much. On top of it, we have many other types. I don't think that I'll talk about that much. So this is the basics of Cairo. We have nice language.
00:07:23.360 - 00:07:55.660, Speaker A: It should look like any regular language. We don't want you as a developer to feel that, oh, we are working in order to prove something. We want you to just write your regular code. We'll do everything in order to prove it and give you the security that you want. Let's look a little bit more deeper into Cairo. Again, if you worked with Cairo Zero, you know that there is a painful point that there were no loops in Cairo. Zero.
00:07:55.660 - 00:08:27.688, Speaker A: I told you it was sketchy. So now in Cairo we have while loops. It should look like any other while loop that you've seen. Nothing special before the while loop, like one year ago we introduced the loop loop, which was even simpler. It just while true, but now we have while loop. Soon we'll have for loops. We needed something for the for loops, but in the next version we'll have for loops as well.
00:08:27.688 - 00:09:01.946, Speaker A: So again, Cairo, not that scary. Arrays, we have a few native data structures. One of them is array, another is a dict type. It behaves a little bit different than the arrays, you know, but you can do many, many things with it. Again, Fibonacci. Now you can put everything in the arrays and it all works as you can see. If you know rust, this is rust code, it will work in rust.
00:09:01.946 - 00:09:39.888, Speaker A: You can just plug and play it. But as you can see, it's a regular language, nothing special. Let's continue. Okay, now we're getting into a bit of chiropractic stuff. So we have an array we can return from our Fibonacci function. We don't have to return only the array or only the result. We can return the tuples of the array.
00:09:39.888 - 00:10:38.620, Speaker A: You can see that we can unpack the tuple in here and we get the results of Fibonacci ten using the array that we defined, and we just adding into the array. So that's it about arrays. I'll go now into a few deeper things in Cairo, and then I'll tell you about how Cairo is used in startnet. So in this part I'm going to not going into very much details because it's a little bit deeper. So if you know rust, in rust you have traits. Trait is a way to define an interface, because up until now I only talked about functional languages. Traits is a way to define an interface that you can implement for a type or not for a type.
00:10:38.620 - 00:11:31.284, Speaker A: So in here we have a trait that we call combine. And our new Fibonacci function doesn't just add a and b, it does combine a and b. How does it know how to combine which combine to use? I only have a trait we give as a generic parameter. We give an implementation of combine. We call it tcombine. You don't have to give this name, but we give an implementation of combine that the fib function will use. If we want to be even fancier, we can change the trait of combine to use the self keyword, and then we can just do a combine b and we are getting methods for types.
00:11:31.284 - 00:12:29.324, Speaker A: How can we implement a trait? Well, it's simple. We just add an impel function, impel with some name, combine U 64 of the trait, combined with U 64 as a generic parameter, and we do self plus other. Now you ask yourself, I need to define which impel I want to use everywhere. No, create an instance of fib that we infer. Use the type U 64. We will infer also that we need to use the combine U 64. So you only need to state that your Fibonacci function needs an impel of a combine of t, and we'll find for you the correct implementation.
00:12:29.324 - 00:13:00.424, Speaker A: The inference mechanism of Cairo is really strong. We try to make it even stronger. The next version will have some improvements in this field, but it is already really strong. If you know rust, by the way, this is the place we derived. We strayed as far as we got from rust. In rust, impels are not named, but we choose to do it. We are thinking that this is better.
00:13:00.424 - 00:13:24.932, Speaker A: Another thing that we have is user defined types. What do we mean by that? We have structures. You can define structures as in any other programming language. That's nice, drain. So we can define structures. It is really self explanatory for developers. And also we have attributes.
00:13:24.932 - 00:14:04.754, Speaker A: Attributes are decorators for any kind of item or statement. So in this case we are saying, oh, destruct fipresult. I want it to derive implementation implementations to the copy and drop traits. I want it to be copyable and I want it to be droppable. By droppable I mean I can just forget about it. And then we can make another fib implementation. So that's it about struct and another user defined type, which is not that common in any language, is an enum.
00:14:04.754 - 00:15:02.354, Speaker A: What is an enum. It's a type that allows you as a developer to have one of a few possibilities of types of variants, we call them. So fib operation can be either add or add const. And in this case it have the added, like the echo wasn't enough, the added data of U 64 type and it can be mool. And remember that at the beginning I told you that match can be used for another thing, where it can be used to choose which variant we have and act accordingly in your code. So you have an enumerator, you choose which, you do a thing according to the variant, and that's it. That's like a crash course of Cairo.
00:15:02.354 - 00:16:07.402, Speaker A: It's like the most basic things you need to know about Cairo. But up until now it was like any other functional programming language. I haven't said anything about Stocknet or about smart contracts. It's dripping on the tv. Yeah, okay, so I haven't told anything about stagnet or smart contract, but what can you do with what I've shown you till now? You can write any code you want, and you can prove that you ran it and later verify using our Starknet technology. So let's see how you can write smart contracts with it. This is maybe the most basic contract you can write.
00:16:07.402 - 00:16:43.014, Speaker A: In Cairo we have. At the top we have an interface that we define for the contract. We have setbalance and getbalance, nothing fancy. Here we have a storage that we define for the contract. This means that this contract can access a balance field in the storage, and then we implement the interface that we defined above. There is nothing fancy. You do serve balance, write new balance.
00:16:43.014 - 00:17:33.524, Speaker A: If you developed a little bit in your life, it should look familiar for you. Okay, the same with read, you can do whatever you want, all the attributes that we add. It's because the smart contracts are like an additional layer on top of our language. We don't want it to be a part that is embedded in the language itself. But the compiler knows all about smart contracts. What else can you do? You can add events to the smart contract and just then emit the event. Event is an enum of events and you can emit any variant of events.
00:17:33.524 - 00:18:49.264, Speaker A: And I won't talk much about this, but if you want to have some shared, shared cases between contracts, then you can add components. What is a component? A component is like a module, like an helper function for contract. Here we define the component of upgradeable. I won't get into it much. It implements the function upgrade, and then I just can say I want to embed this component in my contract. How do I do it? I just say on top, oh, I have this component, this is the path to the component, this is the storage of the component, this is the event and boom, you have the component in your contract, can be like upgradable, it can be an ERC 20 component and you just, oh, I want to use the ERC implementation of this library. You add it as a component and you have ERC 20 capabilities in your contact so that it's about components.
00:18:49.264 - 00:19:24.012, Speaker A: I'll skip this, you can call, obviously call all other contracts and that's it. What's next? We are adding associated types. Oh that's nice, that's quiet. We are adding associated types. If you still know what it means. I won't talk about it much, but it opened the door for us as the core developers to add iterators and then for loops, better storage access. All of these are derived from associated types.
00:19:24.012 - 00:20:17.810, Speaker A: We had a default implementation to traits and we had some tools to reduce cost. It's a little bit obscure because we added like this ability to write low level code in Cairo. Not really, but it is good enough approximation, a low level code that will be very much efficient and you can use libraries that will implement it in order to get cheaper transactions. That's what we have in line for the next version that is just around the corner and I think that that's it. Thank you very much. I hope that you will. Now I have heard in the last few days that many people are saying, oh, I know about Stagnet, but I need to learn this new language, Cairo.
00:20:17.810 - 00:20:24.658, Speaker A: I hope that now we'll see that it's not as scary as it sounds. Thank you very much.
00:20:24.826 - 00:20:45.764, Speaker B: Thank you so much gil, thank you and well done for braving the elements. And thank you also in the audience for braving the elements. I know that a couple of you were hit by the water from above. Does anyone have any questions before you disappear please? Yes, young gentleman, there you'll have your microphone a second. Thank you.
00:20:48.144 - 00:21:36.574, Speaker A: Does Cairo compiler do compile time checks and optimizations? Yes, of course, we are doing a lot of compile type checks. It is a type language, so we must infer all the types. You don't need to annotate the types, but we infer all the types from the signatures of the functions and so on. And we have this middle intermediate representation that I haven't mentioned. And in this phase we are doing a lot of optimizations, inlining, graph compacting and many others. You can check it out in our repo. You can ask me later if you want.
00:21:36.574 - 00:21:55.054, Speaker A: But yeah, we are doing a lot of optimizations. The previous version that we released, we added a lot of these optimizations and we cut the costs of transfers of fiercely transfers, for example, by almost a factor of two.
00:21:56.434 - 00:22:00.894, Speaker B: Thank you very much for a great question and a great answer. One more question here, please.
00:22:03.294 - 00:22:50.564, Speaker A: Would you consider Cairo to be an object oriented program language? What? Oriented? Like object oriented? That's a question that is raised a lot about trust because the traits are not bound to a type. There is not an interface of a type. You can implement a trait for a lot of a lot, many kinds of objects, so you can make it look like an object oriented. But I think it's a philosophical question that the rust community is struggling to answer. So I can't really answer it. The Rust Arcore development says that rust is not. So I won't say Cairo is object oriented because it is really similar to rust.
00:22:50.564 - 00:22:56.214, Speaker A: It is interface and trait oriented. I'll say. Thank you.
00:22:56.994 - 00:23:32.454, Speaker B: Thank you very much. We have one more question if anyone would like to ask. Ask now or forever hold your peace. Otherwise, I'll have one. Okay, fine, I'll have one. Gil, when I was talking to your fantastic colleagues at the store yesterday, they were saying that one of the things that you're aiming for is also mass adoption and giving developers from outside a chance to kind of get into blockchain development. What do you think is in store for you for the next year? Do you think that there'll be a much like higher intake from people that have just until now only been familiar with rust?
00:23:32.574 - 00:23:56.444, Speaker A: Yeah, I hope that it can be like the gateway to the web3 world, because solidity, it's not really comparable. Maybe JavaScript, but I'm not sure it is comparable to any main used in the web two industry language and for a rough developer, using Kairos should be like.
