00:00:00.440 - 00:00:09.726, Speaker A: Hello. Ah, there you go. Thanks, everyone, for coming. Yeah, there's a panel about ZK and the future potential, so let me get my guests, if they'll come through now.
00:00:09.910 - 00:00:14.914, Speaker B: Hello. Yeah.
00:00:17.814 - 00:00:41.246, Speaker A: So please come sit down, and then we'll give you a chance to introduce yourselves. So to start with, I think it'd be useful if you could just give your names, the company you're working for, and your role there before we get started. That way I won't get your names wrong. So. Yeah, absolutely, go ahead.
00:00:41.270 - 00:00:52.074, Speaker B: Hi, everyone. First, very happy to be here today with lots of familiar faces. So I'm Aviu. I'm head of product at Starcourt.
00:00:52.894 - 00:01:01.124, Speaker C: Hello, everyone. My name is Togrul. I do research at scroll. You can probably find mishit posting on Twitter a lot.
00:01:01.624 - 00:01:11.656, Speaker D: Hello. But it's fun to read you. My name is Alex. I'm co founder of Matterlabs, which is the company behind Zksync, the creator of Zksync.
00:01:11.840 - 00:01:21.576, Speaker E: Hello, I'm Danny Holland. If you were here a few minutes ago, I'm with Vega protocol. I'm a smart contract developer, and I just gave a talk about five minutes ago about ZK rollups. So.
00:01:21.680 - 00:01:26.144, Speaker A: Yeah, hi, and thank you for coming in at the last moment to follow the panel.
00:01:26.184 - 00:01:26.752, Speaker E: Thanks for having me.
00:01:26.768 - 00:01:28.032, Speaker A: I hope your voice last night.
00:01:28.128 - 00:01:28.898, Speaker E: Yeah, it'll be fine.
00:01:28.976 - 00:01:44.454, Speaker A: Okay, cool. All right, so our topic today is around the future of zero knowledge proofs. So maybe it would be useful if you would, can you give a quick idea of your roadmap from your company for the next few months, year, or that kind of thing where you're heading?
00:01:44.574 - 00:02:52.920, Speaker B: Yeah, I think in this context, I'll say a couple of words. So we are one of the companies in the ecosystem developing Starknet. Starknet right now is on Mainnet. It's still on Alpha mode, so it has all kinds of training wheels. And the next few versions coming this year will be mainly focused around significantly improving the TPS, then reducing transaction cost by enabling different data availability modes. So not just layer one data availability, but also l two consensus, and then later on other layers, and then following that, towards the end of the year, we'll also work on adding fee market to improve user experience and enable all kind of levels of service. Maybe we can mention it later in the panel, but I also would like to say that there are a bunch of efforts on top of Starknet, around Starknet to create the right frameworks for privacy, the right framework for gaming around that is also touching privacy in another way.
00:02:52.920 - 00:02:54.600, Speaker B: So I hope we get there later.
00:02:54.752 - 00:02:55.688, Speaker A: Yeah, definitely.
00:02:55.816 - 00:03:51.186, Speaker C: I feel like for us, the next few months are going to be mostly about launching the main net. We're almost there. There are still a few things that need to be added and things that need to be audited, but it should be coming in the next few months. And once we're on the main net, the next plan going forward is to start working on removing the training wheels. So, because when we're going to launch, a lot of the internal operations are going to be centralized like a sequencer, prover, etcetera, etcetera. And there's a lot of research that we've been doing in the background for the last year, even more on how to decentralize those components. Because while the user could use and interact with a protocol the same as with Zksync, Stockinette and everybody else, there are still risks involved that will not eventually be there.
00:03:51.186 - 00:04:03.174, Speaker C: And the goal is to make sure that we minimize those risks as fast as possible and to make sure that the system is trust minimized and secured to use without a lot of additional assumptions.
00:04:05.954 - 00:05:00.374, Speaker D: At Zikasync, we are also working on a number of things in parallel, so we don't have a sequential roadmap because we have many teams working on different aspects of what the guys were talking about just now. The scalability aspect, the decentralization of the sequencer, decentralization of the prover. The scalability includes the cost factor and the throughput factor. There is the ultimate vision of what we all want to accomplish with rollups. We want to turn Ethereum into something that can scale limitlessly. It doesn't have any bounds on scalability, and this can only be solved in some hybrid data availability model with using volition, using ZK porter in some decentralized way. We don't want it to be run by centralized operators.
00:05:00.374 - 00:05:38.266, Speaker D: This is final north star that we're achieving, and it also involves probably having multiple chains, not just one chain, not one roll up, that can handle infinite load, because that's just not feasible. You cannot run all of the Internet on a single server or in a single data center. There will be an Internet of these chains and they must be connected in some seamless way. So these are the priorities, and we prefer to talk about them as we ship. And we are about to ship something really interesting in the coming weeks. So I encourage you to follow us on zksync on Twitter and you will see some cool stuff.
00:05:38.330 - 00:05:39.134, Speaker B: Sounds good.
00:05:39.634 - 00:06:25.574, Speaker E: So I actually got into ZK rollups specifically to solve the gas problem for our multisig bridge. So the biggest challenge at the moment. Sorry, the roadmap at the moment is there's not really one because we can't find auditors for circumflex. Yeah, we can't find. And even if we could, I mean, all the tech's too new, all the crypto's too new. How do you guarantee it's going to be safe, especially when working with something like Ethereum? So, I mean, all of you are working on your own full ecosystems, but our usage of zero knowledge proofs and whatnot are in interaction with Ethereum. So it's weird because you cross security boundaries and whatnot.
00:06:25.574 - 00:06:26.382, Speaker E: So, yeah.
00:06:26.518 - 00:06:38.964, Speaker A: Cool. I'll come back to security a little bit later on. It's a very pertinent topic, I think. Okay, so some very exciting things ahead of us. That's good to hear, to maybe take something back slightly.
00:06:39.384 - 00:06:39.976, Speaker E: Thank you.
00:06:40.040 - 00:06:47.364, Speaker A: Is there one breakthrough or in the technology over the last year that has really impressed you, has really excited you?
00:06:48.984 - 00:06:50.560, Speaker B: You want to start from the other side?
00:06:50.672 - 00:06:51.644, Speaker A: Please, anyone?
00:06:56.664 - 00:07:39.244, Speaker D: I can start for maybe not last year necessarily, but on the continuum of the last two years, I think zero knowledge proofs in general have achieved the breakthrough in terms of going from, basically that was the period of going from zero to one. Maybe it was not zero, it was zero, zero something. But we definitely are at one now. Zero knowledge proofs are productized. We are at a point where the transactions are very cheap, the proof generation is very cheap, very affordable. You can scale it, and you can also do proofs for individual snarks, individual starks for privacy. From the user perspective, it can generate proofs in the browser or on a mobile phone.
00:07:39.244 - 00:08:02.468, Speaker D: This is a moment where now we go from one to many, where we actually take that and just roll it out into production. So there will be more waves of innovation in the prover technology, in the protocols themselves. But we're past the point where we have everything we need now to actually build stuff. Everything is going to go ZK. That is absolutely clear.
00:08:02.556 - 00:08:03.624, Speaker A: That's a good quote.
00:08:04.204 - 00:08:04.984, Speaker B: Sorry.
00:08:06.164 - 00:08:44.694, Speaker C: If we're talking specifically about ZK in the past year or so, I would say folding schemes have been quite a breakthrough and also another path to scale going forward. And in terms of crypto in general, there are too many things to mention. A lot of things on the incentive side, protocol side, on the consensus side. So, for example, hot stuff two was published a few months ago. There are a lot of things happen. And the good thing about this space, there are still a lot of things that haven't been discovered yet and are yet to be discovered. So there are even more things to come going forward.
00:08:44.694 - 00:08:48.074, Speaker C: So that's why I'm excited about this field in general.
00:08:49.974 - 00:09:37.204, Speaker B: Yeah. On the proving front, I guess, like in the last year, we saw so many teams doing so many breakthrough on so many different directions that I can mention. Like we show we saw a huge improvement on working with smaller fields. There are some, all kinds of thoughts on combining different fields. That's another topic that I think is now gaining some attention. On the use cases front, I think one thing that I would mention is the use of storage proofs that we haven't seen a year ago, and now it seems that it's going to be leaving its effect on rollups and Zika rollups in particular.
00:09:37.744 - 00:09:52.224, Speaker A: Okay, so let's continue on that area. Maybe we're seeing some things like with axiom, the coprocessor idea, and the fact that we can interact then with data on Ethereum. How do you see that? See that moving ahead?
00:09:59.444 - 00:10:00.268, Speaker E: No, please.
00:10:00.396 - 00:10:49.116, Speaker C: So I feel like the idea of storage proofs is great because it allows us to create cross chain bridges that don't actually pass the messages. As long as you can read the message from the message that was stored on the other chain, that's more than enough for you to have a trust minimizer way to interact between chains. And that can potentially have a massive effect on the UX and the way users bridge between chains, et cetera. Because especially going forward with Ethereum, we're going to have a lot of chains trying to interact with one another, et cetera. And a lot of effort is going to go into optimizing that. Cross chain communication and storage proofs are a good way to do it.
00:10:49.300 - 00:11:06.864, Speaker A: So Vitalik had a recent blog where he's talking about the problems of having multiple addresses across l two s and different chains. And then you were talking about having many chains. How do we solve this problem of interoperability? And having something that is useful is a good user experience.
00:11:07.244 - 00:12:13.124, Speaker D: I think this problem is a little more fundamental. So Vitalik mentioned three problems in his last post about privacy, scalability, essentially cost, and the usability with smart contracts. I would add the fourth one, which is going to be the segmentation or fragmentation of liquidity, fragmentation of the users, which is not solvable. You won't be able to solve it alone with standards, unfortunately. You could introduce standards, we could all agree, we could just get all the roll ups together and say, okay, let's have a unified URI for addresses on different roll ups. There are already proposals for this, like ETH, like with the prefix ETH address or zk sync address, or like scroll. You can add more metadata, you can add more parameters, and eventually it's just one string, which you copy, paste, or encode in QR code, which you can display to someone.
00:12:13.124 - 00:13:24.558, Speaker D: The problem is that even with storage proofs, even with cross chain like message passing, which theoretically can, or even practically can be done, at least between ZK chains, the optimistic chains are out of the equation. But in ZK chains, the latency will eventually fall to just a few seconds. So you will be able to finalize your chain, your block on Ethereum, and then the other roll up can read the state of this block and can access the messages that are committed in the block. Problem is, you cannot still breach assets natively. You would still have to pass it all over Ethereum. If we're talking about nfts, you actually have to pass the individual NFT all the way through from one chain to another chain, because you cannot blindly trust the implementation of another roll up for reasons out of, for non technological reasons, because the other roll up can be upgraded by the team or by Security Council, by its governance, in a malicious way, and then the risks of this upgrade must be contained to that roll up. It's a very fundamental security isolation assumption.
00:13:24.558 - 00:14:23.916, Speaker D: So, like, and if the bridging goes all the way up through Ethereum, you can imagine it's like we have a lot of cities, but they are all connected with a single, very narrow bridge that everyone has to pass through, which doesn't matter how many highways you have inside the cities, if the road that connects them is a single pedestrian bridge, you can't carry much overload, I'm afraid. We will see fragmentation, where there will be ecosystems merging inside the ecosystem, there will be seamless bridging, and will be many chains connected within it. Between those ecosystems, it's going to be hard. It's going to be more like countries. Some countries have really good infrastructure, have many cities, many railroads, many highways, etcetera. But some countries are less developed, but still good. But between the countries, there are checkpoints and customs, and you have to pay for moving things across the border.
00:14:23.916 - 00:14:28.986, Speaker D: So this is kind of the scenario to which we're coming. I don't see how we can overcome that.
00:14:29.180 - 00:14:30.390, Speaker A: Do you have a solution to this?
00:14:30.502 - 00:14:48.234, Speaker E: I do. I think it'll kind of solve itself because there will be less roll ups, there will be fewer roll ups. A lot of the projects will go away, they will die, they will fail, and those that remain, the builders will come and they will find solutions to this. So that's honestly going to be a big one, I think, to solve interoperability.
00:14:51.014 - 00:15:17.204, Speaker B: Yeah. I'm just optimistic that maybe, maybe not for all assets, but for messages, and maybe messages will include other complex, interesting use cases, not just votes. You still will have this way to bridge, not going through Ethereum directly. So I agree that for some cases it's going to be more complex, but I think that we will, in between the roll ups, we'll try to overcome at least some of the challenges directly.
00:15:17.704 - 00:15:20.604, Speaker A: Okay, so that's all.
00:15:21.824 - 00:16:02.574, Speaker C: Bridging is probably the most complex problem that we have in scaling. So I don't want to say that it's an impossible feed, but it's definitely a difficult problem to solve. But I'm just hopeful that at some point someone's going to come up with a way to do it. Because if you look at what the bridges were like five years ago and what we have now, that the difference in trust, assumptions and security is drastic. And so I don't see a reason why we should stop here. And there will be nothing else discovered and nothing else that helps us make it more seamless in the future.
00:16:04.714 - 00:16:28.434, Speaker A: All right, I want to move away a little bit from scalability now and move on to other aspects, such as privacy. But also this conference, if you've been to them before, they have quite an unusual manifesto, perhaps compared to other conferences. They talk a lot about social good. What, as people in the CK world, what can we do to further all of that?
00:16:30.654 - 00:16:55.644, Speaker E: Build community, share the knowledge you guys have found. Actually, I said that in my talk a little while ago. Be involved, ask questions on, you know, stack overflow and whatnot. Just, that's the way we're going to get there. That's, we got to find that weird basement nerd who's like, oh no, no, this is how we solve this. And he has to get his voice out and it has to be there as well.
00:16:56.064 - 00:16:57.496, Speaker A: Alex, do you have that?
00:16:57.680 - 00:17:30.669, Speaker D: I agree. This is why I think we have some pretty high bar in Ethereum on the way. We should interact with the way the projects can build stuff like, you have to be open source completely. Yeah, fully, permissionlessly. Open sourceync is a license under MIT Apache. And I would even scratch that if we didn't have to carry over the dependencies. You have to be completely transparent about things like the protocol specification, protocol design, and then you have to give things over to the community.
00:17:30.669 - 00:18:12.246, Speaker D: And the ultimate owner of the protocol must be the community. So things like decentralizing the sequencer, decentralizing the proofs is non negotiable of. It's not a question of whether, oh, our strategy is to build it or not to build that. It just won't take off. It's the fundamental core values of crypto that we represent which go deeply in the roots of this original cyberpunk movement, which the party Nepalis, this place has played a big role in that. It was a meeting point for a lot of cryptopunks in the past.
00:18:12.350 - 00:18:17.994, Speaker A: I know, scroll, I mean, this is a very important thing for you, isn't it? The mindset of the community and being community led.
00:18:18.574 - 00:19:19.580, Speaker C: I mean, we started essentially as a collaboration, so the scroll was born as a collaboration between us and Ethereum foundation. So it's in our DNA and our roots to be open source and be friendly to the community, make sure that people should be able to contribute and should be able to get in touch with us, understand certain things that are, for example, are not well documented, et cetera. So we almost, we always welcome people to come and speak to us. And I feel like that's important and it's central to Ethereum's values. Ethereum was built on this value of collaboration. Like, even if you look at the number of founders of Ethereum, Ethereum had like 30, 40 founders and, like, it still goes on to this day, you can't just say that, oh, yeah, Ethereum foundation is responsible for everything or somebody else. There are a lot of different teams working and interacting with each other and collaborating with each other, even between us.
00:19:19.580 - 00:19:52.166, Speaker C: Like, we spend time talking to Startnet to ZK, sync to optimism, trying to solve different problems together, trying to propose different standards and stuff like that. So even if from the outside it might look like we all just hate each other and we're just trying to completely dominate and make sure that nobody else succeeds. It's not actually like that. We have quite a lot of conversations and discuss how we can work together to help Ethereum grow and become a better protocol and a community as a whole.
00:19:52.350 - 00:19:54.726, Speaker A: And I will start by. You have a very strong community.
00:19:54.870 - 00:20:54.920, Speaker B: Yeah, I wanted to say something around that. I think that decentralization, sure, there is the part where you want to decentralize the sequencer and the prover, and there is the part where you want the core infrastructure to be open source. But I think that one crucial thing that we are trying to achieve with Starknet is that you don't want, you can't have the project fully dependent or even largely dependent in one or two or very small set of companies. So one thing that is happening I think in front of our eyes is that some companies are taking larger and larger shares of the work on some infrastructure. Part I can give as an example in Starknet the coming version, zero, one, two, there is going to be a huge improvement in TPS. And a large part of this work was done by a different organization, not stackware but lambda class. And we see those examples also with zkvms being built on top of Starknet.
00:20:54.920 - 00:21:14.564, Speaker B: So Kakarot is an example infrastructure of the prover. So there are multiple teams building a prover that is compatible with Starknet. And this is all done outside. And I think that it's a huge step for a project when some significant shares in the core work are done by different companies.
00:21:16.184 - 00:21:26.624, Speaker E: To comment on that, I would say, remember when parity and Geth both were coming out? Having both parallel tracks was very useful for the community as a whole. So absolutely, I agree with that.
00:21:27.044 - 00:21:44.284, Speaker A: Can I pick on a point? I think Alex said, but also maybe you about standards in ZK, and I know there's Zkproofs dog who are trying to establish standards, but do we have a good idea of what those standards are yet? Is it still too early? What would you like to see then?
00:21:44.324 - 00:21:47.188, Speaker B: Protocols 20 standards is going to be.
00:21:47.316 - 00:22:15.000, Speaker C: I'll give you an example. For example, we were talking to Starkware and Polygon, and we were trying to have Ethereum make an EIP that implements Poseidon precompile to. And we couldn't agree on a specific standard of Poseidon that would work for all of us because there are so many different configuration, et cetera, that it would be difficult. One of us would have to change something.
00:22:15.152 - 00:22:38.470, Speaker B: Yeah, just to work more on this example. The challenge is not that we don't want to collaborate on how exactly will Poseidon be implemented, but at this point we work with different technologies that require some different changes. And it's not as simple as it might sound. There is a common name, but the implementation can be pretty different.
00:22:38.632 - 00:22:55.682, Speaker D: So I think we're in this phase of exploration where we just experiment and it's good, and then eventually some technologies will crystallize and stabilize over time. And then we will say like, okay, this has been time tested, we can now all agree on putting this up, root into Ethereum and making a pre.
00:22:55.698 - 00:23:10.762, Speaker E: Compile, for example, I mean, we don't even know what hash functions and signing schemes and whatnot will even like be solid in five or ten years. So like everyone's implementing their own, and we don't know which one's going to be the one that actually stands the test of time like Shaw has and whatnot.
00:23:10.898 - 00:23:13.338, Speaker D: We likely know it's going to be not what we're using today.
00:23:13.426 - 00:23:14.362, Speaker E: Yeah, probably.
00:23:14.538 - 00:23:38.424, Speaker B: I think if one thing is open in this discussion is that we have some support from Ethereum when it comes to working on those primitives, because sometimes we are coming and asking something, and it requires a lot of flexibility for this to fit with all other networks at the same time. So there is complexity involved. I admit that. Yeah.
00:23:39.164 - 00:24:09.254, Speaker A: Okay. So I do courses for developers in this area, and there are things that they ask me, I present about, I think, all of your products, and I teach on those, but a lot of the developers say to me, which one should we use? Why? What language should we learn? And it's become easier a little bit, because rust is having such an influence now in this space with Cara one now it's become a lot easier. What should I say to them? What's your advice, sircom?
00:24:11.234 - 00:24:14.842, Speaker C: You're just trying to get people to learn it so someone can audit it for you?
00:24:14.978 - 00:24:15.562, Speaker E: Exactly.
00:24:15.618 - 00:24:15.874, Speaker B: Yeah.
00:24:15.914 - 00:24:17.654, Speaker E: See, someone was paying attention.
00:24:20.394 - 00:25:30.624, Speaker D: I think the future is, unfortunately for zircon, that we will be very flexible in terms of supportive languages. In the very short term, we will be able to support basically everything from obviously solidity, which is already the case, to rust, to anything else that people used on existence. So Zksync for example, is based, our compiler is LLVM based, so we can integrate any language which hasn't used things like garbage collector, but has LLVM front end and we could just plug it in and it will possible to prove execution trace of things like risk and other virtual machines. So I don't think it makes sense to learn any specific esoteric language today, because even privacy can be implemented with like private smart contracts. They will be implementable in solidity and in rust. So like why do again, those are very rich ecosystems where there are a lot of tooling, things get improved, and you want to work on something that has future as a developer.
00:25:31.084 - 00:25:33.876, Speaker E: I don't know, man, the solidity thing, that's a lot of gas.
00:25:34.060 - 00:26:32.910, Speaker D: No, no, no. In the context of, I'm talking about the proofs, you would be able to make a proof of something. You will just describe some private function in solidity. Think of it like you describe a smart contract and some of the functions you mark them private, and they don't become just private from like you cannot call them from outside, they're not public, but they actually private or the node functions and variables are private, right? So they are part of the state, but no one can see them except for the owner of this contract who can then make a state transition by calling some function which will be not called on blockchain, but they will generate the proof locally, they will only submit the proof and there will be like basically one function of the smart contract, like accept the proof and make a proper transition. So developers will not need to bother about correctness of the proofs or like of details of implementation of zero knowledge proofs, which is great.
00:26:33.062 - 00:26:33.758, Speaker C: That'd be cool.
00:26:33.806 - 00:26:34.754, Speaker E: That sounds cool.
00:26:35.054 - 00:27:12.570, Speaker B: I want to say something about it that maybe like in some ways it's on similar lines but with a slightly different conclusion. So we have this framework being built on top of Stacknet that is called dojo, and this is a framework for gaming. And that in particular also means that you need a client side for the users. And well, it's not a server side but a blockchain side. And today the way it works is that, yeah, you have many developers using circum on one hand and maybe they understand a bit what is happening. And by the way, it's not just for gaming. And then you have on the other side the solidity smart contract.
00:27:12.570 - 00:28:36.424, Speaker B: So they already have to handle two different tools that are not necessarily looking similar. And I think the reason many of them are CEO's in Sircom is because offers this very convenient and efficient platform that you can use in your browser. And I think what we are trying to do, and I believe that others here as well, is to create an intermediate level. And in our case in starting it is Cairo that is both very efficient and at the same time is easy to use, easy to learn. And I think that Cairo one gets to the point where it's more like rust based, it's pretty efficient, it's easy to use. And yes, I do think that there will be compilations from other languages to Cairo that won't necessarily go through Cairo one, but I think that if you have a language where you feel comfortable with like Crow, one where you can write both the user site that runs on the browser and it's efficient enough, and the smart contract site that also can be deployed in efficient network, then you get one framework, one language that you can use to write your game, your defi application, your logic or whatever, anything else basically. So to answer your question at the beginning, I would say, yeah, learn Cairo, obviously.
00:28:36.844 - 00:28:53.464, Speaker A: So pick up on that area of games. For me, this area seems very exciting at the moment. And I've seen a lot of enthusiasm around this in ZK. Do you have examples or how do you feel about the area of developing games in CK?
00:28:54.714 - 00:29:27.298, Speaker E: So there's, what was that one dark forest? That was snark js, all that stuff. That was cool. But my biggest, the thing that makes me happiest about that is we can offload a ton of compute. We can prove that compute happened. And then you just do little state updates on chain, because obviously gas is the biggest issue. As a smart contract developer, that's like the number one annoyance constantly. So being able to offload all this compute, no matter how big it is, and to like the privacy doesn't even come into play.
00:29:27.298 - 00:29:29.098, Speaker E: Like just the compute alone is worth it.
00:29:29.146 - 00:30:18.098, Speaker B: Yeah, I want a plus one or plus 100. What Dan said, I think that Dark Forest was great and it shows, but many people are focused on the privacy aspect. Oh, we can have a game, we don't know what is happening anywhere else. And that's great. But one point that was a bit lost in what they did is that users actually play the game, then prove it to the chain with a number of steps they did. And, well, I don't know if that's the future of gaming, but I do hope that some of it is. And like you can imagine that maybe in the future, this is an actual technology of games where users execute locally their code to avoid interactions with servers and to avoid many, many servers and to avoid interactions with many other users.
00:30:18.098 - 00:30:43.174, Speaker B: So maybe there is, maybe it doesn't fit for all game, but if there is enough of quants of time in the game, you can actually build this kind of game with ZK technology today. So maybe in three years things are efficient enough so that you have an actual framework for games that is maybe for some cases more efficient than maybe using one server. And that would be amazing.
00:30:44.404 - 00:31:09.784, Speaker E: In my talk last year, I gave an example of playing 10,000 rounds of rock, paper, scissors. The final proof that was submitted was the entire game, all the interactions. So it was the entire server, not just, here's my moves, now I'm making a transaction. Here's your moves. Now you're making a transaction. It was the entire interaction. Yeah, that is going to be useful because then you can just put the output of the game.
00:31:09.784 - 00:31:14.326, Speaker E: This is the result, because the results are a matter for the leaderboard on.
00:31:14.350 - 00:31:38.938, Speaker A: Chain, I should say as well. I think we've all got teams in the Xerox Titans at the moment. I think I noticed we all have cars in that. I think we've got 15 minutes left. I would like to open up to the audience if you have questions. I see a hand over there. Could we get a microphone over there, please? Yes, please.
00:31:38.938 - 00:31:39.774, Speaker A: Thank you.
00:31:42.914 - 00:31:43.722, Speaker B: Hello.
00:31:43.898 - 00:31:51.562, Speaker E: Do you see any benefit in using recursive ZK proofs, and if so, which of the current methods you find, like, most promising? Thanks.
00:31:51.738 - 00:31:54.410, Speaker A: Sorry, I couldn't hear what you think he's repeated. Yeah.
00:31:54.442 - 00:31:55.794, Speaker E: So if you see any benefit in.
00:31:55.834 - 00:32:00.386, Speaker B: Using recursive ZK snarks or recursive ones.
00:32:00.530 - 00:32:08.444, Speaker E: And if yes, which ones are, like, most promising? I'm missing the noun from that. That question. Oh, yeah.
00:32:09.184 - 00:32:11.364, Speaker D: So can you repeat the question?
00:32:12.664 - 00:32:23.128, Speaker E: You can't. As far as I'm aware, you can't prove a circuit from another circuit. Like, you can't. You can't embed them and make them recursive, so you can't. Like, he was asking about recursion.
00:32:23.176 - 00:32:32.348, Speaker B: I think the character, I don't know about scroll, but I'm pretty sure that they're all doing it. We use recursion. Yeah, yeah, it's. It's in production. Thinking.
00:32:32.436 - 00:32:58.800, Speaker D: Recursion is what enables us to basically prove infinite length of computation. Trace, you still have the sequential bottleneck of the naive execution, but we can parallelize zero knowledge proof generation itself infinitely because we just break it down in small chunks and then we build the tree recursively and we combine them one by one until we get one final proof, which is finalized.
00:32:58.912 - 00:33:04.084, Speaker B: Yeah, this is being used extensively by zkrolabs today.
00:33:11.184 - 00:33:29.624, Speaker D: Everyone is using their own technology. We are currently using Planck. Yeah. So those are proof systems. Like Blanc is a proof system, Halo is a proof system, like everyone is using a different proof system.
00:33:30.044 - 00:33:32.104, Speaker A: Okay, we have another. Thank you.
00:33:32.844 - 00:33:54.294, Speaker F: Thanks. Very insightful. Look forward to learning more. I'm curious if the threat of quantum computers represents a unique threat to the new cryptography being developed for zero knowledge technology, or if a lot of the same arguments that we would talk about with, for instance, transitioning from SHA or elliptic turf to quantum resistant encryption apply equally well to this new cryptography.
00:33:55.754 - 00:34:35.940, Speaker C: I just had a discussion about it on the podcast the other day. I feel like, first of all, let's say even if your proof system is not quantum resistant and it's broken. No, sorry. Assume that your proof system is quantum resistant and the quantum computers are efficient enough to break all the not quantum resistant proof systems. The problem is, even if you make your proof system quantum resistant, a lot of things that are built on top of it are still not quantum resistant. So for example, in Ethereum, the signature schemes are still not quantum resistant. So let's say your proof system is sound.
00:34:35.940 - 00:35:14.138, Speaker C: It works as well as it did before the quantum computers were efficient. You can still steal money via quantum computer by breaking the signature or something else. So I feel like while it's a threat that we need to keep in the back of our minds, it's not something that is pressing at the moment. And also I feel like if we get to a point where we haven't solved that problem, then. But quantum computers are already efficient enough to break things. Cryptographic schemes, I think we have bigger problems than like, proof systems that allow us to bridge.
00:35:14.266 - 00:35:18.454, Speaker E: So to answer your question, yeah, it's the exact same conversation we're having in the rest of the field.
00:35:19.194 - 00:35:48.194, Speaker B: I just want to say one more thing on that. I think that the community as a whole, we are involved, Ethereum involved. I'm sure that all the projects here involved as well. There are some effort to get to some primitives that are secure. So even when it comes to replacing BLS signature in aggregation with some equivalent, that is, for example, stark based ones, this is in this level of the entire community at this point.
00:35:48.494 - 00:35:51.794, Speaker A: Cool. Do we have any more? There's a hand up there.
00:35:59.134 - 00:36:07.640, Speaker C: What do you think the limitations of zero knowledge are? Zero knowledge proofs are as and what will they, what do you think they won't be able to do and do?
00:36:07.640 - 00:36:08.602, Speaker A: Where do you think we will have.
00:36:08.618 - 00:36:13.334, Speaker C: To eventually invoke things like optimistic compute, trusted execution environments and so on?
00:36:14.514 - 00:36:18.734, Speaker A: Limitations of zero knowledge first, data availability.
00:36:19.274 - 00:37:13.248, Speaker B: I think I can go into like something a bit more specific sometimes. For example, I wouldn't go to anything too exotic, but you want to have some execution that is not known to any entity. For example, in the context of dark pools, you want to have a potentially matching engine between orders that is unknown to anyone. And then you have to apply some kind of mechanism that is not using just zero knowledge, but maybe something else, like for example, some kind of MPC or small MPC on some parts of the system that, that it could work. I think normally you would start to see those systems living in harmony in the coming months, years, like the technology of zero knowledge is evolving. You'll see also these kind of systems.
00:37:13.376 - 00:38:02.104, Speaker D: Yeah, I agree. I wanted to say the same. So the NPC, the fundamental limitation of zero knowledge proof systems is that someone has to know the secret. There must be one party who knows some secret that the snark or stark is computed off. If you want to have distributed multiple parties keep their secrets separate, then you need to come up with something more sophisticated. Multi party computation or some kind of interesting combination. You could argue the zero cache protocol zcash and Artstack are based on is kind of a hybrid approach where everyone has their own secret, but then they only generate snarks for state transitions that are public and shared with everyone else.
00:38:02.104 - 00:39:05.308, Speaker D: But so this is one fundamental limitation. And you can also add here the fully homomorphic encryption, where some data is like maybe you want to share some data privately, and then some computations made in this data which must remain private until some people can decrypt it, or maybe threshold of participants can decrypt it. But going back to the second half of the question, like whether optimistic fraud proofs and what trusted execution can help us, I don't think can help us as a primary solution. They could serve as a secondary solution. We could have something that as a fallback, like if the zero knowledge proofs fail, then we have some fallback mechanisms that together give some degree of just a safety net. It's not there to replace the floor, but if something bad happens, you don't want to rely on this mechanism or an escape hatch in the plane, you don't want to be actually trying it out. You would rather prefer to land safely.
00:39:05.308 - 00:39:23.608, Speaker D: But if things happen, then you need this kind of backup mechanisms which only work if they stay back up. Because if you rely on them as a primary means, then you all of a sudden you introduce too many new trust assumptions. So no, I don't see anything that optimistic roll ups can do better than ZK rollups.
00:39:23.776 - 00:40:16.954, Speaker C: Just to add to that, whatever fraud proof can do, validity proof can also do. It's just better. Yeah, basically, gladly. There are no optimistic roll up builders on this stage. So essentially the question is just efficiency. So currently some things are quite inefficient to do in zero knowledge proofs, but looking at the progress that proof systems made in the last three, four, five years, you can ascertain that they're going to probably continue making a lot of progress in terms of efficiency in the next few years years. And therefore I probably feel like in two, three years time, the efficiency difference is going to be negligible to a point where every single optimistic roll up will become a ZK rollup.
00:40:18.734 - 00:40:22.674, Speaker A: Okay, time for a couple more questions, I think just a couple more. We have.
00:40:27.954 - 00:40:29.682, Speaker B: Hi, thank you for your talk, guys.
00:40:29.818 - 00:40:31.714, Speaker C: You mentioned earlier how it's hard to.
00:40:31.834 - 00:40:34.402, Speaker E: Tell developers which language to choose, but.
00:40:34.458 - 00:40:35.682, Speaker C: Just like the language, it's hard for.
00:40:35.698 - 00:40:37.770, Speaker B: Them to choose your own ZK solution.
00:40:37.922 - 00:40:42.002, Speaker C: So could you maybe comment what is the unique offering you have compared to.
00:40:42.018 - 00:40:45.854, Speaker E: Maybe other guys on the stage? If I was to invest time into your own project?
00:40:47.434 - 00:40:48.394, Speaker D: That's a great question.
00:40:48.474 - 00:40:49.774, Speaker E: Oh, that's a good question.
00:40:51.274 - 00:40:52.414, Speaker A: What does it mean?
00:40:53.534 - 00:40:54.314, Speaker E: Nice.
00:40:56.854 - 00:40:59.390, Speaker C: My least favorite part, I didn't make.
00:40:59.422 - 00:41:22.504, Speaker E: Circum, so I don't have a dog in the fight. So other than that, I was able to come across it like as a noob, not knowing how to do any of this and look at it and figure it out. And it was the most accessible one in my opinion, at the time. And it's not general purpose, it's bespoke for a very specific problem. You tackle just that one problem. But I don't know you guys.
00:41:23.244 - 00:42:16.294, Speaker D: Okay, ZK sync. The main value proposition of Zksync is it's a technology that is aimed at future. It's a protocol that is that we developed the core team of Zksync in the community that is contributing to it, is we're thinking about the ultimate mission of the protocol and the ultimate vision. What is that? That we want to build. And we are reversing engineer from there. We're not basing it off past choices. We fast forward a couple of years and say, how is Ethereum and the world and this web free Internet of value is going to look like, and what we will need there? What we'll need to get there? So coming back to the Vitalik's post like two days ago, where he mentions privacy, smart contracts with like essentially user experience and scalability.
00:42:16.294 - 00:42:35.574, Speaker D: Those are the three things that were mentioned as like three out of four points that were named as the key goals for ZK sync. At inaugural post three years ago, we wrote a post for what we tried to accomplish there. We're talking about all three points.
00:42:38.434 - 00:42:38.722, Speaker C: And.
00:42:38.738 - 00:43:25.030, Speaker D: It manifests in the decision that we make. We have account abstraction, as one example, natively integrated at the protocol. So we had to take courage to deviate from Ethereum slightly. Now Ethereum was pushing for, I was going back then for EAP 457, which we took as a base, could not do it like 100% compatible because that would limit us. We would not be able, for instance, to have account abstraction with EOas, which today comprise the majority of the wallets. So like with EaP 457, if you use metamask, you cannot have guestless transactions, you cannot pay for gas in the tokens which you transact. Like, if you only have Dai, you cannot pay in Dai.
00:43:25.030 - 00:44:11.820, Speaker D: You still need to get some ETH, pay for ETH, and this creates a huge friction for the end users. So we said like, okay, we are willing to push this boundaries. This is what l two s are for, to experiment, to come up with new ideas, to build stuff in a different way. And by the way, Stark was doing the same. They also further on the developer experience side, where the difference between us is we're doing all these things like state divs, for example, which are going to be a volition, just going to be massive from the user experience, from the price point of view. But we are doing it in the Ethereum paradigm. We're keeping the compatibility with the code base so that you can take the solutions and you don't have to rewrite the entire ecosystem from scratch.
00:44:11.820 - 00:44:14.740, Speaker D: You can take all the projects and just deploy them in solidity.
00:44:14.852 - 00:44:17.500, Speaker A: We're almost out of time. I just want to get more comments here.
00:44:17.532 - 00:44:59.238, Speaker C: I feel like I was sat down here just to be implicitly bullied, but so we took a bit of a different path. So our philosophy is that Ethereum has reached a point where it doesn't really make sense for us to rebuild the infrastructure, change things, etcetera. So our baseline goal is to be as compatible with Ethereum as is technically feasible. There are still a few things that we have that are different to Ethereum, but for the vast majority of users and developers, I would say 99.999%, there's no difference. And all this tooling works out of the box, everything. But that doesn't limit us.
00:44:59.238 - 00:45:49.894, Speaker C: We can still add things that EVM doesn't have and basically build a superset of functionality on top of the baseline evm feature set that Ethereum supports. So we can add things that Ethereum doesn't have, like state expiry account, native account obstruction, things that don't currently work in Ethereum. But we can still keep the things that work in Ethereum 100% compatible. So let's say for a user that just wants a one to one Ethereum experience, they can use the existing tooling, and if you want something else, you can just use different tooling that allows you to interact with those things. And that basically gets you the best of both worlds where you have the familiar user experience. But if you need something else, you can always just use something that gives you a different user experience.
00:45:51.154 - 00:46:33.194, Speaker B: Yeah, I only have like I say, 50 seconds. So just to cut to the point, I think like the three things, I think the third one is the most important right now. So obviously deep, deep, deep expertise in the technology, both like experience from the past and even looking into the future. So that's one, the second thing that I would mention is that we have the courage like what Alex mentioned as well but even more to the extreme we are not afraid to change things when they need to be changed. So that for example mean the counter abstraction to default and that also means all kind of like hybrid data availability mode. We're just changing what's needed to bring the most scalable protocol. And the third and most important is the developer community.
00:46:33.194 - 00:46:57.754, Speaker B: The fact that you can go and touch the most deeper parts of the protocol and take part in developing the most important parts of the protocol right now and the fact that you can go to every conference and have a bunch of other people working and building around that is very very helpful and I think it could and will help you as a beginning developer in the ecosystem.
00:46:58.414 - 00:47:01.494, Speaker A: Thank you. We're out of time. Please join me in thanking the panel.
