00:00:00.640 - 00:00:40.814, Speaker A: Hi, guys. Okay, so I already got introduced. I'm Alexander. I'm working at the SQL Netflix foundation for developer Relations. And the topic is pretty simple today. It's one of the most, I think, gonna be like one of the new narratives for this year, which is gonna be decentralized confidential computing, or in short, a DCC. So simply put, DCC is, you know, trying to form a narrative around the fact that you have a lot of chains that are doing privacy preserving computation or confidential computation, but don't have like sort of a unified narrative, you know, which they kind of share.
00:00:40.814 - 00:01:24.132, Speaker A: So let me show you which these are. I mean, you might, you might know some of these chains that are always using these technologies. So DCC basically means that we're like having sort of an umbrella, a narrative, to kind of bring in all of the chains that are using these kind of technologies to basically have privacy preserving or confidential computing. So the first of them is a trusted execution environments, which is one of the things that secret network uses. A trusted execution environment simply means that you have a special part in your cpu. We call it an enclave, and you do some sort of computation inside of there. It's not visible to the outside, nor to the node runners, nor to validators.
00:01:24.132 - 00:02:03.334, Speaker A: And you can do all sorts of encrypted computing inside of this trusted execution environment. Then some might know what multiparty computation already is. It means that you have just validators or nodes each doing one small computation without knowing the whole part of it. So that way you can keep the whole computation confidential by just basically distributing them across a bunch of nodes. Then we have fully homomorphic encryption, which is the new kid on the block. Fully homomorphic encryption simply means that you do the encryption directly on the encrypted data, so we don't even decrypt it. You just take the data, you do the computation directly on these data.
00:02:03.334 - 00:02:32.366, Speaker A: And then lastly, we have your knowledge, proofs. I think most of you already know what zkps are, so I'm not gonna go too deeply into this. So now, what's the whole landscape of these chains? If you know them right? Maybe you know some of them, maybe not. I'm going to go into these. But the whole DCC narrative kind of centers around all of these chains that are using these technologies. So, for example, you might already, some know of them. For example, for ZKP, like dusk, Leo Edtech, three D ones that you know.
00:02:32.366 - 00:03:01.282, Speaker A: Then we're going to go to Tes, which is of course, I put secret in the middle, obviously, because I'm because I'm working at secret is a pretty old one of them. Like we started in 2020, then we have oasis, Oasis network, Marlin Phala network, for example, or ten. I mean, they were formerly obscuro, if you know obscura. This is like what X is now. They renamed it. Then we're gonna go more into the FHE direction, which are all on testnet right now. The core technology that they use is Xama.
00:03:01.282 - 00:03:37.990, Speaker A: So if you know Xama already, it might ring a bell. If not, they're basically doing, they're basically pioneering the, the fhe to be, you know, to be used on blockchains. And two projects that are using this already are Phoenix and Inco. They're in testnet stages right now. Then we go to the last one, which is MPC. So we kind of have like projects that are kind of somewhere sitting in the middle basically using all kinds of technologies, like multiple, for example, Aleph Zero, which some of you might know already, or Fairblock and partisia blockchain. So there's a wild mix of blockchains that are protocols that are using all kinds of these technologies.
00:03:37.990 - 00:04:36.262, Speaker A: But what they kind of have in common is that they're all trying to provide you with privacy preserving smart contracts or with confidential computing, however you would like to name it, then. Question is, since we all kind of have these different technologies for conventional computing, why does there even have to be that many? That's the question. Why do we even need this narrative? Why is it necessary even? Key question is, if you have all of these technologies, is there one technology that actually stands out? I would personally say no, because each of them has its distinct advantages and disadvantages. I can give an example. So if you just compare it to Ethereum on the left. So if you can see the axis, it's just a rough idea of how hard it is to do something on the chain. You do some programming, some coding on the chain, or how the application logic is versus how fast it is and how private it actually is.
00:04:36.262 - 00:05:16.258, Speaker A: So it's always like a trade off. I'd say Ethereum is super easy to develop, but it's completely open public. So if you want to go more into the privacy space, confidential computing space, you're going to first get to tes, which are easier to develop. But of course they have the assumption that the CPU or the trusted execution environment doesn't break. Then, for example, for MPC, you're going to have, of course, a little bit better trust assumption because you say, well, if all the nodes or validators don't collude. You're going to be still secure because you don't know the whole part, the whole computation, each one only knows one part of it for fhe, for example. Problem is, it's mathematically secure.
00:05:16.258 - 00:06:00.584, Speaker A: It's just proven that it works. Problem is, it's rather slow to develop, right? You have to use extra logic to make that code work. Also, the execution itself isn't that fast. So if it's not that fast, you're going to have to use a lot of accelerators or you're going to have to just use the fact that you just use small data types to make use of it, so it increases the complexity again. And then on the other hand, for example, with CKP's, of course you can only prove that a computation was correct, but you maybe can't use shared state. So you have to be like a bit clever ever about how you use this. So all of these have the distinct tradeoffs, but what they all kind of unite is the fact that they're all trying to give you confidential computing one way or another.
00:06:00.584 - 00:07:07.946, Speaker A: So that's why we think it's important to kind of give them all a narrative, their own umbrella basically, in which you would give it out into the crypto world. So basically from a whole talk right now is the idea is I'm guessing you're going to go from the top. So from pretty broad scope now into a bit narrowed scope, which goes more, basically we're going to go converge more and more into secret right now to explain also to you how secret is solving this. So we can have this DCC umbrella now. And from our standpoint, from secret, what we're doing is we're trying to do like we just want to foster deeper collaborations. So the DCC narrative is something that any chain that's doing some sort of like privacy preserving, has privacy preserving smart contracts or computing, however you would name it, we want you in that narrative, we want you in that unified narrative in the group that we have to actually push this into the crypto world and make use of the narrative that we have. Then what we can do for sql, at least we can have a bit more deeper collaborations, which is basically we are going from the DCC a bit deeper.
00:07:07.946 - 00:07:38.074, Speaker A: We are basically zooming in now and we are zooming in. And what we have in secret, what we do is we call it, in our case, that's the confidential computing constellation. So it's like a narrow set of projects that are closely, that are working together more closely. So that's a bit. So basically we zoomed in now and I kind of put secret in the middle, obviously, because I'm in secret. So from my standpoint, if you look at a galaxy like a cluster, I see myself as the middle of it. Of course, each of these chains and projects are equally as important.
00:07:38.074 - 00:08:09.016, Speaker A: So in our case, we see secret in the middle. That's the logo that I'm also having here. Then we also have Phoenix, which takes care of fhe. Then we have Fairblock, and then we have Obi. So Fairblock uses MPC mainly, and Obi is actually a sidechain that's going to be made for secret that uses a column abstraction. So we can actually use secret since we have trusted execution environments, we can store private keys inside of that trusted execution environment so no one else can see it. And with this you can create account abstraction wallets.
00:08:09.016 - 00:08:57.526, Speaker A: Obi is already live on Mainnet, but they're also going to do an extra separate chain, by the way. So they actually completely leveraging secret to the maximum to do account abstraction. What's very cool about all of these is that they closely work with each other together. So Phoenix, for example, has a lot of developers that work on cpu and on Phoenix, Firebox, for example, is also developing technologies that kind of go into the direction of secret, for example, with their farrowing testnet and what they're doing. And then also for Obi, for example, they're going to be like a sidechain to secret or an l two, sort of, because secret is an l cosmos l one. But I'm going to go more into this. And then also we're still making our deals with other projects that are actually using secret as part of the code or like integrating more with secret.
00:08:57.526 - 00:10:03.504, Speaker A: So we're still, we're very open for more collaborations as well, but we also have some more in the, in our drawers, which are still not completely finished, so we can't, so I can't announce them yet and we still have more to come. So now my question is really, like, if you're basically reading this now, the question is, well, how would secret actually fulfill this like DCC narrative, like this vision of actually bringing confidential computing to other EVM chains or like, to other chain synthesis, since this is an ethereum event. So now my question really is, how do we do DCC for EVM chains? That's going to be my question that I'm going to answer now. Is this absolutely perfect for the formatting? That was actually better when I actually sent it in anyways, I think you can still read it. Do you? If not, just give me a sign. Anyways, our question really is how can we bring decentralized component computing to EVM chains? I can tell you at least how SQL is going to do it and how we're doing it right now. So on one side, on the left, you can see evms could also be zkvms.
00:10:03.504 - 00:10:30.314, Speaker A: By the way, we're also supporting these. And then on the other side, of course, we have SQL network. SQL network is using trusted execution environments. So you can do like a bunch of privacy preserving confidential computing on secret and then send the result back. So you're going to do some computation on EVM, or you can send encrypted payloads in and send them to secret, do some computation and then send it back. And there's going to be two ways. So first of them it's going to be Axela general message passing.
00:10:30.314 - 00:10:57.784, Speaker A: For those who don't know what Axela is, maybe some of you use squid router, maybe in some use case. If you did, it's already basically, you already just used Axela without actually knowing it. In case what, you don't know what Axela is. Essentially it's also a cosmos l one. And the key idea is it's basically a huge multisig that consists of all of the validators inside of Axelar. So you can almost say it's like a huge multisig bridge. So that way, of course, we have a two way bridge that's pretty secure.
00:10:57.784 - 00:11:34.570, Speaker A: Now, our question is mainly, I mean, I've talked about the ECC and I have talked about secret. Now question is, really, I want to go more what secret actually is for you? So I'm just going to tell you. Secret is a, and this is how we see ourselves. This is how we see ourselves, this is how we want to be seen basically for the whole ethereum community as well. We see us as a confidential computing hub and we are using Cosmos SDKs or base and we are on l one. And our key technology is trusted execution environments. And our use case, we use Intel SGX for this.
00:11:34.570 - 00:12:32.934, Speaker A: Of course there are other technologies as well, for example AMD, SCV and others. But for our use case and for our project, we are using Intel SGX and what we have, and that's basically what we are providing to evms, is our, what we call just confidential execution layer that's decentralized, scalable and secure. And we are using this to just basically give you any, do any sort of confidential private computation that you want on your data from any blockchain that you have on EVM space. We are also starting to support other blockchains now that, like, not non EVM based, but we're like slowly building it out. Now the question is, since we have, we're gonna go more deep, deeper into this. What are actually our disciplines? What do we think? Do we need to like provide actually for users who are using secret, and we call this like the tee disciplines, so it kind of looks like Olympic rings. That's actually on purpose.
00:12:32.934 - 00:12:54.282, Speaker A: That's actually not an error on the formatting. It's actually on purpose. So first of all is we have confidential calculations. What we see is really important for all chains, basically, that can use it. Then we want trusted execution. Then we want transactional privacy. Transactional privacy simply means, for example, you're sending some tokens around.
00:12:54.282 - 00:13:28.096, Speaker A: You don't want to know what are you sending around, right. Or to who you're sending it to or what amount are you sending it to. So that's how we. So that's how we see it. Privacy has to be a must then data protection, obviously. So your data are secure when you're computing on them and they're not leaked afterwards. And also verifiable computing, which means even though we're still doing this all kind of stuff in enclaves and it's not visible to the outside, it still has to be verifiable by all of the validators inside of secret that are like checking the blocks and are giving the signatures on the blocks.
00:13:28.096 - 00:14:05.314, Speaker A: So still has to be verifiable in some way as well. So with this, we can have basically everything together, right? We have the EVM side, we have the secret side now together. And we have one of the bridging protocols, which is accelerated GMP. Thing is with accelerate GMP, if some might have used it. The problem is that it's not really fast. It's like finality is like ten minutes, 20 minutes, depending on the chain that you have. So what are we going to do now? Well, what we're going to do is we are going to use secret path, which is a bridge that's a bit different, but it's way faster.
00:14:05.314 - 00:14:37.172, Speaker A: And the principle is actually pretty simple. So what we have with secret path is it's also like a cross chain bridging solution, but we see it as something that's actually trustless because it actually leverages, only leverages a confidential contract on secret to pull off the whole bridging. And the idea is pretty simple since you have a trusted execution environment. It's encrypted. So all the state that you have inside of this is encrypted. No one else can see the state of that contract. So you can store a private key in that contract.
00:14:37.172 - 00:14:56.480, Speaker A: That's the idea behind it. You store a private key in this contract that no one else can see except the contract. Only the contract has access to this. So that contract obviously can do the following. It can sign messages. Now, since it has a con, since it has a private key inside of the contract, it can sign messages. And since you can send messages with these messages, you can verify them on EVM.
00:14:56.480 - 00:15:20.692, Speaker A: So what you can do is you can basically take some data, put them on secret, do some encrypted computation on secret using an encrypted payload, put it on secret, and then it will sign that message and send it back. So the way in is actually not trusted. That's completely different from any other change you usually see. Right. Because it usually, you know, kind of secures both ways. It secures the way in and secures the way out in secret. It's in that secret path of our special technology.
00:15:20.692 - 00:15:42.244, Speaker A: It's a bit different. You just have a smart contract. So the way in is untrusted, but the way back is actually trusted. That's the only one that's actually trusted. So we see it's like a one way signed bridge, only the messages that are coming out of it are actually secure, but they're only signed by a smart contract. So it doesn't have to be any multi sig behind this. It's just a contract that signs a message and you can verify that message that it was actually coming from this contract.
00:15:42.244 - 00:16:08.166, Speaker A: You just check the signature. That's it. And with secret path, you can. I'd personally say you can almost pull off then personally say it's like almost 80% of the use cases that you're going to do, like using Axla, GMP or other services. So you can basically use any encrypted payload that you can imagine, for example, a encrypted key value store on your EVM. Yep. And you can use, for example, SQVF, which we used at Eve Denver, and if Eve Bucharest, both of the teams that use it.
00:16:08.166 - 00:16:34.046, Speaker A: One actually, and it's a verifiable on chain random number generator. It's way faster, so within one block. And it's way cheaper in gas usage as well, because you won't check one signature. So now we've basically went in super deep into the whole secret stack and what you can do with it. But that's about it. We're basically now going to zoom out again. That's how we think we can fulfill the DCC narrative, to bring DCC to all across all EVM chains and potentially even more other chains as well now.
00:16:34.046 - 00:16:41.794, Speaker A: So I basically talked to ICP as well and also in Solana, if you want to find out more, that's what you can look at. That's it. Thank you, guys.
00:16:45.134 - 00:16:56.262, Speaker B: Big round of applause. Thank you. Thank you. It is a secret. I'm totally sold because it's confidential. So questions, please raise your hand. We'll give you the mic.
00:16:56.262 - 00:17:03.214, Speaker B: You have mic over there in here? One or two? One.
00:17:07.274 - 00:17:35.454, Speaker A: Thank you. So I've got a question about secret path. So comparing to other cross string protocols such as layer zero or across protocol, what are the advantages of secret path? I mean, the main advantage in secret path is that you're not reliant on some, you know, a tester basically, you know, attesting some sort of like message. That was some bridging. That was correct. It's just the smart contract itself does all of the logic. It checks that the message came in, it will execute it on a different contract that you just set.
00:17:35.454 - 00:17:58.028, Speaker A: Basically, you said execute this in this contract and then it will actually use the result of this, sign it again. So it will get back the message? It will sign the message and then send it back into EVM. So you don't have any attestation service or anything involved? It's just sending in some message into that gateway in secret. It handles everything and then sends it back with the signature on it. And you can check the signature on EVM. And that's pretty simple. So you just don't have any intermediary.
00:17:58.028 - 00:18:16.260, Speaker A: You just basically just put the message from EVM into secret. We have a relay for this, but it's trustless, so it can actually try to forge messages. It doesn't matter because you don't trust it anyways. And the web page is also untrusted. You can just basically take this stuff from the contract, put it into EVM contract. The EVM contract will check it if it's valid or not. That's it.
00:18:16.260 - 00:18:24.024, Speaker A: And you don't have to use any attestation service or roll up or anything impressive. It's pretty nice. Yeah. And it's extremely fast.
00:18:24.564 - 00:18:39.264, Speaker B: I hope you will raise more than layer zero did. So fingers. I keep my fingers crossed for you. Any more questions? Then we are staying for the last but not least panel discussion. Everybody's here. Stay here. Thank you so much.
00:18:40.364 - 00:18:41.132, Speaker A: We got a question.
00:18:41.188 - 00:18:42.624, Speaker B: Apologies, apologies.
00:18:43.484 - 00:18:44.264, Speaker A: Yeah.
00:18:47.104 - 00:20:02.194, Speaker C: Thanks for presentation. I was last time I was looking into SGX, it was a long time ago, so I may be not up to date, but I would love to hear from you about challenges in maintaining high security of the privacy. What is executed inside in respect to side channel attacks? Is my understanding correct that the system running inside of enclave is processing the inputs that are provided for the external world. So I could technically make a copy of this state and fuzz it with different inputs and try to measure timings or do other kind of like measurements and try through side channel attack to exploit some good point vulnerabilities. And I wondered because there is this like insecurity, this false sense of security that you provide platform that developers will feel so secure that they will start to be like, you know, a bit loosey about the implementation whilst like believe you need to have a regime like constant time computation or other stuff. So I wonder about your thoughts about this.
00:20:02.234 - 00:20:41.790, Speaker A: Like extremely good point. So first of all, exactly saying the side channel attacks are a huge problem, obviously, because if you're on public blockchains you don't have to think about this kind of stuff. How we solve it is we disable transaction simulations so we can't actually simulate a transaction, so we actually have to really execute that transaction on chain. And also the other thing is, you could potentially say, well how about I'm just forking the network and then just trying to do the same thing. Thing is we basically verify the validator set inside of the enclave as well. So if you try to fork the whole chain and then try to do some execution on it, it doesn't work because you're also including a validity set in each of the proofs inside of the TE. So the GE checks actually who's actually signing this.
00:20:41.790 - 00:21:01.054, Speaker A: And if you don't have the validator set included, that's actually from the original chain, you can't do any execution on that enclave. So that way you're mitigating this. But yeah, these one of the bigger ones. And then for example constant time is also a problem, obviously. So we have for example also gas evaporation. So basically that way you do it kind of like constant gas. Instead of constant time you do constant gas.
00:21:01.054 - 00:21:13.228, Speaker A: And that way it doesn't leak any information about the execution trace that you had. But super good points. And this is like actually not a trivial problem. You really have to think about this when you're doing the whole privacy preserving confidential computing stack absolutely agree.
00:21:13.276 - 00:21:18.484, Speaker B: And we'll keep that for the upper row. Thank you so much, Alexander. Last round of applause for Alexander.
