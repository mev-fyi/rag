00:00:00.600 - 00:00:47.724, Speaker A: So we are going to talk about SEGP 256 r1, which actually is the elliptic curve used in Pascis and Intel enclave SGX. So briefly, our team, we are four former ledger innovation. We left and we just launched our company. And our mantra is that there is no web two or web3, but just web making the difference between the two vanish is our purpose. So we are currently focusing on supporting the P 100 256 on chain. We hone the fastest implementation. Actually, I think that the safe module uses it, Baze is working on it and some other actors.
00:00:47.724 - 00:01:35.344, Speaker A: We are also working on ED 250 519 for similar reasons. It's implemented in Fido framework, which we work on, and we also have works on MPC frameworks. So among the team, I'm Renault, I'm a cryptographer. I've been introduced. So briefly, what we did last year, we ended up finalists at East Global New York with our invisible wallet so implemented passkey on chain. We were rewarded for this open source implementation by the retro PGF. And recently we've been granted by the ATRM foundation to continue our work on ECC work and I will present some of our new results.
00:01:35.344 - 00:02:28.288, Speaker A: Okay, so briefly, Sekpi is a non native to its era, but it's the most widely used elliptical for classical cryptography that we have in our daily lives. So when we perform TL's exchanges, some of the passport. So for instance, dutch passports use this curve, intel enclave SSH and pass keys. So we had two talks referring to it in the morning. Thanks to them it has been specified by nists. So as I said, it's non native that it has to be emulated with EVM instruction in order to implement it for smart contract or smart accounts. And being so widely used, it's a natural candidate for account abstraction.
00:02:28.288 - 00:03:31.594, Speaker A: So we had this very good talk by Yvo about account abstraction. So briefly, how is this invisible wallet constructed? Is by using account subtraction with this curve. So this means that we are able to verify the passkey framework on chain. So it means that using your touch id, what you are really doing is you unlock the access to the private key that is stored in the secure enclave of your smartphone, which is the most secure components of your smartphone. It's actually a secure element. And the related public key is, is pushed to the user of ERC 4337 as your signer. And there is a little front that translates the transaction from the pasky API to the on chain.
00:03:31.594 - 00:04:28.774, Speaker A: So this use has been described by safe sooner. And also we had this, this MPC implementation over pesky so I will be fast. And there are also some proposals to so mainly it was written by Justin Drake on Ethereum research. It has been implemented by scroll and Tyco. And it happens that the Intel SGX which aim to guarantee the integrity of computation executed in the enclave, it's secure also by this curve. It's actually live on scroll on Taiko and actually they are not using your computation, but they could save a lot of gas by doing so. If there is someone connected to Scroll Taiko, I would like to speak to them.
00:04:28.774 - 00:05:30.764, Speaker A: So last year we delivered this fastest implementation. So we had two results. So a straightforward result without any additional deployments which cost 200k gas and one we requiring to deploy an extra contract for each public key. So this is expensive. It's 3 million gas, but the verification is very fast down to if you compare to all the gas you have to spend when you perform a standard ERC 46 transaction, you already have something like around two to 300k. So this makes the signature that was overwhelming before. No, it's not that expensive related to the smart acute implementation.
00:05:30.764 - 00:07:01.094, Speaker A: So depending on the use we provided these two implementations improving by a large factor, pre awards and everything is described on the paper written here, and you have a link to the repo implementing it. So what we did since then, we make things better. So we make it even faster without precomputation dropping from two hundred k to one hundred and sixty. Only a few amounts of extra extra call data, meaning that it's not fully compatible with RIP 7800 2012. But another very important point that we implemented is that we make this computation generic because today we are talking about the 256. But there are so many curves and many use cases that could benefit to have a generic scalar multiplication. Meaning there are for example other ecosystem as cosmos is using the ED 255, there is a curve of stacknet, there is a framework palavesta, actually the g one group of the Bn curve could also be fastened by by such mechanism.
00:07:01.094 - 00:07:55.334, Speaker A: So generosity is also a very important property. So this is a list of proposals of eips to make evolution to ZRM protocol. And we don't know if tomorrow another curve rise or pop for some very convenient system will have to update and push again a new EIP. So what we propose would be to implement double scalar multiplication. I will describe it later as one extra eip. So I will try to give the insight of how the precomputation works. So we had presentation yesterday by Lawrence and Armansch on elliptic curves.
00:07:55.334 - 00:08:46.740, Speaker A: I won't go into deep details but give the idea. So basically what you do when you do a standard scalar multiplication is an algorithm called double anad, which is the equivalent of square multiply. Anyone knows about those? Here one. Okay, not that much. And what we do when we, when we compute this elliptical elliptic curve, scalar multiplication, basically we only have two operations, doubling and addition. And what those implementation are performing is that instead of computing the doubling, add separately for each point. When we do a double scalar multiplication, so two multiplication at once, we are able to mutualize some of the computations.
00:08:46.740 - 00:09:36.694, Speaker A: Here what happens in blue as a double, the number of doubles, the addition are in orange, and in red appears the precomputation. So for instance the last line of the table figure the high amount of precomputation we have to perform with this extra contract. And so the two new implementation we are pushing are the two green lines. So one is still compliant with 70, 212 and a bit faster. The EIP would like to push is the second green line. So with this 512 extra bit of data, we are able to have a massive gain in gas cost. So as I said, basically ECC is easy.
00:09:36.694 - 00:10:34.094, Speaker A: You have points, what you can do with them, you can add them and you can double them. Okay, so the only thing is that the scalar field is huge and there are a lot of points. Okay, so basically what you perform when you want to do double and add, so we don't have to know what elliptic curve is. For instance, if I have an object and I can just add or double hit. The way double and hard works is that I will look at the exponents and for each bit, if there is a one, I will double and add the input value. If it is a zero, I will just double it. So starting from p, so from the most significant bit, I have a zero, I double it and I have a one.
00:10:34.094 - 00:11:34.196, Speaker A: Computing the five p, I double again, I add p and this is five p. You have the same example for computing seven times the value, the value q. So starting from q, double uniting is three q, double uniting, it's seven q. The idea of the Strauss chamier trick is to neutralize the doubling. So you perform only one doubling and you, you will perform only one addition. So now if I look at this sum p plus q, I have one point of precomputation h, and looking at each bit of exponents, no, if there is a one on both line, I will double and add the point h. If it's zero, it's only a doubling, and if it's a zero, one of the line I will add p or q.
00:11:34.196 - 00:12:21.144, Speaker A: So doing this we neutralize all the doubling and we keep the same number of additions. So basically stroschamir is nearly twice effective as performing two scalar multiplication. And for higher dimension you can have more pre computations. But this is the same, the same principle. So just a word about ezogenies, because I guess some of you have heard about the ED curve. Someone knows about ED 255? Yeah, for instance, it's used in cosmos. It's used actually it's part of the Fido framework.
00:12:21.144 - 00:13:22.762, Speaker A: Only ubikey is implementing it and it has a very interesting properties. It's a schnor signature. Schnor signatures are very more convenient to implement MPC framework more efficiently and more securely. Because ECDSI is very error prone. There will be devastating consequences lately on the gain arrow scheme. So we really hope that at some point we'll have a massive switch to the ED curve. But actually you can, using exactly the same formula as before, which is a various stress representation of the 300 256, you can convert your Eduard curves to the various trask presentation, perform using this unified code, the computation, and then switch back to the ED representation.
00:13:22.762 - 00:14:49.380, Speaker A: So this means that the code that we are pushing, so adding just those either enables us to implement the ED curve. So as a conclusion, so we implemented efficient and generic ECC progressive precompile. That means that we will deliver soon all the solid code associated to those results. It will be released around the 22 April and it's going to be audited, which was not the case of the previous FCL and it had generic ECC capacity to the EVM. But I think it would be interesting to push this as a rip. Currently there is a very interesting IP which is called MSM, but I think that maybe if it has not been implemented, it's because it's very complex, because it has genericity to the elliptic curves as well as unbounding the length of input and its use is restricted to some Zk, while double scalar multiplication actually enables to implement most of the classical authentication mechanism. ECDSA, EDDSA, eck, CDSA, et cetera.
00:14:49.380 - 00:15:08.864, Speaker A: So mainly what we will try to do is to find allies in l two to push this, to avoid to switch from one rip to another, we need to switch curves. And that concludes my talk.
00:15:19.164 - 00:15:42.064, Speaker B: Thank you very much Handel, for your presentation. And we still have some minutes for some questions. Does anyone have a question here? So no questions, but later, if you come up with an idea or doubt, Hanoi is like will be reachable outside or through LinkedIn Hanoi. Thank you very much.
