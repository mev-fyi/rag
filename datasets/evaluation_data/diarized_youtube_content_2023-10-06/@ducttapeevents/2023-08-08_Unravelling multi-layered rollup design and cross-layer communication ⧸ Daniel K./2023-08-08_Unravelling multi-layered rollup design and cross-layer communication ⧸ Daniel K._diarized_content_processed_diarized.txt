00:00:01.280 - 00:00:33.802, Speaker A: Hey guys, thanks for having me. Okay, let's get into it. So first, thanks for having me and thanks for this organization. The event is great. I'm Daniel from Taiko and I'm going to talk about multiple layers, multilayer roll up designs and cross layer communication. Those who don't know what taiko is, ethereum equivalent or type one ZK EVM. And yeah, let's jump into the middle.
00:00:33.802 - 00:01:11.222, Speaker A: So the first section of the presentation will be about multiple layers, why we need them, or how it tries to tackle the scaling problems. And I will touch the point of inception layers Taiko is trying to push forwards for. So first, a little bit of an introduction. So what you could see here is the network utilization of Ethereum. So what you could see is like for three years, ethereum is kind of at the edge. So full utilization. You can see here there is a dip, but it should not mislead you.
00:01:11.222 - 00:02:01.930, Speaker A: It's just when the EIP 1559 math went live. So basically, if we would be above the 50% of block a gas target, then the base feed would be exploding. So this just means that we are at the edge, what it implies to be on the edge. So to be something where we are utilizing the network, it usually from a user perspective, from a user point of view, we see like network congestion. So the more transactions are coming in than the network is able to process what comes with it. So it also implies that we need to pay more to block builders or validators to include our transactions. So this is why we could see that those fees are exploding.
00:02:01.930 - 00:02:53.314, Speaker A: Right? Okay, so in order to get to the layers, I would like to give you a short recap of how we get there. How ethereum turns towards the roll up centric roadmap. And first, Ethereum tried to be a chain who scales it all, who solves its scaling problems alone via shards. Shards are multiple. Shards are like they would fractionalize the network into multiple portions called shards, and those shards would have its own state, and they would synchronize via a beacon chain or a coordination layer. But then they reiterated the plan and now they are leaning towards a more roll up centric roadmap with blobs. Blobs is a new transaction type.
00:02:53.314 - 00:03:42.618, Speaker A: It's just like a regular transaction, except they can carry large amount of data and it's much cheaper than the current call data. It expires. This is where ltus could put their state differences, state transitions, transaction list, or whatever they want. So this is why we see multiple layers emerging, because Ethereum wants to scale with the help of layer twos, I would go into the wise more. So we already talked about the throughput, so the network congestion, then the cost efficiency, or actually the high gas cost. But there is more to it. And from a maintenance perspective, or from Ethereum's perspective, that's the problem of increasing state.
00:03:42.618 - 00:04:27.432, Speaker A: So clients running Ethereum does not have the same resources as an angry girlfriend. There was an excellent presentation last year Eid Prague from Peter Siladi, but I just give you a recap or a TLDR. But if someone wants to have a look at it on YouTube, please. So basically, let's say ethereum tries to scale and we are tuning some parameters. Let's say these parameters are like the TPS, or rather the gaseous per second. So what happens is that it would speed up the growth rate, and if it would speed up the growth rate, then it would also like speed, like more. It would require more rights to disk space.
00:04:27.432 - 00:05:03.104, Speaker A: But in order to avoid it, because it's so intense or gas intents or computational intents, we would like to keep more things in memory. But memory is a precious resource and therefore it would just higher the barrier for running nodes. So the more expensive and difficult to run nodes, the less nodes we have. The less nodes we have, the more decentralized the chain is. So therefore, theoretically we have a datability problem. So this is why, I guess one reason why ethereum turned towards like layers. And let's go with the layers.
00:05:03.104 - 00:05:41.360, Speaker A: So what you could see here is multiple layers on top of ethereum. And then I will touch the point of inception errors afterwards. But like. So yeah. If there would be just only one layer, who would try to scale alone Ethereum, that would be ethereum, right? Or there would be one who tries it, that it would tackle. It would need to face the same problems as Ethereum, like the decentralization problem. But for some, sacrificing the decentralization is just fine, it's okay.
00:05:41.360 - 00:06:21.576, Speaker A: But then it would also run into the state bloat problem. So therefore we at Tyco, we tend to think about it that different layer providers and layer solutions, layer instances are healthy and not. How to say it just a sec. So healthy competition. I would not rather call them competitors, but rather like complementary subsystems. Who helps to scale Ethereum? Because there will be no one single layer who will do it all. And now to going back to inception layers.
00:06:21.576 - 00:06:45.324, Speaker A: And this is coming from the term coming from the movie of the inception movie with Leonardo DiCaprio. Like dreams. In the dreams. In the dreams. Right. So the beauty of being a type one or an Ethereum equivalent network is that we eventually be able, it's the same codebase, we are sharing the same code base. Our client is able to verify the Ethereum block.
00:06:45.324 - 00:07:28.664, Speaker A: Basically we can just shoot up layers in the layers, recursively, even deeper than layer threes. Just like that? Very easily. Yes, you can see the. Okay, so that's the concept of the inception. Layers. Obviously it's not only just restricted to type one, shooting up layers in their layers, of course, but in order to do that with other chains, not ethereum equivalent, then they would have to maintain two concurrent systems, which can be a mess. So this is one reason we think we are in a good position and also.
00:07:28.664 - 00:08:06.828, Speaker A: Yeah, layers and layers. I wanted to say something, but I just forget it. But what could it be? Layers and layers. Anyhow, let's go to the next slide. I might come back if I have something to. Okay, the next topic is cross layer communication. So let's see, what is cross layer communication? Cross layer communication is basically just sharing information among other chains or layers.
00:08:06.828 - 00:08:58.994, Speaker A: Basically bridging is one type of, of the cross layer communication or defi protocol on l two wants to access some data on l one. This is also like via the cross layer communication. Why is it important? It's a key element of scaling. So without communication, there is no scaling. We need to talk to each other. And then there is the efficiency issues, like isolated systems usually or could limit the technology. A good example of it is the early days railway systems, when you have to, when you had to, or you wanted to do cross border travelings and then you had to go to the border, disembark, carry the load, uncarry the load, carry it to the other chain and then continue your journey.
00:08:58.994 - 00:09:34.180, Speaker A: This was very inefficient and this is why we needed those kind of railway standards. Now it's much more smooth. So this is why we need, definitely it's a retal thing. And obviously last but not least, some might prefer like cheaper chains or quicker chains. So therefore it's a choice and preference of choosing it or one versus another. Right, one. The current elegant approach is, is that there's a synchronization mechanism between l one and l two and we synchronize the state route.
00:09:34.180 - 00:10:32.928, Speaker A: If we want to verify the whole ethereum or just the storage route, if we are just verifying a specific smart contract like a bridge, and with a Merkel proof or a Merkel inclusion proof, we can just verify the data, what we are accessing on the other chains. It's good, it's working. We are using it. A lot of the participants in the network are using this approach. Problem with this is that we need to broad the data manually on chain with the proofs, which is very cost intensive. The proofs and the data if. Yeah, basically that leads to the next slide, or the last slide of mine, which is a research paper from Tyco and our CTO Brechta was put this together.
00:10:32.928 - 00:11:32.000, Speaker A: Unfortunately the link could not be seen for whatever reason. It's under the subtitle. But there is a research paper on ETH research from Brecht Davos before, which basically says that there is maybe a more efficient mechanism to do that. We are synchronizing the state routes to the l two s, and it's only possible with EVM equivalent chains, plus if we are using the same data structure. So actually like ethereum equivalents, not only EVM equivalent, but so we're synchronizing down the stateroom. And when an l two contract tries to access data on l one, basically the precompile is getting activated and via this precompile it changes the stateroot to the l one state route. And it's actually calling the l one smart contract during the pre compile disk.
00:11:32.000 - 00:12:37.388, Speaker A: It's done by the client and it has the advantages of very efficient, because we don't have to put the proofs on and the data on chain. And it's very easy, like it seems like you can just call an l one smart contract data from l two. It's very convenient and simple to prove. So l two's that already proving EVM bytecode with Merkur Patricia tries can just easily like switching the context, then the state route and then calling the data. It has also some drawbacks of course, like everything is that the l one needs to l two needs to have access to l two. L two nodes needs to have access to l one state and they have to run in low latency communication, otherwise it will not work. Or there has to be an l two node which is submerged l one node, l two l one node together.
00:12:37.388 - 00:13:26.834, Speaker A: But it's very memory and resource intensive again, so it's not, most probably it's not going to work or would lead to higher hardware requirements barrier. And it only depends on the or only works for change that the l two already depends on. So otherwise we would need to implement different kind of chains or data structures within the client. So it's also like very hardware, it could be very hardware intensive. Yeah, one thing I already for. I forgot to mention with the layers and I just figured it out. Is that why I'm talking about multiple layer layer in the layers like layer fours and recursively even deeper layer fives, etcetera.
00:13:26.834 - 00:14:24.602, Speaker A: Personally, we don't think that we need layer fours or layer five, but to onboard the next billion users to the ecosystem, if you want to onboard them into l two s, then we need to have. Need to put. Most probably we need to put. It depends on the mechanism, but we need to put their proofs onto l one, which is very costly, very expensive. So this is why we think that we might need l three s. And even though let's imagine I was working on a gaming company, a mobile company, and they were trying to build up a blockchain department. So what could happen is that we have this beautiful solution from Taiko is a type one network and they want to have an own chain and what they could do is simply shoot up an l three network on the top of taiko or others like scroll or Polygon can even like launch on the top of l two.
00:14:24.602 - 00:14:56.294, Speaker A: Basically it's an ethereum in ethereum. So they could just use Tyco's data infrastructure chain and clients to shoot up their own network within our network or top of our network. So they could even use it for application specific purposes like gaming. As I mentioned. That was it. That was it in a nutshell. If you have any questions.
00:14:56.294 - 00:15:01.474, Speaker A: Okay, I have 1 minute left, so feel free to. Or.
00:15:03.654 - 00:15:13.190, Speaker B: Wonderful. We might have time for one question if anyone's got one. Oh, we've got one at the back. That was the quickest one. We've got literally 30 seconds.
00:15:13.222 - 00:15:18.716, Speaker C: So do you think atomicity is possible between different roll ups?
00:15:18.820 - 00:15:19.180, Speaker A: Which.
00:15:19.252 - 00:15:21.224, Speaker C: Sorry, could you repeat atomicity?
00:15:22.884 - 00:15:23.964, Speaker A: I could not really.
00:15:24.004 - 00:15:28.144, Speaker C: Atomicity, like atomic transactions between different rollups?
00:15:32.244 - 00:15:49.326, Speaker A: I would say between ethereum equivalent rollups. Definitely. Sure. Because it's easy to implement. Otherwise I'm not 100% sure. Or when we get there, I hope it answers your question. It's still so that.
00:15:49.326 - 00:16:07.034, Speaker A: Sorry, just this research paper is still in like in research phase. So we will see if it is feasible or not. We will see. We have partners. I think scroll is also interested and other participants is trying to explore synergies, how we can implement this in the future.
00:16:07.334 - 00:16:12.132, Speaker B: Thank you. Give everyone a round of applause for Daniel, please. I hope we get there.
00:16:12.188 - 00:16:12.444, Speaker A: Thank you.
