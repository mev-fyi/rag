00:00:05.320 - 00:01:02.088, Speaker A: Hi. Hello everyone. My name is Alex. I work on account obstruction and today I would like to make a case that now is a great time for full native account abstraction across all L2 s. So we have been using EOS for better part of like 15 years and the question is, is it the best we can do or we can do better? To answer these questions I will ask five more smaller questions. They are what are we trying to obstruct away? What are we trying to enshrine in Ethereum protocol? Why are we doing it? What makes the account obstruction solution complete? And why now is a great time to do it? So my question is, what is the worst user experience of having some money in human history? So there was an island in Micronesia where people would use giant stone disks to trade for food. I argue it's not a great user experience.
00:01:02.088 - 00:01:34.338, Speaker A: Other islands used seashells they collected on the beach. Probably not good for inflation. And right now we are using often like metal sheets or just papers with twelve words written on them. And this is our store of value. And sure, this is not a great user experience for a lot of users. So what is wrong with externally owned accounts in general? The most common way to back them up is to write the seed phrase or private key on a piece of paper and keep it somewhere. The eoas provide immediate and full control of all your assets.
00:01:34.338 - 00:02:04.078, Speaker A: There is no kind of control in any granularity. It is very hard to replace your private key, your secret, and you just need to move your assets. And not all assets can even be moved. You can have voting power delegated to your address on some DAO, you can have an airdrop coming your way. They are part of the protocol. If you want to change how Eos work, we need to change the Ethereum protocol itself. So for their users, if they lose their private keys, they lose their funds.
00:02:04.078 - 00:02:39.814, Speaker A: If they expose their private keys, they lose their funds. If they send assets to an incorrect address, they lose their funds. If they do it on the wrong chain, they lose their funds. And if they even created their seed phrase with a wallet that has the broken seed generator randomness, they will lose their funds. So you do anything wrong, lots of funds, right away. We don't have any time to waste in adopting native account abstraction, externally owned accounts. They don't provide the convenience that users are used to get from technology in this day and age.
00:02:39.814 - 00:03:44.436, Speaker A: In my opinion, the even existence of externally owned accounts is kind of a technical debt for us. It's an implementation detail from early days of blockchains that is still widely used today, and we should expect to phase out and deprecate externally owned accounts. But that's not what we are doing. Instead, we are creating more and more dapps that rely on EC recover that rely on EOA based transaction types, and we are adding new transaction types with basically every Ethereum update. And it is frustrating because EOA has become more and more entrenched in Ethereum as time goes by, and in a short period of time, it will probably be impossible to replace them. Like, for example, driving on the left side of the road. In the United Kingdom and some other countries, there is so much infrastructure built around it that it is impossible to reverse this decision and convert to driving on the right side of the road or using a metric system or imperial system.
00:03:44.436 - 00:04:16.328, Speaker A: In the United States. People are so used to it that it is impossible to reteach 300 million people to use a metric system. So all that would be kind of theoretical if we could just keep using EOS forever with their bad user experience. But that's not the case. Eos do have an expiration date. Making a change to how Ethereum works takes very long time. Transient storage was created in 2018, got Mainnet in 2017, 2024, six years to make this change to ethereum.
00:04:16.328 - 00:05:10.016, Speaker A: And quantum computers are known to break elliptic curve cryptography, and they are expected to go online somewhere next decade. So NSA sets 1335 as a deadline for post quantum cryptography. It seems like eleven years are a lot, but if you haven't started yet, that's not so much time to convert the entire crypto community to a new kind of cryptography. So if we don't want to wake up to a news like that, with North Korea acquiring quantum computers and having to make an emergency hard fork, we should start doing something about it right now. So let me dive a little bit into what do we need to abstract. So your account consists of four major roles that are assigned to it. This is your address.
00:05:10.016 - 00:05:28.724, Speaker A: This is your identity on chains. This is what actually holds your assets. This is what authenticates you. The private key authenticates that you can control this asset. You also pay gas from the account that is sending a transaction. This is the definition of a protocol. And the execution.
00:05:28.724 - 00:06:06.446, Speaker A: Excuse me, can you hear me? 1212. Yeah, great. And execution is also part of what your account does. So current ethereum transactions allow you to make one execution frame, meaning like, you can call a destination with some kind of call data. And if you want to transfer two kinds of tokens, you need to create two transactions. You cannot batch them naturally, together we want to abstract away all of that. We want your address to be derived from the smart contract account that you are.
00:06:06.446 - 00:07:02.546, Speaker A: You deploy a contract and this is your account. Now you authenticate your transactions by using a method in this wallet called validate transaction. Your account does not need to pay gas for its own transactions. You can have a different account contract that we call it Paymaster and you call its validation function, and this contract can accept paying gas for your transaction and for execution. You just pass some data to your wallet, and your wallet can do whatever it wants on chain to execute multiple transfer swaps, whatever you come up with. So for all of you who are following Ethereum development, all core devs calls Eaps, you may ask yourself, didn't we just solve account obstruction with EAP 7702? So it's a fairly new AP, but the answer is yes, but actually no. If we look at the table, we didn't change how address works.
00:07:02.546 - 00:07:35.394, Speaker A: It's still controlled by your private key. You still authenticate spending even a 77 or two transaction. With signing an ECDSA private key. You do obstruct away gas payment, but not in a generic way. You allow one AOA to pay for the other transactions, which is kind of glorified meta transaction but not a natively abstracted solution. But you have full execution abstraction. You inject your code into your UA and execute this code as part of your transaction.
00:07:35.394 - 00:08:35.178, Speaker A: This is a very interesting aP. I suggest you read up on it if you didn't so having a gas abstraction being done by a second EOA, it's like putting a car inside the car and trying to implement some kind of spending limits for an address that still has a private key behind it is like putting a door in a field. You can still take your private key and overcome all your spending limits or anything. For those who know our work on ERC 4337, you may ask yourself, didn't we solve account obstruction with ERC 4337? And my answer to this is yes, but there is nuance. ERC 4337 right now provides account abstraction to anybody who opts into using it, but the Ethereum ecosystem and the protocol itself don't seem to favor it. And there are downsides of using a non native solution. First and foremost, it's increased gas cost.
00:08:35.178 - 00:09:46.644, Speaker A: Using user operations robbed by a bundler. It adds at least 20,000 gas overhead on top of what your transaction is doing, and often more. And sometimes it's critical for users to have the cheapest way possible, and the best one is EOA right now there is a philosophical issue of increased EVM code trust surface because entry point is a solidity code. There is a single implementation and it's like your wallet and paymasters, they need to have a full trust in it. And even though it was thoroughly audited, it's still a solidity code that you trust a lot of. Dapps don't support smart contract wallets right now, and there is some kind of censorship resistance risk because we see clearly that in protocol inclusion lists require in protocol account obstruction. So building out of protocol account obstruction is like building a house on top of an office building and getting everyone to use account obstruction while keeping the barriers is not very good for the users, many users will just give up and order for the default UA path.
00:09:46.644 - 00:10:42.884, Speaker A: And my next argument is that L2s need to take charge here and implement it first. Layer twos will be the first one to adopt many changes and they will be the ones to shape the future of EVM and Ethereum. And there is a number of reasons for that, I believe. First one is that blob and blob transactions have brought a huge scaling breakthrough to Ethereum recently for l two specifically. Another is that l two s are becoming more safe, battle tested, decentralized, and there are less and less downsides or trade offs for using L2 s. There is also now a rip roll up improvement proposal process within the AF that allows them to coordinate upgrades to their network the way eaps were used for Ethereum Mainnet and L2s are competitive. There are a lot of L2s and they compete against each other while ethereum mainnet struggles to oscillate and not to innovate.
00:10:42.884 - 00:11:39.074, Speaker A: What is inspiring is that some layer tools already today don't support EOS. They start as smart account only and they are having no issues with it being in production. We already see that the vast majority of account abstraction uses is on sidechain, so roll ups that are not on Ethereum mainnet. So first of all, we need to leave gas relays bundlers servers in the past, in ERC 4327, the account abstraction is achieved by actually keeping a bundler server who actually sends an Ethereum transaction to the entry point contract. So you still have an eoa in your account abstraction system and you are stuck with it. It is part of your account abstraction. Now what we should do is to eliminate this step and make sure that transactions are obstructed by design.
00:11:39.074 - 00:12:28.784, Speaker A: So smart contract accounts, they can initiate a transaction without any eoa being involved. A user creates an account obstructed transactions, it gets to the mempool, it gets included in a block, it gets executed. Let me remind you what steps the Ethereum transaction validations take right now. So there are five major steps. Signature verification, account nonce verification, balance verification that you have enough balance to pay for the gas of this transaction, base fee checks that you are paying a sufficient gas fee, and nonce incrementation. So if we were to write it in solidity, we could write a function like that, and that would be our validation functions. But right now it's not part of your transaction, it's part of what protocol does for you outside of the transaction.
00:12:28.784 - 00:13:11.728, Speaker A: Instead, what we are suggesting is an Rip 7560 which splits Ethereum transaction into two parts, validation and execution. So on top you see a legacy transaction, and validation is a part of the protocol defined outside of the EVM context. In native account abstraction transaction, the validation is part of your transaction. It is a code that runs in your EVM and read state writes a state, but its execution defines if your transaction is valid or not, reverts or returns invalid value. This transaction cannot be included in the block, it's not reverted. It's just not a valid transaction to be included. Like you send a transaction with the wrong signature or not.
00:13:11.728 - 00:14:03.424, Speaker A: It's not part of valid transactions yet. So an example, if you were to run this code in solidity with the terminal and you had login function enabled or something, if you were to send regular transaction, you would never touch the validation frame function. You have one frame and this is your only top frame with validation, if you call execute function, the validation has to run and it is executed, and if it returns the correct magic value only, then your transaction gets included in a block. There are three possible frames. One optional frame is account deployment. If you don't have any code deployed in your address yet for the first transaction you are making, your account factor is being called and your code is being deployed. The second step is required.
00:14:03.424 - 00:15:12.970, Speaker A: It is a validation step where your smart wallet is given the information of the transaction, including signature and fields, and it makes a check that somebody actually initiated this transaction and signed it in a correct way, and an optional step of providing a paymaster validation, which means using a separate contract to pay for this transaction. And I want to reiterate that execution frame is not some target that you call. You give this data to your wallet and it can do whatever it wants with it. It is comparable to EAP 7702. However, with true native account abstractions, there is one implementation that you permanently have in your code as opposed to ephemeral code that you can inject and gas obstruction, I reiterate here, means that can you hear me? Want to? No, still. Okay. Gas obstruction means that there is a separate contract that is acting as your gas tank and it can accept or reject the charges for a transaction that is not related.
00:15:12.970 - 00:16:20.334, Speaker A: For example, an app can sponsor its own transaction. We achieved this by creating a transaction type as most of the innovation right now in Ethereum that has some fields that are specific to account abstracted type. So you need to specify the address of your wallet because it's not derived from a signature anymore, you need to specify the contracts that you are using as entries in your transaction. So if you are using a paymaster, you can provide the paymaster and data that it will receive. If you are using a deployer, you can provide a deployer address like a factory and data for it. And you need to specify limits not only for the execution but also for the validation frames of your transaction. What does this rip mean for existing ERC 4337 ecosystem? Well, most importantly, our main goal right now is to make sure that native account abstraction is fully compatible or as compatible as possible with the existing APIs and existing ecosystem.
00:16:20.334 - 00:17:30.997, Speaker A: We fully expect that some chains will go for it and implement native account abstraction soon, while others will take years or will just opt out of it. So both ecosystems are expected to stay live for a long time and coexist peacefully. And for chains that do adopt native account abstraction, we want to make sure that they have a straightforward migration path. Also, it is important that ERC 437 bundlers keep their role in RIP 7560. We accept them to take a role of MEV searchers who will build bundles of account obstructed transactions and provide them to block builders on their respective chains. A bit of context ERC 4337 has become pretty big itself, so it includes some things that are crucial and it includes some things that are quality of life improvements. And we didn't want to pile on protocol developers, so we split the specification into multiple modules for gradual adoption and optional adoption across the chains.
00:17:30.997 - 00:18:13.320, Speaker A: So RIp 7560 is the core of the protocol. This is where the most important changes are defined, and there are like plugins for it. RIP 7711 defines a version of it that is friendly for decentralized, public permissionless mempools. 7712 reintroduces 25 six bit wide, multidimensional, non sequential nonsense. These are part of the ERC 437 specification right now, and we are also working to bring back the signature aggregation. There is an rip in draft. Right now I want to dive a little bit into the decentralized public mempool issue.
00:18:13.320 - 00:19:26.766, Speaker A: I have a couple of minutes here. So the problem with using EVM code to validate your transaction is when the block builder is trying to build a block. If your transactions validity depends on the state of Ethereum transaction in the same block previously can have an effect on your transaction validity, meaning that it is impossible to build a block because the green transaction changes the state and the blue transaction depends on the state to be valid. So now this block is invalid and you need to repeat this process indefinitely under the denial of service attack. So instead, for mempool networks you would need to split the transactions into two parts. They are not atomic and validations need to go in a separate space in the block where they are all executed together in a kind of sandbox where they not allowed to touch each other storage there is ERC 7562 that defines the sandbox and it is fully compatible with the sandbox we did for ERC 4337. Okay, there is a great talk by Vitalik Buterin on history of account abstraction.
00:19:26.766 - 00:20:33.244, Speaker A: Some AP's he mentioned account obstruction discussion started in EAP 86 two letter EAP very long ago a full fledged account obstruction was proposed in EAP 29 38. However, it used an opcode to separate validation and execution of a transaction, meaning that RIP 7711 would not be possible. We would not be able to split the transaction into two parts in a block. And recently there was a hotly debated 3074 versus 77 or two debate in all core devs that ended in 77 being considered for inclusion. For Prague update that I mentioned already allows a transaction to inject temporary code in an EOA address and execute it. What do we expect for L two developers to do right now? We expect them to get in touch, we accept them to check out the rip, to provide feedback, to check out the draft implementation of it, take part in roll calls and just build it. Build it in their networks.
00:20:33.244 - 00:20:57.014, Speaker A: An expression quote a year from now you will wish you had started today. We need to start now. We need to implement account abstraction before that is too late and some links, our GitHub where the actual text of the rip is held and our discord, which is the best way to contact us. Thank you.
00:21:04.714 - 00:21:30.734, Speaker B: Thank you so much Alexander. Amazing talk and beautifully handled technical, small technical issues. So guys, now we have some time for Q and A, let's say two three questions. So ask anything you want to the topic, of course. So if ah there please.
00:21:37.914 - 00:22:01.884, Speaker C: Hi, great talk. Quick question, I don't understand how when you create the Sandman mocks, so you validate the. Yeah, that'd be great. If you can go back. Okay, right here. So you do the validation first so that you know that these are valid transactions. But is the ordering of the execution now important? How do you, how do you figure out the ordering?
00:22:02.224 - 00:22:39.354, Speaker A: Yeah, so the ordering is important, it stays the same. So validations and executions, they do run in the same order, and there are no transactions in between here. But the validation parts of the transactions, they are all executed before the first execution of the first transaction starts. Because this code is sandboxed, it only can access the storage in itself, in the wallet or in a paymaster, so they cannot overlap. So we know that validations don't invalidate each other, but execution code is free.
00:22:41.534 - 00:22:54.834, Speaker C: So do you mean that by validation it's not validation as in is this transaction, I mean, maybe it's the same thing, valid. Does validation mean will execute that like it doesn't?
00:22:56.214 - 00:23:27.300, Speaker A: Will it be included in a block? You might want to have some extra checks in execution, frame and revert, for example, invalidation, you check your signature, nonce and general intentions that it is the right thing. But then in execution you find out that you don't actually have these tokens and then you just revert your transaction. But this transaction was valid in terms of you agreed to pay gas for it and you agreed for it to be included in a block.
00:23:27.482 - 00:23:33.568, Speaker C: Okay, so then in the execution, right, if transaction five reverts, it doesn't block the whole block.
00:23:33.616 - 00:23:41.592, Speaker A: No, it doesn't block. The validation frame remains in the block and the changes you made to your own storage invalidation block remain there.
00:23:41.728 - 00:23:42.208, Speaker C: Yeah.
00:23:42.296 - 00:23:44.084, Speaker A: And the execution did revert.
00:23:44.744 - 00:23:46.044, Speaker C: Got it. Thank you.
00:23:48.064 - 00:23:51.484, Speaker B: Okay, thank you guys. Oh yeah. Okay, one more question.
00:23:52.884 - 00:24:04.624, Speaker D: Thanks a lot. So are there any potential issues or obstacles you have thought through with relation to the execution sharding?
00:24:05.684 - 00:24:08.412, Speaker A: Could you repeat the plus if there.
00:24:08.428 - 00:24:14.404, Speaker D: Are any potential issues you needed to address with relation to execution sharding?
00:24:14.564 - 00:24:16.748, Speaker A: Like the separate, this kind of thing.
00:24:16.836 - 00:24:20.188, Speaker D: Yeah, or any, anything related to the native account obstruction.
00:24:20.356 - 00:25:13.276, Speaker A: Yeah. The big issue with that is that most transactions kind of assume that once you start, you are in your transaction and you will have to finish, but it has to change. And like ERC 437 wallets already know that this is actually how entry point in ERC 4337 works. Right now we execute validations and then we execute executions. But for native transactions, there are things like transient storage, gas refunds, warm cold storage access that are defined on a per transaction level. And then for us it is an issue. So if you write a transient storage in validation frame, you will get it again in the execution, but it's not visible in between.
00:25:13.276 - 00:25:33.054, Speaker A: So it is a kind of like strange state. But yeah, I think that because we had a couple of years to experiment with entry point and ERC 4337, I expect that many developers are already familiar with peculiarities of this thing.
00:25:34.514 - 00:25:43.066, Speaker B: Thank you so much for nice curious questions. And special thanks to Alexander Fostado. Please. Applause to him. Thank you.
00:25:43.090 - 00:25:43.774, Speaker A: Thank you.
00:25:50.114 - 00:26:10.074, Speaker B: And we'll quickly skip to the next talk. We'll stay at the account abstraction in five minutes. I'm just being sad. Okay, so let's wait five minutes. Hopefully maybe the rain will come over somehow. So, see you in four or five minutes.
