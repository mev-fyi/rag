00:00:10.400 - 00:00:25.154, Speaker A: I lined her up a few moments ago, but now the time has come for Franziska Heinthel to come and talk to you about how we're going to move towards trust minimized transactions and a transparent web three. Please give it up for Franziska.
00:00:38.034 - 00:00:54.604, Speaker B: Okay. Hi, everybody. This is the time to come back inside. I know you guys just went outside, but like, yeah, now is the time to come back inside to listen to my talk. Yeah. Welcome, everybody. My name is Franziska, and I'm with the Ethereum foundation.
00:00:54.604 - 00:02:13.186, Speaker B: And today I'm going to talk to you about trust minimized transactions and how we can create a web three experience that is hopefully more transparent and also a little bit more secure for the users. Yeah, sometimes when I do these talks, I bring this very old cover from the Economist from 2015, where the economist called the blockchain the trust machine. And I think we all have different ideas what that can mean in terms of trustlessness and cutting out the middleman and all these nice ideas about the blockchain. But what I want to talk to you today about is, is blockchain really trustless on all levels? I think we also know the bullshit in bullshit out problems and all other things that can happen when we deal with blockchains. And today I will be talking about the UX side of things and the usability of blockchain and if that really makes it trustless or not. So, yeah, to dive right into the problem, let's have a look at a typical web three interaction, how it could happen these days, and find out whether that is trustless or not. I hope these kind of screenshots are familiar to you.
00:02:13.186 - 00:03:40.744, Speaker B: I took Metamask, but it doesn't really matter which wallet you use. And here we see in several screenshots, basically that usually when we are signing a transaction, we are presented with either hex data. So when I want to find out more about what am I going to sign? So what kind of contract and interaction am I going to do? I usually when I click on data or details, I get presented with either hex data or nowadays some wallets have integrated something that is called Abi decoding, where you can see a little bit of information, but it's not really, I think, in my opinion, it's not relevant to an end user in that sense. So, for example, when I see something like function type atomic match and, yeah, I mean, you can read it for yourself, I think this is not optimal when we really want to go mainstream, full user adoption, people that are not technically minded and probably don't even have an idea what any of this is about. So yeah, I think I've been giving these kind of talks now for over a year, and web three interactions nowadays are still a yolo signing nightmare. If you're not yet familiar with the concept of Yolo signing, it's basically you only live once signing, which means you're basically signing transactions with a blindfold on. You completely trust whoever is providing this infrastructure to you that it will do the thing that you expect it to do.
00:03:40.744 - 00:04:40.056, Speaker B: So yeah, I want to ask you today, what have we done and how do we fix this mess? The talk today is a little bit of a basic recap on how sourceify works and what the problem statement and how we can, as an ecosystem together approach it to solve it. But then also I want to talk today a little bit about the big picture vision. How can we jointly push this to the next stage, which is not only relevant for sourceify, but basically all of the ecosystem partners that have to play together for this? So yeah, as we already saw in the other slide, interacting with web three contracts currently requires kind of faith and courage. Not sure if users would think the same because I think they just do it. But there are tons of trust assumptions involved when we interact with web three at the moment. Just taking this as an example, I see in the interface. So in the web two space, basically I see what I want to do.
00:04:40.056 - 00:05:24.660, Speaker B: So in this case, I think I wanted to prolong, yeah, I wanted to prolong my EnS registration for one more year. This will cost 0.003 e's. And at the time that was $5. And so basically then I would click, in the web two interface, I would click, yes, I want to be doing this. And to this point then a metamask pop up or any other wallet pop up opens up and I see this. And now I think in an optimal scenario, I could verify that what I had input into the UI in the web two space basically could verify that on the web three front as well.
00:05:24.660 - 00:06:15.888, Speaker B: But at the moment, that's not really so much the case. This is a little bit of an outdated screenshot. So with this transaction insights feature that metamask has shipped, it could be a little bit better. But about these slight differences, I'm going to talk in a bit. And so that is the point when this pop up opens up, this is the point where you should be asking questions at the latest. And these questions could be what contract am I even interacting with? Is this the right address? Are the function arguments correct? Is this thing doing what I wanted to do. Did anybody else who maybe has more technical experience than I do check the legitimacy of this? And lastly, can I consider this safe to use? Yeah, I think this is something that we can fix as an ecosystem together and it's actually not even that hard.
00:06:15.888 - 00:06:52.694, Speaker B: But a lot of ecosystem players have to work on this together and currently it's kind of in this chicken and egg issue that yeah, the ecosystem stakeholders don't really want to do the first step. So we are kind of in this blocked position. But I think in the last year we've already made a huge improvement on that front. So if we now as an ecosystem together jointly continue to work on this, I think it can really be fixed and it's not that hard. Yeah. On that point I would like to introduce sourceify. Sourceify is a community driven project which is also inside the solidity team in the EF.
00:06:52.694 - 00:07:51.866, Speaker B: And yeah, it's basically, it's a lot of things. On the one hand it's a little bit of infrastructure, which I'm going to show you in a bit, but it's also an educational initiative and we see ourselves as bridge builders who basically want to make aware or raise awareness for the problem of yellow signing and all these things that are currently maybe not yet enabling a user powered web three interaction. And on the other hand we try to educate the stakeholders and get everybody involved into solving the problem. So what we do is enabling transparent and human readable smart contract interactions through automated solidity, contract verification, contract metadata and Netspec comments. That's a lot and I will make it more easy to understand for you guys. Yeah, so the overall goal I think can be described with this image. We want to go from the left to the right or even a little bit further, which I'm going to show you then in the vision ideas later.
00:07:51.866 - 00:08:47.896, Speaker B: But basically what we want to do is really transacting, translating this really cryptic content on the left side to something that is meaningful to human on the right side without sacrificing too much on the security side of things. And in order for this to work, oh wow, that is a big emoji. We need a few components to work together and that's why it's currently a little bit complicated. So we need source code transparency and availability. We need source verification to happen. We need metadata and Netspec availability and then we need wallets and block explorers and frontends to basically leverage that and integrate with the data that is then available. And what do we do on the sourceify front to help enable this more transparent web three feature, there's a couple of, let's say tech tools and infrastructure that we provide to make it easier.
00:08:47.896 - 00:09:47.116, Speaker B: On the one side it's a verification interface at Sourceify dot de v dot where you can do, where you can verify your sources manually. Then we also have a contract repository of all verified contracts that is on ipfs. We have a contract lookup interface for the contract repository which is also on Socifydev lookup I think. And then we have the monitoring and verifier service which is actually a quite cool thing. So if you are a developer and you ever try to verify your contracts on etherscan or other block explorers, you know that it's usually quite the hassle. You have to input a lot of things like the use solidity version and the compiler settings and all kinds of things, but actually that's not really necessary. So what we built here is an automated verification tool which really verifies newly deployed contracts on Ethereum, Mainnet and testnets automatically.
00:09:47.116 - 00:10:37.304, Speaker B: So there's no need for the developer to do anything in case they uploaded their source files to ipfs. And that is because I'm not going to go into the technical details in this talk, but the idea is that the solidity bytecode has at this very end has a metadata hash which leads you, which would lead you to an IPFS address if you would have uploaded the. Or it leads you to the address and then depending on whether you uploaded your source files or not, they will be available on ipfs. And in this metadata, the solidity metadata is extremely powerful. You already have all the information you need. For example, the compiler settings used, the optimizer settings, really everything you need in order to recompile the code. And that's why automatic verifications aren't actually that hard.
00:10:37.304 - 00:11:57.344, Speaker B: And yeah, for people that don't know what solidity contract metadata is about and why, it's extremely powerful. We then also created the playground at playground Dot socify where you can basically learn about solidity metadata. We have a couple of popular contracts there where you can just click on it and experience this power of metadata yourself. And now I'm going to talk about a few of those different stakeholders or different aspects that we need to work together and explain them a little bit. Some of you may be thinking, if you're not a smart contract developer, source verification or contract verification, what the fuck and why is it important? And I think this is an educational aspect that we kind of either we have to do the extra mile to explain it to users or we kind of have to abstract it away so that they just get a sign of a check mark or big x if it hasn't been done. So contract verification is basically the process of checking whether the deployed bytecode of a smart contract equals the source code that a project has uploaded somewhere. Let's say I am uniswap and I link to a GitHub repository and say, here is my solidity smart contract code, everybody can read it.
00:11:57.344 - 00:12:58.584, Speaker B: And then they also link to a smart contract address and say, here is the deployed code. So in this sense, in this case we couldn't yet see whether this code is actually the deployed bytecode because the one is source code and the other one is compiled bytecode. And so what you do with contract verification is you use the compiler settings that this developer has also used and you recompile the source code that they claim is the bytecode. And if it's a match, that's wonderful because then you have basically the power to look into the contract yourself and check what is going on there. There's of course not so relevant for the non technical end user, but it is still super, super, super important because transparent code is in my opinion friendly code. Yeah, anybody can check the code and of course we have a couple of very brilliant developers out here. So it would be quite the bold move for somebody to actively do an exploit or something super malicious in the open.
00:12:58.584 - 00:13:59.578, Speaker B: Yeah, so this already reduces the threat of something malicious happening quite drastically. And the last thing is that we do things a little bit different than, for example, other means of verification like etherscan in the sourceify verification, all metadata and comments are taken into account. You can also read that in our documentation because I only have limited time today. But basically this is very important when we now talk about the second step, which is the code commenting in Netspec. But before that, now taking all the things into account that I just said, imagine what developers could do without us having the slightest idea. I mean, it is already happening and I think we should really make it stop because there's really no reason why this is still the case. I hope all of you now have this kind of epiphany moment and will help me spread the word about these issues.
00:13:59.578 - 00:14:38.534, Speaker B: So yeah, what is the takeaway on this? Please never interact with smart contracts that have not been published, that have not verified their contract code. If you encounter a project that you like to use and they did not verify the contract, please. It's also up to you to demand a verification to text them in their community chat or GitHub or at them on Twitter. I don't know what. Please ask them to do so. And generally I think the approach that we should take to this is really not open sourced. Smart contract code goes against the very idea of trustlessness.
00:14:38.534 - 00:15:14.052, Speaker B: Then we can may as well go back to web two, in my honest opinion. So let's look at the second part of this cluster. Metadata and Netspec availability. I know that this is also kind of a mysterious thing for many people because we always use this name, netspec. Netspec is just a short form for ethereum natural language specification format and in the end it's just code comments. So it's commons that a developer can add to their source code which explains what this source code will do. And there's different tags.
00:15:14.052 - 00:16:03.686, Speaker B: So you can add comments for developer specific documentation, you can add comments for user facing documentation and that really makes the smart contract code a little bit more rich. And this kind of comments we can then also use to, in the best case displayed to the user at the point in time where they are going to interact with a smart contract. And now we come to this kind of interconnectedness of all of these topics because source verification is great and code commenting is also great. But really the only way how we can fully leverage it is if we combine the two of them. Because if code is verified and open source but the end user does not understand it, this is what usually sometimes happens. At the moment it's not great. There's not even an emoji for it.
00:16:03.686 - 00:16:30.202, Speaker B: But yeah, that's not great because we don't know what's going on. That's the Yolo signing scenario. In the second scenario, end user understands it, but the code isn't verified and descriptions could be inaccurate. I mean, that is even worse. We don't want to trust any description of code that hasn't been open sourced. And lastly, when both come together, the code is verified and open source and the end users can understand it. That that's the perfect scenario.
00:16:30.202 - 00:17:07.004, Speaker B: That's what we try to achieve here. This is just an example of how Netspac in code can look like this is the deposit contract and the developer of this contract, I think it was, no, I'm not going to say who this was. Maybe the person wants to stay anonymous. But here basically we have the comments with all the different keywords. So it would for example be developer documentation. And that is done in the way how we would like to see it. So what's the takeaway here? Developers, please use Netspec.
00:17:07.004 - 00:18:35.230, Speaker B: To comment your code and wallets, please display the Netspec comments of verified contracts to the users. Please don't do that for unverified or not open source so where do we go from here? Little picture you already saw. This would be already a huge improvement if we could go from here to there where we would really see what am I doing? I am registering an ENS domain for one year and basically the party in the description really shows it even for users that have no idea what they are doing. And here we would even have a fully verified on sourceify or show source option for developers or technically minded people that want to dig a little bit deeper. But since this is a Solarpunk futuristic conference, I also want to look even a little bit further into the future and want to present you with my personal wish list of how I think things could be even more helpful in terms of leveraging the data. And I see there's like two layers and I would also be super interested in any UX research or any UI researchers that have ideas on how we could best abstract the information away or display it only for people that are interested in it. But how I see it is basically on the first layer of information we should have the info on has the code been verified? If yes, please link to the open source verified code in a decentralized storage.
00:18:35.230 - 00:19:38.984, Speaker B: Let's not rely again on centralized alternatives and then also the human readable meaningful code comments so that I actually know what am I interacting with here? And then as a second layer of information, now we can think a little bit more futuristic. I think it would also be nice to display something like how many times has this contract already been interacted with? Is this something that 1 million other users interacted with or am I the first one? And then maybe also relevant. When did this contract has been deployed? So is it a super brand new contract or has it been there for years? Then decoding the ABI, that's what I already touched upon a little bit. That's basically what the transaction insights feature of Metamask currently does. I think it's great, but it's not solving the purpose for end users. So this I would put in the second layer of abstraction. And then lastly, what we could also debate about is maybe including something like has this contract been audited and by whom? But I have to be discussed here because there's pros and cons about that.
00:19:38.984 - 00:20:26.988, Speaker B: But yeah, imagine this, if we had all this information at the point of signing, we would not be blind signing or yellow signing anymore, but we would actually take a informed decision about the contract interaction that we are about to do. A couple of disclaimers and thoughts and I'm running short on time so I'm trying to run through them quite quickly. Yeah, Netspec cannot be formally verified in that sense, so any comment that you can put there could be malicious. And that is why it is so important that the smart contract source code is open source so that other developers can look at it and also point out if there are any descriptions that are false or inaccurate. The number of interactions with a contract can also add a layer of perceived security. But on the other hand, we know all of these things. It's a crazy blockchain world are trickable as well.
00:20:26.988 - 00:21:27.984, Speaker B: If I have enough money I can just interact with a contract myself for 1 million times and make it feel more secure. And lastly, whether an audit has been done or not, yeah, it may add to perceived security. I think that is also something a little bit more futuristic because we should also rely on some sort of reputation system for auditors first or yeah, there's definitely more details to be fleshed out on that point. But yeah, all of these are just ideas on how to make web three less creepy for the normal end users to interact with and hopefully also contribute to a more transparent and overall more secure experience. And we all know there's always ways to trick the system. But if we work together on this and if we just like leverage the data that the blockchain and open source contracts are giving us, I think we can already go a step further than where we are at the moment. And lastly, I think we really need this mindset shift still in web three, Ux users are for the most part not developers and they may not even be technically minded.
00:21:27.984 - 00:22:20.634, Speaker B: So please give them a chance to understand and verify what's going on without compromising on trustlessness and decentralization as our core pillars, because otherwise we are no better than web two. So yeah, let's look at how this translates into actionable items. If you are a developer and if you are hacking this weekend, open source your code and make it available on ipfs. Comment your code using Netspec, use sourceify to verify your sources and metadata files. And lastly, if you're interested in that, build integrations or encourage other users or builders to do so. How can you help? I will skip this because I'm running short on time, but follow us on sourceify ease and yeah, help us spread the word about the issues of Yolo signing and how we can fix it. So thank you very much.
00:22:20.634 - 00:22:47.296, Speaker B: Sourceify is. Here's all our contact details and we are also hiring. We're looking for types script developers of. So if that is you, please reach out and scan the QR code or talk to me later. And last but not least, I'm going to hijack this session for a little announcement. We are super excited that East Berlin will be back this year. Please all join us.
00:22:47.296 - 00:22:52.484, Speaker B: This is an invitation for all of you. And now enjoy ETH Prague.
00:23:03.594 - 00:23:24.338, Speaker A: Okay, thank you very much. Franzi ETH Berlin three. That's going to be very, very exciting. Okay, do we have a few time for questions? I think maybe some questions from the audience? Does anyone have any questions from the audience? Yes, we've got a question. Two questions. Someone will come. If you could stand up for the question that'll help us all be on the same level.
00:23:24.466 - 00:23:34.144, Speaker C: So just on. Hello? Yeah. Okay. Yeah, so on a practical level, how would retrieving Natspecific from contract when the user's interacting with a proxy?
00:23:34.724 - 00:23:46.584, Speaker B: Yeah, proxy contracts are currently a problem that we are working on. So basically all the contracts need to be verified individually. And yeah, that is an issue, but it's on our radar.
00:23:47.244 - 00:23:48.144, Speaker C: Thank you.
00:23:49.924 - 00:24:04.894, Speaker A: Okay, another question from over here. Do you somehow cooperate with the harder wallet producers in order to avoid the blind signing and to push them a little bit more to actually really show what the user is signing?
00:24:05.554 - 00:24:37.134, Speaker B: Yeah, I unfortunately didn't have time to mention all the cool things that are already happening, so I now made it sound a little bit worse than it is. There's a couple of hardware wallets that are looking into various of these things, and some are even already leveraging now the socify repository. And so there's a keystone wallet, which is already doing great stuff into that direction. We've also been in touch with Ledger, so it's totally on their radar, and they are already doing quite nice experiments in that direction.
00:24:39.714 - 00:24:42.866, Speaker A: Okay. And we got another question from Makoto in the middle.
00:24:42.970 - 00:25:01.952, Speaker C: Hi. For that example, you're using Ens on metamask. So for that to happen, it's two players has to do that, Ens to verify on the sourceify plus metamask to do that integration. Is that what happened? Okay.
00:25:02.008 - 00:25:18.804, Speaker B: Yeah, so Metamask just has to, EnS has to verify the contracts on sourceify, and Metamask just has to basically go the next step to also display netspec and not only do their TX insights, and we're in touch with them, and I hope that eventually we will get there.
00:25:19.344 - 00:25:39.660, Speaker C: Second question, so to verify the source code. I'm actually from Ens, so I was just trying to verify that. But does it have to be like in the website it says just upload a zip from the GitHub, but it has to be the exact version of the time when it's deployed. Basically, it has to match.
00:25:39.692 - 00:26:01.184, Speaker B: It has to be the exact version. There's two ways or two verifications. We say a partial match. If it's not the exact version, that can happen when code comments have changed, variable names have changed, then it's a partial match, and if you have the exact version, it will be a full match. So that is, variable names are the same, comments are the same, everything is the same.
00:26:04.724 - 00:26:12.956, Speaker A: Okay, any more questions from the audience? Okay, then perhaps now there's time to say thank you very much for talking to us.
00:26:13.020 - 00:26:14.004, Speaker B: Thank you and have fun.
