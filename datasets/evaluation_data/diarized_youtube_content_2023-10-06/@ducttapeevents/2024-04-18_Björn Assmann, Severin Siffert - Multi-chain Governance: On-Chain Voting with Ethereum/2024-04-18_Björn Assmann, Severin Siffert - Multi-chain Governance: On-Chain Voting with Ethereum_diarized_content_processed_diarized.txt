00:00:01.560 - 00:00:20.662, Speaker A: Yeah. Thank you very much and welcome. Can you hear me well? Perfect. Good. All right. Yeah, so I'm very excited about this little workshop today. What we want to show is how we can work on Ethereum and the Internet computer jointly realizing multichain governance.
00:00:20.662 - 00:00:57.276, Speaker A: In particular on chain voting, connecting these two blockchains. The idea of this workshop is going to be hands on. So we start with some sort of overview. We show also you a demo that might take maybe 20 minutes or so. And then in the second half we invite you to connect to our GitHub repository and then you can download it and deploy it and play around with it and maybe even then deploy on ICP mainnet. Yeah. So I think we have, we haven't done that kind of workshop in that form yet for this on chain voting.
00:00:57.276 - 00:01:27.208, Speaker A: So we see how far we'll get. But I'm sure it's going to be fun, maybe as a quick sort of background. So we are, as already mentioned, both from the Dfinity foundation, which is contributing to the ICP blockchain. So we are Swiss, not for profit, founded in 2016. Our hq is here in Zurich, but we also have a lot of people dispersed around the globe, roughly 250 people in the moment. And. Yeah, and today it's Severin and me who.
00:01:27.208 - 00:01:31.444, Speaker A: Yeah. Want to present you like this multi chain voting application.
00:01:34.664 - 00:01:35.404, Speaker B: Good.
00:01:35.744 - 00:02:43.924, Speaker A: Yeah. Maybe just to motivate then, like, let's start with a sort of overview part. So if you look at a typical blockchain setup, you have quite often these main blocks as depicted on the slide, where you have a certain amount of information, typically the token, small clips of data which is on chain. Then you have quite a bit of logic, front end, a lot of data typically centrally hosted, for example on Amazon Web services. And then you have the users which are accessing these services again with their own devices in a decentralized fashion. So you have in the middle like this, I mean decentralized blob, which in a way compromises a bit the sort of the story of decentralization because if that is shut down or maybe tampered with, then, yeah, you can't sort of use the decentralized application anymore. That's a bit sort of the starting point for ICP, but also for the POC that we want to show you today.
00:02:43.924 - 00:03:58.794, Speaker A: And hence, like the vision is that you now connect different blockchains, you know, take Ethereum, bitcoin or any other project you might be working on and hook it up also with ICP, which is a decentralized, you can think of like this is a blockchain but also a decentralized cloud provider. So you can really run pretty much anything on it, games, you can run websites, enterprise software, you name it and then you can connect it to other blockchains. So I think a big focus is on like this multi chain aspect and all of this then forms a world computer. And now let's make it concrete. That's the idea of this workshop. So yeah, we want to connect it to a particular case study, namely on chain voting. So I mean there are many daos on Ethereum, you know, that's of course decentralized governance is a core aspect of blockchains and, but of course, like if you do transactions directly on Ethereum, that's typically quite expensive and that's why for example, voting often happens off chain.
00:03:58.794 - 00:05:10.234, Speaker A: So like there's for example like snapshot which offers actually very nice voting functionality, but in order to avoid fees, it's done off chain and then you have to bring back somehow the outcome of the result back to the blockchain, to the ethereum blockchain. And now what we plan to do with you today is to show how can you do that actually fully on chain and actually without a lot of effort, how can you make an ESC 20 based or other token that you want to set up where you really have whole voting with the whole logic and all the data on chain? Okay, so that's the motivation. So then maybe a quick crash course on the ICP protocol. I'm going to be very brief so that we have time really for, for the hands on part. So the way this protocol works is it's run on nodes dispersed around the globe which are run by independent node providers. So it's not allowed to be run in the cloud. So it's really a physical high spec server, standardized.
00:05:10.234 - 00:06:09.576, Speaker A: And in order to achieve scalability, not everything is run on all nodes, but you have some charting going on which in the terms of ISP protocol is called subnets. So you have subgroups, you partition the network and these different subgroups are able to communicate in an efficient way. And then on top of these different groups then you can run smart contracts called canisters in our terminology, where as I mentioned before, you can run pretty much anything. Really think about a decentralized cloud service. Yeah. And that's then brings you a big virtual computer now and it's relatively cheap and efficient to run stuff. So I mean just to motivate a little bit.
00:06:09.576 - 00:06:50.278, Speaker A: So if you want to store 1gb of data on chain for one year on the Internet computer that cost you $5. On Solana, roughly $110,000 and on Ethereum, much more, of course, depending also on gas fees, which might vary. And that's, I mean, yeah, and that's why, you know, you can, for example, host a complete frontend on the Internet computer because it's much more. Yeah. Now maybe some key features. So you will see it later. With the application that you are going to deploy, you can interact them with a normal web browser.
00:06:50.278 - 00:07:25.422, Speaker A: We don't need any particular setup. A normal browser would work. You can access from your phone or from a laptop. And these canister smart contracts then can run web pages, enterprise systems, defi applications, games, et cetera. One particular aspect actually is what we call the reverse gas model. And here the idea is that if you as a user start using an app, you don't need any tokens upfront. Rather the canister is pre charged with cycles, which is the equivalent of gas.
00:07:25.422 - 00:08:32.444, Speaker A: And then only when you start using maybe more premium features and so on. At some point you might have to pay something, but sort of the entry barrier is very low because you have like this reverse glass model that allows you to use stuff straight away. Yeah. And maybe to bit explain how that works under the hood. So when you talk to the ISP blockchain, so called chinky cryptography, optography is used and that means like if you get a message from the, from the, from the, from the ICP blockchain, it's signed with a single public key of that blockchain. And the way, the way that works under the hood is actually that not like the different nodes that underpin the network. They all have a shared part of that key and only collectively, you know, if they, a certain portion of the nodes agree, they can sign together and confirm a message with the overall public key.
00:08:32.444 - 00:09:22.454, Speaker A: Yeah. And now also bring it a bit closer to Ethereum, like the same thing. Work also with elliptic curve keys, ECDSA keys. So a canister that is run smart contract is run on the Internet computer can sign ecs a keys. And again, it's the same principle. No single node will have the full key and can, for example, run away with the linked assets or so, but rather only collectively can these nodes using threshold crypto sign messages. And that's quite cool because ECSA keys are useful for signing financial transactions.
00:09:22.454 - 00:10:14.638, Speaker A: That means these canisters can own crypto tokens, canisters can own bitcoin, they can own ethereum, et cetera, et cetera, and they can sign transactions and they can also use HTTPs out calls to communicate with other applications. And that makes this setup quite powerful because you can embed then logic in these smart contracts, triggering actions elsewhere and hence you can facilitate a very powerful multi chain setup. Yes. So let me then, I think that was the very brief crash course. And if you have. This was of course very brief. If you have more questions and so on now, very happy to have a chat also later on.
00:10:14.638 - 00:10:57.728, Speaker A: But let's more focus now on the, on the PoC. Right. And the hands on stuff for the multi chain POC that I mentioned how the way that looks actually is we have implemented very simple a set of canisters which you see on the left hand side, a front end, a back end canister. And also like what you see here, like this RPC canister which is responsible for talking to the Ethereum blockchain. And we use another canister for the metamask login. But these are all very small, very contained. The code that we added is quite contained.
00:10:57.728 - 00:11:32.824, Speaker A: And then as you can see, if you, if you like the voting, the logic and so on happens then 100% on chain and then the RPC canister and you will see that also now in a minute. Then from time to time actually queries the Ethereum blockchain for certain data. And the way it does actually is it talks to a couple of providers listed here, like alchemy anchor and so on. And that decentralized fashion are several of those. And then sort of combines the received results from them to come back with a result to your application.
00:11:35.964 - 00:11:36.276, Speaker B: Yeah.
00:11:36.300 - 00:12:07.064, Speaker A: And you can talk to Ethereum, mainnet or Sibolia that both works. Yeah. So here is a link to the application, I think. So you need a metamask login, so you probably need to run it on your laptop. But I can also show it to you if you only have a smartphone. I included the QR code here that you can scan it and then also can send it to yourself if you want to run it directly on your laptop. But I can also show it to you directly.
00:12:07.064 - 00:12:41.516, Speaker A: So let me switch. Actually, maybe before I start with the demo, are there any questions, any comments in the moment? Anything urgent somebody would like to understand? Okay, no, it's good. Then let me show you the way it works. And this is now the application that you're also going to put your hands on in the second half of the workshop. So you see that's the web page. It starts. So it's a multi chain governance thing.
00:12:41.516 - 00:12:59.374, Speaker A: You can now sign in here and it will now connect to my. To my metamask. And so I will do that. And I will sign in now. And now I'm. Wait a little bit.
00:13:00.314 - 00:13:00.882, Speaker B: Okay.
00:13:00.938 - 00:13:19.014, Speaker A: Demo effect. Yeah, I see, I see. Okay. Yes. So we have. So you must be. Are you Christopher? Huh?
00:13:19.094 - 00:13:19.542, Speaker B: Yes.
00:13:19.638 - 00:13:33.270, Speaker A: Yeah. Hi, Christopher. Nice to meet you. Yeah, he is actually. He is like, I mean, I had like the slide where we talked about like this, the one canisters, which called CV, which is like, for the login that was written by Christopher. Many thanks for that. Very useful.
00:13:33.270 - 00:13:52.714, Speaker A: So we used it directly for this prototype was super useful for us. Okay, so. And thank you for your comments. Like, let me try again with Christopher helps. We should now be able to login. There we go. All right, so you see now.
00:13:52.714 - 00:14:57.618, Speaker A: So for the time being, what happened is just like, I logged in using my ethereum address, and it's now linked also to a principle, like an identity that lives on the intercomputer. So, like I said, now I have sort of built up a session that's thanks to Christopher's work, where I have this connection between an identity on the inner computer and an identity address on Ethereum. So that's very nice. And now we are in our little voting application. And now I can show you what we can do here. So I can submit a proposal, for example, and say, yeah, I mean, motion on motion number six, for example. And then, you know, let's give a beer to Christopher because he was nice to help me.
00:14:57.618 - 00:15:34.984, Speaker A: So. And you could think about, like, you could also have different kind of, in our proposals here. You could maybe have token transfers or whatever else your particular dao on Ethereum would like to decide on. I mean, I think that's just an example here, which is easy. So it's just a motion proposal for the time being. Now I click on submit proposal, and now what happens is like this spinner here in this moment, the application is now, which sits, is hosted on the blockchain. ICP shocking, talks to Ethereum sepolia and says, okay, by the way, I want to have a proposal here at that timestamp.
00:15:34.984 - 00:15:56.972, Speaker A: Please tell me what's your current block height? And you see now here we have now the motion number six. It's now recorded under the set of proposals you can vote on. You can see that it was me here. This is my Internet identity. This is my Ethereum address. The same stuff you can see here on the top. So I was the submitter.
00:15:56.972 - 00:16:33.290, Speaker A: But you can also equally, if you log in there, you could also see the same kind of proposal. And now I can vote. And the key thing is now the block height that was determined at this particular timestamp here is now the time for which the token amount is counted. What we decided here for the little demo is that we use Sepolia ETH. So the more sepolia ETH have, the more voting power I will have. And so I can, you know, since I'm a big fan of Christopher, I say, yeah, perfect. Now let's, let's give him some beer.
00:16:33.290 - 00:17:13.586, Speaker A: So I vote yes again. Now in this moment, the application is talking to Ethereum sepolia and is essentially asking for this particular Ethereum address. How many sepolia is do you have this block height? And you see now it determined that I have a certain amount and now that amount is allocated to the yes camp and other people now in the room are invited to vote as well. Right. And that will then change Italy over time. And then in the end we can sort of agree or disagree with that particular motion. Right? Yes, please.
00:17:13.730 - 00:17:15.134, Speaker B: Where is the snapshot?
00:17:16.914 - 00:17:51.846, Speaker A: Good question. So there is no snapshot like that would be. That would be a potential enhancement. I mean, what we do in the moment is we always query sepolia on the fly, but we give the query the block height so that it's really clear that you can't vote twice by transferring tokens or. So personal enhancement would be at the proposed submission, we make a snapshot who has how much sepolia. Then we also know the total supply, etcetera, store it on ICP. And then when somebody votes, you just look in the cache instead of querying sepolia again, just to keep the code simple.
00:17:51.846 - 00:18:34.944, Speaker A: And also, since we only spent a few days on it in the moment, we query it on the fly. Yes. So I think that's actually what it is. I think it's a very simple demo, I think, but it really shows you how to build a bridge between Ethereum and the Internet computer. And then you can connect these two worlds and do, for example, realize a DAO voting application or maybe something else. I think it's relatively powerful because you now can do a lot of logic that might have happened before off chain. You can do it fully on chain.
00:18:34.944 - 00:19:03.816, Speaker A: All right, so I think that's all I wanted to say up to now. Did I forget anything? Ah, one more question. Yes, please. The proposal, you mean? Yes? Yeah, yeah. I mean it's. Indeed it's not. So I think there are actually two more things we could do with this POC.
00:19:03.816 - 00:20:11.684, Speaker A: Right. First, we could have other kind of proposals which are even more concrete, for example, to say the DAO decides whether we want to send you ten polyath, for example. And then you would, as part of the proposal, specify the address, and then when the proposal is executed, then the transaction is automatically triggered. That would be like one way to do it. And in addition, I mean, what we didn't implement yet, but also I think the national extension is that you could, for example, have a timer here that says a proposal has a duration of, say, four days, people have time to vote on whether Christopher should get its b or not. And then after four days the tally is closed, and then the result is actually written back to Ethereum. I think what's already, what's done, I mean, I think seven just did it, I think yesterday or so you can, there's already a backend call where you can say execute proposal, so that writes back the result of this to our Ethereum smart contract that is configured in the backend.
00:20:11.684 - 00:20:18.366, Speaker A: But we didn't, I mean, I didn't actually, to be honest, I didn't have time yet to kind of include that also in the frontend.
00:20:18.560 - 00:20:25.694, Speaker B: I'll show you afterwards when I hook up my laptop. Cool, thanks. I need to code another one.
00:20:41.674 - 00:21:14.484, Speaker A: The backend could have a periodic task that checks, for example. Okay, are there any proposals that are past the four days? And then if it's true, like you close the proposal, and then this back end canister already executes an instruction to Ethereum and says, please write back or execute the token transfer or whatever, please write back the result of the tally to your Ethereum smart contract. So you don't need an admin. That's the cool thing about it. Yeah.
00:21:15.384 - 00:21:37.944, Speaker B: Did that miss your question or was it. Yeah, so the canister itself. So the smart contract on ICP has an address on Ethereum, and I send some ETH to that address, so now it can use those ETH to execute those transactions. Is that what you meant?
00:21:43.404 - 00:22:22.850, Speaker A: Right. Any other questions? No? Cool. Okay, then I think, let me share this again. So there's one more link now, like for the, let's now get our hands dirty. Here's the GitHub link. I mean, either you can type it or again scan the QR code and then send it maybe to yourself so that you can exit this. So the idea is really to you go there, then you will find a readme which has install instructions and we can all go around and see and help you.
00:22:22.850 - 00:22:37.674, Speaker A: And the idea is you can have a look and go through instructions step by step, check it out, get it deployed locally, and if you have time, even maybe deploy it on the ISP mainnet.
00:22:38.254 - 00:22:47.314, Speaker B: And for those that don't have a computer here, I will show you on the big screen, of course, otherwise it gets a bit boring for you.
00:22:47.934 - 00:22:52.474, Speaker A: Cool. All right, do you want to have this thing here?
00:23:15.394 - 00:24:11.624, Speaker B: Okay. Is the microphone working properly? No reaction seems to be it. Wonderful. Okay, so here for your question, can we write the result to Ethereum? Here I have a very simple storage contract. It just stores the last ten strings that were submitted. Nothing too fancy. This is the proposal that Bjorn just showed.
00:24:11.624 - 00:24:50.274, Speaker B: I voted on it as well. I voted against it, and then I told the backend to execute that. And here is the result on Ethereum or cipollia in this case. So let's go to the practical part. This is the repo. Please clone it and then goes to the runbook and start working on it. First step is to get some sepolia ETH if you want any.
00:24:50.274 - 00:25:31.974, Speaker B: It's the most convenient faucet I found. It makes you solve some proof of work or your computer. Just start mining a bit and in a minute or three you should have enough to do everything we do in the workshop. If you don't want to deploy your own storage contract, you can also use the one that I deployed and just showed you. That works just fine. Then you don't need to get any zeppeli es yourself. So, first step, install DFX.
00:25:31.974 - 00:26:27.734, Speaker B: DfX is the command line tool that we use in the ICP world. It helps you manage your smart contracts, your gas, you can use it to create, to call your contracts. It's just the tool you use for everything. Don't quite know how far you guys are. I'm just gonna talk a bit more. So, the installer, in case you're wondering, because curling into shell is always a fun experience. It's based on the rust app installer, and if you want to analyze it, you will find a lot of similarities.
00:26:27.734 - 00:27:22.834, Speaker B: Did I not add that last instruction? Let's fix that. After installation, you may have to run DFX VM, update the effects VM, the version manager, is the thing that actually gets installed and DfX VM updates, then installs the latest version of DFX. Sounds a bit complicated, but turns out it's the easiest way to actually get it running for us. I'm on the SDK team, so I actually work a lot on the effects. So if you have any complaints, yeah, I'm your guy.
00:27:26.534 - 00:28:01.974, Speaker A: Maybe we can just. Quick poll. I mean, the first step in the instructions is to get some superior ease. If you don't have it, is anybody stuck there or is it fine. And the next step then would be installing DFX. So is there any question there anybody who's stuck? I mean we can also walk around and you know, have a look if you're stuck in a particular step. Everybody happy?
00:28:04.314 - 00:28:49.214, Speaker B: Okay, I'll continue then. This defect start is how you start your local instance of ICP. This will spin up one single replica on your machine. So you don't have multiple subnets. But a single subnet is plenty for this case. It doesn't run on, or sometimes it's broken on WSL, on windows it doesn't run at all. So if you are on windows then you need to deploy straight to Mainnet.
00:28:49.214 - 00:29:06.190, Speaker B: If you need any codes for gas, I have some here. If anyone needs, just yell at me or come here and get a code. There's instructions for Mainnet down here.
00:29:06.342 - 00:29:37.694, Speaker A: Yeah. And just to be clear, like the, like the gas, like if you, you only need this gas cycles if you want to deploy on mainnet. So maybe, I think the first step, if you just want to run locally then yeah, we would, that would be like already a great achievement. Can I, can we make a poll like who is like who has DFX installed? Perfect. And the others do, are you, do you want to do it or you're still in the process of doing it? Is there somebody who needs help?
00:30:01.094 - 00:31:16.204, Speaker B: So I'm gonna now do the same thing here. Just stopping the current replica in case I still have one running. There we go. That's one of the complaints you probably could have. Okay, I now have a local replica running and now I can deploy the whole project here. We wrote a makefile for all that because the commands are really annoying to use the first time around. This is for example how you install the login provider.
00:31:16.204 - 00:32:11.280, Speaker B: Just as a mini overview, you say deploy. This is the name of the canister you want to deploy. I'm telling it where in this case automatically on the local network. And then we need to give it some arguments for installation. Those init arguments are so that we don't have to compile everything. Again, if we want to change a few small things. It takes a while, but as you can see, first it creates the canisters and then it installs the RPC canister.
00:32:11.280 - 00:33:29.444, Speaker B: That's the one that actually makes the requests to the Ethereum RPC providers. And yeah, here it builds the frontend, uploads it. And once that is finally uploaded, we can look at it. Front end uploads take quite a while, usually, especially on Mainnet, because there's just many different transactions to execute on chain, but we can't do much more to speed it up. Okay, here we go. Now we have the frontend running locally. Here we are on localhost and I'm gonna connect here and then sign in.
00:33:29.444 - 00:34:58.234, Speaker B: And here you have the interface. Anyone progressing here as well or are you stuck with other parts? So now if we want even the local backend to be able to create transactions on Ethereum, we need to give it some ether. It is not the same account as the mainnet deployment because it doesn't have the same private keys. So we need to ask it for its Ethereum address. I'm going to know, to give you all a bit more time, I'm going to show you how this works here. We call our contract on ICP. We call the backend and a function called get address.
00:34:58.234 - 00:36:00.074, Speaker B: This ends up here. And I try to put roughly what you would write yourself in the lib Rs file. And everything else is relatively standard stuff that you can mostly copy paste. So you probably wouldn't have to write this yourself. You may want to clean up the code a bit because I wrote it for simplicity and not necessarily for correctness. But yeah, I do some caching because making that call all the time takes forever and I'm not that patient. But you can ask ICP for your canister's public key and then you need to do some encoding wrangling because yeah, different chains use different formats.
00:36:00.074 - 00:37:05.484, Speaker B: Of course nothing can work the same everywhere. And then we just turn it into an ETH address. And this is the address that we got back. I'll send that a few zipolar ethnow just to demo it. Point one should be easily plenty. And then I'm going to go here and make just a dummy proposal and then I'm going to vote on this one. This hits, where is it? This hits the vote on proposal function.
00:37:05.484 - 00:38:25.354, Speaker B: In the backend we send along the proposal id, which is the one you see here, and, and whichever we voted, and to figure out who sent that vote, we see who made the call. Every call to ICP is signed by either the anonymous identity, which everyone can use, or some other identity. In this case, my backend sees this identity here. This is what you get with the caller. We then ask the sign in provider which Ethereum address is linked to that. So here we get for the voter, the ETH address that we actually logged in with how that exactly works, that mapping, Christopher would be the man to ask how the mapping works. If someone has questions about that, they should talk to you.
00:38:25.354 - 00:39:10.874, Speaker B: Best I can do is point to you. And then we ask what is the ETH balance? This is a function that you probably only have to clean up and not write yourself. But here's roughly how it works. You can make a request to the RPC canister for that, you send it some gas. That's the cycles in ICP. And here we have a JSON RPC request. We don't need to sign it since it's only reading the state and not actually submitting a transaction.
00:39:10.874 - 00:40:10.872, Speaker B: This is copied pretty much straight from the documentation. And here's how we do the snapshotting. We just have a string saved that contains the block height when the proposal was created, and then the RPC provider makes sure it uses or it checks at the correct block height. Since we don't quite trust a single one, we can here add multiple RPC providers if we want. So we can check do they all agree? And if they give different answers we can either log an error or we can say we just take the majority of them. Whatever you guys need for your application. We then decode everything.
00:40:10.872 - 00:41:10.936, Speaker B: Need to do some data wrangling because nothing is easy. But then we get back natural number, I convert it to a net because that's just the type we use in ICP land. Yeah, it's the equivalent of U 256 in Ethereum land. Once we have the voting power we just save the vote. That's nothing too fancy. I'm not going to walk you through all that, it's just rust. And then I bet yep, that has been sent.
00:41:10.936 - 00:42:05.764, Speaker B: So just to make sure, I'm going to check if it actually worked, just ask the backend to request its own balance and that looks good. So now we can execute that proposal. I didn't put any authentication in front of that just to make it easier. Yeah, I wouldn't recommend you do that on a real voting application, but that's all fine. Not sure if that is enough. Yeah, looks fine. I don't need to format the one a bit nicer.
00:42:05.764 - 00:43:31.642, Speaker B: In ICP world we use an encoding language called candid. For anything more advanced than just this basic call we would have to format it a bit nicer, but it's smart enough to interpret that correctly. So we get back a success and an Ethereum transaction hash. And this is the transaction that is submitted. And if we go back here to check, we can see now this is the vote that we executed, I just made it as short as possible to save some gas. But this is the canister id BK Y z two. That's the address of the backend, so you can see that it comes from that proposal one and 100% yes votes matches this here cargo tunnel.
00:43:31.642 - 00:43:39.054, Speaker B: Of course. No, that's. That's probably the one you're more interested in.
00:43:43.634 - 00:43:47.334, Speaker C: Are you like, able to run any arbitrary rust code?
00:43:49.134 - 00:44:36.874, Speaker B: Yeah. Question is, how can we run any rust code we want? Not quite. We run on WASM 32 environment. There's work going on to make it WASM 64, so we get some more address space, but it is a very plain environment. We have some special calls for which we have the IC CDK, for example, to make calls to other canisters. But, yeah, we don't have random numbers provided to you because that's hard in the blockchain world. Yeah, but if you can run on pure WASM 32, you can do anything.
00:44:38.354 - 00:44:40.934, Speaker C: Anywhere or just to the ethernet.
00:44:41.674 - 00:44:43.014, Speaker B: RPC calls.
00:44:43.634 - 00:44:45.294, Speaker C: Could I make RPC calls?
00:44:47.114 - 00:45:47.128, Speaker B: So if the RPC provider supports Solana, then yes, which I think it does. But right now we don't have schnorr signatures implemented. Work is ongoing right now, and I think it's expected Q two or Q three, and then you can actually sign Solana transactions securely. Right now you would have to have the keys in your canister state, which data is not public, but technically the node providers can still read your state. There's work going on to stop that, but yeah. Yes, we can sign with ECDSA. Okay, let's check.
00:45:47.128 - 00:46:23.314, Speaker B: Yeah, yeah. If you want to deploy your own Solana. There we go. You talking about Solana? You can also deploy your own contract to Sibolia. For that. We have the file here, solidity contract. Sol just throw it in, remix, then compile with the green button, of course, and then deploy using the injected provider.
00:46:23.314 - 00:47:26.968, Speaker B: So you target sepulia. Then you get down here, the deployed contract, and you can copy the contract address, go to librs and replace the target contract with that, and redeploy. Then your canister knows which. Which contract to call. Okay, how's that going? Anyone have any problems? They run into some things that are not quite clear. I know it's a lot of information at once, but the main things I wanted to show you we've gone through. Now we have either time for questions.
00:47:26.968 - 00:47:45.214, Speaker B: We can do some mainnet deployments if someone is interested in that. As I said, I have some gas here, or we can turn it into a generic q and a about ICP, whatever you guys want to.
00:47:46.674 - 00:48:13.034, Speaker C: If I understand that correctly, the transaction which is executed on the Ethereum side is like permissionless. You don't need to, anyone may execute this transaction if the transaction needs to be authorized by some particular addresses. So you say that it's possible to sign the Ethereum transaction. What would be the change?
00:48:14.094 - 00:49:15.700, Speaker B: Right, I totally skipped over that. How do we execute the proposals? So right now I allow anyone to call execute proposal, but that is very easy to get behind, either whoever created the proposal or just after a certain amount of time. On ICP, you can have timers so you can autonomously wake up in five minutes or two days and then run a transaction. So you don't have to have anyone call your function for that. So yeah, once this function gets triggered, we just read the proposal, and then I generate the summary string. Here you can do whatever you want, of course, make it more than just storing a string. But then to create an ETH transaction, this is actually all you need to do.
00:49:15.700 - 00:50:36.084, Speaker B: But in the background we parse the API. So over here we import the JSON schema of the target contract. We compare that, it actually matches the right arguments, and then we sign a transaction. What this does is it generates an ethereum transaction according to the RPC specific. And then here goes deep into the call stack, it asks ICP to sign the transaction hash with the canister's private key. Then all the nodes in the subnet do their thing and out comes a valid signature. And only if your canister allows someone to access that, then they can actually execute those transactions.
00:50:36.084 - 00:51:30.414, Speaker B: So anywhere in here you can just say if the color does not match this or whatever, what you can even do is here you can provide a derivation path, meaning you can have arbitrarily many different private keys in your canister. So you can have a different Ethereum address per user. Of course, then it's on your canister to do access control to these sign calls. But you can actually separate funds by the users or a group of users if you prefer that. Yeah, your imagination or your coding skills are the limitation for that.
00:51:31.954 - 00:51:33.814, Speaker A: Are these contracts upgradable?
00:51:34.634 - 00:52:43.924, Speaker B: Yes, that's, yeah, that's so second nature to me. But for people coming from Ethereum or many other chains, that's very unintuitive. On ICP, smart contracts are upgradable by default. So if I say, for example, I don't know, let's change this string, then you can observe it. Actually in practice, this will now rebuild and just change the running code I actually didn't tell it to persist whatever proposals you had. But you can store data through upgrades. You have up to 400gb of that storage available.
00:52:43.924 - 00:53:46.968, Speaker B: Yeah, you can always upgrade your code, unless you say this smart contract is now, it has no controllers anymore or yeah, that's what we call admins in ICP land. If you delete all controllers, then the contract is not upgradable anymore. So that allows verification that you are yet. Then you can show how you build the code. You can always check the hash of the installed code, even though the code itself is not public. But then you can trust that it actually does what it's supposed to now executing that transaction. So while that's running, let's see if I missed anything here.
00:53:46.968 - 00:54:37.664, Speaker B: Yeah, you have the signed transaction and then you call the RPC canister. In this case we tell it to use three separate RPC service providers. And since I'm lazy, I just told it, if only if they all agree, we output the result. Otherwise I just say screw that, something went wrong. Again, simplicity over correctness. So we get back again. Transaction id I'm not going to look it up, but here now we have proposal signed by the ah, maybe that's why I should show you this.
00:54:37.664 - 00:56:11.014, Speaker B: This is the new transaction that we created. As you can see the from eight D, seven C, and here the previous transaction that we created, same origin, so the private key stay the same, even through different versions of the same smart contract. Any other questions, problems? Complaints about DFX? Okay, I think then we can start wrapping up. Let's see. Yeah, here we have a few more closing slides. What now you can use a bunch of languages on ICP to do whatever you want. So far I've shown you rust, but we also have Motoko, a special purpose language for ICP, which makes it pretty simple to work with all things specific to ICP.
00:56:11.014 - 00:56:52.080, Speaker B: Maybe to show you why that's maybe useful. This is how we manage state in our rust canisters. We use thread local, which basically means a global variable. It's not very nice, but canisters are single threaded, so it just works. You have to do this to create data structures that persist through updates and then use it like this. It works, but especially if you don't know rust already, it's not that nice. For that.
00:56:52.080 - 00:57:51.934, Speaker B: Motoko is a much better fit then. We also have great people working on JavaScript, typescript or python libraries to develop your canisters. The JavaScript one actually runs a full JavaScript engine in the canister, and you upload your code, I think after installation I'm not even sure. Probably not. Here's where you can get started. First link is our main documentation. Second link is where we have a nice zero to hero series where you start with very simple topics about ICP and then slowly build up and get into more and more complicated parts.
00:57:51.934 - 00:58:43.284, Speaker B: I'm not sure if they already go into EVM calls, but if it's not there it will be added pretty soon. And then last we have the forum. That's the place I suggest you go. If you need any help, you will find me there basically every day. Then this is how we see it. Smart contracts will grow more and more useful whenever people notice that things go down or get taken down. And if you can run arbitrary code on the blockchain, you will have much fewer problems.
00:58:43.284 - 00:58:59.104, Speaker B: And that's what we have. Thanks for paying attention. If you have any more questions, come talk to us. We also have small booth outside. Hope to see you then.
