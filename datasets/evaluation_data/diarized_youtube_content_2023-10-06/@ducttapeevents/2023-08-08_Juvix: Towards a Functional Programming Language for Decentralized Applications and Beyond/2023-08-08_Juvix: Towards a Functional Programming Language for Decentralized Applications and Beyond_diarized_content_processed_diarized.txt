00:00:00.560 - 00:01:13.434, Speaker A: Hello everyone, welcome to the talk about jewics toward functional programming language for decentralized application and beyond. My name is Veronika Ramashkina and in today's talk I want to introduce Jewic language to you, explain its main goals and main features that language suggests, and also we will walk through the compilation pipeline and what role it plays in writing decentralized application, specifically writing arithmetic circuits for zero knowledge proofs. I will explain which is the current state of the language and what ongoing process of creating new features we have in mind for that. And yeah, let's start. So Juvix is a high level programming language with a strong type system. Its goal is to write privacy preserving decentralized application. And we're also focusing on privacy and security a lot, and also on efficient compilation processes to low level languages such as C and LLVM.
00:01:13.434 - 00:03:02.914, Speaker A: We also focusing on deploying this application smoothly on Anoma or Ethereum. Anoma is an intent centric protocol. You can think of a Noma as a system where user can do transactions, and in order to write such application you need to introduce few concepts in your application, such as transactions themselves, some of the resources concepts, and also describe some constraints on privacy and security that such system would have. Then your application, your application would change the state of the system by providing this action that you described, and it also will depend on the input for the program and on the existing privacy constraints that you have on the program. And when we wanted to create such application with a current existing solution, we faced a few limitations that we were not satisfied with, such as most of the programming languages existing. They are not focused on writing decentralized application per se. And specifically they are not focused on features that important for us to write application in a normal protocol, especially not specialized in in privacy security, in handling complex consensus algorithms, or working with on chain and off chain interactions.
00:03:02.914 - 00:04:21.094, Speaker A: Also, even if the languages are created for decentralized application, not all of them have that level of scalability, performance and maintainability that we needed, and also the problems that they had locked in back ends, and we wanted the solutions that would be more flexible in that. And another focus for us was efficient development process. So with all that in mind, we created our own solution language, Jewix. And to summarize all I said, here are the goals of the language that we created. So first of all, we are focusing on deploying these applications on anoma, and we also wanted to be very easy to write for developers and the process should be as smooth as possible. That's why Guix is created as high level language with a very efficient tooling for developers. We also want to focus on privacy and security and provide necessary abstraction for developers to write such applications.
00:04:21.094 - 00:05:07.524, Speaker A: And again, we want it to be scalable, performant, efficient and maintainable and developer friendly, considering all that I said before. And another important aspect for a normal application would be flexibility in backends as well. So we created this language and here is the team. Meet Paul, Jonathan, Lukash, Christopher, me, Veronika and Jan. Most of our team are here at the conference, so you can find us at the normal booth. So come speak to us any moment. Now let's speak about how you can actually use Jewix language.
00:05:07.524 - 00:05:54.210, Speaker A: So first of all, Jewic language can be used to write zero knowledge proofs. Zero knowledge proof plays a crucial role in decentralized application. It allows parties to prove the validity of statement without relieving unnecessary information. And with that you can use that to write systems such as secure voting system or private transaction on blockchain. So it's very important. And here is a scheme that can demonstrate which role juris can play in that. So juics is high level language, so you can write your application using the language.
00:05:54.210 - 00:07:18.994, Speaker A: And as it's flexible in backends, one of the compilation target would be vampire, which is in house language we use in anoma for writing arithmetic circuits for zero knowledge proofs. And a vampire being a flexible language itself, it could compile to the different proving system backends such as halo two or plong. So basically writing one application using high level Jurix language which is effective and quite flexible for developers to work with and to create their types and business domain in the language. You can actually get the approving system you need. But in general you can write any decentralized application using Jurik's language. And another example could be uniswap like application which is swap and trading platform for your tokens. Or it could be opensea like market for NFT on a normal protocol and basically any decentralized application you can think of as well.
00:07:18.994 - 00:08:28.604, Speaker A: So now we understand better how we can use that. Let's speak more about highlights of the language features. It's functional language, which is quite important because we believe that language being functional provides a lot of security by design because it eliminates a whole layer of errors and bugs you can introduce. And I will explain more on that on the examples will provide as well. But yes, the idea is that it's important that we decided to go with a functional language. And here you can see the example program written in Jewix it's a program that describes the balances. Here we introduce the balance abstraction and some operation you can do with balances such as add balances together, create the empty balance, negate the balance, or subtract different balances.
00:08:28.604 - 00:09:34.992, Speaker A: And let's look closer to what's written here. First, what you can notice is that syntax is similar to Haskell or Agdalike syntax. It's because we take a lot of inspiration from those languages. And if you already familiar with functional languages, it would be very easy to follow the syntax of Juvix. But if not, this syntax structure is quite easy to follow and read another main feature of Juvix, that it's strongly typed language. So you can see that every function and everything is predefined with type signature, which actually gives us a lot of of information about what this function can do. For example, if you look at line seven at add balance function, you can see that it's already says that it will take two balances and will return us another balance.
00:09:34.992 - 00:10:38.890, Speaker A: So it can serve us as a documentation itself. But not only that, we have built in primitive types, we can also introduce custom data types. And in this example we see that on line one the balance itself is custom data type that we introduced in here with a type keyword. And basically it represents the list of the pairs of denominator and quantity together. And you can work with that. It's very handy because you can actually represent all your business logic in the type system of your applications that you need. Another feature I want to highlight is polymorphic functions, which means that you can write very generic functions that would work with different data types in different abstraction.
00:10:38.890 - 00:12:01.514, Speaker A: That would mean that you can write less code and work with any type that you need in your system. And if you look at line 15 in the negate balance function, we are using map function. That could be the example of such function, polymorphic function, because it doesn't care with which container it would work with, it can actually change the inside of any container, not depending on the type that container contains inside. And we also have higher order function, which means that our function can take another function as arguments or return functions. So again, if we look at the same map function, we see that the first argument is I actually the function that it takes. So we don't say how we need to change every element of the container, we just provide one function in order to say how to apply this function to each element in the container. So another thing which is very important in development of jukes is referential transparency.
00:12:01.514 - 00:13:32.014, Speaker A: Referential transparency means that each expression can be replaced with the corresponding value and the output will never change. So if we for example create two balances, as in example one b one and b two, and use add balance function with them, or we just directly use addbalance function with function run of balance, it will make no difference. It will work the same each time we run that. It's very important because we will have the predictable behavior of the program each time. So it gives us opportunity to reason about the effectiveness of our application or the outputs of our application as well. And Juvex being the in house language that we are creating means that we can take the best of any existing languages, so we can integrate all the best features that we think will be best for creating decentralized application and have it implemented in Jurix itself. So currently from the functional programming we are using purity, totality, immutability, pattern matching.
00:13:32.014 - 00:14:35.932, Speaker A: Pattern matching means that the function could decide which actions to run based on the pattern of the inputting argument it has. And now let's look from the perspective of Juvix project for developers. So first of all, Juvix has a model system. So each Juvix file is a model, and Juvix project actually contains one or more Juvix models. Inside here you can see the example of such models which is specified with a model keyword. And inside each model we can also import all other models. It could be either from the same project that we just implemented, or it could come from the dependencies of the project which could be separate juice projects that you can use inside your application as well.
00:14:35.932 - 00:15:52.382, Speaker A: You can see online, for example, eleven and twelve. There are examples of both such imports. One is from the standard library and another from another data CMP model of the same project. Another thing that we can do with models is to re export it from the existing models, so we can provide a more more beneficial way for users to use our library or application by specifying the right export output of the model. Also, we have a local model system, so it helps to separate the internal logic from external logic of the application. So if you need some implement some internal details inside the model, you can do so without leaking these details into the whole application or other models as well. And with that in mind, we can have the nice testing system implemented provided through the testing libraries.
00:15:52.382 - 00:17:02.750, Speaker A: And here we can see example of how we can implement testing our balance model with the usage of jurik test libraries. We have the libraries for both implementing unit testing or property based testing as well, and you can write it with you can run it with a jurixtest command which will output all successful and failing tests. Another great feature for developers is replaced which is read evaluate print loop. It's interactive process that you can run in order to evaluate any expression. And here in the example you can just run any mass multiplication or anything. You can get information about any expression like we do with the type keyword here, or even get the documentation for each function of your project. But besides that you can also load any model you are currently working at.
00:17:02.750 - 00:18:30.804, Speaker A: So in order to test it very quickly and reduce the development time for your project, you can load the model and test the function you are currently working at. Like in the example here, we can load the balance model and use the function from that model inside the repl terminal and we have out of box documentation provided as well. If you provide the commands to your function, to your types, or to your models, you can get for free the documentation provided in HTML format which you use then can deploy somewhere where you want to have the reference to your project with all the corresponding documentation. And also we have already ecosystem with the libraries that you can use in your project. We have a standard library that has all built in types and functions that working with them. We also have containers which is the data structures such as set maps, hash maps, and we have testing libraries, quickcheck and unit testing library as well. And the best part is that you can add any library into the ecosystem and reuse that in any project you want as well.
00:18:30.804 - 00:19:25.224, Speaker A: And we support different ides. We have the plugin for versus code that we wrote specific for Jurik's language, and it has such features as semantic highlighted, go to definitions, preview of the documentation, and so on. And here in the example, you can see that hovering can provide you information about every token, about every function and variable in your project. So it's quite handy to develop with such hints. And the same features are supported in the emacs. So if you are emacs user, we have emacs mode for that. So it basically has all the same functionality as versus code plugin.
00:19:25.224 - 00:20:47.434, Speaker A: And it's not all the languages in development. So we continue working on that and adding new features as well. So here's a few things I can share that we're working at. We're adding the support of record types which would help you to even more precisely integrate your business logic in your type system of your application. We are adding traits which are type classes like structures, which will help you to write abstract functions that you will be able to use with different data types. We are also working on formal verification capabilities in presage which could include dependent types for example which is very important also for verification of your programs and we constantly improving tooling and adding more documentation and libraries in the ecosystem and we also put a lot of effort into working on the compiler efficiency and performance for compile time and runtime as well. So this is juic high level functional programming language for decentralized application.
00:20:47.434 - 00:21:29.764, Speaker A: So try it now and if you're interested we are having workshop today at 430 in the workshop group so you can join us and our team will help you with your first Juvix application. Thank you very much. We had a bit late so I mean we're in time but there's time for maybe one question. Yes, sorry we have time only for one question. If you have some you can ask or you can find us in the anomaly booth and ask any questions or at workshop as well. Thank you.
