00:00:00.280 - 00:00:00.688, Speaker A: Thank you.
00:00:00.726 - 00:00:40.114, Speaker B: So, hi, my name is Jan. I'm co founder at Zurkit and technical lead. So I'll tell you a little bit about myself. I've been in the space for a while. I did a PhD a while ago, got some grants from the Ethereum foundation, started working on roll up related topics, and then decided, you know what, let's just try to build one so we can explore our own ideas. And one of the ideas that myself and my co founders are really excited about was this concept of sequencer level security, which I'm going to talk to you a little bit about right now. So you're here, you probably know some things about blockchains, but I got to get you all on the same page to motivate why we're looking at the specific topic, the specific feature of a roll up.
00:00:40.114 - 00:01:19.274, Speaker B: And so let's take a step back for just a second and say, what does a blockchain actually sort of do to guarantee security on it, right? The node does a bunch of things right. It'll check the transactions are well formed, that things have signatures, and that things should be included in blocks. So if you saw Arthur's talk earlier, censorship is sort of an issue. And actually, we'll talk on a related topic. But essentially, it does all of these things to make sure that the chain advances in a nice way. So the chain is doing something correctly, always predictably correct, according to some rules. And this is very, very important, obviously, so that you have a chain that you can trust and rely on to do a whole bunch of really cool things.
00:01:19.274 - 00:02:12.056, Speaker B: But what it doesn't do is actually secure your funds. So if the chain includes a transaction that might negatively affect your balance because you deposited in some untrustworthy defi protocol or something else where your funds are lost or hacked, this is not ideal. And you actually can't fault the chain for doing this. If you believe code is law, you certainly think that this should be the expected outcome. But probably you're a little bit more attached to your funds than just saying code is law and sort of washing your hands with the funds you lost, and you want to do better. So we were looking at this and thought, can we add some value in some area of this ecosystem? And getting ethereum to do this is not desirable. We don't want to do that, but it doesn't mean that other people can't do something about this, namely layer twos.
00:02:12.056 - 00:02:47.920, Speaker B: If you have a particular concern about this, you can deal with it. And in particular, we're going to do this on circuit which is a new zero knowledge roll up that we're building. That's going to put some level of security that can guard against not just that sort of sequencer level, traditional protocol implementation concerns that you would normally have. So are things signed properly and do transactions execute all of that? But also, are your funds going to get hacked or lost? Obviously, only on the l two. We can't do anything about the l one. But what this means is you can actually design some stuff to guard your funds, even when sort of things are going away. And this won't be for everyone.
00:02:47.920 - 00:03:23.206, Speaker B: This is going to be sort of a hard pill to swallow for some people, because we're going to have our hands in the mempool. We're going to start looking at things and say, oh, that should be or shouldn't be. And what that means is interesting, challenging research questions and research directions. But there is almost certainly value in doing this, right. If you can guard your funds and your honest actors, and you can discourage dishonest actors, this is something you might want to do. So, before we talk about how this works or what we're doing on Zurkuit, how to transactions flow in a roll up is important because we're going to be changing that flow. So let me go through this very quickly.
00:03:23.206 - 00:03:42.870, Speaker B: So what happens in a roll up? You have some layer one blocks, these are the orange ones at the bottom. And you have a mempool, which is a sort of text document on the screen. And there's a sequencer. Sequencer is essentially just a centralized privileged node, not always centralized. In the future, everything probably be decentralized. But generally right now everything is centralized. And it takes some things out of the l two.
00:03:42.870 - 00:04:31.354, Speaker B: Mempool constructs an l two block, which actually posts first to the l one as a batch to get a soft commitment. And then from the l one commitments, you actually rederive the l two state. So the sequencer can do this optimistically, and it has a good vision of what's going on in the l two state all the time, but you probably don't trust it until things are hit on the l one. And then there's some notion of finality. There's either an optimistic roll up where you're waiting seven days to make sure that no one has proven that the sequencer didn't do anything wrong, or a zero knowledge roll up, which is the case for circuit, where there is eventually a proof that hits the chain that says, actually my state transition followed some rules and we're all good. So that is generally what a sequencer does. It constructs l two blocks by posting data on l one.
00:04:31.354 - 00:05:38.248, Speaker B: Xurkit's going to do a little bit more than that. What we're going to do is add this level of sequence or level security where we're going to go into the l two mem pool and change how l two blocks are constructed in order to safeguard users. And so what's going to happen is we're going to add this security oracle. So we're using oracle in the computer science sense, not in the price oracle sense that you're probably familiar with in web three that asks for every transaction, is this a safe transaction? Is this a good transaction? And I'm not going to define for you what a good transaction is right now because that's reasonably challenging, but you can envision it as is there a flash flow? And that's wiping out a defi protocol? And you can define what this looks like, at least at some level, for your needs, and we'll talk about how we're going to do it. But essentially there's some notion of good and bad, which we're going to have, and we'll have an oracle that will determine for a given transaction on the current tip of the chain, is this good or bad? And if the answer is yes, we're going to put that into the batch. We're going to process the transaction just like it normally would be, perfectly in sync with standard notions of an l two. If it's bad, though, we're going to kick it into quarantine, or if we think it's bad, we're going to kick it into quarantine.
00:05:38.248 - 00:06:33.064, Speaker B: And what this means, I'll talk about in a minute, but essentially it will be ignored, at least temporarily. And so what you end up having is an l two chain where everything in that l two chain actually went well according to some definition of, well, obviously that is still something we should talk about. And exactly how does this happen? Well, first, how does it do it? So what does it mean to put something in transaction? Can it ever get out? Is there, what are the technical details? What happens in it? Can something leave it? Then the hard questions of how do you tell if a transaction should be quarantined? That's going to be probably the most controversial, the most challenging thing. And then there's some technical corner cases you have to also deal with. Some transactions originate on l one, for example. These are called deposit transactions. And then how do you make sure that other people who are running l two nodes to replicate the node if not acting in this privileged sequencer position, can also come to the same conclusion of what the l two state should be.
00:06:33.064 - 00:07:16.002, Speaker B: So let's start by talking about what is the quarantine. So the quarantine is going to be this place where we put things to determine if they're good or bad in particular. If we think they're bad, we'll put them in there until we can validate them or for some other criteria that we'll talk about. But essentially what happens inside of a sequencer, especially one that's based on geth, like most of them, are including circuits, you've got two queues there. You get a mempool and you have a queue. And the queue is for sort of things that could be right, it could be transactions that have nonces that are too far in advance, or the good ones that that are ready to process right away. And if they're right away, if the nonce is sort of the one you'd expect for a user, the gas is all appropriate.
00:07:16.002 - 00:07:46.610, Speaker B: All of that, you can put them into the pending queue. And from the pending queue you essentially build l two blocks right away. That's nice. And it's exactly that flow where we're going to interrupt and put this oracle. So what we do is we say, well, before we process it into a block, is it good or is it bad? And that's a simple question. And so it naturally flows right in there. And that means quarantine essentially just says take it out of the ability to go into that pending queue.
00:07:46.610 - 00:08:14.004, Speaker B: So we're just going to put it somewhere else. We could call it a different queue, a quarantine queue, if you wish. But essentially it's not going into that pending queue, and then the rest of the transactions go on. Okay, so let's talk about what happens when we actually put transactions into the quarantine. They could stay there forever. If they're a bad thing that everyone agrees is objectively bad, they lock a lot of funds somewhere. It could stay there forever, and we'll talk about exactly how that will work.
00:08:14.004 - 00:08:51.440, Speaker B: Or they could leave for some other reason. They could leave because there's been a time delay. Maybe there is a nice rule on the chain that says you can actually leave the queue a little bit later, or the user could cancel them. Right. You can replay transactions with the same nonce with a different gas price and a different content of the transaction to actually have your transaction sort of be kicked out of the queue, because you'll put a transaction that isn't bad onto the l two and then rendering any transactions with the same nonce invalid, namely the ones in the queue. So you can actually have users cancel them, which is kind of cool. This is helpful.
00:08:51.440 - 00:09:36.368, Speaker B: If someone thinks they're doing something good, but actually they're doing something bad accidentally, they can cancel that transaction. Or if it starts to fail, we can then sort of not care about it anymore. If we can sort of prove that at a given time, replaying it out of this quarantine queue would cause it to revert, well then no harm done there. Except I guess the person who submitted the transaction will take their gas fees. Or there could be other really cool things you can do, right? You can release it subject to economic considerations. So what you could do is say, I don't know what good or bad really is, and you're telling me it's a good transaction, but I don't believe you. I think it's going to do x dollars worth of damage.
00:09:36.368 - 00:10:26.584, Speaker B: So you could have them stake x amount of dollars and say, look, I'm going to play your transaction, but if something goes wrong I'm going to slash your stake and I'm going to use it somewhere else. So there's a bunch of things you can do once you start looking in this design space, but the most simple one is also just the administrative concern. So if you think something is bad, you put it in the queue until someone actually sort of traces through the transaction, figures out and says, hey, this doesn't look that bad, maybe we can let this go. It's probably the one we'll start with, but there's a whole lot of areas you can do with this design space once you start doing this. And what you notice is actually these things can do actually a little bit more than that and we'll talk about that next. But essentially if you have decided something comes back out of the queue, for example, because it was a false positive in terms of badness, it was actually something that was good, but just complicated. You can put it back into that pending queue from two slides ago and everything works as before.
00:10:26.584 - 00:10:54.912, Speaker B: So the next question is, how do we know something is bad? And we're going to leave this largely up to the oracle. But the oracle has a lot of information at this point in the game because you're not doing something very sort of academic in the sense of trying to prove that all transactions can go wrong. When you're auditing code, you're not saying that there's something could go wrong with a smart contract. You're saying this transaction will do something bad. You can simulate it. You can actually play it, play with it. You can play it off chain, you can simulate it.
00:10:54.912 - 00:11:23.954, Speaker B: You can use things like AR models to detect patterns in previous hacks and see if this one corresponds it. And you can do a whole bunch of really cool stuff, because you have the information, you're not dealing with hypothetical attack vectors. You're given a transaction that you want to determine an outcome for good or bad. And so this is in fact what we're going to do down the line. It might be even nicer to do something better, or maybe not better per se, but different, which is to say, define custom invariance. You could tell me what is good or bad. You have a DAP, you're concerned about losing its value.
00:11:23.954 - 00:12:07.450, Speaker B: That's important to you. But the next app doesn't care about that property. So you each define specific invariants, and the sequencer enforces those in different ways for different apps. And you can do this to actually change the semantics in a blockchain, which is also really, really cool. For example, you could have invariants that aren't sort of goodness or badness, but actually just enforce things more efficiently for you. From a gas point of view, you could say that any transaction hitting a specific function on one of your contracts is bad, unless it came from your address. That's effectively implementing the only owner modifier that people write in spark smart contracts, which say you can only upgrade it if you're the owner.
00:12:07.450 - 00:12:51.914, Speaker B: But now you can take that modifier out of your smart contract code and put it into the sequencer, and you now saved yourself a little bit of gas when you run that function call. That's probably a pretty contrived example. You're probably not doing that very often to have that warrant the extra engineering effort. But you can envision taking these other things in smart contracts and putting them into invariants that are enforced by a c sequencer, which we think are really cool. For now, what we're going to do is research this idea quite a bit. We've got some partners, both in academia and industry, where we're going to figure out how to look at these models, how to test them, how to simulate them, and how to use back testing of previous hacks. So we know what things have gone wrong in the past lunch chains.
00:12:51.914 - 00:13:38.224, Speaker B: Obviously, everyone probably remembers with the Dao hack and all of that, there was a whole bunch, there was $2 billion lost in bridges over the last couple of years. There were tens of hacks over each of the last months. We can play around with those, we can figure out what looks bad and start to tailor the system to start, at least, to counter transactions that look exactly like those or similar to those, so that we can prevent at least those disastrous outcomes. Because none of those seem to be upsetting to the people who pulled off the attack. They all knew that they were pulling off attacks. Okay, so we just have a couple more minutes, and there's actually some small technical considerations that I'm going to dive into just for a bit, in case you're wondering about some of the more detailed stuff, or just to avoid questions about it later. Sorry.
00:13:38.224 - 00:14:29.338, Speaker B: L one deposit transactions are a bit unique. So l one deposit transactions are generally the transactions, say, put my ETH off of ether, off of ethereum, and onto a roll up, say Zurkuit. The term's actually been conflated to say anything transaction that affects l two state that starts on l one. But essentially, this is a little bit of a technical issue because the sequencer has less control over these transactions. The protocol for most sequencers says, look at the l one inbox or the bridge, and if there is a transaction there that puts something on l two, I sort of just have to deal with it. So I can't kick it out of my mempool, because everyone looking at the l one state and trying to rederive the l two state from it will look at that deposit transaction and actually realize, oh, that should be in there all the time. So what you actually need to do is you need to have a different way to check and quarantine them.
00:14:29.338 - 00:15:01.462, Speaker B: I thought that was a slide. And you can do this, but what you have to do is you have to go back to the l one chain and write to the l one chain saying, this deposit transaction is going to be ignored, put in quarantine, essentially, because of some reason. You can say the reason or you can just mark it as ignored. And what this also means is to rederive the state. You have other nodes watching the l one, and it's got to have this sort of special functionality. So I think that is actually the end of my talk, which means I'm a little five minutes early. But if you have any questions, please find me.
00:15:01.462 - 00:15:23.124, Speaker B: I'll be around here outside or sitting or at chain science, I think. I'm also on a panel on Sunday, and I have a talk at chain science tomorrow. You know, come check us out. Zurkit's a new ZK roll up. The staking thing is actually over a billion now, so it's grown quite a bit since these slides were made, but check us out, ask me questions and thanks.
00:15:23.504 - 00:15:28.124, Speaker A: We actually have time for one or two questions. Are there any questions in the audience?
00:15:33.344 - 00:15:37.592, Speaker C: So do you imagine Oracle to be deterministic or can be randomized?
00:15:37.728 - 00:16:15.992, Speaker B: I mean, you're going to be. I don't have a good answer for that. I mean, I think you'd want it to be deterministic so that you could show someone that, like, hey, this transaction didn't go into the chain because of this reason. If there was a compelling reason to introduce randomization there, I'm not sort of opposed. What we envision long term is to have the ability to sort of have multiple of these oracles. You could also envision a two of three majority where your oracle might be randomized and might say, this is not good, and someone else's oracle is a little bit more deterministic and gives a different answer and you take the majority of them. I don't really know.
00:16:15.992 - 00:16:26.528, Speaker B: Would you consider LLMs or AI based things randomized? Probably also not, but they're probably not necessarily deterministic, depending how you train the models.
00:16:26.656 - 00:16:34.122, Speaker C: I mean, if Oracle is deterministic, malicious attacker can also check in advance and design transaction so that it passes.
00:16:34.178 - 00:17:26.554, Speaker B: Yeah, yeah. I mean, the hackers, I think, probably always have a little bit of a leg up here because they're trying to skirt this. I don't know how much we're going to be able to counter that. And the best answer there is probably that custom invariance. If you tell me as a Dap developer what shouldn't go wrong, and you do that in a way that's careful, then the attacker should never be able to break that invariant. If I can simulate it, and if we do that, then there's sort of no advantage, I think, to the attacker abovehand until we get to that point. I think, yeah, people can come up with new attacks in the same way that if you're a smart contract auditor, you've probably been looking for a reentrancy all of your life, but now there's a whole bunch of new classes of attacks that you also need to look at because you didn't think of them as concerns before, but now you do in particular things like read only reentrancy.
00:17:26.554 - 00:17:46.694, Speaker B: So ideally we catch all of those as well. But if the invariants are defined, it's a long winded answer. If the invariants are defined well enough, even new attacks can be canceled. So if you just say, don't wipe this protocol, it doesn't matter how the attacker tries to do that. If it wipes the balance of a protocol, it's going to be up.
00:17:49.994 - 00:17:54.384, Speaker A: Any other questions? One last question. Maybe anyone.
00:17:56.844 - 00:17:58.944, Speaker C: Who is defined all those rules.
00:18:00.604 - 00:18:32.328, Speaker B: For now, it's us. For now, it's going to be an AI based model using the previous hacks that have gone on. Ideally we would love that you or the Dapps to say, this is what I care about in addition to the AI, because you might have gotten it wrong or the AI might have gotten it wrong, but together we can do it better. Well, yeah, every roll up is sort of a middleware. So. Yeah, this is. Yeah, I mean, we haven't open sourced the ideas just yet or the tech.
00:18:32.328 - 00:18:43.004, Speaker B: We will probably at least the infra for the roll up. I'm not sure the LLM will go or the IA stuff will go public, but the idea, you know, you can definitely take and implement.
00:18:46.204 - 00:18:51.164, Speaker A: Thank you so much, Jan. It was a really interesting presentation.
