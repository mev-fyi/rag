00:00:01.240 - 00:00:18.674, Speaker A: Good afternoon. So, I can see in the audience, you know, a lot of the others, and I think they contribute more than 30% of the speaker. Sorry, audience. So I'm a bit nervous, so I'll try my luck. They're over there. And if you have, like, very hard questions, I'll point them at you. Okay.
00:00:18.674 - 00:00:52.630, Speaker A: So the whole idea of this talk is, like, we had worked. I'm from Panther, the CTO chief scientist. We have a small research team. Pretty much all of them sat on the back, except one person. We did some work on a snark, and we were looking for how best to actually put it to use. And what we found out was, there's a good opportunity in cosmos. So how do you actually do succinct, easily, cheaply verifiable, a set of cosmos signatures.
00:00:52.630 - 00:01:24.262, Speaker A: So that's what we looked at. And. Yeah, so one of the things that we figured out was there's two part problem. Actually, it's a multi part problem. One of the problems that we have is, like, whenever we create a proof that has to be EVM compatible, and because of the curves that are existing in cosmos, this becomes a bit more tricky. And, yeah, that's the start of it. So I should have actually shown the picture.
00:01:24.262 - 00:01:51.706, Speaker A: Right. It's a picture somewhere else. Okay, so what's the bigger. What's the elephant in the room kind of question? So the elephant in the room kind of question is like, doing all those things as non native field arithmetic. Right. So that's quite a huge overhead because the curve that's being used is edd to 25,519. So, so you can either choose one of the two parts, you can actually do a massive parallelization and have a proof of regression with a suitable proof system.
00:01:51.706 - 00:02:30.958, Speaker A: So there's a couple of them, I think, the secretary, divergo and pianist. And then there is the second path, which is essentially trying to avoid the non native arithmetic, and especially for the scalar multiplication and suction bridging scheme. That's what we call overfly. This is the, you know, our proposal in that sense. So we had a snark scheme, and this is our proposal to how to do this. So what's special about cosmos signature schemes? Can I have a show of hands of people who are familiar with cosmos signatures? So I can. Okay, so I will hand over a bit.
00:02:30.958 - 00:02:50.604, Speaker A: So, essentially two bits of challenges. One bit is the fact that you have a SHA 512. It's non trivial. And the even bigger problem is the curve. So you have an adverse curve that's ED 2550. So that causes a bit of a problem for us. So we want to actually solve for both of them.
00:02:50.604 - 00:03:32.872, Speaker A: So we could actually get smaller size proof, make it faster. So that's kind of the objective. So, yeah, kind of the normal iceberg picture where you go, okay, what's the biggest thing? Everybody recognizes the SHA 512, but what's the bigger one? Is a non native field arithmetic that you have to do to do this thing. So, yeah, if you were to go a bit more into depth, why is this a challenge? So, part of the challenge is the first bit is the fact that the signatures are not efficiently aggregatable. Okay. I was always being said that. Don't say that you can do half aggregation.
00:03:32.872 - 00:04:03.004, Speaker A: Okay. Full disclosure. Yes, that's possible. And the second bet is the fact that the curve that's there is not very, how could I say, friendly to snarks. So it's kind of not a great situation to be in. And there's also the problem of low to acidity and no large smooth order subgroups. So, essentially, if you have that, you can actually have some ways by which you could do things a bit faster.
00:04:03.004 - 00:04:38.076, Speaker A: Okay, so what do people typically do? So, when you want to solve this problem, what you do is you do multiplication over another field. Right. And this typically has a very large overhead, and there has been some. Some amount of progress in this space. And even though there's been a bunch of progress, it still is pretty expensive. You know, it's more expensive than the ShA 512. So.
00:04:38.076 - 00:05:04.010, Speaker A: Okay, so what are the possible solutions? And this is, like, one of the possible solutions. So there are, like, solutions that's been proposed which are using, you know, what I would describe as field diagnostic FFT free snarks. So everybody's familiar with fast Fourier transforms. Okay. All right. Okay. So fast freer transforms is kind of the easy way to do some multiplication when you have very large numbers.
00:05:04.010 - 00:05:45.470, Speaker A: So this is like, typically when you have a snark, you have two things, the fast fourier transfers and multi scalar multiplication. So in this, we definitely have msms. And the possible solutions that are being proposed is like, fft free. Free snarks. And one of the challenges with proposing things like this is the fact that you end up having large proof sizes, and it becomes more expensive, both in terms of overhead for doing the computation, storage, and communication complexity. So there's also some linear time things with msms or with merge hashing. Okay.
00:05:45.470 - 00:06:33.658, Speaker A: So I'm not going to go into a lot of detail, but in general, as I was describing, typically snarks have two sets of operations in that sense. So you try avoid the FFT a bit to reduce overhead and then focus more on msms. Okay, so, right, so what is it that we are looking for? We actually want to have a snark that's compatible with the field. The underlying field is 20 519. And what does it need to support? And you need to have support for custom gates and lookup. So in our case, what we have is like, we have a flung ish lookup mechanism. And one more thing we did was like, we have two choices.
00:06:33.658 - 00:07:10.636, Speaker A: The choice of having a multi linear point commitment system or a univariate point commitment system. And we kind of stuck towards the univariate. Okay? So the person who actually named the scheme is sat on the audience. So if you guys like the name of lie, he's there. He's the guy to be asked why he named it that way. So, as I said, we actually worked on this snark scheme for a bit. Bunch of the people that I hear were, you know, people were heavily involved in it.
00:07:10.636 - 00:07:58.454, Speaker A: And it uses, I would say it uses like a plankish lookup scheme with a CQ mechanism. And one of the things we do is like we kind of stitch together two sets of proof systems to BnT 50 and get the results. So I have two slides which actually describe this. So it's much more intuitive when you see the pictures. So this is the first way of doing it. The first way is like you have a number of ED 25,519 multiplication, and then the validity of the SHA 512. And because of the way the cosmos actually has this rotating set of validators, you take a subset of them and they're validated.
00:07:58.454 - 00:08:52.116, Speaker A: And then you actually simulate the whole thing on top as a growth or other schemes on top of a PN 254, which is kind of bit heavy. So the proposal or the approach that's been taken is this. So we do take a proof of ED 25,519, have a look up argument just to validate the rotating validators assumption. So that from the set of all publicly known validator set, you have a subset and you want to check that. Then you have a on BN 250, Planck plus CQ scheme, which actually looks for the validity of the n shaft. I want to hash functions, right? And then you combine the two. You could actually use growth or f link and it's a non native 250.
00:08:52.116 - 00:09:19.164, Speaker A: And then you get the results. So that's the end of the verification. So the difference is like this one, you do everything in one step. And this is our first approach. We would probably describe this as a naive approach. This is the more, how could I say, finest approach, slightly better. So I could probably talk a bit more about where else we could actually use this.
00:09:19.164 - 00:09:55.354, Speaker A: The other places this could be used is for bn 254 proof aggregation in one layer. And you can also use for sec. This is, I'm just talking about the snarks, right, the snarks. This is one of the places where the snarks could be used, and you can use it in other places as well. That's the proof of multiple sec, 256 signatures, and for multiple PLO signatures as well. Okay, so there was a talk that was given last year, and the paper is there. You could probably have a quick look.
00:09:55.354 - 00:10:18.354, Speaker A: I will hand wave at the scheme. So at least you have an idea. As with most nocs, it's a KCG commitment. Arithmetic is splunkish. And we have a monumental univariate basis. So this is kind of the thing that helps us to keep size of the proofs within a. You know, when there's non arithmetic, it doesn't really blow up.
00:10:18.354 - 00:11:07.094, Speaker A: So one of the bits that's probably of interest is the fact that we do the sum of the polynomial products via multimodal FFT. So probably if you meet the team, they will tell you the story of how they got there. So the key bit in this whole scheme is a hadamat product. This is how it looks like a bit more detail there. Like in a larger sense, this is kind of the pivotal part of the whole scheme for the snark scheme. It kind of exploits the structure of the product, and that helps us actually do this faster. And we also use the permutation argument.
00:11:07.094 - 00:11:39.458, Speaker A: And we would probably say this is somewhat similar to Planck's scheme in that sense. The real difference is we use the monomial basis. Okay. So we also have this ability to do custom gates, which allows. Oh, sorry. We also have this ability to support custom gates. You know, it's helpful for like additional multiplication, addition and doubling.
00:11:39.458 - 00:12:06.044, Speaker A: Not sure. Yeah, I mean, addition plus doubling is multiplication for 25, 51. Okay. So other bits that are there that's probably as relevant would be like. It also supports like a subsets and sequences. In this instance, it's useful because it's a subset validation mechanism. You have a set of all globally known set of validators and you want to check out subset and.
00:12:06.044 - 00:12:37.538, Speaker A: Yeah, so it just has like three elements in G, one merged into one field agnostic snark. I would probably skip. Yeah, I mean, just to give you an intuition of the size of the proofs. So we have two variants. One we call the small proof and the fast proof variant. The small proof is like ten g one points and 20 elements in FP, and the faster one has 14 and 24. So the small proof is like 1.4
00:12:37.538 - 00:13:23.932, Speaker A: kb, and like, the fast one is 1.76. And. Yeah, so the verification mechanism, it's pretty straightforward. We have a few scalar multiplications in G one. And again, there's some similarity to Planck, or the similarity is that we don't have any pairings in G two, so it's possible for us to actually do recursive aggregation. Okay, so again, now the question about performance, right. How much time would it take? And the largest chunk of computational time here is MSm on G one.
00:13:23.932 - 00:14:23.344, Speaker A: So, typically, as I was describing, if you take a normal, what do I call a classic snark, you have a couple of ffts, nfts and multiple msms. So the largest fraction of the computational time here is MSm. So the second is like the Hadamard product calculation in that sense. So largest chunk goes to MSM, and then the Hadamard product. Right. So, as I was kind of describing, like, when we do computation, we end up doing the computation using multimodeler ffts. So, to be, you know, one might wonder, what's the benefit of doing such things? So, there is this upside of actually fft that can be.
00:14:23.344 - 00:14:52.648, Speaker A: FFT can be parallelized, and the inverse can be batched as well. So overall, you could possibly do some precomputation and save some more of a shave a bit more of it. We haven't done a lot of shaving in that sense. So if you were to look at it, we have an implementation. So, one of the person who actually implemented is here, the other person is not here. So if you have specific questions, you can find them and ask them. So, the snark was implemented.
00:14:52.648 - 00:15:16.004, Speaker A: For the current form that was implemented, it has like 100 bit security. The pairing used is like eight pairing and takes 4.7 milliseconds on a normal eight core laptop. Not very beefy. Normal laptop. Okay, so we also have a rust implementation. This is an AWS instance.
00:15:16.004 - 00:15:52.758, Speaker A: I'm pretty sure everybody sees this. Everybody has like a 64 core AWS instance. And the proverb time was 24 seconds, and the verification time is 15 seconds on a eight core one, a laptop, rather. The other one is AWS instance. Okay, so we have some benchmark for multiplication on a single AWS instance, the 1.761 the faster one, it takes 45 seconds. So we had two of them.
00:15:52.758 - 00:16:18.914, Speaker A: The faster one and the smaller one, 1.4. This is 1.761. Okay. The 14 g one elements, and I can't remember the second number of. So in the same machine, we did the simulation for bn 254 grow 16, and it takes less than a minute. And in total, if you were to combine all of this, it takes sub two minutes to do the whole thing. Right? Right.
00:16:18.914 - 00:16:46.664, Speaker A: Yeah. Again, you see the picture. This is like comparing before and after. So talking about SHA 512. So as we were describing, typically everybody recognizes SHA 512 as being very computationally expensive. Expensive. There's a lot of lookups.
00:16:46.664 - 00:17:16.378, Speaker A: It's not really friendly with r one c as kind of mechanism. So the cost of scalar multiplication is pretty high and actually dwarves the cost of actually doing Sha five. So we also have a lookup, a SQL lookup. So this is literally using Aztec Brattenburg library. Apologies if I butchered the name. And it does have lookup tables. And it's like a six k per hash kind of thing.
00:17:16.378 - 00:17:48.940, Speaker A: So it's a scheme that has actually come up with Ariel Gabison, and I can't remember the second order. So it's a lookup mechanism. We liberate that. So last of the bit is combining the two of them. And if you were to think about this, it costs like 280 multiplication b and two PI four signature. So if you have n signatures two n times that. Okay, so yeah, that's pretty much the whole thing.
00:17:48.940 - 00:18:21.120, Speaker A: So this work was done by a bunch of people in Panther, and some of them left and they moved to Mozak. So they are working on continuing the work on whatever they're doing in Panther. So we had a choice. It's more like metrics, the red pill versus a blue pill kind of situation. Do you actually look for minimizing non native field automatic, or do you want to do fully distributed proofs? So they have come up with a way to actually do both. So you don't have to choose one. You can just have both.
00:18:21.120 - 00:18:57.434, Speaker A: You can ideally have both worlds. And yeah, there's some more work that's being done. So a fully distributed snark, agnostic snarky, which actually allows all of this. It's the blend structure of both the snark that I described that were there, and a pianist, which is one of the schemes I described. There were two choices we had. One is to massively parallelize. So some of the upside of actually having a massively parallelizable snark scheme plus whatever that was there, which actually reduces the overhead for doing things in a non artifact.
00:18:57.434 - 00:19:05.064, Speaker A: So that's pretty much what it was. If you don't have any hard questions, I'll be okay. If I have hard questions, I'll point at people over there.
00:19:13.204 - 00:19:22.944, Speaker B: Thank you. I love the slide with the iceberg, but we have questions coming. Please raise your hand for the questions.
00:19:23.544 - 00:19:26.044, Speaker A: None of my team members are allowed to ask me questions.
00:19:26.464 - 00:19:43.032, Speaker B: Right, exactly. Exactly. So we can do around. So maybe you have a question that we can have. Like, put up your hand. And so with the voting, I don't know who would like to try this cross crossbridge. It.
00:19:43.032 - 00:19:45.284, Speaker B: Is it oracle or messaging? What is that?
00:19:45.904 - 00:19:46.784, Speaker A: It's a bridge.
00:19:46.864 - 00:19:52.104, Speaker B: Bridge. It's a bridge. Because there are as part of them. No, there are bridges and there are messaging protocols.
00:19:52.604 - 00:20:03.372, Speaker A: Okay. So the difference between. Okay, so you could do bridging by messaging or by true bridging. This is IBC. So it's more. I would describe this as bridging.
00:20:03.508 - 00:20:10.424, Speaker B: This is bridging. All right, so would you like to use what exactly now was presented? Raise your hand.
00:20:11.764 - 00:20:25.694, Speaker A: Okay. There's some GitHub stuff there, so. Yeah. And there are guys sat behind you. There's like a whole row of them. You can get hold of one of them and talk to them. The guy in the red t shirt and the rest of the guys in that row.
00:20:27.274 - 00:20:35.514, Speaker B: All right, all right, all right. Good, good, good. Thank you so much. Wow. Impressive. All right, give a round of applause. Thank you.
