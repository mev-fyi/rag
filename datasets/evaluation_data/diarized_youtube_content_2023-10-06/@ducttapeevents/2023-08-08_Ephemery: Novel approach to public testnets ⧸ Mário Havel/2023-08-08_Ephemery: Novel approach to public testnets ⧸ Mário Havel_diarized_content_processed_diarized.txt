00:00:01.800 - 00:00:59.966, Speaker A: Awesome. Whoa. Thank you so much for joining us this morning, really appreciate it. Especially those who've been parting long enough. Right? And yeah, it's honored to have you here and to talk about fMRio, which is a project that I've been working on with the community in the past few months. And yeah, I'm Mario from Ethereum foundation, protocol support and this is one of the things we do in protocol support, try to support the core infrastructure, testnets. And yeah, before I talk about the testnets, we should define them, right? We should know what I mean by testnets because maybe just to give you a quick background, Testnet is a network where we test things because we have blockchain technology, we have the Ethereum, we have any other currencies which are real money, and it's not good to test our applications which are being developed on the Testnet or the actual implementation of the cryptocurrency.
00:00:59.966 - 00:02:26.746, Speaker A: The Ethereum clients have to be tested in environment which is as close to the production, to the real deal, but at the same time we cannot lose the real money, right? So we have testnets which are networks running similar or the same parameters as the mainnet, as the real deal, but with no real funds on it. So we can go crazy, we can test our apps, we can test our validators, the infrastructure on testnets. And speaking specifically about Ethereum testnets, they have quite a bit of history we've seen over the years, many, many of them with Morden, Robston, Rinkeby, and now after the merge, this is the current state. So before the merge, the old testnets were either deprecated, deprecated or merged into the proof of stake. And from those, for example, Ropsten, it was the oldest proof of work testing at the time. And it was killed here by the way, in the hackerspace we met with the get team and we merged the shit out of it and it got deprecated. So it was the Ripston and we ended up with just two testnets, Curley and Sepolia Gerli actually started as a proof of authority testnet.
00:02:26.746 - 00:03:43.978, Speaker A: It was a new project invented or started at Eid Berlin by Afri and the community around there, which was always basically a community testnet. And with the prater, the beacon chain connected to Gurley, it's been the place for testing the beacon chain, the merge over the past, well, two years or more since before beacon chain. So the girly now after the merge, is the only public testnet with open validator set. That means that it's the only one where you can actually test your clients to run as a validator and then switch to mainnet to try whether your validator keys and the whole setup works. But being started in 2018, it's quite old, quite big, which means that it has large state and most importantly, lack of funds. You heard about the huge fuckups with all the faucets empty and people actually selling girl eat, which is like a total fail of what Testnet is supposed to be, right? It's supposed to be this completely free open network where anybody can just test anything. And on the other hand, we have Sepolia launched roughly a year ago, more than a year ago.
00:03:43.978 - 00:04:08.562, Speaker A: So it's very young testnet compared to Gurley. And I would say that it's the place to test your applications right now. However, Sepolia has a closed validator set. It doesn't allow anybody to run a validator. It's mostly the client teams and the core devs running the valid infrastructure. So we make sure that it's stable. So this is the state right now.
00:04:08.562 - 00:04:59.214, Speaker A: And the problem with not just two of these, but all of the distance that we deprecated and what is eventually happening to these is that they run into certain issues after a long time. Already mentioned not enough supply, because the test starts with certain supply which is distributed over the faucets and it doesn't have a value. People don't really think about sending it back or doing something with it. It ends up just lost in a bunch of test wallets and or locked in dead beacon chain or something. So the supply might be inefficient and we end up with empty faucets tweeting, oh, send me some sepolia please. Yeah, there might be issues with the validator set. With people not being properly incentivized to keep their validators running.
00:04:59.214 - 00:05:41.062, Speaker A: We might end up not reaching finality and have the issues to keep the network even finalizing the size. With testnets being few years old and people just deploying anything they want, it can be pretty big, so it can take you some time to even run the node. If you just want to test something, you want to do it fast. So it takes a time to bootstrap the node, and also you have higher requirements to even run it. So if somebody just wants to play with Ethereum, he still needs a bigger machine. And over time these testnets will anyway end up deprecated. Now it's becoming more of a standard.
00:05:41.062 - 00:06:45.660, Speaker A: Before it was ad hoc, we realized that the testnet should be deprecated thanks to Afri now the plan is to no deprecation ahead. So the garly is being deprecated right now, going to be replaced by Holash key or Holashowitz testnet, which is named after the place that we are standing right now, this part of Prague. But it was started a year ago at Eat Prague here and the whole show is supposed to be supported for like two, three years. So we know exactly when it's going to be deprecated. And with this in mind, why can't we create actually a testnet which is not deprecated deterministically or that we know when it's going to get shut down? But what if we shut it down automatically and reset every now and then and everybody just counts with it? So we go back to the Genesis every time and that's fMRI. So this is a novel approach to the public testnets that we've been working on. And yeah, as I said, basically it's an automatically reset testnet every given period.
00:06:45.660 - 00:07:51.028, Speaker A: The period can be arbitrary, right? Can be a few weeks, few months, anything that community agrees on. The testnets just drops everything and goes back to zero, to Genesis. That means that all of the funds go back to the faucets, all of the validators are clean. And there is just the genesis set of validators which is supposed to be secure. And this is still the single infrastructure, it is still the same clients running the testnet, which means that you have just the same bulk Explorer, the same RPC, and you connect to the same network, but it's a new network, let's say every week. What we can achieve here is not just enough supply, enough supply for everybody, because if you just waste all the supply this week it's just going to reset back and we have it all back. What is great that we also can ensure that we have secure validator majority that will always finalize because we can just calculate how many validators we need to always keep the majority.
00:07:51.028 - 00:08:23.462, Speaker A: So there is the period to activate a validator and we can make sure that, I don't know, we have 500K validators. It would take one month to lose the 66% majority there. So we know that if it's running for less than a month it will be always secure. Nobody can take over the testnet even if we have all the funds for free. And what happened just now? Ok, I'm sorry. Ok. Just wanted to show you this.
00:08:23.462 - 00:08:55.590, Speaker A: Yeah, so this is the resource repo, just some general information. I'm going to show more resources soon. Yeah, it's my GitHub, fmril testnet. And the idea here is that fMRI is sort of an implementation, but the fMRL testnet or the automatically reset testnet is a specified concept which is implemented here. But you can just run your own notes with the same specification or fork it. So you can actually it's running, right? It's happening. It's not just an idea.
00:08:55.590 - 00:09:29.004, Speaker A: It's been running since December last year, actually it started. The discussion was boosted by Defcon in Bogota. We had a chat with Afri, Denny Ryan, but also people from here, actually Lumi or Mohammed who've been participating in the whole show. It's a testnet and we ended up, we came up with this idea and it started well thanks to BK 910 Remiroi from Eatstaker and other people from community who contributed started around December. So we actually started testnet. So it's running. You can connect there.
00:09:29.004 - 00:10:27.954, Speaker A: I'm going to show you the links. But what is it good for? Why would you like to use it? First of all, the short term testing, which means the applications which you need to test just right now, just imagine how many friggin hello worlds is there on girly. Like we don't need that. If you are just starting as a dev or you are doing something at a hackathon right now and you're just testing it, you are not going to need it in one week or in a month or something, you can just deploy to fMRI and have it as a disposable testnet infrastructure. So for short term testing of your apps, but also validators. So if you are trying to set up a validator and it's hard to get hands on some girly eat and you don't want to wait till your notes bootstrap sync, you can just use ephemera, it's very easy. And you can run as many validators as you want because the faucets are very rich and yeah, it syncs in few minutes because it's just short and small and mostly empty chain.
00:10:27.954 - 00:11:04.754, Speaker A: Yeah, and I'm hoping that it's not going to stay empty because I would like some more folks to use it. So please look into it. And it's fun because you can just break everything, try anything you want, you can take all the funds, you can deploy any apps you want. It's just going to get deleted in a week. So don't worry about it, go for it. And yeah, it's the weekly reset mechanism right now because it's still kind of a development phase we started just like a few hours, few days, development phase. With each reset we test whether it survives, the infra survives, and now it's one week.
00:11:04.754 - 00:11:56.248, Speaker A: It should be more later on, ideally like a month in the repo you can always see when is the next reset. It's every week on Thursday, 07:00 p.m. UTC. Right now it's all written, or like it's all handled by DevOps tooling basically. So how it works is that we have bash scripts which are handling the logic according to the specification. So it watches the period, whether it's supposed to be resetted, and in that moment it triggers the rist mechanism which stubs the node, deletes all its data, updates the genesis, and starts the same node on a new network. Also we are testing some implementations in actual clients because so there is EAp work in progress on this.
00:11:56.248 - 00:13:04.114, Speaker A: We would like to have this not just implemented on the tooling side where you can run some external DevOps tooling which handles the node, but have it implemented in the node in the client itself. So there is like a test naive implementation in Goeterium and in Lodestar right now. Yeah, you might think as app developers that like it's hard to actually test your applications on this testnet when it's empty, right, when it resets every week. But what we developed is a tooling which automatically deploys, automatically deploys infrastructure, applications, some deFi primitives and so on after each reset. So as the network resets there will be automatically uniswap, zero xsplits, some safe, right. The contracts that everybody are using and you can actually contribute to the repo, you can add any app that you want to this deployer or run it by yourself. Yeah, and the specification is mostly done and the EAP is still being discussed.
00:13:04.114 - 00:13:55.756, Speaker A: And yeah, talking about the roadmap, what we did. So starting in December we had a bunch of discussion about how it should be, should look like, and we are running the stable public network and we made a draft of the EAP. And oh yeah, we are also deploying the primitives right now, but also refunding validators. So if you've been running the validator on the network when it was reset it, you won't get the validator in the new genesis, but you get the funds back. So you don't have to go to the faucet again, you can just pin the validator again. I have to do the deposit again. Yeah, and right now we are trying to make it run within the client itself and have connect the public chain, there is the go Ethereum fork running on the public chain already.
00:13:55.756 - 00:14:21.908, Speaker A: But we need to have a proper client pair doing this. Right. So how it works, it defines two functions. One is the genesis and the reset. So the genesis basically is deterministic genesis, which creates the new Genesis state for each network iteration. So it's. Let me show you how it works exactly.
00:14:21.908 - 00:14:51.216, Speaker A: Come on. Right. So how do network, how it's supposed to work? It always, we first define, the whole network is defined in what we call Genesis zero. Normally you have the testnet, the network defined in its genesis, right. But here we need to update the genesis which we've ever reset. So we create the Genesis zero, which can be hard coded in the client or can be like the base template. And this starts with some chain id.
00:14:51.216 - 00:15:30.766, Speaker A: I don't know, chain id 1000 or something. Right. Some number which probably, which should, shouldn't collide with any other public networks. It has its genesis time and we have to keep this variable, this information about a period, about one week, one month, how long the test is going to run. And now based on this Genesis zero template, whenever you start a client, it checks the current time. So it checks the latest timestamp and compares it to the Genesis zero timestamp. So based on this data, it can tell how many iterations of this period happened.
00:15:30.766 - 00:16:00.104, Speaker A: So if the period is one month, the Genesis zero was. The network was started a year ago, there was twelve iterations. So the I will be twelve. And based on that we can calculate the current chain id. We iterate it. So it will be the n plus twelve and the timestamp will be just the period times the number of iterations above the genesis timestamp. So you can calculate deterministically.
00:16:00.104 - 00:16:58.014, Speaker A: We can always calculate what is the genesis of the current network that you want to connect to. So you can just start a client and it will trigger. The idea is that when it's implemented in the client, you start it and it will trigger, not just listen, not just reading the normal genesis, which is hard coded, but using it as a template to calculate the current genesis. Now there is the reset which actually needs to reset the network, trigger the database dump and generate the new genesis by itself. So this is not currently implemented in any client. It's handled only by the external tooling. And the idea here is that if you want to actually do this, the genesis function is good enough because the automatic reset can be done using some script, some cron job, basically, very simply.
00:16:58.014 - 00:18:15.604, Speaker A: And this is something which the infrastructure structure need people who are actually running the explorers or validators and so on, they need this reset function. And for you to actually run the node, test your own validator, well, you can always just use RpC or you can run the node easily based just on Genesis function. Why do we do this? Why we always need to generate the new genesis is because of security, mostly the replay attack protection, because if we keep the same network, you can just use the same transactions which have been recorded from the previous iteration and steal money, drain the faucets and so on. And the idea is here that we have the single specification which can be done either by the external script tooling or implemented in the client. And that means that we are right now running the client implementations with this init and those clients which just use the bash scripts and they are compatible. As we develop it more in the clients, they can join the existing network. We don't need to fork it into a new one or anything, it's backwards forward compatible.
00:18:15.604 - 00:18:52.230, Speaker A: Yeah, so this is how it looks like. And yeah, the EIP is in process, just draft pr. I'm scared to merge my open pull request for the first eap I'm doing, but there is still some community discussion about details and specification. I'm still getting feedback from some client devs. So you can find the PR 6916 and you can check the files, you can read the EIP there, it's all there. Cool. And yeah, why I'm talking about this because I want you just not to use.
00:18:52.230 - 00:20:02.412, Speaker A: I would be very happy if you use it ever, but also to maybe contribute. So if you actually start using it, I would be very happy if you let us know some issues feedback in the repository that I showed you, you can open issues, you can join our metrics channel and yeah, so if you run your node or validator, please let us know the experience and based on this you can actually identify what is missing. There is actually a few things missing. We are not running the forkmon, we are not running the Eatstats, we have a bunch of explorers and so on deployed. But there is maybe something that you are using and you miss in the infrastructure around Desnet. So you can contribute by starting this, building this, and yeah, helping with the DevOps tooling, which again I'm explaining that this is the bash script implementation is the main one to use, but you can do this in any other way that you prefer. Maybe you can do it in some ansible scripts, maybe you can use some python or something to end up with a different but better user experience handled alternative.
00:20:02.412 - 00:20:41.558, Speaker A: How to deploy the fMRI client and. Yeah, and ultimately, if you are into the client development and you'd like to look into implementing this custom network in some of the clients, that would be very, very helpful. And the idea here is that you might be doing this with an EPF. And I'm going to talk about this tomorrow as the very last talk of this conference. But there is the Ethereum protocol fellowship happening right now. If there is anybody interested in anything within the core protocol development, if you're technical and want to dive into this, if you want to learn about core development, please just pet me here, find me here. I'm really glad to talk about this.
00:20:41.558 - 00:21:33.922, Speaker A: The applications are closing in one week on Friday, and this is completely open permissionless program which can help you to dive into the core and even work with the current core devs. And one of the projects that you can work on that I propose here is implementing this testnet within the clients and helping its infrastructure. Right? You can, yeah, you can use it for your short term testing, validator testing, and it's all on fMRI dev. So on this website, very simple to remember, right? You have all the resources linked to those repos, link to our metrics chats. We have a metrics server where we are discussing all of the development and if you are interested in having the discussion, please join us. Yeah, maybe. Before I finish, I would also like to mention that there is going to be the Holoswicz Testnet coordination call on Thursday.
00:21:33.922 - 00:21:47.514, Speaker A: We're going to attend it as fMRI testnet people. But anybody who is interested in testnets or helping with the next iteration of the public tested infrastructure can join. And I guess that's it. Yeah. Thank you so much.
