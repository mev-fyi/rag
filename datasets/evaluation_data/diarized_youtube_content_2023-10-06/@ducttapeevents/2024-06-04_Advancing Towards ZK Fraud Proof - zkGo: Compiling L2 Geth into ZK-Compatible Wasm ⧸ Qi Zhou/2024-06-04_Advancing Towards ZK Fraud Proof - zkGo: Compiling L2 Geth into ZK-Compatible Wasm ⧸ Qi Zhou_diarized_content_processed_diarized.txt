00:02:11.634 - 00:03:18.638, Speaker A: Of the example like Ethereum and current plan is to use the data availability technologies so that each node does not need to download all the data rather than just have the pieces of data and then be able to sample the data, the rest of data in the network. To know that oh, this data is guaranteed to be downloaded by everybody in the network. So that's basically the target of DA. And also that requires some like requirement in terms of CPU. For example it requires some decent core number of cores of CPU with some memory and also storage. For example a fresh ethereum nodes now require about 1 storage and sometimes grows higher because it has to have some intermediate stage during the execution. So to solve the cpu requirements and also the storage, the basic idea here is to using some proving mechanism.
00:03:18.638 - 00:04:10.232, Speaker A: For example ethereum proposal is for status NIST client so that we can quickly verify the execution. Because here we just need to validate so we can quickly verify this execution of these results using low performance cpu. Or the cpu can be smart contract on top of ethereum. That is for app L2 and very small amount of the storage. Just maintain some key minimum data using the constraint resource constraint environment, which definitely can be our notes in our cell phone or in our like iwatch or the l one blockchain. And that is the smart contract. So in the ckevm category it sometimes is called type zero.
00:04:10.232 - 00:05:18.142, Speaker A: EVM. Why it's called type zero? Because it's super general and which means that we are able to use in any language of code to write all these like just like a normal execution client. And then we can proofread introducing for example new circuits in maybe different ck setup like plunkish. So what is Ck? Vm is generally we try to solve the problem or satisfactory problem that given a program and the instruction set architecture, it can be mips, it can be Warsaw, it can be xx six. We want to verify that given the input output of this virtual machine, its execution result is correct. In order to verify this, we first need to choose ISA. So there are a couple of isa that we can choose, for example Watson, RisC V, mips.
00:05:18.142 - 00:06:21.394, Speaker A: Those are all open source, which means that we can use them freely. And definitely there are also x 86 which is proprietary and arm. And we have a compiler which basically is able to compile any high level languages to this low level instructions. So on the right hand side is assembly language called web assembly language in terms of Wat format tells what is a very simple instructions to add two variables. So here we choose to use in the Wassen languages to prove a long execution of the Wassen so that we can compile any high level language code in wasn't and prove execution its execution is correct. Why we want to using wasn't because wasn't becoming most popular language in the Internet. For example, almost all the computer with the browser supports execution of WASM.
00:06:21.394 - 00:07:19.274, Speaker A: And so that also have a bunch of the tools that support execute the WASM languages or the compilation. And so next question is which language we would like to choose to program the blockchain and then we would like to translate to as a language that can provide Zk. And here we use the Golan. Why? Because Golang is perhaps one of the, I would say easy to learn language with pretty capability to scale. So on the right hand side is one of my favorite graph which shows how many years. So six months, one years, two years, three years, five years. And then on the y axis is the percentage of the programmer can believe is mastering these languages.
00:07:19.274 - 00:08:07.572, Speaker A: So for go it just take about a couple of months or one year, so that every developer is quite confident that they can understand how it works, can safely write a code. And there are a couple of other language, I think there's one is C languages. The curve can be even goes down because when I use C languages to write some code, I feel, oh, there's so many new features that I realized that, oh, I have to learn more and learn more. And then I realized, oh, actually there's a lot of things I need to understand. And so it's because it's so complicated and I also have garbage collection. All these features that can also simplify the burden of developers. And in the Ethereum world, Golang is also widely to develop the client.
00:08:07.572 - 00:09:06.622, Speaker A: For example, both famous like consensus client and execution client, the Golan implementation are the most popular ones. For example, go Ethereum at the time of writing, after about a couple months ago, it's more than 80% of the adoption right now is a little bit decreased. And also prison is also written in Golan. And also if we check the historical of the execution layer or consensus layer development, you can found there's a kind of method effect that once the client has been adopted for more, there will be more people to maintain it, to fix it, and then it become more stable and then more people will come further to use it. And this goes to this circle that it will become more and more people using one specific type of client. And this is happening. And that's why even like Ethereum is encouraging for client diversity.
00:09:06.622 - 00:10:10.544, Speaker A: But still a lot of people, including myself using Go Ethereum as my stakers. So now with all these environment setups, we would like to narrow down what we like to achieve. So first of all, we want to compile the L2 execution layer that is returned in go. Sometimes we call L2 guess or opgas and compile it into the WASM. And then we have a WaSM verifier prover that can prove that this long execution of WASM code is correctly so that we are able to use in very constrained environment, including for example layer one, smart contract or even like iWatch to verify that execution is correct. And this is one of the, I think the candidate for the future Ethereum and gain. And this is a really good starting point.
00:10:10.544 - 00:11:25.224, Speaker A: But when we dive into the details to implement all this, they found there's a lot of challenges. First of all, even though WASM is widely adopted in like for example for all the browsers, it is more suitable for an Internet browser environment with very limited interfaces to perform. For example, system calls, for example create a connection raw socket to connect to the underlying resources or accessing the files. So here we list all the basically key challenges, both in terms of the browser environment. That wasn't the compiled go Ethereum in WASm that is basically looks like so that we are not able to use in the ZK environment because Zk only have two inputs, private input, public input done. So we need to change this kind of host environment, that is the interaction between the WASM code and the host external environment. So to make sure that we are still able to execute the corresponding layer to guess, but with minimum changes of this code.
00:11:25.224 - 00:12:36.846, Speaker A: Second is that there's a huge diverge IO models there versus wasn't, and also the wason model that's as I mentioned, in a ZK environment that's public and private inputs. There's also a couple of others, for example floating point instructions that is not able to support in most of the ZKVM setup. And lastly is some detailed implementation of Golan that have really weird execution, the exit semantics, which is quite different with what we expect. So for example, here is a code that we compile, the goal ethereum, the L2 go ethereum. And then we here list all the APIs that the Wasm code relies to. You can imagine kind of a system call so that they can execute a code correctly. And all these APIs, for example, have file descriptor read, file descript write clock read, and all kinds of things are essentially impossible to be supported in a Zk environment.
00:12:36.846 - 00:13:39.910, Speaker A: How we are able to translate all those things into a ZK friendly interfaces with public input and private inputs. This is something you have to adjust. And so this is basically the target of a Zk goal. First, we do not want to re implement the go compiler into go to the wasm ourselves. So we made a deep modification of the go compiler, so that with some modification we would like to have it to be able to directly compile any golem into Zk friendly worsen. So the ZK Go is basically open source, and we also work closely with our collaborators to make it happen. And one, I would say attractive feature of the ZK Go is that it maintain support most of the go features.
00:13:39.910 - 00:15:11.626, Speaker A: For example, garbage collection and go routine is also supported by written in WASM languages with this I O, so that it just needs about three dependency of the external host environment, public input, private inputs, and whether there's something that's wrong, then it will exit the execution of the WaSM VM early. So besides like replacing all this, we also have for example replaced the unsupported instructions like Volt employee instructions called using a soft float, that is using the integers to mimic the execution of a floating point so that we can translate single floating point instructions to multiple integer integer operations and yeah, a couple of things. So let me see. Yeah, this is for floating point instructions. And so yeah, this is something I would like to show. So for example, suppose I would like to write, write a simple go code to verify like a calculation of Fibonacci sequence. So if I using the traditional go code, I will first read the data from, for example from the CLI and then do some calculation that is 1000.
00:15:11.626 - 00:16:25.884, Speaker A: And then finally I print the corresponding outputs. Because in a Zk environment we only have public input and private input, so that we will first read two public inputs from the external so that we are able to verify what is the inputs that the user supply during the verification, do the calculation, and lastly, and then we verify that the corresponding calculation result equals the same as another public input. This is basically how the Zk verification does. Like. Basically I provide three public inputs, the first two variables and the results, and then the Zk verifier will tell me whether it is correct or not. So it is solving this satisfaction problem. And since we are a go compiler, so this is the so for using go it just go build the Fibonacci go program and using Zk go, then it has the same semantics to using it just say, hey, I want to build the gold code, but the output will be the Wasm.
00:16:25.884 - 00:17:34.984, Speaker A: So that it will be generated a WaSM code that can be directly proved by the Zkwarson prover. For example here we use indefinite CLI which provides kind of like some parameters both into especially in terms of public inputs. For example, the first two initial variable of the female sequence will be zero and one and also would like to verify that the ending result is some large number after doing the Fibonacci sequence in like a 1000 calculation. And then we can basically using this CI we can prove this language and also create corresponding the verifier in solidity and then deploy this verifier and to make sure that the code is correct. So in this way we greatly save the developer, especially developers that would like to use in Ck to solve their calculations without writing any circuits. Just write a Golang code, whatever you want. It can be even complicated as go it there.
00:17:34.984 - 00:19:00.554, Speaker A: So for example, one application that we are going to solve is to verify the off chain execution of L2 guess L2 execution layer so that we are able to, for example to use in a Zk four proof tell that the L2 sequencer when it posts some result, I can instantly challenge that something is wrong. So the previous design using a binary section which I actually explained yesterday that it takes about 73 interactions of on chain in order to figure out which instructions is incorrect and also need to take about seven days to settle. So using Zk now we are able to program all this L2 in gas, compare it into white wasn't and prove it using single transaction and verify on chain if something is wrong. So this is basic idea of ck four proof. We are glad that we receive a grant from op stack to support us to do the research in this area together with riser zero and also olabs which are targeting for different ISA. So ris zero is targeting for RiSc five and zero one labs is targeting for mips. We are targeting for uh wasn't.
00:19:00.554 - 00:20:12.808, Speaker A: And so the general goal is that we are able to reduce have much shorter latency, just proof time plus one time transaction and tells that hey, there's something wrong on the option of execution and for any general purpose like L2 guess. And one feature I like most for the ZK fraud proof is that it can be easily to upgrade to support new Ethernet eips for example 7702 because it compels any for example layer one changes in new changes to the L2 and compile in the Watson and directly proof using ZK VM technologies so that the cost of supporting upgrade is almost negligible. Versus in the traditional ZkVM, like type one, type two, type three. If they would like to support these new features in general, they have to re implement the circuits and audits and all these highly complicated things. And it's called Zkevm. Scary. They're scared.
00:20:12.808 - 00:21:23.454, Speaker A: Once there's an upgrade, introduce some, for example new hash or new simple features. They have to reimplement all these things in the circuits, which is extremely difficult and very easy to produce new issues and takes time to verify. And using ZKVN and fluffer approach, we can instantly support all the new upgrades. Just copy the layer one code to L2 guest recompile, generate the corresponding verifier, upgrade done. And this will also help to contribute to multiprovin system that we also participate with the RiSC zero and also the one labs. And so we are able to compile the L2 execution engine that is Opgas with some minimum modification of the Go ethereum, but generally basically some IO adaption. And so now we are able to generate the whole WASM, be able to compile and then be able to prove it using the, the whole ZK WaSM setup.
00:21:23.454 - 00:22:38.156, Speaker A: Yeah, and so we can do a lot of things because we can basically prove any arbitrary execution. So one crazy idea is that we are able to prove a lot of off chain database, like sampling all these things using ZK go without writing a specific circuit. And also we are able to like do a lot of off chain calculation fixed in machine learning. And then we can using the basically ZK four proof to prove that off chain interference on machine learning is running correctly. So we are also working with hyper Oracle to help solve this problem and a lot of couple of interesting work to be done. One thing is to accelerate this proving procedure, because this requires tens of billions of instructions, which is perhaps the largest proving system that we found in the world. And so it require a lot of optimization like using parallelization multiple gpu's so that they can run in parallel and so that they can save the time and also be able to aggregate the proof, proof of the proofs.
00:22:38.156 - 00:23:48.424, Speaker A: This is general ideas so that we can aggregate them and then using a single proof to prove all these parallels proving results. We are also working on customized host circuits, especially for some instructions that commonly used in Ethereum like pre compiles ecca we can use in customer circuit to support it, so that we can reduce the trace of the we need to proof. And also a couple of new proving system like Vitaly mentioned, there's a growing of the called smaller fields like binance, all these smaller fields. And so how we are able to utilize this smaller fields and to incorporate to proven the WASM code is a very frontier of this direction. That's all I have for this talk, so there's a lot of technical details and happy to answer more questions if you have. Thank you. Any questions? Sure.
00:23:50.964 - 00:24:43.344, Speaker B: Hello again. I wonder what, like what how does this compare with the existing ECK vms like starquare for example? Or even I know this is not SDK Evm. So it doesn't necessarily run the Ethereum, the EVM protocol, but it does in any way, I guess verify random or whatever programs. So it kind of relates with RISC zero in a way, and also with starkware or Cairo, even though those aren't necessarily compilable via high level languages, but also like Polygon Maiden and all these kind of high level language compilers to wasm. What's the main difference? Are just the competitor not shaming sometimes.
00:24:43.804 - 00:25:41.450, Speaker A: Yeah, that's great questions about the comparison with maybe other solutions like stockware or fixture resistrial. I think I should really put a table for the comparison because I think I get too much much details today. So compared to stockware, first they have their CK like languages, ASA, so that they are able to prove the language using their Carl prover, all these tools. One major difference is that for the support of Carol is still, the tool set is still pretty in early stage. I know there's an idea that using Carolyn write some a lot of code to emulate EVM like Kakara is doing. I think this is really interesting direction. But at the same time, one thing is that they have to re implement all those things in the Kera language.
00:25:41.450 - 00:26:53.444, Speaker A: But for us, if people are familiar with Obstac, so right now they are L2 or L2 guests is a minimum modification of gold Ethereum that is affecting 1000 lines of changes to support a bridge between layer one and L2. The great benefit of this that we are easily to reuse existing mature code of gold Ethereum that has been developed, which I show why it's been widely adopted, because a lot of you see a lot of people are fixing it, optimizing it. So yeah, so we are able to reuse all these benefits compared to stackware. Need to rewrite this EVM stack in Cairo and also make sure it is upgrade to the latest eips if there's some Ethereum upgrade almost every year. So for those things we do not need to worry about, we just recompile merge the code, recompile and then submit a new verifier on chain. Done. So this is, I think, the great benefits versus the stack rail approach.
00:26:53.444 - 00:27:04.144, Speaker A: Cool. Yeah, I think I run out of time. So. Happy to ask me a question? I'll be here. And, yeah, thanks for attending my talk.
