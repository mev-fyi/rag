00:00:00.560 - 00:00:39.854, Speaker A: So, hello everyone. My name is Philipp. I'm researcher at Rockaway X. And today I'm going to talk about very computation and AI and a little bit about myself. Before I started working in crypto, I actually spent four years working as an AI researcher at CERN, where my role was coming up with novel, deep learning architectures to solve some of the big problems in particle physics. And so, naturally, given my two backgrounds, AI and crypto, I have always been interested in the intersection of the two. And so this is what my talk is going to be about.
00:00:39.854 - 00:02:40.900, Speaker A: I'll start off introducing three problems that we are facing today, then give some broad introduction into ZK piece and how it works, and then I'll show how we can use these techniques to solve the three problems I'm going to present. So, first one is about generative AI. So with the rise of powerful generative AI models become mid journey chat GPT Dali it becomes ever more difficult to distinguish between what's real, like real images or videos, and what's being just generated by some powerful AI's. And so the problem I'm going to be talking about is how do you make sure that when you see some picture or like a drone footage online, how can you make sure it was really taken at some place at some time, and it's not just an AI generated content? The second problem I'm going to be talking about is KYC and privacy. Like, as you all know, you've probably all had to go through some KYC or AML process in your life. Like, usually when you want to use some financial application, you have to prove who you are and how it works is you take a selfie or you provide some documents and you send that to some third party and they will verify, okay, this person really says it's true that it is who you say he is. The opportunity here is, can you bypass that? Can you pass a KYC while preserving your privacy? I think this is going to be really important because there are some, as regulators are coming after crypto, there are some attempts to basically use smart contracts for Defi only if you're a Kyc.
00:02:40.900 - 00:03:29.484, Speaker A: So having, like, a Zkycyc, I think, would be a very important piece of infrastructure. And the third is that today, smart contracts are really not that smart. Even Vitalik says that he regrets calling it smart contracts because really, it's sort of like a persistent script that you can call. And so is there a way how to make smart contracts actually smart? So, first of all, I'd like to introduce zero knowledge proofs. This is a technique I'm going to be talking about a lot, which can be used for all of these problems. And you can define in many ways, but the important thing is it's sort of a short proof that a statement is true without revealing any extra knowledge. There are always two actors in the scheme.
00:03:29.484 - 00:04:27.118, Speaker A: There's a prover and verifier. You can give private or public input to the prover. You can use a private or public program, you run the program, create some execution trace, and also generate the proof that you then send to a verifier who can decide, I accept it or I don't accept it. And the most important impact is with zero knowledge proofs you can arbitrary long program computation with optionally private, and it can be verified in constant time, and optionally privacy preserving way. And the two ways how zkps are used are for its zero knowledge property and its succinctness property. That means that the proofs are short. So how to use it for knowledge property? You can, for example, say, I know a password to an account and I want to access the account without sharing the password to anyone.
00:04:27.118 - 00:05:34.070, Speaker A: So you can avoid many the middle attacks. And the second way how to use it is for example how rollups use it. You can execute potentially millions of transactions of chain, and you want to prove that all these transactions were valid. So you can aggregate those proofs together and verify it on chain and all under 1 million of gas, because the proof is very short. So how does the pipeline for verifiable computing normally look like? So again, you have some public or private data, you do the computation as well as zero knowledge proof generation of that computation, and you verify it somewhere. And one of the problem is that like with machine learning, if you input some incorrect data, you're also not going to get better result. So for many use cases, we need some attested sensors, like some sensors that can also sign the outputs.
00:05:34.070 - 00:06:28.936, Speaker A: Then for zero knowledge generation the problem is slow. And this is why even though the technique comes from the eighties, it has always been sort of in the minds of theoreticians as something that can be done, but will never be practical. But only in the last five years this actually become practical and they can be paralyzed and hardware accelerated on FPGA's and GPU's essecs. And last is zero knowledge proof verification. I'll be talking about on chain verification. And I mean, that is expensive per one proof, but the fact that aggregate them sort of amortizes the cost of verification per one proof. And why would you want to verify it on chain? Like, you know, you can verify it on any device.
00:06:28.936 - 00:07:29.264, Speaker A: And my argument here is that Ethereum can become the most trustworthy zero knowledge verifier, because in the schema I showed before, the prover, like another really cool thing about this is you don't have to actually trust the prover. This is why ZK rollups work. It could be your biggest enemy, like Darth Vader running the machine. But you know that you can only produce a proof that is correct, or it will not produce the proof at all. But who can be dishonest is of course the verifier. The verifier decides, do I accept that proof or not? And of course you might not trust the verifier, but since Ethereum strives to become the most credibly neutral system, it's ideal ZKP verifier. And how you can solve the problem of the cost is by recursively aggregating the proofs together.
00:07:29.264 - 00:08:20.834, Speaker A: And one last theory before going to the examples is if you want to use zero knowledge proofs for privacy preserving computation, you can also do that when the computation does not leave the model where you want to store your private data. So there are essentially two ways I was using. Either you don't care and you use some public input data for ZK rollups. It's being run on some huge computers that are optimized for zero knowledge proof computation. And then you potentially verify it on chain. Or if you want to use it for privacy preserving applications, it has to be running on the client side. So you produce the proof on the side where the private data is stored as well, and then you can verify it somewhere.
00:08:20.834 - 00:09:08.272, Speaker A: So now let's go to the examples that I showed previously. So the concrete problem is, how do I know that when I take a picture, it is a real picture and nobody has used Photoshop or edited it somehow. So you need something like an attested sensor. This is something that's already happening. For example, there is a standard called c two PA and Sony and other manufacturers are now adding essentially private keys to their devices. And how it works is the producer generates a private key, they embed it to the device, and then they delete all copies of the private key. So it can only be this device signing it.
00:09:08.272 - 00:10:25.838, Speaker A: And then whenever you take a picture or make a video, it signs the output. So you took a picture of some person and you also signed the metadata, such as type amp or the GPS location. And then you can verify the metadata by checking signature and say, okay, I believe you that this picture was really taken in Ukraine at this time. So I know it was not generated by some AI, but the problem with this currently is that usually you don't want to be using the raw image files because they're too large, or maybe you want to modify them a bit. And whenever you do some modification, like any edit to the picture you took, it no longer works. You can't verify it because it's a modified picture. So what if you could use ZK proofs to for any edits you do, you also generate the ZK proof that this is what happened, and then you could verify this output of the honest edit.
00:10:25.838 - 00:11:13.014, Speaker A: So for example, you could show the only thing I did to the image was resizing or maybe changing some brightness, but I didn't use Adobe and they didn't add some new people in there. How the pipeline does looks. You have some attested sensors. It could be camera as an example, but it could also be voice, keyboard, or any other sensor. And then you prove that you edited it honestly and you can verify wherever, but you could do it on chain because that's the most trustworthy verifier. The second example, how to pass KYC without losing your privacy. So as I said previously, data cannot leave the private, data cannot leave the device.
00:11:13.014 - 00:12:10.586, Speaker A: So you have to do the ZK proofing on the same device where the private data lies. So again, you have some attested sensor, maybe a selfie or like lidar on your phone voice, or maybe even a fingerprint. And instead of sending your private data to some third party that does the checking for you, you can essentially have some machine learning model that matches your selfie or def camera to some other data and you generate the proof that you are who you say you are and the private data leaves the device. And then you just send the proof to whoever you want to convince and you're a KyC. And the third is smart, is works like this. So this is Ethereum. Ethereum produces blocks every 12 seconds.
00:12:10.586 - 00:13:09.954, Speaker A: And the reason why you can't run arbitrary computation on Ethereum is you only have 30 million gas limit. It's because blockchains are very robust and credibly neutral machines, but they are super slow. So you can, for example, only fit like 100 uniswap swaps in one block. So if you wanted to run something like JGPT, it's completely out of question. And so how rollups work, for example, is as I said previously, you perform the transactions or state state changes off chain and you send the state differences to call data or after prototyping, charge to blobspace. That will make it cheaper. And you also send a validity proof that all of the transactions happening here were indeed honest.
00:13:09.954 - 00:14:39.406, Speaker A: And so how you could make the, this is sort of, you make the same computation, but you just do it elsewhere to save gas, right? What you could do with zero knowledge machine learning is have optionally private inputs or public inputs, run some arbitrarily complex machine learning model, and then have that inference, have the output of that model, and also generate a validity proof that this is indeed what happened. And you can have that verified on Ethereum and used with some other applications. So what are the challenges of zero knowledge machine learning and why we don't see GPT four being verified on being used with applications today? And it's mostly that the attested sensors are not really widespread. There is the standard I talked about, but it's still getting slowly adopted by major companies. Second is quantization and sort of the dichotomy between what machine learning models need and what will zero knowledge proofs need. And it's about like floating point precision. Like if you have low floating point precision with machine learning models, it reduces the accuracy of your model.
00:14:39.406 - 00:15:32.014, Speaker A: But on the other hand, if you use higher floating point accuracy or precision, your zero knowledge model will be super, super slow to generate proofs. And the ways how you can solve that is there are some attempts to do weightless neural nets, or you can use zero knowledge proof hardware acceleration on GPU's, FPGA's, or asics. Similar story with circuit sizes, large models. For example, GPT-3 has like 175 billion parameters. And even though now we can make zero knowledge proof generation in quasi linear time, the overhead, you can still think it's between 1000 x and 1 million x. And generating inference on chat. GPT is already pretty expensive.
00:15:32.014 - 00:16:23.854, Speaker A: Imagine multiplying the cost by, for example, 1 million. So it's not really feasible today. But again, what you can do is both the proving systems are getting improved and the hardware is getting improved. And last problem is adversarial attacks. This is like big problem in machine learning in general. And that is like, no models are perfect, and you can always find, let's say, an adversary example, that when you have a trained model, you can give it such an example when you fool it. For example, if you have a Tesla and you want it to stop on a stop sign, and it's been trained to recognize a stop sign and stop there, you can create an adversary example by printing some carefully made sticker you put it on the stop sign, you don't even see it.
00:16:23.854 - 00:17:08.918, Speaker A: What Tesla thinks it's go faster sign or something. And why this is even bigger problem in zero knowledge machine learning is that if you know what the input data is and for some reason your model is behaving incorrectly, you can maybe debug it later. But what if you actually never see the input? Because that's the point. So there's some sort of. Okay, so there's one more slide. So the problem is if you never see the input, you actually don't know if people are sort of doing attacks on your model or not. So this is sort of fundamental problem with zero knowledge machine learning.
00:17:08.918 - 00:18:15.374, Speaker A: And one way how to mitigate that is just increase the number of ways to authenticate. So instead of just matching your selfie to your passport for zkkyck, you could also match your voice or fingerprint or depth camera and just make it harder for people to find adverse attacks for the models. And so how can you use the react machine learning today? You can use generic compute, like RISC zero, and you can use any rust program and use the zero knowledge virtual machine for any use cases that we showed before. Or you can if you want to make like fast, if you want to use it for machine learning specific models. There are some zero knowledge machine learning specific libraries like S IQL or ZKML that will make the proving much faster. And we have, we have done like Zkwirdle and Risc Zero. You can play it here zkwirdle dot rockawayx.com
00:18:15.374 - 00:18:26.294, Speaker A: and that's it. Thank you for your attention. Are there any questions?
00:18:26.714 - 00:18:28.574, Speaker B: We have time for one or two questions.
00:18:53.654 - 00:18:56.354, Speaker A: I didn't hear it properly. Do you verify?
00:19:03.114 - 00:20:03.214, Speaker C: So how does that interact where in the verification process they train on it. And this input is then used for training the model. Right. So how does that like, how do you link to them? Because in that case. Thank you so much. Is there any way this data can still remain private when you have.
00:20:05.314 - 00:20:09.370, Speaker A: I don't completely understand, but let's discuss now. Yeah, cool.
00:20:09.442 - 00:20:24.278, Speaker B: Thank you very much. The speaker is going to the bathroom coming in 1 minute and we can start. We speak 1 minute later. You are going to be around?
00:20:24.366 - 00:20:25.062, Speaker A: Yeah.
00:20:25.238 - 00:20:26.174, Speaker B: What invite you to, I think.
