00:00:09.200 - 00:00:31.514, Speaker A: Hi, welcome everybody to the third day of East Prague. My name is Raul Chaffreneck. I'm from runtime verification. I hope you all got a good coffee in the morning. So this workshop is an interactive session. So if you brought your laptop you can actually follow along, but you don't have to. So you can just also follow me on screen if you want to.
00:00:31.514 - 00:01:39.414, Speaker A: I will introduce my company in a minute, but before I do that, I want to start the installation process because I know that can take one or two minutes. So here's a quick agenda of today we will have an installation party of symbolic, which is a solidity debugger and it doubles as a symbolic execution engine. Then we have an interactive session that just shows how you can use symbolic as a classical debugger where you can set breakpoints, where you can step through the code, where you can inspect the storage and the memory. It's all integrated into visual studio code. Then I will do a little bit of an introduction to what symbolic execution is because, well, that's not a well known concept out of academia. And finally I will show you the extended mode of symbolic, which is this advanced symbolic execution mode. So to participate in the demo or in the beta, you have to get an API key from this website.
00:01:39.414 - 00:02:20.698, Speaker A: You can just take your time. The website is symbolic dot runtimeverification.com and everything you need to do is you just need to log in and then after logging in you can do it with GitHub, with Google, or with metamask. You will get an API key at the bottom of the dashboard that you can copy. I will bring up this slide later on if you didn't have the time to copy the website URL. So it's symbolic dot runtimeverification.com and then there's four steps that you need to take.
00:02:20.698 - 00:02:58.812, Speaker A: So create a free symbolic account. That's the first step that I just described. Then you need to install the visual studio code extension and you can just go to open your visual studio code or codium if you're using codium. And then just go to the extensions and search for symbolic. And symbolic is spelled s I m b o l I k. So it's with a k at the end and I will get to that later. And then in the extension configuration you need to copy paste or you need to paste the API key that you just got from the website and you need to have foundry installed on your system.
00:02:58.812 - 00:03:23.480, Speaker A: So these are the basic requirements. So let me just show you. I can do that at the same time. So that we match the speed. So that was the wrong website. So it's symbolic dot one timeverification.com login with either Google Metamask or GitHub.
00:03:23.480 - 00:04:07.724, Speaker A: I use GitHub. I hope the network connectivity will be not a problem doing this demo. All right, so you copy your API key from this field, please don't copy mine. I will just, we generate it after our workshops here and it won't work for. Oh, there's a question. Yeah, let me see. Okay, I haven't seen that one.
00:04:07.724 - 00:05:14.580, Speaker A: Another one? Yeah, if you have metamask, maybe. I think that's what most users are using. Yeah, but fetch me after the talk and I will take a note and take this to our website team. So you copy the API key, you open visual studio code and then you search for symbolic this extension and you go to the extension settings and you just paste your API key in this field in the first field. So I already did that. And then I will use this demo repository for this workshop. You can also try to use your own foundry project to follow along, but you don't have to do that.
00:05:14.580 - 00:05:54.514, Speaker A: I recommend really use this example project so you can git clone runtime verification, symbolic examples. And I will give you some minutes. In the meantime, while you're doing that, I will leave that slide open and I will just introduce a bit of my background and a bit of the background of my company. So I'm Ral Shafranek. As I said, I'm working as a formal verification engineer for a company that's called runtime verification. We are a security company and we do, well, we do all kinds of security stuff. We do audits or code reviews, but we specialize in doing formal verification.
00:05:54.514 - 00:06:49.538, Speaker A: And we have different open source tooling for doing formal verification for solidity, but also for rust based ecosystems. And some examples of projects that we formally verified is we formally verified Uniswap V one. We formally verified the beacon chain deposit contract from the Ethereum foundation. We are currently doing long running engagements with lido and with optimism. And so you figure, well, all these are high profile customers, but we actually want to. So it's been proven that formal methods are useful to harden your security. But the problem at the moment is a little bit that, well, we don't only want that like high profile customers with lots of money can do it.
00:06:49.538 - 00:07:32.684, Speaker A: We also want that every developer and every independent security researcher is able to run his own form of verification. And that's why we developed symbolic. And symbolic is really, it's my hard project and it's really like a tool that should lower the entry barrier to formal methods for everyone. So you just start with a classical debugger. You can set breakpoints and stuff. And as you learn more how this works, you can then advance into this symbolic execution mode and transition into becoming basically a formal methods expert without having a college degree. Are you good? Okay, great.
00:07:32.684 - 00:08:12.072, Speaker A: Everybody's good with the slide here, so I can continue. All right, so it's demo time. So if you have checked out this repository that I showed you, there's two solidity files in here. This is the first one. Is the font size readable for everybody? Or maybe not. Is this better for everybody? All right, so this is a very simple ERC 20 contract. It's intentionally simple so that it doesn't detract from the content of this presentation of this workshop, which is really the debugger itself.
00:08:12.072 - 00:08:47.474, Speaker A: So it's like any other ERC 20 contract, but it has a critical bug in the transfer function, and, well, we will. Maybe you can spot it. It's like a textbook prime example of a bug. So it has all the classical functions. It has a transfer function, it has an approval function, and it has a transfer form function. And all these like the balance, the symbol and the decimal, they are just public fields. So it's a very simple implementation.
00:08:47.474 - 00:09:36.952, Speaker A: So, now how can we start debugging this contract? And if you have used a debugger like remix before, what you need to do is, well, you first need to compile this project. Then you need to deploy this contract on chain or on a local testnet. Then you need to get the address of the freshly deployed contract. Then you need to do a transaction to invoke your, to invoke the function that you want to debug. And we could have built a user interface for that. But we think that debugging configuration or a debugging session should be reproducible. So in our case, we don't have a user interface for that, but instead you just write solidity code to set up your debugging session.
00:09:36.952 - 00:10:45.374, Speaker A: And I can show you how that looks like. So here we have this under the test folder, we have this debug ERC 20 file that's just inheriting from our contract that we want to debug. And it has some constructor that takes no arguments. It's minting some tokens to some addresses so that we can actually use it. And then it has basically just some wrapper functions. For example, debugmint calls the mint function, and it's specifying, okay, who do you want to mint to? And how much tokens do we want to mint? So now the critical thing is, if you want to start debugging something, your contract must have a parameterless constructor and the function must be, the function that you want to debug must be, must also have no parameters. So I mean the contract under test, like the buggy c 20 token, of course it can have parameters like the a transfer function without parameters wouldn't make any sense.
00:10:45.374 - 00:11:38.534, Speaker A: But the debugging contract, it must be parameterless. And then you see right above every public external function with no parameters, you see this debug button, and that's just how you start a debugging session. So I will do this for the debug mint function. And what you see is on the right hand side, you see that it's automatically compiling your project, and then it automatically does all the deployment stuff under the background. It deploys the contract to a local testnet and it just jumps right into your transaction. And it always stops at the very first line of the contract. Because usually in solidity, while this debugger works on the EVM level, and usually there are some opcodes generated that get executed before you even jump into the function.
00:11:38.534 - 00:12:26.314, Speaker A: And we will in a minute, minute I will dive a little bit deeper into bytecode level debugging, but for the moment, let's stay at the solidity level. So what we can do now is we can just, what you would expect, we can just step into the function. This brings us now really to the first line of the function that we want to debug. If I step into another time, you can see that I'm now in the mint function of the buggy ESE 20 contract. So that's the actual function that I wanted to deploy bug. Let's take a look, maybe at this initial state, and see what we can see here. First of all, you will notice you can inspect the EVM states, you can see what has been the call data, what is the current program counter.
00:12:26.314 - 00:13:11.274, Speaker A: You can see all the values on the stack currently. You can see what's in the memory, and you can see inspect the storage and the return data. So I assume that most of you would have expected to be able to inspect solidity variables. And this is a planned feature, it has just not shipped yet. So at runtime verification, we like to build our tools in public and do it informed by feedback from the community, from the users that are actually using it. So we could either have like implemented that and then released the entire tool like one year later or two years later, but it will never be in a perfect state. So at some point you just have to release a tool, push it out.
00:13:11.274 - 00:14:03.688, Speaker A: By the way, most of symbolic is open source. The components that are not open source yet will be open sourced over the next weeks or months as they become more stable. But it's completely free to use of course. And inspecting solidity variables is something that we are currently working on and we will ship this gradually one data type and run data location at a time. But at the moment you get basically a full view on the low level EVM details in this variables view on the top left corner, of course you can also see the call stack. So you can see that we are actually coming from the debug mint function and we are now in the min function. You can well just step over, step over code, you can of course set breakpoints and then directly execute until the breakpoint is hit.
00:14:03.688 - 00:14:42.572, Speaker A: If it's hit. Yeah, that's the most basic functionality. And one word about the storage. So you can see that storage slot number six has this cryptic value. I think that's the owner address of the, of this contract. So if I am going to execute now over the next statement of the balance off. So when I increase the balance of the, of the receiver of this mint, you can actually see now that the, that there's another storage slot that is assigned 2000.
00:14:42.572 - 00:15:52.624, Speaker A: So why it's 2000? Let's look at the debug ESC 20 contract we called Mint lS 1000 tokens, so it should be 1000. But in our constructor we minted 1000 token to Alice before, so now in total it's 2000 tokens. So this storage slot belongs to Alice balance and then we are updating the total supply of our smart contract and you can see that in the storage slot. So the total supply is now 11,100. So all what you would expect the storage here, if you noticed at the moment it only shows you the warm storage and that's again a feature that we are like there's a difference in the EVM that tells you what is warm storage and what is cold storage. Warm storage is all the storage slots that have been accessed during the execution and cold storage is everything else, all the storage that was not attached. And at the moment it only lets you inspect the warm storage, so only the slots that have been accessed.
00:15:52.624 - 00:16:44.444, Speaker A: But basically we have a pending pull request. It just needs to pass code review until it's merged before it's merged, and then we will also have cold storage. So you can actually inspect the entire state of the EVM, you can inspect the full storage, you can inspect the full memory, the full stack, the program counter. Yeah, but, well, we just released this beta basically last week, so it's a pretty new tool to the market. So please be patient if it's not perfect yet. And actually we appreciate if something in this debugger is not as you would expect it. If you were hoping to get a solidity debugger and finally use it in visual studio code, and that's not what it is, then just let us know so we can make it happen.
00:16:44.444 - 00:17:32.213, Speaker A: The good thing is we just started developing it, so we are very flexible in terms of what features to prioritize next. All right, so if I step over this function, it brings me back to the debug mint function. Nothing interesting happening. Now, the debugger always drops at the last state of your smart contract. So because the final state of your smart contract just before the transaction is finished is usually very interesting. There you can see. Hey, did it revert for some reason? Did it, what's the return data and stuff like that? So we always, by default, we always stop at the initial state of the transaction and at the final state of the transaction.
00:17:32.213 - 00:18:14.842, Speaker A: Okay, so let's look at maybe at a more interesting example. So let's look at this transfer function, maybe again it stops at the initial state of the smart contract. I'm going to step into the transfer function or the debug transfer function first. So I'm now debugging. Oh, I'm hiding all this with my big head. So maybe I can just do it this way. So I'm going to step into, or I can just scroll up.
00:18:14.842 - 00:18:35.724, Speaker A: Man, I'm dumb. So now you can see where we are. So I'm going to step into the transfer function. So there's a required call loss here where we check that our balance is sufficient. By the way, I'm going to hide this one here. So it's checking that we actually have enough balance to transfer. This check should pass.
00:18:35.724 - 00:19:43.070, Speaker A: So now we are just memorizing, hey, what has been our balance before the transfer, then what has been the balance of the receiver before the transfer. And now we are basically just debiting our account and crediting the receiving account due event and we turn two because that's what the standard of ESE 20 demands. Has anybody spotted the bug yet? Okay, that's great because then I will show you in the next test. Actually, this debugging session did not trigger the bug so yeah, I'm not surprised you didn't spot it. So let's look at the, so I'm going just to step over this one again. It stops automatically at the final state and I'm just going to dismiss this debugging session. So now let's look at an even more interesting example.
00:19:43.070 - 00:20:13.700, Speaker A: Even more interesting. So this debug transfer self. So now we are transferring tokens to ourselves. So you see I'm calling the transfer function and I'm saying hey, I want to be the receiver of the, of this transfer and I'm also being the sender of this transfer. So I'm just transferring to myself. And what should be happening is nothing. My balance shouldn't change at all.
00:20:13.700 - 00:20:59.512, Speaker A: Right, so because I'm just sending money to myself. So at the end it should be as before. So there's also this assertion statement at the end that validates this. So I'm going to debug this one and I'm going to set a breakpoint this time because we haven't seen breakpoint in action yet. Breakpoint and the let me set it in line 32. That's where all things are still good. So up until here everything has been fine.
00:20:59.512 - 00:22:14.494, Speaker A: So now we are updating the balances of the receiver and of the sender of this transfer, right? So I'm going to update the balance of the message sender first and let's look at the storage. So my current balance is 10,000 tokens. After updating the balance from the message sender, it becomes 9000 as expected. So now, yeah, you have a question? Oh yeah, greater than 10,000. What would happen then if the value, I don't know. We do this, we have this balance off check, we check that the balance does not exceed the value. Yeah, you can, you can.
00:22:14.494 - 00:22:54.870, Speaker A: So yeah, and you're right. So the problem is now let's see what happens to my balance if I execute over the next statement. So you would expect it to go back to 10,000, right. So you really would expect it to go to 10,000 but it goes to 11,000. So I just like created money out of thin air or I just created tokens out of thin air. By just transferring tokens to myself I can just basically increase my balance to infinite. The problem is here that you see the message sender and the toaddress are actually the same.
00:22:54.870 - 00:23:49.072, Speaker A: And the bug is here where we use the cashed balance of the receiving end from before doing the, before debiting the message sender account. So that's the problem here? And there was a. So this bug, it may look superficial, right? So you have to like, be careless to introduce it into your contract or you have to do it on purpose. But actually, I have seen this in a, in a contest, basically the first audit contest that I ever did contained exactly this bug, like, exactly in this configuration. And this was my first contest, as I said, and it was confirmed as a. As a critical severity issue. And I thought, yeah, I made it.
00:23:49.072 - 00:24:20.262, Speaker A: Now I'm going to be rich. I called my mom, told her, hey, you can retire now. We are going to be rich. Don't worry, I buy you a nice house. It was year 2021, and I got $17 cents out of this high sorority finance. $17 cents? Yeah. So I'm still not rich.
00:24:20.262 - 00:24:42.624, Speaker A: So that's why I'm here today. Yeah, I mean, the finding is super critical and it has been acknowledged, but it was filed by, I don't know, 20 contestants who are doing this audit. And the way that these code platforms work is the more users report the same issue, the last, the payout.
00:24:43.124 - 00:24:45.812, Speaker B: Do you know that there is an approach, that you milk it first and.
00:24:45.828 - 00:24:49.852, Speaker A: Then you return 90% 2nd, do you.
00:24:49.868 - 00:24:55.824, Speaker B: Know that there is a novades approach, that you milk it first and then you return the 90% to the project?
00:24:57.084 - 00:25:00.304, Speaker A: Sorry, this monitor is way too loud.
00:25:02.124 - 00:25:12.384, Speaker B: What? Do you know that now is the approach of the hackers that they milk it first the project, and then they return the 90% and keep the 10% as the white hack?
00:25:13.404 - 00:25:14.184, Speaker A: Yeah.
00:25:16.004 - 00:25:19.700, Speaker B: For the others and for the record, that's the joke, but it's happening.
00:25:19.892 - 00:26:09.384, Speaker A: Yeah, it's not really white hat hacking if you are just expecting to get a profit out of it. I think if you're white hacking, then you should disclose vulnerabilities confidentially, like take a proper route and not just exploit it. And then. Because even if you're exploiting and then intend to return it, like returning from a hack, returning money from a hack can also go badly. For example, we have seen like people try to return money and then it got exploited by a math bot or something like that. So, yeah, so if you're a really wider attacker, then always choose the honest route and disclose it confidentially.
00:26:09.804 - 00:26:42.146, Speaker B: I remember that there has been the discussion recently that actually the wider hackers do not get that. I would say satisfactory both recognition and the bounty, because some projects just squeeze down the bounties or refuse whatever is being found out. They do not concern those as a high profile or high risks and consider those as low risks. So there's like a gray area where some people are turning it on into the white hacking of the hack first and return later.
00:26:42.290 - 00:27:20.912, Speaker A: Yeah, I see that. Yeah, I think it's a matter of security politics, basically. Okay, but has everybody now understood where this bug is coming from? Okay, I see you all nodding. That's great. So nothing interesting is happening after this bug was triggered. Now I just minted tokens to myself, critical bug, not very nice. And now I see really that I have an exception, an assertion failure at the end of my debugging session.
00:27:20.912 - 00:27:58.020, Speaker A: So because I put this like, this is like a test case, basically, this is like a unit test that asserts at the end the balance before should match the balance after. If I'm just transferring money to myself. And the cool thing here is, well, you need to, you don't need to set a breakpoint anywhere to trigger it. So I'm going just to clean all breakpoints. Cool thing is really you can just restart this debugging session and directly execute it. And because this debugger automatically stops at the final state, it stops here at this assertion as well. So that's a nice way of also just doing unit tests.
00:27:58.020 - 00:28:56.804, Speaker A: It's a poor man's way of doing unit tests. Basically, that brings me to the next feature that we are planning to do so well, you probably already have a foundry test suite for your smart contracts. So what we are currently doing is we are implementing foundry cheat codes into this debugger so that you can actually just, if you have a foundry test, you can just execute it right out of the way and pranking and assuming things about your initial state, they will all just work as, just as in foundry. So you don't need to write like a debugging replica contract like we did in this case. For many cases, you can just reuse your existing foundry tests, basically also as a configuration for your debugger. And the nice thing is here, well, also in foundry tests are just code. They are committed to the code base.
00:28:56.804 - 00:29:47.484, Speaker A: They are reproducible. So it's a very good way of doing proof of concepts. For example, if you're doing audits, if you're doing code contests or bug bounties, and you need to come up with a proof of concept, I think the debugger is a very nice way to visualize them because writing a code proof of concept is one thing, but then you also need to explain it to somebody, maybe to the developer team that you're auditing. And that's really nice because then you can just send them to the debugger and they can step by step reproduce your proof of concept and literally see where things are going sideways. Okay, we are at half time. I wanted to show you a bit about. Yeah, let's do this real quick.
00:29:47.484 - 00:30:36.084, Speaker A: Okay, I'm going to, I wanted to talk a little bit about bytecode level debugging, but I'm doing to do this very quick now. And I'm just taking the, the debug function here is the mint function here is an example. So it automatically stops at the first line. And what I'm going to do now is I'm going to the call stack and right click open disassembly view. And this opens this nice disassembly view. Let me just put it side to side with a source code. All right, maybe I need to.
00:30:36.084 - 00:31:02.674, Speaker A: Doesn't fit on this. Oh, so now it fits on the screen. It's not perfect, not ideal. But now on the right hand side of this column, you can basically see the disassembled bytecode of the smart contract. And you can see that the first instruction is a push operation. The second instruction is also a push operation. Then there's an amp store, and you can just step over the bytecode level as well.
00:31:02.674 - 00:31:51.720, Speaker A: Reading bytecode at first is a little bit intimidating, I have to admit this. But it's a very, this debugger is a very good way of learning how the bytecode actually works. The push operation just pushes an item on the stack. So I would expect that this number, hexadecimal 80, is on top of the stack after I executed over this first bytecode instruction. So let's see, what's our stack? Yeah, it says 128, which I assume is just the decimal representation of hexadecimal 80. So now I'm going to push another amp constant onto the stack. I can see here live how my stack changes.
00:31:51.720 - 00:32:36.404, Speaker A: Now I'm going to do an amp store. An amp store operation will basically pop the top operands of the stack. It will pop these two items and then write something to the memory. If we look at the memory now, it should be all zeroed out. User interface is not perfect yet, but you can see the memory is all zeros. So if I execute now over this mstore operation, the items from my stack are gone because the mstor operation consumes them both. And my memory has changed to this constant.
00:32:36.404 - 00:33:24.206, Speaker A: Hexadecimal 80 has now been written to this memory offset. What's happening here is, well, the solidity compiler, basically. So the memory of the EVM is just a linear memory. It's ever expanding to the right. And the solidity compiler, when it allocates a new variable or a new value on the memory, it always does that by appending this value to the right hand side of the memory. And this special memory location here just tells solidity where is the next free slot free offset in our memory. So that's just how solidity works.
00:33:24.206 - 00:33:54.454, Speaker A: Solidity reserves some scratch space. It calls it scratch space at the beginning. That's memory that's just used internally by some internal generated code. But all the variables that are allocated in memory are then appended basically to the memory. Okay, that's very nice. Of course you can also set breakpoints on the bytecode level. That's really nice.
00:33:54.454 - 00:34:18.518, Speaker A: The way that it looks weird here on the right hand side is because basically how you can read this is, well, this is the address of our smart contract that we are executing, and this suffix here is the program counter. Yeah, there's another question.
00:34:18.646 - 00:34:33.974, Speaker B: Yeah, thanks. Since we are running out of time. This is awesome that the debugger is inside the versus code. What is any other exception or edit value contrary to, whereas the founder debugger?
00:34:35.514 - 00:34:59.751, Speaker A: Oh, foundry debugger. Yeah, foundry has this built in debugger. It's called a forge debug. It's a command line tool, first of all. So it's not connected to visual studio code at all, and it does not give you. So it's just a matter of taste. Like if you are a command line person, then you would prefer the Forge debugger.
00:34:59.751 - 00:35:37.672, Speaker A: If you are a visual person like me, you just prefer working in visual studio code. But I think we have more feature plans. I will show you in the second demo, I will show you the symbolic execution features, and that's something that is only possible in our debugger now. That's not possible at the Forge debugger at all. And also, sorry, I saw your question 1 minute. And also I think the forge inspect debugger, or the Forge debugger does not attempt to decode variables at all. And we don't do it at the moment, but we have it planned.
00:35:37.672 - 00:36:01.428, Speaker A: So that's the key differences. But it's a very nice tool. Actually, I used Forge debug a lot. Ok, there's another question. Yeah, so this is kind of technical, but is this implemented using debugger adapter protocol so that you can connect it with Neovim and Helix and other editors as well? Yeah, thank you for bringing up this question. I was hoping somebody asked me. Yeah, this is all implemented on the debug adapter protocol.
00:36:01.428 - 00:36:35.696, Speaker A: So you can, this is just, this is like a networking protocol for debuggers. And the nice thing is you can develop a. A debugger separately from the user interface and then just connect it to different ides. So in this case, we have connected it to visual studio code, but in the future, we might also connect it to, I don't know, to emacs, even to remix, if they are open for that, or basically any ide that supports the debug adapter protocol on their side. So we do it on our side. Yeah, go ahead.
00:36:35.800 - 00:36:45.604, Speaker B: Just remarks. Thank you for pointing that out, because that would be awesome to connect it to the 7702, the new transaction type, which is going in Pektra.
00:36:46.864 - 00:36:49.964, Speaker A: I'm not an expert on this new transaction type.
00:36:50.424 - 00:36:57.256, Speaker B: It's just, it will allow to execute the bytecode within the context of the.
00:36:57.280 - 00:37:01.244, Speaker A: EOA, basically the serum object format.
00:37:01.564 - 00:37:03.276, Speaker B: No, no, no. Different one.
00:37:03.380 - 00:37:20.904, Speaker A: That's another one. Okay, yeah, let's talk about this. Like, fetch me after the talk. So, that sounds interesting, but I'm not an expert on this topic. Okay, so we have 20 minutes or 23 minutes, 17 minutes left. Okay. It's less time than I expected.
00:37:20.904 - 00:37:59.204, Speaker A: Let's do a little bit of theory for before we come to symbolic execution. So you might have heard that the theorem is basically a state machine. The network is in a current state, and you do a transaction, and it modifies the state, and the state is basically all the storage of all the smart contracts, all the balances of all the accounts. That's your entire state. And then you do a transaction, and the state changes. Now. So I think the initial state of Ethereum was created in 2015, if I'm not mistaken.
00:37:59.204 - 00:38:58.770, Speaker A: And then we recorded a bunch of transactions. The state kept changing, changing, changing. We know that some states in the past have been exploited due to bugs, and now we are at the present, and now here we are, and we try to avoid situations like this, but that's very hard to do given that we cannot predict the future. We cannot see what will be the next transaction, what will be the parameters of the next transaction. So even if we could predict just the next transaction, well, the game would repeat, right? We have an infinite amount of options just for the next transaction, and then there's another infinite amount for every possible successful state after the next transaction. So this is a huge expanding state space. And how can we actually make sure that our smart contracts are safe from situations like this? How can we make sure, like, you can think of.
00:38:58.770 - 00:39:38.742, Speaker A: If you're doing a debugging session, you're basically following one of these paths, and there's an infinite amount of passes. So how can you actually make sure that you find the path that leads to this bug? And this is where symbolic execution comes into play. So here's a simplified example, basically zoomed in into the formal picture. So we have a transfer form function. We are calling it from an initial state where Alice has 100 tokens, Bob has zero tokens. We could call this function with different parameters. Transfer from Alice to Bob, transfer from Alice to Alice.
00:39:38.742 - 00:40:24.554, Speaker A: This ten amount of tokens, 30 amount of tokens, and every, every single transaction will give us a different successor state. So in one of the successor state ls has a balance then of 90, and Bob has a balance then of ten. So in another one, Alice has 100, Bob has zero tokens. Now, symbolic execution is the way of exe, sorry, is a way of executing transactions, but leaving the concrete parameters of your transaction, leaving them symbolic. So first of all, you start in a, and by symbolic, I basically just mean variables. So if you look at this initial state, this is now a symbolic state. That's why it's yellow.
00:40:24.554 - 00:40:59.224, Speaker A: I always imagine like symbolic states must be yellow. So we have just a generic balance of a from address that equals anything that's called x, and we have a balance of the to address that equals y. We do a transfer from the from address to the to address with an unknown amount of value. So we cannot see that actually. Right. So let me see if I can. Hmm.
00:40:59.224 - 00:41:40.696, Speaker A: This is not perfect. Okay, just, just trust me. So we have in this yellow box, we have a variable here, we have a variable here, we have a variable here. And then we have two abstract or symbolic successor states. One where the balance of the format is decreased and the balance of the two address increased. And then we have the case where the from address and the two address are the same address. So that's the buggy case that we just explored in our debugging session.
00:41:40.696 - 00:42:34.810, Speaker A: And then the balances should not change. So the interesting part on this slide is like here you have an infinite amount of concrete transactions that you could follow and that you could try to debug. And maybe one of these, basically only this transaction, only this debugging session will trigger the bug. And in this case, in the symbolic case, you just have one, you just have one abstract debugging state, basically one debugging session, and it will eventually definitely trigger the bug. Because symbolic execution is a way of systematically exploring all the reachable states of your smart contract. And I'm going to give you a demo right now. And even if you have not installed the visual studio code extension, you can just try out this demo at symbolic runtime.
00:42:34.810 - 00:43:31.116, Speaker A: Verif try dot symbolic dot onetimeverification.com network is not the fastest, but. All right, so here we have another smart contract. We have the famous wrapped ether contract. It's completely unmodified, but one change, I just mentioned that for completeness, that is, we change this liddy compiler version because our debugger is not well tested on older compiler versions and newer compiler versions is giving us additional extra information so it does not match the bytecode of the deployed wrapped contract one to one. But this is just to demonstrate the concept. So now I have this wrapped contract and I want to say debug the transfer from function.
00:43:31.116 - 00:44:26.814, Speaker A: So one thing that you see here now is that the symbolic execution mode does not have the same limitation, or I should increase the font size. Okay, so one thing that you can see here is that this symbolic execution mode does not have the same limitation as the concrete execution mode in the sense that you can start debugging functions even if they have parameters. So that was not possible with a debug, with a concrete debug execution. Because when you're doing concrete execution, you always need to know what are all the concrete values that you want to debug. With symbolic execution mode. You can then just leave them open so I can just start debugging this transfer from function. And now let's first look at what is the call data here.
00:44:26.814 - 00:45:24.292, Speaker A: I'm going to make this all clean, this user interface a little bit up. So if you look at the call data, you see that there's this hexadecimal constant, which is just the selector of the transform function. And then you see that there's this plus bytes operation. And that is, well that is a function, that's a symbolic term basically. And basically it says, well, the call data is our function selector, plus some variable that is encoding the source address, plus some variable that is encoding the destination address. So if you look closely, you can see here that it's saying source. If you can look here it's saying destination and then not visible on the screen right now, there's another parameter appended at the end of the call later.
00:45:24.292 - 00:45:52.326, Speaker A: That is for the amount that we are going to transfer. Now let's look at what is our storage of the smart contract. And that's very interesting because it just has this cryptic value in it. And this just says, well, our storage is fully symbolic. That means our storage could really be anything. We don't make any assumptions about what is the shape of our storage and what are the contents of our storage. It could be anything, really.
00:45:52.326 - 00:46:51.654, Speaker A: And now we execute, now we execute over this code and we just track and modify the variables. And what you see here, now, I just stepped over the first statement and you can see now the debugger, I have to scroll up. Well, the debugger stopped at two different positions. It first stopped at the require clause because there is a branch that is reachable, that violates this require clause. And symbolic execution really explores all the different branches. So it has to stop here and tell us, well, we found a branch that is throwing an exception here, but there's also another branch that just passes this require clause and then just goes to line 64. So if you look at the call stack now, you can actually see, see that we have different branches.
00:46:51.654 - 00:47:32.190, Speaker A: And one of the branches paused on an exception and the other one paused on a step. So this exception branch, I'm going to select it here. It's not doing any interesting beyond this point. It just reverts your transaction and you're done with the execution. So if I'm just going to execute over it, it will just disappear. So that leaves me now only with a branch that passes line 62. So now I have an if statement, and I don't have sufficient knowledge about whether this if statement is true or false.
00:47:32.190 - 00:48:33.672, Speaker A: Like in concrete execution, when I know all the concrete values of the variables, I can always say, okay, this if is true, this if is false, false. In the symbolic case, I cannot do this. So what we need to do is, or what the debugger does is if I execute over it, you will see it branching again and one of the branches will stop at line 65 and the other branch will stop at line 69. So I'm going to do that there, see? And actually it's not just two branches like I predicted it, even for me, like I'm a formal verification expert for years now, but even for me, it's sometimes really hard to predict how many branches are there. So in this case, there are actually three branches. And why is that? There's only a single if statement. But if we look this if statement is actually a compound operation.
00:48:33.672 - 00:49:21.102, Speaker A: So there's actually, it's a conjunction here. And that means when the left hand side evaluates to false, then we can just directly, or when the left hand side, when this part evaluates to false, then we know the rest, then we don't need to look at the rest of the condition, we just know it's going to be false. So we just step to line 69. But there could also be the case that this part is true and this part of the conjunction is false. So that's another branch, because it has, well, it has different side conditions. So that's why we see three branches here, and two of them actually stopped at line 69. So you can see that here.
00:49:21.102 - 00:50:21.264, Speaker A: And one of the branches stopped that line. So only one of the branches enters the then branch. And so you might wonder, okay, now what are the constraints that must be satisfied, for example, in this if condition, like in this branch that is stopped at line 65, and you can actually go and inspect what we call path conditions. So a path condition basically tells us, hey, for every possible execution that passes to line 65, all these like logical formulas must be satisfied. And you can see there's quite a lot of them and they are not super readable at the moment. We are working on that. We are always trying to improve our user interface.
00:50:21.264 - 00:51:32.202, Speaker A: Just why are they looking so weird? So you have to have a formal, you have to have a logical language to express these constraints about your variables. And in our case, we are using something that's called the k framework. And these are basically, K framework is based on matching logic, and these are just matching logic formulas given in a very weird syntax. So the goal is here, ultimately, we want to make these constraints look more like solidity expressions so that they become more natural to read for solidity developer. They look scary at first, but that's, I promise you that just you get used to reading them. So for example here, let's pick out this site condition that says the message sender equals the source address, and then that's negated. So it says basically the message sender does not equal the source address.
00:51:32.202 - 00:52:27.886, Speaker A: And I think that's one, this one is coming from this part of the conjunction of our if statement. So source address does not equal the message sender, and you can see that in the constraints here. So yeah, I can now step over every single line of code if I want to and see how my, like, how my control flow graph unfolds. But I will do something else instead. I will just restart my debugging session. And what I will do now is I will just execute without setting any breakpoint. And remember that the debugger automatically stops at every final state.
00:52:27.886 - 00:53:12.206, Speaker A: So in concrete execution, that was only just a single final state. But if I do that now, in the symbolic case, I can see really all the possible branches, all the possible control flows that my program can take. So I've just done that. And let's see, on our call stack, there are actually, how many branches are there? 1234-5678 910. So there are ten different branches just for a simple transfer from function. And if you would look at the code, you wouldn't see those. Like, I cannot predict those.
00:53:12.206 - 00:54:37.114, Speaker A: But that's ultimately what you have to do as an auditor, really. If you're a security researcher and you're reviewing code, you really, you must consider all possible cases because bugs are always, or critical bugs are often hidden in some edge cases. And what symbolic lets you do is it really forces you to look at all the possible edge cases and you can see the site conditions that are attached to each branch. And you can see which of these branches, maybe there's one of these branches that's doing something weird. There's certainly, there's five branches that are reverting, should they be reverting? And there's like then four branches that are successfully terminating. And do they do that in the correct state? Like we can just pick one of those branches and then actually see if the, if the storage is actually what we intended it to be. And is the stack, yeah, the stack is not that interesting, but basically, is the storage in a correct shape now, is it expected or is it unexpected? Is it returning the correct data? We can all see that.
00:54:37.114 - 00:55:12.634, Speaker A: Okay, one last comment here now is, let me go back to my slides. Yeah, so, yeah, we are doing this. We are developing this debugger. It's pretty new. Most of it is open source right now. Some components are still closed source, but will be open sourced over the next weeks as they become more stable. We have some other open source tooling.
00:55:12.634 - 00:56:01.094, Speaker A: For example, we have control, which is very nice. Control is basically it's foundry, but instead of doing fuzzing, it's doing symbolic execution. And that means if you have foundry, it calls your tests with random inputs, and then it just tries to find if there's some input combination that violates your assertions. In control, we use formal verification or we use symbolic execution. And that means we don't just try it on random values, we do it on symbolic variables. And that means that we really cover your entire input space. So if you have a uint 256 integer value, that's two to the power of 256, and if you want to fuss over all the values, well, that will take you more time than we have in the universe.
00:56:01.094 - 00:57:04.296, Speaker A: But if you do it symbolically you can cover all these possibilities really every single possibility without any exceptions in a reasonable amount of time. It will be slower than foundry. Of course it sometimes can take you minutes or hours to run control on a proof but then at the end you get a really on a test, sorry. And at the end you get a really strong correctness guarantee because control will either find the counterexample that breaks your code or it will give you a proof that no such counterexample can exist and that's really a machine checkable, super precise, rigorous mathematical proof and or it will give you a stack state which means hey, I'm not sure how to solve this and then you need to write some lemma, we call it. So you need to guide the approver in the backend to make more progress. Okay, that's all I have for today. Thank you very much for attending this workshop.
00:57:04.296 - 00:57:08.024, Speaker A: Please follow me on Twitter, follow my company and thank you.
