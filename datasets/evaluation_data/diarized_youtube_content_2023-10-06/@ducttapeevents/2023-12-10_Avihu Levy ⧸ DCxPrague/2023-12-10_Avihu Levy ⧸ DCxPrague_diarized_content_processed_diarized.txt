00:00:03.400 - 00:01:09.694, Speaker A: Okay, so hi everyone, my name is Avil. I work at Starkware for the last six years and yeah, I don't have my starkware shirt, but I realized that I anyway have the shirt with the same color palette as Starknet and also Czech Republic. So all is great. And you know, I need to, we need to get out something that feeds to castles, but that's the best I could do. Today I'm going to talk about escape hatch. I think it's becoming relevant again when we move to talk about up chains. So I'm going to explain a little bit about what are up chains, what is the motivations? Why do we hear so much about app chains right now? And then I'm going to talk a little bit about what kind of solutions exist for censorship, resistance for up chains.
00:01:09.694 - 00:01:57.434, Speaker A: I will show real quick one example of a solution that works for some use cases and then I will talk a little bit about what exists and what will most likely happen next. Ok, so what are appchains? This is my own definition. Yesterday when I spoke with l two bit guys, it was kind of surprising to them. But for me an app chain is a change that serves one particular application. There is this if you watch Rick and Morty. So sometimes you use really complex technology to achieve or serve one particular application. So in options, this is what we have in mind.
00:01:57.434 - 00:02:53.046, Speaker A: Okay, so can I give you examples for options? Yes, I can. If you go to l two bit, and you are particularly interested in options that are l two s over ethereum, then you can see a bunch of those I marked here. Basically everything that is not a general purpose chain. So you can see that on the website. And I also excluded two chains that I would consider not to be up chains because they are a bit more general than this. But except that you can see 14 live chains already as an l, two serving a particular application. And from those we, Starkware, run, about nine, of which eight are running on a special purpose platform that is called Starkex.
00:02:53.046 - 00:03:39.642, Speaker A: I won't be talking about it today. And one, the newest one, paradex somewhere over there, runs already on a general universal platform, Starknet. But it's a single application chain, so I include it in the app chain. And basically what we are talking about, what I'm going to talk about today is how do you do escape hatch for general universal chains such as Starknet. Okay, so why up chains? Why? We hear about it a lot. We hear about all kind of stacks going out, we hear about all kind of applications that are having their own chain. What is their motivation? Well, there are a bunch of reasons.
00:03:39.642 - 00:04:37.610, Speaker A: I'm not going to list or go into all of them because this alone is probably going to take me another ten or 15 minutes. But I can say that there are some clear benefits in terms of performance. Some applications thinks or believe or actually experienced the need for up to 100% of the network capacity. And they want to be able to utilize for example, the entire sequencer capacity, the entire to have a separate storage so that when you as a full node needs to download their data, you don't mix with other applications data. So some kind of sharding for the poor. And what else? If you know that you have an application of specific type of on the network, you can sometimes optimize the way that you process transaction for this application. So you don't need to handle general contracts.
00:04:37.610 - 00:05:21.212, Speaker A: But you can say, I only have whatever this logic contract and ERC 20 so I know what I need to handle. Let me optimize if I get this type of transactions. Some applications want to change the way that users are paying fees on the network. Some applications wants to have different finality times or are ready to take different trade offs on the network when it comes to, for example, security. They want to work on different data availability mode, they want to change the finality times, et cetera, et cetera, et cetera. Okay, so we understand that app chain exists. We understand that many teams are motivated to come up with their own upchain.
00:05:21.212 - 00:06:08.634, Speaker A: I didn't show it, but if you go to l two bit and you click on upcoming projects, then you will see a list of about 15 new projects. Most of them are up chains. Okay, there was some hidden assumption here, so I'm gonna state it very clear. I don't care about things that are not on top of ethereum because I think that for most, and this is already not just a theory, this is a practical assumption. You see that most of the liquidity, most of the fees are being paid for chains that are related to Ethereum. So our assumption is that you are interested in app chain that is connected very well to this pool. And in addition, I'm going to focus on validity roll ups.
00:06:08.634 - 00:07:03.584, Speaker A: And the reasons are listed behind me are really, it's really interesting conversation to talk about, why do we want all this? But in my non objective opinion, the best in class solution for an app chain is a validity roll up. So this is what I'm going to focus on. Okay. Censorship, resistance. It's basically the answer to the question, what can users do if they're being censored. It sounds trivial that there will be an answer, but in fact, in many, many chains in l two today, the answer is they can't do much. I think and hope that this will change, but that's not so easy problem.
00:07:03.584 - 00:08:37.408, Speaker A: When there is decentralization in place, this problem becomes easier. I'm not claiming that it's out of the box, because there are all kinds of questions. If I'm a new sequencer and I want to participate, what does it impose on me? How much money do I need to bring? Am I being censored by other sequencers? All those are interesting questions, but overall, the state of things is much easier for censorship resistance if there is decentralization. As you may know, l two s today are generally not decentralized, and so many of them has to handle with a centralized sequencer. And then the question becomes a little bit harder, like, how do you still enable users the ability to do whatever they want if they're being censored? What else I want to say on this? So, censorship resistance, I don't think, is just a theoretical problem in the case of app chains, because you can imagine that as an application, you have some restrictions. Those can be like regulatory or legal ones, or they can be business reasons, but in all those cases, they might end up sensory users, and the users need some guarantee that their money is safe in those applications. So, and remember, we are talking now only about options that are validity roll ups.
00:08:37.408 - 00:09:07.796, Speaker A: So there, the situation is slightly better, because users know that the validity of the state is always promised. They don't have to monitor for invalid state transition. That's good. So is the order of history. So once something is finalized on ethereum, they can become, and they know that it exists and that it already happened. But censorship per se, like getting their funds outside, for example, is not guaranteed. Okay, here is a framework.
00:09:07.796 - 00:10:01.172, Speaker A: It's not completed, but I think it's important to understand that there is a very big difference. And as solutions will become live, we will start noticing that there is some inherent differences between solutions and what do they actually provide. So I'm going to focus on one particular solution, that is the escape hatch. What is it? It's just a subset of solutions. What it ensures is that users can always exit their funds out of their system already. By this definition, you understand that this is not a general solution, because in some applications, the meaning of censorship is not about your funds. For example, if it's a game, maybe you want just to continue and play the game, and this doesn't solve it.
00:10:01.172 - 00:10:53.248, Speaker A: So stating this clear, I'm going to focus only in enabling the user to exit their funds. We could expand it to more requirements. I'm not going to do it here, but it is possible to say I don't want just users exiting their funds. I want every general logic to always be able to, for the user to be executed. And another requirement that I'm also not going to require, but it is somewhat reasonable, is that the chain continues to operate. This is basically your appetite to. Well, if a chain censoring users, should it continue to run or not? It really depends on the application and on your ideology, but it can also be a reasonable requirement.
00:10:53.248 - 00:11:37.844, Speaker A: But I'm not requiring it for today's talk. Great. Okay, so here's the problem. The first problem, okay, when we think about, we want to, let's go into this thinking process, right? So we have a network, we have a chain, this is an l two. We want to enable users with rotor funds even if they are being censored. So the first step is enabling these users to request exactly this. And on other networks, this problem by itself is hard, but we have Ethereum, so everything is much easier because Ethereum is already resistant to any kind of censorship whatsoever.
00:11:37.844 - 00:12:19.418, Speaker A: And that's our assumption here. I'm using a meme, but it's not an actual meme, it's just easier not to draw pictures. So ignore the meme part of this. So the first step, we are just going to use force. Transaction queue on ethereum. Ethereum is going to be the place where users can request, withdraw their funds and it will be registered and nobody will be able to censor them. The reason I put this picture is that you should remember that even though this first transaction queue exists, usually users will just go to l two directly and they will never interact with l one for such a request.
00:12:19.418 - 00:12:46.714, Speaker A: It's only an emergency mechanism. So here is the plan. There is this queue. If a user complains that they haven't received service and they want to exit, they're going to request it. On l one. We are going to let the operator, the sequencer, the application time t to handle their request. And if they do so, nothing bad happens.
00:12:46.714 - 00:13:24.946, Speaker A: And if they don't serve the user after time t, the user can come back again and complain to eCRM. Okay, here is a complex diagram. Let's see how much time I have. Okay, I can do it in ten minutes. Don't worry, this diagram is not going to take me ten minutes. Just, you'll see it like five more times. Okay, what do we see here? So down there is ethereum and here over the right is the starknet up chain and on the left there is the sequencer and there is some escape tool that we will get to later.
00:13:24.946 - 00:14:06.818, Speaker A: Those are like off chain components for the user service. The false transaction queue is a contract. On Ethereum there are also the usual suspect contracts. That is the starknet core, which is the contract that handle the state of the starknet application. A verifier for verifying proofs that everybody can query to ask what is correct, what is valid and a bridge to the starknet application that holds the money, the funds that are sitting in the application on l two. And this is important because this is already specific for this solution. You have a function of the application that handles forced transactions.
00:14:06.818 - 00:14:40.426, Speaker A: Remember, first transactions can be general transactions, but you can also choose to say I only allow forced transactions of specific type. And then you basically limit the attack surface on your application. If you didn't understand what I said, it doesn't matter now. And you also need, and this is very specific for escape edge you need some kind of a balanced calculator. You need to be able to say this user in the case of emergency deserve x dollars. And it sounds simple and in some application it is simple. But the more complex the application, it's not necessarily going to be a simple function.
00:14:40.426 - 00:15:24.574, Speaker A: And that's why it's on l two, because you may need to do a complex computation involving a lot of data to get to how much user a should get. So we see here the user asking for a first transaction and the first transaction queue, registering it and submitting it to l two to be processed. And then there is time where the operator sweats. It doesn't really, it happens automatically. We did it many times and at the end of the day everything is cleared and the user exits their funds. But what if not? Okay, so now thinking process, we have the second step. We know that the user requested something on ethereum and they haven't been served.
00:15:24.574 - 00:15:46.564, Speaker A: And now a time t passed and they're being censored. We know that for sure. L1 knows it for sure. What can you do? So you can do many things. Depends on how complex you want your system to be. Here are examples of things you can do. And some systems think even one system in prod is doing or offering something like that.
00:15:46.564 - 00:16:15.116, Speaker A: You can change the operator. Meaning you can say, this operator is censoring users. I don't like him. Let's have some kind of process to decide who is going to be the new operator. Side note, I don't like the solutions that says now everybody can be operator because it serves well if there is one request. But if the operator is down then everyone can do whatever they want, just create a mess. So there should be some mechanism to replace the operator.
00:16:15.116 - 00:16:57.212, Speaker A: That's one option. Another option that you can also see today, some version of it on some l two s is everyone can be operators for their own transactions. It's also complex because it requires there is some concurrency issue, right? If you let everyone progress the state then my wish and somebody's else wish can collide. And again it serves well if you have one transaction. If you have many transactions and many people wants to go out, then they are dependent on each other. So they need to agree on how they're going to serve something without doing computation for no reason. I don't want to get into it.
00:16:57.212 - 00:17:37.386, Speaker A: It's very interesting directions to go and consider, but we have only 25 minutes and from it I already wasted like 20. So we are going to take the simplest approach, which is we're just going to freeze the system. So we are assuming nothing about the liveness of the system. After this we are going to freeze the system, remove the concurrency issue, because once the system is frozen everybody can act on l one and they don't care, they never change the state of the system and we are going to move to exit mode only. Okay, so here is exit mode, the system is frozen. This should represent frozen. And here is what the user can do on Stacknet.
00:17:37.386 - 00:18:38.646, Speaker A: Remember this is a general purpose system, so the tools are general purpose, but the logic on l two is application specific. So what the user is doing can do is that they can take the escape tool which is made of madara, which is an open source sequencer, and stone, which is an open source prover. Or they can use whatever favorite tools they would like to and they ask this tool to please synchronize on the latest final state from L1. This exists because we are talking about a roll up, so that's also easy. And compute or calculate their own personal user balance. And after they do that they ask the tool to generate a proof that shows two l one that they hold in the l two up chain such and so balance and send it to the verifier to register it. Once it's registered they can go one time to the more complex bridge than what we are used to asking to withdraw their funds.
00:18:38.646 - 00:19:18.640, Speaker A: For example, let's say they withdraw USDC. Stockingbridge will check that the application is really frozen and that the fact exists. Register the user's request so that they can double spend and give the user their funds and that's it. It's very simple, but in reality it's not that simple, because those tools and those systems, they are complex. So you need to be very careful with everything you do when it comes to the first transaction. Handling the balance calculation is application dependent. The tools, you should make sure that they're working in reasonable time, that all users can use them.
00:19:18.640 - 00:20:27.014, Speaker A: So there are a couple of layers that we will achieve as everything matures. What exists. So I'm not going to cover everything that exists, even that we did look into it and it's quite interesting. But I do want to mention that for no general purpose platforms such as Starknet, but for specific logic platforms like Starkx, we already have reasonably accessible such tools. So if you go to for example the YDX, or basically any perpetual system that is built on Starkx, the L two bit team has built a very nice explorer that also enables you to see the latest force transactions and force trade. I'm not going to get into force traits, forget that you saw it. And you can also, there are also demo tools that I hope soon will be live that enables you, in case you already initiated such a request, to finalize the escape and exit using some reasonably nice GUI.
00:20:27.014 - 00:21:37.298, Speaker A: So this is already out there, but for specific logic applications. And we, as you remember, want something general. So what is next? I can only talk about what we are going to do next, but I will also mention some others. So we starc we are going to work for the escape edge general solution for stagnant app chains, which means that still applications that won't stagnate app chain will need to develop their own first transaction handling and calculate balance logic. But then they will have all the other tools supporting users that wants to exit in an exit mode. And I know that some other solutions such as Polygon they have for their ZKVM, some maybe more general L1 first transaction mechanism, but I haven't looked scenario and I know that it's not live in production just yet. It's also worth mentioning and you can think about it later.
00:21:37.298 - 00:22:33.964, Speaker A: It's like homework. But in fact what I said here on small changes works also on the public network for specific applications that control their own bridge. So as an example, if you are Maker Dao and you want to create a bridge for Dai tokens, and you are the canonical bridge of the Dai tokens, then you can apply similar logic that says let me check if the application is live or frozen on l two. And if it's not live, if it's frozen, then the gate for Dai will basically change behavior. Enable exit mode for users. So you can actually build this infrastructure today also on stagnet with some changes, but except maker that did something that's close to it. I don't think that anybody else did, but it is an interesting direction moving forward.
00:22:33.964 - 00:23:20.504, Speaker A: That's it. Thank you very much. Yeah, thank you. I don't know who is talking next, but yeah, question. Well I don't know, but if you, but if you see but people are actually using it, that's like in dy DX it has been used the first transaction, not the exit mode, but the first transaction were submitted multiple times. I don't know if. Good question.
00:23:20.504 - 00:23:47.174, Speaker A: I think it's something in like either they're trying the system, like trying to check if things work, or they were by accident. Thinking from this nice gui that yeah, this should be the way to exit the system. Or they really maybe aren't able to access TydX GUI for some reason. I have no idea. It's just speculation.
00:23:48.034 - 00:23:53.586, Speaker B: What's the logic behind the freezing city? I mean what's how it's triggered?
00:23:53.650 - 00:24:20.784, Speaker A: Like when is triggered freezing, basically freezing is just, it's important for not having concurrency issues, but it is obviously very bad for the application. So you only want to do it when users requested to exit on l two, then on l one. And they haven't been served for very very long. And l one is able to verify that that's the only trigger that you allow.
00:24:21.764 - 00:24:31.704, Speaker B: We decide like as a whole too. We decide like everyone said. Okay, we will send, our users are complaining, but why wouldn't we?
00:24:33.184 - 00:24:56.784, Speaker A: This is something that the users can trigger. That's the point. The users can trigger on l one, users can do it directly on l one contract. And for the l two, the l one contractor input. Yeah. Okay, we are after time and I think the next speaker is here. So thank you.
