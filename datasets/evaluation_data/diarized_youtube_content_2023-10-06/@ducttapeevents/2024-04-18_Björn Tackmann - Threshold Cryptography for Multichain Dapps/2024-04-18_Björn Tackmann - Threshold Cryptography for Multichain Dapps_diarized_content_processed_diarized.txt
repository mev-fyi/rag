00:00:02.280 - 00:00:33.894, Speaker A: Thank you very much for the introduction. So you may have seen that threshold cryptography actually becomes a lot more prominent in the entire blockchain space. So there have been early adopters like Thor chain or ICP was also pretty early. And now recently, more and more projects seem to join that train. So XLR is a recent one. Nir has just announced that they'll also be part of the threshold crew. So as a cryptographer, I thought, what's the best I can do for you? And I thought I'd give you some overview of threshold cryptography.
00:00:33.894 - 00:01:01.502, Speaker A: I set myself two goals. The first one is for all the non cryptographers. I want to give you one or two of these beautiful aha. Moment where something really becomes clear. And that goal number two, without any potential cryptographers in the audience later beating me up for oversimplifying the beautiful things. So what is threshold cryptography? I mean, on the high level it's very simple. It's like this.
00:01:01.502 - 00:01:52.644, Speaker A: We have a group of nodes, such as the four nodes there on the left, and they together want to perform some cryptographic computation and they want to do this under two conditions. So the first one is for some threshold t, which four nodes could be three. For example, any three nodes together should be able to actually do that computation. But any less than three, or generally t nodes should not be able to do that. In particular, they should not learn anything useful for them. And so when I was a student in cryptography, I found this really fascinating. Like how do you get this property that for t minus one, you know, nothing, the nodes cannot do anything with the material they have, and yet you just add one additional node, doesn't matter which one anyone, and they suddenly can do everything.
00:01:52.644 - 00:02:48.044, Speaker A: So how is that possible? And the answer is, of course, math. In this case it's polynomials, because polynomials that was detected by chamier, or the application was detected by chamier in the seventies or eighties, it's pretty old. Polynomials have this beautiful property where, I mean, I've shown a degree three polynomial there. And that has the property that if you know three points, three of the gray points, say on that polynomial, you have no information at all about the pink point. The pink point could be anywhere on the y axis in that case. But if you know any additional point, any additional fourth point, you know the entire polynomial, you can use Lagrange interpolation to compute every single point of that polynomial. So this gives us this very hard gap between what happens at, in this case D and D one.
00:02:48.044 - 00:03:25.236, Speaker A: And so of course we're going to use this to put the private key that we were using, cryptography, we'll put that at the pink dot there. So it's convention that one puts it at the axis, but you could actually put it anywhere. It doesn't matter, just a convention. And. Yeah. So how do we go forward if we want to do threshold computation? I'll now specialize a bit to public key cryptography, in particular digital signatures. We have a private key space and we have a public key space and the two are usually mathematically very different.
00:03:25.236 - 00:04:21.932, Speaker A: So in the elliptic curve schemes that are widely used today, the private key space is just numbers and the public key space is points on the elliptic curve. And so there's functions between the two and it's easy to go from a number to a point on the elliptic curve. It's practically infeasible to revert it. Okay, so what we're going to do with the threshold scheme is I've now replaced the gray by three different colors here, so it's easier to distinguish. What we're going to do is we give three parties these three colored dots, and together they kind of know the pink dot on the right, the key where we want to go to. And so now we can ask the question how do we compute the public key? And if we have the pink one, that's easier, right? We can just do the standard computation from the number to the elliptic curve and we have the key. And of course we also have this lagrange interpolation.
00:04:21.932 - 00:04:53.384, Speaker A: So if we, if we have the key shares of all the parties, we can interpolate and get the private key and from there we can go to the public key. Unfortunately that's not really useful because that means we have to compute that interpolation in some way, right? Someone has to compute it and they will know the pink dot. And once they know the pink dot, they know the private key. And so that's bad. No single node should ever know the private key. So this is not something we can do. So we're not going to use Lagrange interpolation here.
00:04:53.384 - 00:05:52.784, Speaker A: We're not going to compute this thing and in particular we're not going to compute anything from it. Instead, what we realize is that the colored dots are mathematically very similar to this pink dot, right? They're the same thing. They're also just a number and so we can interpret them as private keys and we can compute private keys from these public, sorry, public keys from these private keys. So every node that has such a key share can compute the corresponding private key corresponding to its key share. And since we have a nice homomorphism property which is mathematical speech for it preserves structure, we can also do the Lagrange interpolation on the level of public keys. And so this is the idea, this is the core idea of most threshold cryptography protocols. We share the private key, but whenever we need to compute something, we go to a different space and we compute in that space.
00:05:52.784 - 00:06:36.310, Speaker A: So here for computing the public keys, and if we think about threshold signatures, we basically do the same thing for the signatures. So we can just replace all the public key stuff by signatures. It's easy to compute the signature from the private key, it's hard in the other direction. And every party can compute using the private key, a corresponding signature share. And again, there is such a homomorphism property so that these parties can use the same type of interpolation to compute the signature. Now this has to be taken with a grain of salt. So there is some cryptographic schemes such as BLS, which if you know the proof of stake Ethereum, you probably have some had some exposure to.
00:06:36.310 - 00:07:18.038, Speaker A: BLS is super nice in all the properties. And so for BLS, this diagram works exactly, and you can think about it in exactly that way. If you have somewhat less nice signature schemes such as schnor, EDDSA, ECDSA in particular, it still kind of works in an intuitive sense. But the protocols are a lot more complicated than I can show here. Now, okay, now we have the threshold cryptography threshold signature scheme, and it's exactly that. If we have sufficiently many nodes, we can sign, otherwise we can. Now you may ask, wait wait wait, isn't that a multi signature? If sufficiently many can sign, then it's going to be accepted, and not quite.
00:07:18.038 - 00:08:04.292, Speaker A: And I think there's a nice duality between the two that it makes sense to explore, and that's as follows. So for threshold signature, every party, as I've shown before, has some kind of a share of a key. So you can think about it as every party owning some part of the key. And if enough of those parties come together, they kind of know the entire key and they can proceed. So it's pretty complex on the sender side, but it's very easy on the verifier side. So for the verifier, this looks and smells and feels like a standard signature, and the verifier just has to run standard signature validation in order to validate this threshold signature. And multi signatures do a very different trade off in multisignatures.
00:08:04.292 - 00:08:45.296, Speaker A: Every node on the left hand side has their own independent key. They just generate it and they sign as if they were just providing a single signature. And the work in that case is very much on the, on the verifier side. The verifier now has to know all the public keys, not only one. It has to validate all those signatures and it has then to decide whether the signatures it saw comply with the policy it's supposed to implement. And so I've tried to make it to exemplify it a bit in this table. So in a threshold signature we have the same verification as in an existing signature scheme.
00:08:45.296 - 00:09:20.674, Speaker A: You can use exactly the same software where it's a multi signature, the verification is tailored. You need to implement multiple signature verification and a policy. In threshold signatures, the policy is on the signer side because the verifier doesn't know about it. And multi signatures obviously on the verifier side. In threshold signatures the group of signers could change and the verifier wouldn't notice. In multi signatures, if you want to change the group of signers, you have to actually change things on the verifier site. So make a transaction, for example, where it's on threshold, that's not necessary.
00:09:20.674 - 00:10:02.654, Speaker A: On the other hand, for threshold signatures it's pretty much non accountable. All you know is oh, I have a valid signature and enough nodes have signed, but you don't know which ones. In a multi signature you always know which nodes have signed. So the two are kind of related, but they're useful for somewhat different scenarios. Okay, so what can we do with them? Wait, not so fast. The problem with this is, especially as a young cryptography researcher, you think like this, right? There's threshold signatures, and once you solve your threshold signature, all you need to do is you need to bring them to practice. And the reality is more like this.
00:10:02.654 - 00:11:02.968, Speaker A: Sure you have your threshold signature, but now is where the hard work actually starts. And I just want to give you some examples. So one is how do you actually choose the set of nodes? Like who do you give the key to? The second one is how do you actually give them the key? I mean no one is supposed to know the key, so how do you actually come up with that key? A third one is, and what if one of those nodes dies and takes its key share with it? Like how do we recover? Right? And so I want to give you some hints here. So choosing the nodes, I mean here kind of the problem is that every node is the same, every node has one share, and that works very well for some cases where, for example, your consensus. In ICP, that's easy. The consensus is every node has one vote and all the nodes are equal. So in ICP we could just implement threshold signatures in the consensus or on top of the consensus mechanism that we've been using.
00:11:02.968 - 00:11:48.444, Speaker A: But for other consensus mechanisms, such as ethereum, that wouldn't be so easy, right? Because you have very different voting rights depending on the stake. And for threshold signatures, that just doesn't work. Of course, you can make many shares and distribute them somewhat unequally, but that's an efficiency catastrophe. So that's not what you can do in practice either. And so, for example, what Nir seems to be doing, based on their documentation and their recent implementation, is they have their blockchain and then they have a permissioned MPC cluster sitting next to the blockchain. So they completely separate it. It's just something, I mean, there are solutions, but it's very important to think about what your solution then actually also means for the security of the system.
00:11:48.444 - 00:12:19.106, Speaker A: Now for the next part, how do we generate the key? And the nice thing is there's distributed protocols that are called distributed key generation that do exactly this. And they were working on this started in the nineties. So today there's efficiency improvements, but they still base on the same foundations. And the idea is as follows. On the right hand side, we have the receivers. Those are the ones that are supposed to have the key after we run this generation protocol. And the dealers on top, they are helpers.
00:12:19.106 - 00:12:50.140, Speaker A: They are just there in order to facilitate the protocol and the protocol itself. The core structure is again, very easy. So what each of the dealers does is it just chooses a random key. So the one on the left hand side, it chooses this purple dot and creates a sharing with the colored dots. And of course that dealer knows the purple dot, right? That's how it works. But then we have more dealers. We have the one that does the squares and the one that does the triangles and so forth.
00:12:50.140 - 00:13:31.964, Speaker A: And so what we're going to do is we're going to collect many of those dealings and every node will then basically sum up all of its colored shares it receives. And so overall, what we're going to end up with is we need three things. The first one is we need sufficiently many honest dealers. Actually, if there's one honest dealer, that's sufficient to provide enough entropy for everyone. Okay, so we just need to make sure that we have at least one honest dealer that's going to produce a correct dealing and distribute it to everyone. And then even if all the others are dishonest, as long as the honest one deletes the key, it's fine. So you probably want to have more than one honest.
00:13:31.964 - 00:14:07.848, Speaker A: But anyway, the second property we need is we need the individual dealings to be correct. Now this is complicated, so I'll not go into this into detail. There's interactive protocols with the receivers complaining there's zero knowledge, proof based things. This is really where a lot of the work recently is also happening. And the third one we need to make sure is that we have agreement on which kind of, which set of dealings we use. Now that's trivial, right? If blockchain can do one thing, it's agree on something. So that kind of, that is kind of easy.
00:14:07.848 - 00:15:13.516, Speaker A: Now what's nice here is now the receivers on the right hand side, they actually have a key that no one can know, right? So the sum of all those keys is actually something that's unknown. Another nice property is that we can slightly tweak the protocol and use the receivers as dealers and they can reshare their keys. So instead of creating a new fully random key, they take the key they already have and create a sharing out of that. And with a slight adaptation of the math and the protocol, this allows us then to have one group of receivers that own the key, that act as dealers and transfer the key to another new group of receivers. So this is how one can deal with the problem of having nodes that die. You can replace them and then just use this protocol again to provide a new sharing. Okay, so that's what you need to add to all the threshold signatures in order to make them usable in practice.
00:15:13.516 - 00:15:54.106, Speaker A: Can we use them now? Yes, we can. And just to give you an idea, so this is my very easy description of the ICP architecture. Threshold keys are used in ICP everywhere. In particular we have subnets which you may also know as shards. And each of those has its own threshold key. Now the advantage of this is it makes interaction between them extremely efficient because all that they have to know about each other is a few hundred bytes of public key and then they get the signed messages and they can just verify and all is good. So if we have smart contracts on one chart communicating to another shard, it's basically a threshold signature.
00:15:54.106 - 00:16:19.666, Speaker A: Verifying a threshold signature. Done. There's no need for any node to replicate state and so on and so forth. It also makes it super easy for clients to validate information they receive because they can just validate the threshold signature. There's no need for clients to validate anything about consensus. It's all about threshold signatures. Now what one can also do with those things is actually implement multi chain depth.
00:16:19.666 - 00:17:01.174, Speaker A: So that's where the title of the presentation came from. So you can create a signature on one blockchain network and then sign a transaction that's going to be executed by another blockchain network. So I've taken ICP as the sender side here. So ICP would generate an ECDSA signature for the transaction, pass that to Ethereum, and would just be a standard smart contract call from an external account address from the perspective of Ethereum. And you can then use this to build nice kinds of multi chain application. My simplest example here is just a timer application. So smart contracts on nice p can set a timer.
00:17:01.174 - 00:17:53.734, Speaker A: They can say wake me up at 05:00 p.m., today, which EVM contracts cannot do, right? And so you can use this in order to implement things like limit trading or scheduled treasury management in an EVM contract in a fully decentralized way, because you just have a smart contract on ICP that would call out to this Ethereum smart contract. Of course you can do more. Like the ICP contract has the capability to interact with web two services, it has access to the bitcoin Utxo set. It can also, for example, read events from EVM chains. And it can all do all this and provide the data to the Ethereum smart contract. So you can basically implement a full oracle just in two smart contracts interacting with each other.
00:17:53.734 - 00:18:53.016, Speaker A: Or this one is one I find particularly nice is ICP smart contracts have a pretty high capacity in terms of memory and compute they have. So you can build daos entirely on chain. The entire voting can be fully on chain. But you may want to use this in a way to control assets or smart contracts on Ethereum. But for this you may want to actually take data from Ethereum. So a colleague of mine actually has a demo on this at 330 at a neighbor stage, showing how exactly this here works, where a governance contract running on the inner computer fetches the voting power data from an ERC 20 contract and then executes a transaction on the Ethereum blockchain. And yeah, so that's all I wanted to go through today, if you're interested in this kind of thing.
00:18:53.016 - 00:19:10.004, Speaker A: Colleagues of mine will give several demos and tutorials on this. So Thursday, so Sunday morning is another one. So you'll find them across the schedule if you want to have a look at those. That's going to be the same in much more detail on the technical side.
00:19:15.864 - 00:19:53.894, Speaker B: Thanks again. I was wondering, is there some signature scheme that is like some kind of a mutant scheme between multisignature scheme and threshold signatures? What I'm trying to get is the property with threshold signatures. Normally you just observe the signature and you have no view on who actually signed, on who actually produced and partially signed the data. Is there some kind of a signature scheme where you can do that, where the signatures are actually different? The resulting signature is still valid, but is different based on who signed it.
00:19:54.054 - 00:20:22.572, Speaker A: So the answer is yes and no. So there is research work on this by Dan Monet from Stanford University, and that explores exactly the space between the two. So I think it's a very interesting research direction. The problem with this is it does not work for existing schemes. So whenever you need to support something that is existing, you will run into the problem of having this non accountability. But in principle it's totally possible, just not with the currently standardized schemes.
00:20:22.668 - 00:20:24.904, Speaker B: But it's not implemented yet. Any?
00:20:25.484 - 00:20:33.744, Speaker A: Not that I'm aware of, no. I think right now it's really at the research stage, but I think it's a very promising direction for exactly that reason.
00:20:34.044 - 00:20:43.112, Speaker B: Yeah, for some application that would be super helpful. So, you know, and you can punish or reward the nodes that actually participated.
00:20:43.228 - 00:20:53.192, Speaker A: Absolutely. I mean we've been implementing this and we would have loved to have full accountability for the threshold signatures. Problem is the current ones don't have it.
00:20:53.368 - 00:20:54.244, Speaker B: Thank you.
00:20:58.784 - 00:21:09.044, Speaker C: Any other questions? We have three more minutes, but we will have a coffee break actually starting now for 30 minutes. Also, feel free to approach Bjorn.
00:21:09.474 - 00:21:15.354, Speaker A: Yep, feel free to find me anytime. I'll be upstairs. So thank you.
