00:00:17.640 - 00:00:32.820, Speaker A: Hi, everybody. This is ZK rolips tales from the field. My name is Danny. I'm an obligate data borer. I can't not. It's just a thing. I've been a solidity developer for actually going on five years now.
00:00:32.820 - 00:01:04.266, Speaker A: I did this a few months ago. Cryptowinter was fun. In case any of you were there for that, I am the head of blockchain integrations for Vega. Vega is a fully decentralized derivatives platform running on tendermint, our current main project. Our product is cash settled futures, which is why we care about Ethereum so much. So we're all here at F Prague because we love Ethereum. Everyone here, I mean, hopefully, loves Ethereum.
00:01:04.266 - 00:01:42.150, Speaker A: If there's any haters out here, you're probably in the wrong place. But Ethereum has a problem. Like, clearly it's slow, it's expensive, it doesn't scale very well, so it needs our help to scale. So why do we use it at Vega? Well, that's where the assets are, the cash. And cash settled futures is die f. You know these guys, you can see this. So at the moment, what we do is our bridge uses a multisig process that bundles up signatures from all of the validators and submits that to a smart contract as you normally would.
00:01:42.150 - 00:02:07.314, Speaker A: And it cycles through the signature bundle and verifies that each signature is correct. Now, as you can imagine, that gets more and more expensive. The more signers we have, the more validators we have, the more expensive. And at some point there's like a hard cap or we can't go past that. It's a ways off. We figured out a way to push it further off, but it's still eventually a problem. But there's hope.
00:02:07.314 - 00:02:47.760, Speaker A: L two scaling does exist. There's a bunch of different ways to do it, but we've decided to go with ZK rollups. Okay, so what's an l two? Just quick overview. An l two is a way to scale Ethereum while using the underlying security of Ethereum, but offloading all of the compute somewhere else, or most of the compute somewhere else. So we do this with optimistic roll ups, zkrollups, plasma, and side chains. Asterisks is there because people like to argue whether or not sidechains count as l two s. So I did this thing months ago before the market downturn, and at the time, $6 billion was locked in l two s.
00:02:47.760 - 00:03:13.212, Speaker A: I looked it up today on the same website, and it's 4.8. So considering the massive downturn, we've had recently. This is not bad. The l two s still have a lot of strength. Okay, so quick overview of some of the different l two options. We've got optimistic roll ups. The idea is the transaction is assumed correct until someone submits a fraud proof and you, you know, disagrees with it.
00:03:13.212 - 00:03:33.972, Speaker A: What that necessitates is wait times. A lot of these systems have up to like a week long wait time, which I don't know. If I want to withdraw my funds from something, I'm not waiting a week. I don't like that. That kind of frustrates me personally. What's cool though, is it uses math to disprove everything. So, you know, you don't have to like, go through some weird arbitration process.
00:03:33.972 - 00:04:01.104, Speaker A: It's math, but it does require a network. It does require a whole separate network outside of Ethereum. So, I mean, Vega is already a network. I don't want to have to use another network. So that one was out. Side chains are fast and secure, but they changed the security assumptions of, they have different base assumptions than Ethereum has. And as we've seen with the ronin hack and the black hole hack, bridges are hard and they can be.
00:04:01.104 - 00:04:23.138, Speaker A: A hack like that will absolutely kill projects. So we don't want that. And then there's the debate on whether or not it's an l two. Okay, so zkrollups, that's why I'm here. That's the thing I'm promoting. And I see it as a per problem l two. So, like these are individual circuits, individual roll ups for specific tasks.
00:04:23.138 - 00:04:39.622, Speaker A: So much like an individual smart contract. Not general purpose, not making a whole vm, just individual. This is the task. So I'm gonna start. Oh, yeah. So ZK rollups are, the benefits are they're fast and secure. They're entirely built on math.
00:04:39.622 - 00:05:10.906, Speaker A: All of it in the background is math. And the proof can be verified on chain and it's in a single transaction. There's none of this wait times, there's no crazy wait times. And the best part is it has fixed proof size. So no matter how big you've scaled the thing, the input data is fully decoupled from the proof. So the proof is just four un, two hundred fifty six s and then whatever output parameters you want to do business logic on. So that makes it really cool.
00:05:10.906 - 00:05:47.478, Speaker A: And this is how we get the scaling. Okay, so general overview on how they work. That's a quote from a french guy. You guys can read it, but you take a very large input file or any input file you want of whatever data you need to actually do the processing, you put it through a ZK circuit, out pops the little bitty proof that then you can verify on a generated solidity smart contract. So the smart contract obviously can be inherited from. And that's where you add all your business logic in real simple, real straightforward. In theory it's, you know, application gets a bit harder.
00:05:47.478 - 00:06:21.954, Speaker A: So little quick toy example, say you wanted to play rock paper scissors between two people and you wanted to do 10,000 rounds of rock paper scissors. You can't do 10,000 anything on Ethereum, period. It's just, it ain't happening. So in this case, you would take player one's choices, their 10,000 choices, zero, one or two for rock, paper or scissors, take player two s, throw them into a JSON file that's just arrays of their moves. You put their arrays through the circuit, that's what they're called. The roll ups are called circuits. Long story, I don't even think I'll cover it here.
00:06:21.954 - 00:06:48.916, Speaker A: What will come out is a proof. And in this case, the proof is the four Uint 256s. That is the proof itself. The number of wins player one had and the number wins player two had. That's enough information to verify that the wins are correct and to do business logic on the wins. Say give someone an NFT or give someone tokens or ETH. This is in a language called circum.
00:06:48.916 - 00:07:14.192, Speaker A: This is the language that the ZK rollups and ZK snarks use. I think there's other languages out there, there's like Cairo and stuff. There's some differences there. But this is the one I'm doing. So as you can see here, we've got, let's see, we've got the player one choices, the player two choices as inputs. We've got player one wins, player two wins as outputs. So all it does is loop through all of the choice pairs.
00:07:14.192 - 00:07:57.932, Speaker A: And this is where it gets a little weird, because it's all based on really strange math that I really don't have my head fully around. Sadly, you can't do branching. It has to be compiled down to just numbers, single equations. So that line right there is, if this line equates to zero, then player one one. If this line equates to zero, player two one. You got an accumulator for player one, accumulator for player two, you constrain them to the outputs and that's your circuit. So now one thing to point out is down here we've got the 10,000 at compile time.
00:07:57.932 - 00:08:45.092, Speaker A: Before you create the verifier, you have to know whatever input things you have, you have to know the size, because that's part of building out the math to it. So this could be a million, this could be 10 million. This could be however big your compute can handle, but you have to do it at compile time. So if you want to upgrade later, if you haven't set a high enough cap and you want to upgrade later, you have to do a full recompile, a full redeploy of the contracts and all that stuff. So think ahead. Okay, so the idea, the thing we want to do at Vega that we're researching right now is to replace our multisig control with a circuit. I've already written the circuit, testing it and playing around with it and seeing the feasibility of incorporating all of this.
00:08:45.092 - 00:09:20.148, Speaker A: But the basic flow is that a user requests a withdrawal from the system, from the network. It gets gossiped around. All of the validators sign, yeah, yeah, this is okay. And they sign it all up. Then it's bundled up for the user. We've got the validator public keys, the validator waits, the validator signatures, and the message hash that goes to the actual trans, the withdrawal transaction on chain. So what this will do is the signatures all contain the hash of the weights and the hash of the public keys.
00:09:20.148 - 00:09:41.854, Speaker A: So everyone's signing them. Everyone agrees that this is the set. And then what happens is it goes through the circuit like everything else. Out comes the four uint 256s. That is the proof. The signer hash, the original message hash, and then the total amount of weights that people that signed. Yeah, that gets put into the business logic.
00:09:41.854 - 00:10:29.186, Speaker A: And then you check the signer hash against the known signer hash, the one that's on, that we store on chain, and we go, oh, cool, it's good. We allow the withdrawal to go through. Another thing we can do and I've been looking into is bulk transaction check ins. So the Vega network will bundle a massive amount of transactions. Hash each one of those, make an array out of those hashes, and then hash that array and just store that on chain through, through the standard process we did in the last thing. So that's all this shows. And then when a user goes to claim a transaction that was on that belongs to them, they submit the original array of hashes.
00:10:29.186 - 00:11:12.972, Speaker A: And then which hash is theirs? All the circuit does in this case is cycle through them and say, hey, is the hash provided in this array? And then it hashes that array and the output, as you can see. Right? Yep. Right there, you've got the hash they want, and then the whole array hash. And if this whole array hash was checked in in the last step, well, then we know it matches. So all we gotta do then, in the smart contract is check does that match? And has that one been claimed yet? And that's it. If they haven't, all the rest of the parameters you hand to that function allows you to run the transaction. So fairly straightforward.
00:11:12.972 - 00:11:57.220, Speaker A: There's no limit on how many transactions you could put into this, other than the amount of compute right here. But you can replace that with a merkle tree proof and make it scale and stuff. So that is a useful way to scale bulk transactions. Obviously, the user is still paying gas every time they want to claim their transaction, but you can't really get past that. Okay, so why are we doing this? Okay, so a roll up with 500 signers or 5000 signers or 5 million signers, doesn't matter. Is 66% less gas than our current multisig with 13 signers? Once we scale up to 50 signers, it's way more than 90%. And effectively, it just gets better and better the further we go along.
00:11:57.220 - 00:12:29.738, Speaker A: So that's the reason we would want to do this. There's a lot of complexities involved. There's a lot of asterisks and a lot of weird caveats. And these things need to be overcome. But basically, the benefits are it's provably secure. There's the fixed gas costs, the more complex calculations combined with the larger data sets. So you get to do complex calculations on big datasets, which is something you absolutely can't do on Ethereum right now, which is really nice.
00:12:29.738 - 00:12:48.802, Speaker A: We don't have to rely on third party networks because there's actually a snark j's in the browser. You can download snark js yourself. Any client can run the compute, so you don't need a full node network of nodes. We don't have to do that. So that's nice. There's no wait. Times like there is with optimism.
00:12:48.802 - 00:13:04.628, Speaker A: And my favorite part is it's cool and futuristic. That's why I'm here. I think that's why a lot of people are probably here. Yeah, exactly. Okay, so risks. So sha 256, catch act, whatever you want to call it, is. It's too loopy, like I said there.
00:13:04.628 - 00:13:45.154, Speaker A: But basically, it's too complex to work into a circuit and then have, like, 10,000 of them in that circuit. The complexity just goes up and up and up, and the compute goes up and up and up. However, there are a number of newer hashes that are ZK friendly. There's Mimc seven, there's Poseidon, there's a few others. And there's been no bugs or breaks or things. And they should be secure, but they haven't been out in the field as long as something like SHA 256. We know through trial and error and 10 billion hackers trying to hack it, that not only does the math line up, but also the.
00:13:45.154 - 00:14:07.198, Speaker A: It appears to be secure in the face of real threats. We don't know that about mimc seven and Poseidon and all these others yet. So that's the problem. I've seen another one is there's no community. I mean, how many of you use stack overflow, right? Everybody, always, constantly. Well, we don't really have that for Certcom. I mean, there's some.
00:14:07.198 - 00:14:22.306, Speaker A: It's getting better, but it's not there yet. Also, crypto is hard. Every time we end up with a new. A new feature we want to do, or a new weirdness, we've got to implement it. The libraries don't exist. The tooling doesn't exist. It's just not there yet.
00:14:22.306 - 00:14:39.294, Speaker A: And it's deeply complex. The language is fairly hard to handle. The whole being able to compile everything into chains of math is kind of hard. There's no auditor. There's a couple auditors, but exceptionally hard to find. Very. Not a lot of availability.
00:14:39.294 - 00:14:59.060, Speaker A: Don't really know how good they are, that sort of thing. And then, of course, there's unknowns. There's the things we don't know. We don't know. Right. Okay, so my to do, my call to action is, if you are a solidity developer, try building a circuit. Come in, play around in a hackathon.
00:14:59.060 - 00:15:19.120, Speaker A: You want to win a hackathon, try to do a ZK roll up. Try to do something that is impossible on chain in a roll up, and you'd probably win the hackathon. It'd probably be pretty cool. Join forums. Play in the forums. Tooling. If you're one of those nerds that really like to build tools and stuff, please, we need you right now.
00:15:19.120 - 00:15:37.640, Speaker A: It's like, I started solidity in summer of 2017, and web three sucked in summer of 2017. It was awful. All the tools, everything was buggy. The compilers sucked. Everything was sucked. That's where we're at with Sircom. That's where we're at with ZK rollups right now.
00:15:37.640 - 00:16:26.674, Speaker A: So please come join, be part of a community and play around. Implement the rock, paper, scissors, try weird things, make toys. That's how you learn things, that's how you have fun, that's how you get other people to engage. So if you're a solidity developer, if you have any interest in ZK rollups, it's not even about the privacy necessary necessarily, but the ability to massively scale Ethereum, I'd say join, try. So, questions anyone? All right, thank you. There's Vega, Vega XYZ, and all my music is on all the streaming as sacrificial pancakes. So hit me up.
00:16:26.674 - 00:16:28.874, Speaker A: That's it. Thanks everyone.
00:16:29.294 - 00:16:30.142, Speaker B: Questions?
00:16:30.238 - 00:17:07.804, Speaker A: Yeah, I thought there might be. Yeah, it's probably a naive question, but. So after the merge, do you think that there's any competition with ZK rollups, or is it going to make them obsolete or in any way? Does it in any way like the merge doesn't cut down gas prices and it doesn't really open up block space. So no, this actually helps scale after the merge. It's also going to work in parallel with sharding when sharding finally happens. So at least that's my understanding of it as it sits now. Gotcha.
00:17:07.804 - 00:17:08.864, Speaker A: Thank you. Yeah.
00:17:10.124 - 00:17:14.144, Speaker B: Okay, any more questions from the audience? Here we are.
00:17:17.063 - 00:17:29.575, Speaker C: So you mentioned that ZK rollups, in your opinion, should be application specific, not general. But there are a couple of layers being built that are generalistic, more or less. Right.
00:17:29.759 - 00:17:53.286, Speaker A: There are starkware things like that. They tend to be, in my opinion, slightly on the slow side, slightly cumbersome. They need a lot of work at the moment. These do as well. I'd rather have something that is bespoke and crafted to the problem than have some generic bulk that I'm not in control of. But that's just a control issue.
00:17:53.350 - 00:18:11.154, Speaker C: But isn't the problem with, let's say, application specific roll ups or even blockchains that they lose a lot of composability among each other? They need bridges or some other way how to communicate to take advantage of composability versus generalistic chains or layers.
00:18:11.804 - 00:18:44.440, Speaker A: Yes. However, the ZK is just doing a bit of verification. You still have the access to the rest of the smart contract and all the business logic, so you get the composability in that format with all the other smart contracts out there. You are correct. I see your point for sure. But you don't fully lose composability because you have it on the business logic side, because there is currently no way to verify proofs within a proof. So that does definitely become a problem in the long run.
00:18:44.440 - 00:18:47.644, Speaker A: So. Good question. Anyone else?
00:18:48.024 - 00:18:52.008, Speaker B: Yeah, one more down here. You're good to take a few questions.
00:18:52.096 - 00:18:52.464, Speaker A: Yeah.
00:18:52.544 - 00:18:54.304, Speaker B: Nice. I think we have time.
00:18:54.344 - 00:19:13.744, Speaker D: So, any thoughts on how to work on expanding the expertise within the development developer circles with ZKP? Like, given all the deep maths that's so hard to grasp, even by people from ZKP, I think it's very scary to try to enter.
00:19:16.084 - 00:19:37.794, Speaker A: No, this talk is my idea for how to expand this out. Yeah. Because I want people to join to play with it, because it is so new, it's so strange. Yeah, yeah. No, that's a good question. And it is hard, but that's why I said the toys, like play, make things that are fun, make things that are trivial. Don't put millions of dollars on them immediately.
00:19:37.794 - 00:19:44.674, Speaker A: That's down the road. Get it audited and stuff. Yeah. Anyone else.
00:19:46.694 - 00:19:48.394, Speaker B: Is shooting up everywhere. Now.
00:19:53.214 - 00:20:31.896, Speaker A: How do ZK rollups affect the end user and the way that they interface with what we build? Well, as I said before, there is a snark j's library that is in the browser, so ideally you can obscure it all the way, just like we do all the connections of actually building up the transactions that go to ethers or web three. So it really depends on how it's developed. But if you do it right, you can obscure a lot of that stuff away. And I really suggest we do that because. Yeah. Having a user actually download a file and then re upload the file somewhere else and then actually wait, you know, a minute for the thing to kick out and all that. Don't do that.
00:20:31.896 - 00:20:34.684, Speaker A: Yeah. Like, at least if you can avoid it.
00:20:35.344 - 00:20:37.804, Speaker B: Okay, we have one more question here.
00:20:38.384 - 00:21:07.346, Speaker A: Yeah. Now, most of ZK roll ups are application specific ones. Do you see? It's like the way for ZK rollups to be, or we will see more general computation. ZK rollups. Personally, I like the per application, there is a general purpose computer out there. What's it called? What was it? Yeah, the snarkware guys. There's a few of them out there.
00:21:07.346 - 00:21:16.494, Speaker A: Those are general purpose, but those are really bulky machines. Lots of compute. It gets really heavy. They'll get better as we go along, I'm sure. But at the moment, application specific.
00:21:19.474 - 00:21:22.864, Speaker B: Any more questions from the floor? Yep, in the middle.
00:21:24.764 - 00:21:29.804, Speaker E: Hey, do you see this as the sort of holy grail for what you're trying to do, or.
00:21:29.964 - 00:21:53.316, Speaker A: It is, yeah. Oh, yeah. For scaling Ethereum. Absolutely. This is the best way to scale Ethereum that I'm aware of at the moment because no matter what we do, if we're storing all the data on chain, the block data gets too big. We're having that problem. Trying to sync a whole node with Ethereum right now is a nightmare and it's only going to get worse.
00:21:53.500 - 00:21:59.748, Speaker E: Holds. Like, it's, it's not like, oh, it's great, but for the, all these compromises.
00:21:59.916 - 00:22:07.564, Speaker A: Oh, there's always going to be compromises, but it's still better than, it's still the only way I can see to really scale it big. I'd love to be wrong, like, that'd be cool, but.
00:22:07.644 - 00:22:15.704, Speaker E: And in your whole kind of learning journey, what's been the gnarliest part of it for you to get over?
00:22:16.084 - 00:22:27.224, Speaker A: No branching. I can't use zip statements like, like that. Seriously, as a coder that just immediately kicks you and you're like, oh God, what am I going to do? Good questions. Thanks.
00:22:27.724 - 00:22:29.356, Speaker B: Another question from over here.
00:22:29.540 - 00:22:31.544, Speaker A: Wow, I'm getting a lot this time. This is awesome.
00:22:31.844 - 00:22:34.324, Speaker B: It's turning into mass mentoring session.
00:22:34.404 - 00:22:52.364, Speaker A: Yeah. Oh, by the way, before you ask your question, reach out to me. If anybody does start one of these things, reach out to me. I'd love to answer your questions. After the last time I gave this talk, I had two people here get ahold of me and I walked them through and they made circuits and one of them made a tutorial and stuff. It was pretty cool. So.
00:22:52.364 - 00:22:55.544, Speaker A: Yeah. Yes, of course.
00:22:58.004 - 00:23:23.302, Speaker F: So one of the questions I have, so the great part is that you're able to remove the computation from inside the smart contract itself and you're able to do it on the outside, but thus also kind of presets the fact that you kind of need a storage solution to keep that information for a long time because otherwise, like if you come back to a ZKP, like you want to verify something like a year afterwards, you have to have that information available. So is there some kind of way.
00:23:23.358 - 00:23:55.354, Speaker A: That it's not intrinsic, we can use things like ipfs or you just build it in such a way that the verification is all built in. So you don't care about the data that went into it. All you care about is the output. With an individual withdrawal from our bridge, once everything's done, we know it's accurate, we've accounted for it on our side. The data doesn't, that whole bundle and everything doesn't need to continue to exist. I mean, it will in our particular case, but it doesn't need to. Yeah.
00:23:56.774 - 00:24:04.614, Speaker B: Any more questions? Yeah, one here, maybe this is the last one or maybe one more.
00:24:04.734 - 00:24:05.634, Speaker A: Yeah, probably.
00:24:07.694 - 00:24:10.438, Speaker B: The stage manager isn't shouting at me, so we're fine.
00:24:10.606 - 00:24:11.388, Speaker A: Cool.
00:24:11.566 - 00:24:27.936, Speaker D: Hi, again. The operation in some layer twos is, I think, very central now. They say they will fix it in the future, but what do you think about that? Like a secure answer infrastructure?
00:24:28.080 - 00:24:54.042, Speaker A: Oh, I think a lot of the stuff will end up being wrapped into Ethereum eventually. There's going to be a lot of compatible things built directly into it. Yeah, yeah. I don't know if there's. Yeah, that's what I got. Sorry. Okay, if there's nothing else, I have a question.
00:24:54.042 - 00:24:54.854, Speaker A: Oh, yes.
00:24:58.154 - 00:25:12.344, Speaker B: You clearly seem to have found the place and the role in life at which you shine. Right? You found this thing that you absolutely love and you just. You're able to, from that, put all your energy into it.
00:25:12.384 - 00:25:16.168, Speaker A: Oh, I'm like this with everything. Sorry, keep going.
00:25:16.336 - 00:25:20.520, Speaker B: I just want to know, like. Like, where'd you get all your energy from?
00:25:20.672 - 00:25:30.326, Speaker A: I go manic when I find something that I like. When I find something I like, I just. I dive in and I embed myself and that's what I do. And that's the thing. Yeah.
00:25:30.400 - 00:25:34.826, Speaker B: Specifically, the subject is the development of zero knowledge roll ups.
00:25:34.970 - 00:25:36.266, Speaker A: Honestly, it's specifically.
00:25:36.290 - 00:25:37.642, Speaker B: How do you define your subject?
00:25:37.738 - 00:25:54.450, Speaker A: No, it's not just ZK rollups. Yeah. Right. It's smart contracts and blockchain and decentralized ledgers and all. It's like blockchain games and all the other stuff. Yeah. It's crypto in general that I love, that I find myself attracted to like this.
00:25:54.450 - 00:25:58.404, Speaker A: I mean, I've been a dev for five years, just in solidity, so. Yeah.
00:25:58.744 - 00:25:59.192, Speaker B: Wow.
00:25:59.248 - 00:26:01.164, Speaker A: Yeah. Good question. Thank you.
00:26:01.544 - 00:26:07.804, Speaker B: It's inspiring to see, I don't know how other people feel, but I'm just like, wowed.
00:26:09.744 - 00:26:10.168, Speaker A: Thanks.
00:26:10.216 - 00:26:17.248, Speaker B: So maybe should we let him rest? Ok, good. It's been a pleasure. Thank you very much. Danny Hobbes.
00:26:17.256 - 00:26:17.504, Speaker A: Thank you very much.
