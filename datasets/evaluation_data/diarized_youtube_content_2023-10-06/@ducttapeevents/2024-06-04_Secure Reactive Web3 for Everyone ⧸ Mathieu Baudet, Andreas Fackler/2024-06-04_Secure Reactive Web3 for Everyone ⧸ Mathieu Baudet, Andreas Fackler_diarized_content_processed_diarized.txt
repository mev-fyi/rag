00:00:12.760 - 00:00:40.584, Speaker A: All right. All right. Hey, everybody. It's good to be here. Do we have a lot of builders in the room? Infra builders. All right, cool. Okay, so, yeah, so one thing I really like with web3, and I mean computer science and web3 in particular, is that sometimes, sometimes you look at a program with a fresh look, and that's really, and there's really a lot of innovation that can happen with just a few people.
00:00:40.584 - 00:01:51.284, Speaker A: And that's really, I found it really motivating. And so when I started leaning around, the prime I had in mind was how to solve scalability and user experience for web3. And so this talk is very much kind of a result of, of a long process, starting with this ambition and slowly understanding that we were missing. It's not only about transactions per second. When you want to really provide good user interfaces, you really need to look at the responsiveness of the interfaces, the responsiveness of the applications. And so technically, you really want reactive applications. And so this talk is about how can we make this a reality? How can we have reactive applications in web3 without training of security and decentralization? If there was any doubt that reactive programming is important, we can look at what's happening in web two.
00:01:51.284 - 00:02:37.818, Speaker A: And what's amazing is that you have frameworks like react js that have tens of millions of projects using them. If you just look at the stats on GitHub. And so definitely this is a standard, this is the way people are used to program user interfaces. And concretely, what does it mean? So what it means is that you have a web UI that's going to maintain connection with the servers and be ready to receive notifications. And what you want is that when there's a notification, you want to be able to pull the data, pull the updates from the server and process them and refresh the UI. And the quicker, the better the experience is for the users. You may be interacting with other users, you may be playing a game.
00:02:37.818 - 00:03:23.936, Speaker A: You want things to be fluid. You want users to never wait on the interface. And so can we have this in web3? Well, let's look at the current stage. The current state of web3 is that it's really mostly about transactions. I mean, arguably, when you look at what are the, when you ask people what is the end to end latency, more often than not they tell you they're going to consider what the end to end transaction latency is. And so they're going to look at the time it takes for a client to initiate a transaction and get it final, get it confirmed as part of the blockchain. Okay, but it's only about the writer.
00:03:23.936 - 00:04:52.074, Speaker A: And you may ask, okay, but what happens with the second half? What happens once the transaction is executed? And now you want to know that the receivers of the transactions of the receiver will have the UI updated, right? So one thing that we really want to work on in web3 is the data latency for the readers. Another thing also that arguably is not perfect just yet, is also the security of the data when they are being read from the blockchain. So data authentication. And so I am going to speak also about that. So the vision here that we'd like to advocate is that reactive programming should be easy and secure for everybody. In web3, imagine a word where when you start, a payment not only gets confirmed very quickly below second on the writer side, on the sender side, but the receiver will also receive a notification in under a second that the money is there and the UI is refreshed immediately. Wouldn't that be nice? Right? And now in the world of gaming, for instance, if you had a system where you have very quick notifications, then you would be able to deliver the user rewards very quickly.
00:04:52.074 - 00:05:32.730, Speaker A: And you can imagine that from the point of view of a gamer, it's kind of nice. You're interacting with the game, you get the rewards, they are final, they are on chain. You can see that you have them already. So it's a nice thing to have. But of course, now if you have an infrastructure that supports these very quick interactions between users, then you can start also thinking about having an entire game on chain. So we spin, maybe we can spin a game, you can make a move, the other users see a move, they react, and everything is fluid. What you don't want is if you're creating on chain games, of course you don't want to have a round trip between the users.
00:05:32.730 - 00:06:18.104, Speaker A: That is like 10 seconds, 20 seconds. Nobody wants to play chess like this, right? And then finally, there's a third category of applications that I think would benefit a lot from having secure, reactive applications. It's the multi chain, what I like to call multi chain defi. So Defi, of course, decentralized finance is one of the domains where there's the most obvious product market fit with blockchain technologies. But so far it's been a lot about single chain. Define. So you have atomic composability inside a single chain.
00:06:18.104 - 00:07:02.424, Speaker A: You can run uniswap and it works. But we know. So the world has changed and now we have a lot of chains that are running and so it's more likely that when you want to do define, nowadays you want to interact with multiple chains in parallel. So now imagine if you had a reliable and secure notification system to provide you with notifications about your different trades, your different ongoing positions with the different chains. A number of things would be possible. You would be able to, obviously you would be able to do arbitrage across the chains. You would be able to take several positions, maybe overcommit.
00:07:02.424 - 00:07:40.936, Speaker A: And when you're matching on one of the chains, you can quickly adjust your bids in the other chains. And that's what some professionals do. But it's a lot of work. You need to run full nodes of all the chains. You need to optimize for the latency. And so imagine if we had an infrastructure that makes that available for normal users from their web browser or from their mobile phone. How can we make that happen? So let's look at the current state of developing a web3 application.
00:07:40.936 - 00:08:29.216, Speaker A: How does it work? Currently you have a web UI, and usually your browser doesn't have a full node for the layer one or the L2 you're using. So what's going to happen is you're going to talk to an API provider, and that API provider is talking to the blockchain infrastructure. Now the problem is, first in terms of security, more often than not the browser is just trusting the data from the API provider. So we'd like to do better this technological lite client. So you basically ask the API provider to prove to you that the data that are served are authenticated are correct and tied to the security of the underlying blockchains. The problem is the light clients come with a number of restrictions. They don't support arbitrary calls.
00:08:29.216 - 00:09:15.994, Speaker A: They can only prove to you the stored data. And in practice the adoption is very low. There are also some attempts to make light planets more appealing, in particular to support arbitrary calls with zero knowledge proofs. But that's going to add server side costs and latency. And so in this talk we're concerned about latency. And so we can see that it doesn't seem that light clients are going to be quite what we can use for reactive web3, for secure reactive web3. And in general, when you look at all the existing layer one, L2, I think it's fair to say that the main focus has been historically transactions per second.
00:09:15.994 - 00:10:24.714, Speaker A: And our infrastructure, they actually have a maximum TPS, which is kind of scary if you're an infrastructure builder that you're not going to be able to scale above a certain threshold so everybody has been competing to get the maximum number of tpos supported by their blockchain. Nowadays we're also seeing some recent layer ones making really good progress at low fidelity. So the time it takes to confirm a transaction is starting to look pretty good, like in some cases under a second. What nobody is really looking at is the data latency, the time it takes from the layer one to after the layer one has confirmed a transaction, the time it takes for the API provider to pick the changes, to index them, to make them available to the other users that didn't initiate the transaction. This is data latency and this is hurting reactive programming. So can we do better? Well of course some users could just run a full node. So that solves the problem of trust.
00:10:24.714 - 00:11:09.604, Speaker A: You don't need to trust an API provider because you're running it. And of course if you invest a lot of material, a lot of hardware, you could maybe make the homemade indexing fast enough for a number of applications. But most users, if they're on the web or mobile, they just can't run a full node of Ethereum. That's just not practical. So what can we do? We need to take a step back. Basically we need to redesign a system and really prioritize low data latency. So the solution that we are advocating at Lineara is to introduce a new concept that we call microchains.
00:11:09.604 - 00:11:59.594, Speaker A: So what we're going to do is going to have a separate layer that has block space organized in a different way. We want something way more user centric. We want to have users have their reserve, a reserve block space, a small chain of block where they can keep their assets and keep their application state so that it's easy to create blocks and easy to replicate the data of the user from validators to their wallet. It's changing the programming model. It's a bold move. We are giving up atomic composability, but we are going to replace that with a very rich programming model where you have question messages that are very cheap. You have chains that belong to users, but you also have chains that are shared between users.
00:11:59.594 - 00:13:18.534, Speaker A: And inside a chain, of course you still have composability as usual. Okay, so how does it look concretely when you have a system based on macro chains? So we're going to have a number of validators. They're going to be maybe a bit larger than Ethereum validators because we're going to ask them to validate the chains of all the users, the micro chains of all the users are going to be secured by the same validators, they're going to have the same level of security and we're going to have asynchronous messages between them. And so the nice thing about designing a system like this is that you can use the internal network of validators and make the messages way cheaper and way faster than usual than in traditional blockchain charging system, for instance. And now when you look at the user wallet, so the user wallet is going to have a replica of a number of microchains that they are interested in. So in particular in this example, so you have a user that has microchain b, and that microchain is going to be replicated and maintained. And now the user can create a block anytime they want and tell the validator, okay, it's my next block, please validate this block and give me back a signature.
00:13:18.534 - 00:14:25.252, Speaker A: And so in the simplest cases, you only need to do that once you get a quorum. That's it, your block is final and you can just broadcast it back to the validators. And then the validators are going to execute your block and then they can notify other users if they receive a message, for instance, that has been just triggered by this block. So what we see here is that when using microchains, we have split by construction. It's a system that is indexing friendly. We have structured the block space in a way that we know exactly which user, where the users are storing their data and their assets, and we know exactly who to notify when there's a new block added somewhere. So Linearr is an implementation of this idea that is using proof of stake to secure the validators and is optimized for quick penalty and low latency client synchronization for the programming of the applications.
00:14:25.252 - 00:15:27.344, Speaker A: We're using rest and WASM. We're working on interoperability with EVM chains and a hybrid model to introduce very strong security on top of the validators, potentially even with a bridge to Ethereum eventually. I meant a roll up to Ethereum eventually. And so what does it look like in our system? So if you compare to the previous diagram, you can see that we don't need a data provider. When you program most of the applications in, you will just replicate the microchains inside the wallets of the users and then the wallet will be serving the data to the web UI. So in that system, the wallet is acting as a local data provider, which is something that is very original and it's completely unlocking exactly what I was talking about. The reactive programming and notifications fast notifications to the users, to the user UI.
00:15:27.344 - 00:16:14.874, Speaker A: Just a quick word. We chose wasm, rest and wasm. It's actually a really good choice if you're going to have a wallet that contains chains and is going to execute transactions. So that wallet is going to have a vm. And so by choosing the wasm VM, we get the VM for free. Essentially we just need to add some instrumentation to admitting and suddenly we got a portable system that can very cheap portability for transaction execution between validators and web client. So now let's zoom in into this idea of having a wallet tracking chains.
00:16:14.874 - 00:16:57.558, Speaker A: So when you're using micro chains, your wallet is going to have actual chain of blocks for the micro chains that the user care about. And then this chain, a particular chain, will have a number of applications that are being used. Each application has two bytecode files, one that is we call the contract bytecode and one that we call the service bytecode. And that's something that's really interesting and kind of unique. The contract bytecode is there to execute transactions. It needs to be deterministic execution and method. So this is traditional blockchain execution model.
00:16:57.558 - 00:18:01.064, Speaker A: The service bytecode however is fairly unique. You have to imagine that you have some code that is immutable on chain, but is run off chain and that code will not be able to mutate the state of the applications only querying it. But on the other side, it doesn't need to be metered and it doesn't need to be deterministic. And so this is what we leverage here to help applications create their own specific data provider for their own uis. So now when you're in web UI, what you see is that you have this magical local data provider. You can send graphql queries to query the state of the chain or to query the state of an application, and then the application will execute the wasm code created by the authors of the application to answer your query. So the nice thing about it is that there's no need for metal proofs or zero knowledge proofs.
00:18:01.064 - 00:18:56.732, Speaker A: So it's very low cost and it's run on the client. So there's also no need to pay for any fees, just the web browser of the client is doing the work. Another side benefit of that, by the way, is that when you want to create a block, you can just say, hey, I want to initiate, this is what I want to do. I want to transfer assets, or I want to make a move in my chess game or something like that. And the web UI is going to make that intent visible by making a graphical mutation. And the wallet can actually create a block for you that corresponds to your intention. So that solves the problem of visualization that is very hard to use in normal wallets.
00:18:56.732 - 00:20:17.034, Speaker A: In normal wallets the UI will actually build the transaction and then send it to the wallet. And so the wallet has this transaction that comes in that is supposed to sign. But if the wallet hasn't specific code specific support for the, for the particular Ethereum application can be really hard to present the user a meaningful confirmation message before signing the transaction. So in our case, the wallet is the one building the transaction in the first place based on high level intentions that have been specified by the web UI. So it's much easier to confidently sign the data, sign the transactions before by the user. All right, so now what does it look like wrapping up? What does it look like? Reactive web3, when you have microchains, so you have a user wallet that is maintaining a connection with the validators, that is able to propose new blocks, getting them approved by the validators and getting quick finality for those blocks. And then through the connection you can be notified by the validators when somebody is sending you a question message that is kind of waiting to be picked.
00:20:17.034 - 00:21:07.662, Speaker A: When that's the case, your wallet can react to notification and synchronize the missing data very quickly from the validators and in a way that is censorship resistant by the way. And then you get the data replicated on the wallet side. What's important here is that the wallet, when it receives blocks, is going to verify all the signatures. It's going to re execute the transactions if that's one of the chains that you care about. So at the end of the day, you get the state of the chain on the client side that is fully authenticated and ready to answer questions from the web UI. And in fact for the same price you also, of course you can notify the web UI if it has subscribed to modifications. Then the web UI can quickly pull the data from the wallet and refresh using a reactive framework.
00:21:07.662 - 00:21:47.018, Speaker A: So that's it. Finally, we have a framework for fast and secure reactive web3 programming. It doesn't require complex cryptographic systems like zero knowledge proofs. It's fairly natural to programming this because from the point of view of the web UI, you are just querying a local service that is using standard web, two concepts like GraphQL or JSON. And that's what we do. And now, bonus, we have a few minutes. So we in our user wallet.
00:21:47.018 - 00:22:54.712, Speaker A: I said that we have some service code that can answer queries and that's using a vm that is deployed. And so of course the next thing we did is to put AI on the edge in the wallet of the users. And so what we did is that we programmed the description of AI models on the blockchain. And then that means that now the users, I mean, the UI of the users can query their wallet and the wallet is going to run AI in France for them. So you're like, okay, but why should I run AI inference in my wallet? Well, the wallet is a secure enclave that is running trusted code that is either deployed by the provider of the wallet, the software developers of the wallet, or that has been deployed on chain and has been audited by the community. So you have a secure, a secure enclave that is, that you can trust, that is going to run AI in France. You could query the model using private data.
00:22:54.712 - 00:23:44.674, Speaker A: You have the insurance that the data are going to stay private. They are just run by you in your wallet. The models are just run by you in your wallet, so you know you can trust the result of the computation. So that's where, for instance, you could have your private AI financial agent to help you make decisions about trading. Especially I was talking about the multi chain defi use case. So seems like it would be really nice if you can have a number of connections open that are making you aware of the changes in the auctions that you're participating with. And your AI financial agent can, your financial AI agent can help you process those notifications, tell you what to do next.
00:23:44.674 - 00:24:40.264, Speaker A: In this particular demo that is on screen right now, what we did is, of course, more modest to get started, what we did is a generative NFT. So the idea of a generative NFT is that the content of the NFT is not going to be an image, it's going to be a prompt for an LLM model. And so here we're using a demo that we took from a rust library called candle, and we packaged it in our own framework for web3 development. And so on the right side, you see the prompt. Once upon a time, there was a magical kingdom called web3, and that prompt would be unchained and immutable and would be minted as NFT, and then everything else. The rest of the story is the result of running the LLM on that prompt. And so you have a system where the NFT is very short.
00:24:40.264 - 00:25:41.224, Speaker A: Okay. And the visualization, the rendering of the NFT is very cheap and trusted and so you kind of have the best of both worlds. All right, so to wrap up, I presented a system. So most blockchains right now, they prioritize the story for writes, they prioritize performance for transactions. But currently the story for data latency for the reads is still, I would say questionable, still up in the air with microchains for the first time, we propose a system where we organize the block space to be, to be indexing friendly, to be structured around the notion of user accounts and potentially the notion of objects. This is very convenient for activewear. Three really enables fast client and validator synchronization, and we are the first decentralized infrastructure to use that idea.
00:25:41.224 - 00:25:44.564, Speaker A: All right.
