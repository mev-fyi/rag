00:00:01.200 - 00:00:28.234, Speaker A: Thank you. Hi everyone, I'm Yaroslav. This is Tereh. Today we would like to just very briefly explain for this dpruver how it works, and then we will show you some particular examples, like we will work with particular smart contract, try to verify the properties. And it's also because r two recently become free to use. So anyone can use it in some restricted mode, but you can use it. So I hope that you actually use it to verify your contracts.
00:00:28.234 - 00:01:07.584, Speaker A: So, let me start. Our prover takes some smart contract, usually written in solidity and some specification, and it somehow decides whether the specification holds or not. If the specification holds, we can give you some mathematical guarantee that it holds. If it is violated, we can give you like execution of the smart contract that validates the specification. Now, this specification, it can be something like if you execute function transfer, then it actually transfers the right amount of tokens to the right address. Okay, this can be like a piece of the specification. We have our custom specification language, it's called cetera verification language.
00:01:07.584 - 00:01:41.224, Speaker A: And you write the specification in this language. And we'll see some examples later. We can sometime out, because we are doing formula verification. The formal verification means that we check all the possible executions of the smart contract, if any of them can violate the specification or not. So it's like it's not testing, it's not fuzzing. We are checking everything, which means it's more expensive from the computational point of view and in my timeout, but it gives you some additional guarantees. Okay, that's the difference, maybe.
00:01:41.224 - 00:02:16.934, Speaker A: And the nice thing is that once you've write a specification and you've made changes to your code, you can run the prover again against specification. So, either you write specification, you integrate it into your CI tests, and whenever you make some changes, you check again if the specification still holds or not. So, that's like the ideal use of certain approver. Now, very briefly how it works. So, this is the architecture of the approver. So I'll just go briefly over steps, and then we'll see the demo. So the first step is that we take the solidity code, we compile it to bytecode.
00:02:16.934 - 00:02:46.164, Speaker A: And the reason is that you uploaded bytecoin on the blockchain. Right. And there are different compilers, they produce different bytecodes. Sometimes there are bugs in compilers, and we actually found some bugs in compilers, because using some compilers, this specification was proved, and using other compilers, this specification was violated. So we have to work with Debye code. Now the issue is that Debye code is not human readable. It's hard to automatically process because it contains too many instructions.
00:02:46.164 - 00:03:23.574, Speaker A: You cannot easily map it back to the solidity. I mean there are some decompilation step, and if you find some valuation, we want to tell the user, hey, there is this, you know, this is the violation, but we don't want to show this on the byte code. We want to somehow map it back to solidity. So there are some complications, but we have to work with the bytecode to make sure that we verify the code that is on the blockchain. Now what we do next is that we take this bytecode and we convert it to our customer code representation. We call it three address code. And basically the motivation is to make it easier for the proverb, because this three address code, it's simpler.
00:03:23.574 - 00:03:54.104, Speaker A: It is using only a small number of instructions. These instructions are easy, so it's easier to automatically analyze these programs. And also it allows us to actually support other inputs. So everything that compares to EVM can be supported by our tool. And also if you compile, let's say Solana to our three reals address code, somehow you can also verify it using our tool. So that's like the motivation for having our custom three address code representation. Good.
00:03:54.104 - 00:04:29.404, Speaker A: Next step, we take the specification and we add it to this three address code. So you basically somehow merge the specification and match the program. And we actually turn the specification to assertions in our program. So at the end it's about find out if you can reach and violate an assertion in our three address code. That's the verification task. Now we are just checking assertions basically. Okay, next step, we take this three address code and we simplify it to make it easier for the prover.
00:04:29.404 - 00:04:54.876, Speaker A: So we do things like points to analysis. If you have heard about this before, we do some slicing, some value range optimization. So for instance, you might have variable, let's say x. It's un, so it can have many values, right? And we are doing this formula verification. We are checking for all possible executions, all possible values of variables. But perhaps x is always between zero and ten. If we somehow find out, it can simplify the verification task for us.
00:04:54.876 - 00:05:15.224, Speaker A: Okay, so we do this like analysis of the program and some simplifications. Definitely an example of slicing. So let's look at, it's at the bottom. I'm not sure if you can see the program at the bottom. Can you see it a bit? Okay, maybe I can just read it. So it's a very small program. There are two variables.
00:05:15.224 - 00:06:03.704, Speaker A: These are structures x and y, and there's some internal variable f, and you set x f to one, y f to two, then you change the value of y, and then you have an assertion about x. And the thing is that y is irrelevant because you are talking just about x in your assertion. And now, you know, if this is the specification, this assertion, it basically means that you don't care about y, about a variable y, and about like operations related just to y. So you can just remove it from the program, you get something smaller, and then it's easier for the prover. So this is like an example of transformation simplifications that we do on the target representation. And then we are almost done. So we take this program and we encode it to logical formula.
00:06:03.704 - 00:06:52.430, Speaker A: So intuitively, the formula says that there exists initial values of variables of the program, such that after the execution, the assertion or an assertion is violated. This is our logical formula. And if you can satisfy this formula, it's like a mathematical formula or some variables functions. Okay, if you can satisfy this formula, it means that there is an execution of the program developing specification, right? So, and we can map it back to solidity. And that's like the, you know, countries input, your specification, and if you cannot satisfy this formula, you're okay. Like your specification cannot be violated by any possible execution on the smart contract. And the very next step is that we take this formula, we convert it to something called SMT.
00:06:52.430 - 00:07:27.454, Speaker A: It's like a input for some solvers, for logical formulas. Then let me just apply these SMT solvers, which are developed by universities or by Microsoft, for instance, and we check if the formula is actually satisfiable or not. And if it is satisfiable, we get the execution of the smart contract that validates the specification. If it is not satisfiable, we have this guarantee that there is no execution that validates this specification. That's it. It sounds very easy, right? The idea is simple, it's not so easy. But that's the idea behind formula verification.
00:07:27.454 - 00:07:33.586, Speaker A: Sure, we can ask questions now, can.
00:07:33.610 - 00:07:34.774, Speaker B: You show the example?
00:07:37.074 - 00:07:56.210, Speaker A: I will not show bytecode, but the rest of this session will be actually practical demo where we will show some smart contract and some properties and verify them. This is the content for the rest of the session. Good sense of the prover. Yes. Another question, how much work is it.
00:07:56.282 - 00:07:59.082, Speaker B: To do the back and forth from.
00:07:59.258 - 00:07:59.974, Speaker A: The.
00:08:01.874 - 00:08:03.254, Speaker B: Thing that we can offer?
00:08:12.854 - 00:08:36.699, Speaker A: It's not easy. We will show this any demo. It's. Yeah, it could be hard, but it's somehow like yeah, decomposition to bytecode is hard, but let's say the compilation to our specification language is easy because it's us. So you can basically, you know, make some marking in the specification and then use this information to understand the counter example. We will see some examples.
00:08:36.821 - 00:08:45.923, Speaker B: Do you need to write the contract in some specific way, also formally verifiable or you can formally verify any contract?
00:08:49.023 - 00:09:37.688, Speaker A: We cannot verify any contract because the model checking formula verification, it's like undecidable problem and it's hard. So even if decidable, just time out. Now, the thing is that you can write solid in different ways. Some of them are good for the prover, some of them are not. And for instance, you might optimize for some gas consumption and make your code ugly but efficient in some way, right? But if it is ugly, it might be hard for the solver. So usually it's good to think about the form verification when you are already writing the code to make it somehow compliant with the tools that you want to use. Should be like decomposable for instance, into some like sub modules, and then you process into some modules and somehow compose the results and.
00:09:37.688 - 00:09:42.184, Speaker A: Right, yes, but you mentioned that actually.
00:09:42.264 - 00:09:48.232, Speaker B: Solidity is enrollment here. Your input is the bytecode and on the other side is the specification.
00:09:48.408 - 00:10:01.754, Speaker A: Right. Well, we still map the result to solidity to show the user. Yeah, we have some kind of mapping and we'll show some examples.
00:10:06.654 - 00:10:13.994, Speaker B: Is it somehow different from already existing to like older formal verification projects? I forgot the name of.
00:10:14.734 - 00:10:47.274, Speaker A: You mean like in the space of blockchain or in general or in ethereum. So there are more companies that do some form of verification, like runtime verification. There are many tools working on different principles and we have our custom principle. Hard question. It works. That's my answer. It works.
00:10:47.274 - 00:11:20.458, Speaker A: Okay. If you allow me to postpone these discussions, we can talk after the session. We want to show you how to use the tool because we hope that you will start using the tool. So just if you open our website, certeta.com, you can click on this get started free button. And basically you can use the tool for free. There's some limitation in like number of computational time you can use per month and also like a time limit on single usage of the tool.
00:11:20.458 - 00:12:12.188, Speaker A: But you can use it to verify smart contracts. Okay, like you cannot verify Aave, for instance, with like this free version because it's like too complex. But yes, you can, you can write some nice specification about contracts. Another thing I want to show you, maybe you'll find this interesting so cetera is organizing these contests with code arena or with aave community for instance. So basically the idea is that anyone can participate in these contests and you can use the prover, you've write specification, you use our prover and you are trying to find bugs in these protocols. So if you also interested in this like trying our tool to find bugs in, you know, existing protocols, you can just participate in some of these contests. We'll have context of GMX in December for instance.
00:12:12.188 - 00:12:44.034, Speaker A: Or you can just use the approver on yourself using like you know, this free license and verify your smart contract. So these are like the options and I hope you will try some. I'll just skip back to the slides. Here's some recommendation, you will find it. But for today we prepared this simple smart contract. It's called english auction and Taraj will now replace me and show you actually how to write the specification, how to run the tool, how to read the results of the tool. So please welcome Taraj.
00:12:48.894 - 00:14:05.002, Speaker C: Thank you Aroslav. Hello. So I'm Tadash and I would like to show you the contract and what can we do with it? This is the contract, I will try to move fast and break nothing as our motto says. And the contract basically is meant for auctioning. So when you want to start using it, you call the constructor and you supply to the constructor the address of the NFT that you want to sell and NFT ID and you supply also the address of ERC 20 in which you want to accept the payment and also starting bid what you want to get at least this amount. And then other users can like bid and offer their amounts to get the NFT. And whenever they bid, if the amount they offer plus the bids that they already offered increases what is the current highest bid? They become the highest bidder.
00:14:05.002 - 00:14:16.934, Speaker C: And the protocol gets the amount from them so they don't run away and keep the money. So let's go through some of the functions. There is function start.
00:14:20.914 - 00:14:22.458, Speaker B: Yes, you're right.
00:14:22.626 - 00:15:04.244, Speaker C: We should put it here, right? Yeah, thanks. So, so the start function starts a protocol. It sets started to true. It gets the NFT from the message sender, which is the seller, and it sets end at to seven days from now. Which makes sense that you want the auction to last seven days. Then there is function set operator. You can allow somebody else to withdraw your funds from the, from the contract.
00:15:04.244 - 00:15:30.554, Speaker C: We will get to it. When we talk about the withdraw, there is bid four, you can bid on somebody else's behalf. So that's what it used for. There is bid function. It's basic, basically easy bit. You call it and it bid for you and you pay for it and the amount is used. And then there is this underscore bit that's internal function.
00:15:30.554 - 00:16:16.318, Speaker C: And this does all the work, bidding work. So it requires the auction to be started. It requires to be still before end. The timestamp should be before. And, and it transfer from basically you, if you call this or from the payer, I'm sorry, from the payer, it transfers the amount that they are offering to this contract. So contract takes the amount also bids, which is internal map that keeps track of what is the bids of each person. So bit of the bidder is increased by amount.
00:16:16.318 - 00:16:49.144, Speaker C: There might be zero like at the beginning and there might be like thousand if they bid it before and they are increasing this amount. So this amount gets increased. Highest bidder gets updated. Highest bid gets also updated. And then there is the require. So if this offer doesn't like overshoot the previous bit, then this all gets reverted. Makes sense, right? Any question, just shoot.
00:16:49.144 - 00:17:29.314, Speaker C: Then there is withdraw function, underscore withdraw. It takes in bidder, recipient and amount. And what does it that when you are not the winning the highest bidder right now, then you can call it and succeed. The highest bidder cannot withdraw their money because we are counting on them to pay. Right. So bids get subtracted by amount and tokens are transferred back to either to the bidder or to a recipient. And that's where the operators come into.
00:17:29.314 - 00:17:57.434, Speaker C: So if you assign somebody a role operator for your bidding, they can withdraw on your behalf. So that's the withdraw for function. And then there is withdraw amount function. And the basic withdraw which withdraw everything you have there. So that's withdrawal. And then there is end function. Anybody can call it and it can be only executed once the auction ended, which is here.
00:17:57.434 - 00:18:50.474, Speaker C: The timestamp must be greater than. Oh yeah, the timestamp must be greater than end at. And you don't want to end your auction files. And we also require it to be started, of course. And what happens inside is that the NFT gets either transferred to the highest bidder and the tokens that we got from them inside this contract get transferred to the seller. Or if there is no highest bidder, meaning that nobody wanted the NFT, nobody gave enough money, then the NFT gets transferred back to the seller. So this is the contract and we are going to verify it.
00:18:50.474 - 00:19:34.374, Speaker C: To verify a contract in Sartora, we use rules and rules are like properties written somehow. I will show you how and when verifying, we check that any possible scenario, any possible run through the contract calling multiple functions stuff, always these properties will hold. So it's not unit testing. You really test for any possible setup if you write it correctly. And let me. Yes, this is CVL. It's our internal language.
00:19:39.634 - 00:19:40.854, Speaker B: For your id.
00:19:42.094 - 00:20:14.122, Speaker C: Markings for id. What is marked? Oh, you mean this comment? That's my comment, yes. We also have, we also have syntax highlighting for the language. Yeah, it's CBL with syntax highlighting. We wrote that. Yes. Thank you.
00:20:14.122 - 00:20:46.880, Speaker C: Yeah, yeah, yeah. Syntax highlighting. Okay, so this is the first rule I would like to show you. It's rule that takes any recipient, any address, any amount. Okay. And any state of the contract. So this environmental variable, enve holds timestamp message sender and it holds message sender.
00:20:46.880 - 00:21:38.108, Speaker C: So you can pass it the e to a function of the contract, which is here, withdraw amount right here. Okay. As a first parameter. So withdraw amount actually usually takes just two parameters, but in Cvl here, it takes one more e and it contains sender of the message and timestamp and much more. So here we remember the bit before. That's like what the emessage sender, the one that will send this message had in their bits before. And then we execute withdraw amount with this modifier, which I just used to make sure, or to track if the function reverts or not.
00:21:38.108 - 00:22:14.794, Speaker C: And so we execute this function and then we claim bitbefore is less than amount. Then this had to revert. What does it mean? You cannot withdraw more than you have in your bits. Makes sense, but not in some scenario, all scenarios. So that's one rule. Any questions regarding this rule? So let's see another one. Let's see this one.
00:22:14.794 - 00:23:09.424, Speaker C: This one is the next easy rule. This is invariant. Invariants are properties that you want to be preserved. So it's just statement that you want to claim that it is preserved in all rounds, in the beginning and then everywhere. What this invariant says is that either the highest bidder is zero, which is at the beginning, or if the highest bidder is sum a, then it means that bits of this a of the highest bidder are equal to highest bit. Okay. We also want to make sure that the bits that the programmer uses the map keeps like it's in harmony with the highest bit that they also use.
00:23:09.424 - 00:23:11.464, Speaker C: Okay.
00:23:12.264 - 00:23:15.364, Speaker B: Invariance with, just like with every rule.
00:23:17.104 - 00:23:43.990, Speaker C: With every possible run of the, of the contract. So we will run all the rules and all the invariants with the contract, and we will see if it passes or not. Okay. Yes, yes. So the syntax of invariant is a bit like hidden. You don't have there the function call, as I showed you in the rule. But it happens.
00:23:43.990 - 00:24:24.774, Speaker C: Essentially, what you claim here on the two lines is just some kind of property. And if you run the invariant, you claim this property is preserved whenever you call anything at the beginning and later. So that's what this invariant says. Highest bidder. Bits of highest bidder is equal to highest bid, or it's zero at the beginning. I want to show you one more rule, and then we switch to the tool. So this is rule integrity of bit.
00:24:24.774 - 00:25:05.272, Speaker C: It's quite long, but essentially what it does is it's checks the bid function. And if you succeed to bid, this rule says that the bidder becomes the highest bidder and their balance, like the bits of them, should be updated accordingly. But it also says another example, like when before plus amount is less than the current highest bit. It didn't succeed. Let's go, let's go from the beginning. We have this filtered block here. We have method f.
00:25:05.272 - 00:25:30.064, Speaker C: We have environmental variable. We know what e is that collects, like the message sender and the timestamp. Good. We will use it to call the function with any arbitrary state, because e can be arbitrary. Also f can be arbitrary. Arbitrary function. But we will filter some out here.
00:25:30.064 - 00:26:05.372, Speaker C: That's what the filter does. It only accepts functions bit for and bit. Okay, so this rule doesn't take into account any function, only bitfor and bit. And what it does is that it takes any amount. Thanks. It takes any amount, any address for the bidder. It computes the current highest bid before the call.
00:26:05.372 - 00:26:42.072, Speaker C: It computes bid before, before the call. And then it also add one more require on the bit function. You require that the bidder is the message sender because. Yeah, let's, let's go further. Then you also assign success to the result of this call. So you call the bit function. You cannot see here that I'm calling bit or bit or bit four.
00:26:42.072 - 00:27:31.930, Speaker C: But the function, this is just a wrapper that we have up there. It's easiest things. So here we call the function with any arbitrary state of the program, amount and bidder. We know what bid after is. And then we claim this assertion that if the bidding was successful, then the bid after equals to amount plus bid before, and the bidder is the highest bidder right now. And we also claim that if bit before plus amount was less than current highest bid, then we didn't succeed. Actually, we could even claim like more.
00:27:31.930 - 00:28:21.704, Speaker C: We could claim if the bit before plus amount is less or equal than the current highest bid. We didn't succeed, but this rule is also fine. It's just a little bit weaker, but it will do its work. So we've shown three rules of many here. I've shown you the contract and now we want to see what it did, what we found with verification. So it took 1 minute and 50 seconds here, and I will zoom in a bit. And what happened is that everything got green except for these three, for which we claim that those rules are easily by tautology.
00:28:21.704 - 00:28:50.484, Speaker C: It's obvious that they are met. So this contract fulfills each and every of the rules. It doesn't have bugs. Well, at least these rules don't find it. And actually, yeah, it's bug less. But we made some modifications to the contract. We added some bugs for the purpose of this workshop.
00:28:50.484 - 00:29:18.832, Speaker C: And we will now go through verification of these bugged contracts and see what the tool can do. So let me first show you the code. The bugged code of this one here is a critical bug. We added unchecked block to do. Yes, scroll down. Thanks. We added uncheck block to withdraw function.
00:29:18.832 - 00:30:21.938, Speaker C: So the bits of the bidder is decreased by amount, but unchecked means that it can also underflow. So let's see if the suit of our rules can catch this problem. This is all green, but here we see some rules failing. And we have explained what mortal withdraw amount rule does. So let's have a look on the violation. This is the rule just to remind you what it was about. So it took recipient amount a bit before, then it executed the withdraw amount, and then it claimed that if the bit before was smaller than the amount, so the user was trying to get bigger amount that they had in the contract.
00:30:21.938 - 00:30:51.734, Speaker C: It reverted. It seems like this failed, so let's see why. Okay, we have the violation. Bit before is less than amount, but it didn't revert and corresponds. Yes, yes, yes. Thank you. So this is like a run of the of the contract which got violated.
00:30:51.734 - 00:31:29.954, Speaker C: So as this rule, the mortal withdrawal amount was violated. With this contract, we obtained the call trace. And it begins with global state setup, then bit before. That's like in the code we had bit before. That's it. Okay, so assignments to properties, and this is the call trace. A tree that shows up what happened.
00:31:29.954 - 00:32:22.464, Speaker C: Yeah, here we see the violation and it corresponds with what we seen in the code that was bugged, and that the bits of the bidder got increased below. So let's see, we see that bid before is zero. So the user didn't have any bit, bit any balance, but they were able to withdraw one amount. Amount is here and now that amount was withdrawn here. So here bid before was zero. We withdraw an amount which is one. And then it failed.
00:32:23.344 - 00:32:52.944, Speaker B: Very well done. Does it somehow check for the coverage?
00:32:53.484 - 00:33:01.424, Speaker C: Coverage? No, no, no, we don't have that metrics. But.
00:33:16.144 - 00:33:25.244, Speaker B: How would you differentiate the search work approach to the environment testing which we have in foundry framework.
00:33:30.824 - 00:33:37.724, Speaker C: We use such solvers. SMT solvers? Yes, yes, please.
00:33:51.964 - 00:34:25.820, Speaker D: So the question is, how is the Satora Puva differs from the. Using tools like foundry or so? First of all, we are planning to integrate with these kind of tools. There are multiple different. One is that in foundry you specify the correctness in solidity, which is nice. We specified the correctness in CVL. CVL is a very expressive language. For example, you can talk about quantifiers, you can talk about Ghost, you can tell things that you are not expressible in programming language because we are not implementing it.
00:34:25.820 - 00:34:48.190, Speaker D: We are telling you what's the property like these high level properties. So we have a very powerful specification language that you can. I think people are planning to integrate it into foundry. The other difference is the technology. The technology is very, very different, and what it gives you is very different. In foundry, you're starting your code from. Starting from initial state.
00:34:48.190 - 00:35:14.966, Speaker D: We are starting from an arbitrary state. This has downside and upside. It's like proving things in mathematics by induction. We start from a state, that arbitrary state that satisfies the environment, and then we see that arbitrary path. Yeah. So we are exhausted. That's why we usually, we are 100 times or thousand times slower and we are consuming all these Amazon machines, whatever.
00:35:14.966 - 00:35:36.594, Speaker D: It's much more expensive procedure, but we can show you certain bugs that we have found, for example, in the sushi or in the oven, which are beyond reach for. I mean, people usually find them with foundry, but after a human have found the error and then they replicate it, it's very different. This. You put it to the machine and then it gives this thing.
00:35:36.714 - 00:35:37.474, Speaker C: Okay, good.
00:35:37.594 - 00:36:25.714, Speaker E: Second question, which would be related, if you mind. I think you can still stay here because that will be also related to you. Sorry, sorry for grabbing the attention. And it is during the panel we discussed over here that there are more interesting bugs and mistakes, considering the systemic risk. So when we like chain the different protocols together, and then in the different protocol there becomes a change and it can influence whatever we are building on the other side. Currently, frameworks are foundry and hardhat. It's very hard to simulate these, not by the fact that we can roll in those already on chain protocols into the testing, this is solved.
00:36:25.714 - 00:36:53.084, Speaker E: But those systemic risks, it's very hard to make the tests for it. Right. We typically do like unit tests, or we could do fuzzy tests, or we could do the invariant tests. But regarding the systemic risks of the whole blockchain landscape, that's very hard to predict. Design and so on. So we do not have a tool in these frameworks for that. Does cetera somehow solves that for us? At least partially.
00:36:54.314 - 00:37:50.626, Speaker D: Yeah. So the answer is that it's partial in the sense that what we usually do, when you write the setup, you say which function is calling which function? And then we actually analyze all the interactions and we have a mechanism which we call summarization. If I'm calling your function and I don't know what it is, I can say that it has an arbitrary behavior. So you could actually prove something like, with respect to, we have, for example, verified the compound with respect to arbitrary call to uniswap. So we have specific cases that we have done it, but we only, what I said, we only analyze the code and the interaction. And there's a limitation. So, for example, if we made certain assumption about your function, how it's called, and then you are changing it, then in fact, we only verify the piece of code, and that's, our verification is not valid.
00:37:50.626 - 00:38:22.936, Speaker D: And usually when we do the setup, we make certain assumptions. We make certain assumptions. Say, when I'm calling your function, your function is monotonic. It means I don't know what it does, but at least every input, if you give us larger input, it gives you larger output. So, and this assumption, we can try to check it when the code of the coli of the function, which is called, is available. But what if it's not available? Or what if it's available and later it is changed? I don't know if I got you. So the answer is partially.
00:38:23.000 - 00:38:24.184, Speaker E: Yeah, partially, exactly.
00:38:24.264 - 00:38:25.004, Speaker C: Okay.
00:38:27.144 - 00:39:11.424, Speaker A: Maybe I can also add that you can basically define some interface that should be implemented by all the contracts that connect to your contract, and we can do the verification against this interface. And then whenever you connect with new contract, if it satisfies or implements correctly the interface, then you should get the guarantee. But it's, you know, when we, when we do the verification, if you don't know the future contracts, we cannot verify against those, right? Like precisely against those constructs. But if you find out that we only actually need, like this particular piece of interface to guarantee some properties and we don't care about like the other behavior of the contracted dual connect. This is okay, so this is what we often do. Like we somehow just abstract the connected contracts and work with this abstraction.
00:39:13.654 - 00:39:35.350, Speaker E: I can give a little bit more concrete example of this sort of system at risk. I don't know if you are guys aware of the liquidity protocol that's highly immutable. Stablecoin on chain. Well, not highly. It's immutable. It's governance free. So very sexy protocol, I would say.
00:39:35.350 - 00:40:20.674, Speaker E: But there are two dependencies. One dependency is on Chainlink and the other dependency is on teller. When it was built and actually released already audits everything, it was perfectly fine. And you could create a test to whatever would be happening towards the LUSD protocol and it was perfectly fine. What was omitted was the fact that actually teller in the future, at that time in the future, was changing something a little bit, I guess. And it actually happened at the moment that there was a fallback from the channeling towards the teller. And then they realized that it's not working.
00:40:20.674 - 00:41:02.984, Speaker E: And the consequence was that you cannot change the liquidity protocol because that was immutable and actually without any proxy. So it was literally immutable. So they had to do some changes on the tower side. But this is that part of the chaining the protocols and the systemic risk that something happens somewhere else and then influences your immutable protocol. That's why I'm giving you the example, like the really real life concrete example which we have here on blockchain, with all the data and with all the experiences, all of that. And I wonder whether Certera could help us in this sense in some way. It's just open for further discussion or whatever, you know.
00:41:05.764 - 00:41:22.904, Speaker A: Yeah, you need to keep the contracts in the loops. So you know, if contract you are using is changed, you need to reverify again, basically. But once you've write the rules, you can just run it again. It's not like that. You need to audit it completely again.
00:41:26.264 - 00:42:34.434, Speaker E: Sorry that we are having this discussion here, but I think it's very important because we are talking about a whole like defi security. Basically what I am aiming to is that typically when we work on the projects, we prepare even the tests in some isolated, in the scope, isolated manner, that we serve the protocol with those tests. And here we have the option, et cetera, that actually you have there already several protocols, not only one, right? Yes, you have many, many protocols. So isn't it a chance, and I forget now, this centralization or decentralization wouldn't be that the chance to actually trying to address this systemic risk, that once you have those protocols there and then you can see even the changes on chain, that something is being posted there as being changed, that you can foresee the potential risk, the systemic risk, the impact on the other protocols, and that you could even trigger some warning or notification. Look, there is something happening here in the DeFi and it could influence something else somewhere else in the DeFi.
00:42:46.234 - 00:42:47.814, Speaker B: Or is it two moments?
00:42:48.754 - 00:43:04.698, Speaker A: So two things. We would like to finish the tutorial. That's one thing. So I'll just briefly answer this and then I hope we will have discussions later. We are ready for these discussions. We want to have these discussions with you. So we just say that, yes, to me it makes sense.
00:43:04.698 - 00:43:36.812, Speaker A: So, for instance, if you do some verification and you rely on some other contract and you have these current assumptions, reasonable assumptions about that contract, and the verification is fine, perhaps you can contact the other company, the authors of the other contract, and say, hey, we had these assumptions, they were reasonable for us. Are they also reasonable for you? And if yes, then maybe the other company will try to comply with those assumptions in the future as well. But it's nothing that we can, as a security company to enforce. It's about the outers of the protocols if they make some danger changes in the future or not.
00:43:36.988 - 00:43:39.464, Speaker B: But you can be the facilitator of this discussion.
00:43:42.424 - 00:44:15.104, Speaker C: So we are proposing to develop a new tool that would keep track on all changes of blockchain and notify people if there is some change. But that's not really like we are doing formal verification and we are doing audits and you are proposing. Okay, Molis said that there are tools in the ecosystem for this. I don't know that tools.
00:44:16.324 - 00:44:37.970, Speaker A: So from one point, I don't want to close the discussion. On the other hand, I would like to finish this. Maybe we can get back to this later in the schedule today. I'm not sure what is the schedule, but maybe we'll have some time for discussion later. So, I mean, it's interesting. Taras, please continue.
00:44:38.082 - 00:45:10.046, Speaker C: Yes, so I have another mutation here. So we modified the code again, introduced the bug, and here is the output that the prover created. This time I would like to go first through the output and then look at the code. So what did happen here is that we got some violations. Let me choose. Highs, bid versus bits, because that's the rule that we were already talking about. So it failed here.
00:45:10.046 - 00:46:00.844, Speaker C: It failed on preserve and it failed on preserve with the withdrawal four and withdraw function, withdraw amount. Let's have a look what's broken. So, to remind you what this rule was about is this is invariant. And what it does, it checks that the highest bidder always means that the bits of him are the highest bid or the highest bidder is zero, which is the initial state. So this was broken. Let's see why. We see this address that it's highest bidder.
00:46:00.844 - 00:46:29.504, Speaker C: We see that the highest bid is one, but bits of the highest bidder is zero. And we know that withdraw function was called. We've seen it there. We see it here. So withdraw function was called. Interesting thing is who called it. We see that this address, two d eighty six, is the same one as here.
00:46:29.504 - 00:47:26.220, Speaker C: So we see that the highest bidder called withdraw function. And then what happened is that even though highest bid is one, the highest bidder has zero bits. So it does a lot of sense to us. Now we know where should we look for the bug? And we go to the withdraw function. And we see that if the highest bidder calls this or if it's called with bidder being the highest bidder, we do check that this doesn't happen because you don't want the highest bidder to withdraw their money. They would get the NFT and not pay for it. But somebody added this if here, if it's not ended.
00:47:26.220 - 00:48:05.746, Speaker C: So what happened was that after end of the auction, the highest bidder collected tokens. So that's the bug. And we also introduced different bugs. So right here we have this bug. So the highest bidder was set to bidder. Always when you bid, you want to set the highest bidder to the bidder. But here somebody wrote payer, which is a mistake.
00:48:05.746 - 00:48:46.434, Speaker C: Let's see if we see the bug from the verification. So here it took two minutes precisely. And we have rules that failed. And this time, this time I'd like to choose integrity of bet yet, because that's the one that we talked about. So integrity of bit failed for the function. Bit for, let's see, what was the rule saying? And the rule was saying that.
00:48:50.094 - 00:48:50.430, Speaker A: When.
00:48:50.462 - 00:49:54.232, Speaker C: You bit in the end, if the bidding was successful, then the bid gets updated. So bid after is bid before plus amount and the bidder gets updated like the highest bidder gets updated to bidder if it fails. We have this other assert that says that when actually bid before plus amount is less than the current highest bid, it won't succeed. And this was broken here. So in the cold race, you start with arbitrary state, you compute the current highest bit, which is one. Then the bid before of the bidder. Bidder is arbitrary in the rule is zero.
00:49:54.232 - 00:50:40.084, Speaker C: And then you call the bit function and the bit after is two. And you would assume that if it was successful, then this is fulfilled. But it seems it wasn't. So what happened here is that bid after was equal to bid before plus amount. But the bidder is not the highest bidder. And it resonates with the bug that we've seen. Because here we see that the highest bidder wasn't set to bidder, but a payer.
00:50:40.084 - 00:51:03.856, Speaker C: Okay, so that's another critical bug. And I have five more minutes for like. So. Yeah. I thank you for your attention. If you have any questions, please ask. Okay, no question.
00:51:03.856 - 00:51:04.184, Speaker C: Thank you.
