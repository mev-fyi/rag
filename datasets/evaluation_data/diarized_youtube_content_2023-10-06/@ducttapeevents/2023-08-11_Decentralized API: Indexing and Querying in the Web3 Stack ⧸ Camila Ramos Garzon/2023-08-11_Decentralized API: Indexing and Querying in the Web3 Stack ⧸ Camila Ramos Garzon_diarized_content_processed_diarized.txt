00:00:24.320 - 00:00:43.562, Speaker A: Cool. All right, thank you. Hi everybody, my name is Camila Ramos. I am a developer relations engineer at Edge and node. And today we're going to talk about how to build rich APIs on top of Ethereum and on top of any layer one. So a quick about me. So my name is Camila.
00:00:43.562 - 00:01:11.320, Speaker A: Like I said, I go by Kami. My background is in education. I have been teaching kids how to code before my professional engineering career for five or six years. And teaching and education is my passion. So it's kind of how I ended up here in Devrel after coming from a more traditional, just regular engineering role. So these images aren't rendering for some reason, but it's all right, we're just going to work with it. So I think I'm going to skip over this blockchain 101 thing.
00:01:11.320 - 00:02:00.430, Speaker A: After that dank sharding talk, I think we all are clear on the basics of blockchain. Sometimes I use these slides for more web two focus, so we're just going to power through these. I'll just read this off though. So I like to use this definition because for people who maybe aren't too familiar with blockchain, it's a way to take terms that they know and are already familiar with and kind of put them on top of what we as developers understand. So distributed public ledger and peer to peer network. And the part that I want to highlight here in a blockchain is that it's a peer to peer network in the sense that any participant in the network can directly send or receive data to and from any other peer in the network without an intermediary. So getting on the topic of building rich APIs and working with data, there's a bunch of reasons why me particularly, and I think all of us here are aligned with web3 and why we're here.
00:02:00.430 - 00:02:33.650, Speaker A: But the one I'm going to focus on today is this idea of data sovereignty and owning your own data. And because we're building on this public ledger and because we're building in this place where no one owns this data or everyone owns this data, depending on how you look at it, there's a whole bunch of data to work with. And when we're talking about a blockchain, just, I want someone to just call out, how many blocks do you think are in Ethereum as of today? Just a guess. Great. Perfect guess. Usually people don't get it right. They're like, oh, maybe like 15,000 or 20,000.
00:02:33.650 - 00:03:19.088, Speaker A: And again, some people are like super shocked to hear like, no, it's actually closer to 15 million at this point. And again, these are rendering kind of funky, but we're just going to work with it. So there's 14 million blocks and we all know, right, a bunch of transactions are batched together into blocks. So although there's 14 and a half, maybe 15 million blocks by now, there's much more data. So much data. And us as developers, we want to find a way to use this data and build applications with it. So this has a really cool animation of showing like all the different blocks and kind of illustrating that you as a developer, the data that you particularly might be interested in building with can live anywhere in the blockchain, right? And due to the nature and the structure of a blockchain, there's no built in way to identify, categorize and query for that data.
00:03:19.088 - 00:04:19.270, Speaker A: So you as a developer, there's a bunch of data to work with. You might know exactly what you're looking for, but as of now, there's no kind of native and built in way for you to actually find this data and query for it in a really efficient way. So that's where the graph comes in. So the graph is an indexing and query protocol used to efficiently read data from the blockchain and expose it with the graphql query API. And I want to highlight that the graph, kind of where it shines, is for efficiently grabbing data from the blockchain, for more sophisticated queries, and for more sophisticated questions that you want to ask about your data. Because as we all know, we can go see who the owner of a specific token is, or we can see maybe the most recent transaction in a wallet pretty easily. But when you want to ask more sophisticated questions, make these queries that are more complex and maybe include things like mapping and understanding relationships between data, doing the ability to have like full text search and doing things like filtering, that's not something that you can really easily do on your own.
00:04:19.270 - 00:05:02.094, Speaker A: So, quick overview about the graph. So the graph is chain agnostic, meaning that you can use it with any chain. You're not locked into one chain. There's support for Ethereum, we just announced support for Cosmos, there's support for near and support for a bunch of other l one s coming kind of in the roadmap. And the way it works is that it reads data from a blockchain. And if we kind of compare this to how this works in web two with like graphql, right? You may be reading data from some database somewhere, or maybe you're making a call to another API to get this data and how it works here is that we're reading data directly from the blockchain, and then you as a developer, you write resolvers or logic that actually transforms that data to kind of massage it and make it fit the schema that you defined. And we're going to talk about a little bit what that means in a second.
00:05:02.094 - 00:05:34.144, Speaker A: So, just a quick note on indexing. I always like to highlight this because I think people from different backgrounds in tech, maybe we have different understandings. So to get on the same page, when I say indexing, it refers to the process of turning unordered data into an order that will maximize the efficiency of a query made on that data. So an example that I like to give is that if I gave you a list of all the names in this room, and I asked you, hey, give me the count of the number of names that start with the letter c or something. One way that you could do it is you could check every name. Just check if it starts with a c. If yes, tally if no, keep going down the list.
00:05:34.144 - 00:06:16.448, Speaker A: But a way to maximize the efficiency of this process that you want to do, one thing you could do it would be to put it in alphabetical order. Start with the first c and with the last c. That way you wouldn't have to scan the full list, right? So that's exactly what the graph does. When I say we're an indexing and query protocol and kind of to highlight where the graph really shines, I kind of like to talk about what it would be like to build a web3 or blockchain API without the graph. So you can see some of the pain points that exist and how the graph solves this. So let's just say again, the picture on the right is like this NFT of this woman of a drawn lady. So let's say you wanted to build an API that allows people to search for an NFT PFP in a way that they can find one that looks like them.
00:06:16.448 - 00:07:10.840, Speaker A: So you might want to be able to pass in hair color, skin color, eye color, and whatever else that you want to do. But in this specific example, let's talk about those traits. So without the graph, there's a couple different ways that you can do it, and I'm going to briefly go over them. So one thing that you could do would be to take each unique token id that maps to one of these women, one of these ladies, one of these NFTs, read the metadata, manually aggregate this altogether, and then maybe on the client side, write a program to filter based on the stuff that the user passes. In another scenario would be that you could run your own server, you could index all of the transactions made to the blockchain, save it in a database, index this database for a reasonable query times, and then build a regular API on top of that to expose this data. Now, neither of these are great options. For one, if you are really trying to stay true to kind of the core tenets of decentralization, it doesn't really make sense to build your own indexer.
00:07:10.840 - 00:07:47.158, Speaker A: And outside of that, even if you don't care about that, anyone here who's tried to build an indexer knows it's not something you do in a day or a week or a month. It's a multi month thing, even with a whole engineering team. So it's just a really heavy lift. And as a developer, as a solo developer who just wants to build, none of these are really great options. And now querying with the graph, so as I said before, kind of where it shines is doing things like filtering, mapping relationships between entities, full text search. And the way that you do it is you as a developer, you write what's called a subgraph. So a subgraph is written in three parts, and we're going to talk about all of these parts in a second.
00:07:47.158 - 00:08:29.910, Speaker A: But the cool thing about these is once you make one and deploy them, they're available for anybody to use. So if one developer makes a subgraph or an API for this very specific use case, and then you want to build an application that could make use of this, you as a developer can access hundreds of these subgraphs that already exist, and hundreds of them already do exist. So you might see some familiar ones, like Livepeer has one up here, radical uniswap. And I like showing this image just to kind of also get on the same page of kind of where the subgraph sits in your stack. So at the very top we have your UI, you have your client application. Just under that you have your subgraph, which you can use to hydrate your UI. So to actually pull data from and display this, you can think of something maybe like a dashboard or really any application.
00:08:29.910 - 00:09:05.424, Speaker A: And then under that we have our smart contracts or the data from the blockchain. So now to develop a subgraph, we're actually going to talk about how you define the data that you need, and then we're going to actually go through the steps of how to do that. So in order to build an API, you build what's called a subgraph. And then you as a developer, you define the following, you define the data source. So by data source I mean the actual contract address or contract addresses of the data that you're interested in. So for this example that we're talking about, right, we're building an API for this NFT collection. I would pass in the contract address for this specific NFT collection that I want to build an API for.
00:09:05.424 - 00:09:59.054, Speaker A: Two, that you pass in is the data that you want to index. Again, in our use case, what do we want to know? I want to index the color of the skin, the color of the eyes, the color of the hair, the face expression. The third thing that you define are the events that you want to listen for. And now the events are a really critical role here because they're what make sure that you as the developer and that your end users always have the freshest data and that you don't have any steel data. So for example, as you're going to see in a second, we're not only going to get information about the NFT itself, like these traits and these properties and the metadata. We also want information about the user because we want to understand the relationship between the person who owns this and the actual NFT and the events make it such that if you own this NFT today, but then you sell it, how do you make sure that when you run your program tomorrow, you actually have the most updated version of that data and that you have the current owner, not the owner from yesterday? So that's what events do. That's what their role is.
00:09:59.054 - 00:10:31.630, Speaker A: And then finally are the resolvers. And these are the functions and the code that executes when these specific events that you defined are emitted. So for example, in our case, one event that we're going to listen for is the transfer event because this is the event that gets emitted when your collection gets minted and then every time it gets sold to a new user. Right. So we want to understand that when is it getting minted? When is it getting sold? Because I want to understand who owns this specific NFt so that I can go and buy it. So the really cool thing about the graph and kind of what drew me to it in the very beginning was that it's really simple to work with. You only work with three files.
00:10:31.630 - 00:10:51.190, Speaker A: And coming from a web, two background, a lot of this may seem familiar. So the first file is this manifest. So it's a yaml file where you just define. I know it's hard to see. Usually I would zoom in here. So I'll just kind of talk through it, but you define the start block. So this is an optional parameter that basically makes it so that you don't have to start indexing from the very first block from the Genesis block.
00:10:51.190 - 00:11:18.290, Speaker A: If you know for a fact your contract is in like block 14 million, it doesn't make sense to spend all that time indexing so you can define the start block. Again, it's optional. The second thing that you're going to define are your entity names, which we'll dive into on this next one. But this is basically your schema. What are the names of the entities that you're going to define in your schema? For our case, again, I know it's small, but it says lady and user because this is just developer defined. I could have called this banana, I could have called this woman. You can call this whatever you want.
00:11:18.290 - 00:11:35.406, Speaker A: And then finally you define the event names and the event handlers. Again. So the events are from the contract. So they're contract specific. In our case it would be the transfer event. And then the event handlers are developer written. So we say, you know, when this specific event gets omitted, I want you to call this function that I'm going to define.
00:11:35.406 - 00:12:22.406, Speaker A: Then the second one is this schema file, which again is just your basic graphql schema. And here we define what that lady and user entity is that we talked about in our last file, in the Yaml file. So here we're defining the owner, the name, the face expression, hairstyle, skin color, eye color, id, token id, a few other things. And then same thing for the user, we're defining that wallet address. And then one thing that you'll notice is different from regular graphql is this at entity directive. And this directive, so that derive from directive is what allows you as a developer to write code in such a way that you can understand relationships and draw relationships between two entities like we're doing in this case between lady and user. And then finally the last file that you're going to work with is your mappings file.
00:12:22.406 - 00:12:49.002, Speaker A: So these are written in assembly script and this is where you actually write those resolvers that are going to execute when those events are omitted. So for example, for us we say when the transfer event is emitted, I want you to run this specific function. Again. I would zoom in here, but basically I'll talk through it. So metadata is a big JSON object and for this specific collection it's a big JSON object. And then there's a few properties that are in that outer object. And then we have a key named attributes, which is an array of objects.
00:12:49.002 - 00:13:32.530, Speaker A: So we have this array of objects and each object is a different attribute. So if you guys can see, you'll see that kind of towards the middle of the page here. We're looping through something called attributes, and we're looping through this array of objects and we're saying if you match any of this properties that I defined in my schema, then go ahead and save that to my entity. So that's what we're doing. When we say lady hairstyle value, lady skin color equals value, we're looping through all this and say, all right, when you find something that I care about and it's something that I defined here, that's what I mean by care about, then go ahead and save that to my object. And this is where you're actually constructing that object that you're going to return to your client. Here's a better screenshot because I figured this would happen.
00:13:32.530 - 00:14:06.606, Speaker A: I'll put links to this at the end. I have a whole workshop where you can find this repo, so don't worry if you can't see. And so now that was really it. You work with three files, you deploy this, you give it your authorization code, and then it's out in the wild. And you can start querying this from your client application, you can start querying this from the playground and just kind of test it out and play around. And this next slide, start building. So I've been to a few of these conferences where a lot of people feel like they have to be this super amazing, crazy genius coder to start contributing to the ecosystem in some way.
00:14:06.606 - 00:14:30.594, Speaker A: But really there's a bunch of different ways that you can get involved and there's lots of opportunities, opportunities for you to contribute to the ecosystem with all of these grants. So, you know, they're all listed here. Take a picture. The graph has a bunch of grants. And the grants programs is actually how I got started in web3. And kind of how I ended up working full time at edge and ode for the graph was I participated in this grants program. I shared my gift and my talent, which is education.
00:14:30.594 - 00:15:31.724, Speaker A: And they're like, hey, you're really good at that. You should come work here. So we're in a really great space right now with like lots of opportunity where if you just contribute your gift, whatever it is that you're good at, you know, it's a meaningful way to participate right now. So another thing, and when we're talking about start building, starting in about 19 days. Women build web3, which is a Dao focus on developing female engineering talent, is hosting 30 days of web3, where you'll get to learn how to build your first or second or whatever fully decentralized application. And kind of what we're trying to solve here is that, again, there's a lot of people who are talented web two engineers, but when you come to web3, it's kind of hard to know, where do I start building this mental model and this architectural reference is kind of a new hard thing to do when you first enter this space because there's just so much going on, it changes so fast. So kind of what we're trying to do here is define a stack that we have found to be ideal and then just help you guys build out a reference so that when you're ready to build your own thing, you're like, okay, I know kind of all the pieces and how to string them together.
00:15:31.724 - 00:16:07.486, Speaker A: And then for the women and non binary people in here, part of what we do. And, yeah, I think you should be able to read that. So 30 days of web3 is just phase one of this larger program that we have. And for people who kind of complete this challenge and this program, they get invited to phase two, where you can request funding to work on anything you want. So it can be like an idea you've been sitting on. It can be a project that you've already started, and you can just say, hey, look, I kind of proved my diligence in this 30 days of web3 because it's not so much based on, like, can you code? Well, like. Cause we're actually gonna give you most of the code.
00:16:07.486 - 00:16:52.188, Speaker A: Again, this is really just to build a reference for yourself. You can join this accelerator, get funding, and for everyone who's maybe not in this place in their career where this makes sense for them, but you want to support. We're actually part of gitcoins round right now, where as of like a few hours ago, a $1 contribution gets matched at like $140. So I would encourage everyone to just check out, in general, all the gitcoin grants that are going on this round. But in particular, I would love for people to kind of contribute to this that we're doing. And then finally I have some resources I want to share here where. So this first link is like a blog where I go kind of more in depth of what the graph does and basically what I talked about here, but with a little bit more technical depth to it.
00:16:52.188 - 00:17:21.750, Speaker A: The second one is, oh, sorry, the first one is a workshop. So it's like a GitHub repo that has the code for what we just talked about. And then it also gives you a step by step guide for how to create that API we just did. And then obviously this is for a specific NFT, but you can just switch out the contract address and build this for anything you want. That second one is that blog post where it kind of goes more in technical depth about what we just talked about. And finally, that link is to get to 30 days of web3. If it sounds like something you want to do, that's where you can register and kind of just like, be in the know of what's going on.
00:17:21.750 - 00:17:29.364, Speaker A: And I'll be around for maybe an hour or two after this. So if you have any questions about the graphics or anything in general, you can just come find me. Thank you.
