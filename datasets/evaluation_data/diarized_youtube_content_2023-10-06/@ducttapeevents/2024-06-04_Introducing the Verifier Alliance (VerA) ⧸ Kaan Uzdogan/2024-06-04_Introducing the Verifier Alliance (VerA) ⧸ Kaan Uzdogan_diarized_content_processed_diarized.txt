00:00:00.320 - 00:00:53.688, Speaker A: Thank you. So hello everyone, my name is Khan and I'll be talking about the Verify alliance today and as well as some info about Sourceify, the project I'm working on. Sourceify, if you haven't heard about it, is a source code verification project. It started as a side project of the solidity team, the smart contract language solidity. And now we are on our own project inside the EF. So we are public good, funded by EF, let's say, and not a company and so on. Right now we are, yeah, we are decentralized and open source smart contract verification service.
00:00:53.688 - 00:01:35.854, Speaker A: We are three people, Manuel, Marco and I, working on it. And as I said, we are decentralized and open source smart contract verification service. This kind of assumes there is another, there is a counterparty to this, that there is centralization and close sourceness in the ecosystem. And it is because of. Yeah, it's not decent at all. It's because of this, I guess everyone in our ecosystem so far knows etherscan. And these days I've, I was, I'm talking to some people and talking about source finance, smart contract verification.
00:01:35.854 - 00:01:57.614, Speaker A: And a lot of people think etherscan is a public good and it is open source. No, it's not open source. It's not a public good. It's an insanely profitable business. Not that they don't provide any value. I think it just can bring incredible value to the ecosystem. And they, they are just basically the go to place to know what's going on on the chain.
00:01:57.614 - 00:02:48.474, Speaker A: But still, they are company and they own all the data. So our general thesis, like what we think is this does not align with the ethos of the ecosystem. Before we go into what sourceify does and what the verified alliance that I'm talking about exactly is, let's recap what's smart contract verification. So the problem the smart contract verification solves is that contracts on the chain lives as a bytecode. So when you go on chain, want to see what the code does? This is all you get. Like the binaries, the zeros and ones is all you get from a smart contract. And this is obviously not human readable.
00:02:48.474 - 00:03:40.274, Speaker A: By looking at this, you don't understand anything what your contract you are about to interact does, and you are basically going to give money to this code. So I guess you should know what it does, or at least someone that knows what's going on should be able to look at it. And I can say, for example, this contract is my source code. Like I can say, okay, the source code of this contract is this. But then how do you know, like how do you know this GitHub code? Like the code that I copy, pasted and sent you is actually the code behind everything. Because in reality it could be like stealing your money or doing some other stuff. At the end of today, what we want to see is the human readable solidity wiper or other human language, human natural language written code.
00:03:40.274 - 00:04:16.244, Speaker A: And this check mark that is green and verified. And this will make you happy. So how does it work? We first have the source code, contract source code in different files. Let's say we have these solidifiles here, my contract sol ownable ERC 20. In addition we have the compilation settings here. It might be difficult to see, but it's basically the compiler version. The optimizer settings and other options you give to compiler that will affect your compilation.
00:04:16.244 - 00:04:53.116, Speaker A: And then we feed this into the compiler, the solid compiler. And this gives us a bytecode. This gives us the bytecode from these written contracts. Then we have a contract that is on chain that we want to verify. So let's say we want to verify the contract at this address. And the on chain contract itself also has a bytecode. So on the left side we have the one we compiled ourselves from our smart contract verification service.
00:04:53.116 - 00:05:35.102, Speaker A: And on the right side this is taken from the on chain data like this. This what lives on chain. And we compare it like do these bytecodes match? And if it's a match, we say these files are the source code of this contract at this address. So of course it's simplified. But that's the main idea behind it. And how does sourceify solve this problem? What is our approach? As I said, the current status of smart contract verification is closed source and decentralized. So obviously the whole code of sourceify is open source.
00:05:35.102 - 00:06:17.774, Speaker A: And another thing that is possible is you can run your own source. For example, this is hash scan from the Hedera chain. It's one of the most popular block explorers of Hedera chain. And hash scan Hedera itself run their own sourceify. For example, instead of their writing everything from scratch, they basically fork sourceify and they're running sourceify themselves for smart contract verification. So it's open source, so you can both run your own sourceify and see what's going on and why it's not compiling, why it's not verifying. If there's a bug, we can fix it together, we can document it and it's publicly available.
00:06:17.774 - 00:07:10.830, Speaker A: Secondly, it's decentralized in the sense that it's served all the contracts we have are served on ipfs. And IPFs also brings us a nice feature that we do something differently. So besides the other verification services, sourcefy does something we call a full or a perfect match which is the bytecodes plus the metadata hash match. What is the metadata? What am I talking about here? So solidity compiler by default appends a special field at the end of the bytecode. So this part is the functioning bytecode and this one was added as a metadata at the end. Yeah, and this, this is a hash of metadata. So the part here, the black part is the functioning code.
00:07:10.830 - 00:07:47.208, Speaker A: So this is like what executes. And the later parts, the last part is the part that does not execute. This is just metadata. And this metadata contains something called solidity contract metadata. So it's an IPFS hash and if you resolve it you get a JSON file that contains basically two information. One, how do I interact with this contract information like Abi user Devdoc and how do I reproduce this contract compilation? So the compilation info and the source file info. The file looks like this.
00:07:47.208 - 00:08:21.826, Speaker A: So you have the compiler version, the language. Then in the output you have Abi user doc devdoc and below that you have the settings. So the compilation targets the compiler settings part. And below here you have the source file info. So you have the source names, the source. Sometimes the source code itself can be embedded but also we have the IPFS hashes of the sources. So the full verification then makes sure that what you see is 100% what was compiled.
00:08:21.826 - 00:09:12.324, Speaker A: So I'll go with an example how this works. So let's say we have these contracts, my contracts all, and I make a small difference in the contract. I add a comment, I change the variable name, anything that does not affect the functioning code. Now we have this mycontract div. Then the hash of this file will change, right? Because as I said, the source file also contains the ketcha cache of the contract, the source code and also like IPFS hashes. So the hash of the file will change. In turn the hash here will change inside the metadata file, right? And then in turn the whole metadata file has changed and the IPFs hash of this file will change.
00:09:12.324 - 00:09:46.878, Speaker A: So in this case the whole thing here will completely change. So we say ok, like this part does not match. So this contract code you are seeing is different than exactly what it is. If you want to play around more about how it works and what it does. Playground. If you can't see it, it's playground. Sourceify dev we have some example, contracts and we break down everything that I have shown here in more detail.
00:09:46.878 - 00:10:15.694, Speaker A: So if you want to see contracts and how all this metadata hashes and everything works, you can check it out there. Yeah. In short, Sourcefi now is supporting 152 evm chains. Don't ask me what these chains are, we just accept everyone if they want source code verification. Yeah, you can see which chains we support on our docs page. You can verify through our UI. We have an API and you can also import contracts from Etherscan.
00:10:15.694 - 00:11:07.452, Speaker A: We have hardhat support. So if you are using the official hardhat verify plugin, you can verify your source code by enabling sourceify. It's unfortunately disabled by default, but we are working on it, so you have to enable it if you want. For example, if you have a custom sourceify, you can give the custom sourcefy URL on your local or somewhere else and you can easily verify your contract by heartat verify network and the address. There's foundry support. So if you're using foundry you can pass the verifier sourceify flag. And again, if you have a custom URL on local, for example, you can pass this info and this will send your contract to verification to sourceify.
00:11:07.452 - 00:11:45.112, Speaker A: And we also have a remix plugin. But we are also now working on a new plugin, a unified verification plugin that will allow users to verify on all verifiers. Let's say you have a contract, you want to verify it behind the scenes. This will verify everything on Etherscan, on Bloxcard, on Sourceify. Because I believe the contract verification should not take place in one place only, and it should just in parallel go to everywhere generally. So we are working on a unified plugin for all verifiers, but we can't solve this by ourselves. This is quite a big problem.
00:11:45.112 - 00:12:32.024, Speaker A: We need ecosystem wide collaboration with this. That's why we at Sourceify and other projects started what we call the verifier alliance. So with Routescan, Sam helped us quite a lot as well. Block scout sourceify tenderly. Dora at the moment we have found this verifier alliance to tackle the problem of smart contract verification and the openness of the data. So in short, where firealliance is an ecosystem collective aiming for easy, unified and open access to source code of EVM smart contracts. Because as I've talked about the problems, currently it's closed source, the data is difficult to access and it's not standardized.
00:12:32.024 - 00:13:20.472, Speaker A: And what we want to do is actually a really simple thing we say like what if we took everything and put it in one place, that's the basic idea is quite simple. Of course there's a lot of coordination, effort behind everything. But yeah, we just want to put everything somewhere and make it really easy to access and open we have. So how it works is verifier. Alliance is not a verifier. It's like a unified, it's a place that your verification goes. So you have to go to a verifier, you go to sourceify, you go to block Scout, you go to Routescan and you verify your contract there.
00:13:20.472 - 00:14:01.392, Speaker A: And your contract will end up in this shared database. So everyone will collect what they have in one place. And yeah, this data will be filled by these data providers. And the database schema is also available at our GitHub. It's verify alliance database specs. In short, without going into too much detail, it looks like this, it's an SQL database which basically decouples the contract deployments from compilations. So a verified contract is basically an association between a deployment, a contract on chain, the compilation.
00:14:01.392 - 00:14:39.270, Speaker A: So we say this compilation matches this deployment. So yeah, as I said, we decouple the compilations from deployments. There is a runtime code code match and there's a creation code match. So runtime code is the code that is running on chain and the creation code is what's produced by the compiler. So we can verify on those both. And we normalize the bytecode and add transformations. Like what does this mean? The transformations are what we call are the edits on the bytecode before everything goes on change.
00:14:39.270 - 00:15:30.046, Speaker A: So like things such as libraries, immutable Cbox data, these are not the functioning byte code, but other things added to the bytecode. Let's give an example. For example, this is a creation bytecode transformation because how do I know this? Because there's a constructor transformation. And this means that constructor arguments has been inserted like appended at the end of the bytecode to the code. So that means there's a compiled code and then on this compiled code we replace the metadata and we added these code constructor arguments. At the end we have the code that we verify against. So this is also a runtime code transformation.
00:15:30.046 - 00:16:37.458, Speaker A: Here, for example, we have replaced a library address, a library contract that this contract uses, or the immutable variable, its value. So we say, for example, for this case, if this is the completion output of the runtime bytecode, you can see the green field is the library address placeholder. What color is this? Like the, the one in the middle is a immutable variable placeholder and this is the field I shown you on the meta, the metadata field. So the compiled output becomes this on the on chain contract. So if we apply these transformations, the compiled output will become this and we say okay, and this code will match the on chain code that, that enables us to have a base contract. And you can apply a bunch of transformations on top of the base contract and verify different addresses with the same contract. So if you, if you deploy the same contract on a different chain with different values, you can use the same contract.
00:16:37.458 - 00:17:19.484, Speaker A: Let's say we have a uniswap pull on different addresses so we can use the same base contract by applying different transformations everywhere. Yeah, yeah. And the normalize, of course I forgot to add this place. The normalization basically removes all these stuff. So it creates a base, base contract for applying the transformations on top. So yeah, the database right now has around 900 verified contracts and it's growing. It's not only a database, it's also a shared knowledge place where all the verifiers can collaborate and exchange information.
00:17:19.484 - 00:17:56.360, Speaker A: We want to have test cases, we have to have certain edge cases tested and document the information, the knowledge we generate basically. And it hopefully will be a place for tooling around the standard and the schema that we are creating. And on top of the data so many things can be done. This data is missing and both for data analysis purposes. You can do some security analysis when there's a vulnerability. Or for example, what you can do is you can do a bytecode similarity search. For example, if you have a contract on one address and it's not verified.
00:17:56.360 - 00:18:33.660, Speaker A: But by looking at this database you can say okay, like this contract is 98% similar to this contract. So it might actually be this one. So there's a lot of things that we can do on this data. Yeah, right now the database is growing. We really want to share this database publicly in parquet formats soon. Actually wanted to share it this week, but unfortunately we have spotted a mistake inside the database. So it's a bit delayed, but really soon and maybe even in the future we can add an API or application access for people to just pull data.
00:18:33.660 - 00:19:07.554, Speaker A: But for now it's just a database and it will be just a database dump because running an API, a public API, is a bit tricky. It requires much more, much more effort. So yeah, that's mostly it about verify alliance and sourceify. You can check out the website and from the website you can reach the GitHub and the Twitter. We also have a public chat, community chat if you want to reach us out. And yeah, this is also how we can reach sourceify. And yeah, that's it from my side, I'm happy to take questions.
00:19:14.734 - 00:19:16.154, Speaker B: Do we have any questions?
00:19:20.914 - 00:19:22.174, Speaker A: Any questions?
00:19:22.714 - 00:19:41.654, Speaker B: Well, actually I do have a question I would like to know because I can imagine there are cases where the verification can be super valuable. So is there any incentive for the validators or to create a pool of validators specifically dedicated to the verifying contracts? Validators, yeah, the verifiers, sorry.
00:19:42.354 - 00:19:49.406, Speaker A: So the verifiers are sourceify, block scout and another block explorer. And what is.
00:19:49.510 - 00:20:07.158, Speaker B: Yeah, so I guess I'm trying to ask like what was the, like how can we get more people to, to be interested in this, to maybe want to fork, you know what I mean? Other than just saying, hey, we need this. But like what would be the incentive for an ecosystem, maybe beyond just transparency?
00:20:07.286 - 00:21:06.714, Speaker A: I mean, I think the basic incentive, or let's say force should be the community voice. Basically the users, the community members should be pushing these tooling and other people that have verified contracts to contribute to this place. And we also know who really we want to push this for. I guess our big guy and etherscan also would be nice to have. But yeah, basically just the community members should be pushing this. And I don't, I mean, what I, this, this should be a natural thing to do because the core source code verification is the basis of every single thing that we take for granted on blockchain, like trustlessness, open source, all of these things are based on the assumption that the source code is available and verifiable. And I see it as a no brainer that everyone should be opening up and sharing this data.
00:21:06.864 - 00:21:08.194, Speaker B: Awesome, thank you.
00:21:10.654 - 00:21:28.594, Speaker C: Hi. So I wanted to ask about during, when you verify, do you trace the construction transaction entirely and also compare since the constructor doesn't end up on chain, do you verify that it's identical to the one in the source code and metadata?
00:21:29.334 - 00:22:32.952, Speaker A: Yeah, this is a good question. So at sourceify we try to trace the RPC for the creation transaction if it's available at the RPC level, like it's an archive node that we can look at the traces. But basically the problem here is the runtime code is on chain and it's fetchable from an RPC, but the creation code is not there. And I see this as a centralizing force in the ecosystem because you basically need to index the chain for the creation bytecode and that's quite difficult for doing for every single chain. So what we do, at least at sourceify, is we check the transaction that created the contract and try to get the transaction data like the payload of the transaction, if it matches the creation code. But then also if we look, if it's a factory contract, if the traces are available, and if not we just have to skip it and at least source defies. And maybe, I think block Scott does it, probably, probably etherscan does it as well.
00:22:32.952 - 00:22:37.284, Speaker A: But we personally as our project, we don't index everything.
00:22:37.864 - 00:23:15.384, Speaker C: Yeah, I guess you would have. Since it could be a factory, you would have to actually trace the transaction and see when the create or create two opcode is being called. You need to see what it is called because otherwise you could have a very similar but malicious constructor. Let's say it sets something, it backdoors through the storage and then returns the same code. And the compiler would give you the same. The compiler for the source code without the malicious version could give you the same metadata, like the correct metadata. So I think the only way is really to trace the opcode, the create opcode.
00:23:17.424 - 00:23:21.444, Speaker A: Let's discuss about this a bit more. Thank you.
00:23:21.824 - 00:23:28.720, Speaker B: Awesome. Benji, do we have a final question? Well, if not, thank you so much for joining us.
00:23:28.832 - 00:23:29.184, Speaker A: Thank you.
