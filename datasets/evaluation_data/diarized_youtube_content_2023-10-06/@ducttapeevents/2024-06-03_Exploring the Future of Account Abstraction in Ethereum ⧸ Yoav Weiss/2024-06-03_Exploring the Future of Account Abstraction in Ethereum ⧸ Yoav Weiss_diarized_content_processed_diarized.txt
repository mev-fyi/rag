00:00:13.960 - 00:01:18.314, Speaker A: All right. Hi everyone. So thanks for coming, for staying this late. And today I'm going to talk about the counter structure roadmap. So we're going to cover, we're going to start with how ELC 4037 got started, and then discuss where we are now and what we learned along the way, then talk a bit about the future, where we are headed next, with a focus on native account abstraction, although it partially overlaps with the previous talks. So I might skip ahead a bit and talk about what are we going to do with EOAS, and what are we going to do about layer one, which is a bit more a long term topic. So where did it get started? Back in 2021, more than three years ago, Vitalik had an interesting idea.
00:01:18.314 - 00:02:20.744, Speaker A: What if, instead of trying to build account obstruction into the protocol, while there are a lot of unknowns, maybe we can start without a protocol change and create a layer above it in order to start experimenting with account obstruction. This led to a few months of brainstorming, which resulted in the first version of ELC 4337. And the goal with 4337 has always been to have a full account abstraction, keep it fully decentralized, and not compromise on censorship resistance. So let's see, what does it mean? In order to have censorship resistance, we must have a decentralized mempool. We can't rely on anything permissioned, we can't rely on any, we can't rely on a centralized server because then someone may be censored. You can't have whitelists for implementations. Everything needs to be permissionless.
00:02:20.744 - 00:03:21.240, Speaker A: Now why is this a challenge? So to understand the challenge, we need to first understand what is full account abstraction. When we say full account abstraction, we mean that every aspect of the account is abstracted, not just execution, not just execution, but also things like validation. So the validation itself becomes EVM, execution becomes state dependent. And to compare this to EOA with an EOA, validation is really simple and very strictly. It has exactly one valid flow. Each transaction must be signed with an ECDSA key. The key is not revocable, so the transaction that is valid, a signature that is valid, is always going to remain valid, and then the nonce must be correct, and the account must have enough if to pay for the transaction.
00:03:21.240 - 00:04:46.240, Speaker A: That's it. It means that validation doesn't take a lot of computing power, and if a transaction is currently valid in the mempool, it's very likely going to remain valid when you try to include it in the block, unless it's being replaced by another transaction from the same EOA with account abstraction, it's a different story, because now since it's EVM execution, first of all you need to spend a lot more computing power in order to even validate the transaction while propagating it in the mempool. And then also it could, and also the transaction could become invalid after it was previously valid. And if this happens in large quantities, then we have a DOS vector, we have potential denial of service that could take the mempool down and make it unavailable. And since we don't want to introduce a centralization by starting to send certain addresses or something like this, we need to figure out a way to stop this at a protocol level. So the first thing we realized that we had to do is to separate validation and execution. We need to know that, we need to know up to a certain point the transaction is not valid yet, and then we need to enforce certain restrictions to make sure we don't spend too much computing power on it.
00:04:46.240 - 00:05:43.084, Speaker A: And after a certain point we say okay, now it's okay, now the transaction can keep going, we know it's going to pay, we know it's going to pay for the work. We separated validation and execution, but that's not enough, because since transaction can become invalid, we need to make sure it doesn't happen in large quantities. And I'll give a couple of examples of how this could happen, since the validation itself is EVM execution. Consider an account where the validation function checks the block number, and it requires the block number to be equal to the current block number. And now someone, so someone sends thousands of transactions from different accounts with this implementation to the mempool. They send them with the current block number. So now they all get evaluated.
00:05:43.084 - 00:06:34.144, Speaker A: When they propagate across the mempool, they are tested by every node. So every node spends some computing power checking it, and they are all valid. So they get propagated. But then by the time the next block is built, the block number has changed, and now all of these thousands of transactions are no longer valid. So what would the builder do? So now the block builder now tries to include the first transaction and say, oh shit, this transaction is actually not valid, it reverts in validation. So I'm going to drop it, I'm going to try the next one, and the same thing happens over and over. So the block builder actually misses the slot, will not be able to even build a block in time.
00:06:34.144 - 00:07:45.754, Speaker A: And the entire mempool did a lot of work propagating these transactions without ever getting paid. So another example would be using storage you could have. I mean, let's say we prevented the access to block number, we prevented access to certain opcodes, but then we have accounts that all look at the flag. In a singleton contract, they require this flag to be equal, zero, and then, so the transaction is only valid if this storage slot has zero. But then the execution part of in every transaction, it's going to increment this slot, which means that these transactions are actually mutually exclusive. When evaluated separately, they all seem valid, so they all get propagated, but as soon as one of them gets included, all of the others have to be retested and dropped. Which means that at the cost of a single transaction writing to a single slot, the attacker can cause any amount of work to all the nodes in the network.
00:07:45.754 - 00:08:59.384, Speaker A: So you see, we need to mitigate many such use cases. So when we started working on, started working on ERC 437, we spent a long time trying to come up with a rule set for what you can or cannot do during validation. During execution you can do whatever you want, but until you validated it and you agree to pay for the gas, you need to have certain restrictions to prevent such denial of service attacks. After spending a long time of this, we ended up with a protocol that was safe from denial of service, but it was also quite restrictive. Then we spent even more time trying to relax the rules, finding ways to enable more use cases while remaining dose resistant. We ended up with a rule base that actually enables quite a lot of use cases, some of which we didn't think that would be possible with the counter structure validation. And still, hopefully it's, and hopefully it's safe.
00:08:59.384 - 00:09:53.034, Speaker A: We have yet to see a reason to believe it's not, so I hope so. And these rules ended up in an ELC, the ELC 7562. This ERC contains the rules that are used for, that are used for ERC 4337 as well as well as Rip 7560. The reason we actually separated it to a different ELC for two reasons. One reason is that we needed to serve multiple implementations of account obstruction. The rules are actually similar, whether it's native account obstruction or ERC 4037. So it's the same rules.
00:09:53.034 - 00:10:52.134, Speaker A: And another reason is that the count obstruction, both ERC 437 and 7560 could actually be used without these rules, because these rules protect off chain entities, in this case the mempool nodes or bundlers, but they are not needed on chain. If somehow a transaction ends up on chain with an account that violates these rules, that's fine. It doesn't put the chain or anyone else at risk. The only risk was during propagation. So there are actually use cases, valid use cases where you want to use the account obstruction on chain part without these rules, for example, intent solvers. Intent solvers are typically a centralized server, and so they can mitigate denial of service in different ways using centralized methods. And they don't need these rules.
00:10:52.134 - 00:12:00.094, Speaker A: They also cannot really obey the rules because they need to do certain things in validation that would not be possible. So being a separate ELC makes it possible. So where are we now? So we launched ELC 4337 on mainnet of most all major EVM chains back in March 2023 East Denver. And since then it gained quite a bit of. So last time I checked we had like 5.3 million accounts deployed, 22 million user ops sent, and dozens of projects being built on it, ranging from different wallets with different focuses to pay master services to many other things, including some interesting privacy protocols. So it's quite exciting to see what people are building on it and.
00:12:00.094 - 00:12:50.782, Speaker A: All right, so, yeah, so over there. So we learned a few things observing all of these transactions. The most interesting thing for us was to see how much gas obstruction is used. We started with the assumption that gas obstruction is really important. We learned that it's even more so because almost all of the transactions, almost all of the user ops actually they specify Paymaster, which means that they use some form of gas obstruction. And this gas obstruction, it could be gas sponsorship, such as Dapp sponsoring the gas for its users. It could also be things like the user paying for the Gaz using an ELC 20 token, using a token paymaster.
00:12:50.782 - 00:13:40.402, Speaker A: So almost all of these user ops use that use some form of gas obstruction. And it validated the design choice we made early on to make paymasters a core component of this system. Recently we released version 0.7, which unfortunately was a breaking and an ABI breaking change because we needed to mitigate for a security, for potential security risk that the previous version didn't cover. Now, hopefully this is the last breaking change. So I hope soon we'll be able to move the ELC to final. And we also recently launched the Mempool, the peer to peer part of the mempool, the actual network.
00:13:40.402 - 00:14:18.530, Speaker A: We launched it on Testnet. It's being tested and after some more testing and fuzzing is going to launch on a mainnet across different chains. Another thing we learned is that there is demand for layer tools to do native account abstraction. We knew that at some point we would have to have an EAP or something to somehow get to native account obstruction. But we didn't think it will happen so early. And then we saw L2s. We saw some L2s implementing their own.
00:14:18.530 - 00:15:03.548, Speaker A: They took ERC 4037, modified it in some non standard ways and enshrined it into their protocol. And while this was exciting to watch, it also had a negative side effect. As it turns out, these networks, for example ZK sync or Starknet, that implemented modified version of 4337, they started getting really nice wallets with great UX such as Argent or Bravos. But these wallets only work on one or two chains, and that's not great for users. We don't want this kind of fragmentation. We want user. We want wallets to compete on better UX, on better security, not on whose supports with chains.
00:15:03.548 - 00:16:21.484, Speaker A: Users should be able to use the same wallet across every chain. So we realized that we need some sort of standardization here, and that we can't wait a few years before doing that. Then we also realize that this problem is not unique to account abstraction, since we strongly believe that the way to evolve EVM is through L2s. We want L2s to, to innovate and to make modifications to EVM. But we still need to standardize the way that it's being used because otherwise contract developers, wallet developers, developers generally have to start developing separately for each chain, and this will not be great for the ecosystem because most of them will target the most popular chain or two and ignore everything else. So we started working on rip roll up improvement proposal with the idea of standardizing certain things across the L2 ecosystem while letting them innovate freely within certain standards. And then we started working on Rip 7560, which Alex already talked about.
00:16:21.484 - 00:17:27.313, Speaker A: Our Rip 7560 is basically ERC 4337 in, in an enshrined way. And it started as very big and monolithic rip. Then we started making it more modular. We stripped it down to the bare minimum usable part which only separates validation execution, and then started moving everything else to separate rips which are optional and can be used by different chains as needed. We are working on a guest based implementation, and I know that other clients are also working on their own implementations. So we hope to launch the first Devnet soon, and then people will start to start experimenting with this model. And of course we would love to get the community's feedback on this from L2s, from layer ones, from the community in general.
00:17:27.313 - 00:18:42.166, Speaker A: So where do we go from here? So we have this minimal version of RIP 7560. Then we are working on different, we are working on different rips. Alex talks about them a bit, talked about them already, such as doing all the validations before doing any execution, which is actually not needed for a single sequencer. Chains that don't have a mempool because it mitigates an attack that they do not have to care about. But once you have a mempool, it becomes critical to have this for DOS mitigation. Other things are like 2d nonsense that are not absolutely needed, although they enable some interesting use cases, ranging from sending transactions in parallel when the order doesn't matter, to more complex things such as a privacy oriented multi tenant account where the nonce can actually be ZK nullifier. And we've seen some interesting use cases.
00:18:42.166 - 00:19:24.752, Speaker A: It's also needed in order to be fully compatible with ELC 4337 which has this feature. Yet another one is aggregation, signature aggregation, which means that we could end up with a block that we could end up with a block that only has one signature verifying the entire block. And this could save a lot of data costs for L2s. Another one is related to layer one. I'll get to that later. And there's so, and there are a few other areas of research we are working on. I think the most interesting one is inclusion lists.
00:19:24.752 - 00:20:14.394, Speaker A: So inclusion list is something that I think is very important in the Ethereum ecosystem. We have problem with censorship and it's not getting better. The way Ethereum is going to fix it is using inclusion list, which basically forces block builders to include certain transactions after they've been waiting in the mempool. Now doing it with EOA is difficult and therefore it hasn't happened yet. There are teams working on it. Doing it with account abstraction is a much bigger challenge because now transactions can become invalid in infinite ways, and if a transaction ends up in an inclusion list but then gets invalidated, then it's impossible to build the next block. So we need to be very careful about that.
00:20:14.394 - 00:20:56.884, Speaker A: So that's an area of research we've been working on. Now what about layer one? So there is value in enshrining counter structural on layer one as well, such as gas saving because layer one gas is quite expensive. And of course things like inclusion list can't be done if the protocol is not aware of count obstruction. So we need it. And in the future we also need things like quantum resistance. So the protocol needs to start moving away from ECDSA and a count abstraction is the way to get there. But we know it's going to take a lot longer.
00:20:56.884 - 00:22:02.324, Speaker A: Making any change to a layer one is a very lengthy process. So we are also okay with it taking a long time because of the way we designed the 7560. It is fully compatible with the account model of 4037. And therefore it's easy to write an account that is an account that is both a 4337 account and a 75 account, which means that users can deploy this account across different chains, whether they have native account obstruction or not, and on chains that don't. If later they get a native account abstraction, if later they decide to adopt it, the account just becomes more efficient but doesn't need to be redeployed. The address stays the same. So that's why it's okay if it takes, if it extra a long time now, why not? Why is layer one different? Why can't we just use 7560? There are some different trade offs.
00:22:02.324 - 00:22:34.634, Speaker A: One is solidity AbI. In ELC 4337 we had to enshrine certain. We had to enshrine certain ABI for the account we had to because it's an ELC. So you have a validate user op function that the account must implement. And on L2s, it's okay to also enshrine it at the protocol level, because L2s already enshrine abis for different reasons. They have, for example, precompiles within ABI. On layer ones, core devs are not okay with that and they want a different system.
00:22:34.634 - 00:23:54.822, Speaker A: So we have EAP 7701, which uses EOF instead. So on one hand it introduces an eof dependency, meaning that we have to wait longer until it can be included, on the other hand it uses a validation section, so it doesn't need to know anything about function names, about APIs, and for eoas. For eoas, there is also a lot of demand for doing some account obstruction, for doing some account obstruction features such as batching or gas obstruction. And while we know that it will never be a full substitute for account obstruction, because for example, you cannot rotate the keys, you cannot turn it into a multi sig or something like this, but you can have certain features, and EIP 7702 does just that. It's a way to make the account, the EOA behave like a 437 account for the duration of a transaction, which means that now it can use the count abstraction mempool. As is, it doesn't require any changes to entry point. And then for gas obstruction it can use paymasters, exactly the same paymaster without any modifications.
00:23:54.822 - 00:24:48.484, Speaker A: So just like account obstruction, just like smart contract accounts, now eoas will be able to use the same gas abstraction. We are talking about how to do future migration and why it would be needed, but I think we don't have time to cover that now. So in conclusion. So in conclusion, we've been working for the past three years on account of structure for Ethereum, both for layer one and L2, without compromising censorship, resistance. And we see this as the path to make Ethereum a future proof in multiple ways. We'd like to keep collaborating with both layer one, core devs, L2s, and with the rest of the community. So if you have any feedback, feel free to reach out to us here or on telegram or any other channel.
00:24:48.484 - 00:24:51.044, Speaker A: All right, thank you.
00:24:59.144 - 00:25:08.974, Speaker B: Thank you so much for amazing talk. Unfortunately, we are running a little bit behind schedule, so we'll have time for just one question, the most curious one. So is it?
00:25:12.794 - 00:25:47.520, Speaker C: Hi, thanks. Regarding the 7702, we all know that it was quite like, rushed, right. The proposal, the recent one. Was there any thought through regarding the blind signing aspect of that? Blind signing for the users, when they sign the transaction in metamask or anything like that, and actually they just see the hex codes so they do not understand the implications and what is going to be done. So just whether it was like thought through or discuss this kind of thing.
00:25:47.712 - 00:26:03.606, Speaker A: Yes, it was discussed quite a bit. And I can't. And I can say that I'm happy with the current. With the current design. I think that it would have been best if the signature was over the. Over the code and the address, rather than the address itself. Itself.
00:26:03.606 - 00:26:32.154, Speaker A: Because then at least you know what you're signing. Currently with. Currently signing an address, it is entirely possible that on different. Since it doesn't also cover chain id, it's entirely possible that you'll have different code on different chain, or maybe no code on some chain, then something else gets deployed. But the way the authors look at it is that you're supposed to. So it becomes part of the wallet. So the wallet should never sign something that it does not agree with.
00:26:32.154 - 00:26:43.694, Speaker A: The wallet developer is the one who deployed it across different chains. The wallet developer should also make sure that the code checks for chain id basically delegates all the trust to the wallet.
00:26:46.954 - 00:27:08.814, Speaker B: Thank you so much. So please, thanks to your advice. Okay, now we need two minutes just for switching the. Yeah, for the technical break. And I know that you are looking forward to seeing Mario Havel, so give us two minutes.
