00:00:01.400 - 00:00:44.834, Speaker A: Hello. So I will talk about this reentrancing Cancun hard fork the curious case of EIP 1153 so, transient storage chain security is a smart contract audits firm. We represent many of the main protocols on Ethereum. I'm a blockchain security engineer at chainsecurity. I have many years of experience in cybersecurity. I've been auditing curve, the VYPR compiler, conic yearn, and I found critical life bugs on multiple protocols. So I will give a quick recap about what Cancun does.
00:00:44.834 - 00:01:59.940, Speaker A: I will present an overview over execution context messaging, so how different execution contexts of the same contract talk to each other. I will present how transient storage works, and then I will talk about this new reentrancy vector which is introduced by transient storage. So the Cancun hard fork was activated on the 13 March 2024, exactly one month ago, and it contains a bunch of new eips that change the protocol for once. We've got the beacon block root in the EVM. That means we can access the consensus chain from the execution chain. We've got blobs, so this one and this one are for blobs. We've got memory, copy, opcode, we finally get rid of self destruct, and finally we have transient storage opcodes.
00:01:59.940 - 00:03:07.484, Speaker A: So I will talk quickly about how the data layout was before cancun. So within an instance of the Ethereum virtual machine, you had the stack, the memory which you can write to the code is immutable. You've got the account storage, which has the data storage of a contract program counter gas available. Not represented here, but also present are call data and return data. These are all the data locations that are present within a smart contract execution. So let's say we have two contracts, c and a and C a, which calls c again. So now we've got a first execution context, c one and a second execution context c two, all within the c contract.
00:03:07.484 - 00:04:17.964, Speaker A: How can we communicate information from this execution context to this execution context? So it's the same contract, but we cannot use memory because when you call a contract, even if it's already executing within the call stack, the memory will be new, it would be a new instance. So we cannot write data in memory to communicate between the two execution contexts. That would have been convenient, because memory is very cheap to access and to write to we can use cold data, maybe so c one can pass a message to a, which passes this message to c two. This can work if a is a trusted contract, so we know what it does and we trust it. But if a is controlled by the user, it can do whatever it wants and it can lie about the message it received from c one and back to c two. So call data can work, but not always. And finally, we can use storage.
00:04:17.964 - 00:05:09.524, Speaker A: So basically, c one writes to its own storage and c two reads from its own storage. And since they're the same contract, they share it and they can message this way. This is what happened until Cancun. But it's expensive so the cost of one S store is between 2900 gas and 20,000 gas, depending on whether the slot is warm or if it's been written to already. Most of this can actually be refunded if we reset the slot to its original value at the end of the execution. But the refunds are limited by the total amount of gas you are spending in one transaction. So a refund can only be up to 20% of the gas spent.
00:05:09.524 - 00:06:16.188, Speaker A: So this is why transient storage has been introduced. EIP 1153 introduces these two new opcodes, tload and testore and they behave, they claim to behave exactly like storage, except that they are reset at the end of a transaction. So now c one can t store and c two can t load and the value that's been stored in c one is retrieved in c two. And this happens within one transaction. At the end of the transaction the value that's been stored is deleted. It's reset back to zero and tload and t store cost both 100 gas so much less than s store. One example of how we can use these transient storage opcodes is to implement reengiency guards.
00:06:16.188 - 00:07:24.098, Speaker A: In this case, the execution context messaging would be that c one says to lock while calling out and c two reads the current state which is locked. So reentrancy guards are implemented like this in using traditional storage. So lock is a storage variable, it's initialized to not entered, which is one, and the non reentry modifier will simply check that lock is not entered and then it will set it to entered. It will execute the body of a function and then set it back to not entered. Now why we use one and two is specific of how s store costs. So if you write a positive value in a slot that's zero, that costs 20,000 gas. If you write a value in a slot that's non zero that costs 5000 gas because the slot is already initialized.
00:07:24.098 - 00:12:35.574, Speaker A: So that's why we use one and not zero for not entered. Anyway, this was the current state of re entrancy blocks and we've so how much does this cost? We've got one s load which is cold, it's taken from storage and it's not been accessed yet so this is 2100 gas then we've got a cold s store which costs 2900 gas and then we've got when we reset back the lock, we've got a warm s store which is 100 gas so in total we've got 5100 gas spent but we get 2800 gas in refund from the resetting of the lock so if we are using the full refund, it's only 2300 gas so this is the minimum cost of our reentrancy lock using trains and storage we don't have it in solidity yet, I think, but we can use it in assembly and so this is pretty much the same logic we check that it's non set, we check that it's zero, we set it to one, we execute the code and then we set it back to zero and now the cost is very easy to calculate it just 100 for the first load, 100 for the second t store and 100 for the third t store and this ends up being 300 gas plus the overhead of everything of course so this is like three cents of a dollar in today's price pretty much these would be like thirty cents of a dollar or something like that so it's quite an improvement. Now we know what transient storage does and how it works let's forget about reentrancy guard and talk about reentrances I've got a contract here which uses normal storage, not transient storage it's got a deposit function in which you can increase the balance of the message sender by sending some ether and then there's a withdraw function which transfer to the message sender its balance and then resets its balance to zero so can you spot the problem? Yeah, yeah, but it was a trick question actually there is no problem because transfer only transfer 2300 gas and this is not enough to recall withdraw again calling withdraw will cost 100 for the message call and then you will not be able to set the balance of the sender to zero again in the inner core because even if it costs only 100 because it's a warm storage slot, maybe when you've got less than 2300 gas in your execution context you cannot use s store and this is an addition to the EVM that was introduced with a Constantinople hard fork because initially a storage was always 5000 gas and so you could never write to storage in a send or transfer reentrancy so this was a safe operation with a Constantinople hard fork, the cost of storage was changed and it was lowered and it was, in the least case it was 900 gas, I think, which was kind of an oversight because now you could use send and transfer functions to re enter contracts. So this was detected actually by a colleague of mine back in 2019. The Constantinople hard fork was delayed one month because this bug was just detected a few days before the upgrade. So in low gas, when you have got low gas in your context, you cannot have a reentrancy. And this is to preserve the safety of transfer and send with old with this Constantinople upgrade.
00:12:35.574 - 00:13:28.564, Speaker A: So what changes with EIP 1153? Well, the difference is that now EIP 1153 so tstore and tload, this t store doesn't implement this safeguard. If you've got less than 2300 gas, you can still destore. So the send and transfer functions are now no longer safe. If you use them in a contract that uses transient storage, they're not inherently safe. They can still be safe. So I've got an example here which has a balance field, it's still a vault, it has a balance field and a temporary allowance. Temporary allowance is a transient mapping.
00:13:28.564 - 00:14:50.684, Speaker A: We can deposit by sending some ether to this contract and we can temporary approve, which means we make an approval which only lasts for this transaction. And this is highlighted as a use case of EIP 1153 because usually when you make an approval, you don't want it to last a long time, you're just, you just want to do some operations with it. So temporary approvals could be an application of transient storage and then we've got withdraw all temporary approval from and this uses the send function. And again it sets the temporary, it decreases the balance by the temporary allowance. So what can happen here is that I call withdrawaltendfrom which sends me my balance, I can do from whatever approval I have. And in this send function I reenter temporary approve, set it to zero, and then my balance is decreased by zero. But I've already sent the ether to myself so now we can use send for this reentrancy.
00:14:50.684 - 00:15:42.138, Speaker A: I've got a second example, it's a bit more complicated, but it reflects some code that was in Euler V one, which is actual code in production, which the code of Euler uses storage. It's safe. This one used transient storage. It's more efficient therefore, but it allows this reentrancy. So we're not, we can defend against re entrances. But now functions such as send and transfer have to be double checked. If you are using transient storage what happens here is that we've got a deferred liquidity check option.
00:15:42.138 - 00:16:49.694, Speaker A: This is a vault that can do operation. And if we enable the deferred liquidity check, our balance can become negative, which is sometimes useful if you want to do. We want to chain operations such that at the end of chain of operations we have a positive balance, but at some point the balance might become negative. This is a way to implement flash loans. And so just translating this code from s store to tstore, we have now the option in descend to reenter the withdraw function and send ourselves our balance twice. So in conclusion, transient storage implements data locations which have the lifespan of a single transaction. It's mostly equivalent in behavior to storage operations.
00:16:49.694 - 00:18:03.628, Speaker A: They both cost only 100 gas in every case. But differently than storage operations, t store will work during address transfer, even if the gas left is less than 2300. There's an additional caveat with transient storage, is that if we go back to the example of a reentrancy lock here, we might think since this is reset to zero anyway, at the end of a transaction, we might want to drop this additional t store at the end. Because anyway we are locking, we are executing our function, and then since the transaction is ending, this thing will be reset to zero anyway. So we can save 100 gas with this. This can be tempting, but it breaks composability of contracts. So if you want to execute multiple times a contract sequentially, not during a reentrancy, this will no longer be possible.
00:18:03.628 - 00:18:54.904, Speaker A: So it will break multicols, it will break batching operations, it will break account extractions such as EIP 4337. So this is a caveat of t store. You should always reset back to the intended value and not let the transaction expiration do it. And operations that we thought would be safe, such as send and transfer, or contracts that we thought to be safe because they only use send and transfer, might not be safe anymore if your contract that uses them uses transient storage. Thank you very much.
00:19:00.964 - 00:19:10.954, Speaker B: Thank you very much, Pietro, for this insightful presentation. We have about six minutes left, so let's open the floor for questions.
00:19:12.294 - 00:19:41.984, Speaker C: Hi. Yeah, thanks for the presentation. Really interesting. So just to recap, the smart contracts that have been previously not vulnerable to reentrancy now with Dankune are still not vulnerable, right? Unless. Unless it's like, unless that contract is taken and redeployed with additional functionality of accessing the transient storage. Am I understanding it correctly?
00:19:42.024 - 00:20:00.104, Speaker A: Yeah, exactly. So contracts that are currently deployed are safe because they don't use the transient storage option. Basically, new contracts which use transient storage have to be careful around transfer and send.
00:20:01.004 - 00:20:21.532, Speaker C: Okay, so like, if I have a code for the smart contract that has been deployed and in the past, I know it's been safe. If I go and add transient storage functionality, I should account for the reentrancy and go over the code to see if any of the functions are now, have been exposed to that vulnerability. Right?
00:20:21.588 - 00:20:28.204, Speaker A: Exactly. If you optimize your existing contract by using transient storage, you should reevaluate its security.
00:20:29.104 - 00:20:30.524, Speaker C: Okay, thank you.
00:20:32.584 - 00:20:34.284, Speaker B: Any other questions?
00:20:42.144 - 00:21:01.228, Speaker C: I guess I can ask another one. Yeah. So with Dankun, the transient storage, is there any, I mean, with the next update of, I believe, 64 blobs being added, whatever that's called. Dank sharding, right?
00:21:01.316 - 00:21:01.984, Speaker A: Yeah.
00:21:03.164 - 00:21:11.084, Speaker C: Do you think, do you see additional vulnerabilities as far as like, transient storage when it's expanded to that many blobs, or is it going to be just.
00:21:11.164 - 00:21:31.974, Speaker A: No, I don't think that touches the transient storage subject. The blobs and the blobs are really accessible from execution only through the block root blob hashes. And I mean, this is safe. It's not something that's touched. Yeah.
00:21:32.634 - 00:21:47.394, Speaker C: Oh, because in the consensus is that. Because in the consensus, the EVM execution cannot really access the blobs. That's why it shouldn't be an issue for the smart contract.
00:21:50.254 - 00:22:19.774, Speaker A: Well, you can kind of access it in the smart contract by getting a proof of what's in the blob, but it's not related to transient storage. And it's also. No, it's. Okay, so the main reason it's safe, it's read only, you will not write to it from the execution layer. So the problem here is you can write in transfer, send reentrancy.
00:22:21.194 - 00:22:21.974, Speaker C: Thanks.
00:22:25.754 - 00:22:27.734, Speaker B: Okay, one more question please.
00:22:31.354 - 00:22:46.894, Speaker D: Yes, I remember there was some discussion or some people that wanted to implement the resetting of the transient storage at the call level rather than at the transaction level.
00:22:46.934 - 00:22:47.874, Speaker A: So when you.
00:22:48.974 - 00:22:50.446, Speaker D: What do you think about that?
00:22:50.590 - 00:23:26.014, Speaker A: So at the coal level, it would have introduced a concept of a coal stack of contracts, which. So the transient storage would only pertain to the calls under my execution and not up from me. I thought it was probably a cleaner implementation, but probably it adds a lot to the execution nodes. And I think this is also valid.
00:23:30.154 - 00:23:32.242, Speaker B: All right, thank you very much.
00:23:32.418 - 00:23:32.954, Speaker A: Thanks a lot.
