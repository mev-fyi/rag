00:00:00.560 - 00:00:52.942, Speaker A: Hello everyone, thanks for joining this conversation. I'm very happy to walk you through my current contribution to the core ethereum from the stateless team and just walking you through the efficient like client for stateless verification and the WECL three era afterwards. So I've launched this PoC last year at Devconnect in Istanbul, November 2023. So the GitHub is often working if someone is interested interested to have look into the source code. So let's jump into the motivation of this work. So I wish that everyone in the room has heard that one of the biggest problem by Ethereum at the moment is like state bloat. We have seen so far the monoton increase of block size and witness size.
00:00:52.942 - 00:02:01.598, Speaker A: As you can see, for example, in the picture we have seen, we have hit actually three hundred k bytes of block size just in the few past months. And obviously we would face to the other problem of overhead of if MPT with a large number of input output operations, which requires to sync a block. So the big size of thickness is required. Obviously that must be transmitted over the network pair block. And as a conclusion, increasing the number of input output operations increases the block verification time as well. As you can see also in the right hand side, the increase of number of operations increases the blocking time, which reduces actually the efficiency of doing sort of block verification. At the moment there are a type of different clients, or at least the client types as we are familiar with, that they are full nodes, lite clients, and entering into the era we would have like stateless lite clients with cryptographic proofs.
00:02:01.598 - 00:03:07.530, Speaker A: Here is a general overview of the efficiency and security of those client types. So fullnode is the most secure type of clients in general with the least efficiency grade. They can download and process entire transactions and store the entire state and they demand a significant resource. And they are mostly the most impractical type of clients for mobile devices. There are other type of flight clients that are better in terms of efficiency, but maybe less secure than the full nodes. Lcs that we are all familiar with are sort of burdening the full nodes by incrementally requesting block state. For example, each client just calls the full nodes a piece by piece to gather data they want to verify and imagine that altogether calling a full node makes a lot of burden and also they could be more vulnerable to potential data manipulations or tampering during the verification progress.
00:03:07.530 - 00:04:00.254, Speaker A: And that's the motivation that we wanted to have new state like clients that have sort of cryptographic proofs with them. At the end. We have sort of stateless like clients which are coming more type of those clients after the era of vehicle tries. But this work at least is to show how that era would look like they are more efficient because they don't need any type of hash routes of the entire block headers. And of course they are more secure due to the extra cryptographic proofs they reducing the computational and IO requirements for transactions. They can validate transactions much efficient comparing to other types with minimal data transfer. They are ideal for low bandwidth environments like mobile phones for example.
00:04:00.254 - 00:04:45.054, Speaker A: And they can also ensure the integrity of fitness data, resisting tampering and ensuring the authentic transaction validations. So what's the goal? As people at EF constantly speaking about this, everyone's weak statelessness as like the most mature type of, you know, statelessness at the moment. And the state is not required to be fully validated nodes, when we do have such a thing, even like it too, validators would not need to have the full state. And it allows for proof protected. Like clients, they literally can validate single block as a fraud proof. And that's it. They don't need to do anything.
00:04:45.054 - 00:05:45.016, Speaker A: More means here block builders or validators still need this state. So it's not fully stateless in that content, but it means that actually dynamic state access isn't a problem anymore. So for more information on weak statelessness, I would encourage you to check Dank Rotfe's writing in this flip flow. And the goal of entire presentation today is to introduce you to a client that is able to verify the correctness of a block without any information, extra information expect for small type of proof that every state holding node can generate, and we call it as a witness. The witness contains the portion of state accessed by the block along with the proof of correctness. And that's like the general definition. So yeah, stateless, like client witness.
00:05:45.016 - 00:06:20.734, Speaker A: There is some numbers there. I just wanted to give some insights. The size of the witness. Actually, instead of a client just holding the state, the client holds the state root witness, the portion of state that are read and modified along with the proof. So just to have some idea about the numbers, total size, total state size, we can consider n typical. N is two power 230. And the k objects accessed by that block is typical, typically like two power to ten.
00:06:20.734 - 00:07:17.164, Speaker A: So the witness size we can calculate here easily is sort of number of 600 bytes. Access in practice becomes like 600 kilobyte block witness. So obviously it's like the chunks plus the objects themselves that, you know, are involved. So let's have a look on the gas estimation of these stateless blocks. So here is a general overview and calculations. So I just compared disk space and also the sort of the gas cost for both traditional witnesses produced so far at Ethereum and also when we just compress them even for border with zika snarks. So as you can see, like the cost of average gas, sorry, it reduces when you have compressing your witness with the snark.
00:07:17.164 - 00:08:16.314, Speaker A: And also the space that is required by snark proof of weakness is even less than the traditional witness. So we can save a lot of disk space at this room. Yeah, in terms of having even more gas friendly kind of like clients. There are a type of different snark proofs, but actually the SHA 256 is the most inefficient hash function for the case in this example. So because comparing to other type of hashing processes, the researchers can with the idea of using poisson t three hashing. So it has some good reasons to do so. One is efficiently hashes to elements ideal for binolumerical trees, which they are, and facilitates cryptographic proofs and data integrity verifications.
00:08:16.314 - 00:09:28.614, Speaker A: The gas cost, by the way, can also have sort of a trade off compared to vehicle tries. It's not like the best option, just replacing the vehicle throws. It is like the intermediary solution up to the point that we can have vertical tries, but at least it is still more efficient than what it is. So it requires updating hashes from the new leaf to the root. And also gas cost increases linearly with its free depth due to the hash updates. So again, it's not like the better option than vehicle tries, but at least to compare, initialization cost for this type of snark involves hashing and caching zero leaves for each level, and cost unfortunately grows linearly with the depth of the three. The key takeaway here is that Poisson t three s are more efficient in hashing and enable the scalable and secure incremental Merkel trees if you don't want to change completely the architecture of Ethereum as it is with predictable gas cost, scaling linearly with the three depths as a trade off here.
00:09:28.614 - 00:10:38.800, Speaker A: So this table just shows a little bit sort of overview of the costs of this type of snark. And just to give you some sense, how, you know, how much are the gas costs when you have sort of capacity to insert values into the binary incremental market. So yeah, we are moving towards stateless Ethereum, from traditional to stateless lite lines and to record tries. I just recently published sort of article on Ethereum research if you'd like to check it out. I just discussed it more in details and comes time to explain about EAPX, which is a proposal of mine under the supervision of Niambella, the lead of vehicle tri and Piper Medium, the lead of portal network. And we thought that this can at least be more production ready, rather vehicle choice. Meanwhile, so I said like there are diversity of like clients.
00:10:38.800 - 00:11:44.948, Speaker A: So in this case when you have sort of stateless like clients, you will end up having like more type of clients just running and syncing with the entire network faster. So instead of running minority clients, you will end up having multiple clients that are less expensive. We can run stateless peer to peer clients and ask validators to cross validate the Ziki proof with other clients statelessly, which is the goal of this architecture design. We can also have enhancing blockchain security and efficiency. The current progress is as follow. So you execute a bundle of transactions and compare the results with expected outcome in the block header. But in the proposed architecture you can have during the execution you can create a witness for the block and after the execution you add extra step which is a cross validation of the peer to peer and you can send the witness to various clients for sleeping verifications.
00:11:44.948 - 00:12:45.064, Speaker A: The benefit is that increasing the security by validating transaction across multiple clients and just because again, it's super simple and super fast to get synced within rest of the network. It increases the diversity and also ensures accuracy and integrity of the blockchain without heavy resources being used due to the cryptographic proof of CK. So this is the high level overview of the workflow. So we actually have implemented sort of architect as follows. So we have a chain event. So we subscribe to the bacon chain events and whenever the block has been generated, the nodes there are responsible to generate a witness alongside with the transaction. So we subscribe and also listen to the chain events whenever a new block produced and witness will be generated as well.
00:12:45.064 - 00:13:51.340, Speaker A: We generate the ZK proof of the witness for each block header basically, and through the sort of protocol communication protocol over Ethereum we just propagated at one call to all clients that participating. So the clients that already we made them stateless are based on treen. Trin is sort of like client ad portal at the moment and we can have a peer to peer communication between them to cross check the proof of the headers that every node just received recently. So this is a screenshot of our code currently. So generating the witness and Ziki proof for a random block, it is not the most efficient block that we generated neither in terms of generation time nor in decise. But at least it's like an example of proof of concept, how it works. And then this shows the propagation progress over Diskv five protocol.
00:13:51.340 - 00:14:55.404, Speaker A: So through this we are able to remove the burden from clients to just actually have sort of one call to receive all the necessary fitness data they want instead of like clients just calling full nodes. So yeah, with that I would jump into the conclusion about talking about applications and roadmap of this work. So that can be a diverse type of applications. Here you can have more enhanced security in staking operations. For example, validators could quickly verify the set of block without need to the entire blockchain history. It can be used for example for efficient restaking mechanisms in protocols like Eigen layer for example, which enables rest taking. The stateless like client could be very efficient by verifying the delegation of transactions and improving the integrity of the restake assets at a very short time.
00:14:55.404 - 00:15:46.060, Speaker A: And last but not least, we can have sort of new type of on the fly verifications for Dapps. That allows Dapps to operate more efficient by reducing the need for constant synchronization with the block state. And also we can enhance the user experience and scalability. So this is the timeline for our work so far. We have initially made a proof of concept and it just generates the ZK proof of the block header and propagates it across Trin. At the moment trin has like 50 peer to peer clients joining the network. But obviously the more clients just joining this protocol design the better for the ecosystem.
00:15:46.060 - 00:16:41.404, Speaker A: Of course we are going to next improving the pocket with ZK generation time and of course implementing new sub network layer in portal network for storing sort of ZK proof messages and introducing new RPC call method to facilitate that kind of peer to peer cross check. And last but not least, we can have sort of a surface like mobile app which everyone can be a verifier and just verify the state of Ethereum in a more diverse way. And we are also exploring the synergy with protocols like Eigenfire and other staking protocols just to use this type of clients. And I really appreciate our mentors of course and other people that made this event. And thank you so much for listening.
00:16:47.324 - 00:16:55.264, Speaker B: So go. Thank you very much for all the insights. I think we have time for one question from the audience anyone?
00:16:58.764 - 00:17:10.915, Speaker C: Isn't the witness generation also taking a lot of gas and also producing more time delay in block to propagate on the disk?
00:17:11.099 - 00:18:10.734, Speaker A: Obviously for the gas it makes it much efficient than it is at the moment. So generating a witness consumes not much gas as already we just have for each transaction to be involved in a block. But in terms of delay, it depends on which type of ZK, snark or other type of proofs you just use. As I mentioned, there is the one option, Poisson T three, which is the least delayed type of ZK proof generator. But obviously this is something that we can investigate in terms of ZK proofs, how we can just increase the time of proof generation, decrease the time of the proof generation and reduce the cost. Furthermore, but again, it's not the replacement of vehicle choice, it is just some intermediary step toward that. And comparing to the current solution is the best architecture we came up with.
00:18:10.734 - 00:18:30.010, Speaker A: The reason is of course is like the update of each leaf whenever the transactions just are changed from one state to another. So obviously this one would not be that efficient in terms of gas and everything else, just to to reproduce your Zk after each transaction state change.
00:18:30.202 - 00:18:34.682, Speaker C: One additional question on top of it, what is the witness size now?
00:18:34.858 - 00:18:50.934, Speaker A: The witness size at the moment, I guess is about 30k, sorry, 60 kb, which we produced here. But it's not obviously like the best option. It's a plc.
00:18:52.394 - 00:18:53.954, Speaker B: Amazing. Thank you again.
00:18:54.074 - 00:18:55.754, Speaker A: Sure, I appreciate you. Thank you.
