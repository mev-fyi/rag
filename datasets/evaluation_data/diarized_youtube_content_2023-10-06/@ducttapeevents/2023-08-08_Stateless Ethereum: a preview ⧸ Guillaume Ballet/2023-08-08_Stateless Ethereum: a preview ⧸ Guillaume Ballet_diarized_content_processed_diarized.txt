00:00:00.480 - 00:00:48.214, Speaker A: Hello? Yeah, in this talk, which is going to be a bit less technical than what I usually do, I just want to explain what stateless Ethereum is and more importantly, why you should care. So a couple months back, I finally decided to go with a home staking solution. I wanted to build, yeah, wanted to build my rig and everything. You know, I realized the upfront investment was already quite stiff. I mean, obviously there's the 32 ETH, but on top of that, you need a good machine. You need to pay for electricity, you need to pay for a good Internet connection. So there are obviously some other solutions.
00:00:48.214 - 00:01:12.484, Speaker A: You can do that cheaper. You can, for example, use the raspberry PI, which is what ethereum on arm guys are doing. They're awesome. Talk to them. But nonetheless, these methods are still, you know, they're not, they're not for the faint of heart. They're quite difficult to manage. So yeah, I went for the standard option.
00:01:12.484 - 00:02:41.304, Speaker A: And then what happened is that I found a lot of problems. I'm not gonna go through the whole laundry list of my first world problems, but there's one thing you need to realize when there's one thing you learn when you start doing this, is that you don't know how good your ISP really is before you start staking, and you don't know how good your electrical grid is before you start staking. And that's a lot of stress because you're always like, what if I miss a block? You go on holiday. Of course the validator crashes and you can't really reset it. So, yeah, as a summary, it's expensive, it's complicated, it requires a lot of babysitting, and as a result, ethereum centralization increases because why would you go through all the, you know, the heartache and the thousand natural shocks that staking is hair too, when you could just dump your, like, let Amazon handle the Internet connection, the power cuts and everything, or you could just take on Lido. And while not those, none of those problems are, you know, centralization per se, they're still relying on a reduced set of actors. And that makes them, that makes the whole ecosystem, like, ripe for, or at least makes capture of the entire ecosystem easier.
00:02:41.304 - 00:03:12.934, Speaker A: So let's revisit this. You effectively have a dilemma. Either you choose the pain and the rewards, I guess, of home staking, or you go for a centralized solution. But there's nothing really in the middle. How do we fix this? Well, there's no obvious fix. There's no simple fix, of course, but when it comes to at least we could solve a few problems that would make things a bit more manageable. And one of them is the state.
00:03:12.934 - 00:03:47.928, Speaker A: The size of the Ethereum state is growing and growing and growing, and that become up to a point that it becomes unmanageable. Stateless Ethereum is looking at solving this problem. Of course, I have to mention the existence of light clients. What is a light client? It's a node. You run a node, but it relies on a different. It relies on a full node to do all the checking to get the data. So it doesn't handle the data itself.
00:03:47.928 - 00:04:40.720, Speaker A: It just basically follows a node. So it puts a lot of trust into a different actor. Ergo, that's a risk of centralization. What stateless clients do, they basically try to find a sweet spot where you have a maximum trust as exactly the same level of trust as a stateful client. But the power consumption or the power you need to run a node is much, much lighter. So what is stateless Ethereum? It's basically what I said, it offers you the ability to the same level of trust, the same functionalities as the real, like the stateful Ethereum, but without storing all the data. And stateless Ethereum is composed of four major endeavors.
00:04:40.720 - 00:05:06.770, Speaker A: I will only talk about the first three, because Matt, aka lite client, will talk about the fourth in his presentation here at 03:40 p.m. So be there. The first endeavor I'm going to talk about is the one I work on. It's vertical trees. What are vertical trees? Is just a new tree structure. We change the. So all the data in Ethereum is stored in a tree.
00:05:06.770 - 00:05:53.194, Speaker A: We just change that structure, like the shape of the tree, if you will. And why do we do this? It's so that we can. When we need to prove things that are in the tree, we need less data to do so. It takes less space to prove that the data is in the tree. And what do we do with this proof? We simply prove enough data, and just enough data that we need for the execution of a block. And if we have all that data, and no more but no less, we have exactly where we need to run a block without storing the state locally. We download the block, we execute it, we validate it's correct, and we take whatever we need from it, and we throw away the data.
00:05:53.194 - 00:06:33.638, Speaker A: Yeah. So how do they work? Very, very short summary. This is the representation of a tree. Of course, the current ethereum tree and vertical trees will be much larger, much wider, much deeper. And if you want to prove, for example, so this is a very contrived example. But if, imagine that pink spot here represents your or account, like you want to send money to an account, let's say money to yourself, because that's a very, very contrived example. And all you need, really you just want to prove, okay, this is my account, this is how much data it's got.
00:06:33.638 - 00:07:11.562, Speaker A: So you're only interested in that tiny bit, that tiny pink bit of the entire tree. So what you do in the current method, you have to pass for each level you have. Oops, ok, that was too fast. Yes. Ok, you have to pass every sibling. So of course, once again, this is a very small example, but you have to pass sibling of which there are more than one on every level. So if you use the current model of the tree, each proof will be for a typical block, 1.5
00:07:11.562 - 00:07:41.486, Speaker A: megabytes. That's a lot with verkultrees, the proof system. Yep, still not okay. Okay. With vertical trees you only need to pass the data along the path. So this is a great approach because you can make like, it kickstarts a virtual cycle, you can afford to make the tree much wider. If it becomes much wider, it automatically becomes much more shallow.
00:07:41.486 - 00:08:23.554, Speaker A: So the path gets even smaller, even shorter. And the consequence is that you can take that data and pack it into the header field of a block. And when you do this you can, like whoever receives this block can take that data and reconstruct just the view that you need to execute the block. So in that very contrived example where there's only one account that is being accessed, for example, it's red. You just, this is, this is the view of the tree that you need and this is what you get from, from the proof. So why don't we use them already? The problem is the size of the state. It's, it's huge.
00:08:23.554 - 00:09:03.917, Speaker A: So we need to perform a conversion. And currently we're looking at a pro, an approach where we have a transition period with two trees, the old tree format and a new tree format. And every block we move maybe a couple thousand leaves from one tree to the next until all the data has been moved and then we can forget the old tree. So we have written. All right, so I wanted to say we estimate it might take, depending on how many leaves we, we transfer per block, it might take two weeks, it might take one month. If we relax even more, like if we transfer even less leaves, we can be a, can be six months. But we're trying to do something.
00:09:03.917 - 00:09:55.204, Speaker A: I mean it doesn't look like it's going to be that bad. So once you see this, we have a prototype that just performed the transition. And you see this message because each hard fork, each major hard fork has a spirit animal. We haven't really decided on one for vertical trees, but I just wanted to point out I'm on team elephant. Okay, so the second approach is the portal network. So if you think of the Ethereum network, you can sort of see, imagine all the computers being connected to the network in some kind of big giant circle. And as it turns out, everybody has, okay, it's kind of hard to see on the, on the screen, but everybody has the same copy of all the data.
00:09:55.204 - 00:10:32.930, Speaker A: This is a bit wasteful. So we could imagine that actually some computers have, some nodes only have, you know, part of the data. And if the node at the bottom wants to get some data that it doesn't have, it simply requests the, the data from a different machine and gets it. And it gets it, of course it gets the data with the proof, which is great. We just, I mean, we were talking about vertical trees. Vertical trees allow for smaller proofs, so that makes the scheme even more practical. And the last endeavor I will talk about is called state expiry.
00:10:32.930 - 00:11:17.842, Speaker A: And I would say on paper it's the simplest, you just forget the data. So you say whatever address was created or touched or accessed more than a year ago, you simply forget it. Of course it's not completely forgotten. The cryptographic primitives will still work, but to recover it, to resurrect it, you need to pass a proof. And if you pass a proof, did I mention that vertical proofs are smaller? You could resurrect just this bit of the state and proceed as if it was never to begin with. This sounds pretty simple. It comes with a lot of usability problems.
00:11:17.842 - 00:12:04.840, Speaker A: So currently that effort is dormant. We are not really worried about this because it can be addressed later. First of all, and even if we never get to this, I think vertical trees and portal network are probably enough to buy us a lot of time. So, okay, last part of the presentation, what is more like, let's imagine how stateless could make ethereum more decentralized. So this is the typical view that you see when you're staking. This is like your income stream. You have at the bottom what you earn every time you validate, because that's the way proof of stake work.
00:12:04.840 - 00:13:02.428, Speaker A: Everybody needs to validate that the blocks that are produced are correct. And to do so, to motivate people in doing so, you just, you receive a reward, a tiny reward, I mean, which is nothing compared to this huge reward, which corresponds to a block being produced. So the block being produced is like the block reward comes in two pieces. There's the consensus reward per se, and then there's all the fees that were, the green part is all the fees that were accumulated. So let's see how we can unpack this with the help of stateless. One thing we could do is create a first mode where we say, well, I don't care about the block reward, I'm happy just validating. So just this income, this is great because, okay, you don't get like the big fancy spike that makes your heart raise, sorry, your heartbeat raise, but you also don't lose sleep.
00:13:02.428 - 00:13:42.594, Speaker A: You're not going to miss building a block because you're not going to build a block. So you still need to come up with the 32 ETH, but you don't need to store the state because you will get the block with a proof package. You can run the block, verify it's correct, and then sign a test to the block and say, this is correct. So this way you can start using machines that are less powerful, like Raspberry PI's. Maybe not raspberry PI's, but arm machines. And you don't, yeah, you don't do, you don't need to store the state, you just do. Just do the simple thing.
00:13:42.594 - 00:14:30.622, Speaker A: You can take the opposite approach, which is to say, I'm not really interested in validating, I'm just here to produce the block. I mean, technically this is more or less what the mev searchers are doing already. They don't bring any stake. They just have machines that can do a lot of computing. So, you know, those will remain stateful for the time being. And it doesn't matter if they don't put the stake, because if you produce a block and your stake becomes, and you produce a block and it's invalid, you have an army of staker that has just increased because of the other strategy, this strategy. So your army of validators will definitely make sure that your block was correct.
00:14:30.622 - 00:15:07.616, Speaker A: Otherwise your block will be rejected. So you lose the big fancy, like the, sorry, excuse me, the spike. And also potentially, if we imagine putting some kind of stake still you would lose your stake. And then there's the third approach. So this time it's only execution income. So what happens if you are just serving data to the portal network? Well, presumably people will pay you so that you serve the state for them. So this strategy here does not even need to store the state.
00:15:07.616 - 00:15:46.464, Speaker A: Eventually all they need to do is prepare the block. And when they realize they need a piece of the state, they just send money to whoever is on the portal network willing to provide it to them. And then this is what the server on the portal network will see, just fee income coming from their serving. And you don't really need to store the entire state to get this kind of reward. So you can also once again run on very inexpensive machines, low power machines. Yeah, so that's the idea. So that was my last slide I have.
00:15:46.464 - 00:16:20.590, Speaker A: Yeah. So I hope at least I got you excited a bit about stateless Ethereum. If you want to try it, we have this testnet, so come and break it. And this is a bit of a long address, but this is where we give our updates. I need to come up with a smaller address, but sorry, QR code. Yeah, I should have put a QR code, but I will put, I mean, I'm sure East Prague will share the slides and if they don't, I will. There's no issue.
00:16:20.590 - 00:16:24.114, Speaker A: And yeah, that's pretty much it. If you have questions, I think we have time.
00:16:35.094 - 00:16:37.154, Speaker B: Any questions? Perfect.
00:16:40.054 - 00:17:04.112, Speaker C: Yeah, very nice talk for retrieving the data that you need in this stateless Ethereum. I presume you will use something like a DHT or something like that. Maybe, I don't know what is the structures that you plan to use, but I'm curious, how do you compare this with down sharding, in which blocks of data of the blocks are also distributed across nodes? Is it similar or not at all?
00:17:04.208 - 00:17:12.544, Speaker A: Okay, so I didn't quite hear the whole thing, but you're asking how does it play along with Deng sharding, right?
00:17:12.624 - 00:17:15.644, Speaker C: Yeah. If the structures are more or less similar or not.
00:17:16.344 - 00:17:47.223, Speaker A: So it uses, okay, it's similar in a software and is different in other ways. It uses the same, let's say, set of technologies like proving things. Although it's not exactly the same. Denk sharding uses something called KCG commitments. We use another proving technique called IPA. But yeah, it's not meant, I mean vertical trees and I would say vertical trees, stateless and deng sharding have been invented more or less by the same people. So clearly it's meant to play along.
00:17:47.223 - 00:18:18.654, Speaker A: It's not competing. If that's the question. You could eventually, assuming Den Sharding, the full scale den sharding happens, that would be like they would play nicely together because if you start a validator set could be shuffled between shards. And if you find yourself on one shard and then you realize you have to start validating on another one, you get shuffled on another one. What happens is that you need to sync, unless you have vertical proofs that you don't need to do a sync for. Basically.
00:18:20.754 - 00:18:23.774, Speaker B: Any other questions? No. Okay.
00:18:27.674 - 00:18:43.422, Speaker D: Hey, Guillaume. I was wondering, beyond just allowing ethereum clients to start becoming stateless, moving the stage. Try from the Merck Patricia tree to a vertical tree. Are there any other kind of applications or use cases you think that this will enable? That's not very. That's not really possible today.
00:18:43.578 - 00:19:34.714, Speaker A: Well, so one thing that would be that I can think of off the top of my head is just like reducing the disk space. Like, just because the vertical tree is more shallow, it will take less space on disk. At least that's the hope. Is there anything else? Well, yes, of course. There's the potential to move to ZK proofs because the MPT uses a hashing like technique, a hashing primitive that is extremely unfriendly to ZK proof. With vertical tree, we start, we went for primitives that can, that make it easier for people developing ZK system or ZK proof system to build circuits that are much cheaper. So that would be, I would say, the other major asset of vertical trees.
00:19:35.534 - 00:19:38.714, Speaker B: Time for one more question, intakers.
00:19:41.434 - 00:19:42.194, Speaker A: All right, thanks.
