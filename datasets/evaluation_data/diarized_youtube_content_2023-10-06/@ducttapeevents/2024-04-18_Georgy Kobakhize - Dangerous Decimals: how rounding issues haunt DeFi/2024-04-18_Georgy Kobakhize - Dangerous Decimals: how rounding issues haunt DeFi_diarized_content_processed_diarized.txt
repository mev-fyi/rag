00:00:00.160 - 00:00:52.778, Speaker A: Mike, thank you. Thank you. Thank you very much. Today we're going to talk about some of the smallest possible things in life. And that is literally the one way difference between being hacked and not being hacked. For some background and context, over the last year, actually I would say literally twelve months, there have been a lot of hacks that happened specifically due to rounding issues, either rounding up, rounding down, and just the general precision loss that leads to actual value loss in a lot of the DeFi protocols. And of course, because these systems need to be very precise because they have financial assets in them, any kind of precision loss can be devastating if it's not caught or not properly handled and so on.
00:00:52.778 - 00:01:31.264, Speaker A: And that's indeed what happened over the last year, year and a half, across quite a few protocols, many of them very, very new. In fact, many of them were just straight up forks of other common defi protocols such as compound V two. We're going to take a look at that. That's probably one of the more popular hacks of this kind. But very, very surprisingly, in some sense, in some sense maybe not. We also can find the rounding issues and precision issues with some of the biggest protocols of today and some of the most innovative ones. And we'll talk about that as well.
00:01:31.264 - 00:01:55.138, Speaker A: I guess I should say a little bit about myself. I was introduced, thank you very much, and pretty much they said everything. But yeah, I'm an auditor at consensus diligence. I've been auditing professionally for exactly two years as of March 30, which was like a week ago almost, actually. Was it exactly a week ago? Maybe. And yeah, it's been a journey. It's been a journey.
00:01:55.138 - 00:02:34.332, Speaker A: Security is definitely going at 100 miles/second right now in our industry, which is really, really cool, but also quite terrifying because things change all the time. So that was my attempt to kind of bring some light in towards more mysterious things, I would say. Because to me, this was a little bit unnerving how these things can happen. Anyway, let's go on. So the agenda for today, it's quite simple. We're going to introduce just what the hell precision loss even is and how it's usually handled. And that would be the floating point arithmetic in Ethereum, how floating points are handled there.
00:02:34.332 - 00:03:29.726, Speaker A: Then we're going to talk about just how important arithmetic precision is in Ethereum smart contracts. And with these two topics covered with the context from them, we're going to go into actually, and look into some of the infamous exploits, or at least the ones that I chose to demonstrate these issues and kind of what happened, how they happened, and what's the impact, and then we'll talk about the way forward, because, of course, you know, it's. Knowing about these hacks is only half the battle. Trying to deal with them is really what we want to do. We don't want to just keep on doing post mortems about them, because that's sad. So, floating point arithmetic in Ethereum. What is floating point arithmetic? Without going into too much technical detail, which I still will, in general, this is just some.
00:03:29.726 - 00:04:08.444, Speaker A: Floating point arithmetic is meant to help in computers to handle decimals. It's essentially irrational numbers, rational numbers, but everything that is not just an integer. So it's your PI, or your one, two, or 0.5 or 0.33. Repeating all this type of stuff is what's handled by floating point arithmetic in computers. As you look into it more technically, you'll see that it's. Floating point numbers in computers are separated into two parts, which are the mantissa and the exponent.
00:04:08.444 - 00:05:12.718, Speaker A: We'll take a look into what this actually looks like in a little bit. And as I mentioned, it's a very, very critical part of computation for a lot of mathematically heavy use cases where precision can be very, very important, which is, of course, the case with a lot of things like scientific data science and deFi, and financial instruments is definitely one of them as well. Surprisingly, this is not so simple. Floating point arithmetic is not something that is very straightforward, especially in our digital computers with binaries, zeros, and ones. And there are actually plenty of standards for how to handle that. One of them, and probably the most popularly used, is IEEE 754. We'll take a look into what this is, but even with the standard, we find that due to the differences in the literal operating system level, or sometimes even hardware level, the way that two different computers handle this, one same standard can be, well, different.
00:05:12.718 - 00:05:48.704, Speaker A: And this will be a very big problem for ethereum, and you'll see why in a second. Okay, so a little bit about the standard, just very little, just so that we have the context for it. We're not going to really look into it too much. This is the standard. It's fairly popular, it's fairly well used right now. It uses three basic components, kind of similar to what I described before, with the mantis and the exponent, except there is one more, and that's the sign. And the way that it looks is something like that.
00:05:48.704 - 00:06:18.200, Speaker A: I don't really know how we get to 0.15,625 from this, but somehow you do. It's just a representation, just so we know what we're talking about. Again, it's not, sadly, as important to us in Ethereum, because I'm going to tell you why in a sec. But this is what it kind of looks like, so. Yeah, cool, right? So there is a way to handle floating point arithmetic in computers. There is a way how we can handle decimals, fractions and all that type of stuff.
00:06:18.200 - 00:07:29.964, Speaker A: That's awesome, right? What are the downsides? Well, the downsides is that for us, in our industry, it sucks because the EVM does not support it. It's a very intentional decision. There are a couple of reasons for that. One is that it's just not simple or straightforward. At the time of creating Ethereum, EVM, the yellow paper, all that stuff, as long ago as it was at this point, this was definitely not something that was considered very much just because of its complexity, but also because as people started to look into it, it turns out that because of what I told you earlier, how different machines actually process floating point arithmetic differently, these things, these processes can actually end up with very different computations across different nodes in the ethereum network, which would literally lead to forks. So even if the difference could be something like 1,000,000th of. Of an item or of an integer, that if there is that difference, if there is some rounding difference between two nodes in Ethereum, that could lead to a fork into a split of a network.
00:07:29.964 - 00:08:26.204, Speaker A: And of course, it's a liveness problem. That's just all sorts of horrible for a distributed system, especially a consensus distributed system such as Ethereum. So there was a very deliberate, explicit choice not to include float point arithmetic into Ethereum and the EVM, something that haunts us to this day. But again, on the other hand, it's very possible that it's not something that's actually feasible to implement, though I hope it is. But we'll see about that. So, yeah, there is no floating point mat in EVM, but we must work around it, because we all know that you can buy of a bitcoin or a wrap BTC on Ethereum. You can buy one times ten to the negative 18th of Ethereum, which is one way, which is, of course, not a full ether.
00:08:26.204 - 00:09:09.744, Speaker A: So there are decimals, right? There are also interest rates in Ethereum. There are exchange rates in Ethereum. So what are we talking about here? There's definitely decimals. So how do we actually handle this arithmetic precision in Ethereum smart contracts? Because clearly it's very, very, very important, and we handle it by doing fixed point arithmetic. So it's just a very, very simple way to go around floating point. And that is, we just define how many decimals an integer has, and then we just handle the last couple of decimals of a number as well as those decimals. It's quite a, quite a simple way to go through these things.
00:09:09.744 - 00:09:51.544, Speaker A: There are a lot of things that need to be handled, like scaling between two different integers, or un's, I guess, with decimals, but we'll see how that's all handled. But this is basically how it's done right now. The two pretty common examples of this usage are, well, token balances. I just mentioned that, of course there are the decimals for each ERC 20 token. It's part of the standard and the interest rates. And we'll kind of very, very quickly look at the two of them just very quickly to go over what I talked about. What is fixed point arithmetic? It's just a way to represent fractional numbers and decimals by literally storing how many decimals there are.
00:09:51.544 - 00:10:07.840, Speaker A: So kind of like, that's the fixed point. You fixate how many decimals there are in the number. So if you have decimals equals two, then 100 zero two becomes ten. 0.02 right there. O two is the two decimals. So it's very simple, it's quite deterministic.
00:10:07.840 - 00:10:47.248, Speaker A: There is no way you can mess that up between nodes. But of course, you know, if you have fixed point and you have fixed decimals, that means you have only so much precision there. And that's not great. And at the same time, because you literally fixated, you have a predefined scale for each specific value or number, which can also be an issue when you need to compare two different numbers with two entirely differently defined fixed decimals. So you have a scaling problem between them as well. All very much manageable problems, but problems nonetheless. And it creates more surface for error.
00:10:47.248 - 00:11:10.096, Speaker A: And you will see that this surface for error might be responsible for some of the hacks. This is how it looks like in binary. So it's pretty simple. It's quite self explanatory. Yeah. So some examples of the fixed point arithmetic in Ethereum, the token standard, of course, the ERC 20 that we all use and love. Decimals have to be explicitly defined.
00:11:10.096 - 00:12:07.884, Speaker A: I think it's explicit that it has to be there. No, it's optional, but pretty much everybody uses it. So very, very commonly, we have a decimals field on an ERC 20 contract, which is a token contract, which kind of explains to frontends how to actually display a big number of, a big amount of tokens of token balance for a user. So two big ones that I like to point out. I should probably also point out USDC here, but these are quite popular tokens. The DAI and Wrap BTC wrapped BTC actually has only eight decimals in it, which for some DeFi protocols can be an issue in some cases if they don't handle it right, specifically for multiplication and whatnot. Between two differently scaled balances, that could literally be an issue.
00:12:07.884 - 00:12:56.620, Speaker A: Whereas DAi, for example, a stable coin, decentralized stablecoin, one of the most popular ones, has 18 decimals. This is very, very standard, in fact, in the ERC 20 world. But just as an example, I didn't really put it here, but maybe I should have another very popular stablecoin on Ethereum and just across our industry is USDC, and that has only six decimal points. So kind of interesting how even between some of the more popular tokens that are used within our industry, we don't have standard amount of decimals, though I would argue 18 is kind of that. But the other two big ones don't do it like that. And that means that we have to handle scaling differently. And by we, I mean DeFi developers.
00:12:56.620 - 00:13:43.782, Speaker A: And that does lead to all sorts of gotchas that you have to take care of. Another big one in the DeFi applications is interest rates. Those almost by definition have to be less than one because they kind of define, you know, how much of an interest you get on an asset or how much of a, what's the borrow rate to lend out an asset? You can't. I mean, you could in some cases lend out 100% of it per block, but it's unlikely to happen like that. So simply put, this is something that requires decimal precision. A very popular one that uses, that is compound. I mean, pretty much any lending application on ethereum or smart contracts does have borrow rates, but compound is pretty popular.
00:13:43.782 - 00:14:19.562, Speaker A: It's got pretty good documentation. And this is where I stole this line from. But yeah, that's a very good example. A borrow rate at compound is a decimal type of a number that's scaled up by one e 18. So if you look at the raw code and what the EVM returns to you, you're going to actually get a giant number. You're going to get a number with 18 zeros followed by it, but it actually represents something less than one. So for example here, this was a couple of days ago when I updated these slides.
00:14:19.562 - 00:15:12.134, Speaker A: So maybe what, Monday, Tuesday on Monday or Tuesday, the borrow rate for compound USDT was 0.0051% per block, which is however represented by this giant number in the actual code or from the EVM from the state when you try to read it from the method. This is of course a much bigger number than 0051. But again, we have to remember that this is scaled by 18 and this is how you're supposed to treat it, this is how you're supposed to make sense of it. And scaling by 18 at least gives us a lot of precision to try and understand some of the impact on the borrowing we would have if we were to take it. Long story short, decimals are quite critical in defi. You can't really make complex financial instruments without decimals.
00:15:12.134 - 00:15:57.426, Speaker A: We do have workarounds such as fixed point arithmetic. It's pretty much the workaround that is used now, but there are actually some libraries that allow for some quasi floating point arithmetic as well. But pretty much fixed point arithmetic is the biggest workaround that's used for decimals in Defi. But yet the problem remains. And that problem is that we still get quite weird once we get to very, very small results. Basically on the edges. Once you get to the edge cases, you end up getting kind of unexpected results, I would say this can be a very big problem for exchange rates.
00:15:57.426 - 00:16:35.824, Speaker A: So in those same lending applications I was mentioning about, like compound, this can be a pretty big problem, and we'll actually see this problem. But this can be a problem with also unexpected places such as boundary calculations, which is something that's quite important in decentralized exchanges. I will see that as well. And that was probably one of the more complex hacks. If not, some people say the most complex hack in the last couple of years. But long story short, on the boundaries, things get weird and you can't get away from that. So you have to round things one way or another.
00:16:35.824 - 00:17:18.848, Speaker A: Here's just a very, very quick example. Just so we're all on the same page, what is the problem that I'm talking about? Let's say we have these numbers, and these are not like with tons of decimals. This is literally what you see is what you get. You have number ten, number six, very, very, very small numbers, and if we try to perform division between them, we'll get, I mean intuitive results if you think about them as integers, but non intuitive if you're trying to maintain accuracy. So if we divide a by b, which is ten by six, we're going to get one, and if we divide b by a, we're going to get zero. Now, ten by six is definitely not one. There's a lot more to it.
00:17:18.848 - 00:17:53.460, Speaker A: And six by ten is also definitely not zero. If we were to look at these as conversions in the first case, I mean, in both cases, there is a lot of value lost, like a lot of it. In some cases, like almost 50% plus of the value lost. And if these types of computations happen in our defi applications, we'll be in a lot of trouble. And I mean, I'm hinting on it, but that's literally what happened. It's just the thing is, getting down to these numbers can be tricky, but hackers are quite, quite tricky as well. Yeah.
00:17:53.460 - 00:18:26.050, Speaker A: So it's just a natch case, right? Well, sadly it's not. And there are a lot of infamous exploits and vulnerabilities. Thankfully, there are a lot. Also white hats out there who disclose responsibly vulnerabilities. And when that happens, they get a nice bounty and users get their assets back. So it's not so bad, but it doesn't happen always. So the exploits we're going to be talking about today, time permitting, and my ability to explain them permitting, are the following ones.
00:18:26.050 - 00:19:13.024, Speaker A: I thought these kind of explained and showcased these issues quite, quite well. So the first one is going to be onyx 100 finance, and just in general, other compound v two forks. So this is what I was mentioning earlier. Despite being just a very robust application of defi compound v two, there are some edge cases there that people need to be aware of. Now, compound V two actually didn't get affected by these vulnerabilities, not that I know of. I might be embarrassing myself out here saying something wrong, but at the very least, it's definitely being handled correctly nowadays. But people who fork compound V two, which is of course heavily encouraged in our industry now, we like to open source, we like people to fork and improve things.
00:19:13.024 - 00:19:41.776, Speaker A: If the people who fork aren't quite aware of all the ins and outs, which was what happened. Sadly, with Onyx 100 finance, you might be in a lot of trouble, and we'll see what that trouble is. Then we'll take a look at raft, which is the lending protocol with a stablecoin. It's quite an interesting one as well. The hack there was quite, I guess innovative might be the word. I don't want to give credit to the hacker and wise is also going to be quite interesting. That one is going to be the saddest.
00:19:41.776 - 00:20:24.590, Speaker A: You'll see why. Then we'll talk about a lot more galaxy brain level stuff, which is decentralized exchange hacks, which is what happened with Kyber swap and balancer. The Kyiv swap hack is the one I was mentioning earlier, which might be one of the most complex hacks of the last, frankly, maybe many years, if not ever, you will see why, as much as I would be able to explain it. And then Balancer only sort of got hacked. It didn't really get hacked, but there was a chance it could. And then a white hat came in and helped out balancer and received a very, very good reward for it. But then at the same time as it happened, they did get hit by an actual hacker as well.
00:20:24.590 - 00:21:10.374, Speaker A: But not by much, thankfully. But still, I wanted to point it out, because balancer is a behemoth in our industry as well, and they're not immune to these things like nobody is. So I wanted to definitely talk about that as well. It's also an interesting hack, again, as much as I can explain it. So yeah, with that in mind and with the context I gave you, let's get into it and let's see what we can understand about these hacks. So lending protocols, that's what we're going to start with for again, just some context. So we're on the same page.
00:21:10.374 - 00:21:56.088, Speaker A: What the heck are these lending protocols? What do they do? What are they for? So essentially, these are complex financial applications that do a lot of stuff. They're used often nowadays for traders to like long or short assets by borrowing them or lending them out. I mean, that's one way. Or just in general, it allows people to lend and borrow digital assets. The thing that we're going to be focusing on specifically is the process of actually depositing items and getting shares back, like kind of like your IOU use for those items. Right? This is something that's called shares in Defi commonly. And then assets is of course where you deposit your collateral.
00:21:56.088 - 00:22:34.468, Speaker A: Sometimes it's called your deposit is what sometimes it's called. But basically the process we're going to be taking a look at is a user providing some assets like ETH to a contract. How much do they give? They figure out through an exchange rate function. And then the lending market gives back shares of that ether. That isn't actually that asset, but it represents this asset within this defi application. So for compound, for example, that would be c ETH. For compound ETH, depending on the lending application, the shares that you get back can do all sorts of things.
00:22:34.468 - 00:23:33.196, Speaker A: It could be something like a rebase currency, which automatically increases its balance as some things happen. It might not be, but its value might increase passively on this exchange or on this lending platform. So there are lots of cool things that can be done with these shares that represent the assets, but that's not something that we're going to focus on much today because it's too much. But we are going to look at how this exchange happens. How do we figure out how much we get for how much ether, or how much ether we get for redeeming a certain amount of shares? Again, we'll start with Onx and 100 finance, really primarily onnx, but these are two of exactly the same vulnerability. So both of these protocols, and actually a couple more, I didn't mention them here, but a couple, couple more also that have gone through the same type of vulnerability. These are all forks of compound VTU.
00:23:33.196 - 00:24:19.054, Speaker A: So that lending platform was talking to you about earlier. What we're gonna look at is the vulnerability that has to do with empty lending markets. That's basically the beginning kind of block of all these hacks. What are empty markets? These are markets where essentially nothing's been deposited yet. So what could be a good example? Imagine we open up a lending protocol here at Ethereum Zurich, and we decide that we would like to now lend out water bottles for, you know, francs or whatnot for Ethereum Zurich, specific francs, some token that we create ourselves. It's not a popular token, it's not recreated anywhere else. In fact, we deployed it.
00:24:19.054 - 00:25:10.842, Speaker A: So of course, nobody's bought it yet, nobody's deposited it yet into our lending platform, even if we already created an ability to do that. So in this specific time when there's an ability to lend it out, but nobody has yet, nobody's deposited yet. We call that moment kind of like the empty lending market. Again, nobody's deposited any assets, nobody started lending anything out, even if there is a possibility to do that. That's the exact situation we're talking about. As you can imagine, this situation most often happens in the real world, in Defi and Ethereum and any other EVM chain, or frankly, any other smart contract chain. This happens right after the protocol says we now support blah blah blah token, and then they deploy it, and then they just leave it up to the users to actually figure out what to do.
00:25:10.842 - 00:25:51.220, Speaker A: So within the minutes, seconds, whatever you want to, you know, whatever you want to find, there is a certain moment where you can create a lending market on a protocol, but nobody has yet. And that would be the empty lending market. With Onnx finance, for example. This had to do with a meme coin. They released support for Tetacoin at some point, and it was actually fairly well traded than liquid coin on Ethereum, but their lending market was empty, so they released support for it. And for like a day nobody's deposited anything and nobody tried to borrow it or anything like that. I mean, nobody could borrow it because nothing was deposited.
00:25:51.220 - 00:26:29.368, Speaker A: So there was an empty market for a fairly liquid coin, which is an important prerequisite here. So we're gonna now jump in right into the rounding issue, and then we kind of go, we'll go backwards from that. I found that to be an easy, easier way to discuss these without having to go through the whole hack, even though we'll try, but just because these get a little complex. So let's take a look. I will release these slides. I mean, I think the organizers have them. So whoever wants to look at these later, I've provided some links towards the exploited contracts, so you can take a look at them later as well.
00:26:29.368 - 00:26:59.860, Speaker A: Yeah, and we'll take a look specifically at OnX. But again, 100 finance code is exactly the same. So the rounding bug, this is exactly what happens. I mean, this is the literal root cause, like where the computation goes wrong. Again, we'll go backwards from that. So this is the line where a division happens and a rounding issue happens that breaks everything. So let's start from just looking at this line over here.
00:26:59.860 - 00:27:51.694, Speaker A: We'll see how we got here, why there is a problem, what it can do. So basically what this line here does is it figures out how many tokens do we get to do we have to redeem to get back the actual assets? So long story short, as somebody comes into this function, Redeemfresh, and they provide redeem tokens in, this is a number of tokens they would like to get back of the asset. In our case, this was Pepe. So let's say the person said, I would like to get back 100 pepe tokens. So they put that in here. The application goes through a bunch of logic that's very important, but not towards us. And then the application goes here and says, okay, the user would like to get back 100 pepe tokens over here.
00:27:51.694 - 00:28:33.756, Speaker A: This is the number, I'm going to punch it through this equation, div scaler by x, truncate, whatever that means. We'll take a look in just a second. And by taking the tokens they would like, and the current exchange rate, this is what this variable here, it says exchange rate mantissa. It's a fancy financial thing, but it's basically the exchange rate. By taking how many tokens they would like and the exchange rate, we're going to spit back out how many shares they need to provide. So how much they should have as their balance in the internal accounting of this application. So it's actually a fairly, fairly straightforward line over here.
00:28:33.756 - 00:29:36.458, Speaker A: Again, all it says is, okay, the user would like to get 100 Pp tokens back. How many do we need to request for him to provide in terms of shares to actually withdraw their collateral? So far so good. But as we take a look into these functions, and you don't really need to look into this, I was just kind of going, tracing the, tracing the computation here we see that at the end, what happens is just pure old division. And the division right over here, this is where we get the problem, where a would be the, essentially how much, basically the number dependent on how much the user would like to get back, and b would be the exchange rate. So why would that be a problem? Let's pretend that we got the exchange rate to an absurd amount. It's some crazy number that should never get there. But sadly, it's possible in an empty lending market.
00:29:36.458 - 00:30:08.408, Speaker A: Let's say the exchange rate is one share of participating in this lending market. Literally just number one, not one point, something. Something with some decimals. No, just one share, the smallest possible number. Let's say it costs $2 million. So for somebody to join this lending market, the system would say, you need to provide me $2 million of value in pepe to receive one share worth in this accounting. Fine, let's say you do that, and the user has one share worth.
00:30:08.408 - 00:30:44.276, Speaker A: Let's say the user decides to deposit again and again, goes through the same thing. And now that user has two shares worth because they deposited $4 million. And then the user says, all right, now I would like to retrieve not $4 million of collateral back. I would like to retrieve 3.999,999,999 repeating million dollars back of Pepe. Now tell me, how many shares would you like to receive back? And so the application says, all right, well, let's do all the exchanges, let's do all the manipulation. And it comes right over here.
00:30:44.276 - 00:31:12.786, Speaker A: And right over here it says 3.99,999 divided by the exchange rate, which is two, and 3.9 divided by two in integers is one. So effectively the replication will say, oh, you just need one of the full share. Because we round down, because this division over here rounds down. We just need one share for you to give back. To get back 3.9
00:31:12.786 - 00:31:56.172, Speaker A: million worth of pepe. That is, of course, a giant problem, because now the protocol has lost out on 1.9 million worth of pepe tokens of collateral while still having the user left with one full share. And remember, in this application, these shares have actual value. So the user is effectively left with a 2 million share while having gotten back pretty much effectively all their collateral. And that's the synopsis of the bug, that's what happened. Hackers figured out that they can actually game this exchange rate to allow for these things and for the application to round down and given an incorrect number of shares.
00:31:56.172 - 00:33:02.856, Speaker A: So specifically, the issue is that if the user manipulates exchange rate mantissa, which is the exchange rate, the price, we can get it to such an absurdly high number that almost whatever number of tokens we would like to request back, everything is going to be rounded down. So, yeah, again, specifically, I mean, I use millions of dollars, but you can just use two on one. So when redeeming collateral, almost two shares worth, just slightly less than two shares worth, the application will only request to burn one share worth. The exact reason why this was possible, which is, again, getting a little bit more into the details of the hack. How they were able to manipulate this exchange rate is something called force feeding. So force feeding in these applications is depositing tokens into these contracts through unconventional means. What does that mean conventionally? When you go into these lending applications, you go through a function called deposit.
00:33:02.856 - 00:33:47.064, Speaker A: You provide your tokens and the application gives you back shares so that it accounted for an increase in the tokens by minting some shares against them. Well, you could also just transfer the tokens directly to the contract, right? Nobody's stopping you from doing that. The problem is you're not going to get any shares back. So that would kind of suck for you, but nobody's stopping you from doing that. And indeed, the way that the exchange rate is calculated, which is the second slide on the bottom exchange rate stored internal. As you go through the lines, you see that at line like, what is it, fifth from the top, you into total cash equals get cash prior. The way that the exchange rate is calculated is dependent on the literal token balance of the contract.
00:33:47.064 - 00:34:48.061, Speaker A: So if you force feed this contract, the token balance here is going to go through the roof, and then the exchange rate is going to be incorrect. Now why would you do that? Right? Because now you've lost all these tokens, they're now stuck there. Well, they aren't if you're able to manipulate it so much that you can fake burn tokens or fake burn shares and just keep draining the contract away. Specifically, what happened here was a user found an empty market. As I mentioned, the reason why it's important to be empty is because if there are no shares minted, then and only then can you actually mint one share worth of something, because otherwise the accounting just doesn't work. If any other user came in at that time and tried to mint, like, let's say, one dollar's worth, the system would already, because of the way the accounting works, mint something like, you know, five times one e to the 8th worth of shares. And because it's, you know, there's fixed point arithmetic there.
00:34:48.061 - 00:35:27.452, Speaker A: There would be a lot of numbers that would actually represent a small amount of shares. But because hackers found an empty market, they were able to manipulate just exactly how much they deposit to be so little that they managed to get the amount of shares down to just one. Then they inflated the exchange rate for their own shares that only they own. Remember, they are the only people who own these shares, so nobody else would actually benefit from them. They inflated the value of their own shares by depositing a ton of collateral through force feeding. And now they have this giant, giant, giant position in the lending protocol with just two shares worth. So far so good.
00:35:27.452 - 00:36:00.290, Speaker A: They haven't hacked anything yet. But then what the users do, because it's a lending protocol, or the hackers, they borrow against these just two shares and retrieve all the pools from all the other tokens they stole Daisy, they stole USDC, because the system says, well, they still have the collateral. They still have those two shares worth millions of dollars. So, I mean, of course I'm going to let them borrow other assets because they have the collateral. So the users did that. They had two shares, a ton of debt. They borrowed a ton of stuff.
00:36:00.290 - 00:36:33.016, Speaker A: And then they said, you know what? On the second thought, I would like to redeem my existing collateral. This is the point where the letting protocol should say, you can't redeem it. You have a lot, a lot of debt. The debt would prevent you from doing that, because then our checks wouldn't pass. But the problem is, and that's the redeem fresh on the top. If you remember the last parameter in the first, call the comptroller redeemal the last parameter there, redeem tokens. That's the amount of tokens that need to be burned.
00:36:33.016 - 00:37:09.254, Speaker A: Well, this one is wrong. The system made a mistake. It made a mistake thinking that for the health check of that user's balance to actually go through, they need to burn only one token worth instead of two. Tokens worth. So even though the user said, I have a ton of debt and I would like to actually exit my positions of all my collateral, the system thought, he said, I would like to only retrieve half of my collateral, and I'm going to leave half still there because of that one share still there. So it let it go because of its rounding issue. And that rounding issue was only possible because there were only two shares in existence.
00:37:09.254 - 00:37:33.150, Speaker A: And that are that valuable because we force fed the contract. I know it's a lot, these are quite complex, and maybe you followed it. I didn't at first, but the problem is this, basically, I mean, I think we can all see how. Well, let's actually go over here. We can all see how this would be a problem. There is some value loss. It's pretty bad.
00:37:33.150 - 00:38:33.886, Speaker A: And the value loss depends on a whoops on the token balance of the contract, essentially. So that's kind of how this issue happened here. Again, this is a fairly common problem that sadly happens quite a bit still, with compound v two force, people fork it because it's very well documented and very well battle tested, but they don't really know how to handle these things. And it's sad because the fix for this is very simple. The fix is simply whenever you deploy a new lending market available for usage for your users, you should just, in your deployment script, create some shares so that you initialize the supply of the shares to be something greater than, you know, 100,000, which would be very, very, very little because it's still with fixed point decimals. But if you do that, these types of attacks are just simply infeasible, in fact, and we'll see this later. Uniswap V two technically suffers from this vulnerability, too.
00:38:33.886 - 00:39:19.118, Speaker A: But when you deploy Uniswap V two pools, they create and burn shares immediately, not allowing for this type of attack. So this is just a deployment issue, frankly. I mean, yeah, there is an actual issue in the code, you can say, but it's remediated by deployment, and it's as easy as just following deployment practices. All right, let's hurry this up. My bad. Another one that we'd like to take a look at today is raft protocol. Also, lending protocol in this case is taking a little bit of a different approach where instead of allowing people to deposit assets and then borrow against them, borrow other assets against them, rough protocol actually has a stablecoin.
00:39:19.118 - 00:40:09.352, Speaker A: So you deposit assets, after you deposit, you declare those assets as collateral, and then you're able to create stable coins against this collateral kind of like maker, at least that's kind of how I read it. You know, maker, Dai, all that stuff. Not a super expert in raft, but it's only as much as what I've gone through here. So sadly, there was a rounding issue. The rounding issue here was different, and suddenly this rounding issue resulted in roughly 1500, well, 1577 ETH being lost from user deposits, which was approximately over $3 million at the time. A little spoiler alert about this hack. I didn't mention it there, but this hack actually did steal all this money.
00:40:09.352 - 00:40:33.824, Speaker A: But because of an issue in the hacker's code, he accidentally burnt it all. And in fact he ended up losing four ethereum on it. So kind of sucks to be them. Plus they have a legal case on them now. They'll probably be found. We've gotten a lot better at that. But users still sadly lost all this money, and $3 million is not an easy hole to fill up.
00:40:33.824 - 00:41:16.380, Speaker A: So anyway, let's take a look. As usual, I do have the tokens, the contracts over here. Once you can find this deck online, you can definitely click through this. It's a very, very simple way to find where the issues are. So this is a little bit more difficult, but stay with me. So as I mentioned, the way that raft protocol works is you deposit tokens, collateral assets, be it ethereum, bitcoin, I think there was a bunch of other stuff, USDC. Once you deposit it, you can declare your deposits as collateral.
00:41:16.380 - 00:41:56.288, Speaker A: When you do that, the system says, okay, now they're a fair game for borrowing and lending and all that stuff, but I have to give you some tokens for your collateral so that you know you still have something that, that is within our accounting that says you can now borrow against it. So that's exactly what happens in the manager position. Call. So a person with collateral says, okay, I would like to actually now declare this as collateral. Give me some shares back. So in this case, the attacker had Coinbase ETH, I believe is what this is. He said, for my Coinbase ETH collateral, I would like to increase it.
00:41:56.288 - 00:42:29.666, Speaker A: And they wanted to increase it by one way. One way is the smallest possible number in all of ethereum. It's literally just one. And then they said, okay, and now for this one way, I would like to please get back some collateral. And so what the system did, it does a bunch of checks, a lot of very good logic, and then says, okay, now let's adjust the collateral of this user in our internal accounting. This is where we actually pass the collateral change number. And then as it goes here, it goes to adjust collateral, blah, blah, blah.
00:42:29.666 - 00:42:59.538, Speaker A: It actually finally mints this collateral over here. But the mint is sadly vulnerable. All the mint says is the amount requested to be minted. We will actually mint it by dividing it by something called stored index. For all intents and purposes, stored index is also an exchange rate. But the problem is they did a divup. I mean, frankly, a round down might have also caused an issue here too, I don't know.
00:42:59.538 - 00:44:12.196, Speaker A: But in their case, dividing up and dividing up means dividing with rounding up caused them a critical issue. Why? Because what this Devop does is it says whatever number you get from division, give it a plus one at the end. So now that we're all professionals in this type of hacking, we can guess that if the stored index is a ginormous number representing crazy amount of value, and amount is a tiny number, perhaps the smallest number possible in Ethereum, we should get a result like zero, but instead we get one. So think about it this way. If we again hack the system enough, manipulate the system so that we say the stored index, the exchange rate, should be absurdly high, and that each share is very, very valuable, then we can see that getting these shares for free would be a problem. And in fact, one way of Ethereum is an incredibly small number, and just providing it here and getting some actually valuable share back would be a problem again, only if the shares are actually valuable. Sadly, they are valuable.
00:44:12.196 - 00:44:57.000, Speaker A: There is a way to manipulate the system to actually drive up the exchange rate of these shares to an absurd amount. To give raft some credit, they did try to block it. It wasn't a very conventional way how this exchange rate can be manipulated, but it's possible anyway. So the issue, the literal running issue we're talking about is that minting rounds up the division. So when you try to mint with very, very, very little amount, you're always able to get at least one of something back. And if that one is greater than whatever you try to mint with, there's the problem. So yeah, the result is that a sufficiently high stored index gives essentially free mints.
00:44:57.000 - 00:45:36.918, Speaker A: Stored index is basically the exchange rate. The problem why this happened is that during a very specific point in this protocol, liquidations, actually, during liquidations, I mean, we don't need to really read all this code, but I just left it here for or posterity, during liquidations, all the way down here, there is a call to the collateral tokens called set index. And what set index does, as you can see here and there we go. Here is our problem. That we are so familiar with. It basically just says the index to the supply of the tokens. Where is it? Here.
00:45:36.918 - 00:45:57.806, Speaker A: Sorry. It's this line to the supply of the tokens that are on this contract. So again, force feeding. If somebody is able to force feed this contract, anybody can. You can always transfer it to a contract. Then the index would be set during only liquidation, which was the kind of the trick to an absurd amount. Now, the index is an absurd amount.
00:45:57.806 - 00:46:25.020, Speaker A: Now, the index goes back to this point over here, right? Amount divided by store index. Index is giant. It should give back zero, but it doesn't. It gives back one. And voila. We now have free value being minted from these shares. Now, basically, the way that the hack went is somebody also found an empty market.
00:46:25.020 - 00:47:09.986, Speaker A: Actually, was this one empty? No, this one wasn't empty. They just force fed a market, but it was almost empty. There was only one other user. I believe it might have been empty, but this didn't matter as much in this particular case, because effectively, what they did is they created a position. They started to add to this position through just tiny, tiny, tiny amounts of one way. But as they did that, they force fed this contract with a giant amount of tokens, and they essentially were able to create free mints, or free shares with just one worth away. That actually is worth the whole contract balance, figuratively.
00:47:09.986 - 00:47:50.184, Speaker A: And, yeah, long story short, the accounting messed it up here. The system started thinking that the user does indeed have all those shares in there, and then they were able to mint a bunch of free stablecoins, which is r. It's just called r for the rough protocol. They were able to mint a bunch of free ones. Once they minted the stablecoins, the system started to treat those stablecoins as their collateral, too. And so they were able to withdraw their collateral. They were able to withdraw the fake minted stablecoins, and that was the 3 million worth of ether that they accidentally sent to the zero address, because the hacker wasn't, I guess, too sophisticated.
00:47:50.184 - 00:48:30.864, Speaker A: But the long story short, what I wanted to show here is that a completely different problem with the exchange rate. Right here we had a devop. Here we had even a different lending protocol where we actually create stablecoins, but yet a familiar problem with the supply. So force feeding, clearly a problem, right? Something that we would like to get guardrails against. And in fact, yeah, here, the fix wouldn't just be good deployment, but would probably be something like better invariants. Invariants are just checks that need to be true at all times. Better invariants here specifically would probably be against force feeding, maybe.
00:48:30.864 - 00:49:20.200, Speaker A: Frankly, I don't really know this. This is a bit of an intricate situation. This leads me to the last lending protocol that I want to talk about today, and that is wise, and this one was quite wise about how they go about these problems because it actually had very good round downs against the user, very good roundups for the system. And in fact it even had safeguards against donation attacks. So you couldn't force feed it. You couldn't really do any of that force feeding that I was talking to you about because the way that the contract accounted for value, it actually kind of did something like divided it by the time of deposit. So you couldn't just put it in one transaction.
00:49:20.200 - 00:50:07.310, Speaker A: So it was actually quite, quite clever, and yet it was exploited still not that much. I mean, it's still a lot of money, don't get me wrong. But in the grand scheme of things and the couple of last hacks, I'll talk to you about, not that much like half a mil worth at the time, but it was a very intricate hack, again, code here. So the hack was right over here. Essentially it has to do with, again, the exchange rate between the collateral you put in and the shares that you get back for this collateral. Literally, this function over here was the one that was exploited. Calculate lending shares, calculate how many shares, the assets that I'm depositing or withdrawing or whatever are worth.
00:50:07.310 - 00:50:54.304, Speaker A: And the way that this is done is through this equation over here. So how many shares have been deposited times the amount that's about to be deposited divided by the pseudo total pool. Pseudo total pool is essentially the contract balance. But again, it's a contract balance with checks that doesn't just allow you to go at the contract by the contract balance, but the long story short is this right over here. Again, we have the same, same problem. If the number, if the value of the shares, which is pseudo, is so large, there will be larger than this product over here, which is total deposited shares times amount. Then we get zero here.
00:50:54.304 - 00:51:24.470, Speaker A: But then we round up. And this rounding up is what did this protocol. This is what actually led to the issue. But the problem is slash. The good thing is that this rounding up happens only in favor of the protocol. So technically speaking, this would be good for the protocol. This chain or branch of logic only happens when we try to burn away from the users.
00:51:24.470 - 00:52:27.046, Speaker A: So basically, instead of what onnx did here, it says, look, if you want to retrieve your collateral, you pretty much almost always are going to have to round up how many shares you have to burn. So here it basically tries to protect itself against that attack that we saw in the beginning. Again, to put it simply, this branch of logic only happens when people try to withdraw collateral. And basically it ensures that whatever people withdraw, it is one more than what they would expect to protect the protocol, but yet it is still rounding. And as we saw with the last couple of examples, rounding is in some ways kind of a sneaky way of transferring value from one side to another. And this is what the hacker exploited, essentially they figured out. But by doing this rounding, the value does flow, yes, from the user to the protocol.
00:52:27.046 - 00:53:14.780, Speaker A: But if the hacker was the 100% owner of this lending pool, they would essentially be donated to themselves. And this is essentially a force feed donation attack. In a mask, they were able to exploit this, rounding up towards the protocol as rounding up towards themselves, thus exploiting the whole system. Again, I know it's a little bit complex to just be explained right over here, but that was the issue. Trust me on this one. So, yeah, basically the problem was with the conversion, where a tiny amount of collateral would be translated to one more of the shares than what it is. And in fact, at the very least, at least one.
00:53:14.780 - 00:54:24.188, Speaker A: And if you're, again just trying to deposit a very, very, very tiny amount of ether, you would be essentially be required, or, excuse me, if you're trying to withdraw a tiny amount of ether, you'll be required to actually get at least one worth of shares back to the protocol. But the problem is that this is also kind of like a donation attack in a mask, as I mentioned. And the long story short, let me just fast forward through this. This is able to be exploited because the pseudo total pool is able to be increased by a crazy amount. And what the user essentially did here, which was kind of crazy, is they've deposited to this lending protocol through, like, seven different accounts. One master account that held all the shares in the lending pool, and then six puppet accounts. For each one of the puppet accounts, they provided some collateral, and they bought these very, very expensive shares, and then they borrowed against those shares.
00:54:24.188 - 00:54:52.952, Speaker A: Now, at this point, it's fine because the user is borrowing against real collateral that they have. They've deposited a lot of money. They're borrowing against it. That's perfectly fine. Their collateral is still back there. But then what the user did was the users tried to withdraw all their collateral, and the system said, okay, you can try to do that, but we're gonna, first of all, check how much you need to withdraw. And second of all, even if it's more than what you're trying to withdraw, we'll burn it.
00:54:52.952 - 00:55:21.036, Speaker A: And that's what happened. Basically, let's say the user had 1 million of a collateral in the system. They have borrowed $600,000 against this collateral. So far so good. The system has a debt of or a credit of 600,000 to someone, and then they have collateral of 1 million. The user is at a loss right now. Then the users try to withdraw just one way worth of collateral back, and the system says, well, screw you.
00:55:21.036 - 00:55:56.298, Speaker A: Instead of one way worth, we're going to burn one whole share worth of you because of that rounding up. And the system burns it, and the user is left with six hundred k of their borrows and their whole collateral share was burned. So their whole 1 million. So you look at that and you say, well, that's fine, the system still has that 1 million. They burned away the user share. What's the problem? Well, the problem was BeCause the share was burned. Now that collateral needs to be accounted for Somewhere, and that collateral is accounted for with the rest of the lending pool.
00:55:56.298 - 00:56:33.856, Speaker A: But the rest of the lending pool is with the master account of the attacker, who has no debts. And essentially this burn, this ensuring of one shares worth is burned, at least transfers this collateral with no debt to the master account of the user, and this creates bad debt. That's essentially what happened. Again, bit complex. Going through these post mortems is difficult on the fly. I definitely encourage everybody to read on it. But yeah, the gist of it was, through this burning, there was an accidental unlinking of the user debt and the collateral.
00:56:33.856 - 00:57:09.414, Speaker A: The collateral got transferred to the rest of the pool, which was 100% owned by the attacker. And then the attacker just walked away because the master account had no debt. And then the attacker walked away with all the borrows that they had and all the collateral that they had, and they still were able to do that. Even though we had donation attack prevention, we had rounding against the user in favor of the protocol and still were able to do that. And yeah, frankly, in this case, again, it was an empty pool. It was an empty pool. Empty pools allow for manipulation of shares, specifically share supply.
00:57:09.414 - 00:57:46.044, Speaker A: When you allow for that, you allow the users to get to very, very weird edge cases where you have like one of a share total or two of a share total, just very, very small numbers. You get there, you start getting into rounding issues. And that's exactly what happened here. So definitely deployment is a fix here, but there could be other fixes, such as better invariance for checking at the end whether there is bad debt or not. And that's totally possible. But again, other things would have worked out too. Now, I have only a couple of minutes left, so I'm going to run through these next ones.
00:57:46.044 - 00:58:25.014, Speaker A: Yeah, I guess. Let's do a quick takeaway about the Linux protocols. So, yeah, manipulating of lending markets is a giant problem. Nobody should do that, ever. You can defend against this through deployment strategies, literally. In uniswap v two white paper, they have this line over here where they say, we do know there is an issue, but whenever you deploy a uniswap v two pool one e -15 of a pool, shares are minted immediately, which renders all these empty pool attacks just completely infeasible. It just won't work.
00:58:25.014 - 00:58:59.500, Speaker A: But on top of that, of course, we may have very complex logic, and that complex logic can be caught by invariants. It's a bit of a buzzword, what is a good invariant, but it's possible you can definitely try to defend against it like that. Now, decentralized exchanges. Again, I'll run through it quite quickly, even though they're way more complex, but simply because of the time. Kyberswap. Kyberswap, very famous and quite frankly, one of the OG protocols on Ethereum. It allows for decentralized exchange stuff.
00:58:59.500 - 00:59:33.270, Speaker A: One of their cool things. And the latest features is a CLmm, which is a concentrated liquidity market, kind of like Univ three. It got exploited for 56 million with a very, very, very complex exploit. Again, look at the pool. The specific problem happened right here. And even though, I mean, I'll very quickly explain the bug, but this was actually kind of like. I mean, I don't mean to say anything against the developers to the others at all, but this was a silly bug.
00:59:33.270 - 01:00:15.494, Speaker A: The specification that's right there within the code, you can find it at the link I sent over there, right there, the comment says we have to round it up, and right there, right after they round it down, it's all it did. It's all it took to get $56 million stolen from users. Just one small mistake like this to explain a little bit more what this did. Do I have anything else here? Yeah, I do. We don't need to go through this. Very, very, very shortly explained. Concentrated liquidity in exchanges like this works by setting up boundaries on the curve of the exchange.
01:00:15.494 - 01:00:46.984, Speaker A: And those boundaries are critical because they define where the liquidity is, where the pricing is and whatnot. And in this case, rounding down made the system think it was not within the boundary where it was, put it simply, and this allowed for double liquidity counting. Double liquidity accounting means that once you go through liquidity a certain price, you can go through that liquidity again at that same price, which is technically much cheaper than what it should be. This allows for a drain. Bam. Drained. Awful.
01:00:46.984 - 01:01:16.140, Speaker A: Very complex logic. There is really no fix. I can think about this better than just triple check, the more complex your protocol is. I know it's general. In general, in my opinion, problem in this ecosystem, we make some really complex stuff. And yeah, these things can get exploited as easy as not following specification, which happens to everyone. Another one I wanted to very quickly talk about in 30 seconds is balancer.
01:01:16.140 - 01:02:32.526, Speaker A: Very popular decentralized exchange as well. It does a lot of really cool things with trying to actually get idle liquidity through idle tokens, active in all swaps, increasing price for everyone, and also getting more fee liquidity for everyone. At one point, a bug on balancer that had to do with rounding could have affected at least 20%, probably a little more of Balancer's total value locked, which at the time was over $1 billion. Thank God White Hat founded and he was granted a $1 million or, excuse me, USDC grant. Though if you read the post mortem, which I did link by balancer themselves, they actually did get hit by an exploit at almost exactly the same time as them trying to remediate this issue, and they did lose some amount of money, very, very sadly, but they were able to make it all. The long story short, here was this specific code over here, where again, the comments suggest it will be fine. And it was fine until they included a new feature that allowed an unexpected branch of logic to go through this code.
01:02:32.526 - 01:03:24.968, Speaker A: The long story short of the issue is they use very careful rounding at the end of settling transactions in the exchange part of balancer, except for here, where they upscale. And they say it's fine in this case because, well, whatever they say here, they say something, something. This is the only place where we round in the same direction for all amounts as the impact of the surroundings expected to be minimal. And it was normally, but because all of their. Do I have anything here? Kind of, yeah, you can kind of read about it here. But basically they implemented a feature where they allowed a lot more of the pools to participate in a single swap. That was because of how they nested pools against each other.
01:03:24.968 - 01:04:11.236, Speaker A: Essentially, you could create a pool, and then the tokens of that pool could be in another pool, and the tokens of that pool could be incentivized with another pool. And all of that could be done through something called flash swaps as well, which allows you to manipulate the balances. The long story short, they added a few complex logic branches, too many that allowed for manipulating the balances of pool shares. And then when you do, as we now all know, when you're able to manipulate the balances of shares, rounding can be a really, really, really big problem. Because if you can manipulate, you can get down to just one of a number, and then that's it. Then upscaling can be a really, really big problem. Yeah.
01:04:11.236 - 01:04:33.364, Speaker A: Again, I linked here their own post mortem. Very, very interesting. Reads like a movie, and they explained a lot of stuff there. It's very interesting, but also very scary because it's very complex. I've got no fix for this one. It's just complex. So yeah, the way forward, obviously, we mentioned this a ton of times.
01:04:33.364 - 01:05:12.104, Speaker A: Deployment strategies, avoid minimal balances, avoid empty pools. It's very important and frankly, not that difficult to do manual review. You know, that's where we auditors come in. The manual review needs to ensure compliance with technical specification. I think it's a problem that right now, in the security part of our industry with audits, we don't actually always require the auditors to read the specification. It can lead to that invariance. It's something that's kind of getting new and cool in the ecosystem.
01:05:12.104 - 01:05:48.734, Speaker A: Definitely look into those. Definitely look into how to create invariants very nicely. DyDX has some really, really good code for that, if you want to get some inspiration. But a very good plus of invariants is that they're easily turned into, into fuzzing rules later. And fuzzing is definitely picking up as well. And then finally, and this one is a bit of a hot take of mine, but I kind of think we might want to look into floating support into the EVM. I know I mentioned the issues with it, but I'm staring on $100 million worth of reasons why we should implement it now.
01:05:48.734 - 01:06:19.300, Speaker A: Again, it should be done carefully. We don't want any liveness failures. But I think maybe at least I will take a look into how feasible that is. I think there's inspiration to be taken from JVM Java virtual machine, which is also hardware and operating system agnostic, but it is able to actually standardize floating point arithmetic there. I think there might be something here for us as well. And then this is just a summary slide of what we talked about today. Feel free to connect with me on Twitter.
01:06:19.300 - 01:06:30.644, Speaker A: Feel free to connect to me on Telegram. Feel free to find me throughout the conference. I'll be here today and tomorrow. And this was my talk about dangerous decimals. Thank you.
