00:00:11.720 - 00:00:37.106, Speaker A: You're a trickster. Alright, so yeah, level up wallets with this one weird trick. L1 s will hate you, l zero will love you. Let's go. So yeah, the project is called BlS Wallet and it's part of the privacy and scaling explorations group within the ethereum foundation. Yep. Cool.
00:00:37.106 - 00:01:30.222, Speaker A: So the QR code's there, you can look more and I'll shout out to that at the end as well. This is the team. We've got four developers at the moment, we've recently hired two more, and yes, just expanding more. So in terms of bringing this technology out into um, into the ecosystem. But I kind of like to start with, you know, why are we doing this, um, why are we, you know, working on this project and what do we hope to achieve? And for that, I start with sort of this graph and looking at feasible applications that use blockchain, um, with respect to uh, transaction costs. So when you have um, layer one costs of like whatever tens or hundreds of dollars, say per transactions, depending on the time, only so many applications are actually feasible and will sustain themselves and solve problems at that price point. With rollups we can go a little bit further and we can have more applications, but still we're not really reaching those really lower levels yet.
00:01:30.222 - 00:02:01.038, Speaker A: On top of that, if you increase usability and have more people able to use the technology, then you can increase the impact that this technology can have on the world or in again specific applications that use it. So this is roughly what we see at the top end. You've got defi front running, some hyped up NFT drops, everyone's just scrambling to pay for the transaction for them. They consider it worth their while and projects are existing in this space doing those kinds of things. High value asset transfers as well. Work on l one. Roll ups let you get more casual gaming.
00:02:01.038 - 00:02:33.734, Speaker A: So people can spend 510 $20 or under dollar ten a transaction and do casual gaming. And that makes sense at that point, but we kind of want to go here. So the BLS wallet applies to EVM roll ups and it reduces the cost even further. And then we can start to target things like microfinance for developing economies. There is an application that I know of that is doing that, not without technology, but they've just spun up their own blockchain because it's cheaper. And that's the unfortunate reality of it. They may compromise on security just to have a feasible application that solves their problem.
00:02:33.734 - 00:03:33.044, Speaker A: So I'm always reminding myself of this to say, what are we trying to achieve? And it's to bring these solutions to effectively l one ethereum rolled up. So what have we achieved so far? Again, staying a bit high level, this isn't actually from l two info, it's just a representation of it. But if you've got something like optimism and arbitrum getting like 30 transaction, the BLS wallet, which combines both the signature aggregation as well as some parameter de duplication, you can have some significant savings that brings it down to something like this. So this could be in terms of an application of a lot of the same types of transactions. You can actually get a lot of deduplication of parameters, but also in reducing signatures that get written to l one. But I will go into a bit of details now, by virtue of it being a smart contract wallet, I just sort of incidentally added these other things which for me when I started this a year and a half ago, was just hacking away at a smart contract. That barrier was saying, oh, we want to do this savings.
00:03:33.044 - 00:04:08.738, Speaker A: And I started that with a BLS signature scheme. But I thought, well, it's a smart contract wallet, I can add a few more things. And what that introduces now is sort of gasless transactions, account recovery, upgradability and this multi action. But we'll see more of that later. Account abstraction is spoken about by Vitalikin 4337 and we're working on just communicating with them on the v two of 4337 and how it will include BLS signatures. So starting with what's pragmatic, what I can get out there now, and then moving towards standards and bringing those in later. So let's just quickly go down the origin of this, and it's gonna prior work all the way down.
00:04:08.738 - 00:04:55.584, Speaker A: So I'm always building on the shoulders of giants. So starting here, it was actually relatively recent in history, I'll say that the. I'm gonna send it wrong. Bonay, Lin and Chacham, they wrote this paper about, yeah, pairing cryptography based signature scheme, which is used for ethereum phase zero deposits. But the key attribute we want from it, which is what makes us pay less gas, is the signature aggregation. And just to sort of go into how that, or why that saves us money or saves us gas, is that l two s writes not only the state, the new state to l one, but also writes all the transactions that progress that state. So for every transaction you have a corresponding ECDSA signature as well.
00:04:55.584 - 00:05:43.782, Speaker A: So that's a lot of data. What signature aggregation does, or specifically the BLS signature scheme permits, is that instead of having every transaction with its corresponding signature, you can just aggregate it and it will take the same amount of space as one signature and you can still verify all of the transactions. So imagine if you've got 30 transactions, you can compress the signature to one and have one 30th of the signatures written to l one. Therefore that's the saving in terms of signatures. This was implemented in the Hubble project, but that was an ERC 20 focused network. So it was its own roll up effectively and it wasn't EVM compatible, but it was able to use that. And they wrote some libraries that I've been able to use and bring it to this project called BLS wallet.
00:05:43.782 - 00:06:18.898, Speaker A: So we'll get the QR codes again at the end. But yeah, that's when that started. And yeah, so it started with the smart contracts. Then we've implemented an aggregation service. So that's something that's hosted that will take transactions and do the aggregation for you and submit that to l two s or EVM l two s, the client module that we'll be getting into wallets. And then we have a prototype extension that we call quill that just shows an example of a wallet using the client module. So this, like I said, that's, yeah, reducing the l two data that gets written to l one.
00:06:18.898 - 00:06:46.892, Speaker A: And that's both via signature aggregation, but also then parameter deduplication is what I've implemented. But there's, I think currently l two s do something else. They use kind of like zlib compression. Optimism and arbitrum I think are looking to things like that. For what I did, we had 31 transactions and these were the results. This was someone who knew sort of more about the block structure of arbitrum and they were able to measure this for us. So that's where the results are for that.
00:06:46.892 - 00:07:37.514, Speaker A: And I am just skipping along so I can get to the, so the layout of it, of the components is like this. We have the prototype extension inside the browser at the moment, but that could be any wallet. It uses the client module that does the signing of the BLS signatures. We are hosting our own aggregator at the moment and that allows you to send transactions or have multiple wallets send transactions to this aggregator which periodically can effectively batch them together and aggregate the signature into one. So that's how you get those savings and then it submits it to l two. When you have something like gasless transactions, you can effectively reward the aggregator for submitting the transaction for you. And on chain we've got the verification gateway that checks the, checks the signature and the corresponding transactions and then can effectively execute them with each of the wallets.
00:07:37.514 - 00:08:08.578, Speaker A: So kind of like I just said, the DAP will create an operation which contains multiple actions to say we want to do something like approve and transfer or approve and swap or whatever. We want to do a set of actions that are executed atomically as one operation. So that's quite a handy ux feature, I think that is then sent, yeah. The client then receives that in their wallet. It signs the operation and many other wallets are doing the same thing. Those get aggregated together and sent. Yeah, to the aggregator that bundles it.
00:08:08.578 - 00:08:36.134, Speaker A: That bundle is then sent to our smart contracts. The expansion is what we had for the parameters. And then the signature verification calls each of the wallets with their corresponding operations. Obviously in that case the wallets and the verification gateway are kind of paired. In that sense the verification gateway will be, is getting audited pretty much this week or next week. Yeah. And then, yeah, any actions are fed back to the DAP.
00:08:36.134 - 00:08:59.870, Speaker A: So hopefully this video works. Oh, so they've put the PDF's here. I sent the full thing. Great, because I specifically sent the PDF. Well, I'm a line of code. No, I can't actually. So basically what we would have seen is I think he goes from scratch.
00:08:59.870 - 00:09:30.190, Speaker A: So he installs it. And again the link's not showing the color. So around there it says BLS wallet client. That's really disappointing. Now my talk's going to be five minutes early, so please prepare a bunch of questions because there's going to be five extra minutes to fill or we go for wine early. So basically you can install this client module and you'll have NPM install it. You can connect it to your web3 provider in the client and then we'll expand upon the signing part of it.
00:09:30.190 - 00:10:09.184, Speaker A: But it's wallet sign should be pointing to the screen wallet sign. We'll expand that in the next one here you can have client side aggregation. So if it makes sense for you to combine multiple operations, you can do that here with multiple bundles. And then this part here is basically creating an aggregator and sending the bundle to the aggregator to be put together with other wallet operations and then aggregated. So just in summary, connect the wallet, create and sign a bundle of operations. You can aggregate locally if you like, and then you send it to the aggregator to submit or to aggregate with others and then submit for you. And that's when you get all the savings.
00:10:09.184 - 00:10:43.444, Speaker A: So this is expanding out the bundle. This is what it is. So you just call wallet sign, you pass it the wallet nonce because it's a smart contract wallet. We did have a chat about the nonce with the gas station network people who are doing, who initially wrote 4337. And for our case, we are assuming and incrementing nonce, which is not ideal because noncers can take, there's different ways of implementing nonce to have uniqueness. But yeah, consecutive nonces are what we're using for now. And these two actions were the two examples that he showed.
00:10:43.444 - 00:11:47.532, Speaker A: Basically it was a live demo on video of a DAP that he'd written that Kortuk had written that doesn't approve, and then a swap as one, because again, right now the UX is just hideous, where you have to connect, sorry, perform one operation and then perform another, and you have to wait for that. So this sort of gets rid of that problem. So where to from here? We have, again, the top row is what we had, but what we're doing is talking to various wallets and to get them to have the client module in there, there's existing l, there's other l, two s that are basically forks of Ethereum that are interested in doing this. So for their own reasons, they're like jumping ahead to do this. We spoke with arbitrum specifically, but I believe optimism as well is keen to get this code into their nodes because it makes sense for them, because anything they can compress and reduce, they're just reducing their cost. On l one, to quote I forgot his name. Yeah, the guy who talks about arbitrum, he had said if metamask were to have this on a Tuesday, they would have the aggregator code in there on a Wednesday.
00:11:47.532 - 00:12:30.834, Speaker A: Like once BLS is in wallets, it becomes a no brainer for it to work because everyone's paying less, more users, more feasible applications, everything just grows from the right direction, from people actually wanting to use it. We spoke with Gnosisafe who have their own smart contract wallet, and they had a suggestion that their wallets allow you to highlight a trusted module. That trusted module could be our verification gateway. So these are just ways we're seeing our pieces go out and get used by whomever it makes sense to use. So it would be, again, EVM rollups. And if and when or when Zika evms out there, this can perhaps be parts of it go in there as well. So we are.
00:12:30.834 - 00:13:14.878, Speaker A: Oh yeah. So we've created this name just calling it the web3. Well, so the idea is that we want to provide sort of pure resources that people can use and leverage and have some open conversations with different ecosystem partners or people in the ecosystem building components of it. For the BLS wallet, we've improved the dev docs, we're defining more issues in our repos and yeah, good first issues and whatnot. Because our contracts are upgradable. We are looking at the standards. We're looking at the standards such as 4337, but also any other wallet standards or other paradigms that or security improvements or feature improvements, we can upgrade the wallet.
00:13:14.878 - 00:14:18.624, Speaker A: So this is. I can actually go into this a little bit because I now have a bit of time. The verification gateway will be a single audited thing that everyone will make peace with and understand that that is solid and checked from all angles. When you interact with it, you get your smart contract wallet created with create two so you can know the address in advance. And if you wish to use a different verification gateway, say in the future, a new one is created that has more features or will we detect a problem and we fix it? We'll deploy that audited contract as verification gateway two, and individuals can choose to point their, or refer to their trusted gateway as no longer being the first one, but then being the second one. So it's in the wallet's control to choose if and when they point to the new one. Similarly, the wallet smart contract is using the transparent proxy method, the libraries from open zeppelin, and similarly they can choose to upgrade their implementation at their discretion, which is actually quite good.
00:14:18.624 - 00:15:04.314, Speaker A: But in terms of writing this code, you have to be very careful to assume that both parts of your thing can change. And how do you keep the verification gateway pure if people can change their own wallet implementation? So that was the cause of a couple of little bugs that were picked up, and that's before audit. So hopefully the audit doesn't find anything, but we kind of hope they do if there is something else wrong with it. And again, on top of the yeah, just repeating all the features, we've got BLS signature scheme, gasless transactions, account recovery, upgradeability, and the multi action. This is all ready now. We've got our own discord there, so please jump in, ask us questions, jump to the repo, check it out, have a go at using it if you like. Yeah, we're here to support you.
00:15:04.314 - 00:15:43.854, Speaker A: We hope other wallets will be coming in soon, but there's also another initiative around Ethereum wallets that we are talking to wallets through, and also some direct contact with wallets. And again, this is part one of the projects within the privacy and scaling explorations group, and this is the one I would say it's the one scaling project, but a lot of the others are around zero knowledge proofs and. Yeah, applications of those projects as well. So they're doing some interesting stuff there. I think there's also the, if you've not seen already in the sponsors area, there's a quadratic funding project, which is one of these as well, which is part of PSE, and. Oh, that's the last slide. Thank you very much.
00:15:49.554 - 00:15:52.974, Speaker B: Wow. Wow.
00:15:53.554 - 00:15:55.394, Speaker A: Hope that's a good thing. Yeah.
00:15:55.474 - 00:15:57.054, Speaker B: Wow. Wow, wow.
00:15:57.514 - 00:15:59.970, Speaker A: Trick. You said it would be a trick.
00:16:00.082 - 00:16:07.974, Speaker B: Has anyone got any questions? Yeah, one here in the middle. Has anyone not got any questions?
00:16:08.554 - 00:16:15.314, Speaker C: Hi, I'm Thomas from Minerva Wallet. Maybe we talk later. Yeah, I come down a little.
00:16:15.394 - 00:16:17.854, Speaker A: That's okay. Camera's got to follow you.
00:16:19.834 - 00:16:31.012, Speaker C: You have their account recovery. Could you elaborate on this one as well? So, yeah, kind of interesting because it's usually a huge debate on how to get back. You lost keys.
00:16:31.108 - 00:16:47.076, Speaker A: Okay. Yeah. So the way I've implemented this is. It looks like they've got the video there. Yeah. So the way I've implemented that is just storing it was kind of a simple implementation where it just stores a hash on chain and that doesn't reveal anything. So that's the idea.
00:16:47.076 - 00:17:09.740, Speaker A: If you've got a multi seg and it's pointing to a bunch of addresses, you don't want to reveal that you don't want to. Like, if you've got a high stakes wallet, you don't want to say who has the. The keys to recover your wallet. So it's just a hash that gets stored on chain for the recovery process. You have to call it from a specific address. So it's part of the hash that it generates during recovery is using message sender. So you have to, let's say it's a multisig.
00:17:09.740 - 00:17:45.084, Speaker A: You'd have to have the people sign to call the recovery function as well as, I think, pass something else. So it might just be a salt from memory. And that just is a way for people to not sort of lookup addresses from known multisigs associated with you. So if you have the message sender and the salt, then that's the hash that's stored on chain. So we don't do the multisignature thing. We just say, if you're calling it from something that has multisig behind it, that's it. So, hopefully I just dodged the debate.
00:17:45.464 - 00:17:49.286, Speaker B: Is it mathematically provable that you answered his question? Maybe.
00:17:49.390 - 00:17:50.030, Speaker A: I'm not sure.
00:17:50.102 - 00:17:55.754, Speaker B: Does anyone else have any questions from the audience? Okay, one over here.
00:18:00.494 - 00:18:05.374, Speaker D: Hi, I'm wondering if batches are guaranteed.
00:18:05.414 - 00:18:48.190, Speaker A: To be atomic or in order, executed in order. There can be some concerns about front running something. No, good question. Yeah, so the struct is effectively a bundle and the bundles contain wallet operations, or call them user operations, which is similar to 4337 terminology. Inside an operation is an atomic set of actions that are in order. A bundler or an aggregator or pretty much like an l two node can shuffle operations around if they want. It makes no sense for them to shuffle your operations around because you've probably signed it in consecutive nonce order for our implementation currently.
00:18:48.190 - 00:19:24.284, Speaker A: And yeah, so they can put things between operations but they can't put them between actions. And again, it's atomic. So if you approve, and I think there was a recent tweet around, take back all your approvals, like stop approving everything to dapps here, you'll just be approving the amount that you'll be swapping, say in the example that you didn't see, and then doing the swap for that amount if the approved fails or the swap fails. Neither of those things have happened. So if you do a swap that fails, you've not left a sort of lingering approval there. So I've probably answered hopefully your question plus plus.
00:19:27.264 - 00:19:34.084, Speaker B: Okay, do we have any more questions from the floor? Ah, here we are.
00:19:35.024 - 00:19:38.604, Speaker A: Anything about applications, products and where people are looking, please?
00:19:39.134 - 00:19:52.558, Speaker D: Unfortunately not. So refer to this one. So what is the time that it takes for the bundled transaction to go in? So if I want to make a swap, it just takes time until price change.
00:19:52.606 - 00:20:37.454, Speaker A: So I'd say our aggregate implementation is kind of simple. At this point, we haven't put much thought in optimizing too many things. The sweet spot will be filling up an l two block and sort of having the period that we're always filling up l two blocks. So right now, because it hasn't got huge use at the moment, I think we wait maybe a few seconds and we say, look, if however many wallets have sent transactions in those seconds, those get bundled together and then sent. So it's just a simple delay. If we find that we have enough transactions to fill up a bundle or fill up a block, then we just send that straight away and then the timer restarts. So just a simple implementation for now.
00:20:37.454 - 00:20:42.454, Speaker A: Any more questions?
00:20:45.474 - 00:20:48.770, Speaker B: I guess then that's a wrap. Thank you very much, James.
00:20:48.882 - 00:20:49.754, Speaker A: Thank you. Cheers.
