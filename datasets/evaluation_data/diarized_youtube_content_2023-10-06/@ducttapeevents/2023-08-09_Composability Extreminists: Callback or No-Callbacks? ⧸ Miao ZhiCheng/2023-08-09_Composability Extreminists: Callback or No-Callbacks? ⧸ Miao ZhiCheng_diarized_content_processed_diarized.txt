00:00:17.800 - 00:00:59.136, Speaker A: Is everyone having fun staying pure today? Yeah, I really like this place and this means a lot to me. The paralympic polis and Yves Parag. And that's where we actually started the inception of the superfluid. So today we're going to talk about the callback or no callbacks. So nowadays I spend a lot of time for superfluid and superfluid is a composable money that can do streaming and mass distribution. So composability means a lot to us. In fact, I would say we are composability extremists.
00:00:59.136 - 00:01:57.404, Speaker A: So we go extreme, right? So I'll show you what do I mean? So what do we have got today here? So how many people here know about ERC's 777? All right, some. So it can be a good idea. So that a single transaction can do both send and extra action, right? What otherwise? I'll talk about otherwise how we do it. But with single transaction, you basically send a token to a contract and contract can implement some actions, right? So that's a good idea, but there's also bad idea part of it. So the changing the semantic of ERC 20 transfer in the actual standard. So they added extra semantic to the transfer. So what happened? The first Uniswap v one hack, a lot of money got drained.
00:01:57.404 - 00:02:28.694, Speaker A: Pretty. Nowadays it seems a very small amount, but yeah, that was big amount before. And also the same thing happened to landev me. So it's a similar thing. The reality is that there are not many ERC 777 tokens out there. In fact, super fluid tokens are the only ones and that's a reality. So in order to do an action together, you have to do the approve and transfer from.
00:02:28.694 - 00:03:06.674, Speaker A: I think many of us here hate it. You have to approve a contract and you have to do action. That's not nice. But in order to fix one of the bad ideas from the 777 standard, we create some little bit of dialect. So our token variations, we actually disabled that ERC 777 transfer semantic. So we just make the ERC 770 have the callback. So in fact, super token comes with more callbacks.
00:03:06.674 - 00:04:09.316, Speaker A: So before I go on, there's actually a very good genealogy tree study of the Yas 20 more detail you can find from our Monorepo wiki page, a page called about ERC 777. Kudos to our colleague Didi. So what are the new callbacks we added to super token? So we're talking about something called agreement lifecycle event hooks. So first give a quick overview. What is agreement? So in superfluid because we are composable money that supports money streaming and distributions. So we have to represent relations between accounts and their ongoing relations. So if I send you a stream of money and that relation is ongoing until time ends or I delete the flow, or the outside delete the flow.
00:04:09.316 - 00:04:56.614, Speaker A: So there's ongoing relationship between the accounts. And the way to calculate how much balance you have of your account is to aggregate all those agreements and their balance amount. In JavaScript, it would be like reduce all the balance provided by a list of agreements and sum it up in the end. So the implemented agreements, in our case, the first one I talk about money streaming, that's the most popular one. That's the constant flow agreement. So it's streaming money every second, I'm sorry, every block, we call it every second, that's every block from one account to the other. It's one to one.
00:04:56.614 - 00:05:37.866, Speaker A: But we also have a distribution, it's called instant distribution. So it's got kind of money fan out way of manufacturing on steroids. So the money distributed from one sender to any number of subscribers to that index, we call it. So there are all things we can introduce in this agreement framework. In fact, ERC 20 can be considered just an agreement, normal agreement. So your balance from ERC 20 is, can be fit into the agreement framework. We also have some experiment regarding decaying flow, like the radioactive decaying.
00:05:37.866 - 00:06:59.720, Speaker A: So there's a half life. So if you say that decaying period is one year, then after half a year the flow rate becomes half, and after another three months the flow rate becomes another half. Right? So there's a decaying type of flow can implement instead of the, as opposed to the constant flow, we also have a combination of the instant distribution agreement plus the constant flow agreement combined into something called general distribution agreement. So that, imagine that instead of sending a dividend to 10,000 accounts, I'm sending a stream of new type of dividends that goes to 10,000 accounts every block, right? So that's a new thing we can also build into the agreement. So that's agreement in a nutshell. So there's life cycle events for these ongoing agreement, ongoing relations between accounts, right? So let's use a CFA, the constant flow agreement, as example, when you send, when you send flow, a stream of money to another account, so that's when the agreement is created. So there is a before and after Hook callback.
00:06:59.720 - 00:07:28.428, Speaker A: But when you update the amount, let's say you are sending to $10 per month, then you update to $12 per month. There's update, there's also events there. But when you delete that flow, there's another event called agreement terminated. So there are various type of callbacks we are talking about here. It's called lifecycle events. So here's now we can become a composability extremist. So we have something called a super app.
00:07:28.428 - 00:08:30.828, Speaker A: So it is an on chain contract that implement the agreement lifecycle hooks. So all those hooks in previous slides I mentioned, you can implement the function to handle them. It enables atomic and transactional composable agreements. Let's see a couple of a simple example. So the first super app example is DCA, a dollar cost average. So the idea is that many want to invest every day, some USDC for BTC for example. So the way it's implemented is that when Bob stream USDC to this green box in the center, the super app called DCA super app, and it triggers a callback and it will trigger the callback that calculates how much Bob should get distributions in an ongoing basis.
00:08:30.828 - 00:09:22.494, Speaker A: So in the blue box it's, it's an exchange. So the DCA actually can go to the exchange periodically to convert some of the USDC for BTC. And the agent is the off chain component that actually triggers this constant periodical job. Then Bob or Alice who invested in this DCA super app will then get periodically distribution of the web rapid BTC simply by sending the stream of USDC to the green super app. The super app also needs to handling lifecycle events. Why? Because if Bob stopped the stream, then Bob should also stop receiving wrapped BTC. So as simple as that.
00:09:22.494 - 00:10:07.394, Speaker A: Without the lifecycle events handling then the app can be in danger of sending too much it needs to send back to the bob. So there's a kind of accounting accuracy here. It's enabled by this new type of applications powered by callbacks. Another example, it's a referral link app. So there are three actors in this space. So there's the merchant and there's marketer for the merchant and there's a buyer. So the buyer sends a stream for money to buy a service from merchant through a link that is shared by the marketer.
00:10:07.394 - 00:11:03.778, Speaker A: Then marketer automatically get a certain percentage, let's say 10% of commission so long as that ongoing purchase from the buyer to the merchant is ongoing. So that kind of atomic compose stream enable this kind of scenario, that marketer get a commission so long as the purchase is ongoing. So that's a super powerful thing enabled by the callbacks again. Right. So what are the problems though? Right? First callbacks are scary, right? Callbacks can introduce a reentrance issue. Everyone see quite often from time to time there's a reentrance hack and a couple million gone here and there, right? So it's scary but not necessarily scary if you do it, right? So in addition, the bad design can be a breaking change to the example is the ERC 777 transfer. So it can introduce bad design also.
00:11:03.778 - 00:11:31.236, Speaker A: And the list of EVM related exploits that are related to the re entrance issue is a lot, right? So it's scary. In short. So the solutions to the callback problem, right. The first is not really a solution, it's just to avoid it. I think that's many projects go with that, just don't have it, right. But to actually make it better, you can apply the idiomatic programming pattern. So be more careful when you do the programming.
00:11:31.236 - 00:12:27.444, Speaker A: So the check effect interaction is a common pattern. Reentrance lock is another hatch hammer that you can solve this problem just by having a mutex and avoid re entrance altogether. Not related to EVM, but in other account model like Eutxo, they can also they solve it differently because they limited side effects. But I'm not going in detail, we're in an ethereum conference here. One of the problem I didn't mention though when I talk about a super app is that we need to give an exit guarantee. Why? Think about it. If you send a stream to a super app and super app has a callback to handling the termination, but what if the super app refuse to close your stream? You kind of keep sending to the app and app refuse to close your stream, you are losing money forever.
00:12:27.444 - 00:13:05.854, Speaker A: So in the super fluid system we need to give such guarantee that the app should never be allowed to do that. So if you want to and the ongoing relations the stream of money, you should always be allowed to do so. That's the problem. And we have a very peculiar system called geo system. So if the app violating that exit guarantee, the app would be marked as something criminal, right? So it's most likely faulty, right? So it should be marked like that. So that should be stop functioning. So that's how we give the exit guarantee for the agreement.
00:13:05.854 - 00:13:40.328, Speaker A: But let's look back. So let's slow down a little bit. So let's look back what is actually composability before we analyze a bit more. So if you go to Google and search. If you go to a search engine and search, what do people say about composability? Actually a lot of web3 links pop up web3 industry web links pop up. I was wondering if it's because my search engine was biased and then I disabled the cookie, went to private tab. Actually a lot of links from web3 people.
00:13:40.328 - 00:14:19.160, Speaker A: So I think we are contributing a lot to the Internet. So it's not a bad thing to call us web3, I guess. So there's research from multicoin, there are research from Aragon, there are things from future.com that people say a lot of about composability, a lot. So you can search and find these links and you can have a read about them. So, but in the other world, the non web3 world, there are already established definition actually for a long time about the interoperability model. So this is one of the conceptual models.
00:14:19.160 - 00:14:37.256, Speaker A: It looks very similar to the network model, if you're familiar with the OSI model. Right. So there is a, the lowest level would be no interoperability. The first level would be, technically it's called integratability. Then the next level would be interoperability. The next level would be composability. All right, this is all abstract.
00:14:37.256 - 00:15:16.734, Speaker A: If you're interested, you can search about, it's called conceptual interability model. Let's map that to ethereum world. What does it mean? So the layer one technical and L2 syntactical integratability reflects to these instruments we use from EVM. So there are EVM op codes, opcodes, that is for interacting with Ethereum contracts. So you have a static core for read only in Vue cores. You have a delegate core for letting other code to manage the call as a storage. Then you have the actual core for the internal transactions.
00:15:16.734 - 00:16:11.172, Speaker A: Those are the technical instrument could use for composability in EVM level. EVM also transaction also is automatically rollback, which is a feature you will use a lot in the in superfluid, right? Because if it doesn't rollback, then you can't have atomic transactions. So that's the lowest level. Then the next level would be semantic level and the pragmatic level, programmable level. So there is usually we rely on the a solid ABI contract specification. But the attention is many people tend to forget that you don't need to send all the messages using the isolated API specification. Actually you can send some even under the radar transactions that the baby block scanner wouldn't be able to even decode it because you can totally bypass the API decoder.
00:16:11.172 - 00:16:54.554, Speaker A: And there might be even, I don't think they have, but there could be decoder, bug form solidity, contract abi solidity decoder. So that's just some attention that it's good to remind yourself when you look at this kind of layered approach. Through this layered approach, the last bits interesting part will be the composability you have, the dynamic and conceptual. So how do you achieve that? First write your code very modular, distribute your through the open source, ethics can verify the source code. Then people can start to compose it with your contract. And better to be autonomous. Also permissionless, so that you don't need other people don't need your permission to interact with your system.
00:16:54.554 - 00:17:21.704, Speaker A: And discoverable provide example code is just a basic way of making it discoverable. But maybe we can also borrow something from the web 3.0, the one before. What if we can self document to the contracts and then it can be discovered automatically by other contracts to do the interaction. So it's just a suggestion, maybe we can think more about it. So a couple of patterns and examples. Let me go quickly.
00:17:21.704 - 00:17:59.424, Speaker A: So one important method to make your system composable by others is to adopt existing standards. So ES 20 is the best example. It has a vast ecosystem, it has a wallet supporting it, defi supporting it, Uniswap support all sorts of ERC 20 tokens. Then you have block scanner supports it natively, the ERC 20. So by adopting those established standards you are composable by others. And 777 is actually opposite example. It is a standard, but it has no adoption.
00:17:59.424 - 00:18:32.802, Speaker A: We made a mistake to use it, but we are the only one actually using it. Things like 27 71 is a good way to make your contract to support native meta transaction, for example, that's basically padding the message sender in the core, in the hidden core data. A plugging approach is another one to be composable. ArDA is one of our baby projects. Before superfluid. We have also something called a strategy. Way before yearn has a strategy, but we only implemented a compound strategy, unfortunately.
00:18:32.802 - 00:19:18.060, Speaker A: But yarn has like 250 strategy or something I just lately checked, right? So that's plugging. Quote quote plugging super fluid agreement is another type of plugin. We're adding more features without breaking the interface per se, right? Transactional system is where the callback coming from, right? Or the our super apps are using the transactional concepts, right? So if something happens, something else should happen. Also if one fails, it should revert. Flash is another type of transactional system. If you can make a profit, finish transaction. If not, revert everything, right? So conceptual system is going even deeper, right? So you have to have different components, they work together become an even more conceptual level of composability.
00:19:18.060 - 00:20:00.636, Speaker A: All right, I think I'm running out of time, so I'm not going to go through how we actually did our control flows. I'm going to go just talk about the last conclusion. So my conclusion would be composite is powerful and worth effort. Callbacks are powerful and worth effort. And it's not new problem. I think I would encourage everyone look into the existing in other kind of non crypto industry, how the history evolves regarding composability. Learn from them and it's not a new problem.
00:20:00.636 - 00:20:33.984, Speaker A: We can join insights from the past and there's more than one way to achieve composability. So that's my conclusion today, and thank you. If you want to know more about and want to be part of it, join superfluid, of course. And we have a bug bounty on immunify. If you want to check our contracts and maybe help us to improve the security, start hacking superfluid money, go to our Monorepo superfluid finance protocomonorepo and the presentation source code. It's also available on our wiki page. So thank you very much.
00:20:33.984 - 00:20:44.144, Speaker A: Thank you very much. Meow. Does anyone have any questions from the audience? Ah, we have one question. We have time for one.
00:20:44.604 - 00:21:08.404, Speaker B: Wait for the jingle to finish. Hey, I was wondering about, well, generally I was curious about the jail thing you were talking about and kind of related to that, the idea of if you can forcibly remove a token from a contract, how can you do that without kind of like potentially breaking internal accounting of that contract?
00:21:09.344 - 00:21:19.384, Speaker A: Yeah. So once the contract is jailed, that kind of internal accounting of that country is no longer guaranteed. Right. So, yeah, that's a simple answer.
00:21:20.924 - 00:21:33.864, Speaker B: Okay. The jail thing, is that like something that's automatically like, you can detect if a withdrawal fails or is it something that requires like governance or manual intervention to like, jail a contract?
00:21:34.684 - 00:22:05.444, Speaker A: So there's a couple of rules to determine if the app should be jailed, if that's what you're asking. So the jail rule are very black and white. It's all in the smart contract. So basically, if you revert in the callback, in the termination, it got jailed. Or if you run out of money as an app, you also got jailed. And there are a small list of rules that automatically trigger the jail condition, then the app basically got broken. Yeah.
