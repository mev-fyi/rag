00:00:01.080 - 00:00:29.814, Speaker A: Good morning, ETH Prague. Welcome to the Institute of Crypto Anarchy. I am Camille and I love you. You are my family. Thank you for being here. Next up, we have crossing the interoperability bridge, a deep dive into building interoperable daps with IVC. Welcome, guys.
00:00:32.674 - 00:00:54.114, Speaker B: Thank you. Hey, guys. I'm Daniel. I'm a lead product at Evmos. I usually ask our team why we're doing things, and we're going to talk about building applications that are interoperable. Feder, do you want to give an intro to yourself?
00:00:55.094 - 00:01:40.062, Speaker C: Hi, everyone. I'm Federico. I'm the co founder of Evmos. I've been in the Cosmos ecosystem since 2017, where I started first building the Cosmos SDK and later was part of the core team that shipped IVC. IVC is an inter blockchain communication protocol that powers most of the interoperability in all the cosmos ecosystem. And today, we're going to be doing a deep dive into how Evmos leverage IVC in order to build smart contract interoperability. So after that tank twist crossing the interoperability bridge, we're going to do this deep dive into IVC and how fmos comes into the, into this game also, maybe.
00:01:40.118 - 00:01:57.594, Speaker B: Originally we had planned to do a workshop that's hands on, but since it's the last day and probably everybody's already started hacking other projects, we have more like a presentation format, but we have a bunch of today tutorials online, and we're also going to play a video in the end. But yeah.
00:01:59.534 - 00:02:58.844, Speaker C: Awesome. So today we're going to be talking about why there are so many chains. Why are different chains specializing in different use cases? How do EVMs come into play, and how does this impact overall user experience? Then we're going to be talking about why interoperability is important. Why is it necessary today more than ever, to build interoperability standards to allow these smart contracts and applications to talk to each other? We're going to see the consequences of an ever increasing number of chains. Layer two is included. Then we're going to do this deep dive into the IVC protocol, explaining how it works and also talking about, of course, evmos and how we take interoperability to the next frontier. And how do we enable smart contract interoperability through IVC to connect not only to smart contracts, but also to other chains in the cosmos ecosystem and the EVM world.
00:02:59.344 - 00:03:10.304, Speaker B: Maybe a quick check in. Who knows IBC has ever heard of it? Okay, that's quite some people. So you guys are familiar with the cosmos ecosystem in general? More or less.
00:03:10.424 - 00:03:11.204, Speaker C: Somewhat.
00:03:11.694 - 00:03:14.674, Speaker B: Yeah, that's good. We'll talk about it more.
00:03:16.534 - 00:04:37.836, Speaker C: Okay. Today. Why are there so many chains nowadays? Back in the 2015 era and 2017 era, where all these icos started booming, the only choices for developing a new platform or a new project were either forking bitcoin in the early days, like, for example, ccash, and on top of that, adding privacy on top, litecoin, et cetera. Until Ethereum came into the, into this world. And through Ethereum, people now start building smart contract on top of the same platform, which was great. You can build different applications, different use cases, just by writing your smart contracts. And this was like a shared stack until in 2017, Cosmos announced its vision for an interoperable world of smart contract, where the premise here was there should be applications that are not only able to live on a shared virtual machine, but should also have full ownership and sovereignty over the entire stack.
00:04:37.836 - 00:05:59.394, Speaker C: That means that using an SDK or a programming framework like the Cosmos SDK, in this case, you will be able to write your own application specific blockchains, or app chains, as they're called, and interoperate with other applications through this interoperability protocol called IVC. So instead of going through a horizontal scaling, we shift the model to vertical scaling, where you handle more gps, you handle more validators or nodes that are participating in consensus, you're just scaling horizontally via an interoperability protocol. And this is key to understand that on Ethereum, we find all these smart contracts that are able to share code with each other. You're able to call other smart contracts and compose on top of each other the money legos, the DeFi legos as we know them. But with interoperability, that's also a missing case. So once we started seeing an ever increasing number of applications, layer twos, specialized for different use cases, we're starting to have these user experience problem, as we see here. So we have, like, for example, aave or curve that are now deploying to multiple environments, multiple EVM chains.
00:05:59.394 - 00:06:08.234, Speaker C: And that also comes, that's also affecting the overall user experience.
00:06:10.614 - 00:07:12.368, Speaker B: I guess. Another check in. Like, do you guys actually use all of these chains when you're using curve or aave? Any opinions? Is this something that you're excited about, or do you actually care? Okay, no strong opinions. Okay, well, we believe. Okay, so you said you care because there's different features or functionalities, and you mentioned liquidity. Is that the only thing? Because usually we talk about the EVM compatibility between those chains, so that's easier to deploy the same application or same dapper. On multiple chains.
00:07:12.368 - 00:07:31.684, Speaker B: Is there anything else but liquidity? Okay, it's good to know because our goal is to basically remove that selection for the end user. So overall, Ux is becoming more and more important. And so we're pretty aware of that.
00:07:33.304 - 00:07:34.896, Speaker C: Yeah. So this is.
00:07:35.040 - 00:07:36.278, Speaker B: Wait, there's another one.
00:07:36.376 - 00:07:38.494, Speaker C: Does that mean at the end of the day.
00:07:40.234 - 00:07:50.014, Speaker D: What chain you're on would become predator? Does that mean, at the end of the day, what chain you're on would be relatively transparent?
00:07:50.714 - 00:08:16.182, Speaker B: I mean, ideally, as a user, you just show your intent of what you want to do or the program, and you're not really concerned with the network, but you have to have some entrance point. And then what happens on the background, depending on which chain it is on, is really not of your concern. Actually, that's why I say it's like the selection, the dropdown shouldn't be there.
00:08:16.358 - 00:08:17.394, Speaker D: Nice. Thanks.
00:08:17.814 - 00:09:15.682, Speaker B: I mean, what you see here is in the cosmos ecosystem, we have so many chains popping up because they are optimizing for one specific application. They're application specific blockchains that allow for sovereignty. They have their own token, their own validator set, their own community as well. You could see them as all individual daos. And that's actually really interesting. The cosmos ecosystem is trying to basically build this scalable way of new chains that are opting into connections with other chains, but they could, you know, has, like, very good security, implement implications. You know, if one chain dies or something goes wrong, it actually doesn't really affecting other, other chains.
00:09:15.682 - 00:09:39.254, Speaker B: And so in the cosmos ecosystem, we're really trying to tackle the idea of scalability in a very different way. Whereas on Ethereum, it seems like everybody's kind of, you know, building on Ethereum until it becomes expensive or it's not really scalable. And that's how we're coming, basically from two different sides and trying to connect them.
00:09:39.674 - 00:10:37.170, Speaker C: Basically, the layer two vision for Ethereum is what cosmos initially envisioned as like, okay, you have application specific blockchains that communicate with each other. Now you have layer twos that are specializing in privacy. You have rollups that implement optimistic rollups, ck rollups. And then maybe there might be some layer twos that are only specializing in one specific category of applications, say Defi or NFTs or Refi or DaO tooling. For example, neosis chain is really big on Dao, on dao tooling, on Dao frameworks. So there is going to be a transition into going to the niche of your users and targeting that niche and having interoperability come into play. And of course there is scalability concerns and of course composability concerns.
00:10:37.170 - 00:11:37.018, Speaker C: Because now the legos that were previously available to you on Ethereum, all these smart contracts, amazing smart contracts that now are very expensive to run, are not available to you on your EVM. So how do you go about it if you want to build an amazing application that requires chainlink, but Chainlink is not available on your EVM. Now, you can't build a lot of the DeFi primitives like landing markets. So how do you interact with other chains that do have these oracle services in order to compose and build on top of that? And that's what EVmos is trying to do. So we saw that onboarding users is really hard. Users don't need these, like don't need to choose which platform they're in, what wallet they're signing. There are like different standards for signatures.
00:11:37.018 - 00:11:55.284, Speaker C: So ideally these should all be obstructed. And basically, as Daniel mentioned, based on the intent, the application should be the one directing to the corresponding chain or to the corresponding smart contract on different evms.
00:11:58.704 - 00:12:56.852, Speaker B: So this is just an example, because like I mentioned, you can come into the cosmos ecosystem or ethereum from different angles. Either friend tells you, sends you some ETH, or you're in some testnet or a developer. There's just so many multiple angles and communities to tap into. And so onboarding users are really hard, depending on the previous knowledge that they have, and maybe also if they already own some crypto in a different ecosystem or just are trying to on ramp from fiat. So that's a problem that we're really aware of in the cosmos ecosystem. And we have, I guess also our front end or our application where we want to unify this onboarding experience and help users. And we really understand that building assistance or co pilots to lead users through that experience is quite important.
00:12:56.852 - 00:13:19.284, Speaker B: And the whole goal is basically we want people to onboard just once to crypto in general or to. Yeah, to crypto in general. Basically, instead of having to force people to download multiple wallets or have this notion of like ten different accounts depending on which chain you're on.
00:13:19.584 - 00:14:23.426, Speaker C: So basically the premise is, okay, I want to onboard to evmos, I want to use a smart contract application on evmos. I have tokens somewhere else. How does the front end know where those tokens are located and through which route to route them through evmos in order to start using that decentralized application? Then once those tokens are in fmos, what happens with the fmos tokens that you need to pay for transaction fees. So that's another limitation. So like in the user journey towards onboarding, specifically from other chains, you need to take into account like different routing mechanisms, different cost associated for the transaction phase. First, in the ethereum world, like for example, if you're bridging directly from Ethereum, but then there's the other concern that maybe avmos is not your last stop. Maybe it's like you're routing tokens through avmos to the rest of cosmos ecosystem chains.
00:14:23.426 - 00:16:10.624, Speaker C: The so what happens afterwards? Do you need to send another transaction like bridge to Evmos, then another transaction to somewhere else? That's a painful user experience, and that's why we're trying to work with these core technologies around interoperability that are going to be hundred x the overall user experience, not only for us, but in general for the entire ecosystem. And our hope is that in two to five years, everyone will start using these smart abstractions for transaction fees for routing through the ecosystem based on the shortest path or on the cheapest path to a destination on another counterparty chain. So this is our first attempt to also improve the discoverability. So before you onboard, you need to have an intent. Okay, what am I going to do on fmos right now? And for that, discovering what the possibilities are is really important. And on evmos, we're trying to push for our Dappstore, which is showcasing in the same way that you might experience with your Google Play or App Store on your phone, showcase the different developers the latest news leaderboards in different categories for DeFi, Gus Guzzlers, what are the most used or more popular smart contracts being interacted with. We're also showcasing different content that is going to be an announcements that are going to be created by these different teams.
00:16:10.624 - 00:16:23.514, Speaker C: And this is like our first push to declare first the intent and then through the onboarding experience that we just mentioned, attract more users to the evmos ecosystem.
00:16:24.574 - 00:16:42.274, Speaker B: Yeah, I think the idea of this also is if ecosystem dapps that you see listed here shouldn't be just deployed on the Evmos chain, you could also think this is the ethereum, Dappstore or whatever, but the point is you don't really know where these applications are actually hosting their code.
00:16:46.134 - 00:18:21.512, Speaker C: The second big topic that we are working on, besides onboarding new users into our ecosystem, is changing the mindset from going cross, from going multi chain like deploying different instances in different EVM chains, to just being cross chain, deploying once and having these interoperability obstructions to work everything for you and not having to suffer this user experience of going through the dropdown and interacting with multiple blockchains, that might be helpful for overall user experience. So this is how it looks like today. We took the example of AAVE. So today you can interact with AAvE on different evms, different layer twos, mainnet on Ethereum, et cetera. But aave not only has one single version deployed, it has multiple versions. And what was being described here before is like, ok, you have access to different functionalities, but what happens with the engineering team that needs to maintain, keep track of all these new functionalities? They need to have separate instances with that specific functionality on different chains. And moreover, not only for the engineering team that needs to maintain more instances and keep track of like any breaking changes, any upgrades, specifically on EVM chains that are not using nakamata consensus, but are using like BFT consensus, they need to keep track of that.
00:18:21.512 - 00:19:47.018, Speaker C: And also for the community teams, what's going on in terms of governance, how our community, like our Aave community, is getting involved in all, all these different instances on all these different chains. Am I participating in governance? Are they able to participate in governance? You have snapshot that is deployed on Ethereum for voting. How do you manage snapshot across different instances as well? Do you need to submit a different integration for every single EVM chain? So those are the questions that today a developer needs to ask themselves if they want to go with a multi chain strategy. But the ideal case scenario we're talking about two, five years again from now, is like you only have one instance, one instance that your team needs to deploy, and you can access it from every single EVM chain, every single cosmos chain, every single smart contract. Not only solidity or like EVM based smart contracts, but also wasm smart contracts, JavaScript smart contracts, Solana smart contracts, and you can, through the interoperability, compose and build on top of it. So this is a vision, the longer term vision that we're trying to aim for is like deploy once, connect with everything. And this is why it's so game changing and why it's so important, the interoperability.
00:19:47.018 - 00:20:00.294, Speaker C: That besides all the user experience, it also brings huge benefits for the entire development teams and the entire. You don't need to hire five community managers, one for each ecosystem.
00:20:04.554 - 00:21:04.324, Speaker B: Sounds good. So the idea is when you just deploy once, or when you are trying to twice. Actually, when you're trying to create a new application and trying to build a new application currently in the cosmos ecosystem, one way is to do it. You just launch your own chain, have some custom core protocol functionality. Maybe your application is baked into the protocol or you're running a vm and building smart contracts. But the idea is it comes with a bunch of problems, right? So Fader was mentioning earlier, you actually, every time you build a new chain, you'd have to rebuild certain basic applications to have a rich defi ecosystem or any other. Just defi is the most prominent.
00:21:04.484 - 00:21:05.604, Speaker C: The primitives.
00:21:05.724 - 00:22:09.794, Speaker B: The primitives, the building blocks. And so if you have this notion of being able to access data or I guess liquidity on other chains, you don't really have to think about and worry about bootstrapping these basic building blocks. So basically we're rethinking the way that we also measure, I guess, the success or the activity on a chain. A lot of chains are thinking about, okay, how do we optimize TVL or just use that as the main measurement of success and maybe also possible revenue methods. But for us it's actually rethinking this and we want to make sure that people just think about access. You don't need to build a protocol like always launch your own token and then optimize for TVL. It's rather how do you reuse components or liquidity that other teams already have built up, basically.
00:22:09.794 - 00:22:47.194, Speaker B: So it's kind of like, if you think about it, every chain could be like a different API or different service that you can have access to. And I think the UX point, I mean, we mentioned it quite often already. One big idea is that you don't need to be concerned with paying transaction fees in different tokens. You can just onboard once to your one favorite token, maybe Evmos, ETH, whatever, but you just connect it once and then you're paying transaction fees for services, even if they're on other chains with that token. And that provides just a better user experience.
00:22:47.354 - 00:23:51.078, Speaker C: Yeah, the access to liquidity part that Daniel just mentioned is very important right now. Everyone knows you don't have wrapped usage first. You don't just have Ethereum, you have wrapped ETH, stake ETH and different denominations of liquid staking Ethereum. So in that sense, the original token, the ETH token is now fragmented across different denominations, only on Ethereum. But what happens then when you bridge them over somewhere else and then like, it fragments the single token even more? So now you have this initial pool of tokens, the ETH token that is scattered around different denominations everywhere in the ecosystem. So how do you access that liquidity? You can't just build pools that have the initial value of the tokens, but you need to work with what you have on your local chain. And that's the concept of total value log, the TVL that a lot of chains are trying to optimize for.
00:23:51.078 - 00:25:46.066, Speaker C: And our shift of paradigm at Evmos is not how can you build more TVL natively on the chain, but how can you access that liquidity that is scattered everywhere? So how do you enable a smart contract that lives on a chain that doesn't have these DeFi Legos that I mentioned that you need in order to build your smart contract and doesn't have deep liquidity for your application to exist? And this shift of paradigm allows us to rethink how these smart contracts should be interacting, not only with other smart contracts in other chains, but with application specific blockchains like osmosis, which is the main Dex app chain in the cosmos ecosystem, to access that liquidity via interoperability, getting those tokens back and then using them for whatever use case they might, they might need. So access to interoperability is a keyword, not total value locked on a single chain. Let's expand from the constraints of the single EVM and look beyond that into what's over there, scattered and fragmented in the rest of the ecosystem. And so that brings us to our next topic, which is the inter blockchain communication protocol that I was allowed to be part and built with the rest of the interchange team. So the inter blockchain communication protocol, I'm going to go explain what it is. But basically you have in this case, two chains with their own validator sets around 100, 100, 5200, 300 validators coming to consensus and validating blocks. So the main thing is like, okay, bitcoin solves the double spending problems.
00:25:46.066 - 00:26:55.014, Speaker C: Right? Now, when you're thinking about cross chain, how do you solve the double spending problem? But when you transfer over to another chain, so how do you prevent this issue? And for that, you need to be able to validate the state transitions or the transactions. Moreover, on one chain, on another chain, and for this is critical, the role of the lite clients. So lite client proves there's an actor in between. That I'm going to explain right now that runs lite clients of both chains and is able to verify the state transitions on chain a and chain B and constantly update the latest state updating. For example, updating the state of the chain a for chain b and vice versa. And with that, you're able to verify that a token has been locked, a token has been released, a token has been minted, or a token has been burned. So how does IVC work? The concept of IVC first was meant to be defined in the same way as the Internet protocols with different layers.
00:26:55.014 - 00:27:32.604, Speaker C: So you have the proofs that are like Merkel proofs to be able to verify the state transition. That's called ICIS 23 here. Then on top of that, you have the like lines. The like lines are, as I mentioned, the key components to be able to verify state transitions between the different chains. So there's one relayer here in the middle. I'm not sure if this is here. Here, the relayer in between is able to run the lite clients for both chains.
00:27:32.604 - 00:28:12.036, Speaker C: So this is like the bottom layer clients, IVC clients, and the light clients for the different chains. And on top of that, you have the connection. So connecting one chain to another is the next primitive. And then on top of that, have channels. So what am I connecting right now? You had the connection between one chain and another. And then I'm connecting, for example, the transfer logic, like the state transition for balances. So that's, that would be, for example, okay, I want to transfer some tokens from my chain, chain a to chain b, or fmos to osmosis.
00:28:12.036 - 00:28:40.218, Speaker C: I'm updating my balance on evmos, reducing it. I'm putting it on an escrow. That Merkel proof is submitted via the relayer. The balance is updated on the chain, on osmosis, on the receiving chain, you get an acknowledgement back that the transaction was successful. And then that token that was held in escrow is then burned. And that's how it finalizes the state.
00:28:40.266 - 00:29:03.098, Speaker B: Transition, I guess, for the channels. I think right now, basically, you set up a channel for different packet types. And the one that's mostly used is the transfer. But actually IBC is data agnostic. So you could send any kind of data that's encoded. I just wanted to mention that.
00:29:03.226 - 00:29:53.678, Speaker C: Yeah. And on top of that, you have the application layer. After you set up, you have the proofs, like clients connections between two different chains, channels between two different smart contracts or modules in the cosmos world that are able to decode an encode data, the packet data that is sent over in this envelope, this packet. And then you have the application that handles that specific data that has been decoded once it's received. So that's how the IVC stack works. So it's not very clear here, but the cross chain user experience. You have two models for cross chain user experience.
00:29:53.678 - 00:30:42.382, Speaker C: One is using an application, an IVC application that is using a specific channel. So, for example, I want to send tokens from my chain to evmos to osmosis. And what I do use is here's the interchange agent talks to the IVC transfer module with an IVC transaction that declares an instruction to transfer. But what happens with, and that works for transfers like bank balances that need to be updated. But what happens with other transaction types like staking if you want to vote on governance for another chain, or if you want to. What's this? I don't see it.
00:30:42.558 - 00:30:44.274, Speaker B: CTP, CDP.
00:30:45.174 - 00:32:09.944, Speaker C: So like other whatever modules you might want to build and for that cross chain user experience, going back to the same problem, like how do we remove this need of having to switch different networks is just having one single account on evmos that now through smart contracts or on your behalf is able to send instructions everywhere to submit different transactions. So you remove this dropdown completely and just use evmos and you're able to send instructions for all the different chains that you have tokens around for all your portfolio tokens. And then you are able to send IVC transactions, for example the transfers and non IVC transactions that are local to that specific chain. For example staking or sending a governance boat or sending a CDP action. So those are the two different UX models that we have right now. One is like just using an IVC application, which is perfect specifically for the use cases of like just using it once. But if you want to manage something on the medium term, you can use interchange accounts which will allow you to manage your portfolio without having to leave the receiving chain.
00:32:09.944 - 00:33:04.518, Speaker C: So going back again, transfers, I wanted to send a transfer over, transfer to the receiving chains on, for example, osmosis, evmos, osmosis. The balance is updated here. You send a receipt here and you can have that token sent back to you, or it can be kept here. So one single action. Let me finish this and I'll give you the word. And for more management or management over your portfolio, you can just send the instruction to the receiving chain for all these different interactions. The zone, that's like a standalone blockchain, right? Yeah.
00:33:04.518 - 00:34:01.640, Speaker C: And the interchangent, is it a part of the full node implementation of that original blockchain? So the interchange here, it was defined as such because it's either a user, like an EOA account, externally owned account, like a user, or a smart contract. So imagine this is a user just like a person here interacting with the IVC module and so on. A, but it can also be a smart contract and a user here interacting with that smart contract or series of smart contracts that are using the IVC module transferring to the corresponding chain. It's already implemented on Cosmos, but so.
00:34:01.672 - 00:34:37.053, Speaker B: Just so it's on record, he was asking if IVC has to be implemented on the zone, right? Is that the question? Yeah. So you're asking where does IBC kind of, where is it implemented? So every zone on Cosmos can decide to just inherit the IBC logic, but it's part of the node, basically like the full node.
00:34:38.553 - 00:35:16.874, Speaker C: We're going to talk a bit later. How can you leverage IVC being a smart contract solidity developer so you don't have to implement all this logic? This is already obstructed for this, and you just use solidity interface with the Avis. So evmos working on these three main items is taking interoperability to the next frontier. Working on these different use cases, particularly around onboarding UX and access to liquidity. We're going to be talking a little bit about that now.
00:35:20.934 - 00:36:10.932, Speaker B: So, I guess, I mean, we mentioned evmos quite a lot. For those who don't know, we originally created ethermint, which is the EVM library, which has been used by not just ourselves, but also other chains to actually launch their EVM chain, especially in the cosmos ecosystem. And we only see actually more and more EVM chains emerging. So that's kind of our thesis, why this interoperability is super important and also setting the standards of how these chains will be able to interact with each other. And it's really interesting to be here at ETH conferences. And last week we went to gateway to see how also different the communities are. So for us, it's quite nice to bring these worlds together.
00:36:10.932 - 00:37:26.874, Speaker B: And we chose to build the EVM implementation, or use, I guess, an EVM implementation in the cosmos ecosystem to combine both of the best parts of those two worlds. So composability through smart contracts from the EVM, but then things like sovereignty or, you know, the whole scalability of the Internet, of blockchains in the cosmos ecosystem. Okay, it's a bit hard to see, but basically, the EVM extensions are the functionality that we're building to allow for interoperability from the EVM. And without these EVM extensions, you have, you know, your, maybe your smart contracts deployed on the EVM, but they're pretty isolated. You don't really have access to data outside or liquidity outside of the EVM. Smart contracts, as Feder mentioned, can talk to other smart contracts or eoas to those, but they're pretty contained in the EVM. And the EVM extensions are basically the gateway for smart contracts to access core protocol functionality such as staking, voting or IBC.
00:37:26.874 - 00:38:26.886, Speaker B: And so this means you can tap into, for example, if you want to build like a staking index through smart contracts, that as a user or smart contract, you could automatically stake or delegate your tokens with a subset of validators. Instead of having to choose, you could build subdivisions with voting and governance functionality. Like a lot of different possibilities. But I guess for this talk, the more important one is really the access to IBC. So you can have your smart contracts deployed on the EVM, but then send data to smart contracts on other chains, or basically create your own packets and define what kind of data you actually want to send. Right. So the EVM extensions are something that we already, you can already use on Testnet.
00:38:26.886 - 00:39:08.404, Speaker B: We're running through some audits and then going to Mainnet. But one of the first things that we actually want to enable are these things called outposts. So outposts, basically, imagine you're on fmos and you have another chain like osmosis. Osmosis has the most primary Dex in the cosmos ecosystem. And in outpost, you could build an osmosis outpost on the Evmos chain. So this is basically a smart contract that users or other smart contracts can interact with to use the Dex, to use osmosis. So it's done through IBC middlewares.
00:39:08.404 - 00:39:52.134, Speaker B: If we go think back of the slide we had where you do the cross chain transfer over IBC, somehow it has to be understood, right? And these middlewares basically take the packet and just forward it to the smart contract or the place and the VM that actually going to execute the logic. Let's run through some two examples. So we have stride and osmosis. Stride is really cool. They do liquid staking as a zone. So you could liquid stake your evmos, but also atom or any other token in the cosmos ecosystem. And they have a really great user experience.
00:39:52.134 - 00:40:53.576, Speaker B: So if you haven't used it, go for it. And what you do right now is you actually have to send your fmos token with one transaction to the stride chain. Then you do another transaction to, to liquid stake and then basically send the liquid stake tokens back to atmos. And they already optimized this to almost basically one transaction for end users. But with an outpost, you could do this in one transaction from the fmos chain being connected to the FMOS network. It's pretty subtle, but basically what we did here is usually you're connected with your stride address, but the big change is you just connect it to the FMOS network and you can pay, like I said, transactions fees with the evmos tokens. And then just sign one transaction and get back your liquid stake token on the fmos chain.
00:40:53.576 - 00:41:53.074, Speaker B: And that's just from end user's perspective. But you could also write smart contracts that get the liquid stake token and then use it. Otherwise, maybe deposit it in forge. It's like a uniswap V three fork, or do anything else for getting more yield. So this is what kind of would look like. So basically you're connected to, like I said, or just showed to stride, or you're opening the stride interface, but you're connected to the FM's network with any of the wallets, Kepler metamask or ledger. You send an EVM transaction that talks to the stride outpost contract, which then talks to the EVM extension, and then it will perform an IBC transfer with the asset, with evmos in this case to send over and then stride, just like an API would execute the liquid staking logic and send back the liquid stake token.
00:41:54.454 - 00:42:08.254, Speaker C: What's important here is after you send the first transaction, usually you receive an acknowledgement back. So if your transaction was successful or not. So that's what smart contracts use in order to verify that the transaction.
00:42:10.274 - 00:42:10.586, Speaker B: That.
00:42:10.610 - 00:43:10.434, Speaker C: Can use in order to have some conditional logic. If the acknowledgement was successful, then execute the next logic or the next steps. But the acknowledgment itself doesn't get the tokens back. It's actually another like as part of these first transaction that we went through here, you get the acknowledgement back, but the tokens is actually like another transfer of those liquid stake evmos back to evmos. But then what happens with the smart contracts that needs to handle those? And that is handled by the IVC callbacks that I mentioned before. So it's pretty complex from a technical implementation point of view, but we've abstracted all these user experience of three transactions into a single one. And not only allowing end users to interact with an interface on another chain, but also allowing smart contracts to compose and build with a leakage taking application.
00:43:10.434 - 00:43:23.474, Speaker C: So basically these DeFi Legos that I was mentioning before are now accessible through this outpost model that allows you to compose with not only smart contracts, but with external chains.
00:43:24.534 - 00:44:19.734, Speaker B: Yeah, maybe we don't have to go through it too much, but this is pretty similar. So you would be having an osmosis outpost on evmos. So as a user you onboard to evmos, and then you can use a Dex to swap tokens, for example. So you're not connected to OsMo, but with your Atmos address going to the next slide, pretty similar. You'd have an osmosis outpost smart contract that you can interact with. We used the standard ics 20 packet, which also has a memo field that's kind of like a hack that is being widely used to basically send the right information to handle the call on the middleware. And so you'd send the fmos token with your intent that you want to have atom, for example, swap it on the Dex and then send that back to the original chain.
00:44:23.154 - 00:45:38.036, Speaker C: So we talk about how to compose with app chains in the rest of the cosmos ecosystem. But one key part is smart contract. So what happens when your smart contracts now wants to build and compose with other smart contracts on the interchain ecosystem? And that has always been a major limitation of IVC, because it allows for these simple applications right now of just sending tokens. But we want to take it to the next level and be able to compose with smart contracts not only in solidity, but also in other VM frameworks like Cosmo WaSM, which is a WaSM implementation of Cosmos, Solana, Polkadot, etcetera. So how do we enable that? And the solution is called dynamic IVC, which allows us to abstract the components of IVC into so that smart contracts can interact with one another through this dIVC interface. So I was explaining before that one of the main things in the IVC protocol is the packet. So we had the lite clients.
00:45:38.036 - 00:46:17.934, Speaker C: We have the connection between two chains, and then we have the channels. And the channels is what allow one specific part of the state on one chain to talk to a specific part of the state in the receiving chain. And this state can be either a module or a smart contract. The packets is what it's forwarded between these different channels. And you can see here that it has a sequence, what's the source, what's the destination? But more importantly, and then you have some time undoubted. But the most important part is here, the data. What's the call data? With this data, you're able to call other smart contracts, get the acknowledgement back, and compose.
00:46:17.934 - 00:46:37.214, Speaker C: So this is how we are allowing smart contracts to talk to one another, by defining this call data. And yeah, be able to compose not only with other chains via the outpost, but also with smart contracts that live elsewhere.
00:46:37.514 - 00:47:32.174, Speaker B: I think before we get into the demo, one important part is also, it's called dynamic IBC, because right now we have certain packet standards, like ICS 20 for normal transfers or for like interchange accounts. And it requires a chain upgrade for each chain to kind of bake that interface into the core protocol. But dynamic IPC, as Fede mentioned, just has a data field. It's pretty arbitrary. And smart contracts now have the ability to define their own packets, so it doesn't really require any chain upgrades for new applications, new interoperable applications to actually deploy and build their own logic, their own packet types that they encode on one side and then decode on the arriving chain. So I think that's the big game changer.
00:47:32.294 - 00:47:41.994, Speaker C: And now we're going to run a demo for how to use these IVC token standard for transferring tokens using a smart contract.
00:47:43.174 - 00:48:30.330, Speaker B: Yeah, so we just recorded this, sending some fmos tokens to osmosis. So this is still just a local setup, but it's also possible in testnet you have osmosis chain and it's connected through a relayer. As Veda mentioned before, you can query the balance of an account on osmosis that we want to send some tokens to zero because we're just starting out. And this shows basically a smart contract that interacts with the precompile or the EVM extension. You see the packet in this case, it also has a memo. This is the ICS 20 transfer, like the normal packet type. In this case we also included approval.
00:48:30.330 - 00:49:22.184, Speaker B: It's not necessarily, but if you want to have proxy contracts, then you want to probably have an approval case. And so we have 109 test fmos, and now we want to do actually a transfer to that address on osmosis. Just confirm it, sign the transaction, wait for the block to be built and the relayer to pick up the transaction and send it to the new chain. You see the first balance actually is still zero because the packet hasn't been relayed. But then you see it actually arrives. And just for confirmation on the original chain or the address, the amount also has decreased. Pretty simple demo, but it's just an example on what you can do.
00:49:22.184 - 00:49:30.492, Speaker B: And also if you want to build, like I said on Testnet, this is already available. And yeah, that's kind of it.
00:49:30.588 - 00:50:19.884, Speaker C: Yeah, this is the most simple demo that we could have built. But usually after that you want to check, for example, oh, you received the tokens. If for example, you're using the osmosis outpost or the strat outpost, you get the liquid staking tokens or you swap, you send some instructions to swap on osmosis, you want to check if the token has been received and then write down some conditional logic. Same applies for example, for staking, you stake some tokens, you can rebalance those tokens. You can check every day whether or not your position is actively managed, if your validator is jailed or has some downtime. And you can update this using smart contracts with our EVM extensions.
00:50:20.944 - 00:50:34.174, Speaker B: Also, we didn't really mention, I just mentioned it on the side sentence, but it's using precompiles. So who's using precompiles on Ethereum? Probably nobody.
00:50:35.834 - 00:50:41.050, Speaker C: There's only a limited set of pre compiled on ethereum chains. There's like a few more.
00:50:41.162 - 00:51:21.224, Speaker B: It's not as maintained as other code, I guess, on eclient, but for us it actually is a game changer. Right? Are we using precompiles to just understand at a predefined address? Is there a call coming in and then redirecting it to the core protocol? Like I said, staking whatever IBC. And so it's kind of nice to see that this part of code is also now being able to come to fruition in a very nice way. Yeah, come talk to us if you want to build with us. Build applications. We have a testnet faucet. There's also mainnet faucet, actually.
00:51:21.224 - 00:51:49.842, Speaker B: We have a bunch of tooling. We have oracles price feeds. We have block explorers for EVM, cosmos transactions indexers, subgraph. Like basically everything you need to build. Try it out, talk to us afterwards. That's it. Is there any questions? Go for it.
00:51:49.842 - 00:52:25.774, Speaker B: Maybe amp the microphone. Hi, I had a question about the outpost. So we saw, for example, the stride outpost on fmos. I was just thinking, who's the initiator? Like, who has to deploy and maintain the outpost? Would it be the shrine team, the FMOS team? Or could it also be like an application developer who does it? Technically, you could have several outposts, right? It's composable, like everybody or permissionless. Anybody could do this. But ideally, probably we're going to be the ones doing it first. Or the stride team.
00:52:25.774 - 00:52:54.204, Speaker B: There is one caveat. So on fmos, you can actually gain revenue from the transaction. So you can register your smart contract. And anytime somebody interacts with the contract, you can get some of the transaction fees as the contract deployer. So there's an incentive to do that. Maybe you have the best interface. Maybe you don't even use the stride interface, but build your own widget that's pluggable into somewhere else.
00:52:54.204 - 00:53:17.974, Speaker B: Or you're just a more well known team or whatever. It also ties in with the Dappstore idea that we had. So there's a bunch of ideas of showing, like, verified addresses or presenting your application. And this could be outpost as well. So there's, you know, we're definitely going to implement or kickstart it, but hopefully there's other implementations.
00:53:18.014 - 00:53:40.124, Speaker C: Yeah. For the go to market, I think it's important for us to showcase what's possible and then having other teams come in, build their own outpost on EvMos. Yeah, hopefully we'll have like, a single outpost for every single chain in the cosmos ecosystem, and you will be able to interact them natively via smart contracts.
00:53:40.544 - 00:53:48.324, Speaker B: If you want to build it. We should talk. Any other questions?
00:53:53.264 - 00:54:19.304, Speaker D: Hey, thanks. The talk was great, by the way. So I was wondering, because you mentioned about the cosmos ecosystem, but originally you were sort of talking about other EVM chains. So is that the same case, or are there any sort of additional steps? And one more question. What's your timeline for mainnet?
00:54:20.364 - 00:55:16.334, Speaker B: So, I mean, the first step is that we are looking at what are the bridging or the bridging protocols that work. And IBC has just been proven in the last two years to be very lightweight and resilient. So there's also some work being done of other teams connecting polymer, connecting more chains, or even having Ethereum like client to connect over IBC. We hope that that goes in that direction and we wouldn't really have to change much. But, yeah, polymer is actually also building exactly that. But, yeah, there's a bunch of ideas of our teams that are working on. How do you translate between IBC and another protocol? But that's kind of.
00:55:16.334 - 00:55:44.324, Speaker B: I hope that answers the question. So, yeah, I mean, the ideal case is we connect Evmos and Ethereum. Right. I think there's still a lot of work to be done for that, but that would be the ideal case and Mainnet for this, I mean, we're deploying to, like, we do another release candidate next week to make the IBC part possible. The staking and distribution is already available. Mainnet. Yeah.
00:55:44.324 - 00:55:47.160, Speaker B: Bit hard to tell, but hopefully, like.
00:55:47.232 - 00:55:49.658, Speaker C: Yeah, we're launching some audits right now.
00:55:49.786 - 00:56:18.164, Speaker B: Yeah, but the idea is, I mean, we've had the brick compiles or extensions on testnet for a while to enable, to break it, have people use it, give us feedback on the interfaces that we've built and the authorization logic, things like this. So just want to. We've done so many upgrades already on ivmos, so this is not a problem, but we want to make sure that it has actually a good developer user experience.
00:56:21.744 - 00:56:30.244, Speaker A: Thank you, Daniel and Federico, for that. Amazing talk on interoperability and blockchain agnostia.
00:56:32.304 - 00:56:32.824, Speaker B: Thanks, guys.
