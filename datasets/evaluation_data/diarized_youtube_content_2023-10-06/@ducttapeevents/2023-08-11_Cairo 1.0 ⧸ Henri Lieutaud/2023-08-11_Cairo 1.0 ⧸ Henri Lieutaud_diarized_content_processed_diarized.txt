00:00:11.480 - 00:00:45.906, Speaker A: Can you hear me? Ah, this is better. Hello, everyone. My name is Henry. I'll present for you today, and I'm going to talk about how Starks and Cairo will allow Ethereum to scale in a mind blowing way. I'm going to try to make my presentation in various steps. For those of you who are not familiar, I'm going to start by explaining really quickly what ZK rollups are and how they work. I'm going to explain to you a few basic concepts, and then we're going to build on top of that to see where we go.
00:00:45.906 - 00:00:57.124, Speaker A: Can we first do a quick show of hands? Who here considers themselves a dev? Very nice. Who here has already written a solidity smart contract? Who here has heard about Cairo?
00:00:57.504 - 00:00:58.088, Speaker B: Very nice.
00:00:58.136 - 00:01:22.600, Speaker A: Who here has written Cairo? Not so bad. So can you raise your hand again? All right, so all these people, you see them raising their hand. If you have questions about Cairo, don't take my words for it, ask them. No, but really, you'll have the best feedback. All right, so my name is Henri. I'm based in Paris. I'm the lead developer advocate for Starknet.
00:01:22.600 - 00:01:51.244, Speaker A: So my job is to explain to people what Starknet is and how they can build cool stuff on top of it. So if you're wondering how you can build stuff on Starknet or how you can extend your l one application and do more stuff on L2, you should reach out. I'm happy to answer either on Twitter, telegram, or here. Happy to talk whenever. Don't hesitate. All right, so I'm going to start with first what it is we're building. And let's talk first about the blockchain paradox.
00:01:51.244 - 00:01:58.628, Speaker A: Don't you think it's kind of weird that the technologies we're using in the blockchain space are all relatively new?
00:01:58.676 - 00:01:58.932, Speaker B: Right?
00:01:58.988 - 00:02:22.802, Speaker A: 1510 years old for Ethereum, and yet they don't scale, right? There has been massive payment systems emerging in the past ten years. You can name Alipay, Visa, Venmo. There's a bunch of them who are managing to handle thousands of transactions. How come bitcoin and Ethereum, who are newer technologies, why can't they do the same thing?
00:02:22.898 - 00:02:23.586, Speaker B: Right?
00:02:23.770 - 00:03:06.354, Speaker A: And when you really look at it, it boils down to the trust model that blockchain use compared to traditional institutions. In the traditional world, you have one entity, say, your bank or your payment processor, who is in charge of keeping tabs of who owns what. Everything goes through their computer, everything goes through their data center. Now, this has a bunch of disadvantages. I'm not going to tell you why blockchain is cool, but it also has pretty cool advantages, right? There's only one place where all the transactions go through. And if at some point you need more capacity, you just throw more data centers at it, right? Pretty easy to scale. We know how to do that with the cloud.
00:03:06.354 - 00:03:42.424, Speaker A: Now, compare this with the blockchain. In the blockchain world, we don't trust, we verify. This means that we don't trust somebody else to do the accounting for us. We take every transaction and we re execute them. And here first, you have a first notion as to why blockchains don't scale. Because every. Why blockchains are expensive? Because every time a transaction is done in the system, it is not done by one actor, it is done by all the actors in the system.
00:03:42.424 - 00:03:49.086, Speaker A: Implicitly, a work that is done by thousands of people is gonna be more expensive than a work that is done by just a handful.
00:03:49.150 - 00:03:49.566, Speaker B: Right?
00:03:49.670 - 00:04:16.742, Speaker A: And another question to that is, like, who here thinks that on their laptop they're able to handle the load of visa? Well, you might have a very big computer then, but other than that, I think it's really hard for you with a retail computer to handle the load of visa, right? So blockchains give us really cool stuff, but we sacrifice things for that. We sacrifice scalability. We can't do a lot of transactions and we sacrifice privacy.
00:04:16.918 - 00:04:17.518, Speaker B: Right?
00:04:17.646 - 00:04:24.990, Speaker A: So that's why blockchain don't scale. Today we talk about them as distributed ledgers. They're not distributed, they're replicated.
00:04:25.102 - 00:04:25.470, Speaker B: Right.
00:04:25.542 - 00:04:52.498, Speaker A: Everybody is doing the same work. Now, I want to introduce a concept you may be familiar with, and it's a concept you can put in the same box as digital signatures are hash functions, right? They're tools you can use in your application. They're backed by mathematics. You don't have necessarily to understand how they work, but you can know how you can use them.
00:04:52.546 - 00:04:53.042, Speaker B: Right?
00:04:53.178 - 00:05:43.248, Speaker A: And the way they work is the following. A validity proof allows Alice to execute a program and to send the output of such program to Bob along with a proof. Now, Bob is able to take this proof, analyze it, and make sure that the program was executed correctly without having to execute the program. Simple enough. Well, that basically here is a fundamental paradigm shift in how computing works, because there is no other paradigm where you can give to somebody the assurance that a program ran correctly without him or her running it themselves. So this has deep implication for computing in general, but mostly for the blockchain world today.
00:05:43.336 - 00:05:43.800, Speaker B: Right?
00:05:43.912 - 00:06:36.876, Speaker A: So ZK proof or validity proofs guarantee computational integrity. In our case, we don't use them for privacy. We use them for scaling. Why do we use them for scaling? Well, for a very neat property that these proofs have, which is that there is an asymmetry between how much work it takes for Alice to execute the program and how much work it takes to Bob to verify the program. The more work Alice executes, the less time it takes for Bob to verify it. Say it differently. Bob can execute a program on a supercomputer, and Alice can verify the proof and use the output of the supercomputer in her application on her retail laptop without having to trust Bob at any step, which is kind of mind blowing when you think about it.
00:06:36.876 - 00:07:08.692, Speaker A: It really introduces an asymmetry between these two players. So validity proofs are to computation what zipping is to a file size. This analogy is actually, it's good, but it has its limit in the sense that with recursion you can actually compress further a validity proof, and you can't with compressing a file. So let's not get into it right now. All right, so far so good. Now let's talk about how we apply this in the blockchain context. Let's talk about Starknet.
00:07:08.692 - 00:07:44.724, Speaker A: So Starknet is a general purpose smart contract platform that is based on that is, that lives on top of Ethereum. It is secured by Ethereum. And the way it works is the following. You have a bunch of actors that are able to run a blockchain with transactions with block, which is starknet. And this blockchain uses a lot of resources. It is able to process a lot of transactions, like a lot lot. And you can scale this machine as much as you want, because every time a block is processed, a proof is generated.
00:07:44.724 - 00:08:19.510, Speaker A: This proof then gets sent to Ethereum and is verified there, meaning that Ethereum can take for granted that the output of that blockchain is correct without having to trust any human. And this is here also an interesting artifact. This is the only context, ZK rollups are the only context where two blockchains are able to understand each other. When you think about it, when you have WBTC on Ethereum, what Ethereum knows is that some humans say, yes, yes, we have BTC stored and we'll give them to you. But we have them.
00:08:19.542 - 00:08:20.718, Speaker B: Stores trust us, right?
00:08:20.766 - 00:08:35.134, Speaker A: They rely on signatures. Well, with proofs you can have guarantee that these funds are there and you can have guarantee that what happened on this hover network is valid. So let's talk a little bit about the lingual of Starknet.
00:08:35.174 - 00:08:35.326, Speaker B: Right?
00:08:35.350 - 00:09:13.844, Speaker A: So you have a bunch of new actors. The fact that these validity proof allow you to do that, to delegate execution to specialized actors, changes a little bit the topology of the network. It changes what it means to be a node. It changes what it means to be a validator, right? So in general, in ZK rollups, we have these actors, the sequencer. The sequencer is the entity that received transactions and aggregates them in a block. It doesn't prove them, it just aggregates them in a block and calculate what is the latest state. The prover then takes these blocks and processes them to generate a proof that these blocks are correct.
00:09:13.844 - 00:09:59.740, Speaker A: And this proof is then sent to Ethereum in a verifier. Smart contract. That's the beautiful thing. Also about proofs, it is a program, right? And you can write one in a smart contract. How crazy is that? So there is a smart contract on Ethereum that verifies stark proof and is able to say, yes, all of these blocks were processed correctly. Now, what is a full node in Starknet? A full node is not necessarily a node that will store all the transactions because it doesn't need to, it just needs the proof that the latest state is valid. So the full node will just store the state and give access to the data to, sorry, to the application using it.
00:09:59.740 - 00:10:06.304, Speaker A: Then you have Starknet core. Starknet core is another smart contract on Ethereum that manages the state, state of Starknet.
00:10:06.424 - 00:10:06.920, Speaker B: Right.
00:10:07.032 - 00:10:33.740, Speaker A: Don't hesitate if you have questions on that. So one thing I want to mention about Starknet is that if you followed so far, you understand that validity proofs are a fundamental new building block in the way we design blockchain networks. They have deep implication of what it means to be a node, what it means to run a validator, what it means to verify and not trust.
00:10:33.812 - 00:10:34.284, Speaker B: Right?
00:10:34.404 - 00:11:20.768, Speaker A: They fundamentally affect the topology of your network, but also the way they're designed. They're based on mathematics, fundamentally impacts the programming paradigm in which your smart contract is used. So when faced with building a new solution on top of that, we thought, what should we do? Should we try to emulate what is happening on the blockchain right now? Or should we try to leverage all these new advantages that this new paradigm gives us? And we chose the latter. We chose to build this network from first principle. We chose to optimize for speed, for performances, for security. So stack net, first of all, uses stark proofs. Stark proofs don't need any trusted setup.
00:11:20.768 - 00:11:47.468, Speaker A: They're quantum resistant, they scale very nicely, and they gave you, they're faster to prove, and they're better to prove big workloads. So they allow L2 to scale to amazing quantities. The second thing is stocknet uses a ZKVM. It does not emulate Ethereum. It has its own vm. This comes with a general purpose language, which is Cairo. I'm going to talk about it in a second.
00:11:47.468 - 00:12:34.734, Speaker A: It is not a smart contract language. It's a general purpose programming language that is provable. And Stacknet also comes with no backwards compatibility with Ethereum. So it allows it to leverage new innovations that come with ek rollups, such as the ability to choose where you store your data, also known as how do you deal with data availability. It also builds on the shoulder of giants like Ethereum, and takes good innovations like account abstraction and use them at the network level. And it also allows things like off chain proving. It actually allows for distributed blockchains to exist where work is done by certain entities and verified on main chain.
00:12:34.734 - 00:13:35.294, Speaker A: All right, so summarizing, what is darknet? It's a general purpose L2 on Ethereum. It allows heavy machines to process the network and smaller machines to have mathematical certainty that they were not cheap cheated without having to incur a big cost. Starknet is about scaling, it is not about privacy. And Starknet was built from first principles. It's optimized for this new paradigm that are validity proofs, because it's worth it. All right, so now let's talk about Cairo, right? Because at the end of the day, my presentation is about Cairo. Where am I going with that? So what is Cairo? The first thing you have to know, without getting too much into the mathematics, validity proofs are a mathematical concept, right? And validity proofs are based on designing specific polynomials that represent specific programming specific programs.
00:13:35.294 - 00:14:38.222, Speaker A: Who here has already used circum, for example? A few. So if you use circum, you know that you have to define your program, and then it will define a circuit and it will define a verifier, right? We went down that route in the beginning. We tried to write programs using specific polynomials, and then eventually we quickly realized that this doesn't scale, it's too hard, it's too long, and it's a bit less safe also. So we decided instead of trying to craft a polynomial for each program, to create a program that can run programs, aka a cpu. This is the basic of what you have in your computer, right? A cpu is a chip that allows you to run any program. Well, Cairo is a virtual cpu that allows you to execute instructions that you can compile from a high level programming language. And these instructions are in turn provable.
00:14:38.222 - 00:15:19.994, Speaker A: Okay, so Cairo is a virtual cpu. It stands for CPU Air, Cairo. We also use Cairo to designate the programming language, meaning it's a high level programming language that boils down to these instructions that in turn are provable. You can use Cairo just like you would use Python. It does not need to exist in the context of the blockchain, a general purpose programming language. It allows you to write any program and prove it, which is extremely powerful. Now if you've heard about Cairo, then you might think, okay, what kind of program can I do with Cairo? Well, you can write Starknet, the network I told you about before.
00:15:19.994 - 00:16:07.364, Speaker A: It is all written in Cairo. When we say that Starknet, the network, is verified by Ethereum, it's because the whole execution of Starknet, the aggregation of transactions, the fact that the transactions are valid, that the blocks are valid, what is the state, the state dif at the end, and what is the output, all of this gets proven to Ethereum. Think about it. How much work would it take for you to write a circumcircuit that manages a full blockchain with state and smart contracts, right? So Cairo is extremely powerful. It allows you to write blockchain software. Now, if you've heard about Cairo, you might have heard about Cairo one, which was released recently. Who here has heard about Cairo one? Maybe just a tweet or something like that.
00:16:07.364 - 00:16:34.264, Speaker A: All right, so Cairo one, so, spoiler. In a few months you won't have to worry about Cairo or Cairo one because referring to Cairo will refer to Cairo one. But Cairo one is the next version of Cairo. It's a more resilient, easier to use smart contract language. It has a rust like syntax. It comes with years of hindsight from running Cairo in production. It has gas metering and error handling.
00:16:34.264 - 00:17:18.524, Speaker A: This is fundamentally a new change, a big change for starknet, because it will allow Starknet to be more resilient to dos attack, it will allow it to decentralize, it will allow it to be sensor shape resistant. But for most of you, you don't have to necessarily think about it. It's just a programming language and you can write your smart contract in it. I want to leave you with one last thought about Chiro and Chiro one. And it's the who here has heard about l three s and fractal scaling enticing, right? You have your l one, you have your l two, and then you have your l three, okay? And it kind of makes sense. You think about it there's a blockchain on top of a blockchain on top of a blockchain. Well, here's the truth.
00:17:18.524 - 00:17:51.864, Speaker A: The space between l two and l three is much more continuous than it is discrete. I'll give you an example. I was last week with one person who did a PoC for yearn, right? And yearn they have a, they have a smart contract to update their yield strategy. Currently what happens is the governance will sign a message to say, yes, this is the new strategy and it is good. But ethereum, the smart contract, has no way to verify that this strategy is indeed better.
00:17:52.024 - 00:17:52.632, Speaker B: Right?
00:17:52.768 - 00:18:33.990, Speaker A: So what he did is he wrote a Cairo program, not a Cairo smart contract, a Cairo program that takes input from ethereum, verifies that the new strategy is better, and then enforces it on chain so that it updates. And this right here is an example as to why l three s are a continuous thing. It's not a l two l three. There's a lot of things in between. Some people will choose to run some of the computation of their app off chain and verify it on chain. Some people will choose to just aggregate transactions and then settle them on chain. Some people will build weird constructions that are not blockchain but can still be used on chain.
00:18:33.990 - 00:19:28.174, Speaker A: You will have for the first time the ability to run code outside the chain and use trustlessly the output inside of the chain. That is a big, big paradigm shift in how blockchains works. And this is why it's worth it to have this construction, to have something that is not just meant to be executed in a blockchain context. All right, so summing up, why Cairo? Cairo allows you to create provable programs. Proof verification allows you to. It allows a retail computer to monitor a herd of supercomputers and keep them honest without having their computing power. And Cairo allows you to execute any kind of logic on off chain in the same language that you would write your smart contracts in and use the results on chain.
00:19:28.174 - 00:20:04.746, Speaker A: Okay, well, this is the end of my presentation. Can you raise your hand if you learn something nice? Who thought it was too easy? Who thought it was too difficult? All right, I think I'm spot on. So if you have questions, I don't know if you have a few more minutes, but don't hesitate and ask them. If you want to see what car one looks like, check out this QR code will take you for a small ride. You don't have to write any code, just read it and solve puzzles so that you understand how chiralwine works. If you want to learn more about Stark. Net and receive educational material, check out the second QR code.
00:20:04.746 - 00:20:24.814, Speaker A: It's our newsletter. We send it once every two weeks. No bullshit, just cool stuff for nerds. All right, thank you. And don't hesitate and come talk to me. All right?
00:20:29.514 - 00:20:38.466, Speaker C: Yeah, we have a few more minutes for questions, so if you have any questions now, our colleagues will show up with the microphone first.
00:20:38.530 - 00:20:39.134, Speaker A: Here.
00:20:41.914 - 00:21:18.614, Speaker D: You'Re also able to scale the complexity of the kinds of programs that you execute. And I just wanted to ask if I'm getting the order of magnitude right. So, for example, for distributed decentralized video hosting, you need re encoding that needs to be provable. So you want to re encode an uploaded video file, and you want to prove that you run this exact algorithm to re encode it in a different resolution and so on. So is starknet powerful enough to handle these kinds of volumes.
00:21:20.634 - 00:21:55.960, Speaker A: Pointing to a really cool direction, which is Zkrollup, allow you to do more of the same and to have cheaper transactions or to have more complex transactions. Now, is startnet able to handle encoding right now? Probably not. Also, you will have to rewrite all of this stuff in Cairo, but there's nothing like eventually the prover will be open source, not too far away from now. So you'll be able to encode your video on your computer and then verify the proof on the network. It doesn't have to be executed on Starknet, just verify it. That makes sense. Cool, right?
00:21:55.992 - 00:22:04.444, Speaker C: We have time for one more question, and I assume Henri will be around afterwards for you. If you have more questions, just hit him up.
00:22:05.584 - 00:22:30.636, Speaker E: Thanks for the talk. I've been using the previous version of Karo for a while and I haven't been checked recently, but I remember a chiropractor. So the chiroprover were a proprietary backend service and it wasn't open source. Like, what about Cairo one? Will the Cairo one prover be open source, something that so we can generate the proofs on our machines locally?
00:22:30.700 - 00:22:55.122, Speaker A: That's a great question. So first of all, Cairo Zero and Cairo one compile down to the same cpu and the same set of instructions, so the prover will be the same for both. The prover is currently still closed source, but we announced a few weeks back that we will open source it. We committed to it, so it will be open sourced and you will be able to run your own instance of it or run a proving service if you like.
00:22:55.218 - 00:22:56.974, Speaker E: Okay, that's great news. Thanks.
00:22:57.874 - 00:23:06.574, Speaker C: All right, we have actually time for one more question. Henri what do you think? One more question. The last one.
00:23:16.704 - 00:23:35.252, Speaker F: So I was wondering, when you have something like Starknet, what do you see as the source of truth for the transactions? Is it the l two or the l one? Or then even if you have maybe an l three on top, like where is the real source of truth? At the end of the day, the.
00:23:35.268 - 00:23:56.020, Speaker A: Source of truth is ethereum. Definitely. We delegate the security to Ethereum. That's the cool stuff about Zk roll ups, right? They can live on top of another network and be secured by it. So there are different layers of finality to your transactions. First it is accepted on l two, right? So there's consensus on l two. Then eventually a proof is generated and sent on l one.
00:23:56.020 - 00:24:13.224, Speaker A: This, at this point is when your transaction is the most solid. So the source of truth is on l one. Interestingly enough, this is also why it's hard to connect Azqlab to various chains. But it's probably not unsolvable. And sometime in the future we could have cool applications with that.
00:24:13.764 - 00:24:18.224, Speaker F: And do you think that also works if the data availability is not on Ethereum?
00:24:18.564 - 00:24:27.344, Speaker A: I think this is an open question and I think that. I don't have an answer, but I'm really looking forward to what each application is going to decide. Their security model should be.
