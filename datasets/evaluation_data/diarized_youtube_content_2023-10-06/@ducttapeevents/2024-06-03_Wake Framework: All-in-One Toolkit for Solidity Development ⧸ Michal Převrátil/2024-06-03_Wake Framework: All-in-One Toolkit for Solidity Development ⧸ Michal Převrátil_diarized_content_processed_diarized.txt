00:00:08.840 - 00:00:39.918, Speaker A: Hello everyone. I hope you enjoy this event and conference even through this unfortunate weather. So as it has been said, my name is Michael Absavratiel. Clicker. Yeah, my name is Michael Absuratil and I'm the lead developer of tooling for Ethereum at Equiblocain Security. We are smart contract auditors, mainly focusing on audits made on Ethereum and Solana, but we are also tooling developers. We love building open source tools and we have two tools to share with the community.
00:00:39.918 - 00:01:01.394, Speaker A: Wake. This talk is all about wake, so I am going to skip it for now. And then there is Trident, which is fuzzing solution for Solana. We also onboard new developers to the ecosystem. For example, we run school of Solana. We are excited to work with the best of the best clients out there. Like for example Axlar save Lido one inch.
00:01:01.394 - 00:01:22.458, Speaker A: And we've received a couple of grants. For example, the grant from Coinbase started the development of Wake. But let's get to wake. So water is wake. It's an open source tool, it's a Python based tool. But it's not only a tool, it's a framework. It's a framework for deployment and testing.
00:01:22.458 - 00:02:06.916, Speaker A: So anyone can deploy any contract to many chains that we support. For example, we support BNB chain, Polygon, or for example base. But there's also the testing part, so that we have simple unit tests. Anyone can try to debug or test a simple case in their contracts. There's also support for fuzzing, which is quite different technique when someone generates random data, generates random sequences of operations and passes these data and these sequences to contracts, trying to break the contract and trying to find some interesting bugs. There's also support for integration testing. This is mainly useful for projects that have some dependencies, for example chainlink or AAVE or some projects like this.
00:02:06.916 - 00:02:41.602, Speaker A: And in this case we can fork any chain we want to probably domain that and we can just use these contracts normally as if they were on our deployment chain. And. Yeah, so this is the testing and deployment part. There's also static analysis framework and I believe there are two main outputs for users from static analysis. And these are detectors and printers. So detectors are mainly about finding some common issues, some vulnerabilities or code quality problems in code. This is quite clear, I believe.
00:02:41.602 - 00:03:22.608, Speaker A: And the second feature is printers that are basically almost the same from the developer perspective, but very different from the point of view of the end user. Because printers extract some information from the source code, they don't just show some. Let's say findings or problems in code, they just print information from code. And finally, there's also language server. So let's say that we are developers, we want to develop some solid smart contracts we want to use versus code. But the problem is that versus code itself doesn't support solidity. So we have to use a few of extensions that are out there.
00:03:22.608 - 00:04:04.532, Speaker A: One of them is called tools for solidity, and this extension is also developed by Eki and it works with wake. So every single request that is made to the extension, like the code, highlighting, going through references or renaming a symbol, everything goes through wake. So wake is really behind all this stuff. And tools for solidity is just a front end for wake. Wake helps us a lot in our audits. This is an incomplete table of all the findings that were found thanks to wake. Some of them were found using static analysis, which means with detectors.
00:04:04.532 - 00:04:38.174, Speaker A: This is the case of the first one, that ERC 4337 detection. This is like account abstraction. And the problem here was like incorrect storage to access, storage access. I'm going to talk about this one later in the presentation. Some other findings are from fuzzing, that's the example of the finding from Lido or for example from XLR, while others are from simple unit test. This is the case of slide. But let's move to the first topic, which is deployment and testing.
00:04:38.174 - 00:05:11.756, Speaker A: And I believe the best way to introduce a testing framework is to show it on very simple example that everyone can understand. So I've got a very nice code example here. What we are doing here is that we do some imports that are quite necessary for our testing. Then we import from py types. Pythagoreans are very special to wake because let's say that we have some solidity code base, we have some contracts here, some structs, some events and so on. But we want to have the same types, but in Python. So we have auto completions and type checking support.
00:05:11.756 - 00:05:43.696, Speaker A: And what veg does is that compiles the project, it generates py types, which are like types from solidity, but in Python this way we can import them and then we have auto completions and all the nice stuff in Python. Let's move back to the, to the test. So we are connecting to a chain. In this case we are using fork testing. So we are forking from a local node running at port 8545. So we are expecting an ethereum mainnet node here. And then we have a test.
00:05:43.696 - 00:06:16.094, Speaker A: We are generating two random addresses. The first one is for sender, the second one is for recipient. After that we can just typecast an address of USDT to ERC 20 because we are using foretesting. So the token is already available here. After that we can make some assertions about the symbol, about the name, about the decimals. And now since we are in testing environment, we can do anything we want to. So we can use some cheat codes to mint some tokens, 200 tokens to the sender.
00:06:16.094 - 00:07:10.236, Speaker A: After that we can transfer a half to the recipient and finally make some assertions about the balances of those senders and recipients. Let's talk about some more interesting features in the testing framework. As I said, we do support fuzzing, which is generating random data, generating random operations and passing those data and executing those operations on contract. There's support for fork testing, as I showed in the previous example. And let's say that we have a transaction that interacts with many contracts, and some of those contracts are from the forked environment. And in this case we want to print a coltrace which shows all the contracts that were executed or executed in a transaction. And this cold trace just shows the names of the contracts of functions, of parameters and so on.
00:07:10.236 - 00:07:48.984, Speaker A: And because of this etherscan integration, we can show the names of those contracts because wake basically fetches the source code and the API from Etherscan, so it works even for the forked contracts. Then there's also coverage analysis support. So we can run a testing suite using code coverage feature. And we see the results right in versus code, which is highly integrated into versus code. So we are trying to use the best of two worlds, like the command line and versus code. So the coverage collected from fuzzing and testing is showed in versus code. And actually in the case of fuzzing, the coverage is showed in real time.
00:07:48.984 - 00:08:26.384, Speaker A: So as we fuzz, new coverage lines appear or are highlighted in versus code. There's also support for cross chain testing. So we can define any number of chains, most probably just one or two of them. And then when we are deploying new contracts, we can choose a chain we want to deploy to. So this way we can test very interesting projects that need cross chain testing or just they are using multiple chains. And this is very, very nice feature needed for cross chain projects. There's also, or there are also random seeds.
00:08:26.384 - 00:09:35.506, Speaker A: This is especially useful in case of fuzzing. So let's say you have found a very interesting issue, but we need to print some information about that issue, some logs, and we need to run the same test case again, again and again. And this is possible because of random seeds, because we are basically after every single run of vague test, we print the random seed, and we can use that random seed to reproduce all the same transactions inside that test run. And finally, there's support for matlabrocessing, which means that we can execute like a single test multiple times at multiple cpu cores, or multiple tests like spread or split across different cpu cores, so we can speed up the whole execution. And there's also debugging. Since we are writing tests in Python, we have very strong debugging capabilities. We can stop at any line in the code, we can print any information about the code, and we can also interact with some contracts that are deployed, or we can even deploy a new contract.
00:09:35.506 - 00:09:59.974, Speaker A: I have quite nice animation on the next slide. This is an example, and unfortunately it doesn't work. So I'm sorry, the animation won't be here. But as I said, we can stuff at any line and we can print anything about the contract. And yeah, we can even deploy new contracts. We can print cold traces. So the debugging is very powerful in the testing framework.
00:09:59.974 - 00:10:54.622, Speaker A: So since we are testing in Python, we can use something called differential testing, and this is all about that. We have some solidity code, and then since we are doing testing in Python, we can re implement the same problem, but in a different way in Python, so that we can compare these two models, the original solidity one and the new Python one. And sometimes it's even possible to re implement the same problem in a different way. And this is the case especially since we are working in solidity. We are somehow limited by the gas. We are also limited by mappings. We cannot iterate over mappings, while in Python we can iterate over dictionaries, so we can re implement the same idea, the same problem, but in a different way, and then compare these two results that are often very different, at least from our experience from auditing.
00:10:54.622 - 00:11:22.450, Speaker A: This is an example from IPAr, like the project that we have audited. We are trying to compute some interest, it's a floating interest. So we are multiplying multiple values, like from intervals. And this is something that cannot be done in contracts. It will be super gas expensive to do so. So they are using a different approach. But in Python we could just multiply these two values as the formula states, because we can.
00:11:22.450 - 00:12:05.470, Speaker A: There's no reason we couldn't. And at the same time, Python supports floats like floating point numbers. So we have more precise results than the slotted implementation, and we can probably find some errors and then decide if the error is big enough or just small. Now let's talk about performance. Of course we want to find bugs, but we want to find them very fast. And yeah, so we took uniswap v three core repository, we took 271 tests that were already written in hardhat, which means in JavaScript, and we have re implemented those tests into brownie, into ape, and into wake. And these are the results.
00:12:05.470 - 00:12:53.174, Speaker A: So these are the times in seconds, and this is the time of executing all the tests, like 271 tests. And as you can see, Wake managed to run all the tests in less than 4 seconds, which is pretty awesome in my opinion. And that's because wake is highly optimized for Anvil. Anvil is part of the founder project, so it's written in rust and it's very fast. So wake is somehow integrating anvil and we are trying to even improve these numbers by integrating more rust libraries and code to make the execution even faster. All right, so let's talk about static analysis. Now, as I said, static analysis is mainly about detectors and printers.
00:12:53.174 - 00:13:37.466, Speaker A: I'm going to start with detectors. Our approach here is that we prefer quality over quantity. So we don't want to have 101 detectors trying to detect everything we possibly can, but we are slowly, yeah, we are here. Nice. So we are trying to slowly build one detector by one while keeping the high quality at the same time. We do care about user experience, so of course we have some command line input, which is very nice, I'm going to show on the next slide. But except from that we have GitHub integration.
00:13:37.466 - 00:14:54.344, Speaker A: So when someone pushes new comments to the GitHub repository, there's automatic compilation in the pipeline. Then all the detectors that are available are run automatically and the results from those detectors are shown in a very special page on GitHub that is only accessible for omnis of the repositories. So it's not possible that that defining would leak to someone who's not the owner of the repository. As I said, Vic is highly integrated into versus code, and so there's extension for versus code and there's automatic compilation over each change to the code base. So every time, sometimes someone types some new code in versus code, there's automated compilation and automatic run of detectors, and those detections are shown in real time in versus code. And of course static analysis may provide sometimes false positives. And in this case we can just type very simple comments in code that disable very specific findings, or maybe like a range of findings across the code base.
00:14:54.344 - 00:15:46.534, Speaker A: And finally, we do have public APIs so everyone can create their own detectors as I promised we will speak about that ERC 4337 detector. By the way, this is an example of a command line interface, so I believe it's very user friendly. It shows all the specific line where the issue is. Also some lines before and after there's confidence and severity of a finding and there's also text message describing the finding. But let's talk about that ERC 4357 detector. And basically that ERC defines some rules for smart accounts. There has to be a function called validateuseroperation and there are some restrictions for that function.
00:15:46.534 - 00:16:19.314, Speaker A: The function cannot execute any operation. Like there are some restrictive opcodes inside the function. So the function itself and the functions called from that function cannot use, for example timestamp and so on. And there are also some restrictions for storage access, not for the smart account itself, but for contracts that interact with that smart account. And this detector does that. It checks those invalid opcodes that cannot be used as well as the storage access. So this is something automatically reported.
00:16:19.314 - 00:17:00.368, Speaker A: And honestly for me as an auditor, it's very hard to find those storage accesses because the code can be very complex and finding these is non trivial. So I'm really glad that we have such end detector. When it comes to performance of detectors, we don't usually care about execution times. We care mainly about false positives and false negatives. So we've taken one single detector. In this case it's right after. Right, so we are writing a single value into a variable and then we are writing maybe a different, maybe a same value to the same variable, but we didn't use the previously written values.
00:17:00.368 - 00:17:37.734, Speaker A: So the first word was basically useless. And we've taken three different metrics. The first one is precision, which states like the number of good findings versus the number of all findings reported from the detector. The second one is recall. The recall is like non missed, right? So basically it says how many findings we did not miss versus the total number of findings out there. And finally there's f one score, which is basically like a combination of these two. So it's like a harmonic mean between recall and precision.
00:17:37.734 - 00:18:10.206, Speaker A: And I believe the table just says it for itself is very, very, very good. And it's also one we are glad to use in our auditing process. Okay, now let's talk about printers. So printers are used for data extraction. They extract some information from the source code. It can be, for example, graphs. So yeah, so it can be an inheritance graph, like graph on inheritance of contracts.
00:18:10.206 - 00:19:07.434, Speaker A: It can also be like, for example, cross reference graph showing how contracts interact with each other, but it can also be something like API storage layout, or some statistics like lines of code, or for example number of functions. There's also integration for language server. I think this will be the best describe on an example, so I'm going to just skip it for now. And finally, there's of course public API for creating custom printers. This is an example of a command line printer, like a static printer. We've got an interchange token here, like a contract, and we are printing storage layout of the. So as you can see, there are some storage variables, there are names of those variables, there are types, and since the contract inherits from other contracts, we can also see like the name of the contract that defines that specific variable.
00:19:07.434 - 00:19:53.684, Speaker A: And finally, this is an example of language server integration. So this is a printer, but for versus code. And what we are trying to do here, we have a contract and we want to show to the end user, public and external functions from the code base from a single contract. So basically it's about extracting information from source code, but we want to show it in versus code native way, so not on command line but in versus code. And yes, so we have a contract named stonks here, and there are some labels above the contract. One of them is public functions. And if we click but on that label you can see all the public functions that are defined inside the contract, even across inheritance.
00:19:53.684 - 00:20:27.146, Speaker A: This is the extension that I spoke about. It's an extension for versus code. And what's really nice is that it installs Vik automatically, it even does compilation automatically. It downloads all the versions of source seeds that are needed in the codebase. And finally it compiles the project after every change to the codebase, and it runs detectors for that codebase. So the detections are really shown in real time. This is the table to sum up the presentation.
00:20:27.146 - 00:21:12.486, Speaker A: So there are quite many tools out there. Some of them are more specific to a given area. Let's say for example slitter is mainly focused on static analysis, while others are mainly testing frameworks. But for example hardhat integrates also a language server as well as wake. And for example foundry has a fuzzer like a fuzzing engine as well as wake. But what's probably the biggest advantage of wake is that it leads developer through the whole development process, starting from simple typing code while showing already some possible detections or problems inside the code base. Then by doing single testing like unit testing, or maybe fuzzing.
00:21:12.486 - 00:21:49.820, Speaker A: And after there are no bugs inside the codebase, it's also possible to deploy contracts using deployment script. There are some additional resources we want onboard new developers to using the tool. For example the official documentation. I will have a QR code here so I'm just going to skip those links. There are also solutions for ethernow like the capture reflect challenge so we can try to check them out. They are very nice and they show some basic usage of the framework. And we also from time to time publish some audits like tests from audits.
00:21:49.820 - 00:22:11.624, Speaker A: And this is the example of light of stones slide, ipor and we also have some tests for XLR and so on. And finally, regarding static analysis, there's nothing easier than just check out those built in detectors and printers and that's the end of the presentation. So thank you for your attention and be sure to check out the landing page of wake.
00:22:12.124 - 00:22:44.194, Speaker B: Thank you so much. And thank you to the fine gentleman from Ackee as well supporting from the front row that is great for helping to build this community by being the great sponsors and content creators on this conference. We have a space for two quick questions. Anyone? Yes? Was that a thumbs up or do you want to ask something? All right, fair enough. Okay, anyone? A question? Yes please. Thank you.
00:22:47.654 - 00:23:03.886, Speaker C: Hey, thanks for the presentation. That looks really cool. Do you also have your like how are you doing compilation? Are you using foundry or hardhat or are you using your own compilation pipeline to compile smart contracts?
00:23:03.950 - 00:23:22.354, Speaker A: Yeah, we have our own compilation pipeline and we are doing incremental compilation. So we split the code base to like very small compilation units and because of that we can do incremental compilations. So this is something we are using on the command line as well as in the language server, but sometimes in a bit different way.
00:23:23.094 - 00:23:24.274, Speaker C: Cool, thank you.
00:23:24.694 - 00:23:52.902, Speaker B: Thank you very much. Any other questions? Well, I have one. So we mentioned at the start it's a bit of a swiss army knife of blockchain development. My favorite way of using the swiss army knife is the bottle opener, for example. In your particular case you're keen to onboard new developers. What feature do you think? Or the use case of using Awake will be the easiest entry point into the ecosystem?
00:23:53.028 - 00:24:27.914, Speaker A: Thank you for the question. I believe the easiest entry point for new developers is testing because usually developers have some smart contracts already or they are deploying new ones and it's very easy to write a simple test case or like unit test that tests the contracts while developing new detectors. It's very complex, but at the same time if the developers want to use built in detectors, they can just see the detections right in versus code. So this is something that's done automatically and developers don't even need to do something very special. Just download the extension for versus code and that's all.
00:24:28.294 - 00:24:50.134, Speaker B: Fantastic, ladies and gentlemen. What else do you need? You've got an Ikea manual basically to join the wake community. Thank you so much, Mikhail Przebarakil of Aki. Give him another hand of applause please, and we will see you very shortly yet with another talk on this fantastic mainstage. See you soon.
