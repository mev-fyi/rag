00:00:00.600 - 00:00:43.844, Speaker A: Thanks for coming for the talk. So I just realized that I only have 20 minutes, I have to go a bit fast. I apologize for that. So today I'm going to talk about the comprising of continuous time swap. My name is Neal, I'm from superfluity protocol, so it's my second time actually talking here. What you'll hear about today is why you should trade time continuously and what does it mean and what different designs of decentralized exchange there are for the time continuous way of exchange and beneath the surface, what makes it possible. So that's today's talk.
00:00:43.844 - 00:01:19.532, Speaker A: So I'm a trader, I trade all kinds of things, including crypto, including tradfi stuff. But nightmares that I have, I believe a lot of people also have is first of all, most of us suck at market timing, let's just face it. So this is one of the good examples. So people buy top and sell low, that's kind of what most people do. Statistically, likely not. That's how people does, which is bad. And there's also study about why you should invest it all the time as opposed to trying to time the market, because statistically most people just don't do it.
00:01:19.532 - 00:01:52.138, Speaker A: Well, this is one of the data from the treadfire studies about s and P 500. I'm curious what kind of data is for the crypto investment. I would believe it's rather similar. And also it's very difficult to know which are the best days in the market. And so best way for a normal trader, boring trader like me, like some of you, it would be don't time it just keep invested. Dollar cost average. Sometimes people say that's my first nightmare.
00:01:52.138 - 00:03:10.024, Speaker A: The second will be very specific to crypto. So the front run by the MEV bots, what does it mean? So let's go through a couple of MEV technology terminology first, quickly. So there's a user, a normal Ethereum user, who sends transactions and searchers like advanced Ethereum users that specialize in finding MEV opportunities or MEV like maximal extractable value, right. And sending advanced transaction types like bundles. Then we have also builders who specialize in constructing the execution payloads received from either users or either from searchers. And then you have the validators, the party who signs and submit the transaction to the, and it's called proposal sometimes also, maybe you heard of this term PBS, right? So proposal builder, separation and actually validator and proposal is kind of the same thing, right? So if you look at supply chain, it's like from the user to the searcher in between there's a wallet usually, right, from search to the builder and builder to the validator. In this case, it's without the PBS, right? So this is just set up without PBS.
00:03:10.024 - 00:03:46.918, Speaker A: But what's the problem of it? But the biggest nightmare would be sandwich attacks, right? So in the graph above, you will see that, okay, Alice tried to buy something from the Dex. However, Bob sees a transaction and tried to squeeze two transactions. Put Alice transactions in between, similar to a sandwich, and then take advantage of that by. Why? Because it's possible. Because transactions on the blockchain that we know of are transparent. So there's a chance for the builders, anybody in the stage of the supply chain actually.
00:03:47.006 - 00:03:47.230, Speaker B: Right.
00:03:47.262 - 00:04:44.062, Speaker A: So in the diagram below is a bit more than the one that I showed a moment ago, because this one has PBS built in, right? So actually there's 95% of the validators in Ethereum ecosystem now utilizing mev boots to do the PBS. So there's builders, there's validators, there's escrow, there's relay, and there's users, blah blah blah. But still doesn't solve this problem because transactions are transparent. So that's kind of the nightmare sort of crypto trader would have. So here's one solution that I'm going to talk about today with a couple of designs that, that implements such solutions. So the gist is that we let the swaps happen every block, but virtually we're not going to submit the transaction every block. Of course it's going to be too expensive, but we let it happen virtually every block.
00:04:44.062 - 00:05:26.294, Speaker A: We model a swap exchange using time. We don't model it in a way that it's instant transaction or instant swap. So this way we avoid market timing. We avoid the first nightmare and the second is we minimize a single block mev risk. So let's see what kind of design we can come up with to create this kind of solution. So design one, I call it the flow swap. So the basic idea is that you add the continuous time elements to the Uniswap v two contract, or the uniswap v two concept, let's say rather.
00:05:26.294 - 00:06:08.030, Speaker A: So first of all, just a refresher, what is uniswap for v two? It's a very elegant and simple. I think it should be the exercise for everyone that learn to program your own ethereum to do by hand yourself, because it does show a powerfulness of defi, the simplicity and sometimes, but if you look at this diagram, there's a curve which shows something called a constant function market maker. And in this particular case, the curve represents a constant function that is constant liquid constant product, or I call it constant liquidity product, which is, I think it's more accurate. So basically, if you multiply the liquidity a and liquidity b, they are constant, and then create a curve.
00:06:08.062 - 00:06:08.206, Speaker B: Right.
00:06:08.230 - 00:06:33.502, Speaker A: So when you do a trade, it will be moving from the blue dots you see to the, to the red dot. So it's an instant move. So one transaction down. So that's how a uniswap v two transaction looks like on that curve. Right. But what if we make it smoother? So let's see. So we say we don't do an instant move from blue dot to green dot anymore.
00:06:33.502 - 00:06:43.304, Speaker A: It is a green dot, sorry, blue to the red dot. But we want a green dot that moves smoothly, conceptually, that smoothly over time. So time become a function of it.
00:06:43.384 - 00:06:43.600, Speaker B: Right.
00:06:43.632 - 00:07:16.508, Speaker A: So there's a very scary, it's not that scary, but scary enough formula there. But how do we come up with that? That's kind of the, we need to find a solution. How do we come that? I'll show you in a moment. So there's some magic there. But the idea, I just want to visualize you move the points continuously along the, along the curve. So I would recommend using the, something called sagemath. It's a very good open source mathematical library licensed under GPL, and show you quickly how you solve that problem.
00:07:16.508 - 00:07:41.786, Speaker A: So, first, you define the constant liquidity product function using symbols. Or say you have x and y, you have x prime and y prime. You say the product of them should always be equal. So that's your equation, that's your basis to work with. Let's validate if it's correct. So let's say we solve the instance, swap the uniswap v two, instant swap liquidity function. So you plug that Clp function with the solver.
00:07:41.786 - 00:07:58.826, Speaker A: Say I want find a solution right in the line of the last fourth line. The solve function would be basically say, okay, I want to find the solution to satisfy this equation, and this sagemath will come up with this equation, which is the correct one.
00:07:58.850 - 00:07:59.034, Speaker B: Right.
00:07:59.074 - 00:08:45.970, Speaker A: If you do the uniswap v two yourself, that would be the formula you use. You probably wouldn't use sagemath in that case, but at least it shows that it can work. But now let's see, how can we do that for when we need continuous time? I use time sagemath again, in this case, you have to come up with something that, you have to have a leap of faith that come up with some magical variable q. And you have to imagine how that formula look like. Once you come up with that shape of the formula and plug to the solver, the solver will give you that. So that's the basis of how to calculate the liquidity movement continuously over time. So now you can define a function, say how much liquidity has moved as a function of time.
00:08:45.970 - 00:09:08.504, Speaker A: So you don't need to change block. I don't need to do a blockchain transaction anymore because liquidity just moves every time the block moves, right? Because every time block moves, the timestamp moves. Timestamp moves, the liquidity moves. So that's how you do it without sending an on chain transaction. And that's how you come up with the equation. You use a sage math, right? So that's the first design. Well, let's see what's the property.
00:09:08.504 - 00:09:46.264, Speaker A: So, first of all, you still need to do liquidity bootstrap, right? Means that the TVL would be, there will be tVl. So you have to lock the liquidity that's the same as uniswap, but in this case, supporting, of course, continuous time. So there's some funds at risk. Second of all, would be LP complexity. It is almost as same as the Uniswap V two. So nothing to be said about more than that. The third would be the single block MEV, so it would be safe, because now the transaction happens every block, so that it's no longer subject to the single block mev kind of risk.
00:09:46.264 - 00:10:14.968, Speaker A: All right, so I need to go slightly faster now. So second design would be the zero intermediate liquidity market maker. In this case, let's say LP sends two mining streams. One sends token a, the other is token b, and they get it back immediately. So in this case, neutral. So the LP, the liquidity provider, don't actually lose anything or win anything, right? It's neutral. This is the initial state.
00:10:14.968 - 00:10:51.106, Speaker A: But then someone send the trader one, say, I want to swap 100 USDC for ETH X. And now the LP actually has imbalance now. So LP will have to give the trader a certain amount of ETH and taking more USDC back. So the created imbalance, the LP, now the money actually moves, but there's also a fee there. So the LP provides a difference, but also take fees from the streams. So in this case, in this design, it's like aqueduct, that kind of routes, routing the money streams, right? So liquidity bootstrap required. No, in this case, there's no money at risk.
00:10:51.106 - 00:11:19.534, Speaker A: So money is simply going through the router sort of like routing from one place to the other. Right. The complexity wise, it's a downside of it, because the complexity is quite high, because no one actually know how to actually do the up charge for this system because it's very unconventional. So that'd be the main risk of using this model. A single block mvv also saves, because it also happens over time. Every block, actually. So now we see the third design.
00:11:19.534 - 00:11:48.284, Speaker A: So now we talk about uniswap again. In this case, we use a twap. What is a twap? In brief, TWap stands for time weighted average price. And twap was added in uniswap V two and was improved in the V three. Right. So they use something called a price accumulative, which is recalibrated for each swap and its value changes also for each block. Right.
00:11:48.284 - 00:12:27.084, Speaker A: In order to calculate the price, you use two price cumulatives and you divide by the time window, the range of the time. A way to visualize this one is V two. So you have two price cumulatives from different time. You get the delta, you get delta over time, you divide it, you get the price. So you can always get the average price between two times if you observe the data. So, Uniswap V three is slightly different here, but the fundamental idea is the same. If you want to know more, you should reading to the paper.
00:12:27.084 - 00:13:35.370, Speaker A: So we have actually in production something that tracks the observed price and the market price. So you can see that the average price, if we use this method, tracks the data from Yahoo pretty well, whereas the green data would be the one that we actually track and the red data would be the one we retrieved from the market. So how does it work then? The way it works is that the step one is everyone send money to this liquidity that the pool, so that you can see that it's like stream of money goes up over time. But then the step two would be that you withdraw all those liquidity by someone moves the liquidity, the yellow quarter liquidity movers take all those liquidity, find the liquidity source and swap it and give it back to everyone. Right? That's how it works. But you have to satisfy the price that you observe from uniswap. Right.
00:13:35.370 - 00:13:58.524, Speaker A: You have to give back the amount of money that satisfies the liquidity constraint. So you can't just take the liquidity and give back not sufficient amount. So it has, has to be satisfying the liquidity requirement. So that's kind of a design. And let's see the property again. There's no liquidity bootstrap needed, so there's no TVL per se. It's not entirely true.
00:13:58.524 - 00:14:30.436, Speaker A: As you see there is a little bit accumulation temporarily, but it doesn't go up forever. So it's always go to zero from time to time. And complexity is kind of simple, right. So you just need to satisfy the benchmark price and it's flexible. Also you can find the liquidity from anywhere you like to because this system doesn't really care. And it's also competitive because everyone kind of competing with that job, which is about swapping liquidity, satisfying the price constraints. So single block MeV is kind of safe for the traders.
00:14:30.436 - 00:14:38.816, Speaker A: There's little bit challenge to the liquidity movers to be competitive and they are still subject to MeV, but it's their job to solve that challenge.
00:14:38.940 - 00:14:39.200, Speaker B: Right.
00:14:39.232 - 00:15:17.312, Speaker A: So there's a design for us. I anticipate I don't have enough time to talk about it, but if you look at paradigm, they have another design called t one time weighted average market maker. And they have a design that there's some similarity with that and with the Torx I just talked about, but I will not go into that. So how all these can be possible? Well, the enabler is actually you need some sort of composable money stream. Without all the design you can't really do it. So I actually leave it until the end. I don't want to show the superfluity, but you have to have this kind of token wrappers.
00:15:17.312 - 00:15:38.890, Speaker A: It has to be ERC 20 compatible. You have to be able to wrap existing ERC 20 tokens. You also need to be programmable, money stream and composable. That's most important. You have to be just in time liquidity so that you can use the liquidity just are received and used for something else. If it's not composable, then you can't make it, right. So that's why it's needed.
00:15:38.890 - 00:16:21.712, Speaker A: So I'm going to skip this one and just do the comparison right away about the three designs we have. So we have the flow swap, we have the zero intermediate liquidity, and we have the Taup oracle based. Only the flow swap needs a liquidity bootstrap all of the others doesn't need. And LP complexity wise, the zero intermediate liquidity is the most complex one. And the twap is the simplest one, I would say. And MeV safety wise, all of them are safe. With a little bit caveat that the T Wap version has to liquidity will have to compete and have to solve the challenge themselves.
00:16:21.712 - 00:16:43.262, Speaker A: So there's possibility. So it's not a problem, really, for them to find the liquidity source. So some additional theory. I mean, I just go really, really fast. This is called something called functional reactive programming. And if you interest, you can look into it. It's really about how to model everything using time continuously as opposed to otherwise.
00:16:43.262 - 00:17:11.418, Speaker A: So FRP is actually the theory behind it. And so, yeah, thanks for, for your listening. Yeah. So follow us on super boring on webcast or superfluid and follow me with my handle. And if you want to see the source of the slides, you can go to our Monorepo. Let me repeat, superfluid finance protocol Monorepo wiki. If you search for continuous time, stop.
00:17:11.418 - 00:17:15.654, Speaker A: You would find this slide, the source of the slides. So, yeah, thank you very much.
00:17:16.054 - 00:17:19.754, Speaker B: We actually have time for one quick question, if we have any questions.
00:17:20.934 - 00:17:21.794, Speaker A: Any questions?
00:17:23.814 - 00:17:32.054, Speaker B: No? Okay. I'm sure that if you have other questions, you would love to connect with meow after his talk. Let's give him a round of applause. Thank you so much.
