00:00:27.154 - 00:00:29.154, Speaker A: After you finish, just put the mic.
00:00:29.194 - 00:00:34.274, Speaker B: To the migrator, okay? All right, everybody, moving on to the next panel.
00:00:34.314 - 00:00:35.986, Speaker C: This will be my easiest introduction of.
00:00:36.010 - 00:00:38.934, Speaker B: The day because I'm going to hand over the mic to Stefan and he'll do the rest.
00:00:40.514 - 00:01:12.944, Speaker D: Thank you very much, man. So I think we all feel great to be here and thank you all for listening. And we'll go straight to the point today. With us are Miao from superfluid, Mario from Ethereum Foundation, George from Consensys, Anton from chain security, and Nebuchadnezzar and myself are from tenderly. Guys, if you want to say one or two short sentences about yourselves, introduce yourselves and we'll get straight to the point.
00:01:14.324 - 00:01:15.304, Speaker C: Oh, okay.
00:01:15.684 - 00:01:17.420, Speaker E: Yeah, I was building super token.
00:01:17.452 - 00:01:18.024, Speaker B: Yes.
00:01:19.214 - 00:01:37.374, Speaker E: Yeah, so I'm from superfluid. We've been building the magical token called super token for quite a while. And I don't know enough about EOF, but I hope I can provide some also my new thoughts about it also for today's talk.
00:01:37.414 - 00:02:08.584, Speaker F: Thank you. Hey everyone, I'm Mario. I work with EF, specifically protocol support team, which is a team which helps to coordinate the work around core devs and well, also to test ship hard forks. So I'm more of a technical part of this team where I dive into some research around the current research and I've been running the protocol fellowship, so I'm helping to onboard new core developers.
00:02:08.964 - 00:02:09.704, Speaker A: Yeah.
00:02:10.644 - 00:02:21.314, Speaker B: Hi everyone, my name is George. I'm from consensus diligence and I mostly do smart contract security audits, some tooling and some ZKP research here and there nowadays.
00:02:23.054 - 00:02:45.904, Speaker C: Hey everyone, I'm Nebuchadnezzar, one of the co founders in Tetherly. We are building a developer platform that helps builders be more productive and efficient when they are building and testing smart contracts. Mainly I'm working on our custom virtual machine that is capable of extracting more data during the runtime.
00:02:46.204 - 00:02:46.764, Speaker E: Anton.
00:02:46.844 - 00:03:08.484, Speaker A: Hello, my name is Anton, I'm from chainsecurity. We are also doing audits for ethereum smart contracts and also internally we're doing different tools and keeping a close eye on all the changes in the bytecode and uf including. This affects our security tooling a lot, I would say. And yeah, thanks guys.
00:03:08.644 - 00:03:30.764, Speaker D: So for the intro, Nebuchadnezzar will really shortly go through the what Ethereum object format is, but we wouldn't want to focus too much on the technical aspects of it. Today we would like to focus on what kind of impact EOF will have in the space and on developers. So Nebuchadnezzar take it away.
00:03:31.264 - 00:04:29.884, Speaker C: Right, I'm going to do just a short intro, and anybody from the panel can also chime in if they have something to add. So basically, Ethereum object format introduces this new way of how smart contract bytecode should look like. By that I mean it restricts how the, exactly the sections of the bytecode need to behave and look like. And this has a lot of implications. The first one is that on the runtime, we no longer need to do and perform some checks which can in essence help us with the scalability of the whole Ethereum, but as a consequence, we need to do some checks on the deployment time. Right? Yeah, that's basically it. I mean, if anybody has something.
00:04:29.924 - 00:05:08.600, Speaker F: Yeah, I would mention just one important thing that like the whole name is wrong here. Like I was, I was telling the organizers and I think it was changing the schedule, but it's still here. It's not Ethereum object format, it's easy EVM object format. Okay, so we are talking about Ethereum virtual machine, the heart of Ethereum. I want to say the brain, the execution environment, which right now it has to work with just a blob, basically just a bunch of bytecode. When you are deploying a contract, it doesn't have any structure, it's just a bunch of code. And EVM goes code by code, byte code by code.
00:05:08.600 - 00:05:51.136, Speaker F: First it verifies whether it's correct, whether it can even execute it, whether it exists, whether it has enough gas, whether it doesn't break any computation. And this can be well externalized to do it at the moment of deployment, which is great, not just because we save the time at execution, but also we will prevent having just a mess on the chain, which is unexecutable. And yeah, just to mention. So now instead of just random pieces of code, it will be structured like we have a header. This is the code, this is the data. And when the EVM comes, it can tell, like, okay, the header explains the version. That's one important thing.
00:05:51.136 - 00:05:57.712, Speaker F: That will be the versioning. And this is the code that I'm looking for, and I need to verify this. Right, right.
00:05:57.848 - 00:06:13.764, Speaker D: It's good that you mentioned versioning because that's basically where we wanted to start. So like, what will be the implications of versioning? I mean, how do you see that going down and propagating through the levels all the way to the depths or whatever you're building?
00:06:15.264 - 00:06:16.724, Speaker F: Should I talk like it?
00:06:17.144 - 00:06:22.272, Speaker D: I mean, I mean, I can choose who talks, but George looks like he wants to say something.
00:06:22.408 - 00:07:26.108, Speaker B: Yeah, no, I think since we're talking a little bit less technically, more like narrative almost at this point. First of all, I think one thing I want to say is that this is the first big change to the EVM itself, especially after all these upgrades to the protocol. Now finally, we're putting the spotlight on one of the main things, probably about this whole Ethereum ecosystem. So that's first big change and then the second within the change itself we have the notion of versioning. So it's kind of an interesting thing how now we're going to be looking at even more explicitly looking into upgrading very core parts that are of not even necessarily backwards compatible parts of the protocol as we're going to be upgrading them. And then on top of that we're going to even have an explicit versioning part to it, meaning that we are explicitly looking to have several different potentially not compatible versions of code living on Ethereum. And we might have, correct me if I'm wrong, some contracts, they're going to be able to speak to each other in future, potentially not being able to speak with each other.
00:07:26.108 - 00:08:03.704, Speaker B: Let's say if we have Uf version 13, it might not be able to be speaking to version six. And then we were speaking in the green room right before this. It might be interesting that this might spill out to different L2s and how they might have their own dialects of the UFS running there in different containers, or code containers that might be a little bit slightly different from the mainnet and might be compatible, but maybe one way, not the other way. And just overall, I think it's interesting how this isn't just a major upgrade of the EVM itself, but in itself, within the upgrade, we have a notion of that it's going to be changing more and more.
00:08:05.164 - 00:08:50.658, Speaker A: I just wanted to maybe add something that Mario mentioned before, because it's basically, this could be chunk of an executable code. It's actually one of the cool things is that they're going to be introduced also data sections. Bytecode is not only executable code for many things. The parts of a bytecode contain actual data because there is like code copy of codes and so on that can be used for immutables. Right. The factory contracts needs to store the bytecodes of the contracts they need to be deploying also somehow, right? And alternative is doing it as storage, but it's super expensive and there is no way to load large chunks of storage in one go. You only can access it word by word.
00:08:50.658 - 00:09:07.254, Speaker A: So it's like for many places the bytecode is used as a kind of data storage. And for me it's like, this is honestly really nice feature because now you can clearly distinguish between what's executable and what is used as data.
00:09:09.794 - 00:09:37.862, Speaker F: Thank you for mentioning. That's one of the important things to mention, that it's the biggest upgrade to EVM in a while. Like the most significant upgrade we had was push zero this week. Yeah. Like the EVM today looks almost the same, like three years ago. And the folks from the Ipsalon team, Exig, Pavel, Andre, has been working on EVM upgrades since like the evasium era. And this is something which they put a lot of work into.
00:09:37.862 - 00:10:13.378, Speaker F: So I'm hoping that it's going to, like, these changes in EVM are very slow. It's also one thing. So we mentioned versioning. Yeah, I wanted to react to that because I mean, it's like we'll basically now have different, I want to say versions of EVM, but it's not like fully what people might imagine because there is, you cannot. The changes that can be done in each version are still limited. It's more like the new version can add new features, it cannot change things. Right.
00:10:13.378 - 00:11:13.570, Speaker F: So we can see that the contract or the developer can actually see that he's using this version and he's compatible with the new features, let's say. So it might be even easier to add more features, but also it's like maybe more standardized approach to have the various evms around the ecosystem, especially for L2s. Right. Because I think arbitrum already announced it, but the idea was already a year back, at least we could have kind of beta version. I don't want to, don't quote me on this, but like another version of EVM where we improved something and this is running on L2s they tested and maybe it could boost up to maintenance at one point. But again, like this breaks the equivalency which some people are trying to reach. And generally, like, there is a lot of issues with EOf as well.
00:11:13.570 - 00:11:36.374, Speaker F: Like it's not, it's not all fairy tales. Like it's pretty a big problem to. That's why it got pushed from Shanghai to maybe Cancun, maybe prague and. Yeah, and one thing is that now we are going to basically break the EVM for all of the forks, which is like half of the crypto coins out there.
00:11:37.634 - 00:11:39.026, Speaker E: So I'd like to add that.
00:11:39.050 - 00:11:39.186, Speaker A: Right.
00:11:39.210 - 00:12:19.042, Speaker E: So it's not just rainbow and sunshine and there might be also the fragmentation and now it's not only technically a new arena for us to innovate, but also probably politically a new arena for fragmentation, right? So there are political actors like kill switch for small contract. What if someone decides on this EVM, that specific feature enabled by better versioning, which is technical excellence perspective. What if the political kind of hijacking. So I think that part we often, let's talk about in the technical circle, but often in crypto, there's a lot of this kind of good and evil sometimes can emerge as a conversation, especially.
00:12:19.138 - 00:12:29.364, Speaker B: Now as we have a lot of L2s that are coming out like white labeled like exchange based L2s, like let's say the coinbase one. You could definitely see something like that there.
00:12:29.744 - 00:12:54.444, Speaker C: And as well, as you mentioned, the fragmentation of the chains, but you also have the fragmentation in the tooling space. So the layer above the l two s is like. And the EVM is programming language. And the layer above that is the tooling, the security components, the decompilers, et cetera. And they would also need to keep up with all the improvements on the object format as well.
00:12:54.934 - 00:14:03.400, Speaker A: I also wanted to add something about the features because it was mentioned here. Basically we are adding features, but honestly, with the AF one at least, like how it's now, it's technically, we are constraining how the code can look and what it can do. It's technically removal of features, you can say, by forcing this blob of data that's now to be of a certain shape, we are technically disallowing certain behaviors as we're kind of allowed before. And I think, I don't know if it will make into the final eof one or it will be some further eofs. For example, self destruct opcode is going to be kind of replaced by something sell opcodes. And this is, you can say also like a feature removal. Right? And it's technically like even like there was one proposal, our engineer Hubert Riddorf, people know propose to uf itself on the discussions and it's maybe going to be accepted is that there's no going to be longer a way to delegate call from the EOF into the vanilla EVM version, just because otherwise this will be like a backdoor to access all those features.
00:14:03.400 - 00:14:15.044, Speaker A: This technically right now we are removed in UF. But of course going further, maybe Uf three, four, five is going to be more feature rich than UF one, right?
00:14:16.024 - 00:14:45.394, Speaker D: So this is what you actually just said is a nice segue into the following topic, which is basically, I mean, sure there are good sides and bad sides and people are going to use uf in various ways. But how do you see it starting to propagate in the developer community? What do you see are the first use cases or usages for UF in which types of projects? I mean, any kind of thoughts on that front you want to share?
00:14:47.814 - 00:16:02.244, Speaker B: I guess one thing, we're also trying to battle this question earlier and trying to think how is the adoption actually going to happen? One thing that kind of springs to mind and that often how these, especially in our space, these things happen is there's probably going to be a big player, like a big project, big protocol. The uniswaps of the world is going to release their new smart contract version and they're going to have it probably all up to date and then all the t's crossed and the I's dotted with the UF container version with the newest UF, whatever that's going to be UF one or whatever that form is going to take. And they're going to say, we're now fully doing it up to the UEF contract with all the things removed that need to be removed, all the things there that need to be there. And then other players later on, as is usually the case in our space, will start to fork this and that's going to start to propagate this. And then since these are going to be popular contracts, our security tooling is going to need to start to catch up with this and it's going to start to adopt these features more and then other security tools are going to start to follow, and slowly and slowly everything is going to avalanche from there. It's definitely just one of the ways I think that adoption is going to happen. But probably in my head a big player is going to do this and then that's where it's going to go.
00:16:02.744 - 00:16:33.310, Speaker F: It's funny that you mentioned the uniswap because they've been pushing for the 1153. Is it the transient storage? They had their own solution, basically, and now they can. I have to wait for the Eof. Yeah, I mean, because, I mean, first of all it needs to be implemented in compilers, right? I mean, solidity doesn't have it because it. Well, it's not even specified yet. We don't have final EOf specs. So like, I'm, what I'm hoping for is that it will be on the solidity level or the compiler level.
00:16:33.310 - 00:16:48.684, Speaker F: It will be natively or like won't be like some optional experimental feature, but it will be easy to use so it will be basically utilized automatically by any contract. And yeah, hopefully we'll save a bunch of gas. Yeah.
00:16:50.584 - 00:17:21.076, Speaker E: I'm not so sure the increment, increment incremental change is the best way to actually get this out. I'm just wondering if there's chance for a bit more leap forward type of improvement that maybe something from scratch, like a new chain or something that they say, hey, how about we start from scratch in this particular chain to demonstrate something like really, really new, as opposed to incrementally fix something in the ecosystem already. But you guys probably should know more about it.
00:17:21.100 - 00:18:09.586, Speaker B: Actually. Interesting that you talk about starting new chains with these updates, because with things like zkvms, they need to completely rewrite all their circuits with every single upgrade. I even wonder that because there's a couple of ZK VMs supposedly already alive today for them to upgrade with this new EOF version. I wonder if it's easier to just start a new L2 and then start a new instance of their zkvms with these upgrades, as opposed to maintain the existing one, and then try to upgrade it to the newer version with the eoF. But to actually support these leaps is what you're saying. Because for them, especially for these circuit based ones, it's going to be very difficult to always keep up to date with incremental upgrades for all of this.
00:18:09.770 - 00:18:52.754, Speaker F: Yeah, I mean, it's great. You mentioned it like it was one of the point to be raised. Like there's like five Zke EVM projects right now, and they will have a, like, it's not trivial to change something so big as EVM there or the EOf there. But also on the, for all of the client teams, for all of the Ethereum clients, what it means now is that they basically need to maintain different versions of EVM because you want to do the full sync and now you need with each hard fork, or like in this case, let's say with each EVM version, an EOF version later, you need to execute this piece of student deduction that, okay, we switched the new one and that's a lot of code paths to be maintaining. Yeah.
00:18:53.494 - 00:19:30.352, Speaker C: And on the adoption, I think George and Mario, you mentioned a good thing. I think that this space is incentive driven, and dapps need to find a way to reach the broader audience, and for that they need better virtual machine. And so they are pushing for the innovation of the virtual machine. Then the virtual machine is pushing the innovation on the compiler level, then they are pushing the innovation on the tooling and then we are also giving it back to the dev developers. So it's this whole circle of incentives that and everybody is pushing in the right direction.
00:19:30.448 - 00:20:10.880, Speaker A: But yeah of course it's like this innovation, I think essentially this for Uniswap as well, it was motivated by doing the same things but cheaper. In the end transaction gas you need to pay for and the less you pay the better. Exactly. The EOF how I see we are disabling jump up codes and introducing new static jumps and cofs because. Exactly they're not going to needs to do the checks on like validity of the destination addresses and so on. I think it's most likely they're going to be cheaper. And this adoption can come just from the fact that using EOF one is cheaper.
00:20:10.880 - 00:20:11.624, Speaker A: Right.
00:20:11.784 - 00:20:58.718, Speaker B: I also recall, I think that now, well now once EOf comes out on chain validators specifically for like L2 is like a thing for optimism say you know, the arbitrums of the world. I think even for them it's not going to be actually cheaper to run their on chain verifiers to actually verify the state changes submitted by sequencers. And that's cheaper proofs, cheaper rollups and that's downstream cheaper for the users of those roll ups. That's also more adoption, right? If I'm one L2 that doesn't adopt this and my competitor adopts it and now suddenly they have much cheaper gas costs for their transactions because of the EOF, because their on chain validators are that much cheaper. I'll be that much more encouraged to adopt this new version as well.
00:20:58.886 - 00:21:19.546, Speaker D: Do you guys think, I mean one of the biggest things with EOF is definitely a much better utilization of resources and paying less gas and cheaper gas. But do you think that EOF will have an impact on security, a positive impact on security as we hope it will or we're going to find some other problems down the road I would.
00:21:19.570 - 00:21:23.010, Speaker A: Say it's really a good question and it's really undetermined.
00:21:23.162 - 00:21:24.042, Speaker D: That's why I'm here.
00:21:24.138 - 00:22:31.274, Speaker A: Yes. Last thing I remember was one update in Constantinople I think where the storage operations were repriced and something like Ethereum solidity was using the gas limit for enforcing operations during the calls that just need to send the value and you had enough gas on 2100 gases to basically emit an event. And after the reprise you actually could do some storage operations. And it was problematic in this case. What I'm thinking, what's essentially happened in that update and why it's relevant to us, the system allowed more behavior than it was before. Now with UF, at least how it looks like again, the behavior is not edited, removed mostly. So at this point, I would say once there is no backdoor to delegate callback to the more feature rich UF.
00:22:31.274 - 00:22:47.796, Speaker A: I'm not super concerned about the security because you technically just making more restrictive systems that shouldn't break easily. But of course because the tooling needs to catch up with all these changes, maybe there's going to be some compiler bugs again and so on.
00:22:47.820 - 00:22:48.384, Speaker F: Right?
00:22:49.444 - 00:22:58.024, Speaker A: This is always a danger, right? It takes a while to test and to validate such big changes. So yeah.
00:23:00.324 - 00:23:32.614, Speaker C: You mentioned before the call app of code, I think it's going to especially help us validate not just certain contract, but look at the whole chain more holistically and understand better what's going on. Like right now, when you have the EVM execution, you basically almost have no idea what's going on with non verified contracts. But with the EOF and the code sections, we can better understand what's happening inside there.
00:23:33.534 - 00:24:38.992, Speaker B: Yeah, I think to that point, especially because a big thing right now in security is doing war room analysis, post mortem analysis, and trying to determine what happened where with what contract and what happened with those transactions. With EOF. Supposedly it should be much easier to actually perform some of these analytics on the attacker contracts and whatnot. But it's interesting because assuming that once a UF comes out, you will still be able to for some time deploy legacy contracts, which are a lot more of a random byte, not random, but unstructured bytecode that is much harder to actually decode and understand. I wonder if the attackers in those cases will exclusively deploy non EOF contracts to throw off all the new tooling that will be better able to understand EOF contracts instead. But of course that's, I think going to be attackers are going to attack always haters going to hate. But on the other hand, for good contracts and for good bugs, good bugs, you know, non maliciously occurred bugs.
00:24:38.992 - 00:24:44.336, Speaker B: With EOF, it's going to be much easier to understand what happened and what's going on there and what those attacks.
00:24:44.360 - 00:25:20.498, Speaker D: Did besides EOF, obviously improving the development process and hopefully the average quality of a smart contract. Do you guys see like EOF or like smart contracts being used in any kind of. Well, I don't want to say innovative a is because everything that we're doing in this space is more or less innovative, but something that we haven't seen up until now. Is it going to open some new doors for people to do things differently or to do new things or something like that immediately.
00:25:20.546 - 00:25:40.960, Speaker A: No, I mean in UAF itself, like the one that's going to be recent, it's like again, less feature. So say something that's now present in solidity, like function pointers, it's going to be pretty harder to do it without dynamic jumps. Right. But what's big thing is versioning, right?
00:25:40.992 - 00:25:41.256, Speaker B: Yeah.
00:25:41.320 - 00:25:44.724, Speaker A: And with versioning all the doors can be opened.
00:25:46.664 - 00:25:54.368, Speaker F: Axig had this dog, but it was like a year or maybe two years ago about how EOF can work with echo and abstraction.
00:25:54.416 - 00:25:54.992, Speaker B: Yeah, yeah.
00:25:55.088 - 00:26:27.324, Speaker F: So actually we might see some improvements on that front, like actually utilizing it for more effective or more feature, full account abstraction. And yeah, I'm wondering how the data, like now when we have the space for the data, whether it will be maybe. I mean what I was hoping for before was that this can be utilized better to store the l two data, but we will have blobs for that maybe sooner than EOF. So yeah, we'll see about that.
00:26:29.064 - 00:26:44.324, Speaker D: And like since the effects of UF will propagate and you guys mentioned like we need to develop tooling and everything else. And this is not a tendril issue, although it's our panel. How do you think UFL impact tooling as a whole?
00:26:48.224 - 00:27:35.064, Speaker A: I can start. Yeah, we're doing like security tooling, right. And sometimes like we did like static analysis on a bytecode. Technically it should become easier for such kind of tools, which needs to defend the bytecode analysis just because dynamic jumps were, let's say, not the most ideal thing to deal with, especially during some symbolic execution when you can jump to symbolic, I mean, solidity, things got in most cases had a good enough invariance where never happened. But for generic bytecode, it's like any bytecode that you can ever deploy, it was a real problem. So for security tooling on a byte code, it's going to be most likely easier.
00:27:36.124 - 00:28:13.682, Speaker B: An interesting thing there is, I think there was some comments also online around EOf about this. Is that because we had to deal with these problems as is in security, telling some of them, maybe even the majority, have already been kind of solved. Like we've adapted our security tools for that. So ironically, while the impact is that it's going to be easier to create newer versions on this EOF stuff, we've already have existing code to deal with the previous problems. So we're going to have kind of like both. It's just going to be easier to adopt, I guess, newer tools and create newer versions of these tools. But also interestingly, we're going to need to maintain both for the time being to take care of the legacy contracts as well.
00:28:13.682 - 00:28:23.718, Speaker B: So there is a little bit of that slightly negative thing now that we're going to have to take care of both types of contracts or styles of contracts on chain.
00:28:23.846 - 00:28:45.404, Speaker E: I think the existing tooling is definitely will push back on this because no one pays them to actually do the upgrade. Ethers can have to upgrade their stuff, they're well paid. But there are people that doing other toolings may not have the position to actually support both versions. The economic incentive has to be also there for them.
00:28:45.944 - 00:29:34.534, Speaker C: Right. And then yeah, you mentioned an interesting thing that the tooling is going to have to keep up. I mean, I completely agree with that. The interesting part there is that we're still in like this is the version one and the community is still yet to see the real implementation of this and the possibility of the EOF. I think that once they get a sense of how they can utilize this, what would be the improvements for them that they, if were implemented that they would benefit from? Like we're going to see a huge number of use cases for it and then the tools and security components will try to adapt based on that. And I think there's like huge room for improvement in that area.
00:29:37.004 - 00:29:37.708, Speaker E: Awesome.
00:29:37.836 - 00:29:41.420, Speaker D: So the spotlight is back on me. You want more hard questions?
00:29:41.612 - 00:29:42.420, Speaker A: Please.
00:29:42.612 - 00:29:44.744, Speaker D: No, I have one more because.
00:29:46.604 - 00:29:46.892, Speaker B: At.
00:29:46.908 - 00:30:19.524, Speaker D: Least some of the people will want to know. Well, UF is just getting started and we don't really have still any kind of best practices or guidelines or use cases which you could refer to either good or bad. Like do you think that the best practices will be led by Ethereum foundation or the team behind the EOF? Or it is more likely to come from one of the projects which will implement it well and use it well and act as a use case to be replicated throughout the industry.
00:30:20.864 - 00:30:37.420, Speaker B: I think it's a silly answer, but all of them specifically because the team behind the, that's pushing the EOF, the team ipsalon that you were mentioning, I mean they're just excellent. I mean they maintain so many pages about this and they constantly update all of them and they provide all of this stuff.
00:30:37.492 - 00:30:38.476, Speaker F: So many Hackham Dd docs.
00:30:38.500 - 00:31:16.374, Speaker B: Yeah, yeah, exactly. I don't know how many Hackham Dd docs I had to go through for this panel. So without a doubt. I feel like once we get closer to implementation and once we have all of these things already set up with the specs and whatnot they're gonna also give out, here's what we think is best practices because of course their child, their baby. But likewise, I think as I was mentioning earlier, I think one or two bigger projects are going to try to jump on this to also claim the spotlight, quite frankly. Say we are the first big one that adopted fully this EUF spec and here's how we did it. Here are our best practices and then that's going to be the new holy grail of other developers projects to follow this.
00:31:16.374 - 00:31:35.014, Speaker B: But I do think there's definitely going to be different pushes and some for altruistic reasons, like the Ipson team help out with their own little project for the sake of the ethereum ecosystem and some a little bit more lucrative to like say like we are the first ones who got this UF spec right and here's our best practices and do it like that.
00:31:37.594 - 00:32:09.994, Speaker F: Yeah. Just to mention again, like with the hackmd pages, I believe that actually made some like solidity examples or some examples or of how EOf should be used. Not sure if it's best practices, but because I mean, we are still too early, not that we don't have implementation. The specification is also not properly figured out. Like what I would recommend the latest reading is the mega EOF end game, if I'm correct. Right. So that would be the current state of the EOf.
00:32:09.994 - 00:32:23.214, Speaker F: And then. Yeah, what I'm interested in, what will we find will be the race to be the first contract, not like do it properly, but just to be the first EUF contract on the main ad. Yeah, we saw that with push zero as well.
00:32:23.294 - 00:32:24.474, Speaker B: First DK Vm.
00:32:27.374 - 00:32:32.214, Speaker F: So you can make NFT out of that or whatever. First EUF and made it well, we.
00:32:32.254 - 00:32:47.288, Speaker D: Probably will make an NFT out of it. We have a couple of more minutes. I would like to leave this time for you guys to share some final thoughts or whatever you find interesting about EOf or like, you know, whatever crosses your mind.
00:32:47.416 - 00:33:31.304, Speaker A: I actually have a question to the rest of the question. I have a question. So like we mentioned, it's like best practices, but this practice, best practices. You mean like for most developers, they are not working with a bytecode, right? They're working with solidity in this case. Are you thinking that like solidity will change a lot because of how the bytecode that solidity needs to compile into will change? Honestly, it's like there is a layer between developers and bytecode, which is solidity. And I expect like if it's done well, people won't even feel the change maybe the only best practice so far. Don't use function pointers.
00:33:33.054 - 00:33:49.894, Speaker B: Not really quite sure on this one, but I feel like I'm going to. Correct me if I'm wrong, colleagues, but you could end up utilizing the data part of the code a little bit differently. And I feel like there could be some clever tricks and best practices around that that could be utilized. So things like that I think could come up.
00:33:50.014 - 00:34:10.792, Speaker F: I mean, like the best practices are inline bytecode, right? If you are a proper solidity hacker. So I mean there is the layer, but yeah, I mean that's what I was mentioning. Like I hope that sold it to implementation. The compiler will work so smooth that like we won't even notice. But still, for example, version is something that you need to work with, right. There will be some subtle changes that we notice.
00:34:10.968 - 00:34:16.232, Speaker A: It's very interesting and speculation like what if wiper does Uf better than solidity?
00:34:16.328 - 00:34:32.566, Speaker F: Yeah, actually I wanted to mention, like that's another thing with the tooling that I hope that Viper will catch up on UF and fee fe as well, which is also already production ready and nowadays will have a lot of work to catch up as well.
00:34:32.750 - 00:34:45.554, Speaker D: Yeah, but in a way they have. In a way they have less work to do because they haven't been so spread out. But I get your point completely. Nebuchadnezzar, some closing thoughts.
00:34:46.014 - 00:35:23.634, Speaker C: Just that I'm really excited about the implementation of DOF. It's been like what, nine years since we made any significant changes on the EVM bytecode, and this opens the door to new possibilities. And like once we change the base layer, the layer above that are going to change as well. And probably introduce some new way of developing and more introduce ways of having more security on each above layer as well.
00:35:23.974 - 00:35:47.040, Speaker B: Yeah, I completely agree. I think the most exciting part for me is like what this change means, and that it's not a protocol change now, it's the EVM, the computing change, and in itself it has suggestions for future changes and future upgrades. And I feel like it's just going to encourage a lot more, maybe even wild experimentation on what could happen with the EVM later. And yeah, that's just exciting.
00:35:47.192 - 00:36:02.934, Speaker D: Awesome. I honestly completely agree with that. Guys, thank you so much for being a part of this panel. I think I speak in everyone's name that we all enjoy this. And for you guys, thanks for listening and I hope you found this fun and useful. A big applause for the guys.
