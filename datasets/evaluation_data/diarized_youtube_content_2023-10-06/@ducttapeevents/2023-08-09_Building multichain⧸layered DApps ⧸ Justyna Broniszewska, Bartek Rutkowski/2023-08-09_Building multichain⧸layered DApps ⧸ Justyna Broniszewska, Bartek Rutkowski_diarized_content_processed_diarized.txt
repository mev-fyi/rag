00:00:10.480 - 00:00:40.874, Speaker A: Thank you very much for that, Andre. So we're going to move on to the next talk now and we're hopefully back on schedule for the live stream. This is coming from Prague, Czech Republic, and we have a studio audience here as well, so looking forward to hearing something from them. If you have any questions as well from the live stream, then you can post them in the Telegram channel. But to move on to the next presentation, it's going to be Justina Bronizevska at Bartek Rutkowski talking about building multi chain dapps.
00:01:00.184 - 00:01:01.364, Speaker B: And take it.
00:01:26.534 - 00:01:34.502, Speaker C: Okay. Okay, the mic is on. GM. Everyone. Can we get the slides? Thank you.
00:01:34.598 - 00:01:45.634, Speaker B: GM Prague. Welcome to our presentation. My name is Broniszewska and this is Bartek Rudkowski. And today we will tell you about building multi chain, multi layered dapps.
00:01:46.334 - 00:02:28.844, Speaker C: So what could possibly be hard about building Dapp front ends in general? Well, apparently there are several hard things. So to start with, we have like many different tools that are battle tested, very well known, everyone works with them, but they come from web two. So they solve web two problems, not necessarily all of the web3 problems, and many of these we have. So first thing is that the core of the web3 app is almost always the user's wallet and his account. And before he connects to that, we need to show something. Usually we see apps that show nothing, only a large connect wallet button and nothing else. That's a problem that we need to solve.
00:02:28.844 - 00:03:12.596, Speaker C: Also, we need to always show the fresh state of the app. So the state of the app changes each block. So it's like 15 seconds or even faster. And our app needs to follow that, needs to update all the time, everything, while at the same time we need to keep the number of requests in check. If we have an API key that we pay for and we want to now fetch hundreds of different data points of different smart contracts, we can spam API very easily and the app will be very hard to operate. Also, we need to gracefully handle switching wallets. So do not refresh everything, but refresh some of the things and do that immediately.
00:03:12.596 - 00:03:43.210, Speaker C: And the same with switching networks. And then we also need to track transactions. So we send transactions, then it's pending, then sometimes it's successful or it fails or we just fail to send it or the metamask rejects it. And also we cannot lose that context and the history of these transactions. So we can show notifications, we can show all the history, even if user is changing the tab or going somewhere else in the app. And yeah, so quite cumbersome yeah, so.
00:03:43.242 - 00:04:07.594, Speaker B: We had all these problems and we were, you know, repeating all over again the same scheme of the Dapp and of application. And then we decided that okay, let's create a library and we created used app and it's a framework for rapid Dapp development and it supports Ethereum and all EVM compatible blockchains.
00:04:08.174 - 00:04:43.434, Speaker C: So if you hear framework then you probably think yeah right. So we had react angular Vue and now there is something else that's like web3 native. Well not completely, that's not the case. So usedup is just a set of utilities that operate on top of the react framework. So you can easily continue using the web two tools that you know, but with native web3 support and also use that works with ethers, web3 react and waffle. So the usual tools that web3 developer on the front end might use.
00:04:44.414 - 00:05:01.104, Speaker B: Yes. So let me go quickly through all these features we have and then we can dive in deep into them. So we have connection management, reading blockchain state efficiently, we handle easily transactions. We have multi layer support and also built in support for type chain.
00:05:01.184 - 00:05:06.000, Speaker C: So if you are not a JavaScript type of guy, but type chain type of guy is here for you.
00:05:06.152 - 00:05:36.286, Speaker B: Exactly. So as for the connection, we have read only mode out of the box built in. We have also network switching and handling multiple networks like L2 and layer one. So let's go to an example. So to start using used up you just need to wrap your application with dapp provider and dapp provider needs config. So you need to pass config. And it could be as simple as that with only two parameters.
00:05:36.286 - 00:06:41.614, Speaker B: And one very important parameter is this link to, let's say infuria in this example. So your application will work in read only mode for mainnet in this example. So here we have an example of connecting a wallet. If you develop applications in react, you probably know hook paradigm and we also use it and you can see use eaters, it's like main function of usedup and it can give you all these helpers that we have. And in this example we use this use eaters function for getting activate browser wallet and account. So account is actively connected, actually connected account and it's just a string, it's just an address of this account and activate the browser wallet is a function that you need to call to connect to metamask. So the code is very easy, we have only like two lines to connect to wallet and then display balance of ether balance.
00:06:41.614 - 00:07:18.032, Speaker B: And here another example of how we can get ether balance and the first line is just for readonly state. So we can just get iter balance of anything. And in this case it's just a staking contract. And then we call use ethers to get account address. And then in the fourth line we just call use ether balance with this account that is connected. And then in the following lines which is displayed to user. So let's see if this video will work.
00:07:18.032 - 00:07:28.204, Speaker B: But you can see this application, this is in a read only mode. And when I started then. Not like this. Maybe like this.
00:07:29.904 - 00:07:32.360, Speaker C: No, not like this.
00:07:32.432 - 00:07:57.254, Speaker B: Okay, so yeah, maybe someone from the backstage can help us with displaying this video. Okay, so probably you need to trust us that this works. So when you click connect button then you will see the address. Okay, maybe I need man's help.
00:07:57.554 - 00:08:01.494, Speaker C: Oh no, sorry, not like this.
00:08:02.634 - 00:08:21.674, Speaker B: So it worked on our computers. Probably every developer heard that. Okay, so yeah, and when you click connect button then you will see address and then balance. Okay, let's go to another example. Yes, so about reading blockchain state.
00:08:22.214 - 00:08:44.914, Speaker C: So I'm only gonna add that the thing that you can imagine that happened on the video was that not only after connecting the wallet, it displayed the balance and the address, but also then we went into the metamask and change the network. And immediately the state was updated to view the balance on the other network. And when we changed the wallet, it also automatically changed the wallet that was connected to the other one and displayed the new balance.
00:08:45.614 - 00:09:15.800, Speaker B: Exactly. And this is how we can actually read the blockchain state. And Usedap helps you because it refreshes the state on each new block. It also refreshes on every wallet change. And additionally, all these calls are, are combined into one single call and it's done via multicall. So you won't spam any API with too many calls because it's just one single call.
00:09:15.952 - 00:09:54.372, Speaker C: There's also another important aspect of using the multicol, because if you imagine yourself making ten calls, 20 calls or 100 calls within the lifespan of one block. So within like 15 seconds, it's possible that some of the calls will arrive to the node at block x and some of the calls are going to arrive and going to be resolved at the block x plus one. So the state might change and you will get an inconsistent state of the app. This is an important reason to use a multicol. So then all these like hundreds of calls potentially are going to be combined into like one API request. And all of them are going to be for. We can be 100% sure that they're going to be resolved at the same block.
00:09:54.372 - 00:10:00.954, Speaker C: And the state is going to be 100% consistent all the time, because it's just one call.
00:10:01.454 - 00:10:30.570, Speaker B: Okay, so we have another example. Actually that's the same example. I mean the code hasn't changed, but what changed we just sent. Yeah, was the demo we wanted to send here a transaction. So actually, yeah, this is what happens when, what you can see after we connect our wallet, so we have this account and then our balance is displayed. But right now when we. Let's try it again.
00:10:30.570 - 00:10:59.298, Speaker B: Maybe this button this time is going to work. No, maybe you can help us with starting this video. Ok, let's try it. Yeah. So let me describe what should happen. So we have metamask opened, and then we send a transaction to someone else. And then right after this transaction is successfully mined and we can see it in metamask, our balance changes.
00:10:59.298 - 00:11:06.242, Speaker B: So we don't need any additional code. So this is still the same code we had previously, but it just updates.
00:11:06.378 - 00:11:16.054, Speaker C: And what's important, we don't refresh the whole Dom of react, we only refresh this one particular component that displays the user balance. And it's not like heavy on computation.
00:11:18.664 - 00:11:51.638, Speaker B: So we can also not only read iter balance, we can actually call any smart contract. And here we have an example of very well known ERC 20 token balance. So of course ERC 20 interface is always the same. Should be. And we created all these helpers for ERC 20 or different known contracts. And here you can use it, of course. But here is an example how you can create your own helpers for your smart contracts, because they can be different.
00:11:51.638 - 00:12:24.532, Speaker B: Right, but I won't dive into that. So let's talk about transactions, so we can track transaction state. We can have history and notifications. So let's go to examples. So here is an example of how to send ether. You just need to call, use sendtransaction function, and then it will return you state and send transaction. Send transaction is just a callback that you need to call with transaction parameters.
00:12:24.532 - 00:12:48.016, Speaker B: And state is the state of the transaction you sent. So here are different states. We have non mining success, fail and exception. We have another demo video. Okay, we can do anything. So I will just describe what will should happen. And we can show you after presentation on our computer, because we have it as well.
00:12:48.016 - 00:13:07.222, Speaker B: Yeah, so right here we just click this button send. And actually under this button send, we have this sending transaction called. And then you should probably see on, you would see on this video we have this state of this transaction. So as soon as you click send.
00:13:07.318 - 00:13:09.526, Speaker C: It'S like there's going to be metamask.
00:13:09.630 - 00:13:50.092, Speaker B: Yeah, of course metamask, sending confirmation, et cetera. And then after we send this transaction we have mining state. So it's like our transaction is in the mempool and then we have also this notification from user notifications. And right after is successfully mined we have status success. And also we have a notification about that. Yeah, the same we can do with smart contracts iterations. So we just simply call usecontract function with contract that you probably know from ethers library.
00:13:50.092 - 00:14:26.034, Speaker B: And then you need to pass. Another parameter is the function name you would like to call. And here are withdraw and deposit functions. And additionally we also have state return from usecontract function. And then this send callback that you need to call if you want to provide this function. And another demo we wanted to show you. So here we just like send our ether to wrapped ether and then we wrap our iter and you can see also like balances.
00:14:26.034 - 00:15:04.538, Speaker B: So right after we wrap our iter, then our balance will like if balance will decrease and then wrapped iter will increase. And additionally we also have these states here and notifications. Yes. So the final like, like the feature we all came here for is like multi chain support. Multilayer support. So let me show you the example of how to do that. So here we just can call like for iterbalance on three different chains.
00:15:04.538 - 00:15:20.284, Speaker B: So to do that you just need to pass additional argument, which is chain id in this case. And here we have mainnet, arbitram and cksync testnet. All these different balances displayed in one view.
00:15:21.304 - 00:15:44.538, Speaker C: Yeah. So without changing anything, you can read from multiple chains at the same time. But in order to write to a particular chain, you need to switch to that chain. Like for example in metamask. So the transaction is going to be signed and prepared properly. So you can use the switch network utility. And then whenever you wish to send transaction to a particular network you can use that function.
00:15:44.538 - 00:15:58.494, Speaker C: And then you can for example check whether the chain id you are currently connected to is correct. And if not then you enforce the network switch. The metamask pop out will appear and will change the network.
00:15:59.074 - 00:16:08.972, Speaker B: Yeah, so you can see that you just need to check whether the chain currently like active chain id is different than mainnet. Then you need to just, and force user to just switch network.
00:16:09.108 - 00:17:23.288, Speaker C: So we can imagine for example like one slide before that you have three different pools deployed on three different chains. And then when you click deposit, you check whether this pool is on the network that you are currently connected to, and if not then it's going to switch the chain automatically and send the transaction also using the transaction history. Super easy using the notification as well. Yeah, recommend to checking out the documentation for details. And one more important thing about the usecontract function call is that it doesn't only return you, only allow you to perform the transaction, and doesn't only return you in the state, but also is capable of returning you the array of events that were emitted during that particular transaction execution. So you do not need to, after the transaction is processed, somehow call the node to check what events were emitted in that particular block, in that particular transaction. You just get the array of the events right away and no pain, no additional effort attached to that.
00:17:23.288 - 00:17:42.723, Speaker C: And it can be really hard sometimes. We have a bunch of other goodies that can help you develop the most powerful app possible. So gas prices, block metadata, explorer links, everything already baked into the library.
00:17:43.823 - 00:18:27.304, Speaker B: We support all this, as I said before, we support all EVM compatible blockchains, Ethereum, mainnet, testnets, L2, Binance, etcetera. But the nice thing about that is that we can support your own chain as well. So we can do it in two different ways. So you can just set up used up in your application as you want with your own chain. But additionally you could create a pull request in our repo and then add your chain to our support chains. And of course it will just very easy pull request, it's just like ten lines or something like that. So if you would like to do that, just go to our documentation and see how you can do that.
00:18:28.604 - 00:18:59.226, Speaker C: Yeah, and there is also another feature which is super important in my opinion, which is the browser plugin. So the browser plugin for usedup works for Mozilla and Chrome for now. And it tracks under the hood events. So not the events that were emitted on the blockchain, but events that happen at the core of the used app, also manages APIs and ducks. And this is what the plugin looks like. So you can see the tab that it's the use the plugin. And on the left you can see the list of all the stuff that happened in the application.
00:18:59.226 - 00:19:48.744, Speaker C: So you see that the main net network was connected, that the network was changed to Kovan, that the account was connected, there was new block mined, there was another network change, all of that with a timestamp you can easily debug your application, you can see what was exactly happening. And that makes developing extremely easy and what's next. So we recently released used up 1.0, so we consider used app to be somehow feature complete. At this point we see it as a whole, though we are of course working on it all the time. So right now we are working on optimizing the RPC requests even more. We are working on more flexible, more powerful and more advanced config as multi chain support is the thing that we want to improve even more.
00:19:48.744 - 00:20:19.004, Speaker C: But if you have any ideas, any feature requests, there is anything that you thought that you're going to hear about, but we somehow skipped this, then feel free to talk to us. We are open for any external contributions. We are open for resolving any issues. You can start with usedap today by just scanning the QR code which will lead you to the page where you will find documentation, sandbox examples, descriptions, discord link, everything that you need.
00:20:20.104 - 00:20:38.614, Speaker B: So thank you guys for today. Thank you for hearing our presentation. We are happy to answer any questions you have. If you want to do it right now, or if you want to just text us, just feel free. These are our handles, Twitter, telegram, whatever you prefer. Thank you. We have.
00:20:38.614 - 00:20:41.574, Speaker B: Okay, thank you, thank you.
00:20:45.474 - 00:20:50.934, Speaker A: We also have a microphone for the question so that the people on the live stream can also hear. Thank you very much.
00:20:53.474 - 00:20:54.414, Speaker B: Thank you.
00:20:57.334 - 00:20:58.714, Speaker C: Or just the browser?
00:20:59.294 - 00:21:05.974, Speaker B: Yes. So currently you can actually react used app works for react applications.
00:21:06.054 - 00:21:09.514, Speaker C: Yeah. So just the browser, not react native.
00:21:10.534 - 00:21:16.086, Speaker B: Probably if you set up it with react native it should work in my opinion. That's what I guess.
00:21:16.230 - 00:21:23.918, Speaker C: Okay. Yeah, we weren't trying this explicitly, but I don't see any reasons why it shouldn't work.
00:21:24.046 - 00:21:26.554, Speaker B: Yeah, perfect. Thank you. Thank you.
00:21:29.374 - 00:21:58.018, Speaker A: Okay, does anyone else have any questions? We have maybe some questions from the live stream. I have some questions as well, but anyone from the audience. Okay, so I have a question. So you talk about how you're open to contributions, pull requests, raising issues, fixing issues. Can you talk a bit more about the kinds of developers you'd be looking for? Like are they, what level in the stack would be the right people to contribute? Or anywhere?
00:21:58.146 - 00:22:15.214, Speaker B: You can be contributor wherever your experience is. Right. So you can just read our documentation and see a typo there and decide, ok, I will open a pull request and then fix that. So we are open to any kind of contribution.
00:22:15.554 - 00:22:42.326, Speaker C: Yeah, and we really mean that because for example, adding a new EVM compatible network is a dead easy pull requests and we are happy to merge such a pull request. While still some, I don't know, heavy optimizations on the calls level is hard stuff. And if you want to work on that, then you're also welcome. Probably JavaScript knowledge might be necessary, but other than that I think there are no requirements.
00:22:42.510 - 00:22:50.280, Speaker B: Yeah. And currently we are having some issues from community and we are like, yeah.
00:22:50.312 - 00:22:55.552, Speaker C: Constantly working on them. So maybe if you want to help with resolving them, then you're welcome as well.
00:22:55.688 - 00:22:56.404, Speaker B: Yeah.
00:22:57.464 - 00:23:13.888, Speaker A: Okay. And I have one more question, which is how does your project contribute to Solarpunk? It's a bit of a broad question, but Solarpunk is one of the themes for this event. Can you think about how your project connects with the Solarpunk concept?
00:23:13.976 - 00:23:51.730, Speaker C: Yeah, so I think it connects with both the solar panel and the concept of the hackathon as well. Because imagine if you have an idea or a proof of concept to build, then you don't want to spend that much time on creating the low level stuff. This is the thing that helps you spin up the applications super fast. So you only focus on the smart contract part, on the core idea and you do not need to dive too deep into the technical details. So if there's anything that you want to test, if there's anything that you want to show to people, then probably this is like the easiest way of having something bootstrapped and working within like hours or minutes.
00:23:51.922 - 00:23:53.174, Speaker B: Yeah, even minutes.
00:23:55.114 - 00:24:06.614, Speaker A: Okay, I believe we have a question at the back. Ah, Nike, please stand up. Thank you. Hi, I really enjoyed your presentation and I liked the project, but I was really wondering if you guys were making a Vue JS version as well.
00:24:07.394 - 00:24:12.414, Speaker B: Vue js? I'm not sure. Does anyone use Vue js in web free?
00:24:12.754 - 00:24:14.814, Speaker C: So someone of course does.
00:24:15.394 - 00:24:26.226, Speaker B: Yeah, maybe. I mean like if you use like Vue js, maybe you could be a contributor and help us support Vue js. That would be great.
00:24:26.330 - 00:24:44.790, Speaker C: Yeah, I would put it like this. We ourselves mostly use react so we know exactly how react works. Like deep under the hood and we were able to like to go to a very low level of react to integrate everything really smoothly.
00:24:44.862 - 00:24:46.214, Speaker B: So you see the best from react.
00:24:46.254 - 00:25:10.064, Speaker C: Yeah. And I'm not sure if we would be able to do that with Vue because we don't have that advanced knowledge of Vue. But I guess if there is someone willing to work on the Vue version and sees the possibility of adapting, use that idea to the view paradigm, then we are super happy to talk about this and, and work on that as well.
00:25:13.444 - 00:25:16.064, Speaker B: Okay, do we have any more questions?
00:25:19.484 - 00:25:22.732, Speaker A: Okay, then I think that maybe wraps it up. Thank you very much.
00:25:22.788 - 00:25:23.364, Speaker B: Thank you guys.
00:25:23.404 - 00:25:23.932, Speaker C: Thank you very much.
00:25:23.948 - 00:25:24.164, Speaker B: Thank you.
