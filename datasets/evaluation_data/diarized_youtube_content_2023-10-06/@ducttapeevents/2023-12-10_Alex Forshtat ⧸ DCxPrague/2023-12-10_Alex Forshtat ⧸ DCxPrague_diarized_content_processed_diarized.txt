00:00:02.440 - 00:00:46.676, Speaker A: Hello everybody, my name is Alex Forstadt. I work with the ERC 4337 team on account abstraction. And today I will talk to you about the new project that we are working on that's called native account abstraction. So when we talk about native account abstraction, there are three main questions that we want to ask ourselves. One is what are we abstracting? The second one is what do we enshrine and make native? And the third one is like, why are we doing it? So let's dive into it. First question is, what even is an account for us when we're talking about it? So an account for us is an entity that represents a user on blockchain. We are talking specifically about currently externally owned accounts.
00:00:46.676 - 00:01:31.914, Speaker A: So it represents the user with an address. The address has a 20 byte string, the address that holds Vale is ether and tokens. And this address is controlled directly by the private key, by ECDSA private key. This is the address that will be executing a transaction, which means calling the target contract with call data that is provided by the user. And this is also the address that will be charged for gas during the transaction. The transaction is paid by this account, and this is currently all part of the Ethereum protocol. It is encoded and enshrined as a protocol, this kind of accounts.
00:01:31.914 - 00:02:27.464, Speaker A: So the next question is, what do we abstract away? So basically we abstract all of these things away. And when we say abstract, we mean that we allow contracts to change how these things are done. So you still have an address. This address is controlled by smart contracts. There is a contract deployed to this address and now this is a contract that holds tokens and value and does that. So this is not different from a multisig. However, we abstract away authentication entirely, which means the transaction will be valid if the function that we defined in this contract, called validate transaction, returns a correct value and not by a given verifying the given private key, a signature.
00:02:27.464 - 00:03:22.550, Speaker A: We also obstruct the execution. Instead of just user providing a target and the call data to invoke it, we give the data to the smart contract to decide what to do with it. And we also abstract the gas payment, meaning that it doesn't have to be the contract that is an account who pays for gas. We allow other contracts to pay for these gas, other entities to pay for the gas of this transaction. There are limitless endless possibilities with a client abstraction, but I would like to give some examples that are not really possible with externally owned accountants. Authentication. We have one way to authenticate a transaction, and for some users, the one we have to sign a transaction every time can be way too complex.
00:03:22.550 - 00:04:13.074, Speaker A: Let's say there is a game that wants to introduce a gaming session. If every action in this game is a transaction, you will be constantly clicking your metamask. Confirm confirm confirm. With account abstraction you can generate a target specific session key that enables the site to do what it wants with the targets that you approved and for other use cases. This authentication with the single private key cannot be strict enough. Like a corporation, we want all accounted controls to multisig with a threshold, and we also enable that natively. Currently they would have to still own an operator private key that controls their multisigs, so it creates also a lot of friction.
00:04:13.074 - 00:05:06.834, Speaker A: We natively enable ways to recover these accounts. We can finally have a native UI for social recovery. And another major feature that is missing for externally owned accounts is replacing your key. So let's say you had your twelve words written on a piece of paper and you kept it in a book and now you are not sure if anybody saw them. So you want to change your key, but you also have positions on exchanges and you don't want to migrate all the assets to a new address, but you want a different secret to control your account. We will enable that with account abstraction, but with UAE it is not possible. The great opportunity to pay for gas for Dapps that want to onboard new users who may not have a correct asset or any assets on a given chain.
00:05:06.834 - 00:06:11.334, Speaker A: Previously, in most cases there was still a process of you need to get these girly optimism tokens to make a transaction on this chain. If you get an airdrop of our tokens with gas abstraction, you can pay in other tokens, or ADAP can outright sponsor specific actions of an account. And with extracted execution we can have use cases that were previously basically impossible. Like an account can make a batch of transactions and it can use the results of one transaction as an input to another. It can read on chain state during a transaction execution, which is almost impossible to achieve with externally owned accounts. So we all have that. What does it mean to make it natively? What does it mean for us to enshrine it? When we say that we make an account abstraction native, what we mean is that a transaction is fully initiated by a smart contract.
00:06:11.334 - 00:06:59.706, Speaker A: With a smart contract account, it does not rely on any externally owned account. So once a user creates a transaction, it's broadcast to a mempool, it's picked up by a blockbuilder, and the Ethereum virtual machine itself performs all the actions. So we have ERC 4337 and it already does account abstraction for us. However, in red you see that the bundler servers that are ELC 4337 workhorses, they own and operate an externally owned account. When they make a call to the entry point contract. This is a legacy transaction. This is type two transaction that they sign and the bundler server pays Gaz for this transaction.
00:06:59.706 - 00:07:47.794, Speaker A: And an entry point contract compensates this externally owned account with a value on chain. However, this still enshrines and establishes an externally owned account and its private key as part of our account abstraction solution. So there are some issues with it. So what are the main issues? Like the first, and it's a big one for us, is gas efficiency. Because there are roppers and roppers and layers of abstraction here. The user operations of ERC 467, they are not very gas efficient. There is an overhead of around 20,000 gas for user operation and it often gets bigger than that.
00:07:47.794 - 00:08:39.730, Speaker A: And the best way to remove this inefficiency is to actually put all this protocol into the consensus layer of Ethereum. Another issue is what we say code bug risk. So entry point contract in ERC 4337 is still a smart contract. It has been audited and formally verified, but still there is a risk of a bug. And normally when there is a bug in a smart contract, just all of the smart accounts that would rely on this entry point, they would need to migrate. There can be a catastrophic event, or less catastrophic, but that would be a lot of overhead for them to change the implementation of ERC 4337 that they are using. However, if it's part of a protocol, it's implied and it's explicit that it works.
00:08:39.730 - 00:09:42.958, Speaker A: And the core developers of Ethereum or other roll ups will be responsible to making sure that this is safe and it stays safe going forward. Another thing is some EVM opcodes don't work well in the context of ERC 4337. For example, TX Origin returns the account that made the transaction in the first place. However, with ERC 4337 it would return an address of a bundler, an EOA that is not relevant to a transaction. In any case, it just happens to be a server that created this abstracted transaction. Another one this is a growing concern is that censorship resistance. As Ethereum is going towards a proposal builder separation, it becomes easier to sensor transactions and there are ways to mediate it with inclusion lists.
00:09:42.958 - 00:10:43.344, Speaker A: However, they all target transactions and what user operations do. They are bundled together in a single large blob transaction, which is not transparent for the inclusion list. So bundlers can sensor individuals in user operations and we will not be able to provide the censorship resistance we want with non native account abstraction solution. And last one but not least some networks that are starting right now, they may decide to go without eos. There are I think already some networks that do that. So if you can start now and not have this reliance on a specific signature scheme and just allow arbitrary validation of transactions, some may want to do that. And it would not be possible if we would still require a server to sign transactions that bundle your operations together.
00:10:43.344 - 00:11:19.686, Speaker A: You can read on this link an article from Vitalik on this topic. I'll move on and I will have it later. So what does validation of a transaction looks like today? So this is a hypothetical code from the previous presentation. Also of what are the steps that the transaction does when it's being validated. If it was written in solidity, it's not. But if it was written in solidity, this is more or less what it would have looked like. It would verify the transaction signature, it would verify the account nonce.
00:11:19.686 - 00:12:17.586, Speaker A: It would verify that account has enough balance to pay for the transaction that is happening. It would verify that the transaction has a sufficient base fee, and then it would increment in knowns, and only after that the transaction proceeds. This is what current transactions, externally owned account transactions do in Ethereum. So can we do more? So, in order to achieve account abstraction natively, the first thing that we do is we separate the code that is running inside a transaction into multiple smaller frames. So the concept the frame is you can think of it as a sub transaction, a small transaction that is part of a bigger one, or a separate call to a function that is top level. Like you have multiple main functions, main entry points to your transaction. So on the top is how transactions work.
00:12:17.586 - 00:12:56.874, Speaker A: Today there is a validation that is happening in the protocol. And on the right you have a single top level execution frame of a transaction. So you have a target contract, and you call it with a value, with some call data, and you provide a gas price and gas limit to this call. And this is the top frame. And all other executions happen from there. For example, if you call transfer in the ERC 20 token, so the call data would be a function of transfer in the circuit. And as I said, validation includes signature, nonce balance, gas limits and gas fee payments.
00:12:56.874 - 00:13:41.504, Speaker A: So when we go to abstracted transaction, we divide it into two big groups of frames. The first group is validation frames. In validation frames, what we do is we validate and increment nonce separately on chain and smart account. If need to be, we deploy an account. So if this is the first transaction the user is doing, we deploy code at another that he said he wants a code in. Then we provide the details of this transaction to the account. And the account has run some EVM solidity code to decide if transaction is valid.
00:13:41.504 - 00:14:23.362, Speaker A: And then if the contract is provided, the contract pays for, gas is provided and we call it a paymaster contract. We provide these transaction details also to this contract. Basically to ask him like this is a transaction that is happening, are you willing to pay for it? So only if all four of these calls succeed, we proceed to include this transaction in the block. The transaction cannot be included in a block. If any of these steps fail, and once they are complete and the transaction is inside the block, we actually perform the inner call. That is the execution frame. And also it's a detail.
00:14:23.362 - 00:15:28.250, Speaker A: We also allow the paymaster to do some operations after the execution. So it is also considered to be an execution frame. But the main thing here is the actual account execution function. That is bin code. Okay, so this is a hypothetical code and hypothetical CLI where if you were sending a legacy transaction type to this contract, to the execute function, only the execute function is actually run. But this shows an idea that if you send an account abstracted transaction to this contract, it will actually run the validate transaction function, and only then it would run the execute function. So it's a single transaction that calls two functions as a top frame, right? So the four validation frames that we have in the current state of native account abstraction proposal are nonce validation.
00:15:28.250 - 00:16:10.334, Speaker A: So there is a smart contract that manages nonces of every smart account, and this is the contract who is responsible for verifying and incrementing the nonce of a transaction. I said about account deployment account validation. We define a function signature, it is validate transaction, and we pass in the transaction hash and an encoded transaction, and it must return a special value to indicate that it accepts a transaction and the same thing happens. For a paymaster. The function name is different, but it accepts the same parameters and it returns the same. It can also return context for later. We will get to that after.
00:16:10.334 - 00:16:58.504, Speaker A: So next, abstracting the execution frame. I talked about it briefly. Instead of invoking the target contract directly, account abstracted transactions provide this call data to the smart account. And this allows smart account to interpret the input and perform actions that it decides. I don't want to say the word intense, but it can be something in that case that you tell your account what you want to do and account can interpret it arbitrarily. Next. So one issue that we have doing it is we need to allow block builders to construct good blocks, and we need to do it fast, secure and efficient.
00:16:58.504 - 00:17:45.474, Speaker A: So the validation function of externally owned account, which checks signature and the nonce and all, they are all obviously isolated. You can look at them separately on different states and they cannot intervene with each other. This is just one account, it has its own nonce and another one that has its own nons and signature. This is not necessarily the case with account abstraction, because the validation happens on chain and it has access to blockchain state. Transaction can change each other's validity. And block builders don't have a lot of time to prepare blocks. They cannot spend hours and hours iterating over combinations of transactions at work.
00:17:45.474 - 00:18:36.106, Speaker A: So in order to allow them to find blocks, we do a couple of things. The first thing is we try to sandbox each validation function in a way that the block builder can parallelize validation, so it can run different transactions on a same state across different cpu clusters. So without having to talk to each other. And we see the individual validation of a function if the transaction is valid or not. So in this example, all transactions have passed a validation function successfully, except for transaction c. So then when the block builder builds a block, it just does not include the transaction c in the block. But now what blockbuilder needs to do.
00:18:36.106 - 00:19:28.582, Speaker A: It needs to validate the entire block. It needs to make sure that transactions did not interfere with each other because they were validated separately. And if the sandboxing works and we managed to isolate transactions, this is the picture we would get. If the transaction passed a validation individually, it passes validation inside the block with mixed with other transactions. However, if the sandboxing fails, this is an example. A transaction a sets the value of some variable to one, and all the other transactions in their validation functions revert. If x is set to one, then these transactions were all valid individually, but as a block together, only one of them can go through and the others will not work.
00:19:28.582 - 00:20:15.690, Speaker A: And this also presents a denial of service attack vector, because it can be very cheap for an attacker to fill the mempool with transactions that are mutually exclusive. And see bundlers spend cpu cycles validating transactions that are valid individually but are not valid in a block. So they need to find a different block indefinitely. So we worked hard to write these validation rules, as we call them. So this is a separate ERC ERC 7562 that define rules for the code that can be executed in the validation functions. So there are limitations that are applied to these functions. However, these are ERC, meaning that it is not part of the consensus layer change.
00:20:15.690 - 00:21:36.004, Speaker A: Like if the bundler block builder wants to include a transaction that doesn't satisfy these rules, it's allowed to do so. However, if you populate mempool with transactions that violate these rules, you will not have a function in mempool because you would not know if you can include this transaction in the block. So the rules are basically, they make sense, but they become more and more complex as you go in. So for example, we don't want to allow transactions during their validation to observe the environment. We don't want them to observe timestamp or block hash or a balance of other contract, because this is an easy way to randomly invalidate your transaction when it's included in a block. We restrict access from one contract storage to another, and in many ways we isolate the storage that is available to a validation function. And there are also things like limiting the number of transactions from the same entities that can be included in the same block, so that there is no risk of, for example, a privileged contract like a paymaster, invalidating many transactions in your block.
00:21:36.004 - 00:22:20.914, Speaker A: It's still a pull request. The rules at the link here, but they are not very different from what we have. They actually will be the same as the rules applied in ERC 4337 account abstraction. Now there is a thing that the rules, the validation rules are applied to the validation function. However, there is still the body of a transaction, the actual execution, that can do what user said it to do, like it can do arbitrary action. It is not feasible for us to limit the execution of a transaction. We cannot say that your transaction is only allowed to change your own storage and not allowed to change the storage of some other contract.
00:22:20.914 - 00:23:07.050, Speaker A: So what can happen is that while the validation function did not violate its constraints, and in sandbox the execution actually can do whatever it wants. So here we come to the third realization of what we need to do for account abstraction. We split the transaction into two parts, and the validation frames are not run together with execution. We put them in a separate place in the block, and the executions run separately. So all the validations are executed. First, and only then we start applying the execution functions. So if you are developing a smart contract, you need to be a wallet.
00:23:07.050 - 00:23:42.264, Speaker A: You need to be aware that between the validation of your function and the execution, then there can be a different code running. It's not necessary. The transaction is not atomic per se. There is an atomic validation part and atomic execution part. So here is the example. Let's say we have three transactions, a green, a blue and a yellow one, and we want to isolate access to the same state by validation frames. So what we do is we apply them in this order.
00:23:42.264 - 00:25:08.868, Speaker A: We apply the green transaction validation part, then the blue transaction validation part, then the yellow one, and then we start applying the changes that happen in the execution of a given transaction. So this is how that would look like in this hypothetical CLI. If you were to call three transactions like three different wallets execute function. What you would see output is that you are inside the validation frame three times in a row, and then you are inside an execution frame three times in a row. They are not linearly applied, right? So if that is clear, there are a few things that are not per se a part of account abstraction, but they are extras that we added to this improvement proposal based on the feedback we receive from the community. One part of feedback that we received is that 64 bytes nonce are not enough for many applications, especially when we are talking about smart contract accounts that can be used by groups of people. And if they are only using a sequential incremental integer nonce, they can step on each other's stores and invalidate each other transactions while they are being prepared and signed.
00:25:08.868 - 00:26:11.344, Speaker A: So smart contract account developers wanted to enable unique transaction nonces that are not sequential. So we decided to increase the nonce parameter size to 256 bits, and we dedicate 192 bits to the key part, which can be arbitrary value, and the 64 bit value part that is actually a monotonically increasing integer nonce. So if transaction wants to use unique nonce every time, it just leaves the value apart empty and creates a unique 192 byte key for every transaction that is being signed. If you want to use just sequential nons, you can use a key field empty and just increment the value part of a transaction. You can have lanes like lane one, lane two, lane three. Right. Another part that we added to account obstruction proposal is gas obstruction.
00:26:11.344 - 00:27:28.884, Speaker A: So the thing is here like, we want to allow also externally owned accounts that exist today to benefit from a gas abstraction and smart contract accounts. So we allow externally owned accounts to sign account obstructed transactions, which would mean that the gas for the transaction is charged from the paymaster contract and not from the sender, regardless if it's a smart contract wallet or regular externally owned account. Right? And another thing that we introduced is transaction validity time ranges. So in regular ethereum transaction, once you sign it, it's probably valid, and until it is mined or other transactions the same nonsense mined, it will remain a valid transaction indefinitely. So if you sign a transaction, broadcasted it, and it wasn't included in a block, it can be included in a block anytime in the future, in a year, in ten years, tomorrow. Regardless, if you still have the same intent to do it, you don't remember you sign it and you cannot delay the execution. You cannot say that you sign a transaction that will be valid like starting next week.
00:27:28.884 - 00:28:10.944, Speaker A: What account abstraction adds to the core protocol is that a transaction has a valid from and valid until parameters. So you can sign a transaction at any time you want, in any way you want as a smart contract account. And this defines the validity of transaction explicitly and very specifically. And this is also applied to externally owned accounts. They are allowed to sign such transactions. So in order to achieve that, we introduce a new transaction type. This is like following the transaction type one that added access list, transaction type two, added fees, base paper, gas priority fiber gas.
00:28:10.944 - 00:29:22.354, Speaker A: Transaction type three will add blob transactions, and hopefully transaction four will add account abstracted transactions. So the fields that are new to this transaction type are actually the sender, which means that in a normal transaction you derive the address of a sender from the signature by doing EC recover. This is not possible with an arbitrary signature format, so we tell explicitly which address is the sender. We allow a builder fee, which is a little bit technical, but we allow to pay an explicit fee to the builder that is not tied to gas. This may be relevant to layer two roll ups where gas is so cheap that it may not compensate some computation. We still provide the cold data, but in addition we have what we call paymaster data and deployer data. These are optional fields that are used if you include a paymaster, a contract, who pays for a gas or a deployer, which means you don't have code in your sender account and you want to inject it.
00:29:22.354 - 00:29:57.044, Speaker A: And also these separate frames, they have their own validation gas limit and paymaster gas limit. So they have their own gas limits. And that's basically other fields remain same from other transaction types. So account abstraction on ethereum is not new. It was one of the first. The first account abstraction mentioned in the EAP report is EAP 86 by Vitalik Buterin. So it talked about abstracting transaction origin signature.
00:29:57.044 - 00:30:52.850, Speaker A: That was not a mature state for account abstraction. EAP 1014, the one that added create two opcode, was actually aimed at enshrining account abstraction in the future. In the first actual account abstraction, EAP was EAP 29 38. It is very advanced NAP and a lot of our decisions are based on it. However, in my view, it relies on a pay gas opcode to transition a single transaction from a validation phase to an execution phase. Which does not explain how a block builders would produce the blocks that include such transactions. How would they prevent execution and validation from interrupting with each other? Another one that is in account abstraction realm is EAP 3074.
00:30:52.850 - 00:31:36.024, Speaker A: This one suggests to add two opcodes, auth and Auth call. What they do, in two words is it allows an externally owned account to make a delegate call to another account. So instead of just calling another account, you allow a smart contract to take over the context and be the message sender of your transactions. This has two issues in my opinion. One is it enshrines the EcdSa signature. Like this is an EOA that's controlled by CDSA signature, and now it can sign an approval for another contract with this private key. But it still has a regular account.
00:31:36.024 - 00:32:29.540, Speaker A: And so we don't see it as an alternative to ERC 4337 or a native account abstraction. And we see it as solving another like additional problem to what we are trying to solve, which is mostly a validity of a transaction. All right, so this is a very huge change and it's a breaking everything change. So it's very complex and it makes sense for us to first aim it to layer twos and roll ups. So we will be introducing rollup improvement proposal process. So instead of doing an ethereum improvement proposal, we are publishing this as an rip roll up improvement proposal. So we want to do that because side chains, in our opinion, and layer twos, they will all benefit from following the single standard for native account abstraction instead of everyone trying to reinvent their own.
00:32:29.540 - 00:33:23.856, Speaker A: And there are already some layer twos that edit account abstraction based on ERC 4337 natively to their protocols. But there are differences in incompatibilities and we want to work with all layer twos to implement them the same standard. So of the repo already exists. You can go there. We are the first roll up improvement proposal and it will be properly announced later. So there is a question, obvious question like what does this rip, what does this proposal mean for the broader ERC 437 ecosystem? So the first thing we must say that our aim is to have a cross compatibility between ERC 4337 and native account abstraction. So it will go both ways.
00:33:23.856 - 00:34:37.214, Speaker A: So we will make sure that if it works for one, it works for another. In terms of contracts, paymasters, deployers and any component, we expect that some networks will be quick to adopt native account abstraction and we expect that others, especially Ethereum mainnet, will take more and more time to adopt this breaking change. So there will be a lot, a lot of interoperability and times when it support like one solution works for one chain and another is used for other chains. Once the chain approves and adopts native account abstraction, we want to make sure that there is a clear and straightforward migration path for contracts and other players in the ecosystem to move to native account abstraction. And there is a question of a role of a bundler. So right now with ERC account abstraction, bundlers need to maintain a special relationship with the blockbuilder. They cannot broadcast their bundles to the mempool because they will be griefed.
00:34:37.214 - 00:35:35.714, Speaker A: So this similar dynamics stays in action for native account abstraction. So we expect that there will be bundlers who will act as kind of MAv searchers who will provide blockbuilders with valid batches of type four transactions going forward. And this is how they will interact with builders. This is why the progress that's being made by bundlers is still very relevant for the native account abstraction. Okay, so join us for all the discussions, provide feedback, track our development in our discord and these are the links. The rip itself is Rip 7560, available at this link and the new RIp repo, not eap Repo. And please join our discord to provide feedback and hear back from us any questions.
00:35:35.714 - 00:36:52.350, Speaker A: Given the restrictions on access to the environment, like time in the validation phase to prevent some of the griefing issues, how did you do the valid from and until? Right, so your solidity code is not allowed to access time, but the EVM is allowed to access time. So instead of checking time yourself, you provide the time range to the machine. Like this is a return value of your validation function. It says that this transaction is valid and when it is valid and the EVM checks it. So you cannot do weird things like be valid on an even second, but you can be valid in a time range. Yeah. How do you prevent bots from calling the paymaster and just draining the paymaster? Yes, so the paymaster is a smart contract.
00:36:52.350 - 00:37:30.374, Speaker A: So it must maintain an on chain logic to define if it wants to pay for a transaction or not. So it can maintain like per user counter like some kind of whitelist blacklist. They can have like cost signature required for a transaction, so they can have a server that also approves the transaction. It's provided with some extra data, so any on chain mechanisms that you can come up with or off chain as well to prevent the sibling DOS attacks on smart contract basically works here.
00:37:34.514 - 00:37:58.930, Speaker B: Yeah, I just wanted to add that, I mean, people often think about Paymaster only as something sponsoring the Gaz, but it's not always the case. It may be a bit misleading. For example, there is token Paymaster. The token paymaster doesn't really sponsor anything. It's the user paying. It's just that the user is paying with an ELC 20 token. So the paymaster actually pre charges the.
00:37:58.962 - 00:37:59.654, Speaker A: User.
00:38:01.354 - 00:38:12.934, Speaker B: The maximum amount that it transaction would cost in, let's say, USDC, and then the contract pays for the ETH, but it's actually the user paying just with a different currency.
00:38:13.474 - 00:38:25.034, Speaker A: Yeah, right. No more questions. Okay, so that's it. Thank you very much.
