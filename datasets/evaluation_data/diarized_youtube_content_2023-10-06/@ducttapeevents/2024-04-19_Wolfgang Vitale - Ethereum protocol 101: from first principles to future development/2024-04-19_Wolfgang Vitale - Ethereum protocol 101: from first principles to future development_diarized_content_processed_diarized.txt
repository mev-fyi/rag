00:00:00.520 - 00:00:25.442, Speaker A: Welcome, everyone. Thanks for joining. This 60 minutes is an introduction to Ethereum, the protocol, Ethereum protocol 101. So it's for people who want to look a little bit more in depth at how Ethereum actually works. But yes, I'm covering the basics. So to make it very, very clear, we have only 60 minutes. So, yeah, let's go through it.
00:00:25.442 - 00:00:57.616, Speaker A: Disclaimer same I've shown yesterday. So these are just my opinions. But still, we are talking about Ethereum and yeah, let's go. Ethereum protocol, 60 minutes. I have four sections and start from fundamentals, principal values, like why do we even need Ethereum? Why are we here? Second, execution layer, consensus layer, and future work. Roadmap. What is hot in the research environment on Ethereum today? Okay then, fundamentals.
00:00:57.616 - 00:01:51.022, Speaker A: First of all, why are we here, like Saturday, 10:00 a.m. Why do we care about Ethereum? What's going on, why it's important and my belief. So this is my belief, again, the disclaimer at the beginning, my opinions, I believe, and I think we all believe if you're here, that there are at least some pairs of user pairs and applications for which decentralized trust brings additional value. I'm not saying much really. It's just there is a set of despairs, some users and some applications for which you actually get more from decentralized trust. What is more, either more value, meaning that decentralized trust brings more value to the alternative, that is only centralized trust. Second option is the only way to get value.
00:01:51.022 - 00:02:21.006, Speaker A: So in case there is no trusted third party, then you have a pair of user based applications for which you need the decentralized trust. So there are different theories. Some believe that this is the only way. Like only in the case there is no trusted third party, then decentralized trust makes sense. I also believe there are potential application user based pairs for which you actually have more value. And I will define what more value is. We start from definitions.
00:02:21.006 - 00:03:14.914, Speaker A: This is the fundamental section. So what is decentralized trust? That's what you get when you identify, minimize and remove all central parties, all central authorities and or single points of failure. So from decentralized trust, you bring decentralized applications of different types, and at the end of the day, you have to bring additional value. So what is value like, what do the user want? Users don't want decentralization per se, okay? That's not the end goal, that what they want is what decentralization can provide. And again, it will provide to some users for certain applications. And our job over the years will be to find these pairs application user base for which this makes sense. But what does the user want? What do I mean when I say more value? I mean very concrete things, like tangible things, very clear.
00:03:14.914 - 00:03:31.686, Speaker A: Fairness. Well, fairness is not super clear. To be fair, then safety, cost efficiency must be cheap. The application responsiveness, it must be fast. Accessibility. Everyone in the world should be able to access these services. Add privacy.
00:03:31.686 - 00:03:57.522, Speaker A: I think it's super important. Okay, so how do you get there? I said, you start from decentralized trust. That's the substrate. But then what do you build to create these pairs of applications and users for which there is additional value? You need a decentralized state machine. I mean, this is what we are building. And my theory, my belief is that pretty much all the effort in blockchain technology development. So not only ethereum, pretty much everything.
00:03:57.522 - 00:04:23.486, Speaker A: If you go really to the core of what you're building at the end, the goal is to provide a decentralized state machine. It's, again, a very generic term. You can do it in different ways, but I think it's very important to put the subsidy down and the efficiency down. So what is the state? State is a word that we repeat very often. A state is just a database. I don't know, people, sometimes they're ashamed of saying the state is a database. Like, who cares about database? Well, database are extremely important.
00:04:23.486 - 00:04:53.970, Speaker A: Database can be anything. When I say database, I mean valuable information. And we care about the data integrity of this valuable information. So state is valuable information that is important. State machine is a software that is able to change the state according to certain protocol rules. And decentralized state machine is what you want to build. And for that you need consensus among many nodes that will find an agreement on the updates to the database.
00:04:53.970 - 00:05:24.034, Speaker A: So we have this very important information that is the state and the way to operate on the state according to rules that are transparent, without anyone that can change the rules or do bad stuff. So that's what we are trying to achieve. Decentralized global state machine, synchronized at the speed of light, ideally. So why is that interesting? This is done. Why decentralized? Because then the protocol rules are transparent. Everybody knows the game. Nobody can cheat.
00:05:24.034 - 00:05:54.314, Speaker A: And yeah, no single authority can even just change the rules. That's very important. Otherwise it would be decentralized. And once you have that, you can achieve efficient social coordination at a global scale. And that's unprecedented because we have seen social coordination scaling from tribes to villages to nation states, but arriving really to a global network state. We need this kind of technology. And I mean we need blockchain technologies.
00:05:54.314 - 00:06:21.754, Speaker A: I'm not saying we need 1 million meme coins pumping. We need blockchain technology. So that's what we are trying to get. And yeah, that's cool. And that's the final state of Ethereum. Now I said we are building decentralized state machine, and it's true, but there are many different ways to do it. And you can have some trade offs and compromise on how you build this decentralized state machine.
00:06:21.754 - 00:06:55.012, Speaker A: There are some things that are, you need them. I mean, it must be decentralized, otherwise it's not decentralized state machine. But you can define what decentralization means. But let's focus on Ethereum, because it's an ethereum session, and what ethereum optimizes for are different things. So first, general purpose. We all know that, but let's make it very clear, when I say state machine, and I say that the state is valuable information, it doesn't mean that it has to be general purpose. So bitcoin is a general, it's a decentralized state machine as well.
00:06:55.012 - 00:07:28.328, Speaker A: But in that case, the state is just a list of coins and the rules to spend those coins, that's the database. It's a database and it's not general purpose because the only things you can do is to transfer coins. Ethereum was to build, or at least the original vision was to have a world computer. So when I say general purpose, you can do pretty much anything on this database. Other important values, credible neutrality. So when I say fairness, and I said fairness, is not very clear to define. Some things that are important for fairness are credible neutrality.
00:07:28.328 - 00:08:01.090, Speaker A: So there is nobody that has an advantage like embedded in the protocol. The protocol is built in a way to give advantage to certain parties. That's neutrality. Credible means that it must be obvious, like it must not be something very difficult to prove, it must be very clear. And the other component of fairness is censorship, resistance. It's pretty much connected. But the idea here is that anyone can submit transactions and if they follow the rules of the protocol, then they will be included in the chain.
00:08:01.090 - 00:08:32.168, Speaker A: We will see more in detail how it works. Then we have consistency, like safety, availability. It must always be up. That's important for Ethereum and the user verifiability, which is something that will be more clear in the rest of the talk. But it's definitely super important for Ethereum. Pretty much every user must be able to not trust, but verify that the decentralized state machine actually works according to the protocol. Without trusting anyone.
00:08:32.168 - 00:09:10.916, Speaker A: So this is in the trustlessness property. You can also see that way, but in practice it means end user verifiability. Okay, then what is Ethereum? Ethereum is a protocol, but you know what is the physical instantiation? It's a network. So you have many nodes that run the Ethereum protocol. So let's go through some base definitions. I told you, what is the state in general, in Ethereum, the state is again valuable information in a database. This is what I have there for Ethereum users.
00:09:10.916 - 00:09:37.512, Speaker A: So you see all the users around the state, around the database, because they care about this information. They find value from this kind of information and the way it's processed. Then you have the nodes. I said Ethereum is a network. Network means it's a collection. It's a peer to peer network of nodes that talk to each other to ensure that the protocol works. So what this node is the software running on certain hardware.
00:09:37.512 - 00:10:20.254, Speaker A: And this is what is needed to read the state and to write, or at least request write to the state. You care about this information, so you want to be able to read it and ask to write it, like modify it again, according to the rules. To do that, you need a node, your own node, or you use a wallet and ask someone else. But at the end of the day, there is a node there. So when you see there number one, user submits transaction to update the state. There will be a node there because the node will send the transaction. Okay, so now network is a collection of nodes, and that's the software and hardware needed to update the state or just read the state.
00:10:20.254 - 00:10:50.454, Speaker A: Now, the following sections of this workshop, we have execution layer and consensus layer. So I want to introduce what the execution and consensus is. Let's start from execution. So what I have here, there are other important concepts that we need to know about that are transactions, the blockchain, and the verification aspect. Transaction is what I mentioned before in the. .1 in this diagram, you have a user submitting a transaction to update the state.
00:10:50.454 - 00:11:39.010, Speaker A: So what is a transaction? It's a package of information that describes an operation that the user wants to be done on the state, on the database. And the fact that Ethereum is trustless and there is censorship resistance means that any user with access to any node can make this request at any time they send the transaction. The transaction then in the, .2 circulates among the nodes of the ethereum network, and at some point, according to consent, that you will see this transaction is included in the blockchain. So when you see the blockchain there, it's a list of transactions, append only. So you can only add the transactions. You cannot remove them, but you basically add the transactions to the blockchain.
00:11:39.010 - 00:12:27.644, Speaker A: And the blockchain is just a list of transactions. What's the point of the blockchain is to have this high integrity list of transactions such that you know that they cannot be removed from history. Once they're there, they're forever there. This transaction list, and the whole point of execution is that if you are new to the network and you download the blockchain and you execute all the transactions in the blockchain in this list, that is high integrity, then you know that you will end up to the same state that all the other nodes in the network have. So that's very important. You don't need to trust anyone, you just get the blockchain, maybe from more sources, you execute the transactions and you know that at the end of the day you will get the same state as everyone else. And why is that important? Because the state is important.
00:12:27.644 - 00:12:56.328, Speaker A: The state is this very valuable information for Ethereum users that to make it in more concrete terms, for instance, is even just the balance of ether token of all the addresses. That's obviously very important, right. So you want to make sure that this state has very high data integrity. And the blockchain is the only way to do it. When you don't know if you can trust any other node. That's the point, that's the problem, but we'll see that. Okay, and then this other point.
00:12:56.328 - 00:13:42.924, Speaker A: Yeah, that's the verification that I said. You can just verify that the state is correct. If you re execute all the transactions in the blockchain, then consensus is something that I sort of skipped from the second point to the third point. So when you send a transaction to the network and the transaction is basically propagated to all the nodes, then there must be some mechanism to decide which transaction is added at what point of the blockchain. So what is the next transaction? Because here you see only one user, they send you one transaction. But in practice you have many users that are pushing transactions pretty much at the same time. So how do you decide what is the next transaction to be added to the blockchain? Again, the blockchain is just a list, an order at the list of transactions.
00:13:42.924 - 00:14:17.036, Speaker A: How do you decide if the transaction is even valid? It follows the probable rules. You cannot just trust onenote because you don't know if anyone node is honest, you cannot know. So you need to have as many nodes, and that's where the decentralization comes from. And as many honest nodes as possible to actually achieve consensus. And consensus really only means agreeing on what is the order of the transactions that are sent to the network. Okay, so it's not just first come, first served. Doesn't work like that.
00:14:17.036 - 00:15:09.058, Speaker A: More complex rules to achieve consensus in a decentralized network with many nodes and you don't know whose owners what. Not cool. Yeah, so, okay, I also have other definitions that are important for later that the block proposer and the fourth choice. So on Ethereum, how it works, you have many nodes, all the nodes see the transactions that is sent by the user. And then among all those nodes, one node is selected or elected as a block proposer. So basically this single node will decide what is the next transaction, or at least will propose what is the next transaction, and then all the others apply for choice rule and decide if it's really part of the blockchain or not. So there are different roles, but we have a full section consensus to look more in particular.
00:15:09.058 - 00:15:52.314, Speaker A: But yeah, it's good to know block proposer and then all the other validators that actually finalize this choice. Cool. Then let's start with the execution. As I said, the state is this very important, valuable information, this database that we want to make sure that it has very high integrity because it's very important for all the Ethereum users who are constantly looking at the database. They want to make sure they still valid and nothing went wrong. So what is inside this database? The state, we have a list of accounts. I'm talking about the execution state to be precise, but this the one that really has the information that matters to the users in practice.
00:15:52.314 - 00:16:40.584, Speaker A: So here we have a list of accounts and associated data. So accounts with a specific address that is an identifier for the account, and then some data related to this account. So we have, for one account, we have different fields, we have the address, there is the identifier, we have a balance that says how much of the ether token is owned by this account. Then a field for the code. Because Ethereum is a decentralized state machine, there is general purpose, so it can execute any kind of code. Like any kind of algorithm, any kind of software can be executed on this world computer. So you will have accounts that own code, the code is stored in the account.
00:16:40.584 - 00:17:38.271, Speaker A: Then you have a field for storage, like generic data field that can be held by an account and then announce that is just a field for avoiding, replay, replaying transactions. Yeah. So it's something that we need to ensure, again, that the state has high integrity, but it's not something that you really care about in terms of information as a user anyway. What matters, balance code storage. Now, as you can see in the table, I have two kinds of accounts. So I have the contract account and an EOA account, externally owned account. So the contracts are controlled by code and actually have code in the field, you can see there is a code hash, while externally owned accounts don't have code, don't have storage, and they're controlled by keys by users.
00:17:38.271 - 00:18:14.644, Speaker A: So normally, when you think about accounts on Ethereum, you think about the EOAs, because those are like, if you have a wallet and you have some ETH and you want to move it, that's what you have. Eoas, it's your account, it's controlled by you, your private key, and then you have smart contract accounts. This is what I mean here, by contracts. But yeah, they're both accounts. And I almost see the contract as the real normal account and you a the exception. But it's up to you and opinions here. But yeah, let's not delve too much into that.
00:18:14.644 - 00:18:43.276, Speaker A: What I want to say. Yeah, so we have the state, it's made of this list of accounts. And then you need state machine operations, because as I said, this is a decentralized state machine. You need to have a protocol to have operations on this state and update the state. That's what execution is, finding a way to update the state according to the rules. So what kind of operations you can do? I said this is a general purpose state machine. So pretty much anything.
00:18:43.276 - 00:19:16.164, Speaker A: But let's be a little bit more concrete. So there are different things you can do. One is just transferring ether. It's a very important operation. You want to move either from an account to another. Then you can do deploying code, like you write code software that you want to have executed on this word computer. So you can deploy code on a new account, on a new contract account, and you can execute code, so you can call code that has already been deployed and stored on Ethereum.
00:19:16.164 - 00:19:48.630, Speaker A: These are the state machine operations on the execution state. And this allows you to do pretty much anything, because again, you can deploy pretty much whatever kind of code or software. Okay, then, as I said, we have state machine operations. What do the state machine operations do? Is to update the state. Another word to say update the state is state transition. I say that because it's what you usually hear people talking about, state transitions. So you have a state SI at a certain point in time.
00:19:48.630 - 00:20:22.594, Speaker A: And we will be more precise about time in Ethereum. But you have Si, you apply a transaction and you have a state transition function that lets you go from the state I to the state I plus one. That's the very generic way to talk about state transitions. Now, what I write there is very important because I didn't say that transaction data package. I said that, but signed by an EOA describing a state machine operation. So the transaction describes a state machine operation. We said that, but we didn't say that it's signed by an EOA.
00:20:22.594 - 00:21:13.224, Speaker A: What I want to say is that only externally owned accounts, so the normal accounts that we use as we control with our keys, only those ones can initiate transactions and can initiate new things happening on Ethereum. So the execution will always be initiated only by keys and not by code, not by contract. A contract can call other contracts, but at the very beginning there must always be an EOA. So a normal account signing a transaction, okay, then a state transition is the outcome of the transaction. We said that. And then there is the Ethereum virtual machine concept that we need to know the EVM, and that's the general purpose virtual machine that is implementing the state transition function. So here you see something very generic, very abstract.
00:21:13.224 - 00:21:43.992, Speaker A: You apply STF state transition function to the previous state. You add the transaction, you get the new state. What it means in practice is that you have a virtual machine. So a virtual machine that is executed by all the nodes. To implement the state transition function, you have the database, you apply a transaction and you get an updated database. That's it. So let's move to the transactions more in practice, because I was very generic, very abstract.
00:21:43.992 - 00:22:34.980, Speaker A: Transaction is an operation like the user says I want, or at least a request to change the state in a specific way. But yeah, let's look more in practice at what you can actually do, what is inside the transaction. Okay, so you have two addresses from address to address, source and destination or source and target. Source is you, because the signer is always an eoa. So it's controlled by users, by keys. So that's you, and you have to apply a signature also for other people to verify that this was actually you and you actually own the private key related to the source account. Then you have a destination account, a value field, that is how much ether you want to transfer.
00:22:34.980 - 00:23:15.908, Speaker A: It doesn't have to be, I mean, it could be zero, but the field is there. Then you have a field for data, like input data, and we'll see what it can be. But for now, it's generic field with any kind of data you want to apply as input to the transaction. Then fields to calculate the transaction fees that you need to pay for using ethereum resources. And again, the nonce and the chain id for replay prevention. Now these are the fields that you find in a transaction. Depending on what kind of accounts you have in the from the source and the two destination fields, you have different types of transactions.
00:23:15.908 - 00:23:41.908, Speaker A: So that's a very important thing to keep in mind. If you are an EoA and all you do like your destination is another EoA, there is no code involved because EOAs don't have code to them. Storage. So the only thing you do is transferring ether, which is, you know, very important operations. It's okay. So you're moving it from one account to another. If you want, you can also add the data, but it doesn't do much.
00:23:41.908 - 00:24:24.932, Speaker A: It's just a message that if you want you can do that. But yeah, because the fields are always the same, then if you are an EOA and you are always an EOA. So it's not an if. There are always sign in transactions, only eoa if the destination is the zero address. So let's say there is no destination. What happens is that this transaction type is a creation transaction because you actually create a contract, a contract account, meaning you are deploying code that any node running the ethereum virtual machine will be able to run or will need to run if someone is calling that code. Okay, so the last type of transaction is what happens if you send a transaction to a contract.
00:24:24.932 - 00:25:17.458, Speaker A: So to an existing contract that will have already existing code, because it has already been deployed, it has already been created by this other kind of transaction to the zero address. And that transaction where you call a contract means execute the contract according to the data. So when you send this transaction to the contract, you have to add data, this input data, and this input data says, I want to execute this specific function in the contract. I didn't mention. But when you create the contract, yes, you put the code in the data field. So now it's more clear why we have a data field in the transaction, either to deploy contract and say what is the code? Or to say which function and which parameters you want to or arguments you want to send the contract. Then let's look at how contracts look like.
00:25:17.458 - 00:25:51.082, Speaker A: So as I said, this is a general purpose state machine in principle. You can call any kind of code like Turing complete. And this is written, the code is written in solidity or viper. Anyway, Turing complete languages, they look, this is an example written in solidity. And this particular is very simple but important. Contract is wrapped ether. How to wrap ether and make it an ERC 20 or anyway, a token that is composable with other functions on ethereum.
00:25:51.082 - 00:26:35.224, Speaker A: But I just want to look, I just want to show how the contracts look like. So they're described like general code. And what we can see is that there are different functions. So I have different function names, like I am highlighting the deposit function or the withdraw function. Deposit means that you bring ether to this contract, you are sending ether to this contract and it's locked there, and then you get something in return. There is disrupt ether, and then you can withdraw by, you know, giving back, let's say giving back the wrapped ether and unlocking the ether or unwrapping the ether. But all I want to say here is that there are different function names.
00:26:35.224 - 00:26:59.384, Speaker A: That's the code. So when you call the contract in the data, you have to say, I want to call this function or this function or this function. And you can see that different functions can have different parameters. They might have parameters or not. So if you call a function with a parameter, you're also expected to send in the input data, also the value of the parameter. Good. Yeah, just another deal.
00:26:59.384 - 00:27:35.152, Speaker A: The contracts also define the specific storage related to the contract. Because remember, in the account field, you have code and storage. So that's why here, for instance, you define storage, and this is just a map of all the ether that has been deposited by different users. You need to keep track of that. And by the way, wrapped ether at the end of the day, is just an entry in this database in this specific storage field. Okay, now this is the last part of the execution section to talk about transaction fees. Because I said ethereum is permissionless.
00:27:35.152 - 00:28:16.580, Speaker A: Anyone at any time can just send transactions and request to update the state. Now, if that was really true, like literally anyone at any time, then you know what would happen? That the network would be spammed really to death. Like completely collapsing, because everyone is requesting just to destroy the network for fun. It cannot work. The fact is that executing transactions requires time and resources. You have to be able to handle spam. You have to be able to meter the resource consumption and charge it, because even if it's an extremely small amount, you have to do it.
00:28:16.580 - 00:28:51.984, Speaker A: It cannot be zero. That's it. So how do you measure which transactions are more demanding to the network? As we have seen, we have many different types of transactions. It can be something as simple as sending ether, but it can be something as complex as running a huge contract that is modifying the storage. And it's asking a lot of these kind of operations, very slow for the network, very demanding. So it's clear you cannot charge them at the same price. So you need to define resources on Ethereum and a way to measure the resource consumption.
00:28:51.984 - 00:29:31.514, Speaker A: Now, for a long time there was only one resource on Ethereum that was called gas. And now we have also another kind of resources, a resource that is the blob, that is related to data availability. And we'll see that later. But for you, it's important to know there are two kinds of resources. What I call execution gas and what I call data availability gas, execution gas, sometimes also just call gas. And the availability gas can be blob gas or blobs. But anyway, you have two resources, one more related to execution, one more related to making data available to the network and people outside the network.
00:29:31.514 - 00:30:19.576, Speaker A: In both cases, you need to apply gas metering to know which operations are more demanding. And basically the users will be charged. So to send the transactions, you have to pay in ether. So that's now we see for the first time, I think some use case for the ether token, we'll see more. But to operate with this network, yes, it's permissionless, but you need to pay with ether. Okay, so let's see, how do you define then the cost of gas? This is also very important, because I said gas metering means that more complex transactions will require more gas. But what does it mean in terms of ether? So let's say one transaction cost 1000 gas.
00:30:19.576 - 00:31:00.268, Speaker A: But what is the price of gas in iter? That's very important, and that's a dynamic price. It's not like for one gas, you have to pay this much heater, it's changing. And it really depends on the level of congestion or the level of demand for the network. So if there are a lot of requests of transactions, then this price will go up. Otherwise, if there is under demand for the network, then the price will go down. The price of gas, you have a target for how much gas you want to spend, how much gas you want to spend on average in time, if you're above or below, then the price will change. As I said, we have different resources, gas and blob gas.
00:31:00.268 - 00:31:34.374, Speaker A: These resources are priced independently. So if there is a spike of demand for blob gas, then the price of blocked gas will go up. But the price of execution gas is independent. Once you have then a transaction for which you know how much gas they're consuming and you know, the price of gas, then you can calculate the transaction fee. So the price in iter that you have to pay this price is divided into components. There is a base fee and a priority fee. They're both in iter, but the base fee component is burned and, and the rest is paid to the proposer.
00:31:34.374 - 00:32:12.108, Speaker A: We'll see more in detail what this means, but just to give an intuition, paid to the proposer and the block proposer is one of the nodes in the network. You need to incentivize the network to do this work. So a part of this transaction fees will actually go to one of the nodes. And yeah, this last slide for the execution, just to talk about blocks 1 second. So I mentioned blockchain. The blockchain is a list, an ordered list of transactions. But this list of transactions is segmented into packages of like sub lists.
00:32:12.108 - 00:32:46.194, Speaker A: And these sub lists are inside a block. And I want to say this because the first slide I've shown that was very generic for the state transition. There was only one transaction. But what is actually happening in Ethereum is that you have many transactions executed as a block, as a batch. So you have a batch of transactions that are inside a block, and then you have this actual state transition. So it's not transaction by transaction, but block by block. In a block you will have this list of transactions from TX one to TXN, this ordered list, and then you have the new state transition.
00:32:46.194 - 00:33:16.564, Speaker A: Cool. Then let's start with consensus. So this is the second part and the third section. And to remind you, what are we talking about, we have this diagram with the user sending a transaction. Now we know that they have to pay with the ether token to basically demand this usage of network resources. So you send the transaction, the transaction is circulated in the network and the network executes the transaction. Very important.
00:33:16.564 - 00:34:12.668, Speaker A: So every node that sees the transaction will execute it to see is it actually a valid transaction, what would be the next state? Yeah, after they make all the checks they need to do, they find the consensus on whether this transaction is added to the next block or not and in which order. So this is what we are talking about, consensus. And this is a difficult problem because you cannot know which nodes are trusted, like which nodes are honest and which are not. So that's one of the first challenges that you have there. Now, how does it actually work on ethno, how do you find consensus among all these nodes? You have many nodes and they have to agree on what is the next transaction, what is the next block, how does it work? The nodes vote. There is a voting process. It's really just that it's an election, basically, or an approval for the next vote for the next bloc by voting.
00:34:12.668 - 00:35:15.490, Speaker A: So all the consensus participating nodes, because here I've shown nodes in general, but there are some nodes that have the specific role of participating to consensus, and we'll see how. But those nodes vote on what is the right blockchain, like, what is the right ordering of transactions, because all the nodes have seen these transactions coming from everywhere, and somehow they all have to agree on what is the right order. And since this is a decentralized network, different nodes might see things in different orders in different ways, and you have to ensure that they all agree at the end. How do you agree with voting? So if you have many nodes that say this is the right order of transaction, then they win the voting. And that's the truth, basically, because everyone will know that if you follow that kind of order, you will get to the same stage. So we have the voting component and we have the block proposer. I said before, you have a block proposer, who is the one that first proposes the block.
00:35:15.490 - 00:35:38.550, Speaker A: I said, in my opinion, this is the right order, then the other votes. So that node is the block proposal. How do you decide who's the block proposer? Because it looks like a very, very important role. Right? It starts from there. Out of all the nodes, there is one that says, no, this is the right order. So how do you decide? By random. So you just select one node, because you don't know who can be trusted.
00:35:38.550 - 00:35:57.424, Speaker A: You cannot know. Every node can be malicious at any time. So you select one node randomly. Okay. Of course, this, over time, you rotate and change. But it's an important mechanism to know there's this random selection. Now, consensus is difficult.
00:35:57.424 - 00:36:23.638, Speaker A: So we have challenges here. It's not obvious to make all these nodes from everywhere in the world where you don't know who's controlling what node, you don't know if they're honest or not. How do you achieve consensus? This is difficult. There are challenges with open participation. I have three main challenges that I summarize here. One, you might have too many nodes. So let's say you have 10,000, 10,0000 1 million nodes.
00:36:23.638 - 00:37:02.764, Speaker A: It might be very difficult to find an agreement. When I say difficult, it might even be just very time consuming, very computationally expensive, because remember, you are doing this voting and you have to check the votes from everyone. You have to aggregate these votes and see who, what is the truth of the blockchain. And if you have millions of nodes. This doesn't scale computationally because you remember at the beginning, I said the end goal would be very nice to a decentralized state machine working at the speed of light. So you cannot do this with 1 million nodes for what we know today. So this is at least a challenge.
00:37:02.764 - 00:37:44.974, Speaker A: I'm not saying impossible, but it's difficult to find an agreement very fast. The other problem you might have is that you might have not enough nodes, because what if the protocol is just asking you to work for free, or for altruistic reasons? You might end up not having enough nodes. So maybe you need to incentivize network participation because you're actually doing some computationally expensive work, and or you're taking some risk or opportunity cost to work for the network. Maybe you end up not having enough nodes. And if you don't have enough nodes, you don't have decentralized trust. And the beginning, the thesis of everything, why we hear, is the decentralized trust is actually useful. So we need that.
00:37:44.974 - 00:38:21.092, Speaker A: And the last is that you might have too many bad nodes. Bad meaning faulty or even malicious like you might have. This is an open participation network. So imagine anyone can participate at any time. You might end up in a situation in which you have many malicious nodes, and in that case, it becomes really impossible to find an agreement. So how do we deal with that on ethereum? What is the approach of Ethereum? You have three important mechanisms or concepts. One is civil resistance, and that's something that you basically need in every blockchain.
00:38:21.092 - 00:39:12.134, Speaker A: Because when I say open participation, meaning really anyone can enter at any time, and actually at any time, then it's very easy for an attacker to create many nodes and dominate the network. If you don't have any way to prevent people from just spamming the network or dominating the network with millions of nodes, then it will fail. There is no way around it. So you need that sort of mechanism to limit the entrance. And this is what we call civil resistance, avoid basically fake nodes that are all controlled by the same entity. To do that, what ethereum asks is to provide for each voting right, 32 ether. So you need to have 32 ether tokens, and you need to lock them and deposit them in a contract.
00:39:12.134 - 00:39:49.168, Speaker A: And once you do that, for every chunk of 32 ether that you deposit, you have one vote. Again, consensus is based on voting. What is the voting right? It's not one node, one vote, but it's one chunk of 32 ether, one vote. If you have a lot of ether, your voting power increases. So CB resistance is good for two things. One, too many nodes because you cannot, I mean, you limit, you put a cap to the number of nodes for sure, because not everyone wants to lock 32 ether. And there is really a physical cap because there is a limited supply of ether, by the way.
00:39:49.168 - 00:40:31.842, Speaker A: So you cannot have that many nodes just because there is not much ether in existence. And CV resistance also works for there are too many bad nodes problem, because if you want to try to attack the network, you need to have a lot of voting power, and so you need to have a lot of ether. And this makes things much more difficult for the attacker. Other things done by the ethereum consensus are incentives and penalties. So there are economic incentives such that good behavior is rewarded. And that helps with the not enough nodes, because you are giving something back to the nodes that to the work to secure the network. And the penalties are discouraging the attackers.
00:40:31.842 - 00:41:08.994, Speaker A: So bad behavior is penalized. Okay, now, before going more in depth on how the consensus actually works, I just want to give some terminology that is important to know the difference between nodes and validators. So the nodes are what physically make the network. There are around 10,000 nodes, or at least that's the order of magnitude. And then you have the validators. And what I mean by validator is the voting power, basically. So if you have one node, but you have 320 e, then you can deploy ten validators, ten by 32, and you will have ten votes.
00:41:08.994 - 00:41:55.404, Speaker A: So the validators are really not the nodes, but just the amount of ether that has been staked, the total voting power that will be distributed to the nodes according to how much ether they have put at state, because that's locking. Ether means staking. You can see this is up only. And there are theories according to which this will keep going up only until everything is staked. Another detail that is important to know still is the validator queue. So I said it's open participation, but there must be some limits, otherwise it doesn't work. And another constraint that they have is that you cannot just deploy thousands of validators at the same time there is a rate limit because the consensus must be able to.
00:41:55.404 - 00:42:32.528, Speaker A: I mean, you don't want to have suddenly a huge amount of new validators that might be malicious. Okay, now, yeah, a little bit more in detail. I will talk again about how Ethereum solves the consensus issues. So I've said there are certain mechanisms that Ethereum uses to make consensus approachable and feasible, and this was civil resistance, incentives and penalties. On top of that, there are other things that make the problem, approachable and easier. And there are these properties. So one is consolidation.
00:42:32.528 - 00:43:10.894, Speaker A: We don't agree on single transaction or thing, bottom blocks. So as I said, there are blocks and the state transitions don't happen transaction by transaction, but block by block. And why is that? Because we don't want to vote on every single transaction, because otherwise everything is just too slow. We have a compromise, and we have this consolidation such that we put transactions together in a list they still ordered. But we vote on that specific block, not on the. So we vote on ordering of blocks, not an ordering of transactions. Then we have time synchrony.
00:43:10.894 - 00:43:42.210, Speaker A: So we have a constant rate of adding blocks. We can add blocks every 12 seconds. We only have new blocks every 12 seconds. And that simplifies things a lot, because imagine how tough it will be if you didn't have such rule and it was open to it could be dynamic. This makes things easier times synchrony. We have this proposer monopoly concept. But what I mean here is that every round, every 12 seconds, you have a single node that is selected as block proposer, again, randomly.
00:43:42.210 - 00:44:33.194, Speaker A: And this block proposer has all the power to say, this time, this slot, I propose this block. If you like it, you vote for it. If you don't like it, we wait for the next block proposer to send something that actually is liked by the network. So again, this makes things much easier, because if you add more proposals for the same slot, it will be not impossible, but more complex. And then the fork choice rule is deterministic. So what do I mean by that? Is that if I tell you that the nodes have to vote on what is the right blockchain, it might look a little bit subjective or like, how does it actually work? So it's very easy. Like you used software, one of the clients of the Ethereum implementation, they look at the state of the blockchain and they can easily decide what is the right blockchain or not.
00:44:33.194 - 00:45:18.784, Speaker A: So if you're honest, voting is very easy. Like it's, it's not opinionated or anything. And this again makes things easier, because all the honest nodes will run the same software and they will have the right decision, they will all vote in the same way, and everything works smoothly. Okay, now we will see at the different consensus mechanisms on Ethereum, and we have two consensus. Well, we have two components of consensus. But in both cases, the basics that we need to know is how time works. In Ethereum, as I said, one simplification, one thing that makes things easier is the fact that you have this time ticks every 12 seconds a new block.
00:45:18.784 - 00:45:51.144, Speaker A: And this is defined by the concept of slots. So time on Ethereum is divided in slots, one slot takes 12 seconds. So you have slot zero from 0 second to 12 seconds, one from twelve to 24, and so on, forever. That's how it works. Time in Ethereum is quantized like that, 12 seconds, 12 seconds. And inside the slot you also have sub slots or subdivision of time for different operations that are done inside a slot. There is also some time synchrony there.
00:45:51.144 - 00:46:28.960, Speaker A: So at the first threshold of 0 second, the block proposer has to send the block. So the block proposer has seen the transactions in the previous slot makes a block and he publishes it to the network. And then from zero second to 4 seconds, all the other nodes will look at this block and will decide if they want to vote for it or not. That's for second. Then you have from fourth to eight an aggregation of the votes. From 8 seconds to 12 seconds. The aggregation is sent to the network and basically all the nodes update their knowledge of the agreement between the nodes and they will finally find the consensus.
00:46:28.960 - 00:47:07.592, Speaker A: But yeah, all this to say that you have this twelve second slots and there is some subdivision of time also inside the same slot, but if everything goes smoothly, one slot, one block. Now on top of that, there is another division of time that is putting together slots into epochs. And this is another very important concept to know, because you will see it's a building block for the second part of consensus. So 32 slots, 32 consecutive slots make an epoch. You have, this means 32 slots, 12 seconds each. You have 6.4 minutes for every epoch.
00:47:07.592 - 00:48:15.826, Speaker A: And these are also consecutive, epoch zero, epoch one, epoch two. Why do we need epochs? Because I said that basically consensus is based on voting. You want validators to agree on what is the right order of blocks. And basically the validators will need to say, yes, this is the next block that we want to append to a blockchain. Now, Ethereum has a lot of validators because yeah, we have 10,000 nodes, but almost 1 million validators that are, they are voting, they're all voting independent, they're all sending messages. And if you want to have 1 million validators voting every 12 seconds, and you want to check all these votes every 12 seconds, it just takes too much time, it's too computationally expensive, so it doesn't work. What are you going to do? Is to divide all the validators in 32 groups again randomly, and 132 divided by 32 of all the number of validators votes on one slot, then you have another group voting on the second slot.
00:48:15.826 - 00:48:52.580, Speaker A: And basically you need 32 slots because you have 32 groups. And once you are done with the 32 slots, then you know that all the validators had the chance to say their opinion about what is the right order of the blockchain. So what an epoch is in time, is the time that you need to wait to ensure that all the validators could vote on what is the right order of the blockchain. This happens over time in different slots, but you need this 6.4 minutes, after which you know that everyone had their say. Yeah, this, that's it. And yeah, that's the concept.
00:48:52.580 - 00:49:28.066, Speaker A: Each validators votes once per epoch, and that's why you need this longer time frame. Now let's look at consensus mechanisms, like how do you actually vote in practice, in the ideal case, where everything is super easy, like very ideal. And also, I mean not true, it's not happening, but ideally there is only one chain, you have twelve. These are in time. You see on the x axis you have one image. In the slots below the x axis, slot zero. A proposer is randomly selected out of all the validators proposes block zero.
00:49:28.066 - 00:49:47.862, Speaker A: Then there is slot one. You have a new block proposer, and the block proposer builds block one and say the previous block was b zero. And the block one is a nice block, it follows all the rules. Everyone votes for block one, because it's. There is nothing to choose. Again, b two, b three, b four. Everyone is honest, everyone is building on the previous block, on the previous slot.
00:49:47.862 - 00:50:16.218, Speaker A: Easy. So if you are the block proposer at the slot seven, you build your block based on the transactions that you have seen on the previous slot. And then you add it to the one only blockchain. It's very easy both to add the block and to vote for the blocks, because there is nothing to do. Now in practice this is what happens. You have forks. So in this example you have, we start from slot zero and you have a block, slot one.
00:50:16.218 - 00:51:04.950, Speaker A: You have a proposal that builds b one on b zero. So they propose block one and say the parent block is b zero. But then at slot two, the block proposer two, instead of building on b one, is building again on b zero. I say after block b zero, we have to execute block b two and not block b one. Now you might ask how, why anyone would do that? And you know, it could be a malicious operator, because again, the network is not fully permissionless in the sense that you have to stake 32 ether, but still anyone can do it. Anyone want to be malicious, they can do something like that. But more often in practice, what happens is that the block proposer at slot two didn't see the block at slot one, because maybe it was very late or for whatever connection issues.
00:51:04.950 - 00:51:35.672, Speaker A: Again, this is the problem because this is a fully decentralized network spread all over the world with different latencies and everything. So these situations can happen. And again, you can have other forks, you can see b four, b five. So now when you are at slot seven, you are the block proposer at slot seven, and you have seen the transactions coming and you have put them in the right order. You still need to choose if you are building on b four, b five or b six. How do you do that? With the fork choice rule. So this is the algorithm that is used.
00:51:35.672 - 00:52:20.262, Speaker A: LMD Ghost fork choice rule for liveness and is ensuring that the chain will always go on. Every 20 seconds you will have a new block. So how does it work, LMD ghost? At each slot, validators are voting on what they see as the right chain of the tip, sorry, right chain tip. So the right leaf of this tree, the final block of the right blockchain, and every validator also keeps track of the votes. So if I am block proposer at slot seven, I know that there were 20 votes for block 115 votes for block, 210 votes for block three. These are, these numbers. I put them are the number of votes that all blocks have accumulated over time during the epoch.
00:52:20.262 - 00:52:51.764, Speaker A: And then what I do, I am summing the contributions from the leaves to the root of the tree of the blockchain. And I follow the heaviest observed sub three. That's what ghost is. And I'm summing 25 plus 20. Yeah, I get 45 plus 15, I get 60. So I go from b zero to b two to b four to b seven. That's how you vote both on what is red block and how you decide to add the block to a blockchain.
00:52:51.764 - 00:53:23.454, Speaker A: You just apply this algorithm. So it's very easy, very objective, is defined by code. If you're honest, you will agree with the rest of the network. Unless of course there were problems with latency communication. Because here I'm telling you what b seven, what the block for waste seven is seeing. Other nodes might have a different view of the network because maybe some blocks were not received or whatever other reason, and then applying the same rule will have a different opinion. And that's how forks are created.
00:53:23.454 - 00:53:59.222, Speaker A: Okay. But otherwise, for your view of the blockchain, this is the rule and you will know for sure. Where to build. So, when you have a fork, then you have block reorgs. What I mean by that is, is that the block one that at slot one, some people looked at it and said, this is the next block after you apply finalization. Finality that we see, you end up in a situation in which the right order of the blockchain is not b one, but it's b zero, b two, b four. So b one is skipped.
00:53:59.222 - 00:54:32.068, Speaker A: And you can see it as a block reorg. In the sense that up to a certain point in time, you thought it was b zero, b one, but actually b zero, b two, b four, b seven. Why? This is important because what I write here, you cannot assume that the block is finalized after 12 seconds. So you cannot just see a block at a slot after 12 seconds saying, okay, this is the final history of the blockchain. It will never change. You need to wait for longer and you need to wait for epochs. And why? Because in 12 seconds, you didn't have time to get all the votes.
00:54:32.068 - 00:54:57.524, Speaker A: Because all the validators are divided in 32 groups. And you need to wait for all of them to vote to be sure that there is no malicious minority that is trying to modify the history under their own advantage. Let's put it this way. So only 132 of the validators are voted on the slot. You need to wait. And for finality, you need to wait. You need to work on the knee box base, not on a slot base.
00:54:57.524 - 00:55:15.860, Speaker A: All right. Minutes. So we have. The last part is how to achieve actual finality. Because I said, LMD ghost is for liveness. Casper FFG is for finality. Finality means that once you achieve finalization, then the history can never be reverted.
00:55:15.860 - 00:55:56.080, Speaker A: There is no block, there is no epoch reorg of finalized epochs. Unless the attacker is willing to destroy a huge amount of their own ether. So extremely high economic cost. So how does it work? You work with epochs, and more precisely work with checkpoint blocks that are the first block, or at least. Yeah, anyway, the first block of an epoch. And what you're trying to do is to establishing super majority links between source checkpoint and a target checkpoint. So you have epoch zero and then you have epoch one.
00:55:56.080 - 00:56:14.096, Speaker A: And at the first lot of epoch one, you start building this super majority link. That means you are voting on what is the right connection, not between slots, but between epochs. Or more precisely, checkpoints. First slot. You don't have all the validators voting. You have only one out of 32. One divided by 32.
00:56:14.096 - 00:56:59.322, Speaker A: So you have, let's say they all vote positively for this link. You have 3%, you can go, you keep going, you have 6% 2nd slot. If by the end of the slot of that epoch you have more than 66% of the stake voting for this link, then the previous epoch that was justified becomes finalized and the new epoch becomes justified. So what is finality? It means two consecutive justified epochs. So this is another example. IDN reached 66%, so the new epoch is not justified and the previous epoch doesn't become finalized. And then I keep going and I find another super majority link and the new epoch is justified but not finalized yet because it's not two consecutive justified ebooks checkpoints actually.
00:56:59.322 - 00:57:30.134, Speaker A: Yeah. Then why we care so much about finally, that's what I said. Once it's finalized, you cannot revert the previous history unless you really destroy one third of the total stake. Dude, not happening. Yeah, unfortunately I don't have much time, but what I want to say is that there are incentives and penalties, so there are ways to enforce the probable rules that depend on economics and yeah, that's it. I can't do the last part.
