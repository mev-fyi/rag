00:00:26.304 - 00:00:46.204, Speaker A: Yeah, you have the screen. All right, so we are continuing with our schedule on time. The next talk will be from Martin Darka, and he will be talking about security at the sequencer level. Please join me welcoming Martinet with a big round of applause.
00:00:49.024 - 00:01:01.428, Speaker B: All right, hi, everybody. My name is Martin. I'm very happy to be here. I love coming to Eth Prague. I love showing new material in here. I'm from Zurkit. So some new material here.
00:01:01.428 - 00:01:29.914, Speaker B: For the first time ever, I will be showing you security implemented at the sequencer level. So before I do so, I would like to introduce Xurkit. We are a new zero knowledge rollup. We are fully EVM equivalent. And as I said, we bring security to the sequencer. So before I go deeper, I should probably tell you a little bit about the terminology that I will be using and explain what rollups are. Okay, so let's take a look how a ZK rollup works in general.
00:01:29.914 - 00:02:02.344, Speaker B: In a normal roll up, not only ZK rollup, you always have a chain that you spin up. And that chain runs a little bit faster than Ethereum. You configure it so that it produce blocks very quickly. Right. So that those blocks are bigger. And that chain has something called sequencer. Sequencer is a service of the blockchain that is responsible for organizing transactions into the sequence, right? So the sequencer receives transactions from the user, and every once in a while, when it has enough of them, it has enough of them to produce a block.
00:02:02.344 - 00:02:33.006, Speaker B: So it poops up a block and it appends it to the chain. And then we have another service that is waiting. And when it has seen enough blocks, it takes the state route of the blockchain of that l two, and it submits it into some smart contract on an l one. And that submission is done in two ways, depending on whether you are zero knowledge roll up or an optimistic roll up. If you're an optimistic roll up, it will be this kind of a trust me, bro principle. You know, we roll it up and you have a period of time where you can challenge something. When you are a zero knowledge roll up.
00:02:33.006 - 00:03:04.192, Speaker B: When you are rolling up, you are submitting a chain that is equipped with some sort of zero knowledge proof that removes any kind of trust. It's mathematically proven that that transition was executed correctly. Okay, so this is a principle of a roll up. Now, Xurkit does a little bit more and it does a little bit more on that sequencing level. So in Zurkit, we also have our l two chain, right? It's ticking a little bit faster than ethereum. Our block time is 2 seconds and we have a sequencer. The sequencer again is receiving transactions from multiple sources from the users.
00:03:04.192 - 00:03:50.184, Speaker B: And when it has a transaction it doesn't right away include it in the block. What it has available is what we call an oracle. And it asks this oracle hey, is this transaction okay for being included in a block? Meaning is this transaction benign or is it here to hack something? Is it going to damage some of the users residing on this chain? Is it going to drain your favorite lending protocol or something like that? And if the oracle says yes, this transaction is safe, nothing changes. The transaction gets included into the next block. And if the transaction is not safe then instead it gets quarantined and doesn't get included into next block. Okay? And the rest of the process is the same. Once we have enough blocks, we roll them up into a smart contract on l one.
00:03:50.184 - 00:04:31.048, Speaker B: And because this is Zurkit, this roll up will come equipped with zero knowledge proof. So let's see how this actually works in practice because we have this implemented. I will be demonstrating this on an example of a hack which is based on some economic manipulation. So let me first explain how this hack actually works. So first of all, we have one smart contract. I will be calling this smart contract the victim pool. And the purpose of this smart contract will be to hold some ERC 20 tokens and sell them to whoever comes for the exactly same price as they are currently being traded on for on uniswap.
00:04:31.048 - 00:05:25.306, Speaker B: Okay? So let's configure this pool so that it holds, for the sake of a practical example, 30 million tokens. So on top of that, as I said, I will need Uniswap. So I will have a Uniswap pair and that Uniswap pair again for the sake of an example, I will load with liquidity where it will have 30 million tokens and 30 eth. So Uniswap is willing to sell me 30 million tokens for 30 eTh. And then we will have an attacker contract whose obvious goal is to purchase tokens from the victim for price that is much lower than the market price, much lower than the fair price. And finally, because I will be manipulating some markets on Uniswap, I will need a flash loan provider. So flash loan provider will have the purpose of, or the possibility to give me a loan of some amount of tokens.
00:05:25.306 - 00:05:41.804, Speaker B: Here again, I will have 30 million tokens for the scope of a single transaction. And if that loan gets repaid at the end of the transaction. The transaction will become part of the chain. Okay, so this is my setup. Those are the four actors that will. That will be participating in here. So let's start hacking.
00:05:41.804 - 00:06:25.004, Speaker B: So at the beginning, what the attacker does is that they will come and say, hey, dear flash loan provider, you have 30 million tokens. I would actually like to borrow them. Okay, so this is the first step. Attacker borrows 30 million tokens. And the state that will be recorded as an intermediary state of this transaction on chain will be that attacker has 30 million tokens, and the flash loan provider knows that somebody owes them 30 million tokens. So then the attacker has those tokens, and they say, hey, I will take those tokens and I will sell them on Uniswap to drive the price of the token down, right? They come to Uniswap and they say, hey, here's 30 million tokens. Give me all the ether that you are willing to give me for that.
00:06:25.004 - 00:06:59.672, Speaker B: So that will double the amount of tokens in the uniswap pair. It will drop the amount of ether in that uniswap pair, and that ether will go to the attacker. So what it will mathematically work out to is that the attackers now hold 15 eth. They have no tokens. But the state of Uniswap is that they have 60 million tokens that they are willing to sell you for 15 etH. So that means that Uniswap is currently selling 1 million tokens for much less than one ETH, which was the state at the beginning. So this is already wrong.
00:06:59.672 - 00:07:40.600, Speaker B: Therefore, the attacker can come and say, hey, victim pool, please do sell me some tokens of yours for the price that they are currently being traded for on Uniswap. Right? And because we want to be smart about it, we are not going to buy all the tokens from the victim pool, but we are only going to buy 10% of those tokens. Okay, so I'm going to buy 3 million tokens from the victim pool, and that will cost me roughly 0.75 eth, so way below what would normally be the fair price. So this is the change. Victim pool now has 27 million tokens, and the attacker has 3 million tokens. And still nearly 15 eth, right? 14.75.
00:07:40.600 - 00:08:19.454, Speaker B: Well, now we have more ERC, 20 tokens. So we can do this again, right? We can go to Uniswap and say, hey, uniswap, here. I will give you three extra million tokens, drive that price of the token even more down. So we do that, and we will end up with Uniswap holding 63 million tokens. They will be selling that for roughly 14 eth. But the principle is now Uniswap is selling 1 million tokens for one, much, much less than before than for one ETH. And the attacker contract, again, has no tokens and little bit of extra ethical, and then rinse and repeat.
00:08:19.454 - 00:09:12.390, Speaker B: So we go to the victim and say, hey, give me 10% of your tokens, and it will be even cheaper than before, right? Because we drove the price down, and again, we have acquired some tokens, the victim has much less tokens, and we will keep doing that. We will keep going to uniswap, keep selling those tokens, keep driving the price down. And the point is that with every single iteration where we do this, there will be one extra much, much less in here, and the victim pool will be losing tokens, and the attacker will be gaining tokens. Okay, so this is roughly what is happening up until the moment when the pool is sort of almost drained. Uniswap, at that point, will be selling the tokens for almost zero price, because there will just be excess of liquidity in it, right. Victim pool will have almost nothing. It will not have received the fair price in ether for the tokens.
00:09:12.390 - 00:09:49.478, Speaker B: And the attacker will have all that ether that it collected for selling the tokens on Uniswap. So that will work out to roughly 17 eth. Well, and now it's time to close the hack. So, attacker comes, and they will buy all the tokens back from Uniswap. We have 17 eth, right? We will 100% be able to buy the original 30 million tokens that we sold to it, plus all that extra stuff that we have sold during the individual iterations on Uniswap. And Uniswap will be brought back to balance. So they will have probably 30 million tokens for approximately 30 eth.
00:09:49.478 - 00:10:21.984, Speaker B: Well, now, since we have all those tokens, we can close the flash loan, we can repay, right? So we sent 30 million tokens back. Flash loan providers is happy, and the final result is this attacker still holds whole bunch of tokens. Victim pool doesn't have any tokens left, but it also has probably no eth left, right? Or it received no eth for it. Flash loan provider is happy. The loan has been closed, and uniswap is back in balance. So victim pool is damaged. Attacker is super, super happy.
00:10:21.984 - 00:10:54.242, Speaker B: So now I have a demo for you. I'm going to do two things. I've scripted this entire hack, so I created a smart contract that represents the pool. I created a smart contract that actually hacks that pool. And I will be showing you how those smart contracts look and how that execution looks on a local simulation in hardhat on my laptop. And then I'm going to show you how this would look on circuit testnet, which currently has the sequencer level security embedded. So it will be discovered and it will be quarantined.
00:10:54.242 - 00:11:29.232, Speaker B: Okay, so I'm going to switch into my terminal and I'm going to ask for some assistance. Perfect. All right, let me see how this works. I will make it larger. All right, there we go. Perfect. All right, so first I should actually show you that smart contract that implements the exploit.
00:11:29.232 - 00:11:53.728, Speaker B: Right? So this is my exploiter. I said that we will need some references to flash loans, to Uniswap, and to ether, which in the case of Uniswap is called weth. It's the wrapped ether. So those are some variables or attributes that I have in here. Then I have a constructor, and then I have an entry method into the attack. It's called initiated flash loan. In here.
00:11:53.728 - 00:12:42.664, Speaker B: I'm going to tell the smart contract how much of the tokens I would like to borrow from, from the flash loan provider and who is the victim that I would like to hack. And I'm going to make a call to the flash loan provider saying, hey, please give me those tokens that I have requested. Now the execution is going to get transferred to the flash loan provider. The flashlan provider is going to transfer those tokens to this exploiter smart contract, and it's going to, in revert, call back this function called execute operation. Okay? And inside of execute operation I do in a loop, for good measure, 20 times exactly what I've just described. So I'm gonna sell all the tokens on Uniswap. So here you can see that I am reading my own balance for this particular smart contract.
00:12:42.664 - 00:13:37.444, Speaker B: Then I'm going to approve these tokens to the Uniswap router, and then I'm gonna tell the Uniswap browser, hey, please swap all these tokens that I have. This is this balance for all the eth that you are willing to give me. So I sell all of them, and then I go to the victim and I say, hey, victim, how many tokens do you have? Okay, how much eth would you want for that? And I'm going to buy those tokens from the victim. I'm actually going to buy only 10% because I'm dividing the balance by ten in here and that all happens in the loop. When the loop ends in here, I'm going to come with my ether back to Uniswap and say, hey, uniswap. And I'm going to put it higher, uniswap, please give me all the tokens that you are willing to for all this ether that I currently have. And then at the end, I'm closing the flash loan.
00:13:37.444 - 00:14:01.628, Speaker B: So this is the transfer. Now I have all of that set up in a test. So test. So this is a standard hard hat test in mocha. So the setup of the test is that at the beginning I am defining some constants. Those are those numbers that I've told you. I want everybody to have roughly 30 million tokens.
00:14:01.628 - 00:14:26.874, Speaker B: So I define my tokens. I have some log statements for nice output during execution. And then I start deploying. I deploy an ERC 20 token that will be my mock token that I am going to hack. I deploy weth because this is what Uniswap wants. I deploy a factory because the factory is needed to create the Uniswap pair. Then I deployed a router so that I can actually trade on Uniswap.
00:14:26.874 - 00:14:55.078, Speaker B: And then we deploy flashlon provider and we load this flashloan provider with 30 million tokens. Okay, I'm going to scroll up. This is where we are transferring tokens into the flashloan provider. Then we create a Uniswap pair that trades these tokens for weth. And we are going to provide liquidity to Uniswap. So we are going to approve the token. Then we are going to create for ourselves some wealth.
00:14:55.078 - 00:15:17.224, Speaker B: Then we are going to approve with and we are going to add liquidity to the token pair. And then finally we are going to deploy the victim. Here is the victim pool. The victim pool will be again loaded with some ERC 20 tokens. And finally we are also deploying the exploiter smart contract, which is the smart contract.
00:15:21.204 - 00:15:21.984, Speaker A: Sound.
00:15:26.764 - 00:16:06.264, Speaker B: All right, thank you. So finally we are deploying the exploiter, which is the contract that I've already shown you, and that is going to hack the victim. The hack itself is then in the test unit in here. And the hack itself is on this one line because we are really talking about a single transaction. So we are calling that entry function initiate flash loan with how much we want to borrow, who needs to be hacked. And then we are just waiting for this transaction to get mined. Finally some log statements again so that we get nice output.
00:16:06.264 - 00:16:39.256, Speaker B: So if I now go ahead and execute this on my local network, it's going to look somewhat like this. So scrolling up we have 30 million tokens and 30 web that went into uniswap pair. So exactly as I said, 1 million tokens for one ETH. And then we have some logging that you could have seen. So exploiter right now didn't receive any tokens, right. Starts with zero balance. Victim has 30 million of tokens.
00:16:39.256 - 00:17:10.562, Speaker B: Flash loan provider has also 30 million of tokens. And then the transaction that exploits the smart contract actually launches. So I have instrumented my smart contracts with some log statements. So those are 20 logs that are being printed in those individual iterations when I am purchasing tokens from the victim. So as I said, in the first iteration we are purchasing 3 million tokens for roughly 0.79 eth, in the next iteration, 2.7 mil for 0.64.
00:17:10.562 - 00:17:50.372, Speaker B: And you can see that in every single iteration there is actually that amount that I am purchasing dropping because the pool is getting drained and I'm purchasing it for less and less and less eth because the price of those tokens on Uniswap is also being driven down. When the exploit completes, let me see if I can actually move it up for you. There we go. When the exploit completes, this is the final state. So the flash loan provider was satisfied it received the loan back. The victim got totally screwed because they do not have 30 million tokens anymore. They only have 3.6
00:17:50.372 - 00:18:09.514, Speaker B: left. Notice that this decimal point is actually moved compared to the other ones. And the exploiter now has balance. It started with zero and now it has 20 million tokens. Right. So this is a justification that this hack actually works, that I did not make it up how it should work. You are seeing it now.
00:18:09.514 - 00:18:32.622, Speaker B: What I have next for you is actually a video of how this thing works and plays out on circuit. Now I'm hoping that this is going to be big enough for us. Let's see. Hopefully. There we go. So I've deployed all those smart contracts on Zurkit and executed exactly the same hack. So here you can see what I'm doing.
00:18:32.622 - 00:19:02.120, Speaker B: I'm going to play this at the beginning. At the beginning we are deploying. So I am deploying from this account DAC. First the mock token. Then after I deploy the mock token I deploy weth. After I deploy weth, I'm going to start deploying Uniswap. So first you get the factory, after the factory you get the router.
00:19:02.120 - 00:19:31.074, Speaker B: After the router we will be able to deploy the flashloan provider. Then we are going to use the factory to create uniswap pair. Then we are going to log something and load that pair with liquidity. We've added liquidity to uniswap and now we are going to deploy victim and that should be it. So this is the first step. This is the setup. Now I'm clearing my terminal and I'm going to deploy the attacker.
00:19:31.074 - 00:19:55.696, Speaker B: So deployment of the attacker, that's going to come from a different address. So nothing special. This is my exploit orchestrator. That's the address that I'm going to turn this back a little bit. This is the address that I am going to be exploiting from. This resolution is not good. Okay.
00:19:55.696 - 00:20:43.186, Speaker B: I'm not going to turn it back. So there is an exploiter contract deployed. Now, what I've created for myself in here are two auxiliary scripts. So because we are going to be quarantining some transactions, it wouldn't be a good experience for the users if they couldn't know whether the transaction was not mined because they had some issue with the transaction, or whether it was underpriced in terms of gas, and it's still waiting for being processed, or whether it was actually quarantined. So what we have created are custom RPC methods for Geth Zirk get quarantined, which returns for us the content of the quarantined as it currently is. And I have one more method. It's is quarantined.
00:20:43.186 - 00:21:26.062, Speaker B: Cirque isquarantined, which takes one parameter is the hash of the transaction, and that tells us whether the transaction has been quarantined or not, specifically so it returns true or false. So now I'm listing the quarantine. You can see that the result is currently empty. Right? And I am going to run the exploit. So now the exploit starts on circuit and you are going to be able to see that we've logged something and we are launching the exploit. But no output is coming out. Why is no output coming out? Well, because the transaction is actually not getting completed, it's not getting mined.
00:21:26.062 - 00:22:24.368, Speaker B: So in my scripts, I'm going to show you that exploit script. What I have in here is this line. So here I am launching the exploit, here I am waiting for the transaction receipt that gives me back the hash, and here I am waiting for successful inclusion of the transaction to the next block where it will tell me, hey, this transaction was completed, or this is where it would fail. So this line actually never completes because we are not sure what's going to happen. The transaction gets quarantined, right? So the attacker is just waiting up until, you know, you can see this control scene here. I decided to kill the command because now we can actually double check what happened and we can list the quarantine. And our quarantine is no longer empty.
00:22:24.368 - 00:23:04.470, Speaker B: I don't know if you guys can see it, but the, the hash of the transaction is zero x 785 in here. And then if I query the other script. So here I am filling in this hash of the transaction into this parameter. If you've seen what I've pasted, for the first time, I actually screwed up. I pasted the wrong hash from my clipboard. So now I'm grabbing the proper hash, I'm fixing it, I'm going to put the right one in there and we are going to query it again and you will see that this actually returned through this time. Okay, so this transaction is now quarantined.
00:23:04.470 - 00:23:30.666, Speaker B: So this is the end of my demo. Thank you a lot. Back to the slides. So we have seen that circuit has successfully captured this transaction and quarantined it. Obviously for non technical users. This will be also displayed on the block explorer. So this is a screenshot from our staging environment from the block explorer, how this is going to look when we launch our main net.
00:23:30.666 - 00:24:16.668, Speaker B: And right here, if you can read this first transaction, this is actually the one that starts with zero x 785. That's the one that was quarantined. So how does it work in the background? The implementation of Zurkit is, is based on Geth. So geth maintains some very creative naming for pools of transactions that it maintains. So it puts all the transactions that it receives from the users that are properly signed in something called queue. And then it has also something called pending queue, where it moves the transactions that are ready for immediate inclusion for the next block, for example, because they already mean the nonce rules and so on. So there's some validation that happens in between.
00:24:16.668 - 00:25:26.844, Speaker B: And this is exactly that moment when we hit the oracle and we say, hey, should this transaction actually be moved to the pending queue or should it not be moved to the pending queue and go to the quarantine instead? And for us, quarantining transaction essentially means that we put a flag on it and says, hey, do not ever, or, you know, up until some other conditions are satisfied, move it into the pending queue. So some early experiences with this circuit is currently on Testnet. There are not so many hacks that happen on testnet. Right? So a lot of this is based on our testing environments and various simulations. But the very obvious question is how performant is this? At the beginning of the talk I mentioned that Zerguz block time is 2 seconds, right? So if I needed 10 seconds to analyze a transaction that would actually again provide very terrible user experience. So the bottom line is that our oracles are performant enough that majority of transactions can be analyzed under 1 second, and some of them can take up to 2 seconds. So the bottom line is we actually using these particular oracles have sufficient bandwidth through parallelization to accommodate the blockchain traffic at the two second block time, which is great.
00:25:26.844 - 00:26:01.544, Speaker B: You might be asking what happens with those transactions into quarantines. I was getting a signal that I'm slowly running out of time, so I actually have a different talk. It's from ETH Denver. There is a YouTube recording of it, so please watch that if you want more details about implementations and considerations for the sequencer level security. We also have a paper on archive, so if you google my name and sequencer level security, it will definitely pop up. Otherwise, here is the archive link. Other question that comes up is if this can suffer from denial of attack.
00:26:01.544 - 00:26:33.578, Speaker B: Yes, well yes you can attempt, but no, you will not be successful. There is a cost so that there is some civil protection there. Again, deferring this to the paper. How strong these oracles are vary. We have the privilege of having the transaction history of all the EVM chains available on those chains. So we actually back tested those oracles and trained them, and they are very strong. There are some hacks that I'm listing in here that were caught by these oracles.
00:26:33.578 - 00:27:16.594, Speaker B: And yeah, the bottom line is the oracles are very, very strong. Can it be decentralized? Yes, again, deferring you to the paper. Can we work with multiple oracles? Yes, deferring you to the talk from Denver and when Zircon Mainnet, where this is going to be available for every single project and every single user on the network is coming in summer of 2024. As I said, we are a zero knowledge roll up. So we are also right now running a KZG ceremony. So if you would like to contribute to our trust and the trusted setup, please get in touch with us on discord, on Telegram, anywhere, we will very gladly include you. And that's everything that I wanted to tell you.
00:27:16.594 - 00:27:24.664, Speaker B: So yeah, this is Zurkit, this is circuit's sequencer level security. If you like circuit, please come and build on us.
00:27:29.084 - 00:27:35.924, Speaker A: Thank you very much. Martin. That's precisely on time and with a live demo that went flawless. So thank you.
