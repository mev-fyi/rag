00:00:02.560 - 00:00:27.394, Speaker A: Yeah, back then, I remember 2017, I went to Defcon in Cancun, and there, one person told me, why do people even go inside of talks? They're all recorded. You can watch them later on. The actual action happens outside when you meet the people. I kind of agree. So thank you so much that you. Anyways, come to watch my talk. Yeah, let's start.
00:00:27.394 - 00:01:13.474, Speaker A: Let's get into it. How does it work? So, who knows what the graph is real quick. So that's the graph. The blockchain is a big mess of different stuff, and it just magically puts it in order. Or we can also look a little bit more at the architecture that I know from Mallamport back in the days that we have the frontend on top, decentralized, and then a data layer, which is the graph, and then the smart contracts and the blockchain. So it enables that access to blockchain data, or as I said, the data layer of web3. The graph is not only just a technology, it's also a decentralized network.
00:01:13.474 - 00:01:41.944, Speaker A: As of now, I think this morning, there are 239 indexes, independent indexes across the world, added index subgraphs. There are 120,000 more delegators, curators and subgraphs. The one topic that we go a little bit into it. So it's a decentralized network of data, if you want. As of today, there are 3.49 million GRT in query fees already processed through the network. So you see, it's actually one of those decentralized networks that work.
00:01:41.944 - 00:02:22.180, Speaker A: And it's not just promises we end up with truly decentralized data. But the other concept is subgraphs. Who is familiar with subgraphs? The concept, a little bit less. Right? So a subgraph, as engineers, we can simply think about them as database schemas. So, like, if we have that mess of different data that's on the blockchains, and we want to kind of make sense out of it. So we design a database schema, and then some logic how to fill that database schema according to what happens on chain. So, as I said, the chain, we all share the same block space, all the protocols share the same block space.
00:02:22.180 - 00:03:17.636, Speaker A: And if you want to make sense out of it, usually we are not interested in its entirety, but very specific in certain contracts that are there. And then subgraphs, basically, you can think of this logical unit that kind of defines a database that is very specific to one particular use case. So when you, for example, look at the subgraphs at Masari, it's writing, they have, like, for each protocol, the subgraphs that are tracking them, storing them in a way that then they can in the end create a protocol matrix on top of it. So then when we talk about read oriented roll ups, then we need to maybe think about the subgraph data flow. Do I have a laser pointer here? Ah, nice. So everything starts with the blockchain. So when the blockchain we have all that data that kind of streams, as I said, into these mappings.
00:03:17.636 - 00:04:17.282, Speaker A: This is written in assembly script or like in the newer technologies for substreams. It could also be rust in the end, like it compiles down to webassembly, then it goes to a store. It can be read from the store if needed, but in the end the consumer can just query it. The magic happens actually here in these mappings because assembly script also and also rust are so called Turing complete, smart contract, Turing complete languages. So we can actually code whatever we want inside of that data pipeline. So for example, there was a team that actually wrote the synthesizer into a subgraph that gets blocked data and starts to generate music out of it. But we can also think about maybe some CK prover that run off chain inside of the subgraphs and then can then funnel back, funnel back the data where we go in that later on.
00:04:17.282 - 00:04:59.008, Speaker A: So that's cool thing. So I want to emphasize it's during complete, we can offload a lot of computation from chain into subgraphs to make sense. So there was this idea that came up, actually it's a while ago, right? 2021. But like, hey, we can just like build a blockchain into the graph protocol by itself if that inherits the security of Ethereum kind of this idea. So then, okay, how would that look like? And it's basically very simple, just a smart contract. We call it the data edge. You can find that also in the graphs forum that just has a fallback function that basically does nothing.
00:04:59.008 - 00:05:57.054, Speaker A: But the cool thing is when we call that function, we can provide any call data into it, and that call data is stored on chain. And then we can write a subgraph that watches that data edge contract and gets that data in. And maybe we can come up with something like there is an instruction set, there is some logic going on a little bit similar as bitcoin. People try to have their ordinals that have their logic that might or might not be applied. But yeah, that's the data edge. So in a very extreme way, then the blockchain is just like the data storage that triggers then all that logic computation in subgraphs later on. So what's happening is that logic can move from the blockchain to the mappings to reduce the load that we have on chain if needed.
00:05:57.054 - 00:07:01.784, Speaker A: Another very interesting component that could come into play is so called off chain data. So far we looked about on chain data, which is kind of like, yeah, it's cool, we can maybe extract some stuff and do more with it, but we can even bring off chain data into the mix, which makes it more interesting. So when I talk about off chain data, what would be off chain data? So for example, it could be empty seats for airlines. Airlines want to have monetize that more, want to kind of publish that data a little bit more, or we have hotel beds for hotels that they want to publish what's going on there, even like weather stations. So we can think about maybe like a decentralized network of weather stations that all have some off chain data that we then want to bring back on chain or traditional, or not traditional. It's kind of like server data, like requests to a server or quality of service, response times and so on. These are usually off chain.
00:07:01.784 - 00:08:17.474, Speaker A: And the graph could be used with subgraphs to just publish them. I just show how that would go. So basically the trick here is to have it on IPFs and Arviv, and subgraphs can then be triggered on chain to then start to download that stuff from IPFs or Arviv and then still go into the maps and store it in the same store. That's possible today already. So like for the off chain data that we had before, the graph could be or subgraphs could be and can be actually that people are doing this, a way to publish data, make it accessible because like data access in the graph network, it's already made, there are the indexes that store it, there are the gateways that give access to it, they care about billing. So that whole hassle of oh, I have that data, but I don't want to make it public because then I need to have an API and the API that needs to have access control and that access control is complicated and maybe I want to monetize it and we don't have a credit, it could also be offloaded to the graph. And yeah, it's simply by just emitting a hash of an IPFS file or an rv transaction and then download it and store it.
00:08:17.474 - 00:09:16.694, Speaker A: That enables, that actually is in use. So for example, for the gateways on the graph network, that's what we do is there's a quality of service, Oracle, so to say. So whenever someone access the graph network, then it goes through one of the gateways, the gateways. Then they send these logs, some of them now they don't need to necessarily, and they go into the red panda, materialize the EB, there is a cron job. And then regularly there will be the whole access logs, so to say, like which subgraph was access, what was the query, which index was selected? How long did it take for the index to resolve? That query is then uploaded to ipfs. I think every five minutes that IPFS hash is then put on Nosischain and then there is a subgraph that indexes that data again and then creates that quality of service subgraph. So we can now go to that subgraph.
00:09:16.694 - 00:10:18.208, Speaker A: Yeah, I cannot do live coding here, but we can now go to that subgraph and start to find out which index is the most performant or like which top graph is the most, the most queried one and so on, so forth. It's all there. It's very cool. And that's basically off chain data that could, like every other company, even like not web3 company could start to publish data like this and have it accessible. But the magic comes when you, when you put that together. So I kind of hinted quickly before, imagine like we have like this decentralized network of weather stations that helps us to have like an oracle that says like did it rain or did it not rain for my own chain insurance for the Zurich open air or whatsoever. How would that work? How can a smart contract know if it rained or not without needing to trust maybe meteors rights or whatever? But then we can think about, there are thousands of weather stations that are just uploading the weather data that they see into ipfs and then anchor it down on chain and say, that's what I saw.
00:10:18.208 - 00:10:43.796, Speaker A: Then we can more or less have a more trusted image about what's going on. Nice. That's all around using what's already there with the graph network, as I said, we have the indexes, we have subgraphs, indexers have stake, that secures the network. We can work like this. This is out there. And then we are back on chain. So now we have all that on chain data.
00:10:43.796 - 00:11:40.240, Speaker A: We talked about server access logs, quality of service looks, and also decentralized weather oracles. But when you want to bring it back on chain, that's the thing with a decentralized weather oracle. We also want to have this boolean thing of do we need to pay out the insurance sum or not? And that's where oracles come back into play. So I have like, there are two examples, like gelato for example, with the gelato web, three functions, they can read from a subgraph on the decentralized graph network and then put it back on chain and then say, okay, actually it rained, so we need to pay out. Yes. That kind of closes the loop. The cool thing is all that information, we go later into that.
00:11:40.240 - 00:12:17.606, Speaker A: Also, that is not just like someone has said, but there is some economic proof on top of it. I think it's the last slide. So just to recap quickly. So why are we, why am I talking about subgraphs as roll ups? Because basically what happens in rollups is like we have to block, we have the l one, and then the state goes up, the state will be changed, and then the change state goes down and so on and so forth. That's kind of like how we can think about the roll up. And now when we go to the graph, it's read oriented. Rollups is like there's also state happening on l one that goes to l two.
00:12:17.606 - 00:13:00.304, Speaker A: There is some computation going on. And now if Orac, because we can even bring it back on chain, it's a little bit different. It's kind of like the focus is on reading and processing. Yeah, if that makes sense. Yeah. Closing thoughts about verifiability, especially when we have oracles that bring stuff back on chain. It's like when we look at this, let's say gelato web, three functions, they can query any endpoint, but what we need is we want to know, is it actually true? And so with the indexes on the graph network, the thing is that they have stake.
00:13:00.304 - 00:13:36.946, Speaker A: So all the indexes on the graph network stake a good amount of GRT, some more, some less. And then whenever they respond to query, they send a so called index attestation back and say, like I, with my stake, say, that's true. And if someone can prove them wrong, then can be slashed. So it's not just like something, it's actually they prove if they're stake. There's also more going on. Like can we have more verifiable indexing, more verifiable queries index also start to talk to each other with gossip networks and so on to see if they see the same data. But in general, this is how it works.
00:13:36.946 - 00:13:55.394, Speaker A: It works with that stake at the moment. Yeah, it was a bit quick one, right? But as I said, it's recorded, so you can still watch it, maybe relax at home. This is the link to my twitter if you want. And thank you so much for having me.
