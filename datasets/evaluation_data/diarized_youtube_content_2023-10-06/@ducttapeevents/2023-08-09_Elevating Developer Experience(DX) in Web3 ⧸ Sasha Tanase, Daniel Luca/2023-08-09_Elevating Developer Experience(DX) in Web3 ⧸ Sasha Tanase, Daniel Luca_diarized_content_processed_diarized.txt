00:00:05.920 - 00:00:27.854, Speaker A: Hello everyone. Hi. Good to see so many new curious faces and hungry to learn some things. Some new things. So let me introduce myself. I'm Sascha Tanase. I'm a designer and researcher collaborating and contributing to the threshold network, formerly known as new Cipher Network and keep Network.
00:00:27.854 - 00:00:48.458, Speaker A: I am part of the core team who is building TBTC, the first fully decentralized bitcoin to Ethereum Bridge and I am also the co founder of web three UX user panel. I like to say that my job is to transform extremely complex products into.
00:00:48.546 - 00:01:16.734, Speaker B: Palatable bits and I'm Daniel. I've been in this space since 2017. I was a developer entrepreneur before I started by building an analytics platform. As part of consensus. I moved on to consensus diligence where I did security audits and security research. I helped found a stablecoin and now I run the tech platform at Edenblock and we do investments in seed stage companies.
00:01:18.494 - 00:02:21.828, Speaker A: So today we're going to learn what is this DX or developer experience? What is the impact of DX? And we are going to present you the great guideline which me and Daniel have put together. And you will also have an appendix which means that you will be able to check the TBTC client code diary study and the Mina protocol diary study. So let's learn what developer experience is. Well, is the equivalent of user experience when the primary user of the product is a developer. But don't get fooled by the fact that the primary user is a developer and it means they are highly technical. Usually the products designed for developers are really bad and the experience is quite, quite traumatic. So due to the fact that developers are more of a technical Persona, the product's ux owners end up believing the developer is a power user.
00:02:21.828 - 00:02:53.924, Speaker A: But that's kind of wrong because developers deserve solutions as well designed as non technical people. So developers are power users, and even though they are like this, we throw at them the most cumbersome solutions. Poweruser is a super deceitful term that makes you forget that developers are normal users too, and they will appreciate and benefit from simple solutions just like everybody else.
00:02:54.944 - 00:03:16.084, Speaker B: So we have to kind of help the developers to become power users, because they're not power users. When they start using your product, you have to unlock that potential and that is done over time. You present a new tool, a new SDK, a new library. They're not going to know to use it right away. It takes a little bit of time and guidance.
00:03:18.384 - 00:04:28.758, Speaker A: So in order to build a developer centric product, you need to make sure that your product is taking into account three pillars, best practices, user experience, and developer needs. So we're at an Ethereum conference and why should we care about DX? You will ask me? Well, Ethereum consistently draws 20% to 25% of the developers coming to web three. From January 2022 to December 2022, Ethereum monthly active developers grew by 5%, which means that Ethereum is onboarding more developers and the need for straightforward processes may be higher than ever. A positive DX can increase adoption and retention and the growth of a chain's developer community. And if you're still not convinced, here are some stats. You can actually check the report afterwards. It was done by Electric Capital.
00:04:28.758 - 00:04:30.114, Speaker A: Developer report.
00:04:32.614 - 00:05:10.752, Speaker B: Okay, so a little bit about the importance of the x over time. We've said that blockchain is not getting adoption because the UX is bad. And in the last few years we kind of realized that the user in the UX is actually a developer. They first need to build something on your protocol in order to bring it to the users. So they're not the first person who touches your protocol or what you've built. So that means that we have to build things with the developer in mind and helping them onboard your protocol. So for example, you might have an SDK.
00:05:10.752 - 00:05:54.814, Speaker B: An SDK just provides some kind of abstractions on top of your protocol. It does require some resources to build that, and you don't need to know a lot about the internals of the protocol. So an SDK definitely helps in that sense. For example, you have SDKs for Uniswap that help you use their protocol, which is more complex than it actually seems, but the SDK makes that very easily accessible. So you have other things like biconomy, which does account abstraction, and they also have an SDK, and you can use that SDK to onboard developers. Sometimes you just have smart contracts. So that means that you didn't have the resources, the time and the people to build SDKs.
00:05:54.814 - 00:06:35.544, Speaker B: You just have those smart contracts. So the initial design that you did will affect you quite a lot and will affect the amount of people that understand how to expand your protocol, how to use it as a Lego piece and build something on top of it. But you can also have, you can think about developers. When you're launching a new blockchain, you're not going to have users like users that have Web uis right away. You're going to have developers, they need to build stuff. They need to know how to query the chain, they need to interact with it directly. You also have web widgets like small pieces of HTML code that can live within your product.
00:06:35.544 - 00:07:27.230, Speaker B: Having good DX can reduce the cost of growth. So it's much easier to grow your user base. It's much easier to integrate and help others use your product, and thus it's much easier to scale your product. It's also good when you're building stuff to not spend too much time on helping users. You have to spend some time to be connected with them. But you want to focus more on adding more features and building more within your product in your protocol. Okay, so I think it's important to describe that this framework, this great framework, is not something.
00:07:27.230 - 00:08:11.174, Speaker B: It's not a git repo, it's not a template, it's more of a guideline. It's something that can help you plan your product and help you understand how to talk to a developer, how to have them in mind whenever you're creating something. It's more like a set of principles and guidelines to guide you throughout the process. So we start with g, which stands for good documentation. This is probably one of the most complicated things. You have to understand your audience. What is their background? What questions do they have? Do they need help installing tools? It has to be clear and simple.
00:08:11.174 - 00:08:52.076, Speaker B: In the first stage, you kind of want to guide your audience to get to a success stage. Even if you don't present all the bells and whistles that you have, you have to help them reach that success thing. Build the hello world of the application. That initial success will pay for the struggles they can take to build something more advanced. Also, it's very important to have it up to date. It's easy to have it up to date when you're creating it right now, but it's difficult to keep it up to date over time. A trick to do that is, whenever you're growing your team, you have new people coming in.
00:08:52.076 - 00:09:20.528, Speaker B: You don't tell them a lot about your product or about how it works. You let them go through the documentation. If they find something that is not up to date, they can do a pull request. They can build something. So this way you know that the onboarding process for the developer is still smooth. Of course you need to have examples and tutorials. Engineers work very well by doing stuff, by writing code, by changing that code after that.
00:09:20.528 - 00:10:13.088, Speaker B: Examples and tutorials are very, very important and it's good to think about how to organize your information. You can think of it like getting started, installing tutorials, reference API, faqs, all of that. But it's important to have in mind that you have to organize your information. Another important thing is you have two types of users. One user is the developer who will use the SDK or the library to build something. And you will have another type of user, the one that can be a contributor so they can contribute to what you're building. And maybe the documentation will be different in different cases because you need to set some PR guidelines, some issue guidelines for all of that.
00:10:13.088 - 00:10:49.014, Speaker B: It's good to have that in mind. Now the r starts for robustness, and in software development it's important that the system is robust. So that means even in the presence of a stressful environment has to work correctly. So you kind of have to be paranoid. Assume that everybody's trying to destroy your product, they're not doing the actions in the right order. You have to assume your user is maybe stupid, so they don't know exactly what to do. Or maybe they forget.
00:10:49.014 - 00:11:35.814, Speaker B: Dangerous implements refers to protecting in your libraries, protecting the things that shouldn't be interacted with. So that means private properties, methods that should be hidden, don't allow them to be used directly if they shouldn't be interacted with. And the can't happen is that you might have a few things that are very very unlikely to happen. So you assume that you shouldn't do anything there. You should still write code that protects your users from that. Okay, so now I have an example that tries to lay out an example of robustness. Let's say we have this class, so people will instantiate this class.
00:11:35.814 - 00:12:15.844, Speaker B: They need to call connect, and after that they can call get to extract some data. A user might instantiate a class and use get right away without connecting. So what you can do is you can add connect in the constructor, you're protecting the users from themselves. What is if, for example, you don't want to connect on instantialization. So you might add something like an argument that defaults to true, but you can set it to false so it doesn't connect right away. So you're kind of trying to protect the user from itself every time.
00:12:19.224 - 00:13:20.400, Speaker A: So e stands for error handling, which is crucial for any system. And in order to have good error messaging, you should label them correctly, which means the error will communicate to the user how important this error is. If you label a fatal error as an info, you will mislead the user and they may suffer big consequences because of that. This will make the user lose trust in the product and even stop using your product. You have to be specific, which means the error message will tell the user exactly what is wrong and can help guide the user towards a solution. The error message needs to be instructive and verbose. A verbose error message will describe in detail what is the issue the user encounters and will have a hold hand approach by telling the user what are the next steps and what they actually need to do in order to solve the error.
00:13:20.400 - 00:14:13.414, Speaker A: You have to be non blaming when you're writing your error messages. It's not the user's fault that you haven't given them the exact information and you haven't offered them good instruction. You would also need to do error messages in plain language even though the errors are addressing devs. Explaining an issue in plain language will go a long way and it's better to avoid using terms that you've coined and nobody else understands. You would also need to add severity grades. It's super important because this way the user understands what's the impact within this system, and then you can also add error codes. This way a user can see exactly in the documentation the code and help them troubleshoot.
00:14:13.414 - 00:14:58.494, Speaker A: And what do you think, guys? This error is telling you. It doesn't matter what you think because the issue with this error is that whenever you would have an error, this would show. So not very useful. How about this error? Well, this one is definitely better, but it can be improved. Right now in this error, we don't know what address needs to be registered and also we have to know where the threshold dashboard is by heart. We don't have a link.
00:15:01.514 - 00:15:32.230, Speaker B: Okay, so regarding accessibility, I think it helps a lot if it's community first. You're going to have developers who first find your GitHub repo and that has a readme with installs and whatever try to onboard them in the community first. So like make them join the discord server or the telegram whenever they have problems. They're not going to be stuck waiting for you to respond. The community can help. That helps tremendously. Make sure that you provide support.
00:15:32.230 - 00:16:04.344, Speaker B: So when they open issues prs, even with prs, help them write better code, help them respect the standards. No barriers to entry or low barriers to entry means that it's good not to have credit card if you want to test the product or implement something. Or it's even easier if you have a testing environment that can people use. No email confirmations whatever.
00:16:05.284 - 00:16:53.844, Speaker A: And you would also need to think of impairments. Impairments can be temporary or permanent. For example, temporary impairments are when your user may have a broken arm or they may be drunk or high. However, there are also permanent impairments like users who are colorblind or they have astigmatists such as myself. So every time you're designing something, it's no matter the duration of the impairment, you should actually be super inclusive and make sure you accommodate any type of user. Testable. We have a right to the last one.
00:16:53.844 - 00:18:05.484, Speaker A: Testability is extremely critical for the developer experience because it impacts maintainability, reliability, and overall the quality of software. If you want to do documentation testing and task success, the easiest way in web three is to set up a diary study, which is all also known between researchers as the poor man's ethnographic study. We have a couple of examples. By the end of the presentation, you will need a minimum of five participants. You will give the participants a big task, like, let's say, setting up a node, and you will give them a longer period of time to finish the task. This will allow users to complete longer tasks, and you won't need to be there observing them living and breathing onto their necks. And because they're going to log into their diaries, all of the actions they have needed to take, and all of the emotions they're experiencing.
00:18:06.704 - 00:18:56.644, Speaker B: Regarding modularity, your system can be modular, so if you want to test only a part of it, you can kind of fast forward the user to that step. And that helps testing with very, very specific, specific things, but also helps with development and integration tests and all of that deterministic helps if you can reproduce the errors, you can reproduce the states, can you actually save the state and regenerate it at the later stage? And it helps a lot if you have a testing environment and also can be kind of a development environment. Think of it like GitHub codespaces, where you can just instantiate a machine that is on top of a GitHub repo.
00:18:58.664 - 00:19:43.124, Speaker A: So we've learned what DX means. We learned how it impacts a product, and we also learned the great framework, which stands for good documentation, robustness, error handling, accessible and testable. We also added a couple of links you can check out to see later on about the studies that we have conducted, but there's no problem. We also have created the QR code, and you can actually check the presentation deck, and you have everything there. Thank you. Thank you, Barry. And any questions?
00:19:52.304 - 00:20:26.374, Speaker C: Have you built your own tools to actually make this developer experience a little bit more concrete, maybe more tabularized than in the current Docs project, whatever, because it's very simple there. It's not really open. Sometimes people, it's still quite, let's say, scattered the communication of the community in a discord, then there's a docs and so on. So there should be something better than discord, we all know that. But have you built your own tool?
00:20:27.094 - 00:21:18.794, Speaker B: So we did start working on a framework. The thing is, we kind of need to develop a framework for typescript or for go for rust for all of that. And then you can add some good practices within the repo. So like the CI will auto generate documentation for me, or I have some good templates for issues or for prs, and that helps a lot, but it definitely doesn't solve all of the issues because I'm not going to have too much communication on GitHub. Even though you can have Wiki, you can have something like a forum on GitHub. So you can actually do that. People are not necessarily used to that, so we are working on something like that, but I don't think we can provide something that solves everybody's issues because everybody wants things a bit different.
00:21:18.794 - 00:21:30.140, Speaker B: So we're gonna launch this, I think, at EcC, but everybody can do their own. It's just a good set of practices. Okay.
00:21:30.172 - 00:21:32.104, Speaker C: No, thank you. See you at Ecc.
00:21:37.644 - 00:21:38.724, Speaker A: Okay, thank you.
