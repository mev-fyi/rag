00:00:00.320 - 00:00:40.810, Speaker A: Hello everyone. Thank you for being with me today. So today I'm gonna present a topic that is not that recent. It's been something, it's something we've been talking about for a while now. We call it often Defi pooling. And what it is, in a nutshell, is a way for you to build applications that live on l two that give your users l two experience with fast, cheap fees, fast transactions, cheap transactions and a better ux. All the while using l one, liquidity and using defi applications that live on l one that have a lot of advantages around l two.
00:00:40.810 - 00:01:05.896, Speaker A: So I'm going to try to explain how is it. I want to underline that this is very much an open field. So if you have questions about it, don't hesitate and ask them. And if you want to try and build stuff in that field, reach out. I'll be more than happy to give you pointers on how to explore that land. So before we start, I'm Henry. I'm a developer advocate for Starknet.
00:01:05.896 - 00:01:43.964, Speaker A: I work at Starcware, which is the company that develops Starknet. I'm based in Paris and you can reach me on Twitter or on Telegram. We have a booth over there, so don't hesitate and come say hi. So, what am I going to talk about today? First of all, I'm going to do a very quick refresher as to what are validity rollups or ZK rollups and how they work. Then I'm going to talk about messaging bridges and protocols. And then finally I'm going to explain how that all results into what Defi pooling is. So first, let's talk very briefly about validity rollups.
00:01:43.964 - 00:02:08.212, Speaker A: So who here in the room is somehow familiar with validity rollups or ZK rollups? Can you raise your hand? Nice. So a few of you. So for those of you who are already familiar, I hope I won't. It will be fast. Don't worry. So first, let's reintroduce a concept that are validity proofs. Validity proofs are really the basis of what validity roll ups are.
00:02:08.212 - 00:03:28.250, Speaker A: And they're essentially a cryptographic tool which you can put in the same category as say, hashing functions or digital signatures. They are mathematical tools that are backed so they are based on mathematics. You can dive into how they work if you want, but if you're building an application, you can also just use them in your application. And validity proofs allow for the following they allow one person to run a program and generate a proof of execution of that program, meaning they run their program to get the output and they also get a proof. This, this proof is like a value a number. And by sending this proof and the output to another person, this other person can use these two elements, put them in another mathematical instrument and verify that the program was executed correctly and that indeed it yielded that input. So in other words, it allow person a Alice to execute a program and it allows person B to verify that the program was executed correctly and trustlessly exploit the result because they know mathematically that this is what the program yielded.
00:03:28.250 - 00:04:15.430, Speaker A: Now where this gets really interesting is the following. There is an asymmetry between proving and verifying. When you're proving a big program, it takes longer to verify on the other end, but it gets exponentially cheaper, meaning the bigger the program, the lower the marginal cost of verification per unit of compute. So it introduces an asymmetry between the person doing the calculation and the person verifying the calculation. All right, so these are validity proofs in a nutshell. Now, how do they relate to blockchain and how do we use them in the blockchain world? Here is what validity rollups are in a nutshell. Validity rollups are blockchains.
00:04:15.430 - 00:05:07.604, Speaker A: They have blocks, they have transactions, they have smart contracts. And these blockchains are executed by entities which are called sequencers. And every now and then, let's say every 100 block, these sequencers generate a proof that the blockchain move from block zero to block 100 correctly. And that proof gets sent to Ethereum in a smart contract where it is verified. So in other words, this blockchain is executed by a big machine and it can be verified by small machines in a smart contract on Ethereum. And the Ethereum, blockchain has certainty that the blockchain was executed. The off chain blockchain was executed correctly because it has this proof and it is able to interpret it.
00:05:07.604 - 00:06:19.424, Speaker A: All right, now what is really nice with that setting when you start thinking about it in different terms, is that to the best of my knowledge, this is the only instance where you get blockchains talking to each other natively. Think about it. When you are using a bridge that relies on validators signing messages, what you're really doing is you're asking blockchain A to interpret something that is coming from blockchain B. But the only way blockchain a knows that blockchain B did something is because a bunch of humans signed messages to say, yes, yes, this is what happened, right? So you're relying on the human translator, taking the example of, say, bitcoin, for example. There's no way for Ethereum to actually validate what happened on bitcoin because running a full node, a full bitcoin node on Ethereum would be way too expensive. Well, with validity proof, you get to prove the blockchain and use that result in Ethereum so they can actually understand what happened. On the other hand, without human translation, just based on mathematics.
00:06:19.424 - 00:07:03.400, Speaker A: So the cool thing with validity roll up is that they allow you to pass messages. So now I'm going to talk a little bit about messaging bridges and how they relate to validity rollups and defi. First of all, let's define what cross chain protocols are. Cross chain protocols are essentially a way for l one and l two to exchange messages. When you think about bridges these days, most of the time you think about asset bridges, you think about bridging nfts, you think about bridging tokens. Reality is you can do a lot more with blockchains than just manipulating tokens permissions. You can maybe delegate execution of code or this kind of stuff.
00:07:03.400 - 00:08:28.998, Speaker A: So cross chain protocols are really not about moving assets, they're about moving data. They're about exchanging instructions and coordinating behaviors of smart contracts on l one and on l two, right? They allow smart contracts on both chain to interact with each other and be a meaningful whole without having to rely on humans. Now, if you think back at what defi is, defi is sort of similar, right? There are protocols, there are set of rules that govern how you move asset around in the blockchain in Ethereum. And usually most of defi application rely on input that comes from l one, right? It comes from a transaction, it comes from an oracle update, it comes from a liquidation event, something like that. Now, the concept of defi pooling is really simple. What happens if you connect both of this world? What happens if you use a defi protocol and you connect it with a cross chain protocol? What happens if you link an l one defi liquidity pool with stuff that are happening on l two? Another way of looking at it is the following. Right? Now, when you think about defi on l two, what most protocols do is just clone their application on another layer.
00:08:28.998 - 00:09:27.568, Speaker A: You have a landing pool on l one, and you just instantiate the same landing pool on l two, meaning what you're doing is just fragmenting liquidity. And usually you will have one pool which is much deeper than the other. And this makes it really hard for the second pool to live because users have no incentive to pull in that pool, even though the other one is much harder to use and much more expensive because it lives on l one. Defi pooling is really about not cloning your application, but extending it, adding extra functionality on l two instead of duplicating functionalities. Okay? And that gives you a lot of power, because now you're able to get the best of both worlds. You're able to give to your users experience that is much cheaper, much faster. It's l two, right? And much better.
00:09:27.568 - 00:10:10.896, Speaker A: Ux. With changes such as Starknet, you get to leverage account abstraction, which enable experiences for users that are far better than whatever you could imagine on top of Ethereum. And you also get the best of l one, liquidity. You have a much, much, much bigger pool of a pool of pools. There's much more applications living on l one than living on l two. These pools are generally much, much deeper, so liquidity is more efficient, and you also get best security because it lives on Ethereum, it doesn't live on another chain. So let's see examples of what Defi pooling is.
00:10:10.896 - 00:10:48.834, Speaker A: And what I want you to come up with is not necessarily those two use cases. These are interesting use cases I want you to come home with knowing that extending your protocol to l two is a very powerful way to give access to your protocol. If you have an l one protocol, give access to more people. And if you don't have a protocol, it's a way to provide access to existing liquidity pools on l one with much better ux. So let's look at the case study. The first one would be batching user actions. The issue, one of the big issues with Defi on l one right now is that it's expensive to do transactions on l one.
00:10:48.834 - 00:11:49.946, Speaker A: So it may not make sense to deposit money in, say, a curve pool if you have only $10 or $20 of liquidity. So what do you do then? Do you just do it on another chain? Well, one way to do it with l two would be the following. On l two, you gather users, they will deposit money on your protocol on l two. So they will deposit, say, USD on your protocol on l two. Every now and then you will get a message moving from l two to l one that will at that point, actually move the funds on l one. So if you have 100 people doing transactions very cheaply on l two, at some point the l two protocol will send a message and just move everybody's money in one transaction to l one. That sounds simple.
00:11:49.946 - 00:12:36.576, Speaker A: That's because it is. That's what yearn is doing. But directly on l one now you get to do it on l two. The cool thing about this thing too is that if you build your protocol in a smart way, you can actually tokenize the like, say for example, let's imagine with the aave lending pool, if you're depositing USD and you get AUSD, you can actually give them a USD on l two, and they get to exchange it with the AUSD equivalent, which is on l one. So what you're doing with that really is just tapping into l one liquidity and using l two user experience. There's not much more to it, right? It looks simple. That's because it is.
00:12:36.576 - 00:13:17.640, Speaker A: There's a lot of things to do with that. Another interesting example I like to take is using Starknet for Dao treasury management. Right now, most daos that live on l one, I have a very big problem with the engagement of people. Voting is very expensive on l one, so most people don't vote, so you don't get a lot of participation in your dao. The other solution is to use something like snapshot, which is great. Snapshot is a wonderful system, but it doesn't have teeth. It's just signaling.
00:13:17.640 - 00:14:22.674, Speaker A: It's entirely off chain. So you rely on snapshot to collect voters intention, and then a multisig is tasked with enforcing those decisions. Well, here you could imagine having a system where you get the best of both worlds again, and you have your governance on l two and your liquidity on l one. So you get your brain on l two and your muscle on l one because, yeah, we didn't talk about the other side of that. What happens if your dao fully lives on l two? Then you get people to vote for not a lot of money, but then liquidity pools are not great, or they're shifting more. So your assets are way less efficient. So what you can do in that case is basically have a set of smart contracts on l two where people vote, take decision on capital allocation, and you pull their results, you count their votes, and you reach a decision.
00:14:22.674 - 00:14:53.596, Speaker A: And what's that? Decision is reach. You send a message. The smart contract will send a message to l one that will execute some action. You can actually use ready made tools for that. If you use a multisig contract and you just connect it with l two, it can take instructions from l two and just execute them on l one. You don't have to change a lot of stuff for it to be efficient. I want to mention that those two use cases are not something I just made up.
00:14:53.596 - 00:16:36.484, Speaker A: There are smart people already, smarter people than me, working on this thing. Snapshot, which I mentioned is working on Snapshot X, which is actually even more involved than what I just described. They're working on the system to collect all the user votes off chain the signatures that you're currently doing with Snapshot, count them as is in a smart contract on Stacknet, and then use these discount to send a message to l one, and execute and enforce decisions on l one. And the part about depositing batching user funds on l two and then sending instructions on l one, you have aave making experiments around that, you have maker who are doing experiments around that, and a lot more people. Something that is also really interesting that I want to mention is that right now, if you're an l one project and you want to bridge your token to l two, oftentimes you have to go through a specific bridge, register your token, and then you don't have a lot of flexibility of how your token will behave on l two, maybe it's a standard contract that is deployed for you on l two. This kind of stuff, messaging bridges and having a tight connection to l one allow you to design your own bridge and to actually operate your token and your bridge token exactly the way you want. So maker, for example, is operating their own bridge, their own stocknet bridge, and they're fully in control of the representation of their token on l two.
00:16:36.484 - 00:17:24.214, Speaker A: All right, and that's about what I wanted to present. So there you go. So, to sum up what I discussed, defi pooling is essentially a new primitive you can use. In Defi, it's about not just using input that comes from l one interaction, but using input that come from l two interactions. This is something that wasn't possible before, because up until then, whatever was coming from outside the chain was trusted. You relied on validators, you relied on people signing information, and they had control over your protocol. Now, with validity proof, you can do this in a fully non trusted way.
00:17:24.214 - 00:18:11.274, Speaker A: It's a really exciting primitive because it allows you to do a bunch of stuff, but one of them being to expand your user base. Right now, DeFi is very hard to use. Blockchains in general are very hard to use, but l two s are a bit easier to use, so you get to have more users for your l one application, all the while having more efficient liquidity. I also want to mention that this is very much an unexplored territory. There are a lot of things to build using this messaging bridge. Some people are really into it, but you should be too. Like you're very welcome to come and experiment.
00:18:11.274 - 00:18:55.154, Speaker A: I'm going to be doing a workshop later for ETH Prague, where I'm actually going to take you through how to deploy your own bridge, going to explain to you how to write the solidity part to receive input from l one, from l two, and I'm going to teach you how to write the l two part that receives input from l one, and how you can get started experimenting with that. It's also something that can be very useful for you to experiment during a hackathon. So yeah, come to this workshop if you're interested in making this work. We also have a booth down the hall and come say hi. We'll be happy to help you out. Are there any questions? Yes.
00:18:58.774 - 00:19:16.372, Speaker B: Thanks for the chat. It's a very interesting topic. One of the field, arguably most important we need is liquidity debts for amms. That's where the industry desperately needs. But I fail to see how this could work with your aggregating.
00:19:16.548 - 00:19:53.314, Speaker A: You're right, amms are a more complicated topic. The system I described works well for. It works really well for lending. For amms it's more complicated. So I'll say it this way, this is a nut that hasn't been cracked yet. There's no reason why it can't. So I think there's, you can imagine a lot of different ways you can do that, and I don't know what's the right recipe, but at least here I don't know.
00:19:53.314 - 00:20:02.594, Speaker A: I don't have a good design for that, but it's definitely an interesting, an interesting area of experimentation. Yes.
00:20:05.774 - 00:20:32.578, Speaker C: Hi, I wanted to ask about the, so the messaging layer and the, the storage proofs part. That's fine. I was just curious about the defi pooling part on the l one. How is this pooling happening? Actually, on a smart contract level, are there any implementations that are like, you feel like are similar direction one should be looking at to explore how these, how the defi. What is Defi pooling on a smart contract? What does it look like on a smart contract?
00:20:32.626 - 00:20:34.854, Speaker A: What is defi pooling on l one?
00:20:35.194 - 00:20:39.572, Speaker C: What sort of ways of doing it that can be efficient for this use case?
00:20:39.628 - 00:21:43.508, Speaker A: Yeah, sure. So for example, taking back the example I took of batching user deposits, you would have an l one contract that is able to hold assets, right? When l two users send USD to the l two defi pooling, then the l two defi pooling at some point will withdraw money from starknet, and it will withdraw money to the defi pooling counterpart on l one. So now, that defi pooling contract on l one will hold these funds and will be programmed to deposit those funds and put them to work in any kind of pool. So it's about, you have contracts on both sides, and it's just about like, think about it, kind of like yearn in a way. You have a factory or you have a contract that is able to move money around. It receives specific inputs from time to time, but instead of receiving these inputs directly from l one, it receives them from l two. Does that make more sense? Kind of.
00:21:43.508 - 00:21:46.944, Speaker A: Okay, any questions?
00:21:51.084 - 00:22:17.130, Speaker D: Thank you for the talk. So, I wonder, as far as I understand, correct me if I'm wrong, that in this roll up space, starkware is kind of special because it doesn't strive for EVM compatibility, whereas other projects want to be as compatible as closely as possible. How does this distinction correlate with the issue that you've described? So, pooling, is it easier if you're EVM compatible or not, or is it just an orthogonal metric that doesn't have any influence here?
00:22:17.322 - 00:22:35.484, Speaker A: That's a good question, and I don't know about that. I think it's still very much early, and I would be very interested in talking with teams who are taking this approach, either on zkvms or on ZkVM, and to get their insights on that. So, yeah, I don't know.
00:22:43.424 - 00:23:02.066, Speaker E: Hello, I wanted to ask if there is any latency between the layers. I mean, how do the layer two users know that the state of the blockchain they are experiencing is the same as is on the l one, and it did not change since the last update.
00:23:02.250 - 00:23:50.704, Speaker A: Okay, your question is about latency, is that correct? Yeah, yeah, yeah. So messages move from l two to l one at a specific pace. So l two to l one messages move every few hours? L one to l two messages are move every few minutes. Now, how are users aware of this? That's up to you. That is how you design your application. Do you want to give them an instant token that has value, or are you going to put this in a pool and then transfer them token later on? It's really up to the app developers to give visibility on that or to abstract it away. But it's kind of like, again, like applications like yearn, who pull user deposit to then deposit later on, or Lido, for example.
00:23:50.704 - 00:23:57.700, Speaker A: This is very much about how you define your application. It's not necessarily a technical issue. Does that make sense?
00:23:57.852 - 00:24:03.264, Speaker E: Okay, thank you. Any more questions?
00:24:05.004 - 00:24:35.710, Speaker A: Here's an. I'm thinking now about yearn here's another fun thing that was done by yearn. Actually, it's an experimentation. But you, you know that yearn has these concepts of strategies where depending on the best way you allocate liquidity, they will change the parameters of where they allocate liquidity. Right. All of that calculation is done off chain and then a multi SIG will say, yes, this is the best strategy and they will implement it on chain. In other words, yearn strategy relies on multisigs.
00:24:35.710 - 00:25:07.506, Speaker A: They recently did an experimentation where they wrote the best strategy allocation algorithm in Cairo and they proved that this strategy is the best one. And then they used that output to change the result on chain. So they used provable code and validity roll ups to make their system safer. Anyway, just the fun stuff. Also, you can experiment with validity rollups. All right, I think I'm done with my presentation. Thank you for listening to me.
00:25:07.506 - 00:25:08.834, Speaker A: Don't list it and come ask questions.
