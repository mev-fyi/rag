00:00:12.240 - 00:00:39.874, Speaker A: Okay. Hi. Hi, everybody. My name is Wei Jie and my colleague Andrea from geometry. How's everything good with the video? Oh, it's on. Are we good? Testing. Okay, testing, one, two, three.
00:00:39.874 - 00:01:18.924, Speaker A: Okay. Hi, thanks so much for coming. My name is Wei J. That's Andrea from my colleague Andrea. We are both from geometry. And just a brief background is that we are, we are vc invested in startups that are deep into cryptography and mathematics, and we are on a research team. And this is our latest project called Semacock, which is something that we built to address a problem that we see in the EVM and web three space is that in many privacy applications we see today, we have to choose two out of three of these things.
00:01:18.924 - 00:02:10.188, Speaker A: So just a bit of a correction here. It should say low cost in many applications where you want to insert an identity on chain so that you can prove membership of your identity without revealing which one you are. Later on, you have to choose two out of three. So, for example, if you choose to have low cost deposits but high privacy, you are going to trade off proof of efficiency, which means that you are going to take a long time to generate proofs. The second option is that let's say you want high privacy and you want to have decent proof of efficiency. What is going to happen is that you're going to be using ZK friendly hash functions. But if you use ZK friendly hash functions, you have to pay a lot of high gas fee at the start when you deposit your identity.
00:02:10.188 - 00:03:06.564, Speaker A: And that's because the ZK friendly hash functions cause a lot of gas. You need to do it every time you perform a hash to compute a mercury route. And that's why it's expensive. And the third option is if you have low cost deposits and if your prover time is sufficient, what's going to happen is that some applications outsource the proof generation to a third party centralized server, and that means that you lose privacy. And in certain applications that's not acceptable. So what do we do with Semacock? So with Semacrock is a gas efficient ZK protocol for SAP membership. And the key benefit that SemacoQ brings is that inserting identities to your on chain accumulator is 90% cheaper compared to using traditional techniques of mercurys on chain.
00:03:06.564 - 00:04:19.478, Speaker A: The gas cost is 68,000 per insertion. Proving time is competitive with ZK graph 16 proofs on chain, and it's very similar to semaphore, which uses mercury trees, except that the gas cost is cheaper. So the first benefit is lower gas cost. Second benefit is that with semiconductor we use advancements and lookup arguments such that you can perform precomputation of proof data. And if you combine that precomputation with private information retriever, you can get better ux for users because the bulk of the proof generation could be done ahead of time or in the background of a client application. And if you choose to use PIR to privately retrieve proof information from a third party server, that can be done without revealing which member of the set you are. And lastly, another benefit of Semacalc is that we don't need a new trusted setup for every circuit or every instance of semcock that you have.
00:04:19.478 - 00:05:00.654, Speaker A: You can just use a phase one trusted setup output which already exists for Ethereum. Okay, so back to basics about what exactly is proof. So let's take a really simple example where Alice, Alice knows secret numbers one two and three four, and Bob knows his secret numbers five six and seven eight. The public leave or identity commitment that Alice owns is a hash of the, is a hash of the values that she owns and the public leave that Bob has. It is the hash of 5678. There's a bit of an error here. It should be one Atlas knows one two and three four.
00:05:00.654 - 00:06:29.806, Speaker A: So we want Alice to be able to prove that she knows her secret numbers one two and three four without revealing that she owns index zero, which is the first element of the set. So with summer four and summercop, this is, you can do this using ZK proofs. The key figures behind this is that with Thermocoup 6000 8000 gas, when you produce a proof, it takes roughly 15 to 20 seconds in total on a slow laptop. It could be faster on modern hardware and proof verification in semiconductor, 300 to 5000 gas. And this is regardless of the capacity of the set, the lower bound for semiconductor is 1024 and upper bound is the limit set by the trusted setup output to the power of 28. And so traditionally, and before I go into the details of how we do, before we go into details how we achieve this, I'm just going to give a bit of a brief refresher on how existing approaches use mocker trees to accumulate these leaves. So we have this, we have function on chain that computes a mercury root, and this involves computing multiple hashes.
00:06:29.806 - 00:07:06.688, Speaker A: So each node is a hash of the two nodes below it, and you hash it up to the, to the top of the, to the Merkur root. And because if applications like semaphore, you use zk friendly hash functions like Mims C or poseidon. Each hash is around 20,000 to 28,000 guests. Multiply that by the depth of the tree you get. You have to pay like a million guests to deposit, if your capacity of the set is 1 million, for example. But with Samlcog, we use a different technique and let's, I give the floor to angel.
00:07:06.776 - 00:08:30.864, Speaker B: Yeah, so I'll speak roughly about how we achieve this and which techniques we needed to use. So, first natural approach to changing the merkle trees is like with KCG commitments. And those commitments are very good and used widely today, as I guess all of you might heard for them. So you have very nice properties of like additive homomorphicity, and you can compute lot of stuff directly on commitments. So we are using like Ethereum friendly curve BN 254, and this will allow us to very efficiently update the vector that we store in the chain. So now, instead of having the whole very deep merkle tree, which Rayjay was explaining, you have just this one vector of commitments that you need to update, and you can do it very efficiently with just a few elliptic curve operations, which gets very cheap because you don't have to do any hashing or no repeated work. The only problem is that since we want these vectors to be very large, like two to the 20, even two to the 30, you cannot store this Lagrange basis commitments in the contract.
00:08:30.864 - 00:09:52.258, Speaker B: It's very expensive and you need to have the access of them in order to compute to derive next commitment. And here, maybe if you just look at the documentation or code, it can be confusing that we actually have some Merkel tree, but that's just catch a Merkel tree, which allow whoever inserts the identity to prove that they're using correct Lagrange basis. And we don't need to store those elliptic curve points in the contract, which again makes this very very cheap, like 68k gas instead of 1 million and something for depth, two to the 20. And this is like a constant. So even if you go to the larger group, it still stays the constant. So I'm not gonna go very deep into how this math works, but you just have some default zero value of your position in the vector, and you can very easily update it with all these additive homomorphic things, which is again very cheap in the contract. And now, what is the difference between this, the most useful and maybe the most broadly used application semaphore? So the whole idea of ours was not to change a single thing in the semaphore API.
00:09:52.258 - 00:10:32.184, Speaker B: So however you used your application, now it stays the same if you switch to using semaculk. There is no new values. Everything stays the same, but the machinery underneath is totally changed. And it's based on a few techniques that we modified and optimized a little bit. So, first of all, we used mimchash. And today the most popular hash is Poseidon. And it was just because, like Mimsy was easier to do with what we wanted with just some small engineering effort.
00:10:32.184 - 00:11:20.376, Speaker B: You can switch to Poseidon if you are considered about Mimsy security or something like that. And three main techniques that we are using are calc lookup arguments. That's the new work, which is very popular and very useful from the set of these lookup argument papers. Why is it important? It gives us zero knowledge. And we had to change it a little bit on the IOP level in order to make it compatible with our custom prover. So our custom prover is based on similar techniques that you see in Planck with all the Lagrange basis. And the IOP is very similar, but it's very customized to just proving this Mim C round hashes.
00:11:20.376 - 00:12:02.324, Speaker B: And you don't need the whole planck machinery as lookups or a permutation argument. So you just have a few polynomials that you need to prove. And that's why it also makes it very fast. And then it's compatible with the Colc modification that we did. And finally, as you might know, the Grot 16 is still very popular because its very far is very cheap in the contract. And to be honest, it was very hard to beat the Grot 16 verifier in gas cost. Like, just by counting the pairings, it seemed that our approach will be much more expensive.
00:12:02.324 - 00:13:25.464, Speaker B: We took this halo two multi open argument, which is similar to splanck, and we also modified it a little bit and precomputed some stuff. And then we finally were able to, even with more pairings, to get to the same cost as gross 16 verifier. So now when you look at the cost, we save like more than million guests just on the insertion part, which I think is very good result, like more than 90%. Okay, so this calc argument and all this new lookup work is based on this stuff, like when you need to precompute something, and we also have to do that, of course, in order to run this calc. So this precomputation part takes a good amount of work if you want to set up everything, but then your proofs are extremely fast, roughly 50 milliseconds, but probably can be like, it can probably be even less and it's constant. It does not depend on how huge your group size is. Whereas trying to do grot 16 of poseidon to two to the 30 with three of depth 30 can take very long time, whereas here it's just constant after you do this precomputation step.
00:13:25.464 - 00:14:35.368, Speaker B: So I'm not going to go into that precomputation step. It's quite complex what you need to do with polynomials, but what we are enabling users to do, there are two ways how you can use it so you can precompute those stuff and it's not just precomputing once. So once the group gets updated and you want to be on the live set and use the biggest anonymity as possible, you also need to again precompute some stuff in the commitment. And sometimes if you want to have very light client that can also be the problem. Maybe you need to run it secure extension, you need to download some data, you need to store somewhere, you need to make sure that it's secure. Because anyway, if somebody even learns which member you are, even if they don't learn your secret, you're kind of losing privacy and it's breaking the zero knowledge property. So we did something with this new library bliss which enables private information retrieval.
00:14:35.368 - 00:15:19.106, Speaker B: So there is a bunch of techniques based on this vector commitments where you can pre compute a bunch of stuff and update very efficiently on commitment level. So we also provide you with the server which does whole precomputation and updates all the commitments accordingly as like that's the only part in the system which should listen to blockchain events and update stuff. You as a client don't need to care about that. And this server is completely trustless. Like it's just working with commitments and it cannot do anything with your identity maliciously or even find anything about your secret. It's all just public data. And then what you can do.
00:15:19.106 - 00:16:26.934, Speaker B: You have this very nice API that the bliss allows you and we just did a few modifications. So you can have very light client where you can just download all these new data and new quotient polynomials that you need for the proof. And you do it completely privately, so nobody learns nothing about your index even, which also breaks the zero knowledge property. So you can do it very efficiently, it does not affect your proving time. And you have kind of a blobs from which you can download stuff based on how huge group you want to be. And when you put this all just to say again, so I guess that membership proofs are still one of the most used proofs currently and we are able to achieve 90% guess savings even more. We allow like this constant proving time and it's all based on very well known arguments that we just did some modification on.
00:16:26.934 - 00:17:35.284, Speaker B: So yeah, what do we want to do next with this? So it's just now about building applications and adopting the Semaculk, trying to see how it will be in the wild like building tools, building maybe some other use cases but as I said we try to have the same interface so there is nothing new on a use case level, it just good old membership proofs that we're using. Maybe guests can be optimized even more if needed and just building clients around it and maybe some secure extension for keeping secrets and stuff like that. We still haven't audited but that's something that we have in our plan and yeah like you can find all the links, documentation and implementation and if you're interested feel free to reach us. We are very happy to help someone integrate this in their current system and see some good performance optimizations. Thank you very much.
