00:00:00.200 - 00:00:44.854, Speaker A: Hey everyone, thank you all for joining. My name is Nebush. I'm one of the co founders at Tenderly and I'm also the lead for our R and D team. With me is Marco, one of the R and D engineers who's going to help me out with the live demo. Hopefully nothing goes wrong. Today we're going to be talking about ETH debug format for smart contract debugging. So what is ETH debug format? So, a brief history some year and a half ago, after the merge in Bogota Devconnect, we assembled as a group consisting of solidity developers.
00:00:44.854 - 00:02:11.434, Speaker A: Tooling company focused on building debuggers and tooling company focused on building security analysis tools. And we started talking about like what's missing from the tooling perspective and what can we do to make lives of developers easier. And we sat down with the solidity team and we started giving them feedback. Fast forward some year and a half ago, we now have this group that meets usually once every week where we talk about the specification of the format that solidity compiler and hopefully other EVM compilers are going to implement in order for the tooling to get to the next level. So why having a good debugger is important for all the similar reasons for why debugger is important in web two. So all the essential stuff that the developer use it for, such as navigating through the code, understanding how the execution is correlated with the source code, what's going on on the high level, and if an error occurs, it helps them navigate to the bug much easier. On top of that, in web3, the stakes are much higher and the bugs that could occur in production are usually irreversible.
00:02:11.434 - 00:02:52.214, Speaker A: So one aspect of it is of course the security. So whenever you're developing smart contracts, in most cases a lot of funds are going to be stored on them. So you want to make sure that everything is working and that there are no bugs. The second thing is that you're usually interacting with some other third party contracts. Navigating and managing complexity is one of the most important things in the web3. So a good debugger should help with that as well. And of course it enhances your confidence and reliability in your code once you push it to the production.
00:02:52.214 - 00:03:33.194, Speaker A: All of these reasons is why at tenderly, some six years ago we built, one of the first features that we built was a debugger. It sort of helped us solve some of our problems while we were building on hackathons, et cetera. So what are some of the frustration that happened during the debugging. And this is not just for our debugger. This is basically for any debugger, for any VM debugger. So usually we get the incorrect source code for the given instruction. This can happen in a case where solidity source maps don't point to the right line of code.
00:03:33.194 - 00:04:56.694, Speaker A: Other things are misidentified function calls. So what solidity optimizer can do sometimes is when the optimizer sees two blocks of code that are usually identical or almost identical, it's going to use only one of those. So it's hard to navigate, and it's hard for us to showcase which exactly function is called, in that case, error in the coding function parameters. This is something that quite often occurs. It's usually hard for debuggers to pinpoint where the value of some parameter is, is it on stack, is it in memory, is it in storage, et cetera. And this is even harder for some of the more complex structures in solidity or wiper bad or if any, local variable detection, especially when the optimizer is enabled, we are usually unaware of where the variable is unstack, is it a pointer, is it a value? Etcetera? And there are numerous other minor inconsistencies and errors. These are all some of the problems that we hope that e debug format is going to solve.
00:04:56.694 - 00:05:58.954, Speaker A: But so first of all, what's a debugging format? So it helps us make sense of the bytecode that is being executed on the EVM. So we all write codes in the solidity or wiper. Maybe like less than 1% of the people write direct bytecode. But like for the people that write solidity or wiper, we need some way to map instructions to high, high language features such as for example function variables, etcetera. The thing is that when we talked to the folks at solidity, they told us that compiler has most of this necessary information during the compile time, but they don't output it. And so there is a need for these debug format due to the data complexity that exists and various compilers differences. And for all of these reasons, we need the EVM specific debugging standard.
00:05:58.954 - 00:07:19.944, Speaker A: So it won't just be for the solidity, it should, all the EVM languages should apply it, and it should account for the unique aspects of the EVM, such as 256 bit memory locations, gas data storage methods, etcetera. So what's the current state of the debugging today? In short, there is no reliable way to build a debugger. Simply put, the compiler doesn't output sufficient amount of information for us to build a reliable debugger, or even in some cases existing data can often be unreliable or mislead us to thinking it's something it's not. Therefore we deploy some of the heuristics and guesswork. But of course there are certain edge cases where those heuristics or guesswork don't work, simply don't work. This is usually the case when the optimizer is enabled, or where you'll optimizer is enabled. In those cases we simply mislead the developers and we hope that debug format is going to solve most of these problems.
00:07:19.944 - 00:08:02.420, Speaker A: And the last thing is that mapping storage slots to variables is relatively complex. We can do it. It requires much more compute today, but ideally solidity compiler can point us in the right direction of the storage slots. So some of the key problems that this format is aiming to solve. So there are a lot of things, but hopefully with four of these it can solve most of the problems for people building a debugger. So first is type definition. So ideally for every structure, ideally for every type, we should have a structure of it.
00:08:02.420 - 00:09:03.794, Speaker A: We should have name field declarations. And the idea is to have an information on how to detect it, like where it is, is it on stack, is it in memory, is it in storage? For some more complex structures, ideally we would have pointers. So for example, if there is a memory of array of structures, we would have an information of where it is and what's the location, and ideally something that can tell us how to decode it. As you can see, pointers can be anywhere on stack memory storage. Now after transient storage called data return data code, on top of that we would need source locations. So some way of mapping how each instruction on the EVM corresponds to the high level source code. Currently we use source map for these, but it can be quite unreliable, especially in the cases where YOL optimizer is enabled.
00:09:03.794 - 00:10:00.912, Speaker A: And the other thing is what I talked at the beginning. So in certain cases the optimizer is going to de duplicate some of the code segments. Ideally we can have information pointing us to the multiple locations and ideally of course tell us how to determine which one it is. And the last thing is variable decoding. One of the most painful thing I would say to today for someone who is building a debugger is so some way to represent variables visible in the scope. Right now what we do is we basically deploy a bunch of heuristics in order to determine what variables are on stack it's quite hard for us to know if the variable is optimized out, meaning that it's not even used. So ideally debug format should tell us that.
00:10:00.912 - 00:10:47.274, Speaker A: Or what could be even better is a way to reconstruct some of those optimized variables. Now this format is in, we have first draft of the specification. Afterwards we're going to enroll in the implementation phase. So after we have the implementation phase, we're going to be talking like what we could have with better data. So after we do that, we can have 100% accurate co locations. We can decode function, call stack. We can be certain about all the parameters that are inside of the functions, like what's the input, what's the output.
00:10:47.274 - 00:11:34.334, Speaker A: We can have all the variables in the scope. We can know which variables are optimized out, meaning they are not used. We can fully decode memory, we can have 100% accurate storage decoding. We could have evaluate expression without the need of the compiler, or set them to watch variables and of course line by line debugging and so much more. I mentioned at the beginning that we are going to have a quick demo. So this is a very, very early proof of concept that we have built of how the future debugger might look like. On to marco for the demo.
00:11:34.994 - 00:12:12.014, Speaker B: Yeah, hi everyone. I'm going to show a small demo of what we could have in the future, and hopefully it works. Let's see. So here I have a basic erc 20 token implemented. So I'm going to try to run a function in the debugger, and it's going to be a pretty basic function that just means some tokens in a weird way. So let's go through it. First we are going to be prompted to enter the parameters of the function, which are some x and y coordinates, and then we are going to start debugging.
00:12:12.014 - 00:13:06.004, Speaker B: And the first thing that we can do is actually find the function. It's this one, fish for tokens and select where do we want to start debugging from? And let's hit a breakpoint there. Then we can hit continue and hopefully we do stop at the point. Currently this is pretty hard to do without source locations provided by the new format since there is a lot of instructions that are jumping around. You can't really create trace points anywhere, so you need some logical ways to stop the code. But in the future we could possibly map every instruction there is and just have a line by line debugger. So currently what you can see here is just the stack on the top.
00:13:06.004 - 00:13:33.590, Speaker B: I have some heuristics parsing the local variables. You can see the inputted x and y values. Yeah, I actually inputted them in decimal, but they're showing up as hex values. Whatever. They are the same, trust me. And you can see the local variable, today's maximum, that has been calculated. We can turn on the instruction history, we can see which instructions were on.
00:13:33.590 - 00:14:25.188, Speaker B: With some additional information that can be useful to us. We can maybe do some, let's say, watched expressions. If I put in something like x plus five, we should be able to evaluate that expression. We should be able to do that with local variables. So I'm going to add something like today's maximum plus one and hopefully it does evaluate. We can maybe try to evaluate the weekday which is currently not in scope since we are not on that line yet. So the evaluator can't do it.
00:14:25.188 - 00:15:14.402, Speaker B: But if we go a couple of instructions forward, let's go jump instruction by instruction, or maybe just skip to the next line. And next one we have the weekday, which is in this case two, it's calculated in some way. It's like days after starting modded by seven. And the days after start is calculated like in a standard way. You can see there on the line 41 where we actually broke the or created a breakpoint. Some other interesting stuff that we can do, that we can't really do now is Debug Yule. I'm going to turn on Yule debugging and let's cycle instructions until we hit some Yul code.
00:15:14.402 - 00:16:00.984, Speaker B: Here we have if anybody saw utilities, you all. Did anyone actually see this file before utilityz? No one. It's a file that solidity generates itself actually, and it has like some crazy named functions you can see like function name that is long like over 128 characters and stuff like that. So yeah, the solidity generates actually this helper file that we can now debug. We could also debug any Yule file that you write to yourself. Like Yule is a low level assembly language or an intermediary language. Not many people use it, but maybe we could create a debugger for it if needed.
00:16:00.984 - 00:17:09.704, Speaker B: But currently it is pretty hard to do without the debug format since we are missing a lot of information that would allow us to do stuff like this. Okay, let's run off Yule debugging. So we saw that we have evaluating expressions, we have breakpoints. Why not combine those two and have conditional breakpoints? I'm gonna hit like conditional breakpoint on line 49. So I added a conditional that if x local variable is greater than three, which it is, and if we hit continue, we should hit that breakpoint and we actually do that. Another thing that we could do reliably is the decoding of 1 second. We could do the decoding of function stack.
00:17:09.704 - 00:18:08.734, Speaker B: Let's try to get that. So yeah, we are currently in the function context of the fish for tokens function, but if we go into the next line, we are going to prepare the parameters and we are going to jump into the distance function, and you can see the function stack has been, let's say reliably created. We can do that currently, but it's not completely reliable with the source map because we often get some inlining or some de duplication that often messes this up. And you can get really, really weird function stacks from the current source maps. But yeah, so even if we enter the ul, we can actually see the called ul function. And that's pretty useful I would guess. Also I think that very, in my opinion useful is like this stack annotating.
00:18:08.734 - 00:19:00.794, Speaker B: You can inspect the stack and see which value is what. These gray ones are not really that useful. Anything that's colored in is probably some useful information. I color coded local variables to be blue, and you can see the third or the second value on the stack is currently calculated as x plus 256. This could be actually pretty useful. If you have some values that you don't know the origin of, you can just check and go to the point where you are interested in the value of the storage slot or sorry, stack slot, and then just check the expression that actually calculated it. And it's actually pretty easy to do once you have reliable source map.
00:19:00.794 - 00:19:35.584, Speaker B: Pretty easy create. To create things like this, you just remember a tree of expressions. Like every arithmetic operation, you just track and construct a tree and just show it there in some representation. But yeah, we can also check out the memory. Let's turn off these and turn on the memory. This program doesn't actually use human readable memory. It usually uses it to generate random numbers.
00:19:35.584 - 00:20:34.870, Speaker B: You can see the function down there that uses the ABI encode pact and ABI encode pact just dumps everything into memory so it can be hashed and so you can see those values there. If it were some values that we could actually read like humans, it would be useful. But in this example it's not really that great. The place like the memory on the left is actually just bytes, and on the right you have the escape ASCII representations, if they actually mean anything. But yeah, so generally you could debug stuff like this, and I'm just gonna go through until we hit some of the inherited functions from the code in GRC 20 token. And you can see here on the stack, everything is prepared. You can see how many tokens you fished.
00:20:34.870 - 00:21:06.404, Speaker B: It's two tokens that's going to get minted. You can see who is the caller who's going to actually receive the tokens, and you can track the history of the values through the stack and see how they were generated. So yeah, I think this could be improved upon a lot, but for now it's not. I just let it run instruction by instruction with some pause and we hit at the end and that's it. I'm going to let Nabush continue.
00:21:07.944 - 00:22:04.102, Speaker A: Yeah. Thank you, Marco. Now we see how the things could look like after the debug format is implemented. But what's going to happen beyond? What are some of the benefits of it? Of course, we're going to see improved debugging efficiency, which is going to result in more productivity for the web3 developer, which is going to result in more applications and more users coming to the web3 and trying things out. Of course, this format is supposed to be cross language, so we could see some very interesting cross language tooling come out. And it's much easier for us as we would have to adopt just the one debug format and not for each language implementation debugger. For the security analysis tooling, it's going to of course enhance it.
00:22:04.102 - 00:23:11.094, Speaker A: There's so much more data that these analysis tool can now work with. It's going to be much easier for the developers in the web two ecosystem to join in the web3, because they're accustomed to having a full debugger and not like some quasi implementation of it. And with the rise of the AI and llMs, and with the amount of data that we can now finally extract and have it visible from the on chain execution, we can train these models and hopefully catch some of the vulnerabilities or potential attacks before they even occur. Of course, all of this wouldn't be possible without people coming and contributing to this debug format. So if you're looking to contribute, or if you have some idea, or if you just want to brainstorm, go to the edebug GitHub format. We post all of the updates there. Currently, as mentioned, we have draft implementation of the specification, and if you have any feedback on it, please let us know.
00:23:11.094 - 00:23:13.414, Speaker A: That's it. Thank you.
00:23:14.914 - 00:23:20.226, Speaker B: Thank you so much. Thank you so much.
00:23:20.250 - 00:23:23.774, Speaker A: Guys. Are there any questions? We have time for two questions.
00:23:28.154 - 00:23:49.374, Speaker C: Can we add any data for it? For example, like you have tested this contract against a local node maybe can I use against Mainnet data? Like can I check and upgrade against my mainnet data currently? So what are the changes of my storage stack storage there?
00:23:49.794 - 00:24:06.234, Speaker A: Yeah, sure. That would be one of the improvement that we could add with the debug format. Definitely. Basically anything in the execution layer that is relevant to the high level programming language, we would be able to decode it.
