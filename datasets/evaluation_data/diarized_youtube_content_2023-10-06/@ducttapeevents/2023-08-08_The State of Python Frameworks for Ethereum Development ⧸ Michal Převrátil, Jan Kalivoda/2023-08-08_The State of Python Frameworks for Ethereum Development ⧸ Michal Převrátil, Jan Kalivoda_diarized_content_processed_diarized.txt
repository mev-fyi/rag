00:00:00.840 - 00:00:01.328, Speaker A: Cool.
00:00:01.398 - 00:00:12.474, Speaker B: So hello everyone, welcome to our presentation the state of Python frameworks for Ethereum development. My name is Ean and I'm ateroum, tech lead at a key blockchain.
00:00:13.214 - 00:00:25.474, Speaker A: Hi everyone, my name is Timik Habsevrato and I'm the lead developer of security tooling for Ethereum at Ekiblockchain, where I develop two main tools, poke and tools for Solidi. We will talk about both of them later in the presentation.
00:00:26.114 - 00:01:09.364, Speaker B: Cool. So what we are doing, we are doing smart audits and also developing some open source security tools. And of that we are also onboarding developers to blockchain via online courses or teaching at a local university. So the first section there is also we work with. So we work already with one inch XLR or safe formal ignosis and some of the last audited projects. What we had. Is there anyone who knows Solaide? Okay, nevermind, I will tell it to vectorized.
00:01:09.364 - 00:01:45.196, Speaker B: It's an alternative to open the plane or soulmate. There are gas optimized solidity snippets, so you should definitely check it out. It's some nice piece of code. So the first section is Python and ethereum itself. So I will start with Python. So why we are talking about Python? Why we are not talking about JavaScript or rust? It's still the number one language across many leaderboards and it's used across a lot of tech industries. And still it is easy to read.
00:01:45.196 - 00:02:40.688, Speaker B: And if we are talking about solid testing, it doesn't bother you by typing async await like JavaScript or you don't need to cast addresses to interfaces like for the solidity test. So it is pleasure to write. And the last notable thing that Vitalik loves it. So what are the verticals in blockchain development in Python? We have there some core blockchain and node software like the EVM implementation in Python called PI EVM. Then we have some pythonic languages for smart contract development like Wiper or integration libraries like the competitor of Webfree JS called Webfree Py. Then there is a big section about smart contract development frameworks. We will talk about that more later.
00:02:40.688 - 00:03:29.224, Speaker B: And that a lot of security and auditing tools like Slitter. And the last notable thing is a repository called Python execution specs. If you want to educate about EVM, this is now probably the best way to do it because yellow paper is in some way outdated. So there are some protocols, you maybe know them, curve finance, badgerdao. They started developing in brownie framework and some of them move to the ape framework, but still they are using Python and Viper, most of them. And there is also a big community around the Python and Ethereum on Discord. And Viper has also its own discord.
00:03:29.224 - 00:04:26.770, Speaker B: So if we will check the timeline, we are somewhere in 216, when web three Python was founded, and then it was followed by Slitter and first Python framework. First its release was in 219, then there was founded Wiper, and after that was released to another frameworks, Ape and wo. This year we got some new tooling, and it's a symbolic execution tool called Hallmoss, and it's from a 16 z. So in this talk we will focus on these three frameworks, we will compare them, check their advantages, disadvantages, and we'll see. So I start with brownie. Just a quick introduction. It was the first alternative to JavaScript frameworks.
00:04:26.770 - 00:05:32.794, Speaker B: So if you don't like JavaScript and still want to develop on Ethereum, this was your first time into 18 when you could start to choose anything else. And it has contract testing, we have PI test and hypothesis property based testing. It's just derived from the Python native libraries, and it has also support for VYPR. Unfortunately this framework is no longer actively maintained. It has a lot of open issues and also bugs related to them. So there comes the second framework, and guys from the ape works are onboarding the users of a brownie. The project is heavily inspired by Brownie, but it introduces some new features, like their so called modular plugin system, where you have a core framework and you can just use some other plugins like plugin with VYPR to get the supper for VYPR and so on.
00:05:32.794 - 00:05:46.330, Speaker B: And this framework is actively developed by Ape works. And the third framework that we will be talking about is Vogue. And I will give a word to main Vogue developer.
00:05:46.522 - 00:06:31.084, Speaker A: Thank you. Thank you so much, Jan. So first of all, the name Vogue does not, it's not connected to the movement. You just got the name package first and then yeah, so it's not connected to the movement. And Vogue is in house tool built by a key blockchain. I'm the lead developer, and so my opinions might be a little biased, but still the name is Vogue, and first it was static analysis tool and the language server. So when you launched your versus code, installed an extension called tools for solidity, then Vogue got installed in the background, and basically all the requests like go to definition, find all references and things like that, rename symbol and so on went through Vogue.
00:06:31.084 - 00:07:14.540, Speaker A: So Vogue was the backend, and the Instagram for versus code was just a front end that communicated with woke. And also, as I said, it was originally a static analysis tool. So we got some kind of vulnerability detectors. This can detect common vulnerabilities like reenterncy or unsafe service tract and things like that. As I said, we have an extension for versus code. And except from the static analysis and language server, Wok is also a development and testing tool. So you can basically write your testing scripts, your deployment scripts, Python, and execute them through vogue.
00:07:14.540 - 00:08:08.246, Speaker A: What's different from the other testing frameworks that we have introduced is that VoC has something called py types. And basically when you have your project, which is in solidity, because VoC supports only solidity, then you can compile the project, and then we generate Py types, which is like the equivalent of the solid project, but in Python. So for each contract we have a class in Python. For each struct, error or event, we have also a data class in Python. And when you interact with these classes or data classes in Python, you basically interact with the contracts on chains and also has integrated Fuzzer, so you don't need to use, for example, hypothesis with brownie. We have some kind of already integrated fuzzer, which also has some kind of advantages. Now let's compare all the free testing frameworks that we've introduced by performance and then by user experience.
00:08:08.246 - 00:08:47.422, Speaker A: Let's start with the performance. So what we did is that we took uniswap v three core repository that already contains tests written in JavaScript, in ethersjs and hardhat, and we have migrated or rewritten the test into all the free testing frameworks. And then we measured 271 tests, multiple times taken, average. And these are the results. And as you can see, Vogue is quite fast, especially with anvil. We used some kind of cheat codes that anvil offers. So we can be really fast because we, for example, don't sign transactions unless the user wants to.
00:08:47.422 - 00:09:20.820, Speaker A: So we use some kind of cheat codes, but still, ganache doesn't have these cheat codes. And we are like, I would say, quite fast when compared to the other testing frameworks. So it's not only about cheat codes, but it's also about the architecture. For example, we decided not to use web three Py, which is like big library in Python because of the performance reasons. So yeah, we also created an academic paper with the measurements and submitted it to a conference. Now let's talk about user experience. I have a few examples here.
00:09:20.820 - 00:10:00.908, Speaker A: The first one is about cross chain testing or multi chain testing. And basically this is how it looks like in amp. In Brownie we don't have a native support. We have checked the documentation multiple times, even the GitHub repository, but there's no native support. So basically you can probably connect to some kind of network and then disconnect connect to another one, but still there's no native support. And basically in ape you have to switch between an active network. You can have multiple networks, but you have to always switch the network when you want to deploy a new contract or interact with a contract on a different network and then invoke.
00:10:00.908 - 00:10:57.592, Speaker A: We took quite a different approach and we decided to build the architecture from the very beginning in this way, so that when you deploy a contract, then you may specify a chain. A chain is basically the same as a network in ape, and when you specify a chain, then the contract is already bound to the chain. So when you interact with the contract, you don't need to switch any chain or network. Basically the contract remembers the chain that was deployed to, so you don't need to switch the chains. And you can normally interact with your contract and contracts and everything works quite fine. And you can have basically as many chains as you want. The second example is a representation of data, because you basically want to interact with some kind of contracts with structs that are inside the contracts, the events errors, and it's quite important to know how to interact with them and if it's user friendly or not.
00:10:57.592 - 00:11:35.706, Speaker A: So we have an example how we work with events in Ape, Brownie and vogue. So basically you decode some kind of transfer event in ape. Then you make assertions when you can use properties or the dictionary like style. In Brownie, you basically have only the dictionary style. And well, you can have multiple events with the same name transfer. So Brownie doesn't really care about some kind of special cases, I would say. So for example, when you have a contract or two contracts with the same name in the same project, then Brownie won't compile the project because you have to contract with the same name.
00:11:35.706 - 00:12:14.732, Speaker A: Brownie doesn't often care about d cases. And the third approach is invoke. And as I said, vogue has something called py types. So for example here that IRC 20 minimal is a class in Python, and the transfer is a data class, which basically looks like this. If you can see that it's a data class. And what you do is that you create an instance of the data class and then you can make an assertion that this, this instance exists in TX events. What's really nice when you have these py types is that when you are writing the script.
00:12:14.732 - 00:13:02.634, Speaker A: You have type hints because you have this structure already regenerated in a directory. And also you have type checking. So for example, if we have used to is equal to pool instead of pool address, then the integrated environment would highlight the line because you have different types compared. So type hinting and type checking thanks to PI types. Also, one more interesting thing is maybe you have noticed that the event transfer has some kind of original name and the from field, it's not from, it's from underscore. And that's because from is a reserved keyword in Python, so we cannot use from. But you have some kind of metadata here.
00:13:02.634 - 00:13:40.082, Speaker A: And the reason for that is that we support AIP 712, aka structured data signing. So when you have this pre generated data classes, you can sign those directly. In python you don't need to generate some kind of JSon and then sign the JSon. Like in other testing frameworks, you basically can sign directly the data class, which is quite nice. Another example is rewards. So let's say that we want to make an assertion that a special transaction rewards with an underflow error. And this is how you would look, how you would do that in ape, Brownie and Vogue.
00:13:40.082 - 00:14:12.522, Speaker A: As far as we know, there's not a better solution in a capsule. Okay, so yeah, you probably have to use this big number. It's not very nice, but it is what it is. The second approach in Brownie is that you use some kind of constant like integer overflow. But as you can see, there's counter decrements. So there's probably an underflow, not an overflow, but the error message is hard coded. And yeah, it's integer overflow.
00:14:12.522 - 00:14:40.380, Speaker A: And the third invoke, well, like these panic errors are well documented. So we have an enum for this. And there are all the panic reasons. So we have enum for these panic errors. Now let's talk about code coverage. Brownie and Vogue have code coverage support. As far as we know, ape doesn't have it, but it feels like the ape documentation is bit incomplete.
00:14:40.380 - 00:15:21.728, Speaker A: So maybe there's code coverage, but as far as we know, we have not found it. And invoke we have an integration for versus code. So basically we can show the code coverage in versus code. And what's really nice is I have told you about the integrated fuzzer, is that when you fast your contracts, you can get your code coverage updated after like every 5 seconds. So you can see in the versus code how the branches of the code are executed or not executed by your fuzzer which is quite useful, I would say. And Browning has a custom user interface, and this is how it looks like in vogue. So we have versus code and we have some highlighted statements.
00:15:21.728 - 00:16:09.110, Speaker A: When you have exact number of executions for each statement, then you have a percentage, which is always relative to the function body or in case of function name, it's relative to all the function names in the project. And this is basically how it looks like in the custom UI in Brownie. Okay, and I have two examples here. As Jan already said, we have audited Slidey recently, and these examples basically come from the slide audit. The first one is about miracle proofs. And what's really nice, I would say, is that like when you want to verify or test a contract that verifies micro proofs, then you need to generate the Merkel proofs first. So you need merkel proof implementation.
00:16:09.110 - 00:17:10.738, Speaker A: And I would say it's very easy to do this in Python, especially when you need to generate multiprofs. And yeah, then when you have mercury tree implementation, which was like 50 lines of code, which it was very easy when compared to the solid implementation, then you can basically like fill your tree with some, some data, and then you can make assertions that the proofs are or are not correct. So I would say it's like very easy to use Python test to verify this kind of libraries. And the second example is ERC 1155 fasttest. As I have said, Voc has integrated fuzzer, and this is how it looks like. So you have a fastest class, you need to inherit from that fastest class, and then you have the contract that you want to test. And what typically you want to do is that you want to model the state of the contract, but in your code, in your python.
00:17:10.738 - 00:18:10.850, Speaker A: So basically you are doing differential testing, which is useful, especially in the case that the compiler would have some kind of issue because of optimizer, for example. So you would probably discover the issue because you are testing the code in a different language, but if you tested the code in the same language, then you wouldn't probably discover the issue. So basically you want to model the state of the contract, but in Python, so that's why we have balances here, we have approvals. And what's really nice in Python, that you have default dictionaries that behave basically like mappings, so you can set the default value. If the key does not exist in the dictionary and you have basically the same behavior as in soda t, which is quite nice, then we have some kind of initializer here. So we deploy the contract we set the default dictionaries with their parameters. We want to generate some token ids.
00:18:10.850 - 00:18:41.434, Speaker A: But what's also nice, that when you are generating a random data, you can specify the edge values probabilities. So you probably want to increase the probability of generating zero, the minimum value and the maximum value for integers. And then there's a flow which is like a single executable step by the fuzzer where in this specific case we made some tokens to a random recipient with some random amount, things like that. All right, passing the word to Rhiannon.
00:18:42.214 - 00:19:48.314, Speaker B: Okay, so just quickly to sum up, based on our experience by writing the academic paper, Brownie has discontinued development but still feels more stable. And ape. Ape takes everything what people loved on Brownie and trying to do it better. And Vogue is blazingly fast and brownie and brown and architecture different from ape and brownie, with a focus on developers comfort and security. The developer's comfort is signified by type hinting in tests, which is the only feature which Vogue has apart from brownie and apex. But on the other hand, it doesn't have wiper support coverage reports are available for brownie and Vogue, gas reports only for brownie and ape. And Vogue has some other features like integrated fuzzer engine static analysis based on built in LSP server and Ape and Vogue has active development and all the frameworks have in common that they love Python.
00:19:48.314 - 00:20:01.054, Speaker B: So there are some resources. What I used, and a little bonus, there is a Vogue ape eating a brownie. So thank you mijourney, and thank you all for your attention.
00:20:07.074 - 00:20:32.004, Speaker C: Thank you. Do we have any questions to kick off? Anyone? I am checking the chat. Just have one comment. This is interesting. So I don't see any hands or any questions. Thank you guys. We will go to the next session now.
00:20:32.124 - 00:20:33.484, Speaker A: Okay, thank you.
