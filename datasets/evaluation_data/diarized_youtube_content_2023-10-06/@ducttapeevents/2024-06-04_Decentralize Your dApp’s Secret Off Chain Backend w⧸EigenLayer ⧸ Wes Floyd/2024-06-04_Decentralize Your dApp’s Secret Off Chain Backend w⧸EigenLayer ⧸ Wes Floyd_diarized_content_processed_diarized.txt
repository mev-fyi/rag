00:00:00.400 - 00:00:01.594, Speaker A: I think I should be straightforward.
00:00:09.894 - 00:00:32.104, Speaker B: All right, thank you again for joining us for our next talk at 01:00 p.m. we are continuing with Wes, Wes Floyd. He will be talking about decentralizing your dapp's secret of chain backend with Eigen layer. So please join me. Welcome, Wes. The stage is yours.
00:00:32.214 - 00:00:57.864, Speaker A: Thanks. Cheers. Hello. Good morning. Can everybody hear me okay? Awesome. All right, well, thanks for having me. This talk is specifically focused on your service, your DaO, your project, and particularly talking about the areas of your project that may not be as decentralized as you would like and how Eigen laylayer can help you on that path of that roadmap to decentralization.
00:00:57.864 - 00:01:39.534, Speaker A: So a little bit of background for me. I'm a part of the Devrel team at Eigenlayer and previously worked on decentralized compute projects or protocol labs with Filecoin and IPFs. Used to be an Ethereum miner back in the day, and then also had a background in web two with decentralized systems, database systems, and cloud systems. So that's a lot of the motivation of why I'm trying to combine the two for the talk and also just Eigen layer generally. And also, this is our broader team for the dev rel folks. If you want to follow us on build on Eigenvalue, you'll get some updates about hackathons, developer news, and all those sorts of things. So that's a great way to stay in touch with what we're up to.
00:01:39.534 - 00:02:32.574, Speaker A: Okay, so this talk will cover your project's roadmap to decentralization. The reasons, the economic benefits, the philosophical benefits, architecture's examples I'm going to go through a demo at the end of a sample project that I took of a centralized backend service and made it a decentralized service with Eigen layer. Unfortunately, I cannot get into Eigen token details, in case anyone was curious. Throw that out there and I won't cover as much this new concept of intersubjectivity. But I will strongly recommend, if you have time to go to the white paper for Eigen layer, this new Eigen token white paper, which covers a very interesting topic. We'll cover it briefly, but there's more development work, so it's a bit future out. We're going to cover today more deterministic, objective examples of attributable events slashing and how that plays into your decentralization.
00:02:32.574 - 00:03:10.972, Speaker A: Okay, so your challenge, the setup for your team is you've got a great, wonderful decentralized ecosystem. It's web3 it's Ethereum, but there's a couple back end services. Maybe there's a demon that's doing some aggregation that's occasionally posting a proof somewhere. And even though most of your project is a decentralized protocol, there's. So it's a couple reliances you might have on an AWS service or other things that are just, you had to do it, or you're busy or whatever reason. And so these are just kind of focusing on those things. And the reason it's valuable to think about decentralizing your entire project is a couple things.
00:03:10.972 - 00:04:02.130, Speaker A: One, your project is paying for those services in fiat, which is very strange because you're a crypto project. You have your own token that makes your organizational aspects more centralized. Your corporation kind of relies on who owns the actual service. From a security perspective as well, you have a roadmap for decentralization, probably that you're posting to your team, and maybe you have some centralized services now, but you've committed to your community. This is our roadmap for decentralization. More recently, especially in the US, the regulatory environment, the United States legislature passed a bill that said if your project is less than 20% owned by an individual, then you're considered a commodity, which is beneficial. So, like, even from a political perspective, decentralization is becoming more valued.
00:04:02.130 - 00:04:54.046, Speaker A: And so there's a premium just in general, and this talk is really meant to help you on that path. All right, and so the solution I want to talk about today to these problems is taking your existing app where it is, your existing binary, as much as is limited amount of work as possible, maximum benefit, but bringing the benefits of shared security. Permissionless innovation. As an AV's on Eigen layer, AV's stands for actively validated service. And so before we get into avss, this talks just about shared security in general and what this looks like before Eigenlayer. And then with shared security in eigen layer, traditionally, you know, your service, your blockchain, your protocol, has its own set of operators. Like if you look at networks like render or Filecoin or any of these really successful web3 projects, a lot of times they have their own operators and their own token associated with it.
00:04:54.046 - 00:05:35.820, Speaker A: The challenge is the security or the degree of decentralization, the economic security, the capital behind it is often siloed. And so if you're thinking I'm gonna maybe decentralize my network of operators, you're gonna have to raise capital, you're gonna have to bootstrap a network of operators. There's friction there's time associated with that. In the new shared economic security model, you had this capital that's pooled. You bring into a larger group of capital. On Ethereum particularly, you have a network of operators that are available and ready to run. And so your service operates on this existing network and also takes advantage of your token so you don't have to give up the benefits of your economic aspects of your token.
00:05:35.820 - 00:06:15.354, Speaker A: So when we talk about building a service or an AV's, porting your existing services as an AV's and Eigen layer, it's really trying to get the benefits of all these economic benefits. So reduce marginal cost for your folks. And this is kind of the name of the company and how we got it to Eigen. Your own layers, this is your layer on shared security. And the actively validated service is effectively taking, in this case, whatever was your centralized service today. And what we're going to do is we're going to add a small demon, a small service that will validate it. It will distribute amongst your operators, and it will write on chain some proof, some evidence that it's operating the way you expect it to.
00:06:15.354 - 00:06:56.060, Speaker A: And that's how we'll bootstrap the trust. Now, there's aspects of slashing in case those operators misbehave. There's aspects of rewards and payments for those operators when they behave well. That's actually what we're rolling out on Testnet right now is that kind of final component. But that's really what makes the trust, turns it to more of a trust, less service than a trusted service. So to give you a slightly different perspective on AV's is this is a very like protocol, Ethereum centric view, where in the ecosystem there are stakers, people that stake restaked ETH lsts, native restakers, there are people that stake your token, particularly in the Eigen layer protocol. And then there's operators.
00:06:56.060 - 00:07:23.168, Speaker A: Operators have to register their metadata. They have to opt in to be an operator. In eigen layer. We've got, I think 250 approximately operators today. And there's AV's service that we're going to talk about building today. And the AV's service operates both as an on chain service and as an off chain service. And then the consumers could be whomever, they could be your community who's already using those services today, which is really the goal of this port, them to become AV's consumers.
00:07:23.168 - 00:08:07.654, Speaker A: They could be other avss like you may have a back end service that does some simple check the date, time or check of a server is available, and it turns out other people also need to benefit that from that. So there's like a bit of a SaaS Lego block building mentality there as well. So there's a lot of folks building a variety of different avss, and I won't get into all of them today, but I will just say that there's a ton of stuff going on. Bridges traditional, like roll up oriented services. Ivda is one AV's that we're building in house as sort of a prototype and example of a large scale AV's. But then there's other things that you might be benefiting as you're building your AV's. Like if you need transparent trusted encryption environment, those are available.
00:08:07.654 - 00:08:54.094, Speaker A: There's lots of other improving services and things like that. So please kind of consider it as a bit of an ecosystem that you can build on. So we talked a little bit about why shared security. One thing in particular here is allowing you to choose the degree of decentralization that fits your needs. I used to work in the decentralized science space, particularly a lot a year ago, and these folks were very interested in running their own protein folding, but they wanted their own community members within their dao to actually run the hardware and services. You may want that for your folks as well. So your decentralization could be amongst your token holders, it could be people across different geographies, it could the economic aspects of what you care about decentralization, you just want solo validators versus large institutions, lots of customization there.
00:08:54.094 - 00:09:49.344, Speaker A: A second really important innovation in eigen layer is this dual staking model. So in order for anyone to be an operator for your service, they have to stake, they have to put up some skin in the game. And previously, prior to this past few weeks, when we launched it for Igda, they would stake ETH, they would stake Rocket pool etH, or Lido ETH, or native ETH. But what we're enabling now is this dual staking and dual core model. So that in order for them to be operators, they have to have a component of ETH and also a component of your token, which has tremendous benefits for your community. From an economic perspective, if you have a new token with low liquidity and low float, it helps bootstrap the growth of your token, but it also just brings the payment of those services more native to your own service as well. So it makes your token more of a real utility that your folks can use to fund operations on your network.
00:09:49.344 - 00:10:35.084, Speaker A: So we've got a ton of operators today when you build the service. You could have just your community members be running the service as operators, or you could reach out to these existing operators and they're very eager to run your service. They would love to run your service because they're professional. They've got these systems set up to run your AV's in a very, very high uptime manner, and they would love to participate as well. All right, so how to get started? So I wanted to kind of condense this process into easy, bite sized pieces. Whether you're the technical architect in your project, or even if you're a community member and you want to propose a project that could get a grant to help decentralize your favorite crypto project, a couple simple steps. So first, just identify some low hanging fruit.
00:10:35.084 - 00:11:10.660, Speaker A: A simple, centralized service that's easy to decentralize, something that exists today. Maybe it's a backend service running on a lambda function in AWS or something simple to start with. Number one, check to see if someone's already built it, because a lot of these services are being built as avss today, so some portion of that may already exist. Second is start thinking about the trust model need to support your service. It's a really fun aspect because in the centralized world, everything is effectively trusted. You trusted AWS will run your service properly and there won't be any issues. In the AV's world.
00:11:10.660 - 00:11:51.856, Speaker A: We have to start thinking about what are the aspects of your service that we need to prove. It does not have to be a binary decision such that every component in your architecture, when it's an AV's, has to be ZK proven and fully verified. It can be a progressive decentralization. You could start by, let's just at least create some checkpoints of what's going on in the service and post those, because those can then be slashed and they can be rewarded and et cetera, et cetera. And so you're moving in a direction of decentralization. And then lastly is to build a proof of concept. Take that example here and deploy it on a developer network on your machine, which we're going to do today, or deploy it on testnet and start building it out and get a sense for yourself of what's involved.
00:11:51.856 - 00:12:16.102, Speaker A: I'm trying to call this an MVA. It's a new word, so if you like it, please start using it. We'll make it a thing. I don't know if it'll catch, but give it some consideration. MVA. All right, so step one, is anyone building this? Go to app Eigenlayer XYZ AV's to see if anyone's building it. Also, we have a repo called awesomeavs, which lists a bunch of existing AVss.
00:12:16.102 - 00:12:57.156, Speaker A: Please check out that GitHub repo and then think about the trust model. So today, the trust model itself really needs to be things that are objective and provable on chain. So for Eigenda, as an example, Eigenda is a data availability layer. Eigenda is ensuring trust that all the operators in the eigenda network for that service have received the blob, and they were actually storing that given blob themselves. They sign a key, which becomes an aggregate key that gets proven on chain. And for that service, that is the right trust model that they needed. I'll show you an example of a different service later on that has a slightly different trust model.
00:12:57.156 - 00:13:41.848, Speaker A: So you just need to think about, you know, in the short term, what are the steps that you want to build more trust so you can decentralize over time. There's a really interesting component which is called intersubjectively agreeable truths, which is going to come out with a big part of the Eigen token that's discussed in the white paper, which are things that are not necessarily provable on chain, but that you can have a consensus of people that hold your token that agree with this. So for example, if we're all holding our community token, and there's a service that checks, is google.com up? Is it available? We can have one operator that says no, Google.com is down. You can have a majority of operators say Google.com is down, but everyone that's owning the token could say, yes, Google.com
00:13:41.848 - 00:14:19.008, Speaker A: is up and available, and so you can actually fork that token as a means to incentivize honest behavior. This is a really exciting area, which I think for this particular use case of services to avss is going to be a big unlock. So please keep that in mind as you move along. All right, so here we go, building an MVA proof of concept. We have a hello world AV's, which I'll show you guys here in just a second. It's a great way to get started. We're going to be building some additional components to make it very easy to templatize and fork from there, you will want to customize the on chain contracts for your AV's.
00:14:19.008 - 00:15:09.526, Speaker A: This is kind of the heart in Ethereum of what it means to have an AV's, and I'll show you that in a second. Then you want to build an off chain daemon and I have built a very lightweight version in JavaScript to show you an example. It's basically something where if you have existing binaries, and the goal is to minimize development of those binaries, minimize the effort required to port them, leave them as they are, but create a very lightweight service that could interact with those binaries and bring them on chain. And then lastly is package the off chain components into a service, something that your operators can run, because these operators are not going to be experts in necessarily what you built. They want a package they can just spin up, run, they want some health metrics. Is it good? Is everybody happy? So we'll make it as easy as possible for those folks. This is a view of the hello World repo.
00:15:09.526 - 00:15:58.974, Speaker A: My teammate Gajesh actually put this together not long ago. It's a nice, easy basic way to view what's required for a minimum viable AV's. And from an architecture view here, this is restating what we just covered, which is on the ethereum side, there's going to be the Eigen layer contracts that you're going to integrate with, there's going to be your contracts that you're going to write as part of your minimum viable AV's. You're going to write an off chain daemon for your app, and then you're going to have some binaries which are existing binaries. And we'll show you an example of using some existing Docker binaries here in just a second. And so as an example of an AV's, I spent a lot of time in the past in the IPFS ecosystem. IPFS is a fantastic technology, particularly for storing decentralized information.
00:15:58.974 - 00:16:56.514, Speaker A: However, many of the IPS hosting solutions actually have centralized backends. And even though you're uploading and pinning data through IPFS, you're relying on cloud storage in the backend. And so I thought, wouldn't it be nice if there was an AV's that was an IPFS pinning service that could be available and could be more decentralized, but it's also a really good example of porting your service. So the existing IPFS service has a binary called Kubo, which is a docker container. So what we can do is we can fork from hello world, we can take that IPFS daemon that exists today, and then we can write a little bit of lightweight code, wrote it in JavaScript, because JavaScript's easy. Everybody likes JavaScript, everybody knows JavaScript. You could write it in PHP, you could write it in shell script, it doesn't matter, it's entirely flexible and then a little bit of task management code on chain to communicate with the off chain code and the on chain code, and you're good to go.
00:16:56.514 - 00:17:29.314, Speaker A: So let me cut over to a quick how are we doing on time? Do you guys know? Five minutes, 15 minutes? Okay, great. Oh, perfect. Okay, so this is a view of what it looks like here for the demo. Lightweight code to interact with it off the shelf docker container. This is minimizing as much work for you guys as possible and then orchestrate with any orchestration technology that you like. All right, so let's jump to a demo here. I want to take you to the code repo, pull this up a little bit.
00:17:29.314 - 00:17:57.638, Speaker A: All right, so I've got a series of shell scripts I'm going to run you guys through. This is actually a little bit of a tricky thing to demo because there's so many moving parts. So what I want to just kind of give you a visual walkthrough here. We're going to spend some time looking at this off chain daemon and JavaScript here. I'll show you the code for that. And for this demo, we're going to set up this kubo binary daemon here running in a docker container. In order to test it, I also need a remote ipfs server.
00:17:57.638 - 00:18:23.012, Speaker A: So we're actually going to pin the IPS server remotely. Then we're going to trigger an on chain interaction. The on chain interaction is going to tell my operator to pin that service. It's going to be like an example of it. So you'll see a couple different docker containers running. And this is basically to prove the concept that I can have some level of a trust model that I write back to my on chain contracts which could be slashable. So I have to have some evidence.
00:18:23.012 - 00:18:49.764, Speaker A: I requested this item to be pinned. Was the item pinned? Can I verify the item was going to be pinned? And that's where we get kind of more into a design exercise for the ABS. All right, so this is my off chain code here. And basically it's just going to interact with a local IPFS daemon. It's going to call it through HTTP restful API. And I've got a variety of functions here. I'm going to check if it's up.
00:18:49.764 - 00:19:14.762, Speaker A: I'm going to add an IPFs hash. This is, is all off chain code. But then I get into some on chain interaction code where I'm going to be listening for an event that's posted to my Eigen layer contract. And once that event's posted, I'm going to pick it up. I'm going to do some off chain work here and I'm actually going to pin that CID. I'm going to write it here to the local ipfs server. So let's go through the demo here.
00:19:14.762 - 00:19:30.360, Speaker A: So first I want to start my anvil chain. I'll get that going for us here. Okay, so I've got my anvil chain running. It's up. I've got some keys here. Good to go. And then in my second terminal I am going to add these contracts.
00:19:30.360 - 00:19:49.580, Speaker A: This is my forge script here to run my Eigen layer code. Add that to the chain as well. So we get the AV's on the chain. Okay, that's good there. And you can see that the anvil chain is picked up. Now my Eigen layer code sits on chain. And then we're going to start a couple daemons.
00:19:49.580 - 00:20:25.736, Speaker A: So this is going to be the ipfs daemon for my operator. Now normally this would be packaged into Docker compose. It would be more easy for the operator to run for demo purposes. We'll just kind of spin it up individually and there's also going to be a remote IPFS container that we're going to use for testing. Now this remote IPFS container, really when I was testing it before, I had it running on some other server in the cloud somewhere. So you can actually see it communicating across and that's better for integrity, but it's not as good for demos because you can't always predict the networking between different systems. So if you'll bear with me, we're just going to do it all locally for today.
00:20:25.736 - 00:20:58.824, Speaker A: And then I'm actually going to start the binary for the operator. And again, this would be ideally packaged for the operators to just hit a start script and it runs it automatically. But for today's purposes we're just going to run it manually. Okay, so now let's run a test, end to end test. First we're going to open up this new window. We are going to get some environment variables set up and I'm going to create a message that I want to pin on this remote test server. It's going to say, hey, IPFS is today's date prog is amazing.
00:20:58.824 - 00:21:50.704, Speaker A: And then we're going to add that to the remote IPFS server here and we'll get a CID back. The CID is a unique identifier for any data that's stored in ipfs. So we know that this CID now lives on this remote IPFs server. Actually, let's add it pin and add to the remote ipfs server and let's just check the contents of that remote ipfs server just to make sure everything's good. Okay, now we're ready to test. So now we have this scenario where the remote server does have this ipfs server and I have my code, my operator code that's listening for any on chain events. And it says if there's an on chain event posted, I'm going to pick that up, I'm going to store it locally and then I'm going to post back to the eigen layer contract that I stored it so that there could be a decision about should I be slashed, should I be paid.
00:21:50.704 - 00:22:16.874, Speaker A: So let's do that. So let's check also my local operator API operator IPFS instance. Okay. It does not have this CID yet ending in two eight w. It just has the default vanilla, nothing stored there, whatever like the standard is for the kubo instance. So let's submit the contract on chain. Let's create this task.
00:22:16.874 - 00:22:50.526, Speaker A: So I actually want to pay, I want to use my, in fact as a real consumer, I would use the token of the conception token or something to pay for this. And I would say I care so much about this particular piece of data, I want to use the maximum decentralized way to store it possible. And that is this example AV's here. So let's write that on chain that gets picked up by our anvil node here as a transaction. And then also our off chain service catches it. It says okay, wow, I heard that there's a new job for me to take on a new task. Task management is the model that we use.
00:22:50.526 - 00:23:29.738, Speaker A: So we're actually going to store that locally and we're going to write it back to the eigen layer contracts that we stored this information. And so now that that end to end process is complete, let's run a quick check of my operator API to make sure that it stored it here. Okay. And so it has, so now we have this file here. It's stored locally on chain and we've kind of done the end to end components there for storing it. So anyways, long story short, that is an example of porting a simple binary that already existed into the Eigen layer ecosystem. Now it's more on chain.
00:23:29.738 - 00:23:56.710, Speaker A: Now I'm paying for it. My token, I get all the benefits of decentralization, MVA, minimum viable AV's. Let's make it a thing. All right, so just to kind of wrap up the talk, please do check us out. We've got a fun hackathon going here with lots of prizes for folks to help us build reference architectures and more developer tooling. We'd love to get your feedback as you're going through this process. Follow us at build in Eigen.
00:23:56.710 - 00:24:09.794, Speaker A: And then also, please do check out the white paper if you have not already. There's a lot of really interesting stuff we're going to be able to do also in the future with these architectures. And that is all I have for today. Thank you so much. Appreciate it. Cheers.
00:24:12.814 - 00:24:24.174, Speaker C: All right, that's a very great talk on decentralizing our dub secret with Egon layer. I don't know. Do anyone have a question? I guess we should have a question. Yeah, over there.
00:24:28.874 - 00:24:29.330, Speaker A: Okay.
00:24:29.362 - 00:24:50.284, Speaker D: Oh, sorry. So just a question. You spoke about this example where you would sort of have an ipfs sort of output that would be provable back to on chain. Like, what if the off chain computation doesn't actually return something, as in returns void? How do you prove something that returns void?
00:24:51.304 - 00:24:58.736, Speaker A: That's a really interesting question. If you're saying in this scenario, there's some off chain computation, that happens, but there's no outcome proof of it.
00:24:58.800 - 00:25:06.768, Speaker D: Yeah, like it could write to a database, or it could do something in the cloud, for example, but it doesn't necessarily return something to prove that it actually computed that correctly.
00:25:06.896 - 00:25:52.004, Speaker A: That is the most, in my opinion, the most interesting design exercise of this whole thing is taking things where in web two we had this, this default trust model where we didn't have to do these things. And in this new world, we do have to think about these things. So if it just returns void, it doesn't do anything. Then we have to think a little bit creatively about how to create on chain provable visibility. There's a lot of different work going on in this space. So, for example, there are, like, I had this one idea where I would like to be able to write all of the event logs from a given server daemon on chain as a way to prove, you know, not necessarily always deterministically, but sometimes objectively, things are right there. So I think, like a little bit of engineering that has to happen if you don't have a clear piece of text, you know, that's coming out that you can write on chain.
00:25:52.004 - 00:25:58.528, Speaker A: There's another example. I'll think of it in a minute, but there's definitely some work to do there. Yeah, it's a good call out.
00:25:58.576 - 00:25:58.904, Speaker D: Thank you.
00:25:58.944 - 00:26:03.044, Speaker A: Yeah, cool.
00:26:09.124 - 00:26:25.364, Speaker C: No question. All right, thank you very much. So we have five more minutes for the next person, so stay around.
