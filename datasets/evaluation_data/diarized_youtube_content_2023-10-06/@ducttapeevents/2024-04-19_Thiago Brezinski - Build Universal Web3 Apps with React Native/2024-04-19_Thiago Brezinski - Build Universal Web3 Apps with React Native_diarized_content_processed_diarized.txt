00:00:00.720 - 00:00:26.670, Speaker A: So thank you. Thank you for being here, everyone. So today, basically I have a little bit of a different talk. So I will not be talking about l two s or evms or all of this deep blockchain stuff, but instead I'll be talking about building good frontends for that. So basically we have built universal web three apps with React native. My name is Thiago Brzezinski. I work at Costech.
00:00:26.670 - 00:01:27.184, Speaker A: I'm a senior react native developer. And basically at call Stack we're trying to work in this niche interception intersection between web three and react native, and trying to understand why it has been so difficult to build good Web three mobile applications until now, why it's not the case anymore, and how we can do it with React native. So first we need to talk about what are universal apps. And these are apps that basically using the same codebase, you can target multiple platforms. So the beauty of react native is that using the same code, you can build to iOS, to Android, to web, Windows, macOS and even vision OS and other different platforms. But the thing to keep in mind here is that it's not a webview, it's not any custom rendering engine, it's just using native components. So JavaScript in this case is just orchestrating the native components from the operating system and you get the whole native look and feel.
00:01:27.184 - 00:02:29.014, Speaker A: So this series of tweets got pretty popular around last year when Matt was basically saying that people didn't even notice that React native was being used in the PlayStation four and PlayStation five UI until the community was J O breaking the PlayStation five. So this is how you can know that react native just integrates seamlessly with other native applications and you can keep the native look and feel and performance. It's also used in the Xbox UI. Also because Microsoft is a big player in the React native space. So if you're not familiar with React native, this is the most basic code you can get to build with react native. And if you're familiar with web development, then you can just, you can know the analogy here. Basically the views will be HTML divs and texts are analog to paragraphs, for example.
00:02:29.014 - 00:03:13.808, Speaker A: And this runs in every platform, as I mentioned. So we need to talk about the current DApP situation. And basically, if you look all around web three, you're going to see that most dapps are web only and only maybe the top three dapps will have the equivalent native mobile experience. So for example, if you look at blur, it's only web. If you look at sushiswap, the exchange, it's only web also, hey, the lens protocol client, only web. But then we have a few good mobile contenders. For example orb, another lens protocol client, especially now in v two, they're excellent mobile experience, also Wildcats, which is also a universal app.
00:03:13.808 - 00:03:49.746, Speaker A: It's amazing. And uniswap, we don't even need to talk about it. It's amazing. But why we need to talk about why it has been this way, why it has been so hard to build good web three mobile experiences. And it's mainly because of the popularity of the browser extensions, because the browser extensions wallets, they basically standardize this way of injecting the Ethereum provider inside the window global. And the window global is a browser web API. So when you try to take this out of the browser, it's going to crash, obviously.
00:03:49.746 - 00:04:33.420, Speaker A: And then most of the web three libraries were built with this in mind. So they're also sometimes hard to port outside of the web. And this leads to a big number of polyfills when you want to bring this to mobile, for example. So let's talk a little bit about polyfills. So a few months ago, if you tried to start a react native project with Webtree using the famous web three libraries, you would probably stumble across these errors and maybe more. These three are only a few of the most common ones, and basically it's missing APIs from the web that are not present in Req native. So for example, let's go a little bit into each of these.
00:04:33.420 - 00:05:02.958, Speaker A: So in the first one we basically don't have the crypto module which is present in both the browser and node js. The second one is Atob and Btoa. These are base 64 encoding and decoding APIs, also not present. And then we have the text encoder API which is also not present in the react native environment. So let's talk about a little bit of these and why it's not the case anymore. It should be already fixed. So first the crypto API.
00:05:02.958 - 00:06:06.594, Speaker A: So most often even Webtree dapps, when they need the crypto API, most often they only need a good way to generate random values to use as a seed for the crypto functions and crypto hashes. And this needs to be generated natively because JavaScript doesn't have, can't guarantee enough entropy for random values. So most often dapps will only need this from the crypto API. So if you only need this, you can just install this polyfill called react native getrandomvalues. It's done natively for iOS and Android, uses native APIs from each platform that is already battle tested for years in these operating systems. If I remember correctly, what is using in iOS, the API dates from iOS three if I'm not mistaken. But then if you happen to need the whole crypto module, then you can just install react native quick crypto, which is meant to be a complete replacement for the node JS crypto API.
00:06:06.594 - 00:07:00.504, Speaker A: And then when we talk about the other two polyfills, so base 64 and text encoder, basically we have the Hermes team. So this big green h here, Hermes is the JavaScript engine that powers react native. So for example on Chrome we have the JavaScript engine, it's called v eight. When it's the same on Node js we have a custom one for react native to better fit react native needs, for example startup time, which is more important in a mobile app. And the team at Hermes, basically they polyfill this natively into the JavaScript engine. For us, this is actually very recent, like one or two months ago, and this should already be present in reg native zero seven four, which is the next version that should be coming in the next few weeks. So this also should not be a problem anymore.
00:07:00.504 - 00:07:41.966, Speaker A: So at this point we should be good to write a react native application for web three using web three libraries and have very little problems. So let's talk about the next generation of web three apps. I strongly believe they will be built with react native for multiple platforms at once, and it's going to be using those tools. So expo react native web rack navigation, VN and WagMe, and the wallet connect web three model. So here on the right we have one example that you can build using req native targeting native platforms. For example, this app in the right and also have the equivalent web experience to the left. So you can see that I can also specialize.
00:07:41.966 - 00:08:26.924, Speaker A: For example on the web I prefer to have a sidebar instead of tabs which are not popular on the web, and then I can just on mobile I can just use my tabs also on the web, as I have more screen real estate, I can put more columns in my list, as on mobile I only keep one column because it's better. So these are only a few examples of what you can do. You can do whatever you prefer, get the best of each platform. So let's talk about each of these tools here just a little bit in case you're not familiar. So if you're not familiar with the React native ecosystem, there is Expo. Expo is a framework to help develop universal apps. Think of it like the next j's of React native.
00:08:26.924 - 00:09:19.580, Speaker A: So they provide you with a lot of curated native modules, for example maps, camera images, geolocation, sensors, whatever you can think of. Then they also help you with automated builds, deploy to App Stores and over the air updates. Basically, if you're starting a React native project today, you should probably be going with Axo because they will facilitate several things for you. Then we have react native web, which is used by Expo under the hood, and it's a compatibility layer between recdom which is react web and react native. Basically react native web will take your react native code like views and texts and translate it to the web APIs to divs and paragraphs for example. Much more of course, but this is just a basic example. Then we have RAC navigation, which is the standard navigation library in RAC.
00:09:19.580 - 00:10:11.652, Speaker A: Native rack navigation provides you with these navigation primitives like the tabs, the sidebar, or pushing stacks on top of each page. And this is also using native APIs from each operating system. Then we have VM, which I believe many people here might know. It's very popular in the last year, let's say it got a lot of rising downloads and it's a lightweight interface to ethereum, so it's an alternative to web three J's or ethers J's. And you can communicate with the blockchain, so send and receive data. And the advantages is that it's lightweight and performatic. So for example in the first two lines we can see that we're querying data from the blockchain, so getting the block number and getting the gas price.
00:10:11.652 - 00:10:45.644, Speaker A: And in the last two we're asking the wallet to sign a message or send a transaction. So it's easy like that. And then we have Wagme which is built by the same team as VM and it's just a react hooks wrapper on top of VM. So it's basically react way of using VM and you get these reusable rack hooks, you got caching, you get persistence. It's just a better development experience to interacting with the blockchain. And of course VM is a dependency of Wagme. So basically usually you're going to be installing both of them.
00:10:45.644 - 00:11:33.258, Speaker A: And finally we have wild connect web three model, which certainly everyone here already saw it when interacting with dapps, probably maybe the most famous model to connect to wallet. And they integrate well with VM and Wagme that I just showed. And they actually have both a react native SDK and a web SDK. So in the web you got this center and model in react native. In mobile you get this bottom sheet which is more like a mobile look and feel. So I talked about all of these tools, but how we can actually do it to build a universal app. So basically you need to do these three big things, which is setting up a navigation, connecting the wallet, and then interacting with the blockchain.
00:11:33.258 - 00:12:28.114, Speaker A: So you may already see where I'm going with this. So to set up the navigation we're going to be using platform specific code. So basically react native has this platform API that lets you branch off or run conditionals, run different code for each platform. So in this case for my navigation, the example I showed you before, when I'm targeting the web, I want to render a drawer navigator, which is that sidebar, and if I'm not on the web I'll be on mobile, then I want to render the tabs. So the beauty of this is that I'm just replacing the shell, but the screens inside, they're the same. So we're reusing the same code for our screens and all the data fetching, all the components are going to be the same. So instead of also checking for the web, you could be checking for iOS, Android specifically if you need.
00:12:28.114 - 00:13:00.340, Speaker A: And then after we set up navigation, we need to connect the wallet. So to connect the wallet we're going to be using platform specific file extensions. So imagine you have a button that you want to make it look different on each platform. You could also be doing this the same way I just showed you, but there's another way which is just using these file extensions. So you can have a button, iOS button, Android button web, and it's going to be loaded conditionally on each platform. And this is powered by Metro. Metro is the JavaScript vendor for React native.
00:13:00.340 - 00:13:49.616, Speaker A: So a bundler is basically what takes all your project files, how do you say, it, analyzes the dependencies and outputs a single JavaScript file in the end for production. So Metro is going to see these file extensions and drop the ones that are not needed depending on the environment you're running. Okay, so we're not talking about buttons. I want to know how to connect the wallet. So as I said, the web three model, Wireconnect web three model, they have both rec native SDK and a web SDK. So what we can do here is we can create a directory called web three modal or anything else you want. And then we have two index files, so we have a standard index type ts and then an index web.
00:13:49.616 - 00:14:35.994, Speaker A: So since the web is more specific it's going to take when it's running on the web and in every other case it's going to take the plain index ts. So if you look at the code here in the right it's just the same thing. But when we're on the web we import the web package and when we're on mobile we import the mobile package and the rest is just a standard setup. But how do I use this? So this is the beauty of everything. So you can just import this directory that you just created that has the, the index specific files and the metro blender will figure this out for you. So you don't need to do anything. So when this is running on the web it's going to pick up the index web file and when it's running on mobile it's going to pick up the index normal file.
00:14:35.994 - 00:15:09.692, Speaker A: So then you can just import the components as usual and render them. So with this single piece of code you're going to be using this model on both web and mobile. So after connecting the wallet we need to get data. So maybe this is the easiest part for you. So we basically have two ways of doing this. First is using the Ethereum interfaces such as VM as already showed. Then we can use data aggregators such as Zora such as Alchemy, or using the SDKs itself, for example lens protocol.
00:15:09.692 - 00:15:57.404, Speaker A: In their SDK you can query posts or users directly through the SDK. So in the example I'm going to show next I'm using the Alchemy API where you can just pass an address and get all of nfts for that address and then I can just use that to render a list. So when you mix it all together, for example, in this case I decided to put my wallet connect button on the sidebar. On web and on mobile I decided to put it on the header. When you click it you get this native look and feel for each platform. So it's using, with the directory recreated, it's using the web API on web and this bottom sheet, the react native API on React native. And after you connect your wallet you can display the data that you just got.
00:15:57.404 - 00:16:46.694, Speaker A: So the same example as I showed before, we can specify better for each platform. So in this case on web I decided to have four columns and on mobile I decided to have only one column. But you can do this as much as you want, as much as you think. You can take advantage of each platform's strengths. So another example is using the lens protocol, you could create for example a cross platform lens protocol client where I'm using the SDK to get my profile on Testnet. And then for example, if you move to the homepage, you could be querying the posts and showing this post in a cross platform way also. So you have a native app, you have a good web app, and you can just reach a much more broader audience right from the start without too much effort.
00:16:46.694 - 00:17:24.634, Speaker A: So if you want to know more about this, these two examples are in these QR codes. So in the left we have the universal NFT list and on the right we have the lens protocol client. And if you want to know more, we go deeper into this, into the call stack blog. We have these two articles explaining why these decisions of why we went with this code and how to do it more specifically and other cool topics. Also if you want to know more about this, also you can find me in the conference or find me on x forecaster or lens. Just send me a message. Thank you.
00:17:30.254 - 00:17:52.194, Speaker B: Perfect. Thank you so much. We do have some time for questions from the audience if anyone has any questions. No? Ok, then I actually do have one. So from your experience, what do you think is the biggest difference for building web three applications versus web two? And what's the biggest challenge for building for web three?
00:17:52.694 - 00:18:23.714, Speaker A: Honestly, the thing that is different is basically fetching data, because you're just fetching from the blockchain or from one of these options I showed, but the rest is mostly the same. Instead of logging in, you connect your wallet and then you need to fetch data from different places, but the rest is mostly the same. You still need to do the same performance optimizations. You face 90% of the same challenges as a normal front end and that's what we're trying to do here.
00:18:25.614 - 00:18:29.784, Speaker B: Awesome, cool. And what was your motivation for building for web three?
00:18:30.724 - 00:19:01.564, Speaker A: It's just that because we develop a lot of mobile apps and when I started on web three a few years ago, you just noticed that you don't have very good mobile apps except for the top three or top five big players for a long time. So yeah, you just noticed that there's something missing and you don't know why. So we're trying to explore this intersection and try to help get more better mobile experiences.
00:19:02.624 - 00:19:05.744, Speaker B: Awesome, cool, thank you. Please give him a big round of applause again.
