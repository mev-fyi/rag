00:00:03.320 - 00:00:15.294, Speaker A: All right. Hey, everyone, I'm Alexei. I'm one of the co founders of Intelay. We just had some minor slide issues, but it's the same deck. It's all correct. So today we're going to talk about mastering cross trim bridges. We come from a research background.
00:00:15.294 - 00:01:06.160, Speaker A: We've been doing research on bridging techniques and how to, you know, connect different blockchains in a trustless manner for the last five years. And this talk kind of provides an overview of the challenges, the problems, and the way forward to, you know, or truly decentralized multichain future. Now, I won't take long on this one, but why should we care about cross chain bridges? I mean, you just heard a talk by Zaki about using it for off chain functionality, and there's so much things that we can actually unlock. I'm a strong believer of the option thesis that you can customize your chain to a certain product and that there won't be one chain through all them all. And we're likely looking at an Ethereum roll up architecture, Cosmos, Polkadot app, gene thesis, and avalanche. So it's very unlikely that only one of them will prevail and will all converge towards one system. They all optimize for different things, and we basically need bridges because it's very unlikely, again, that they will not speak to each other.
00:01:06.160 - 00:01:37.994, Speaker A: Just like in different currencies, different states, you do have interactions. They're not completely isolated. And we'll have the same situation in blockchains in this ecosystem in the near future. The issue is that, well, we all try to design decentralized systems. Blockchains or decentralized networks should not be bound to trust a centralized provider. But then when we talk to each other, we unfortunately have to go back and use centralized bridges. And I looked at the volume of funds moved between different chains over the last 30 days, and it's over $10 billion.
00:01:37.994 - 00:02:14.800, Speaker A: And that doesn't count, like, NFT values and so on. And unfortunately, the only trustless volume that we have comes from Cosmos Polkadot a little bit through, like, the intel BTC bridge and some l two bridges, and that's less than 10%. Right. So we're still, like, relying on centralized bridge providers, and that is, of course, a potential risk. So cross chain bridges 101. One important thing to remember and understand is that bridging means depositing. Like, if we ignore the complexities of different designs of different blockchains, from a user's perspective, what you're actually doing is you're depositing ether into some other product.
00:02:14.800 - 00:02:44.140, Speaker A: This product might be binance or Bitfinex or Kraken. It might be some cash app or something like that, which is a custodial wallet. Or it can be a roll up NL two that allows you to use the same functionality, but cheaper and faster. Or it could be a completely different chain. So for you as a user, it's depositing. But of course we prefer to deposit into a decentralized system than into a centralized exchange. And the goals of depositing or bridging assets are pretty straightforward.
00:02:44.140 - 00:03:09.766, Speaker A: We deposit ETH into an app chain. We use ETH there like any native asset. So you want to be able to interact with all the smart contract functionality, just like on, let's say, Binance. You can use your bitcoin or ether in all of their features. You don't have to figure out how to wrap it between these different products, right. For you, it's like binance ETH or Polkadot ETH or whatever. And to withdraw ether back to ethereum, well, you want to always be able to get it back.
00:03:09.766 - 00:03:38.320, Speaker A: And the goal is the usability and the user experience should be as simple as depositing into a centralized exchange and getting it out, right. You don't want to worry about signing different transactions, connecting your wallet to five different things, and it should be secure. You should always be able to get your assets out of the system. You don't want to end up losing your money. Pretty clear. Now, before we dive in, a quick reminder on trust models. If you are working with one single system, with one single chain, what you need is a wallet.
00:03:38.320 - 00:04:06.236, Speaker A: You trust that the network is secure, otherwise you wouldn't be using it. And you kind of trust that the wallet is not corrupted. We've heard recently, right, there's always like wallet hacks happen, and this is definitely something you should be aware of. And the way to verify it is, well, if the code is open source, there's a big open source community that kind of audits the system. Even if you don't code yourself, you can somewhat rely systems working. Now, if you go multi chain, a few things I added on top. First of all, you need two wallets.
00:04:06.236 - 00:04:38.280, Speaker A: Yes, there's multichain wallets, but under the hood there, you're kind of creating accounts in different systems on different chains and provide you with an S interface, but you're still managing multiple accounts. And then you're now trusting two networks. So you're trusting network one and network two. Now this is an okay assumption because, well, you know, you won't be depositing into another system, if you don't trust it, right? Why would you use it otherwise? So we can kind of assume that that's okay. You need the wallets to work, and that's where things get hairy. You need the bridges to be secure. And this talk focuses on that specific point.
00:04:38.280 - 00:05:21.144, Speaker A: Now, last one, kind of basic, basic kind of point, ETH only exists on the Ethereum chain. This means to move it into another system. We're actually not taking an apple from one box into the other box, which you actually have to create a representation of that apple. So think of it as a projection. So you're projecting to the other system that, hey, I've locked one ether and now I should be able to use this one ether on this other network. But in like, in physical terms, the Ethereum is still locked on the Ethereum chain. And in computer science terms, what this means is you're obtaining a write lock, so you prevent any other updates to that ether coin on the Ethereum network until you have crossed back over from the other chain.
00:05:21.144 - 00:05:57.944, Speaker A: And this also means that if I transfer the wrapped ether to somebody else, obviously it should not be me who is redeeming Ethereum on the Ethereum chain, but the recipient. So you want to make sure you propagate all the updates back to the source chain. So that was the basics, right? Sounds simple. So why is bridging so difficult? And why haven't we figured it out today? And this takes us back over 1000 years in history. It takes us back to one of the oldest problems of commerce, the fair exchange problem. Now you may wonder, like, oh, how does this even relate to blockchains and so on? But bear with me. In the fair exchange problem, we have Alice and Bob.
00:05:57.944 - 00:06:27.844, Speaker A: Alice wants to buy an apple, Bob wants to get paid. Super simple. What would they do in non digital times? Well, they'd meet in some marketplace where there's lots of people, there's guards, and they would exchange their goods. Why would they not meet in a dark alleyway? Well, because Alice does not want to get robbed by Bob or his friends, right? Because she does not necessarily want to trust him. On the Internet, however, you don't know who your counterparty is. Think of ordering from Amazon. You're buying some goods and you're either making the prepayment or the merchant trusts you to pay afterwards.
00:06:27.844 - 00:07:14.080, Speaker A: And essentially, when you don't know who your counterparty is and you have no way of enforcing their correct behavior, you need somebody else to do so. And there's a formal proof from 1999. And this is like actually a very old problem. But in the end, to do trustless communication, well, you need to trust a third party to make sure that the swap actually is executed. How does this relate to bridging? And some of you may think of atomic swaps, and if we have time we can come to that at the end. But bridging means swapping the native for the wrapped assets, right? You swap ETH for the wrapped ethereum, and when you go back, you swap wrapped ETH for wrapped ether for ether on the source chain. So someone needs to make sure that this locking and unlocking actually happens in an atomic way.
00:07:14.080 - 00:07:54.706, Speaker A: You only want to get wrapped ether if you've locked the ethereum, and vice versa. And that's the bridge problem, right? So you have two actors on two different chains. Bob is a potential recipient of Ethereum, let's say on Polkadot. And you really need to make sure that these actions happen atomically. So you need to guarantee that Bob only gets the wrapped ether if Ethereum has been locked and under no other circumstance. So how do we solve this problem? Well, coming from fair exchange and learning from that, we know well, we need to pick a custodian. So someone, and maybe custodian, you can pick other words, but someone needs to be in the middle and make sure that the locking and unlocking happens correctly.
00:07:54.706 - 00:08:24.356, Speaker A: And this can be a centralized entity. So someone, a centralized entity, signs messages on both contracts and says, hey, yes, Alice locked ether in the Ethereum smart contract. Let's unlock and mint some wrapped ether on Polkadot. It can be a commit to your federation if you don't want to trust one person. So you say, well, let's pick 20 people in this room, they do a multisig and they are the ones who kind of agree. If the majority of them says yes, then we're good. But that's a fixed committee, it's a fixed set of people, it doesn't change.
00:08:24.356 - 00:09:16.474, Speaker A: So if you want to have it more dynamic and more open to everybody to join and leave, you can go a step further and you can create a separate network that is used purely for bridging. So comedies, federations, you have things like multi chain wormhole, there's quite a few bridges in the commit deferation kind of sector. You have things like accelerate the kind of position themselves more towards consensus. They have the separate network which connects between different blockchains, and you trust that the accelerated chain will behave correctly. But ultimately the best setup is to trust the consensus of the involved chains. So if you only trust ether, Ethereum and Polkadot and nobody else. So centralized bridges, quick reminder, how do they work? I deposit Ethereum into a smart contract, or this smart contract is just maybe an account, or it's controlled by a custodian.
00:09:16.474 - 00:10:12.930, Speaker A: The custodian says, hey, I received Ethereum, let's mint some wrap ether on the target chain, and then that's executed either manually or automated. But in the end there's a central party. And if I want to go back, well, I have to ask, hey, can I please have my ethereum back? Because I'm returning the wrapped assets. And of course you need to trust the centralized provider. And if the centralized provider says no and loses, or basically they steal, they lose access, something happens, you have nothing that protects you against it, just like with centralized exchanges. So it raises the question like is it really defi when we bridge between different chains, if the bridge is actually centralized in c five, and if we look at the recent history of bridge hacks, and I'm just listing the ones here that really relate to private key and access control compromise. So where the bridge broke because it was centralized, there's tons of more hacks, right? Nomad and so on, that happened as well.
00:10:12.930 - 00:10:47.754, Speaker A: But they're not because the bridge was centralized, right? That wasn't the main reason. And then also it doesn't mean that the bridge must be hacked. You know, the team might just lose access to the servers and something might go wrong. And in the end you're just trusting that centralized provider just like you're trusting binance when you use binance. So the question is, how do we build a decentralized bridge? And as already hinted, we want to use the consensus of the two chains we're connecting. So ideally we want to inherit the security and decentralization of both Ethereum and let's say Polkadot, the target chain. And the way to do this is to use light clients.
00:10:47.754 - 00:11:35.206, Speaker A: So Ethereum would verify the state of Polkadot and be able to check state transitions, updates of the state, this proof of stake kind of longest chain, and know which transactions happened in a smart contract and vice versa. Polkadot would have a smart contract that verifies the state of Ethereum. And the only thing you need then between the two systems is one honest online party that sends the message, the proofs, and that's it. And this construction is called liteclime bridges. Sounds fancy, sounds complicated, but it's been around since 2014. It dates back to the bitcoin sidechains paper, which basically already back then said, look, the best way to connect your chains is to use these spv litecline proofs because then we don't need a centralized bridging partner. So question is, well, why haven't we built them yet today? And we'll talk about this in the end.
00:11:35.206 - 00:12:02.664, Speaker A: So if you look at the scheme, essentially what changes when we use lite climb bridges is instead of the custodian or centralized provider, you have smart contracts. And these contracts are able to verify the state of the other chain cryptographically. The same way that when you have a wallet on your phone that has a light client, it doesn't store all the data of Ethereum. Usually it stores some metadata so it can verify transactions. Same concept here. You don't download the entire chain.
00:12:03.404 - 00:12:04.220, Speaker B: It was close.
00:12:04.332 - 00:12:25.264, Speaker A: You don't download the entire chain of Ethereum onto Polkadot. You just download the block headers, which is much more efficient. So what do I do then? Same construction. I lock Ethereum. A proof is generated in. Somebody forwards that proof to Polkadot, I get the wrapped assets. When I go back, same idea, I return the assets, proof is submitted and I get ether back.
00:12:25.264 - 00:13:05.304, Speaker A: Now what happens if this relayer, this person in the middle, is malicious and does not relay the proofs? Well, the cool thing about this construction is that I can do that myself. And if I'm an application that uses bridges for like for example, somily or other chain or other products, it's in my own interest to actually run one of these relayers to generate the proofs and make sure that they're submitted between the two chains. And anybody can do that, which is the beauty of this construction. So you don't need anyone in particular. You can be your own kind of relayer. And we are good to go. Now, quick kind of reminder, like clients, super important part of this construction.
00:13:05.304 - 00:13:39.434, Speaker A: We want to know what's going on on the other side. So what we do is we store the block headers, right? So just the metadata, which says, okay, hey, like this is block number x. We're referencing the previous block hash. This is the root hash of the transactions that are in this block. And then we also, on top of that, have information about proof of work difficulty or proof of stake state. And that contract verifies, if given two different chains, which one has the most proof of work or the most proof of stake. So it kind of verifies whether the consensus executed correctly.
00:13:39.434 - 00:14:04.598, Speaker A: And on top of that, it can then check transactions. Security model assumption super relevant. It assumes that if a transaction is included in the main chain, then it must be valid because it does not download all the blocks. It cannot really trace the transaction back to all the executions. It cannot check if there's a double spend. It must assume that, well, if it got into the main chain, that means that all the full nodes in the network accepted it. So it must be valid.
00:14:04.598 - 00:14:41.982, Speaker A: Otherwise somebody would have had to attack the entire network. So this thing really is secure, as long as there's one honest party that submits the data from Ethereum to Polkadot and keeps it up to date with latest blocks. If that's given, this thing works, and you cannot lie to it. Right? So we actually built a decentralized bridge. Before we talk about challenges, let's talk about economic security. If we have two chains, let's say Ethereum, and something smaller, like some app chain, and we're moving value between them. So the green kind of thing is the value of all the assets moved from the green one to the green one, and vice versa.
00:14:41.982 - 00:15:36.454, Speaker A: If this is the model that we're speaking about. So the actual market cap and the value of the actual chain is less than the bridged assets, we're fine, right? Because it's not really worth attacking this thing and losing all your stake and sending the whole value of this to zero. But if at some point the value of the bridged assets exceeds the kind of proof of stake or proof of work security budget of the target chain, you might run into issues. Now, this is purely theoretical, but in the future, if we kind of have a multi chain ecosystem, there's a high chance that this will at some point happen. At some point there will be a chain where somebody decides to buy up the stake or kind of prepare the attack and then steal stablecoins, bitcoin where they can exit to a separate system. So that's definitely something to pay attention to. When you're bridging assets over, make sure at least that the value kind of is not completely exceeding the security budget of your target system.
00:15:36.454 - 00:16:20.818, Speaker A: Now, we won't have time to talk about bitcoin bridges, but economic security is also relevant when we're bridging between two systems where one does not have lite clients. So, for example, a bitcoin Ethereum bridge. If I want to bridge bitcoin to Ethereum, right? Ethereum can have a lite client for BTC. It can verify bitcoin payments and bitcoin state. But bitcoin has no smart contracts, so it has no way to check what's going on in Ethereum. And in this case, you need someone on the bitcoin side to simulate the smart contract behavior, right? So you need a few nodes that kind of replicate and pretend to be a smart contract, but you trust them. And in wrapped BTC on Ethereum today, right, you have WBTC, bitgo is the custodian, and you trust bitgo to lock and then release the bitcoin when you go back.
00:16:20.818 - 00:17:12.981, Speaker A: And the way to make this model more secure is to use game theory and incentives, and without going into too much detail because of time, but instead of having one node, you make, allow anybody to run the nodes and then you make them lock collateral, right? So it's a collateralized system. As long as the collateral is worth more than the bitcoin that you lock in the vaults, your bitcoin is safe because they have no incentive of stealing it. Because if they do steal your bitcoin, right? And as it's shown in this picture here, you will be reimbursed in collateral. And how this is enforced is by using these state proofs. So you prove to the bitcoin, you prove to the target chain to ethereum, hey, I locked the bitcoin, and these guys need to prove to Ethereum that they actually return the BTC to you. And if they don't prove, then they get liquidated and you get reimbursed. So last two minutes, I'll probably cut down to 1 minute.
00:17:12.981 - 00:18:12.958, Speaker A: So what's the outlook? First of all? Unfortunately, there shall be chaos. And the reason is we have so many different bridges right now that exist in parallel. And what's happening? We're fragmenting liquidity because wormhole ETH and Axelr ETH are not compatible. The other issue is that they don't, mostly for now, they support EVM chains. So if you're coming from Cosmos, Polkadot and other kind of layer ones, you kind of have to either add EVM support or you plug into another chain that has EVM and you have to do multi hop routing, which again creates even more fragmentation and complexities. And then you, as a project, if you're an apprentice, you have to decide, do I put all of my eggs in one basket and I trust only one bridge, or do I spray and pray and get as many of them as possible and hope that if one breaks, then I'll still be okay? But then I'm fragmenting liquidity, and then my users need to choose, well, which version of ether I'm actually going to use. Now, the other issue is I've been shilling lite client bridges to you for the last 20 minutes, so why don't we have them yet.
00:18:12.958 - 00:18:35.920, Speaker A: And the challenge is that it's not that easy to build. It's a technically quite complex issue. So for bitcoin proof of work, there exists lite clients that are building smart contracts. We can verify bitcoin proof of work and signatures and everything reasonably efficiently. On Ethereum, that's possible. For litecoin, for example, that uses the S script algorithm, that is memory hardware. It's not possible.
00:18:35.920 - 00:19:04.332, Speaker A: It's simply not feasible to do that verification in a smart contract. So you cannot bridge Lycom using this mechanism, right. You need to use some off chain trusted third party. And that's actually, you know, simply, it's a no with ethereum proof of stake or Solana proof of stake. Right? So Ethereum proof, pos, we know it works. There's first bridges kind of being designed and should be launching later this year. With Solana, it's still not quite clear, will it be efficient enough or not? And what I'm getting at is there is no universal lite client solution.
00:19:04.332 - 00:20:16.524, Speaker A: You're building a lite client for each single chain that you're connecting to, and each of them has its quirks, formatting issues and everything you need to take that into account. And one thing to really keep in mind that ZK does not solve this, zero knowledge proofs may make it cheaper, more efficient to do the verification, but you still need to build the custom circuits and proves and verifies for each single chain. And considering that if it's difficult to build without zero knowledge, you can assume that it's even more difficult to build a proven verifier. So we're kind of getting there, but it's a very technically challenging issue. However, I'm very certain that, like, line bridges will prevail. You have Polkadot, near Cosmos, already have them kind of between, like within their ecosystems, and first kind of cross chain bridges are going live for from them to ethereum later this year, I believe, and in five years, my bet is that between all these big networks, if you look at the biggest networks in terms of adoption, we will have lite climb bridges between them, and then essentially we can finally rely on code as security rather than trust the third parties. Thanks a lot, and I hope we have maybe a few seconds for questions.
00:20:16.524 - 00:20:19.164, Speaker A: Otherwise, catch me later. I'll be around.
00:20:40.084 - 00:21:19.264, Speaker B: I kind of for. I mean, interlay is nice technology, or nice idea, I would say, but I was surprised that it has so low TVL and. Yeah. So I would ask, what do you think it's the reason? And maybe if do you think that the reason could be that the customers need to put collateral if they want to breach something.
00:21:20.164 - 00:21:43.996, Speaker A: That's a very good question. So maybe, first of all, Intel A is a bitcoin focused product, right? So it builds the big decentralized bitcoin bridge like bridges. If you have like clients on both sides, you don't need collateral. It works because, you know, you have two smart contracts for bitcoin. That's where it gets tricky. And I mean, we can briefly take a look at this image here. So obviously, users don't put the collateral, it's the vault operators.
00:21:43.996 - 00:22:34.260, Speaker A: So it's like you as a user, if you have bitcoin, you don't need to put any collateral, you just bridge over for you, it looks like any other centralized bridge. It's the operators that need to put up collateral. And the challenge so far has been, obviously it's less capital efficient, there's a capital cost. And the way to solve this, and there is a blog actually, that we posted two days ago, the way to solve this is to use liquid staking assets as collateral or integrate the collateral into DFRAP protocols. So instead of competing with the base free risk, the risk free yield rates of Ethereum, proof of stake or lending, you actually use Q tokens or a tokens from Avecompan as collateral or liquids taking ETH as collateral, and then you're not competing anymore. And then anything these vaults earn on the bridge is on top. And then actually it allows you to scale the bridge much faster.
00:22:34.260 - 00:22:59.214, Speaker A: So this is essentially what we're doing on intely right now. And this will allow to get it much more collateral in the bridge and maybe one day get very close to like eigenless rest taking vision, right? So like what you can do is you like use somewhat like rest taking, and it works. And we've actually been doing that for last year. And it's, you know, while it's on like smaller networks, of course, the TVL is not so high, but apply this model to Ethereum and you can scale much, much faster.
00:23:00.834 - 00:23:03.054, Speaker B: Thank you so much for your thought.
00:23:03.474 - 00:23:05.554, Speaker A: Thanks. I think we're out of time.
