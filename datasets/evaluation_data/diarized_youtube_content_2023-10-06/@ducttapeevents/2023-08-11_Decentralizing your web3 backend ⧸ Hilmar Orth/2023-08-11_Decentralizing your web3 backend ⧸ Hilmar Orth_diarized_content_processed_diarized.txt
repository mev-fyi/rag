00:00:06.120 - 00:01:00.354, Speaker A: Great. Ok. We have microphone is working quite well. So thanks everyone for coming. Because we are highly concentrated crowd, we can make it very interactive. So if there are any questions in the middle or something, just try to interrupt me and ask me. What this talk is basically about is just I want to give you a quick overview about gelato, what we do, our mission, which is helping projects decentralize in their web3 backend, realizing the need for not only having smart contracts be run by a decentralized network like Ethereum, but also some other components that are quite necessary for your application to be used by users and you not becoming the central point of failure when you're actually the developers or the projects themselves building the applications.
00:01:00.354 - 00:01:29.464, Speaker A: Yeah. So if you have questions, definitely just interrupt me, we can talk about it. Let me just see if the clicker works. Yeah, it's this one. Cool. So we will very briefly go through sort of like backend architecture of web3 applications today. They sort of assume still this notion of not being on your own chain, like not on your own application specific chain.
00:01:29.464 - 00:02:22.300, Speaker A: I think they are certain things that get added if you go into that area as well, but it focuses more on, let's say if you deploy on Ethereum or polygon, for example, and then basically the services that we offer and how you can decentralize your backend using gelato, what we do, what we don't do, etcetera. Cool. So this is sort of, I think many people when they join the space and they, let's say on the hackathon like here, they think about how the application will look like from an architecture point of view. They got their front end, they got a couple of smart contracts and they think, okay, hey, the smart contracts will be my backend. And that's sort of it for most parts. I can write my business logic in there, I can get my data storage in there. But of course, we all know this isn't really everything that is needed.
00:02:22.300 - 00:03:24.448, Speaker A: And sophisticated applications look quite different to that. And there are several problems with smart contracts, or not problems, but limitations from smart contracts that make it so that you need a bunch of other things actually to build really scalable, sophisticated and user friendly web3 applications. And so the first one that we realized with gelato very early on is that, yeah, smart contracts are actually not that smart. They're quite dumb. They just store some business logic, they store some data, some states, but they don't really self execute their business logic, or they don't have this notion of event driven execution or recurring execution. Cron jobs, these type of things. And so for a lot of use cases, you need that sort of outside, you require an outside impulse to your smart contracts and actually to move data from a to b and to change state and to actually execute the business logic that you define within them.
00:03:24.448 - 00:04:29.079, Speaker A: And this is actually quite interesting because smart contracts, they're not smart. Then, of course, we all know blockchains are very isolated environments. You need that sort of deterministic nature of an EVM or any other sort of container machine. And that means that you can't have them talk to or it's not natively supported to talk to the outside world because you would introduce a bunch of uncertainty to the underlying blockchain. And so you need again, other middleware to actually enable you to communicate to, let's say a web two server or something else. Then we all know the user experience is terrible because we still require users to interact directly with the blockchain rather than sort of making it. So we have this abstraction layer and we interact on their behalf on the blockchain, which is sort of like letting users directly write in your database or something in web two world using some queries or whatever or calling APIs themselves, even though for a chrome extension, which sounds also weird.
00:04:29.079 - 00:05:35.008, Speaker A: And then of course data is really, really difficult to actually get, especially historical data for your applications. If you want to show what happened a year ago, making that interacting straight with a blockchain is very cumbersome and very inefficient. So how it turns out, there are probably some other things as well, but this is sort of like how it usually looks like if you build an application. These are like a bunch of things that you require in order to have a truly scalable user friendly with three applications in place. So first of all, you have to index the data of the blockchain, sort of in parallel to new blocks being created to then be able to, let's say, go back in time 100 days and see from 100 days to now what was the return that someone got by investing in a certain pool? Let's say this helps you solve this issue about data indexing and making it available. For that you of course need databases. Sometimes you can opt in for centralized ones.
00:05:35.008 - 00:06:54.334, Speaker A: Then there are of course IPFss or AoIs, which hope to be more decentralized. And then you have this notion of, ok, these smart contracts, they can't trigger themselves, right? You can't update their state programmatically based on certain events happening. And so for that you need job schedulers, you need event driven transaction services. And you combine this job scheduler aspect with transaction relaying, which is just a matter of, okay, how can I write to the blockchain in order to update itself? And you combine these together, and then you make your smart contracts actually smart and reactive and event driven. Then of course, you need off chain data fetching. To fetch data from off chain, you need a private key vault or some notion of someone sending transactions and signing transactions in order to actually update the state on chain. And then of course you want notifications and alerting because let's say you run an investment pool or a vehicle and something goes wrong, or there's a hack or something weird happens, there's a deep hack, right? You want to alert, you want to get alerted as a team, your customers should get alerted if something happens, like a transaction, an order was executed on their behalf, right? All these sort of notions of things you have to work and build in parallel to the underlying system, the underlying blockchain.
00:06:54.334 - 00:07:37.644, Speaker A: And this is just like an example. Arrakis is this decentralized market making service in web3. And this is sort of how like some of the functionalities they need to do in order to actually off chain, which is not supported by the smart contracts themselves, to actually build the applications in the right way, they have to do a bunch of computation of chain. They're building these very sophisticated strategies where they get the price data, volatility, volume. They run AI models to then define when to rebalance, basically liquidity and when to rebalance money in uniswap v three. And of course they need to execute these strategies automatically. They need to send the rebalance transactions and they need to send alerts to the team.
00:07:37.644 - 00:08:49.840, Speaker A: So the team knows when something is maybe not rebalancing correctly, they have to have emergency stops. If some sort of weird thing happens, they need to stop maybe and send a transaction to their smart contracts. And yeah, then of course on the UI they need to display to users, hey, what is actually the current price? What are the current prices? What are the ApRs that you as a customer have gotten over the past 30 days, let's say, when did you deposit? When did you withdraw? And this is just a lot of data, a lot of calculations that have to happen off chain in order to actually make it work. So a bunch of things. And yeah, there are of course a bunch of problems if you want to do all of that yourself, just from a managerial point of view, like the first ones, but then at the end, the notion of centralization. So of course you need to manage, scale and maintain a bunch of server resources, especially if you go multi chain, you basically have to replicate that and it goes linearly for every new chain you add that you want to support, especially if you go to more sort of exotic chains. Rpcs are still a huge issue.
00:08:49.840 - 00:09:58.304, Speaker A: You still need to, you can't really rely on a single provider, right? You need to have two, three redundant, two, three rpcs to have redundancy in order to actually connect or even run your own node to have like a stable connection to a certain, certain network. And even then it's not really guaranteed. And then you need to, maybe if you use other providers, you need to pay a bunch of them in different tokens and deposit them here and your money is fragmented. Of course there is this notion of private key storage, which is always very sensitive, but then if you do that all yourself, then, well, you basically become the central point of failure within your system. I think Michael from Liquite did a great talk two days ago about why decentralization matters. The goal is your application shouldn't be just be able to switch off if someone comes in or demands that you do something. But if you control all the data, if you control the system that actually sends transactions to updates the state, then basically the application will be made useless if you don't have a more decentralized system where it can withstand some sort of censorship attack.
00:09:58.304 - 00:10:41.498, Speaker A: Yeah, and this is what we try to do at gelato. We try to help you with that and build your smart contract web3 applications in a more reliable, user friendly and scalable way without trying to sacrifice device decentralization sensor resistance. This was like the high level goal. And for that we really have three main services that try to solve that or solve parts of the aspects. We don't do everything. There are other really cool middleware providers in the space that do a bunch of other really useful and interesting things. What we are really focusing on is the smart contract automation part helping you to do this event driven recurring transaction like writing to the blockchain system.
00:10:41.498 - 00:11:33.482, Speaker A: So whenever an event gets fired, you want to react to it and send a transaction. You want to check certain conditions off chain every minute or so. This is what our automation service helps you. Web three functions I think I had a talk on Friday about it. It's really about bringing that notion of write to the blockchain programmatically on your behalf, but using off chain computation and data like you used to just be able to define smart contracts and these smart contracts where you are like on chain sort of computation environments that would tell Gelato when to execute a transaction. But now with web3 functions, you can write like a typescript file off chain that you deploy to ipfs. Let's say you say to gelato nodes, please run that particular, basically back end sort of lambda function for me based on certain events happening or every minute.
00:11:33.482 - 00:12:30.514, Speaker A: And then if the logic is met, please execute. That's, for example, what Arrakis is using. If they are running strategies off chain, they're using these functions that are being called, let's say every time someone swaps in Uniswap, they will trigger this logic off chain which then sees, okay, can I rebalance my liquidity to now again create some spread in the market that I want to achieve? This is all based also on transaction relaying, which is just this notion of, hey, help me get transactions written to the blockchain. And next to that, of course, you still need a bunch of other things. You need data storage like an ipfs or arweave. You need indexing like the graph, for example. You can actually, on top of web3 functions, also add for more data integrity, stuff like pool based oracles, where you can actually pull data from oracles in and then run some logic on this and see if you want to send it transaction on chain to update the price actually.
00:12:30.514 - 00:13:09.044, Speaker A: And you can do it right. So it's really focused on this computation and then writing to the blockchain for you. And this is sort of like how it works. Gelato consists of a bunch of validator nodes, gelato nodes. These are right now White House parties that we onboard case by case. Some of them are, for example like staking facilities that I think also the biggest lido node operators, beware labs and some others. And what they do is they run this base client where they have to stake gel in order to get whitelisted and have to undergo some sort of whitelisting criteria.
00:13:09.044 - 00:13:43.886, Speaker A: And then they can choose that they want to run some of these services. They can run an automation service, just a transaction relaying service, or three function service. They all have different sort of, it's like a microservices based system. So you can sort of opt in what you want to do, but if you want to optimize and increase your, or maximize your revenue, you basically want to run all of them because it provides you with most work. And for all of this work that you run, you actually get paid as an auto operator. So there are two sort of fees in the gelato system. They depend also on the services.
00:13:43.886 - 00:14:45.660, Speaker A: There's one is the computation based fee and one is transaction based fee every time. Let's say you need to run a web3 function, which is like this lambda function off chain on behalf of a project you incur. Of course, some cpu costs, some memory, some RPC costs, and so on. And for that you basically charge the project. We built this whole payment system, like an off chain payment system, which is super efficient, where you deposit UCC on polygon and you can pay for computation, and you can pay for transaction on all chains, on Ethereum, on Linus, chain avalanche, arbitrage, whatever, just with depositing USDC on polygon, or you can deposit USC on arbitrum, and you can pay for transaction on optimism, right? So it's all handled and abstracted from you under the hood, with gelato basically fronting the network token always. And that money basically gets deducted for all users in certain intervals. So we push basically Merkle routes that define the state of everyone's balance on gelato every like half an hour or so to all the chains.
00:14:45.660 - 00:15:54.162, Speaker A: And this updates their cost, basically, that they incur with us. And yeah, if you, if you basically run this computation of chain, and then you might end up in sending a transaction on chain, and this is really what Jalato is about, then you actually sign a message, you send it to another party, which are executor node operators. And these executor node operators, they are just very sort of simple dumb parties. They just take transactions and they have to follow certain rules, like go via flashbots, go via this private gateway, or go there, and then they get the transaction mined on chain. The goal for us right now is to make it so that everyone in the world can run these executors to actually send the transactions on chains. And then the validator set is a bit harder to make completely permissionless, because there's some non deterministic nature to that and some data integrity that is important to uphold. So there, yeah, we are right now basically making this approach of whitelisting people, whitelisting individuals, companies and projects in the space that have reputation that will run this according to our spec.
00:15:54.162 - 00:16:41.788, Speaker A: But yeah, as soon as the transaction gets on chain, you hit the protocol. It does some checks like, hey, does this node have sufficient stake and stuff? Sends it to the target contract, which might be Makerdao, let's say, gets in mind to give you a bit of context for our automation service. Let's say you have these, let's say three customers that you probably know. How does yearn use it yearn uses our automate system to just harvest the rewards and fees of these vaults that they run. So they pull die from everyone. They put it into Aave or another protocol. They harvest some yield farming rewards there, and some fees, and then they sell them all in one batch every day or so and then recompound it into the pool.
00:16:41.788 - 00:17:19.418, Speaker A: And so your assets increase in value over time there. Mekadao has a bunch of in protocol related tasks they have to do. They have to change parameters based on votes and do a lot of cleanup, sell fees that are incurred and burned to maker. And these sort of things, all these operations that have to happen under the hood, that's what they use gelato for, to automate that. They actually build a very nice sort of protocol specific automation system where they can just plug into Gelato and just easily create all of these on chain. It's actually quite cool. And then optimism.
00:17:19.418 - 00:18:05.068, Speaker A: What they do use it for is they have to constantly push, they have to have these sequences, right? They have to constantly push transactions on chain, on ethereum, right, with all the data of the transactions that are being executed on their l two. And this means they're burning through a lot of ETH. I think the l two sort of sequences, they are burning through a lot of ETH. I think they're like the biggest ETH consumers on Ethereum, actually. And so these nodes that do that have to be constantly topped up and have to be constantly monitored to have sufficient ease to pay for transactions. And so what they have, they have to centralize smart contract. This is where they collect all the fees that they collect and all the ETH from their system.
00:18:05.068 - 00:18:55.934, Speaker A: And then they have gelato basically monitor the balances of all these nodes that send transactions. And then they send them to the nodes and top them up periodically in order to make sure their system isn't down and transactions get executed on chain. So this is like a, this is like a common use case there, topping up systems, monitoring this, and then they can actually send alerts when these transactions are sent and so on. Yeah. For transaction relaying, this is really more about UX. So this is really, how can you level up the UX on your application? It's very like you might have heard about the concept of account abstraction, right? Transaction relaying is a big part of it. And especially the problem here is not really like, how can I get my transaction included in the chain? You have concepts like use operations in ESC 4337 that you can use.
00:18:55.934 - 00:19:43.196, Speaker A: You can use traditional just transactions where you just send a transaction via the regular ESC 4437 is just a different mempool that you can use. So to say, to get transactions mined. You can also use the regular mempool or you can use flashbots. But it's really about the payment. So how do you pay for these transactions? And how can you as a project sponsor a transaction? How can users use tokens, let's say, that are in their nozosafe to send transactions and pay for transactions? And this is where this whole relay system comes together. It has a multi chain payment system, which works across many chains. And as a couple of use case, for example, the safe team, I think it was actually two days ago or three days ago, integrated Jatarelay on their UI.
00:19:43.196 - 00:20:10.804, Speaker A: So you can now, I think they are starting with nosis chain. You can now basically just, rather than having some signer of your nose safe, Multisig have to send the transaction. You can just click a button and then gelato will send it on your behalf. If all the signatures have been collected. So you don't, especially if you have saves on multiple chains. You don't always want to bridge your funds over to all the chains. To then have someone that can click the button and send a transaction.
00:20:10.804 - 00:20:28.636, Speaker A: Yeah, you can basically just click a button and have Gelato do it. And they will roll it out on all the other chains. Right. So at some point no one has to pay for transactions anymore. When sending transactions on the safe app. And we actually worked on a system right now they're sponsoring it. So the safe team is sponsoring all these transactions.
00:20:28.636 - 00:20:56.440, Speaker A: Nozos chain is quite cheap, so I think it's not breaking their bank. But we were actually working with them on a way where we can use the funds in your nozosafe to pay for the transaction. So you just have to collect the funds in your safe. And then you pay gelato in the transaction with that. Connext is basically doing the same. There is cross chain messaging protocol, or bridge. If you send a transaction on the home chain, they will send a transaction for you on the destination chain.
00:20:56.440 - 00:21:24.682, Speaker A: To bridge your assets, let's say. And actually use Gelato's relay system under the hood. So the only thing they have to do is they have to deal with the liquidity of having sufficient assets on chain a and chain b. And they have to deal with the security of the system to make sure that the data is correct. And the user is actually allowed to mint tokens here and burn them here. And for all the transaction part, they use our relay system. Then of course, you have gasless NFT drops.
00:21:24.682 - 00:22:12.830, Speaker A: Renault did one with us last year in December, for example. And this is just very cool, especially if you combine it with smart contract wallets and web3 auth to have really like a super seamless user experience. I demoed it in the workshop on Friday where you can literally just sign up with your gmail and then min some NFT and they pay for it, right? So it's really cool. Free functions is our newest system, right? And there I'm super excited about. And we just like rolled it all very recently. But there what we are seeing is that projects leverage it to basically what you can do is you can call off chain APIs and then run some computations and transactions based on that. And how projects are using it is before something like web3 functions.
00:22:12.830 - 00:23:13.270, Speaker A: If you wanted to, let's say periodically sell, let's say you accrue fees in your protocol and you want to sell them your native token to USDC. Let's say you had to build a smart contract that routes for sushiswap, uniswap, curve, whatever to always tap into liquidity. And now this whole routing you can just do off chain with one inch, call the one inch API and then just sends a transaction on chain and you basically save a ton of smart contracts. And this is actually something we see more and more the more they are all outsourcing logic that is not core to the protocol, to off chain and just do everything they can do off chain and then just send a transaction that includes a route and a payload on chain and just do it. And I think this is actually where this space is going. I think protocols might actually look like just like nozzle safes. And then you just do all the computation that you want to do off chain and then send a transaction.
00:23:13.270 - 00:24:07.074, Speaker A: And then you, if your application is nothing else than just enabling people to go from aave to compound and then swap on Uniswap and then go back in the past you had to build these smart contract systems that do that all, and these were then urine or whatever. But you can do all of this off chain and just send a transaction on chain and then do it in one transaction and have the funds be in the user safe. I think this is actually what we're seeing. And this will actually make a bunch of protocols not that interesting anymore. But yeah, other use cases other than one inch APIs are calling subgraphs, iterating through millions of nfts and then sending transactions to buy or sweep the floor and do something like that. So these are a bunch of use cases we see, but also prediction markers, dynamic nfts, etcetera. So yeah, this is the web, three functions, service and some use cases there.
00:24:07.074 - 00:25:18.394, Speaker A: Yeah. And what's the mission here for us over the long run is we tried with gelato to get as close as possible to Ethereum security and decentralization. You should not be able to stop, if you set up a task with Gelato, that should, for your protocol, update certain states periodically, you shouldn't be able to stop it. Like no one should be able to stop this process. And right now, I think we are not quite there yet, but we are looking into a lot of different ways of achieving this. One thing that actually goes live right now is the gel staking slashing. Not quite yet, but also this year where node operates up to stake, and so they have some crypto economic incentives to actually do what they're supposed to do, not only off chain contracts, then we're actually looking into having Ethereum nodes run gelato clients as well, through something like Eigenlayer, let's say, where we would open up the system to not only allow gel stakers to run nodes, but also e stakers basically.
00:25:18.394 - 00:26:02.174, Speaker A: And this would really enable us to get as close as possible to Ethereum's decentralization. So this is something we are discussing quite heavily. And then of course you have the whole notion of off CK proofs, especially if you deal with deterministic off chain computation that we are very much looking into. Though most of the cool stuff that developers are doing right now with gelato is with non deterministic stuff and off chain data that is very hard to ZKFI. So that's why I think this is still a bit out there in terms of actual real applications. Yeah, I think we're also like right on time. So this is some of our ecosystem map, a bunch of projects that we work with.
00:26:02.174 - 00:26:20.554, Speaker A: Maybe one of your projects is also on there. Yeah, and if you are building something and need something, like what we do, definitely reach out to us, let us know and yeah, I think that's already it. Thanks for coming here this morning, guys. And if you have questions, just shoot at me.
