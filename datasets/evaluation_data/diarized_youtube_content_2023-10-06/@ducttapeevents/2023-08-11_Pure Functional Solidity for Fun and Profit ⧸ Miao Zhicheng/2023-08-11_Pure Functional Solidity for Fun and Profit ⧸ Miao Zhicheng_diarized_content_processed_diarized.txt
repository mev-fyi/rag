00:00:15.400 - 00:01:02.418, Speaker A: Sorry, should I be here or she wants in the middle? Oh yeah, yeah. I can take a look at this. Yeah, okay. Yeah, thanks. Thanks for people coming here for the rather technical talk about pure functional solidity for fine profitability. I just wonder how many people actually familiar with the idea of functional programming, just so that I know. All right, great.
00:01:02.418 - 00:01:40.634, Speaker A: So let's just get going. So, the goal of this talk is to demonstrate the possibility of limited functional programming in solidity. And the second is, I use a new paradigm to build a simple super token step by step. So it's going to be involved, and I'll try to go write speed, but it's a bit short time. The third one is examples of using Satora to formally verify the code. I don't say it's complete down, but just exploring the possibilities. And last, if you are not familiar with functional programming, edits to make you interested in functional programming in general.
00:01:40.634 - 00:02:13.436, Speaker A: Let's start with today's task or idea. Let's reimagine what is a token. So let's have a new mental model of what is a token. Let's call it super token for now. So, token is like a bank containing a collection of accounts. That's how we know about even ERC 20 tokens. Each account has an owner representing the owner's wallet with a collection of, let's give an abstract name, monetary units.
00:02:13.436 - 00:02:46.820, Speaker A: Not to be confused with currency units, we're talking about just abstract units. This monetary unit provides a balance and a set of payment primitives. So let's have this mantle mode and move on and see what's about. What are payment primitives? Let's give four of them, and they have two dimensions. One is one to one transfer, one is instant versus constant flow. So we all familiar with one to one instance. That's ERC 20 transfer, right? That's one, that's one thing.
00:02:46.820 - 00:03:37.416, Speaker A: In that two by two boxes, there's one to end instant to all the accounts. There are a lot of ad hoc projects that are doing that, but let's say, can we generalize as sort of a payment primitive? So we want to one to end instant transfer. There is a one to one constant flow of money, often known as money streaming by people. And the last is the one to n constant flow. How about I distribute to any number of people as flow of money? So that's so called a generalized payment flow. Generalized payment primitives, okay. Furthermore, what come with this generalized payment primitives and the new mental model? It's also frictionless.
00:03:37.416 - 00:03:58.476, Speaker A: What does it mean? So it's real time. So it's a model that continuous in time. So it's in effect because blockchain move per block. So actually it is moved per block, but it's modeled continuous in time. So it's real time. True real time. The other is composable, so it can be chained with other payment primitives.
00:03:58.476 - 00:04:21.288, Speaker A: So the moment you receive the money is the moment you can use the money. So it's frictionless. In that sense. You don't need to wait for the money accumulate and you transfer as a batch later. So it's using at the same time you receive. So programmability also, right? So there's two programmability. One is onchain mechanism, so let's say include a callback.
00:04:21.288 - 00:04:50.584, Speaker A: So when you receive the money you act on it. One of the example, DRC 777, but you can generalize it. If you receive a flow of money, then you trigger a callback, does something that's kind of on chain mechanism. There are certain things you cannot do on chain, such as reacting on time. You can't do that on Evm yet. So when the certain time hits you do something, for example, so it's not doable. So you have to provide off chain incentive in that kind of cases.
00:04:50.584 - 00:05:32.190, Speaker A: A little bit more thoughts about super token before I move on. Actually about the main topic, which is functional programming is monetary units you can think of as coins, cards or notes in your wallets. So optionally you can think of Utxo based system or on chain representation of account could be complete bypass. It's no longer wallet, but just a bunch of nodes. You can do that in your UI instead. Let's now have this mental model in mind and let's build it using solidity. But we'll not do all the feature we've talked about so far.
00:05:32.190 - 00:05:59.664, Speaker A: We'll talk about only creating those payment primitives also for fun. Disclaimer this is not for production, just for fun. So first of all, let's define some types. There's something called custom types already in solidity. I don't know if you start to use it or not. What you can use for wrapping numerical types. And from 8.19
00:05:59.664 - 00:06:36.784, Speaker A: there is something called operator overloading also. So you can actually make it more convenient to use by using that. So let's see an example, right? So first of all, let's define something called time. In this case, time is int 32 unsigned, and you define two functions, pure functions for add and subtraction. And the last line is the 8.19 new feature you can do operator overloading where you say ok, you say the plus operator is using this function and the subtraction operator is using this function. So this is the new syntax available from 8.19.
00:06:36.784 - 00:07:03.434, Speaker A: So with this you can then actually use custom types in a more ergonomic way. It's just syntax sugar, but it's rather convenient. Let's define more types. So you need to have value, unlike the ERC 20 value this is assigned. Also there's a positive and negative, so it's int 256. Similarly, you define the add and sub and you apply the operator overloading. Also.
00:07:03.434 - 00:07:25.592, Speaker A: Now there's flow rate. In this case, let's say it's 128 bits instead, because otherwise it's going to overflow. There's only 256, otherwise, so very similar code than previous one. Let's move on quickly. Unit, we'll talk about what is unit later. It's really about distribution. Think of the dividends payments.
00:07:25.592 - 00:08:05.258, Speaker A: You need to have a share number in traditional how many shares you have. Microsoft share, Twilio share, whichever, and those are measured by something called unit. So this type gonna be handy later. All right. However, solidity doesn't have a operator overloading when you have two types that are different. So you kind of have to go back to the old way using a library. Say if you want to multiply the flow rate by time, you put that as a library function, and then you use kind of keyword using this library for the flow rate globally.
00:08:05.258 - 00:08:44.007, Speaker A: This way you can then have a operator by name of dot MAU. Right, so multiplication. So this is, you can't do mixed type, so unfortunately you have to do this. All right, so next step, let's define what is actually the thing we're talking about here. So we need some sort of data type for doing this very specific magical token. So there are three things, there's a time for that data structure. It's very abstract name, it's called a basic particle, we will see later y and there's value and there's a flow rate with three fields you can call.
00:08:44.007 - 00:09:25.864, Speaker A: Okay, before I go further, right, so there's something in the solidity about functional programming is that it's not really pure function. Why? Because it's similar to JavaScript or some of the language that when you have an input of, of the memory data type storage indicator, you can actually modify the input. So this is not really a pure function in that sense. If you know what is actually the pure function, you can modify the input, which is kind of bad for the functional programming perspective. So what you really need to do is do a clone. So whatever input you receive, you clone it. So you make sure that you don't modify the input.
00:09:25.864 - 00:09:48.280, Speaker A: So we keep that pattern throughout the code. So make it purer. I didn't check the time, so got to move on fairly quickly. So now we have a small data type. Now we need to calculate the balance from the data type. So it's very straightforward. It's one liner.
00:09:48.280 - 00:10:31.346, Speaker A: Say, okay, flow rate multiplied by the delta of the time. Then you plus something called a settled value. Then effectively you have a calculation of what's the balance of that data structure. So it's called RTB, a real time balance. Another very abstract function called settle is because it's a very important construct throughout the code in order to make sure that when you do operation between two data structure, they are synchronized with the same data structure, same time, you settle at the same time. Otherwise they're not compatible, let's say. Or another way to put it.
00:10:31.346 - 00:10:55.652, Speaker A: If they don't, if they are not settled at the same time, we cannot do operation on top of it. So let's call it settle. As you can see, there is, first operator is always clone, so you don't modify the input data. Or talking about functional programming, you always clone it in solidity. Unfortunately, you have to do that. So that makes a little bit boilerplate, but not too much. You clone the data, you calculate the real time balance.
00:10:55.652 - 00:11:27.040, Speaker A: It's the second line of the function. Calculate the balance, settle it, and put the time in the third field. Okay, now go to the third step. One of the things about a function of programming is that when you define a bunch of functions, but how do you know if those functions are correct? So you do now need to define some laws for it. So, laws, what are the laws? Right. So laws, like mathematical laws. Right.
00:11:27.040 - 00:11:56.608, Speaker A: So let's define something called a monoid. If you are in a functional program, you probably know what I'm talking about here, but it's actually a very simple concept. So it's the data structure we talked about. There has additional operator, let's call it x, or has some name called append, and satisfy certain laws. What are laws? Very simple. So there's empty elements multiplied by any number. Adding any data is equal to that data.
00:11:56.608 - 00:12:30.204, Speaker A: It's like zero plus x equal to x, or one multiplied by x equal to x. You can do different order left or right, so you can have left and right. So now we have a foundry based test, property based testing. Right. So you have any random input and you test if the law satisfies with any order you have, right? So multiply by a pen from the left or pen from the right, you get the same equality. So that's kind of function based testing. So the fuzzing to test this law, that's other way to test.
00:12:30.204 - 00:13:14.814, Speaker A: But this is one convenient way, another is associativity. So you a, multiply by b, multiply c equal to a, multiplied by b, multiply by c with different brackets, locations. And in the function is also very clear one liner. So you check if it gives the same data you do, kind of with different brackets applied to the data structure. So it's very easy to test. That's a common mathematical property for the data, for a lot of data, especially for data wants to append to each other. But the data we just defined also has its own laws, because we were talking about some domain specific stuff.
00:13:14.814 - 00:13:41.084, Speaker A: Something is kind of, there's a settle function. So if you settle twice, they should give the same result. So it's kind of Eden potence, let's call it. So actually, the fun fact I asked chatGbt, can chat GBT generate to the function if I just give the function name, actually generate. Pretty. Okay. It doesn't work fully, but it does understand the word and it understands what it means.
00:13:41.084 - 00:14:08.144, Speaker A: In principle. It's second formula. Just settle twice with the same time, is equal to settle only one time. So that's basically what about. This is not very interesting yet. The next interesting one is what actually about the constant flow of money. So you are actually then testing the real time balance is always the same, no matter how you settle it.
00:14:08.144 - 00:14:38.118, Speaker A: You have three timestamp here. Now, in the foundry based testing, you have t one, t two, t three, and you settle with a different order. Then you calculate the balance at the same time. They always equal. This way you can make sure that the function you define actually makes sense according to this law. So, foundry again provides a very nice facility for testing this very concise test. You just test the property and you put random inputs and it will give you 1000 data points, and it all works.
00:14:38.118 - 00:15:02.154, Speaker A: Then you're happy. Gonna speed around. Now, the number four step we talked about one, two, n. Also, how do we model the one to n? Now we need a new data type. Let's call it the pool of money. Look at the pie chart. Imagine, okay, I need a data structure can represent an ownership of the pool of money by different owners.
00:15:02.154 - 00:15:41.270, Speaker A: So let's say that each pool has members, and each member owes some amount of units, and anyone can distribute money through this pool of money to its members. And these distributions can be kind of instant or as flows and members share of the distribution are proportional to kind of a number of units relative to others. So this is a mental model of a data structure. Let's just define it. Okay, we have this kind of basic data structure we defined a few slides ago. Now we just wrap it into three. On the left side, two different new data structure.
00:15:41.270 - 00:16:18.886, Speaker A: So you say the pool has total units, and you contain a wrapped information. That wrapped particle is actually measured per unit. And then you have each member, each member, say, how many units I own and where is the settled number I have there? And what's my synchronized position of that? Now you have two data structure, and essentially done, you have now a one to n. How again, you need to define this function that we defined for the basic data structure. Now we define what's a real time balance for this function. It's also very, very concise. This is a kind of hallmark of functional programming.
00:16:18.886 - 00:16:55.254, Speaker A: So you just define pure functions, different data structure, different really, really small functions, and you gradually build things up and you'll get what you want. So, as you can see here, the real time balance function for that pool is essentially a few lines. You say, oh, I need to see the difference between the raptor one and the sync one. You multiply by the number of units this member has, and then you plus this so called settled value. Done. How do you come up with this formula? It takes a little bit time, but once you get it, it's short and it works. But how do you know it works? There's something called let's move on.
00:16:55.254 - 00:17:28.494, Speaker A: How do you know it works? Remember we talked about laws, right? So in order to know if it works, you basically test with the same law we talked about there to see if these new functions you created satisfy those laws. And the good news is they satisfy, right? So now, you know, you created something new, and they satisfy the same law, and they work. Right? That's the good news about that, why you should do functional programming, because then you just create data, create function, test with laws, and step by step and build things up. And. Yeah, I'm hand waving here. I just. Trust me, it worked.
00:17:28.494 - 00:17:40.734, Speaker A: So now. Not finished yet. Now we have data structure. Now we need to go to something. Finally, we're building the token. We're not there yet. Step five.
00:17:40.734 - 00:18:19.024, Speaker A: Five minutes. All right, so we need a shift and flow, right? So we need to shift the value from two parties from left to right, and we need flow money from left to right. So that's got two primitives. And in solidity I have to do twice this for different data structure. On the left side is two basic particles, on the right side is, on the left side is on the right side you have a basic particle is a and you have a pool, which is b. And as you can see, they are very, very similar functions. Looking the body of the function is very, very similar, almost identical.
00:18:19.024 - 00:18:49.994, Speaker A: It's not a coincidence. Let's see another example. Then you have a shift flow. They are almost the same, they are just different input types a and b. They are just slightly different type signature, but the structure of the function is almost identical, is something that in solidity they are going to be introducing. As far as I heard from last year, they're going to introduce something called generic programming. So that means when solidity have generic programming, I don't have to create the same function twice because they are essentially the same.
00:18:49.994 - 00:19:36.376, Speaker A: What do we need is generic programming so that I can write one function and they can work for both different types. Because you can just duck type it like in JavaScript, you don't care about the type of it, you just say, oh, if you have function, it works. So we need a similar thing kind of in solidity, then we don't need to create the function twice. Okay, so now we have laws for the new function. So in solidity, I want to show you one trick in foundry, rather solid and foundry. So I have a generator function. So it takes two functions as a pointer, as an input, and I can generate tests based on the operation one and operation two.
00:19:36.376 - 00:20:14.636, Speaker A: They are abstract function, sorry, they are function pointers. And this is kind of my template to generate more tests. What do I do then? I use that generator function to create four different set of test cases. I say it's a shifting, shifting flow, flow, flow, shift, shift, flow, all the combinations with a generator function. So this is something that you could also do in solidity with function pointers. And then you generate a bunch of the tests using that. Now where are we? Now we can do shift, we can do flow.
00:20:14.636 - 00:21:13.236, Speaker A: And if you shift from two basic data structure, you get transfer and you get one to one flow. And if you do the shift for the basic data structure and the pool, then you get one to n, both instant one and both stream one. As you can see, it's using functional programming to build stuff from bottom to up. You have basic data structure, you have a complex data structure, but same function, and you get all the function you need. So you get a functionality you need. Right, so, okay, now what? So we have a, we have a library, pure function library does a lot of things, but also at the same time, nothing because can't really change storage, can't do anything. So like what do we do now? Right, so let's call it the infamous m word.
00:21:13.236 - 00:22:11.488, Speaker A: If you know the function programming, that's kind of the most dreaded word because no one can explain it, right? So, but let's focus. What do we need? We need a reusable code that use the library we just created to build these tokens. I'm going to fast track, sorry if I have to jump a little bit. Let's go straight here. What we can do is we create abstract function, has a function that say I want to flow, I call these pure functions, and then I want actually modify the storage. That means I have to define a virtual function and then do all the tricks. So this how you create kind of reusable code for using those functional, pure functions, the implementation in the token.
00:22:11.488 - 00:22:51.016, Speaker A: So this is now the final code in the token flow. You will see, okay, I use, the only important part is almost in the end, like underscore do flow and then you have it. So there's another trick, unfortunately I can't show you here, but just see, this is actually solid code. You can see the last time you have the dot set. Sorry, this one, the last part is you can, this almost exotic code is like you can do shift and flow. It's like chain of function calls. So re implement the same token flow with a slightly different ergonomics, how you do it.
00:22:51.016 - 00:23:35.694, Speaker A: So what do we have achieved? So we now have a solidity pure function library for implementing the token. Now we have two variants of the interface that for reusing that code and why it matters. I'm going to jump real quick because people are waiting. What is function program? It's really about implement as much code as possible using data definitions, equation and logic formulas. To make code actually useful, we need to have the computation strategies stuff. So why it matters, I suggest you look at this paper called why functional program matters. It's really, really old paper, it's ten pager and it tells you why it really matters.
00:23:35.694 - 00:24:26.134, Speaker A: So the keyword is that it's for better debugging, reusability and less maintenance costs. The main point I want to actually bring out is that with this kind of way of building stuff, you can actually make the form of verification really easy. Then you can have the, in the sertora, you can have this, define the rule. You say this property we're using foundry to prove it always work. Not only with 1000 data samples, but also mathematically always works. There's another magic from Sertora is that it can inductively prove that something always works throughout the state of the program. I'm rushing a lot here, but thank you for listening.
