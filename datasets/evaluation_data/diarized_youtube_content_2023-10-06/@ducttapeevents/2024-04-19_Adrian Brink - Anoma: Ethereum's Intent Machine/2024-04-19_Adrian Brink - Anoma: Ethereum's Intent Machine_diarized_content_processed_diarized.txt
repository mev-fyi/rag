00:00:00.600 - 00:00:19.234, Speaker A: Perfect. Thank you very much. I'm actually very happy to be here. It's the first or one of the first times that, even though I'm based in Switzerland for the last couple of years, that I'm actually giving a talk at a local event here, which is. It's quite nice. So, yeah, welcome, everyone. Thank you very much for coming.
00:00:19.234 - 00:00:58.034, Speaker A: Today. I am just going to very briefly talk about Anoma Ethereum's intent machine. And really this is a talk about sort of what is the next level of abstraction that we're clearly going to be heading towards? What are intents? How do they work? How do you build abstractions on top of existing infrastructure? And so with this, let's start with a quick recap on what is a VM or what is a virtual machine? A virtual machine, it has an instruction set as a program counter. It has different layers of memory, and importantly, it runs programmed sequentially. Right. This is sort of every existing system, really. It's a VM.
00:00:58.034 - 00:01:17.230, Speaker A: When you think of, for example, Ethereum. Ethereum is a virtual machine, or it has a virtual machine. And so the predominant example in use right now is the ethereum virtual machine. But you can also think of something like the Solana VM or the neo VM. These are all virtual machines. And this is the predominant model. Or this is the.
00:01:17.230 - 00:02:01.186, Speaker A: Yeah, sort of pass bitcoin. This is the only model that exists currently in order to give programmability to developers and end users so quickly. What is an IAM on intent machine? It's. It takes a batch of intents, it computes possible valid state transitions, selects one of them according to some possible, to some criterions, and then updates a state system. Importantly, AVM, an IAM is an, is an abstraction on top of a vM. Um, so for example, in the case of anoma, is, uh, the anoma resource machine is an intent machine that is an abstraction on top of, um, the ethereum virtual machine. It allows you to do more things than just, um, execute transactions against the virtual machine.
00:02:01.186 - 00:02:32.768, Speaker A: And it allows users to describe things as intense as, as partial state transitions. Where I would like to go from state a to b, but I don't yet have the inverse, so I'm not yet settleable on chain. Right. Like when you think of this in terms of a very simple limit order example. One example here is I want to trade ETH for bitcoin, for example, or ETH for USDC, I guess, but I don't yet have the other leg of the trade. This is like ETH for USDC. Is not something I can currently settle on ethereum or in any virtual machine.
00:02:32.768 - 00:03:15.836, Speaker A: It is something that I need to have counterparty discovery done to, as well as distributed solving. And this is what the anomaly resource machine implements. This is what an intent machine implements, and a lot of anomalies. How do we build this infrastructure to give developers and users this new intent abstraction, which is really what most people have when they interact with these systems? And how do we allow this kind of new infrastructure to exist on top of ethereum? So anomaly is an interface, and this is very important. It is not an intermediary. And I will talk a little bit about distinctions here, but I think a lot of people tend to build intermediaries, not interfaces. But intermediaries are actors in a network.
00:03:15.836 - 00:03:56.944, Speaker A: Really think of them as they are people you can specifically interact with, for example, blockchains. They are mostly privileged. In almost all cases, actors or intermediaries are privileged. So they have some ability to extract rent, they have some by charging fees, for example, they have some ability to impose extra security constraints on YouTube. Like for example, most bridges currently in use, or what people would consider bridges are not really bridges. They are just intermediaries that sort of forward data on your behalf, but they for one, charge for it, and two, they add extra complexity into the security model. So yeah, for example, in Ethereum, many bridges really are just multisigs.
00:03:56.944 - 00:04:30.386, Speaker A: And really here these are intermediaries. And this can also be, even if you have a bridge that sort of tries to be a chain, these are still intermediaries. These are fundamental things that are add to the complexity stack, that add to the security stack. And actually a very good real life example is banks. Banks are fundamentally intermediaries that extract, rent or that charge for the services they offer and that you must consider in your trust model. So what is the other side of this though? Well, we have interfaces. Interfaces are just protocols.
00:04:30.386 - 00:04:50.882, Speaker A: They are a way to represent data, a way to represent compute or even storage semantics of an underlying machine. They are simply code. They are freely copied. Anyone can deploy them to different environments. They are just interfaces. Here, a very good real life example is TCP Ip. TCP IP is just an interface.
00:04:50.882 - 00:05:30.042, Speaker A: By using TCP IP doesn't mean you must all connect to the same oracle server or oracle database that does the routing for you. If that was the case, TCP IP would have never worked because no one would have wanted to connect to the single central server run by Oracle in order to sort of facilitate network traffic. Right? So TCP IP is a very good example of an actual interface in the real world. And the way anoma is structured is anoma is a declarative protocol, or anoma is a protocol for declarative intents, imperative ordering, compute and storage semantics of underlying machines. It is just an interface. You can take this to whatever specific system you want. It is just code.
00:05:30.042 - 00:06:02.958, Speaker A: It is freely copied. And this is really to say, there is no anoma chain which you must interact with. It's an open source protocol. If you don't like the specific deployment models that currently exist, you can take it and deploy your own version of the enormous protocol effectively. And this is very important because I think a lot of the reason why the Internet actually ended up working is because we had common standards that people could sort of build abstractions that people could build against. And really here, a normal is an interface, not an intermediary. Yeah.
00:06:02.958 - 00:06:50.188, Speaker A: Interface is not intermediaries. And whenever you interact with the system, you should think, are you interacting with an interface? Are you just interacting with free open source code? Or are you actually interacting with intermediaries? That sort of, you have to consider in your security stack. Yeah. So much universal intent machine for Ethereum. And when I say intents, a lot of people come up to me, well, aren't they just limit orders? And, well, limit orders are like, yes, that's true. Limit orders are very specific, kind of intense. Um, they are very smart, a hard coded kind of intent, where I want to trade a for b at some price, um, with a normalized universal intent machine.
00:06:50.188 - 00:07:10.230, Speaker A: Intents are just code. They are whatever you can describe and execute in code, they can be. I want to trade a for b. If the weather is nice in Paris, and if the weather is bad in Paris, I want to sell everything. Right. They can also be 5 hours, want to get together and contribute to a git coin funding round. This is really, intents are just arbitrary.
00:07:10.230 - 00:08:18.648, Speaker A: They are just code that is executed. One of the nice things for intents as well is intents can be free, because intents aren't actually posted on chain until they're executed. So this means that I can stream a new intent from my phone every half a second. And only the thing that actually gets soft when multiple intents are combined into a single transactions, does one of the intents get actually executed on chain? And maybe if you come from sort of the shared sequencing world, an intent machine with a consensus engine, which in the case something we're working on, it's called typhon or chimera chains, if you're familiar with heterogeneous, novel heterogeneous Paxos Typhon will be very familiar to you. It's sort of an extension of what's possible with PBFT intents in this model, given that, given typhon actually generalize shared sequencing and as a result, intense generalized rollups. When you think of what a roll up really is, a roll up is if intent to go from a to b. That is not executable yet on chain, because otherwise it pays the same compute cost.
00:08:18.648 - 00:08:55.742, Speaker A: So I find another guy that wants to go from b to c and c to d and so on. And then a roll up sequencer sort of takes all these things together, collapses the entire state update into one single thing. So we immediately jump from a to date, and then this gets posted somewhere. Really, like when you think of intents, intents generalize close to 90% of all the compute currently happening on every system in existence. Really, with the one caveat. If you just want to use bitcoin to do a transfer to someone else, transfers are not intense. That's like, if you just want to go to a store and buy milk for bitcoin or for ETH, that's actually a transaction.
00:08:55.742 - 00:09:37.298, Speaker A: You can immediately execute this on chain, um, for. So the very specific reason that the counterparty discovery and solving is done by you while standing physically in a store. This is not something where, like, I want to figure out who else can sell me milk. As soon as you do not know where to find the milk, you, you have an intent again. Uh, yeah. So what does this mean? Um, with an intent, machine builders can write dapps in terms of intents rather than transactions, rather than thinking, well, every one of my users will post something on. Chain builders can start thinking, well, how do I allow users to actually write or submit intents? How do I structure the solving of this computer around this? And so it just allows you to do more things.
00:09:37.298 - 00:10:17.184, Speaker A: You can always fall back to this more simple direct transaction model. And here really, it's a universal standard for intent and application formats. It does not constrain what kind of intents can be expressed. It is intents or whatever you'd want them to be. They are just code plus some state, right? Like an intent is effectively, I want to go from state a to state b, and here's a bunch of code, or a little bit of code, actually, because a lot of the compute happens off chain rather than on chain. Here's a little bit of code in order to verify whether my sort of predicate is valid, or like, here's my predicate function. Yes, intents and depths written with anoma can be ordered and solved and settled on ethereum.
00:10:17.184 - 00:10:51.124, Speaker A: And this is a very important point. Anoma does not impose a settlement layer, it just imposes an intent framework, or, sorry, it provides a generic universal intent framework that allows people to say, well, maybe I want to be settled on Ethereum mainchain. Maybe I want to be settled somewhere else in the ecosystem. This is really just to allow this kind of abstraction where users can specify directly in the intent what kind of security model they care about. Yes. So intents and tabs written with anomaly can be ordered and solved and settled on Ethereum or anywhere else. Really.
00:10:51.124 - 00:11:31.324, Speaker A: A user can say, well, I'd like to be settled on optimism. This depends on the user. Users get to freely pick what kind of security model they want their things to be settled in. Actually, where's my timer? Oh yeah, great. So what do intent centric dapps on Ethereum actually look like? And maybe let's go through some examples here. Um, oh, let's go first through why Anoma and what kind of affordances do you get with this? You get permissionless intent infrastructure. You do not have to ask for permission to use this kind of intent infrastructure.
00:11:31.324 - 00:12:22.754, Speaker A: Anoma really is topology agnostic, sort of the specific topology of how soft the networking stack, for example, is set up and who's going to connect to whom. This is again part of the specific deployment. And if you do not like a specific topology, you can deploy your own topology, or you can deploy your own system that has a slightly different topology. In that sense, really, intents are just, they're permissionless. You can pick whether you want to go to the topology A or topology B, you get intent level composability. And this actually has two aspects. Um, for one, you get intent level composability, which means, um, I can, for example, if I want to trade against Dex A and someone else wants to trade against Dex B, all of a sudden these intents become composable rather than application specific.
00:12:22.754 - 00:12:50.396, Speaker A: So you sort of unfragment a bunch of liquidity where currently, um, users have to very fundamentally pick where they want to be executed or who they want to trade against. With an intent. You can say things like, well, I actually don't care. I'm very happy to be settled on optimism. Arbitrary monotherm, I don't care, just give me the quickest and cheapest thing. It can also mean that I actually don't care which amm this gets executed against. I just care about quickest, cheapest settlement.
00:12:50.396 - 00:14:07.104, Speaker A: So rather than you get this kind of intent level composability across many different kind of dapps. And you also get intent machine composability, um, which effectively means a user can now treat a network of rollups as a single intent machine rather than many different rollups. Right? Like when you think of, uh, rather than picking the specific chain or roll up you want to interact with, you can rather interact with the intent machine and encode specify what kind of security models you care about. But this could also mean that, for example, I, as a user, I want to be settled, um, on Ethereum, and another guy wants to be settled on either optimism or ethereum, or arbitrary or ethereum. Um, now these things become composable and they become composable across the two dimensions of intent, um, intents themselves as well as intent machines. Um, you also get information flow control. And what does this actually mean? Well, we currently live in a world where lots of state lives in a single bit big blob on chain, effectively, right? We have lots of shared global, mutable state, all living in the center of the network, um, with intents, we actually, you sort of abstract the computer way where a lot of this kind of state can start living on edge devices where I don't have to, we don't have to keep track of my balance on chain.
00:14:07.104 - 00:14:46.872, Speaker A: I can rather publish a commitment to some balance that is sort of trusted with using a Zk proof. And then whenever I want to spend this balance, I can locally compose a proof that can shipped around and then settled somewhere. Right? Like this is very important. Information flow control, I think, is sort of the single biggest thing which is going to unlock a bunch of people, being able to say, well, I have a bunch of local state I don't want to reveal to the rest of the world. Maybe I just want to reveal to the five people I'm connected to, maybe I want to reveal to no one. Let me construct a local proof over my local data, and then have the intent sort of ship this to the rest of the network. So it still remains composable in the rest of the network.
00:14:46.872 - 00:15:24.330, Speaker A: Um, yeah, and it allows you to have heterogeneous trust. Um, it allows both users as well as developers to sort of pick the specific trust model that they care about. Um, and sort of one sort of nice example that I tend to use is, um, phones are a great example of this, of sort of the entire, um, cellular stack. It's an interface, not an intermediary. It allows me to take my phone from Switzerland, fly to south Korea, fly to the US. And my phone still works. I don't have to sort of reconfigure my phone.
00:15:24.330 - 00:16:06.554, Speaker A: I don't have to buy a new phone. This is kind of what we mean here by heterogeneous trust. It allows you as a user to use the applications on your phone to roam between different security models or different kind of application deployments across many different chains. And I think this is sort of the most powerful thing, actually, because I think fundamentally we're going to be heading to this world of a heterogeneous trust model where not everyone is going to want the same global security model. Many different people want different security models. It's very hard to sort of build a universal security model for 7 billion people on the planet. And if we do not fix this sort of at the abstraction level, using intents, people will have to fundamentally pick.
00:16:06.554 - 00:16:46.084, Speaker A: And then roaming between these different deployments or different security models is going to be very, very difficult for most people. Yes. So what kind of novel dapps can you actually build here on Ethereum that aren't possible to build right now? So these are just some examples. And at the next hackathon, feel free to explore a bunch of these things. I think they'd be very cool because for one, they're not financially, they're just interesting, as in it's not yet another defi thing. So public signal. It's effectively rather than supply side driven Kickstarter, where sort of people supply a bunch of products and maybe they get funding.
00:16:46.084 - 00:17:31.003, Speaker A: It's rather the inverse, where it's a demand driven thing, where many different users can say, well, I'd like to pay, I'd like to get this kind of thing or this kind of service, and they can make credible commitments so they can publish the intents that, yes, if there's another thousand people, all these intents are combinable and then end up funding the specific thing that those intents wanted. Right. So this is a way to invert rather from a supply side. Many projects or many things that actually aren't needed get proposed on the supply side. Rather we move away, move towards a demand side thing where the public can signal what they actually want, and then maybe someone picks it up and builds it. This is maybe also important to understand here. Intents do not guarantee settlement.
00:17:31.003 - 00:17:59.550, Speaker A: If you have an intent that no one wants to work on or that no one wants to interact with, you will not get settled. You can have an intent that says sell me bitcoin for a dollar. No one is going to fill this. This is very important. To understand intents are partial compute. And it's not necessarily the case that all computers is solvable. In this case, it could be that I'd like to get a rare rain flower from the Amazon, or rare flower from the Amazon.
00:17:59.550 - 00:18:28.214, Speaker A: Maybe this flower doesn't exist anymore. Right? Like some intents may fundamentally be not solvable. Another interesting idea which I really like is actually scale free money. It's the idea that everyone issues their own monies. It's like I have effectively my own monies. I can use it to pay people within my social network based on sort of actual trust metrics and intents make this fungible across many different people. I can pay someone else in the audience if they trust me, they can decide to accept this.
00:18:28.214 - 00:19:52.634, Speaker A: They can then spend this onwards using their own tokens. And rather than having to rely on a single issue of a specific currency, many different people can issue their own currencies. We can build an ecosystem where the actual sort of currency starts representing the actual sort of trust graph and economic activity happening, rather than there being an abstract currency concept that is independent of the actual specific topologies of an economy. Another example is multichat. This is effectively private encrypted slack or discord, where many different interfaces can exist on a completely permissionless protocol where intents just represent messages that are authored in ZK, for example, that are encrypted against specific public keys, where different interfaces can exist to represent different sort of different user behaviors, where in the end you can still get a canonical chain of messages because once in a while you can post an actual state route that reflects all the messages that were sent and delivered. Um, and yeah, you also have this idea of a promise graph, which is the ability for, which is actually something we're using internally. Um, it allows you to structure teams not around the teams themselves, but rather it allows teams to configure themselves around the actual work being done.
00:19:52.634 - 00:20:35.574, Speaker A: Um, so, like if multiple people need to work together even though they're not on the same team. So the promise graph system allows you to very cleanly represent that, uh, even though people are on different teams, they can still sort of work on the same graph like structure towards a common goal. Yes, if you like any of this, take a picture of this. There's a bunch of chatting going on with regards to what kind of new applications are actually possible outside of what everyone is currently doing in defi. Yes, maybe as a quick TLDR we are going to move away from or not away. This is actually the wrong way to think about it. We're moving from virtual machines to intent machines.
00:20:35.574 - 00:21:10.694, Speaker A: This is not to say that intent machines replace virtual machines. No, they're just fundamentally a new abstraction built on top of them. You should care about interfaces and be careful when you use intermediaries. What does a universal intent machine mean for Ethereum? Well, it gives us intent centric dapps. It gives us a standard for intents, and it gives us the ability to settle on Ethereum. These are the kind of affordances. And I spoke a lot about intent level composability because actually, I think intent level composability and information flow control are two of the biggest things, because we need information flow control for the real world to adopt any of this tech.
00:21:10.694 - 00:21:42.164, Speaker A: And we want to have more composability because we are currently just fracturing or fragmenting all liquidity, not only between specific dapps, but also across the ecosystem. Yeah, and then I spoke about some ideas for novel Dapps on Ethereum. So yeah, join the discussion. This is the link to the post that Chris wrote on ETH research a couple of days ago that really goes into a lot of detail on Noma is the universal intent machine for Ethereum. So feel free to check it out and yeah, thank you very much.
