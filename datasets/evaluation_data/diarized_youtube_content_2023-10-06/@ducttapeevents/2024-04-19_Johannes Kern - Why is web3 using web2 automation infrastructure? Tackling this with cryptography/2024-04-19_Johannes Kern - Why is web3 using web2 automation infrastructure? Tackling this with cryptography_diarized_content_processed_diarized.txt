00:00:01.120 - 00:00:13.414, Speaker A: Hi. Good morning, everyone. Thanks for showing up on this Saturday with such a beautiful day. You kind of stole my phrase here. I always say, hey, I'm Johannes, and I'm here to make web three suck less. So I'm just going to say that again. So, hi, I'm Johannes.
00:00:13.414 - 00:01:07.022, Speaker A: I'm the founder of Nerve Network, and I'm here to make web three suck less. If you could switch over to my presentation, that would be much appreciated. No worries. Today we'll be talking a bit about some problems you'll find in building decentralized applications. And what are different things you can do to solve that? We live right now in what we call a high value, low volume world. And what does that mean? If you look at, or I know that many of you are very, very deep in the technical side of web three. If you look at applications, they have to live in a world where you have very limited throughput and a relatively high cost per transaction.
00:01:07.022 - 00:02:06.516, Speaker A: And any application you would build needs to live under those limitations. That's why Defi has kind of became the killer app in web three, because Defi, what it basically is defined by is that each transaction inherently has a very, very large value and need, technically speaking, relatively few transactions to be able to make a living. And tooling has been built for this paradigm. However, now looking at new layer two, looking at things like Solana Polygon, I'm not going to throw dirt here because other people already did that. Change that. We move into a world where you suddenly have a lot of throughput you can use and a lot lower fees to do so. And that actually kind of aligns with this original vision of web three to build an Internet computer.
00:02:06.516 - 00:02:50.716, Speaker A: I know that some, you know, use that term themselves and have a lot of different things on chain and for this world to work. And here I'm talking about decentralized social media, gaming, Daos governance on chain governance and so on. This world requires new worlds, and that's what Narif is all about. That's what we're building now. Why is this so important? How does this play into making web threesoc less? If you look at the Dapp, that's how it looks like. We have a blockchain, which is your backend. On top of that blockchain, you have your smart contracts, which you could say is your business logic.
00:02:50.716 - 00:03:43.292, Speaker A: And then the only thing else you need is some kind of user interface. That's a theory. Practice looks quite a bit more like that, where you need a lot of surrounding things for the application to work, starting from off to oracles. You might want to send out notifications, you want to do stuff cross chain, you might want to do cron jobs and all those things. They cause some issues. They're not only very hard to build, they're even worse to maintain because you suddenly have a lot of moving parts which need to be working in sync. They're so bad that typically roughly 20% of total cost of running, and maybe some of you have actually real world experience with that, running their own systems.
00:03:43.292 - 00:04:25.094, Speaker A: A significant part of cost of running a Dapp is just in this maintenance of the surrounding parts. And from a more philosophical or high level perspective, what is even worse is platform risk. Now imagine you want to do a rebalancing once a week with your dapp. How would you do that? Okay, you would run a AWS server which triggers a transaction on that you have a private key. Oh shit. Now we have a private key for decentralized network on a centralized system which is controlled by me. So that very much goes against the core of this whole idea of having a decentralized app which is open, which is permissionless, and you're forced to do that because we're just not there from an infrastructure perspective.
00:04:25.094 - 00:05:22.830, Speaker A: And that is pretty much answering that first part of my task. Why is web three using web two for automations? Because there's just no way around that, because you need to rely on systems to be able to trigger it. Now what we're doing, and I'm just going to brush it because I don't want to do a product presentation here, we've built this platform which allows you to do all those different, different kind of things. Now how do we do that? And that's the beefy tech part, is we're running our own network, and this network is basically connected to all those different blockchains we're working with. Kernel is EVM based, and that network runs its own consensus mechanism. It's not a blockchain, it doesn't really have blocks. But what it does, it uses threshold cryptography.
00:05:22.830 - 00:06:26.614, Speaker A: Now how could we understand this? It's a bit like a dynamic multisig with ever changing keys and members. And if you look a bit on a higher level, here is each node which makes up the narrative network is one of the members of the multisig, and it has a stake to be able to be part of that. And only if all those members of this network agree that a certain outcome of an automation is correct, it can be written on chain. So the beauty of this is that the whole security relies on the specific chain you want to automate. If you want to run something on Polygon, it's on Polygon. If you run something on Ethereum, it's on Ethereum. So we're kind of basing our security on the security of the specific chain, but then have this multi sig, which is once again secured by the proof of stake, meaning you can't really game the system unless you have a lot of money.
00:06:26.614 - 00:07:17.984, Speaker A: That goes into discussions of how secure proof of stake is or how insecure proof of stake is. What time is it, actually? Beautiful. Now, I always like to build stuff, and I'll actually use the blackboard real quickly to show you what different stuff you can actually talk about. So do we have some chalk somewhere, actually, or do we only have the blackboard? Oh, there, I got it. Found it, found it, found it, found it. I haven't been at the university for a long time, so it's kind of a first for me when talking about automating stuff in the web three world. There's kind of three ways you can do it or you have to do it.
00:07:17.984 - 00:08:06.904, Speaker A: The first one is the most common one. That is web three to web two. Now, this is, in a sense, the simplest use case. This means you take some kind of trigger or data in the web three world, and you do something in the web two world with it. An example for this might be sending out notifications, and actually we're going to build that because it's the easiest one, which I can build in just five minutes here. So example here would be a notification. Okay? Second one, which is pretty powerful.
00:08:06.904 - 00:09:03.920, Speaker A: And that is actually where narrative really starts to play out, is web three to web three. Now, why is this relevant and what is an example here? Let's assume it is two big ones, cross chain stuff. You want to take certain things on one chain, let's say ethereum, mainnet, and you want to move that to another chain, like polygon, called a bridge. Or another example, and that is because smart connect execute itself even on the same chain. Let's assume you want to buy Ethan. Whenever Vitalik posts something on lens or farcaster, that's all on chain. So you can literally take that data on chain, listen to the event happening, and then directly, without having to go through any unsecure, centralized environment, trigger a transaction which buys some ETH or sells some ETH or does whatever you want.
00:09:03.920 - 00:09:57.124, Speaker A: That is web three to web three. Let's call it dynamic. It's a very bad word, social buying. I'm not sure, if I'm writing large enough, actually, but all right. And then the third one, and that's where it's getting a bit murky, is web two to web three, you could say this is known as oracles. The problem you have with this is that as long as you're in the web three world, everything is nice and tight and tidy. You can be more and more or less sure that the data you get is secure is correct.
00:09:57.124 - 00:11:02.404, Speaker A: Web two world, you don't have any of those guarantees. You have no idea if that data you're actually consuming right now is actually correct. But still you need to use it because that's this big oracle problem you have. So what you would need to do here is you want to, for example, have some error correction oracles and basically Nariv covers with the setup we have with the threshold cryptography, we cover all three of those use cases. And let's actually build one of the first one because it's really, really easy to do and you'll just kind of see immediately and think for yourself, what else would we be able to build with this? Ok, one more time. So what I have here, that's the Narif app, it says live, you can actually try it out yourself. I'll just show you a link afterwards.
00:11:02.404 - 00:11:44.164, Speaker A: So I'm going to log in here. Let's hope Internet works. Okay, so now here I'm on Narif. I also have a webhook site which is just a very simple tool which allows me to get kind of a place where I can collect webhooks or posts done on webhooks. So what we're going to do now is we're going to create a new workflow. The idea of this is we want to receive a notification whenever someone is doing the transaction with stablecoins, with Dai. So Dai tracker, you want to call it? Good.
00:11:44.164 - 00:12:18.980, Speaker A: What we want to do is we want to listen to the Dai contract and listen to the transfer events. So we select event trigger. Now we're going to Etherscan and we're getting the Dai smart contract, Dai stablecoin. So you can see here it's not a stable coin. We actually need the contract, the token contract. What you see here is all those transfers happening. So we're just copying this address and we're going back to Narif.
00:12:18.980 - 00:12:59.064, Speaker A: And now we say, hey, this is on Ethereum Mainnet and we are going to post or just paste this contract in here. It will automatically load the API. So the event we have here, we want this transfer which is whenever something sent, it's transferred. We have source and destination and Watt, which is kind of where it comes from, where it goes to, and how much it is. We could filter it here. We're not really going to do that. And the only thing we also need to do whenever we want to have that event, in this case, we want to send this.
00:12:59.064 - 00:13:15.424, Speaker A: That's what I'm saying. This is web three to web two. We want to send this to some kind of endpoint, centralized endpoint. So I'm going to select a web hook here. And in here, we don't do a post. And now I go to my webhook site. I have this unique URL.
00:13:15.424 - 00:13:51.320, Speaker A: So I'm going to copy. I'm just pasting it in here. And now what we want to have, we actually want to also know what kind of data we're sending. So we have the source, which basically pulls. So this is the source. As you can see, we have the destination, which is the DST from the smart contract from the ABI, and we have the watt, which is kind of the size, which we have here. Okay, cool.
00:13:51.320 - 00:14:08.230, Speaker A: That's all we need to do. We close the workflow. I mean, I could now add a lot of filters and, you know, funky stuff in here. I'm not going to do any of that because we don't have time. I'm publishing it now. This is basically going to be registered on chain. Add some polygon.
00:14:08.230 - 00:14:27.020, Speaker A: Actually, we register those things. It's going to cost me a bit of gas because I'm actually doing a state change. And that is it, really. So now we have to wait. And then what we should see happening is that we have. We will see requests flowing in here. Right.
00:14:27.020 - 00:14:48.844, Speaker A: Because you have that workflow and. Exactly. Now it's published. So we can go see the die tracker, which just did, which is actually now live. It hasn't been executed yet. Always takes a while until everything is registered and starts collecting data. But as soon as you see.
00:14:48.844 - 00:15:05.604, Speaker A: Now we see it. Okay. That's the first trigger. Right. That's the first notification it basically sent out. So you can see here that this was sent from. Sorry, from zero x B nine five c to zero x 171 with this amount.
00:15:05.604 - 00:15:33.282, Speaker A: And now, obviously, we could very easily just plop kind of a simple email service or something on top, which then does something consumes that webhook data. This is just like a short. And I think we're actually running out of time. Yeah. Nope, we're good. A short example of how you would then build that in the backend, it's all secured. Not that relevant in this case, to be honest, because we're not really doing any change on chain.
00:15:33.282 - 00:15:57.814, Speaker A: But imagine if we would do like web three to web three automation now. Then you want to be sure that no one can go and change your workflow with not being you. Cool. And basically like that. I would like to open up for questions and you can try it out yourself. This is done. Let me move that bit down.
00:15:57.814 - 00:16:42.198, Speaker A: So with this refcode e three, you will get whitelisted immediately. And so you can just start building if you have any interesting ideas. Questions? Yes, sorry, where is being applied? There's a lot of different things we see happening. One place would be maintenance tasks in the background that use case. I just actually showed the notification. One is the simplest one. There's a bunch of people using it for either projects or for their own purposes if they want to just see something happening on chain.
00:16:42.198 - 00:17:28.754, Speaker A: It's a very, very quick way to get notifications up and running. We also see that's quite an interesting use case I didn't actually have on my radar is for point systems. So where for example you have a dapp, which is hotel bookings, and then people book hotels. And then every two weeks or so you don't want to do that real time, but every two weeks people accrue loyalty points so they can automate loyalty points like this automatically. For example, they would want to issue those loyalty points on a different chain, which are cheaper. The actual transactions happen on Mainnet, but then the loyalty points are being accrued in polygon. That would be one example, which is I find quite fascinating because it's got nothing to do with DeFi, really.
00:17:33.754 - 00:17:38.334, Speaker B: We still have a couple of minutes we can take.
00:17:41.754 - 00:18:12.060, Speaker A: Thank you. Thanks for the presentation. And I have a question regarding this web three to web three flow. How do you take care of the gas fees? Okay, let me show you. So the gas fees is paid by, but the user, but by the network. So if I want to use it, I have to kind of like recharge my balance. It's a prepaid gas fees, if you will, which is nary if using those to cover the gas fees.
00:18:12.060 - 00:18:42.524, Speaker A: Really. Now if you're using this in a large application, you can also push it to the user, for example, depending how you want. It's a relayer really, because you could like, this is a smart contract call. So you could say, okay, I'm just going to basically put something on top of what I'm talking to the user and then whenever a user is doing a certain thing, a certain action which is not synchronous. So this is async. That is the beauty of it. This just accrues in this prepaid account.
00:18:42.524 - 00:19:22.434, Speaker A: Now, maybe one comment here on what we're thinking about here, because this is also quite relevant. Let's say if you want to buy, I made that example for dynamic social buying this money needs to come from somewhere. Right? Now, what you would do, you would pre charge it, preload it. But we're thinking hard. How can we build efficient integrations with something like safe, where you would just have a safe plugin which allows to pull the money so you don't have to move money all around. Exactly.
00:19:25.454 - 00:19:27.314, Speaker B: Any further questions?
00:19:31.934 - 00:20:14.952, Speaker A: And I guess you're going to be using that token for paying for all these transactions, right? How is that workflow going to go? Yes, no, no. The main use case for the token is actually the network stability. So it's proof of stake because we need that token. So you can be sure, or you have an economic incentive that the nodes which are participating don't have incentive to basically change the workflows, right? Yes, we can use the token to basically pay for the fees however we want. NarIf is really all about user experience or developer experience at the end. So we don't want you to have to hold a token to be able to use the network. We wanted to just be able to use the native token.
00:20:14.952 - 00:20:39.644, Speaker A: And what we're actually very recently released, before that you had to have, it's actually still the old version. You see here, you have to have all the different tokens of the networks. If you want to automate different stuff, you don't need to do that. So the network automatically rebalances and make sure there's enough tokens. And you only can have basically one currency in, logged in, and then you can still use all of the different networks.
00:20:43.924 - 00:20:50.004, Speaker B: And we came to the end of our talk, actually. Thank you very much. It was quite interesting.
00:20:50.164 - 00:21:12.194, Speaker A: Thank you very much for coming. Oh, one more thing, one more thing. I'm not Steve Jobs, but. So tonight we're hosting a little side event with Chronicle Labs. We're actually doing this thing called tacos with narrative around the world. It's not tacos today, but it's something really, really cool. So if you like schnitzel, you should really join.
00:21:12.194 - 00:21:19.334, Speaker A: There's a waitlist, but we're running a bit of a contest, so we still have a handful of spaces to give out. So see you all tonight.
