00:00:08.520 - 00:00:23.114, Speaker A: Hi everybody. Let's settle down. I hope you're enjoying this talk so far. So for the next one, please welcome Jose Ramirez from Palmyra with the talk enhancing aa with on chain hierarchies.
00:00:25.214 - 00:01:01.054, Speaker B: Hello everyone. Thanks for staying this talk. So the topic of the day is enhancing account abstraction. We don't change hierarchies. What's our new approach? But first we need to start thinking about how it arrived, account abstraction and smart accounts. So we're going to go delve into history of smart accounts, how you can optimize it, how you can customize it with modules, plugins, and then what's our approach for that? Just a quick intro about myself. I'm Jose, computer scientist, founder of Parmera.
00:01:01.054 - 00:01:48.530, Speaker B: Been in the crypto ecosystem since 2017, building different things. But most relevant, I was on the dark side a little bit, building a custody system for a bank, a crypto bank. So I'm quite familiar with Multisig since 2000, 1920, and now on Palmyra within the same topic. So let's talk about the smart account evolution. What do we need? Why do we need smart accounts? We want to customize the behavior of a transfer of anything that is besides the EOA. So the first one that came around was like Nosis safe. It was a smart contract that it was just a basic multisig.
00:01:48.530 - 00:02:51.466, Speaker B: That means that you have multiple signers that need to approve any transaction that going through the smart contract, right, but that was the main and the only feature, but it was enough for that time. Then there was the next version, like safe, the spinoff of Nocice. They generalized it a little bit, this smart contract that they created. And now you could attach other logic, other smart contract to your original multisig in order to have more customizable ways to do it. And that was enough, but still tied to the safe ecosystem to just one type of contract, one type of interfaces. So the next step was, okay, how everyone can benefit from this approach in like smart account, using smart accounts with custom ability. And that's where 437 arrived.
00:02:51.466 - 00:04:14.560, Speaker B: Like this standard that allows anyone that is building a smart account to just comply with a set of rules to, to have this generalized behavior on what we do. So now let's talk a little bit. I mentioned before a lot of time, how can you customize your smart account? And that's one of the main subject of this topic. Nocice was just a multisig save, has like the Multisig modules that are like smart contract that you attach to the safe, to smart contract that is going to bypass the multi SIG logic, it's going to be a roverite like they have guard that is basically a smart contract that is going to do pre checks and pro checks before the execution. And in 4.37 of course, following that same idea, you have some validation modules, some execution models and some hooks that are basically the equivalents of safe hubs, but in a standardized way. But what were the problems that the ecosystem was facing? Like first fragmentation, because every smart account protocol was having their own interfaces, was having their own way to create that vendor.
00:04:14.560 - 00:05:06.266, Speaker B: Login is tied to that, like how you can achieve interoperability. That's what 437 tried to achieve instead of mitigating security risk and also trust signaling. To which smart contracts do you want to attach to your smart account? But why do we really want smart accounts like basic use cases, right. We want to improve the better UX from any dapp. That means that you don't need to always sign with your UA. You can just attach like a key pass to your smart account and sign, I mean approve the transaction with your face id. You can set up like session keys so you can give a specific dapp the authorization to run and use the funds from your smart account.
00:05:06.266 - 00:05:57.724, Speaker B: You can create batch transactions on other side regarding also to gas, that is a constraint with UA's that you always need to have gas. In this case with smart accounts you can just, you don't need that. There is another entity that we're going to see later on that is in charge of paying for that cost and that is embedded within the smart contract. Customization and in terms of security. Also UIA is problematic, as we all know, you just need a private key to move everything. In this case with a smart account safe was using multisig. You have already can have a social recovery mechanism setting up different signers that can be your friends or other entities with attaching new contracts, new custom logic.
00:05:57.724 - 00:06:42.094, Speaker B: We can also use new cryptographic primitives that will be very useful for quantum resistance. Unlike hybrid custody setups. Basically the same thing as probably as a social recovery, but using an entity as a third party delegation, third party for your thing. And our operational part that's also more on the spending limits, role based as its control. And we're arriving a little bit on our main subject. That is like the hierarchical structures that we were focusing on. Let's have an overview of Fortran seven.
00:06:42.094 - 00:07:31.526, Speaker B: So the main components here are like the user is going to create a new set of transactions, a new type of transaction that is the user operations. There's going to be another roles that are the bundler that is grabbing all these user ops coming from different users and batching it and send it to the entry point. The entry point is the smart contract account where everything is going and is going to be processed. So there you have like concrete account. The paymaster, as I mentioned before, is the entity who is going to pay for the gas consumed by the transaction and the account itself. Let's see which types of modules. As we already mentioned before, they're three different types, but are attached to this 4.37
00:07:31.526 - 00:08:04.122, Speaker B: standard. So we had the validators like a validation logic that is running within the entry point. When every user operation goes, there is a validation step that you can add a module to make it custom. On the execution side, the same. After a validation step has been accepted and approved, you can enforce different execution flows. In this case you can. Maybe a good example is like intent based system.
00:08:04.122 - 00:08:52.974, Speaker B: When you want to have a token to a to c, you have to pass through two, three different steps before, and you can enforce this flow to be within the execution module and the hooks, that's mostly like post and execution checks before the transaction is going to be executed. Right. And now let's see how this is plugged within the fort structure seven in more detail. So here we have like the whole high overview about the account abstraction users sending the user ops, the bundling, submitting the transaction. And then the entry point of course is doing like the one step. One is like 437 validation. Then you can add the plugin.
00:08:52.974 - 00:09:33.874, Speaker B: So that's where the plugin is coming in. Second step, the paymaster is going to validate approved. Good. And within the third point, as you can see there, then there's going to be involved, the plugin for the hooks and execution that you can add this custom logic within the system to make the state change. And the last part, the paymaster. Okay, so this is like a high overview, ERC 437 and custom logic. But we need a standard, right? Because that logic that is presented in the schema has to be understood by the smart account implementation and also by the developers of the plugins.
00:09:33.874 - 00:10:36.526, Speaker B: So we need a specific interface for how we can install this module, this plugin, how we're going to manage that module, how is it going to be like this execution of the logic, of the custom logic being implemented within the smart account, and the same for the logic. So the question is here like is there a standard for customization? As a builder, you always want to follow standards. Why? I mean, it's quite easy. You want interoperability, you want to go where the marking is going, where the builders are going. In this case, I mean, in my case, it was quite difficult because there is two standards for custom logic. So it's like how do you decide which way to go? At the end, these two standards wants to do the same thing. It's just standardize the custom modules within the four tricktra seven standard, but they have different approaches in a really, really high level.
00:10:36.526 - 00:11:42.964, Speaker B: Like ERC 6900 wants to keep all the permissions within the module. And in the other side, ERC 7579, they want to give that permission control over the users. So it's two different ways to see the same problem, and we want to get into each of them to understand what's going on there. So as I mentioned before, ERC 6900, a permission system is embedded that has to be supported by the smart account with a specific rules and which kind of address do you want to interact, how do you need to interact between the smart account and the custom logic? So they have a configuration file, they have a manifest that both entities understand. Advantage is that the plugin functionality is very isolated. The disadvantage is you have less flexibility. Here the control is really over the developer or the plugin itself.
00:11:42.964 - 00:12:38.326, Speaker B: In the other side you have ARC 7579. That is like, as the name say, a minimal standard for modular smart accounts supported by quite a big community like biconomy, rhinestone, ether, spot, Zerodev, OKX. They are pushing this standard that has the benefits on making the user the main one who set the permissions. And with that you can make modules interoperable. They want to create this module store concept where as each plugin really doesn't need like any specific permission, they can all work together as App store the module. They have also the same module installation and a management system. They support all the different types that we've discussed before.
00:12:38.326 - 00:13:44.550, Speaker B: And also like just mention on another ERC 7484 that is about registry, how another entity can kind of vetted some specific smart accounts that you can install it. But now, okay, now we have the big overview about, okay, what's smart accounts? 4337, the different customers customization standards. We're going to talk about Palmyra, just a quick intro about we are an aggregation layer for on chain organizations. We are supporting web3 organizations to manage multiple saves, multiple smart accounts, the integrations and their automations. And in this case we're going to focus on the Palmera module. So the Palmyra module is a specific way to enhance smart accounts using hierarchies but before going deep into that, just a little question. Who here thinks that we went with ERC 16900? No one.
00:13:44.550 - 00:14:11.770, Speaker B: Okay. With ERC 7579? Okay, true. Good. And none. Nothing? Okay, I will say that everyone has said none. And you were right, we didn't go to any of those. Why? Because as a builder we started also a little early before the standards and we want adoption of the module.
00:14:11.770 - 00:14:50.094, Speaker B: And this right now is really tied to the safe ecosystem. Safe has like 10 million of safes deployed. They have the most TVl between all the chains. And as we're targeting more on chain organizations that are managing these multiple safe, we want them to use it. And we know that the switching cost for a safe user to like a new 437 smart account that has been just released like one year ago, it hasn't been fully battle tested by the time. It's very difficult. So we say, okay, we're going to just go with the safe standard safe module.
00:14:50.094 - 00:15:39.228, Speaker B: And now we're going to get deep into the functionalities. So basically our module is like a Unix file system for a smart account. You can think about it as creating a hierarchical tree. When you have like the root folder is your root safe or root smart account. And then the sub safe, subsmart accounts are going to be under the control of the root one on the parent one. This helps to maintain like a different compartmentalized hierarchical structure with also like role based access controls baked in. We're going to just mention like the couple of roles that we have embedded.
00:15:39.228 - 00:16:41.936, Speaker B: Like after talking with multiple organizations, one of the main roles is of course the root save. That is like the admin of the organization that has the power over the whole tree. Every sub safe is under control, the parent one, like the super safe. And in terms of what they can do, they can really execute. Anyone that is on the upper level can execute a transaction on behalf of the sub safe. So the design challenges about our model were like, first, from an organizational point of view, do we only want to give like one control, one entry point control for the organization, like one root account or multiple ones? Then in terms of, okay, organization, they have multiple departments that are managing multiple safe. Each safe can also kind of like just quit.
00:16:41.936 - 00:17:55.036, Speaker B: The organization can just be deleted from this hierarchical structure that is enforced by our module. And what's going to be the role assignment? And on the technical side, it was also more on the are we going to just have like the module as a singleton where all the mapping between the organization and their safe is going to be stored or we're going to create like more proxies, proxy based contract gas cost. Of course, we needed to be very mindful about how big this tree can get, right? If you have like ten levels with like four or five subs, can be a problem. We end up doing some testing and we can support like seven levels with an average of three sub saves per level. So that's quite good. And the logging for uninstalling and unplugging the module. So we went with multiple root structure to give any organization multiple ways, two or three or four root admins.
00:17:55.036 - 00:18:57.862, Speaker B: In this case, a very quick example can be within the about an entity, you will have like one root save for Aave, one root save for lens, and then under those you will have all the different groups that are within this organization. So that gives more flexibility for the organization to set it up their structure. But this also like, as we're talking about trees, we want to give flexibility within the organization of the tree system. And you can move some branches. Of course for this operation you need the approval of the admin account, the root safe. In this case you can delete a branch, but that's specifically for the rage quit example. As a sub branch, you cannot quit just because you want it.
00:18:57.862 - 00:20:09.564, Speaker B: You need approval of the admin and more specific use cases. For this hierarchical structure that I presented, like the DAO management, that's the one that I think we can really very easily visualize when organization have multiple departments, multiple groups, and each one will have his own smart account with his own set of signer and his own set, his own set of rules to execute anything, but with some control from the upper level. And in this case, we can attach another module to make that admin, to make the community part of the admin with some on chain voting mechanism. Another use case gans distribution. The same idea about distributing different treasuries amongst different groups, but within the control from the organization. In this case, you can also manage the expenses for each individual smart account. Take the control.
00:20:09.564 - 00:21:35.264, Speaker B: If someone is behaving or not doing what they see, they can just claw back the money. And that's quite important for these types of organizations because they don't want to just spend money without a real purpose and operation. And in terms of treasury management, this more on the operational part, okay, you can give some spending limits to some branches of your whole organization, or just a specific one, a specific different budget allocation. And another use case that it's a little different is more on the Devopsy side. Let's say when you can, for example, use this hierarchical tree to create multiple sub smart accounts and each one is going to be like the admin, like the deployer of your protocol smart account. So in this case you can keep this control within multiple saves to all the deployments that you're doing for your protocol in a much safer way than just being an EOA doing the deployment. I have the ownership of the smart contract and the polymera module v two that is being on.
00:21:35.264 - 00:21:53.694, Speaker B: We're going to start building it. Who thinks we're going to go again? 6901. Okay. 75792. Great. Three, none now. I think none is not the option.
00:21:53.694 - 00:23:21.298, Speaker B: Of course we're thinking to adopt the 759 standard as it will give us more flexibility, interoperability, and really is what we think. All the ecosystem is a little bit pushing and is gaining more traction with more players, more support, and also just saif they release an adapter for that. I mean, safe and Rhinestone, that is going to be very helpful to make all the legacy code that is there with an adapter, make it compatible. And in our case that will solve like lots of interoperability problems. So the conclusions for this vast topic, we think with all the new use cases coming on, I think modules and plugins are going to be the origin for new adopters because you make it everything easier in terms of the interaction within the contracts. But at the same time, legacy sometimes prevail because of the battle tested of the system. That's what makes safe, like the most used smart accounts in terms of TVL because it's been there for four years, no hack.
00:23:21.298 - 00:24:00.434, Speaker B: So yeah, you can put like millions on there with the safety and the challenges, of course, like as we see every day, which is standard, is going to prevail. And as I talked before about the adapter development makes all these different points much more easier to accept. So that's all for it. Thanks for listening. That's the Palmyradao Twitter and my Twitter, in case you want to follow us and keep the updates.
00:24:01.014 - 00:24:07.554, Speaker A: Thank you very much, Joseph, for that exciting talk. I know we've got some burning question. Who wants to go first?
00:24:11.174 - 00:24:12.126, Speaker B: No questions.
00:24:12.230 - 00:24:14.702, Speaker A: No questions. Okay, thank you very much.
00:24:14.838 - 00:24:15.454, Speaker B: All right, thank you.
