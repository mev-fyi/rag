00:00:00.360 - 00:00:47.652, Speaker A: So good morning. I am Ivo and I'm the CEO and co founder of Unbire Wallet, and I'm going to help you demystify all the account obstruction ercs, eips rips. We're not going to go ahead and dive into what any of those letters mean. But all that matters is that those are proposals to improve Ethereum and EVM ecosystems, and there is millions of them regarding account obstruction and a quick agenda of what we're going to go through. First of all, the big picture stuff. So what are all the account obstruction improvement proposals? Then we're going to go into the biggest one. ERC 4337 biggest one.
00:00:47.652 - 00:01:58.144, Speaker A: When I say biggest one, I mean biggest one in terms of mind share and in terms of how it captured, how it captured our community and how it reignited the vision of account obstruction. We're gonna go into what it is not, and then we are gonna do a deep dive into native account obstruction. What's the state, how are we doing in terms of native account abstraction in the EVM ecosystem and on Ethereum? And then finally we're gonna cover smart contract signatures and a few other eips that more or less help the account abstraction ecosystem, but are not directly related to account abstraction. So who are we? When I say we? This presentation is brought to you by Ambire. In general, it has been a team effort. I already presented myself, but what are my credentials? Well, Ambire spun off of ADX and Addix was one of the first projects on Ethereum to ever deploy a smart contract wallet back in 2019. And back then, the only other smart contract wallets were parity and agnosis safe, which later turned into safe, obviously extremely successful.
00:01:58.144 - 00:02:51.964, Speaker A: We also rolled out one of the first consumer centric account abstraction wallets at the end of 2021, the Ambire wallet. And it's currently a web wallet, but we're working on an extension. We won a grant from the Ethereum foundation for building account recovery through email. So, like being able to log into your Ethereum wallet with an email and a password, but while keeping a fully self custodial nature of the wallet. And finally, we created ERC 6492, which I'm going to go into later. So why is account abstraction valuable? I guess most of you already know this, but let's have a quick summary of everything so you can get onboarded much easily because you can eliminate the seed phrase. And another big point of onboarding is paying gas with non natives and paying gas with tokens.
00:02:51.964 - 00:03:43.694, Speaker A: Because usually we think of this as a feature, but it's not so much as a feature as it is an ability to onboard users, because one of the main points of friction for new users is having to get ETH or whatever the native currency of the robot is. So this friction of having to get ETH makes people sign on to centralized exchanges, and we don't want that because people end up sticking to centralized exchanges. We also don't want it because it really doxes your wallet. So for example, if I make a new wallet and I need ETH for gas, I'm going to ask one of my friends to send me some eat for gas. And then I'm kind of doxed because I'm creating this relation between the two wallets. So that's not ideal. Of course we have account recovery, like what Argent did with social recovery, and a bunch of other account recovery mechanisms, as I mentioned earlier, the one we won a grant for, the one with email.
00:03:43.694 - 00:05:00.874, Speaker A: And of course you have alternative signature algorithms, which is also hugely valuable because you can validate passkeys from iOS devices, you can validate web authentication from web browsers, you can use secure enclaves that are already on the devices that we have. So why reinvent the wheel? Why use different signature algorithms when we already have secure enclaves on our devices? And we build sort of a demo for all of those? And of course we have to ask ourselves, when is account abstraction coming? We all know that that's a painful issue. And we already know that there's a lot of wallets on Mainnet already that implement a ton of account abstraction features. Argent was one of the first ones back in 2018, they launched and they launched on Ethereum. So even back then we had a count of three. But the purpose of all those Eaps, ERCs and et cetera is to make account abstraction more accessible and to allow it to get adopted quicker and basically to give developers better tools to build it faster and to basically make it usable. And this is a huge bubble of the entire account abstraction space.
00:05:00.874 - 00:05:41.224, Speaker A: And we have EAP 29 38, which was one of the original account abstraction proposals back in 2020. It wasn't the first one, but it then evolved into this rip, which takes the best from year c 4337 and makes it native, which is amazing. We're going to talk about it later. But there are two key takeaways from this slide. So one of the key takeaways is that none of those are competing. And that's really important because a lot of times when we think about account abstraction, we think about this ERC versus that ERC. But in reality, that's just not true.
00:05:41.224 - 00:06:39.082, Speaker A: You have all of those ercs which are mostly complementary to each other. Almost none of them are competing. And sort of, they all have the same goal, but they all tackle the problems, tackle different problems, or the same problem from a different direction in such a way that they can work together. And none of those are conflicting. And the other takeaway is that we need many aspects of account abstraction to work, to make it work, basically, the other key takeaway here is that we have a key intersection between a few eips where we need to be. So for example, in order to have account obstruction right now in a pretty reasonable way, and to make it developer friendly, we need ERC 4337. But then to make it truly native, and to make it cheap in terms of gas, we need rip 7560.
00:06:39.082 - 00:07:21.732, Speaker A: And then in order to get signatures to work, we need the ercs on the bottom. So we need everything together in order to get account abstraction going. So yeah, none of those are competing. They are competing, however, for attention and for memes, as you might know from Twitter. So a quick recap of 4337 and the revolution of 4337, really in its essence, is the fact that it doesn't require any consensus level changes. And this is something that the Ethereum community kind of realized, that if you want to make account abstraction work, you need to make it as least disruptive as possible. Because previous ercs arguably failed because they required way too much changes.
00:07:21.732 - 00:08:17.648, Speaker A: And on a main net that's already live and it already has tons of dapps deployed, and every small change in the EVM can bring security issues, that's kind of an issue. So you cannot simply change the EVM, you need to avoid this as much as possible. And ERC 4337 is the first account obstruction ERC to be entirely on the application level. So another question that people kind of get and that people sort of don't understand is, is it a standard? And the answer is really complicated. You can think of it as a standard for relayers because as I said, we had account obstruction before it. And account obstruction was largely built on these proprietary relayers that you send a transaction like object, which is also signed using some signature algorithm to that relayer. And this relayer used a new way under the hood to make the transaction confirmed on Mainnet.
00:08:17.648 - 00:09:05.786, Speaker A: And the way that ERC 4337 changes that is, it allows anyone to be this relayer in the form of a bundler, and it standardizes the communication between the wallet and the entity that's relaying this transaction to the actual blockchain. So that's what it does. It allows a network of bondwares and as a result a public mempool, and as a result, account obstruction kind of gets the same benefits as native AOA transactions. So what ERC 4337 is not, it's not a change in the Ethereum protocol. It does nothing to change the actual Ethereum protocol. It doesn't add new features or functionality to smart accounts. Even though a lot of the marketing material for 423.7
00:09:05.786 - 00:09:28.134, Speaker A: was related to those features that it's going to bring to Mainnet. It doesn't actually bring those features to Mainnet. It just lets developers build you them easier, build them better. And that's really valuable in itself. It's amazingly valuable. But it doesn't add features, right? So it's not native AA. We covered that, and it doesn't actually do anything to standardize accounts.
00:09:28.134 - 00:10:10.962, Speaker A: This is an interesting point that a lot of people have been understanding wrong. It doesn't standardize accounts in any way, it just lets bundlers and wallets talk to each other. So that's an interesting point, because accounts can still have different interfaces between different implementations. Like for example, safe can have one interface and umbire can have a totally different interface. And then finally there is nothing cross chain or intents related to your C 4337. And I'm only mentioning this, it might sound weird because I'm only mentioning it because I've heard some people make this big confused by that point and think that EFC 4337 is somehow related to intents. It does help account obstruction happen.
00:10:10.962 - 00:10:49.118, Speaker A: So it does help intents happen, because account obstruction is kind of an important step to intents. But it doesn't. It's not related to intents directly. So what are the benefits? So the biggest benefit, although that's a double edged sword, is that it inspired developers to fall in love with account obstruction. Again, when I say a double edged sword, I tweeted about this recently. It's about the fact that many people were hyped from ERC 4337. And then when adoption didn't happen super quickly, as everyone expects in crypto, people sort of became disillusioned with the count obstruction and thought that something must be wrong with it, which isn't the case.
00:10:49.118 - 00:11:18.684, Speaker A: Obviously. Good things take time, but this hype train that it created sort of backfired a bit. In general, it's really good because everyone now is thinking about account abstraction. And like a couple of years ago, Dapps never thought that accounts that users can be contracts. And now dapps know very well that users can be contracts. So they built with that in mind. As I said, there is no consensus level changes, which helps a lot for everything to get done to get implemented.
00:11:18.684 - 00:12:13.686, Speaker A: And the biggest point that ERC 4337 helped with is that wallets do not need to spend time to develop these proprietary and fragile relayers, which took a lot of effort to happen, basically. And obviously we have a lot of improvements in terms of censorship resistance, which is what we want. And it's standardized smart account user operations, which is, as I said, the structure of data, which is similar to EOA transaction. And finally, we have paymasters, which is really a huge part of the standard, which is a lot of people think that paymasters are for sponsoring gas. They're not necessarily for sponsoring us in someone else pays for your gas. They are for allowing gas payments to happen in many different ways. It could be sponsored by someone, it could be sponsored by the DApp, it could even be sponsored by the network in a row up.
00:12:13.686 - 00:12:57.366, Speaker A: Or it could just be paid by the user, but paid in your c 20 token, or paid in even with an NFT, let's say, or paid with a deposit that you made earlier on. So, yeah, when people talk about sponsoring, they don't mean that someone else is paying it. They mean that the paymaster gives the if and then the user gives some other form of value to the paymaster. It could be just the network effect from using the Dapp. And so let's switch the topics a bit and go to native account obstruction. And there was already a talk by argent about why native account abstraction is important. And we totally supported this, but it's going to take a while for it to happen on Ethereum.
00:12:57.366 - 00:13:58.710, Speaker A: But something interesting that you may have known, or may have not known, is that Ethereum was actually meant to launch with native account abstraction. Who here knew that? Anyone? Okay, so Ethereum was meant to launch with account abstraction, but due to time constraints, they didn't ship it. And there's actually a piece of text from the original white paper here saying that there's two different account types. One of them is new way and the other one is a contract. Out of context, it's a bit tough to understand this, but basically Ethereum also meant to have contract accounts be able to initiate transactions themselves. This is the actual account obstruction feature that never happened for contracts to be able to initiate transactions. So what's the brief history? So after Ethereum, sort of when this was in this rush and didn't ship this feature Vitalik immediately started drafting a few eips on account abstraction.
00:13:58.710 - 00:15:12.804, Speaker A: The first one was 86, and that one didn't happen, so it was kind of rewritten to 208. And back then the point was to obstruct the signature and nonce checks. So this would allow for contracts to initiate transactions. But it isn't quite the same as the native account abstraction ercs that we have now. And then Vitalik wrote a really good blog post on the challenges behind native account obstruction. And generally a lot of this was related to the current challenge that ERC 437 has, which is how to make sure that transactions cannot be arbitrarily invalidated, right? Because like for example, imagine that there is 1000 smart contract transactions in the mempool, but unlike EOA transactions, their validity doesn't only depend on the signatures, it could depend on some contract logic, right? So like changing one storage slot in one contract can invalidate all of those thousand transactions, like in a flash, in a second. So the problem with this is that the network becomes really exposed to spam issues, and it's possible to just like spam millions and millions of transactions, which would be considered valid in the mempool, but like in a flash, they could be invalidated without any way to predict this.
00:15:12.804 - 00:16:36.304, Speaker A: So ERC 4337 solves this by introducing some storage constraints and all of the account obstruction eips. Ercs have some sort of mechanism for this. And then in 2020 there was a more mature account obstruction proposal, but that didn't happen due to requiring a lot of consensus changes and having a lot of security edge cases that we couldn't possibly address on Mainnet. And then we had EAP 3074, which is really interesting, and ERP, EAC EIP, sorry, 500 three, which is complementary to this, and those two are fully, are totally different from the previous ones because they do not introduce account obstruction. They introduce an ability to convert eoas to contracts, which is extremely helpful for account obstruction. But it isn't account obstruction, right? So it doesn't allow us, it doesn't allow contracts to initiate transactions, but it does allow existing wallets on the main net, existing key aways to convert to account abstraction, which is really cool, and it will be amazing for adoption. And those eips kind of died for a second, but they got revived recently, and they got revived in a way that's really funny, by having this meme war against 4337, which isn't even technically accurate, right? Because there are not competing standards.
00:16:36.304 - 00:17:38.160, Speaker A: But the fact that it got memed a lot means that this got revived and then finally RIP 7560, which is absolutely amazing in my personal opinion, because it combines all the learnings from everything that happened before, including a lot of valuable learnings and a lot of valuable development from 4337, but makes it native, makes it enshrined into the protocol. And why is this important? It's important because it gives us the best of all worlds and it gives us cheap gas for account obstruction, for account abstraction transactions. Because at the moment for 4337, we have an overhead of like 60,000 gas, which we cannot get rid of. It's absolutely impossible. And like for native, like just for sending ETH for native transactions, this would make it four times more expensive. And this rip solves this. So I meant to write something about Vitaliko on the bottom, but I forgot what it is and I guess it got stuck in a draft.
00:17:38.160 - 00:18:14.142, Speaker A: So anyway, so are any of those live? Absolutely not, none of them. But we're working on it. And the last one has a really big chance of becoming Clive very soon in a row up. I'm not really sure which one, but it's definitely going to happen. And there's already an implementation in Go Ethereum, which is the furthest any of those eips has ever made it. And a really important point here that I already mentioned, those two can absolutely coexist. One of them is meant, as I said, for converting QA to smart accounts, and the other one is meant for relaying transactions.
00:18:14.142 - 00:19:13.234, Speaker A: Absolutely no competition, but there is a competition for attention. And finally, one of the biggest topics is signatures. So basically a lot of people think contracts cannot sign messages, and that's technically accurate. However, contracts can implement logic that states which signature is correct. So how this looks, imagine that your wallet is a contract, which is obviously the case with account obstruction. And for this smart account, a valid signature would be the signature, the elliptic curve signature, for which there is an authorized signer with this contract. So the contract would keep a mapping of the valid keys, and then if you have signed with a key which is considered valid by the contract, then it's considered a valid signature for this contract and by extension for this account.
00:19:13.234 - 00:19:51.908, Speaker A: So yeah, this is how this looks in practice. And basically this is ERC 1271, the standard signature validation method for contracts. This is how the interface looks like. You can see it's almost the same as my example. I've actually flipped signature and hash, but that doesn't matter here. And another peculiarity of the standard is that it doesn't return the boolean, but it returns a magic value. And the reason for this is that if you're validating a signature and it accidentally goes into a fallback function that for some reason it happens to return true or one, then the signature would get accidentally validated.
00:19:51.908 - 00:20:25.688, Speaker A: And that's why you don't want this. You want to return a magic value, which there is a very low chance of a contract just returning randomly. Is this a solution for contract signatures? Unfortunately, it turns out it's not. After many years it's still not adopted. And it's great actually, the adoption issue has been an issue of mostly convincing Dapps, but there is one big flaw with it. And the flaw is that you cannot validate signatures for contracts which are not deployed yet. That's a great technique that many account abstraction wallets did.
00:20:25.688 - 00:21:20.300, Speaker A: They don't deploy your account contract until you've done your first transaction, which is hugely valuable because it eliminates one step from the process and it eliminates one fee payment. And how is this solved? With ERC 6492, universal signature verification. So this is an ERC that extends 1271. It doesn't compete with it, it completely extends it, and it allows for very easy verification of any type of signature, including traditional e away signature, but also to verify a signature for a contract that isn't deployed yet. And that works basically in a magic way through an ETH code which deploys a contract, but it doesn't really deploy it because it's off chain. It's a bit crazy how it works. If you want to learn more about it, just read the ERC.
00:21:20.300 - 00:21:54.842, Speaker A: It's really cool. And a lot of ercs have been replicating this magic deploy less method of calling contracts. And yeah, this ERC can verify any signature and it can also verify signatures for contracts that are not deployed yet. Therefore solving a big ux battle between counterfactual deployment and being able to verify signatures. So a quick rundown of the satellite ercs. And when I say satellite, I mean things that are not strictly account obstruction, but help account abstraction a lot. And the first one is modular accounts.
00:21:54.842 - 00:22:33.118, Speaker A: There's been two ercs. Some of them are supported by safe and Zerodev. And I think those are the first case of competing QRCs that I have on my presentation. And then you have the wallet function call. And this is really cool because it enables Dapps to tell wallets to make you sign multiple actions at the same time, which is great for eliminating ERC 20 approvals. We all know how bad approvals are and this ERC enables the ability to do exact approvals every time without having to do an actual additional signature. And exact approvals are amazing because they cancel out automatically after you do the operation.
00:22:33.118 - 00:23:36.248, Speaker A: So like imagine you do a swap, you do a swap for 100 USDT, and then the approval is only for 100 USDT and it doesn't require an extra signature, so you don't really notice. And there's no open approvals left to the Dapps. So there is no security risks in this. It eliminates a huge amount of security issues, as you all know. And then we have precompile for the NIST curve, which is a cryptographic curve that you have on iPhones, you have on multiple devices, and you have diamond contracts which allow building different sort of upgradeable and flexible accounts. And finally, we have one thing which I think the number is not correct, but it's something that the wallet Connect team is also working on, which is a user operation bundler, which standardizes the way, or more like it allows for a way for adapt to build a user operation in a way that's compatible with the particular account. Because I said different accounts have different interfaces, how this might look, one account may have an execute function and the other account may have an execute full function, which takes different arguments.
00:23:36.248 - 00:23:54.684, Speaker A: So this user operation builder, EAP, allows this to be, allows ADAP to know which standard or which interface the wallet uses. So yeah, that's pretty much everything. It has been a lot of stuff. So I hope we have time for questions.
00:23:55.504 - 00:24:09.462, Speaker B: Ivo, thank you very much for such a rich and interesting presentation. Unfortunately, due to time, we are not going to open for questions right now, but Ivo is pleased to, to help you and to attend you outside in the coffee, or even you can reach him out through LinkedIn.
00:24:09.558 - 00:24:12.774, Speaker A: Yeah, and on X and Warpcast.
00:24:12.854 - 00:24:15.942, Speaker B: I'm sorry for that, but we are late on time, so thank you very much.
00:24:16.078 - 00:24:16.454, Speaker A: Thank you.
