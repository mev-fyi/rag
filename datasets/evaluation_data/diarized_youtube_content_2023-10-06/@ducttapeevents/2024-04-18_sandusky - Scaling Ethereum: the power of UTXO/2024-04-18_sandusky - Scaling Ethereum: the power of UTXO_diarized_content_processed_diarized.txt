00:00:00.080 - 00:00:17.726, Speaker A: Where's yours? Thank you. Thank you so much guys for being here. Thank you so much to the staff team for making this possible. So, scaling Ethereum, the power of Utxo. We are going to understand why we need to scale Ethereum. We are going to understand what's Utxo. But this is Vitalik six months ago.
00:00:17.726 - 00:00:46.600, Speaker A: This is 2023 layer two days in Istanbul. Bulletproof. Vitalik did an amazing task that date to keep key takeaways. The first one is Vitalik talking about plasma, which is quite crazy, and Vitalika talking about Utxo, which is today's topic. So we are going to talk about the state load and decentralization issues. We are going to talk about race, condition and execution issues. We are going to talk about Utxo indeed.
00:00:46.600 - 00:01:39.194, Speaker A: We are going to have a quick view the history of Utxo by the work of Hal Finney. We are going to talk about the state minimized design. We are going to talk about predicates and we are take a very quick look to some projects using Utxos right now. So state load and decentralization state load is the situation where increasing state in the blockchain leads to increasing hardware requirements for the validator nodes. Basically increasing hardware requirements, trends, decentralizations, because more hardware mean more money. And not everyone can run a node, so the network gets centralized. This is a chart portraying how ethereum state is growing nonstop since the beginning.
00:01:39.194 - 00:02:21.673, Speaker A: But not every kind of a state is the same kind of state. So we can understand like basically three kind of state growth issues. The first one is state growth, which is new accounts, new by code, new storage. We can see history growth, which is new blocks and transactions. And we can talk about estate access, which is the issue of reading and writing operations for building and validating blocks. Today we are just focusing on estate growth, which is new contracts by code and contracts. Right now the ethereum state is up to 245gb on a red node, which is a lot.
00:02:21.673 - 00:02:51.374, Speaker A: Mainly we have accounts, which is 14%. Then we have by code which is 4%. And then we have contract storage, which is 81%. A lot of memory spent there. Seems like it's fine, but it's not. It's strengthening the whole Ethereum ecosystem. And as you can see, somewhere around 48% of current ethereum storage is basically ERC 20 and ERC 21 transactions.
00:02:51.374 - 00:03:45.484, Speaker A: So it's like we are spending a lot of resources just to tracking assets. So summary state bloat is bad. Then we have another issue, which is the race condition. Some of the computer nerds out there might understand this concept, which is this is like a block header for an Ethereum block. An important, this, oh, an important step might be the state root, which is the root of the merkle tree of the state of the block. And basically Ethereum storage looks like this is a dictionary where you have account names and ETH balances. And for the case of contracts you have like the ETH balance and you have another storage root representing the contract storage, which for years it might be like just accounts and balances of that specific token.
00:03:45.484 - 00:04:33.144, Speaker A: So the question might be, why is not parallel? Like what's the issue behind the account model to make the parallelization impossible? Well, because of race condition. Race condition is a situation where two processes or threads are trying to access and update the same slot of data. Looks like this, basically. And Ethereum did some work trying to solve this issue. This is a screenshot from the EIP's GitHub. Basically this is Vitalik proposing somehow some kind of access control list for execution. So basically the node can know beforehand which storage slots are being updated.
00:04:33.144 - 00:05:22.364, Speaker A: There's a lot of interesting information in this issue. One of the cool takeaways is that accounts can have arbitrarily large storage trees and we can load that into memory. And then we have another funny stuff which is we might require nodes to have 512gb of ram, which is completely nuts. But basically the issue was closed when they realized that this cannot be done. Like it's another bottleneck. And the conclusion was we should move to a stateless clients or sharding, basically so you can do parallel execution in Ethereum. So stateless is the way.
00:05:22.364 - 00:06:09.666, Speaker A: I don't dig into many of the available solutions to, to solve the state blow on Ethereum, just the state minimized design. But right now with account model is somehow bad, then it comes Utxo as a blessing. This is Hal Finney inventing Utxos and helping us to solve these issues. And basically Utxo is an approach where you don't need a root state, so you don't have centralized state, so you don't have race condition and so on. Utxo look like this and they stand for unspent transaction outputs. So basically this is how bitcoin works. And it's like you don't have a big spreadsheet of balances from each user, but each user has some amount of money locked in some kind of program.
00:06:09.666 - 00:06:36.924, Speaker A: And then you have like a bunch of programs with money that is not spent yet. So it's like a piggy bank basically. You put money into a piggy bank. And then you have your account with a bunch of piggy banks with different amounts of money inside them. And when you want to spend some of this money, you just destroy as much as piggy banks. You need to fulfill the desired amount. Then you create a new piggy bank with that amount of money and send that to the recipient.
00:06:36.924 - 00:07:19.940, Speaker A: Another analogy might be cash. So basically when you pay with $100 bill, let's say you are willing to pay 30. So you have 17 change. Well, the cashier might be burning that $100 bills and creating two new bills from scratch, $30 bills for themselves and $70 bills for you. So it may look something like this. A bunch of Utxos are going to be merged into one transaction to create a new Utxo. A more accurate depiction might be this one where you have 50 bitcoins, you send them into a transaction and split them into another recipient and 49.5
00:07:19.940 - 00:07:52.990, Speaker A: for yourself. Another account might be the same. So it's going to merge a couple of Utxos in order to create a couple of new Utxos. So it's like an ongoing process forever. So why is this parallel? Well, because you remember race condition where you are trying to access the same slot in memory where you don't have that problem because of atomic state. Basically you are having pieces of storage, pieces of data flying around in the blockchain. So beforehand, you know they are not colliding together, which is amazing.
00:07:52.990 - 00:08:11.264, Speaker A: Utxo killing the root state with the second. I'm Zandoski, I'm developer license engineer at Fuel Labs. You can find me like this on Twitter. We are building the roll up os for ethereum so it's pretty cool. Go to fuel.net work to check it out. Please skip the selling.
00:08:11.264 - 00:08:44.723, Speaker A: We were talking about Utxo. So good, right? But this has a history behind and it's a pretty cypherpunk history. This concept kind of was invented by Hal Finney back in 2004 and basically comes as this concept. Reusable proof of work. This is a screenshot from the archival website which is at the Nakamoto Institute website. And they even have the slides. So I'm going to reuse some of the slides.
00:08:44.723 - 00:09:20.116, Speaker A: This is based on top of hash cache. Hashcache was built in 97 by Adam Bach and basically is proof of work. They invented a way to tokenize expensive computation in order to avoid email spam. The issue with this is like you cannot exchange them. And Hal Finney had this theory that if you're receiving a lot of hash cash. Proof of work means that you're a real human being. Spammers often don't receive emails, therefore they don't have proof of work related to their own account.
00:09:20.116 - 00:10:14.794, Speaker A: So they say if you already have a computation proving that you are a real human being, you should be able to spend that tokenized computation in order to perform all your actions. And this is basically the Utxo model. You have proof of work tokens, you have a data structure that allows you to spend that tokenizing computing. And then you have a network of decentralized protocol and servers willing to verify that information. This is basically bitcoin almost five years before of the white paper. So thank you so much, Hal Finney, for building this technology that makes us so happy. Now we go into a state minimized design where basically we are trading off bandwidth with state.
00:10:14.794 - 00:10:44.750, Speaker A: In Ethereum, we have different kind of storage information. We have like cold data and memory, which is like ephemeral information. Memory is like the scope variables you are using within a function. And call data is read only information that comes as form of parameters within the transaction. And then you have a storage, which is permanent. Information storage might be like going to a restaurant. So you are like walking so lightweight.
00:10:44.750 - 00:11:26.618, Speaker A: You go there, they have the food, you eat, you leave, and then you have cold data, which is like keeping your own lunchbox wherever you go. So basically for storage based execution, you have all the information in the contract, and then you send lightweight transactions to avoid taking so much ban with it. And then you have call data where actually you are sending big transactions to pretty stateless contracts. That's why it's called state minimized uniswap. B three is doing this. Actually this is like the staker, a section of the staker contract. And basically you see that they are just starting a derivation of some data structure.
00:11:26.618 - 00:12:09.630, Speaker A: And each time someone is willing to get information from that incentive, they are basically computing back again the information. And it seems counter intuitive because we learned that we want to avoid computing things many times. So we build, hack caching and all of this other stuff. But actually for blockchain this makes sense and it's called a state hydration. So basically you are keeping track of small pieces of data in the blockchain and then using computer power to reiterate that data and have meaningful value. And then it's where canes come into action. Basically, this is a stateless account abstraction.
00:12:09.630 - 00:12:53.486, Speaker A: It's a new kind of primitive built on the field network. And it's something really cool that I would like you to see. So we began talking about Utxo and we end up talking about predicates. But in the middle there's pay two script hash. This is something coming from, I think it's beep 16 by Gavin Anderson. So what the fuck is p two pay to script hash? Well, you know the standard kind of account in bitcoin and everywhere else, which is private key, elliptic curve, and then a public key. So you deposit money or associate money to that account, and then a private key is able to like expand those resources.
00:12:53.486 - 00:13:44.154, Speaker A: Where in the case of pay to script hash, you have like signatures and you have a redeem script, which is some kind of puzzle designed to define the conditions whether utxo can be spent or no. So basically you are having a public key that doesn't come from a private key, but from a script. So that's the idea. You can imagine that as the lockboxes you use for Airbnbs. So it's not a person giving you the asset, but device in the world having some kind of puzzle and then having some kind of asset that you can unlock. So if you know how to solve the puzzle, you know how to get the assets. That's the whole idea.
00:13:44.154 - 00:14:30.494, Speaker A: But what's the issue with p two script hash? Why is not like so widespread use? Well, basically because bitcoin is dumb. Like you can do almost anything with bitcoin so far. That's why we went into Ethereum. Ethereum decided to go with the account model rather than Utxo model. So that's where predicates become so useful. Because predicate so powerful, so good, so gentle, are some kind of mix between the utxo standard approach. Powerful vms such as the fuel vm high level expressing unuseful language such as sui lang, which is a DSLR build based on rust.
00:14:30.494 - 00:15:04.706, Speaker A: And the philosophy behind pay to script hash. That's where you get predicates. A predicate is just a pure function that you hash and get a public address. So it's like the source code is the private key. And this is basically a stateless account abstraction. Why? Because you are not storing this code in the chain, you are just keeping track of the hashes. And whatever who has the input script is able to spend the money that is there, but not with the code.
00:15:04.706 - 00:15:36.760, Speaker A: Only you have to fulfill the conditions of the code. So a predicate may be basically a functor. This for the computer nerds. So predicates are like wallets, they can receive assets, they can hold assets, and they can spend assets. Predicates are like wallets, so they can be deployed and they cannot be deleted. So yeah, so they are pure functions with a boolean return. And if the result of the predicate execution, we call it evaluation.
00:15:36.760 - 00:16:05.968, Speaker A: If the result of the predicate evaluation is true, well, you can unlock the assets within that predicate. A slide about reusing proof of work. I'm reusing this slide spending predicates. So basically you need the predicate code, as I told you, you need a transaction that fulfills the condition of the predicate. You need the full client and the fuel Utxo set. This is basically like the blockchain. And then you have a new Utxo.
00:16:05.968 - 00:16:47.884, Speaker A: So it's basically, it's like Utxo sending a transaction between them, but adding an additional step which is solving a puzzle so you don't have to keep the money yourself. You can keep the money in a stateless, obstructed account, and you can spend that by fulfilling the conditions of the predicate. Differences between contracts and predicates. Predicates won't access on chain data. Why? Because they are pure functions. They can read data from smart contracts. They are not aware of time, and they can read hash numbers or block numbers, but they can read input and output coins of the transaction.
00:16:47.884 - 00:17:16.069, Speaker A: They have access to transaction script and transaction bytecode. This chart is coming from our own guide on predicates, which is predicates 101. Building a stateless defi applications. You can check it out just right here. But I'm getting the QR again. Monstrock code, all vms and Utxo. This is another project right now leveraging on the Utxo approach.
00:17:16.069 - 00:17:47.604, Speaker A: We have aztec privacy solutions, we have nervous, which is like intent based network. We have finder out which is some kind of ethereum sidechain. We have legume and only one of them has powerful predicates, which is fuel network summary and a few conclusions. State load is bad for decentralization. Account model can be parallel. Utxo is so good. Hal fini, thank you so much.
00:17:47.604 - 00:18:12.918, Speaker A: And predicates are so amazing. So if you want to start building stateless defi applications, you want to mess around with predicates. You want to build these crazy off chain, on chain secure functors, well, come and join this QR code. I promise that is not a security threat for you. I just need a tracker for the event so I can show it to my manager. But yeah, that's it. Thank you so much.
00:18:12.918 - 00:18:31.014, Speaker A: Do we have time for questions? We have time for one or two short questions. Are there any questions? Is there anyone? However, we can meet outside and keep talking about computer science stuff. However, thank you so much for attending and I hope you have a great time building with predicates. Thanks.
