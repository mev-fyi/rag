00:00:21.320 - 00:00:47.004, Speaker A: Yeah, hi everyone, can you hear me? Well, great. So I'm a viewer. I'm head of product at Stackware. I'm very happy to be here today and talk about recursion. On a personal note, I started to work at Starcware, actually from here, from paper hub in polis. I spent my, almost my first year in Starquare working from there. So for me it's very nice to be here and give this talk today.
00:00:47.004 - 00:01:35.524, Speaker A: Okay, I only have 20 minutes and there will be no question time because there is something right after that. So if you have any questions, feel free to come to me after and ask. I do want to try and present in just 19 minutes what is recursion? And basically I'm going to separate it to three or four parts. I'm going to talk a little bit about the background because, well, you need to know something to understand what's happening in this talk, but it's not so much. And then I'm going to explain what is recursion? Why do we want recursion? And at the end, if I have time, I'm going to touch a little bit on what is the timeline. When are we going to see recursion in production for starts. Okay, cool.
00:01:35.524 - 00:02:23.438, Speaker A: So what you should know is basically this is like a short and not comprehensive list, but actually I'm going to touch very briefly on the first three points. And the fourth point is like nice to have, if you know what Stark is it great. If you don't, that's very, that's pity. And you should come to me after and I will feed you with all the details. Great. So a little bit about starks, proofs and Cairo. Basically the concept that, the concept that you need to be familiar with is that there is an ability to, to take every computation that takes time t to execute and generate a proof for this computation and the entity that generate the proofs, we normally call it the prover.
00:02:23.438 - 00:03:01.344, Speaker A: There is also a separate entity which is called the verifier. And the verifier only takes log t time to verify the correctness of the computation if he get a proof. What Cairo, the programming language I mentioned earlier, what Cairo enables, is basically to take any logic, any computation, and have it written in a way that it can be efficiently proven. Okay, great. So this is like very simple heuristic of how Cairo works. You want your program to be proven. You write your program in Cairo, then you have a prover on the left side.
00:03:01.344 - 00:03:42.116, Speaker A: She's running the Cairo program on some input, let's say input x. You can think of the input basically as a list of transactions most of the time, and the program being something that takes those transactions and does something with them on the state, and eventually it outputs y. And the verifier basically wants to know that running this chiroprogram on some input really generate the output y. And that's basically how you should conceptually think on what's happening here. Okay, great. Okay, this is something I must explain, and most of the people are probably not familiar with. So we have a prover that, a spatial prover machine that we call Sharp.
00:03:42.116 - 00:04:17.568, Speaker A: Sharp is like a shared prover, right. And what Sharp knows to do very well is to take chiroprograms that are not necessarily similar. For in this example, I took Starcx immutable, Starcxrare and Starknet. From the prover perspective, those are all completely different programs. They can be with completely different chiral code. He can still take all of those with different transactions for each. So when you see her job, and I'm not going to get too much into that, but when you see her job, every job is basically a program in a set of transactions.
00:04:17.568 - 00:04:39.328, Speaker A: You can take different programs with different set of transactions and prove in a single proof, prove all of them together and verify it on ethereum. In one proof. In one. Well, it's not one, but one. Prove several transactions. Okay. So conceptually, and also in practice, sharp takes different program, unite them to a single proof.
00:04:39.328 - 00:05:04.216, Speaker A: And that's what you need to know about sharp. Great. Okay, so now I can start talking about recursion. Are you familiar with these? I guess some people are familiar. So basically, admit I haven't seen this particular chapter for a while, but the basic idea that you see in the picture, this is from a tv show named Rick and Morty. And the guy at the top is Rick, and he's driving a spaceship. A spaceship, sorry.
00:05:04.216 - 00:05:45.006, Speaker A: And he has, in this particular episode, his engine is broken, so he has to go inside his engine. And it turns out that he created basically a completely, a full universe just to generate energy for his engine. So when he goes inside, he finds out that this universe that he created, well, they were too lazy to run everything to create the energy for his engine. So they created another universe that created the energy to run whatever they need for him to run his engine. And you can imagine that this universe are also, they're also being lazy. So they created another universe. Yeah.
00:05:45.006 - 00:06:36.828, Speaker A: You understand where I'm going? Okay, so actually, this kind of reminded me what you're going to see with stark recursion. So if you don't want to take anything else, you can always go back to Rick and Morty. That's what I do. Sometimes it will be good for you to refresh your memory. Okay, so I want to explain in a couple of sentences what is recursion, right? Because you know recursion probably from programming or maybe from other areas of life, but I want to explain what is recursion when it comes to starks and proofs, right? So what you all, if you know proofs from before, this is what you're normally used to. There is a program, doesn't matter what it is, can be starknet or anything else. And up until now, what you're used to is that we generate a proof for the original program and then we verify the proof in a verifier program.
00:06:36.828 - 00:07:08.070, Speaker A: And that's how things works in the normal life. And that's how things works today. Sharp takes computation, generate a proof, send it to the verifier on chain. But the verifier program is a program by itself. It's a program by its own, right. So the same way that you can prove any other program, you can also prove a verifier program. And basically when you prove a verifier program, you don't prove directly the original program.
00:07:08.070 - 00:07:36.068, Speaker A: You prove the verification of the proof of the original program. Right. Take two or 3 seconds. Okay, you have it, great. And then you can verify the verification, instead of verifying the original proof of the program, you can verify that you verify the program. And of course you can also prove that you verify the verification and so on. Okay, so that's fantastic.
00:07:36.068 - 00:08:22.264, Speaker A: And that's very cool. And we do things because they're cool. But then the question is, okay, so why do we want to use recursion? What are the reasons that we want to do something crazy like that? Okay, I'm going to skip that. So here is a clue about the motivation. So the clue is that if you have a program that takes t steps, then proving it takes roughly also t steps. But if you already proven this proof, then proving the verifier only take log steps, which is much in most of the times it's much much much shorter to prove once you have it compared to the original proof of the original program. Right.
00:08:22.264 - 00:09:40.958, Speaker A: So here is something I can do and I'm going to explain it in a second. Okay, this was a clue. So, okay, the first thing that you want to do recursion for is basically dramatically reduce the gas cost and increase the proof capacity as we have today on chain. So why is it like this? Well, today you can imagine, you take a program, a program can be starknet, and it gets many, many transactions, right? So you collect those transactions, and at some point you took the largest machine on Amazon, AWS or GCP, and you can only push yay, many transactions. And that's it, because after that the machine run out of memory, ran out of core, you can't push larger computation inside, you can't have more transaction in a single proof. So if you have 10,000 transactions, let's say that means that an approved verification cost 5 million Gaz, then it puts you a limit on how low can you go with every transaction, right? Because you know the 10th, you can put up to 10,000 transactions in 5 million Gaz, which is amazing, but that's your limit. And we want to do better, we want to do sometimes 20,000 transactions, or we want to do 100,000 transactions.
00:09:40.958 - 00:10:40.910, Speaker A: So then this is a place where recursion can actually help. Because if before all you could fit is program a with these steps, then now you can use this scheme, prove every program separately, but then prove the verification of those programs, and two times log t is most of the time way smaller than t. So now you could, you can push two, like you could double your capacity, meaning pay half the gas cost in the best case, right? And still use a single proof on chain. And it goes further, right? It doesn't have to be two programs, you can also do it for four different programs, and you can increase your capacity by four times. And basically it goes on and on and on, right? Because this can be nested, this can be a tree of arbitrary size, almost. So this enables us practically to take the gas cost to be like infinitely small and the proof capacity to be extremely high. So that's very, very cool.
00:10:40.910 - 00:11:20.626, Speaker A: And this is by itself already why we would like to have recursion. But there are a few more things, and I really wish that I would have more than nine extra minutes to talk about the other things, but I don't. So you're going to have to come later. But I do want to mention a few more things. Latency, you remember that I introduced sharp a few moments ago. So imagine that in real life, those jobs, they are not coming at the same time. You wait for transactions in immutable, you wait for transaction in sorer, you wait for transactions on Starknet, and at some point immutable are saying, okay, we have enough transactions, we want it on chain.
00:11:20.626 - 00:12:10.864, Speaker A: So they sent their job, and Sorare comes later and starknet comes later. So in practice what is happening is that you wait and wait and wait and wait for enough transactions to fill up enough jobs before you start proving. And when you do start proving today, it's a huge proof that takes hours to prove, right? So overall you get latency from two places. One is you wait for transactions, and the other one is that you wait for a single huge proof to be proven. And that's going to improve dramatically with recursion. Because now let's say that we are waiting, we are all waiting, we like to wait, and then we have job zero arrive from immutable, and instead of waiting we can just prove it. So RJ here stands for recursive job.
00:12:10.864 - 00:12:58.904, Speaker A: Basically we took the original job from immutable, we didn't wait for other jobs to arrive, and we proved it. And because we proved it, we do the same for the job from sore, but now we can just take two proofs, two basically proofs with the verifier program and unite them and prove them all together, right? So we didn't wait for the job for Starknet to arrive, we already proved the jobs from immutable and swear, and we do the same with starknet job. And by the time we have all three jobs ready to be sent, we already have them proven. So we got two things. One, we don't have to wait for the line of transactions to be fulfilled anymore. We can prove things as they arrive. And two, the proving itself is faster because it doesn't necessarily have to be on a single huge machine.
00:12:58.904 - 00:13:38.484, Speaker A: It can be splitted to many, many, many machines that take partially smaller jobs and run them in parallel. So if you want to imagine how it looks in sharp, in the general case, there is some algorithm that takes jobs that are waiting on the queue, recursively proving them. If he finds two recursive jobs, he unites them, and so on and so forth. This is just one potential outcome. It doesn't have to be that way. It really depends when the jobs arrived, but I'm not going to get into it now. Okay, this is another topic that I'm really touching in a minute or two, but I think just about this, I can probably talk an hour.
00:13:38.484 - 00:14:35.890, Speaker A: So this is basically the general idea of layer three. I like to picture it, and also in my head it looks like this. So I don't know why, but the base layer for me sits in the top and you're never going to see it, including not in my slide because nobody agrees for me to put it that way, but I can put it in a picture. So for me it's like Starknet all the way down. Basically the general idea of layer three is to say, well we run things on Starknet and that's great, but sometimes for whatever reason in the world, you want to have your own environment, you want to have your own custom Stacknet, you want to have your own Stackx system. Maybe you will have a different VM and you don't want to relate to the way that starcks or Starknet vms are created. Maybe you have a Zke VM system that you care about, maybe you have, I don't know what, I took orbit VM as an example.
00:14:35.890 - 00:15:15.356, Speaker A: Maybe you have your own whatever mips or whatever VM that you can think of. So what you can do is you can write your VM in Cairo, implement your VM state machine in Cairo, and then using the Chiro verifier that we already wrote for the recursion, you can deploy the chiroverifier on Stacknet. We will actually do it for you probably soon. You can use this chiroprifier to prove any such environment separately. So you can have your own personal environment within Starknet. It has all kinds of benefits. You pay even less than Starknet, you control the environment yourself, you can have a different vm.
00:15:15.356 - 00:16:02.344, Speaker A: You can even imagine a world where all, each one of those layer three has completely different smart contract system, but they can interact with each other and it's much much cheaper than doing it from L2 on Ethereum. So I know maybe it's not going to be as clear as I see it right now, but take a moment, think about it. This is like you can put in different environments with different vms and different state machines on top of Starknet and you can prove them and they can communicate with each other. You can have ZKVM smart contracts talking with some custom smart contracts over Starknet. It can be very cool. What else I wanted to mention. So I have four minutes, I'm going to touch this in a very like, yeah, let's do it.
00:16:02.344 - 00:17:15.750, Speaker A: This is actually something pretty cool that I think most people don't understand yet. Normally, at least in starks there is some complexity in the verifier. This complexity comes because in starks the verifier has to know the program in some way, it has to know whatever he's proving. So the stark verifier of Cairo has to know the Cairo VM constraints and we want to do things more efficient, which means to present more constraints. For example, people are saying we want to approve ketchup very efficiently, then we are introducing a ketchup, building ketchup constraints, that goes to the verifier, and that makes over time the verifier complex and expensive. And we don't want that, nobody wants that. With recursion you can actually say, well, you want to add complex built ins, complex restrictions to prove things faster, but you don't want to over complex your solidity verifier, that's fine, prove everything that you want that is complex on a higher level of recursion, and then just use this verifier to prove it.
00:17:15.750 - 00:18:03.646, Speaker A: But the solidity verifier will never need to be aware of those because the intermediate step will not use them. And I don't know, it helps so much in that you can now do very over complex things on our side. You can prove things much more efficiently, but the solidity verifier is not going to get hard. And sometimes you can keep it very, very simple. That's basically what I want to say about it. You can do proof compression, which is very, very cool. It's basically the idea to, if you have already several proofs that you generated over time, for example, proofs for the validity of starknet or the validity of bitcoin or any chain, and now you had like a proof every hour, let's say.
00:18:03.646 - 00:18:53.964, Speaker A: Then if until now you just end up with having like 100 proofs or whatever it is per day that you had to download and rerun, now you can unite them to a single proof all the time, which is I think very useful. Okay, 1 minute to talk about when. So the reason I'm actually giving this talk, it's not like, well, if you think about recursion, it's some concept that people have been talking about and sometimes implemented for specific use cases already in the past. The reason I'm talking about it is that recursion is now very, very close to production in Starknet and stark systems. It basically means the verifier is out there. Sharp knows already how to run with recursion. It's actually running on sharp environment that basically mimics production.
00:18:53.964 - 00:19:25.622, Speaker A: And I expect that in a month or two we are going to see recursion running on general computation. That includes Starknet and Starkx and maybe other programs, who knows, running in production, which is very, very cool, and it's going to present new changes for the good. So you should be aware and yeah, that's it. That's what I want to say. Thank you very much. I know I don't have time for.
00:19:25.638 - 00:19:31.686, Speaker B: Questions, so there's time for maybe. No, we've gone over now. I'm sorry. Okay. Thank you very much, Avihu.
00:19:31.710 - 00:19:32.394, Speaker A: Thank you.
