00:00:14.800 - 00:00:40.994, Speaker A: Yeah. Hello everybody. It's my great pleasure here to present our work on accelerating the op floor proof using the latest Ethereum upgrade, EIP 4844. So next. Oops, it's not working. Next. Okay, cool.
00:00:40.994 - 00:01:18.334, Speaker A: Yeah, so first of all, a quick intro of myself. I've been working in the web3 area since 2018. Before that I was a software engineer at Facebook, Google, got a PhD, primarily working in infrastructure. So my primary interest is in Ethereum data availability and L2 technologies. Get some support from both op and also Ethereum foundation. For example, vitality personal grants on cross L2 bridge data, web based sampling and edge storage. So for today's talk, it's also sponsored by the op grant.
00:01:18.334 - 00:02:30.484, Speaker A: Okay, so here's the online I will first give a quick intro about what is optimist roll up and its corresponding bisect dispute for proof gain. And then I will introduce our proposed multi section for dispute gain, how we are able to accelerate the whole procedure to one to the ten time. And then lastly I'll give a summary. So optimistic Rora is one of the basically most popular RoA these days, including for example famous obstac and arbitra. The basic idea is that we can perform a lot of off chain computation which is very efficient with a very high TPS or very large memory model. And then we use an on chain some smart contract to verify the off chain execution. For example, we can use not proof to verify the validity of the transaction results, or we can also use inferior proof to prove that the execution result of the off chain is wrong.
00:02:30.484 - 00:03:54.856, Speaker A: So how it works, basically there's a proposal defender that submit the claim which is the execution result of the off chain. And then this is a subjective claim that the proposer believe this is correct and so anyone is able to challenge the claim within core challenge window. And when the challenging happens, there will be we call dispute for game, a thought dispute game which will basically interactively tells which instructions in the option execution is wrong. And then once this execution is found, we can basically submit on chain verification to tell that the challenge wins the game within this time window. And if no one is able to challenge the claim with the term window, then we will believe that actually the smart contract would believe that this is assumed to be correct. So this is basic mechanism of the optimistic rollup. So optimistic rollup has a lot of benefits versus for example Zk rollups first is much much simpler to implement and also to implement its prover.
00:03:54.856 - 00:05:01.784, Speaker A: For example, in the ZK ROA, the major cost is the prover cost, which takes a lot of time, first to implement correctly and second to prove the option execution. So for optimistic RoA that would be much simpler. And second, but things like the major disadvantages of optimistic ROA is that it require a very long settlement time. For example, in the current optimistic op stack for proof it requires 33 moves in the fall dispute game, and which right now is generally required seven days. Especially consider some attack vectors and also takes about 80 million gas which causes about 0.3 ether at about 20th jewelry price. So the question is that can we reduce the moves to much much smaller ones, for example less than ten interactions, and also we are able to reduce the gas cost to less than one to the ten.
00:05:01.784 - 00:06:14.780, Speaker A: So that's basically the idea of why we proposed multi session for proof. So before we dive into the details, I will give some quick overview of what the current for proof dispute game happens. So first of all, we have a state which represents the current state of a virtual machine. In a Fibonacci case we will have the two last variables of the Fibonacci sequence. And in the more complicated cases, for example specific instructions architecture like MIPS wasn't, then it will contain a list of registers, memories, stacks and we also have a state transition function which tells that after running this state, what is the next state looks like. For example in the Fibonacci sequence, then we basically sum these two last two sequence last two variables in the sequence and then move the last one to the previous variable so that we can have a new state which is bi and then AI plus bi. And in the virtual machine cases there will be a one step execution of the MIPS opcode.
00:06:14.780 - 00:07:54.782, Speaker A: Here I list all the OB code that is defined in the MIPS specifically. So in order to execute a large number of transactions in general we will have a multi stepped state transition function which just repeatedly apply the state transition function on the state with m times so that we will have execution chase for starting from the initial called pre state and the post day of s plus I plus m. So here is an example of a Fibonacci example that when we start with the initial state with two variables is starting with one one and after 16 execution, then we will end with a result with 1597 and 25 84. And we also have the corresponding execution chase of repeatedly running this Fibonacci sequence for 16 times. So the question is how we are able to make sure this s 16 is correct, especially if somebody is wrong. Then we can find out which step of this execution is wrong and then we can use an on chain verifier to challenge corresponding execution and to tell that this is something wrong made by the proposer. So first of all, before we basically start a game, we need to know what is the claim.
00:07:54.782 - 00:09:49.764, Speaker A: If the claim is very similar to a multistep state transition function, but just tells that after running some pre state with m steps, we get a corresponding post day and a client has said, hey, this, this is the post state that we would expect it to return from the state transition function. Or it can also claim that this is not the case which is not the corresponding post state that we given this claim. So in the Fibonacci examples, basically we want to using this for dispute for proof, to tell that given this objective execution result, given initial state and corresponding post dates, we want to basically have this. For example, this claim is given tells that this is a valid claim because the execution result is the same as the state transition function. But it's also, for example, suppose there's a proposer propose a claim with a wrong result and this claim will become invalid. And that is the fraud dispute gain, trying to convince to the smart contract that something is wrong by the proposal. So what is the Ford dispute gain? It's basically doing that given an initial state that is generally off chain, for example block transition so that we have an initial state of the world state of the L2 virtual machine and then given a state function, for example in the EVM case, that will be the EVM virtual machine.
00:09:49.764 - 00:11:04.694, Speaker A: And then where both the defender and challenger agree how these two that is written on a smart contract and we want to design an interactive game to prove on chain that suppose there's an invalid claim that is of a long off chain execution. For example, running a very very long sequence of Fibonacci result. And that is really wrong by the on chain smart contract. In these cases, this m, which is the off chain execution number of steps can be super, super long. For example, in the optimistic op stack cases, this number of stack can be two to the power of 73. That basically covers most of the L2 transitions with a large number of, for example, blocks. And another thing is that the one step state transition function is able to be verified run on top of a blockchain so that we can verify any one step transition is correct or not.
00:11:04.694 - 00:12:29.694, Speaker A: So this is, for example in the opstack it provides mips sol so that we can verify a one step MIPS opcode execution on top of blockchain. So now the gain becomes that the defender agrees that I have a proposed root claim that starting from initial state with some execution steps, option execution steps, and we get corresponding execution results while the challenger says, hey, there's something is wrong. And I would like to challenge in how you execute this data and what are the intermediate state during this execution. And then FDG will be able to run as a smart contract on chain to determine who is the winner. So for Fibonacci cases, basically we want to prove that suppose a claim is wrong, like objective is wrong, then we can use this game to prove that is actually wrong on a smart contract. But we cannot prove that. If the claim originally is valid, then we can prove that it's incorrect, or we cannot prove any claim that is correct.
00:12:29.694 - 00:13:39.664, Speaker A: So this is basically the capabilities of the for dispute game. Basically we just suppose the claim is invalid and we would like to use in this game to find something is wrong. And so the optimistic assumption is that suppose there's nobody is able to challenge the root claim for a specific time of terminal. Then the polyco assume that the root claim is valid, which means that the finality window, which means that nobody challenged the game, must be greater than the minimum challenge window, which right now requires 73 interactions of the on chain transactions. And generally it takes about seven days. Why is such a long time? The founder of obstacle Kevin gave a really good thought about how this can happen. And one key factor is that it highly depends on the number of the interactions, or we call FDG moves between the smart contract and also the defender and challenger.
00:13:39.664 - 00:15:13.134, Speaker A: So in order to basically to play this game, so one party, for example, right now this is defender will first, if I disagree with this result, it will basically submit a list of subclaims. In the bisect case section cases, there will be two subclaims to divide the whole root claim in the two sub claims, which counter corresponding original claims, saying that hey, I disagree with your claim and this is my intermediate execution result, and tell me which one you disagree. And so this requires the counter subclaim contains the new state, the intermediate states, which must be data available, and the rest of the stay already exists on the chain, so they don't require this additional information. And at the same time, this each subclaim halves the original claims number of steps. So that we would like to reduce this step to one so that we are able to finally decide who is the winner. Using the on chain verifier. So did the defender must respond that I either disagree with the first part of the execution or the second part, or agree with the first part execution, but disagree with the second part of the execution or in May fails to respond within timeout, so that again he will fail again.
00:15:13.134 - 00:16:22.184, Speaker A: And so suppose the defender agrees with the c two, that's the previous half section of the execution, but disagree with the second half. Then it will counter the second half of the subclaims and this repeatedly. And finally it will reaching state that both parties disagree, actually agree with the previous date, but disagree with the corresponding post date and with only one step to execution. And when reaching this state, now we are able to settle the who dispute procedure, use the on chain one step verifier. So this is basically how the thought proof dispute gain looks like. And here we can have the whole FDG clang tree, which will basically be able to find the corresponding counterclaims given corresponding original claim. So basically this list all the possible claims in the whole procedure.
00:16:22.184 - 00:17:21.014, Speaker A: So for the bisect FDG, this require log two m moves between the defender and the challenger. And suppose we want to support a lot of the off chain executions. Then it requires log two m moves which m equals to 200. Suppose two to the power of 73, that require 73 moves to determine which step is disagree between the defender and the corresponding challenger. And then they can settle by the corresponding on chain once the verifier. And this takes a lot of the time and also guest calls. So one nature idea is that instead of split the full execution trace into two segments, why not we are able to split this into multiple segments, so that we just need to able to accelerate this procedure with much finer granularity in each move.
00:17:21.014 - 00:18:17.814, Speaker A: So this basic idea of multisection for distribute gate. So for here give an example that we split the whole execution chase into four sections and then provide additional three states to tell that the corresponding execution result in the middle. And then the defender must respond to with four choices. Either it disagree with the first quarter of the execution result, or the second quarter, or third quarter, or the last one. Or the defender may also fail to get the gain by timeout. And so this will basically reduce this. We only need to two moves, so that we are able to find out which execution result is disagree the step disagree between the challenger and also the defender.
00:18:17.814 - 00:19:29.654, Speaker A: And so that we are able to greatly first reduce the number of claims in this tree. So for all these, for example, claims, for example in the two or three and all these layers, they will be removed. Because we basically using this each time it will create four counterproofs in the previous example, and at the same time also reduce the number of interactions, so require only two moves or interactions that we are able to find which instructions is disagree between these two parties. And this will be the clang tree of the multisection for distribute gain using k equals four. So the good thing is like using multisection floorproof, we are able to reduce the number of moves to log from log to m to log to log to n where n is number of the sections. For example, if n is 4096, then we can reduce the number of moves from 73 to seven. And the coins is that since we need to carry more data.
00:19:29.654 - 00:20:15.784, Speaker A: To tell the corresponding intermediate states of the execution. For each counter moves, increase the corresponding gas per move. For example, using n equals 4096. That will suppose we put the corresponding intermediate execution chase using coredata. That will need extra 2 million per guess in each move. That will be considerably larger versus the current bisect game. So the question is, can we reduce the gas while harvesting the benefit? The key idea here is now we are able to use an EIP 484 blob, which is just launched about two months ago.
00:20:15.784 - 00:21:11.728, Speaker A: Which introduced a new object for binary large object, which can be able to carry 128 data. And now the key idea is that why not use this blob to carry 40, 96, 95 state hashes. So that we can able to submit one transaction with one blob and be able to counter 4096 subclanes. And in addition, thanks to the upgrades, the blob cost versus coredata is. This is a huge, huge number that is cheaper versus the core data. Which means that corresponding actual gas can be almost negligible using the block to carry those intermediate hashes of subclanes. So here is the cross summary.
00:21:11.728 - 00:22:08.572, Speaker A: Using the current n equals two, it requires about more than 118 million gas with more than 73 moves. And we can use the core data to carry the corresponding intermediate states. For example, using n equals 256, we can reduce the number of guests to 3 million with about nine moves. And we can further optimize this using EIP 44.4. So that we can reduce the move to seven, further reduce the number of the total gas to 1 million, which is ten times smaller than the original n two. That is the current implementation of the op stack. So currently we have a proposal that is submitted to the op stack, which is already accepted.
00:22:08.572 - 00:22:41.754, Speaker A: And we also have a specification to basically describe mathematics rigorously. To how this multisection floor pool works. And there's also Ethereum optimism discussions. So if you have any questions, feel free to share comments there. And we also open source the who code. So that if you have any idea to contribute or test this feature? Welcome to contribute to the repo. And so with all these features now we are able to do a lot of crazy ideas.
00:22:41.754 - 00:23:24.494, Speaker A: For example, we are able to prove a super, super large execution off chain, for example, artificial intelligence interference or training procedure using optimistic for proof, and be able to almost instantly settle the corresponding for game if something, somebody is wrong. So we co work with Aura to develop all this OPML so that we are able to employ the benefit of multisection for approved to accelerate this procedure. So many thanks for attending my today's talk. If you have any questions, feel free to reach out to me and I would love to see you there. Thank you much.
00:23:26.634 - 00:23:33.414, Speaker B: Thank you so much. Thank you. Yes, working. Thank you. Are there any questions?
00:23:36.414 - 00:23:45.234, Speaker A: Yeah, any questions? Nice.
00:23:48.534 - 00:24:06.174, Speaker C: Hey, thank you for having me. So, and the question is like how do you envision like the future of like what you're building, like what you're trying to achieve generally speaking. And what is the kind of end goal which you can call as a success basically in terms of development of the features maybe and so on. Thank you.
00:24:06.834 - 00:25:36.814, Speaker A: Yeah, so the question is what's the future of these proposals and how do you define the success metric? So basically we are right now running this, the whole proposal is to be able to first implement all this feature, pass all the tests, and then test this feature on the testnet and deploy op stack, be able to do the fraud proof. And actually this is current stage of Bistac op stack. And next step is once they have been launched in the mainnet, we also launch the whole feature on top of Mainnet and then so that we are able to collect more detailed results, how much gas is been saving and all those number of time that is reduced. This is the basic success metric. So definitely the ultimate goal is running on top of domain net. And there's another proposal that I will discuss tomorrow, is to using the ZK floor proof to also accelerate the final step, or maybe multiple steps, so that the ultimate goal will perhaps to reduce the interaction for approve to one or two times so that it can reach almost instant settlement using the fraud proof while saving a lot of cost, both the op thraw proof and also the ZK fraud proof itself. So we will discuss some ideas tomorrow about the CK flaw proof there.
00:25:38.194 - 00:25:48.546, Speaker B: Thank you so much chief, working now. Yes, thank you so much. I believe we are out of time. Thank you again. We're gonna be getting ready for our next talk.
00:25:48.610 - 00:25:49.314, Speaker A: Thank you, thank you.
