00:00:13.160 - 00:00:46.968, Speaker A: Cool. Hello everyone. I'm happy to be here. Yeah. So today I'm going to be talking to you guys about something that I call future block MeV in proof of stake, which is kind of a made up name, but I hope that by the end of this presentation you'll know what it means. Is this the right clicker? I don't think so. Oh, maybe not.
00:00:46.968 - 00:01:19.656, Speaker A: Okay. Yeah, so I'm from chain security. We do smart contract audits. We work with a lot of companies that you might have heard of. In my normal day job, my specialty is working with the smart contracts directly. But today I'm also going to be talking more about the consensus engine of Ethereum. To understand what future block MeV is supposed to be, first we have to talk about block production.
00:01:19.656 - 00:02:04.196, Speaker A: And block production is something that has changed a lot in Ethereum over the last year. So before the big merge, we had proof of work, right? And in proof of work it was kind of a chaos. So in proof of work, every single miner was always trying to mine every single block. And what that meant was you could never know who was going to be producing the next block. Now, in proof of stake, it's a little bit more structured. So in proof of stake we're actually determining whose turn it is going to be to produce a block ahead of time. And in Ethereum specifically, you can actually know up to two epochs ahead of time, which is about twelve minutes, who is going to be producing the next blocks.
00:02:04.196 - 00:03:01.484, Speaker A: And in particular, that means that if you are one of the validators in Ethereum, you'll know twelve minutes ahead of time when your validator is going to be producing a block. And this is different than in proof of stake, you could never know before, and now you can. So this is what I mean when I talk about future block MeV. So what are some things that we can do with that knowledge? So one thing is that you could use it for oracle manipulation. So an oracle in Defi, usually we use price oracles, which tell you what the price of something is, right? Like the price of Ethereum today is different than it was yesterday. And there's a lot of DeFi protocols that need to know the prices of their assets. For example, if you had a lending protocol where you can put in some collateral and then you can borrow a different currency, it's important to know what the exchange rate between those currencies are.
00:03:01.484 - 00:04:07.164, Speaker A: And so one of the approaches to oracles are so called on chain oracles, where you use an on chain market, for example, Uniswap and that's super convenient, because that data is already on chain, and your contract can just go read the other contract and see what the price is at the moment. Now, if you just do that in a naive way and you just read the price at the current moment, that's probably not a great idea, because someone can just come and push the price up, and then you read it, and then they push it down again, and you're reading a totally wrong price. So the kind of mitigation that people usually use is that they use a time weighted average price of some time frame. So, for example, you say you use the average over the last 30 minutes of prices. And specifically in uniswap, the way it works is it always records the last price in a block. So it doesn't matter what the prices are in the middle of a block. It only matters at the end of the block.
00:04:07.164 - 00:04:26.152, Speaker A: And the reason why this is supposed to be good is that it means that if you want to manipulate the price, you have to bring it to, let's say, some very high level, and then you have to wait for the block to end. And when the block ends, that means that everyone else sees that this price is wrong.
00:04:26.288 - 00:04:26.560, Speaker B: Right.
00:04:26.592 - 00:05:15.484, Speaker A: So there's going to be someone who's doing arbitrage. He's seeing, oh, the price on uniswap is super high, and maybe on Coinbase it's lower. So they can just buy coins in one place and then sell them in the other, and they'll make a huge profit. And if you're the attacker that manipulated the price, that's going to be a loss for you. So now, if we take into consideration this idea of future block Mev, where we know that in the future, we're going to be proposing a block, we can do this exact same attack, but we're going to do it such that we manipulate the price in the block where the next one is going to be our own block. So the block n plus one here in the graphic is going to be the one that we know we're going to be proposing. And that means we're going to be able to order the transactions in that block in any way we want.
00:05:15.484 - 00:06:03.834, Speaker A: So we'll buy a bunch of the token in block n, and then the price is going to get recorded. And then in block n plus one, we just make sure that our own transaction is going to be the very first transaction, and we can just decide that, like, nobody else has any chance against us because we literally have the ordering rights. And so in that way, we can make sure that we are the ones that are taking the arbitrage, and we're pushing the price back down to where it's supposed to be. And so what that means is that instead of the entire amount of money that we used for the manipulation being a cost, we're only going to be paying the Uniswap trading fees of about 0.3% when we're trading up and down. But aside from that, we have no costs. So basically what this means is we are hiding mev from other people.
00:06:03.834 - 00:06:34.694, Speaker A: I guess an important thing to note is I'm assuming that we can use a dark pool, such as the flashbots mefboost, to put our transaction into block. Nice. Currently, about like two thirds of all Ethereum block producers are using Mavboost. And if you use MavBoost, what they give you is transaction privacy. So that means before the transaction gets into a block, nobody is supposed to see it. This works in most cases. We've also seen some cases where it doesn't.
00:06:34.694 - 00:07:22.570, Speaker A: But assuming that we have that, then in block n, we're not going to use the mempool. So no one can see our transaction. Then our transaction happens. Everyone can see that the block was produced, but then it's too late because the next block is going to be our block. We can take the arbitrage down. And then the other cool thing about this is that if, let's say there was a lending market that was using this oracle, then maybe because of our manipulation, some positions would be in the zone where they can be liquidated. Now, let's say that we push the price of an asset down, and then because that block is ours, we can also just use the rest of that block space for ourselves.
00:07:22.570 - 00:08:12.204, Speaker A: So first we take the arbitrage, and then we do a bunch of liquidations that are based on the new oracle price. And this is something that also nobody else can compete with us on, because we'll just won't let them into the block and we'll just take the first slots for ourselves. And so this means we can trigger a liquidation with no competition. And the reason we can even do those liquidations is because of an oracle manipulation that we caused and had very low cost for. And so this is basically the reason why nobody uses these on chain oracles today. So you can actually do this in practice just because nobody is using the twap oracles. And unfortunately, there's also not really a lot of better ways to do it with on chain oracles.
00:08:12.204 - 00:08:54.664, Speaker A: So a lot of people use chainlink instead or similar services where, you know, you don't have this specific problem, but you have a bunch of other problems, especially in terms of centralization. Yeah. Now another fun thing that you can do if you know that you're going to have a future block, is if you have a block, you get all the MEV payments, right? If someone really wants to get into that block, they'll pay you a lot of money for it. So as an example of that, we have here the other side NFT sale. This was the bored ape yacht club land. This is the biggest NFT sale that ever happened. And here you can see the gas costs.
00:08:54.664 - 00:09:53.534, Speaker A: At the beginning they were very low and then at 01:00 the NFT sales started, right. And you can see that the gas that was paid per block immediately jumped up to 200 ETH per block, which is about half a million dollars at the time. So every single validator that got one of those blocks got paid half a million dollars. But there's a caveat to it, which is we have the two colors, right? We have the black and the red. So in the red we have the base fee from the EIP 1559 and in the black is the validator tip. So the validators at the beginning, they all got paid half a million dollars, right? But then because of the way that the ethereum fee market works, when there's a lot of demand, the base fee spikes up as well. So after about 15 minutes or so, actually all of the ethnicity that was being paid was being burned in the base fee.
00:09:53.534 - 00:11:04.644, Speaker A: And the validators that got all of the rest of the super high fees actually got nothing, right? They only get the black part. So that shows you that it's super important to be in that very beginning phase of a gas spike. So let's say that we are maybe some big entity that controls quite a lot of validators and we can go check always, right? If in the next twelve minutes we're going to have a bunch of blocks. And if we do have, let's say, an over proportional number of blocks, then it would be worth it for us to maybe make some mev happen. And so one way you could do that is you just launch an NFT mint at that point where you're going to be collecting the MEV, right? So you could maybe work together with an NFT project. And you tell them, hey, you probably don't care exactly when your mint starts, so you just pay them some money and you tell them, okay, you can start your mint within this 30 minutes window. And we'll tell you exactly when, right? And then you make it so that it starts when all of your validators are going to be collecting the MEV fees.
00:11:04.644 - 00:12:11.722, Speaker A: And so this is kind of cool because it's like the validators should actually pay someone who is launching a project to do it at the time where it benefits them most. And it's kind of like reverse mev, right? The validators are paying the projects, and then the users of the projects are paying back the validators. And of course, it's very bad for the average validators that aren't playing this game because they're probably going to get less lucky on average. Another thing that's interesting, which was actually brought to my attention, to my attention by a guy called Iridian Alpha, is that because of the way EIp 1559 works, it might actually be profitable to censor some blocks. And combined with the way that mevboost works as well. So as we saw before, the total fees paid on Ethereum can be very high, but it's possible that only a small amount of that goes to validators.
00:12:11.858 - 00:12:12.130, Speaker B: Right?
00:12:12.162 - 00:12:49.288, Speaker A: So we have one example block here where the proposer was paid about 20 times less than what the total transaction fees paid were. So that means that block space, if you want to make a transaction, is expensive because you have to pay the base fee and the tip. But the blocks themselves are actually very cheap. You only have to pay the tip, right? And so that means that if, for example, you wanted to just create a block that's empty, you can forget about the base fee and you just pay the validator the tip.
00:12:49.416 - 00:12:49.704, Speaker B: Right.
00:12:49.744 - 00:13:53.268, Speaker A: And the way that it works in the Mavboost system, which most validators are using, is they just get a block and they don't know what the transactions are inside. They only get the block header. And they also get how much the fees or the tip that's going to be paid to them is going to be. So if you're a builder in the flashbot system, which is totally permissionless, anyone can be a builder, you can just start handing out empty blocks to validators and you tell them, I'll pay them, I'll pay you, is slightly more than all the other blocks, and they'll just take it and blindly pick the one that gives them the most money. Now the question is, why would you do this? And the reason is, or the reason that I can think of is that you might want to censor the block before yours. So again, we know when our block is going to be. We know which one is going to be ahead of us? So we might want to just make that block be empty.
00:13:53.268 - 00:14:28.550, Speaker A: We pay a small amount, like in that example, it was maybe like $40 to the validator ahead of us, and then all of those transactions are instead going to come into our block. And also the block before was empty, so nothing happened on the blockchain. Right. And this is super important for arbitrage once again. So one example is what is called stat Arb. So, for example, the binance markets, they trade all the time. All the tokens are always trading.
00:14:28.550 - 00:15:39.714, Speaker A: But on Uniswap, the tokens only trade once every 12 seconds because there's only an ethereum block every 12 seconds. So there's actually always arbitrage opportunities between binance and Uniswap just because one market lags it. Now, you can imagine if there's one block being skipped on Ethereum, now all of a sudden uniswap lags behind by 24 seconds. And so the arbitrage opportunities are going to be bigger because the market is going to move more on average. And it actually turns out that if you do this, if you stat ArP every two blocks, that will end up being about 35% more profitable, which is an analysis done by this guy on Twitter. I also recommend you check him out because you can end up, first of all, with fewer transaction fees, but then also just because the market has more time to move, the arbitrage is generally going to be bigger. And it actually turns out it'll be more than the combined amount of just the two single arbitrages.
00:15:39.714 - 00:16:34.604, Speaker A: And also even if you're just doing atomic arbitrage. So, like one very popular mev strategy is sandwiching, where you see a big trade happening, and then you buy that same token before, and then the trade happens, and afterwards you sell it again. So you're basically making sure that that trade gets the maximum amount of slippage that they've set, and you take that slippage for yourself as profit. And now if you can censor, let's say, the block before then, there's a good chance that there's going to be more sandwich transactions that you can all sandwich at once. If it was two different trades in two blocks, you would have to sandwich twice. You would have to pay the gas fees twice. But if you just move them both into one block, you can do it both at once.
00:16:34.604 - 00:17:29.146, Speaker A: Also, if you want to do the arbitrage yourself, again, you're the block producer, so nobody can compete with you, or you can just have other people do it for you and pay you the fees, and then it'll actually be more efficient to sandwich multiple people at once than it would be if you did it one by one. And I think here there's actually also an effect where if you have more sandwiches, they move the price more, and it actually makes it more profitable to sandwich them as well. Yeah. So that already brings me to the takeaways for today. So I think my main thing is that block proposers in proof of stake are known in advance, and this is very different than how it was before in proof of stake. And you can take advantage of it in many different ways. Right.
00:17:29.146 - 00:18:03.392, Speaker A: This information can be very valuable if you want it to be. I've showed you a couple different ways to do that. I'm stumbling upon new ways all the time. I'm sure you can also think of some that I haven't shown here. And, yeah, I think it'll be very interesting. I think it's an underexplored area so far, and we'll see how big of a pain this is going to become in the future. I could imagine maybe there's some problems that will show up as a cause of this.
00:18:03.392 - 00:19:06.814, Speaker A: We haven't seen too much of it yet. We've seen the math boost system not quite work the way it's supposed to. Just two weeks ago, where a validator actually basically proposed two blocks, two different ones. So they got the one from Mevboost, where they don't see the transactions, and then they signed that block, and then the transactions are released, and then they just created a new block as well, with those same transactions. But they weren't respecting the Mavboost rules, so they were just reordering them however they wanted to. And in that way, they could actually take transactions that were supposed to all happen at once, and they took them apart, and they were able to steal $20 million from the MEV bots that were creating those transaction bundles. And in that specific case, there was actually also a small bug in Mevboost.
00:19:06.814 - 00:19:35.666, Speaker A: But in general, you can actually just do this in every single Mevboost block. If you're a proposer, you might have to kind of race and make sure that your block is distributed through the network more. But it's definitely possible. And you will get slashed, probably for one ETH. But if you can steal $20 million, maybe one ETH is fine to get slashed by. So, yeah, I think it's very interesting and still evolving topic. Yeah.
00:19:35.666 - 00:20:07.400, Speaker A: If you're interested in the Oracle manipulation part, that I talked about. I actually have a whole blog post about that and also this future block mev multiblock mev stuff that I've been talking about. I also wrote a paper about the Oracle manipulation about two years ago, back when it was in proof of work. It's actually, you could kind of do the same stuff in proof of work as well. In case you're interested, the paper is also linked in there. Yeah. So thank you very much for your attention.
00:20:07.400 - 00:20:12.044, Speaker A: If you want, follow me on Twitter, read the blog post. Thank you very much.
00:20:15.584 - 00:20:18.560, Speaker C: So we got a lot of time. Can you wait, hang around for some questions?
00:20:18.632 - 00:20:18.984, Speaker A: Sure.
00:20:19.064 - 00:20:25.684, Speaker C: All right everybody, so we've actually got a fair amount of time left before the next speaker. Any questions out there? Any block producers looking for some tips?
00:20:29.664 - 00:20:45.866, Speaker D: Hey, I'm over here on your right. Hi, can you maybe just refresh us the premise that the block producers are known ahead of time? Can you maybe just give us a refresher on exactly how that works with Ethereum, how the block proposer is chosen and how far ahead of time?
00:20:45.970 - 00:21:42.976, Speaker A: Yeah, so basically in Ethereum, the two inputs to the random function that decides who the block producers are going to be is first of all the Randao value from the beacon chain, and then also the current ethereum validator set and the Randall value. You can always know it to epochs ahead of time. That's just how it's determined. And then the ethereum validator set, it can at most change every epoch. But if nobody gets removed from the validator set, it actually also won't change within two to epochs. Yeah, and that's just the input to the random function that generates the proposers. So if nobody gets removed from the validator set, you'll know it up to two epochs ahead of time.
00:21:43.120 - 00:21:43.424, Speaker B: Right.
00:21:43.464 - 00:22:20.924, Speaker A: So if you're at the very beginning of one epoch, you'll know the entire next 32 blocks of this epoch, and then the 32 blocks after that as well. Now if you're at the very end of the epoch, you'll just know like the next block, right, the end of the epoch, and then the next epoch as well. But in case someone gets slashed and gets removed from the validator set, then that second input changes the validator set, and then it gets reshuffled. So if you get unlucky, then the next epoch is going to change. So the current epoch that you're in right now, you can know for sure that it won't change, and the next one is pretty unlikely to change, I would say.
00:22:23.124 - 00:22:24.264, Speaker C: Anybody else?
00:22:30.684 - 00:22:55.094, Speaker E: Yeah. So I wanted to ask, it seems like the flashbots vev problem is persistence, in the sense that if I'm in vir, I can get front run by the validator at just the cost of one ETH, essentially. So what does this mean? Does it mean like mevers can't have more than one ethnic vulnerable at any point in time, because then they can just get front run like this happened, or what does that mean?
00:22:55.714 - 00:23:52.576, Speaker A: So it's kind of, yes, the validator can just propose a second block. There are some parts that make it a little bit harder, which is they're going to sign their block and give it to the Mavboost relay, and that's going to send it to the network. And then they actually, two weeks ago when this happened, they added a delay of 1 second of the relay sending the transactions back to the validator. So you probably won't get it quick enough there. So what you need to do is you have to have a bunch of Ethereum nodes. They can just be normal full nodes, they don't have to be staking nodes. And you have to basically build up a good peer to peer connection in the Ethereum network so that you have a high chance of being a peer of that node that the relay owns.
00:23:52.576 - 00:24:43.354, Speaker A: And then you'll get the transactions from there, hopefully with less than 1 second delay. And then you need to do all your computations for your new block of how you want to reorder it, and then you need to spread that block in the network quicker than the other block, which was earlier. So again, here it's going to help you if you have a bunch of different nodes and you have good connectivity, and you send it out from all of those nodes to their peers, because basically the other validators, they're just going to sign whatever they see first. And so you need your block to have more signatures than the other one, so that yours becomes the canonical one. So it's not super simple. It's always going to be a race, but it's pretty easy to just spin up 1000 Ethereum validators. There's not really a cost to it.
00:24:43.354 - 00:25:35.722, Speaker A: So yeah, it's not super simple. The other thing is, one ETH is going to be your slashing amount if nobody else gets slashed in the same period, if other people are also doing weird stuff, or if you do this every block, the slashing amounts are going to go up. But even if you get slashed for 32 ETH and you can steal 20 million, it doesn't matter. So I do think it's a real problem, the real world case where we saw this happening two weeks ago, there was actually the bug in the, where it didn't validate that the block header was correct, that was signed. So there, there was actually no race because the relay got an invalid block and it didn't release it to the network. And then the validator just sent their block, and it was the only block.
00:25:35.858 - 00:25:36.130, Speaker B: Right.
00:25:36.162 - 00:25:43.114, Speaker A: So they didn't have to race. So now that they fixed that, they will have to do this race. But I think it's something that's feasible to do.
00:25:43.274 - 00:25:59.502, Speaker E: Super short follow up question, is this actually bad for the network? Because I think the only ones that disadvantage here are mevers, essentially, if there's this threat for mevers to not do meve, it's good for the network in.
00:25:59.518 - 00:26:07.814, Speaker A: A sense, because then, I mean, I think it's not as simple as saying, like, all MEV is bad, or all people that use the MEV relay are bad.
00:26:07.934 - 00:26:08.190, Speaker B: Right.
00:26:08.222 - 00:26:34.934, Speaker A: Like for example, if I wanted to just do a big trade on uniswap, I would also send my transaction through the MEV relay because of the privacy that it gives me, because I don't want to be front running, even if I'm not creating a bundle. Right. But then if this happened where the validator did this attack, then they could front run me, even though I think that I'm using this private mempool which protects me from mev.
00:26:37.914 - 00:26:49.074, Speaker C: All right, we still have some time. Anybody else? Maybe over here in the middle. Then I think we have one more over here afterwards.
00:26:53.014 - 00:26:53.566, Speaker F: Hi.
00:26:53.670 - 00:26:54.006, Speaker A: Hi.
00:26:54.070 - 00:27:27.366, Speaker F: So imagine at some point it's possible to hide completely who's proposing the next block or the future blocks? Is there maybe like a threshold or some models on the percentage of stake that one validator might have to assume it's so high that you can optimistically assume that you will have two blocks in a row and create attacks that are profitable anyway, even if you don't know, because you know that you have some likelihood of having two or even three blocks in a row. Is there?
00:27:27.430 - 00:27:35.430, Speaker A: Yeah. So does it make sense if you can't see the future validators anymore? Sorry, what was your beginning of the question?
00:27:35.502 - 00:27:54.168, Speaker F: Yeah, imagine that we find a way that there is no future mev in the sense that you cannot know. Like there is an ethereum crate such that validators will not know in advance, but still there is stake. Maybe 30% is so high that it will still work. Is there some possible model like that?
00:27:54.256 - 00:28:32.460, Speaker A: So I don't think so. I think if you didn't know, you know, there would always be some percentage that you don't have blocks in a row, and it's probably not worth it. But I think the Ethereum upgrade you're talking about is the, the secret shared validators idea. And as far as I understand, they're the ideas that other people won't know when you're going to be proposing a block, but you yourself are still going to know ahead of time. So if I've understood that correctly, then it's actually not a solution to this problem. So I'm not aware of any solutions right now being proposed.
00:28:32.652 - 00:28:33.424, Speaker F: Thanks.
00:28:35.014 - 00:28:48.234, Speaker C: I think over here he had his hand up. Which one of you is frontrunning?
00:28:50.054 - 00:29:26.340, Speaker B: I had a question on account abstraction. So things like. So one of the things you can do with account abstraction is going to be to schedule transactions. And I think so I'm not an expert, but I would imagine that if you're using something like biconomy, for instance, in the case of the other side mint, you could basically say, okay, we're going to, you pre commit and you schedule transactions to happen over a certain amount of time to avoid having a guesswork. Right. Does that mean that then the operator is totally in control of, because you can, obviously you know how much you have to print and you know what the market is. Right.
00:29:26.340 - 00:29:33.594, Speaker B: So you could basically arb this as freely as you want. Does that mean that it becomes quite mercenary?
00:29:35.734 - 00:29:47.638, Speaker A: So I'm not super familiar with how the scheduling works. Me neither. Yeah. Okay. I mean, at the end of the day, the proposers will always decide which transactions go in the block.
00:29:47.806 - 00:29:48.134, Speaker B: Right.
00:29:48.174 - 00:30:19.784, Speaker A: No matter what you do, and there always has to be someone initiating the transaction. Like transactions never happen by themselves, even with a current abstraction. Yeah. So you'll still have the same problem if you're trying to get into a specific block. Maybe if there's some mechanism where you can just sign up for a mint ahead of time and they give you some different time windows or something like that, then yes, but I think that would just be like a design decision on how you create the min.
00:30:20.124 - 00:30:46.034, Speaker B: And do you think that if like as things grow and the transactional layer becomes basically happening on roll ups and not really on mainnet anymore, do you think that the fact that most protocols will, you'll be using zero knowledge proofs most of the time? Right. Do you think that this kind of arbs away the use the use cases of MeV?
00:30:47.614 - 00:31:24.964, Speaker A: So I don't think so. I think all of those execution layers are going to have their own MEV problems. You have usually some sequencer that just decides the ordering, and then that sequencer is basically in control of the MEV. And then the zero knowledge proof stuff happens afterwards, usually when the ordering on the roll up has already been decided. So, yeah, it's just a question of how you design the rights to order transactions. And I think you will definitely want to have some kind of bidding market where people can pay more to have their transactions included quicker.
00:31:25.904 - 00:31:29.272, Speaker C: Okay, I think we're going to have to stop there. Thanks a lot.
00:31:29.408 - 00:31:30.024, Speaker A: Thank you very much.
