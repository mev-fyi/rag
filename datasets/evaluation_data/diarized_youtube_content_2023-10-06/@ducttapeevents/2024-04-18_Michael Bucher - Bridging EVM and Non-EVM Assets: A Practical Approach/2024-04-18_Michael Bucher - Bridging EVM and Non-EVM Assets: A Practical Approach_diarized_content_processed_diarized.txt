00:00:00.400 - 00:00:55.654, Speaker A: Thanks for the nice introduction. So welcome to my talk here. This is going to be a practical approach, so it might get quite technical. So if you have any questions on pretty details, just talk to me afterwards. So we're axlabs, a team of five people, three located here in Switzerland. We've been developing tools for web three for a long time, for about six years now, and even also before we've worked with Web three, so we have quite some experience today. So we've worked with various VC's, corporates, binance and Okex, for example, use our tools to transact Neo, for example.
00:00:55.654 - 00:01:57.804, Speaker A: And we're also a core community of the neo blockchain, and we're in close ties as well with the hashgraph association. So here's a quick overview of what we're going to talk I'm going to look into here. So let's dive right into. So the neo ecosystem is quite a dinosaur and crypto, it's been here since 2014. Some of you might not recognize it because previously pre 18 it was called nshares and it did a rebranding in 2017. It aims to build a smart economy and its main part of the neo ecosystem is its blockchain, neo n three. It has the Neo VM, which is quite feature rich and dynamic flexible, but it's not EVM compatible.
00:01:57.804 - 00:02:56.412, Speaker A: We'll get into that later. It has a DBFT consensus, which means it has a one block finality. So whenever you issue a transaction and you see it in a block, you don't need to wait for further confirmations it's done. It provides native oracles and file storage as well, so you can easily store your files on a sidechain that's connected to Neo. It supports multiple languages, so you can, for example, develop your smart contracts in C sharp or in Java, or in Python, whatever you like best. It also has a special dual token model, so we have two tokens here. One is native gas token, which is used for utility things like transaction fees, and Nio is the governing token.
00:02:56.412 - 00:04:06.054, Speaker A: So when you vote with Nio and hold Nio, you earn gas. So you just need to hold gas and you get, you just need to hold Nio, and you get your gas that you need to pay for your transactions or pay for file storage, etcetera. So as you might know, the current situation is quite challenging for non EVM chains. It is not the main standard, like EVM has a large community already, so it has first mover advantages. So if you're a non EVM chain, it's just difficult if you would have EVM compatibility. It's just easier for integrating with central exchanges or issue a stablecoin, or also just generally to connect to institutions. Because most companies that start with web three, they will start with EVM compatible solutions.
00:04:06.054 - 00:05:23.888, Speaker A: On the other side, non EVM chains have also some R and D possibilities that EVM doesn't have. EVM is a bit slower, where non EVM chains can just have a faster pace, right? So the neo ecosystem wants to have both in its world. So EVM compatibility to connect to everyone that's out there that's already in the game and still keep this feature rich Neo VM that it already has. So introducing Neox, which will be the new EVM compatible side chain in the neo ecosystem, it will adapt the n three's dbft consensus, so you will also have a one block finality there. And more importantly, it will add a very great feature which is anti mev. So on Neo X, you. I'm not sure if it will become the standard, but it might that all transactions will be enveloped.
00:05:23.888 - 00:06:25.988, Speaker A: So they will be encrypted, and only after the ordering of the transactions is finalized, they will be decrypted. Besides, all that gas will be the native token on that chain. So usually some projects they come up with a new chain, right? And they will issue a new token. But Nio doesn't want to do that. They want to keep the current dual token ecosystem and they want to use gas because why? Why come up with something new if you have something that's already working? So the gas token on, on nio x should not be nu gas. So no new gas should be minted on that chain. Everything that's on neo x must have come from n three.
00:06:25.988 - 00:07:14.364, Speaker A: That's the goal. And also the gas production ultimately just stays on n three. Also important is that gas will be burned on neox to keep the ecosystem flourishing. Yeah. Further utilities for gas on neo x will be governance as well, which they don't have. So it will just extend the utility base of the gas token in general. So we need a bridge, we need to bring these gas tokens from neo n three somehow to neo x, right? So why do we need it? It's really simple, it's not rocket science.
00:07:14.364 - 00:08:15.634, Speaker A: We just need to move it and connect neo x to neo n three in this whole neo ecosystem. So when we were asked to help with that development, we had some requirements. So first one is it should be a low risk solution, of course, because you all know, bridges are pretty drawn to hackers in the recent past. So there shouldn't be a single point of failure, right? So there should be no single key holder. And also we want to decentralized the trust. Another thing is we don't have that much time to develop this. So we can't do much R and D.
00:08:15.634 - 00:09:07.424, Speaker A: We need to do it, but not too much. So we need to do more engineering. So here are some solutions that we, we consider Neo X as a layer two solution. And the solutions for the bridge would be an optimistic rollup or a Ck rollup. However, with the requirements that I just mentioned, it will take a long development time for some of them. For optimistic roll up, for example, we would need to emulate the EVM because remember, NeoVM is not EVM compatible, which will take quite some time. And Ckrollup, it's just a high complexity and we don't have the skill set.
00:09:07.424 - 00:10:11.704, Speaker A: So we would need to onboard new people that already know this, or otherwise we would need to learn it. But this takes a long time as well. So we went to the direction of a sidechain. So we need to bridge something without having this challenge option, right? So let's just take the most trivial approach that we could have. We could have just a central entity that just listens to one chain, right? Sees an event, a bridge event, and then creates a transaction on the destination chain and does that. But that requires a lot of trust, right? So before we will talk about what exactly we will bridge, we'll talk about how we will do that. So the goal here is to reduce trust.
00:10:11.704 - 00:11:06.114, Speaker A: And also what's not on the slide is increased security. As you can see here at the bottom are multiple validators. So our solution includes multiple nodes that are disconnected. They will listen to the chains if there is a bridge event, and then they will assign individually what happened, forward this to the relayer. And once the relayer has enough signatures of those validators, it will relay this to the destination chain. So the validators here act kind of like a multisig. In current stage, it's five out of seven multisig.
00:11:06.114 - 00:12:21.664, Speaker A: So with that said, let's go into what we want to bridge, right? Because just bridging every single deposit that happened to the other chain, it could lead to validators not signing something. They could just leave something out. So what you would want to do is to keep track of what happened in the past as well. So you can trust that the validators actually signed everything that happened in the past. So there are two approaches here that we considered. One is a state proof, which takes minimal computational effort, because on the origin chain, when you deposit something, you could just do the transaction, and in a smart contract, it would just stored that data, and that data would ultimately be included as a leaf, you know, in the whole Merkel Patricia tree, in the state proof. However, on n three, the state root is not in the header, so it doesn't really have final consensus.
00:12:21.664 - 00:13:01.134, Speaker A: On the other hand as well, to prove that on the destination chain is quite expensive. So remember, Neox is a new chain. So if a user wants to bridge something, he doesn't have any gas yet on Neox, so he can't claim. So what we really want is an automatic bridge. So we want to include the whole transfer, the distribution on the destination chain to be in the hands of the relayer. We can do that on a smart contract level. So we can force, whenever we update the route on a destination chain or on either chain, you need to provide data.
00:13:01.134 - 00:14:12.318, Speaker A: You need to provide the bridge data in order that you can do that. So that will be automatically. And we also considered Merkle tree, using merkle trees directly on a smart contract level. So we did actually a proof of concept for this, but it's just expensive. And another interesting problem we discovered was that there were variable transaction fees, which is a problem on a UI level. So if a user bridges something, provides some funds to pay for the transaction, and some other person comes with his bridge action before him, then maybe the transaction will just cost more and your funds will not be sufficient and fail. So then we asked ourselves, what do Merkle trees provide that we can actually afford to lose? And keep in mind, what I just said before is we want to have something automatic.
00:14:12.318 - 00:14:58.274, Speaker A: So we want to have the relayer prove what happened directly when updating the route. So we don't need the feature of merkle trees that someone can come after 20,000 deposits and prove this leaf, this deposit, was included. We don't need that, right? Because we do it on the go. So we don't actually need a tree. So what could we do? We can just chain it together. So it's no rocket science here. Chaining it together will just keep track of the whole history with having lower complexity, we don't need the claim.
00:14:58.274 - 00:15:29.604, Speaker A: And a downside though, is there's not really a proven record for that. But let's go for it. So here's the ordered binary hash chain that we use. So on the bottom right, maybe I can point here. You see, this is a deposit. So that represents deposit data. So let's say I want to bridge something, I send my funds to the bridge contract.
00:15:29.604 - 00:16:47.224, Speaker A: This will be the data, then it will be hashed, and then it will be connected to the previous root that is stored on chain and then hashed again and will be the new root. So it goes just up like this instead of a tree form. So let's go into challenges that we discovered when implementing this. So on a high level, of course, we have different smart contract languages. For example, the contract for neo x was written in solidity, but we can't write the neo n three contract in solidity, so we need to write that one in Java for example. But it has essentially the same needs, the same functionality on a business perspective. Right? Then standards, as of now with gas we don't really have the problem yet, but because gas will be the native token, right? You can consider gas on new x like ether on ethereum, right? But neo n three doesn't have erc 20.
00:16:47.224 - 00:17:31.613, Speaker A: Neo n three has another standard for fungible tokens. So you would need to include if you were to support fungible tokens, for example, you will need to map that. And there are other differences. For example, ketchup 256 is not supported on n three, so you can't use that hash function. So for example here we used sha 256. Then on a lower level you have big endian versus little endian from evm side. You probably don't even know about that if you're not working on a low level, because everything is big endian on the EVM.
00:17:31.613 - 00:18:10.974, Speaker A: However, on neo vm everything is little endian, so it's reversed. The bytes are reversed and then EVM has a fixed size data structure on vm level, while neo has dynamic structure. So on EVM, for example, you have un eight, un 16, un 64 and so on. On neo you have just int and the data. The bytes will be as long as they need be. So you don't have the limit of un 256 or whatever. Let's go into a quick detail about this.
00:18:10.974 - 00:19:01.900, Speaker A: So what happens if I deposit two on n three? We have nonce here. Then I want to bridge this amount, of course with the decimals. And this is the recipient address. So what happens on chain now in the contract is this is in hex, it's zero one, that's the hex for this amount. And then the address remains the same. Then we concatenate this data and then we hash it and we get this hash, eight, b e four, etcetera. Right? Now, when the relayer reproduces this on the destination chain on Neo x, he will provide this data here, and then the hash will be recreated to check whether that data is correct.
00:19:01.900 - 00:19:38.974, Speaker A: However, on Neo X, the data in bytes looks like this, lots of zeros. So the message will be different. So the hash will be different. So if you run easy recover on that, it will return another address and not the one that actually signed it. Right. So we need to fix that. So what we can do, since Neo VM is flexible, we can adapt to that and we pad the bytes to the same length that EVM requires.
00:19:38.974 - 00:20:26.802, Speaker A: So in order to get to the same message and get ultimately to the same hash, then we can recover the same signer. Again, one thing that's not on the slide is what I said before, big endian, little endian. These bytes here, actually, there's another step in between. They're in little ending on the Neo Vm, so this is actually in reverse on Neo VM, so on NEoVM, you need to reverse and then pat concatenate and you have the same message. So you need to consider a lot of things on a really low level. So, yeah, that's it. We are live currently on testnet t two.
00:20:26.802 - 00:20:59.364, Speaker A: We're developing as I speak, t three. We'll release that soon. You can scan here to get to know more about new x. Some future things we want to include is that the relayer could be open. Currently it's just restricted to one central entity. But as you know, we don't want a single point of failure. And we can also bring more validators to even decent, centralize it more.
00:20:59.364 - 00:21:30.420, Speaker A: So just quick takeaways here. Non EVM ecosystems, we can't just copy, so we can't just fork an existing solution and deploy it. And if you want to do this, if you want to create a bridge from non EVM to EVM, you need really good understanding of both vms to achieve that. Thanks for listening. And if there's any question, we have.
00:21:30.452 - 00:21:33.104, Speaker B: Time for one short question. If there's one question.
00:21:37.684 - 00:21:41.324, Speaker A: You can also ask me later if you want. I'll be here.
00:21:42.744 - 00:21:44.684, Speaker B: There's one. Oh, I'm sorry.
00:21:46.744 - 00:21:51.444, Speaker C: So is this a nonprofit or a for profit project so far?
00:21:54.344 - 00:22:01.528, Speaker A: Well, from our perspective, we're getting paid from the NIO foundation, so it's not a for profit.
00:22:01.616 - 00:22:01.872, Speaker B: Okay.
00:22:01.888 - 00:22:03.484, Speaker C: Okay, thank you. That was it already.
00:22:06.124 - 00:22:26.324, Speaker B: Thank you so much, Michael. I guess if anyone else has questions, you will still be around later on a little bit. Please stick around. Our next speaker will be getting ready in approximately two, three minutes. So thank you very much.
