00:00:00.640 - 00:01:03.964, Speaker A: And then, so we investigated that and then eventually we discovered that there was the portal network. So the portal network, I guess the idea is that it's, you're going to be having instead of just running a full node or an archive node or a light client, you can choose I guess sub networks. You could say I want to, I want to run a node in the portal network which covers the history network or the state network and things like that. And that's where I'll start with the slides. So just as a bit of background, so lite clients, they use this light ethereum sub protocol. They downloaded only the latest block headers as they appear and then they execute that as part of their own EVM. And then if they want any additional information, they request that on demand from full nodes or archive nodes.
00:01:03.964 - 00:02:08.636, Speaker A: So then if you, for example, if you're running, if you're a like client user and you want to interact with a smart contract that hasn't been used in the last hundred blocks, then you'll have to do an additional request for the state for that smart contract. And so that's part of the contract state. So when we were initially going through using ZK proofs, we also discovered acxiom. And I was fortunate I got to speak with one of their leads and he sort of went through and said yeah, they can actually cover everything that we need. Later on. We actually looked at adopting ZKe EVM as an alternative as well, which was interesting. Yeah, but I guess what we generally found was that the full and archive nodes, they've already got the state, so that you don't necessarily need these EK proofs.
00:02:08.636 - 00:03:24.574, Speaker A: Whereas in for example the portal network where you might be having like clients interacting with other light clients, or just more peer to peer rather than light client to full node, then that might be an application for ZK proofs. So just a quick summary of the portal network. They've got great docs, but I'll just sort of try to summarize it on one page. So they split the Ethereum data into different types and they basically run JSON RPC, JSON RPC servers. So you can gossip information from where you can run a node, they've got different implementations that you can run a rust implementation, a Go implementation, a typescript implementation, and you can specify whether you want that to be running a dedicated sub network. So it could be the history history network, the state network, transaction gossip network, or canonical indices network. And they're in different stages of development since it's quite early stage and you can choose how many megabytes of storage you want to use on your device and so forth.
00:03:24.574 - 00:04:14.386, Speaker A: Yes. The main goal, a couple of their main goals is to spread the Ethereum data. Instead of just being on the full nodes or archive nodes, you can split that amongst multiple portal network node peers. And there's this EIP 4444 which is proposing to limit the, I guess, the cost of participating in the Ethereum network. So the idea is that maybe data that's more than one year old, that could be something that you could be querying a portal network node, whereas other nodes might only have to, they could prune certain amount of blocks and only focus on more recent information. Yeah. And so if you wanted to access information in these portal network nodes, they have like key value pairs.
00:04:14.386 - 00:04:58.854, Speaker A: So you've got content keys, you can, so you could gossip information. There's a method called gossip, so you can say I want to gossip a string of data and it sends it to within a certain radius that you can specify nodes that are around you. And then you could, you could, I think there's a fine content method so you can check that, check that they've, that those nodes have received it. You can check how many nodes actually received as well. Yeah, and the different implementations. So Trin is the rust implementation of the portal network. And the other ones, there's ultralight, which is the typescript implementation, and there's others as well.
00:04:58.854 - 00:06:19.804, Speaker A: So I guess some of the solutions that port network provides is that allows you to request Ethereum data from another light client, peer or whatever trin node sub network that you're running. Those, those lite clients can run as both a client and a server instead of just only a client, so they can interact in a distributed fashion. So there's some great YouTube videos from Pipermirium that shows it's distributed rather than just decentralized. And it's, yeah, I'm not necessarily saying it's a few years from completion, but yeah, it's not in progression. And yeah, it's also said that it's going to be solving the like client problem, which I've already mentioned in terms of the burden on the fallen archive nodes. And yeah, so the benefit of zero knowledge proofs, I guess that's a question that I still sort of ask myself because I'm not quite sure. And so I guess the zero knowledge proofs, the idea is that with zero knowledge proofs is you'll be able to prove, prove to verify that you know some information without disclosing all that information.
00:06:19.804 - 00:07:39.114, Speaker A: So for example, you might have the, you might retrieve the block header from a block and then you might generate a zero knowledge proof based on certain information in that block header and then share that with other nodes. And the size of that, the size of the zero knowledge proof might be, it might be more succinct than a Merkle proof or other ways that you might be able to verify that you've got the latest information. So that's something to investigate further. But yeah, in terms of the, we progressed through different ways of generating the ZK proof. So initially looking through axiom, we had some mentors that were helping us go through this whole process as well. So basically obtaining the idea is that we'd query for the latest finalized block header, which was the pre state that would serve as what they call the witness in the zero knowledge proof terminology. So for example, we might use the get block by hash method.
00:07:39.114 - 00:08:56.976, Speaker A: And if you're running many of the light clients, they often have to like for example helios, you need to, if you're interacting with a node that has to be supporting the get proof method to be able to get that latest block hash with all the information that you need with all the transactions. Yeah, so we're only interested in the latest state. So that the latest, for example, you might want just all the accounts that we need to execute a transaction in the latest finalized block, not the full history. And then the idea is that we filter that pre state to only include what we were interested in and that would be what we'd use to generate the proof and distribute that proof. And then there's in acxiom they have, you can generate a proof, a back end server to generate the proof. And then they have on chain smart contracts where you could verify that the proof. So you might distribute that proof to various nodes and then they can check on chain whether it's use that as a way of verifying it.
00:08:56.976 - 00:09:28.794, Speaker A: And then there's another, another approach that the team were looking into which was Zke EVM. So privacy and scaling solutions has got a repository, ZKE EVM circuits, which has got a lot of open source tools which we can use. I didn't really go deep enough into that. That was something that other team members worked on. So yeah, I'm just going to quickly go through what I eventually got to work. So initially I was trying to use Trin. I set up a couple of nodes, I was getting request timeouts.
00:09:28.794 - 00:10:12.196, Speaker A: I couldn't quite work out how to, you know, what I was doing wrong. Some of, I got some great support they said oh, maybe something wrong with the external IP addresses and I couldn't work it out. And then I thought if I run there, it's in rust, so I could run cargo test and all their tests would pass. I thought, well their test cases were essentially exactly the same as what I'm doing when I'm running two nodes. So I thought well, at least I can make some progress just getting stuck into their tests. So yeah, just bit by bit. And that was what other team members were doing as well, just writing short simple scripts to understand the code base.
00:10:12.196 - 00:10:17.784, Speaker A: So this is just basically some of the.
00:10:19.844 - 00:10:22.276, Speaker B: Some rust like rust test code.
00:10:22.300 - 00:11:20.224, Speaker A: So target one, but anyway, if you can read what that's basically saying, it's saying there's a basically going to be sending, gossiping some information from target one to target two, so that they're both client trin clients. They're both running a client, a version of Trin. So I want to make sure, I want to check what those versions are. They've both got an ENR Ethereum name, I can't remember what it stands for, actually. Something resource, ethereum name resource or something. It's got the node id which has got various information about the node, and you can get the ENR which is of this certain form, ENr colon and so forth. So that's just information about the nodes.
00:11:20.224 - 00:11:46.496, Speaker A: And then you're essentially just sending some string information. So in their existing test they were already sending across proofs which were strings, string values. So I guess you could just send zero knowledge proofs in a similar form. So you could in your test cases you could set up a fixture that just generates that, just obtain a string. And then at the bottom of this.
00:11:46.520 - 00:11:52.724, Speaker B: Screen you can see I'm calling the store method to store.
00:11:54.424 - 00:12:03.586, Speaker A: A content value under a content key on the original target. Then I'm at the bottom of the.
00:12:03.610 - 00:12:06.402, Speaker B: Screen, you can see I'm calling wait for history content.
00:12:06.498 - 00:12:19.242, Speaker A: So waiting for that content to be stored on the local, on the originating node. And this is just so you can see in this that's sort of a.
00:12:19.258 - 00:12:27.658, Speaker B: More, all it's doing is calling the client and calling local content and just checking that it's there and it just.
00:12:27.786 - 00:12:42.956, Speaker A: Retries if it doesn't to find it straight away. And then you can verify, do an assertion to verify that it's present or not. So it's, was it possible history content value?
00:12:43.060 - 00:12:45.772, Speaker B: If the content's either present or there's.
00:12:45.788 - 00:12:49.060, Speaker A: A match, you're doing a match, a match case, like a switch statement, checking.
00:12:49.092 - 00:13:04.112, Speaker B: If it's present or not, and if it's present, then you return that as the result to receive content value. Otherwise it's absent in your panic or failure test case. And then you assert that it's the.
00:13:04.128 - 00:13:18.764, Speaker A: Same and then you can use this gossip method. So gossiping the proof from the trinclient one to trinclient two, if there are other nodes that could do the same, only tried it with one.
00:13:19.464 - 00:13:31.464, Speaker B: So, yeah, so target one is calling the gossip method, providing the content key and the value which we did ck proof and.
00:13:34.284 - 00:14:05.874, Speaker A: Whether it was gossip to one other node or not. And if that passes, then that's great. And then you can call. Well, I created this wait for history content from remote, which is pretty much the same as what they already had, but I'm calling. This was based on feedback from the trin team saying that we needed to call. That's just doing lots of assertions, but all it's doing is calling find content.
00:14:08.014 - 00:14:12.786, Speaker B: So you're providing the client the remote DNR and checking that it's, it's been.
00:14:12.850 - 00:15:07.918, Speaker A: Received and stored there. Yeah. And then, and then after that, the trin client two could use axiom smart contracts to verify whether it's received a valid zero knowledge proof or not. Yeah, so that's the presentation. Any questions? I guess initially was working out which tools, how do you get them running? So initially I thought, well, I'm going to use Helios, just a light client. I need to get the block headers from somewhere. And I was using rust.
00:15:07.918 - 00:16:18.630, Speaker A: I thought I could use Loadstar or typescript, which I'm probably more familiar with, but I thought I'll try and put a bit more energy into rust because the other team members were using rust too, and I've got unfamiliar with that too. And Helios had some good documentation. I tried it and I was getting issues and I'd create issues on the GitHub repo. The maintainer was really responsive, so I kind of felt really that, that made me feel good that, you know, now I feel more comfortable using the Helios repository, you know, so. Yeah, and that uses this, what they call them, the checkpoints. So when you can, when you want to run a Helios node, you basically specify is it a consensus, a consensus API key and an execution API key, so you can use alchemy or just to configure it. And then you go on to the different block explorers and you get one of the oldest finalized block headers and you specifies that as the checkpoint.
00:16:18.630 - 00:17:22.792, Speaker A: And then run the node and it syncs, and then you can query that node to get the latest block headers. So that was what I was doing initially, and then Trin, we were going to do that as a second stage because although I guess the code base was really nice and it was easy to understand, I thought in terms of a prototype, is it going to be something that we can, is it going to be something that we'll be able to show? I thought if we've got the lite client, maybe we could modify it to share, to share, to gossip some information. I thought, well, maybe that's going to be a lot more work than using Trin. And all the work's already been done on Trin. It's just, it's still early stage and it's already going to be solving so many of those other problems. So, yeah, so in terms of setting things up, it was. I was using Docker initially, just creating docker containers to quickly spin up helios and quickly spin up trend thinking.
00:17:22.792 - 00:18:08.002, Speaker A: I can quickly all do it in Docker and just do a one single command. And then I ended up just writing some simple test cases. And that gave me the peace of mind that I needed. So I think the main learning was start with the tests. Yeah, I think that's what you said in your presentation, that you got carried away with the test, because I guess you get a lot more confident with your own work or other people's work. Same with GitHub issues. Once you're comfortable, go through their open source issues, feel comfortable with what the state of that repository is, and then you want to keep working on it.
00:18:08.002 - 00:19:36.794, Speaker A: You'll make new connections and. Yeah, I think you already can. Working like client. I haven't tried it, but I can't see why you couldn't, why you couldn't run helios and then you just go into metamask and just add whatever local host 8545 or. Yeah, yeah, I don't know if that's problem that I'll be solving, I guess. Yeah, I guess for mass adoption, if everyone likes using metamask or they feel more comfortable doing that than from the command line. Yeah, I don't really know how to answer that question in terms of even signing transactions using metamask and seeing what transactions you're signing, I guess seeing those as things progress or different wallets, protecting the consumers so they can see what's going on.
00:19:36.794 - 00:19:54.274, Speaker A: Yeah. Any other questions? All right, thanks very much.
