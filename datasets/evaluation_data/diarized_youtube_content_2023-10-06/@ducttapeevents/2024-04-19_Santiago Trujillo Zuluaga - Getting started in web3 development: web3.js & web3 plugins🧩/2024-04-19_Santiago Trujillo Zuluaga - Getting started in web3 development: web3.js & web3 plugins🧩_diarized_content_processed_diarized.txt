00:00:00.440 - 00:00:11.494, Speaker A: Okay. Can you hear me properly? It's fine. Okay, perfect. Yeah. Thank you so much, Herman, for that intro. Yeah, but something that I want to add is like ethers is fine. We are not competitors.
00:00:11.494 - 00:00:50.996, Speaker A: We are really just trying to build more tools for the ecosystem. So we are actually really good friends. But yeah, you should try to go into web3 js and I will support you personally if you need anything with web3 js. So today is kind of like a mix of a workshop and a talk. I'm going to show you how you can get started if you are a web two developer, or if you are coming into web3 and you want to know some things, you are going to learn today, how to get started with web3 js. So we are going to learn about web3 js. We are going to talk a little bit about remix id, like we are going to write a little smart contract and then we are going to deploy this to Sepolia network as well.
00:00:50.996 - 00:01:33.978, Speaker A: You will be able to deploy your first smart contract and interact with it. This is what I'm going to cover today. First a short intro to web3 js, like the milestones, the timeline that we have. Then in web3 JS basics, I'm going to code a little bit, deploy the contract, interact with the contract, and then I will show you some code samples as well for sending transactions, listening to events in the blockchain. Then I'm going to talk about Webtree plugins. So this is a new feature that we released last year that allows you to create SDKs, interfaces or any developer tooling for projects in web3. At the end I to show you a chainlink plugin that we have built for Chainlink.
00:01:33.978 - 00:02:07.306, Speaker A: So yeah, I'm going to demo that at the end. So yeah, let's start with the web3 JS intro. So what's web3 js? Web three JS is basically a JavaScript typescript library that allows you to talk to any EVM blockchain. Normally if you're a developer and you want to interact with the blockchain, you need to send these things that you see in the top that are basically JSON RPC calls. But if you're a developer and you need to talk to the blockchain, that would be really complicated to write these JSON RPC calls manually. So that's what you need to do. That's what we do at web3 js.
00:02:07.306 - 00:02:33.194, Speaker A: We kind of abstract these JSON RPC calls into JavaScript. So when you want to get, for example, the getblock number of the blockchain. You don't need to write these RPC calls and you just write the web tree getblognumber. And it's a way easier way than these JSON RPC calls. So that's basically web3 js. If you want to talk to a different blockchain. In this case you need to initialize the web3 object here with a different RPC endpoint.
00:02:33.194 - 00:03:11.504, Speaker A: So in this case this is to talk to the Ethereum mainnet. But if you put a polygon endpoint here, you will be talking to the polygon mainnet. This is kind of like a Dapp communication flow that allows you to understand the big picture of a dapp. So if you have a dapp, this dapp will be used in the background web3 js and then web3 js will use this provider, that is the RPC endpoint, to communicate directly to the blockchain node. So that's why Web three JS is compatible with any EVM blockchain. Just by changing this endpoint that you see here, this link, you can talk to any different network. So yeah, that's how it works.
00:03:11.504 - 00:03:45.032, Speaker A: That's the Dapp communication flow. This is a short timeline that we have for Web three js. Web three js was created in 2014 by Jeffrey Wilke, one of the Ethereum co founders. Then after that, Merrick Kodewigs from parity tech joined him as a lead maintainer of the library. Web three JS is open source, so anyone can contribute to the library. Then in 2015, Fabian Bodil Steller, the ERC 20 standard creator, took over as a lead maintainer of the library. So far he's still the number one all time contributor to the web3 JS repository.
00:03:45.032 - 00:04:28.956, Speaker A: And then in 2020, Chainsafe came into the picture to take over as a lead maintainer, thanks to the Ethereum foundation and nomic Labs foundation, and since then we have more than 1000 pull requests from external contributors. We have 18,000 stars on GitHub and we have released the version 4.7 last week. Some of the milestones that we have at Chainsafe with web3 js in these three four years. The main one is that we rewrote and refactor the whole library from JavaScript to typescript because it was written in JavaScript. Now, web3 Js is compatible with ECMAscripts and CommonJs modules. We reduce the library size from 329.
00:04:28.956 - 00:05:06.260, Speaker A: We revamped all the documentation as well, so you can find all the APIs, the tutorials all the code samples and videos as well. We have videos on YouTube about how to get started in web3 js. And the last thing, the usage that we have right now, we have around 2 million of NPM downloads per month and 19 million of CDN requests. So we are still around and we have a lot of usage currently. Ok, so now let's go to the fun part. These are some basic things that you can do with web3 js. So you can fetch data from the blockchain, interact with wallets and accounts, deploy contracts, listen to events and transactions.
00:05:06.260 - 00:05:33.204, Speaker A: I'm going to do the first five more or less, and then if you want I will share this in the web3 js Twitter later. So if you want to see them you can just click there and then you will be redirected to the slides. So the first one is. Yeah, so let's start with the web3 JS installation. So what I'm going to do is just to create a note project. It's taking a while. Yeah.
00:05:33.204 - 00:06:00.884, Speaker A: And then I'm going to do like everything from scratch with you. So you will be able to follow. So the first thing, if you don't want, if you don't have for example versus code or any code editor, you can also use a stack blix. This is a really good alternative. And then you can just create no JS project here. But yeah, in this case I'm going to use my code editor. So let's say it's Zurich.
00:06:00.884 - 00:06:28.674, Speaker A: Perfect. So here I'm going to create node projects. To create a node project I'm just going to type NPM init y. So to make sure that we created a node project, you will see the package JSON in the code editor which is here. Perfect. So now we have this node project. So to install web3 js we just need to run NPM install web3.
00:06:28.674 - 00:07:06.760, Speaker A: So that's what I'm going to do now. NPM install web3. And then you will see the web3 library here in the dependencies a few seconds after the installation. The main things that we have to do now is to initialize the provider. So this provider is the node endpoint that I told you that you can change to talk to any blockchain. So what we can do is first we need to, let me just create an index JS file. We need to import the library, the Webtree module.
00:07:06.760 - 00:07:38.692, Speaker A: So we just need to type const curlybraces Webtree with the W oper require from web3. Ok. And after that we need to initialize the provider. So to initialize the provider we just need to type new web tree and then we put here the node endpoint that we want to talk to. One thing that I recommend, if you are testing, you can come to chainlist.org and you will find a lot of different node endpoints. For example ethereum mainnet, binance, smart chain, arbitrum.
00:07:38.692 - 00:08:05.524, Speaker A: In this case, let's talk to the ethereum mainnet. So I just click here and then you will see a lot of endpoints here, right? In this case I'm going to use the first one. Eat lamarpc.com dot just put more zoom here. Okay. And then I just put that here. Okay, so now web3 js is able to talk to the Ethereum mainnet.
00:08:05.524 - 00:08:55.708, Speaker A: So if we want, let me just fetch data from the blockchain. The first thing that we can do after we initialize the provider is to fetch data from the blockchain. So to fetch data from the blockchain, we just need to use the Webtree eat package and then we can use any method that we have. We have a lot, that's why I put here the link if you want to explore more. So the first one, let's just create an asynchronous function. Okay, so in this asynchronous function, I'm going to fetch, let's say the block number, the latest block number, and then I'm going to store this in a variable, let's say called block. Okay, so this is how we can fetch the latest block number or you can also use get price.
00:08:55.708 - 00:09:24.174, Speaker A: You will see all the different methods here. If you want chain, id, et cetera, get block number. And then let's just print that here, ethereum. Then let's put block and then if we run this, hopefully that will work. We can see that this is the latest block number. And then a little extra thing is, for example, let's fetch the same block number but for the polygon. So what we can do is that we can type web3 setprovider.
00:09:24.174 - 00:10:06.742, Speaker A: And now I can set an endpoint here to talk to Polygon. And then I can come back to chainlist. Then let's look for polygon, Polygon, LamarPc. And then if I run the same thing here, but this polygon, then block two, let's say block two. And then if I run the same, then we'll have Ethereum is this one and then in polygon it's taking a while. When that happens, it's because the RPC endpoint is kind of that happens when you use public RPC endpoints. So normally you should use like alchemy.
00:10:06.742 - 00:10:23.268, Speaker A: Quick note. Yeah, let's run it again. Oh yeah. And then we have here, so this is the latest block number for Ethereum and this is the latest for Polygon. So yeah, this is how you can fetch data from the blockchain. Now let's do something else, do something more exciting. Ok.
00:10:23.268 - 00:10:55.254, Speaker A: Interact with wallets and accounts. So who from here knows what is an account? Everyone knows what is an account in web3. Ok, perfect. Yeah. Basically an account is just a pair of a private key and an address, right? So if we want to interact with an account, what we need to do, there are two different ways. The first one is with a private key, so we can initialize our own account with a private key, or we can just create a random one. Always we need to import the web3 module and initialize a provider.
00:10:55.254 - 00:11:31.484, Speaker A: So I will copy paste this. This is like a requirement everywhere. For whatever thing that you do with Webtree js, you need to import the Webtree module and initialize a provider. So for accounts I will just copy paste the same. And then we just initialize a wallet by typing web3 it wallet add and you can put your private key here, just remove these things. Perfect. So if I go to metamask and then I check my private key, this one, and account details show private key.
00:11:31.484 - 00:11:58.164, Speaker A: Don't forget to use this solely for testnet. And don't put public funds here. So I will put my private key here, starting with zero x. That's something that is a requirement for all the hexadecimal values. Now I'm able to interact with this wallet. So if I console the wallet, you will see what we have in this wallet node accounts. Perfect.
00:11:58.164 - 00:12:35.094, Speaker A: So we have a wallet with one account, which is this address, this private key. And then we have some methods which are signed transactions, sign data, encrypt, and some other things that web3 js will use under the hood to be able to sign and send transactions. So that's how we can interact with a wallet. So that's basically that part we need always to initialize a wallet if we want to deploy smart contracts or interact with the smart contracts. Okay, so now let's deploy smart contracts. So what I'm going to do here is that I'm going to remix id. I'm going to write like a simple smart contract with two functions.
00:12:35.094 - 00:13:10.254, Speaker A: Let me just create this, let's call it message sol always to write a smart contract, we need to put a license. So I will just copy paste this a license and the compiler version. When you go to remix, you will see this default workspace with contracts, scripts and tests. But yeah, we don't really care about that today. We will also use the solidity compiler here to make sure that the contract compiles properly. And then let's just write the smart contract. I will use the version zero 8.7
00:13:10.254 - 00:13:39.714, Speaker A: can use like any version. That will be fine. Then to create the contract we just need to type contract. And then let's put my contract here. Perfect. So this contract will have, it's showing me this error. This contract will have one state variable, which is a string that will be a message, right? So let's put message here, a constructor who doesn't know who is a constructor, I can explain the constructor.
00:13:39.714 - 00:14:09.924, Speaker A: Perfect. So a constructor is a function in the smart contract that you can call only once, and that once is when you deploy the contract. So if you have the contract that you want to publish or deploy in the blockchain, you can use this constructor only in the deployment. But then after that the constructor kind of disappear that you cannot call that anymore. So that's the constructor. This constructor will receive the first message to set up this message variable here. So let's call it first message.
00:14:09.924 - 00:14:39.556, Speaker A: And then to do that we just need to override this, that perfect. So this will rewrite the, the message. And then we need two functions. One function to get the message, the current message that we have, and then one function to update the message. So the first one will be to get the message, call it like this. This will be external view returns memory. Okay.
00:14:39.556 - 00:14:54.732, Speaker A: And then this will return this. Let me just put some zoom. This will return this message that we have here. So we just put return message. Okay, perfect. So that's the first function. Then the second function is to set, let's say update message.
00:14:54.732 - 00:15:17.968, Speaker A: So this will be external, and then this function needs to receive as a parameter a string that will update the message. Right. So let's put here string memory, new message. And then here we just overwrite the state variable with the new message. Perfect. Any questions so far? With the functionality of the contract, it's kind of clear just to set a message. Perfect.
00:15:17.968 - 00:15:57.714, Speaker A: And to retrieve the message. Okay, so if we want to deploy this smart contract using web3 js, we need two things, the ABI and the bytecode. So if you want to know where to get this ABI and the bytecode, you can come to solidity compiler here. Then you can scroll down and then we'll see the ABI and the bytecode. Like remix id compiles this in the background and then that gives you the ABI and the bytecode. The API is basically an interface that allows JavaScript or web3 js to talk to the contract because it will kind of destructor the functions in a way that is readable by Webster js. And then the bytecode is what is deployed in the blockchain.
00:15:57.714 - 00:16:25.210, Speaker A: So let's copy the ABI here. And then I will just create an Abi JSon file. And then I just paste this and the bytecode JSon. Perfect. This bytecode needs to be within quotation marks and starting with zero x because it's a hexadecimal value and all the values in the blockchain are stored in as a hexadecimal value. So starting with zero x. Perfect.
00:16:25.210 - 00:16:56.234, Speaker A: So now we have the ABI, now we have the bytecode. So now let's create a script to deploy the smart contract. So again, what we need to do is to import the Webtree library. Let me just copy this. So we just need to import the Webtree library. And then we need to initialize the provider in this case, because I don't want to deploy this to the Ethereum mainnet, I need to look for a provider to talk to Sepolia Testnet. So I can just type sepolia.
00:16:56.234 - 00:17:27.525, Speaker A: We can check this, include testnets. Then we'll scroll down and we will see Sepolia here. And then the same thing. Let's just get this sepolia from tenderly. Okay, so now we are talking to the sepolia testnet. And then let's create the function to deploy. Okay, so the first thing here I have in the slides to deploy the contract is to initialize a wallet.
00:17:27.525 - 00:17:56.194, Speaker A: Now you know how to initialize a wallet. We just need to use the wallet add and then the private key that I already have in accounts. Make sure that you have funds in this wallet, otherwise it will not deploy the contract because you need funds to deploy the contract. So if we come here, you will see that I have 1.9 sepolia ETH here. Okay, so now we have the wallet with funds. We initialize the contract by typing new web3 it contract and then we pass the ABI.
00:17:56.194 - 00:18:23.010, Speaker A: Oh, I need to import the ABI here require and I need to import the bytecode as well. Perfect. So we just need to pass here the ABI as a parameter. So web3 js knows what is the structure of this contract. After that we need to create this contract deployer. So we just need to type the contract instance. In this case, it's my contract deploy.
00:18:23.010 - 00:18:49.154, Speaker A: We use this method deploy and this will receive two parameters here. The first one is the data, and then the data that we are deploying to the blockchain is the bytecode itself. So that's why we need to send the bytecode. And then the arguments are the arguments of the constructor. So in this case, the constructor is receiving a string that will be the first message. So we just need to send any message. Like for example, hello Zurich.
00:18:49.154 - 00:19:17.674, Speaker A: Right? And then after that we can send the transaction. To send a transaction, we just type deployer send. And then in the send we need to specify which account is sending the transaction. So in this case it will be my wallet, my wallet. And then in the position zero of this array address, which will be this account. Or if you don't really get that part of the array, we can literally just copy paste the address here. Something like that.
00:19:17.674 - 00:19:48.242, Speaker A: Yeah, so this is my wallet. In the position zero address is basically this address here. And then if you want to know the address of the deployment. So we can store this transaction receipt here. And then we can just print it. Console log, transaction receipt, transaction receipt options address. And then in this way we will get the contract address once we deploy it.
00:19:48.242 - 00:20:07.914, Speaker A: So now let's run this. Hopefully it will work as well. Clear note, deploy. Okay, when we get this rate limit exceeded is the same thing that happened when you use public RPC endpoints. So let's just change for another one. Oh yeah, let's change another one. Let's run it again.
00:20:07.914 - 00:20:36.426, Speaker A: And if not, I will just change it. Okay, so now let's change the RPC. Okay. Silence. Hopefully it will work now. Perfect. So now we got the contract address, which is this one.
00:20:36.426 - 00:21:05.118, Speaker A: So we can go to Sepolia Eaterscan IO, which is like the iter scan of the blog explorer of Sepolia. We can put here this address, which is the address of the contract that we just deployed. And we'll see that there is nothing here. This is updating. This takes like a few seconds and then the contract will be here. Yeah, perfect. So we can see that 29 seconds ago I just deployed this to the sepolia testnet.
00:21:05.118 - 00:21:30.174, Speaker A: We can verify the contract. Verify the contract is just basically publishing the code. So every time that someone interacts with this contract, they will know what is the code of the contract that they are interacting with just by clicking verify and publish here. This is the address that we just deployed the contract. This is a solidity single file. This is just like one file. You saw it, compiler version is zero 8.7.
00:21:30.174 - 00:22:04.664, Speaker A: So we can put this zero 8.7 and the license type is this one GPL. Yeah, three. Perfect. So we can continue enter the solidity code. So we just need to copy paste the whole code here and then put it here in the sepolia blog explorer, verify and publish. Perfect.
00:22:04.664 - 00:22:29.660, Speaker A: So now the contract is verified. So now if we go to sepolia ether scan, we'll see that the contract has this little check. Because it is a verified contract. That is a verified contract doesn't mean that it's not a scam contract. You can still have verified scam code. It just means that the code is here so you will be able to see the code. As you can see, it's just the same code that I just wrote in remix id.
00:22:29.660 - 00:23:00.232, Speaker A: And you can also interact with the contract clicking here in read contract. So if we read contract and we go to the getmessage function, we'll see that this is the last message and the write contract. We can set up a message, but then let's do this with the scripts using web3 js. So that's how we deploy a contract with this code. Now interacting with contracts, there are two main functions and contracts that we can interact with. One is the reading functions that just retrieve value. And then one is the writing function that we can update a value in the contract.
00:23:00.232 - 00:23:25.878, Speaker A: So to interact with these reading functions, we just need this code. Let's put interaction. Yes. Okay, so I will just copy paste the same thing of the import web. Three js import the ABI. Because remember that we always need the ABI to interact with contracts. And then we initialize the provider with the sepolia endpoint.
00:23:25.878 - 00:24:00.990, Speaker A: And then let's create a synchronous function here and we can put this inside. So what I'm doing here is first we initialize the contract by typing new web tree. We need to send the ABI as a parameter and then the address of the contract that we can find it here in the sepolia. So I can just copy this address here and put it here. Perfect. So now we are interacting with this contract. What I'm going to do is to call the, what was the name of the function getmessage.
00:24:00.990 - 00:24:34.066, Speaker A: So if we want to interact with this getmessage function, what we need to do is to type my contract methods and then the function name that we are calling in this case will be getmessage. And then we put call, because this is just making a call, this a reading function. But if you are sending a transaction, you just put send. So yeah, in this case, call, we can store this value in the say response. And then we can just print this and let's run it now. Interaction. Okay.
00:24:34.066 - 00:24:54.618, Speaker A: And then we can see that we just got the value that we just updated in the smart contract. That is hello, Zurich. So now let's interact with the other function, which is setmessage. So to interact with that function, what we can do. Let me just put setmessage here. Let's change this one for readmessage. Perfect.
00:24:54.618 - 00:25:37.500, Speaker A: So, to interact with this read setmessage function, I also have here some code interacting with writing functions. So this one, the only difference with this one and the reading functions is that we need to set up a wallet because we are sending a transaction. So every time that we are updating the state of the blockchain or interacting with our writing function, we need to send a transaction. So that means that we need to have funds in that wallet. So first we need to initialize the wallet the same way that I did it previously. Here with this private key using Webtree ETH wallet add. And then we just add this private key with funds, initialize the contract, new Webtree ETH contract.
00:25:37.500 - 00:26:03.324, Speaker A: We just pass the ABI and then the address again. Same here. We always need to initialize a contract if we want to interact with a contract. And then yeah, we are all set to start using the to send a transaction. So here is the same thing. My contract methods function name in this case is setmessage thing. Update message is update message.
00:26:03.324 - 00:26:31.240, Speaker A: Perfect. Update message send. And then we need to specify the address from where we are sending the transaction. So in this case will be this wallet address. And then this will return the transaction received. So if you want to print it, we can just put this, store the value in the transaction received and print it in the console. Or if you want to just get the transaction hash, let's just print this and then you will see everything.
00:26:31.240 - 00:26:48.036, Speaker A: And then we can call setmessage. Let's just call setmessage. Now you still need to put in the message. Oh, yeah, you're right. Wow, you're okay. You are engaged. Thank you.
00:26:48.036 - 00:27:14.404, Speaker A: Tell me the message. What do you want to put? No pressure. No pressure. An emoji. I don't know what will show in the blockchain. I don't know if that will be able to now we can recall, let's see. Ok, let's see if that will work.
00:27:14.404 - 00:28:06.138, Speaker A: Ok, so now the interaction, then we are using this and then we will get the transaction receipt here. The main thing in the transaction receipt object will be the transaction hash. Because if we have the transaction hash, we can copy paste this value in the, in the blog explorer and you will see the transaction. So this is all the transaction object, the block hash block number, all these things from the wallet that I sent the transaction, the gas used, and the transaction hash is this one. So let's copy this and then we can go to the blog Explorer, we put the transaction hash and then here we can see the transaction information. It's success. The blog, the status to the contract that we kind of communicated to from the wallet, that is my wallet in this case.
00:28:06.138 - 00:28:36.326, Speaker A: So let's check what is the message that we have right now. We can see here that 37 seconds ago I just called the update message function. So contract read, contract getmessage and we have this lovely rocket. That was a great idea. Perfect. So then if we do this now if we can read the message again, let's see what's the value that we get here? Node interaction. Ok.
00:28:36.326 - 00:28:50.234, Speaker A: And now we get this rocket. Wow, that's amazing. Perfect. So that's basically how you can interact with a contract. Then I have also some other code here. If you can listen to the events, you can send transactions. I'm not going through all these things.
00:28:50.234 - 00:29:11.040, Speaker A: Ok. And now I can walk you through the web3 plugins. Yeah, we are kind of on time. That's perfect. To show you the Webtree plugins. The web3 plugins is just a latest feature that we have in web3 js. You can leverage any web3 js functionality to create your own SDK, your own interface, or your own developer tooling for any type of project.
00:29:11.040 - 00:29:48.102, Speaker A: So some of the use cases that we have are creating custom RPC calls. This is useful for layer ones or L2s that are kind of a little bit different from ethereum if they have some specific RPC methods. This is a really easy way to create web3 APIs for web3 developers because they don't need to care about ABIs contract addresses, they can just directly interact with JavaScript with these functions. Also contract wrappers, complex function arguments, custom logic, and oracle calls. Let me put this full screen. Okay. Why web3 plugins? Web three plugins will give more accessibility to all.
00:29:48.102 - 00:30:32.444, Speaker A: The web3 projects will drive more adoption as well because it's really easy. Everyone uses JavaScript or at least it's the most used language among developers. This is also really scalable because the web3 plugins are just NPM package with a lot of reusable code that any developer can use at any time. And the short learning curve of learning a web3 plugin is way easier than learning a protocol from scratch. So if you create a web3 plugin like a Uniswap SDK, for example, it will be easier to understand the Uniswap SDK instead of going through all the different contracts and mechanisms of uniswap. How you can create a web3 plugin? This is the code. The first thing that you need to do is to import the web3 plugin based module from the Webtree library.
00:30:32.444 - 00:31:20.102, Speaker A: Then you can create a JavaScript class, in this case my plugin, which extends from the Webtree plugin base, you need to put a name, in this case the property plugin namespace. And then I just put this, my plugin, and then you can create any methods that you want. So you can send transactions, deploy contracts, interact with contracts, listen to events. One of the use case that we have that was like a fun thing for hackathon that we did is integrating a web3 plugin with the Google API. So we have a plugin that can listen to events in a smart contract, let's say a token. And then using the Google API, you can write all these different events into a Google spreadsheet. So this is just like, this gives you a lot of unlimited possibilities to integrate web3 with web3 or web3 with web two and everything.
00:31:20.102 - 00:32:03.738, Speaker A: Yeah. So this is just some of the, oh, this is the usage that, this is how simple is to use the plugin. So we just need to import the plugin. We initialize the plugin just by typing new my plugin, and then we can use the different methods that we have in the plugin, in this case my plugin, do something. So it's kind of really simple and it's giving a lot of easier usage for developers. Really good example that we have for superfluid is superfluid is an asset streaming protocol. And if you are a developer and you want to interact with superfluid, you need to talk to some forwarders, which are contracts on chain, and then the forwarders will talk to the host contract, which is like the main contract with all the core functionalities of superfluity.
00:32:03.738 - 00:32:40.604, Speaker A: But then we created a plugin that allows the developer to use the Webtree plugin off chain so they don't need to send a transaction, talking to these forwarders and directly, the plugin will kind of abstract the forwarder's functionality and will talk directly to the host contract. So this is really good because it's improving the developer experience. It's also having less calls and transactions. So that means that we'll have less gas fees for the final users. So, yeah, it's just about exploring the different possibilities of the web. Three plugins. Another example of swisstronic, which is a layer one built on Cosmos SDK.
00:32:40.604 - 00:33:12.458, Speaker A: If you want to make calls, calls are these communication to reading functions. When you want to get the message, for example, if you want just to get the message in swiss tronic, you need to do all these things. You need to encode the function, encrypt the data field, make the call, all these six steps. But then with the web3 plugin, you just need to encode the function. You call the plugin, and the plugin abstracts all these different functionalities, all these different things is doing this under the hood. And then you can just show the result at the end. If we translate this into code, this is something like that.
00:33:12.458 - 00:33:45.956, Speaker A: This is how we can make calls to swisstronic. All this code that you see here will not go through that. And then using the web3 plugin, it's just using the Webtree swisstronic call. And then you need to send the contract address that you want to talk to the data, and then that will just manage everything under the hood. And then for Chainlink plugin, I'm just going to show you the same example of how it works. So who from here doesn't know what is Chainlink data feeds? Everyone knows Chainlink. Okay, perfect.
00:33:45.956 - 00:34:12.502, Speaker A: Yeah. Chainlink is just basically a bunch of smart contracts on chain. And then if you want to retrieve the price of bitcoin, you call a smart contract. That's how everything kind of works. So if you want to get the bitcoin price, what you need to do is to look for the Abi of a smart contract. You need to look for the address of the smart contract that you want to talk to, because they will have different addresses. If you want to talk to, if you want to retrieve the bitcoin price or the Ethereum price after that, you can initialize the contract using the same things that I show you.
00:34:12.502 - 00:34:37.770, Speaker A: New Webtree ETH contract, you call the contract, and then you can show the result. But then using the web3 plugin, you just need to initialize the plugin. You can call the plugin, which is a get price. It's called web3 getprice function. And then the plugin will look for the API of the contract. We'll look for the address of the contract because all the addresses are stored within the plugin as well. We'll initialize the contract and we'll make the call.
00:34:37.770 - 00:35:23.124, Speaker A: So all these things are happening under the hood for the plugin, kind of abstracting more things for developers, making it easier for them to use Chainlink. In this case, this is the standard way to interact with chain link. You need to do these kind of five steps, but then with the plugin you just need to install the NPM, install chainsafe web3 plugin, chainlink, you need to import the chainlink plugin and the web3 module as well. And then to use the Chainlink web3 plugin, you just need to initialize the plugin here. You need to call the Webtree registerplugin to kind of give the provider context to the plugin. And this is the main function which is called chainlink. Chainlink plugin getprice and then we send mainnetpricefits btcusd.
00:35:23.124 - 00:35:54.684, Speaker A: But then you can change this for EthereumUsD or add a USD and then you will be able to talk to all the different contracts that you have in Chainlink. And yeah, here are some resources in case that you want to learn a little bit about web3 js. We have these two web3 JS series and web3 js course for beginners. We have the web3 JS documentation. And then if you want to get started building a plugin, which is easy, and you can start depending on what you want to do, but you can do it in 20 minutes. Right. And here we have a video as well that will be really useful.
00:35:54.684 - 00:36:27.294, Speaker A: You can find us hereinsafe th on Twitter also web3 js. I'm going to share the slides in this Twitter web3 js. You can find me on Twitter, LinkedIn, telegram, everywhere at Santiago Devrel. And also if you want to use the web3 plugins that we have, web3 js.org plugins and yeah, that's everything for today. Thank you so much. Is there any questions? Everything is kind of clear.
00:36:27.294 - 00:37:06.554, Speaker A: Is there any specific source or content that you recommend for us? Okay, I think the best will be to send me a message on telegram. And then if you send me a message on telegram, I can set up a telegram group, but everything is kind of in the documentation. But I think the best is setting up a telegram group and then I can give you one on one. Developer support. Yeah. Something else written. Clear.
00:37:06.554 - 00:37:45.074, Speaker A: Amazing. Yeah. How is it about wallet interaction? Wallet interaction? What do you mean by wallet interaction? Like normally what you can do with the wallet is send transactions, right? And that's what we were doing. Like every time that we interact with a contract, we are sending the transaction. But what specifically? Like, do you mean from the front end? Okay, so if you want to. Oh, for example, metamask, I will show you something really quick. If you want to use metamask, the only thing that you need to change is actually, I have some code here.
00:37:45.074 - 00:38:10.224, Speaker A: That was a really good question. It must be here. Health devs react I will show you something. You just need to do the same. The only difference is when you initialize the provider. So instead of initializing the provider with an endpoint, we need to use two things. Let me just.
00:38:10.224 - 00:38:42.972, Speaker A: Perfect. So we just import the web tree here, but then to connect to metamask, we just need to initialize the provider with an object that is called window ethereum. So when you use this window ethereum, you're initializing the provider with the injected provider that the user has in metamask, because it will show this pop up that is called web3. It requestaccounts and then it will connect. If we connect the wallet, for example, let me show you this really quick. Actually, I think this will work. Hopefully NPM start.
00:38:42.972 - 00:39:12.036, Speaker A: I think it is, it's in test. Okay. So yeah, it's just like these lines of three lines of code. This is just like a simple thing that I have. Let me just open the console here. And then if I click in connect, you can see that then metamask is showing here. And then you can choose which wallet you want to connect.
00:39:12.036 - 00:39:41.688, Speaker A: So I want to connect this ETH Oxford wallet. I click next connect, and then here in the console you see account connected. So now I'm interacting from that account. And then it's the same thing. If you want to interact with a contract, it will be the same mycontract methods function name send because you are sending a transaction. And then from this accounts, accounts zero. Yeah, account zero.
00:39:41.688 - 00:40:00.712, Speaker A: So this is basically how you can interact with a contract. So now if the user clicks here, the metamask will pop up to confirm the transaction and everything. But yeah, this is how you can use the injected provider in a react application, for example. Yeah, great question. Yeah, something else written. Clear. Amazing.
00:40:00.712 - 00:40:01.264, Speaker A: Thank you so much.
