00:00:11.640 - 00:00:44.714, Speaker A: Hello everyone. Today's talk about smart contract vulnerabilities from first principles. I think you've already heard a bit about DeFi security, and now I want to talk a bit more from the code side. How are these vulnerabilities actually caused? How can you find them as an auditor, or how can you avoid them as a developer? Let me briefly introduce myself. I'm roman. I studied at ETH Zurich, so pretty close to here. I work as a smart contract developer for various protocols, mainly in the DeFi space.
00:00:44.714 - 00:01:49.444, Speaker A: I worked in the past and as a security researcher in my spare time. I also participate in bug bounty competitions and auditing competitions. If you don't know these kind of formats, basically you have to find rare vulnerabilities there to maximize your payout and to maximize your rank. Because this depends on how many rare vulnerabilities you find. And I noticed after finding many vulnerabilities over the years, I noticed that while the bugs are somewhat different, the underlying issues are always kind of similar. So at some point I started to think what are really the underlying issues of these vulnerabilities, and also of the hacks that everyone reads about. And I started to compile a list for them that you can use as a mental heuristic, as a developer, or also as a security researcher, or even as a defi user, depending on your role in the ecosystem.
00:01:49.444 - 00:02:48.684, Speaker A: Just as a small warning, these are all heuristics, so they can help you a lot to get ideas where to look for exploits and what to look for in a code base. But of course you cannot directly apply them to every codebase and find directly ten vulnerabilities. It would be nice if something like that would exist, but sadly it doesn't at the moment. So let's start by the first one. Everyone that has a programmed at some point knows about off by one errors. It's like one of the most common errors that you see when programming, when iterating over array, or in general that you're just off by one, either one too high or one too low. And surprisingly, this is also very common for vulnerabilities or for bugs that then can be turned into vulnerabilities.
00:02:48.684 - 00:03:51.746, Speaker A: Because of that. I always recommend when a comparison is made, you should always think about what happens at the boundary so directly when the value is reached. For instance, I've shown here an example that I've seen in an audit in the wild, and this was an auction platform, and basically they had a modifier for the time before the auction has ended and the time afterwards. And these two phases should be distinct and the developer actually assumed that they are distinct. However, it turns out that when the block timestamp is exactly equal to the auction end, this contract was in a very weird state where the auction has already ended, but it also hasn't ended yet. And this was actually exploitable here to buy a free NFT in that case. And this code was actually audited before and it wasn't caught there.
00:03:51.746 - 00:04:48.398, Speaker A: So I think just with this mental heuristic you can catch this error because I mean here I also just thought about what happens if the block timestamp is exactly equal to auction. And this was actually a major issue here because you could have exploited that to get a free NFT. So in that case it was quite a financial loss that could have occurred because of this bug. Another thing that is very common for smart contracts is that you have a source and a destination address. I mean if you think about tokens for instance, that's of course the obvious example. But in many, many protocols you want to do transfers, you want to specify sources and destinations. And many programmers when they code this, they assume implicitly that the source will not be equal to the destination.
00:04:48.398 - 00:05:22.432, Speaker A: And I think that's a pretty normal and human thing to do. When we talk about the source and the destination, we always mean that they are not equal. Just I think that is pretty normal to do as a human. But of course when you don't ensure that in the code the user may be able to specify the same address. And for some protocols this can result in huge vulnerabilities. And this snippet that I've shown here, I've not seen this in only one audit. I think in four or five audits.
00:05:22.432 - 00:06:31.578, Speaker A: Actually a very similar vulnerability to that one where the balance is cache before and then you use on source you don't use the cash balance, but on the destination update you use the cash balance. And basically what this results in is that you can inflate your own balance. If you just specify source and destination, you can inflate your own balance as you wish and completely break a protocol like that. And I mean, also these kind of vulnerabilities aren't that hard to catch as a developer or as a security researcher if you just have this mental heuristic in mind that you should think about what happens if the source is equal to the destination. Another thing that's very common for DeFi protocols and in general smart contracts is that you have symmetric code function pairs. I mean the obvious example here are deposit and withdraw functions. But this can also be administrative functions, for instance, a pause and an unpause function.
00:06:31.578 - 00:07:18.542, Speaker A: And when you have these kind of functions, they should always be symmetric, or most of the time they should be symmetric. There are a few exemptions, but most of the time they should be symmetric. So this means that a withdraw function, for instance, should undo all side effects that a deposit function did. And surprisingly, this is also quite common that one of the side effects is forgotten. Maybe it's only a small side effect, but oftentimes this can lead to other problems down the road. And I've given a very simple toy example here. Basically, deposit and a withdrawal function and the deposit function marks addresses over a certain balance as premium addresses.
00:07:18.542 - 00:08:20.484, Speaker A: And these kind of patterns are relatively common that you may have a side effect depending on the balance or depending on the amount. And then when you look at this code, or when you develop this code, I really recommend to compare both functions, maybe even line by line, because then this is extremely easy to catch. When you don't do that, this can be very hard to catch because it may be a small side effect. But when you really compare them side by side, things like that are easy to catch. But if you don't catch them, they can have pretty major consequences depending on the exact code. In smart contracts, it's pretty normal that there are rounding errors, and in general this is not a problem. However, it can become very problematic if these rounding errors are amplifiable in some way.
00:08:20.484 - 00:08:53.364, Speaker A: And I've shown a small example here. There's actually parentheses missing here. There should be parentheses here. But let's assume that there are parentheses in the days delta line. And then what this function does is it first calculates how many days have passed since the last interest accrual. And then it uses this value to calculate the interest that is due for the user or for the position. I mean, this is a very common pattern.
00:08:53.364 - 00:09:32.552, Speaker A: This is also actually more or less from a production code base where a similar code was in. And this generally works if you accrue very rarely. I mean, if you accrue interest every 200 days, for instance, this isn't too problematic to do it like that. But of course, the problem is that the days Delta that this calculation runs down. So if you call this after 23.9 hours, for instance, the days delta will be zero and the whole interest will be zero. And this was actually the vulnerability in this protocol.
00:09:32.552 - 00:10:18.074, Speaker A: This was a mortgage protocol. So pretty high values, million or a few millions. And then of course if you take out the mortgage, there you have an incentive to just call this function every 23.9 hours because you get a free mortgage like that. And I mean, paying five or $10 for the gas fees isn't too bad to get a free mortgage. So I think that's a deal that most people would take. And also this error, this was tested this function, and it worked well in the test, but the problem was they only tested it with holidays and they didn't think about rounding errors or what happens if values are rounded down.
00:10:18.074 - 00:11:35.904, Speaker A: And I think that it's always a good thing to have this in mind. And I mean it especially problematic if you divide before multiplication. These are usually the scenarios where things like that happen, where you have these amplifiable rounding errors, where suddenly instead of one way you lose one e four, or things like that. Solidity is kind of special because it doesn't have an option type, so you don't have none or null like in other languages. And a very common pattern to check if a state is uninitialized, or if some variable is uninitialized, or if some mapping key is uninitialized is to check if it has the default value. So zero, for instance, in the case of an int or address, zero if it's an address. And I mean this pattern is generally fine, but it can become problematic if there is a way for the user to set this value to zero, because then you execute the initialization logic, but then the user can reset the value to zero or address zero or whatever the default value for this particular type is.
00:11:35.904 - 00:12:40.484, Speaker A: And then if this code is executed a second time, the init logic is executed a second time as well. And I mean, as you can probably imagine, this logic is usually written in the mind that this should only be executed once. So this can often lead to quite large problems, not only security problems, but sometimes it just leads to a denial of service and leads to smart contract in some weird state where it doesn't function anymore, simply because this was never intended. So this is also something to keep in mind when you see such logic. Always think about is it possible that the value will have this default value again? And if so, the recommendation is to use an explicit initialization flag. So just a Boolean, you set that once and when it's set you do not execute the logic again. It has a certain overhead, but sometimes it's unavoidable.
00:12:40.484 - 00:13:38.604, Speaker A: Something that's more testing heuristic is that for many, many functions, n function calls with the value x should be more or less equal to one function call with the value n times x. For instance, if you think about the deposits function in a smart contract, if you call this function ten times with one ETH, or if you call it one times with ten ETH, the resulting system state should usually be quite similar. There may be small differences, and there might be valid reasons that there are large differences, but in most cases the state should be similar. And that's also what you would expect as a user. And I mean, this is very easy to test. This is also very easy to test with fast tests. You just split up a given test and run a small loop and compare the two states.
00:13:38.604 - 00:14:29.444, Speaker A: Nevertheless, it's often able to catch some errors. For instance, it might be able to catch surrounding errors, or it might be able to catch wrong init logic. And this mostly because I've seen test reads that only call a function once and the system completely breaks if the function is called a second time. But they don't test this. And of course this is also something that you should test. Don't only call your function once, call it multiple times in your test suite and check that nothing breaks like this. Another thing that is common in quite a few smart contracts, and that leads to a lot of vulnerabilities, are the handling of duplicates.
00:14:29.444 - 00:15:45.974, Speaker A: And this is all the snippet that I've shown here. This is also from an audit I did was also not catched in quite a few prior audits. And basically what the problem here is is that the developer first cached all the balances of a user provided token array and then paid out these cached balances. This generally works fine, but it becomes problematic if the user provides a duplicate in this list, because then his balance will be there two times and he will get paid out two times or even multiple times. And I mean, you may wonder why the programmer even used this weird pattern or this weird code, right? He didn't initiate the transfer directly. The reason here was that he wanted to follow the check effects interaction pattern very closely, so he wanted to do all interactions in the end for security reasons, which is generally a good thing to do because of reentransi attacks. But he actually introduced another vulnerability when refactoring the code to address this first vulnerability.
00:15:45.974 - 00:17:12.070, Speaker A: This is something that is relatively common, that you see a lot, because oftentimes also developers do this implicit assumption. At least they won't have duplicates, but then they forgot to check for it or to disallow lists that actually contain duplicates. And as you probably noticed by now, many vulnerabilities are caused by assumptions that a developer makes by implicit assumptions that he doesn't then explicitly check in the code. And also this one is the same. Basically, something that you often see is that a developer assumes he can just query the ERC 20 balance or the ethereum balance of the contract to get the sum of all deposits that were done, for instance, over a function. However, the problem is you can always just manually transfer tokens to a contract, and you can also always manually transfer ETH to a contract, even if it doesn't have a receipt function. And this can cause some problems, because when it may result in situations where some variables are out of sync, where the developer assumed that his manually kept variable with the deposits is equal to the balance of.
00:17:12.070 - 00:18:28.956, Speaker A: And these discrepancies can be quite problematic and actually have caused major problems in the past. Also, when calculating exchange rates, for instance, that you were able to transfer a few tokens before the calculation and things like that. So if you see this, that the balance is queried either of tokens or ETH, always think about if this becomes a problem when a user just manually transfers tokens to the contract, or if this is properly handled. I mean, it's not always a problem. It can be that these tokens are just lost or just, just transferred to all depositors, which is generally fine, but it can cause major problems. So these were a few mental heuristics and common things to look for when you as a developer, or you as a security researcher, or even as a defi user that just checks the code on e four scan, looks at at a smart contract in the GitHub repository that I linked here. You can also find all of these heuristics and also a few more.
00:18:28.956 - 00:18:53.484, Speaker A: And you can also use that when you are developing yourself contracts or when you are looking for vulnerabilities yourself in a contract to use basically as a reference sheet and to check if you find one type of these vulnerabilities or attack patterns in the smart contracts you are looking at. Thanks a lot for your attention.
00:19:00.504 - 00:19:05.324, Speaker B: Thank you so much, Roman. So there's time for questions. There is one hand already there.
00:19:08.024 - 00:19:21.524, Speaker C: Yeah. Thanks for the presentation was very interesting. You seem to have some experience with c four audits. So for people that also want to kind of like participate in these type of contests, what advice would you give?
00:19:22.944 - 00:20:11.200, Speaker A: Yeah, I mean, I think for c four specifically. So basically, first you have to, I mean, you have to get to a certain level to just find the basic vulnerabilities. But afterwards, like I said, c four is kind of special because your payout and your rank is determined on how many other security researchers find the vulnerability. So I would there, I would try to really focus on finding rare vulnerabilities, try to get creative, maybe use a few of these patterns. I personally used these in the past to get attack ideas. And a few of the vulnerabilities that I've shown here were actually solo findings then on c four. I mean, they weren't so obvious like here on a large slide in font size 20, they were more hidden.
00:20:11.200 - 00:20:35.724, Speaker A: But for c four and these kind of contest formats, my recommendation, after you have the basic security knowledge and participated in ctfs, is to really try to get creative, try to think about how could this contract be exploited in maybe even some exotic ways. And this usually helps a lot in these kind of contests.
00:20:39.884 - 00:20:45.284, Speaker B: Are there more questions? If not, then well, thanks again. Roman.
