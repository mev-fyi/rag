00:00:00.410 - 00:00:58.766, Speaker A: An introductory session on oracles and then run you through how to integrate your solidity smart contracts with Chainlink so the presentation format today. Firstly, we'll just run through an introduction of Oracles, what they mean in the context of blockchain and smart contracts. We'll then run you through a comparison of the different types of oracles that currently exist to serve smart contracts. Then we'll be speaking a little bit on the current issues that oracle systems are facing in the ecosystem, especially when interacting with decentralized finance protocols. We'll then run you through the most recent BZX protocol exploits, highlighting a bit of a step by step of what happened there. After that, we'll speak a little bit on the design philosophy and what you should generally be considering when implementing oracles into your smart contract applications. We'll then provide a bit of an overview of the current Chainlink solution and how you can use it.
00:00:58.766 - 00:02:02.878, Speaker A: And then finally we'll run you through a bit of code as to how you can integrate chainlink into your smart contracts before answering any questions that anybody might have. But yeah, as Peter said before, not sure if everyone caught it. Feel free to interject in the chat or press the raise hand option there if you want to ask any questions. We'll kick it off. So, in explaining what an oracle is in the context of blockchain and decentralized applications in its functional use, an oracle is something that can be referenced by a smart contract when it requires data, or when it needs to interact with payment gateways such as PayPal, or when there's an excessive expensive computation required to be done off chain. A simple example of how a smart contract may use an oracle is if an insurance provider writes up a crop insurance contract that is triggered when the temperature exceeds 45 degrees Celsius. Here, an oracle system will deliver the temperature data to that insurance smart contract.
00:02:02.878 - 00:02:57.110, Speaker A: Another example is a binary option smart contract that requires the price of gold in US dollars. Here, an oracle system will be delivering the gold US dollar price data to that smart contract. Essentially, if a smart contract is going to interact with any piece of data or system external to the blockchain, then it will require a secure method of inputting and outputting that data. So there's several types of oracles that are used in various different ways, and I'll now run you through the pros and cons of using each system. So a centralized Oracle solution example being provable. It's a centralized node that delivers off chain data on chain. It's one entity that's responsible for providing that data for your smart contracts, and it's blockchain agnostic in the sense that it provides a solution that's suitable for any blockchain.
00:02:57.110 - 00:03:47.430, Speaker A: The pros of using provable is that you can achieve high throughput for your smart contract applications. It's relatively cheap to use as there's less nodes submitting transactions on Ethereum, so lower gas fees and it's also blockchain agnostic. The cons of using a service such as provable is that it's a single point of failure. There's a single data source which can be manipulated, and there's a large attack service. The main takeaway with centralized oracles is that it's somewhat counterintuitive for you to rely on a single node that is inputting data onto a blockchain that has thousands of nodes doing computation. Then there's the Chainlink network, which enables multiple nodes to deliver off chain data to the one smart contract. This is known as a decentralized oracle network.
00:03:47.430 - 00:04:34.814, Speaker A: The pros of using Chainlink is that it's quite difficult to manipulate and bribe, as you'll have to bribe the entire cohort of inputs. There's generally multiple data inputs, there's a decentralized source of data providers, and there's no single point of failure. The cons of using a service such as Chainlink is that it's relatively expensive as you're paying multiple providers, and you can congest the network by bumping up gas fees for everybody. With Chainlink, you're relying on multiple nodes to provide data. Therefore, if one goes down, then you will not generally have any issues. Thirdly, you've got protocols such as auga, which is an on chain oracle. Auga can be referenced as a source of truth.
00:04:34.814 - 00:05:30.790, Speaker A: It has rounds of voting where individuals can bet against each other on the outcome of an event. If a smart contract depends on the outcome of a presidential election, for example, Auger will be able to provide that truth and be a reference point on chain. Pros of using a system such as auga is that it's game theoretically sound. It's on chain and there's immutable data and it's easily referenceable, cons being it's relatively low throughput and it can't be used for many dapps as a primary solution. It's expensive on a per call basis and it's isolated to Ethereum. Fourthly, you're able to reference on chain contracts for a price point. For example, you've got uniswap, which is a peer to peer token exchange on Ethereum so you can reference that price point for your other smart contract applications on chain.
00:05:30.790 - 00:06:08.820, Speaker A: The pros of such a solution is that the data is readily available, it's cheap to read from, and you can aggregate multiple decentralized exchanges or multiple price points on chain to find a more secure solution. The cons of this being that exchanges can be relatively easily manipulated depending on the liquidity of that exchange, and another con being you can't reference it outside of that native blockchain. So Ash is now going to jump on and run through how you could exploit current oracle systems and what's recently happened in the past.
00:06:10.790 - 00:07:44.382, Speaker B: So yeah, at the moment, I'm sure everyone's aware of what was penned as Black Thursday, one of the most recent examples of just how adolescent the technology really is that we're building on where crypto markets wiped 35% off the global market cap. A lot of the entities that were congesting the network at that point in time were trading into stablecoins on the ethereum network from other digital assets to hedge against their risk and the market risk. And so the congestion was caused by a lot of throughput at that point in time, which the ethereum network just can't handle at the moment. So the gas price increased from an average of five to 15 GWe per transaction to about between 250 to 500 GWe, which obviously congested, was reminiscent of just how congested the network really was. So Chainlink experienced a six hour delay in passing data through the network just under a week ago during Black Thursday, and that data was being used by Synthetix, Aave, Ampleforth and off chain labs, which subsequently shut down a number of different markets on those defi applications. During that period, the Chainlink nodes had hundreds of pending transactions and were not able to process new requests due to transaction non issues. So moving on like the same day, Makerdao had what was quite a significant liquidation event.
00:07:44.382 - 00:09:12.190, Speaker B: So maker subsequently launched an addition of the Coinbase and circle backed US dollar coin as a new collateral option after the flash drop in the ETH price. Seemingly it is quite an interesting turn of events which subsequently saw a number of positions liquidated and auctioned off where there was one trader able to exploit the maker system and purchase just over 5 million us worth of Ethereum for close to nothing. This is pretty crazy considering that all of what is defi on Ethereum has systematic exposure to Maker daos dai. Every single on chain exchange utilizes dai as an oracle of sorts as there is a lot of liquidity traded with DAi as the pairing of digital assets on most decentralized exchanges. Just imagine what is the Dai crypto economic system failing after being stress tested on black Thursday? There are a lot of worries moving forward. It's quite clear now that we're in rough seas to the point where there is now a trusted third party issuer of a stablecoin that underpins stability of the Dai US dollar peg. The reason this is important to consider is that in oracle designs, where data is sourced and referenced from Dex trading books, there is a lot of systematic risk associated with and when only relying on these reference points for what is to be regarded as the truth of an asset pairing value.
00:09:12.190 - 00:10:26.642, Speaker B: So order books are too small and liquidity is too small and thus gameable. So moving on to another exploit on June the 24th, 2019. The day was quite an incredible day in terms of what would be defined as the first large scale oracle exploit in DFI decentralized finance. Synthetics was successfully exploited and had 37 million synthetic ethereum stolen synthetics shut down trading for 24 hours. The exploiter had theoretically profited $1 billion in less than an hour. Obviously the collateral was not in the system for that to be traded outside of the realm of synthetics'contracts, so the report on a korean one was substantially off from a synthetics in house Oracle. So they were running their own centralized oracle in house that had aggregated a price from two exchange APIs that somehow simultaneously both went down and thus the arbitrage bot trader exploited false reporting and instantly exchanged his thousand times profit on korean yuan into synthetic ethereum.
00:10:26.642 - 00:11:25.670, Speaker B: This led synthetics to begin talks with Chainlink and eventually six months later, they integrated with Chainlink. Chainlink and synthetics recently have had an exploit on the 21 February 2020. There was a classic example of what is human error associated with adding a new price reference contract to the synthetics protocol. The gold price registered as Xau on the job identifier was added to the contract rather than XAg, the silver price identifier that was actually required in that system. Again, several arbitrage bots took advantage and profited $36,000 from this human error where there was no dispute layer subsequently mintes on the synthetics system walked away out of pocket with Chainlink now funding any of those losses that were incurred.
00:11:30.510 - 00:11:52.282, Speaker C: Hi everyone. Yes, David here. Yeah, so just to come to now, a fairly recent exploit conducted. Yeah, I think it was on the 15th. So just a precursor to begin with. Flash loans. Basically what these are, these are DFI's most primitive unsecured loans.
00:11:52.282 - 00:12:36.734, Speaker C: So they're executed actually in the duration of one block. They're riskless in the sense that the loan can be canceled within the duration of that block should the borrower fail to pay. And essentially what they're allowing for is very large under collateralized positions to be executed over a very short period of time. Yeah, so to come to the first BZX attack. So just a high level overview. All of the rates that we're citing here are as at the time of attack, obviously things have changed since then. So to begin with, that flash loan of that 10,000 ETH was secured from DyDX with a value of about 2.64
00:12:36.734 - 00:13:07.918, Speaker C: million US. 5500 ETH of that was then sent to compound to borrow 112 wrap bitcoin at a C factor of around 75 of 75%. Exactly. Actually, as that's what's applied to all lending on compound and then from what was remaining. So 1300 E. So he's got 4500 in his back pocket there. 1300 of those ETH is then sent to BZX to fund a five X leverage short on ETH against wrap bitcoin.
00:13:07.918 - 00:13:55.640, Speaker C: Kyber being the liquidity aggregator there, it routes the order to uniswap, eventually converting 5637 e to 51 rat bitcoin, causing massive slippage. So the 112 rat bitcoin there is borrowed at two is redeemed for about 6871 E. So now the attacker has sufficient funds to repay the loan at one, and they draw on the uninvested 3200 and pocket 71 e left over. So the 10,000 ETH is returned to Dydx. Now further steps are involved to redeem the remaining collateral. So the majority of the profit was derived from actually securing the collateral remaining in compound. But we'll discuss that later.
00:13:55.640 - 00:14:28.850, Speaker C: Okay, so call one. So the attacker, like I said, borrows 10,000 ETH. We're not going to analyze this too deeply. It's basically just suffice it to say that the purpose is to have enough ETH to pull off this whole attack. The attacker then converts, like I said, 5500 ETH to 112 wrap bitcoin. Again, the idea here is to leverage a large amount of price slippage later on during the attack. So this is basically just to secure a position in wrap bitcoin.
00:14:28.850 - 00:15:05.594, Speaker C: Now before we come to call three, there are a couple of things that are necessary to understand about BZX, the lending protocol. So itokens and p tokens. Now itokens are, simply put, just global lending pools. An itoken is minted. You basically deposit an equivalent amount of the underlying token that you deposit if you want to mint one I ETH. If you want to contribute to the ETH lending pool on BZX, you must deposit one ETH to be able to earn the interest on that asset. So they're not to be confused with inverse tokens on synthetics.
00:15:05.594 - 00:15:43.830, Speaker C: They're completely different on synthetics. These are tokenized short positions on their platform. So p tokens, these are what are used for trading on BZX. They're tokenized versions of long and short positions. So to illustrate, taking a short position on ETH would be executed as such, the user first deposits an asset to mint a p token. That p token then borrows from the IE pool and swaps the newly borrowed ETH for a stable asset like Dai. This is still the standard method for executing a short in legacy financial sector, simply done using Kyber as a liquidity aggregator.
00:15:43.830 - 00:16:23.350, Speaker C: So what Kyber do at this stage is they query all of their linked reserves to find the best rate for this trade to be executed at. And once this is done, it's at the ledger of the trader to liquidate that position. So a long is executed the opposite way. So the P token essentially borrows a stable asset and swaps it for whatever asset the trader would like long exposure to. Okay, so now we can clear up call three. So this call opens a fulcrum position, shorting ETH against wrap bitcoin at a five x leverage. So the 1300 E is sent to BZX.
00:16:23.350 - 00:17:11.702, Speaker C: Once that call is made, Kavit, like I say, queries all of its reserves to find only uniswap actually had sufficient liquidity to execute the trade. So what happens then? This order essentially chews up basically all of the orders on Uniswap, rapidly lowering the price of ETH against wrap bitcoin. So I guess the economic impact of such a large order is what's important here. The financial term is slippage. So Uniswap's pricing mechanism basically dictates that the more of a token I buy, the higher the marginal price of that token, so that the more I buy off the market, the more scarce that resource and thus the more expensive. So the opposite is true here. The opposite cases at play.
00:17:11.702 - 00:18:05.474, Speaker C: So the attackers borrowed out this e and he's, beg your pardon, flooding the market with it and therefore rapidly diluting its value. On top of this, the slippage was greater than the margin maintenance of the attacker's position. So he's leveraged at five x. So the slippage was greater than his margin maintenance, which basically then trips a bug in the BZX smart contract logic, which had that not have happened, all of this would not have executed. And so just diving a little deeper into that bug. So when trading slippage is less than 20%, the amount of wrap bitcoin that could be redeemed would be guaranteed to be greater than the ETH deposited. So they can seize the entire value of the position as collateral.
00:18:05.474 - 00:18:41.470, Speaker C: And BZX themselves wouldn't run a loss. All losses would be shouldered by the trader. But when their position falls greater than that 20%, the amount of wrap bitcoin redeemed is actually going to be less than the value of the ETH they deposit less than their collateral. So the position is underwater. Now BZX has got a problem. In this case, the value of wrap bitcoin is appreciating so heavily against ETH, even if BZX do liquidate the position, they'll run a loss. So the attack wouldn't have been allowed, but for the aforementioned reasons.
00:18:41.470 - 00:19:27.970, Speaker C: But for that error in the BZX smart contract logic, that basically meant that the final check to ensure that no positions were underwater, never fired. So essentially the upshot of this massive slippage is a huge opportunity for the next trader on Uniswap. Because essentially this trader would have the opportunity to correct the market price. So there's a sizable arbitrage opportunity there. Yes. So to come to call four, like I say, to take advantage of this slippage, at call three, the attacker sells their 112 rat bitcoin earlier on compad for 6871 east. This covers their collateral, inevitably loss, because that position is underwater.
00:19:27.970 - 00:20:35.558, Speaker C: And the trader actually walks away with the 71 E surplus. Now the attacker is simply playing the role of market here. This is basically the way that uniswap was designed for these things to be executed as such. And now tidying this whole thing up for the transactor, for the attacker to access the collateral still remaining on compound because he still has that 5500 E, securing that 112 wrap bitcoin at 75%. Basically what he needs to do is source 112 wrap bitcoin, buy off the market externally to the actual flash loan 112 wrap bitcoin, source externally, and purchase from the market for around 4372 E, at which point they can seize the rest of that 5500 E. So the ultimate profit of this trade is 1193 E, which should really prick your ears up about how this can be done. So the takeaways is that this is not an oracle attack.
00:20:35.558 - 00:21:16.418, Speaker C: So the attacker manipulated the prices on uniswap by directly participating in the market. So he drove the prices of ETH down first and up in the second time round. All of this took place within the one block, and it's indicative of an experienced and calculated attacker. It serves, I think, as a very important reminder to anyone building in the defi space that the security really is of central importance. And just to come to the second attack now, it's a little simpler to understand. It occurred a few days later. It exploited a different vulnerability posed by on chain reserves actually being used as oracles.
00:21:16.418 - 00:21:49.434, Speaker C: So the first call, it's comparable with the first step of the last attack. So the attacker just simply has to secure enough to complete the attack. So 7500 e was secured. He makes then 19 successive calls to Kyber, basically artificially driving the price, getting an incrementally worse price for his ETH. So yeah, call one. Like I said, that's just the first stage. So the 19 successive.
00:21:49.434 - 00:22:30.234, Speaker C: So Kyber uses two reserves, so it's synthetics and uniswap for its ETH, SUSD reserves. So what the attack is doing here is eating all of the available liquidity. So each trade will hit either of the two reserves based on which has the best price. So at the end of it all, 900 ETH was converted to 155 nine nine four SUSD. So this price is very distorted from the original market rate of about 270 e USD exchange rate to around 111. So ETH is rapidly depreciating there in value. So call three, this doesn't really matter so much.
00:22:30.234 - 00:23:13.318, Speaker C: The goal here again is just to access a fairly liquid market to buy a lot of SUSD. So they want to take advantage of the next call. So call four, this is where the oracle attack was executed. The attacker can now borrow a disproportionately large amount of ETH because BZX is fed an erroneous price from these oracles, these on chain oracles. So in the end, a million and 99,000 SUSD is borrowed for 6796 E. So all the attacker is really doing is creating a very large bid off spread and profiting from doing so. So this had a huge impact on the BZX pool.
00:23:13.318 - 00:24:20.682, Speaker C: It resulted in about $600,000 in equity being lost. And once this profit was secured, the attacker could actually repay their flash fund. The takeaways here, I think the most important one is that using permissioned on chain reserves to source price data has some inherent vulnerabilities. So the attacker contorted the price offered if you can contort the price offered by a permissioned reserve, you can actually create very large spreads between reserves and you can profit from this activity. So it's an oracle problem in the sense that if the price Oracle use was entirely decentralized, then the manipulation of one reserve would actually have a bit of a trivial effect. It would result in far lower slippage costs, and by using a secure Oracle solution, your smart contract app application will actually execute as intended. So BZX has, since this most recent attack, they've moved away from the use of on chain price oracles like Kaiba and have actually integrated Chainlink.
00:24:20.682 - 00:24:31.250, Speaker C: So decentralized exchanges are a fairly new and novel concept. So as such they leave a lot to be desired in the way of security. And this is the argument for Chainlink.
00:24:35.750 - 00:26:08.798, Speaker B: So moving forward, branching more into what a design philosophy should be for the context of oracles, we've briefly touched on what is the different types of oracles earlier in this, and so there are high quality oracles and you need them to be, they're such an extremely vital part of what is a smart contract system, and thus they should execute how a designer intends them. So fundamentally speaking, our approach to the oracle problem in this context of blockchain application development is that you should really take a layered approach to what is an oracle solution. You must consider when using a trusted external oracle such as Chainlink, that no matter the game theoretic consequences, there are agents who act in such a way as to disable networks so that other networks may take its place in the context of the specific oracle system. They may act irrationally, but when taken into consideration, a competitive environment that other replacement oracle systems could take their place. The actions to harm one system are rationalized. So we would suggest that the usage of any oracle system is utilized in conjunction with another or even two others. We strongly recommend the utilization of a trusted oracle system while we're still in such an early stage of the underlying technology's development.
00:26:08.798 - 00:27:15.462, Speaker B: And that oracle system then fails over to a dispute mechanism whose function can be called in a scenario where erroneous data is reported by the trusted Oracle solution, which is baked into the smart contract logic. People are trying to coin this term, what is a meta oracle one which has multiple independent mechanisms external to each system that support the one contract system. So let's walk through what this would look like. Let's assume you're a developer building synthetic.com, an unstoppable synthetic commodity trading platform with a number of different futures and options contracts listed on it. So gold iron and oil are the first three commodities you'd like to enable to be traded on this platform. The original contract type allows users to take out binary options contracts that are settled on some specific future date, and so currently without the secondary security protocols that would enable a game.
00:27:15.462 - 00:28:19.850, Speaker B: Theoretic proof of the Chainlink solution. Chainlink is to be considered as trusted middleware, thus utilizing it as a super integratable and customizable solution is recommended as it allows livetime updating of collateral positions being held in escrow for the binary options contract. But it is better and far more efficient when paired with Auga or universal market access'dvm data verification mechanism. So the failsafe security that a system like Auga or the DVM bring to the binary options contract is incredible, as the result can be disputed and the result of a transaction can be disputed, and the process can somewhat simulate what is a clearinghouse and the role of the legal system in what is the current context of the derivatives markets around the world. The threat of a dispute and the cost of the penalty will always outweigh the gain of locking funds in a contract for up to three days while the dispute is cleared.
00:28:23.810 - 00:29:38.946, Speaker D: Yeah, so if you're a developer or you want to create some sort of contract, there's two real main ways that you can integrate Chainlink, the first of which being reference data contracts. These are quite simple and easy to use, and you're simply requesting from a set list of data contracts. These data contracts are sponsored by very large defi apps, which support a network of chainlink nodes which all individually request, and then those requests are pulled into single feeds. So as you can see on the right here, you have different sets of feeds that you can use, this one being US dollar pairs, there's a few others. Well, and you can find these at feeds chain link and these are really easy to use, and you're just directly reading in the data and that data there. Each one of those is supported by a network of Chainlink nodes, and they're aggregating that data which you can just integrate straight into your application. The second of which ways that you can integrate chainlink into your contracts requires a little bit more effort, but not too much more, and that's individual data requests.
00:29:38.946 - 00:30:51.566, Speaker D: So these individual data requests are a little bit more difficult because you're requesting a specific feed which isn't one of those listed on feeds. Data link one of these specific feeds is custom to your app per se, because it's something that you want to use in your contract. So Chainlink nodes support this with special specific job IDs which fulfill standardized sort of requests. So if you had an API that you know, that had an integer that you wanted, it'd simply just be get this integer from this path, from this URL and you can plug that straight into your API. If the data required is a bit more complex, it may require a new job ID which node operators can add to their list of jobs. But this is a bit out of scope for most tasks that need to be done, such as a simple API request. You can see the term complex here is defined by any sort of operation that you require the chain link nodes to do, which can't be completed with the list of adapters at that link there.
00:30:51.566 - 00:31:19.510, Speaker D: So those adapters include simple stuff like get and post requests, as well as different conversions from strings to bytes and stuff like that. So once you have a set of oracles which can fulfill the job that you require, you make these requests to that set of oracles, and on return of that you can aggregate this data, resulting in a fully decentralized data feed that you'll be able to use within your contract.
00:31:22.490 - 00:32:29.850, Speaker E: So moving on from that and building on Ash's binary futures example, we're actually just going to walk through and sort of build a very basic binary futures contract and integrate chainlink itself. So you guys can just sort of see how that all works. So the premise for the binary futures contract, at a very simple level, we're allowing one party to buy the long position, one party to buy the short position, and when the contract has expired, then we're going to use a chain link oracle to pull in the US dollar price of the asset being tracked. So the, there's two individual methods we can use to start off this example. So we have a choice of either using the truffle chain link box so there's some links later. But if you're not familiar with truffle, it just simplifies the whole process of building smart contracts. If you don't want to do that and you already have smart contracts you want to use, you can directly integrate with the Chainlink NPM packages.
00:32:29.850 - 00:33:38.716, Speaker E: So we're going to go with method one, just because it's the most simple to build a basic proof of concept. So when you actually start up this chain link truffle box, I'm going to run through the basic boilerplate code it gives you and what this does, and then we're going to dive into actually modifying this for our example. So first of all, in the constructor it basically allows you to have this set chain link token. So the chain link library handles a lot of things for you, and one of them is the actual setting of the token you want to use. So if you want to deploy to the ethereum main network or Ethereum Robston test networks, basically all you have to do is call this function and chainlink will pick up what token to use, depending on the network you're deploying to. Next up is sort of the core of any chainlink smart contract, and this is actually creating the request. So the truffle box example gives you a really nice piece of boilerplate code to basically create a simple request.
00:33:38.716 - 00:34:37.210, Speaker E: So you can see here, all we need to do is define what Oracle we want, what job id we're calling, how much we're going to pay them, the URL we want to call. So as Aidan mentioned, all you need is a URL and some path you want to walk along that response object. So you can provide any URL. And in this case, we're assuming that we want to multiply the result that comes from that URL by a certain value. And this basically just goes back to the fact that we can't have floating point numbers in solidity, so we're going to multiply it out to be an integer and work with that in our contracts themselves. So you can see here, all this really does is build up the request and then the very last line we have send Chainlink request to. And this actually lets the Chainlink library handle all the transactional side of sending the request that the oracle will then pick up on.
00:34:37.210 - 00:35:32.116, Speaker E: So the final piece of boilerplate code that you get is this fulfill function. And basically this is called by the chainlink oracle itself, once it's fetched your data. So you can see it passes in the request ID, which you would have got before when you created the request, and then it passes in a piece of data. So this is where we sort of handle, almost think of it like a callback. This is what the node is going to call, and from there we can do whatever we want with it. So with those three in mind, I'm going to jump on and share once the other screen is gone, and walk you through how this would kind of look with a binary futures contract. So here is our binary futures example contract, and this is all open source.
00:35:32.116 - 00:36:19.448, Speaker E: Currently. There's a link in the presentation later on if you want to check this out later. But this is a very rough proof of concept of how this would all work. So you see here we still have the chain link boilerplate code in the constructor. And what we end up doing is basically adding a tiny bit of functionality to the boilerplate code to turn this into a futures contract. So we have this take position function which essentially allows a party to either take the long or short position, and once both those positions are taken, then the contract becomes active. The idea here is that someone can release this contract, pick the position they want, and then another party can come along and buy into this contract providing the correct price that they need to buy in, and then the contract is essentially active.
00:36:19.448 - 00:37:10.856, Speaker E: The only other major thing we need to add then is the execution of this contract. So this check execution function is essentially when given a price and given a certain point in time, how are we going to act? So in this case, if the price is above the target price. So going back to the example before, if the price of gold is above 1500 USD, the long position is getting paid out because they were essentially hedging that it would be above that price. Otherwise the short position is getting paid out. And so yeah, that's the basic functionality for the very simple futures contract. Now we can quickly go over how the chain link boilerplate code is being changed. So the actual create request two has remained exactly the same.
00:37:10.856 - 00:37:48.820, Speaker E: And what I've done, just for demo's sake, is I've created this get latest price function which is essentially going to create the request. So you can see here what we've had to do is we're using the secure data links Robson Oracle address. We have a job ID that basically can get any unsigned integer and return that on chain. So these can all be sourced again, it's linked later, but these can all be sourced from the chainlink docs. So you can go along, pick one or many oracles, a few job IDs and create various requests. We're saying we're paying them one link. This is the URL we want.
00:37:48.820 - 00:38:23.984, Speaker E: So it's actually eqsd. As finding a reliable free gold spot price was proving difficult. And then this is the path we want to traverse. So we're going to quotes USD price. Finally the multiply again to get rid of any floating points and bring the price into an integer on chain. So we call create request, we build a request up sent to the chain link node and then the chain link node will call back this fulfill function. And all we do on fulfill is check execution.
00:38:23.984 - 00:39:07.820, Speaker E: So essentially anyone can call this get latest price at any point in time. And if the contract is expired, then we actually act on this price itself. So that's the basics of the contract. What I've gone ahead and done is actually deployed it on the robster network. So you'll see here, this is the contract in itself. This is the long position. Apologies, I'll change my shared.
00:39:07.820 - 00:39:53.600, Speaker E: I'm just going to have to stop, share and reshare this screen. So there we go. So this is the contract itself on the Robston network. So you can see here we have two transactions. One is the user buying the long position, one is the user buying the short position. And now what we can do is I'll go ahead in another window and actually just send off this transaction itself. And essentially we're going to trigger the price execution and wait for the oracle to respond.
00:39:53.600 - 00:41:17.770, Speaker E: So if all goes to plan we should hopefully see the transactions pop up at some point on Everscan itself. Depending on the oracle response time and the gas users can take a few minutes. So I might go back to the presentation and we can come back once this is executed. So building on that very basic proof of concept, obviously it was quite simple and we've mentioned a lot about decentralization and how Chainlink and various oracles can help, but obviously this was just pulling from a single oracle. So moving into the future, what we would work on with this small example, you would want to have multiple Oracles retrieving the data from different data endpoints. So essentially this is how the reference data contracts that Aidan mentioned previously work. We would then aggregate this response within the contract and then act on it rather than just trusting this one oracle's input from a single source of information.
00:41:17.770 - 00:42:26.400, Speaker E: The other point is automatic execution. So you saw, I mentioned previously we have this get latest price function that a user has to call after the contract has expired. Now obviously this isn't ideal in itself, so there's a few options here you can go with to actually execute the contract automatically. So we have external initiators or time jobs and I'll briefly touch on external initiators because they open up quite a lot of functionality that can build some pretty unique smart contracts. So an external initiator itself is basically a piece of middleware that you can build on top of the chainlink network and it acts as this layer between on chain and off chain. And essentially what they do is they are monitoring real world data. So this could be maybe you poll an API and you're waiting for the price to hit a certain point or maybe you're even just watching a world clock and then the actual remote initiator or external initiator acts on this data to trigger a job with the chainlink node.
00:42:26.400 - 00:43:08.732, Speaker E: Now all this seems a little bit abstract, so I'll talk about it in terms of like a concrete example. So one such thing we've worked on briefly for a hackathon is a sensor triggered insurance contract. So you can think of the external initiator being a piece of software. So it was just a node JS server and then our trigger was a sensor. The node JS server itself simply pulls the sensor data and then when certain criteria is met it triggers a job on chain. So as you can imagine, the opportunities here are almost endless. Insurance itself is quite a big area.
00:43:08.732 - 00:43:57.724, Speaker E: So you could have multiple node operators running these iot sensors, polling them at different times and then based on a consensus overview, triggering some insurance contract to pay out. So whether this be based on temperature, tilt, things like that. So sort of an advanced feature coming up to chainlink. But definitely if you're interested in this area and interested in building quite unique oracle based smart contracts, then external initiators are definitely something to look into. I will quickly check if this other transaction has triggered fully. Bear with me. So yes, we can go over that quickly as well then.
00:43:57.724 - 00:45:06.144, Speaker E: So just going back to the binary options contract, you'll see here, this is the actual transaction coming in to call the get latest price. So hopefully that means our oracle is now processing it. Yep. Okay, so this is our Oracle contract. And this latest transaction, is it actually processing that request and writing the latest price on chain? And then if we look back in here in internal transactions, you'll see there is this top transaction that is basically going from our contract out to one of the takers of the position. So what's gone on there is we requested here three minutes ago to get the latest price. Our oracle has received that request, processed it and written the response back on chain in which our smart contract has then run that check execute function, seen that the contract was expired, and then based on the price paid out a certain party.
00:45:06.144 - 00:45:29.964, Speaker E: So in this case it was paying out the short position. And yes, this is our link of resources. Most things we mentioned are in here. If you have any questions that you think of later on, feel free to reach out to us. And yes, that's it. Thanks everyone for listening. And if you've got any questions, feel.
00:45:30.002 - 00:45:31.150, Speaker A: Free to fire away.
00:45:41.690 - 00:46:06.800, Speaker F: So I've got a question. So those two hacks, it's not really a hack, it's a usage of the technology. The issue they really had was they were relying on oracles on chain and the attacker found a way of compromising the oracle and if they had have used chain link, their life would have been better. Was that I guess the summary of that situation?
00:46:08.130 - 00:46:52.174, Speaker C: I guess yes and no would be the answer there. So the first attack was the attacker was actually engaging with the Uniswap market. So he was simply eating up all of the liquidity and then buying it back and actually engaging with the market in that way. The second case, yes, he was directly contorting Kyber as it was an on chain reserve because. Yeah, so BZX was basically using permissioned reserves as a source of their price feed. So that's the second case, yes. The first case, no is the answer to your question.
00:46:52.372 - 00:46:55.120, Speaker F: Okay, thanks.
00:46:55.490 - 00:47:58.334, Speaker B: Yeah, and I suppose a bit more of an analysis there. Chainlink, they can offer somewhat of an external, and this is where we were talking pairing different Oracle solutions. They offer somewhat of an external to the Ethereum network solution that enables pricing data from a number of different, let's call them curators, to be passed back on chain. So the pricing data can be sourced then from a multitude of different centralized exchanges. And so that pricing data has some more validity due to the fact that liquidity, currently in a lot of these trading environments, is being passed through centralized exchanges such as binance and the likes of poloniax, for instance, so that most of the liquidity and the order book exists off chain. And so a lot of that data is a lot more liquid. A lot of it is probably a lot more valid.
00:47:58.334 - 00:48:47.410, Speaker B: And so at the moment, we have this weird environment where there's a hybrid sort of trading model between centralized and decentralized exchanges. And just using the chainlink, Oracle provides that data, external data, from what is Ethereum to essentially a failsafe in the context of lifetime oracles. But then you also have obviously the dispute mechanism that auga really brings to the table, or the universal market access data verification mechanism brings to the table. They're systems that slow down, obviously the transaction throughput and the clearing of that transaction, but they obviously offer a layer that is very similar to what a legal system offers current derivative markets.
00:48:50.800 - 00:48:51.710, Speaker F: Yeah, okay.
00:48:55.440 - 00:49:28.840, Speaker B: That'S quite all right. If there's any more questions, feel free to shoot them through. We've been running secure data links for the last seven months, so we're one of the chain link main net nodes. There's another 23 entities that are providing the same service. And currently we service a number of contracts on, for instance, synthetics Ave and Ampleforth and off chain labs.
00:49:32.620 - 00:49:40.968, Speaker F: What's the monetarization methodology or how do you guys make money from running a node?
00:49:41.144 - 00:50:53.536, Speaker B: Yeah, so we're paid per request. So every time we execute on a job that we've been requested, we earn anywhere between zero point 33 link or one link depending on the type of contract at the moment. And then from our oracle address we can send that straight through to, for instance, uniswap and trade into so such that we're not exposed to market volatility of what is the chain link token. I suppose that's currently how you're not exposed to market risk, but provide a service to these DeFi applications. The utility token of Chainlink is part of their security assumptions that they're going to be building out in the future and such that you pay for the usage of a chainlink node through a link token. It's a similar model to a lot of utility tokens. The jury is still out as to whether or not it will hold up as a model that can be or will be adopted.
00:50:53.536 - 00:50:59.252, Speaker B: But at the moment it works quite fine. Yeah.
00:50:59.306 - 00:51:18.680, Speaker F: Okay. All right, and so I'm just having a quick look at the exchange. And so it says a dollar 92 us for a chain link, which was probably 50% more last week. Okay, so you're getting about two or $3 australian for each request that you're fulfilling.
00:51:20.480 - 00:51:46.420, Speaker B: Yeah, that's correct at the moment. And a lot of that is subsidized obviously by chainlink. It's part of their early subsidization of the network and they will be doing so, I assume for quite a while. That was part of their white paper. Having utility tokens allows for a lot of these early stage, early adopter incentivization packages.
00:51:49.160 - 00:51:53.770, Speaker F: Is the chain link coin an ERC 20 token on Ethereum itself?
00:51:56.780 - 00:52:16.190, Speaker E: Yeah. So the chain link token is an ERC 20. It's got a slight differentiation from ERC 20. It's got a transfer and call, I think it's called function, which chain link sort of designed, but other than that it conforms to the ERC 20 standard. Yeah.
00:52:16.580 - 00:52:25.010, Speaker F: Okay. Yeah, I was just trying to. Cool. So I know I've asked a lot of questions, but are there questions from other people?
00:52:30.790 - 00:52:32.420, Speaker G: Hi there, can you hear me?
00:52:33.590 - 00:52:34.340, Speaker B: Yes.
00:52:35.510 - 00:53:07.866, Speaker G: So yeah, the binary kind of futures example is quite an interesting use case and I believe it. What would be the kind of cost for, let's say, if that contract, a contract for oil future prices, there's enough value behind it could multiple, let's say chain link node operators collude to provide a result that benefits a single party like where the payoff.
00:53:08.058 - 00:54:01.202, Speaker B: Yeah, currently that is the case. So you would require, depending on the aggregation method, it could be anywhere between 23 and 50% of the nodes to Kalu, just depending on how the data is being aggregated on chain. So that's a big point there, how the data is aggregated. But yes, bribery is the chainlink solution is a trusted middleware solution. They're trying at the moment going through the white paper. If you get later into some of the game, theoretic consequences of some of the implementations that they haven't implemented yet, it becomes more secure in the sense that they require, obviously, chain link nodes to provide collateral. At the moment where we don't provide any collateral, but that is well within the scope of the technology.
00:54:01.202 - 00:55:07.430, Speaker B: So providing collateral against any data that we're putting up, such that if we provide an erroneous response that's outside of the mean by a certain standard deviation, then I suppose those funds will be lost. Obviously, this is the same with any of these crypto economic models. A lot of the time, as I was saying earlier, these types of networks, if there is someone who really wants to do a network some damage and they have enough funds and resources, they could, that's, I suppose, just currently where it sits, they could do the damage if they were that malicious due to what is a market competition for the Oracle, provider of the Oracle solution. So, yeah, obviously outside of the network, if they wanted to come in and kill it, they could. But obviously, a lot of crypto economic blockchain, open ledger, blockchain theories are built on a similar premise.
00:55:08.730 - 00:55:13.842, Speaker G: Yeah, I guess almost like a 51 kind of percent attack kind of theory.
00:55:13.906 - 00:55:43.780, Speaker B: Yeah, similar, depending on the aggregation method, as I was saying. So the aggregation method could cut the bottom 25% and the top 25% out of what is the aggregated answer on chain. And there's just a multitude of different ways that data could be aggregated such that in those methods there, that really defines the security model as to whether you're taking a median, whether you're taking a mean, obviously, you can just extrapolate from there. Yeah. Okay.
00:55:44.470 - 00:55:54.694, Speaker G: Would having a failsafe oracle in this scenario improve that chance mentioned, like the Auger kind of?
00:55:54.892 - 00:56:28.750, Speaker B: Yeah, of course. I think Auger, they were built in such a timeless nature, obviously a lot ahead of their time. And that solution is an incredible solution, a costly solution. The coordination costs are higher, but it does provide what is a very novel solution to the oracle problem. And so having a fail safe, just having that threat there, that exists when you're building one of these protocols. I think that's an extremely important consideration.
00:56:33.500 - 00:56:34.248, Speaker D: Okay.
00:56:34.414 - 00:56:34.744, Speaker C: Yeah.
00:56:34.782 - 00:56:43.240, Speaker G: Thank you. I think it's really interesting that binary options contract. Is there going to be a link that you'd share after the presentation?
00:56:43.580 - 00:57:06.450, Speaker B: Sure, yeah. We'll shoot this through and can pass it through the Ethereum engineering group. I think, as Peter said, this will be uploaded online. There's a couple of links there that you can get into contact with us from. Feel free to reach out.
00:57:08.420 - 00:57:08.928, Speaker C: Awesome.
00:57:09.014 - 00:57:09.890, Speaker E: Thank you.
00:57:12.440 - 00:57:14.470, Speaker B: Thanks for tuning in.
00:57:15.880 - 00:57:18.100, Speaker F: Maybe move to the next slide.
00:57:21.080 - 00:57:22.390, Speaker B: Yeah, very true.
00:57:23.180 - 00:57:33.930, Speaker F: Thank you. Okay, so we have some more talks coming up, and so thank you to chainlink team. That was fantastic, by the way.
00:57:36.480 - 00:57:39.132, Speaker B: Thanks for having us on, Peter. It's great.
00:57:39.186 - 00:58:21.320, Speaker F: Yeah. So the ones that we've got coming up, we've got Ethereum two cross shard. So Raghavendra and I are going to chat about crosshard techniques that people have proposed. Darren Langley is going to give a talk on Ethereum two staking. And then Ali Dory is going to talk about his blockchain research. And then we're going to have Roberto or Frank or maybe and Joanne David, maybe a combination of them talking about Ethereum to formal verification. And Daphne and talk about what they've got up to as far as formally verifying the beacon chain.
00:58:21.320 - 00:58:28.760, Speaker F: Okay. All right. So are there any other questions or thoughts?
00:58:33.660 - 00:58:34.120, Speaker A: Okay.
00:58:34.190 - 00:58:38.000, Speaker F: All right. Well, thank you, everyone, and have a great day. Bye bye.
00:58:38.660 - 00:58:40.380, Speaker A: Thanks, guys. Goodbye.
