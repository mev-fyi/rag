00:00:01.610 - 00:00:35.910, Speaker A: Okay. Hello and welcome everyone. My name is Peter Robinson, and today I'm going to talk about cross chain and bridges. So it's me presenting, so I guess I can introduce myself. I'm a technical director and applied cryptographer at Consensus, and the area that I look at in particular is cross chain and bridges. I'm also the co chair of the Enterprise Ethereum Alliances Cross chain Interoperability Working Group. Let's share my slides.
00:00:35.910 - 00:01:18.790, Speaker A: Okay, so cross chain bridges or DeFi bridges or chain bridges, take your pick. So lots of people have reviewed these slides and provided helpful comments. So thank you to all of them. And this is a picture of a bridge. And as you can see, there's a lot that's happened to that bridge over time and it was complex when they built it. And it's built on foundations that's not built on raw earth. A lot of work has gone into what goes underneath.
00:01:18.790 - 00:02:08.646, Speaker A: And in fact, that one's even got three arches or four arches. And so you could almost view it as going across multiple areas, multiple bits of land. And so people have had to carefully design that bridge. And so similarly, blockchain bridges are like this, where you've got they're complex, there's a lot of design that goes in and they are based on the underlying blockchains as well. Another interesting aspect of this bridge is you can see that there's that darker bit. I don't know if you'll be able to see my mouse moving around where you can see that bits have been tacked onto the bridge partway through. And so obviously there was some maintenance needed.
00:02:08.646 - 00:03:05.026, Speaker A: And I think that's an interesting one to think through, that bridges are likely to need a bit of maintenance from time to time. So today I've got a big lot of topics to cover. And the first one is really trying to define what a bridge is. And then I'm going to talk about the protocol stack and the parts of the protocol stack and then talk about fewer to think about, such as security, scalability, fees, and I'll talk about standardization. And then we can have some questions to think through at the end of the talk. So what is a bridge? So a bridge allows you to swap assets from one blockchain to another. So you might have some assets on one chain that you want to swap with someone for some assets on a different chain.
00:03:05.026 - 00:03:51.080, Speaker A: Or maybe you want to be able to transfer the assets to the other chain. So swapping and transferring are similar but different. So transferring, you're taking something from one blockchain and getting it to the other. The other one is saying that, look, I'll give you some assets on my chain, on this chain for assets on the other chain. Another thing that cross chain and bridges can do is allow you to communicate arbitrary data and arbitrary messages. Or another feature is that you could have function calls that execute across the chain, so you can have business logic across the blockchains. And so, as I said that a bridge is known by a range of different terms and they're all approximately the same thing.
00:03:51.080 - 00:04:46.994, Speaker A: And I don't think there are good fixed definitions of any of them. So when someone's saying a token bridge or a DeFi bridge, it's just a bridge. So why would you want to move value from one blockchain to another? So, say, if you're using Ethereum mainnet, you'll know that the transaction fees are quite high because it's a popular blockchain, lots of people want to use it and it offers great security. But those fees mean that maybe you can't do as much as you could if you had a cheaper blockchain. So maybe you want to move to a roll up or some other side chain that has lower fees. Also, the confirmation time is another aspect, so how long it takes before a transaction in a block is final is different depending on the blockchain as well. There might be some functionality that is on one blockchain that's not on another blockchain.
00:04:46.994 - 00:05:17.502, Speaker A: So you might want to access that functionality. Another thing to think about is liquidity pools. So you might have some liquidity. So there might be liquidity for a certain sort of token in one, say, roll up. And there might be other liquidity in, say, Ethereum mainnet or on some other roll up. And if there's more liquidity in one spot, often the opportunities that avail themselves are greater. So there's also capital, utility and efficiency.
00:05:17.502 - 00:06:06.690, Speaker A: So maybe you have liquidity across multiple chains and you want to, in one single transaction, utilize all of your money to do something. And so you want to be able to simultaneously access the liquidity across the blockchains. And I've said all that via some notes just here. So if you want to read what I've just said, there it is. So, value transfer, how does it actually work? Well, let's walk you through what you want to do. So you've got, say, ethereum, some ether on ethereum, and you want to get it to some other blockchain. So you want to send some ether, send four ether to that other blockchain.
00:06:06.690 - 00:06:47.786, Speaker A: So really, you're going to need to submit a transaction to Ethereum Mainet saying, hey, let's send for ether to that other blockchain. But the thing to think about is that ether doesn't exist on that other blockchain. It doesn't know about ether. So you can't send ether to the other blockchain because it doesn't exist. So you end up sending what's called wrapped ether. So in other words, you've got four Ether but represented as an ERC 20 token. And so you say to some contract on main net, hey, I want to send four wrapped ether to the other blockchain.
00:06:47.786 - 00:07:22.458, Speaker A: It can be represented as wrapped ether on that other blockchain. The overall process, though, is a lot more complicated and let's walk through this process. So the first thing you're going to do is you're going to buy that four ether and say, I want to convert the ether to wrapped ether. So that's the first transaction. And then you need to do what's called approve. So in an ERC 20 contract, you're the only one who can do a transfer. But there's also a function called transfer from.
00:07:22.458 - 00:08:31.582, Speaker A: And so an account can execute transfer from to transfer someone else's money if it has been approved. So Alice here approves of the bridge contract, spending four of her wrapped ether, so using a Transfer From. So then she says, all right, let's do this transfer. So she submits a request to the bridge contract saying, can you transfer four appditha to my account on another blockchain? So the reason why she says her account on the other blockchain, rather than just leaving that as something to happen automatically, she might have a different account on the other blockchain, so she might not have the same private key, public key and address on both blockchains. She might also be using a wallet. So if you're using a wallet, so a contract, then in all probability the contract is not going to be at the same address on both blockchains. And so she needs to be able to specify the recipient address.
00:08:31.582 - 00:09:25.538, Speaker A: And as well, she might want to send money from her account on this blockchain to someone else's account on the other blockchain. So then the bridge contract, as part of this overall transaction, talks to the, ERC 20 and does a transfer from from Alice's account to bridge account of four wrapped ETH. So essentially, now the four wrapped ETH belong to the bridge. And then some magic happens. We're going to talk about the magic later on. And then finally, the bridge contract on that other blockchain says, all right, let's transfer four wrapped ETH to Alice's account from the bridge account. So that's one way of doing it, where you're transferring, but another way is that you can mint, so you can create some new value that doesn't exist at the moment.
00:09:25.538 - 00:10:23.134, Speaker A: And so the four wrapped ETH goes into Alice's account and it's created. And so that's a minting burning idea. So in this situation, you can view that Alice's four ETH on Mainet are currently in escrow or they're locked up and owned by the bridge contract. So you hear people talk about locked up and locked up in the bridge contract, but really the tokens are still in that ERC 20 contract. It's just the ownership is the bridge contract. Now we've got Alice has got her four wrapped ETH on the destination on the other chain, and the bridge contract has four wrapped ETH main net, so that has been affected. So there are a lot of other cross chain use cases.
00:10:23.134 - 00:11:12.158, Speaker A: It's not just transferring money. So there's something called supply chain financing. And in fact, Sandra Johnson, who's on this call, she's written a great paper on that. There's also provenance and selective transparency. So you can imagine you've got a blockchain that's all about supply chain and organizing deals and when stuff's arrived and all sorts of transformational processes. But then you might want to also selectively transparent key points so that people can use that for traceability to know that say, some produce is really organic as well. You can imagine that some countries might decide to stop blockchain at their borders and so they've got say inside a country blockchain and outside a country blockchain.
00:11:12.158 - 00:12:07.560, Speaker A: The case in points China for instance, they might decide they've got within China blockchain and the rest of the world blockchain. And so you can imagine to do that cross border supply chain, you're going to need to have a cross chain transaction as well. CDBCs so that should be CBDC should I say. You can imagine that they're all on different blockchains. And so if you want to have interbank transfers or inter central bank transfers, then you need to be able to have inter. CDBCs and the EEA Cross chain Interoperability Working Group back about two years ago now, or actually we finalized it a year ago, we're working on it for a year. We created a whole stack of interoperability use cases and I encourage you to read that document to get a better idea of how crosschain can be used.
00:12:07.560 - 00:13:24.270, Speaker A: So now I'm going to talk about terminology and topology. So the blockchain that the information is coming from is the source blockchain and the blockchain that consumes it is invariably called the target or destination blockchain. You can have a unidirectional bridge where you can only transfer information from a source chain to a target chain or you can have a bi directional bridge where information can flow in both directions. So some bridges are custom built just for one pairing of a source chain and a target chain. Other bridges are more generic and can work with a variety of blockchains. Some technologies rely on a hub blockchain, so the source chain has to communicate via the hub chain to communicate with the target chains. And so you have this hub blockchain that helps to be an intermediary between all the chains.
00:13:24.270 - 00:14:39.810, Speaker A: You can also have transactions that go across multiple blockchains and they allow you to have more complex use cases. And in this situation you have a root blockchain and segment blockchains. So one thing that I've been working on and at the EEA we've been discussing and moving towards is a cross chain protocol stack and we think this is important to allow interoperability. And so the idea is that you have cross chain applications and so they're applications that work across blockchains. And you can imagine you're going to have your application code but you might also have companies develop software components that are designed to work with the lower protocols and make it easier for application developers to develop great crosschain applications. You've got crosschain function calls. And so this is the layer that lets you execute some complex logic across blockchains.
00:14:39.810 - 00:15:45.046, Speaker A: And so you could have a function on a contract with some parameters and it gets called from another blockchain. And so the updates associated with these function calls could be atomic, but they could also be not atomic as well. And there are trade offs to be had as far as atomic, not atomic, and things in the middle too. So the crosschain messaging layer is about ensuring that information can be verified as having come from a certain blockchain. And so it's really the thing that the function call layer is built on. And so you've got the messaging layer which provides that information has come from a certain place function call layer that gives you arbitrary execution of functions across blockchains and then the application layer which builds on those functions. And so having this protocol stack with clearly defined interfaces is really important because it's going to allow interoperability.
00:15:45.046 - 00:16:46.858, Speaker A: So you can imagine an application gets to choose which function call implementation it wants to use, with which set of messaging implementations, and different companies can create their own components. It also gives you flexibility. So you could have a technique could be used, say for a roll up, and then maybe you'll have a different technique that you'll use for say, from mainnet and you'll be able to have as part of one cross chain call, different messaging methodologies. And you'll be able to mix and match depending on what makes sense. You'll also be able to reuse infrastructure. So you can imagine that you could have a company that offers relay nodes from a certain blockchain and has some infrastructure that they've stood up. So you could use that infrastructure to execute your system over equally.
00:16:46.858 - 00:17:55.090, Speaker A: You could choose to stand up some infrastructure and then have other people use your infrastructure and you could charge people to use your infrastructure. And so rather than a lot of people at the moment, whenever they create a bridge, they create the whole protocol stack and they stand up their own infrastructure, which is not a good use of resources. Also having this plug and play style, it allows people to work on what they're good at. So maybe you're good at function call capability or messaging capability, or maybe you're just an applications company and you just want something to work. You can focus on what you're good at rather than creating the whole protocol stack. And if you are a researcher, you can do experimentation, you don't have to develop the whole protocol stack from scratch, which is good. So if you're a university researcher, you could take a preexisting protocol stack that's implemented with these interfaces and create your own component.
00:17:55.090 - 00:20:13.420, Speaker A: So I'm going to talk about a whole lot of stuff in the protocol stack, but let's have a bit of a think about things first and think well, these are really questions to think about whilst I'm going through the next hundred slides or so. So who is being trusted in the system and how many transactions are needed to facilitate the transfer and who is submitting those transactions? So importantly, if I'm a user and I don't have any value on that destination chain do I have the right or the ability to submit a transaction and how are these infrastructure components compensated? So why should someone offer an infrastructure component if they don't know that they're going to get paid? And do the infrastructure components need to interact with users? And if they do they've got to worry about DDoS attacks and things like that and how many components need to be compromised or bribed for the system to fail and what attacks are likely to be possible. And probably the big one is if you had a billion dollars that you wanted to transfer from one blockchain to another blockchain which of the techniques would you use? So before I dive into the messaging layer there's an important concept to understand in Ethereum called events. And so you can imagine you have say a function called transfer which takes some parameters and then it can emit an event. So emit deposit with a set of parameters and so this event is defined programmatically and then that event becomes part of a block. So the event logs include information about which contractor emitted an event that is part of a transaction receipt and that is included in a block. So that means that you can confirm that an event was created on a certain blockchain due to a certain transaction.
00:20:13.420 - 00:21:26.542, Speaker A: And so you can imagine Alice is there, she submits a transaction, and then an event is emitted, and the event can be proven to have come from that blockchain. So you can prove that information came from a certain blockchain. Another important thing to understand is finality. So you can imagine you have a blockchain and the economical chain is shown to the bottom and you've got a fork at the top and so forks happen in Ethereum main net all the time and it's due to latency across the network and you have say two miners mine the best block at the same time. So if you've got some stale blocks the transactions in them don't necessarily end up in the canonical chain. So the transactions may be also in the canonical chain but they don't have to be. And so if you're relying on an event that was emitted by a transaction that never ended up in the canonical chain then you're going to be in trouble.
00:21:26.542 - 00:22:34.922, Speaker A: And as well the transaction when executed on the canonical chain might have ended up creating a different event because the event's got information that is programmable so it's based on these parameters and those parameters might have changed. So when you're looking at these cross chain messaging systems you've got to be sure that the events that you're basing everything on belong to transactions that are in blocks that are probably final. Typically on Ethereum Main Net you want to wait between six and twelve block confirmations. I've written a paper which you can access down the bottom there, which talks through how you get the numbers and what they mean and you can work out which end of that you want to be on. So other blockchains have got faster confirmation times and some of them offer instant finality. And so if you've got 1 second blocks instant finality, then you're ready to go after 1 second. However, you do need to be watching out for centralization and security issues.
00:22:34.922 - 00:23:20.662, Speaker A: So as the block time gets less and as things become quicker, there are trade offs and so you've always got to be mindful of that. So I'm going to talk about EVM based blockchains and that covers a lot. So you've got all of those purely EVM based blockchains and side chains and you've also got roll ups. So all the optimistic roll ups are EVM compatible. All of the ZK roll ups seem to be moving towards EVM compatibility too. But EVM is not the only show in town. There are a lot of other blockchains out there.
00:23:20.662 - 00:24:25.066, Speaker A: So I'm going to assume messages in some way, shape or form and I think that is generally true. Bitcoin obviously can't, but I think pretty much all of the other platforms can. So one of the big design choices that you've got to make in these systems is trust. People talk about trustless and I think trustless is a bit of a misnomer because at the end of the day you're always trusting someone and it's just really a matter of knowing who you're trusting and how many people you're trusting and that's really what it comes down to. So on Ethereum Main Net, for instance, if 51% of the proof of work miners became dishonest, which is not going to happen, but if it did, then you'd be in trouble. So it's a matter of knowing who you are trusting. And so trustless the hope is that you don't have to trust anyone.
00:24:25.066 - 00:25:19.980, Speaker A: But that's not quite true ever semitrusted or almost trustless. You've got to trust that at least one party is honest and then you've got semitrusted where maybe you're aiming for a threshold number of honest players and trusted, well you're relying on one single party and you're hoping that they're honest. So trustless so it generally comes down to hash timelock contracts. And so the idea is that you are going to release some value based on a pre image being presented based on a hash. So H equals the message digest of R where R is a random number. So R is the pre image. HTLCs aren't by the way exactly messaging protocols, but they're pretty similar.
00:25:19.980 - 00:26:12.014, Speaker A: So when you're looking at a HTLC, the first thing you need to do is set deals between and how much is being transacted. And that may happen off chain, could happen on chain. And then the next step is that Alice comes along and she puts in some value and she says all right, ten beta coins on blockchain B. Jimming, I get one alpha on blockchain A. And so she puts in her ten beta and she sets up a timeout. And then Bob then deposits his tokens on blockchain A. And then Alice submits R such that H equals message digest of R.
00:26:12.014 - 00:26:47.794, Speaker A: So in other words, assuming that equation works, then she can withdraw her tokens on blockchain A. And then Bob then comes in and sees that R value and submits it on blockchain B and then he can withdraw his tokens. And so that sounds great. No one had to trust anyone and it is atomic usually. So it's limited to value transfers. There's also griefing attacks possible. So griefing attack is also known as sore loser.
00:26:47.794 - 00:27:40.074, Speaker A: And so Bob could just choose to not do step three. So Bob could not put his coins in and Alice has to wait around until the timeout. And also Alice could wait for Bob to submit the R and then yes, you can get the slides and the coins will be locked up forevermore. So it requires the parties to be observing the blockchain, which is a bit of an issue. And as well you have to be careful with the timeouts. You want to have more timeout on blockchain A than blockchain B. Otherwise Alice will have to wait until could wait just before the timeout and then do withdraw, not giving Bob enough time.
00:27:40.074 - 00:29:02.200, Speaker A: And also if Alice can make Bob go offline by maybe turning the electricity off where he lived or maybe making the blockchain that Bob's trying to submit his R value to busy, then again he could end up not being able to execute before the timeout and losing his money. So that's the basic HTLC mechanism. But what about as a bridge? And so you need to have two transactions on both blockchains which know that's some transactions and Alice needs to be able to submit transactions on the source blockchain and Bob needs to be able to submit transactions on the destination blockchain. But how do they do that if they don't have any value on those chains? Another issue that is sometimes cited is using HTLCs with consortium chains such as IBFT. And the thought is that Blockchain Validators could be bribed or just refused to submit transactions until the timeout. And so you can imagine that you could have dishonest Validators doing that. But if you've got just one honest Validator in an IBFT network, they will be able to submit the transaction for you.
00:29:02.200 - 00:30:03.090, Speaker A: But if all of the Validators on that destination blockchain or source blockchain get bribed, then you're in really big trouble anyway because your whole security of your blockchain is blown. So there's also talk of using deposits to stop the griefing attacks. The issue of course with them is that they introduce more latency and you're doing more transactions. So connect have come up with a modified HTLC based bridge and their idea is that they don't want Bob to have to have gas on the destination chain. And their modification though is that for that step where Bob would have put in R to get the value, a relayer does it on his behalf. And in fact, you're interacting with a relayer for the whole situation. So rather than it being Alice and Bob, it's relayer and Bob.
00:30:03.090 - 00:31:10.618, Speaker A: So in that case though, Bob has to trust this relayer, this router, and if the router cheats, then he's suddenly got to get value onto the chain so he can get his money. So if the whole reason for Bob doing the transfer was to get value on the target chain, then he's in trouble. This is a bit of a centralization and fully trusting part of their trustless scenario. So there's also semi trusted or almost trustless mechanisms too. And so one of them is essentially BTC relay. So essentially if you've read the Bitcoin white paper, there was this concept of a simple payment verification and essentially you run a light client of the consensus protocol on the destination blockchain. And so you use the proof of work hashing power, for instance, of the source blockchain to be sure that the information can be trusted.
00:31:10.618 - 00:32:13.470, Speaker A: And so the first step of course, is to deploy to the destination blockchain a contract that's got say, the genesis block or some other starting block that can be used to confirm new blocks. And so how it works is that you have Alice who's a relayer, and hopefully there are lots of relays and they grab block headers off the blockchain and they put them on the destination blockchain. And those blockheaders are only trusted or accepted if the rules for the consensus protocol. So proof of work are correct. So the difficulty is okay, and it's building off the last block. So I've just said that. And so then Bob then executes a transaction on the source chain which causes that transaction to be included in a block.
00:32:13.470 - 00:33:23.330, Speaker A: So for Bitcoin there aren't any events. And so BTC relay is all about Bitcoin. And but so his transaction gets included in a merkel tree of transactions and then the block header that contained his transaction gets transferred across. And then once enough other block headers have been built on top of that block header and you have say, six block confirmations, then you're ready to go to use that transaction. And then Bob then can submit his transaction on the destination chain with the transaction from the source chain and a merkel proof showing that it was included in the block and then doing something with that. And so the compensation model that we've got here is that users pay for confirmed transactions and then the relayers that have blockheaders that are used get compensated. And so the advantages of all this is that you only need one honest relayer.
00:33:23.330 - 00:34:36.990, Speaker A: So you can have as many dishonest relayers as you like, submitting false blockheaders that are on forks of the canonical chain, but you just need R1 honest relayer who submits the canonical chain, and it's going to have better proof of work. So better weight, better length, and so hence that will be the trusted chain. There is a disadvantage, or actually multiple, and one of the big ones is that if there are no transactions on that BTC relay, then the relayers aren't being compensated and so they'll stop working. And so if there are no confirmed transaction blockheaders, then you can't confirm transactions. This sort of approach has been tried on other blockchains that don't have as good proof of work capability. And the problem is that then the whole system can be hacked because someone can come up with a than the real blockchain by just doing better proof of work. And another issue is that the proof of work algorithm has to be able to be implemented on the target blockchain.
00:34:36.990 - 00:35:31.220, Speaker A: There are some attacks as well. So Lee Settle came up with this great attack. So imagine Eve has a $1,000 on Ethereum main net. And so Eve sets up the contract so that she says if someone gives me $1,000 worth of bitcoin on bitcoin, then I'll give them $1,000 on Ethereum. And then Eve convinces Alice and Bob to transfer $1,000 of bitcoin to her on bitcoin based on the ETH that's on Main net. So only Alice or Bob though, will be able to confirm their transaction because one of them will get the $1,000 worth of ETH and the other, by the time they submit, it'll be too late, there won't be any ETH there. And so Alice gets $2,000 of BTC, or rather Eve gets 2000 of BTC and Alice gets 1000 and Bob gets nothing.
00:35:31.220 - 00:36:20.642, Speaker A: They also identified another attack, a liveness one. And so you could imagine that Eve convinces Alice to have $1,000 of Ethan Mainnet and then Eve walks away and never transfers any money. So Alice now has got her money locked up forever, which is not good as well. Martin Swind, who was the chief security person at Ethereum Foundation, he identified a software defect as well, which meant that you could get around having to pay to have blocks or transactions confirmed. So there were software bugs as well. So that was BTC. Really? Has anyone tried a similar thing with Ethereum Mainnet? And the answer is yes.
00:36:20.642 - 00:37:28.162, Speaker A: So there's the Rainbow Bridge by Nier Protocol And so it's a way of going from Mainnet to NIA's blockchain. And so they've done this massive feat of getting the Ethereum Proof of work algorithm to work on NIA. And it's a huge feat because it's a time and memory hard protocol and so it's much more complicated than Bitcoin's protocol and so it works. Ethereum Mainnet is going to be. Coming proof of stake in Q One next year probably. And so once the merge happens, this bridge is not going to work because there'll be no proof of work anymore. So now I'm going to talk about these semi trusted or trusted mechanisms and invariably you've got a threshold number of relayers or some validators or testers and they sign or maybe they do multiparty computation on the source chain.
00:37:28.162 - 00:38:59.220, Speaker A: So threshold signing essentially, but sometimes it's not signing, it's computation. And if you've got a trusted system, maybe you've only got one relayer. And so the public keys of the system are registered on the target blockchain, which invariably means for Ethereum, the address is stored on the blockchain. So I'm going to walk through a whole stack of approaches, but the choices really come down to who is signing. Do you sign individual messages or maybe a merkel? Whether you've got a whole merkel tree of messages, do you create that merkel tree yourself or are you relying on blockheaders and transactions? So have the blockchain create that merkel tree, do the Attesters cooperatively sign or do they separately sign? And do the relays and Attesters respond to requests from users and maybe have to deal with Dos attacks? And so who does put that transaction on the destination blockchain? So the first approach is a bit like Iron framework. So you have a source blockchain and you have Alice submitting a transaction and it emits an event. So business logic contract calls the bridge contract and the bridge contract emits an event.
00:38:59.220 - 00:40:05.414, Speaker A: And then you can imagine that you have relayers and they see the event, they see blocks being produced. And once the blocks are final, they each individually submit the block header on the destination blockchain. And then Alice then can submit her event with a merkel proof which says this event was part of that block and hence you should trust it. And then based on the function call that's submitted, a business logic contract gets called. And so for the simplest approach, you're submitting all of the block headers. And so this is simple and the relays don't have to talk to each other and the users aren't interacting with the relayers, which is good, but you're submitting one transaction for each relayer for each block, which is a lot of transactions. And if there are multiple target blockchains, these transactions are going in all sorts of directions.
00:40:05.414 - 00:41:06.380, Speaker A: You got transactions for each block, so it's a lot of stuff happening and the relayers have to pay to submit those transactions. It's going to cost money and the user also they have to be able to submit a transaction on the destination, which is not good. So a subtle modification of the system is the relayers watching the events and watching the blockheaders and only submitting the blockheaders that are needed onto the destination. And in this case, you're only doing one transaction per relayer per block that is needed. But of course, the big thing is that now you've got to work out which transactions are going to which blockchain and hence which block headers need to be transferred. So suddenly your relayers have to get more complicated. They need to be able to understand which blockheaders to transfer.
00:41:06.380 - 00:42:37.078, Speaker A: And another slight change would be that the relays cooperate and then just one of them transfers the needed block header. And so this is good because now you've gone down from one transaction per block per relayer to just one transaction per block header that's needed. But the relays do need to talk to each other and that cooperation, that protocol of all that communication is non trivial. Another mechanism that doesn't use these relays is having an Attestor. And so again, Alice submits a transaction bridge emits an event and then the user says to a set of can, did you see that event? Can you sign that event and say it came from this source blockchain and it should be trusted. And then she gets a threshold number of those signed events and then she submits them to the bridge contract and again executes her code. So the Attesters don't have to submit any transactions on the destination blockchain, which is fantastic, but the Attesters are only signing for a certain contract, so they don't need to understand the target blockchain either and they don't need to cooperate.
00:42:37.078 - 00:43:29.562, Speaker A: But the users have to interact with all of those Attesters, which is pretty big. The Attesters could cooperate and then the user just has to interact with one of the Attesters. But now the Attesters are going to have to cooperate and that's pretty big. And the user is still interacting with the Attestor, which is not good. Another way you could do it is the relayers rather than relaying blockheaders, they could relay the event themselves and so they could look at the event and then they could all separately relay the event. And this is how chainsafe's chain bridge works. And so the relays aren't cooperating, which is great, and the user isn't interacting with the relayers, which is great as well.
00:43:29.562 - 00:44:36.174, Speaker A: And the users don't need to submit a transaction on the destination, which is fantastic, they don't need any value. However, the relays are submitting one transaction per event and they're submitting transactions on the destination blockchain. So suddenly you got to worry about how much is it costing for the relayers to submit transactions on the destination. And yeah, the relayers do need to have some understanding of the target blockchain for that event. It adds some levels of complexity as well. So the relays could cooperate with each other and then submit a signed event, which would be another approach, which means that now we've only got one transaction per event from the relayers, but the relayers need to cooperate. Another approach is the one that the Solana bridge has done.
00:44:36.174 - 00:45:37.090, Speaker A: So the Solana to ethereum their bridge is called Wormhole. And so with their approach. You do that set of emit the event on the source, you have a set of attesters. And what you do is you observe the event. And then what you do is you submit that event as a signed event on a special cross chain event contract, and then anyone can fetch that signed event and then they can then submit that event on a destination blockchain. And so the good thing about this approach is that the relayers aren't submitting any transactions on the destination blockchain. And so they don't need to be doing any interaction, which is really good, but they do need to cooperate and the user is submitting that transaction on the destination.
00:45:37.090 - 00:46:33.246, Speaker A: Another interesting approach is the Cello Optics bridge. And so with their one, I mean, it's far more complicated than I'm going to talk about, but I'm going to give you some feel for it, though. So the user submits a transaction that emits an event, and then you have these attesters, put the event, the message, into a queue of messages and create an incremental merkel tree. And so I think you can think of how Ethereum Two's beacon chain has an incremental merkel tree model. I think they're using the same thing. And so what's happening is they submit back to the source chain the root of that incremental merkel tree. And so for each message coming out, they're giving a new route.
00:46:33.246 - 00:47:05.658, Speaker A: So you can look at, say, route two. So in route one, you've got message one and message two could be confirmed based on route one. But then when you added message three, you've got route two. And the good thing about route two is, though, you can still confirm message one and two as well as message three. So in blockheader transfer, each block header is different. And so you're not summing up all of your messages into one tree, whereas in this approach, you are. So that's a really good feature.
00:47:05.658 - 00:47:58.160, Speaker A: And so the testers submit an ordered list of merkel routes back to a contract. Then you have relayers and they grab those merkel routes. And so they might grab, say, one a second, one a minute, one an hour, one every hundredth merkel route. It's really up to the relayer as to how often they do this transfer. And the relayer submits the signed merkel route to a bridge contract. And so then after a wait period, the bridge users can then use that merkel route to submit their message, which then calls a business logic contract. So, yeah, that use of the merkel trees is an interesting one.
00:47:58.160 - 00:49:09.106, Speaker A: So in Cello Optics, you only need to have one relayer transferring the merkel route. So this saves gas, but you do need to wait for this broad window to expire. And then the idea is you're going to have some observers, we're going to submit malicious merkel roots back to the source chain so that you know about, so you can slash a tester. So the updaters another sort of deficiency or issue with the protocol overall is that it's up to the application to block malicious messages. So if you're on that destination chain as an application you need to understand whether a message is malicious and then block its usage. And so this is sort of the application layer, sort of knowing stuff about the messaging layer, which seems to be a bit of a mix up of protocol layers to me. The relayers aren't submitting any transactions on the destination chain.
00:49:09.106 - 00:49:55.074, Speaker A: Well they sort of are, the Attesters aren't, but the relayers are. So the relayers again, they're not having to worry about the actual target blockchain or the Attesters don't, but the relayers do and the users aren't interacting with the testers, all the relayers, which is good, the Attesters are cooperating, the relayers don't need to. So I think my words here need to be reworked. Sorry about that. Extradition. So I've talked about a whole stack of different schemes for transferring events and one thing I've skirted around is actually the signing. You know, obviously you've got ECDSA but you've also got BLS.
00:49:55.074 - 00:50:58.342, Speaker A: And BLS comes in multiple forms. So you can have aggregated BLS and have threshold BLS based on that. So where you add all your BLS signatures and you keep track of which one signed and then you use that to work out which public key to use. Or you can have threshold signatures where you have one public key and you use essentially multiparty computation to work together to cooperate, to create a signature. You can also use schnor aggregated signatures, that's what onechain is using. So I've talked just point to point, but as well, as I said, you can have Hub blockchains as well. So the reason why people like Hub blockchains is rather than having to have potentially order n number of bridges, you might only have an order one number of bridges.
00:50:58.342 - 00:52:01.630, Speaker A: So in order of the number of blockchains is the number of bridges rather than it being a multiple. So they reduce the number of bridges you've got to have, which is good, but do all the blockchains and roll ups need to be interconnected good, something to think through. And these Hub blockchains are not going to, they're not charities, they're not going to do stuff for free. And as well the latency is going to increase going across these hubs. So you're going to increase the latency of your transaction. Polynetwork have a Hub blockchain as well and in their approach they have a merkel tree of merkel trees. And so the idea there is that you've got your merkel route from one blockchain and a merkel route from another blockchain and then you aggregate those merkel routes up and you then advertise the merkel route of the whole network to all the blockchains.
00:52:01.630 - 00:52:51.520, Speaker A: So there's also staking and slashing and so the Attesters or relayers, they can be required to front up some money. So I've heard amounts such as 50,000 and $100,000 mentioned. And so you stake that money and then if you're proven or your threshold number, if you're proven to do the wrong thing, you get slashed. So something to think about is how much money is being staked. So if you're transferring $500,000 and there are 25 relayers and it's 17 of 25 and they're each staking $100,000, then it's $1.7 million is being staked. So probably okay, but if they were only staking $20, then it's a bit of a problem.
00:52:51.520 - 00:53:46.880, Speaker A: And so you need to also understand when people say we've got this staking slashing solution, you always should ask how am I going to go about slashing? It's great to say I could slash, but how do I really go about slashing? Who can do the slashing and how is it really done and who can be slashed? So you might find that there are only very few parties in the overall solution that can be slashed and only in very certain situations. And so the slashing staking solution might not be as good as it sounds. Yeah. And how is misbehavior proven? And invariably this is going to have to come down to some sort of cryptographic enforcement. It can't be he said, she said. It's got to be. Look, they signed this, but this is obviously malicious and I can prove that they signed something that's wrong.
00:53:46.880 - 00:55:01.750, Speaker A: Another thing to think about is transactions. So what happens in the system if a transaction fails? Does the relayer retry the transaction? Does it reprice the transaction? Same higher tip or higher gas price? What happens? How does this work? And this is something that's quite key. And you could imagine that this does happen, that maybe the permissioning might fail or something like that. So what about at the function call layer? So you can imagine that you have a single blockchain call where you have say, this swap function calling trans. So you've got condom there. And so you've noticed you've flipped your from and to because on one contract you're transferring from to two and on the other one you're getting two to from and abhay. It'll be on YouTube.
00:55:01.750 - 00:56:08.960, Speaker A: And so if you're in the cross call situation in the multi blockchain, you need some magic function, some cross call function to do this transfer for you, where you're specifying the destination blockchain and contract the function to call and the parameters. And so you could have a simple function call protocol. And so you call a contract on a blockchain based on an event. And in fact, I've implemented an example version of this. And so in this not atomic version of the system, you have a business logic contract. Submits a transaction, goes to the function call layer and then using one of those messaging protocols, you go across to the function call layer on the other blockchain and then that bridge contract executes the function for you. And so nice and simple.
00:56:08.960 - 00:56:49.146, Speaker A: However, it's not atomic. So these updates across blockchains are not atomic. And so the transaction on that destination chain could fail. And the reasons why it could fail is maybe there's an revert that happens. So maybe on the destination chain there's not enough funds or there's some other situation that you get a revert. You might not have enough Ether to pay for gas, say for the relayer. You might not have permissioning, so maybe there's solidity level permissioning that's blocking the call.
00:56:49.146 - 00:57:37.398, Speaker A: But maybe also there are some other level of permissioning. Say, maybe it's a private network and you no longer have permissioning to submit a transaction, and maybe you submitted a transaction at a certain gas price, but now suddenly there's an NFT sale and the gas prices have gone up by a factor of ten or maybe just something. There's a configuration issue and the nonce is incorrect. So it does happen all the time that transactions fail, including on bridges. And so you've got to realize that if you've got a non atomic protocol, you've got to deal with them. You've got another protocol that I've worked on is Gpact. And so it's general purpose atomic crosschain transaction protocol.
00:57:37.398 - 00:58:06.420, Speaker A: And so it's all about atomic updates across blockchains. And so either all of the updates are committed or they're all discarded. So you can think of it as a two phase commit scheme for call execution trees. And it allows you to have a composable synchronous execution model. That is what application developers are accustomed to. So in solidity on Ethereum mainnet, it's composable. So you can have components that you can bring together to create an overall application.
00:58:06.420 - 00:59:01.650, Speaker A: When you execute something, it executes immediately. And when you have a return result, it's there when the function returns. And so it's synchronous as well as composable. And so this protocol gives you that as well. And so there's an open source repo with the implementation of this protocol. And so this protocol allows you to do complex things like this where you have a root transaction, say, a trade wallet that talks to a blockchain which has, say, some business terms in it, saying that a shipment has occurred, let's pay on the finance blockchain and let's have the logistics transfer ownership on the logistics blockchain. And so you can do that cross system cross blockchain call using this protocol.
00:59:01.650 - 01:00:16.134, Speaker A: And so the idea is that you have the entry point function calls on each of the blockchains and you have the parameter values that you're going to pass in and you commit to those values. And then you advertise that commitment by having a start transaction. And then you have these segment transactions which make up the leaves of the call execution tree and you work from the leaves up to the root of the execution tree. And then when you finally execute the root of the execution tree, then you're saying commit or discard. And so you're saying, should all the updates across the blockchains be committed or discarded? And then you commit or discard them using a signaling transaction. And so the technology uses lockable storage and so the business logic contracts, they have values that are going to change part of a cross chain call in lockable storage. And so you have a cross chain control contract that controls the overall execution on that blockchain.
01:00:16.134 - 01:01:05.130, Speaker A: And it works with a Verifier to verify those cross chain messaging information from other blockchains. And you call out to lockable storage and then you call back in to do a cross chain call. And there's a technical paper which explains this in great detail. And there's also some videos on the YouTube channel for the Ethereum Engineering Group meetup. Please watch them to understand the protocol in more detail. So the thing to think about when you're using this protocol, and I dare say most of the atomic ones, is that you cannot have unpredictable values that are going to be part of a parameter. And so you can't say, have the block hash of the current block or the block the timestamp.
01:01:05.130 - 01:02:19.762, Speaker A: And so the storage locations that are going to affect the parameter values need to be accessible because you're going to need to be able to work out what they are so you can commit to them. The applications need to be designed with locking in mind, so you can't just execute and not do any locking. But as well, if you've got something, a resource that many people are going to execute, you need to design for parallel execution with locking and it can be done. So the root blockchain needs to be accessible as well, because it's the thing that you're going to be saying, should I commit or discard? And so you need to be able to access that blockchain as application. The gas costs are more than the non atomic protocol, so it's around three times is my current thinking, though the gas prices or the gas usage is being optimized, so anything in blockchain is subject to front running attacks. But let's face it, if you're advertising in a cross chain protocol, this is what I'm planning to do, then you've even got more front running attacks possible. So you need to design with front and running attacks in mind.
01:02:19.762 - 01:03:06.050, Speaker A: And again, in my talk on Gpact, I talk about how to get around front running attacks. So comparing Gpact atomic with a non atomic, say, a simple function call protocol atomic across chains, and if any of the parts of the transaction fail, you're all good. Whereas in for non atomic, you've really got to worry about failures. It's higher gas cost. So if you had all your, say, ERC, 20 transfers on one blockchain, then compared to that, it's about ten times as expensive. If it's a non atomic, it's about three or four times as expensive. So that's the overall approximation.
01:03:06.050 - 01:04:09.190, Speaker A: So the non atomic will work on any contract, whereas GPAC you've got to have locking in mind, but non atomic you don't have a standard execution model and you can't return values. And you've got to be worried about each segment executing separately. Whereas with GPAC it's all together. It's just like you're executing on a normal blockchain, but you've got your logic spread across blockchains. Yeah. And so I encourage you to compare if you've ever got an application, implement it as a single blockchain solution, and then implement it as, say, a Gpact and a non atomic to try and understand what the trade offs. Are and what the actual higher gas costs may be, because it's going to be application specific when we're looking at design considerations for the blockchain layer.
01:04:09.190 - 01:05:58.460, Speaker A: You know, the thing you've got to think about is that you've got to be trusting that event emitter and so you need to know so that function call layer bridge on the destination, it needs to only trust events emitted by the function call layer bridge on the source blockchain. And so you can't just trust any contract, you've got to just trust that contract for the relayers. When you've got these messages going along you need to worry about replay and you wouldn't want an OD message that said transfer ten tokens to someone to be replayed again and again. So you have to have a way of having some sort of unique ID or something to prevent replay attacks and as well you might want to just have a timeout or age events. So say look, after 1 hour any event from any blockchain is deemed invalid and that's just to stop people storing up old events that somehow other they've got obtained or maybe they've found some compromised private key or something and then they've created a malicious event. So I think you've got to look at having timeouts and the timeouts can also work in with those unique IDs that I talked about just before so that then you don't need to store all of your new unique IDs for all time and you can delete old ones. Another thing to think about when you're designing these systems is application level access control.
01:05:58.460 - 01:07:44.074, Speaker A: So on normal solidity on one blockchain you have message sender equals owner or authorized and then throw a require if you are not authorized. So in a cross chain situation it's going to have to look something like this. So is that source blockchain in the list of or in the map of authorized blockchains? And is the source address authorized as well? And was the actual the entity that sent me this or did this function call, was it the actual function call bridge contract or something else? So it's worthwhile you've got to do this application authentication to make sure you're being called by a valid party because that business logic contract there needs to know it's the bridge calling it and not some other contract. The function call layer has to provide the source blockchain ID and source contract address for applications. And so that's something that you've got to design into your function call protocol and should be there. And for these multi blockchain protocols like Gpact, you need to know about the root blockchain as well and have its Identifier as part of the overall call. So you can have a bridge that allows you to do arbitrary execution where you can execute anything, or you could decide to restrict which functions can be called.
01:07:44.074 - 01:08:59.662, Speaker A: So you could have an allow list of you can call these contracts and these functions and obviously arbitrary execution is going to be simpler, but it could give you some more security risks. So you've got to think about the flexibility and simplicity versus security and what does your solution need? It's also a good idea to be able to pause a bridge and so you need to be able to essentially pull the plug temporarily and say, hey, something bad is happening, let's pause the whole bridge. It'll be a pain to customers, but if you're currently being hacked, it's probably a good thing to be able to do. So we've done the messaging layer and the function call layer. Now let's hit the application layer. So we now need to have the move up the stack a bit. So now we're in our business logic contract and really your business logic contract is going to need to know that it's really dealing with part of your application and not some random other contract.
01:08:59.662 - 01:10:17.818, Speaker A: So maybe you need an allow list of application contracts that can talk to you. So, sure, in some situations you're going to be open to any application, any contract on any blockchain, but in other situations it's going to be more linked and so you need to have that allow list. You need to be pausable as well. So the reason for having pausability at the function core layer and the application layer is what happens if there are multiple applications using the one function core bridge and it's only your application that's being hacked. The function core bridge is not going to want to pause, they're going to want to keep on going. So you might be in your best interest to have your own pause feature and it's not going to cost you a lot of gas because all you're going to do is be reading one storage location to say, am I paused? So it's not a biggie. Another thing to think through at the application layer is that if you are using a non atomic cross chain function call layer, then you could have failed transactions.
01:10:17.818 - 01:12:02.410, Speaker A: And so invariably you'll see these, ERC, 20 bridge contracts and they'll have some admin transfer. So it's where you've got this entity that can do a transfer to anyone for any token in any amount. So imagine if you had say, $200 million worth of wrapped e on your bridge and you've got some admin somewhere can just do this call and can transfer all that money. So it's a bit of a scary thing. And so I guess the question is who is this really trusted admin that you're going to have? And what happens if they send $200 million to the wrong address? Or even if it's just a $10,000 transfer that fails and they have to do a refund? What happens if they do a typo and they send $100,000 rather than 10,000 or they send it to the wrong recipient or for the wrong token? To me it feels like a complete nightmare of this is the real cost of non atomic bridges is having to have this admin transfer. So as well at the GPAC protocol it requires locking and the locking is actually done in the application. And so you can do locking for a whole contract at a time or just single storage locations.
01:12:02.410 - 01:13:06.050, Speaker A: And so if you do for a whole contract, obviously your whole contract is locked, but it's simpler and it's going to cost less gas. But if you're doing per storage location then you can have far more complex designs and in fact there's templates to help you to make this simple for you, but it does cost a bit more gas. Another thing to think through, especially for ERC 20, is minting and burning and mass conservation. So you can have an ERC 20 bridge or ERC 20 contract, should I say, which is a minter burner. And in this situation any user can burn tokens, so essentially throw them away, have them destroyed. You can have burn from where another account can be authorized or allowed to burn your tokens as well. Certain entities with a minter role can be authorized to mint tokens.
01:13:06.050 - 01:14:14.482, Speaker A: So you can imagine that you've got say, ethereum mainnet and a side chain. And when someone transfers tokens from Mainet to the sidechain, you want to mint some tokens to give them based on what they've done on mainnet. What that's going to mean is that the entity that's authorized to mint is going to be the cross chain bridge. And so that's a bit of a problem because it means that this bridge contract, which could be hacked, has the ability to mint as many tokens as it likes. So the opposite type of bridge or contract is a mass conservation contract. And in one of those you work out your total supply and at that point you can't go off and create more tokens. And so invariably your bridge owns some tokens and it transfers essentially to users and then they transfer tokens to the bridge, to the bridge ownership.
01:14:14.482 - 01:15:03.990, Speaker A: And so in that way the bridge is holding the token. Most tokens that can be stolen is the number of tokens that were in escrow and so the attacker can't create more tokens. And of course you can limit how many tokens are active as well. The bridge doesn't have to own all. The tokens. So another thought is limiting the value on the bridge. If you've got, say, $50,000 per staker and you've got overall a million dollars staked, say, then you could say we want to limit what's on the bridge to being less than the amount being staked.
01:15:03.990 - 01:16:40.840, Speaker A: But of course, as we know, it's not the amount staked, it's the amount that can be slashed, which is subtly different. But, yeah, so you want to try and limit that. But the question then you've got to ask yourself about we're going to limit, you're going to have a bridge quota is. So at which layer of the bridge are we doing this quota? And can the, say, function call layer know anything about the amount of money on the bridge? And what about, ERC, 20 or, ERC, 721 tokens? So the NFTs, how much is an NFT worth? So how do you work out how much you've got on the bridge? And what about a trade finance situation? How does that relate to money on the bridge? And for that matter, how do you temporarily reject things or pause transactions whilst you're waiting for money to go off the bridge? And what is on the bridge anyway? What does it mean to be on the bridge? So another thought is at the application layer, is that all these cross chain transactions cost money. So maybe you could somehow other batch them up and say, maybe hold all transactions for, say, ten minutes and then send them off in a single transaction. Or maybe you allow users to send multiple different tokens all in one transfer. So you're going to have to worry about then what happens if one, but not all fail on the destination? What happens then? So I think there's a lot of complexity trade offs there.
01:16:40.840 - 01:17:52.302, Speaker A: All right, security. So there is. So Open Zeppelin is a project which does lots of template contracts that you can use, and they've got some access control contracts and using them to then have different access levels for different users is a great idea. So you wouldn't want to have, say, process data and add new bridge contract. Being part of having the same access level, you need to have different roles and different access levels so that you've got some level of security. You want to separate out the data or the data channel and the control channel so that you can't get that mix wrong. Another really big thing with security is before you take on some sort of destination blockchain or roll up, you got to look at the security of it.
01:17:52.302 - 01:19:00.190, Speaker A: Do you trust that they've got good security? I'm talking about physical security, I'm talking about eSecurity. Could their private keys get compromised? And how solid is that blockchain? Because, as the diagram here, if that ground gave way, that whole bridge is going. And what happens if the bridge stops working because a source blockchain becomes untrusted, because it becomes fully compromised? What happens to the tokens that came from that bridge that are on another blockchain? How does that all work? Another security thing to think through is attack surface. So when you've got a single blockchain application, your attack surface is that blockchain. But once you're looking at cross chain, your attack surface has now extended to the other interconnected blockchains. And so you really need to then be controlling which blockchain you react to. Okay, another thing to think through is the blockchain IDs.
01:19:00.190 - 01:19:44.878, Speaker A: So where do they come from? Are they correct? How do you know that you're interacting with the right blockchain? And how do you work out the boot nodes to interact with? So Wager and I, via the Enterprise Ethereum Alliance, have come up with an EIP that talks about this. So have a look at that. Upgrade is another thing. So you may need to fix defects in your contracts. And so you need to have upgradable contract pattern. And so there's two ways of doing this. One is like having a separate data holder and business logic contract.
01:19:44.878 - 01:21:20.366, Speaker A: There's also another upgradable pattern that OpenZeppelin have come up with, which is really cool. And so you really need to think about having that ability. But also you've got to think about the ramifications of being able to upgrade. So will users be concerned about contracts that are upgraded? And another really big thing for security and this is for users, but who are these POA people, these Attesters and relays? Should they be trusted? And do they use staking and slashing? And how do you go about slashing someone and how are they allocated? Is it some sort of random allocation? A bit like, say, how Ethereum Two is going to work? Yeah, how does it work? And so if the validators, say, were the same, or rather the relayers were the same as the validators from the side chain that you're interacting with, then maybe that's pretty good because they've got a vested interest in making sure that the blockchain doesn't get hacked. And a lot of these protocols have these watchers, or fishermen, fisher, women who are going to be watching the chain to make sure everything's good, but who pays them to keep on working. And if there's 99% of the time there's no bad behavior, then they're not being paid, so they're not going to operate. So who's paying the watchers to watch the network? So we've also at the EEA come up with some great security guidelines.
01:21:20.366 - 01:22:27.650, Speaker A: I encourage you to have a look at them. So people ask this quite regularly, how many TPS? And it really does depend. And so the limitations are going to be caused at multiple levels. And so one is that if the relayers have to sign every message, that's going to be a limiter because a lot of signing and you've got to be submitting those transactions to the destination blockchain. But equally, if you got to coordinate that's, a lot of work too. And the number of transactions that need to be submitted on the chains is another thing and the amount of gas used is because that affects the amount of transactions that can be submitted there's. Also if you're going to have mass have a quota on the bridge, then what's the latency across the bridge? And what about if you've got a hub blockchain? Well what's its maximum TPS? And is that going to be the limiter? You've got to worry about also the performance of these blockchains, and especially when they're in congestion.
01:22:27.650 - 01:23:49.280, Speaker A: Maybe the scalability of your bridge is going to go down and as well, at the application level, it's going to come down to what's being executed and as well for lockable contracts, how they've been designed and whether you can have parallelism or not or it's all got to be serially done. Bridge fees, how are we going to make money out of all of this? So bridge fees can be charged at many levels and in fact I should have probably put in the messaging layer as well. So I think the messaging layer could be watching who's doing what and refuse to transfer or relay messages if you haven't subscribed for instance. But you could imagine, you could have some ERC 20 that you ask for. So you could imagine you can have an ERC 20 that you get charged as part of the bridge function call. And you could also require ETH be transferred as part of the call. You could have people being in an allow list and you pay based on a subscription service.
01:23:49.280 - 01:24:35.200, Speaker A: There are many mechanisms. Okay, so the EEA working group is working on standardizing the interfaces between layers and in the GPAC repo you will find this protocol stack including the interfaces. And so this is being actively worked on. I encourage you to have a play with it. Have a go, feel free to contribute. So some philosophical questions before the A. If you Google Ethereum engineering group on YouTube you will find our YouTube channel.
01:24:35.200 - 01:26:08.454, Speaker A: Okay, so philosophical questions. So what is a bridge? So is it the function call layer, the messaging layer, or the application layer? Or somewhere in the middle, which of those is the bridge? Or is it all three? Another thing to think about is so we talk about transferring tokens but is one say token on mainnet the same value as on a side chain? You've got different liquidity pools sizes so it's going to be different. And is having an upgradable contract a good thing or a bad thing? And when is money on a bridge? Is it when the bridge contracts have access to them? And probably the big one is that last one. So if you're transferring a billion dollars, which one would you use? And of course there are these design choices and things to be thought about. Who do you trust and how many transactions do you need to actually have these transfers go through? And who is submitting the transaction? And can a user do this without having any value on the destination? What attacks are there? So, coming up, we have got a stack of talks over the next three months. I encourage you to turn up to all of them. And so next is Raghavendra with state expiry.
01:26:08.454 - 01:26:49.770, Speaker A: So just go onto the meetup website. So this is the Ethereum Engineering Group meetup. Go on to our one. I do put some on the other Meetups, but not always. So for a complete list, use the Ethereum Engineering group. And I have talked an awful lot and I don't know if I even dare to say are there any questions? I know Mark put something in, maybe that's good. Oh, just a sex flies off you lie saying something awfully quietly.
01:26:49.770 - 01:27:26.018, Speaker A: There's a question for you in the chat. Okay. All right. How do you transfer $1 billion? I don't have a billion dollars. I think good problems to have, probably. I don't know, is having a billion dollars a good thing or a bad thing? I'd probably give some of it away or do some I do something a few bitcoin right. Yeah.
01:27:26.018 - 01:28:15.700, Speaker A: I don't know. All good. Funny fun, isn't it? What do you do with a billion dollars? But, yeah, I think realistically, transferring it incrementally might be the way to go. So I know we all get hung up on Ethereum transaction costs and stuff and maybe bridge transaction costs, but if you trickle feed, it at $10,000 at a time. But the big thing is you want to transfer out of the bridge, because as we know from the polynetwork hack, $600 million, if it's all sitting on the bridge, then it can be taken. All right, well, look, thank you, everyone, for bearing with one and a half to ask Vitalik that question. Right, yeah.
01:28:15.700 - 01:29:23.020, Speaker A: So we've had Vitalik do a talk at one point, and I tried to make sure everyone stayed clear of the is the ETH going up? And how much ETH do you have, Vitalik? Because it feels a yeah, but I think you probably find he'd say, why would you transfer why would you you don't need well, I don't think you'd transfer a billion. I can imagine, though, transferring some money onto a roll up just to do stuff on a roll up, but yeah. All right, look, thank you, everyone. Have a great two weeks. It's going to be great to hear Ragavendra in two weeks. Please RSVP for all the sessions. And in particular, I'm really interested in seeing how everyone goes at these solidity test in about two months, you know, start learning up on solidity now, Stefan, and you'll be ready to do the solidity recruitment test.
01:29:23.020 - 01:29:26.390, Speaker A: All right, bye.
