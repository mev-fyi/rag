00:00:03.050 - 00:00:29.446, Speaker A: Hello and welcome everyone. This is the Ethereum engineering group meetup. I'm Peter Robinson, and today we've got Sriram Kanan on and he's going to talk about his technology Eigen layer. And I mean, I can say all sorts of things about it, but Sriram, why don't you introduce yourself and briefly introduce the tech other than me probably doing a garbled story. I'm sure you'll better job.
00:00:29.628 - 00:01:04.242, Speaker B: I really appreciate it, Peter. Thank you so much for inviting me to come speak to you all. Thanks to all of you, David, Frank and others here for making the time to come to this talk. I'm Sriram. I've been working on this project called Eigen Layer over the last two years and my work in the blockchain space, things like consensus protocol, scalability. This goes over five and a half years. I was faculty member of the University of Washington, Seattle, where I ran the UW blockchain research lab.
00:01:04.242 - 00:01:35.338, Speaker B: I've been on leave from there building Eigen layer. My interest in peer to peer systems date far back. Like my master's in PhD was in peer to peer wireless systems starting from 2006. So that's a brief background of my interest in this space. I'm very excited to talk to you today about Agore. I will just dive into the talk to start with. Sounds good.
00:01:35.424 - 00:01:38.346, Speaker A: Are you happy for people to ask questions at any point?
00:01:38.448 - 00:01:48.718, Speaker B: At any point. I'll stop for all clarification questions. If there's something much more detailed that we need to take a sidebar, I'll say that, and we can do that at the end.
00:01:48.884 - 00:01:50.750, Speaker A: Sounds great. Thank you.
00:01:50.900 - 00:01:52.458, Speaker C: Thank you so much, Pierre.
00:01:52.634 - 00:01:54.510, Speaker B: All right, are you able to see the slides?
00:01:55.970 - 00:01:59.838, Speaker C: Yes, perfect. Perfect. Yes.
00:01:59.924 - 00:02:13.110, Speaker B: So what I'm going to present today is about some of the core ideas underneath the project called Agon layer. I have 55 minutes. Is that about right, Peter?
00:02:14.090 - 00:02:28.026, Speaker A: Yeah. Or take as long as you like. I mean, if you go for 55 minutes and then people ask questions and then we make it to one and a half hours and that's great too. But yeah, that sounds like an awesome amount of time.
00:02:28.208 - 00:02:29.340, Speaker C: Okay, perfect.
00:02:31.330 - 00:02:38.400, Speaker B: Okay, so what we're building, I call this a universal marketplace for Ethereum, decentralized trust.
00:02:39.010 - 00:02:39.760, Speaker C: And.
00:02:42.130 - 00:02:43.458, Speaker B: What am I talking about?
00:02:43.544 - 00:02:44.082, Speaker C: Right.
00:02:44.216 - 00:03:49.590, Speaker B: And I think maybe to set the context, I'll say something about why decentralized trust is the core primitive in blockchain. When you think about whether something is a blockchain solution or not, like somebody builds uber or social network, or you have blue sky, or somebody builds a decentralized AI system or whatever. Now you want to know whether it is, whether we would call it in the field a blockchain solution or not. I think the decision boundary, does it rely on decentralized trust or not? If it relies on decentralized trust, likely we'll call it a blockchain solution. If it doesn't, you're going to likely call it a not blockchain solution. So the sharp decision boundary between what we call like a crypto or a blockchain solution is it relies on decentralized trust. Okay, so if decentralized trust is the core raw material of blockchains of the entire economy underbending blockchains, let's examine how decentralized trust gets produced and refined and distributed.
00:03:49.590 - 00:04:10.058, Speaker B: So I'm claiming that we're building like a universal marketplace for decentralized trust. And a marketplace for decentralized trust is not a new concept in and of itself. And I say here that Ethereum was the first marketplace for decentralized trust.
00:04:10.224 - 00:04:11.660, Speaker C: Why am I saying this?
00:04:12.610 - 00:04:44.710, Speaker B: It's somewhat different from the normal view that people take, but really what Ethereum did. So if you zoom back in time and see what the situation was, pre Ethereum, you had this idea of decentralized trust that you can know. Of course, Satoshi, in the breakthrough work on bitcoin, basically showed that you can actually create a permissionless system building upon decentralized trust and where usage of the network was permissionless. Anybody can come and use the bitcoin network to do transactions.
00:04:45.290 - 00:04:46.040, Speaker C: But.
00:04:47.870 - 00:05:47.734, Speaker B: What Ethereum did is by making the programming layer, by making the programming language Turing complete, a general purpose. What it did is really to create a new structure for blockchains where applications became modules that can then be tethered on top of a common framework, a common platform. So here's the kind of layers of the stack as I see it. Like you have the trust network, and in Ethereum when it started, it was the proof of work, and later after the merge, now it's in the proof of stake. But on top of the trust network, there is some consensus protocol, some way to coordinate actions across individuals. And then you have emergent from the distributed consensus is like an ordering of transactions, and then you need an execution environment to actually go execute it. And in the Ethereum case, that was the Ethereum virtual machine, the first general purpose programming environment for blockchains.
00:05:47.734 - 00:06:25.186, Speaker B: What it did is it was not just a technical accomplishment at the programming language layer. It really opened up the market structure. What it means is now if I'm building an application. Let's take ens as an example. So if you take ens as the Ethereum naming system, and there was previously before Ethereum, if you wanted to go build a naming service, you had to go build a new blockchain. In fact, some people tried it. There was the famous namecoin, which was like bitcoin, but only useful for creating addresses and names.
00:06:25.186 - 00:06:37.130, Speaker B: So that was the namecoin, but that required bootstrapping a new trust network for just that application. It's a huge amount of work. It's a high bar to go execute.
00:06:37.550 - 00:06:39.226, Speaker C: So what Ethereum did is said that.
00:06:39.248 - 00:06:45.822, Speaker B: There'S a common framework, a common programming environment. Now anybody can come and build an app, but the application is basically paying.
00:06:45.956 - 00:06:50.590, Speaker C: Ethereum, the takers or validators or whoever.
00:06:50.930 - 00:06:53.870, Speaker B: For actually providing decentralized trust.
00:06:54.020 - 00:06:56.194, Speaker C: So in some sense, what is happening.
00:06:56.232 - 00:07:42.394, Speaker B: Is you have decentralized trust emerge out of the trust network and get passed through the consensus protocol like the virtual machine. And then there is a market for decentralized trust that anybody can come and consume. Why am I kind of pointing a lot to this market structure is because this enables something absolutely insane, which is that as an application creator, you do not have to be trusted. An application creator does not have to be trusted. They borrow trust from Ethereum and they just innovate on top of it. And this is such an amazing architecture because once you separate who brings trust and who brings innovation, now anybody can be innovative, but very few people are trusted. Trust is a huge bottleneck.
00:07:42.394 - 00:07:52.450, Speaker B: Like JP Morgan is trusted. I am not trusted. So you're not going to do a derivatives trade with me, you go do it with Morgan. Like, that's how trust works. Trust is highly centralizing.
00:07:52.790 - 00:07:57.782, Speaker C: But blockchains, especially this particular architecture of.
00:07:57.836 - 00:08:23.760, Speaker B: Separating who brings trust and who brings innovation, enabled many, many more people to come up with all of these things. Some of them were purely pseudonymous, the founders, we don't know who these founders are, but we can still go trust them. That's pretty amazing that. Now the barrier to creating innovation penned down massively. Another way of looking at the market economy is that the blockchain is creating trust.
00:08:24.690 - 00:08:25.054, Speaker C: Right?
00:08:25.092 - 00:08:40.466, Speaker B: Decentralized trust and then selling it to the applications. The applications are buying trust and paying for it. Okay, so another way of seeing it is you have decentralized trust emerge here at this base layer. It's getting refined in terms of I.
00:08:40.488 - 00:08:47.222, Speaker C: Use this consensus protocol and then I use this virtual machine and then now.
00:08:47.356 - 00:09:12.490, Speaker B: Out of which I can build. So you take some amorphous concept called decentralized trust. Refine it into something very specific, block space. There is a certain unit called blocks. Blocks carry, like EVM bytecode. There is a gas limit, which says how much of computation can be packed into it, and then now applications can consume it. So this created and kick started the first marketplace for decentralized trust.
00:09:12.490 - 00:09:23.394, Speaker B: But it's not decentralized trust, which is raw. It is decentralized trust, which is distilled through the consensus, through the virtual machine, through the gas limit, and then emerges the blockchain market.
00:09:23.592 - 00:09:24.340, Speaker C: Okay.
00:09:25.270 - 00:10:09.150, Speaker B: The downside of this market structure is that the marketplace is not fully flexible. What do I mean by this? Ethereum has a really interesting consensus protocol, the Gasper consensus protocol that many of you here built. But the consensus protocol makes certain opinionated choices on how many nodes to handle, how many signatures to handle, how fast the block speed should be, what particular consensus algorithm to use, and so on. And this is nowhere near a solved problem. There is a lot of innovation to be done on figuring out what's the best consensus protocol. So suppose you had a new idea for saying that. Oh, I have a consensus protocol where every node doesn't download progress.
00:10:11.090 - 00:10:13.150, Speaker C: Each node download.
00:10:18.830 - 00:10:19.850, Speaker A: Fixed that.
00:10:20.000 - 00:10:54.420, Speaker B: Oh, okay, thank you so much. Each node downloads a small amount of data, but together, they all download enough data, some kind of interesting consensus protocol. Now you cannot go an hour, I cannot go and go reprogram Ethereum, because that's just kind of out of scope. So what this did is gave rise to a marketplace of new layer ones. Every new layer one comes up with a new consensus protocol, new scaling architecture, all of these things, and then goes and executes on those things. But the hard part is.
00:10:57.270 - 00:10:58.146, Speaker C: Firstly, each.
00:10:58.168 - 00:11:44.020, Speaker B: Of them have to bootstrap their own trust network. Like, if you come up with a new idea for a consensus protocol, you're not just doing an engineering job of figuring out how to build the best consensus protocol. You also have to figure out how to build the best community and how to build the best token of value and all of these other things which are completely outside scope of a distributed systems engineer. So can we solve this problem? And we kind of approached this as a possible builder in this space. We were seeing that essentially, a protocol like Ethereum is like an ocean liner. Like, you cannot randomly go and try different things with it. You want to go steady, you want to go take the long haul, you don't want to make abrupt changes, but there is a lot of people.
00:11:44.020 - 00:11:53.606, Speaker B: And also, importantly, only one consensus protocol can be in the Ethereum native protocol. So you cannot have like ten consensus protocols and then people try out and.
00:11:53.628 - 00:11:55.254, Speaker C: Then figure out which one's better.
00:11:55.452 - 00:12:17.150, Speaker B: So as a kind of protocol builder, my interest was in seeing is there a low barrier way for people to come and try and play with new kinds of protocols that require distributed trust which is not supplied right now. As an application level programmer, I just want to go write a new EVM contract is not enough for me.
00:12:17.300 - 00:12:18.334, Speaker C: What can I do?
00:12:18.452 - 00:13:12.234, Speaker B: And that's what the problem that we are trying to solve and the way we solve it is by building this concept we call restaking. What is restaking? Maybe restaking is even more appropriately called programmable staking. Okay, what are we doing here? If you look at the root of decentralized trust of Ethereum, after the merge, Ethereum switched to proof of stake. What is proof of stake? Proof of stake is I take a bunch of eth or a bunch of money like some token of value, and I go and lock it up into a contract. And I tell in the contract, hey, I'm going to abide by the covenants of the protocol of the Ethereum protocol. I'm going to make the block in this way. I'm going to not sign two blocks with the same block number, whatever set of conditions that make sure that I produce blocks in the right way, I make that covenant and I say, hey, I'm putting up money to show you that I'm reasonable.
00:13:12.234 - 00:13:39.340, Speaker B: I'm honest. This is very important in a pseudonymous economy where you don't know who's going to run the network. You need to make sure that you have the ability to create both positive and negative incentives for these people. Okay, so that's what's happening. So you go to Ethereum, you restake, so you stick, right? That's what happens normally now. So the root of trust of Ethereum is coming from staking. I lock up stake and then I'm able to supply my trust.
00:13:39.340 - 00:14:33.562, Speaker B: Can we take this concept of staking and then expand it so that it's much, much more programmable? Can I take that 32 ETH and make a promise not only that I'm validating Ethereum blocks correctly, but also that I'm validating some other chains blocks correctly or some other service blocks correctly on top of theorem. So that's what restaking is. You stake your ETH and then you add on a programmability layer on top where you're making several covenants of what other things you're promising to do with your validator. I'm going to run the Ethereum node. I'm going to run like this other oracle or data availability or some other thing. I'm going to run all of these nodes according to the covenants. And then you go ahead and sign up for any of the services that can then be built on top.
00:14:33.562 - 00:14:39.466, Speaker B: So you have the concept called services. So Eigen layer is a two sided marketplace. I said it's a trust marketplace.
00:14:39.498 - 00:14:42.986, Speaker C: So there should be trust sellers and trust buyers.
00:14:43.098 - 00:15:16.390, Speaker B: Trust sellers are stakers. Stakers have stake and they have node operation abilities. They are basically selling trust. Who's buying trust? Anybody who wants to build distributed systems is buying trust, right? So I want to build an oracle, I want to build a data, I want to build a bridge, I want to build any of these things. Now I go and buy trust from the Eigen layer marketplace. So there is two sides to the marketplace. Stakers restake and then services build on top, and then they consume the trust.
00:15:16.390 - 00:15:39.114, Speaker B: So let me get into the mechanics of how restaking works. The way the restaking works is normally when you stake in. So we have two modes of restaking. One is called liquid restaking and the other one is called native restaking. I'll explain native restaking first. Native restaking is you stake in Ethereum. You're 30 to eat, and then you have many independent parameters to specify.
00:15:39.114 - 00:16:16.678, Speaker B: You can specify what the withdrawal credential is, who the fee recipient is, and who the validator public key is. What you do is you set the withdrawal credential. Normally you would set the withdrawal credential to your own hardware wallet or execution layer address, so that when you withdraw, all your money goes to that address. You can go and take it out and do whatever you want on Ethereum with it. Instead, you add one more step into your withdrawal flow. In the Eigen layer system, you create your own micro contract called the Nigen pod, which you kind of control, partially control. Only you can withdraw from that contract.
00:16:16.678 - 00:16:31.566, Speaker B: You go to Ethereum, and then you set the withdrawal credential to the Eigen layer contracts to your Eigen pod. In the eigenpot, there is an address called a pod owner. You set that to your hardware wallet or whatever.
00:16:31.668 - 00:16:35.350, Speaker C: So what happens is the Eigen pod.
00:16:35.370 - 00:17:02.138, Speaker B: Is now controlled by the pod owner and you have set your withdrawal credentials to the Eigenpod. So in the normal mode, if you didn't do anything, you opt into Eigen layer and you serve a bunch of services. You got your rewards. Now you want to just withdraw your eth from Ethereum and Eigen layer. Basically you go to Ethereum and then to the beacon chain and trigger the withdrawals. Your money goes to the Eigen pod. You control the pod owner address, so, which means you can then move the money out.
00:17:02.138 - 00:17:51.702, Speaker B: Except if you got slashed in Eigen layer for some bad service, then a portion of the 32 e will not be able to be withdrawn out of the Eigen pod. That's the basic structure of native restaking. You stake in Ethereum, set the withdrawal credentials to the Eigen layer contracts. The Eigen layer contracts, then lets anybody else, then lets you opt into any other set of services, not one, but any set of services that you want to opt into. And if you violate the covenants of any of those services, you will be liable to lose some amount of ETH based on what your covenant that that service was. So that's the basic structure of the Eigen layer system. I'll just briefly explain this and then I think maybe this is a good time to take questions on any of the technical aspects.
00:17:51.702 - 00:18:30.854, Speaker B: So anybody who's building a service needs to build two things. They're building an off chain container and an on chain smart contract. The off chain container is something that if you're staking and then if the staker is opting into your service, they have to download that container and run it. Like think of it like running a get node or a prism node or whatever. So you just download and run it in addition to whatever other things you may be doing. And then there's also a smart contract that the service creator is writing, which is a service contract which talks to the Eigen layer contracts. The service contract specifies who's allowed to register, what is the payment like.
00:18:30.854 - 00:18:32.598, Speaker B: If you store 1gb of data, I'm.
00:18:32.604 - 00:18:34.566, Speaker C: Going to pay you one e or.
00:18:34.588 - 00:18:50.026, Speaker B: Whatever the set of payment condition is. And then the slashing condition may be things like if you say you've stored an x amount of data and then somebody randomly triggers a challenge, or there is a random challenge protocol, and then like a random chunk is solicited, you have to produce it.
00:18:50.048 - 00:18:52.014, Speaker C: If you don't produce it within some.
00:18:52.052 - 00:19:31.146, Speaker B: Amount of time, you will get slashed. There'll be some kind of a covenant on each service. That's the Eigenve system for a service builder. They develop a smart contract on which they are specifying all the covenants of the protocol. There's an option container that the service restakers will download and run. And from the point of view of the taker, there's also another concept here called delegation, which is a staker can delegate. Suppose you're a homestaker and you want to opt into Eigen layer, but you don't want to actually take the hassle of running all these services.
00:19:31.146 - 00:20:05.700, Speaker B: You could delegate only for your Eigen layer services, but still be a homestaker for Ethereum. Or you might want to run all the services yourself at home and you can still do it. So there is no fix it delegation set. It's open and people can participate, just like Ethereum. There is no in protocol incentive for delegation, which means if you're delegating to somebody, then even though delegation is specified in the Eigen layer contracts, there is no end protocol incentives. There is no assurance that your delegate is going to behave right or not. You should do that based on real world trust on that person.
00:20:05.700 - 00:20:33.198, Speaker B: That's the core concepts around how the Eigen layer systems built. What I'll do is, in the kind of rest of the talk, kind of go over what applications and other things can be built on top of Eigen layer, including something we are building ourselves. So if there are any questions on the core architecture or how these pieces interact or anything like that, maybe now is a good time to just address.
00:20:33.284 - 00:20:41.754, Speaker C: It before we can move on to the other. Frank? Yes, over to you, Frank. Oh, thank. Yeah.
00:20:41.812 - 00:20:50.046, Speaker D: So if I understand. Well, you somehow have a mechanism to bridge the stake to some another layer.
00:20:50.078 - 00:20:52.226, Speaker C: Let'S say Eigen layer, and then you.
00:20:52.248 - 00:21:07.210, Speaker D: Have a programmable notion of slashing conditions, right? So you make the slashing conditions that are built in into Ethereum parametric, so you can redefine your own slashing conditions.
00:21:07.790 - 00:21:10.202, Speaker C: Okay, that's right.
00:21:10.256 - 00:21:40.510, Speaker B: Exactly. So that's why I'm saying this is a programmable staking layer. So in some sense, essentially. So in Ethereum, many of you may know that there are many different slashing conditions. One for, if you sign a casper block with certain conditions, or some other, like, there are several conditions for slashing. If you participate in a sync committee and then you produce the wrong thing, you could get slashed and so on. So there is already, like, overlaying of many different slashing conditions inside the Ethereum protocol.
00:21:40.510 - 00:22:21.850, Speaker B: But what this does is makes it completely programmatic for people to opt into new families of slashing conditions, and that's how the trust is potentially transferred. And in terms of the interaction with Ethereum, Ethereum is kind of like the primary source, because if you get slashed in Ethereum, like Eigen layer has nothing more to get slashed. So it is always a secondary on the slashing path. So Ethereum is the primary and Eigen layer is a secondary holder of your, let's say, slashing position. So always Ethereum will have the kind of first depths at slashing, and only if you have anything to be withdrawn.
00:22:22.010 - 00:22:23.810, Speaker C: Eigen layer can slash you further.
00:22:25.270 - 00:22:34.360, Speaker D: But that means that you're bridging your stake, so you have less stake on Ethereum to participate in the trust mechanism, right?
00:22:36.010 - 00:23:23.300, Speaker B: It is not clear whether it actually means that you have less stake because your eth is still controlled on Ethereum. So when you burn the 32 e, your 32 e is burnt at Ethereum, not at like egg layer, right? In some fundamental sense, till the Ethereum protocol relinquishes control and sends it back to the withdrawal. Like Ethereum is holding custody of your 32 e only when it comes to the withdrawal, which means Ethereum protocol has cleared you of any misdoings or whatever. Only then the 32 e comes to Eigen layer and only then any additional flashing can be enforced. So it is in the case when somebody misbehaves on both Ethereum and Eigen layer, they will lose their eth in Ethereum, and Eigenve will have nothing to slash them.
00:23:26.330 - 00:23:46.406, Speaker A: A Lekki asked a few questions in chat, but I think the first one is essentially do you allow dual or multi staking? So rather than just Ethereum, some random other token as well. So could I have USDC as a staking token with Eigen layer?
00:23:46.598 - 00:24:38.342, Speaker B: That's right. So the core mechanics is you can basically, so let me just step back and say what our core design principle is. Our core design principle is we want to push subjective decisions to the edges. In our marketplace, the edges are takers are one edge because they're agents, they have agency and control. Eigen layer wants to be just a protocol, and the ideal outcome for Eigen layer is eventually it becomes part of the Ethereum protocol or Ethereum upgrades to have some aspect of this kind of programmable slashing incorporated. But our vision is to make this protocol as less subjective at our layer as possible. So I mentioned earlier that we have native restaking and liquid restaking.
00:24:38.342 - 00:25:03.394, Speaker B: What is liquid restaking? Liquid restaking is you can take a liquid staking token from any liquid staking protocol and then deposit it. Then you can ask, what is special about a liquid staking token? There's really nothing special about a liquid staking token. You can actually take any token, any ERC 20 token, and then deposit it. So that is the thing. But it's up to the service. Some service may say, oh, I hate USDC. That's no good.
00:25:03.394 - 00:25:41.200, Speaker B: That's a centralized party controlling it. And I don't want to respect anybody restaking USDC or staking USDC as a valid staker. So that's part of the registration condition of the service. So we just push that subjectivity out to the service. Of course, in our own services, we are building one service ourselves. In our own service, we only want to use the ETH restaked either natively or using liquid staking because we think this has a lot of shared security benefits. But other people can do whatever they want on top of.
00:25:41.650 - 00:25:51.220, Speaker A: Okay, yeah. And then they'd have to work out, say, if they were accepting ETH, and, I don't know, matic, say, they'd have to work out the relative value.
00:25:52.390 - 00:26:17.242, Speaker B: Each service needs to specify whether they are baiting them by price or some other relative value. Or they say that ETH quorum is a separate quorum. Matic quorum is a separate quorum. I need to get a certificate from the Matic quorum separately. I need to get a certificate from the ETH quorum separately. I need both the certificates in order for a block to be valid. There's just a lot of design parameters around how you can kind of take two different quorums and work with it.
00:26:17.242 - 00:26:46.950, Speaker B: Having like a bridge price mechanism is one way, but you don't necessarily need it in all the ways. You could have other complex configurations. You could say one quorum is doing one aspect, like, for example, the Matic quorum is doing the ordering of transactions because that's subjective and stuff. And then the ETH quorum is only certifying the validity. You could split the modules in various ways. There are just like various ways to slice and dice it. And our platform is entirely flexible across all of these modalities.
00:26:47.450 - 00:27:09.850, Speaker A: Yeah, okay, that's super interesting. I'll go through Leki's other question right now. You know, withdrawal credential could be changed anytime. Then how could you ensure it points to Eigen layer and not reverting back? Is it through slashing?
00:27:11.550 - 00:27:26.526, Speaker B: Well, the withdrawal credentials, one step cannot be changed. It's like a sacrosanct thing as far as I understand. Basically, when you stake on Ethereum, you set the withdrawal credential. Really, the only way, as far as I know how to change the withdrawal.
00:27:26.558 - 00:27:28.594, Speaker C: Credential is you have to exit your.
00:27:28.632 - 00:28:16.274, Speaker B: Validated position and then stake again. There was a one time opportunity to change the withdrawal credential for those who stake very early on using what were BLS withdrawal credentials called? Zero. The credentials begin with Zero x, they had a one time option with the Shanghai chapel upgrade to go change it, but only once. And they move from like a BLS key to a particular execution address. I think withdrawal credential portability is an important topic and is something we discuss definitely with the broader Ethereum community. And there are certain scenarios where it makes sense to allow withdrawal credentials to be changed, but I don't think that's part of the current specifications at all.
00:28:16.312 - 00:28:29.750, Speaker A: Yeah, okay. And there's one question from Julius, which I think he might have answered already, but how does Eigen layer slashing work? Does it happen only at the point of slasher exit?
00:28:30.170 - 00:29:01.460, Speaker B: Yes, it only happens at the point of exiting when you withdraw from Ethereum. So this again relates to a core way in which the Ethereum beacon chain works. Right now, to trigger the exit from a staking position on Ethereum core, you need to trigger it using the validator public key. That's how you trigger exits on the Ethereum beacon chain on Eigen layer. The way that it works is.
00:29:06.390 - 00:29:06.706, Speaker C: The.
00:29:06.728 - 00:29:09.758, Speaker B: Slashing can only happen when you trigger the exit.
00:29:09.934 - 00:29:11.266, Speaker C: So there is no way for us.
00:29:11.288 - 00:29:48.206, Speaker B: To slash native restaking when you don't exit your position to core host the validity. On the other side, though, there is upcoming proposals for what are called contract triggered withdrawals. So whoever holds the withdrawal credential, even if it's an execution layer contract, can send a command saying I want to eject the validator and that forces the validator to be ejected. This is helpful in a variety of liquid staking and other scenarios. It is in the roadmap. We don't know when it will hit like the main net, but I think that is something we are very interested.
00:29:48.308 - 00:29:49.600, Speaker C: In, is.
00:29:53.350 - 00:30:07.320, Speaker B: Whenever there is a valid withdrawal smart contract triggered withdrawals, we can actually make our system much better by. Yeah, by enabling the.
00:30:12.170 - 00:30:13.318, Speaker C: By enabling the.
00:30:13.324 - 00:30:23.014, Speaker B: Ethereum, the eigen layer contract to go and trigger the withdrawal. If you got slashed in Eigen layer, you can just go and automatically trigger it from Ethereum.
00:30:23.142 - 00:30:24.234, Speaker C: That sounds good.
00:30:24.352 - 00:30:53.538, Speaker A: So I have one question that I just thought about. So say I've done stuff and I've had 32 eth worth of slashing in Eigen layer, but the money is still in Ethereum and I've been all good. I've sort of got nothing at stake on Ethereum now. Am I now going to act maliciously on Ethereum, or do I have the nothing stake problem? Kind of, yes.
00:30:53.624 - 00:31:34.514, Speaker B: So there is a nothing at stake problem there where if you've already lost all your stake on Eigen layer, then there's no reason for you to continue doing your Ethereum duties, probably. So one way we deal with it is the first thing is this is only true till we have smart contract triggered withdrawals. Because if you have smart contract triggered withdrawals, as soon as you're underwater even, you don't have to go to zero eth. Even when you go from 32 eth to some number 20 eth or something, we just force eject your validator for you. Right. But that functionality is not available today. So what we do instead is to actually rely on the other thing, which.
00:31:34.552 - 00:31:35.140, Speaker C: Is.
00:31:38.790 - 00:31:52.786, Speaker B: We don't slash 32 e, we only slash till 16 e on the Eigen layer contract. So there's always something at stake. If you don't want to lose both 16 e, you'd better behave on Ethereum.
00:31:52.978 - 00:32:08.010, Speaker A: Yeah, that makes sense. That makes sense. So we've got sort of three more questions. I'm just wondering whether we should continue with the talk or do the three more questions now. What would you prefer?
00:32:08.510 - 00:32:13.742, Speaker B: Let's continue with the talk and then I'll come back to the questions. I think we'll have plenty of time at the end.
00:32:13.876 - 00:32:14.960, Speaker C: Sounds good.
00:32:15.970 - 00:32:30.130, Speaker B: Thank you so much, Peter and Frank, for the questions. Okay, so what happens when you have a universal marketplace for decentralized trust is now you have the common framework on Ethereum.
00:32:30.630 - 00:32:35.334, Speaker C: Now basically eigenvear is essentially sitting at.
00:32:35.372 - 00:33:07.134, Speaker B: The root of trust, which is close to the staking, and then it lets you supply it flexibly to any other services that can be built on top. So instead of the Ethereum stake only securing the Ethereum governance protocol and virtual machine and so on, you could actually now serve. Somebody wants to experiment with a new consensus protocol, a new virtual machine, a new kind of like a data storage protocol, any of these things, you can actually use a common framework to do.
00:33:07.172 - 00:33:08.240, Speaker C: All of these things.
00:33:08.610 - 00:33:20.690, Speaker B: So we permit more innovation for distributed systems builders to come and do on all these different layers, rather than only at the smart contract programming layer.
00:33:21.190 - 00:33:25.300, Speaker C: Okay, so that's the.
00:33:28.090 - 00:33:32.742, Speaker B: That'S the high level about the protocol. So what I will do is now.
00:33:32.796 - 00:33:36.378, Speaker C: Switch and talk about what are some.
00:33:36.384 - 00:34:28.662, Speaker B: Of the interesting things we can build inside the system. Give me 1 second, I'll switch to a different slide. All right, here we go. Okay, so we all know Ethereum's like roadmap is primarily a modular, layered roadmap. So what it means is we build systems like roll ups, where roll ups do off chain execution. They move the execution off chain and then just verify on Ethereum that they did the right thing off chain. So the advantages of a modular roadmap.
00:34:28.726 - 00:34:31.646, Speaker C: Is you don't have any kind of.
00:34:31.668 - 00:35:01.974, Speaker B: Computation and memory footprint of your off chain computation on the Ethereum network, because you've moved all of it off chain and just submitting proofs, whether it is cryptographic or some kind of an interactive fraud proof. These systems inherit the safety and liveness, basically security from Ethereum. So these are great advantages, and it allows for a lot of execution and computation scaling. But there are still several limitations in.
00:35:02.012 - 00:35:06.694, Speaker C: This system, the data bandwidth that is available.
00:35:06.812 - 00:35:36.562, Speaker B: So whenever you move computation off chain, there is either inputs to the computation or outputs of the computation that you want to publish. Why do you want to publish it? You want to publish it so that other people can verify your computation. You want to publish it so that other people can continue doing your computation after you're gone. So they're not trusting you. So for all of these things, you need to publish the data on Ethereum. So today the data bandwidth of Ethereum is somewhat low. So you only have 83 data.
00:35:36.562 - 00:35:39.986, Speaker B: So if you use the entire Ethereum blockchain only for writing data but not.
00:35:40.008 - 00:35:48.566, Speaker C: For anything else, still the data bandwidth you get is only 83.
00:35:48.588 - 00:36:43.510, Speaker B: Other limitation in the existing system is when you want to finalize that a roll up has returned data to Ethereum. That finality time is actually you have to wait for Ethereum to finalize. And Ethereum's finalization time is like two epochs, which is like twelve minutes. So the finalization time is slow. And what we're seeing is some new protocols coming up which are saying that they can get finality in like 1 second or whatever, even faster. So how does the Ethereum roll up landscape compete favorably with these kind of new protocols? The other aspect that we see is we rely on centralized sequencers. Like each of the roll up has a node called a sequencer which aggregates all the transactions and then makes a computational proof that the transactions are correct.
00:36:43.510 - 00:37:01.950, Speaker B: But this is a single point failure mode as well as if you want to, it can engage in censorship and other things in the short timescale, even though at a slow enough timescale there are ways for a roll up to read data from Ethereum and force include a transaction.
00:37:02.930 - 00:37:04.080, Speaker C: Okay, so.
00:37:06.450 - 00:37:50.830, Speaker B: As we see the landscape, we not only have Ethereum, but also have these other chains. We need to be able to build very high quality bridges to these other chains. And MeV management is of course a major topic. MeV is this concept that arises called maximal extractable value arises because takers who are participating in Ethereum have a degree of freedom in deciding transaction inclusion, and that leads to certain kinds of freedom for them. And they may be able to profit off of that freedom by saying, I'm going to let your transaction in, not that other guy's transaction, and I'm going to order them differently. All of these kind of things, this is called MEP, and we want to manage this carefully.
00:37:51.490 - 00:37:54.426, Speaker C: Okay, so here's a vision.
00:37:54.618 - 00:38:17.640, Speaker B: It's not anywhere near realized, but our vision is basically, we can take any one of these limitations and build a layer on top of Ethereum and just narrowly address that limitation. And you can build this kind of like a composite where different innovations, some group of people just work on figuring out how to do the best.
00:38:20.650 - 00:38:20.966, Speaker C: How.
00:38:20.988 - 00:38:55.986, Speaker B: To scale Ethereum's data bandwidth. And maybe there are many, many teams that come up with this competitive model where they all build different data layers, and all of them relying on a similar set of validators and stake as Ethereum. So you can actually have many teams try to build a data availability layer, and we can see which ones are the best. You can build like finality layers where you have enough economic stake and you.
00:38:56.008 - 00:39:00.226, Speaker C: Can be sure that something that is.
00:39:00.248 - 00:39:05.666, Speaker B: Sent there will not be reverted. Or you know that if they get reverted, some people are going to lose.
00:39:05.698 - 00:39:06.600, Speaker C: A lot of money.
00:39:07.530 - 00:39:17.370, Speaker B: You can build like a sequencing layer, where it's a common layer for decentralized sequencing, just a layer that orders transactions, not for one roll up, but across.
00:39:17.440 - 00:39:18.890, Speaker C: Many, many roll ups.
00:39:19.550 - 00:39:51.150, Speaker B: You can build bridges on top of like Eigen layer, which actually address some of these issues. And finally, you can also build kind of mev management. So this is our vision. Like basically take up any issue that is happening on Ethereum, go and let the builders in the market come up with solutions which compete with each other, and then some of the best solutions then get internalized back into Ethereum as part of the core protocol upgrade or something like that over a longer scale.
00:39:51.310 - 00:39:54.502, Speaker C: So essentially, Eigen layer enables this new.
00:39:54.556 - 00:40:33.540, Speaker B: Suite of solutions to be built on top. The way we think about it is just like the EIP process lets people come up with new ideas, and then we debate and figure out which ones go into the protocol. This is a more permissionless version where people deploy protocols. Only a small fraction of the stakers opt in, the small fraction of users opt in. And as the protocol develops, there may be other protocols. They compete with each other, some protocols clearly much better than the others, and those get more adoption and they get bettered and battle tested over several years. And some of those best protocols can then either inspire or inform the Ethereum roadmap itself.
00:40:33.540 - 00:41:07.900, Speaker B: That's kind of our broader project. Okay, so the one system we are building ourselves is the data availability system. I pointed out that the Ethereum data availability is not that high. 83. There is a roadmap in Ethereum, of course, to upgrade it significantly from 83, like 1.3 megabytes per second. This may be like a couple of years out.
00:41:07.900 - 00:41:54.874, Speaker B: This system is called donk sharding, which basically increases the data bandwidth significantly of Ethereum. The main thing to note here, I'll skip several of the other dimensions, is what we did, is we took Dong sharding, exact same cryptography and the fundamental architecture of Dongsharding, and then tried to innovate on engineering architectures around it. In terms of how data is distributed, in terms of how different nodes arrive at consensus, what data goes through the peer to peer network, what data doesn't go through the peer to peer network. All of these dimensions, which, when you're engineering these protocols, very important in terms.
00:41:54.912 - 00:41:58.618, Speaker C: Of how efficient it is and being.
00:41:58.704 - 00:42:50.778, Speaker B: Kind of like an opt in layer. I canda has some freedoms that core protocols don't have several decisions interlock with each other in a core protocol upgrade, whereas an opt in layer can make several decisions which are kind of specific to that layer. And we can actually push the throughput quite a bit like our system throughput that we can run eigenda at is at ten megabytes per second. And we can do this while requiring each node to actually do very little, as little as each node's node requirements. A node requirement in Ethereum is like, roughly, you need two megabytes per second, whereas on InDa, we only need each node to have like 0.2 megabytes per second. So it's a very low requirement relative to what you need to run an Ethereum node.
00:42:50.778 - 00:43:07.602, Speaker B: So that's a core protocol. And the way it works is fundamentally by using erasure codes, where, like a sequencer, when they're committing data to IGDA, they're basically writing split the data, erasure code.
00:43:07.656 - 00:43:08.258, Speaker C: It.
00:43:08.424 - 00:43:53.810, Speaker B: No node in the system downloads all the data. Every node downloads only, like, a sample of the data. But together, they have enough samples that even if a majority of the nodes go offline or malicious, you can still recover all the data. So that is roughly the core architecture of eigenda. There's a lot of details about that which I'll not be able to get into, but essentially we think of it as an opt in layer for data availability that roll ups, which cannot pay the high fees of writing data to Ethereum, can use while still being kind of adjacent to Ethereum. So eigenda is not a new chain, it only does data attestation. So you can think of it as like a data attestation layer.
00:43:53.810 - 00:44:33.962, Speaker B: One of the things that happens with something like Eigen layer is now everybody building a new distributed system can build like very simple primitives. They don't have to build everything because of course, that's the point of modularity is each person kind of builds a specific module, does it really well. And then now you put in all these modules together and then you get very good performance. So I canda doesn't arrive at consensus, doesn't do a lot of things that a normal protocol has to do because it's tethered to Ethereum. Ethereum does the consensus. We just have these nodes send a data availability attestation. You collect enough of it, you aggregate a signature, put it on Ethereum.
00:44:33.962 - 00:44:39.934, Speaker B: On Ethereum, you just have the hash or a KCG commitment of the data and a signature that the data has.
00:44:39.972 - 00:44:42.958, Speaker C: Been stored from all the eigenda nodes.
00:44:42.974 - 00:45:24.880, Speaker B: And that's enough for the roll up to make progress. This is one example of a service that can be built on top of eigen layer that is very valuable to the Ethereum ecosystem as complementarities to what is being built. When you imagine a universe where we have things like on chain games, we have things like complex social networks running on dollar Ethereum, one megabytes per second is not enough. So we need more. And we believe some of the good ideas in the system, if it works well and everything have to be then internalized back to Ethereum so that you get the full trust model.
00:45:26.690 - 00:45:27.440, Speaker C: Okay.
00:45:33.170 - 00:46:11.246, Speaker B: There is a question. I think it's particularly relevant to eigendia. So maybe I'll just answer that here. What are the slashing conditions in Eigen? This is a really good question, because one of the things with data availability is how do you know that nodes are not storing data? And for this we again rely on the roadmap of danksharding. And there is a particular incentive mechanism in Danksharding called proof of custody. I think Justin Drake and Dankradface came up with different aspects of this. And the core idea of proof of.
00:46:11.268 - 00:46:15.422, Speaker C: Custody is it's a mechanism to check.
00:46:15.476 - 00:47:23.010, Speaker B: That the nodes are custodying the data. And the simplest way to explain it is every time you get a new data item, as an eigenda node. What you need to do is you need to check the hash of the data that you're storing, all the data that you're storing and your own, like some private information. And you take the hash of all these things. And if the hash of all these things is in a certain range, it's between zero and some threshold, then you have to raise your hand up and say, hey, this is called a bomb. Like bomb is basically when the hash of the data items that you're storing and your private randomness is less than some threshold, then you raise your hand and say you got bombed. And if you don't do it, if you don't raise your hand up and say that you got bombed, then you didn't even store the data called the lazy validator problem.
00:47:23.010 - 00:47:52.478, Speaker B: What if you go subscribing to new and new services on Eigen layer and then don't do anything? That's a real worry. So we want to make sure that all the nodes do something. And here what it does is basically enforces that nodes are storing the data and then doing this check. Because if you don't do this check, then you won't raise up your hand and say, I got bound. And if you didn't say that, then you could get slashed. So that's roughly the mechanism. There's a lot more details to it.
00:47:52.478 - 00:47:55.614, Speaker B: This is called, I'll just type it here for those of you who are.
00:47:55.652 - 00:48:01.120, Speaker C: Interested, called proof of custody by Justin Rake. And.
00:48:09.320 - 00:48:13.990, Speaker B: Okay, so you'll find good material on that on ethereum research.
00:48:16.280 - 00:48:19.190, Speaker C: Okay, moving on.
00:48:21.900 - 00:49:06.096, Speaker B: Okay, you can use Eigen layer for things like decentralized sequencing, where you take a bunch of transactions. There's a group of eigen layer nodes which are opted in, and then they order transactions across for many, many roll ups, and then they supply it back to the roll up. And one of the nice things here is, if you think of a roll up, roll up nodes, if you think of what the roll up sequencing nodes role is, it's doing two different things. One is it's ordering transactions, and then it's executing the transaction. The thing is, ordering transaction is a stateless operation, just order transactions. But executing transaction is a stateful operation, which means you need to know the state of the roll up. In order to execute the transaction.
00:49:06.096 - 00:49:38.864, Speaker B: You need to hold the state in memory. And there's a major problem when you hold the state in memory, you have this issue called state growth and so on. So part of the reason why we are offloading, creating the concept of roll up is that we are offloading all the execution. But what a decentralized sequencing network can do is it can just do one thing, which is ordering of transactions. You just order the transactions across all these different awards. And that's all it does. It doesn't understand the semantics of what these transactions mean.
00:49:38.864 - 00:49:56.464, Speaker B: That's up to the roll up executioner to do. The reason that this split works very well is ordering the transaction is the contentious part. Contentious because it's non verifiable. If you ordered all the transactions or you censored some transaction is nonverifiable. It's best to use a decentralized network.
00:49:56.512 - 00:50:00.896, Speaker C: For it, whereas execution is deterministic.
00:50:00.928 - 00:50:22.590, Speaker B: It's just like if you have a bunch of code, you run through the EVM, you get the same output every time. So execution can be offloaded to the roll up nodes, whereas you just get a decentralized group of nodes, as decentralized as possible to order transactions. That's a sequencing service. We have a lot of teams interested in building this that we are working with.
00:50:24.960 - 00:50:33.376, Speaker C: Okay, so the same idea can be.
00:50:33.398 - 00:51:18.896, Speaker B: Used for, for example, you know, I'm a roll up. I want to get a fast finality or a fast confirmation, but I normally what happens in a roll up is a roll up basically writes it stores the data in a data availability layer, it makes a state claim and then sends it to Ethereum. And once it's ordered on Ethereum, you know that that transaction is going to be in. So as long as you have a off chain verifier, off chain node, which can download and run that data, you get a pretty strong notion of finality. But to do this, you need Ethereum to finalize. So that's the thing that I said is twelve minutes. Let's say you want to reduce it.
00:51:18.896 - 00:51:33.188, Speaker B: What we are seeing a lot of roll ups doing is every roll up is coming up with their own mechanism to restrict, to provide fast finality. So instead what we could do is.
00:51:33.274 - 00:51:36.020, Speaker C: You have a common layer onto which.
00:51:36.090 - 00:51:58.110, Speaker B: Roll ups write state settlement claims. And this layer runs like a fast consensus protocol and produces blocks with finality at 1 second or 2 seconds or whatever the interest is. And what you can do is now this layer writes data to Ethereum in this order. If this layer does like.
00:51:59.840 - 00:52:00.844, Speaker C: Porking or.
00:52:00.882 - 00:52:21.460, Speaker B: Whatever, then the consensus nodes in this layer are attributable and they can be slashed on eigen layer. Basically they'll lose their eth on eagle layer if they behave badly. The same thing, actually similar thing holds in sequencing is if you said that. Or TX one, TX two, TX three. These three transactions is my sequence, but later say, no, it's actually TX three, TX two, TX one.
00:52:21.610 - 00:52:23.248, Speaker C: Then you could get slashed because you're.
00:52:23.264 - 00:52:44.760, Speaker B: Saying two different things, which is objectively attributable. That you should only say one thing that then you are censoring or not is not attributable. So we cannot slash for it. So one of the principles underneath eigen layer slashing is we only slash for attributable false. Fully on chain attributable false, not for non attributable false.
00:52:45.440 - 00:52:48.072, Speaker C: Okay, so finally, bridges.
00:52:48.136 - 00:53:34.696, Speaker B: Like, let's say you want to move data from some other chain to Ethereum. The one way you can do it in cosmos this happens a lot, is you run a light client of the other chain and then use that to move the state across these different chains. But let's say on Ethereum, you want to go run a light client for a cosmos hub or some other protocol, then that is very expensive on chain, because you have to now write the light client in EVM on Ethereum and execute it. Pretty expensive stuff. But you can very easily do this off chain. Like off chain, I run a light client, and on Ethereum, I just make a claim that I've run the light client and this is my state. Somebody wants to contest it, they can contest it, and then they will check that on Ethereum.
00:53:34.808 - 00:53:38.780, Speaker C: So this is a super powerful architecture bridging.
00:53:39.360 - 00:53:59.860, Speaker B: This is something I think we are quite excited about as a possible application. Okay, finally, MEV management. So MEV management is again like one of those super fundamental things. So on Ethereum, layer one, the block proposers have a lot of freedom in how to order transactions.
00:54:00.200 - 00:54:05.264, Speaker C: And now what happens is the nodes.
00:54:05.312 - 00:54:31.644, Speaker B: Can then sell the block space or do whatever they want with it. So this leads to this concept of MEV, which is sometimes not favorable to the users. So what we think would be interesting is if the block proposers can make credible commitments on how they order transactions. Let me just give you an example. Suppose you have two decentralized exchanges on.
00:54:31.682 - 00:54:36.556, Speaker C: Ethereum, Uniswap and sushiswap, and there's some.
00:54:36.578 - 00:55:00.640, Speaker B: Kind of like a price difference between these two, Uniswap and Soshiswap. Then what you could do is you could say that whenever I'm proposing a block, the first transaction I go and find if there is a price difference between Ethereum and Uniswap and sushiswap, and then go and equalize that price. This is called an arbitrage and you can equalize that price and then basically earn some money for doing it.
00:55:00.810 - 00:55:02.808, Speaker C: So when you have this kind of.
00:55:02.814 - 00:55:58.856, Speaker B: An arbitrage, let's say block proposers on Ethereum opt into this particular service and then say that whenever there is such an event happens, I will actually go and trigger this like rebalancing transaction, and they make a commitment that they will include it. So you can think of this as an event triggered transaction that you can build on top of eigen layer. And if you didn't do this, it is attributable that the block proposer should have done this, but didn't do it. So this lets block proposers make credible commitments for a variety of ordering rules you restake and then basically make credible commitments of various kinds of rules. This is one example. You can do partial block auctions. You can commit that whenever somebody sends you an encrypted transaction, you sign off on it and say that I promise to include the decrypted transaction in my.
00:55:58.878 - 00:56:00.344, Speaker C: Block, and so on.
00:56:00.382 - 00:56:08.584, Speaker B: So there's a kind of broad range of commitments that you can make when you're ordering transactions. And I think this is something that's.
00:56:08.632 - 00:56:12.104, Speaker C: Quite interesting in an angle.
00:56:12.232 - 00:57:35.706, Speaker B: Okay, so I'll stop with this, but I think the vision that I want to present here is, let me go here. So we look at all the limitations of ethereum that exist. Basically, I'm listing anything as a limitation which other chains are using to say that, hey, this is my distinguishing technical feature. What you could do is basically go and build, specifically have permissionless innovation and competition for many, many teams coming and building these interesting features. You could have a world where roll ups have a much stronger, much lower finality time, much higher data bandwidth, proper decentralized sequencing, very high quality lightline bridges, modular MEV management. All of these can kind of be, some of the most important services can be run on all kinds of nodes around the ethereum network, and some of them can be designed with very low operating costs. So the final point, which I think is kind of interesting here, is that any significant technological improvements, instead of going and happening on a new layer, layer one, can all happen inside the Ethereum ecosystem, where the same stake is used to secure these services.
00:57:35.706 - 00:57:52.240, Speaker B: And as these services mature and become useful, they can be internalized back into the core protocol, pretty similar to the layer two roadmap, but just expanding it beyond just proving execution claims. So I think I'll stop with that and look forward to taking questions.
00:57:56.430 - 00:57:58.460, Speaker A: Thank you for a great talk.
00:58:00.030 - 00:58:00.780, Speaker C: Yeah.
00:58:04.370 - 00:58:26.200, Speaker A: I think the questions may have been answered. But let's see. So there was, in, in the chat there, there was assume you have 32 eth of stake. Can you restake the 32 e for multiple services at the time, at the same time? Or does the sum amount staked for each service need to be less than 32 e?
00:58:28.170 - 00:58:28.920, Speaker C: Yeah.
00:58:32.730 - 00:58:35.880, Speaker B: So the answer to that is.
00:58:37.790 - 00:58:38.106, Speaker C: How.
00:58:38.128 - 00:59:03.140, Speaker B: Do we decide that? Can you restake the 32 e across multiple services? Once you make a credible commitment into eigen layer, you can opt into any number of services. Okay, so in terms of the security model that each of the services are getting, there are two kinds of security models. The first model is a shared security model. In a shared security model.
00:59:05.190 - 00:59:05.698, Speaker C: When a.
00:59:05.704 - 00:59:51.280, Speaker B: Bunch of stakers are opting into many services and they misbehave across many services, then all the guarantee that you have is their ETH is going to get slashed. You do not have any attributability to the particular service saying, oh, this much stake is slashed for you. They just got slashed, they just lost their ETH. Right? ETH is burnt. But there is another dimension of security we call attributable security. By the way, Ethereum operates in this model. Suppose you are running Uniswap, and many people lost money in Uniswap because of a consensus failure on Ethereum and because of a consensus attack where nodes attack the block production and produce two competing blocks, or whatever.
00:59:51.280 - 01:00:05.460, Speaker B: Now, Uniswap doesn't particularly get that Ethereum, or OpenSea or somebody else doesn't particularly get that Ethereum. That Ethereum is just burned. There's no attributable security to a particular application.
01:00:06.230 - 01:00:08.094, Speaker C: It's just shared security.
01:00:08.152 - 01:00:53.686, Speaker B: It's a common pool of security that powers everything. So that's the Ethereum model. But I think one thing we're very excited about is proposing a change to both the Ethereum model, but also particularly implementing it in the Eigen layer is attributable security. Attributable security is, if you have, let's say, just to give some simple numbers, $10 billion of stake, and then there are ten services, and so there's totally 10 billion slashable. And what you could do is different services, and let's say all of them, restake on everything, the $10 billion restaked on everything on these ten services. Now, the shad security says that if any service fails, then 10 billion worth of ETH, or some fraction of the 10 billion worth of wheat will get slashed because you're going to attribute it.
01:00:53.708 - 01:00:54.838, Speaker C: And then slash them.
01:00:55.004 - 01:01:27.962, Speaker B: But what the attributable security says is my particular service will be able to slash and redistribute it. Redistribute it is the important word. That's the new thing. And of course, you can't redistribute every service. We cannot give the guarantee that they can redistribute the entire 10 billion. Then that's an over promise that we cannot keep to when stakers misbehave across all the services, then we will not be able to keep that bargain. So the way we do it is we sell insurance bonds against slashing.
01:01:27.962 - 01:02:01.690, Speaker B: So this is inside the protocol. So there's $10 billion of stake. So we know that all the services together cannot buy more than $10 billion of insurance slashing insurance bond. And each service pays a premium, like there's a bidding market and all that. And then you sell the insurance bond and some service may be like uniswap, and they say, I want $5 billion worth of security. So they go and buy that $5 billion out from Eigen layer, which means now they have. Whenever slashing happens, we guarantee that that service will be able to get $5 billion of attributable security.
01:02:01.690 - 01:02:06.586, Speaker B: There's shad security and attributable security. Right now, Eigen layer and Ethereum are.
01:02:06.608 - 01:02:10.334, Speaker C: Both on the shared security model, but.
01:02:10.372 - 01:02:47.710, Speaker B: I think the insured attributable security is a much more interesting model, both for Ethereum and for Eigen layer, actually. Anyway, so that's the answer to that question of whether you are restaking to many services. And here I want to say that Eigen layer is a validation platform. It's not a DeFi platform. It is not for using the withdrawal credential to lend or borrow or any of these things. It is purely for validation services. You go and build a service, because there is a fundamental difference between the kind of leverage we think about when you're validating versus any other kind of DeFi or financial primitives.
01:02:47.710 - 01:03:09.306, Speaker B: Validation is endogenous. The risk is endogenous if you know you are running a correct validator. If you trust the protocols or you bettered the protocol code, then you know that you will not get slashed. If you don't do run malicious code, it's a very, very strong guarantee. So you can run hundreds of services and promise all of them that you're.
01:03:09.338 - 01:03:11.440, Speaker C: Doing the right thing. But.
01:03:13.330 - 01:03:29.494, Speaker B: If you're doing lending or borrowing or leverage or any of these things, you go and take a ten x leverage or 100 x leverage on a market. Even if one of the service fails, even if the market price moves by 1%, then you lose all your money.
01:03:29.612 - 01:03:30.230, Speaker C: Right?
01:03:30.380 - 01:03:47.610, Speaker B: So the market price of ETH or any other asset is not under your control. Whether you're running your validator node in a malicious manner or not, is under your control. So there is a fundamental difference between validation and other kinds of d five primitives, and we are only focusing on validation.
01:03:50.130 - 01:03:51.600, Speaker A: Yeah, makes sense.
01:03:55.330 - 01:03:56.080, Speaker C: Yeah.
01:03:56.930 - 01:04:09.778, Speaker A: I think there's the one that does the Eigen layer, decentralized sequencer, tackle the mev problem, or it introduces it, since its sequencing is decentralized now.
01:04:09.944 - 01:04:48.142, Speaker B: Oh, this is such a great question. I don't think it solves the meV. So just to make it clear, we are not building all these services that I pointed out, it's just illustration of what could be built, and it's up to the specification of each service to make sure that how they're handling each of these things that arise in that service. Since we are not building it, there is no concrete answer to it, but we do have partners that are building these kinds of services, and they are thinking about working with flashbots and other teams to basically tackle their maybe problem.
01:04:48.196 - 01:04:50.574, Speaker C: Just like Ethereum itself tackles it.
01:04:50.772 - 01:05:15.190, Speaker A: Yeah, makes sense, makes sense. And there was from Harith Hey Sriram, saw Vitalik's post and your thread in response. How will the protocol decide what use cases are allowed for restaking and what aren't? Or how do you tell which ones may corrupt consensus?
01:05:15.610 - 01:06:06.158, Speaker B: Oh, that's a great question. Very timely. Just for context to the others, Vitalik wrote a post two days back, I think Sunday on a topic I think he called it do not overload Ethereum consensus. That was the title of the post, and I think the title was somewhat misleading. The whole article was basically do not overload Ethereum social consensus. That is the kind of point of the article is basically that when you go build something on top of Ethereum, build it so that it doesn't externalize any kind of untoward risk on Ethereum. And particularly, I think what the article is alluding to is don't go build something on Ethereum.
01:06:06.274 - 01:06:09.786, Speaker C: So that with the assumption that if.
01:06:09.808 - 01:06:48.962, Speaker B: Your thing fails, Ethereum is going to hard fork around your failed thing. I think it's such a bad principle to build systems like that. I think it is true for applications built on top. It is true for roll ups built on top. It is true for systems like Eigen layer built on top of ethereum. Because we're all sharing this commons and it's kind of important to make sure that what's the bar one way, I think my best summary of it is kind of like banks go and take excess risk and then they know that they're big and therefore the government has to bail them out. This encourages excessive risk taking and bad behavior.
01:06:48.962 - 01:06:57.160, Speaker B: Because if you take risk and you lose money, that's one thing. If you take risk, and then now everybody has to come and bail you out, that's really.
01:06:59.530 - 01:07:00.230, Speaker C: Yes.
01:07:00.380 - 01:07:30.110, Speaker B: So Peter is saying, no protocol would assume. But I think the point is no protocol should assume, and we don't. Nobody. Nobody should. But I think the question here has some interesting component. It's from Harit. It says, how do you tell which ones make corrupt consensus? I think the article, Vitalik's article already alludes to examples and shows the separating principle, I think, in my view, which we have already adopted over the last, like 16 months after talking to EF.
01:07:30.110 - 01:07:39.762, Speaker B: We had a discussion with the EF researchers in last April, Dunkrad in particular, and he gave us exactly the same principle that we've already kind of internalized.
01:07:39.826 - 01:07:42.038, Speaker C: Which is that when you have a.
01:07:42.044 - 01:08:16.526, Speaker B: Slashing condition, make it objective and attributable. It's a slashing condition. It's written in code. It's something like concrete. There is no vague thing. Like the examples that you see Vitalik give in the article are things like, you have a slashing condition for, you slash an oracle input provider for providing ETH to USD price input if they differ from a majority of the others. If you do things like this, then what if a majority was dishonest and the minority was honest, and the minority will get slashed based on the majority input.
01:08:16.526 - 01:08:27.750, Speaker B: So there are all these essentially tick to objective slashing conditions. Okay, so the slashing conditions are objective. So that's one of our principles. But when we do that, there's another.
01:08:27.820 - 01:08:31.270, Speaker C: Problem, which is a problem all dapps have to face.
01:08:31.420 - 01:08:39.258, Speaker B: The problem is, what if the conditions encoded in the contract don't match what you understand the conditions to be?
01:08:39.344 - 01:08:39.594, Speaker C: Right?
01:08:39.632 - 01:09:10.158, Speaker B: There's a programming bug. There's an underflow. There's an overflow. There is a reentry in, say, attack, like we know, like all the attacks in a smart contract platform. So the way we do this is have double buffer. Basically, slashing requires both an objective, attributable, smart contract to trigger it. And then there is what we call a slashing veto committee, which is one sided, which can only veto slashings, cannot approve.
01:09:10.158 - 01:09:36.406, Speaker B: No slashings. But there's a slashing veto committee, which is a kind of committee that can veto slashing, which is this is the only subjective part that we put into the protocol. But the way this committee works is there are two tiers of services. Initially we launch with only one tier, but eventually there'll be two tiers of services. One tier of services, anybody can build anything. They're not protected by the slashing veto. Another tier of services is they're onboarded by the slashing veto.
01:09:36.406 - 01:09:50.266, Speaker B: And when they onboard through the slashing veto they're going to do a bunch of checks. And the checks are basically, is the slashing condition attributable or is it relying on things like, which may require majority consensus?
01:09:50.458 - 01:09:53.114, Speaker C: And that's the main thing.
01:09:53.252 - 01:10:50.930, Speaker B: And also, of course, things like is the slashing contracts audited and all of these standard things. But that's how we onboard services and stakers, if they trust this slashing veto, then this veto basically has power to basically onboard new services. And this is very important because if there is a power to onboard services we can guide the ecosystem in the direction which is safe. And of course anybody is welcome to build other services which is not protected by the slashing veto. But for them they have to take the additional step of going and convincing the stakers why they are such a good protocol that they don't have to rely on the slashing veto. And so that increases the bar that segregates into two kinds of services, one which is maybe much more risky and many people may not opt into and another one which is much more vettered and ununderstood. So that's our kind of high level answer to that question.
01:10:51.080 - 01:10:57.650, Speaker A: So for the slashing veto, it sounds like, I assume that's some sort of essentially multi seal.
01:10:59.370 - 01:11:00.310, Speaker C: That's correct.
01:11:00.460 - 01:11:12.220, Speaker B: So it starts with the slashing veto being a particular multi sig which basically comprised of 1015 20 over time larger number of members.
01:11:14.110 - 01:11:17.210, Speaker C: The flashing vetoes.
01:11:18.910 - 01:11:26.026, Speaker B: Is basically like a multisig for the protocol, but over time we're thinking of introducing much richer models.
01:11:26.058 - 01:11:27.450, Speaker C: For the slashing veto.
01:11:27.610 - 01:12:05.820, Speaker B: Just like in Ethereum, like in the mev boost architecture, there is a role of something called a relay, right? And a relay is a doubly trusted party. Like a block proposer trusts a relay and a block builder trusts a relay. We can have slashing committees be doubly trusted parties where anybody can create a new slashing veto committee and only if a staker opts into the slashing veto committee and the service opts into the slashing veto committee, then essentially you'd be able to deal with each other. So that's an example of how we can mediate that.
01:12:06.430 - 01:12:09.260, Speaker C: Okay, Frank has hand up.
01:12:11.810 - 01:12:14.254, Speaker D: Yeah, but there was a question in the chat before.
01:12:14.372 - 01:12:16.106, Speaker B: Maybe from Coco Lee?
01:12:16.138 - 01:12:17.134, Speaker C: I think so.
01:12:17.172 - 01:12:18.430, Speaker D: I don't want to skip.
01:12:20.290 - 01:12:35.110, Speaker A: Yeah, so I think we have Coco Lee. Can you expand more on restakers participating in as lights client for bridges? I don't understand the relationship between restakers and people running the light client.
01:12:36.090 - 01:12:50.838, Speaker B: Okay, so suppose you want to bring some cosmos chain state or just for simplicity, let's say avalanche or something. I want to bring the avalanche state into ethereum. So I want to know what the state root of the reason block on avalanche is on ethereum.
01:12:50.934 - 01:12:52.220, Speaker C: How do we get it?
01:12:52.750 - 01:13:08.094, Speaker B: If restakers run light nodes not of Ethereum but of avalanche on Eigen layer, what they can do is they now are following the blocks of avalanche and then certifying that yes, this is the block header that I know and have.
01:13:08.132 - 01:13:10.346, Speaker C: Received and then post it on ethereum.
01:13:10.458 - 01:13:22.042, Speaker B: What will be the slashing condition? The slashing condition would be that if there'll be an implementation of the avalanche like client on Ethereum contracts which is not run on the normal mode.
01:13:22.186 - 01:13:29.000, Speaker C: But if, if there is.
01:13:31.050 - 01:13:45.420, Speaker B: The thing where somebody contests that the restakers did something wrong, then the light client will be run on chain and then executed. Basically it's the optimistic roller pattern, but applied to much, much broader scope of.
01:13:47.710 - 01:14:05.250, Speaker A: We'Ve done so for those who watch this YouTube channel, often we've done talks on optimistic bridges and their advantages and disadvantages and things that can happen. All right, over to you, Frank.
01:14:05.670 - 01:15:16.950, Speaker D: Yes, coming back to Vitalik's post, for instance, tell me if I'm correct and if I understand it well, when I read it, it looks like the programmable ability conditions, they could be corrupted, they could be buggy and so on. And that could in itself, let's say, undermine the Ethereum consensus protocol. So, disclaimer, I'm a formal verification person, so I think this argument doesn't hold up together because this implicitly means that we have more trust in the smart contracts we write for other D apps compared to the smart contract that you would write for, let's say, slashing conditions. And I don't see why this would be the case if it's a smart contract. And again, if it's runnable, executable on Ethereum, I don't see any argument against doing so. And another thing that I was a bit surprised of was that the situation it describes is basically what's the difference between, let's say, validators or stakers exiting? They just disappear from the network, so it would produce exactly the same effect. There would be less stake and less validators in the system.
01:15:16.950 - 01:15:29.370, Speaker D: So I'd like your feedback maybe on these two things. Having more trust in some smart contracts than other ones, and it doesn't prevent a situation where anyway validators are going to exist.
01:15:29.970 - 01:16:35.140, Speaker B: I agree with both of the points, but I would not characterize Vitalik's post as talking anything about attributable false. In fact, I think he's making a nuanced distinction between attributable false and non attributable false. So if it is attributable on chain slashing contract, then I think there is no worry. But the thing that I think he's worried about is things like you rely on a majority of your ristar opinion to slash a minority of the restaker. Then what? If the majority is corrupted, then the minority can be like, and if a lot of normal people lose money, then that will be a big enough of an event that there'll be pressure to say, oh my God, why would you allow this? And then you have to fork ethereum and so on. Which is what I was alluding to earlier, that we only allow on chain attributable slashing conditions for things like you disagree with the majority, you can penalize in the rewards that you give in your service, but not slashing each state. So that is the bar that we draw.
01:16:35.140 - 01:17:01.110, Speaker B: I completely agree with both of your characterization that dapps already have exactly the same trust model. If we don't believe in the D apps, then it's not clear what we are building. But I would also be remiss to not mention that it is such a hard security model to build a D app or a smart contract.
01:17:01.190 - 01:17:01.434, Speaker C: Right?
01:17:01.472 - 01:17:42.360, Speaker B: And this is the engineering group, so we all know this. But I'm just stating the obvious again. It's an open source system, so the attacker can read all portion of our code, the open state system, so the attacker can wait for the absolute worst moment to attack the protocol. It is an open entry system because we have censorship resistance that we pride ourselves on, which means the attacker is system is equally open to the attacker and a non attacker. It's an immutable system, which means it's open exit. So once you attack and get your funds, you're free to walk out royal carpet for your way out. It is an insanely hard security model to build applications in.
01:17:42.360 - 01:18:07.086, Speaker B: So the only principle I have kind of come up for our own building. We talk about all these security things, but really the thing that I'm worried about is what if there is some trivial bug in the rest, taking contracts and then somebody just steals the money. None of these crazy, complex things people have put in money. They just steal the money. And I think the principle that we.
01:18:07.108 - 01:18:10.142, Speaker C: Put in is add a lag between.
01:18:10.196 - 01:18:26.546, Speaker B: Entry and exit, so you cannot exit. So one of the nice things about staking is staking is a long term endeavor, unlike a bridge, where you're like, oh, just give me my money. I need to run away right now. It's not like that. It is, okay. People are staking over long time periods. There is a withdrawal lag.
01:18:26.546 - 01:19:11.954, Speaker B: So we enforce, like, a one week withdrawal lag, in which time your money is just sitting on an escrow contract. And this allows us, like, a luxury of time to run monitoring and other things, and humans can intervene and like, oh, my God, what is going on? Also, our first versions of the contracts won't be immutable. They will have community governance, basically community multisigs that have the ability to do instant upgrades. The team multi sigs can only do, like, lagged upgrades. We come up with a model where we kind of try to do as reasonable a job as possible in the smart contract security, but completely agree that there is no fundamental difference between a smart contract for staking and a smart contract for DeFi or Uniswap or any.
01:19:11.992 - 01:19:13.300, Speaker C: Other things like that.
01:19:17.050 - 01:19:31.110, Speaker A: So I think we've had an awesome number. Oh, there was one question that needs answering, and then I'll do some final slides. But very quickly, is there a GitHub repo? Is there more information somewhere?
01:19:32.730 - 01:19:33.430, Speaker B: Maybe.
01:19:33.580 - 01:19:39.020, Speaker A: I think Roberto was after more details and I would have thought go to the source would be the way to go.
01:19:40.690 - 01:19:41.440, Speaker C: Yeah.
01:19:43.250 - 01:19:47.520, Speaker B: I will basically share the GitHub repo here.
01:19:55.440 - 01:19:57.116, Speaker C: Yeah. Okay.
01:19:57.218 - 01:19:58.708, Speaker A: All right, brilliant.
01:19:58.904 - 01:19:59.472, Speaker C: All right.
01:19:59.526 - 01:20:54.670, Speaker A: And I'm going to quickly share some final slides just so everyone's across. So, yes, the merch store is open. We've got a whole stack of talks coming up next week. I'm going to talk about AI and my endeavors across about half a dozen to a dozen AI tools and what I've been able to do with just solidity code and trying to find bugs in it. Can it actually really find bugs and how well does it go and what you can do to actually get it to work better? And then we've got some talks on cross chain. Frank's going to talk about roll up related stuff, title to be changed as we get closer to it. And I did secure that talk on ERC 65 51, non fungible token bound accounts, and there's all the socials stuff.
01:20:56.660 - 01:20:57.216, Speaker C: All right.
01:20:57.238 - 01:21:14.550, Speaker A: Well, look, Sriram, thank you very much again for coming along and doing this talk. And if you were to get your slides together and share them with me and PDF, then I'll be able to include them as a link on this video, and there'll be a lot of people who will appreciate that.
01:21:15.320 - 01:21:15.876, Speaker B: Absolutely.
01:21:15.978 - 01:21:17.988, Speaker C: I'll do that. All right, great.
01:21:18.074 - 01:21:20.804, Speaker A: Look, thank you for your time and have a great evening. Thank you.
01:21:20.842 - 01:21:21.264, Speaker C: Bye bye.
01:21:21.312 - 01:21:24.724, Speaker B: Thank you so much for your word. Thank you, Frank. Thanks, everybody. Really appreciate that.
01:21:24.762 - 01:21:26.250, Speaker C: Thank you. Ready?
