00:00:00.250 - 00:00:01.742, Speaker A: Cloud. Okay.
00:00:01.796 - 00:00:24.190, Speaker B: Hello and welcome to the Ethereum Engineering Group meetup. Today we've got vitalik is going to talk about account abstraction. So, Vitalik, please introduce know you would assume that everyone would know who you are in the Ethereum ecosystem, but there are a lot of new people, so you never know. So please introduce yourself.
00:00:24.340 - 00:00:53.040, Speaker A: Great. So I'm vitalik. I'm the founder of the Ethereum project. I've also been, well, recently doing a lot of kind of research and work on Ethereum scaling things, some Ethereum 2.0 proof of stake, just all of the different directions of trying to push the Ethereum protocol forward. And I guess definitely happy to be talking about account abstraction today.
00:00:54.450 - 00:01:02.710, Speaker B: Thank you. And thank you again for coming along and doing the talk. So please share your slides.
00:01:02.890 - 00:01:22.598, Speaker A: Okay. 1 second. Sorry, I just will get those out. I wasn't sure if I'd be sharing from my own or sharing from or if there would be that big everyone put together 100 slide thing, but I.
00:01:22.604 - 00:01:26.502, Speaker B: Guess okay, yeah, look, I can get them too.
00:01:26.556 - 00:01:48.720, Speaker A: Just to say it's fine. I almost got it. Event down, double click F five, share screen PDF. Share. Okay, great. Do people see the screen?
00:01:50.130 - 00:01:50.926, Speaker B: Yes.
00:01:51.108 - 00:02:05.860, Speaker A: Okay. How many ghosts are there? Excellent. Okay, so to kind of get right into it, oh, by the way, first, how many minutes do I have again?
00:02:09.030 - 00:02:15.880, Speaker B: As many as you like, really? Sometimes these talk over one and a half hours. Sometimes they're 1 hour, sometimes they're half an hour.
00:02:16.410 - 00:02:22.970, Speaker A: Okay, that's good to know. And should I be expecting questions coming in anywhere?
00:02:24.510 - 00:02:31.580, Speaker B: What would you like? You can say some people are happy to have questions the whole way through.
00:02:31.950 - 00:03:23.210, Speaker A: I'm happy to just get questions in real time through the chat box. And that way, if people ask things, I can just go ahead and answer them right then and there. Sounds okay, so, great. Starting off, what is account abstraction? Right? Basically, today, so Ethereum is a programmable blockchain. And the thing that makes Ethereum more exciting than a lot of the platforms that came before is the fact that it is a programmable blockchain. But the programmability of Ethereum currently only applies to specific parts of a transaction, right? So the effects of a transaction are fully programmable. So a transaction, once it hits a contract, that contract can have arbitrary code, and then that arbitrary code runs.
00:03:23.210 - 00:04:08.790, Speaker A: And there's a lot of different things that transactions can do, but the validity conditions of the transaction are fixed. Right? There's basically one way to do a well, basically every transaction has to have an ECDSA signature. Every transaction has to have a nonce. And if the validity conditions are basically just step one, check the nonce. Step two, check the ECDSA signature. And if both of those are valid, then the transaction is valid. Now, the code that a transaction ends up running can have its own revert conditions, right? Like, you can say things like assert, this equals that and if the assert fails, then the execution reverts.
00:04:08.790 - 00:05:51.766, Speaker A: But there's an important difference between those two kinds of invalidity, which is that if a transaction is fully invalid, then it's not legal for that transaction to even be included on chain, which means that transaction is not going to pay gas, it's not going to cost anything. But if execution reverts, then the transaction is still valid and the transaction can still be included on chain, but it still pays for gas. But the effects of the transaction, either some or all of the effects end up reverting. So I would argue that you can do a lot of things with that kind of reverting but it's not sufficient, right? And I'll talk a bit about why it's not sufficient. And so the question is, well, can we try to make not just the effects of a transaction but also the validity conditions of a transaction? So the conditions that a transaction needs to pass to even be allowed to be included on chain also programmable? So motivating use cases, right? There's two major kinds of motivating use cases that I talk about. So one of them is multisig wallets, right? So personally I've been a big fan and a big booster of multisig wallets and social gear recovery and all of these ideas because I feel strongly about this idea that current wallets are just not secure enough. People lose their seeds or get their private keys stolen or other stupid things happen all the time and people just constantly keep on losing $200,000 left and right and often they don't even talk about it because there's this culture where if you talk about it, you risk kind of looking like an idiot.
00:05:51.766 - 00:06:49.310, Speaker A: And so people end up suffer quietly. But it's still this very big problem that it happens to a lot of people and honestly, I don't even think it's people's fault necessarily. It's this big new burden that this kind of technology is imposing on people of managing one particular key and making sure that it doesn't get lost or stolen. And I think we could do much better than this, right? And multisig wallets are one major way of fixing this. Basically, instead of having one key, you would have multiple keys. Some of those keys can be held by you, some might be held by an institution, some might be held by your friends. Social key recovery basically says you have a group of participants that can collectively decide to basically change the key of your account with some delay period if you end up losing your account, which is also something that's really valuable.
00:06:49.310 - 00:07:52.290, Speaker A: But the problem with all of those alternative wallet designs is that those wallet designs are not kind of quote, natively supported, right? So with the way that a transaction works, a transaction in Ethereum always has to first go through an externally owned account which is just controlled by a single ECDSA signature, then it goes to a multi SIG and then finally it goes to the recipient, right? So basically there's an entry and then a call and then another call. And there's a lot of annoyances because of this, right? Like first of all, you always have to pay gas for this transaction. There might be some kind of extra cost and some redundancy because of that. Also the ETH that pays for gas has to come from the first account. You can't come from the multisig. And so the multisig has to refund the gas and you have to have a balance here and a balance here. And then there's always the risk of like well, what happens if the gas price goes up by a factor of 50? You don't have enough ETH gear, do you have to borrow some? And it gets really stupid.
00:07:52.290 - 00:08:54.066, Speaker A: So with account abstraction, future multisigs, it's a much simpler model, right? Basically you have your account, a transaction and the transaction directly goes into the multisig. The multisig imposes and checks its own validity conditions. And if the validity conditions pass, then it just sends a transaction to whatever the recipient is. And so it just works exactly the same way as a single signature account works today. So that's the first kind of motivating example. The second major motivating use case is Mixers, right? Generally kind of privacy solutions or things like tornado cash. So the challenge here is basically that today if we look at how tornado cash works, it's a smart contract where basically you deposit into the contract and then you get this data that's called a node.
00:08:54.066 - 00:10:21.394, Speaker A: And then when you withdraw the contract, you zero knowledge proof that you have some node that hasn't been included before. But the zero knowledge proof does not reveal which deposit your withdrawal corresponds to. And so basically it just kind of cryptographically unlinks the deposit from the withdrawal and so you have privacy. But in terms of how the thing has to be implemented, there's this big practical problem, right? Basically the problem is this, right? So the goal is for your withdrawal to not be tied on chain to your deposit. The problem is that to send any transaction, you need to pay for gas and you have to have the gas before the X, or you have to have the gas money before the execution starts, right? And the problem though is that the tornado cash is only going to release the money after it does the execution and after it actually checks that your zero knowledge proof is correct. And so there's this cash 22, where if you have a new account, if that account doesn't have any ETH, then you have no way to withdraw unless that account already has some ETH. And then if you actually have a way of privately getting ETH to that account without creating a link, then well, why not just use that to do your entire transfer? Basically, Tornado Cash has this problem and it solves the problem with a relayer market, right? Basically, when you make a withdrawal, your withdrawal is not a transaction, it's an off chain message.
00:10:21.394 - 00:10:53.514, Speaker A: The off chain message gets sent to the relayer. The relayer verifies the on chain message. The relayer fronts their own ETH and they make a transaction wrapping the withdrawal. And then the contract itself provides a gas refund and a fee going to the relayer. And then the rest of the money gets withdrawn, right? So it's this much more complicated setup. It's sometimes a setup that ends up failing. Like, for example, if the relayer chooses a fee that's too low, then often you don't control the transaction.
00:10:53.514 - 00:11:51.470, Speaker A: You don't really have a way of bumping up the fee. There's a lot of annoyances. So Tornado Cash with account abstraction is much simpler, right? It basically says you have your withdrawal transaction, you push it into the Tornado contract and then the Tornado contract verifies the Synarc and verifying the Synarc is the validity condition. And if the letter condition passes, then some ETH comes out, part of it pays the gas and part of it is withdrawn funds. So in both of these cases, having account abstraction, so basically, allowing the validity conditions for a transaction to just be arbitrary code execution allows both of these really important types of wallets to just be considerably simplified. So the simplest kind of abstraction that we can possibly do, and this is only partial abstraction, right, is signature abstraction.
00:11:52.050 - 00:12:36.334, Speaker C: Hey, Vitalik. Yes. Sorry to interrupt you. I might actually have a third motivated use case for, oh, I've been working on a project for the last two years. It's called Inherit Cache. So when we go back to the first use case, where you have a multi SIG wallet and you have social recovery Shamir's, secret algorithm, all these things that are coming out for trying to recover your private key, if you lost it, what about in the case where a person passes away? How many people do you think have passed away with active bitcoin wallets in the last ten years? And those funds might just be lost. So I don't want to take up too much of you guys time.
00:12:36.334 - 00:13:35.460, Speaker C: I'm just going to post some links in the chat so you can take a look. Basically, this is a digital will where you can have ERC seven two one assets where you can assign specific beneficiaries to specific NFTs. And for your, ERC 20 assets, you can assign a specific percentage of your assets to a given beneficiary. So I'll drop that in the link if you're interested. How count abstraction would solve problems in this space is basically you can't have a smart contract move native ethereum from a user's wallet. You can only do this basically, this whole inherit cash system only works with, ERC 20 and ERC seven two one tokens because you can approve them to be moved. Whereas because we don't have this account abstraction today in E 1.0,
00:13:35.460 - 00:14:08.140, Speaker C: account abstraction would theoretically solve this problem so that you would able to create a digital will where your beneficiaries could withdraw native ETH. ERC, 20 and, ERC seven two one. So I'll drop a link into the chat here if anyone's interested. Sorry, it's really late here. I'm in South America and it's very dark, so I can't put my camera on, but I will drop those links in. And if you're interested, this could certainly be your third use case.
00:14:10.690 - 00:14:48.214, Speaker A: No, that's definitely a great example. Right, okay. So signature abstraction. So if we look at kind of how accounts work today, right? So basically, all externally owned accounts have to follow this formula where we can fit the kind of different parts of the system into these categories, right? So a private key is a 256 bit number. Then we have this concept of verification data. So this is like a generalization of a public key, basically. And in this case, it's your address.
00:14:48.214 - 00:15:31.574, Speaker A: Then you have your signature, and the signature is these two values, kind of R and S. And then the verification process basically says, well, you EC recover the signature using the hash of the rest of the transaction. And then you take the last 20 bytes and you see whether or not it matches your address. Right? So this is basically how verification works today. So one could imagine a restricted form of abstraction that just does signature abstraction. And the way that it would work is basically we just replace each of these four categories, right? So private key would be kind of outside the scope of the consensus. It depends on the algorithm used.
00:15:31.574 - 00:16:06.206, Speaker A: There could even be multiple private keys. There could be a lot of things. Verification data. Instead of being an address, it would be a piece of code. And you can think of the code as just the code is like your private key, right? And the code is just the thing that would execute the signature and verify whether or not it's valid. The signature would be arbitrary data, and different code would expect signature signatures that have different formats. And then the verification algorithm would say, execute the code with the message hash and the data as input and check whether or not it returns.
00:16:06.206 - 00:16:36.890, Speaker A: True. So this is the kind of format within which you can basically put any kind of signature verification in, right? So like, if you want to do Shinor, then the signature would be a store signature. The code would be a store Verifier. The algorithm would check. Well, if you read the store Verifier on the hash and the data, then does that lead to the Verifier return? Incorrect. You could do the same for BLS. You could do the same for multi Sigs.
00:16:36.890 - 00:17:32.480, Speaker A: Another use in a fun use case is quantum resistance signatures. So lamport signatures, winter knit signatures, the Stark based signatures, and so on and so forth. So there's a lot of things that you can fit into this format. And this format actually is a fairly small change. But the problem is that there are some things that this format does not let you do, right? And the thing that this format does not let you do is it does not let you have verification conditions that depend on data that can change, right? So it does not let you have, say, social key recovery where the key can change. It does not let you have something like tornado cache where you check whether or not a nonce has already been published. There's a lot of things that you can't do.
00:17:32.480 - 00:18:56.786, Speaker A: So the other extreme, and this is the path that we're taking, is basically start off from the perspective of full transaction abstraction. The idea behind a full transaction abstraction is basically a transaction is just a function call where the sender is just like some standard dummy address, right? So think of the sender as being, say, just negative one, for example, or it could be whatever address. So a transaction is just a function call and then the transaction would call into some accounts that we call the target. That account would impose validity conditions and then that account would, if it's happy, pay the fee and it would do whatever else the transaction wants that account to do, right? So this is the kind of consensus layer, simplest way to do abstraction. But there's a lot of big challenges. So one big challenge is Block proposal dos resistance, right? So this is an issue that the community first started talking about in the context of the Dow soft fork. Basically, if you have this property that you can potentially have an arbitrary amount of execution, and then at the end of the execution, suddenly the transaction reverts and the miner doesn't get the fee.
00:18:56.786 - 00:20:10.734, Speaker A: Then how can miners or block proposers kind of safely process transactions without the risk of them falling victim to fake transactions that do demand service attacks? This is challenge one. It's a pretty big challenge. Challenge two is network layer dos resistance, right? So this is the same thing as block proposal dos resistance, except instead of being whether or not to include it's, whether or not to rebroadcast, and if it takes running the entire transaction to see whether or not you'll rebroadcast, then that's a really huge expense and it will just make the network basically not really be viable. A third challenge is that it will need to have some new kind of transaction Identifier, right? Basically, one of the nice properties that the current non space approach guarantees is that transaction hashes are guaranteed to be unique because the transaction hash needs to contain or implicitly contain the sender and the nonce. And every sender can only have one nonce. And so a transaction hash cannot repeat, right? But in an account abstraction setup, you could totally imagine a target account that has a piece of code that actually does accept the same transaction twice. And there's even legitimate use cases for this.
00:20:10.734 - 00:20:46.940, Speaker A: Like maybe after some period of time the nonsense resets. Maybe the account just needs to accept a poke. And a poke would just be like a zero data transaction and it just forces the account to run. A lot of things could happen, right? So that's one way of thinking about it. But then one possible solution is that miners could just adjust the nonsense of the transaction as the transaction gets included, which keeps hashes unique. But it does mean that the transaction hashes become malleable and potentially unpredictable unless the account is deliberately set up to make them not be unpredictable. Right? So this is also an option.
00:20:46.940 - 00:22:16.386, Speaker A: So our solution, we'll focus on the first two problems and then we'll talk a bit about the third at the end, is that so we'll establish some invariants and we'll establish some restrictions on what execution can do in order to enforce those invariants. So one invariant is that we want to have a rule that says a node must execute a maximum of some amount of gas. So we'll say, for example, 400,000 gas before they know whether the transaction will pay gas or whether the transaction should be discarded. And so the idea here is that we want it to be not possible to have a transaction that just runs for many millions of gas. And then at the end it's like, oh, suddenly, oops, this transaction actually isn't valid and it doesn't pay the fee. So this is the first invariant. The second invariant is that you want one gas of execution to correspond to at most six gas of reverification, right? So what this means is that if you have execution on chain, then we want to be able to make a clean mapping that says that one gas of execution on chain, in general, execution on chain leads to potentially needing to reverify transactions because state changes that happen on chain could lead to transactions that were valid before no longer being valid because some dependency of the transaction stopped being valid.
00:22:16.386 - 00:23:14.534, Speaker A: Right? So we want to have a sub variant that says that one gas of on chain execution corresponds to at most six gas of reverification. And what this means is that after each block, there would be a theoretical maximum of 75 million gas of transactions that you would need to reverify. Now, this is a theoretical max, right? Like in practice, users are not going to be maximally greedy. In practice, if a miner does not manage to do all of your reverification, they're still going to be relatively fine. So 75 billion is just an upper bound. But basically, if we have this kind of cap, then we can make it much safer to actually do this kind of verification, right? So I guess kind of just to step back a bit to kind of think about what the problem is here. The challenge is that you have these transactions and these transactions have some validity conditions.
00:23:14.534 - 00:24:12.110, Speaker A: They do some verification computation. That verification computation is going to inevitably depend on the state. Like it might depend on balances, it'll depend on nonsense or some equivalent of nonsense. But other transactions could potentially change things that happen in the state, right? And so after every block you might potentially have to reprocess some part of the mempool. You definitely don't want to have to reprocess the entire mempool, which is what you would happen if there were no controls whatsoever. But if we add some controls, then we can add a restriction that basically says that after every block you only need to reprocess, you know, what specific transactions you would need to reprocess because you know what dependencies you're allowed to have during verification code execution. And so there's only a limited number of transactions that you would have to reverify.
00:24:12.110 - 00:24:47.510, Speaker A: Great. So now we're going to kind of specify the thing and add some rules. So a transaction is going to be simpler. It has the form first you have a nonce and we're going to keep the nonsense just to make this simpler. Just to preserve a transaction hash uniqueness. Then we have the target and the target is just an address and then we have data and the data is just bytes. Executing a transaction is a call to the target with the given data as an input and the gas limit of the call is going to just be the remaining gas in the block.
00:24:47.510 - 00:25:34.630, Speaker A: When a miner attempts to process an incoming transaction, they start executing the call until they hit one of three conditions. First of all, if the execution consumes a six times N gas, where N is the account spend commitment and I'll talk about spend commitments a bit later. Basically, if the execution consumes too much gas, then at some point the miner gives up and this is a fail. If the execution hits a banned Opcode or a banned call, I'll talk about what those are, that's a fail. If the execution hits the pay gas Opcode, which I'll also talk about, then you check what the gas price sum that the pay gas Opcode declared is. If it's not sufficient, fail, and it is sufficient, then pass. So spend commitments.
00:25:34.630 - 00:26:50.588, Speaker A: Basically the idea here is that we add an Opcode that we can call commit. That takes an argument which is just a gas amount as input and it commits to spending at least that amount of gas within the current execution context. And if less gas is spent within the context, when the execution exits the context, then the remaining gas just gets immediately burned. So the idea with this is basically to establish an invariant that says it is not possible to call into the account and modify its state without spending at least that amount of gas. And you can check very easily what a kind of guaranteed sped commitment of an account is by basically checking the code of its account for a prefix, right? And a prefix basically is just like push three some number from zero to 16 million and then commit. Now, you might notice that spend commit. This is a slightly different presentation from the presentation that was in the current kind of EIP that was published a couple of weeks ago.
00:26:50.588 - 00:28:03.060, Speaker A: There has been some discussions since then and one of the discussions is basically like for this is the longer term version of abstraction, instead of doing a kind of consume gas and refunds thing at the end, have a commit, but we'll see very soon kind of what this commit does, right? So first of all, accounts that are targets, so accounts that are expected to represent end user accounts are going to have this commitment and so they're going to just self declare what their minimum guaranteed gas spend is. PayGas, right? So PayGas, basically the idea here is that PayGas is equivalent to the current gas payment logic. Basically, PayGas is a special opcode that can only be called in a top level execution context. And it takes as input two stack arguments, right? One is the gas limit and the second is a gas price. It immediately spends that amount of way. And if there's not that amount of way, then the transaction fails and it's invalid. It reduces the remaining gas in the execution context to the gas limit minus the amount of gas that was already consumed.
00:28:03.060 - 00:28:57.312, Speaker A: And if that amount is negative, the transaction is obviously invalid as well. At the end of the transaction execution, if execution fails, it reverts only to the end of the Pay gas, right? So if the execution fails, then everything that happened before the Pay gas still, like the state changes, are still saved, the gas payment itself is still saved and then the refund is basically the gas remaining multiplied by the gas price and then the rest goes to the miner as a fee. So you might notice that this is the exact same logic that currently exists that's kind of hard coded in as part of a transaction processing. So transaction processing basically says step one, check the nonsense signature. Step two, spend this amount of way. Step three, do the execution. Step four, do a refund.
00:28:57.312 - 00:30:04.440, Speaker A: Here we basically take that. Step two, take that logic and instead stick it into the Pay gas opcode, right? So calling the Pay Gas opcode acts as a logical separator between verification execution, which is what happens before, and other execution, which is what happens after. If some failure happens during verification execution, then the transaction is just either invalid or it doesn't pay a fee, so it cannot be included at all. But then if some out of gas or some other exception happens after the Pay gas, then it reverts back until the Pay gas, right? So basically it reverts only back until after the verification execution and after the transaction fee was paid. So banned operations. This is the really important piece. So this is things that you cannot do during verification code execution, right? So this is things that you cannot do before pay gas.
00:30:04.440 - 00:30:57.870, Speaker A: One is reading balance and this means including reading your own balance. Another is any external call or any external storage read, with one narrow exception to allow delegate calling libraries that are guaranteed to not go away. And the third is reading environment variables like a number and timestamp. So the purpose of this is to basically say that pre PayGas execution. So execution of the verification code, by the way, I should clarify, verification code is not like separate code. I just mean the portion of the code that runs before the transaction hits the PayGas opcode. So the idea is that execution before the PayGas opcode can only depend on the state of the target account, right? So you cannot call out.
00:30:57.870 - 00:32:26.600, Speaker A: The reason why we do this is to establish a hard guarantee that says that if some account is modified, then the only transactions that need to be reprocessed are transactions that are actually targeting that account, right? So if I have a transaction that targets some account X but then some other account Y gets modified, my transaction does not need to be reprocessed because I know that the execution up to and including the pay gas only depends on account X. It does not depend on account Y. And so there's no reprocessing required. The reason you cannot even read your own balance. So this gets into the spend commitment stuff and why this exists, right? Basically the challenge is so the invariant that we're going for is that we want it to be difficult to modify an account in such a way that it makes the transactions going from that account need to be reprocessed. Right? Now, obviously, if you have a transaction from account X, then that's going to potentially interfere with or invalidate other transactions from account tax. At the very least, if you have an account that works sanelly, then a transaction is generally going to invalidate itself, right? You don't want to be able to include the same transaction twice.
00:32:26.600 - 00:33:46.560, Speaker A: But another thing is that you don't want it to be easy for some execution that happens somewhere else in account Y to modify account X and then cause account X to have to be reprocessed as well, right? So like, for example, you could imagine an attack where basically someone goes and checks and sees what are all of the targets of the mempool and then they just do an attack that says they just do like one call into all of the accounts that are in that mempool. And every one of those calls is going to cost like only, well, right now 700 gas after EP 29 29, 2200 gas, but it's. Still too little. And so they're going to basically potentially make some modification to all these accounts and they're just going to force you to reprocess tens of thousands of transactions in the mempool. This would be terrible, right? And so what we do instead is, well, first of all, the reason why we ban reading the balance is because we want it to still be easy to send ETH to other people's accounts. We want it to be easy to just send a bit of way to someone. But in order for that to not be a vector to force the Memport to be reprocessed, we basically just ban reading the balance.
00:33:46.560 - 00:35:46.324, Speaker A: And so the only way in which a transaction could depend on the balance is basically that the Pay gas opcode would check if there's enough money and if there's not enough money it would fail. And sending someone money cannot make a formerly valid transaction invalid. And so that's not something we have to worry about now getting to spend commitments in the six times N thing, right? Basically what's going on here is that let's say you have an account and transactions from that account take like say 90,000 gas to get to the point where they call pay gas. In order to protect our invariant, we want to have a mechanism that says well, account X cannot be modified unless 15,000 gas at least gets burned in order to do so, right? So if someone is willing to burn the 15,000 gas in order to call into the account and potentially modify it, then fine, we can reprocess. If they're not willing to do that, then they can't call into the account at all. And then if you imagine all accounts kind of having this restriction, right, then basically what you can see is that, well, if you receive a block and that block contains a bunch of transactions, then those transactions are going to cause a bunch of state changes. But we know that if they cause a state change to an account that is a target, then basically for every kind of end gas of reprocess, if that target has some transaction that's going to require N gas of reprocessing, then modifying that target is going to require burning at least N over six gas.
00:35:46.324 - 00:36:08.880, Speaker A: There's only twelve and a half million gas in a block. And so the maximum amount of reprocessing that you can do altogether is only going to add up to 75 million. I'll probably stop here for just a bit in case people have questions because this is probably the most involved part of the entire proposal. Kind of how the invariants work and why things safe and why reprocessing is bounded.
00:36:16.460 - 00:37:02.930, Speaker B: I know I've got a few questions, but they were actually related to earlier parts. This actually makes a great deal of sense so that you can do a trial execution of it in the mempool to make sure it's valid, but then not wanting to then later find out it's invalid and having to turf it out. So essentially not having the problems that hyperledger fabric has of putting a transaction in the blockchain that's then later found to be definitely invalid just due to some simple things. Yeah. Does anyone have questions about this area? Everyone?
00:37:05.540 - 00:37:12.530, Speaker D: I have a question on how the number six was chosen. Why six, and is that arbitrary or is there a specific reason?
00:37:14.900 - 00:37:52.210, Speaker A: It's just arbitrary. I guess if the number was like, say, 100 instead of six, then the amount of reprocessing that you have to do would potentially be really high. If it was, say, one instead of six, then basically the problem would be that there would be a lot of legitimate use cases that would be needlessly expensive. I actually think that it could potentially be reasonable to make the number be even smaller than six. Even two or three could be safe as well. It's just a safety trade off.
00:37:54.740 - 00:37:55.584, Speaker B: Okay.
00:37:55.782 - 00:37:57.008, Speaker E: Is it the other way around that.
00:37:57.014 - 00:37:57.996, Speaker A: Makes it less safe?
00:37:58.028 - 00:38:01.200, Speaker E: Like if you increase the amount of validation gas per gas on chain?
00:38:02.100 - 00:38:14.470, Speaker A: Yeah. Well, it absolutely becomes less safe because the reprocessing becomes really expensive. Like after a block, you might have to do a huge amount of gas of reprocessing to check.
00:38:15.400 - 00:38:21.050, Speaker E: Yeah. So were you saying that we might need to lower the number to make it safer or we might be okay to make it higher?
00:38:22.460 - 00:39:09.000, Speaker A: I guess my personal instinct is that core devs tends to be overworked and tired and scared of their radical things justifiably and so unless there's a legitimate reason to make the number greater than six, we should keep it to six. And unless somebody could come up with a legitimate reason to make the number greater than three, we should probably decrease it to three. And if start conservative and go up from there. I guess one thing about six is that six is like a reasonable ratio between the theoretical minimum gas consumption that you need to do something reasonable kind of within a block and the amount of gas consumption that you would need to do a fear with significant verification in a multi SIG wallet.
00:39:20.920 - 00:39:48.030, Speaker E: So I think Will Villanueva had a write up from Quilt on how the current nonce and signature verification gas or theoretical, the equivalent amount of gas to that verification is related to how much gas on chain is required to invalidate it. So I can put the link to that in the chat if anybody's interested in some of that work.
00:39:48.640 - 00:39:49.390, Speaker A: Perfect.
00:39:50.640 - 00:40:33.710, Speaker B: Well, that actually relates to a question that I was going to fire through because you're saying that the maximum that you can spend in a contract is 400,000 in the verification contract. So then suddenly you could imagine then that every transaction is using 400 gas just to verify. So how does that compared to, say, the ECDSA EC recover sort of verification of addresses and are we now moving a whole heap of processing on chain and doing more than we previously needed to.
00:40:34.240 - 00:41:27.720, Speaker A: Yeah, good question. In terms of how that compares ECDs, I don't think everyone is going to be doing 400,000, right, because people don't want to have their transactions cost 400,000 gas. In terms of how it compares ECDSA, verification is I guess comparable to somewhere between 5000 gas worth of execution. I personally expect most users to just be using a multi SIG or doing schnor or whatever. So it'll cost maybe also in the 10,000 gas range. But in practice it does mean that a transaction is going to potentially cost up to 40 times more to process when it enters the mempool. But at the same time, I don't think that should be interpreted as a factor of 40 increase in load.
00:41:27.720 - 00:42:34.424, Speaker A: And the reason basically is that, well, if someone publishes that kind of transaction, basically if someone publishes a regular transaction today, that corresponds to on average around 50 or 60,000 gas of execution. Whereas if someone does one of these 400,000 gas transactions, then that's going to correspond to at least 400,000 gas of execution and possibly even more. And so just the number of heavy transactions that can happen is going to be lower than the number of transactions that exist today. And so that'll kind of counteract the effect somewhat. Okay, I guess. Continue. Right, so kind of why the rules, right? We've basically gone through this at this point of pay gas is the logical separator between verification and execution of what the transaction is actually trying to do.
00:42:34.424 - 00:43:27.870, Speaker A: If an execution reaches pay gas, then no matter what happens after the pay gas, the miner knows that it will pay for gas. And so that's why the miner or the block proposer only needs to verify up to the pay gas to verify that a transaction will be paying. Prepay gas activity cannot read or write to accounts other than the target. It only depends on the state of the target and modifying an account cost and gas and modifying accounts can only lead to at most six times and gas of reverification. And so you have this wonderful kind of six to one invariant. Notice that unlike previous versions of EA, where for example, in previous versions of account abstraction, you would just have a hard rule that says accounts cannot be modified from the outside, they can only be modified by transactions that go directly into them. This version of account abstraction allows external calls into an account abstracted contract, which I think is awesome.
00:43:27.870 - 00:44:57.620, Speaker A: And this is actually necessary if you want something like tornado cash to be account abstracted, for example. So I guess the last kind of question here is are there alternatives to this approach? And I think there's two major families of alternatives, right? One family of alternatives is, well, instead of doing pay gas, we would kind of have a bit more kind of stylistic complexity for the sake of having less transition complexity. And we'll actually say that there's a special type of account called a target account that has a distinct execution code and verification code. And the verification code just basically would be the same as kind of what I talked about in this slide where we talked about signature abstraction, except the verification code would also have the ability to access storage and it would have some other kind of limited powers, right? If we do that and then the transaction would just be two calls first verified, then if the verification succeeds, it would execute. And this is like potentially it's like conceptually simpler if you look at it from the perspective of what the transition is. But I would argue it's conceptually more complex if you look at it from the perspective, like what is the system if you look at it kind of from scratch. So it's like another alternative.
00:44:57.620 - 00:46:09.720, Speaker A: And then the second alternative is to just don't bother with account abstraction at all at the base layer and just implement account abstraction in roll ups. And roll ups are nice because kind of simple dumb account abstraction where you don't do any pay gas, you don't do any invariance, and you just rely on the sequencer of the roll up to brute force. Transaction validity is much easier to implement. And so the theory would be that if the users are going on to the roll ups anyway, then you'd be able to get much of the benefits there. So I think these are probably the two most natural alternatives to trying to get the benefits of account abstraction in Ethereum. But one thing that I would say though, is that I think even in a roll up centric world base chain account abstraction still has value. One value is just kind of philosophical cleanness value, especially in the really long term when eventually quantum computers are going to start breaking things and we want to have quantum proof everything on chain.
00:46:09.720 - 00:48:01.872, Speaker A: And so when that happens, we don't want to have enshrined Dcdsa verification, right? So we may want to just have account abstraction on the base chain so that signing algorithms can move to something else. And then the other reason is that account abstraction can be potentially good for making roll ups work better. And the reason here, basically, is that if you imagine a design where you allow multiple sequencers and so sequencers could potentially interfere with each other, then you don't want to have the risk of two transactions from two sequencers, kind of both getting included on chain and one of them having no effect but still having to pay gas. And so if you just have an account where the verification code just does the checking and it checks basically does the provided prestate actually equal the post state in the contract, then you could bake kind of on chain roll ups of certain kinds still significantly easier. So in terms of what account abstraction is and kind of how it works and kind of what it can be used for, I guess that's pretty much it in terms of implementation and kind of where we go from here. I personally think that kind of despite the existence of these alternatives, I think the fact that account of Jackson is going to be implemented in roll ups anyway and so that's fine. But I do think that pushing forward on coming up with something and implementing something at the base chain layer is still a valuable thing to do.
00:48:01.872 - 00:48:47.800, Speaker A: And in terms of would we want to instead try this verification code approach? I mean, maybe we could, but the benefits either way are not too large. And in my own perspective is that the current approach seems fine. And so I personally would favor just continuing with how things are now, seeing if we can try to do a testnet, try to actually have some account abstracted wallets, kind of see how it goes and go from there. But I guess we'll see. Great. I guess if people have more questions, I'm happy to answer them.
00:48:48.890 - 00:48:54.280, Speaker C: Will this be deployed on ETH 1.0 or is this only for ETH 2.0?
00:48:55.930 - 00:49:13.470, Speaker A: I guess again, those two are ultimately kind of the same thing, right? Because there's ETH 1.0 is going to keep evolving and then east 1.0 is eventually going to become part of the ETH 2.0 chain. So I definitely favor trying to just get it into ETH 1.0 so we get the benefits sooner.
00:49:14.530 - 00:49:43.174, Speaker C: Great. I'm just going to post in the chat one more time about Inherit Cache. I definitely think that Inherit Cache is a good use case for this. I don't have an audit yet but if you want to take a look, I think it's really cool for someone that wants to be able to leave an inheritance to their beneficiaries, whatever form shape that might be all.
00:49:43.212 - 00:49:44.710, Speaker F: Decentralized show, king.
00:49:45.210 - 00:49:47.690, Speaker C: Thanks so much for guys, time and your attention.
00:49:57.380 - 00:51:02.612, Speaker B: Yeah, I've got another question it sounds and the idea of the context it feels like. So we've got a new concept within the EVM, I guess these contracts or at least the function call within the contract that does this pay gas is now going to be essentially a very special function call. So you can't call it from another bit of code out there. Yeah, I'm just thinking it through. You're not going to be able to call it from one contract into this. It's from an EOA only essentially not enforced. But if this was the second thing that actually could you have a contract which calls into this and so use two contracts, two function calls to do this sort of account verification like do.
00:51:02.666 - 00:51:48.000, Speaker A: Two function calls where one function call does the verification and the other function call does execution. I definitely expect that sort of thing to be a common template. Right. I guess this is the other kind of third alternative to a kit. This is not as much of an alternative because it requires smaller changes, but the alternative is basically that instead of having more complicated logic, we would basically just have more templating logic. And then templating logic basically requires you to do one delegate call that does verification, then call PayGas, and then do one delegate call that does execution, and then just figure out how much to pay the miner at the end. That's definitely another alternative.
00:51:48.000 - 00:52:05.400, Speaker A: I guess that would just have less complexity at the consensus layer, but you would have more complexity in terms of implementing the template and actually checking the template. I don't mean I think both are potentially reasonable.
00:52:10.180 - 00:52:15.910, Speaker B: I do have another question, but I'm conscious that I've asked a few questions. Does anyone else have questions?
00:52:19.480 - 00:52:50.610, Speaker D: Yeah, I would like to throw in a quick one. Vitalik. With the changes that you're proposing here, you're touching on some of the very fundamentals of how ethereum works, like the Dos protection from the simple idea that every transaction has to pay for gas and that there, by definition, therefore can be no spam. And I'll admit that the changes here, messing around with these fundamentals makes me a bit uneasy. What is your view on how secure is ethereum with these changes here?
00:52:51.060 - 00:53:15.610, Speaker A: I guess it does definitely kind of dig into the fundamentals. I don't think that it breaks core invariants. Right. Because it tries really hard to preserve the core invariant. That, for example, there's only a limited amount of execution that can happen before you know that a transaction is going to be valid. Right. Which is probably the most important one.
00:53:15.610 - 00:53:37.550, Speaker A: So I do feel like there is, I guess, some kind of inherent risk that just has to be done if you want it to be possible to run code before verification at all. But I personally feel like within the scope of that requirements, there's already sort of all of the guardrails that we can put.
00:53:42.900 - 00:53:44.160, Speaker D: Okay, thank you.
00:53:44.310 - 00:53:52.768, Speaker B: Is there any attempt to model what the impact would be on sort of Memphis processing with all of this reprocessing?
00:53:52.864 - 00:54:00.070, Speaker A: There was I think there was an ETH research post that got linked in the chat. It was 7937.
00:54:08.240 - 00:54:18.850, Speaker E: Yeah, that was against an earlier prototype of our implementation of AA. If we need more solid numbers, we can always update it to the current EIP and rerun the numbers too.
00:54:23.240 - 00:54:48.830, Speaker B: So the EIP 86 came out like, in 2016, or maybe it was even 2015. So a long time ago. And that didn't get up. And I think there have been a few other iterations of it, and now we're up to the latest iteration. What has stopped account abstraction being adopted earlier and why do you think it will be adopted now?
00:54:49.840 - 00:55:31.672, Speaker A: I think realistically, the answer to that is the same as the answer to why ethereum development in general has kind of not done too many things in the last couple of years, and now things like One point X are picking up really quickly now. There weren't many resources to do radical things before, I guess, and there were a lot of things that we wanted to do from the beginning. Right. We wanted to change from the hexa retree to the binary tree. We wanted to add a history merkel tree. We wanted to do a lot of different things. And I think all of those things have kind of stalled for a couple of years.
00:55:31.672 - 00:56:00.470, Speaker A: And now things have really rapidly changed over the last year or so, and there's dedicated teams for each one of them. So I don't really think it's an account abstraction specific thing. I think it's more a kind of core dev process thing. And the core dev process has improved it.
00:56:01.400 - 00:56:15.450, Speaker F: In your alternative slide, you mentioned how sequencers are used could help make count abstraction easier. Could you recap that?
00:56:16.860 - 00:56:53.904, Speaker A: Sure. So basically the idea there is that the way a roll up works is that you have this one party called a sequencer that just collects transactions that are going into the roll up, and then the sequencer verifies them and puts them into a batch and then publishes the batch. And the sequencer basically transactions just get set to the sequencer directly. Right. So there's not even a mem pool. There's just like one mem node. And the sequencer could even run a much simpler algorithm, because their algorithm is just receive a transaction.
00:56:53.904 - 00:57:45.380, Speaker A: Does the transaction pay gas or not? If it does, then accept, and if it doesn't, then throw it away. And so they only actually really needs to process every transaction once, which is just amazing, right. Actually, if they want, they could even go further, right? Because you could even do transaction fee payments not as part of the transaction. You could have them be done as part of a channel payment going to the sequencer, for example. And so you have a lot more flexibility with a sequencer based approach than you have with a kind of traditional ETH one style network approach. And I think that just ends up leading to well, it leads to a lot more flexibility, right. Because you just needs to worry much less about the possibility of Dos transactions.
00:57:47.560 - 00:58:04.724, Speaker F: Okay. I guess part of my question is I might be missing something about sequencers, but is there something in them that just makes them less attackable to Dos or does it just push the problem kind of to the sequencers to solve?
00:58:04.852 - 00:58:25.920, Speaker A: Right. So I think there's two answers, and one of them is like, it's just the fact that it's only one node that's processing these things instead of tens of thousands of nodes. And the other thing is that the sequencer is expected to be a more powerful and more sophisticated node.
00:58:27.140 - 00:58:38.068, Speaker F: Yeah, okay, thanks for those two points. It still sounds a little bit like though, that they could be open to attack.
00:58:38.234 - 00:58:52.200, Speaker A: Right. Sorry. The third thing that I forgot to mention is channel payments. Right. I believe optimism is doing this. They don't even have payments. As part of a transaction, you just subscribe to the sequencer and prepay for some amount of gas.
00:58:54.620 - 00:59:06.712, Speaker F: Or to use a roll up or a sequencer, you'd have a balance already in them. So if you send a bunch of attack transactions, they could always probably withdraw from that initial balance.
00:59:06.776 - 00:59:14.272, Speaker A: Right. Maybe they would still have to prove oh, I see, right. Kind of like in a state channel.
00:59:14.326 - 00:59:17.010, Speaker F: How you already have a balance in it.
00:59:19.320 - 00:59:20.116, Speaker A: Right.
00:59:20.298 - 00:59:23.440, Speaker F: Like, to use a roll up, you might already have a balance.
00:59:23.520 - 00:59:42.472, Speaker A: Yeah, potentially. Yeah. Right. I guess the other thing is that, as I mentioned, the concept of reprocessing doesn't exist. Right. Because the sequencer's algorithm is just like, receive, try to process if it's fine, immediately included. And if it's not fine, then just ignore it.
00:59:42.472 - 00:59:43.352, Speaker A: Drop it. Yeah.
00:59:43.406 - 00:59:44.040, Speaker F: Okay, thanks.
00:59:44.110 - 00:59:44.730, Speaker A: Yeah.
00:59:53.520 - 00:59:57.512, Speaker B: Maybe flip to the last slide and I'll talk about the forthcoming talks.
00:59:57.656 - 00:59:58.620, Speaker A: Excellent.
01:00:01.040 - 01:01:05.824, Speaker B: And I'm back on the call as well. I dropped off the call temporarily, but I'm back anyway. So in two weeks time, we have got Dominic Schmidt, and he's going to give us a talk on Raiden and explain what Raiden is and how it can provide scaling. And then in four weeks, we've got alexe is going to give a talk on Turbogeth and talk about why he thinks Turbogeth is the bees knees and the best ethereum client ever and ten times faster, bigger, brighter, better. And Constantine, in two more weeks time from then, is going to give a talk on scale, which is another scaling solution. And then two weeks after that, we'll have a talk from one of the people from filecoin, or David and I will give a talk based on our work on Filecoin. So Dominic is in Germany, Alexe is in London, and Constantine is in the Ukraine.
01:01:05.824 - 01:01:59.876, Speaker B: So hence the talks are going to be Brisbane afternoon. The Filecoin talk, if it's one of the people from Protocol Labs, then it'll be probably 09:00 A.m., Brisbane, because they're in San Francisco. Or if David and I or I do the talk, we'll do it at 1230 Brisbane. So are there any final questions? Okay, looks like it's all good. Well, thank you again for coming along and giving the talk. Vitalik I'll post the video onto the YouTube channel, and if people have got further questions, maybe they can put comments against the video and people can work through those later on.
01:01:59.876 - 01:02:04.324, Speaker B: So thank you. Thank you for joining. Congrats on getting it to this point.
01:02:04.362 - 01:02:09.030, Speaker A: Vitalik thank you all for.
01:02:15.000 - 01:02:15.780, Speaker F: Thanks, guys.
01:02:15.850 - 01:02:16.370, Speaker A: Love your work.
