00:00:01.450 - 00:00:34.834, Speaker A: Hello and welcome everyone. My name is Peter Robinson, and this is the Ethereum Engineering Group. Meetup. So this online meeting is going to be recorded and uploaded to YouTube. So if you're unhappy with that, I suggest you say turn your video off, turn your audio off and maybe even leave the meeting and just watch the recording. And so without further ado, let's see. So the speaker today is me, and so I'm going to deliver the talk on abi encoding.
00:00:34.834 - 00:01:27.748, Speaker A: So who am I? I've got more than 30 years experience developing products and doing all sorts of stuff from embedded devices, satellites and application server stuff, mobile phones, the actual mobile phone themselves, and also the applications on the mobile phones and cryptography worked at RSA for a whole heap of time and worked at consensus for more than five years now. So I've done quite a bit of quite a few different things. All right, let's share my slides. Okay, so everyone should be able to see my slides. Yes. Cool, I can see some thumbs up. Very helpful, thank you.
00:01:27.748 - 00:02:28.964, Speaker A: Okay, so if you've got questions you can interrupt, you can also fire them into the chat. I will try and keep half of an eye on the chat as yeah. All right, so abi encoding, so I'm going to talk about what is abi encoding and what the goals are and then talk about the various times that it's used, talk about how the encoding specification works. So try and dive into the detail and then talk about a hack that happened quite recently and how abi encoding was used to help resolve that or at least do root cause analysis. And then there's a bit more on solidity and abi encoding at the end. So what is it? So abi encoding is the application binary interface. So it's the interface into contracts for Ethereum.
00:02:28.964 - 00:03:27.388, Speaker A: So you don't have to use the abi, but it's encouraged if you want to have intercontract compatibility and compatibility with a lot of the tools that are in the ecosystem. And so it's a way of essentially describing the data and the function calls that you want to make for contracts. And so it assumes that function are strongly typed, so it assumes that you're going to have a statically typed function where it has certain known parameters, so it doesn't really allow for dynamic typing. And so that's something that's certainly worth keeping in mind. So it's static typing of an interface going into a contract. That's the goal. So when is it used? So there are four specific times that it's used.
00:03:27.388 - 00:04:15.540, Speaker A: And so it's used for transaction call data. So essentially call data is the data that's passed into a contract when you're making a function call. And so the encoding is such that you have a four byte function selector. So it's essentially the compression of the function signature. So you do a hash of it, take the first four bytes and then you have the parameters of the function are then encoded after that function signature or function selector, should I say. And so, for instance, if we were calling do stuff with that address and that integer value, then the overall encoding would look like that. And so that's what you end up submitting.
00:04:15.540 - 00:05:05.790, Speaker A: And so you can think of you've got that function selector and so that's only four bytes long. So because it's four bytes, 32 bits, you are going to have collisions. So you will find that there will be lots of different functions with different names, different parameter values that will all collide to be the same hash. But this doesn't matter because those function hashes are just used as a way of selecting which function to execute within a contract. So it's only contract scoped. And so normally contracts, say, maybe have a dozen, maybe even two dozen functions, but they don't have millions of them. So having collisions is okay, because when you've got the sole C compiler, it'll tell you if you've got a collision and essentially say, hey, you need to change the name of that function because it collides with this other function.
00:05:05.790 - 00:06:02.380, Speaker A: The other area that it's used in is return values. So when you're returning a value out of a function that is actually encoded using abi encoding, so for instance, if you're returning that address and that integer value, then that's what it looks like. And the thing to notice here as well is that you've got padding at the front of that address. So the address is only 20 bytes long, not 32, and we're sending back whole slots worth of data. So whole words, you are Pading out values that are smaller than a whole word, so that they fill up to being a word. So padding with zeros. And so as well, the other area that you use abi encoding is returning error values.
00:06:02.380 - 00:07:07.616, Speaker A: And so, say if you've got a call, say from an EOA, so you've got, say, using MetaMask on your phone, you're calling a contract A, which calls contract B, which calls contract C, then if there's a revert, say, from contract B back to contract A, then that revert information is passed back as encoded return data. And so you'll have success or failure, and you'll have the actual encoded return value. And so if the function executed correctly, success would be true and return encoded would be the return value that came out of the contract, which is what we just saw. But if it's an error, then you return something a little bit different. You return essentially as if you're doing a function call. So you have the function selector followed by data. And so the function that's actually returned depends on exactly what's happened.
00:07:07.616 - 00:08:20.916, Speaker A: So if you've got to revert the string, then the function that's returned is error bracket string. And you can have custom errors in your versions of solidity. You can also have panics as well, which are caused by either asserts or certain conditions happening. So for instance, there are a whole stack of panic codes, for instance dividing by zero. And so that is another way that you can have Abi encoding is by encoding that function selector panic brackets, you went 256 and then the actual integer value returned after it. This is showing an example where if you look at this code here we've got result info is a custom event that is going to emit whether we've had a successful failure and bytes being the return value. And then we've got a function which is going to cause a panic if b is zero because it's going to have a divide by zero error.
00:08:20.916 - 00:10:02.212, Speaker A: And so if you call the function catch panic, what it does is it goes off and calls. So encode with functionselector is going to call that function there and then it's going to call it and because b is zero you're going to get a panic. And what this means is that returning coded is going to contain that error information and so you get that value there, the four e, four eight, seven, b 71, which is the function selector for panic, and then the actual x twelve, which is the error code for divide by zero error. And another area you have is event parameters, so the actual event signature, so the full 32 byte value is stored separately to the actual parameters. And so any of the indexed events in fact are stored as separate indexed thing indexed values. So you've got the event signature as an indexed value and then any other parameters that are indexed are indexed values, but the non indexed values are abi encoded and stored as event. So for instance, if you look at that result info bool comma bytes, you're going to store that information in the transaction receipt as a bytes API encoded, you can also do application specific usage.
00:10:02.212 - 00:11:07.810, Speaker A: So within some code that you've got, you could choose to use the abi encoding as well. And there are a few different situations where that's quite useful. So how does it actually work? So there are elementary types and dynamic types in solidity and so all of the elementary types will fit into 132 byte word. And so you've got values that are right aligned, such as bill address and all of the uint and int values, and then you've got left aligned values which are things such as bytes, which are fixed length bytes. So bytes one to bytes 32. So they're all deemed elementary types. And yes, so as I was saying, so for a UN 16, you're going to be storing it and it's going to be zero filled out to the left, whereas if you had the same value but as a bytes two, it's zero filled to the right.
00:11:07.810 - 00:11:26.580, Speaker A: There are also structs and so structs are encoded as if they were just a tuple or tuple. Okay, David, you're really up on these sorts of things. Is it tuple or tuple? Never really known.
00:11:28.040 - 00:11:30.900, Speaker B: I think that depends where you come from. I would say tuple.
00:11:31.960 - 00:12:18.320, Speaker A: Okay, all right, let's vote for Tuple and we'll find out if it's New Zealand English or if it's Australian English or what. Anyway, I'm going to go with Tuple. I was thinking Tuple, but I've never been too sure. Okay, so they're encoded as a Tuple. All right, so the elementary types, when you're encoding are encoded in place, but the dynamic types are encoded as an offset, and then with the actual content, then separately encoded as an element in a tuple. So I think I changed my order of my slides. So I haven't actually introduced dynamic types, but trust me that dynamic types are more complicated.
00:12:18.320 - 00:13:22.120, Speaker A: And so what you end up doing with dynamic types, rather than having them encoded in place and then say if B was a UN 256, you would just encode it as if it was just another value. But instead, because it's a dynamic type, it's encoded separately outside of the raw types. And so as we've talked about so functions, how you've got those function selectors, which are four byte values, and the parameters are encoded as tuples of parameters. So they're sort of one after the other. So dynamic types, so we've got bytes, strings and arrays. So a string is just a byte, where you've just got a character array that's utf eight encoded. And so each of the dynamic types are encoded slightly differently.
00:13:22.120 - 00:14:42.576, Speaker A: And so for a bytes or string, the first slot is the length of the bytes. So how many bytes do you have? And so, for instance, if you only have two, then that length is two, and then it's followed by the actual contents of the bytes. So zero x twelve, and then zero x 34. If you've got an array of elementary types, then you just have the number of elements followed by those elementary types, one after the other. And if you've got an array of Structs that only contain elementary types, then the encoding of them is really very straightforward, where it's the number of elements and then they're just serialized one after the other in place. But if you've got an array of dynamic types, then you end up having the length of the array and then the offset of the actual information and then the actual array element. And so then what we're getting is the number of elements that you've got in the array.
00:14:42.576 - 00:15:20.076, Speaker A: And so then we've got the offsets of the actual contents of that piece. So for instance, because we've got a bytes, it's going to have a length and then the actual content. So the first thing to do is have the offset of AB, which is 60 hex, and then offset of def is a zero, which is down here. And I'm moving my mouse around. Can people see my mouse? I can see. All right, brilliant. That makes life that much easier.
00:15:20.076 - 00:16:14.320, Speaker A: And then similarly for the last element, it's e zero, and again, it's just encoded in a byte. So length of bytes followed by content. And so if you've got an array of structs that contain dynamic types, then what you've got to do is you've got to encode it a little bit differently. You say, oh, that's wrong. So you see where it says three there? That should be a two, because the number of elements in the array is in fact two and not three. And then you have the offset of the struct because it's not fixed encoding length because they're not only simple types. Within the struct, you have to encode the whole struct as dynamic.
00:16:14.320 - 00:17:11.428, Speaker A: And then within the struct, though, you have got that simple type and then the offset of that dynamic type. And the offset you note is relative to the start of the struct. And what this has shown you is and then you've got the length of the bytes and the actual bytes. So what this has shown you is that the abi encoding sort of encapsulates so you'll have, say, an inner blob that is encoded and then that is inserted inside of some larger blob. And so you do the inner encoding relative to itself. And then once it's put in the larger structure, say, for instance, this Array, then you're surrounding it by a larger encoding and it's relative to, so Frank says, looks like an inductive encoding scheme. Could be.
00:17:11.428 - 00:18:09.670, Speaker A: I don't know that I'm not familiar with that term, but that sounds if you say it is. Frank I'm sure it is. So putting all of that together, say if you've got a struct lots that has an address, a bytes and a uint T 56, then we've got a dynamic struct. And so if we have a function that's got a dynamic struct and then a Boolean value, then it's going to be encoded like this. So the first thing we get is the function selector, nice and simple. And then the next thing we've got is the actual offset of that dynamic struct, which is going to be at 40 hex and then the value of the Boolean. So let's assume the Boolean is true, which means it's one.
00:18:09.670 - 00:18:51.110, Speaker A: Okay? So then within the struct, we've got the address and then we've got the bytes. So the bytes is going to be encoded as an offset within this struct. And then you've got one, two, three, which is the integer value, and then you've got five characters in the bytes and it's ABCDEF or E ABCDE, where 65 is e because it's lowercase e, and that's the hex encoding of ASCII. Okay, does that make sense?
00:18:55.800 - 00:19:11.050, Speaker B: Yeah, I think it makes sense. Peter I think it does make me wonder why they could put all the blobs at the end and just have sort of the layout with all the offsets in it and have just all the blobs at the end. So I wonder why they sort of intermix them, but I guess it doesn't really make a big difference.
00:19:12.220 - 00:19:57.770, Speaker A: Yeah. The idea was to minimize the amount of the number of steps required, the number of reads required to analyze a blob, but why you wouldn't have all of the offsets at the start. Then I guess you've got to try and come up with some structure behind where things are in the blog. So there was an Abi one encoding, and this is an Abi two encoding, which took over some about a year. I mean, it was provisional or experimental for years, but it's officially taken over as, I think, startup. 0.8. Yeah.
00:19:57.770 - 00:20:51.370, Speaker A: Okay. So abi and decoding unknown data. And this is part of a root cause analysis that I did. So what do you do? That's the transaction that has hit your contract and that has removed a whole heap of all your funds. Someone who was a solidity dev out there had been working on this for 24 hours, going, I have no idea what's happened. And so this really happened about a week and a half ago. And this transaction, if you went to that link, you can see the transaction and try and work it.
00:20:51.370 - 00:21:14.690, Speaker A: So all right, so what does this look like just looking at this? I don't know. Frank, I know you've been active on the chat, but what are your thoughts when you look at this? When you look at, say, the zero and one line, what are you thinking you're seeing?
00:21:17.620 - 00:21:19.296, Speaker C: I don't have my glasses, so I.
00:21:19.318 - 00:21:24.370, Speaker A: Can'T tell that's good.
00:21:25.720 - 00:21:27.860, Speaker C: What do you want to know more precisely?
00:21:28.360 - 00:21:32.516, Speaker A: Well, what do you think you're seeing based on what you've learned so far?
00:21:32.618 - 00:21:33.670, Speaker C: The call data.
00:21:34.040 - 00:21:39.448, Speaker A: Yeah. What is the data structure that's probably.
00:21:39.534 - 00:21:46.570, Speaker C: In here according to what you showed it's? I don't know, two elements of something.
00:21:48.220 - 00:21:51.400, Speaker A: But how are you getting to I mean, but this is the hack.
00:21:52.320 - 00:21:54.636, Speaker C: This is the hack data. I don't know.
00:21:54.818 - 00:21:58.240, Speaker A: Yeah, I don't know. Does anyone want to venture a guess.
00:21:58.310 - 00:22:02.370, Speaker B: At an array of 20 elements or 32 elements or something?
00:22:03.300 - 00:22:32.330, Speaker A: Well, that's certainly a possibility. And if it was an array of 30 elements, though, then that would imply that five is an offset. But so is this big long number here, and yet that big, long number there looks like an address. So my thought was that that is actually an offset of a dynamic type of some sort, some sort of dynamic something or rather.
00:22:34.540 - 00:22:39.630, Speaker B: Signature could tell us the signature of the method they're trying to call would help us here.
00:22:40.000 - 00:23:42.320, Speaker A: It would if you had it. But if all you've got is that function selector, there's a website which we're actually going to talk about later, called Four Bytes, and you can put in function selectors. And if someone has put in what it was, so you could put in your function signature and then you're essentially registering that function selector. But hackers may not have decided to register the function selectors they use and in fact a smart hacker would make sure that it was definitely not in the table because it just helps you. And surely they want you to take as long as possible to try and decode what nerf they've done. But yes, understanding the function signature would be great, but right at the moment, let's assume that we don't know what it is and I didn't when I first looked at it. So if it's an offset, so that means now we're looking at five and whatever.
00:23:42.320 - 00:25:35.140, Speaker A: And I think your thought that five could be the number of elements in an array looks pretty good because that would be 12345 and those numbers do look like offsets, don't they? So maybe a number of elements in an array and then offsets of an array of dynamic types or a structure containing dynamic types looks possible. So that does look like an address, doesn't it? So then if that's an address, then this looks like the offset of some sort of dynamic type within a struct and then six C four. Is it an integer or is it a length? Very hard to know at this point, but if it was, then that would mean that all of this below here is the contents and it's something to think is that that six C four is less than say, seven E zero minus a zero. So could fit into there, which could imply that it probably is a length of a bytes. And so that starts to make us think, all right, so maybe this is a struct which has got an address and bytes in it. Maybe. And I think one thing I've missed out here is there could have been other things after the bytes, but if you do the calculation of 700 minus a zero -20 hex for the address and the 20 hex for the offset, then I think you end up with that value.
00:25:35.140 - 00:26:31.392, Speaker A: So you know that there isn't anything after that. So this then sounds like we've got a function which is taking an array of address comma bytes as a parameter. And so if you do look at that four byte website, then you see that there is actually a function called multicall, which takes an array of address comma bytes. And so looks like we're onto a good thing here. And in fact there's a project called multicall and what it does is it takes an array of address and bytes and it's aiming to allow you to aggregate the return values of many view calls. So you can think you could do one view call, then another one, then another one, then another one to work out a whole heap of information. But that's going to be multiple, say infuria calls and it's going to be more latency.
00:26:31.392 - 00:27:48.844, Speaker A: So wouldn't it be good if you could put together all of the view calls you wanted to do all in one go and so that's what that does. But obviously this has changed the state of a contract. So though they might have used multicall as a starting point, they've obviously modified it so they can do extra stuff. And so I'm not going to go through all of the rest of the decoding, but one of the things that became apparent was that it was actually quite recursive with function calls within those function calls. And so one of the function calls was quite an interesting one given we're doing abi decoding and it was using Pancake swap v two with this function selector. And so I again had a look at that four byte website and it said, well there's this function called swap extract tokens for token, supporting fee on transfer tokens with this big long signature instead of parameters. And so I then sort of applied that possible function signature in looking at the information and lo and behold it does seem to be the right thing.
00:27:48.844 - 00:28:59.968, Speaker A: And not only that, the amount of tokens that were stolen from the contract just happens to be the first parameter. So we do seem to be onto a good thing. And so you've got two uint, 250, sixes, then the address of the array, and then that address, and then you went 256, and then down below you've got the number of elements in the array and the two addresses of the two contracts involved. So just by knowing the function signature it then makes it much easier to try and decode. So I've written up the overall hack analysis for those who are interested, including all of the decoding of the inner data, an analysis of why the hack happened, how the hack could have been prevented on that website. Okay, so what about solidity so applications and abi encoding? And so as well as the simple encode and decode that we talked about briefly, there's encode packed. And so this encodes information without padding.
00:28:59.968 - 00:29:51.092, Speaker A: And so by going say encode packed, it means that the number of bytes you're going to end up with will be smaller. And that's important because you pay for memory in solidity. So the more memory you use up, the more memory expansion costs you have to pay as well. For KCAC, the more bytes you're hashing, the more you have to pay. So you're better off having as few bytes as possible to hash. Hence using encode act, another function that's available is encode call, this is a recent one. And so imagine that there's a function, say transfer, that takes some parameters, then encode call, which is here, abi encode call.
00:29:51.092 - 00:31:14.412, Speaker A: What this does is it takes the actual function and then the parameters and it type checks the parameters. So assume this must happen at compile time, but it allows you to be more sure that your parameter list here is going to match the function you're calling. And so obviously this example is just calling something within the current contract using external call, but it could equally be applied for a cross contract call. And so Abi decoding is an interesting one that you can also use this as a way of doing dynamic typing with functions. And so you could imagine, say, you have signature and signatures, and where signatures contains a type and then a set of signatures. And potentially you could imagine you could have different signatures available, so different structures for the different types of signatures that might contain different information. And so with your decode signatures, you could imagine you go Abi decode and then you decode just the first two slots of that overall structure.
00:31:14.412 - 00:32:19.652, Speaker A: And so the first slot is going to contain the offset of the dynamic type being signatures, and then the second one is going to contain the actual type. So you skip over the dynamic type offset because you don't care about that. And then you just grab the type information and then assuming that it's the correct type information, you proceed and you decode the actual overall structure. And you could imagine, you could have conditional logic where depending on the type, you do different decoding. Okay, so when I've been preparing this talk, I've had a look at a variety of resources. And so the obvious one that you should have a look at is the actual Abi spec that's with the solidity documentation and that four byte database is certainly very useful. There are two Abi encoders decoders online and I had problems with both of them.
00:32:19.652 - 00:32:42.830, Speaker A: So I'm not sure whether you'd almost classify them as anti resources because you could go and use them and thinking that you've got the right thing, but then they might do the incorrect encoding or decoding. So I'd be a bit wary of using them directly. And before I talk about future talks, are there any questions?
00:32:49.260 - 00:33:06.990, Speaker C: So, yes, I've got a question related to the way you found the root cause of the bug. So you started from investigating the data and the Abi, and then just roughly what did you do? How did you diagnose the.
00:33:11.380 - 00:34:03.584, Speaker A: So I went through to analyze what all the transactions were that were being passed into this multicall, and then one of them was a call to the actual ERC 20 contract. So obviously that was the function. And then backing that up, there was a transaction trace. Trying to look at the finance blockchain's, block Explorer. I was searching and searching because normally you can find the inner transactions really easily, so you can have the overall external EOA transaction and then there are inner transactions and being able to find that would have been really useful. But it was only after I'd already decoded everything that I said, oh, what's that button way over there? And that turned out to break down the inner transaction call path. But by then I already knew it.
00:34:03.584 - 00:34:45.392, Speaker A: So it showed that there was a function going into the ERC 20. And then when I told the developer, hey, there's this function that it's being called. I don't know what it does yet, I haven't looked. But then just looking at that, they said, we're not checking for the allowance. And so by not checking for the allowance in an ERC 20, they were allowing any party to transfer on any behalf of any other party. So what they did is they just transferred a whole heap of tokens from essentially the treasury to themselves. That was what I did was actually pretty simple.
00:34:45.392 - 00:35:37.480, Speaker A: Just understand what's been called. I did have a bit of a go at decoding or decompiling the contract. And we did use a bytecode decompiler and that was helpful. But at the end of the day, that was how it unfolded, was going, all right, that's the function going into the ERC 20. Let's just have a look at the code. And I can see in the comments Hayden has recommended a thing called Panorama Mix abid decompiler, which could be useful. Yeah.
00:35:37.480 - 00:36:21.810, Speaker A: And then there's someone else's got one, got their favorite one as well. All right, so there's obviously quite a few out there, and it would be lovely at some point to try and work out which are the good ones and bad ones. But I guess the fact that you're recommending them sounds good to me. Are there any other questions? Okay. All right. Future talks. So, next week on the Gold Coast in Queensland, Australia, there's going to be a small conference.
00:36:21.810 - 00:37:19.890, Speaker A: And so it's an in person event. You can register, find out more information by going to that linksymposium Dlt.org. In the day after that, Omeus is going to present his talk on cross chain security. We've got one of the PhD talks about DeFi enabled data marketplace, and I think the idea of owning your own data, we get another PhD talk, which is about accounting and blockchain. And then I've got my advanced solidity test that I plan to do. So I've almost got that ready, but anyway, it should be interesting. My hope is that no one will find all of the issues in the code and everyone will be left scratching ahead.
00:37:19.890 - 00:37:43.882, Speaker A: So I think that'll be good. And then right at the start of the year, we're going to have Ben, who's going to do a talk about the proto dank sharding. And so essentially the future of scaling in ethereum. Okay. And one. Yep. So this meetup, if you're watching this on YouTube, you can join the meetup.
00:37:43.882 - 00:38:08.458, Speaker A: Anyone can by going to that link and registering. If you're here, you can watch the recording on YouTube. There's a slack workspace. So please join the conversation. Ask questions by joining the slack workspace. There is example code. So all of the Abi encoding stuff that I did today is in that repo.
00:38:08.458 - 00:38:49.950, Speaker A: And Frank and others run a. Formal methods reading group where they go through. So if you're interested in that, join the Slack workspace and then join the FM Reading Group channel within that workspace. And are there any other questions before we close off today? No? All right, we are all good. Is it rude or rudd? It's pronounced rude. Rude. Okay, so rude.
00:38:49.950 - 00:39:21.158, Speaker A: And Hayden, I'm going to post the video in about, I don't know, sometime in the next 24 hours. It would be fabulous if you could post as comments your recommendations for other abi decoders and stuff, because I think people seeing comments about, well, what are these tools? Because they're not going to see the chat. I think that would be really helpful for people. So it would be great to do that. All right, well, great. Thank you, everyone, for joining the call. Have a great day and talk to you all later.
00:39:21.158 - 00:39:23.500, Speaker A: Bye bye, to.
