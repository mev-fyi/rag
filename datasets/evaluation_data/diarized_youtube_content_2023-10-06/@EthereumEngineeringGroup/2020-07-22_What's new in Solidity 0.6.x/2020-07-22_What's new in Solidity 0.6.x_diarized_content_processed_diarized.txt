00:00:00.330 - 00:00:27.640, Speaker A: You okay? Hello and welcome everyone. I'm Peter Robinson, and this is the Ethereum engineering group meetup. So today I'm going to talk about solidity 0.6 and the other minor releases that have happened since then. So we're up to 0.6 point eleven. So there have been a lot of incremental features, plus the major breaking feature as that came with 0.6.
00:00:27.640 - 00:01:10.290, Speaker A: So this talk has a few examples in it. And so most of the examples are in that repo, which the link is there. And I'll upload these slides after the meetup today and I'll attach to them to the meetup, and also they'll be attached to the YouTube video as well when it's released. So there is a pretty big agenda. There's a lot of different things that have been released with 0.6. So yeah, let's dive straight in. So try catch.
00:01:10.290 - 00:02:25.462, Speaker A: So try catch seems like something from Java and so it feels like it's similar, but it's a little bit different. So you can see there you've got try and you are calling a function in a separate contract and sorry, I'll just do that. You've got a function in a different contract that you're calling. And so if an exception occurs in that contract, then you will go to the catch part of the code there. And if you don't have an exception, then the code before the catch and after that bracket is executed. So this code is executed. And so it's important to realize that the code before the catch and after the bracket there is not going to be caught.
00:02:25.462 - 00:03:35.090, Speaker A: It's only that function call, that external function call which is caught. And so if you have a revert there where the text is, it won't be caught. Another thing is that I've shown doing a try catch calling an external function separate contract, but you can also use it for catching exceptions that happen within the current contract. But if you want to do that though, you're using this. And so when you're using this dot function that's in the current contract, you're actually forcing it to solidity. To do an external call to your own contract that costs a little bit more, not a lot more, but it costs more gas to do it that way. But by doing that, you're able to catch asserts and reverts that happen in the functions.
00:03:35.090 - 00:05:07.934, Speaker A: In addition to calling functions that don't return values, you can call functions that do. And the way to do that is shown here where you have the function you're calling and then returns and then the return value, and then you can use that value there within the code for the positive use case. So you could of course have defined that variable v prior to the try as well. So that would be another possibility. You can also deploy contracts, and so contract deployments can revert, or they could have, could cause an assertion failure as well. And so you can deploy a contract and use the returned deployed instance, and then either store that, put that in storage, or you could emit an event. And so when you're looking at these, the execution, and you're, you know, I'm saying it's called an exception is being thrown, you've got to think that actually we're talking about reverts and asserts and requires.
00:05:07.934 - 00:05:55.780, Speaker A: So requires are essentially revert with a conditional. And so with revert and require, you can also have a reason string. And so if you want to, rather than just generically catching. So in the previous slide, you'll see that we just had a generic catch here. So rather than having just a generic catch, you can catch the actual type of error that has occurred. So you can catch the actual reason string. And if you do that, then you could then process that reason string separately and maybe return it or store it or do something with it.
00:05:55.780 - 00:07:10.890, Speaker A: There's also catching of the low level data that's associated with an assert or revert. And I know I've tried using that particular part of the feature, and I was not able to actually see anything, so I was always seeing a zero length bytes value. So maybe I was doing something wrong, but I don't think so. The first one, the error, the string memory reason, that was for revert with reason or require, where it fails with a reason, and the other is for reverts without a reason, require without a reason, or you can do an assertion, or you might have something that caused an assertion failure, such as a divide by zero or a modular by zero. Also, if you run out of gas in the call, but there's still gas left in the transaction, then you'll get to here. So how you can do that. So if the whole transaction runs out of gas completely, then this catch code won't get executed.
00:07:10.890 - 00:08:26.850, Speaker A: And so what you could do though is you can pass in, as you can see here, and specify the amount of gas to transfer to the function or to a make available to the function. And so gas left is a function that can be called it at any time, and it says how much gas is still available at that point of execution. And so you could have a variable which says this is the amount of gas to keep. And so the reason why you wouldn't necessarily hard code the gas to keep is because opcodes change in cost from time to time. So having this programmatic would be, I think, the way to go. And so you're passing in how much gas the function can use, so that then you've got some gas left over to process any errors, in particular out of gas error. So I guess you've got to think about the overall application and how it's architected to whether it would be better to just have the whole transaction fail due to out of gas, or whether you would just want that individual function call to fail.
00:08:26.850 - 00:09:29.814, Speaker A: So if you want to look into this area more, so there's an open zeppelin forum article on it, and then there is also a solidity blog article on it. Another feature which is new is inheritance and abstract contracts. So we've had interfaces in solidity for a while, but with 0.6 you've got slightly different meanings. So in particular there's the virtual keyword, and you don't actually use the virtual keyword in interfaces though. So functions that are in interfaces automatically have virtual associated with them, and that means that they need to be overridden, which I guess is no different from previous versions of solidity. However, you can have an abstract contract in 0.6
00:09:29.814 - 00:10:47.120, Speaker A: and later, and so abstract indicates that the contract should not be deployed. So it's indicating that some other contract is going to actually be the final implementation. And this contract is just provides some functionality, but it's not final. You specify abstract and then as well you've got override is another keyword. And so override indicates that a function implements a virtual function. So for instance, the interface override virtual indicates that you're implementing the interface or the virtual function, but you also want to allow other contracts which derive from this contract to implement their own version of the function. So specialize it, if you will.
00:10:47.120 - 00:11:52.226, Speaker A: You could have define a new function in an abstract contract which is virtual, and provide an implementation. And that indicates that essentially you've got a default implementation which other contracts that extend this contract can choose to use or choose to override. You can also have virtual without a function defined, and then it's essentially like an interface function. So it indicates that you must provide an implementation for that function. Virtual is indicating that the function must be overridden. You can also have just normal functions that aren't virtual or overriding anything in an abstract contract. The key thing to think about though, is that if a function isn't virtual, then you cannot override it.
00:11:52.226 - 00:12:57.770, Speaker A: And so if there was a function of the same name in one of the contracts that derives from this contract, then you'd end up with an error, a compilation error. If you want to access the function that essentially, if you're deriving from a contract and the function is derived, defined in that other contract, then you can use super to call back to that instance or that implementation. But something to note is, though, that the function that you call has to be public. Because what you're doing is you're doing an internal call to the function. Rather than if it was just denoted as external, then it would only allow for external calls. So you need to have it public. So it can be both external and allow for internal calls.
00:12:57.770 - 00:14:17.880, Speaker A: You can also specify the interface or the implementation or the other contract which is being overridden. So, for instance here, function three, or funk three, was defined in the interface that I called interface. And so you could specify that here. And so another thing that I think I've sort of mentioned, but not explicitly, is that when you're overriding a function, say, in an interface, it could be external or in an abstract contract. Again, it could be external. When you override them, you can change from external to public to essentially allow for internal calls as well as external. So this slide shows a class or a contract hierarchy where you have contract C is both a and B.
00:14:17.880 - 00:15:53.522, Speaker A: And you'll note that both of those contracts define funk one. So then funk one is going to override both of the contracts and the functions funk one in both of those contracts. So in this situation, if you want to call and call down to the a one version of funk one, then rather than using super, you would use the actual name of the contract that you want to call it. Another interesting feature is that when you have a variable, a field that is in storage, and you define it as public, then you automatically have an accessor function created for it. This constant here, because it's public, you would automatically have a function called version created, and you could access the value. So in an interface, you can define the actual function that would have been created. And you can then in the derived contract.
00:15:53.522 - 00:17:01.892, Speaker A: So b, you define that constant as override. To indicate that you realize that the function that's created automatically for this variable is going to be overriding that function that's defined in the interface there. So this one here is when you're doing a constant, and hence you're returning a pure type of function. Additionally, you could have a state variable there, and you'd then be using a view because you'd be reading state of the ledger. Another change that has come in at 0.6 is that you're not allowed to shadow instant variables. So in solidity five, you could have had actually that shouldn't say interface A, it should be contract a there, but you couldn't have contract a having a variable called state, and then contract b having a variable called state.
00:17:01.892 - 00:18:18.824, Speaker A: So that would have worked in solidity five. In solidity six, that'll cause an error. And all of this virtual and override logic applies to modifiers as well. So if you've got a function modifier, then you can override it and provide your own implementation in your derived contract, and more information is available there. So EIP 165 defines a standard method of publishing and detecting what interfaces a smart contract implements. And so if you recall that function selectors are 32 bit truncated message digests of function signatures. EIP 165 defines an interface identifier, and it's the xoring of all of the function selectors for the functions in an interface.
00:18:18.824 - 00:19:49.092, Speaker A: So it's trying to, in just 32 bits or four bytes, define all of the functions that exist in an interface. And so to help implement EIP 165, a type ID or interface ID should I say has been defined. And so you can use type brackets, the name of the interface interface ID, to come up with that value that's needed for EIP 165. And so the reason why I think maybe this has come up now is that the deposit contract for Ethereum two has been implemented in solidity, and one of the things they did was they added EIP 165 support, so you could see for the deposit contract what version of the interfaces it supported. So for EIP 165 you've got an interface which is defined, and it defines a function which is supports interface, and then you pass in the interface ID and it's going to return true or false. And then the so then there's two ways of implementing it. One is using a mapping, and one would be just doing a lot of if then else's.
00:19:49.092 - 00:21:24.360, Speaker A: So assuming you're using the mapping, then you have this standard contract, ERC 165 mapping implementation contract, and so it has a mapping of all the supported interfaces, and then you see that new feature type brackets, and then the name of the interface ERC 165 interface ID being used. So you've got a mapping of the interface ID to true or false, and then you're using that to work out whether you support an interface. So how you use all of this is say you've got a class, for instance, remember how we had implementation which was abstract, which implemented the interface called interface. So it then to indicate that it supports that interface uses the interface ID feature. So yeah, as I said, rather than using a mapping you could use if then else style logic to indicate whether you support certain interface IDs. My speculation is that this will result in a larger contract. So how you could imagine this being used is maybe you've got a version one interface for a contract that has three functions, and then the version two interface maybe adds an extra function.
00:21:24.360 - 00:22:50.810, Speaker A: And so you've got implementations of your contract deployed to Ethereum mainnet, and some of them are version one and some of them are version two. So rather than having to have a big long list of which one's version one and which one's version two, you can use EIP 165 to work out which one supports which version of the interface. Another new feature is fallback and receive functions. So prior to 0.6 you had this idea of a fallback function which was called when the amount of data sent to in a transaction was less than four bytes or less than the length of a function selector, or if it didn't match any of the defined function selectors. So you could imagine you would have something like this where you're trying to catch when people send you ether, or when contracts or EOAS send you ether. Alternatively, you could implement some sort of proxy system where you implement no functions at all except for the fallback function, and then you're using some assembler to call the appropriate contract.
00:22:50.810 - 00:23:35.370, Speaker A: And if you're having a look at that assembler and thinking I'm not sure what is going on there, have a look. A few. About two or three talks ago, we went through a whole heap of the Ethereum EvM assembler, and that'll help you understand this slide better. So with 0.6, a new function called receive has been defined. And so when, say, transfer or send is called to transfer ether to the contract, it'd be called. So in particular it's called when the call data length is zero and the transaction value is nonzero.
00:23:35.370 - 00:24:31.460, Speaker A: And note that we don't have function receive here, it's just called receive. There's no function keyword, and it must be external, payable. There's also fallback. And so fallback is the fallback function. And again, there's no function, it's just fallback, it must be external, it can be payable. So it doesn't have to be payable the code gets called. Essentially if the function selector supply doesn't match any function selector in the contract, or if the call data length is between one and is less than three bytes, I think is a better way of saying it, but it isn't zero bytes.
00:24:31.460 - 00:25:13.488, Speaker A: Yeah, I think that last comment that I've got there called out a length is zero bytes and fallback function is non payable. I think that's wrong. I think it's where it's between one and three bytes, but not four. And have a look at there for more information. Yet another feature is immutables. And so the idea is that you can set a value in the init code fragment and that never changes. And so that is in the constructor and contract level variable assignments.
00:25:13.488 - 00:26:08.708, Speaker A: So you can only set a value once and you can't access it during the init code fragment execution. The idea is that you want to store this immutable value in code space to save gas so that you're not loading it out of storage. And so this code shows an example of how to use it. And so for instance, you can be, yeah, you can be setting a constant value threshold for two. And looking at that, that does seem to be the same as using a constant. So I'm not sure if there's any advantage of using immutable. In fact, I've got a feeling that it might be the same.
00:26:08.708 - 00:27:19.790, Speaker A: It might be worse. You can also call a function to come up with the value for immutable, or you can set it in the constructor. So fixed date, what happens is your contract, when compiled, will have some code that looks a little bit like this. And then when the init code fragment executes, it will get the value that needs to be put in for the immutable, and it'll actually copy it into the part of the code that it needs to be used in. So essentially at deployment time, your code is modified. So there have been some changes to how array lengths can be modified. And I think it's mainly a security thing.
00:27:19.790 - 00:28:24.996, Speaker A: And so now you can only use push and pop, and you need to explicitly get the length of an array. So if you're doing this where you're trying to get the length after a push, then you need to change your code to this. If you wanted to make an array bigger, rather than just adding to the length, you've got to do push. And if you want to make the length shorter, then you do pop. And if you were doing something like this. And so setting the length of the ray to be to be essentially two to the 256, so that you could write to any part of storage you liked by just putting in an array offset, then you're going to be disappointed because you can't do that sort of thing anymore. So array slices is the idea of getting a subset of an array.
00:28:24.996 - 00:30:00.520, Speaker A: And so for instance, what's shown there where you could get, say, starting at a start and end offset within the array, or from the start to the end to an end offset, or from a start offset to the end, and the resulting array that you have out of that you can use dot length to get the length of the array. The limitation at the moment on this is that it only works for call data, it doesn't work for storage or any other or in memory. And so you could use it, for instance, to get part of an array of the call data array, and so maybe the value after the function selector. So other stuff, one thing that's been added is forcing everyone to specify what type of license they've got. And so everyone needs to have this SPDX license identifier in their code to indicate what license is being used. And even if you're not using a license, it's possible to specify unknown as well. The formal verification code, or SMT checker is now being used automatically as part of solc Js.
00:30:00.520 - 00:30:35.940, Speaker A: So it does what's called SMT solving. And I'm hoping the people on the formal verification team who are on the call will know a lot more about this. And I think this is quite interesting, and it'd be interesting to get someone who's actually part of the SMT checker development team to actually give a talk at the meetup at some point. So it's only available in solc. Js not available in solc. It's currently experimental. So you need to use a pragma to turn it on at the top of your contract.
00:30:35.940 - 00:31:22.944, Speaker A: And what they've said about it is that it aims to satisfy the specification. So you define how you expect the contract to work using requires and asserts, and then it tries to check that and give you information. So, arithmetic, underflow, overflow, trivial conditions, and unreachable code. And given the rate of development that they seem to each and every release, there's some more checks that are being done. It's obviously inactive development. Other things that have happened. So gigawi has been added.
00:31:22.944 - 00:32:26.500, Speaker A: So whenever people talk about gas, it's all around using it for they always talk about gigawi rather than we or southbo or ether or anything. So you can now use cordata reference values variables for all functions. If you've got say a Uint 256 or something like that, you can use this type brackets the type and then dot, min or max to get the maximum and minimum. The function selectors are compulsory in constants now, so you can use them if you need to. Contract types and enums can be used as keys in mappings. So yeah, and the last one, so the second last one actually here. So enums and structs can now be defined outside a contract.
00:32:26.500 - 00:33:32.936, Speaker A: So you can have what this will allow is you to use the struct and enum across multiple contracts more easily. The last bullet point here is all around being able to use create two where you specify a salt for generation of a contract address. There's some small changes to the inline assembler. The compiler now outputs error codes for errors, which is good. That should hopefully help track down errors for people who are working on projects which have multiple directories and multiple groupings. And I know the Pegasus team X, R and D team, we ran into this problem and so they've added base path. So that should allow the contracts to do greater relative path into say access contracts that are in different parts of a source tree.
00:33:32.936 - 00:34:42.260, Speaker A: When you're doing say development with some common code and other modules, you can also output the storage layout now using the storage layout option. And so Natspec is all around code documentation and there have been lots and lots of updates on that too. And there have been a lot of bug fixes and a lot of optimizations. So look, in summary, you should be using the latest version of the compiler at all times. And the reason why you want to use the latest version of the compiler or any compiler is that there have been bug fixes that have been put in at optimizations, but in particular bug fixes. So if the compiler that's taking your source code to the byte code has a bug in it, then that's not good because then your bytecode is going to have a bug in it. So the more recent and latest version is going to give you the best outcome.
00:34:42.260 - 00:35:24.544, Speaker A: Let's just go there. There have also been some new features put in that will make your code less buggy, inheritance and fallback functions. Fixing up that I think is good and handling exceptions will also allow for new usages, new use cases. So that's good. So in two weeks time we've got Tim talking about EIP 115 59. Now Tim has injured himself. And so if we get to mid next week and it looks like he's not going to be able to give the talk at that time.
00:35:24.544 - 00:36:20.340, Speaker A: We'll probably defer that talk by a few weeks. Then in four weeks time, we've got Olivier and Alexandra. They're going to be giving a talk about a way of increasing their snark by speed, by 230 times. And so for those people in the US, it's going to be in the middle of your night, so you might want to watch the recording, or if you're super interested and want to be able to ask questions live, you'll have to be up late. And then in six weeks time, we're going to have a talk about Metamask. And then in eight weeks time, there's another talk that I'm planning, but that hasn't been finalized yet. And that is all.
00:36:20.340 - 00:36:22.070, Speaker A: Are there any questions?
00:36:28.480 - 00:36:37.520, Speaker B: Yes, I have a question. Is there a formal semantics of different new features that you've presented that's available somewhere?
00:36:40.260 - 00:36:44.960, Speaker A: I don't think so. I'm not sure.
00:36:45.030 - 00:36:53.350, Speaker B: There's no reference formal semantics of our solidity, what the meaning of a solidity program is.
00:36:58.440 - 00:37:04.728, Speaker A: I think that question, if we can get the SMT solver people on, I'm going to try and find out who they are so we can.
00:37:04.894 - 00:37:30.256, Speaker B: That's not related to SMT solving, it's the semantics of a language itself. Because you mentioned in your slides, you've got the description and blogs, or let's say the sections of GitHub repo, related to something. Do they contain formal semantics or just an explanation of how it works?
00:37:30.358 - 00:37:47.520, Speaker A: Yeah, it's just an explanation. So in the blogs it's reasonably loose. There is a read the docs thing, but it's a read the docs, which is another explainer, but it explains the whole language, but it's not a formal specification of the language.
00:37:47.600 - 00:37:53.960, Speaker B: But do you know if there is one? If there exists one formal specification of this language?
00:37:55.180 - 00:38:04.110, Speaker A: Well, and that's why I said, though, people who work on the SMT solver, I reckon that they would know if there was one, but I don't know of one.
00:38:05.840 - 00:38:42.810, Speaker B: Okay, so then I've got some reservation about your comment on making the code less buggy by using these new features. I would say it's more error prone, because if it's not, well, my feeling is it increases somehow. It doesn't increase the expressive power of the language, but many things that you have defined, and with your comments as well, for instance, immutable and constants. Oh yeah, that looks to be the same. But maybe not. Maybe yes. I don't know, with all these things you may write some code that's not as safe as before.
00:38:45.100 - 00:39:19.828, Speaker A: Yeah, look, I understand what you're saying, and I mean, the adding more features can make things worse, but I'm just looking at the number of bugs that they've been fixing, because I've been going through the essentially release notes for each release and I can see that they're fixing lots of bugs. But yeah, if there was a formal specification of the language, then it'd be clearer. But yeah, I don't think there is.
00:39:19.914 - 00:39:59.760, Speaker B: There's two things, right. The fact that if you don't have a formal specification of what a construct is supposed to do, it's not very clear what it's supposed to be doing. So when you use it, there's some uncertainty. And the second thing is in the compiler, when you implement it, because it's not properly defined, there's some freedom for the developers to implement it in different ways. And for instance, there's also some freedom for the compiler to do something that the verification engine will not match. So if a verification engine interprets something differently to what the compiler is doing, then your verification is void.
00:40:09.720 - 00:40:11.190, Speaker A: Are there any other questions?
00:40:16.740 - 00:40:43.930, Speaker C: Um, yeah, you mentioned that the rays now have, I mean, they can't be so big as they were to avoid that kind of overflowing and using it to access random parts of the memory. So what do they do now? Is it like there is a limit on the size?
00:40:44.700 - 00:41:32.452, Speaker A: Well, no, you just push a lot. I do believe, though, you can define an array with a static size. So you might be able to still define a static size that's that large. I think the idea of programmatically redefining an array size was probably deemed to be an attack because maybe someone would somehow write code that would take the array size as a parameter or something crazy like that. I don't know. That's yet another thing to try out. You could probably define a super large array that would essentially be able to write to anywhere in memory.
00:41:32.452 - 00:41:41.790, Speaker A: Though doing that doesn't really help you because you're just within your own account, and so it's not like you're writing to another account storage or anything.
00:41:44.480 - 00:41:58.720, Speaker C: Well, I saw examples of that being used to overwrite, and for example in an ERC 20 contract, you can then use that to affect an address that is not the one that should be affected.
00:42:01.860 - 00:42:25.450, Speaker A: But that would be using it to. But that's within the ERC 20 contract. So if you had an ERC 20 contract which also happened to have an array. That was the whole of the address space. Then you could change people's balances. But that's because you've got really silly code. Yeah.
00:42:25.450 - 00:43:11.940, Speaker A: Are there any other questions? No. Was that valuable? Did people learn anything new? Update code. Now a question then, for the. I don't know, Roberto, Joanne, Frank, should I try and hunt down the SMT solver people and get them to give a talk? Would that be valuable or not so much? What are your thoughts? I think it would be interesting.
00:43:14.630 - 00:43:43.340, Speaker B: Yeah, it's interesting. The technique that you report on using SMT solvers to design software, model checkers. It's not new, so it's been on for ten or 15 years. So it would be nice to know what variations of these techniques they have implemented, what Smt solver they're using, and so on. But this is not new, right? This is something that's been available for other languages for many years.
00:43:44.030 - 00:43:47.422, Speaker A: Okay, well, solidity is only up to 0.6 once they're up to one.
00:43:47.476 - 00:43:52.080, Speaker B: No, it's very nice to have this for solidity. I think that's a very good idea.
00:43:53.490 - 00:44:14.440, Speaker A: Okay. Knowing how they plan to integrate that into the language. Yeah. Okay. All right. I'll try and hunt them down. And if any of them are watching this video, please get in contact and it'll make my life easier, because then I won't have to try and work out who you are.
00:44:14.440 - 00:44:20.242, Speaker A: All right, look, thank you, everyone, for joining the call, and I hope you have a great fortnight.
00:44:20.306 - 00:44:20.934, Speaker B: Talk to you later.
00:44:20.972 - 00:44:24.050, Speaker A: Bye bye. Thank you. Thank you. Thanks, Peter.
