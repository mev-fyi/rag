00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:02.850 - 00:00:57.600, Speaker B: Hello and welcome, everyone. My name is Peter Robinson, and today I'm giving a talk on ERC 20 bridge design. And so I'm head of blockchain research at immutable, so let's share my screen. Okay, all correct. Let's lead off and talk about bridges. So, going to talk about the overall problem and then the bridge architecture generally and how that actually works, and then talk about some security features that I think all bridges should strongly consider having. And then I'm going to talk a bit about other things right at the end.
00:00:57.600 - 00:01:53.460, Speaker B: So many ERC 20 bridges have withdrawal functions that have no safety checks. And this allows anyone to transfer any amount of any token in the case of some sort of failure condition. And so you could imagine that an attacker could fake a withdrawal of some huge amount of money, and this invariably is what happened. So the failure could happen in the ERC 20 bridge contract, on the destination chain, on the target chain, could be in the arbitrary message bridge somewhere. So there's a whole stack of places that you could have an issue. So there have been massive attacks, as I'm sure everyone by now knows. Like, we've had the ronan bridge attack for 600 million.
00:01:53.460 - 00:02:42.670, Speaker B: We've had the Nomad hack 190 poly network, 600 million. And so you just don't want to do that to really drive it home. If you do a Google image search of Nomad now, you get this. And so when you do an image search for your project, you don't want to have people looking in despair and skull and crossbone sort of, you know, not. Not good. And so I guess the big thing to think about is that this sort of attack, if your company loses $600 million, it could well be a company ending event. So even if it doesn't take all the money of your company, it sure blows your credibility.
00:02:42.670 - 00:03:48.950, Speaker B: And so trying to work out how to prevent these sorts of attacks, I think, is really important. So, typically with bridges, in fact, you should design bridges. If you're bringing out a new bridge, you should design it this way, where you've got your arbitrary message layer is at the bottom. And so that is a bridge that will get a message from a source chain to a target chain, and then you build your application level bridges on top. So some people, I think, have made the mistake of tightly integrating the application bridge with the arbitrary message bridge. And the issue you have there is that if you switch the type of arbitrary message bridge, then you're in trouble because you've got this tightly coupled bridge. So you should have a degree of separation might cost a little bit more gas, but it'll make up for itself in flexibility when you change that arbitrary message bridge.
00:03:48.950 - 00:04:41.862, Speaker B: Another thing to consider is that bridges are unidirectional. So here we've got the immutable Zkevm and Ethereum. And so we've got one bridge from Ethereum to the Zkevm, and then separately we've got a bridge from the Zkevm to Ethereum. So they do not have to use the same underlying technology. They can be completely different. And that's a really important thing to comprehend, that you could have one set of properties for the bridge that's going from Ethereum to the Zkevm, but you could, say, be using a completely different system in the opposite direction. And so, for instance, you could effectively have some sort of multi sig from Ethereum to the ZkVM, but then in the opposite direction maybe you've got a ZK bridge or something.
00:04:41.862 - 00:05:39.514, Speaker B: So there are different ways of doing things, and so different opportunities and possibilities. When you think about how these bridges work, say you've got some ERC 20 contract over there on the right hand side on Ethereum, and say this is, say, the IMX one, and then you've got a bridge contract, and then another bridge contract on the ZkevM, and then a wrapped version of that ERC 20. So at a really high level, the user says, ERC 20 approve, then does a deposit into the bridge contract, which will take the money from the ERC 20. Some messages will go across. This ERC 20 will mint some of those tokens and give them to the user. So then the user can go get balance and see they've got some tokens at a really high level. That's how it works.
00:05:39.514 - 00:06:38.282, Speaker B: And so when people say, hey, our roll up or our side chain has got a billion dollars on it, what they really mean is that that amount of money has been bridged across, invariably using an ERC 20 bridge. And what that means is that this ERC 20 contract on Ethereum is the owner of a billion dollars. So it's a massive honeypot and is obviously then a massive target. So walking through the process in a little bit more detail, so your user goes, ERC 20 approve. They then say, all right, on the ERC 20 bridge they say deposit that does a calls transfer from. So now the ERC 20 bridge owns those tokens. It then calls the arbitrary message bridge to sync its state.
00:06:38.282 - 00:07:29.990, Speaker B: So essentially send a message that'll emit an event, have a multi sig which will put the message onto this chain when execute is called. So commit says, hey, this is a whole set of messages that have been emitted. And execute essentially does the exit. And so then in response to calling, execute, onstate receive is called, which activates that ERC 20, which does a deposit, which mints some tokens. And so that's the overall process for deposit, for withdrawal. So taking money from the Zkevm to Ethereum, you approve. Then you say, I want to withdraw money back to Ethereum, which does a burn of the ERC 20.
00:07:29.990 - 00:07:54.990, Speaker B: It'll do a sync state. So essentially saying, send a message to Ethereum and that'll emit an event. Those events get packaged up into a checkpoint. You submit the checkpoint, and then down here you say, all right, I want to do an exit. And you specify the exit. You check that the exit is valid by looking at the checkpoint. And then you say, all right, this message is valid.
00:07:54.990 - 00:08:49.090, Speaker B: And then you call out to the ERC 20 contract, or ERC 20 bridge contract, which does the withdrawal and then does a transfer of the tokens. And so in that way the user ends up with their tokens again. So if you look at where there could be problems in this whole withdrawal process, maybe there's a bug in the ERC 20 bridge on the ZKVM. Maybe there's a bug in the arbitrary message bridge. Maybe one of the validators gets compromised, so one of their keys gets stolen. Maybe the checkpoint manager, the thing that's getting their roots, gets compromised. Maybe the exit helper, which is helping to process the exits and check with the checkpoint manager, has a bug.
00:08:49.090 - 00:09:51.210, Speaker B: Or maybe there is a bug in the ERC 20 bridge on Ethereum. So a lot of places where things could go wrong. And so if there's a bug in any of these places, then possibly the attacker could steal that money. And so if you think of, say, the nomad hack, there was a bug in this ERC 20, actually in the exit helper, should I say so in that contract equivalent, and in the Axio infinity, it was, the validators were compromised. So even if you've got a ZK bridge, you're still going to have some sort of contracts, and there's not going to be validators doing this, but there's still going to be contracts here. So you're still going to have potentially problems even no matter what underlying arbitrary message bridge you're using. So hence the security features.
00:09:51.210 - 00:10:35.990, Speaker B: And so my thought is that what you want to do is just as the message is going out, the door. Rather the money is going out the door. You want to have some sort of hold on it. You want to be able to do things to try and protect yourself right at this ERC 20 bridge contract on the way out. And so the first thing is to have pausing. So essentially be able to pause withdrawals and deposits, but withdrawals importantly. And so you need to be able to essentially stop any of the actual money leaving.
00:10:35.990 - 00:11:22.690, Speaker B: You can imagine you've got an administrator with pause capability can pause withdrawals and then an administrator with unpause can unpause the withdrawals. So these administrators are quite likely to be multi sigs. You're not just going to give one individual EOA that capability. It's going to be some sort of multi sig, but it still comes down to an account somewhere in the system. And I think you want to have pausing to be easy. And the reason for that is that you can imagine that you're on support and it's 01:00 a.m. On December the 25th or some other day that's important and everyone's on holiday.
00:11:22.690 - 00:12:02.894, Speaker B: So you need to be able to pause pretty quickly and not have to try and communicate with lots of people. Unpauseing probably needs to be harder. So you can imagine an attacker could compromise some accounts and the last thing you want them to be able to do is you pause and then they immediately unpause and then complete their attack. That'd be awful. So you want to have unpause to be much harder than pause. Another security feature is to have a withdrawal queue. So in certain situations, a cross chain transfer results in a withdrawal being put into a queue.
00:12:02.894 - 00:12:43.854, Speaker B: And so users can withdraw the amount after a certain delay. And the default delay is one day. And so the reason for one day is, again, imagine yourself, it's 01:00 a.m., on say, December the 25th or whatever day is important where you live. And so you're there, you've detect the anomaly. You probably maybe want to consult with some people and maybe two or three people get together and say, hey, I think we've been hacked. Then you're probably going to want to get some important people within your organization up online and go, I think we need to pause the bridge.
00:12:43.854 - 00:13:31.840, Speaker B: And so you make that decision and then you actually pause the bridge. So that could take a while and so you want. But so one day feels like a reasonable amount of time to make that really big decision. But before that's happened, the funds haven't left the system, they're in this withdrawal queue. So one day I think hence is a good amount of time. And so a withdrawal can be put into the queue if the amount is larger than a certain threshold. And the withdrawal, if the withdrawal is for a token that there are no thresholds have been defined, then just put it in the withdrawal queue anyway.
00:13:31.840 - 00:14:56.250, Speaker B: But also it could just be that the withdrawal queue is enabled so everything goes in there. So the withdrawal queue can be enabled automatically if the rate or withdrawal of any token is over a specific threshold or manually if someone enables it, who's got the rate privilege or rate role. And disabling the withdrawal queue can only be done manually, so there's no automatic disable. Yeah, so an administrator who's got this rate roll, so they're going to configure the thresholds and they're going to configure the duration of the withdrawal queue. So the code that I've written changing the duration of the withdrawal queue affects everything that's in the queue. So the withdrawal time is checked when you're dqing, not nqing. So what that means is that say you put something into the queue and the delay is 24 hours and a withdrawal has been in there for 23 hours and then you say well we need more time.
00:14:56.250 - 00:15:35.240, Speaker B: You could change the withdrawal delay to be 30 hours or you could decide to make it less. So it's a way of giving yourself a bit of flexibility. So having all high values go into the withdrawal queue, it depends on the configuration. So it's on a per token basis. So you might decide that a large amount for one token is different to a large amount for another token. Potentially though I'm not sure if that really makes sense. You might want to try and have approximately the same dollar value.
00:15:35.240 - 00:16:47.440, Speaker B: The other important feature is flow rate. So imagine you've got a bucket and the bucket is being filled at a specific rate, a constant rate, and you're taking fluid or tokens out of the bucket using various size glasses depending on the size of the withdrawal. So if you ever empty the bucket then you have exceeded the flow rate. So that's the broad concept. And the flow rate is defined for configured tokens. So if the flow rate for any one token is exceeded, then the withdrawal queue is enabled for all tokens. So assume that the desire configuration is large, threshold is 100,000 IMX and you want a million IMX per hour.
00:16:47.440 - 00:17:57.750, Speaker B: And so assume the ERC 20 has 18 decimals, which is true for say iMX wrapped ETH Maddox. Then what you do is you set the capacity to being a million IMX with 18 zeros. And then you have the refill rate is a million per hour in seconds. So you divide by 3600, and then you just set your large threshold to be the value. And so something to think about is though, that 24 million IMX in a day is not the same as a million in an hour, because you're essentially saying, I'm going to have the same rate, but average over a larger period. So someone could do a 23 million IMX withdrawal in one go and it wouldn't trigger, whereas it would trigger if you had a million per hour. All right, so we're going to do a bit of interaction.
00:17:57.750 - 00:18:27.520, Speaker B: Is everyone ready? So I've got some attack scenarios. Have a read of it and let's have a think about the attack scenario. So I configure the flow rate for three. So what's the effect of configuring flow rate for an additional token? So, Sandra, what do you think?
00:18:33.090 - 00:19:09.660, Speaker C: I like being put on this box. I did give everyone that configuring the flow rate for three tokens. And then if you configure the flow rate for an additional token, I mean, at the moment, all the other tokens go into the withdrawal queue because they're not configured. So now you've got an additional token for which the flow rates need to be configured. So you'd think that you probably need to adjust the flow rate for the other three tokens. Perhaps, maybe. I don't know.
00:19:09.660 - 00:19:38.920, Speaker C: I suppose I don't really understand how these three tokens could potentially interact if I'm transferring across, because I just had the concept of having this one token, and you've got the flow rate, but you have the different ones. Maybe if you can, someone else should chime in. Yeah.
00:19:44.510 - 00:21:04.980, Speaker B: All right, I'm going to answer this one, but everyone else be ready because there's a few more scenarios. So you're right. You had three that were configured that could flow through without hitting the withdrawal queue. Assuming that they didn't go over their flow rate and that other token that's been added, any withdrawal of that token would have got hit the withdrawal queue because it was unconfigured. However, say if you've got equivalent to a million dollars an hour for those three tokens, and so you've worked it out and you've set it up to be a million dollars an hour, adding another token means you can do, say, a million dollars an hour for that other token. It means, though, that the attacker, assuming you've got sufficient balances, of all those tokens can now withdraw at $4 million an hour across all four tokens without triggering the withdrawal queue. So if you had, say, went from say, one token configured to 100 tokens configured, you've got to think, well, if I'm happy for it to be a million dollars an hour now, maybe it be allowing us to lose $100 million an hour.
00:21:04.980 - 00:21:12.760, Speaker B: So maybe I don't want to configure quite so many tokens. Does that make sense?
00:21:13.690 - 00:21:44.754, Speaker C: Well, I was just going to say. So I suppose I didn't have the concept that every single token would have the million Imex or whatever, because I thought that when you configure one you could decide whatever it is, but by setting a flow rate that's applicable to anything that's configured, because by the word configured, I thought necessarily add up to multiples of a million.
00:21:44.952 - 00:22:04.120, Speaker B: Well, that's true. They can each be configured separately. So you would configure say 1000 imX, 200 e per hour, say, and a million maddox per hour so you could configure it like that so they reach different.
00:22:07.150 - 00:22:08.220, Speaker C: Yeah. Okay.
00:22:09.550 - 00:22:35.180, Speaker B: All right. Second scenario. Ron, are you going to be ready to take one? Maybe not. All right, Tan. Hi. You'll be put on the spot in a few secs. So imagine this scenario.
00:22:35.180 - 00:23:14.920, Speaker B: I configure the flow rate for three tokens and so all other tokens will go into withdrawal queue because they're not configured. And the flow rates are a million dollars an hour or a million IMX per hour, 1000 e per hour and a million kick per hour. So what's the effect of this type of configuration and. Hi, can you hear me? What do you think?
00:23:17.290 - 00:23:48.640, Speaker A: For me, I think there is one effect. I mean, there's one problem that we need to consider is that we maybe need to think about the threshold for the total with flow freight for three tokens, the maximum and the minimum of the total withdrawal. Yeah. This is the issues, the problem that I think of.
00:23:49.030 - 00:24:45.810, Speaker B: Okay. Yeah, well, I mean, you do have to worry about the maximum for a token and there is no minimum as such. Like it could be zero. The interesting thing is I've included the kick token, which was a dud coin I think is atom or a shipcoin is another one. But anyway, it's a coin that's worth nothing. And so if you've got a coin, so if you could withdraw, just say one dollars in any hour, say, and it would activate the withdrawal queue for everyone, then even though no one much uses kitcoin, I could use it to activate the withdrawal queue for everyone. And it would be a way of forcing normal withdrawals of IMX and wrapped eth to go into the withdrawal queue.
00:24:45.810 - 00:26:43.368, Speaker B: Hence you've got to be really careful about which tokens you configure, because if you configure a token that isn't who's got really high price volatility or is really cheap, then, or uncertain value, it makes it very complicated because an attacker could use that token. All right, scenario three. Now, we've got a million IMX per hour, thousand wrapped e million Maddox. So approximately the same values of each of those tokens. And in the past 50 minutes, we've had 900,000 AMX has been withdrawn to Ethereum. And so how could an attacker, without risking their own funds, ending up in the withdrawal queue, trigger the withdrawal queue? How could you do that? Echo, are you online? And what are your thoughts? No? What about you, yun min? Do you have any thoughts on what the answer to this one might be? Okay, all right, I'll handle this one. So what you could do is you could observe the withdrawals happening and then you could try and front run.
00:26:43.368 - 00:27:21.636, Speaker B: So a valid user might be withdrawing, say, 50,000 IMX. So what you could do is if you could see that that was going to happen, you could withdraw, say, 55,000 IMX, so that then that 50,000 IMX withdrawal would take it over the limit and then that user in particular would then end up in the withdrawal queue and triggering the withdrawal queue for everyone. And so what that shows is the thresholds that you set need to be carefully set. Okay, Sandra, you ready to handle another one?
00:27:21.818 - 00:27:24.490, Speaker C: I don't think so. I think I messed up the last one.
00:27:26.620 - 00:28:55.166, Speaker B: All right, so you've configured the flow rate for a million IMX per hour, just one token. Historically, the flow rate was unexpectedly exceeded. And so, you know, we've got suddenly a whole heap of withdrawals that are in the queue. And then I temporarily withdrew, set the withdrawal delay to 1 minute and then cleared all those withdrawals. So if I've done that historically, what could the attacker do to steal all funds? If they could know that this is how I act and what I do. The complicated one, though, so maybe I'll handle it myself. Okay, how this one works is so the attacker would create a whole stack of accounts and they would start doing withdrawals, and then they just do enough withdrawals to trigger the 1 million IMX an hour.
00:28:55.166 - 00:29:33.990, Speaker B: But they may try and make it look like they were all valid, normal withdrawals, fitting the normal withdrawal pattern, then they would hope that I would then reduce the withdrawal delay to 1 minute. So to clear out those withdrawals and then they would do their 600 million dollar withdrawal like that and go straight through. So you've got to be really careful about the idea of say thinking, oh look, I'll just reduce the withdrawal queue delay to 1 minute so I can fix up this problem that I've got with all these important withdrawals having gone into the withdrawal queue.
00:29:38.490 - 00:29:50.860, Speaker C: Sorry Peter to interrupt, but shouldn't you have been able to pick up that these additional accounts, like fictitious accounts have been created to do these withdrawals? But it has been.
00:29:52.670 - 00:30:28.840, Speaker B: Yeah, I know what you're saying though. I think that often these attacks happen that someone might detect a bug and they might not act on it immediately and they might spend a month getting ready and so they could spend a month creating an account and then like a few hours later creating another account and just keep on creating the accounts and starting to do activity on chain that makes it look like those accounts are normal. So I reckon a sufficiently sophisticated attacker could probably do that.
00:30:31.050 - 00:31:04.370, Speaker C: And patient to sort of get the scenario. But then this reduction to 1 minute clear the withdrawal queue. Would that be a manual intervention or would that be obvious that that would have been coded to say that the one day providing these scenario, then it'll be reduced down to 1 minute? Because how would I know if I was the attacker that this is going to happen?
00:31:04.520 - 00:31:29.382, Speaker B: Yeah. So for this, this is a manual process, but if you can observe the processes of the company or the Dow or whatever group that are controlling the withdrawal queue, if you can see that this is what they've done once or twice before, then you could guess that they might do it again. It'd be a bit of a gamble.
00:31:29.446 - 00:31:31.802, Speaker C: But yeah, it would be a gamble. Yeah.
00:31:31.856 - 00:31:39.630, Speaker B: If you thought you could steal $600 million, then maybe it would be probably worth a bit of a gamble.
00:31:41.730 - 00:31:42.480, Speaker C: Yeah.
00:31:46.450 - 00:32:15.530, Speaker B: Okay. So one of the things about blockchain is it's all decentralized and staff, but here I am. I've talked about having this pause, a role unpause role rate. Is that a good thing or a bad thing? Having these admin roles in a bridge? Does anyone want to proffer thoughts on that one? I may try, yeah, sure, go ahead, Dora.
00:32:18.190 - 00:33:11.158, Speaker D: My general belief is that even though we do a lot of things in a decentralized way when it comes to web three, there are still stuff that has to be centralized. And given the fact that the bridge is a kind of insecure element of this system. Maybe sometimes it's good to have some administrative roles to kind of supervise it in a way I can see, like application specific roles and things like that. But obviously it can be always leveraged for malicious purposes, like everything else. That's kind of boys. It's good in a way that sometimes we need this supervision for certain activities, but it can be always leveraged. That's my kind of understanding overall.
00:33:11.158 - 00:33:12.826, Speaker D: But maybe I'm wrong.
00:33:13.008 - 00:34:09.858, Speaker B: No, you've echoed my thoughts after having said that. Then the next one is of course is contract upgrade good or bad? And I think everyone has the same vexed thing, that upgrade. You can imagine rug pulls and they do happen, but not doing is any software perfect. So automated incident response. So I think it's always worthwhile when you're looking, if you're going to operate a bridge, to be thinking about the 01:00 a.m. On December 25. And December 25 is a day that's moderately important in Australia, but think of a culturally significant date for you.
00:34:09.858 - 00:35:22.810, Speaker B: Devali Chinese New Year Yom Kapoor id it doesn't matter, pick your dates. But if a lot of people in your organization are going to be away on holidays and it's going to be difficult to contact people, then that's a great time. If you're an attacker, to attack the system and you can assume that the attackers have looked at LinkedIn, worked out where everyone in your company lives, and tried to work out the chart, and the attack is going to be started and finished often in five minutes or so. So having something like flow rate and high value detection that automatically tries to deal with an incident response I think is a really valuable thing to try and do. And so because it's on chain, it can happen immediately and so stop things in progress. So I think it's quite valuable. However, the user experience of all of this is really complicated.
00:35:22.810 - 00:36:39.490, Speaker B: And so imagine if you have got your mobile phone there and you're at 130 a. M. On Christmas day or so, and you're trying to do some withdrawal on the bridge for the blockchain and someone's just hit pause. How do you surface that to a user so that they know that say their withdrawal that's in the process has been locked because the bridge is paused, or if the user is just about to do a transfer, you need to surface that to say, hey, at the moment we've paused the bridge, so we're not going to be able to do your transfer. And then whoever's operating the bridge needs to have tools to detect what transactions are in flight and try and work out what to do with them and how to process them afterwards. And again with the withdrawal queue you need to be able to give appropriate information to users. And so it's going to be a complicated UI to try and explain, hey, the transfer you're just about to do might trigger the withdrawal queue.
00:36:39.490 - 00:37:42.940, Speaker B: So if you do a less of a lower withdrawal then it won't trigger. And so it's again a complicated thing. And I know, I mean for myself, if someone says they want to withdraw $10 million, I invariably would say look, you're better off doing 100 $100,000 withdrawals than 110 million dollars withdrawal anyway, simply because if there's some failure case with one $100,000 withdrawal, it's awful. But if it's with a 110 million dollars withdrawal, then it's really bad. So better to have smaller withdrawals than one big withdrawal. And so your analysis tools again need to be able to work out what's going on and help complete transfers for people. So the design that I've talked about today, we've done a written code, written a threat model and had trailer bits audit the code.
00:37:42.940 - 00:38:43.930, Speaker B: So the threat model has links to the code and is a great place to start. So the slides will be available in the description of the YouTube recording of this afterwards. So in summary, if you're operating a roll up or a side chain to avoid a company ending event, I'd seriously consider implementing some or maybe all of the ideas in this talk. But you got to consider your flow rate configuration really carefully and the user experience is going to be more complicated due to having these features. So you've got to weigh things up a bit as well. And the merch store is now open and I guess most appropriate for today's talk is the cross chain bridge design is really complicated. T shirt.
00:38:43.930 - 00:39:20.390, Speaker B: Yeah. Coming up we've got Tim Baiko from Ethereum foundation who's going to give us an overview of Ethereum governance. We've got Juan Blanco who's going to talk about the vs code solidity extension. And then I'm going to talk about passport wallet. And then right at the end of the year we've got a solidity interview challenge that I'll do. If you're here today, you can watch this on YouTube. If you want to have a conversation with people about it, go to slack.
00:39:20.390 - 00:39:35.390, Speaker B: If you're watching this on YouTube, you can attend the meetup live by going to the meetup. And that is all. So does anyone have any questions or thoughts?
00:39:35.730 - 00:40:47.470, Speaker E: Yes, I would have a question, Sven here, I looked at some bridges and corresponding token designs, and I came across the X ERC 20 token contract from connects, who also provides a bridge solution, but they are putting the flow, the rate control, right into the token contract. So if the bridge gets compromised and the token contract is on its own, and somebody gained access to the mint function, that at least the impact can be minimized. And just the second feature, they have also the option to have multiple, or give minting rights to multiple bridges. Maybe you don't want to do it at the same time, but the token issuer would be under control to kick out, compromise the bridge or migrate to a better one. What do you think about that approach?
00:40:47.850 - 00:40:48.600, Speaker A: Yeah.
00:40:51.130 - 00:42:14.510, Speaker B: So on Ethereum, the ERC 20s won't have that capability. And so if you're bridging back to Ethereum, which is where you're really worried about, that won't work because they don't have those APIs bridging to some other chain. Having multiple owners should help reduce liquidity fragmentation, where you have two separate bridges that bridge the same token, because otherwise you can have mutually incompatible ERC twenty s. But yeah, I think having the rate control, it helps to have or give the ownership of that rate control to the token creator rather than the bridge, the bridge owner. But yeah, I think as far as general usage goes, it's not going to work from the, I mean, for what I was trying to handle, which is exits to Ethereum, because my thought was that even if someone steals a billion dollars, if they're trapped inside of the immutable ecosystem, we can somehow rather deal with it, probably. Whereas if they're exiting to Ethereum, once that money's off, then it's too late.
00:42:15.090 - 00:42:47.900, Speaker E: Yeah, I'm actually in the fortunate or unfortunate position that I have to come up with a new token contract anyway. So I'm even thinking about creating a new token contract on Ethereum because the token I have to take care of is actually affected by the multi chain bridge and we want to migrate to a new token contract anyway. So I would have the opportunity to put that in the Ethereum contract as well.
00:42:50.670 - 00:43:05.790, Speaker B: Yeah. In that case then would you have any minting happening on Ethereum? Because wouldn't the where is the source chain for that token?
00:43:06.550 - 00:43:43.520, Speaker E: Yeah, the concept is either how it was before that you would lock the original token on Ethereum and mint it on the other chain. But recent suggestions, even from some bridge providers, were that there would be no source chain and no original token. They would all set up identical token contracts on every chain and on every chain the bridge would be allowed to mint and burn so that you don't also have any liquidity issues.
00:43:48.530 - 00:43:57.460, Speaker B: Okay, sounds like a complex token design. I wish you well with it.
00:44:01.110 - 00:44:40.990, Speaker E: I was hoping you would say something else like that. Sounds perfect. Go with it. Yeah, no, actually the design should be maybe not too complicated. Of course the actual token contract gets more complicated because you have the rate control logic inside, but then you have identical token contracts for every chain. The bridge gets mint and burn rights for whatever token on any chain. Yeah, of course there's always a risk.
00:44:40.990 - 00:45:01.010, Speaker E: Sorry, if a bridge can mint tokens, but you have to have that anyway because you can't move it. There's always a need to give minting rights to a bridge with an upper cap anyway, but maybe that's not good if that's reached.
00:45:04.810 - 00:45:17.660, Speaker B: Cross chain is complicated and trying to think through all of the scenarios is really hard. Okay, does anyone have any more questions?
00:45:21.790 - 00:46:33.774, Speaker E: I would have another one if nobody has. I wrote it in the comments already that most bridge designs are based on some sort of multi sig, some off chain stuff between contracts. But once the bridge is gone, then the token contracts are left on their own on the smart contracts and they don't really know of each other. Also if something goes wrong in the bridge. So the latest designs which try to do it the right web three cryptographic way, they don't trust any intermediary multisig, but like the approach from succinct labs, they managed to implement a light ethereum client which actually can monitor the state of another chain. And thus there is no intermediary which needs to be trusted and set up as a multi sick. That's pretty new stuff, but that sounds more convincing.
00:46:33.774 - 00:46:45.110, Speaker E: So again, trying, again trusting the cryptography and not humans or organizations in a multisig.
00:46:46.330 - 00:48:00.042, Speaker B: Yeah, so I haven't looked at that succinct latest offerings, but I know back at the start of the year when I was looking at that, that a lot of the claims were with their fingers crossed behind their backs. And so they would prove most of the Ethereum consensus, but there was an important part of it that they wouldn't prove, which was essentially who the committee was. And another part of it as well is that there's no proof that you haven't got a lying committee. I know it's unlikely, but you could have a committee of 500 that sign a block on Ethereum and then separately sign a special block that they use for bridging, which could say something completely different. The slashing on Ethereum would only happen if they put an invalid block on Ethereum. But if they put up an invalid block and then use that for cross chain, there's no slashing.
00:48:00.186 - 00:48:00.880, Speaker E: So.
00:48:02.770 - 00:48:41.900, Speaker B: Not likely. But still, it's something to consider that even those systems aren't foolproof. And I guess as well, for me, they're very new. And so there's a possibility that there might be some sort of bug in the circuit design, in the ZK circuits. And I don't know that there's enough people who would be able to analyze those circuits well to really say, hey, that should be error free.
00:48:43.390 - 00:48:54.480, Speaker E: Yeah, I have a similar view on that. I think it's actually a great design, but maybe too new to actually use it because of the risks you just mentioned.
00:48:58.870 - 00:49:19.574, Speaker B: All right, well, thank you, Sandra and Tanhai, for answering questions. Thank you, Sven, for your questions. And talk to everyone in another two weeks time. Have a great thanks, Peter, for your talk.
00:49:19.612 - 00:49:32.854, Speaker E: Yeah, thank you very much. Was actually perfect in time for the issues I have to deal with at the moment. Gave me additional ideas and insights. Thank you very much.
00:49:33.052 - 00:49:36.040, Speaker B: No problem. And good luck with your token design.
00:49:37.810 - 00:49:39.418, Speaker E: Thank you. Bye.
