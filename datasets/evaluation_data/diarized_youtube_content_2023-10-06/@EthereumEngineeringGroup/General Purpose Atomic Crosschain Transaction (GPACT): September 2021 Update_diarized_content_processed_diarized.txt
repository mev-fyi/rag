00:00:04.250 - 00:01:03.970, Speaker A: Hello and welcome everyone. My name is Peter Robinson and today I'm going to talk about the general purpose atomic cross chain transaction protocol. So the protocol is a call execution tree commitment scheme that provides atomic cross chain function calls across an arbitrary deep call tree. There's a GitHub repo that you can see the source code. So what this protocol gives you is business logic across blockchains. So for instance, you could have an externally owned account that submits a root transaction. And what they're doing is they're saying, look, some goods have arrived, let's pay for them, and they might have a multi SIG wallet and the other signatories have signed and they do the final signature which says let's execute the overall cross chain transaction.
00:01:03.970 - 00:02:15.522, Speaker A: And so the segment of the transaction goes to the terms blockchain and this is the blockchain which has got the contract terms. So the actual for the shipment, how much should be paid, how should the payment be calculated, and it goes to a Oracle blockchain where it gets the price and gets the result back as part of this call tree. It then talks to the finance blockchain and says we need to transfer this amount of money between these accounts given the shipment. And it talks to the logistics blockchain and says the delivery has arrived, the ownership of the goods now transfers. And so you could argue that all of this could happen on one blockchain. But in my experience of working with people, the people who are on the finance blockchain don't want the people who are involved in a logistics on their blockchain and vice versa. And there will be some parties that are across both blockchains, but invariably you will have two consortium blockchains involved in this sort of endeavor.
00:02:15.522 - 00:03:55.670, Speaker A: So the technology works on public permissionless and permissioned blockchains. So when I say a call execution tree commitment scheme, what I mean is that there are entry point functions that get executed in contracts on each of those blockchains. And what you're doing is you're committing to executing with certain parameter values and executing the particular functions in those contracts on those blockchains and so that you're committing to that execution tree. And this protocol fits into an overall cross chain protocol layer stack which I've defined. And the GPAC protocol sits on top of a cross chain message verification layer where you've got a whole lot of alternative approaches to essentially having some information be proved to have come from a certain blockchain and have, say, either a set of parties attest to that fact, or maybe you have some sort of trustless mechanism to prove that the value came from there. There are a whole stack of methodologies for doing it, but whatever the methodology, GPAC sits on top of that and applications use GPAC. So equally you could have a non atomic protocol as well, or other protocols that sit between the good full atomic capabilities of GPAC and a completely non atomic function call approach.
00:03:55.670 - 00:05:12.534, Speaker A: So the paper doesn't actually talk about this, this is something that's emerged since the paper. So when GPAC though executes, when you're executing that call execution tree that we saw with that trade finance, you start off by submitting a start transaction which emits a start event and that essentially commits you to the call execution tree and then you have the segments of the call execution tree from the leaves up get executed. So you execute the segment for the get price, the transfer and the delivery, and then they feed into the return results. And whether they executed correctly feeds into the next layer up in the Call execution tree. So the shipment and so the shipment gets executed, and then its results get pushed into the root transaction that execute trade. And if all of that has executed correctly, then the root transaction will admit an event saying commit everything, or if something failed or it hasn't executed in time, it'll emit an event saying discard. And so then all of the updates will be discarded.
00:05:12.534 - 00:06:52.982, Speaker A: So in this example, the finance and the stock blockchain have updates that are in lockable storage and to unlock that storage and commit the updates you submit signaling transactions that use that root event to prove that the value should be committed or discarded. So I've said that we had this start segment route and signaling transactions and so they call functions of the same names on the cross chain control contract and this is the contract which controls the overall flow and execution. And so the first thing it does is it takes all of the information that have been submitted, say the start event which the call execution tree or the segments with their return values or the root transaction event with the commit or discard information and so it needs to verify that that information is correct. And so it's up to the crosschain verification mechanism that is used for each blockchain. So each blockchain could have a different verification mechanism, but it's up to the verification mechanism being used to say, yes, you can trust this event. And then the crosschain control contract calls out to the lockable storage or rather calls out to the business logic contract, which has lockable storage, which can then call into another application contract. And if it does have some lockable storage and that storage does get updated, then you indicate to the crosschain control contract that, hey, I've got some storage that's been updated.
00:06:52.982 - 00:07:38.830, Speaker A: When you're emitting that segment event you need to say I have some lockable updates or some provisional updates. A business long chip contract could also be wanting to do a cross chain call. And so it calls into that crosschain control contract. And what it does, the crosschain control contract has the call execution tree in the form of that start event. And so it can look at what functions should have been called with what parameters. And so if the actual call matches the expected call from the start event, then the crosschain control contract can be happy that this execution is correct and so it will return. Okay? Otherwise it would fail the overall transaction.
00:07:38.830 - 00:08:32.474, Speaker A: So I've talked about events that get so that's all about Ethereum events. And so in a contract in Ethereum you can have an event defined which is a little bit like a function call, but it's really just a name of an event and a set of parameters and they get emitted. And you can do this programmatically. So you could have this start function which emits that start event. So events are stored inside transaction receipts, so they're event logs and they've got the address of the contract that emitted them and the name to the topic, which is the function signature essentially, and then the data which is the encoded parameters. And then that then fits into the transaction receipt. You have a modified Merkel Patricia Try which ends up the receipt.
00:08:32.474 - 00:09:54.940, Speaker A: The root of that ends up in the block and you've got a whole set of blocks. So I've talked about a direct signing mechanism as an approach. And so the idea there is you have a set of Attesters that are trusted by a target blockchain and when a transaction happens that emits an event from the crosschain control contract, these Attesters see that, so they're monitoring for those events. They see those events, they then cooperate to mutually sign the events and then the user can then ask for that multiply signed event and then they then can submit their transaction on the target chain with that multiply signed event. And in that way the target blockchain is going to trust the information because they trust their signers. So looking at how does this actually work when you're deploying it, what does that look like? So you've got on chain on the blockchain, you've got your application code, the business logic, and we've got those GPAC contracts, the cross chain control contract. And with the underneath that you've got those verification contracts as well.
00:09:54.940 - 00:10:54.026, Speaker A: We've also got those lockable storage contracts which can be inherited by other contracts to make it easy to do lockable storage. And I've written some ERC, 20 application contracts. So for people who want to do lockable, ERC 20 for cross chain, then they just need to use those contracts. So then you've got the Attester. So the Attester is a node on the network that helps to do that direct signing methodology. Equally you could have a relayer or some other thing depending on the actual approach being used on the user side. So on the application side, say on someone's telephone or laptop computer, you're going to have some off chain code and that's going to then work with some code that the application developer has written to work in with the GPAT protocol.
00:10:54.026 - 00:11:57.294, Speaker A: That's not too much, that's quite a light amount of code and then you've actually got a library and that does all the orchestration for you and all of the hard work. So when you're deploying it, this is a consortium approach. So as I said before, it will work for permissionless as well. You've got your nodes, your blockchain nodes that you might have on your multiple blockchains. So in this case, blockchain A and blockchain B, you've got your Attester, which is essentially sitting next to your blockchain nodes watching for events. And you're going to have an application which has got that GPAC library to run the orchestration for the cross chain calls. And so it's now worth thinking about, well, are there any limitations and what are the limitations on the application? So recall this diagram here and so on chain, you're going to need to be using lockable storage.
00:11:57.294 - 00:12:52.430, Speaker A: So I've been talking about how when an update occurs, the update goes into provisional storage and then you can't modify that value until it's unlocked either by committing or discarding the update. The call execution trees need to be deterministic so you can't commit to a random value. So you need to rely on values that are deterministic. So you can't rely on say, block numbers or something like that. Similar to other blockchain transactions, a cross chain transaction is going to be vulnerable to front running attacks. So when you're designing your application, you've really got to be thinking about how you want to do it. And so for instance, rather than say, having things relative to each other, say, bidding, I want to bid two more than the last bid.
00:12:52.430 - 00:14:03.530, Speaker A: You might say, assuming the last bid is this, I want to bid this much more, or I want to bid an absolute amount and that sort of circumvents your front running attacks. So the events that we need a trustworthy mechanism for transferring events. And so the mechanism needs to be compatible with the source and destination's trust model. So if you're using two trustless blockchains, then maybe using say, a single signer, a tester wouldn't really make sense because that would be very centralized and you should be trying to work out a trustless mechanism if possible. So on the client side there, you've got to essentially run that call execution tree and simulate it. So you need to be able to simulate all of your business logic that's on chain in your application off chain, so that you can work out what the values are. And you need to be able to access the important values that are on chain that might affect the parameter values.
00:14:03.530 - 00:15:18.020, Speaker A: And thinking back to this diagram, another important thing to think about is that the cross chain calls to work, you need to have access to all the blockchains that you're going to execute them on. And so what this means is if you look at this diagram, that organization A can execute a cross chain call across A and B, but organization B and C can't because they don't have access to both blockchains. I've developed two execution engines. So one is a serial execution engine which executes the calls essentially by walking the call graph. Then you can though, and I've developed another one which lowers the latency, and it's a parallel execution engine which aims to try and execute things at the same level of the core graph in parallel. So there is an implementation of the protocol and it's written in Java and Solidity, and it uses a modified version of Web Three J. It's Apache Two, licensed at the moment.
00:15:18.020 - 00:16:10.980, Speaker A: As of writing in the paper, this was the gas costs, but the gas cost can certainly be reduced. And in fact, since the paper was put out, I put a bit of effort into reducing the gas costs of leaf functions. And you can see that they've dropped by more than, in the case of the segment transfer and delivery, more than 200,000 gas. And the root transaction, which I've also put a bit of effort into, has dropped by more than 100,000 gas. I'm sure there's still a lot more that can be done to really whittle down the gas usage. And obviously the gas usage really does come down to the call execution tree you've got and how many values are being put into provisional storage. So you really need to be thinking about your application as you're writing it.
00:16:10.980 - 00:17:09.590, Speaker A: The latency of this technology is pretty good, I think. So these numbers are measured in what I've called finalized block periods. So essentially that means that if you look at how long a block takes to be finalized on a blockchain, you can consider that the finalized block period. So say if you're on bitcoin, most people wait for six blocks because it's one in a million chance given a 30% attack. Similarly, you could wait about ten or eleven or twelve blocks on Ethereum for similar probability of the blocks being changed. So essentially, if you wait ten blocks on ethereum, you're all good, and that's ten times 13 seconds. But if you're on an instant finality blockchain, then that might only be 2 seconds finality or 1 second.
00:17:09.590 - 00:17:47.422, Speaker A: It really depends on the blockchain. And so the actual amount of time depends on how many of the calls need to happen and how deep is your call graph. So we did a security analysis in the paper. We're actually working, starting to work on a formal analysis. Hasn't started yet, but hasn't been completed yet, but it's in progress. Future work. All right, so the layers in that protocol stack are being standardized within the Enterprise Ethereum Alliance.
00:17:47.422 - 00:18:55.202, Speaker A: And so if you're interested in being part of that standardization work, I encourage you to reach out to me or other members of the cross chain Interoperability Working Group. So I'm going to create a non atomic version of GPAC and other approaches that are in somewhere between non atomic and atomic. So for different applications people want to use different types of execution engines to allow for varying gas costs and complexity and it depends on really the type of transaction that's being executed. Also more alternative message verification mechanisms are going to be added and the efficiencies are going to be improved and other blockchain platforms will be supported as well. If you have any questions you should reach out to me. Probably on LinkedIn is a good one. I don't think I've got my email address here, so in summary, Gpact is an atomic cross blockchain function call approach.
00:18:55.202 - 00:19:12.540, Speaker A: So it allows business logic to be spread across blockchains as implemented. At the moment it'll work on any EVM blockchain, but I'm sure it can be made to work on any blockchain that supports contracts and events. Thank you for listening and have a great day.
