00:00:00.090 - 00:00:38.986, Speaker A: Yeah. All right. Hello and welcome everyone. So today I'm going to talk about crosschain transactions in Solidity and how to do how to write some crosschain codes. So I'm going to talk and use the atomic crosschain transaction technology that we've come up with as an example, cross blockchain tech. But a lot of the underlying ideas we've got here are equally applicable to cross shard and in particular to Ethereum two cross shaft communications. So Ethereum two cross shard is still coming together as what it's going to look like.
00:00:38.986 - 00:01:52.282, Speaker A: We're actually going to do a talk on cross shadow communications in about eight weeks, maybe twelve weeks time. But yeah, a lot of the ideas are readily applicable. So what I'm going to do is I'm going to start off telling you about atomic cross chain transactions so you've got a good primer in them. And then I'm going to talk about other stuff which is related to how you write Solidity code in this context and things you've got to be thinking about when you're putting your application together. So in Ethereum you've got transactions which update the state of a ledger and views which read the value back. And so atomic crosschain transactions are nested Ethereum transactions and views. And so if you can think of this diagram here, you've got the externally owned account would submit an originating transaction which is for a function in a contract on a blockchain and it might have a subordinate transaction which might have could do a subordinate view and then another transaction.
00:01:52.282 - 00:03:05.622, Speaker A: So when you're constructing that, you have this nested set of transactions. So this is a signed transaction that is encapsulated inside this signed transaction which is encapsulated inside the originating transaction. So that EOA submits this nested block of signed. So if you think about it, so on blockchain B, so remember, blockchain B was this one here in the middle. So if you're on blockchain B, you could have this code as that function that's being called. And so what you got to think about, say if that parameter was one, then that parameter gets passed into there and then you go, well, we've got this conditional statement here and then we have these values that get added together. So you could look at this whole state here and also maybe you can execute this function, call offline as it were, or simulated, and you realize that the function result will be six.
00:03:05.622 - 00:04:17.920, Speaker A: So you can work out that if we pass in one here and one there, then that should be ten. So you could work out what values you should be passing to those function calls. So those function calls are going to be subordinate view and subordinate transactions. So it means when you're creating that nested transactions that we talked about back here, when we have these nested transactions and you're creating signed transactions, you have to have those signed transactions with certain parameter values. But something worthy of note though, say a state one, that state variable, say if it had have been three rather than two, then rather than having to create three subordinate transactions and views, you would have only had two, only two function calls. So that means you need to be thinking about the actual call that happens, the call graph. So you need to be thinking about what actually happens in the code based on the actual parameter values that you're expecting to have.
00:04:17.920 - 00:05:28.322, Speaker A: So the method of processing code is this. So first thing you do is you say, does this code execution have any subordinate views? So how you know about that is, remember how we have this hierarchy of subordinate views and transactions that you're passed. So you'll say, all right, I have some subordinate views that are going to get called. So you dispatch them first up and you get the parameter value, the return results back from the other blockchain. So you say, hey, if I pass you this, what is the return result going to be? And you catch those results. So then what you do is if you hit a subordinate transaction function inside of the code as you're executing the code in the EVM, then you say, well, I've got a signed transaction which says a parameter value should be this from the EVM you're passing in these values, they match, that's good. Or if they don't match, you revert, you throw an exception.
00:05:28.322 - 00:06:32.860, Speaker A: Essentially, if it was a subordinate view, you do the same thing checking the parameter values and also you return that cached result you have and then the code also executes as normal. So you execute all the code and once all of the code is executed, assuming that all the views and transactions get executed in the right order with the right parameter values, then you dispatch the subordinate transactions off to the other blockchain. So something to think about is with this whole scenario is that enterprises might be across different blockchains. So you can across this way we've got blockchains, and down this way we've got companies. And so for instance, this lady here, this externally owned account, they can do a transaction that goes across all of these blockchains. Whereas this bloke here, his company only has nodes on these two blockchains. And so his cross chain transaction can only go across those two.
00:06:32.860 - 00:07:42.694, Speaker A: But importantly, say if there was a cross chain transaction that did go across all of these, he needs to be able to be sure of the values being returned by the blockchain d and also to ensure atomic behavior. He's going to want to be sure that, say, there was some update here or here that they actually go in because he doesn't want to put his node, does not want to apply for updates if they're not going to be applied atomically across all of the blockchain. So we use a technology called BLS threshold signing. So there's a whole 40, 50 minutes talk from about three to six months ago, which talks about BLS threshold signatures. But what it is, is a technology which allows you to verifiably create a split secret, which is the private keys. And then for each private key share, you do a BLS sign and create a signature share. And then you can combine the M of n of those signature shares using something called LaGrange polynomial.
00:07:42.694 - 00:08:55.560, Speaker A: So essentially curve fitting, and create a group signature. That group signature can be verified using a generic, a public key, which is essentially the curve fit of all of the public keys which correspond to those private keys. So what it means is for the whole blockchain you could have a public key and the nodes could collaborate and have M of M of them consign some data and that can be verified by anyone who's got that public key. And so we use BLS threshold signing to verify values across chains. So here we have a result that was generated by nodes on blockchain C. If you're on blockchain B and you don't have a node on blockchain C, you need to trust that value. And the only way you're going to do it is if you can have the information threshold signed by a majority of the nodes on blockchain C and you can verify it using a blockchain public key.
00:08:55.560 - 00:09:50.902, Speaker A: And then similarly say, if you're on blockchain. So nodes on blockchain A need to be sure that updates are going to be applied on blockchain B and D. They don't want to apply their updates if it's not going to be applied on these two, but they might not have nodes on those chains. So if you could have a message which is threshold signed, which is we have locked in our update and then all the nodes on blockchain A can verify that this update is going to be applied on all the other chains, then I'll be happy with it. And so again, we use threshold signing for that. So contracts in our system are lockable, so they can be locked or they can't be locked. And if they are lockable and they can be locked, then by default they're unlocked.
00:09:50.902 - 00:10:46.122, Speaker A: If there's a transaction that gets mined, then they become locked. If either a signed message saying, hey, we should unlock, goes up, then they'll become unlocked, or if there's a timeout they'll become unlocked. So walking through this a little bit more. So when you're updating the state of a contract, so it starts off being unlocked, and then you look at the contract and you say, well, are you lockable? And if the contract isn't lockable, then you fail because you're trying to lock an unlockable contract. So if it is lockable, then if it's currently locked, again you fail. So this is a really simplistic locking mechanism, and a lot of database people said, hey, there are all these whiz bang things you could do with locking. There are and we could do something much better.
00:10:46.122 - 00:11:41.450, Speaker A: But for version one, we're definitely not. We're just going to do simple walking through the whole system will be incredibly helpful to explain it. Harakio is now smiling and nodding. Okay, imagine we've got those blockchains in that overall call path. So you've got the externally owned account and she's putting in a transaction and it's got a timeout. The timeout is in terms of the coordination blockchain's, block number of that originating transaction to see if it's going to work. And if it does so, then the subordinate transactions that were part of that overall execution have been mined on blockchain A.
00:11:41.450 - 00:12:27.180, Speaker A: And the act of mining it puts any updates that we're going to be able to. So then you recall there was a subordinate view down to blockchain C and a subordinate transaction to blockchain D. So we execute subordinate views first and the subordinate view goes down. We do a trial execution to find out what the return value is. We return the result threshold sign the result and return it. But the blockchain B, all of the nodes may not have the public key required to verify that result. So the public keys have a key version number because you can generate different versions of the key depending on how many nodes are in it.
00:12:27.180 - 00:13:08.890, Speaker A: Maybe sometimes you'll need to roll the key over. There's a whole talk involved in talking about why you might roll the key over and when. But anyway, and then both of them get mined. They lock the contract. So they update it, goes into provisional storage and you lock the contract. And then they will then threshold sign ready messages saying, hey, we've locked the contract, we've got the provisional storage, we're ready to go. And then maybe this blockchain node member nodes on that blockchain need to check the public keys and use it to verify the messages.
00:13:08.890 - 00:14:01.222, Speaker A: And then once the node on blockchain A is happy that everything's ready to go, it threshold signs a commit message and it submits it to the crosschain coordination contract. And then once it can see that that has been locked in on that contract, it then sends messages to the other nodes on the other blockchain saying, hey, you should check the status of this cross chain transaction. They'll check it and the node that checks it first will fire off a signaling transaction. And what this says to all the other nodes on the blockchain is we're ready to go, let's lock in this state update at this point. And so that will then apply the state update. Okay. But of course some things can fail.
00:14:01.222 - 00:14:52.022, Speaker A: And if they do, then you'll end up uploading an ignore message and it can fail in all sorts of different ways, but the result always ends up being ignore. And then you will fire off one of these signaling transactions and you will revert state and it doesn't really matter what happens like if you try and submit the commit message after the timeout it'll fail and automatically the contract will say we're in the ignore state. And then again you'll put signaling transactions into one box contract and you'll roll back the state. You essentially unlock the contract and discard the provisional state. Those are the normal fields you've got for the standard Ethereum transactions. And then we've got a whole stack of extra ones. So we've got ones which all relate to the coordination contract.
00:14:52.022 - 00:16:19.858, Speaker A: So which coordination contract are we using for the transaction? What's the timeout, what's the originating blockchain that started the whole thing, what's the transaction ID? We've also got information which relates to where does this particular subordinate transaction come from? Okay, so that's given you a bit of a feel for atomic crosschain transactions. There are a lot of other technologies out there for doing it, cross chain communication and overall a lot of them give you similar styles of results. This gives you some extra benefits which I'll talk about towards the end. But yeah, a lot of the aspects end up and requirements around coding applications end up being similar I think. So remember we had non lockable contracts and they cannot be locked. And so you can't have a state update as part of a cross chain transaction, whereas lockable contracts can be locked and can have state updates. So one of the big problems that people talk about is the hotel train problem, where you've got a hotel on one blockchain and a train on a different one and invariably you have the travel agency on one of those blockchains.
00:16:19.858 - 00:17:17.282, Speaker A: So we've made it slightly harder by having the train fee travel agency on a different blockchain and we've got payment involved as well. So you could imagine that you could set up this as a simplistic system. So you've got ERC, 20 tokens issued for the train. So essentially you pay for seats on the train using ERC, 20 tokens as a travel agency. Maybe you pre buy the right to have certain seats on the train by buying ERC, 20 tokens. And then similarly for the hotel, you can book hotel rooms at different rates based on certain amounts of ERC, 20. You could imagine you have this booking system and then it fires a cross chain transaction down to here and it tries to book a seat on the train and pay with an ERC 20 token or some ERC, 20 tokens.
00:17:17.282 - 00:18:16.186, Speaker A: And then similarly over here books a seat on the train hotel room using the various things. Problem with this of course, is that if the travel agency tries to do that and then the other travel agency tries to do it, then as soon as they hit this contract here it'll fail because that hotel room reservation contract is locked. And so you'd only be able to do one thing at a time, which wouldn't really work that well. However, if you have the hotel room reservation contract as a router contract. So it knows about all of the hotel rooms that are out there, but it itself is not a lockable contract. So you can't lock it, but you can lock the individual rooms. And so now you go in, you say, hey, can you book me a room? And so it'll go down here, it'll book a particular room and lock them.
00:18:16.186 - 00:19:06.810, Speaker A: So it'll have to be part of the cross chain transaction. It'll lock it and similarly for the train and then do the payment. So that sounds like we're getting better. And so now when you go in, you can get here and you can book your room separately, but then when you hit your ERC 20 contract, again, it's a single point of lockedness of failure. And so you need to have essentially a new type of ERC 20 contract. So essentially, again, a router, an individual item where the individual item is lockable. And so in this situation, you could have the travel agency go in, one of them can book and the other one can go in and again, it can do its booking without having these locking failures.
00:19:06.810 - 00:20:04.080, Speaker A: I'm not sure what that was going to tell me. I did these slides yesterday afternoon. So if you do 60 slides in about 120 minutes, you're guaranteed to have an extra slide that you meant to delete. Okay, so one of the things that we do here is we've got some solidity contract that's calling two other contracts on other blockchains. You can't do that at the moment. And so we've designed some code. So your constructor for your solidity, you pass in the blockchain ID and the address of the hotel contract and again, for the train, the same thing.
00:20:04.080 - 00:20:33.462, Speaker A: And then you've got a method or function in the solenity contract called book, hotel and train. And you pass in the date and a unique ID. And one thing that you can see I've hard coded here is 100 tokens each. There should be some sort of payment. Again, this is some sample code that we've put together. Don't deploy this in a real system. You might want to think about your application a bit more.
00:20:33.462 - 00:22:04.206, Speaker A: But anyway, you're passing some parameters and then you do a cross chain transaction, you call a function and you pass in that blockchain ID the address of the contract and then the actual function you're calling and the parameters that you're calling with. And so this is what your solidity code looks like for doing a cross chain transaction. So in some of the other methodologies, I think you need to get a PhD in asynchronous programming to get a cross chain transaction working. Whereas our code, that's what it looks like, it's really simple. So of course, a lot of magic happens in this cross chain transaction method. So what we do is we put together all of the data and then we do a call down to a pre compile and that pre compile, essentially all it's doing is checking that the actual parameters match what was signed and that's all that precompile does. So another thing to think about is that, say, when you're looking at the book room, bit of code, you're doing all sorts of function calls to other contracts, like the Broom contract, and you're doing these function calls.
00:22:04.206 - 00:23:32.790, Speaker A: And function calls within a blockchain are not signed, so you're only worrying about the entry point into the blockchain and you're not having to worry about calls between different contracts within the blockchain. You don't have to sign them. So one thing that is here is this bit of code here. So you can think that we had say, multiple, ERC, 20 item holders or multiple rooms for the hotel. But when you go into this code, what it needs to do is it needs to say, well, is that contract there at that address, is it currently locked? Because if it's currently locked and you try and lock it, then of course you're going to fail. So you need to work out which rooms are not part of an atomic cross chain transaction at the moment and then only look at them to work out if they're available on the right day is the room rate less than what I'm prepared to pay? And then you'll notice as well, then we go off and call the ERC 20 contract to do the value transfer in the ERC 20 router contract. So, ERC, 20 contracts, normally they're addressed to Uink 256 for the balance.
00:23:32.790 - 00:24:53.530, Speaker A: And this one here, what you've got is an address to an array of addresses and you have them as lockable accounts and then have in the actual contracts, you have the balances. So what we're doing here is each address can have multiple lockable accounts because say, I want to pay Farafio some two coins and then Sally wants to pay him two coins. If he only had one lockable slot, as it were, that we could put money into, then the first person puts money into it, say me. And then when Sally tries to give him money it's blocked. So in the hotel, if you've got the hotel account you want to be able to have a lot of different slots so that lots of people can pay you money simultaneously. But then at a later point you're going to need to have run a method or essentially a batch job to condense all of your coins. So say, find me all of the contracts that aren't locked and essentially take their balance to zero and put all my accumulated balance in some central, maybe the 0th lockable account for instance.
00:24:53.530 - 00:25:54.414, Speaker A: So within an ERC 20 contract you've got an underscore transfer function which is called by transfer and essentially you're transferring from the sender to a recipient for an amount. And as I said, each address has got an array of lockable accounts and so you find out what account that you've got and you make sure that it's actually been set up. So most of the FC 20 contracts, you don't need to set them up ahead of time. You just send money to a bank, to an account. Whereas for this, because you've got to have these lockable contracts, they need to be set up. And then what you do is you go through and find one that isn't locked, as I was saying, and then send the money to the one, the account that isn't locked or the slot that isn't locked. Okay, so that is the hotel train example I had hoped to run.
00:25:54.414 - 00:26:46.346, Speaker A: The actual demo live here and it's probably hours away, but there's still a few bugs in my validity code. There's a few requires that are going off and I don't know, maybe I'm not paying enough for my hotel rooms in the example or something crazy like that. It's one of these things when you make an example and you think I should be a little bit realistic, then suddenly things get complicated. Anyway, it's days away, maybe less. So one of the things that when you're doing cross chain systems that you need to think about is when you're calling into the same blockchain twice, bad things can happen. It really starts to come down to your overall design of the system. So one of the demos that we've got is one where you've got three blockchains and six contracts.
00:26:46.346 - 00:27:27.930, Speaker A: And so in this, you do a View call and then you do another View call. Then you do a transaction. That transaction does a View call, which does a View call. And this works because you're not touching the same contract twice and you're not doing transactions to the same blockchain. So if you had something like this, then you've got two subordinate transactions going into the same contract. And the issue you can have is you're not sure what order they're going to execute in and imagine as well on the same chain. Yeah, sorry.
00:27:27.930 - 00:28:08.646, Speaker A: So you can imagine actually, it's probably better I should have had this slide here. You could also have some more complex call hierarchy before you get there. So you've got this issue that you're not sure what order your transactions are in. All these transactions have got to be signed and that includes the non value. So when you sign a transaction, you have a non value behind it. And so the nonce value for a blockchain has to be unique. And if say this one was three and that one was non value two, but that one arrived first, then this one would be disregarded, it'd be thrown away by the blockchain.
00:28:08.646 - 00:29:09.238, Speaker A: So we could do more complicated transaction pooling where you say, well, if not value three turns up ahead of non value two, then maybe we keep it for a while. But there's a lot of thought that needs to go into that it sounds simple, but it probably isn't as simple as it seems. And maybe we can do better things with nonce management as well. We've talked about that. But that's another extension to the technology. So if you do a subordinate view to a contract, so give me the value and then you do a subordinate transaction which updates the state of the contract that'll work. However, if you do a subordinate transaction and then you did a subordinate view later on, maybe via another contract or something, that wouldn't work because your subordinate view would hit a contract that's blocked.
00:29:09.238 - 00:30:09.070, Speaker A: Well, actually that example is wrong because we need to go via a separate blockchain because the subordinate view will always be executed first. So if you looked at your code and you had the subordinate view after the subordinate transaction, you've got to think the subordinate view will be dispatched first. So there are complexities that you need to be aware of when you've got subordinate views and transactions in the one blockchain. Okay, another interesting thing to think through is application authentication. So a typical scenario in blockchain is you've got two contracts and so this one here might be your data storage and that might be your complex business logic. So you want to be able to upgrade your business logic but not move your storage around. So this is really common and you can imagine that in your contracts you might have required message sender is some authorized address, essentially this contract.
00:30:09.070 - 00:31:18.360, Speaker A: And if the thing calling me isn't that contract, then go bank. So what do you do when we've gone from the scenario where it was all on the one blockchain to now we're on two different blockchains, what does that look like? And so what that looks like is you're going to need to be able to work out what's calling you and what the originating blockchain was and then seeing whether you trust the originating blockchain and whether the from address is authorized. So you need to be sure that that address is okay to or that contract is allowed to send to you. So assuming that you're in a semi trusted environment, this is sort of what you need. You need the originating blockchain to be semitrusted. So you might not have nodes on it, but you need to trust that blockchain. And similarly you need to trust the blockchain that's calling you, which again, you might not have any nodes on that blockchain, but you need to trust it.
00:31:18.360 - 00:32:13.320, Speaker A: And so maybe within your group of consortiums you do all right. So another thing that you've got to do is think about pre execution simulation. So these are some of cross chain transactions, rely on these nested signed transactions. But to work out what the parameter values are, you're going to need to have a model of what the code is that's in the solidity contracts to work out what those parameter values really should be. And so your model doesn't have to be completely precise down to with internal business logic if it's not going to affect a parameter value of a transaction. But if it is, then you're going to need to know what those values are. So you need to be able to do some essentially dynamic analysis or simulation of the code.
00:32:13.320 - 00:33:18.620, Speaker A: So the atomic crosschain transaction technology is a layer one solution which we've put into a fork of hyperledger beso and it provides cross chain functionality. It's designed at the moment for enterprise blockchains but could be equally applied with not much work to public chain. Assuming you had validators that you decided you trusted many of the aspects of this technology can be applied to Ethereum too. And in fact we're working on that right now to work out how this all works. To provide a synchronous methodology for Ethereum Two. This technology allows for far more complex solutions to be done than existing cross blockchain technology. So to my knowledge no other cross blockchain technology in the world can allow you to solve the hotel train problem.
00:33:18.620 - 00:34:01.642, Speaker A: So this is the only technology, to the best of my knowledge, that allows you to do it. And I'm writing a chapter in a book which I'm particularly this sort of area and I any moment now, any moment now I'm going to finish it. Yeah, finishing in the end of November last year. In fact, I've done a solid review and this is the only technology that lets you do it. So it provides composable, so composable programming. You have functions, you have classes and you can put together your program in blocks and you don't have to write everything from scratch. You can use a bit of this function, a bit of that function and call it around.
00:34:01.642 - 00:34:43.960, Speaker A: You've got that function available on that blockchain and you can link your code together. And so Ethereum One has given you that. And so this technology will give you that sort of synchronous execution of code and where everything is atomic but it's across blockchains or across shards. And so in particular intercontract inter blockchain function calls are both synchronous and atomic. If one part fails, the whole lot fails. If they all go through, they're all good. This technology is not based on hashtag contracts, relay chains, blockheader transfer or any other or trusted intermediaries or any other technology like that.
00:34:43.960 - 00:35:22.942, Speaker A: So as far as the actual topic of the talk, the actual let's design some solidity that's going to work in this context. Like any system, you're going to have to be pretty careful and you're going to have to think about what you're doing and design your system. Well, this applies to designing an application which uses solidity or normal Ethereum One. It's no different to that or no different to any other software system. You need to design it and think about what you're doing. I think that non lockable router lockable item model is going to be. Used quite widely.
00:35:22.942 - 00:36:13.106, Speaker A: I think that that is going to be a common template that you'll see. You want to be careful of any cross chain calls where you're calling into the same blockchain twice in the same call and really think about how that all works. I'm sure as the technology advances, we in the platform layer will absorb that complexity for you. But right at the moment, certainly our technology, you need to be the one watching out. And you've really got to be careful with your contract level commissioning. But that's very similar to the existing Solidity code and many applications are going to require some sort of level of business logic analysis. So simulation for each execution call.
00:36:13.106 - 00:37:05.960, Speaker A: So we've done a bit of this in our sample code and as you'll be able to see, actually, it sounds hard, but it's really simple. And we've got some public repos with code. So if you want to use the sample code, the hotel train is currently in a branch that will be pushed onto Master. Pull requests will go in and it'll be on Master sometime pretty soon, I hope. And so the talks continue. So we've renamed Artemis to Teku and Adrian is going to be here in two weeks time and he's going to tell us all about it and it's going to be awesome. Sandra is then going to tell us about the brave new world of stateless Ethereum, which is going to be good.
00:37:05.960 - 00:37:35.966, Speaker A: Patrick and Raymond are going to come in and they're going to tell us about Oracles and Chain Link and then probably Harathio and me. Maybe Harathio. Hope harathio. Yeah, it'll be harassio. Maybe it'll be harassio. Someone is going to tell us all about writing dev P to P sub protocol. If you're a blockchain researcher out there, please get in contact.
00:37:35.966 - 00:38:05.874, Speaker A: At the moment, I haven't got any speakers for that slide. And then on April the 29th, one of us who could be like Avandria, could be me, could be a combination of all of us, is going to talk about Ethereum, two cross shard, and what we're up to in three months time, which is April 29. So with that, I will say, David, are there any questions or statements?
00:38:06.002 - 00:38:42.130, Speaker B: No question. Because the cross chain work, you do have to write the contracts quite carefully. The issues you laid out are mostly, if not entirely suited for static verification. And Nithx already provides that sort of thing for Solidity. Have you given much thought to how you would amend those tools for static verification, cross chain contracts?
00:38:44.630 - 00:39:57.320, Speaker A: I've thought about it and I've discussed it with some members of that team and that team and some other teams that are in the tools area. For all of them, though, they have said, this sounds awesome, this sounds great, tell us as the technology matures a bit more, and I think they really want to know, once we have gone from a more solid complete POC, which we're almost there, including our white paper, which describes the technology in more detail. And I think at that point, then they'll say, all right, what's the route to productization? And so if we're to keep it as a POC, then they'll have one thought on it and they'll be interested in knowing about it. But if it's on the road to productization, I think they'd be interested. Are there any other questions? I dare say once we get to Ethereum Two and assuming something very similar to this ends up in Ethereum Two somehow, or rather, they'll get very interested in it at that point.
00:39:59.370 - 00:40:01.374, Speaker B: Yes, that might be a while.
00:40:01.572 - 00:40:10.640, Speaker A: Yeah, well, maybe not. We'll see. Okay, well, look, thank you, everyone. And we'll see you in two weeks time.
