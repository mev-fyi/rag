00:00:00.330 - 00:00:19.006, Speaker A: Hello and welcome, everyone. I'm Peter Robinson, and this is the Ethereum Engineering Group. Meetup. So today I've got Anthony, and he's going to tell us all about Mev attacks and about how hyperledger besu can be used to help mitigate them. And why don't you introduce yourself, please?
00:00:19.188 - 00:00:34.630, Speaker B: Sure. Thanks, Peter. Hi. My name is Anthony Denya. I'm a software developer by trade. Previous lives I've worked on the privacy implementation with Hyperledger Basu. So that was my first foray into the world of crypto.
00:00:34.630 - 00:01:08.740, Speaker B: I also worked for a company called Web Three Labs, and we were responsible for Web Three J, which is the Jarbra Ethereum client library, stroke, I guess, Framework, and currently working in the Cocorant team at Consensus. So we're looking after Cocorant, basically. So all the open source side of things for Gocorrant, which is good. Been developing software for about 20 years and yeah, that's me. Normal sort of software development stuff.
00:01:09.350 - 00:01:14.466, Speaker A: Sounds awesome. Why don't you share your slides and run us through your talk?
00:01:14.648 - 00:01:29.260, Speaker B: Yeah, let's crack on. So no, that didn't work. That one, isn't it? There we go. How's that?
00:01:31.390 - 00:01:33.130, Speaker A: Still wrong one. It's the other one.
00:01:33.200 - 00:01:41.478, Speaker B: Still the wrong one. There we go. That has to be the right one.
00:01:41.504 - 00:01:45.326, Speaker A: Yes, that's the one. Okay, take it away.
00:01:45.508 - 00:02:19.500, Speaker B: Thanks. So today we're going to be talking about Mev and what best it can do to try and mitigate some of those attacks. It's going to be very basic introduction to mev. So I'm just going to predicate this with this is not research that I've done myself. This is all taken from various other people's work. And so it's all free public information about blog posts about mev. So basically, I've just bundled that together, try to understand it, and hopefully disseminate what I've learned to you guys today.
00:02:19.500 - 00:02:49.326, Speaker B: So that's me. You can contact me there. There's a quick intro. So the first thing we need to understand around Mev is how Ethereum works. I'm just going to give a quick overview of dev P to P. So when we talk about dev P to P, it's basically the communication layer that Ethereum uses to communicate to other nodes. So with mev, the main attack vector with mev is pending transactions.
00:02:49.326 - 00:03:51.906, Speaker B: And so what happens with a pending transaction is when you submit it to the network, it propagates to everybody. So these are transactions that haven't yet been mined. And so what happens is when you initially submit your transaction to the node, it will forward that to another node, and that node will forward it to another node, and hopefully eventually one day it'll end up on the blockchain and get mined. So there's a couple of key questions that we need to sort of think about when we're thinking about pending transactions. And essentially the questions we need to ask is, where do pending transactions reside? And the answer is that they're sort of ephemeral, so they sort of exist in memory on the nodes on the network. So they're not actually made permanence but they do have some kind of permanence just by the amount of uptime that nodes have. So they do linger for a long time and basically they get mined when they get mined.
00:03:51.906 - 00:05:04.330, Speaker B: So the miner wins the race for proof of work and then chooses what transactions get mined. So we can have a quick look at pending transactions on Ether scan and you can see that Etherscan has got a view of 170, OD thousand pending transactions and these are sort of floating around the network ready and waiting to be they're transactions that people want to have mined basically. So mev is a way that miners can extract more value from the network. So previously miners would get, miners get rewarded for performing mining operations on the network and securing the network on behalf of users. And they're incentivized to do that with rewards, mining rewards, this kind of thing. They used to be very lucrative but over time they've been reduced. So miners being miners, obviously they have their own self interest, so they're looking for other ways of maximizing their revenues.
00:05:04.410 - 00:05:05.040, Speaker C: And.
00:05:07.810 - 00:05:46.940, Speaker B: You see some broncos talking about people miners not being very nice. Well, life's not fair like that. They're going to look after themselves, right? So there's a few types of, I guess it's attack. I mean some people call them attacks, I wouldn't say they're attacks. Some of them are exploits and some of them are opportunistic and some of them are attacks. I think, I think it's crucial that we try and categorize the different types of things that can happen. So the most common form of opportunity that miners can take advantage of is front running.
00:05:46.940 - 00:06:25.990, Speaker B: This is very simply doing something before you do. And because they're a minor, they have a privileged position to be able to do that. Another opportunity that they could take advantage of is arbitrage. So again, because they have this market maker stroke privilege view world of things, they can basically arbitrage different opportunities between parties. And then the last one is transaction reordering. So this is what I would consider an actual attack on the network. So we're doing something nefarious to benefit the miner.
00:06:25.990 - 00:07:37.354, Speaker B: So the interesting thing that miners have is that basically they have great power. So they have this power to sort of write history as it happens. And with that they get this privileged position finally. Can we trust miners? Well, this is decentralized. Well, so can you trust anybody? And the answer is no, we shouldn't need to trust them and we should have protocols and systems in place whereby we don't need to trust the miners and they will just do things with their own self interest in mind and that will be beneficial to everybody on the wider network. So what I'm going to do now is just run through a couple of examples of what each attack could look like and the first one I'm going to talk about is a simple front running example and these are somewhat naive but you can imagine how they would work. So what we're going to talk about here is an incentivized cron job contract.
00:07:37.354 - 00:08:41.630, Speaker B: So imagine you've got a DAP and you have some method on your contract that you want to call on a regular basis once a week or something like that. And what you could do is you could have your centralized service provider calling that method once a week. But that's not very decentralized. So you want to make sure that your contract is long lived and if the company involved with calling that method goes bust or bankrupt, the DAP can live on. So we're going to write this contract in a way such that anybody can call the method you want to call once a week and then the person who calls the method gets a little bit of a reward for calling that method on your behalf. So you might have it as Sunday at midnight you need the method to be called. So any point in time after Sunday at midnight you give the first person who calls the method a reward for calling the method and then your function gets called inside your smart contract.
00:08:41.630 - 00:10:02.766, Speaker B: So this was a situation that was set up in various sort of public so quite moderately famous one is a yield farm contract called Yeo. And their initial contracts were set up such that people were incentivized to make method calls on their contracts and the people who would call the contracts would get a little bit of reward for calling that. And this built up a network of automated bots that would basically incentivize hobbyists and this kind of thing to write scripts, to look for opportunities on their contracts and execute their methods when appropriate times. So essentially what you're doing here is incentivizing people to call your method and the reality is that they're only going to call the method if the gas price makes sense to them and yeah, it's an easy little bit of money to be made. Now the problem with this is that miners have the ultimate advantage of being able to front run you. So they can do that in a couple of ways. So if you're a minor, you can either look at the method and say, okay, that's a method that I can take advantage of.
00:10:02.766 - 00:11:04.930, Speaker B: And I will not take your method that you're calling. I will put my method in, and I will call it instead and basically copy what you've sent to the network and basically do exactly the same thing, but change the address to be me rather than you. So that's the first way they could do that. The other way is they could just be just write the automated bots themselves. And because they have this advantage of always being first in, they have the key advantage of being able to execute events. So with the example of our incentivized cron job, if the method reward gets turned on just past midnight, the miner has this advantage of sticking in the first block just after midnight. And the chances are the miner will be able to do that considerably more cheeky than somebody from the outside who's trying to submit a transaction on the block.
00:11:04.930 - 00:12:17.554, Speaker B: Yeah, the other example is a sandwich attack. So this is a little bit more interesting. So the way the attack works is by having inside an intrinsic knowledge of the contract that you're calling. And this is specific to automated market makers like uniswap. So the way that automated market makers work is basically a price curve in the contract and if there's increased demand for something, the price goes up. If you imagine that a normal sort of market volume is ten swaps between different pairs and then all of a sudden if demand spikes for a particular token or swap demand goes up very high for something, then the price goes up as well. And the way that a miner can take advantage of this is by inserting a transaction before and the transaction after your desired swap.
00:12:17.554 - 00:13:25.050, Speaker B: So that's why it's called a savage attack. So you have one before yours, one after. So if we just run through an example quickly. So if you want to buy 1000 tokens of Woofie at the current price, you would submit your transaction to the network, say I wish to buy 1000 transactions and then the miner will see this and basically in the same block they will insert their own transaction for 10,000 Woofie tokens. They'll pump the price up, you buy 1000 tokens at this inflated price and then the miner can sell their 10,000 tokens in the same block at the slightly inflated again, the inflated price again and then the price comes back down. So it's essentially extracting value from the person who wants to buy 1000 tokens. So just to reiterate, they're basically pumping the price up for those 1000 tokens and the amount of money they lose, they get back with the initial purchase followed by the subsequent.
00:13:25.050 - 00:14:16.990, Speaker B: So how can you mitigate against this kind of attack? Well, we see things in uniswap and balancer. We talk about slippage. Basically we're saying we only want to pay x amount from the current price when you supplement the transaction. So if the current price of Woofie tokens is, I don't know, one ether Woofie, you'd say that I'd only be willing to pay 1.5 e per wufie token but the miner still has an opportunity to maximize the price. So if they're seeing that you're willing to pay plus or -5% for your token, they can still do the attack, and they'll just basically pump the price up to the point where your slippage is. So there's still money to be made there but it sort of disappears somewhat.
00:14:16.990 - 00:15:26.710, Speaker B: The other option you have is to reduce the attack vector that somebody has on you and that's basically to chop it up into batches. And again it reduces the sort of big red flag of I want to buy this big position. The interesting thing is this is not new, so it's not something that's suddenly been invented crypto specific. We see this kind of behavior and dynamic in normal markets and you see things like high frequency trading and that kind of thing. There's a decent book around called Flashboys around how that looks and the tactics that people use in market training to gain advantage in a normal sort of stock exchange market. We normally call this normal market size. And what we talk about there is in the middle in a normal stock exchange you'll have a market maker and you go to your market maker to place a trade and you go to your brokerage place trade and the broker market maker.
00:15:26.710 - 00:16:32.342, Speaker B: But essentially the market maker holds a bunch of stocks and shares as available for purchase and sale. And when we talk about normal market size, as a trader you normally keep your trades below normal market size such that the market maker doesn't need to go anywhere else so they'll always be able to fulfill it and it won't shift the price too much. If you put a massive trade through of say you wanted to buy 10% of BP or something like that. If you tried to do that as a trader, obviously the price of BP is going to skyrocket and everybody in the market knows you're trying to buy BP. So there's sort of normal dynamics at play there. The next attack that we're going to look at is a rewriting history. So if we think about proof of work, what we're doing is we're competing to find the next block.
00:16:32.342 - 00:17:56.280, Speaker B: So the miner has the opportunity at that next block to basically write history at the top of the block. Now one thing a miner could do if they've got enough hash power to do it, is to rewrite history for a few blocks or so. So if you spot something happening on the blockchain a few blocks ago, a particularly large trade that you could either front run or take advantage of or do a sandwich attack on, the miner could rewrite history in theory, but it'd be incredibly expensive to do so. So the opportunity would have to be so high that it would be worth the miners effort to do this. So imagine that miner sees this opportunity a few blocks ago, what they could do is rewrite history, take advantage of the situation and basically mine three or four blocks on top of it and then all of a sudden you're the highest block and the rest of the network sort of flips over towards you. Is it possible? But realistically you have to have massive hash power to be able to do it. And you're sort of talking like 30, 40% of the network to feasibly be able to do this kind of thing.
00:17:56.280 - 00:18:09.114, Speaker B: Essentially what you're doing is you're temporarily taking over the network to run the attack. Who knows? Is it possible? Yeah, it's possible. Has anybody done it?
00:18:09.152 - 00:18:09.946, Speaker C: Don't know.
00:18:10.128 - 00:19:10.742, Speaker B: I'm sure there's some research that you had there. Okay, so possibilities to protect against these kinds of things. So we talked a little bit about obscurity or obfuscation. So the first option for obscurity is to reduce your footprint and reduce your transaction sizes so that it's not a big red flag of I'm trying to buy 10% of BP or loads of Woofie tokens or whatever. The other option you can do is try and obscure your transactions in nested contracts. So the miners will look for transactions directly to if you're a miner and you're looking for opportunities, you're going to look at the most obvious ones. So you're going to be looking at transactions to uniswap and you're going to be looking at the method calls that people make on uniswap.
00:19:10.742 - 00:20:06.878, Speaker B: So what you could do is obfuscate your calls to uniswap by making them internal transactions and it might become less obvious what you're doing. But it's not really security, is it? You're just obscuring what you're doing somewhat. There's a few other options around layer two roll ups, specifically a couple of companies. There's Optimism and Starkware, there's some links in the references, you can have a look at those. But essentially what we're talking about is moving things off the main chain and just having the final result ending up on mainnet. So you can do all your stuff, all your trading somewhere else behind closed doors, so to speak, and then just notarize the result on the main chain. The other options are to basically fix it at an application level.
00:20:06.878 - 00:21:09.246, Speaker B: So with regards to the Cron job, I don't think there's an easy way to fix that. I think you're kind of okay to from an application point of view, if you're building that application, you don't really care that much as long as your method gets called. With regards to automated market makers, the application level side of things, the solution at the application level is things like slippage. Yeah, it's basically writing your way out of it. The other option, last and final option you have is to not get front run is to run your own node and get mining. But realistically you're not going to be able to mine transactions. There's so much hash power out there that you sort of one in a million chance of being able to actually mine your own transactions.
00:21:09.246 - 00:22:17.560, Speaker B: It's very unlikely. I mean, depending on your situation, if you're desperate to hide what you were doing and mine your own transactions, you could provided that you are happy to wait a long time for that to happen. But realistically, mining pools exist for a reason. And I think unless you're an extremely large bank or someone with a lot of resources. You're not going to start your own mining pool just to do a few transactions, but who knows, you might see that over the coming years, as more institutions start using ethereum, we might start seeing some dark pools exist for institutions whereby they can submit their own transactions. So what I'm going to do now is just pause for a few minutes and see if there's any questions that have come up. Peter, is there anything in the chat or anything?
00:22:19.790 - 00:22:30.018, Speaker A: So in the chat, let's have a look. So Lekki said, what do you think for mev after the merge?
00:22:30.134 - 00:22:31.338, Speaker B: Would it still exist?
00:22:31.434 - 00:22:35.200, Speaker A: Would the situation be better or worse? Thanks.
00:22:36.930 - 00:23:01.046, Speaker B: Honestly don't know. I don't think anybody ultimately knows. Will it be better or worse? It'll be different. And I think the dynamics will change such that you still have this privileged position as a validator. So, yeah, I don't know, to be honest.
00:23:01.228 - 00:23:11.660, Speaker A: I was going to say Mikhail's on the call and he's leading up the merge effort, so he may have some thoughts. Mikhail, are you able to give your thoughts on that?
00:23:12.430 - 00:24:26.850, Speaker C: Yeah. Hey, guys, first of all, I think I'm pretty sure that MOV will exist after the merge. Of course, there will be some change, probably in the way that mev could be extracted. There is a proposal by Flashpots for mev democratization after the merge, but I think in general, all these types of attacks and the general mechanics will stay unchanged after the merge. There is still the opportunity to yeah, I would say that there will be much less opportunity of one proposer to steal an mev of the other proposer, because it's more difficult to do the ReWalk in the proof of stake system than it currently could be done in the proof of work. But from the user perspective, not sure that a lot of things will be changed. I'm not like much into movie and yeah, that was just a bit of my opinion.
00:24:26.850 - 00:24:29.250, Speaker C: So it will exist.
00:24:29.750 - 00:25:24.354, Speaker A: Thank you. And so the next question, there are two interrelated things. When you were talking about a 40% attack or something, and people would lose confidence in the minor and that might compromise the value of the coin that they're mining. So if you had a large mining pool and then Mark said confidence in miner, if being trustless means anything, surely at least it means not being dependent on being confident on any single miner. Though with Ether miner neftopool arguably close to being big enough to put that at. Yeah. And then we had Ronnie saying, but there's reputation finally.
00:25:24.354 - 00:25:43.930, Speaker A: Then I put on, wouldn't it be good when we moved to proof of stake? Because once we are at proof of stake, my understanding is we won't have or we'll have a lot more different parties being part of the consensus. And so hence you're not likely to have, say, one miner mining, say, multiple blocks.
00:25:44.590 - 00:25:59.280, Speaker B: True. But I think with proof of stake, the dynamic changes slightly in the sense that if you've got a massive if you got a big stash, a big stake, you could leverage that in the same sort of way. So I think it just changes.
00:25:59.730 - 00:26:00.800, Speaker A: Yeah, okay.
00:26:03.590 - 00:27:12.760, Speaker C: If you have a big stake, you could be a proposer in a few slots in a row or yeah, you will know in some advance what slots are you proposing at and if your stake is relatively big. So you can be not probably sister slots, but something that are very close and use this opportunity anyhow. Also in the propostatic, from my understanding, the relationship between searchers and proposers, which are block producers, should be changed because we have much less miners today, as I understand the parties that are connected to searchers directly, then we are going to have an approval stake. So it should somehow be adjusted. I mean, the flashboard architecture, this is what they are working on currently. They are trying to do this without change to the consensus, to the.
00:27:15.930 - 00:27:16.390, Speaker B: Yeah.
00:27:16.460 - 00:27:24.762, Speaker C: That'S from the proposer and searcher perspective, not from the users. Yeah.
00:27:24.816 - 00:27:32.350, Speaker A: Okay. Roberto asked, are you aware of any work on obfuscation mitigation techniques?
00:27:34.930 - 00:28:05.206, Speaker B: Not exactly. However, the most obvious one would be zero knowledge proofs. And yeah, that would probably be the most obvious one. If you're thinking of kind of like fuzzing stuff like you would in normal sort of code base. Not explicitly. The only thing I've seen is trying to hide the transaction in an internal transaction. So deploy your own contractor, call the contract you want to call.
00:28:05.206 - 00:28:06.790, Speaker B: Yeah, that makes sense.
00:28:06.940 - 00:28:10.780, Speaker A: And sometimes simple things are all you need as well.
00:28:12.030 - 00:28:36.500, Speaker B: Yeah, if we just have a quick look on ETA scan, you probably see some transactions going through where transactions ETA scanning can figure out where the transaction is going to and what method you're calling. Then somebody trying to front run. You can see it as well. Right.
00:28:37.430 - 00:28:56.950, Speaker A: And you could imagine you could just, I don't know, even rot 13 it or just even just if you had your data and converted it to uint 250 sixes and then just shifted it by one bit, that will confuse things significantly as well. And that pretty simple to decode.
00:28:57.450 - 00:29:09.500, Speaker B: Yeah. And it would just put the minor off a little bit. It's increasing the cost of figuring out not foolproof, but yeah.
00:29:10.190 - 00:29:50.050, Speaker A: So there are two other things here. Quickly. I know there was someone who said, I know Panther Protocol working on wrapping assets, making it private, and Sly said, but does that take longer to withdraw stake than to switch hash power? And I don't get I'm sorry, I'm not catching slice question there, so I'm not sure sly, if you've got a few secs, you can quickly jump in and tell us your question. Sly, who's on mute, but maybe can't get to his might be traveling.
00:29:52.950 - 00:30:14.460, Speaker D: Yeah, I'm listening. While traveling. No, I was just saying that F two might be harder for a like if a minor, you have to suddenly switch hash power around. So probably less chance for them to suddenly dump a hold of hash power, do an attack and then leave because once stakes in, it's much harder to get out.
00:30:17.390 - 00:30:51.746, Speaker B: Yeah, I see what you mean. They're committed to the network rather than just mining per se. Yeah, it's possible. I still think the dynamic is going to be different because when you talk about hash pal, there's a certain level of security in purchasing hardware to do it. So the actual physical cost of doing it is, I think, going to be lower with proof of state because you don't need as much hardware, you just need a big bundle of ETH.
00:30:51.938 - 00:31:14.430, Speaker D: Yeah. Attacks will still exist. And I suppose for something like Ethereum, it doesn't really matter, whereas if you had a very small coin, if I had a whole bunch of hash power in Bitcoin, I could suddenly take over one of the smaller coins like no tomorrow and yeah, much more vulnerable.
00:31:16.050 - 00:31:17.040, Speaker B: It's true.
00:31:18.130 - 00:31:48.220, Speaker A: Gone I was going to say, the other thing to recall is you can rent hash power and I think if you've got, say, half a million dollars, you can rent a significant amount. I think you can essentially and it's classified on different blockchains and the proof of work algorithm and everything, but there are limits to what's available. Yeah. Anyway, look, why don't you continue with your talk and then we can come back to questions at the end.
00:31:48.670 - 00:32:45.494, Speaker B: Sounds good. So what we're going to do, so I'm going to half talk about what was somewhat alluded to in the questions is we're going to write a little basic plugin and we're going to basically mimic a trusted mining pool. So the idea with this is that in a very non decentralized way, we've sort of stumped up together as a bunch of friends and decided to create this mining pool. You can imagine it as a consortium of banks, perhaps, or something like this, whereby we're going to submit transactions to the network, but we're going to keep those pending transactions to ourselves before we mine them. Okay. I think I've covered everything there. It basically behaves as a normal network and we're going to take advantage of bestie's plugin framework.
00:32:45.494 - 00:33:29.930, Speaker B: We could do this with just static nodes. So one thing you can do when you set up your node is you can just say, I'm only going to connect to these nodes, but we're going to do something slightly different. So we're going to connect to the wider network. So we're going to connect to the entire network for most situations, but what we're going to do is decide who we're going to send pending transactions to and we're only going to send pending transactions to our trusted miner. So let me just switch over to IntelliJ. Where is the share screen button? Gone there we go. So I'm just going to run through a bit of code.
00:33:29.930 - 00:34:37.530, Speaker B: So what we've done is we have created a basic plugin and we've registered with the permissioning service, which is responsible for basically deciding whether or not you can send messages or whether you can connect to peers. So there's a couple of methods on there you can basically hook into when a message is sent and you can also register when you connect to a node in the code. What we've done is we build a fat jar somewhere. Where is it? Some shadow jar. There we go. So we built a big shadow jar and we copy that into Docker image, which is based on Besu. And we basically take the jar, we put it in the plugins directory and then we start basing created a simple docker compose which has three nodes.
00:34:37.530 - 00:35:31.486, Speaker B: We've got our miner, we've got Alice and our Arbitrage bot. Now we're using the plugin in every single one. The reason for that should come clear in a minute, but the important thing is that the Arbitrage bot could be using any version of any sort of Ethereum client. But it's important to know that our mining pool and our sender are using the plugin that we've written. So very simply, what we're going to do is we'll run the code and we'll see that this method gets called for every single message that's fired out from Besu. And I'm just going to intercept dependent transactions, message type and print it out. So you've got all the different types of messages that get floated around the network.
00:35:31.486 - 00:36:44.430, Speaker B: And the one we're really interested in is two, which is pending transactions. All right, so hopefully this should run. So what we're doing here is just deploying just a simple storage contract and then setting the value to 42. So we should see a couple of transactions go through the network and yeah, that's it. Basically, we're starting Docker compose, waiting for it to come up and then deploy the contract with Web Three jet. You can probably hear my laptop taking off. So as we are skiffing through the long let me just make that a bit bigger.
00:36:44.430 - 00:37:39.326, Speaker B: So we see what's happening here is when we're so Alice is deploying the contract. If I just go back to here so we can see that we've got our connection to Alice on the RPC port, we're deploying the contract through Alice first. You can see that Alice is deciding whether or not to send that pending transaction to the mining pool and the Arbitrage bot, the Arbitrage bot gets the message. So this is the pending transaction and they're deciding whether or not to send it to the mining pool. And then the mining pool also gets the message again and they're deciding whether to send it to the Arbitrage bot. So we're basically propagating the message. So everybody in the network has got these pending transactions now, so that's the first one.
00:37:39.326 - 00:38:32.162, Speaker B: That goes through and then the same again for the second one. So again, now this goes so it's slightly different, but the mining bot goes to the Arbitrage bot. The Arbitrage bot goes to the mining bot. Very simple. So next what we're going to do is we're just going to intercept the message and super simple, all we're going to do is just saying from sending a pending transaction, if it's not the mining pool, I e. This guy, we're not going to send, we're going to block the message. So what we should see now, and hopefully this is kind of cool if you're into development, the way this works is it will say grade all, figure out the change, rebuild the jar, rebuild the docker images, and then run everything for you.
00:38:32.162 - 00:40:11.246, Speaker B: So it should all just magically work, which is quite nice, I think talking earlier about how much resource Zoom uses might be quite a bit. All right, I'm going to switch to the backup. And I did this last night. You should be able to see I'm just grabbing the logs from yesterday. It's going now. Let's wait for that one to finish. I think you just caught it through there.
00:40:11.246 - 00:40:46.574, Speaker B: So the transactions going through, you can watch it go through. So you can see that the mining pool. So we've got Alex again sending the transaction to the mining pool. And then it's asking again, is the message permitted to the Arbitrage bot? And we're saying no, so we're not going to send the message to the Arbitrage bot. And then we can see that the mining pool receives the message from Alice. So this is receiving the pending transaction. Then again, it's asking the question, can I send this message? Can I forward it to the Arbitrage port? The answer is no.
00:40:46.574 - 00:41:15.700, Speaker B: We're going to block the message to the Arbitrage port. As far as everything else goes in the network, it behaves exactly the same. We're not just connected to Alice and the mining pool. We are connected between all three. It's just that we're deciding that what we don't want to do is send pending transactions to the Arbitrage bot. That's it. Super simple.
00:41:15.700 - 00:41:22.858, Speaker B: But if I just head back to the slides is I was going to.
00:41:22.864 - 00:41:24.810, Speaker A: Say super simple, but very effective.
00:41:25.390 - 00:42:04.578, Speaker B: Yeah. Um, linked to the code, it's linked to a load of references that I've used to build it up. So does this exist? And so when I did the talk a couple of months ago so this network is starting called Tai Chi Network, which was exactly this. So they started this sort of trusted mining pool whereby you could connect to them to submit transactions. And they basically built this, which is kind of cool. Oh, great. This is a great example.
00:42:04.578 - 00:42:25.520, Speaker B: But yeah, they shut down a couple of weeks ago, so I don't know if anybody's actually doing this anymore or or anything like it. That's that cool. So pause to see if there's any questions about the code.
00:42:25.890 - 00:42:54.490, Speaker A: Yeah, are there any questions about the code? It was very interesting to see the plugin architecture and just how simple it is to do something like that. That was actually intriguing. Here I am. I've worked at Consensus and in Protocol Engineering for four and a half years and first time I've seen that, so that was actually interesting.
00:42:55.260 - 00:43:36.790, Speaker B: Cool. We put that in for a company called All Funds. So we basically added a couple of bits to the plugin architecture for them. And the way they've got their network set up is that they have a consortium of banks and a centralized, validator pool. So what they want is they don't want the banks to talk to each other and that they have exactly this. They only want to submit transactions to the centralized pool, so they want to dictate where those transactions and where those messages go. So it's something that people are using on private networks, but not seen it used on main net.
00:43:39.240 - 00:43:51.850, Speaker A: Oh, interesting. So Leki said, is it similar to flashit or flashbot? Otherwise, what's the difference?
00:43:54.240 - 00:43:58.430, Speaker B: Don't know. Sorry.
00:44:00.080 - 00:44:14.290, Speaker A: Yeah, I don't know what Flashbot is, so hence the comparison is difficult for me. But if you could reshare that last slide for a SEC, that'd be really good.
00:44:14.820 - 00:44:24.004, Speaker B: Yes. So, a couple of references. The slides should be available and that's the one. Yes.
00:44:24.042 - 00:45:15.748, Speaker A: Thank you. Yeah. So the symposium, I'll quickly run through the forthcoming talks. So if you live in Brisbane, or can manage to fly into Brisbane, which could be a mean feat getting into Australia or even getting into Queensland, but I think we might have the borders sort of open by then. But anyway, there's an in person blockchain event in Brisbane and registrations can be accessed from there. It's $100 registration fee and that's really just to cover the event, hire and food and such like. In two weeks time, I'm going to go through the solidity test that I've used when recruiting people and we're just going to run through it together.
00:45:15.748 - 00:46:08.724, Speaker A: And so please have Remix ready to go on your own laptop or computer and it'll be interesting to test everyone's blockchain and solidity knowledge. And, Anthony, if you're prepared to get up real early in the morning, you can come along too. Anyway, two weeks after that, we're going to have a networking and recruitment event. And so if you're an employer, please reach out to me and we can work together to have a group of probably half a dozen or so employers. And if you're looking for a role or even just finding out who's out there, or you just want to chat blockchain with people. So that's going to be an online event in January. I'm going to do another advanced solidity talk.
00:46:08.724 - 00:46:46.848, Speaker A: So the one I did two years ago is feeling rather aged now, so there's a whole heap of extra solidity stuff that I want to talk about. We've got a slot in there between those two talks in January and February for another talk. Don't know what we're going to talk about at that point. If you're interested in doing a talk, it would be great. And Mikhail, you're still on sometime in February. It would be really interesting for you to do a talk on the merge because by then the merge will be like real soon. And I think it'll be really interesting to hear like one year after your original talk, a new talk on where things are at.
00:46:46.848 - 00:47:15.630, Speaker A: So it'd be great if you could consider doing that. And Roberto is going to do a talk on the February the 9th on Qbft and the formal verification of that protocol. And Qbft is a protocol for consortium blockchains. It sort of builds on IBFT. So are there any questions or thoughts about all of that?
00:47:20.320 - 00:47:40.710, Speaker C: Thanks for invitation. I hope I can give some update on February. Probably there will be more, even more information than currently is about the merge and when it happens.
00:47:42.760 - 00:47:47.380, Speaker A: Yeah, I think that'll be very interesting for everyone, right?
00:47:47.450 - 00:48:08.030, Speaker C: Because currently we are about to run the next iteration of devnets and it should end with the persistent DevNet that will likely run until January. So February is like, yeah, good time for the talk.
00:48:08.880 - 00:48:33.350, Speaker A: Sounds great. All right, look, Anthony, thank you very much for doing your talk today. That was incredibly good. So thank you very so and thank you everyone else for coming along. It was great to have all the comments and questions. So talk to you all later and yeah, thank you.
00:48:33.800 - 00:48:34.692, Speaker B: Thanks so much.
00:48:34.746 - 00:48:38.000, Speaker A: Thanks, Anthony. Anthony.
