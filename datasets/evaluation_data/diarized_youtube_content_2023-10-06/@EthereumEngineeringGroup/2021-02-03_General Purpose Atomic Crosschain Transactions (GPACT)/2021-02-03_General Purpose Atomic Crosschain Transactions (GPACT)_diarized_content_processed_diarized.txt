00:00:00.970 - 00:00:49.260, Speaker A: Hello and welcome to the Ethereum Engineering Group meetup, I'm Peter Robinson, and today the speaker is me. And I'm going to talk about Gpact, the general purpose atomic cross chain transaction technology protocol. And I will share my screen in a SEC. And why can't share my there we go, share screen and I'll share that. So hopefully so can people see my slides? So can people see yes, I've got a thumbs up. That is good to see. All right.
00:00:49.260 - 00:01:58.900, Speaker A: Okay, so the Gpact protocol. So Gpact is a L2 protocol that uses a call graph commitment scheme to provide atomic cross chain function calls. And so unpacking that a little bit. So what do I mean by blockchain L2? And so what I mean by that is you can think of the network layer, so TCP IP as layer zero, and the actual blockchain platforms themselves, like Ethereum are layer one and L2. I think of as all of these protocols where you can do off chain stuff that is linked to one chain, the wallets, the Oracles and other things. And so this is one of those L2 protocols that lets you build on the underlying platform. So it's something where you don't need to change the software of Ethereum to get working.
00:01:58.900 - 00:03:25.070, Speaker A: A call graph is a set of functions where one function, calls another function, calls, another function calls another function. And so, for instance, you can imagine you've got this execute trade function in the trade wallet contract, which calls the stock shipment function, which calls get price and transfer and delivery. And so these functions together make up a call graph. A call graph commitment scheme is where you have a call graph and then you commit to executing that core graph and everything goes well, assuming you execute the call graph and the actual executed code matches what you plan to execute. Atomic means that, say, if there are updates in more than one blockchain, those updates either both or all go through or they're all discarded. So you don't have updates that go through on one chain but not on another. So you have consistent state across the chains and blockchain or cross chain function calls is when you have one contract being able to call the functions of another contract on another blockchain.
00:03:25.070 - 00:04:47.186, Speaker A: And the links there, the Open Access Research and GitHub, which you could see on the other slide, they're links to the paper that describes the technology in quite a lot of detail. And the GitHub repo, which has a reference implementation, an arbitrary call depth. So the system is designed to allow for not just say, between, say, two blockchains, but between, say, many blockchains and many call depths. So you could have one function calling another function, calling another function calling another function. So today I'm going to introduce a scenario that we're going to use the whole way through the talk. And then I'm going to talk about cross chain consensus and then talk about this protocol and how it builds on that underlying cross chain consensus, and then talk about the implementation, the analysis, and things that need to be done. So let's think about this trade finance scenario that I've briefly touched on with that core graph chain.
00:04:47.186 - 00:05:50.290, Speaker A: And you have a trade wallet contract. And so this could be some multi SIG wallet or in some way that many parties can sign and they can say, yes, we are happy with that, an event has occurred. So maybe some goods have arrived and they should be paid for. And so all these signatories would then put their signatures into this contract and then someone would then do the final let's execute the trade. So execute trade, then calls into the business logic contract and says, we've got a shipment, and the shipment might then call the Oracle contract which gives the current price for the goods. And then given the quantity and the price, you then change the balances by the transfer function and then you indicate that the goods have actually been arrived by the delivery function. So you could probably argue that maybe all of these contracts could be on the one blockchain.
00:05:50.290 - 00:06:41.870, Speaker A: Maybe. But you could imagine that people involved in trade finance are likely to be different parties to the ones involved in logistics and they may not actually want to have each other on the same blockchain. So you might have some parties that are on both, but many of the parties won't be. So you could easily find the trade finance and the logistics to be separate. The actual terms could be a private blockchain where the terms and the logic that are going to be used might have been agreed by the parties, but may not be public. And the Oracle blockchain, it could be a paid for service. So you could be running a blockchain which gives very good prices and up to date information, and you could charge people for being able to gain access to that blockchain.
00:06:41.870 - 00:07:47.474, Speaker A: And the trade wallet, you could, for instance, decide that you wanted to keep the members who have to sign that wallet secret. So you could have that as a separate block on a separate blockchain too, potentially. So just in case you didn't work through the words or you want to read through, there's this. And so when I publish the slides after this call, you'll be able to read through that. So the underlying lining mechanism that is needed is a way of doing cross chain trust. And so why cross chain trust is important, is invariably you don't have the same nodes on all of the blockchains. And so for instance, enterprise two is on blockchain B and C, enterprise three is on blockchain A and B, but only enterprise one is on all three.
00:07:47.474 - 00:09:00.438, Speaker A: And so, for instance, if you're on Enterprise Three and Enterprise One says, look, this has happened on Blockchain C. So given that has happened, you should do this. You're really not going to be sure unless you've got a good way of doing cross chain consensus and being able to prove that something has happened on that other blockchain. And so in Ethereum we have the concept of events and many other blockchains have similar types of things as well. And so an event is where you emit some information programmatically that you can then later on use. And so you define an event, as I've shown here, say, start, and you take some parameters and then within a function, you can then call the event by going emit and then the name of the event and you pass in some parameters. And so that's how you would use an event from a solidity perspective and then from the actual blockchain.
00:09:00.438 - 00:10:04.970, Speaker A: So the events are stored in transaction receipts. So when you send a transaction on Ethereum, a transaction receipt is created and all of the transaction receipts for all of the transactions in a block are put into a merkel patricia try. And for each transaction receipt you have the information that's shown in the blue box there, importantly the event logs. And so the event logs contain the address of the contract that emitted the event, the topics. So a topic is the function signature but also it can be if you've got an indexed parameter, it can be the indexed parameter value as well and also it's got data as well so that it's the RLP encoding of those parameters that were passed into the event. And so how you could use these events is you can imagine you've got a source blockchain, and you've got a target blockchain. And on the source blockchain, you have a transaction.
00:10:04.970 - 00:11:28.790, Speaker A: And due to that transaction, an ethereum event is emitted. Due to so that can imagine you've written that solidity code that when you execute that start function, that start event is emitted. So then you have a node, a relay node that sees that the event has been emitted and it takes that transaction receipt and that event and then somehow or other creates a transaction with some trust information and submits that to the target blockchain. And then you've got another transaction with the actual event in it and you submit that to the target blockchain and then utilize that in conjunction with a contract on the target blockchain to then execute some functionality. But the big question is so why should the target blockchain trust the information? How can it trust that? So there are a few ways of doing this. So one way is direct signing. And so you can imagine you register the public keys of validators that are on the source blockchain into a registration contract on the target blockchain.
00:11:28.790 - 00:13:07.198, Speaker A: And so you set threshold number of signers from the source blockchain so that then on the target blockchain you're going to trust that event. And so showing that diagrammatically you've got a threshold number of these relay nodes work together to sign the event. And then one of those relay nodes will have the event and the threshold number of signatures and it'll package that up into a transaction and execute the transaction on the target blockchain. So the disadvantage of this of course, is that if you've got lots of transactions that are going from one blockchain to another, you're going to be signing and doing all that work for each and every event. But on the other hand though, you know that you're only signing the events that need to go to that target blockchain. So if you had say, some blocks where there were no events going across, you wouldn't be wasting time signing something when it's not going to be used of validators on the registrar contract on the target blockchain. And you could have the block headers or transaction receipt routes signed by a threshold number of validators from the source blockchain such that they can be trusted on the target blockchain.
00:13:07.198 - 00:14:31.358, Speaker A: And then you prove that an event is related to a transaction from the source blockchain by presenting a merkel proof for the transaction receipt. So again, you've got that transaction which emits an event. The relay nodes work together to sign a block header or a transaction receipt route, they package that up into a transaction and then that gets trusted by the target blockchain because a threshold number of signers were trusted. And then later on you submit a transaction to the target blockchain with the ethereum event, and also with that Ethereum event you need to have a merkel proof as well. So the disadvantage of this is that you're either going to be signing and submitting all the block headers from the source chain to the target chain or you need a way of determining which blocks should be transferred. And the advantage is though that you're only transferring or doing all that signing for one time per block. And so say if you had say 200 transactions per block and you had say 20 transactions that needed to be transferred, then you'd have to be doing 20 separate signings.
00:14:31.358 - 00:15:34.870, Speaker A: So that would be potentially a lot of work. So maybe doing, in that case, doing it at the block level would be better. Another way is essentially what BTC relay team did. And so the idea is that you register on the target blockchain, the starting block, so the genesis block or a starting block that you're going to use from the source blockchain, and then you transfer the block headers and the block headers are accepted if the proof of work nonce is correct and the mining difficulty is correct. And also obviously that the blocks are linked together with the hashes. And so you can have many relayers. And so relayers might be posting from forks of the blockchain, but at the end of the day they'll be the longest blockchain.
00:15:34.870 - 00:16:47.600, Speaker A: And so you'll be transferring blocks from the longer blockchain and then the contract automatically works out, which is the longest blockchain, and discards the non longest blockchains. So your events are then proven using a merkel proof. So in many ways it looks similar to the last scenario, but in this way you're not signing anything, it's just down to the source blockchain's, proof of work, mining difficulty and its connection, its linkage between blocks. So the obvious disadvantage is that you've got to have a proof of work blockchain as the source blockchain and the hashing power has to be pretty strong, otherwise someone might be able to create a false block. And so all of the blockheaders have to be submitted and so you can't miss out a block in the middle. And the public version of BTC relay relied on crypto economic incentivization. And my theory on why it failed is because not enough people used the service and hence the relayers weren't being paid.
00:16:47.600 - 00:18:13.350, Speaker A: But the advantage is that it only relies on one relayer being honest. So the other methodologies where you're doing threshold signing, relying on less than threshold signers, being honest or being dishonest, so that's a real advantage and you're not actually relying on people signing, it's just based on the source blockchain's strength, if you will. Another mechanism is you could use an aggregation chain and so you could register all of the validators from the source chain with the aggregation chain, and then you could register the aggregation chain with the destination chain, with the target chain. And so you're doing everything via an aggregation chain. And so you can imagine you might have many source blockchains and many target blockchains, and the target blockchains would only be having block headers transferred from the aggregation chain. And so it means that you're not having to submit blocks all over the place to all different chains, it would only be on one single aggregation chain. However, this has obviously got the issue that you're starting to increase the latency and you're again going to have to be transferring all the block headers to that aggregation chain.
00:18:13.350 - 00:19:37.938, Speaker A: And unless you want to try and work out which of the blocks should be transferred, which might become complex application logic. But I guess the big point is that you're only transferring to the aggregation chain and you're only having blocks or transactions from the aggregation chain to the destination chain for registering the blocks. So another thing to consider is finality. A transaction is only deemed final when the block that contains it can't be changed. I actually did some analysis on this and there's a paper down the bottom there, but essentially in Bitcoin you've got say, six block confirmations and in Ethereum maybe it's about ten. And that is assuming that you've got someone attacking with 30% mining power, which is just ludicrously large, that would be, I think I've put in there half a billion dollar investment, but for bitcoin it's significantly more. But yeah, if you wanted to have one in a million certainty, you'd need to wait for six or ten blocks on consortium chains.
00:19:37.938 - 00:21:02.800, Speaker A: Say if you're using IBFT Two or something like that, you have something called instant finality, whereas as soon as a block is created, it's final. And so to try and work with these different amounts of finality, I've defined an idea which is finalized block period, which is essentially you talk about how many finalized block periods does something take, and it's all going to depend on the source blockchain as to how long the block period is for that source blockchain. So finality is important because when you're sending a signed event or a blockheader from a source chain to a target chain, you need to be certain that the event is final and that it's not going to be reorganized. So you need to wait for the source chain to be final for the blockheader transfer or transaction receipt transfer mechanisms. When you submit the blockheader to the target chain, you're going to want to wait till that's final. I mean, you could put in a transaction which relies on that block header, but then you risk having it reorganized and your transaction which relies on it then would become invalid. So you'd get charged gas for something that wasn't going to work.
00:21:02.800 - 00:22:33.470, Speaker A: So comparing all these consensus mechanisms, you can see that direct signing, you're going to have to be signing all the time, but it's going to get the event there quickest because you've just got to wait for the source blockchain to become final. The other mechanisms, you have to wait for more finality, so there's higher latency, so you got to wait for the source chain and the target chain. But on the other hand, though, if you're going to be doing lots of transactions between chains, the blockheader transfer using signing could be good, and using an aggregation chain would be good if you've got a huge cluster of blockchains and they're sending transactions to each other all the time. And so the rest of this talk assumes that you use one of those mechanisms underneath your overall system. And so it doesn't matter which one you use, as long as there's a way of getting ethereum events from a source chain to a target chain. And so I've talked for a fair bit and before I PROCEED, are there any questions? Cool. Okay, let's talk about the protocol.
00:22:33.470 - 00:23:57.486, Speaker A: So the first thing that you need to do is you've got that call graph and you need to simulate the call graph that you expect to execute. And so you're trying to work out what are the parameter values for the entry point function calls for the contracts on blockchains. And so you might need to fetch state from the contracts to get the current values. And then you need to simulate the code based on the parameter values that you plan to put in. And so if you can think of this overall set of contracts and code for each of those entry point functions for a blockchain, you're going to need to work out what the parameter values need to be and call graph simulation. You've got to think about say when we're here and we've got the Oracle contract and we're getting the price, then that price is then passed in and multiplied by the quantity to get the cost. And then that cost is a parameter that's passed into the transfer function and the other parameters from the shipment function call are passed through and into these other function calls.
00:23:57.486 - 00:25:16.030, Speaker A: So you need to be simulating and working out what the parameters are going to be for the other function calls. And if you had conditional logic, you'd have to then be thinking, well, what will be called and what will not be called? So you need to create that call graph. So once you've thought about that and got that, then you need to be sending in information into the cross blockchain control contract. And so this contract helps to control part of the cross chain call. And so you deploy an instance of this contract on each of the blockchains that are going to participate in the cross chain function call. And so the address of this contract needs to be registered along with the set of signers on all of the target blockchains in their registrar contracts. And so this will allow events that are emitted by the cross blockchain control contracts to be trusted because you need to be trusting that it's that contract on that blockchain that emitted that event and it's a trusted contract.
00:25:16.030 - 00:26:31.458, Speaker A: And there are four main function calls that are available. And so the start function is called to register the call graph, so it registers that this is what we're going to execute. And so you register it on the blockchain that has the entry point function call for the overall call graph. And so when an event gets emitted, the start event, and that has the cross chain Identifier, the call graph of what you plan to execute. So this is where you're committing to what you're going to execute and a timeout in terms of this root blockchain's timestamp. And also another thing is that you're registering what account you're going to send all of the parts of the transaction from. You've then got segment function calls and so on the different parts of the call graph that aren't the root, they're called segments.
00:26:31.458 - 00:27:38.982, Speaker A: And so you call the segment function to request that one of these parts of the overall core graph is executed. And so you pass in the start event which has got that core graph in it and segment events. So you may have had another segment event that was executed that has a return value that gets consumed by this segment. So for instance, you remember there was a get price which returned a value. You would have the one up function from that would need to have the segment event with the return value from the get price function and then you would bring that in and so you would have signatures of validators from the other blockchains, from the blockchain executed on and the segment events executed on so that those events can be validated. And as well you need an indicator of where does this segment fit within the overall call graph. So then the call graph gets executed and a segment event gets emitted and you've got the cross chain Identifier gets emitted.
00:27:38.982 - 00:29:02.690, Speaker A: So helping you know that this is part of that overall cross chain call and the message digest of the call graph so that you can say that this is definitely the call graph that was executed, the location within the call graph that was executed, the return result or an error result if the function failed, and a list of locked contracts. So you may have locked some contracts whilst executing. And we'll talk more about locking soon. So the root call is called on the root blockchain and it's got the entry point function call. And so similar to the segments, it takes a start event and segment events and a set of signatures of validators and the root event is emitted by this call. And so the root event is going to indicate that everything should be committed or it's going to say all of the updates should be discarded. So if any of the segments fail, so they've got error results, or if an error occurs in actually executing the root function, or if the timestamp is after the most recent block timestamp on the root blockchain.
00:29:02.690 - 00:30:24.110, Speaker A: And so once the root function call executes and finishes, then any of the contracts that were on that root blockchain are automatically unblocked and the provisional updates are going to be committed. And prior to the timeout only the account that submitted the start transaction can submit that root transaction, but if it's after the timeout then any account can submit the transaction. So you've got locked contracts on all of those other blockchains that the segment events were executed on and so you need to have a way of unlocking those contracts, whether the updates are going to be committed or discarded. You need a mechanism. And so you have a signaling function that gets called and it's got the Root event, which is going to say whether the update should be discarded or kept and the segment events that occurred on that blockchain. And they're going to list which contracts were locked. And so then the signaling event will be emitted, which says whether the updates were committed or discarded.
00:30:24.110 - 00:31:53.270, Speaker A: And walking through all of this. So you start out with the start transaction and then you have the segment transactions and you go from the bottom of the core graph and work up to the root so that then you can, say, use the get price function call and the result of it and feed it into the shipment segment. And so you go from the bottom of the call graph for the Oracle finance and stock blockchains and then you've got the results of them go into the terms blockchain for the its segment and then they go into the root blockchain. And then because there were only updates on the finance and stock and not on the Oracle or terms, then you only need to have signaling transactions on those two blockchains. And this explains that sequence but in words. So when you're executing the code and doing a cross blockchain call, you need to call back to the cross blockchain control contract. So it's got a list of the call graph and so it knows what functions should be being called with what parameters because it can just look at the call graph and it knows where the executing function sits.
00:31:53.270 - 00:33:05.480, Speaker A: So it compares what's called with what should be called. And as well it's got the return values that are available and so it's going to be able to return the result of get price and return the current price and it's going to know that the cross blockchain call to the balance contract, the transfer should be called. Yeah, and that's what I just said. But in more words, so that you can do all these cross blockchain updates and have them atomic, you need to do some level of locking and so you have lockable business contracts. The state updates are held as provisional updates until they're committed and the locking model that is used is Fail if locked. So if you try to read or write to a locked contract it's going to fail. So either you've got to read from a contract that's not locked or write to a contract that's not locked.
00:33:05.480 - 00:34:24.172, Speaker A: What this means is that you could possibly have a set up where you read from a contract and then write to it, but you certainly can't write twice or write then read. And in fact I'd say it's best probably to only do one read or one write in a cross blockchain call. So in the implementation there are two separate contracts. So one lockable storage is supposed to be deployed and so it has essentially key value pairs and you can use it to store uwint two hundred and fifty six s or bytes. And it handles all the complexities of locking and provisional storage and registering which contracts got locked and other complexities, so it handles all the complex stuff for you. The lockable storage wrapper is something that you could use as a base contract that you inherit from with your other solidity code. So it essentially makes it easier for you to use the lockable storage.
00:34:24.172 - 00:36:01.244, Speaker A: So whether you want to store a bool or an address or an array or a mapping, this will let you do it. And it could easily be extended to allow you to use any type. And so if you're looking at, say, the stock contract and you're looking at that code, you can see that you're inheriting from your lockable storage wrapper and you are calling that and the storage contract parameter going into the constructor is the actual lockable storage. And so you set that up. And then to set a value, you are setting a map value there and you can see that you just need a parameter which is which of our values am I updating? And you just call set map value and then to get the value back you go get map value and using that you can create some complex business logic that's lockable. So bringing all of this together you've got a start or a segment or a route or a signaling function call that goes in the start registers the call graph in the cross blockchain control contract. If it's a segment or a route, you then call out the function call which is actually being called as part of your business logic and then that then if it's a lockable business logic contract.
00:36:01.244 - 00:37:02.368, Speaker A: So something that is going to update some variables as part of the cross chain call. Then all of the variables that can be updated as part of that call are stored in the Lockable storage contract. And so you can read and write there. And if you do read and write then you're going to indicate that that contract is locked in number six back to the cross blockchain control contract. You could also be calling code which doesn't update any state as part of cross chain calls and in that case it wouldn't have to have a lockable storage contract associated with it. And of course you could be doing cross chain calls as part of it all. And if I was following my numbers I would have done two as the second thing and then I would have said that obviously you need to check the signatures and merkel proofs before you go acting on the cross chain call that you've got the segment or route.
00:37:02.368 - 00:38:15.900, Speaker A: And if it's a signaling call, then you just have the cross blockchain control contractors get a call the lockable storage to unlock it and tell it whether to discard or apply the updates and that is all of that in words. So there are two execution engines that the implementation has there's the serial and the parallel. So the parallel execution engine executes everything in parallel and the serial one executes things essentially starting from the first call at the bottom of a call graph and then executing essentially along the lines of how the code executes. So it's a safer way of executing. The parallel is a little bit faster if you've got multiple things that happen at the same level of a call graph. If you've got a simple call graph, they too don't make any difference at the moment there's a bug or two in the parallel execution engine. So.
00:38:15.900 - 00:38:44.310, Speaker A: I still need to do a bit of work on that. So implementation. So the system has been implemented in Java and Solidity. And I've done a little bit of a modification to web3 J so that I can get the RLP encoding of function. Calls it's Apache. Two licensed. And that is the repo at the moment.
00:38:44.310 - 00:39:41.496, Speaker A: You can see that it uses a lot of gas, lots and lots of gas to do stuff. The thought is that this can be reduced quite dramatically. It's all just time. And so certainly if you're interested in contributing to the project, that would be great. And you could help with things like reducing the gas usage as well. At the moment the code's written in Java for the application side library could be interesting too. And you remember I was talking about amounts of latency and as you can see, if you've got a parallel execution engine and direct signing, it's much faster than if you're executing exactly the same thing using serial execution and blockhetta transfer.
00:39:41.496 - 00:40:13.010, Speaker A: So things just take longer. So security analysis. So have a look at the paper. At the moment there is no formal analysis of this methodology. If someone's interested in doing that formal analysis, please get in contact. Future work. So there is some test code, actually quite a lot of test code, but it'd be great to have more test code.
00:40:13.010 - 00:41:09.792, Speaker A: The efficiency should be improved and I know of ways where I'm pretty sure we could at least half the amount of usage. I need to add essentially that require message sender equals your authenticated user functionality that you've got in normal Solidity. And so essentially that would look like message sender address is an authorized sender address and the sender blockchain is an authorized sender blockchain to provide better linkage between contracts on different chains. There's also a voter weight based algorithm to allow dynamic stake based voting for the registrar contract. There's been an issue open on please, can that support be added for some months now, so I need to put that in. And also other blockchains. There's no reason why this cannot work on other blockchains.
00:41:09.792 - 00:42:14.330, Speaker A: Obviously there are some tweaks on the format that the events are produced in and consuming those other formats. But beyond that, I don't think there are actually large obstacles. I don't think there are large obstacles, there are only small engineering obstacles to getting it done. So in summary, it's an atomic cross blockchain function call mechanism which allows cross blockchain business logic. It should work on any EVM based blockchain as it is, but it could be made to work on anything that supports smart contracts and events. Coming up in two weeks time, we've got Matt Garnet who's going to talk about the EIPS that are likely to happen this year. We've also tentatively got booked Stan Clado to talk about scale, but that'll be a bit later in the day.
00:42:14.330 - 00:43:04.250, Speaker A: There's also the cross chain workshop so we have had an enormous response for the call for papers and call for speakers for this workshop. We've got 37 people who've put in proposals. And so we're right at the moment working through the review of all those proposals. That workshop is going to be run for 2 hours a day for two days a week across two, and maybe it's going to end up being three weeks it's set up so that it will be good for different time zones. So for those people who live in Brisbane, the first session in each week is at 06:00 A.m. On a Tuesday and the second session is 04:00 P.m. On a Wednesday admission, so registration is free.
00:43:04.250 - 00:43:37.940, Speaker A: So it's another one of these events aimed at collaboration and inclusion. We're not aiming to make thousands of dollars out of this. And then Mikhail is going to talk about ETH one, ETH two merge. And I need to update that because we agreed it wasn't going to have the before or after sharding point anyway. So just think ETH One e merge and Mikhail is an expert on that. So that's going to be an awesome talk. And that is the end of my slides.
00:43:37.940 - 00:43:51.640, Speaker A: Thank you very much. Peter, please join me in giving Peter a big hand. That was quite a good talk. Are there any questions for Peter?
00:43:54.860 - 00:43:57.832, Speaker B: Yes, go ahead.
00:43:57.966 - 00:43:59.370, Speaker C: No, please, go ahead.
00:44:01.200 - 00:44:27.830, Speaker B: I was just wondering whether you have analyzed the potential throughput on any kind of setup of this technology. What are potential bottlenecks here? So if we starting to put more and more and more cross chain calls how it will look like.
00:44:28.440 - 00:45:47.304, Speaker A: So at the moment we're in what, about 10 million range for Ethereum Main net for how much gas you can use in a single block. So if you were to say, all right, I'm going to have this complex call graph and it's going to start at Ethereum Main net and it's going to use a million gas, then that obviously would be a huge bottleneck because it would be ten transactions per block. And it would also cost a huge amount of money at the moment because gas prices are pretty high. But if you ignore that or if you just think about, say, between Consortium chains or maybe when Ethereum Two comes along when gas prices are really low and also assuming we can reduce the gas usage of this I think that if you're using blockheader transfer, a real hog can be. Say if you had 100 blockchains that all wanted to use the one target blockchain, and they were all transferring one transaction containing the blockheader per block, you'd have 100 transactions. And all they would be doing was submitting new blockheaders. So that would be awful.
00:45:47.304 - 00:46:54.700, Speaker A: And especially if the source blockchain had a higher or lower block period. So higher block rate than the target. So BTC relay the source blockchain being bitcoin has a ten minute bit period, whereas ethereum is what, 1215 seconds? So it's not too bad. But if you were doing it that the other way around, it'd be a nightmare and you'd be trying to clog up the bitcoin network. I think that's why direct signing in some ways could be the best way, at least initially. Four things that the latency isn't as much of a big issue going via that aggregation chain and is good because then you're not asking the signers to do as much work because you've got these validators. And if they're trying to do, say, ten transactions a second and they've got to coordinate these signatures and try and have all the signatures.
00:46:54.700 - 00:47:23.790, Speaker A: So I've got to say, hey everyone, please sign this event, they've all got to check that that event really was emitted and then they've got to sign it and get it back to me. And so if I do that ten times a second, then that's a lot of work. So if there's a lot of cross chain transactions, then blockader transfer via an aggregation chain might be the way to go. So those are some of the bottlenecks. Does that make sense?
00:47:24.400 - 00:47:25.870, Speaker B: Yeah. Thank you.
00:47:28.400 - 00:47:29.630, Speaker A: Okay, cool.
00:47:30.240 - 00:48:01.510, Speaker C: I just wanted to say first thank you for this great presentation. I have a couple of questions around the protocol support. For example, call graphs that might include control flow graphs that branches the call graph itself. Is that already supported by the protocol or is this something that needs to be handled a different way? Because it seems to me the representation of the call graph has to be around the happy path for that call graph. Is that true?
00:48:01.880 - 00:48:56.890, Speaker A: No, not at all. Not at all. You've got to work out so the thing is that you're going to need to simulate and work out what the entry point to each blockchain function calls are. So what happens within a blockchain doesn't matter. In fact, there's a hotel train example which I haven't yet implemented for this technology, but I have for a previous cross chain technology that we at consensus worked on. And in that technology, you knew that you wanted to book a room in a hotel or book a train seat, and you knew the amount that you were going to offer to pay, but you didn't know how much you actually were going to pay and you didn't know which hotel room you were going to book. And you should be able to do similar things with this technology.
00:48:56.890 - 00:49:29.490, Speaker A: Also, you could have it that you could have conditional logic, which I think is what you're really getting at, where you could say, if this happens or if this is the case, then call this blockchain or this function on this blockchain, otherwise call this function on this blockchain. So you can have that sort of logic as well. But again, you're going to need to know what is going to happen if you're going to be doing those cross chain calls because otherwise it won't be part of the call graph that you've committed to.
00:49:30.180 - 00:50:07.650, Speaker C: Makes sense. Makes total sense. I'm really just still trying to understand because we're talking about representing the call graph or the possible call graph for a business use case, right? So in this type of definitions, you might have a function within that business use case that will branch the call graph, right, still in the same blockchain. But the representation of that call graph will be actually branched based on the input to that specific function. Is that what you're referring to here?
00:50:08.260 - 00:50:55.680, Speaker A: Yes, that is. And so that's why you run that simulator to, you know, your business logic and in particular the business logic that will affect the parameter values of function calls that are entry point to different blockchains. And so you run that simulator to work out what those parameter values will be and also which calls you're going to do. So, yes, you do have the entire call graph, but you've got the call graph which is actually going to be used based on the parameter values. So I guess maybe I need to modify my language a bit and not say, like, the general core graph of all possible function calls, but the specific call graph based on certain parameter values.
00:50:56.100 - 00:50:58.530, Speaker C: Okay, thank you. Thank you very much.
00:51:02.020 - 00:51:30.650, Speaker A: And thank you for your question. Very good question, as was yours, Nikal. Are there any other questions? Thank you very much, Peter. That's great. Yeah, thank you. All right, well, have a great two weeks, everyone, and consider registering for the crosschain workshop. And if not anyway, whatever you do, see you in two weeks.
00:51:31.660 - 00:51:32.964, Speaker B: Thanks a lot, Peter.
00:51:33.092 - 00:51:34.104, Speaker C: Thanks very much.
00:51:34.222 - 00:51:35.460, Speaker A: Bye, everyone. Bye.
