00:00:01.290 - 00:00:39.690, Speaker A: Hello and welcome everyone. This is the Ethereum engineering group meetup. I'm Peter Robinson, and today I'm going to take you through my advanced solidity test. And so I guess a bit about myself. I've been working at consensus for more than five years, and in the blockchain space for a bit longer than that. I'm am a cryptographer, applied cryptographer, but also product development person who's doing a lot of research these days into crosschain communications, and that's me. So I'll share my slides.
00:00:39.690 - 00:01:19.018, Speaker A: Okay. And everyone should be able to see some slides, hopefully. Cool. Thumbs up. So that QR code I've got there will take you to that part of a GitHub repo. So it's the Ethereum engineering group samples repo, and within there, there's a sole test directory, and then there's 2020 212, so December 2022, and there's start. So there are actually three directories that I've got on my computer, which is start annotated and final.
00:01:19.018 - 00:02:18.170, Speaker A: And so the start is a starting point that you could have in a programming test. And also before you get too far in, so when you open up remix, you'll see something like this. And so what we want to do is we want to open up the Ethereum engineering group repo in remix. So you copy that and I'm going to find the chat bar, and in chat I will to everyone. So that's the repo that you want to load. So what you do in remix is you see those three horizontal bars you click on there and then you click on the clone button, and then you paste in the repo that you want to open, and then you click ok. And so that's going to take a few secs, but that'll load up that whole repo of code for me, hopefully.
00:02:18.170 - 00:02:38.674, Speaker A: And so if you do that in parallel, then by the time we get to it, that should hopefully. Fingers crossed. Loaded up. Yep. There it's loaded up for me. So hopefully it'll happen as quickly for you. And so before I get too far into the talk, I'd like to acknowledge people who've helped me.
00:02:38.674 - 00:03:21.600, Speaker A: So Frank Casse has formerly analyzed parts of the starting point code, which has been great, and he's found some issues. He hasn't found all of them, which I'm actually really thankful for, because if he found all of them, I would have been disappointed. But anyway, he found all of them, or some of them. And he also found some areas which I was just relying on panics rather than having good require messages. So I've put in some extra requires Arathio also, I thank you because he tried out some of that starting point code on a range of tools and saw what they could find. And so Emily and Amal, they helped with my truffle test code that you'll find in the repo and improved it. So that was really helpful that they did that.
00:03:21.600 - 00:03:47.314, Speaker A: So I've advertised this as an advanced test. So is it advanced? What is advanced? I hear you ask? So I don't know. I don't know what advanced is. So it's much harder than last year's test. And some people said they thought last year's test was way too easy. And so automatic checking tools have not found all of the issues. So that's one thing to note.
00:03:47.314 - 00:05:02.686, Speaker A: In fact, they've found pretty much none of the issues. And hundreds of millions, possibly even to the tune of billions of dollars, have been lost due to the bugs that this test will highlight. So if you know about all the bugs that this test highlights, then you could save your project that you're working on an awful lot of money. And potentially if you went into the bug bounty searching thing, maybe you can find some vulnerabilities in code and get a bug bounty, which these days could be half a million dollars easily. Okay, so what is the test? So the test is to have a, you've got a flash loan system and it's a contract which is backed by a transparent upgrade proxy, and there is a version one of the code which you would have written, and then later on you wrote version two. So for this test you're presented with version one and two at the same time and they're behind a transparent upgrade proxy. So if you're doing an interview and the candidate looks at you blankly and it's supposed to be an advanced interview, then you got a bit of a problem, because if you are advanced, then you should know what a flash loan is and you should know what a transparent upgrade proxy is.
00:05:02.686 - 00:05:53.298, Speaker A: And if you don't, then maybe you're not that advanced, which is okay, you should continue the interview because maybe they've just not heard of them, but it should be something that you should go, oh, they don't know what a flash loan is. How long have they been in the defi space? So what is a flash loan? So it's an uncollateralized loan. So you can think of collateral as something that you have, like, say if you get a home loan, you've got a house, and then you get a loan from the bank, and the collateral is the house. So if anything bad happens, you can take the house. So an uncollateralized loan is one where you give someone a loan, but they haven't given you anything for that. And the idea is that you have an uncollateralized loan without borrowing limits either. And so each user can borrow as much money as you've got available.
00:05:53.298 - 00:07:01.382, Speaker A: But the key important factor is they've got to return all of the money to you, plus interest within the same transaction. So that's the critical point. So they loan some money within a transaction, and then they've got to give it back to you plus interest. And so you can think you've got a liquidity provider and they deposit some liquidity, and then at some later point they do a payout, they get their money back out, plus whatever interest they should have earned. And you've got to have a fair mechanism for giving the various liquidity providers their money back. And then you've got users, and they call a method, a function called flash loan, and they say the address of the contract they want called, the parameters they want called, and some loan amounts, the amount they want to loan. And then the flash loan contract calls the flash loan receiver contract that the user specified, and they call that with the loan amount in we and afterwards somehow, rather, the user has to arrange for it to return.
00:07:01.382 - 00:07:54.840, Speaker A: And the actual balance of that flash loan contract has to be greater by the amount of interest. So if you think about it, the user, they might only have a small balance, so they've got enough money to pay for gas, and then they loan a huge amount of money from the flash loan contract. And then they call the flash loan receiver contract. And then that flash loan receiver contract has to do something pretty special, because somehow or other, they've got to use that money to earn more money. So they've got to do some sort of defi arbitrage or something like that, so that then they've got enough money to pay back the interest. And so this is just revisiting the code for the test. So let's dive into the test.
00:07:54.840 - 00:08:53.150, Speaker A: And so hopefully when I open up remix here, so I'm going to open up the solidity test directory and start, and then we'll just have a look at the contracts. And so these are the contracts we've got available. So, David Pierce, you happy to help out as an interview? Actually, before I volunteer you, David, let's see from the general audience. Is there someone who's relatively new to solidity, who's ready to dive in as a person to talk about the code? Is anyone happy to do that? And if not, David, I'm sure is happy to dive in. David, I think it's your gig.
00:08:54.130 - 00:08:55.998, Speaker B: So what do you want me to do exactly?
00:08:56.164 - 00:09:29.690, Speaker A: Well, so I'm the one with the repo opened that everyone can see on the video and on the talk. So if you're presented, you're some smart contract auditor, or if you're this person who's doing some interview test and you're asked, all right, what do you do? What's your plan of attack? When you look at some code, what's your starting point to try and work out if it's going to be good or not? Where do you start looking for bugs?
00:09:31.790 - 00:10:28.220, Speaker B: The starting point for me is always to try and understand the process, the use cases, how are people going to use this API and what are they going to do? And when I looked at the original version, that was my starting point was to try and understand well, this kind of person is going to use the method in this way, this other kind of person is going to use the method in that way and then to kind of dig into it at that point. And I suppose to look for things that stand out. Reentrancy is an obvious candidate. And it's easy to look for a situation where you're making a contract call to someone else and to think about does that make sense? And other situations. I spent just quite a while just looking at it and thinking about it, trying to make sense and trying to think about what was reasonable and what you could do and what you couldn't do.
00:10:29.490 - 00:11:12.700, Speaker A: Yeah, all right. And that is a good approach, let's not discount. So given we've got remix here, let's click on Flash loan V one and then let's click into the compile and we compile Flash loan v one. And I encourage people who are looking at this to have a look. So when we go over here now you've got Flash loan v one is available and it's actually got a parameter you can put in. So let's say put 1000 in and then we're going to deploy that contract. And so you can see down here you've got that deployed contract at that address.
00:11:12.700 - 00:11:49.894, Speaker A: Let's have a look at the code again. And so we've got this transparent upgrade proxy just here and let's click on compile and we'll compile it and then we'll click down here. And so the transparent upgrade proxy, it needs an address and some byte data. So the address is going to be of that deployed contract. So we'll copy that, put that there. So that's the address. In fact, we can do that, pull down.
00:11:49.894 - 00:12:31.762, Speaker A: So then we say, all right, so we've got implementation which needs to be a valid address and then data. So let's just go zero x for the data. So we'll call transact. So that'll deploy that implementation, that upgrade proxy contract. So then if we look down, we've got that upgrade proxy. So the idea of an upgrade proxy is now you should be able to run all those flash loan contract API against the upgrade proxy. So what you want to do then is we go back here, we grab Flash loan v one.
00:12:31.762 - 00:12:58.620, Speaker A: Again, we go down here, we compile it just to be sure. We go in here. So we've got Flash loan v one. So we could deploy it. Or we can say, what address is that? So let's copy the address of flash loan v one. And in fact, I think that's going to even be the address that we want. So let's pop that in there and then we go add address.
00:12:58.620 - 00:13:54.270, Speaker A: So what that's done is it said, all right, we've got a flash loan v one, which is at the same address as the upgrade proxy. And now if we have a look, we've got all these functions and so what do we call version, just to see what that gives us, because these are ones that are going to give us a value back. That's an unusual version. What's paused going to give us? Paused is true. So it says that currently we're paused. Can we unpause? What's that? Not admin. So we've deployed with the same contract.
00:13:54.270 - 00:14:22.360, Speaker A: So that's strange. What about pause? That's worked. All right, let's go back to the code and try and work these things out. So in pause, unpause, it didn't work. And pause, it did work. And then when we started up.
00:14:24.330 - 00:14:33.370, Speaker B: So the starting point here, Peter, is to note that flash line, v one. Pause me, v one. And also extends flash level base.
00:14:33.440 - 00:14:44.240, Speaker A: Well, this is true. This is true. So I am cheating because I've seen the code. Yeah. Yes. And that's true. So flash loan v one is pause me, v one.
00:14:44.240 - 00:15:13.480, Speaker A: And then. So we have a look. Yes. So if I was being interviewed by this point, you'd think, oh, he's seen the code before. But normally what I would do is I'd have a look at each of the bits of code and then I'd deploy the contracts just like I've done to just get a feel for if things are vaguely working. Okay. Yeah, but things don't seem to be too happy.
00:15:13.480 - 00:16:02.038, Speaker A: So when I look at this, the first thing I see is that's only admin, but this one here isn't only admin. And what's the difference? And then in v two, pause me v two, we're pause me base as is v one. And then we've still got pause, but we've got only pauser. And so what we've done is we've introduced a new variable. So that's the difference between pausme v one and v two. And let's have a look at flash loan v one. So it's porsme v one plus flash loan base plus a tiny amount of code, and flash loan v two.
00:16:02.038 - 00:16:28.720, Speaker A: What is it? So it's got some more complicated upgrade code, which is fair enough, it's v two rather than v one, but it's essentially porsche me v two plus flash loan base. So they're both inheriting from flash loan base. So that means they're almost the same. And it's really what's the difference between pause me v one and pause me v two, and so pause me v two.
00:16:29.090 - 00:16:55.142, Speaker B: I guess in a normal setting you wouldn't necessarily have both versions to compare against, right? Like you would be looking at the version one of pause me trying to figure out the question that I was wondering at the beginning when I started looking at this contract, I'm not experienced with flash loan, for example, and I was wondering, why do we want to pause the flash loan? What's the goal here?
00:16:55.276 - 00:17:24.530, Speaker A: Yeah, okay, so in D five projects, if there's a hack, you want to be able to pause the project so you can go, oh my God, $50 million has just disappeared before the other 150,000,000 disappears. Let's pause the project, take stock, and try and work out what the attack is and what we can do about it, so that the rest of the money doesn't go away. And so that's what pausing is all about. So it's a very common feature in defi projects.
00:17:28.070 - 00:17:40.294, Speaker B: So that suggests when you think it through like that, then it suggests, okay, so who wants to be able to make the pause? It's not anybody, but it's the contract owner responding to an attack.
00:17:40.492 - 00:18:20.180, Speaker A: Yes, exactly. Because if you've got something like this where there's no admin control, no control at all, then it would imply that anyone could pause the contract. And that's going to be a nightmare because it means that anyone could maliciously just say, hey, they're making too much money. Let's pause the contract and cause them a bit of havoc so that there, so let's copy that from there to there. And by doing that we'll limit who is allowed to pause the contract. And that is a good starting point.
00:18:22.230 - 00:18:41.740, Speaker B: Another thing I noticed there. So I kind of go through the structure of the code and I looked at pause me v one. And then I'm like, okay, it's admin and it's pause me base. So I look into pause me base and I'm wondering should it be paused at the beginning or should it be unpaused at the beginning? What makes sense there?
00:18:42.190 - 00:19:48.554, Speaker A: Well, when I was writing the example code, I had to think about this. And so if the default is not paused or if it's true when it's not paused, then the default is. So I guess it depends on what do you want to do? Do you want to have the default when it starts up being true or false being what should be paused? So if paused is true, then it would have to be set to one. Whereas if you say if not paused is true, so if not paused is false, then hence it's paused. And so the default being boolean false means that by default the contract is not paused. And there are two other reasons why I did it like that. So one is obviously that you don't need to have go in and say, hey, you should unpause.
00:19:48.554 - 00:20:55.322, Speaker A: The other one is this double negative sort of logic confuses people no end, and it's the great source of bugs. And in fact, you would hope that someone, given that when we started up, so if we deploy that now, why don't we go and deploy the flash loan v one again? Just a sec. Let's go in here. Flashloan v one sol compile it, then we're down here and let's deploy it. We needed to have a value in there, didn't we? So let's get rid of what's going on here. Just a sec. All right.
00:20:55.322 - 00:21:40.520, Speaker A: So let's go deploy. All right, so now we've got that flash loan v one contract. And so if we have a look at it and say, is it paused now? So paused is true. Let's have a look at this. So if we had a look at the code, when we're looking at the code here, pause me base, what are we finding? So not paused. So when we start up not paused should be true.
00:21:43.630 - 00:21:52.000, Speaker B: What should it looks funny, doesn't it? Not paused. If I'm trying to call pause internal, then I'm trying to pause it.
00:21:52.390 - 00:22:20.506, Speaker A: Yeah. All right. Are we changing it in the constructor of the flash loan v one? I'm just guessing. Yeah, we'll have a look, though. If I was writing this code, I wouldn't want the constructor of flash loan v one changing paused. I'd like to have that happen in pause me base as constructor. But let's have a look.
00:22:20.506 - 00:22:39.406, Speaker A: Flash loan v one. No, it's just calling out to flash loan base and then indirectly to all of the other constructors. All right, now we've switched the.
00:22:39.508 - 00:23:09.660, Speaker C: I've got a publicity question, but I think all this machinery of inheriting pose me and so on. It's a bit of a killing for what you want to do if you have it in flash loan, that's very easy to set up a boolean variable and to add the require for each function and so on. So it's adding some complexity to me for no reason. I would encode it straight away rather than inheriting something that I don't know what it's doing.
00:23:10.510 - 00:23:25.950, Speaker A: Yeah, I understand what you're saying. I think you'll find that it's very common to have this huge depth of hidden contracts all over the place, very common in solidity. And the reason is because people perceive they'll be able to reuse the code.
00:23:26.100 - 00:23:33.070, Speaker C: Yeah, but what you just demonstrated is that it's very easy to reuse but it's very easy to introduce some bugs.
00:23:33.490 - 00:23:34.094, Speaker A: Yes.
00:23:34.212 - 00:23:56.100, Speaker C: So to me that's an argument against this kind of thing, which is if I have to do it in flash loan, I would say let's have a boolean variable. I'm going to require something that is not true and so on and update it myself. And then I see the code and I don't have to rely on few inheritance levels to understand what it does.
00:23:56.630 - 00:24:39.238, Speaker A: Yeah, that's true. I fully understand where you're coming from. But then you have like a say 3000 line piece of code in one solidity file, which is also very hard to follow too. All right, let's deploy this again. Okay, so now when we start up, is it paused? So paused is true. So in other words, not paused is false. So hence paused is true, which could be good.
00:24:39.238 - 00:25:28.098, Speaker A: All right, so if you want it to be unpaused, how would you do it then as a starting point so that we don't have to. The first thing we do when we've got the contract is we unpause it. I heard someone say a constructor. So should we put a constructor in. Yeah, in the pause me base. Yeah. Well this one here will get called automatically, so that will call down to unpause internal, which will make it so that constructor there, guys.
00:25:28.098 - 00:26:05.118, Speaker A: But don't we plan to use proxy and constructors don't work behind proxies, right? Correct. Go to the top of the class. You are very correct. Yes. All right, so do people understand what's just been said and I'm going to try and get to the correct slide. No, I'm giving away all my secrets now. I had hoped to, sorry if I revealed that.
00:26:05.118 - 00:26:40.070, Speaker A: No, it's not good. Not a problem. So in fact we can even say, so the pause logic is wrong and that's something that's pretty basic. And so we can get rid of that one and then the other one was the access control. So that's another basic issue that you can see. But let's see, what I need to do is have all these out of the, actually that's how I'll do it. I'll cheat.
00:26:40.070 - 00:27:32.772, Speaker A: I'll get all of these out of here and hopefully not have too many Google Chrome instances here. And then I'll just show you the interesting one. Maybe I'm going to one at a time show all the issues anyway. So somewhere here I do talk about this, but maybe it's hidden in the upgrade storage collisions. Yeah, that's it. So I'll drag this one. Okay, so I'm sorry, who highlighted the constructor issue? It was me.
00:27:32.772 - 00:27:47.370, Speaker A: Okay. Yeah. All right. Well, thank you for that. Now I'll tell everyone about this. So this is something which is more of a complicated issue. So when you've got transparent upgrade proxies, they call delegate call.
00:27:47.370 - 00:29:10.250, Speaker A: And so using delegate call means that the code of this flash loan contract executes in the context of the upgrade proxy. So if you run a constructor over here, you initialize storage variables for this contract, but then when you're using them via the upgrade proxy, you're referring to storage variables that are here. So if you have constructors, then you're doomed to failure because you're not going to be calling them. Those storage variables that you've initialized with the constructor never get used. You can see you've got a whole set of code there that needs to not have constructors and it needs to have initializers. So let's go and create those initializers. Yeah, so we've got one.
00:29:10.250 - 00:29:38.248, Speaker A: So let's go through admin, we've got one here. And in fact we can even make our lives easier to, we're going to call it admin. And then inversion. We don't have anything. Um. Pause me one. We've got initialized pause already.
00:29:38.248 - 00:30:40.930, Speaker A: Yep. Then in here we can change this around to be. And then in fors me base. Yep, we've got initialize actually. So we've got initialize. So I think in our initialize pause me one, there's not actually anything to do, is there, really? So we can get rid of that because that's happening in base. And then in pausme v two, we don't need that because it's in base.
00:30:40.930 - 00:32:32.860, Speaker A: So now the big thing is in flash loan v one, we don't have a constructor. We've got a function which is called initialize. And that's going to take a bytes call data. And so now we've got that. But really what we need to do is we need to get that interest rate per block. What's the syntax here? I think that's right, isn't it? And now then what we need to do is we need to call, um, need to call the pause me base. And in fact though I'm calling them out.
00:32:32.860 - 00:33:19.764, Speaker A: So this is flash loan v one. So theoretically we don't actually need to identify which contract we're calling because it's pretty obvious. Sure. All right. And then we had what we got to initialize the flash loan as well. And that needs to be initialized with the interest rate per block. Can I suggest a pattern? I don't know if that's better.
00:33:19.764 - 00:34:05.890, Speaker A: Like initialize posme base should be called from initialized posme. Right. Like the super. Yeah, that's probably a good point. So we're in initialized pause me one. And so that's probably a good idea. Yeah, and then given that we would want to, we'd want to put that in here as well.
00:34:05.890 - 00:34:47.134, Speaker A: All right, so let's have another look at this. Flash loan v one. We've got interest rate per block. So let's get rid of the constructor, initialize admin, initialize pause me v one, initialize flash loan base, and then flash. That's going to do that. Flash loan base is here and it's got an initialized. All right, so I think we're good.
00:34:47.134 - 00:35:51.460, Speaker A: And then for flash loan v one, let's grab the code from here. And then we've just got to put that in here. And actually all we need to do is change that from v one to v two. All right, so now we should be good because now we've got our initialized code. Good. So then the question is, what does the upgrade proxy do? So it's got a constructor and it's calling delegate call that it needs to call, initialize with the parameters and then it sets the input. All right, I wonder whether this is going to compile.
00:35:51.460 - 00:36:26.240, Speaker A: So let's start off. Let's start off by compiling the upgrade proxy. I think that's high likelihood of working. And then we'll go Flash loan v one and let's compile that code. Seven issues. Yes, I forgot to make give some. So let's have a look in admin.
00:36:26.240 - 00:37:31.130, Speaker A: We've got initialized and that should be internal. So, paresh, what does internal do for us? What is that going to do? Only the methods in the same contract can call it. It cannot be accessed from outside, correct? Yeah. Okay. Ashlean base, and then pause. Me base should also be internal. Okay, let's have another look and see if we've got Flash loan v one and we have another compile of the code.
00:37:31.130 - 00:38:47.900, Speaker A: See if we get quite so many problems. Flash loan base, line 61 five function. Shall that be public? No, this one's internal, but I don't think. What is the problem?
00:38:58.590 - 00:39:22.430, Speaker C: Just to make sure I understand what's happening, because we decided to inherit this posing thingy. Right. We are now running into lots of trouble to make things work together with the proxy and blah, blah, blah. That seems to me more complicated than adding the post variable into the contract directly and manage it directly.
00:39:25.510 - 00:39:29.330, Speaker A: Yeah, it has its own challenges.
00:39:30.630 - 00:39:46.600, Speaker C: I mean, we haven't even started to write the code for the flash loan. Right. We are still dealing with posing, so that seems to me an artifact of solidity that's not acting in our favor.
00:39:50.830 - 00:40:07.550, Speaker A: This ability specified, add public. This is to a next one. Flash loan v one. There we are. There we are. We're on flash loan v one, line 20. And that's got to be external.
00:40:07.550 - 00:40:39.838, Speaker A: All right. And now 23, you had a typo there. Actually, I noticed that earlier. You forgot the v on line number 23. There should be a v before one. All right, good. All right.
00:40:39.838 - 00:41:05.532, Speaker A: And I think you forgot to rename the function for v two. All right. For flashtone v two. Okay. Yes. So we'd be calling the. Let's just make sure.
00:41:05.532 - 00:41:37.610, Speaker A: Pause me, pause me. V one. All right, so let's go back to flash loan v one. Okay, does this need to be an inverted commas? I have a sneaking suspicion it does. I wonder if that's it. Yeah. And then that's got to be of type tuple, which means that it's got to be like that.
00:41:37.610 - 00:42:57.660, Speaker A: 21. All right, I'm going to have a quick look and let's try and work this out. All right, how's about I cheat and I use something I've prepared earlier? And in fact, why don't we pass the parameters down? All right. Okay, so let's go here. Let's go to flash loan base. Okay. And so let's hear.
00:42:57.660 - 00:43:40.720, Speaker A: So now, because given it's that variable, we want to actually initialize that in the flash loan base because that's where we're setting it up. And so setting it up in flash loan v one would be a bad idea. All right. And then let's get rid of that little line of code here too, because that's going to be the same problem. All right, so now we should have our flash loan v one code that should compile. So let's have a crack at it. Compile.
00:43:40.720 - 00:43:47.670, Speaker A: Oh, underglared identifier interest rate in per block line 64.
00:44:00.990 - 00:44:04.970, Speaker C: Interest rate per, there's an underscore missing at the beginning.
00:44:06.590 - 00:44:53.370, Speaker A: No, I don't think that's going to be it. I think let's have a look. Another thing that you can do to cheat is you can copy. And it's definitely saying that, I know that if I looked at the error better, I bet, what if I looked closer at the error? That's what the problem is. It's not saying interest rate per blocks wrong. It's saying that underscore params doesn't exist. And let's call it call data as well, because we know that it's going to be call data.
00:44:53.370 - 00:45:50.930, Speaker A: All right, so let's go back into flash line v one and 43. So offset 43 in flash loan base. Let's have a look at this code. So now's when I look at this and go, why can't I work this out? All right, I wonder if that is going to be character 43. Does it need a space between decode and the open bracket? No, I don't think so.
00:45:54.260 - 00:46:00.240, Speaker C: If it's internal, why do you use the Abi encoding and decoding?
00:46:02.440 - 00:46:11.270, Speaker A: Because the proxy is just going to pass Abi encoded stuff and it doesn't know what it's calling.
00:46:13.160 - 00:46:14.696, Speaker C: So that means that when you write.
00:46:14.718 - 00:46:17.844, Speaker A: The contract, you will write it differently.
00:46:17.892 - 00:46:20.970, Speaker C: Whether it's inheriting a proxy or not.
00:46:23.260 - 00:47:29.480, Speaker A: Only for the initialize function and the upgrade function. All right, so now compile base works. What about Flash? In the same place? That's super strange. So what can be happening here? All right, line, so it's strange. If we compile this from flash loan base, it's good. And if we're here in flash loan V one, we get. What could it be? It's the same thing as last time before you fixed it.
00:47:29.480 - 00:48:27.510, Speaker A: Yeah, maybe. What about if we go into Flash loan V two and now we try and compile Flash loan V two, see what it says. Okay, flash loan v two, no visibility in the initialized function. That's okay. Let's make that external compile. So flash loan V two works. And then if we go back to Flash loan V one and we go down to the compilation thing and we go compile.
00:48:27.510 - 00:48:57.220, Speaker A: Oh, now it's disappeared. All right, we're all good, all good. All a matter of compiling enough. All right, so let's go back. So we've got Flash loan V one, let's go and delete all of the old deployments. And now notice that there's no constructor variable. So let's just deploy Flash loan V one.
00:48:57.220 - 00:50:18.838, Speaker A: And yes, we've got it. All right, and then what we'll do is we'll go back to the upgrade proxy and we'll go down here, Kit admin. So what are we going to do? What we could do, we can cheat for the moment just to get this to compile. And that should now. And we're in upgrade proxy. All right, so when we're in the admin, it's saying, so that's internal, and yet it was saying, what's it saying? That you need to have it public. Did you intend to make it public? Function.
00:50:18.838 - 00:50:59.114, Speaker A: Initialize relevant parts. Start here. All right, line 19. So why is it saying that when that's internal? That does not make sense. So let's go back to upgrade proxy. Go back to here and let's compile the upgrade proxy. All right, that got rid of that compiler error.
00:50:59.114 - 00:51:24.720, Speaker A: Matter of making sure you're compiling. Okay. That's why I was thinking. I think in remix there is no way to say compile dependency because many tools, they will automatically compile the dependent contracts. I think hardhead does it. Looks like Vimix doesn't do it. Yeah, well, I think what it's not doing is it's not autocompiling it.
00:51:24.720 - 00:52:15.070, Speaker A: Yeah. Okay. And so now what we need to do is we've got to get the address of the deployed contract, which we can do, and then we've got the bytes value and we need to know that we're having an encoding of a uint 256. And if someone can let rude in from the waiting room, that'd be great. So let's go. Actually, what we'll do is we'll just assume the interest rate is going to be zero. And I think that that will be enough.
00:52:15.070 - 00:52:38.486, Speaker A: One, two, three. Anyway, let's just make it zero. And I don't think that'll be a problem. I think, yes. All right, that's deployed the upgrade proxy. All right. And now what we need to do is go back here and get the flash loan v one and then go back here.
00:52:38.486 - 00:53:12.570, Speaker A: So we've got it compiled. And then if we go here, we should be able to deploy flash loan v one and we need to do it at the address of the upgrade proxy. So we copy that. Okay. And we go add address. Now we've got our v one contract. So now when we look at things, we should be able to.
00:53:12.570 - 00:53:58.660, Speaker A: So we're going to be the admin because we've got the right, we deployed it. So we're going to be admin. So let's see if it's paused at the moment. So it's saying it's currently paused. So let's click unpause and then go paused. Let's go pause, then paused is true. And if we go unpause, if we go unpause, it's giving us an issue.
00:53:58.660 - 00:54:45.620, Speaker A: Let's have a look at this. It's saying not admin. So who is admin? Okay. And the question, of course is what's the message sender at the moment? So if I call pause unpause and it's going to fail. Let's have a look. So that's from zero x five, B 38, et cetera, et cetera, et cetera. So that should be the correct address.
00:54:45.620 - 00:55:46.028, Speaker A: So why would it be giving us that? Let's have a look at the code and try and pick through this. So we've got in the upgrade proxy, we call admin. And does anyone know what's happening when I call admin on the upgrade proxy? What could be going wrong? So who was the person who knew about proxy contracts? What are their thoughts? Okay, I can tell you what the issue is and I'll see if I was going to say is one of.
00:55:46.034 - 00:55:54.220, Speaker B: The issues that the proxy uses a delegate call. So you've got two admins.
00:55:54.800 - 00:55:58.830, Speaker A: Exactly. You've got.
00:56:00.900 - 00:56:02.610, Speaker B: Storage variables or something.
00:56:03.540 - 00:56:38.540, Speaker A: Yeah, you have got an issue. So I'm just going to get to the correct. Yeah. So there's a few things going on here. And I'll pop this here, which will. Yeah, so there's a few. So we've got a function selector collision.
00:56:38.540 - 00:57:55.412, Speaker A: So when you've got the upgrade proxy and you're saying is admin, so you're saying that you've got these functions defined by these function selectors that are available in say, flash loan base and there's whole heaps of them. And then that should be over there at flash loan v two. In flash loan v two, we had pauser and transfer pauser role and they were only flash loan v two. And then because we've defined admin, because we're saying, just wait for it. Because we've got upgraded proxy as admin, an admin is defining these functions in there. So we've got the public admin, meaning you've got an automatic function called admin, you've got initialized admin, or actually you've got transfer ownership and admin as public variables. And so actually it's this one here, isn't it? They're available in both.
00:57:55.412 - 00:59:02.828, Speaker A: So when you go admin, we're actually finding out who the proxy's admin is and not the admin of the contract. Yeah, of the flash loan contract and the other thing and debtto for the transfer ownership. And so notice that typically you have these proxy functions, and so they're essentially a function with the name proxy at front. So assuming that there isn't a function called proxy implementation in here, then there's no clash. A way to obviously do this is to get around by having proxy admin and functions like that. Another issue that we've got is the proxy storage collision. And so because we're calling delegate call, this contract here is executing in the context of this one.
00:59:02.828 - 01:00:00.616, Speaker A: So when we look at it, that means that at storage slot zero, the upgrade proxy has got a variable called admin. But in flash loan v one and v two, their first variable that's defined is called version. And so it means that those two variables are operating at exactly the same location. So if you changed ownership, that would overwrite version, or if you say upgraded the contract, then that would overwrite admin. And so what's going to happen is that the upgrade proxy would then say, have an admin set to say three, which is obviously not an account that anyone's going to have. And so then you wouldn't be able to upgrade the contract. And equally you could have it that you set the admin and then that sets the version to a version that is unknown.
01:00:00.616 - 01:00:44.940, Speaker A: And so then you're not going to be able to upgrade the contract. And so the solution is to define the admin slot. So where you're going to store that, who is the admin at? Somewhere far, far away out of the way, say ff. And so then it's a matter of loading up the value directly from the storage slot rather than loading it up as a normal simple variable. And so what you're doing then is you're moving that address variable down there so it's not clashing. So the upgrade proxy has no clashes with the storage variables of the standard contracts. Yeah.
01:00:44.940 - 01:01:41.220, Speaker A: So let's try and do that. So the first thing we're going to do is upgrade proxy. Let's get rid of his admin because that's not going to help us at all. And the next one is we had to have this admin slot and so it has to be unique. And so this is the storage location that we're going to use for that admin variable. And we're going to have setimple, but we're also going to have set, we're going to have proxy set admin. And message sender is what we'll pass in.
01:01:41.220 - 01:03:24.452, Speaker A: And so then down the bottom here we've got set impulse. So now we're going to have proxy, we'll make this public so that it can be called internally. And then we've got that as an admin slot and we'll just change the name of that so it's not confusing. Okay, so we've got new admin and we're storing that. And then to get the admin back, going to have to have, actually, we'll have a function that's a bit like this, won't we? And it's going to be what? Proxy get admin. We'll have this as a public or external and it's going to be s load of the admin. All right.
01:03:24.452 - 01:04:29.726, Speaker A: So I reckon that that will end up compiling for us. Hopefully. Identifier not found, line 40. Admins not there anymore. Yes. So let's go to admin and grab our only admin. So upgrade proxy isn't dragging in the admin anymore.
01:04:29.726 - 01:05:18.690, Speaker A: So in fact, let's get rid of that there, too. And so we now need to write our new only admin. And let's check. Message center is proxy get admin. And of course that means that proxy get admin is going to have to be public, isn't it? Because otherwise it can't be called internally. All right, so we've got proxy get admin and proxy set admin. And how about we have this as only admin so that we can't have random people changing it? All right, so let's see if that code compiles.
01:05:18.690 - 01:06:15.040, Speaker A: So line 15, it's saying that what comes out of getadmin, you didn't call it. So let's have a look. I think you didn't call it the function. Yes, I'm trying to assign the actual. So what that was indicating is, I'm saying, does this function equal this address? So that's actually a function and you can check if two functions equal each other, which is obviously not what we're trying to do here. Okay. All right, so we should be in business.
01:06:15.040 - 01:07:25.016, Speaker A: Now what we're going to do is we're going to get rid of that. In fact, why don't we trash all of them just for good measure. We'll go back up here and we've got flash loan v one, which will compile, and then we'll deploy. And then we go back here and we've got our upgrade proxy, which is compiled, and then just for good measure, so we need to have the implementation address. So which is this one here. And let's just put zero x zero zero for the interest rate. So we got a VM error.
01:07:25.016 - 01:08:35.140, Speaker A: Let's have a look at this. Creation of upgrade error. Vm error provide reason provided by contract, not admin. So let's have a little look at this. So we had proxy set admin with message sender, but now we've got it. So what we need to do is have a lower level function, which is set admin. And then this one is just plain set admin.
01:08:35.140 - 01:09:12.890, Speaker A: Oh, that's private, isn't it? Just in here. All right, let's try that again. So we've got the upgrade proxy, which we compile, and then we go in here and we copy the flash loan contract address. Paste it in. Then we go zero, x zero, zero. Let's transact. All right, we've got it deployed.
01:09:12.890 - 01:10:00.460, Speaker A: All right, now what we're going to do, we'll copy that address and we'll go up here, we've got flash loan v one, which is already compiled. And then we go in here, and then we can go, we can choose flash loan v one. And then we say it's at that address, which is going to be the right address. D four. No. So add address. All right, so we've got flash loan v one at the proxy's address.
01:10:00.460 - 01:10:36.866, Speaker A: Okay, now if we have a look at it. Let's have a look at things. If we look at the admin proxy, we've got admin proxy get admin and that's five b. So that's our address. And if we get implementation, that's giving us that ae zero. So that looks good. And then let's try and change admin to ourselves.
01:10:36.866 - 01:11:42.350, Speaker A: So just checking that worked. So we were able to change it to ourselves, which means checking the admin worked. Okay, so what about down here? Who is admin? Am I admin? Admin is zero. That's going to cause a bit of a hole. So how do we find out why admin is zero? So we've got owner, should be message sender. Is that going to work? In what circumstances will that not work? If there was no actual message sent to that contract, so then it has to pull from. No.
01:11:42.350 - 01:12:36.888, Speaker A: Yeah, well, there was a message, so that's not going to be it. That's not going to be it. Because the thing that I'm actually thinking about is admin is public. So that's just going to be it. The thing that stands out to me is that message sender is going to be the address of the upgrade proxy, isn't it? Because the upgrade you've got, the EOA calls the upgrade proxy. It calls initialize. And so that means that it's as if it's seeing, and I think the reason why it's seeing is because the contract is calling initialize and inside the constructor of the upgrade proxy.
01:12:36.888 - 01:13:32.262, Speaker A: And at that point, message sender must be deemed to be zero for the contract. It'd be lovely to try that out on a real blockchain to see if that's the case. So either way though, that should actually be TX origin and not message sender. So in this case, what you want to do is when you're deploying this contract via the upgrade, or rather when you're initializing the contract via the upgrade proxy, you want the EOA account, not the address of the upgrade proxy. Yeah. And so I guess an interesting one in itself is because you're calling initialize, then you're having the problem. Yeah.
01:13:32.262 - 01:14:31.870, Speaker A: So if we have it as TX origin, then I think we're good. So this is flash loan v one. So let's go in here. All right, we're all good. And in here, let's get rid of all of the contracts and flash loan v one. Let's deploy. And then we've got the, let's choose the upgrade proxy and then we go over here because we know it's all compiled and we choose the upgrade proxy and then we're copying that address and let's transact.
01:14:31.870 - 01:15:20.410, Speaker A: All right. And then we'll copy that address. All right. Okay, let's do add address. And now we should have our flashland contract. So let's have a look at upgrade proxy again. So get admin is five b, what should expect.
01:15:20.410 - 01:16:04.560, Speaker A: Proxy implementation is seven. Is that one up there? That's good. All right, so flash loan v one. Let's have a look. Who is admin? Question is, is it going to be the right one? No. All right, that is a. Why is that? Let's have a look at the, let's have a look at the upgrade proxy code.
01:16:04.560 - 01:16:52.370, Speaker A: So delegate, delegate call calls, result return data. So that should all work. That's nothing too complicated. Hmm. Okay. And I can see we're also running out of time here. And I will admit, for the life of me, I don't know what the problem is, but I do realize that it's now ten minutes to two, so we've been going quite a while.
01:16:52.370 - 01:17:47.842, Speaker A: And so what I'm going to do, rather than trying to piecemeal go through the code, is I'm going to go through the extra questions you should ask. Then we're going to go through all the bugs in the code. Okay, so at the moment, that code only supports ether for flash loans. And I'd ask people if they wanted to support ERC 20s as well, what should they do? And you're going to hope that they're going to start talking about the various APIs and storage variables. Another thing to think about is ave have APIs for flash loans and flash loan receivers. So you could ask what are the advantages and disadvantages of supporting them or conforming to them. So the advantages are obviously that anyone who's currently using flash loans could use your code.
01:17:47.842 - 01:18:32.250, Speaker A: So that'd be great. Possible disadvantages. They might try and sue you or something, maybe for using their API. I don't know that they would, but I don't know that they wouldn't either. So what were the bugs? So the first one was that the logic being around the wrong way, when you were trying to pause, you were saying not paused is false, or rather you're saying not paused is true. So in fact that should be not paused is false. There was also no access control on pause, which can be fixed with only admin.
01:18:32.250 - 01:19:26.380, Speaker A: And as well, one of the core business logic functions, flash loan didn't have a paused function at all. So it needed a. When not paused. There were some other more complex bugs, but ones that I think maybe if the code had been simpler, we could have got to. And Frank found, which was that you can have a reentrancy bug. And so you could imagine you do a flash loan to someone, and so you give them, say, 100 ether, and then they could call the deposit function and use it to loan back some money. And so they could use that to essentially have money in a contract which they don't really own, and then they could call payout later on to withdraw their deposit that they haven't really made.
01:19:26.380 - 01:20:41.470, Speaker A: So the obvious way around that is just check if you're in the middle of a flash loan. Another thing that wasn't checked for was, did deposits exist already? And so if they already exist, then you've got a problem, because what you could be trying to do is you could be overriding someone else's deposit id, and if you do that, then they can't withdraw, which is a problem. So you need to check that deposits don't exist. Another thing that we didn't get to was storage collisions. As I said, you've got this delegate call thing where the flash loan contracts operate in the context of the upgrade proxy. And so what this means is that it's good because it means that the variables that are available in the flash loan v one and all the storage variables, so it could be a megabyte of data or something. They're all available in V two, which is great, but you've got to be really careful that you don't have storage collisions.
01:20:41.470 - 01:21:43.110, Speaker A: And so what I mean by that is that if you look at the, to the left there, you've got version flash loan v one, and then on the right, you got flash loan V two. And we just introduced one variable called Pauser. And by doing that, all of the other variables shuffled down by one. And so it meant that when you upgraded, all of those variables would be pointing at the wrong things, and so the whole contract would suddenly break. And so what you need to do is have some fixed length arrays and have them as gap variables, and so you need to put them in any file that you're expecting could be inherited from. And so they need to be the last storage variable in that file. And 100 is a random, it could be 1000, it could be a million, but you're unlikely to have more than 100 storage slots that you need in an upgrade.
01:21:43.110 - 01:22:46.806, Speaker A: And so you have something like that, and you could even have it based on the name of the contract. So it makes it easier when you're looking at a map of storage variables. And so doing that, you end up, say, after the version in it, one, you have this gap, and then after admin, and then as you go down, and so you could have this gap pause me v one, which was 100, and then you could just have, say, the pauser variable put in. And now that gap variable is only 99 long. So it means that all the other, the actual locations for all the other variables are still all good. And so we talked about the constructors used in application code and how they operate in the wrong context. And so you've got to make sure you don't have constructors, but you have initializers.
01:22:46.806 - 01:23:32.300, Speaker A: And so you have something like that. Yeah. And then what's this? Oh, yeah. And you got to make sure you're calling initialized from the upgrade proxy. So there were some more complicated bugs, and there was the proxy storage collision, which we talked about, where essentially the variables from the proxy and the application contracts are operating in the same storage space. It's okay and clash, and it's just a matter of storing them in a unique location. You've also got the function selector problem, which we talked about.
01:23:32.300 - 01:24:37.120, Speaker A: And then the final one isn't a bug as such, but it is something that a good solidity dev, I think, should notice and find. And so the storage usage in the flash loan base contract wasn't ideal. And so you notice that there was a structure there, a deposit struct, and it had a whole set of variables. And so the idea is that, say, when you were depositing, you set up all the variables, and then when you were doing a payout, you read the variables back and you did all that. And so the problem with that is that you're storing stuff and reading stuff, and that costs tons of gas. So a better way of doing it would be to store the hash of all those values that you want to store. And then in payout, you pass those variables in as parameters, and you calculate the hash and you check, just a sec.
01:24:37.120 - 01:25:40.740, Speaker A: In payout, you pass those variables in. And then what you do is you check that that deposit hash matches. And in that way, you only have to have one variable, one storage slot, which is much cheaper. So, look, we've gone for one and a half hours, which is a very long talk. And I should have tried to make the interview questions more concise, but I think it's hit on a lot of the really complicated things that you have in these contracts and in web3 and things that have caused hundreds of millions of dollars worth of damage. And whoever, if you're going to have a test that's similar to this, you're going to have to be really good at solidity to get through it and to be able to invigilate to administer the test. Otherwise, the candidate is going to talk about stuff and you're not going to understand.
01:25:40.740 - 01:26:17.214, Speaker A: The ideas talked about in the test are really important, though. And so I think that what you need to think about is maybe people will see this YouTube video and maybe they will get to know the answers. And if someone gets to know the answers to the problem by looking at the code, looking at this video, then maybe they've cheated. But on the other hand, maybe they know how to do stuff as well. Maybe they've learned stuff. And if they've learned stuff that'll stop your project losing hundreds of millions of dollars, then that's a good thing. There are a stack of talks coming up next year.
01:26:17.214 - 01:27:08.734, Speaker A: The first one is January 18, and that's Ben Ngton, and he's going to be talking about the probable way to move forward with scalability with protodankard sharding. There's also a conference that coming up, and the call for papers is closing on January 23. And so whether you're interested in writing an academic paper or an industry talk, if you're interested in crosschain, please consider submitting a proposal, and this talk can be found on YouTube. If you're interested, please join the slack and join the meetup. The example code is there, and Frank and others run a formal methods reading group. So join the slack. Get involved by going to that part of the group.
01:27:08.734 - 01:28:17.450, Speaker A: And I have talked an awful lot, and so are there any questions? Will the recording be available for this session? Probably later today, but it could be tomorrow. Thank you. And are there any other questions? I realize it's one and a half hours later, so everyone's probably saying, all right, let's just end it off. We're all good. So next year for the ethereum solidity test thing, I think I'm going to have to have something that's more concise. Halfway between the last one and this one question I've got, Frank, is, so you've seen the bugs that there were. Could formal methods have saved us from all of these complex bugs, especially the intercontract ones? Is that possible, or is that beyond what formal verification can do?
01:28:17.900 - 01:28:47.312, Speaker C: So, no, I think you can do it. You have to model it. I haven't modeled the pose and the proxy in my modeling and to go beyond, I would say, finding the bugs. I've also been able to pull some properties of the complex, some invariants of the complex, but I haven't modeled the posing feature. I mean, the posing bug, for instance, that you have. Yes, I probably would have found it if I had added the pose variable, the upgrade with the proxy.
01:28:47.376 - 01:28:50.436, Speaker A: It's a bit more complicated because I.
01:28:50.458 - 01:29:08.590, Speaker C: Think of the storage collision and so on. It has to do with the way storage is managed and a lot of different things. I would say maybe it's doable, but it requires precise modeling, and I haven't done that there.
01:29:09.200 - 01:29:23.000, Speaker A: All right, cool. Thank you. All right, have a great day for those who believe in Christmas and New Year. And it's the right new year for you. Merry Christmas and happy New Year. Bye bye, Peter. Bye.
