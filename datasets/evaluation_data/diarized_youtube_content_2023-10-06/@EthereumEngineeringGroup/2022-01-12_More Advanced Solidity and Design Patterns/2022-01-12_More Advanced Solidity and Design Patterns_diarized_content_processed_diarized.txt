00:00:01.450 - 00:00:52.646, Speaker A: Hello and welcome, everyone. My name is Peter Robinson, and today's engineering theorem engineering group meetup is going to be a talk by me about solidity and advanced solidity and design patterns. I hope you all learned something. I learned a few things during the talk, so, yeah, I think, hope you'll find it useful. So, Sandra and everyone else, can you see my slides? Okay, that's all good. All right, so, more advanced solidity. So there was a talk back in 2018, which does feel like 100 years ago, and that was advanced solidity and design patterns.
00:00:52.646 - 00:01:20.338, Speaker A: And that was actually quite a popular talk. We've got about 1000 views on YouTube for that one. And then in 2020, I followed it up with a talk on the EVM. And then there was also the talk on Solidity 0.6. But the EVM talk is one that in particular, I asked people who were going to come and turn up to this talk, please consider watching it. So if you haven't, don't leave. Don't worry.
00:01:20.338 - 00:02:27.914, Speaker A: It's just that understanding everything in this talk will be made much simpler by having watched that recording or having attended the talk. So what is advanced solidity, and what does advanced even mean? As I said, I did that talk back all that time ago, and at that time, advanced meant in the upgrade pattern where you had a data holder contract and you were upgrading from one business logic contract to a new business logic contract. I did talk a bit about assembler, and I had a lot of small design principles and ideas for people to think about. But that data holder upgrade pattern was one of the big things. It's all still relevant, so it's worthwhile thinking about. So what is advanced? And so I'm opening the floor up. Please go off, Mike, and just call out.
00:02:27.914 - 00:02:53.890, Speaker A: What do you think advanced solidity actually means? I don't know. Maybe ways of optimizing the code so it doesn't consume gas or something like that. Yeah, that's a good possibility. Any other thoughts?
00:02:56.490 - 00:03:15.930, Speaker B: I guess some of the other things that don't normally come up in contracts, like assembly calls, some of the new throwing exceptions, packing variables like un one two eight into two five sixes, which is kind of like what the other speaker said around making a bit more optimized.
00:03:19.550 - 00:03:38.850, Speaker C: Maybe it could also be related to security in solidity, the considerations we have to consider when we code in solidity. Maybe instead of talk about advanced solidity.
00:03:39.830 - 00:03:42.802, Speaker A: We may talk about solving advanced problems.
00:03:42.936 - 00:03:48.950, Speaker C: Maybe like defi staff and very complicated business models.
00:03:49.450 - 00:04:37.190, Speaker A: Okay, looks like we've got a few ideas for some future talks. And you'll be happy to know that gas optimization is actually a planned future talk, as you'll soon see. But that's interesting. And actually getting a security talk. I should try and tap one of the diligence team and see if one of them would be interested in doing a security talk because that would be quite interesting to see what they would say. How have I defined advanced? What is it these days? Well, cross contract calls, which is related to all this error process. Error handling is something which is a bit complicated.
00:04:37.190 - 00:05:20.994, Speaker A: And so I'm going to talk a little bit about that and I'm going to talk about the upgrade pattern that Openzeppelin use. And also talk about using hidden parameters and context. So all of these things end up using assembler as well, which does make it a bit complicated as well. Anyway, it's not what everyone was wanting, but it's good to know what people want. So we can try and tackle some of those subjects in later talks. So cross contract calls the dude off to the left. It's a free photo, but I believe it is.
00:05:20.994 - 00:06:00.378, Speaker A: Actually the photographer took a selfie. But anyway, so imagine here's an externally owned account, and so he's calling contract A. And contract A is calling contract B. So that's a cross contract call. So you have message sender for contract A is the externally owned account and the context of the call. So whose storage is being used is contract a. And similarly in contract B, the message sender is contract A and the context.
00:06:00.378 - 00:07:05.460, Speaker A: So whose storage is being used is contract B. There's also an opcode called call code. And with call code message sender is again the same, but the context for both calls is contract a. So what that means is the code inside contract B is going to modify the storage in contract A another opcode called delegate code or delegate call rather the context is contract A for both of them. And the message sender is the actual externally owned account. So whatever's calling contract A, so that means that the code that's executing inside contract B, it feels like it is actually in contract A, and it can do anything the code in contract a can do. There's also static call.
00:07:05.460 - 00:08:05.110, Speaker A: And in this one the message sender is as if it was a normal call, and the context is as if it's a normal call. The only difference is that contract B cannot update state. So if in a higher layer language, contract B had advertised that it wasn't going to update state, then this would enable at a lower EVM level to try and enforce that to make sure it doesn't update state. Another thing to think about and understand is memory layout. So if you look at these two contracts, you've got two un two hundred and fifty six s and then you've got a range of things. You've got a UN 256, an address and a mapping. So you have memory slots for your storage.
00:08:05.110 - 00:09:10.860, Speaker A: I should probably call these storage slots, not memory slots, but yeah, so contract A, the first variable that's declared is in slot zero. The next one is in slot one. And similarly for contract B, the first variable storage variable is in slot zero, then slot one, then slot two. Now for mappings, as per that EVM talk, there's nothing actually gets stored in memory slot two and it's all related to the message digest of two and the key value in the mapping. So have a look at that EVM talk. To really understand how storage happens for mappings you got to think about how the storage is done sequentially. And so if you've got a delegate call happening, then what's happening is contract B, as I said, is going to execute in the context of contract A.
00:09:10.860 - 00:10:17.918, Speaker A: And so its variables are going to be sort of on top of these storage slots for contract day and they'll be modifying those storage slots as if those were the variables there. So you've really got to be thinking about how those things work. That is what happens when you do a delegate call. So going through it again with those four call types we've got call, which is the standard thing that you execute when you're doing a cross contract call where you're going to update state. And the context of the contract B is contract B itself and its message sender is contract A and it's going to update the state or can update the state in contract B. And this is what's normally used. Call code is deprecated.
00:10:17.918 - 00:10:55.994, Speaker A: So it was a EVM opcode that was in the original EVM. But due to a bug the message sender and message value weren't of contract A and were of contract B by mistake. And so it wasn't what was planned. And hence delegate call was introduced to replace call code. And it's typically used for your linked libraries. So there are two types of libraries. There are embedded libraries and linked libraries.
00:10:55.994 - 00:11:45.582, Speaker A: Embedded libraries become part of the contract and link libraries. You deploy them on the blockchain and then when you're building your code you supply the address of that linked to contract. That library. Contract static call is used for pure and view calls. So let's get a bit closer to the detail. So we've got two contracts here that we're going to do a cross chain or cross contract call for. So from contract A to contract B, and we're setting up the address of contract B in the constructor, and then we're calling it.
00:11:45.582 - 00:12:40.686, Speaker A: So zeroing in on that actual call, we've got Val is the return value from that stuff, one function, and we're calling into that other contract, and we're actually passing in a boolean. And if the boolean is true, then we are going to do a require and fail. Otherwise we'll update state and we'll return a value. So if we zoom into the actual byte code here of what's going on, you do that call. So let's not worry about putting all the parameters together for the call. You're doing that call, and then you're checking that the actual return value out of that call. So what's pushed onto the stack is zero or not.
00:12:40.686 - 00:13:26.720, Speaker A: And if it is zero, then an error has occurred. And so we duplicate the return value, and then we say, well, all right, so if the call returned zero, and so if it didn't return zero. So essentially this is a not statement. So if it didn't return zero, let's jump to one, two, b, and we're going to go and fetch the value. So we're essentially going to process the return value. However, if it really did return zero, indicating there was a failure, we've got a revert or a panic or some other error. And so what we want to do is the return data is going to include the error information.
00:13:26.720 - 00:14:15.818, Speaker A: And so what we want to do is we want to copy that into memory. And then we want to do a revert. And when we're doing a revert, we want to indicate by pushing onto the stack the location of the return value being zero and the size of it being return data size. And so that's what this bit of code here is doing. So works out the return data size, pushes that onto the stack, copies the data from the return data into memory, and then it pushes return data size and that location. You can also do this level of detail in solidity as well. And so first thing you do is you put together your parameters by Abi encoding them with the function selector.
00:14:15.818 - 00:15:43.670, Speaker A: And so we plan to do stuff one on contract B. So we do stuff one selector, and then we pass in the parameter value being the boolean, and then we do that call, and we're going to return success or failure and the actual return encoded value, which can be the result or can be the error message. So if it was successful, then what we can do is we can ABI decode the return value, which was that Un 256 and then put it into Val. However, if it wasn't successful, then it's going to be a matter of decoding that value and then getting the return and revert reason together and reverting with that revert reason. So this little bit of code here is smaller than you would have to have if you were going to try and handle panics and other user defined error codes. So that would be how you could do it to handle a revert. So I hear you say, so we can go from one line of code to all of that to handle doing a function call across two contracts.
00:15:43.670 - 00:16:25.282, Speaker A: And why would you choose to do that? And one of the big things is that you're doing that call when you could be doing a delegate call. And you might choose to do other interesting things. For instance, you might try and catch the errors and process the errors. So that could be one thing you want to do. So there are error mechanisms in solidity. So we've got the panics and the reverts. And so revert or require throws actually an error bracket string.
00:16:25.282 - 00:17:15.110, Speaker A: And so that's what you're actually getting. Whereas the panic, you're getting a Un 256 or an integer, any of these error messages are encoded essentially with the bytes for function selector and then ABI encoded parameters. So similar to as if you're having a function call. And the panics, they're listed in the solidity documentation. But it's divide by zero stuff and things like that. Or the one I seem to run into an awful lot is array out of bounds exception, which I think is number 300 x 32 there. So you've got a whole range of panics and why they might occur.
00:17:15.110 - 00:18:09.580, Speaker A: But in very recent times in, I think it's eight point, I don't know, one of the more recent versions in 0.8, custom error codes have become available and so you can define your own error and then you can go revert my error. So at the moment the ability to go require have a boolean statement followed by your error doesn't exist. And I'm sure they're planning to put it in. But at the moment you can do this. So obviously the tooling, say for web3 J and web3 Js and other tools probably don't handle this quite yet. And the other area is actually, I'll show you the other area that doesn't appear to handle it yet either.
00:18:09.580 - 00:19:12.702, Speaker A: So in solidity 0.6 try catch was introduced. So you can go try and then the function call you plan to do and have the return result. So you can have val equals that. And you can also catch error, which is essentially for revert or require, and then do some processing with the reason you can also get the panic error codes and maybe do something with that. And also there are other, if you say, if it's neither of those, it might just be some other error code, that's the limit of it. Now I did try doing a catch and then my error and I couldn't get that to work.
00:19:12.702 - 00:20:12.480, Speaker A: So maybe that's not supported yet. Yeah, so that might be a limitation on custom errors, which I'm sure they'll get sorted out soon. So you could imagine you could write your code to catch the error and then do some action in the contract that's calling the contract that's failed. That's a lot of cross contract calling. And I'm going to talk about the upgrade proxy, which does some very interesting upgrade and using cross contract calls. Okay, so the open Zeppelin project, which I've been told is all one word, so you can remove that space there. So they've come up with this upgradable proxy contract and associated contracts around it.
00:20:12.480 - 00:21:50.650, Speaker A: The proxy Sol is a bare bones implementation, but then there's a lot of other derivatives of it that do admin and upgrade and other things. And so recall that we had this delegate call feature where the contract B executes in the context of and has message sender for the actual contract that's been called so called from say contract A. And so if you have a proxy contract there and it's doing a delegate call, then contract B is going to execute in the context of the proxy. And so what you can imagine is you can switch out contract B for a new version of contract B and it's going to still be executing in the context of the proxy. So if the proxy holds all of the storage, all the data, and the contract b holds all of the code, then you can just upgrade the code and still have the data sitting in that proxy. So one of the implementations in open Zeppelin is the transparent upgrade proxy, and it defines a couple of external functions, say admin implementation, change admin, upgrade to an upgrade to and call. So you can imagine that these are to allow you to manage the actual contract.
00:21:50.650 - 00:23:04.338, Speaker A: And so you can only. So admin and implementation return the current admin and the current implementation addresses. Change admin update, who can admin the contract upgrade two, only the admin can upgrade and you're supplying a new implementation and upgrade two. And call you're supplying a new implementation and then you're saying hey, can you execute this function call? So you can imagine maybe there's some one off upgrade script that needs to execute. So the implementation contract can't have functions that have the same function signatures as these because they're going to be filtered out. So you can imagine the EOA calls the proxy and so say if the admin is one of the functions it's got defined, then it'll execute that. So if the function it wants to execute isn't in the list, then the fallback function executes and the fallback will then call into contract B and then contract B's functions get executed.
00:23:04.338 - 00:24:32.546, Speaker A: So if contract B had a function called admin, it would get filtered out. And so contract could never execute in contract B. So I said that the fallback function magically calls across to contract B, but how does that really happen? What's the magic behind that? And I've simplified the code a bit, but the first thing you get is the implementation address. So you've got to get that and then you copy, you copy the call data into memory, overriding whatever's there. So the idea is that you're going to be exiting at the end of this actual call, the end of this fallback function here with either a revert or a return, so you don't have to worry about trashing everything. And then it does that delegate call saying which implementation to use and passing in the call data saying it's at memory location zero and this is the length of it, and then getting the result of the call. So whether it passed or failed, and then you copy the return data to location zero and then you switch based on the result.
00:24:32.546 - 00:25:39.400, Speaker A: So if it's zero, then you're going to revert and you're going to say well, it's at memory location zero and here's the size of the return data, otherwise it's passed. And so you can return the information and you can just return rather than reverting. So the memory layout looks like this. So the actual implementation address has to be stored somewhere far away from anything that users might use. And the implementation address is actually the message digest of a certain bit of text. And I guess the thought is that the collision resistance, actually it's the second pre image resistance property is strong enough that no one is going to be able to find a collision for this address. So even if you had someone who maliciously wrote a contract that gets upgraded, then it's not going to clash.
00:25:39.400 - 00:26:49.360, Speaker A: And so it's far away and out of the way. And so contract B has these storage slots used, and then when it gets upgraded, you can imagine that you might have a new variable pause. So maybe you decide it's going to be a pausable contract, and so that just is going to be added on to the end. And so as long as you keep on adding, you're all good. So if you say deleted address as a variable in V two, then balances would suddenly be at storage slot one and pause would be at storage slot two, and that would obviously not work for you. But what about more complex code like this one here, where you've got contract C, which has got two storage values, contract D which has got two storage values, and contract E, which has its own two storage values and is contract C and D. This sort of using multiple contracts is very common.
00:26:49.360 - 00:27:42.800, Speaker A: And so you can imagine that this is a common scenario. So initially the memory layout looks like this, so the storage values are included in the order that the contracts are in after is. And so contract C's, variables, then contract ds, and then finally contract E's. So yeah, contract C's, ds, and then ease. So if we add a new variable to contract C, the memory is going to look like this, or the storage is going to look like this, should I say. So then value three, which you've just put in, is going to be where Val four was. And so everything is going to be offset by one.
00:27:42.800 - 00:28:38.948, Speaker A: And that's a bit of a disaster. So what you can do is you can look at your crystal ball and try and say, well, how many variables are we ever going to use? And maybe you define 100 of them. And the thing is, because they're private, the solidity compiler is not going to generate any code. So there's no cost of defining these private dummy values. And so you could define 100 of them and you'd be all good. So you might want to define 100 of them in each of the contracts that gets used. And so if you say just defined one, then the storage layout in V one looks like this, and then as you add that variable in V two, then val three is going to relate to dummy zero.
00:28:38.948 - 00:29:54.692, Speaker A: So you're not going to have disrupted your storage map of your variables. So are upgradable contracts a good idea or a bad idea? I mean, that's really the question. And I had a look because I know that there was a contract that was deployed late last year. And then it's one of these defi contracts, it then attracted a ton of money. And then what happened was people, they upgraded the contract, and then the owners of the contract were able to withdraw all the money because they'd added an extra function that let them do whatever they needed to do, which was steal all the money. But on the other hand, as we all know, on this call software, the next project that is completely bug free, completely has no bugs from day one, will probably be the first one. So, yeah, any reasonably complex bit of software is likely to have deficiencies.
00:29:54.692 - 00:30:55.260, Speaker A: And even if those deficiencies are later on, we decide that it needs to do something else as well. It still means that you probably need to be able to upgrade. So with upgradable contracts, you really are trusting the owner. So whoever is the owner, and it could be a multi sig, but it might just be an EOA, you're really trusting them to not do a bait and switch. And so I guess it is up to the buyer or the user to beware and to have a look at who is the admin. Is this an upgradable contract? And if it is, who can do that upgrade? Okay, so the next part, right, Candice has said, are upgradable contracts transparent? And let's see, 102. So that's very recent.
00:30:55.260 - 00:31:51.710, Speaker A: So they're not, as far as I went through, how the functions can be filtered out. And so, for instance, if the proxy had admin defined as a function, then none of the versions of the other contract, that's the contract B, can have admin. So from that perspective, it's not transparent, but from a perspective of, say, operating in the context of the proxy contract, yes, it is transparent. And Candice, is that what you were asking about or have I got it wrong? Yeah, that's what I was asking. Thank you. All right, cool. All right, let's grab some water.
00:31:51.710 - 00:32:41.052, Speaker A: Okay. Hidden parameters. So functions have got function signatures that look something like this. This could have been an interface. In fact, this is the transfer function you get with an ERC 20. But sometimes, don't you just wish you could add a few more parameters in, have some extra parameters that you sneak underneath some sort of context, and especially when you've got a public interface that you can't change. And so it is possible, imagine you've got call function and you're going to go and you know, pass in this val.
00:32:41.052 - 00:33:38.770, Speaker A: So you know, you'd like to have V one and v two, some authentication parameters or something. And so normally with a function call, you've got this call data and you have that bytes for, which is the function selector. And then you have these ABI encoded parameters, the bytes there. And what would be good is if you could have some hidden parameters at the end that you could pass in and then pass and then you could use on the receiving function. And so what you can do is this. So we encode the function and function selector as per normal. And then maybe you've got some additional authentication parameters that you want to pass in, so you encode them as well.
00:33:38.770 - 00:35:09.820, Speaker A: And then you concatenate the two bytes together and then you've got your function call and you've got your authentication parameters and then you go off and do your call and process your reverts and panics. And so now the function you were calling that funk on the destination contract can process them. And so on the destination contract you can get the message data and then you can go and look at the length of it and use that length to essentially take information from the end of call data. And so you can copy that to memory and then load up that memory location and put it into the storage value. And so to try and decode that, so we're subtracting the length 64 from the length. So two words and then we're saying, well, the length that we want to copy is 32. And so we're copying two location zero from this location in call data and 32 bytes.
00:35:09.820 - 00:36:15.516, Speaker A: Yeah. So obviously just doing this blindly might be a bit dangerous. So you might want to either check the length of message data to see if it just matches what the parameters and the function selector are. Another way you could do it is if you could say, does message sender equal the function that's supposed to be calling it with those additional parameters, then you know you're good to go. So you could have an allow list of known contracts and if it's one of those known contracts, then you know you're good to go and use those authentication parameters. My use of these parameters is so you've probably heard of the GPAC system, so the general purpose atomic crosschain transaction system. And so the hidden parameters are used to inject cross chain authentication parameters.
00:36:15.516 - 00:37:18.740, Speaker A: And so you've got users who are programming against the contract's normal API, but the cross chain code wants to inject these authentication parameters under the covers. And it means doing it this way is important for security as well because you wouldn't want users to spoof that information. It's much cheaper by the way to do it this way via call data than to maybe say, store the authentication information, call the delegate contract, and then have it call back. And so I've got to the end of the talk. I do have two other slides and so maybe I'll quickly flip to them first. So this meetup group, we've got a YouTube channel, there's a slack workspace. So if you want to engage with others who are involved in the meetup, please join the slack workspace.
00:37:18.740 - 00:38:20.650, Speaker A: Obviously we're on meetup, but if you're watching this on YouTube, that might be news to you. And a lot of the example code that you've seen here, and example code from previous talks is available in that repo. And there are a whole stack of talks coming up, one of which is staking as a service. Roberto's talk on formal verification of QBFT has been moved earlier by one and a half hours. There is a talk coming here that's in the works and there's going to be the hundredth talk. So we've been going for four and a bit years. And so I'm lining up a surprise speaker who anyway, due to get them to come on board, and then probably in April or May, I'm going to do a talk on the gas usage and gas optimization, and we can talk about the memory optimization as well.
00:38:20.650 - 00:38:26.030, Speaker A: So are there any questions?
00:38:31.120 - 00:38:44.290, Speaker C: So instead of using the hidden parameters, why can't you just write another function which will accept those extra parameters and have all the checks? What, you need that, who called the function?
00:38:45.060 - 00:39:22.190, Speaker A: Sure. So why couldn't you do that? It would have a different function selector. The function selector is the hash of the function. So, so you can't do that. That way if you say you had to code to an API, you might have some people who are going to just use the API, whereas other smarter newer code that's going to use the API and pass in some additional parameters. So maybe there's the old and the new version potentially. I mean, that could be another reason why you might do it.
00:39:25.040 - 00:39:50.500, Speaker C: You could have an encapsulating function which will have that extra logic which will again call the API function, and that can be protected to certain calls, like only certain contracts can call, or certain EOS can call anything else which you need, you could do that. I mean, I know it's possible theoretically, but isn't it just making it more complex to read or there is an actual use case for it. I didn't get it, sorry.
00:39:50.570 - 00:40:45.880, Speaker A: Yeah, okay. Yeah, sure. So with Gpact, what's happening is the actual function call. So the bytes is passed to the contract, and then that contract then needs to call that. And so it's got to put it on the end rather than because it can't rely on the thing calling it to get that correct. But I still think passing, say, additional information in when you've got a standard API makes sense, too. Are there other questions? Okay, looks like we're good to go.
00:40:45.880 - 00:40:53.910, Speaker A: All right, well, look, thank you, everyone, for joining and have a great day. Talk to you later. Bye bye.
00:40:55.530 - 00:40:57.982, Speaker C: Bye bye, Peter. Things.
00:40:58.116 - 00:40:59.166, Speaker B: Thanks, Pat.
00:40:59.348 - 00:41:01.290, Speaker A: Bye, Peter. Thanks. Bye.
