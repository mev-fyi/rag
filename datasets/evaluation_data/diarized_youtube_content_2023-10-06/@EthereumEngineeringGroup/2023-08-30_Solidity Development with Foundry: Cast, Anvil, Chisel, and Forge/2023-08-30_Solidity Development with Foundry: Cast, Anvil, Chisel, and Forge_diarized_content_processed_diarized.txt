00:00:02.810 - 00:00:16.320, Speaker A: Hello and welcome, everyone. My name is Peter Robinson, and today I've got Christian on the line who's going to tell us all about forge and related tools. So, Christian, why don't you introduce yourself before we start?
00:00:17.650 - 00:00:24.122, Speaker B: Yes, sure. It's actually one of my first slides, so can I just go ahead and share my slides?
00:00:24.186 - 00:00:25.880, Speaker A: Yeah, why not? Why not?
00:00:28.650 - 00:00:30.566, Speaker B: Can you see my slides and hear me?
00:00:30.588 - 00:00:32.120, Speaker A: Well? Yes.
00:00:33.290 - 00:01:22.246, Speaker B: All right. So, yes, a little bit about me. I'm a longtime listener, first time caller, so to speak, of the show, and, yeah, generally got into smart contract development during the COVID lockdown. And yeah, I've been doing pretty much nothing else since then. I'm an open source enthusiast as well, so I try to give back a little bit where I can. And since pretty early in the foundry project, I'm a big fan, a heavy user, and even occasional contributor. So I am super excited to be able to share a little bit about my enthusiasm and what I know about the project with you guys.
00:01:22.246 - 00:02:20.220, Speaker B: And, yeah, if you have any questions, corrections, anything else, feel free to contact me on telegram. And if you want to see what I'm up to, you can also check out my GitHub account. And so, without further ado, I want to talk a little bit about foundry. First, to kick off. What is foundry? Foundry is a smart contract development toolkit, so kind of similar to tools like hardhead or truffle, but it does a few things differently, which hopefully I'm going to show today. As far as I know, it's an extended port of a previous project called Daptools. So if you've heard about that, you'll see that the interface and the philosophy behind it is very similar.
00:02:20.220 - 00:03:23.790, Speaker B: It is implemented in Rust, which makes it very fast. And, yeah, just as a side note, it's a great project also to get involved. If you want to do some rust open source work, they have an amazing community and really welcome new contributors. So it's also a great chance to learn some rust. And generally it consists of four components. So a lot of the content out there about foundry really focuses very heavily on forge, which is kind of the main testing framework and compilation and scripting, but it also has three other parts which are very powerful tools in their own right. And today I want to give a bit of an overview of all of it and then dive a bit deeper into forge.
00:03:23.790 - 00:04:25.650, Speaker B: So that's going to be the structure of this talk. We're going to go through the three other tools, namely cast, envel and chisel, really quick and just kind of tease what they're about and what you can use them for. And then the rest of the talk we're going to look into forge, mostly into testing, and then also a little bit into. So the first tool that I want to talk about in the foundry toolkit is cast. Sorry, no, first we're going to obviously have to say a few sentences about how to get started. So in order to use foundry, because it's unlike hardhead, it's not a JavaScript framework, and so you cannot install it with the NPM or yarn what you might be used to. Instead they have their own installer called Foundry up.
00:04:25.650 - 00:05:56.782, Speaker B: And so the first command here basically downloads that installer and initializes it. And then you will have in your terminal or in your path, you will have this foundry up command, and you can use that when installing foundry for the first time and also to manage versions, upgrade, downgrade, all that kind of stuff. And yeah, once you have installed foundry to foundry app, you will have all the four toolkits that I said before. So forge, cast, envelope and Chisel will be their own kind of commands in a command line, which you will then use to basically leverage these tools. And yes, the first one is cast. Cast is a kind of tool that allows you to do all kinds of cool stuff when interacting with Ethereum or any other EVM compatible blockchain. And so it's kind of for these ad hoc things like you want to get some data on a block, on a transaction, on an address, you want to make a call to a contract, execute a transaction, you can read specific storage values, you can do all kinds of encoding and decoding call data and a lot more, really.
00:05:56.782 - 00:07:25.180, Speaker B: So it's a great tool for debugging the state of any kind of chain or node, both like the actual chain, but also if you have a local test node and you want to look at what happened there, it's really great tool. And again, it has a huge amount of commands. You can use the help command to see all of them. I'll just show two right now, which are really for me, have been great productivity enhancers and have really helped me a lot. So one example of something cool you can do at cast is called cast interface. And so if you run the command cast interface and then the address of a contract, it kind of generates automatically a solidity interface file for you. So I don't know about you guys, but sometimes when I'm working on a smart contract and I'm integrating a third contract, what I happen to do is look into their source code copy paste the function signatures that I'm using and then deleting the function body and all that kind of manual, quite tedious stuff to generate this type of interface and basically cast automates all of this for you.
00:07:25.180 - 00:08:20.678, Speaker B: And it makes sure that you actually have all of the functions of all the inherited contracts in your interface definition, which is great the way it does that. As far as I know, it uses like etherscan to get the contracts abi and then generate this. So this will most likely only work for contracts that are verified on etherscan or are part of what you're developing locally. But yeah, I think most cases that will be the case anyway. And yeah, this also works with other chains, then you have to give it a custom ether scan URL. But yeah, this is really a neat little trick that saved me a lot of time already. And then the second one is called cast run.
00:08:20.678 - 00:09:24.462, Speaker B: So cast run. And this is really, to be honest, even just for this one command I think is worth installing foundry for. Anyone I've shown this has told me that this was a real game changer for them. And what allows you to do is basically it's really good for debugging transactions. So what it will do is it will resimulate a given transaction on a local EVM. So it will kind of fork the chain just prior to that transaction, and then it will in a local evm rerun the whole transaction and give you a whole trace of all the external calls that were called errors. It gives you gas usage, it shows you when there were delegate calls, so you can easily understand when there might be a proxy involved.
00:09:24.462 - 00:10:12.850, Speaker B: It's really good at error tracing, so you rarely get the old, I don't know, reverted without reason or whatever that you might have has frustrated me a lot in the past. If it runs out of gas, it tells you it ran out of gas and all these kind of things. So it's really good at finding quite often what went wrong or just generally understanding it. And like all these tools, it can be run against a local node. So the scenario where I find myself using this the most is actually when I have a project where I'm using hardhead and I have some kind of error in my tests. And I'm not quite happy with the traces in hardhead. It doesn't give me enough detail.
00:10:12.850 - 00:11:16.882, Speaker B: I don't quite understand what went wrong. I can run this command and get a whole more detailed view on the failed transaction, which is really great. And yeah, if you want to go really deep, you add the debug flag, and then it will even open a kind of interactive debugger, EvM debugger, so you can go through the transaction opcode by opcode and understand what went wrong. This is a more advanced tool, but even without a debug flag, it helps me find the error in, I would say, four out of five cases. So that was cast or just a small subset of what cast can do. The second tool is anvil. Anvil is really just kind of hardhead node, but faster.
00:11:16.882 - 00:12:20.650, Speaker B: So basically it runs a local node that you can run tests against. You have kind of unlimited eth in that local node. It has all the features that you're used to, so you can fork the main net at a specific block number and all that kind of stuff. So in terms of functionality, it's really pretty much, as far as I know, exactly the same, but it's just a lot faster. Even just swapping your hard head nodes with anvil can really speed up your test execution or your CI. And due to the kind of, because the RPC interface is the same, you can use it pretty much interchangeably with hearth node or with the truffle ganache. All these tools, just faster.
00:12:20.650 - 00:13:05.010, Speaker B: And then the last one before we go to the testing is called chisel. This tool, to be honest, I haven't really used in my day to day work yet. I looked into this in preparation to this talk. It's rarely even mentioned when people talk about foundry, as far as I know, but it's quite neat. In my experience in preparation, I found it quite cool. And what it is is basically a replalue print loop for solidity. And repl is pretty much the same that happens when you just type python or node in your terminal.
00:13:05.010 - 00:13:50.950, Speaker B: So you can do a kind of interactive programming where you type in each command and you can immediately see each variable's value and do all kinds of tests. And here you can do all of that in solidity Europe. So you have access to pretty much the whole solidity syntax. You can call out to other contracts, as you can see up there. You can specify a specific block number and then the code will be executed as if it is a transaction at the beginning of that block. And so, yeah, I could see this also being very useful for some iterative development or some debugging. There's a lot of potential.
00:13:50.950 - 00:14:04.938, Speaker B: Yeah. So before we go on to the main part, which is about the testing, does anyone have a question about these tools or about foundry in general?
00:14:05.104 - 00:14:07.530, Speaker A: I think there are a few questions in the chat.
00:14:08.750 - 00:14:12.046, Speaker B: Yeah, sure you want to read them out, maybe.
00:14:12.148 - 00:14:12.654, Speaker A: Yeah.
00:14:12.772 - 00:14:13.440, Speaker B: So.
00:14:15.250 - 00:14:24.340, Speaker A: I'll go to Adebenga's question. Can it be used to run integration tests? So this was the cast run.
00:14:26.150 - 00:15:05.520, Speaker B: So cast run basically just reruns an existing transaction. So it reruns a transaction that has been submitted and included in the blockchain already for integration tests. We'll look later at forge, which is the testing tool for both unit and integration tests. So, yeah, this is mostly for rerunning transactions. But if you have an integration test on your local node running and it fails, then you can use cast run to debug that integration test and maybe find out where it went wrong.
00:15:06.610 - 00:15:36.358, Speaker A: Yeah. So that value there, that zero Xacff is what, the transaction hash? I guess, yes. Okay. So Dev asked, and I think they may have misunderstood, you had mentioned that it decode the function details, even software source code is not verified. And I think you were saying you thought it had to be verified for it to.
00:15:36.524 - 00:16:21.794, Speaker B: No, actually I forgot to mention this because it's really cool. Of course, as a first, I didn't fully look into the implementation. It might have changed. But my understanding is such that it first checks if the contract is verified on Etherscan or any other explorer, and then it will use that. But it has a fallback and it used something called the four byte registry. This is like an online repository of function selectors. And if the function selector is in this four byte registry, it can decode a function even if the contract is not verified on ether scan.
00:16:21.794 - 00:16:34.854, Speaker B: So obviously it won't work for all of them. But in many cases, yes, it can even decode unverified contracts.
00:16:34.982 - 00:16:52.190, Speaker A: Okay. Right. Yeah, that makes sense. The other one was a comment. So I don't have any questions. Does anyone else have any questions? All right, yeah, go ahead, Christian.
00:16:53.350 - 00:17:49.422, Speaker B: Yeah. So then the next topic, and the main tool in the foundry toolkit that we're going to talk about is forge. And forge is sometimes people even use forge and foundry, like interchangeably, when they're really just talking about Forge. And it's the tool that contains the testing, the deployment, the contract compilation, managing your solidity project. So it's really like the core tool that you're using when you're developing a smart contract. In that sense, it's kind of similar to functionality of things like hardhead, but it has a bunch of differences. And the main difference is that everything or pretty much everything you will be writing is in solidity.
00:17:49.422 - 00:19:07.130, Speaker B: So the tests are in solidity, the scripts in solidity. Of course, the contracts that you're working on are usually, I mean it can be in viper, but usually also in solidity. So in most cases you will have no context switching because you're doing everything in solidity, and then it's also, as before, it's very fast. And because you're doing everything in solidity and in a smart contract, there's a lot less boilerplate code when interacting with the chain. And also it has these improved arrow traces, what we looked at earlier with the cast run, these kind of detailed traces you have in a lot of places in forge in your tests and everything. And then it also has some really cool advanced testing features that go beyond what you would normally do in the existing toolkits, and those are fuzzing and invariant tests, and we're going to talk about those later as well. So basically you can do everything and more that you could do with existing toolkits, and you're going to be a lot faster.
00:19:07.130 - 00:20:15.426, Speaker B: And again, when you have installed foundry, you will have the forge command in your path. And so usually start by setting up a project using the Forge init command. And what that will do is it will create kind of a template project and with all the files you need. So it contains an example contract, it's the standard like counter example where you can increment a number, and then it also contains some example tests and an example script. You can see that all of these end in Sol, because as I said before, everything is written in solidity. It contains a configuration file. I'm not going to go into too much into the configuration file, but it's got pretty sane defaults, but you can pretty much change anything in there if you want to.
00:20:15.426 - 00:21:29.510, Speaker B: So you can change the RPC URL, the block number, you can change the compiler version, all that kind of stuff. And then it also has this lib folder where you find the dependencies. And because forge is again, it's not a JavaScript project, so it cannot use your standard Javascript package managers to manage dependencies and libraries. And so it has kind of its own system which is based on git sub module, which is kind of a bit of an advanced git feature, but basically allows you to quickly install any dependency that is on git. So it doesn't have to be on any NPM or anywhere. You just say forge install, and then kind of the GitHub repo name and owner. And then it will basically just download that repository and kind of link the files such that you can then import the contracts.
00:21:29.510 - 00:22:28.922, Speaker B: So everything is in solidity, including the tests. So this is the very simple test slightly adjusted from the template example? And to create a test, all you need to do is first you need to create a contract. As usual, everything in solidity, and so everything also in these tests and scripts needs to be wrapped in a contract definition. You inherit from this test contract which is provided by forge, and which gives you access to all kinds of assertion functions and all kinds of tools that you need for your tests. And then you have a setup function that is run before every single test. So it's equivalent to before each in the Javascript setup. So this function is run again before each test.
00:22:28.922 - 00:23:48.342, Speaker B: So you can have a clean setup for every test. And then Forge will recognize as a test any public function on this contract that starts with the word test. So yeah, that's how you kind of tell forge, run this as a test, and then you have a variety of different functions from the inherited test contract, such as assertions like we do here. So this is a very simple test where we just increment the counter and then we check that the number is one afterwards. This is basically the most basic test setup you can have, really in forge. And once you have defined your test, you can run it with forge test as usual, there are a whole bunch of different arguments or like parameters that you can pass to specify how these tests are run. So you can use regex expressions to only run specific tests, you can run them against specific block numbers, all kinds of stuff.
00:23:48.342 - 00:24:42.470, Speaker B: You can make it such that on a failure you enter the debugger that I showed earlier, but normally most of those you don't need. What's really good to set is the velocity. So it's from level one to five. So here in this case, VVV means we have velocity level three, which means that we get the traces on every failed test. And so here I kind of adjusted the test a little bit to have a failing test just to show what it looks like. And yeah, again, you get the same kind of really detailed traces that you also got in the cast run, arguments that can really help you debug what went wrong in your test. And also here in this screenshot, you will see how fast it is.
00:24:42.470 - 00:25:57.870, Speaker B: So this is 794 microseconds, so less than one millisecond that it took for this test to run. And yeah, it scales pretty well as well, so it's really fast. And yeah, no. Any questions regarding how to set forge up, how to initialize your project, how to run a basic test, or anything else really. If not, then I guess I will proceed so this was a very basic example, and in many cases in your tests, you actually want to do a little bit more. You don't just want to have these basic assertions, but quite often you need to do things like, oh, I want to check that maybe only the owner can call a specific function or something else. In many cases you want to check that certain things don't work under certain conditions, so you want to basically check for reversions.
00:25:57.870 - 00:26:50.350, Speaker B: And this is something where maybe you think, oh, I only have the normal solidity syntax at my fingertips, it'd be pretty hard to do that. But foundry has got you covered with that. So there are two ways of having a test that kind of checks for a reversion or a failure. The first, a little bit more crude example, is to just add the word fail to your test name. So if it's test fail, then forge will run this test and it will expect there to be a reversion anywhere in that test. So if there is a reversion in that test, it will be green. And if this function runs without any reversion, then forge will complain.
00:26:50.350 - 00:28:05.510, Speaker B: But yeah, I would say the somewhat better way to do it is to use the expect revert function that also comes with this test contract, and that allows you to check for a specific reversion. So a specific reason error in the very next call. So here in this case, we are checking for an arithmetic underflow error in the decrement function. So in this last test, and normally in this expect revert function, you would just type in as a string. The reason that you expect in this case this underflow error is a solidity compiler level error. So it's not an error reason that we define ourselves. And so for this case, there is this standard error library that forge also provides that contains the error data for all these kind of compiler level errors.
00:28:05.510 - 00:29:10.538, Speaker B: That is quite handy if you want to check for these kind of errors. But yeah, normally if you have an error, you define yourself, you just type in your error message there. And this is actually the first example of what is called cheat codes in foundry. So this VM expect revert is a quote unquote cheat code. And cheat codes are these kind of functions that are added by foundry that extend the normal solidity syntax to allow you to do all kinds of quote unquote fancy stuff that you might want to do in your tests but you normally cannot do on ethereum. So using these cheat codes, you can control the message sender, so you can check, for example, your access control, you can control the block number, the block time, really anything about the state of the blockchain at the point of the test. You can check for reversions, what we just looked at.
00:29:10.538 - 00:30:16.020, Speaker B: You can check for event emissions, which we're going to look at next. You can interact with things outside of the evm, such as your file system, your environment variables, your CLI commands, and a lot more. So, quite often when you come to a point where you think, probably cannot do this with foundry, more likely than not, there'll be a cheat code or a combination of these cheat codes that let you do what you want to do in your test. Another cheat code that is quite useful during test is this expect emit cheat code. And so what this allows you is to test that a certain event has been emitted. So up here in the top, we see a snippet of the implementation of the contract that we're testing. And it's still the standard counter contract, but here we added just emitting an event when we increment the number.
00:30:16.020 - 00:31:00.990, Speaker B: And now below is the test that checks that the correct event was emitted. And this, to be honest, is a little bit more complex, maybe in the foundry case. So you have to do a few more steps. You have to kind of copy paste the event definition into your test. Then you have to call the expect emit cheat code, and you have to tell it which parameters of the event you want to check for in your test. So in this case, our event has just one index parameter. So we set the first flag to true and all the other ones to false.
00:31:00.990 - 00:32:18.620, Speaker B: But normally, the first three flags refer to the maximum three indexed parameters of an event, and the last one to the rest of the data. So here you kind of tell foundry which parts of the event you want to kind of match and check against. And then what you also have to do is you have to emit in your test, you have to emit the same event that you expect to be emitted by your implementation. So you have another emit with this event and the parameters that you expect, and then you call the function under test and forge or foundry will test that. In that call, the same event was emitted that you emitted just before. So this is kind of how you check for events. I would say it's the most complicated kind of cheat code in forge and foundry, but yeah, it's how you do it.
00:32:18.620 - 00:33:09.340, Speaker B: And then another cheat code. So, again, here we're just giving a few examples. There are a lot more, but another very useful one is impersonating an account. So I mentioned earlier you might have a contract where you have some access control. So in this case, I have slightly extended the counter contract to make it such that only the owner, which is the account that deployed the contract, can, can actually call these methods. And if anyone else tries to call the method, they get an error. And then below we see the test to kind of check for that.
00:33:09.340 - 00:34:09.754, Speaker B: Again, we use the expect reverts function to say, okay, in the next call we expect there to be this reversion. And then also we use this VM prank cheat code that allows you to set the message sender for the next call to any address you want. So here we're going to call the contract from the zero address and we expect there to be this error. So this test would work. And it's another one very frequently used scenario in testing. But this is an example where you have to kind of. So there are some subtleties when using these cheat codes that you kind of have to get used to.
00:34:09.754 - 00:35:06.400, Speaker B: So this is a common pitfall, at least for me, it was a common pitfall that I ran into many times and want to see if maybe you can see what goes wrong here. So this example does not work. We have only slightly changed the test. You can see the only difference we did was instead of using the increment function, we're using the set number function to kind of achieve the same goal. And again we're calling it from, we want to call it from the zero address, but this time it doesn't work. So it says the call did not revert as expected. And yeah, the question is why? Does anyone here maybe have an idea why this example doesn't work?
00:35:07.730 - 00:35:16.340, Speaker A: I think I know, and in fact, I'll put it in the chat. But is it because the counter number is the next call?
00:35:16.950 - 00:36:06.020, Speaker B: Yes, that is correct. So counter number is the next call. So what forge will do, it will impersonate the zero address when calling the number function, but then when we actually call set number, we're using the original account again, which was the one that deployed the contract. And so there will be no reversion. And for that case, that's why I usually prefer to use a function called start prank and stop prank. And in this case, it will impersonate all calls in between those two cheat codes. And so in this case, we're also impersonating the number call.
00:36:06.020 - 00:36:22.920, Speaker B: However, this still doesn't work. And this was actually, when I was preparing the talk, actually had this iteration and I was wondering why this still doesn't work. Does anyone have an idea why this still doesn't work.
00:36:26.970 - 00:36:35.210, Speaker A: Wait to see if anyone else has got it. I know it, but I guess I've used forge, so I've sort of cheated.
00:36:36.190 - 00:36:37.420, Speaker B: That's all right.
00:36:37.870 - 00:36:45.870, Speaker A: Yeah, it's the VM expect revert, isn't it? Is now looking at count number and it's saying it didn't revert.
00:36:47.570 - 00:37:43.678, Speaker B: So it's kind of the same error again, but this time with the expect revert instead of the prank. This is a working example. So yeah, in this case we really didn't have, because there's no equivalent of start prank, stop prank for expect revert. So we didn't really have any. We, we kind of have to factor out the counter number call and yeah, I mean, in this case we could just use prank again in between expect revert and set number, but I still kept it at start prank, stop prank. And yeah, so this is the example where that works. And so this just kind of shows you that with some of these cheat codes you really have to pay attention, especially when thinking about, okay, what is actually the next call that I'm expecting a reversion for that I'm expecting an event from.
00:37:43.678 - 00:38:33.722, Speaker B: And this is my, in my case a common kind of trip wire. But yeah, once you get used to it, you're usually able to debug it quite quickly as Peter just did. And another handy tool that you might be used not just from smart contract development, but really from any kind of development is you want to debug your contract. And the first tool usually is just starting to lock stuff out. So your good old trusty console log. And yeah, you'll be happy to know that forge has you covered for this as well. So yeah, you have this console so library that you import in your implementation.
00:38:33.722 - 00:39:24.190, Speaker B: So here the code is the implementation itself because we want to lock something out from the contract that we're developing on. And then you can use these console lock functions and print out messages. Of course, again, in solidity, everything is very strictly typed, so sometimes they have different lock functions for different types and stuff. So you got to be a bit careful. But generally once you use it once or twice, it's kind of the same that you used to, maybe from JavaScript or any other library. And it's for me the first tool to go to when debugging something. And you can see on the top that the log message is then included in your test output.
00:39:24.190 - 00:39:56.090, Speaker B: This is kind of introduction to kind of basic testing. So far we've talked about basically replicating a lot of the functionality of maybe what you're used to in your old toolkit. And next, I want to talk a little bit about advanced testing, but before this, are there any other questions regarding what I just showed?
00:40:01.250 - 00:40:48.160, Speaker A: So Abde Herriman has put a question in the chat. I'll read it out. It's a question regarding forge. How can we get off chain non solidity data for the test, say real time API call? So real life example writing integration test for a smart contract integration, where we fork network at latest block call off chain APIs, for example, one inch and some other bridge build transaction call data based on both of the two last APIs calls and the other parameters. So is there a way of integrating off chain stuff into a call?
00:40:48.610 - 00:41:54.980, Speaker B: Yeah, I mean, in this case, honestly, it's probably going to be a bit more hacky than what you do if you have a JavaScript based library. But there are, as I said before, there are a lot of cheat codes to interact with both the file system and the console. So you can run any arbitrary command in your Cli, in your terminal, basically. And then what you can also do is read in any JSON data. For example, there's a cheat code to read in a JSON file from the file system. And so what you could do is you could run, I don't know, the curl command to call an API and then save the resulting payload on your file system. And then you can use another cheat code to read in that file and even get like a specific JSON object or JSON parameter out of it.
00:41:54.980 - 00:42:51.560, Speaker B: But yeah, it's definitely a bit more hacky than what you'd be doing in JavaScript. And of course it still has some limitations because you are still in solidity. So anything you save in a variable has to be of some solidity type. So there's kind of a limit of, it can be a bit hacky regarding that. But for example, if you want to use an aggregator API that might return some call data, you should be able to do that using this kind of workaround and then just reading in the call data from the file system and doing that. Very good question, and something that I've also sometimes struggled with. Great question.
00:42:51.560 - 00:43:56.438, Speaker B: Any other questions? Right, okay then, yeah, let's go next to a little bit more like advanced testing. So, looking at two features here that you normally don't find in your standard hardhead test toolkit, although you might be able to implement them there, but as far as I know they don't come out of the box, whereas in solidity they do, and they're really quite powerful and quite performant. And those are fuzzing and invariant tests. And both of you allow you really to take your testing to the next level in terms of the amount of tests you run. So you really get a lot of extra testing power for just some very minor changes in your testing code. And so the first one is fuzzing. And what this will do is it will run your test over a large set of different inputs.
00:43:56.438 - 00:44:55.446, Speaker B: So what you do here is you just add one or more argument to your test function and then forge will randomize inputs. It will generate a lot of random inputs for that argument or for multiple arguments, and it will run your test for every single random input. And if any of those fails, then the test will fail, and it will show you what the input was for which it failed. So here we're doing a very simple test where we're just using the set number function and we're subtracting one from it. So here we're quite obviously going to get an error if we run this test with a number zero, because it'll be an underflow. And this is what Ford shows us below as well. So you have to kind of learn how to read some of these messages.
00:44:55.446 - 00:45:24.230, Speaker B: But if you look at the green sticker, you'll see that it shows you the arguments for which it failed. And in this case, it found it very quickly. So it ran only ten times. But, yeah, again, it's very fast, and you can configure the number of random numbers that it tests. So number of runs basically for your function. So you can have thousands or even tens of thousands of iterations with different random values. And so you can really get a lot of coverage.
00:45:24.230 - 00:46:03.090, Speaker B: They're not 100% random. If you think about this. Like, there are two to the 256 different un. So it's quite a coincidence that this test found the value zero. But, yeah, I think it probably checks the ranges of the values first and then does the random numbers afterwards or something like this. But, yeah, if your number is zero, it will always find this very quickly. But, yeah, in most cases, it's still random, and that's fuzzing.
00:46:03.090 - 00:47:15.062, Speaker B: The second one is invariant testing. And invariant testing is in some ways even more powerful. And you have to do even less, and you get even more testing, because all you have to do in invariant testing is you define an invariant, an expectation in your test, and then forge will try to run all kinds of different calls against your contract to try to break your invariant. So it will call all kinds of different functions from different senders with different values, everything again randomized until it finds a combination of calls that leads to there being any reversion in that test. So here in this example, the invariant is basically that the number should always be even of our counter, which is obviously not the case. And forge found a way to break it. So basically, it first set the number to zero, and then in the second call, it set the number to one, and at that point, it wasn't even anymore.
00:47:15.062 - 00:48:02.134, Speaker B: And it shows you here the whole set of calls. It is. You can also see that it called both functions from different senders. So it randomizes really kind of every aspect of it and can be very powerful. Sometimes in these cases, you want to kind of guide it a little bit to maybe only call specific functions. So maybe you have a test where, for example, if you have a contract that has tens of different functions, of course, the number of random runs that foundry will do and the kind of scenarios it will try is limited. Again, it's something you can configure.
00:48:02.134 - 00:49:06.270, Speaker B: But so sometimes if you want to really get the best out of it, and you already know that there's only, like, certain kind of functions that make sense to be called in that scenario, then you can tell foundry to only call these functions or these contracts. So by default, it will try any function on any of the contracts that you defined in your test or in your setup function. But you can really have very fine grained control. So in this example, we're telling foundry basically to only call the increment and decrement functions on the counter contract. And, yeah, there's a little bit of boilerplate here. You have to use this fast selector struct, which is defined by foundry, and then this target selector function, all this. But, yeah, this is really just what it does, is limiting the kind of scenarios that foundry will try out when doing this invariant testing.
00:49:06.270 - 00:49:49.052, Speaker B: And so, yeah, you can have really fine grained control and very advanced scenarios with this. You can have multiple contracts that it's allowed to call if you're testing a whole system. And, yeah, again, it's a very powerful feature. And, yeah, this is kind of a little bit of a view on some of these advanced testing features. Are there any questions regarding fast testing or invariant testing? All right, I guess not. Okay.
00:49:49.106 - 00:49:52.350, Speaker A: Yeah, everything you're saying is obviously very clear.
00:49:53.200 - 00:50:02.224, Speaker B: All right, thank you. Yeah. All right, there will be a quiz at the end. Not. Just kidding. Okay. Yeah.
00:50:02.224 - 00:50:55.120, Speaker B: So, so far about testing. Again, normally, testing is what people talk mostly about when talking about foundry in forge. But I also want to show a little bit about the features that are often a bit underrepresented or underrated, in my opinion of forge. And so another tool that you have when using forge, apart from testing, is also scripting. So scripting scripts are basically things like programs that usually you're not just doing a test, but you actually want to submit some transaction to the blockchain. So often this can be a deployment script, it can be some kind of configuration script, all that kind of stuff. But yeah, the difference to a test is really that you're actually submitting transactions to the blockchain.
00:50:55.120 - 00:51:49.460, Speaker B: And forge has, I think, really a really good implementation of this. Again, it's completely in solidity, as we'll see in a moment. So the scripts are written in solidity and it really has some advantages. And one really big advantage is that what it does is it simulates your whole script on a local EVM before broadcasting any transactions. So what that means is, let's say you have a script with ten different calls before it sends out anything to the mempool. It creates a local evm fork of the blockchain. It runs your whole script and sees that no calls revert, that you don't run out of gas, all that kind of stuff.
00:51:49.460 - 00:52:56.532, Speaker B: And only once it ran through the whole simulation, it starts broadcasting the transactions one by one. And this protects you from something that I have experienced sometimes in the past, is where you have a script, and then in the middle of the script, I don't know, something goes wrong, you run out of gas, a call reverts, anything, and then you're in this weird state where your script ran halfway through and you have to do all kinds of gymnastics to recover from that. And I don't think this has ever really happened, or very rarely in foundry, because it has this kind of really killer feature, in my opinion. And then it also has a really good management of output files. So it keeps a lot of logs about all the transactions that you ran with which call data. And so it's really nice you can look through these files afterwards to see what you did. And yeah, this is an example of the script.
00:52:56.532 - 00:53:45.956, Speaker B: Again, it's our counterexample, it's just a deployment script. So what we're doing here is we're going to deploy our counter contract and then we're just going to set the number. And one important thing is, so there's a few things you have to do. Instead of the test contract, you inherit from the script contract. And instead of calling your function test, whatever, you just call it run, and then this would be run as a script. And there's another thing to be mindful of, is that by default, even in scripts, everything is just simulated. So if you want to have certain calls or certain actions actually be submitted to the transaction, to the mempool, you have to wrap them in these start and stop broadcast function calls.
00:53:45.956 - 00:54:36.916, Speaker B: So here the only things we're going to submit two transactions. One is the deployment of the counter contract, and the other one is the set number call further down. And everything else is just simulated. In this case, everything else is just a static call anyway. But this setup allows you to really have inside of your script, you can have really sophisticated tests, so you can deploy something, and then you can run a couple of test transactions, or what would be transactions normally, to make sure that your contract actually works as you expected. And this will be included in this simulation step that I mentioned earlier. So if any of these tests fail during the simulation of your script, nothing will be submitted.
00:54:36.916 - 00:55:39.896, Speaker B: So you can really have a lot more certainty and a lot of extra testing built into your scripts, which is really great and makes this really powerful again. Also, you can have assertions here, like the script contract gives you a lot of the, you have access to a lot of the functions that we saw earlier during tests. So you can also do kind of all kinds of complex tests in your script combined. And then once you're happy with your script, you can run it with the Ford script command. Again, you have all kinds of flags, parameters that you can set. One very important one is that even when you have marked certain transactions to be broadcasted, you have to in addition, add this broadcast flag to your Forge script command. Otherwise, again, Forge will only simulate.
00:55:39.896 - 00:56:23.708, Speaker B: So forge is always trying to protect you here and always defaults to just simulating stuff. And you have to tell it specifically in multiple places that you actually want to have something executed against the real chain. But this is also a nice feature. So even when you have a script, you can run it first without the broadcast flag to kind of make extra sure that everything works and the outputs look like you expect. And then you run it again with this flag to actually execute the transactions. And then below we see kind of the output, you see the results of this simulation that I mentioned. So it tells you in advance how much gas you are probably going to spend.
00:56:23.708 - 00:57:03.690, Speaker B: And then after the transaction, it sends out one transaction after the other, and it waits for it to be mined and everything. And it's really good. Also, the nons management is really good. So I said that it waits, but it works really well. So you never have any issues with nons too low or some of this stuff that you sometimes can have in other tool sets. And yeah, this is forge scripting, which I also use a lot. And yeah, concludes my talk for today.
00:57:03.690 - 00:57:53.512, Speaker B: Again, this was meant as a bit of an appetizer of showing how amazing this toolkit is. It's got a lot more functions than I've shown today and a lot more that could fit in one talk. So there are amazing resources out there. The canonical resource to learn anything about foundry is the book, which you can find that at URL, which is like a really complete documentation with tutorials and everything. So technically it's really all you need to learn, but then they're also included bit more content in other formats. One thing I really liked is this smart contract programmer foundry playlist. So he did a really good, it's a YouTube channel.
00:57:53.512 - 00:58:21.404, Speaker B: He did a really complete foundry course, much more than I covered here, but divided into like small bite sized videos. So it's a great resource. And then also a couple of reposts that you can look at. One really interesting is this hardhead foundry template. So you might be thinking, oh, foundry sounds great, but I have a huge hardhead project and I don't have the time to rewrite everything in foundry. No problem. It's got you covered.
00:58:21.404 - 00:58:44.760, Speaker B: You can use those tools side by side. You need to do a little bit of configuration, but it's really not too bad. And you can find it all in that template and yeah, with that. Thank you very much. And yeah, if you have any more questions, I'm happy to take more of those. Otherwise I'll return it back to Peter.
00:58:45.900 - 00:59:04.408, Speaker A: Hey, Christian, I did have a question, actually. So you talked a lot about testing and fuzzing sort of dynamic techniques. I'm wondering, is there any interest in doing any kind of static analysis using forge, sort of more static or compile time techniques?
00:59:04.504 - 00:59:30.644, Speaker B: Yeah, so there is a linter. I forgot what the command is, but they do have a built in linter. I'm not sure how much static analysis it does. It definitely does. Looks for decent formatting and syntax. I think it has also some best practices coded into it. But yeah, I forgot the name.
00:59:30.644 - 00:59:37.064, Speaker B: I think it's something like forge lint or something like this. But yeah, there's a linter for some statical analysis as well. Okay.
00:59:37.102 - 00:59:46.570, Speaker A: Yeah, it seems like sort of static analysis is kind of the next step from your sort of invariant testing, basically to start looking at some other properties there.
00:59:48.000 - 01:00:22.010, Speaker B: There's also something else. I think it's. Is it formal verification? I forgot actually that next step beyond invariant testing is something where it actually analyzes the whole tree of possible program states. Probably Peter knows what it's called and it does like a formal analysis of whether there's any case in your test that will break it. But I think it's not yet implemented in Forge. I think they're working on.
01:00:25.820 - 01:00:54.080, Speaker A: David. David knows an awful lot about that. I guess that's what my interest is. Right. But yeah, look, I mean, having run slither recently in a project, it would be good if they had, I don't know, a version of slither that doesn't essentially core dump integrated into forge because slither itself. I don't know, maybe it's just the configuration I'm running or something. But golly, it's unreliable.
01:00:54.080 - 01:01:44.210, Speaker A: Just as a tool just seems to randomly say, well, just because you can compile the code. I can't compile the code. You're going. But why? Anyway, so one question I had was, so we've got the Forge script command and we're presenting a private key which is stored in an environment variable and say if your contract is going to be protecting a billion dollars, you really don't want to be doing that. You want that private key to be in hardware security module or AWS key manager or something. Is there a way of using a key that's in HSM or AWS key manager or something like that?
01:01:44.820 - 01:01:59.520, Speaker B: I don't know. I haven't tried this. There might be, if not, there might be a pr or an issue on this. But I don't know. So far I haven't used any of these integrations. I'm not sure if there's an integration.
01:01:59.680 - 01:02:32.720, Speaker A: Yeah, because it looks like a really great idea where essentially you're forking the current chain, you say, run your upgrade script, checking that everything's working okay, and then assuming everything's working okay, then you go and you actually do the deployment. But yeah, then you want to be deploying that from the real private key, which is a big. Yeah. Devendran asked, is there any plan to extend foundry or forge to non EVM chains?
01:02:35.540 - 01:03:21.516, Speaker B: Not that I know of. Maybe something I should mention is, as I said before, they have a really great open source community. They have a telegram channel, they have a whole bunch of issues and a lot of also documentation on their GitHub of what they are planning as next features. I haven't read anything about non EVM chains, but yeah, that might be, but it is based on something called ReVM, which is a rust implementation of the EVM, which makes it really fast and which is at the core of foundry. So yeah, if they are planning to do this, I think it would be a very big effort and probably a more or less complete rewrite of the whole library. But who knows?
01:03:21.708 - 01:03:52.744, Speaker A: Yeah, I think there's enough momentum around EVM that I think non EVM environments will end up being EVM environments. Who knows, maybe the others will survive. Let me go through this. So thank you for your talk, by the way. That was amazing. So it was very well done. Very much appreciated the virtual clapping, but yeah, let's go through this.
01:03:52.744 - 01:04:32.236, Speaker A: So the merch store is open and I think I've sold it somewhere between 51 hundred t shirts. So yes, now's the time. There is always a time. And I am going to produce an Ethereum research t shirt. I have an idea now, so I'll get around to doing that. Next slide, please. Okay, so next week, golly, next week Clemens is going to come along and tell us his thoughts on AI and web three.
01:04:32.236 - 01:05:49.200, Speaker A: So Clemens is a deep thinker at consensus. And so I'm sure that will be very interesting. I'm going to talk about the passport wallet and the immutable zkevm. So I'm going to talk about a new web three wallet that we've got at immutable and convince you all that not only is it really easy to use, great if you've got a game, and so non intrusive, even when you're playing a web three game or a game, because aren't all games web three these days, or going to be? So anyway, it's telling you all about passport and broadly about the immutable ZKVM and how that works. There is a talk that is very tentatively planned for two weeks after that, but I haven't got it there yet, and I'll just wait for it to be locked in. Then I'm going to talk about some ERC 20 bridge improvements. So I've been looking at these large hacks and thinking about, well, for immutable, what can we do to make our bridges not so hackable as these other projects? And so the bridge improvements that I've come up with are readily applicable to any ecosystem.
01:05:49.200 - 01:06:26.096, Speaker A: So this will apply to anyone who's running an ERC 20 bridge for a roll up a side chain. So an l one l two l three in any configuration. So I think certainly worth coming along to. Tim Bico from Ethereum foundation is going to give an overview of Ethereum governance. And so that is all about how Ethereum as a group makes decisions. So I think that should be very interesting. And we're going to end the year with me doing a solidity interview challenge.
01:06:26.096 - 01:07:15.620, Speaker A: And so this will be another interactive session. Please bring your remix or favorite ide and we'll try and together work out a problem. And if we don't have lots of interactivity, I'll probably rope in people like Sandra, David and Joanne and anyone else who I think won't mind too much if I ask them a tricky question on the. And Christian, can you move to the next slide, please? Just one more slide? Yes. Ok, so if you're here today, there is a YouTube channel that you can watch the recording on. There is a slack workspace. There's also, if you're watching this on YouTube, you can join live and ask the tricky questions live.
01:07:15.620 - 01:07:49.740, Speaker A: Sometimes there is example code and that'll be on that repo. And is the formal methods reading group still happening, David, I wonder, should I. No. All right, so scrub that formal methods reading group. Yeah, I will have to get around to removing that from my final. So thank you again, Christian, that was really awesome and thank you for your time producing that. I know that would have been a lot of effort and, yeah, very much appreciated.
01:07:50.560 - 01:07:55.144, Speaker B: Thank you. I have a question. The merch store, is it shipping globally or only?
01:07:55.282 - 01:08:35.452, Speaker A: Yeah, absolutely globally. And I searched out different merch store possibilities. And this company that I've partnering with, they do global manufacturing. So there's manufacturing in Australia, in the US and Europe. So if you're in any of those places, the shipping costs and the time to delivery is generally pretty good. I have no idea. I've never said I live in Thailand and found out what the shipping costs are to Thailand, so I'm not sure.
01:08:35.452 - 01:09:11.730, Speaker A: But of all the companies I considered, this is the company most likely to, say, set up t shirt manufacturing or partner with a manufacturer in your country and hence have global low cost merch. I think it really works well. So yeah, global shipping and hopefully low cost and low time to delivery. All right, so thank you, everyone. Have a great rest of your day and thank you again, Christian.
01:09:12.550 - 01:09:16.670, Speaker B: Thank you for having me. Bye, everyone. Bye.
