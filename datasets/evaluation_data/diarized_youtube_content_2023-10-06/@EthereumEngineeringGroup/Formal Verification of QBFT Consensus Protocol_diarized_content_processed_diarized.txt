00:00:01.210 - 00:00:18.720, Speaker A: Hello and welcome everyone. I'm Peter Robinson, and today Roberto Saltini is going to talk about Qbft and the formal analysis of that protocol. So, before you start presenting your slides and telling us all about it, roberto, why don't you introduce yourself?
00:00:19.570 - 00:00:56.510, Speaker B: Thank you, Peter. Yeah, so, my name is Roberto and I work for Consensus. I've been in consensus for over three and a half years and my main job consensus I'm part of the R D team and I work in the dependable distributed assistant team where, as you can get from the name we work on making sure that distributed protocol, that we develop a consensus and implement dependence applying by techniques, including design and as you'll see shortly, also formal verification.
00:01:00.610 - 00:01:12.518, Speaker A: All right, thank you. Please share your slideshow.
00:01:12.634 - 00:02:16.920, Speaker B: All right, can you see the slides? All right, so today talk will be about the formal verification effort of the safety properties of the QBT consensus protocol that we've been carrying out. The agenda will briefly introduce what Qbft is. We'll go over why formal verification, why did you have to do that? We'll then have a more detailed look on how we applied formal specification verification techniques to Dbft. We'll also hopefully have time to have a look at Daphne code and we'll speak about current capture work. If you have time, we'll have a glance at the GitHub repo with the code concluding with key takeaways and Q A. If you have burning questions like things that are unclear, please feel free to ask. If there are kind of overarching questions, might be better to leave them for the Q A.
00:02:16.920 - 00:03:17.866, Speaker B: Okay, so before starting, I want to clarify the objective of this talk. It provides key insights on what formal specification verification is, on the value of formal specification verification, and key insights on how we have applied these techniques to the Qbft consensus. Now, we can start with what is Qbft? Well, Qbft is a blockchain consensus protocol, which is Byzantine, fault tolerant, nor randomized as a dynamic validator set and is suitable for eventually synchronous network. The design is not mine. The code design of the protocol is by Henrik Monit, and here is the paper that describes. So, we look at all these terms. So, BFT blockchain consensus protocol, what is it? Well, BFT Blockchain consensus protocol is a protocol that ensures three properties can ensure more than one.
00:03:17.866 - 00:04:16.874, Speaker B: But list these consistency, meaning that the blockchains of any honest nodes are one that prefix of the other stability, meaning that the blockchain of any honest node grows in appendion only fashion aliveness, which says that any transaction submitted to the system will eventually be included in the blockchain of all honest nodes. And all of this must work. All of these properties must be ensured despite a fraction of the nodes potentially being Byzantine, which means that they can collude to attack the system. They cannot follow the protocol and send different type of messages just as a note the maximum theoretical presenter resilience is less than one third of a node and you can see in the table. So for four nodes maximum one to seven, we go up to two. So this is what the PFT blockchain consensus protocol is. We said that the Qbft is suitable for eventually synchronous network.
00:04:16.874 - 00:05:05.900, Speaker B: So an eventually synchronous network is a model of a network where we have a value JST which is finite, but you don't know what the value is. Before JST, messages might be lost, can be delivered in any amount of time. After GST, any message that is sent is delivered within a delta time. And again delta is finite, but we don't know. Qvft is randomized, meaning that decisions are not based on contouring or random values and it has a dynamic validator set. So the validator set is a set of nodes that are allowed to propose new blocks and are responsible for deciding which block to add to the blockchain and nodes can be added to remove from the validator set. Thank you.
00:05:05.900 - 00:06:20.454, Speaker B: So just a quick look on how the consistent agreement works. Basically, initially all the nodes start from the genesis block and they agree on the next block, on the next block, and so on and so forth. And the property described in the paper by enrich it describes how the node reach agreement on one block and with tbft we have basically extended it to clearly define how this appending of blocks works and also done the formal specification. So a quick look at how the agreement protocol works, just to give you an idea. So there are four type of messages proposal prepare and commit and around change. So just a second, I want to use the laser point, okay? Proposal prepare and commit around change. It is organizing rounds and we have a block proposal which sends a proposal message to everybody.
00:06:20.454 - 00:07:32.746, Speaker B: When you receive a proposal message sent by the proposal, you send prepare, then you send them to, you broadcast them to everybody. When a prepared message is received, then if it matches the proposal, you send a commit, you decide if you receive commit messages from two third of the nodes matching commit messages. If this doesn't happen within before the round timer expires, there is a round change phase where a new proposal is selected and then again the same pattern and eventually an order receives enough commit messages before around time expires and the block is created. So that's just a quick overview, just to give you an idea. And in terms of dynamic validator set, this is simply implemented by having a function that maps a blockchain to a set of validator. And for example, this is done by the next validators function. And when applied to block I zero defines the validator set for block B one.
00:07:32.746 - 00:08:24.902, Speaker B: When applied to chain headed by block B one will map to the validator set for block B two and so on and so forth. So that gives just an overview of Qbft. This is not the topic of the talk. This is how we apply formal verification to Qbft. Having an idea of how the protocol works will help in I think getting better feeling of the technique. So start with a burning question. Well, why formal verification? So what can go wrong? Can go wrong is that for example, if you take the paper that I mentioned, the specification is a mix of natural language and pseudocode and it's ambiguous because it comes from natural language, it's inherently ambiguous.
00:08:24.902 - 00:09:28.574, Speaker B: But pseudocode also doesn't have a clear semantic what is the consequence of this is that well, to start with, implementers interpretation might be different from the intended design that was in the mind of the protocol designer and this is already a problem. So they may implement something that's not what the protocol designer intended and there is no way that mathematical reasoning can be applied. This means that all that you are left with is testing. But can actually the question is can all the possible scenarios be tested? So just go back to the protocol. Again, as you can see, there is a lot of message exchanges and as I said before, it's an eventually asynchronous network and some messages can be delivered in any sequence. Now you can imagine that if you want to test all the scenarios you should consider all the possible sequences and also the number of nodes is variable. So you should consider all of these various scenario.
00:09:28.574 - 00:10:36.786, Speaker B: Any change is a change in scenario. So the answer is that actually scenarios in this type of system are usually infinite. Especially if you consider that a message delivered in a given time will add a scenario different from message delivered just in a fraction of a second later or before. And often this scenario also will be of infinite length because you have to prove that something eventually happened. But there is no necessarily bound when this happens. And even if the scenario is well finite, I can actually one be sure that all the test cases cover all the so how can we help? So some talkable examples before explaining what we can do, how things didn't go well. So IBFT is an example wasn't formally specified and there were issues identified where forking was possible, where block production could get stuck.
00:10:36.786 - 00:11:56.560, Speaker B: And also another protocol like Ziziba, which was described in academic paper, actually in a very regarded conference, also won the best paper award at that conference. And it has been found that actually agreement could be violated and there is no guarantee that decision could be reached. And again, what described in paper wasn't formally specified or verified. So this is a demonstration that things can go badly and I want to recall that we are dealing with blockchain system transact money value and so when something goes wrong is a big deal, there might be big consequences. So how we can help. Well, with formal specification, we have a specification that is unambiguous and provides a mathematical definition of the possible behaviors. This means that the implementer's interpretation matches the protocol design intended, the protocol designer intended design that there is no ambiguity and also because it's defined in a mathematical way, then mathematical reasoning is possible.
00:11:56.560 - 00:13:14.458, Speaker B: Meaning that we can prove things, we can prove the absence of bad states also can prove that good things will eventually happen. Substance of bad state is that for example, there are never conflicting blockchains the good things will eventually happen, we can prove that for example transaction will eventually be finalized. So this mathematical proof is basically the formal verification bit. The absence of best aid is what is known as safety property and the fact that good things will eventually happen is what is normally known as liveness property. So now that we have hopefully explained why the why of the formal verification effort, we can take a look at how we apply the technique initially to build a formal specification of Qbfts. As I mentioned before, this is the first stepping stone as you need something unambiguous and mathematically defined in order to be able to apply formal verification to it. So the way the behavior of Qbft node in this case is specified is as a state transition system.
00:13:14.458 - 00:14:07.580, Speaker B: A state transition system. You have a set of states, you have some states. In this case, this specific case, the blue state is the only possible initial state. So that's when the system starts in the blue state and we have transitions, for example in what is depicted here, we have a transition from the yellow state to the green state when message pink is received. And as consequence of this transition, aside from changing state, there is a set of messages that are also sent by the node. So for example, message punk is sent to node n one and node n two. And as you can see, we can see in the next slide by the system, the node in this case, this is the description of a single node, not the system.
00:14:07.580 - 00:15:23.618, Speaker B: Its system evolves on, messages are received, it changes state sends messages, a new message is received and so on and so forth. And what I want to show explain in this slide is that the state what I mentioned in here by state is normally some combination of variables of values, integral, current height, current round, whatever is needed by the specification in order to whatever the person writing the specification thinks that you need in order to define the actual behavior. That is interesting from a specification point of view. What I'm trying to say is that not all of the variables that are in these states are really important. So the current state is not really part of the specification. For example, it's part of how we build the specification, how we build the transition system. So through state hiding we can come to what really the specification is about.
00:15:23.618 - 00:16:49.550, Speaker B: For example in the case of Qbft, it's about having external behavior. So which messages are sent, when a message is received and how the blockchain is progressively built over time. So basically we can exclude some of the variables from the state and say well, this is the specification that must be fault. It doesn't matter if in the actual if you have an implementation where you have additional variables this is what we are prescribing. Another important thing to note is that the specification can be nondeterministic, meaning that from a state you can transition to two different states on the reception of the same message pink. And for each of the two different states, in this case green and purple, you may have a different set of messages that you send to a different set of notes. And as we'll see this specifically the case for example for Qpft, this can be because in some cases you need to select a set of messages of given size and a subset of messages a given size and it doesn't matter which messages you choose as long as the subset matches given characteristics.
00:16:49.550 - 00:18:05.560, Speaker B: Now, how do we provide a mathematical definition of this transition? Well, what we do, we define a function from the source state. This destination state received messages and output messages to a boolean. And the idea here is that if you evaluate the function for example on source received message, destination state and output message if it evaluates to true, then it means that that transition from the source state to the destination state when received message is seed sending output message is valid. Is a transition that can be taken. If it's evaluated force, it means that it's a transition that cannot be taken. When I say this, I want to point out that in a scenario like this one on the left hand side, where the yellow state can transition to the green or the purple, if a message m min is received the state must transition to one of the two. It can transition to one of the two, but it must transition to one of the two.
00:18:05.560 - 00:19:29.598, Speaker B: So just give you an example which is specifically to the picture to the top left hand side if you validate it next on a yellow messaging and green and green state and green set of messages this evolve to true as it's part of the transition. If you validate it with the destination state which is the blue state and the set of messages to be sent which is the blue it will evaluate to false in this specific case because this transition is not part of the specification. So the way by looking at how we can define this function is essentially a disjunction of conjunction. So basically you can see, you can basically say okay, this evaluates to true if the source state is yellow, received message is min destination state is green, the set of output messages to be sent is green. Or again if the source state is yellow, received message is min, destination state is purple, the output message is purple and so on and so forth. So you can potentially know one way will be to enumerator of this. Now, if the set of state is infinite, you can also use universal quantifier to express this predicate.
00:19:29.598 - 00:20:22.690, Speaker B: But that's the idea. That's a mathematical description of the transition. What Evan mentioned is about the initial state. Well, the idea is the same. We can define the set of possible initial states by a membership twin function in it, which takes a state evaluates to a Boolean evaluates to true if the state is one of the possible initial states or it evaluates to false if the state is not one of the possible initial states. And this way we have a mathematical definition of how a node transition through different states and which messages are sent when given messages are seen. So this kind of concludes how we specify again the behavior of a single node.
00:20:22.690 - 00:21:26.226, Speaker B: Now, what we want to do, we actually want to verify in this case I will speak about the formal verification of the consistency property. Only we want to verify. What we want to verify is that in a system of interconnected nodes implementing the Qbft protocol where less than one third of the nodes are present time, it is always true that the blockchains of any two honest nodes are one that per fix of the other. Now, what we have defined so far is Qbft protocol which are the transitions that a Qbft node must go through. We know that to prove this property there are things that we haven't defined yet. So what we haven't modeled yet is Byzantine behavior. What does it mean? We haven't modeled yet the network? What does it mean or how are these nodes interconnected? So, in order to model a Byzantine behavior we can be done in a similar fashion to how the behavior of a harness node has been described.
00:21:26.226 - 00:22:10.150, Speaker B: And just to give you an idea, we need to say what a Byzantine node can do. So a Byzantine node on a transition can send any number of non signed messages. It's not a problem. It can send signed messages that are signed by one of the by nodes. No necessary itself can collude with other nodes. So if I'm Byzantine, it's missable that I send a message signed by another Byzantine node can also duplicate messages. So in this case it means that the Byzantine node can actually send a message M signed by an honest node as long as message M together with the signature had been previously received by the Byzantine node.
00:22:10.150 - 00:22:59.890, Speaker B: Now, what a Byzantine node cannot do anything else there's? Anything else that we cannot say, we don't say it does. For example, it cannot force the signature of an honest Qbft node and it cannot modify the state of an honest Qbft. Now let's look at the other missing bit, which is the network model. Now we have a choice of different network models. As I said, the Qbft is designed for eventually synchronous network. But as I'll explain shortly we consider in this case a synchronous network. So in the asynchronous network model what the model? The property is that deliver only messages that have been privileged sent by one of the nodes.
00:22:59.890 - 00:23:56.514, Speaker B: So for example, the network doesn't generate new messages out of the blue and in the case of an eventually synchronous network, the same property but also must guarantee eventually synchrony after GFT any message is delivered with data type. Now, for the formal verification of consistency we use a synchronous network model. This is because it's more general. So if Qbft guarantees consistency on a synchronous network, then it also guarantees consistency on eventually synchronous networks. And also Qbst must ensure actually consistency even in a synchronous network. It's when you actually want to prove the liveness that you need to use a stronger assumption which is eventually synchronous network. Now we are ready to put all of this slide.
00:23:56.514 - 00:25:32.918, Speaker B: Okay, so how do we specify the transition system for the network? So on the top right hand side you see the kind of transition for the Qbft node. The transition system for that is kind of opposite. It transition on messages sent by Qbft nodes and what it outputs are the messages must be received, that is to be received by one of the Qbft node, in this case n one. So putting all of this together, we can finally come to the model for the distributed system where in this case we have four nodes and the network and we transition from the kind of distributed system level green state to the distributed system level blue state. And this transition can occur if and only if the transition system for this node and for the network are as highlighted here. So this distributed system level transition is valid only if in the specification of the node we say that a node can transition from the yellow state to the green state. There is an error, sorry, the state on the right hand side here should be green on the top in the blue state.
00:25:32.918 - 00:27:07.770, Speaker B: So this can only happen if in the specification of the Qbft node we say that it's possible to transition from a yellow state to a green state and send the Qbft prime messages when a Qbft main message is received. And for the network model we say it's possible to transition from a purple state to a red state when the set of Qbft ML prime message is sent and the messages that are received and then Nqbft mean is received by n one. So basically the two things are kind of swapped around as what is the input for one is the output for the other. Now 1 may ask so if actions have actually only messages received, how is the first message going to be transmitted? Well, what I present is a bit of a simplification. We could have modeled the environment having external messages coming in. But another way to think is that one could think to have an actor initial state to have kind of preloaded infinite or infinite set of input transactions or messages that then can deliver. So for the mathematical definition of the distributor system is basically the same as the Dr at least is the same as for the node.
00:27:07.770 - 00:28:51.560, Speaker B: So we have a predicate distributed system in it, which is a membership function for which states are the possible initial states. And then we have a transition relation function dsNet, which is again a predicate between two states which evaluates to true if the transition between the two state is possible. And the way this is derived is by composing through logical operator the functions that define the transition system for the node and the network and the Byzantine. Okay, now we have defined what we hadn't defined yet, and also we are hopefully ready to prove the consistency properly. So what do we want to prove? What we want to prove is that in any reachable state, in any reachable distributed system state S, where the following predicate is true and the predicate C says that the blockchain of any true honest node states in S are one the prefix of the other. So to put it in picture, what you want is basically if you take this as kind of a possible evolution of the system, where here for example, from state S one I can go directly to the right or to the bottom in any of this state, the predicate C must evaluate to true. If this is the case, then it means that consistency is always verified, is always satisfied in the system.
00:28:51.560 - 00:30:20.594, Speaker B: Now, how can we proceed improving consistency? To do this, I need to introduce the concept of inductive invariant. So C is an invariant if it's verified to be so, that is true in any state. An inductive invariant is stronger than invariant. For an indi predicate is an inductive invariant of the distributed system if and only if it is true for any initial state, which is the first point here and which is depicted by picture. If we assume that int I is true for a given state as any, and that the transition of from S to S prime is a valid transition as described at the specification, then we prove that the evaluation of ind I on the destination state is also true. So if we can find predicate in the I specifies these two condition, this is an inductive invariant and we can then prove that the inductive invariant is true in any state, any reachable state at least. So specifically for our purpose of proving consistency, we want to find inductive indice such that if in I is true in a state, then consistency is also true.
00:30:20.594 - 00:31:58.590, Speaker B: So in this way, through this by induction, we can conclude that the inductive variant is true in any state. And because we have this implication at the bottom, consistency is also true in any state, in any reachable state. So just how have we proceeded to prove consistency? Well, we kind of try to break down the task by leveraging a bit on this modularity that we built in the specification. We try to identify inductive invariant that are concerning only the node state evolution, inductive variance that concerning only the network state evolution. And then we have leverage on the inductive variance, identify the point before to then identify distribute the system inducting variant inducting invariant that implies consistency. So before I wiggle just a sketch of the set of invariants, I just want to remind the protocol we have propose or prepare and commit around change messages the message broadcast. The idea is that a block is created once you receive two third of the basically when two thirds of the node send matching commit messages, which is usually called a quorum in this type of protocols.
00:31:58.590 - 00:32:52.750, Speaker B: So let's start looking at these inductive variants that are not. All this is just to give an idea a flavor of how kind of one can progress in improving the inductive variance that you need for consistency. So for example, at the novel level we can prove that honest qbft node does not send two complete prepared messages. Basically any two prepared messages that have the same round and height, they have the same block, therefore the same block they include the same block. An honest node similarly cannot send two conflicting commit messages. And there's an honest node, an honest q 50 node sensor. Prepare a commit message for round height and block B only if it has previously accepted a proposal message for that round height and block.
00:32:52.750 - 00:33:56.082, Speaker B: And we'll have a slide here on this one later explain how we can actually have an invariant on something that done before for inductive invariance at the network level. If a message m is delivered to node nivarian says that node n prime had privileged sent a message m to node n. So this because the duplication can happen of the messages can happen at the adversary presenter level, but in our model, not at the network level. And then we can build our distributed system inducting variance. So, for example, start with the first. If you have two sets, x and Y of size matching to throw the number of the nodes. Or prepare messages for a given round and height such that all the messages in X are for block B and all message in Y are for block B prime, then the two messages must be the same.
00:33:56.082 - 00:35:11.900, Speaker B: Basically, if you have this quorum of prepared messages for the same height around they are for the same block, you cannot have two conflicting quorum for pair messages .2 the same for commit messages. Then by leveraging on these two invariants we can show that if you have B and B prime that are any two valid blocks for the same height around sent by any node, not any node, then the blocks are the same. In this case therefore the same height around. What we want to do then next is to prove that any two block B and B prime for the same height are identical. And that's the purpose of the following point. We start by assuming that you have any valid block for height height and round l center for height around and B prime to be the block including any proposal message for the following round in same height then accepted by an honest node, then the two blocks must be the same.
00:35:11.900 - 00:36:28.610, Speaker B: Then we proceed with zero five. So, if you have BB any value block for a given height around sent by a node and then this implies that at least two thirds of the honest nodes have accepted the proposal message for round RHM block B. By putting this together and some other few other properties that I will mention here, we can conclude number six, which is that let B be any valid block for a height H round R sent by any node, and assume that the block including the valid proposal message for the same height F for a round higher than R is equal to B. Then we can prove that any valid block B prime for the same height and round successive to F prime is such that B max is B prime. By induction, we can then prove that any two value blocks for a given height are identical. Then by induction again the length of the blockchain, we can prove that blockchains of any two S nodes are one the prefix of the other. This is just to give an idea of how we progress.
00:36:28.610 - 00:37:34.354, Speaker B: So I mentioned before that one of these inductive invariants on the Qbft node says that if an honest Qbft node sends a prepare commit message for round height and block, then it has privilege accepted the proposal message for that rounded height and block. So how can we do this? We basically said before an invariant is operated on a single state, it's not on two different states, not something that happened before. Well, what you've done is to basically create an instrumental spec. So we augmented the state in this case with history variables where we can track, we can keep track of things. For example, when a proposal is accepted, proposal accepted actually means that you send a prepared message matching the proposal message that you received. You augment the transition system by adding that proposal to the set of all accepted proposal and similar for example, you can also keep track of all the messages that have been sent. This is just an augmentation of state.
00:37:34.354 - 00:38:48.560, Speaker B: So there's a really impact and. In the formal verification actually proven that it doesn't impact the property that are proven so this hopefully has given an idea of how we progressed on specifying and verifying consistency for Qbft now we can look at the language and tool that we've used which is Daphne so why Daphne? Well, it is directly possible to prove everything by hand. But it's a mathematical description. So we can by hand prove all the inference rules and follow all the inference rules improve everything. But that opens up for human errors. In the proof so we can mitigate reduce the risk a lot by using tools and languages that allow to mathematically check the proof and this is the case for example, for Daphne but there are other tools so just to give you I don't have the space to compare Daphne with other tools. I just want to give you a quick review of pros like we chose it in this case and potential cons.
00:38:48.560 - 00:39:37.946, Speaker B: So the pros for Daphne. Is that it's developed per friendly syntax. So specification can be easily read, for example, by developers. Easier than what would be, for example, with TLA plus code can be compiled to an executable and we'll see that later. Why? These methods and also can leverage on quite extensive Daphne libraries developed as part of the Ironclad project. And also take a look at, for example, in the case of Liveness, how they progressed improving Liveness the drawback while it's a general purpose language is not specifically designed for formal specification, verification, distributed systems. So some of the things that you come for free in PLA Plus, for example, you need to build them yourself in Dafin.
00:39:37.946 - 00:40:43.080, Speaker B: And compared to other tools, like Ivy, suffers from stability of the time verification. Meaning that the time you change everything, you have a function that always verifies you progress a bit, verifying bits and pieces, and you modify a small thing and now something was taking 1 second takes a minute or whatever. Or minor terminate. Now, we evaluated the pros and cons, and for this case, we decided pros were outweighing the cons. So just a quick glance at some daphne. Code the way we definitively distributed system state sits basically a structure where we have configuration which is a sort of set input parameters like which are the nodes in the system and other things the genesis block we have the network with the adversary and we have an array of nodes. Basically, it's mapped from address, which is another identifier to the node state.
00:40:43.080 - 00:41:59.738, Speaker B: Then, for example, for adversary, we have the set of messages received as, say we can duplicate it. And the set of nodes that are by. This is just a quick of the distribution system next function where basically we can see that it's a conjunction of the next predicate for the network, the next predicate for the node and adversary depending on whether the node chosen nondetermistically to take a step is honest or dishonest. There are other things. But what I want to highlight here is that we have this conjunction of specification for the other modules. And just to give you look at how the consistency properties written we have trace is a basically function from integral to system state which is basically in position e basically means you have a state in position I. It means that after I steps that's the state that the system has reached.
00:41:59.738 - 00:42:35.958, Speaker B: So we define a predicate consistent blockchain. This from blockchain you can ignore, you can assume that it's basically identity because of some detail that raised in the protocol. We had to do this but consume that RBC one is like BC one. So we're saying one blockchain is the prefix of the other. And then we define the consistency property on the trace. Meaning that you take any two nodes and any index. If a node is honest, then the blockchains of these two nodes are consistent.
00:42:35.958 - 00:43:35.382, Speaker B: And then we have dilemma which is proven assume valid trace. Valid trace means that the trace progresses according to the specification and if the trace is valid, then consistency is true. So in terms of metrics, specification is almost 2000 line of code which has documentation to it. Documentation verification is currently 15,000 line of code. There is a lot potential work there to be done to streamline it. There are kind of statements that probably could be removed and verification will still pass. But that's where it is now in terms of verification time, it takes around 45 minutes to verify the entire thing on an eight core machine which is spec here again, I'm pretty confident that this can be reduced considerably.
00:43:35.382 - 00:44:26.598, Speaker B: But there is work to be put there and just better priority current future work almost there. So we proven consistency. Also stability under a condition that basically the set of valid data does not change. What we have to prove is the liveness so that hasn't been touched at all. And also remove this constraint on the fact that set of a data does not change and allowed for the validator set to change improve that all the properties still hold. Another thing that we are busy doing is so we have specification can say be a different level. The one that we have now is the given level of abstraction we call L One.
00:44:26.598 - 00:45:26.720, Speaker B: What we also have is a more refined specification which is deterministic and allows for an easier mapping to the code implementation. And the implementation of Qbft in a Belizer basis is based on this specification. What we are busy doing currently is to prove that the L two specification is a refinement correctly implements the L one specification. Also done created the reference test generator by leveraging the fact that Daphne can be compiled. We have a machinery that can generate reference tests given an input sequence of messages and that also has been done and this can be used. For example to mitigate the risk of implementation error when translating the L two specification into code. I don't have time for this one, but if people are interested, I can do that after the Q A.
00:45:26.720 - 00:46:08.510, Speaker B: Let's conclude with key takeaways important messages. Testing of distributed systems like consensus protocol is of limited benefit. There are infinite scenarios of infinite length. It generally tend to test only epicases. Really byzantine behavior introduces so many possible infinite scenarios. So what we need is an ambiguous mathematical defined specification of the protocol. Start with this removes interpolation errors and thus enables mathematical reasonable formal verification.
00:46:08.510 - 00:47:21.134, Speaker B: Formal specification is as specified as described as a state transition system. For example, for tbft we say what messages to send to which nodes, and how to update the blockchain in response to incoming messages over time. With the formal specification, we can mathematically prove formally verify properties like the absence of bad states, or that good things will eventually happen. We can use tools like Daphne to have a mechanically check proof. And also finally, we can have a refined formal specification and reference test generator from the specification that can be used to further ensure the final implementation actually respects the format specification. Finally, if you want to contribute or are interested to discuss further, or can ask questions now, or you can raise a PR wish you to the GitHub repo, you can email myself, email LinkedIn. And also, if you actually are interested, if you find this is something that fits your skill set and you want to be paid to do it, we have a job opening for the team.
00:47:21.134 - 00:47:25.960, Speaker B: And with this one conclude the presentation open for questions.
00:47:38.940 - 00:47:53.310, Speaker A: It looks like we're all blown away by your talk there, Roberto, and people aren't rushing in with the questions. Joanne's got a video happening, so she's obviously got a hot question for you.
00:47:59.300 - 00:48:00.816, Speaker C: There's quite a few questions in the.
00:48:00.838 - 00:48:04.130, Speaker B: Chat I'm be interested to.
00:48:04.740 - 00:48:40.544, Speaker A: Yeah, that could be a good source. I think Frank's had a go at answering some, so actually I put in one right at the start, which I can actually talk to. So the way you described it early on it did sound like if I have a formal verification of my system and my code, then I'm all good. And so do I need to test the code if I have it formally verified? And I know put his thoughts in, but it'd be lovely to hear your.
00:48:40.582 - 00:48:41.280, Speaker D: Thoughts.
00:48:44.180 - 00:49:26.190, Speaker B: If your final implementation is formally verified. Let's say it's all about reducing the risks. We can't never remove the risks. Again, as I said, we can use tools that allows for machine checking the proofs. And again, this tool can also be bugged. It's about reducing the risk. So if you can actually verified code, you might be very pedantic and wanted to add tests to it as well.
00:49:26.190 - 00:49:57.640, Speaker B: It's kind of a bit of a decision on the specific project. But having said this, the actual final implementation, having that formally verified is very big. It's more detailed. Like if you want to formally verify the Java code, then that's quite challenging.
00:50:00.740 - 00:50:39.116, Speaker A: I think in Frank's example, he gave an example of you could formally verify a system, but maybe the system would be stuck in the initial state. However, that formal verification would still be okay because it was still a valid state. It's just not a useful state. So I guess what he's saying there is that the testing can help prove that things are happening sensibly and as you would expect. So I guess the formal verification is really just telling you bad things can't happen.
00:50:39.298 - 00:51:12.948, Speaker B: Oh, no, hang on. This is because I think, correct me if I'm wrong, it's because in this case, we have formally proved only safety. So since we have formally proved only safety, we have not provided guarantee on liveness. So this scenario can happen. If you had formally proved liveness, then there will be ensuring that, for example, whatever liveness property we have proven, it is proven. If that's proven, it cannot get stuck. Won't get stuck.
00:51:13.044 - 00:51:29.980, Speaker A: Well, true. So, in fact, now we're actually moving pretty much into the domain of Ron Vander maiden's question, which is, how do you propose to handle liveness properties in Daphne?
00:51:30.880 - 00:52:22.780, Speaker B: So the Ironclad project, the way they've done it, they have encoded in Daphne the TLA logic, a portion of TLA logic. So currently investigating, trying to do something like they've done. So they've been able, for example, to prove the liveness of Puxos or a variation of Puxos. That's one possibility, using that library. Otherwise we might need to reason on the trace, somehow improving that, eventually moving around the state. Eventually. Eventually transition is included in the blockchain.
00:52:27.550 - 00:53:24.090, Speaker A: Someone else, Katie said, could you share your contact information? So the slides will be shared afterwards and you'll be able to copy them out. But can I say, if you go into LinkedIn and just search for Roberto Saltini, I think you'll find it, or even Roberto. And then space at Space Consensus, and I think that will find you as well. And from there you'll be able to get send messages and email. What questions have I missed that are in the I don't think I've mentioned missed any major ones, though. David has a question I deceive.
00:53:24.250 - 00:53:45.350, Speaker E: Yeah, I'll chime in. Hi, Roberto. It's good to see everybody at Consensus. It's been a while between COVID and a very busy year for me. I haven't spent nearly as much time with you all as I would have liked. Thanks for a great talk, Roberto. This was really awesome to see your progress.
00:53:45.350 - 00:54:20.926, Speaker E: So is there any way either with other systems or with future work or in stuff that you didn't have a chance to cover, that the applicability of form of verification to distributed systems might get easier over time? Do you see any potential for that? Or are we going to live with those limitations for theoretical reasons, which are.
00:54:20.948 - 00:55:05.674, Speaker B: The speaking about the limitations that the implementation is actually there could be translation errors in the implementation. Yeah, it's a challenging one. Like as I said, Daphne can compile code. So you could think of what you're saying. So you can potentially compile this deterministic specification into a library and use that library in the code. But again, the compilation is not compile, is not formally verified. So my opinion, it's far less likely that if you compile Daphne to code, there are errors introduced.
00:55:05.674 - 00:55:37.526, Speaker B: As they say. The surface area of the code is smaller than what you'd encode if you actually translate manually from Daphne to Java, for example. But again, the progress, I think is challenging. Actually. If you want to remove the errors introduced there, you really need to push the verification to the translation. As I said, it seems to me.
00:55:37.548 - 00:56:02.450, Speaker E: You'D have to have a very deep understanding of the implicit semantics of the language that you're trying to compile into. And so if you wanted to support a new language from Daphne, if Daphne supports C or C plus plus or what have you, and you wanted to do that for Java, there's a lot of work to do, such a thing. It's not an easy task.
00:56:03.190 - 00:56:35.530, Speaker B: That's true. Another way could be, for example, to target just a language where the translation is more formally verified. It's a bit hard to do, but there is more effort put into it and that's the one to go with. And then from that language you can compile to executable. That could be, I think, a way to go. But a few people on the call, on the meeting, on the call have other ideas. Please jump.
00:56:40.190 - 00:56:41.680, Speaker E: Yeah, thanks very much.
00:56:42.770 - 00:56:44.880, Speaker B: Thank you. David, nice to see you.
00:56:48.320 - 00:57:07.670, Speaker D: I have a question related to Liveness too, so thank you for the presentation. Roberto, the protocol that you verify, Qbft, so it's more than a consensus protocol because it's a repeating consensus protocol that you're running for each level of a blockchain, right?
00:57:08.200 - 00:57:08.950, Speaker B: Yeah.
00:57:09.320 - 00:58:06.900, Speaker D: So in standard verification of consensus protocols, liveness is that all the honest nodes are going to eventually decide something. So in your case, you are mentioning that you want to prove lightness as every submitted transaction to the blockchain will be included in the blockchain. So my question is, with my limited knowledge of how ethereum works, when you submit a transaction, you can add a price that you're happy to pay for the transaction to be included in a block. So to me that looks a bit incompatible with the Liveness proof because I could always submit a transaction paying a higher price for it to be included in the next block, and then it could delay infinitely the addition of one transaction and prevent it from being included in the blockchain. So is there something wrong in my reasoning?
00:58:07.660 - 00:58:50.048, Speaker B: No, it's a good point. They say that the reasoning is correct that I didn't mention or didn't clarify the presentation that this liveliness would be without considering gas. And this is because this makes sense in the setting for Qbft as Qbft is mainly used in consortium blockchains and often the gas cost is set to zero. It's a different dynamic from main net. Yeah, you're right. If gas cost was included in that is that the gas cost is that's.
00:58:50.064 - 00:58:54.404, Speaker D: Not only related to gas cost, it's related to having a fair management of.
00:58:54.442 - 00:59:10.200, Speaker B: The transactions that are that's also an assumption that we need to be made. The fact that each node, when they see a transaction and creates a block, starts filling the block from the older transaction that was received.
00:59:12.080 - 00:59:21.020, Speaker D: Because if you make these assumptions, if you need these assumptions to build your proof but they are not valid in the real system, what's the value of this proof?
00:59:23.600 - 00:59:42.550, Speaker B: That's fair. But in systems where Qbft is deployed I think that these assumptions are correct. As far as I know, it's typical to set gas cost to zero and you can have an implementation where you where honest nodes at least fill the blocks in a five four order.
00:59:43.560 - 01:00:01.820, Speaker A: But aren't the messages that are being exchanged, they're not transactions themselves. So there is no gas for them whether you were on a gas based system or not because you're trying to agree consensus so there is no gas.
01:00:03.920 - 01:00:22.880, Speaker B: What Frank is saying is that that's true if you aren't considering the agreement between the node but since I'm considering a transaction is submitted to the blockchain, eventually is included, then the gas cost could come into play, not in reaching agreement.
01:00:23.460 - 01:00:37.620, Speaker A: Yeah, but then surely that's not the consensus protocol. That's something isn't that a layer above the consensus protocol? The sort of the deciding which transactions form part of the consensus?
01:00:38.780 - 01:01:13.650, Speaker B: You could model it in that way. But again, Frank is right that if you want to prove liveness then you need to assume that this layer above behaves in a fair way at least. So that for example would not work if this layer above feeds the block with the most recent received transactions must feed the block with the order received transactions. So we make an assumption on how that level above must behave. But in this case I think for the system sorry, PBT is deployed, seems.
01:01:14.180 - 01:01:36.810, Speaker F: Reasonable assumption but sorry, a question is do you necessarily need a fairness assumption, not something weaker than furnace assumption to prove some liveness properties? I'm not an expert in this area but Ragfan Glapek has talked about Justness as well. Are you aware of that?
01:01:37.420 - 01:01:40.490, Speaker B: Justness yes.
01:01:41.040 - 01:02:02.640, Speaker F: So those are somewhere in between weaker than fairness in hope of proving some liveness properties for the system. Just a question, but the thing is do you need really necessarily a strong fairness assumption to prove the liveness properties?
01:02:04.900 - 01:03:07.030, Speaker B: So the fairness was referring to in this case is about on how a proposer decides to which transaction to include in a block. So it wasn't the fairness really on the system evolves. It's the fairness now the transactions are chosen. The fairness kind of assumption that we make is on having an eventually synchronous network with I didn't say it, but partially synchronous and partially synchronous or synchronous processes, which is essentially a weak fairness, probably. But again, the liveness is not something you're looking into. So you might be right.
01:03:08.040 - 01:03:20.730, Speaker A: So thank you, everyone. And here Joanne and I were just as we hit Question Time, wondering if there were any questions. Could you move to the next slide so we can talk about the future?
01:03:24.300 - 01:03:25.244, Speaker B: Yeah. Yeah.
01:03:25.362 - 01:03:52.020, Speaker A: All right. So this slide here is actually how to get in contact. So this talk, this great talk that you've done and as a few people are doing yes, thank you very much, Roberto, for doing such great talk. Very informative, very interesting. So thank you. And this talk will appear on our YouTube channel. And also, if you've got more questions, you can join the Slack Workspace.
01:03:52.020 - 01:05:04.270, Speaker A: And for that matter, we've even got a formal verification group that meet every two weeks and discuss academic papers. So if you like, you can join that Slack Workspace, and from there you can get information about that. And if you're watching this on YouTube, that's how to get access to the meetup so you can come to the live events. And every now and again, there's some code that's done. And so the example code that's done is on that. Could you go to the next slide, please? Okay, so next week we've got someone along. So Niraj has done some analysis of all of the ERC 721 contracts and has tried to do an ecosystem analysis of who's doing what and what types of behavior is happening in this space and what are the interactions and what can you draw from that? So that should be really interesting.
01:05:04.270 - 01:05:46.536, Speaker A: Two weeks after that, we've got Mikhail is going to talk about the Ethereum merge. So for those of you who don't know, there's Ethereum Mainnet, which is the execution chain that we've been using all these years, that does proof of work. And in the coming months, it's going to merge with the beacon chain, which was previously called Ethereum Two. And so you're going to have the beacon chain running. And then tethered to that, you're going to have the execution chain, and that's going to mean that we're going to be using proof of stake for Ethereum. So Mikhail has been in the Ethereum ecosystem for about six years. So since the dawn of time, as it were.
01:05:46.536 - 01:07:09.172, Speaker A: And he and I were chatting and saying, well, what do people want to know? And so in that Slack Workspace in the general channel, we've got a point where it just says, what do you want to know about the merge? So put your comments in there. Or even if you like, you can message them to me. And what do you want to know? What are the open issues for you? What do you need more clarification about? What should Mikhail talk about? Two weeks after that, we've got a special talk, a surprise talk. So we've got a talk that I said would never happen in this meetup group. We've got one talking about cryptocurrency and pricing, and so we've actually got Lex Sokolin and so Lex is the chief economist at Consensus, and so he's going to try and talk about what are the drivers behind cryptocurrency pricing and what would be a good mental model to have about how it all works. And so he lives in London and is a very busy person, so that talks actually on a Tuesday, and it is at 08:40 P.m., and so we've only got him in total for an hour.
01:07:09.172 - 01:08:07.044, Speaker A: So I'll be opening the call at about 830 and then give him ten minutes to get ready. And so we've got him for an hour. So all those cryptocurrency questions, is ETH going to go up or whatever? I think have them ready, but I think it's going to be good because we're going to get a mental model of how to think about crypto, which I think is really good. Then in April 6, we're going to have real world companies, so companies that are doing stuff in the blockchain space. If you've got an application that your company does, the idea is that we're going to have, say, three companies, they'll each talk for about 2025 minutes. And so, David, for instance, your company is doing interesting stuff and I don't think you've talked at the meetup about that. So maybe that could be an opportunity for, say, for instance, you.
01:08:07.044 - 01:08:15.400, Speaker A: And if you're listening and you've got a company that could present, then please get in contact. And then we've got some other talks.
01:08:25.420 - 01:08:26.840, Speaker B: Did we lose Peter?
01:08:27.820 - 01:08:30.430, Speaker C: Yeah, Peter's frozen at the moment.
01:08:30.800 - 01:08:31.644, Speaker B: Right. Yeah.
01:08:31.682 - 01:08:51.008, Speaker E: I wasn't sure if it was me. I'll just say that I'd be happy to talk about bitscore. I'm not certain I can do it by April. It'll depend on when we close our next funding round, but at some point I'll be happy to do a talk and you can let Peter know when.
01:08:51.094 - 01:08:53.152, Speaker B: He'S we'll we'll do.
01:08:53.206 - 01:08:53.904, Speaker C: Definitely.
01:08:54.102 - 01:08:54.572, Speaker E: Cheers.
01:08:54.636 - 01:08:55.360, Speaker B: Hunter.
01:08:58.660 - 01:09:34.210, Speaker C: Well, everyone, I think that pretty much wraps it up. It's just the other ones that Peter was mentioning, he's actually going to be talking about ethereum gas usage and gas optimization in either later on in April or May. Push it out in May. And then another topic that is selected is solidity security, and we're still looking for someone to present on that. So that concludes the session. Thanks, everyone, for attending and Roberto for a great presentation. Thank you so much, everyone.
01:09:35.940 - 01:09:39.440, Speaker A: Thank you, Sandra. My network crashed.
01:09:39.940 - 01:09:41.410, Speaker C: We worked that out.
01:09:43.540 - 01:09:45.516, Speaker E: All right, talk to everyone later. Bye.
