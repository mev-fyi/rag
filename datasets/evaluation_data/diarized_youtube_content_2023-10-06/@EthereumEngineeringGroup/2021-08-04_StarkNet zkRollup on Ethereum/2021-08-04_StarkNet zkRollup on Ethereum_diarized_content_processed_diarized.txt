00:00:01.290 - 00:00:13.360, Speaker A: Hello and welcome everyone. This is the Ethereum engineering group meetup. I'm Peter Robinson and today we've got Tom who's going to talk about Starknet. Tom, over to you, please introduce yourself.
00:00:15.890 - 00:00:37.670, Speaker B: So hi everyone, a pleasure to be here and thank you for inviting us. I'm actually not alone here, so my name is Tom, I'm from Star Software, I worked there for almost three years now for the last, I would say since the beginning of the year, the product lead of Starknet and together with me I have alon.
00:00:38.650 - 00:00:39.560, Speaker C: Hi everyone.
00:00:41.630 - 00:01:51.182, Speaker B: Who'S engineer at Starquare and he will demonstrate to us how to use darknet today and I think Nomi is also here, she's our head of marketing. So again, hi everybody. And I thought the best way to split the time today is that I will first introduce Starknet. What is the main change it brings to the blockchain ecosystem where we are today and what you can do with it then along with demonstrate what I've just talked about. And then at the end you're all very welcome to ask questions all along during the call, but at the end we can have like a dedicated time for questions because I chose to focus on some things but there are many, many other things which we can ask and elaborate more. So feel free to take the conversation to anywhere you want after that. Okay, great.
00:01:51.182 - 00:02:02.290, Speaker B: So I will try to share my screen. Yes, you're supposed to see now my presentation, please confirm.
00:02:04.970 - 00:02:06.120, Speaker C: Yes, can see.
00:02:09.130 - 00:03:15.930, Speaker B: Okay, perfect. So what I will be speaking now over the coming 20 minutes I think is first, what is the, I would say like the main inherent difference in the way Starknet approaches solving scalability or offering scalability and then what is even Starknet and what we're aiming for. And lastly, what we have today, I mean Starknet is already live, Starknet Alpha is already live for the last two months. So describe what we have, what is the roadmap and how you can start contributing or playing with it, et cetera, et cetera. Okay, so let's begin. Yes, the first thing I want, and maybe this is a very high level concept, but I hope that it will help understand better how stagnant offers scalability. So basically it's the transition from execute to verify.
00:03:15.930 - 00:04:49.500, Speaker B: So our great ancestors, bitcoin and ethereum was launched in 2009 and 2015 respectively. And they offered like list, in my opinion a big, big change to the way people interact with value and with financial systems, but with a very big caveat as well, which they offered a much slower, or I would say much limited throughput systems compared to the old traditional payments or banking systems. And I think we all have an intuition to why is that, but I want to try and give a clear definition to why this is the case. So when we work with banks or with any trusted party, basically what we say we delegate the accountability to the state, either the financial state or the balance state or anything like that, to some lawyers, regulators, accountants, and we trust them to execute our transactions and report to us our state in a trusted manner. And on one hand we trust them, but on the other hand it can be very mean. There's only one party that needs to do any computation or any execution. So it basically can grow as large as, I don't know, Google cloud can support servers or stuff like that.
00:04:49.500 - 00:06:13.170, Speaker B: But what blockchains wanted or what they brought to the world is basically inclusive accountability. Meaning I want to allow anyone who wants to be able to be accountable to the state of the system and basically be accountable to what is the true state. Were the state transitions valid? What are the balance, what transactions were executed? I leave aside all the proof of work and stuff like that. But basically the way we allow this inclusive accountability in blockchains is by saying that every node in the system need to execute all the transactions. They don't trust some external party to execute it and reflect to them what is the state, but they actually execute all transactions from the genesis to the current state of the system to be able to be accountable for the state of the system. Now this is again, in my opinion a very important thing to have and hopefully it can change the way we do interaction with people in the future. But currently it came with a cost and the cost was scalability.
00:06:13.170 - 00:07:34.106, Speaker B: And again, it's not a big shock to you, but what I want to say is that the scalability comes from the fact that everyone need to execute on transactions. Now there are many scaling efforts and there are still many scaling efforts, and it's funny to call them traditional, but I didn't have a better name, so you are welcome to suggest a better name. But basically almost every other scaling effort have the same paradigm, meaning they offer some optimizations, but they still require everyone who wants to participate in the network to execute all the transactions of the network. Sharding work the same way other blockchains work, the same way optimistic collapse work, the same way everyone requires you, if you want to be a node in the system, to execute the full transactions from the genesis block. And they offer us scale by either increasing the trust. So if we have some, I won't name them. But if we have some proof of authority chains that have like some 21 big servers that run the consensus, then we gain scale.
00:07:34.106 - 00:08:59.190, Speaker B: But the trust in them, or the trust that needs to be in the system increases and takes us more to the traditional banking systems than to what we actually want to have. And the other thing that allows scale is actually increasing the hardware requirements. So actually, I had a very interesting call yesterday with some API services, and they said that for example, if we take Solana, which is a new blockchain, that has very nice optimizations, but actually the hardware requirements to run a full node is not something you can today get in the market. I mean, there's a shortage to the hardware requirements to be a full node in Solana, and there's actually no way for you to execute and by that not trust the system in those kinds of blockchains. And this is also true, for example, for optimistic collapse. So optimistic, oops, they delegate some of the trust to validators that will be incentivized to validate the chain. But if you want to actually be a full node in the system, the requirements for the full node just go linearly with the throughput.
00:08:59.190 - 00:10:01.630, Speaker B: Okay? And also a very nice anecdote. So Jameson Loop, which did a nice report, I think it was last week, but maybe it was even this week, where he tried to sync with all the new chains. And one of the conclusions that he wrote at the end of the report is that it seems that for the newer, higher performance networks, almost none of the users actually run a full node, because the requirements for being able to validate the system are too high. So on one hand it seems like they achieve scale, but on the other hand, there's no really way to execute and don't trust some delegated validators. Now, Starknet and VK rollups in general offers a new paradigm. And the paradigm is that we actually don't need to execute the transactions in the system, but we only need to verify. And what do we need to verify? We need to verify the stock proofs.
00:10:01.630 - 00:10:50.890, Speaker B: I won't elaborate a lot about what are validity proofs, but I would be very happy to do so at the end if you want. But basically, stock proofs and validity proofs in general are proofs for some computational integrity. Meaning I can generate a proof that some computation was done correctly. And specifically in our case in Starknet, in Ziki rollups, the computation that we want to prove is a valid state transition. So I will explain it. A state transition, for example in Ethereum is done by a block, I start from a specific state, I execute a list of transactions, and I end up in a new state. The stark proofs in Starknet generate says the following statement.
00:10:50.890 - 00:12:08.310, Speaker B: If I started from a specific state and I executed the list of transactions, I end up at the end state. Now, why does this or how do we scale? By using this kind of system, we scale because stark proofs have a very nice property, which is that with respect to the original computation that I want to prove, for example, the execution of a block, the verification of the proof is exponentially smaller than what I wanted to prove. So for example, if I wanted to prove the execution of, I don't know, 1 million transaction, I need to do something like 20 steps in order to verify it. So exponentially is very small, but it also grows very small. So if I want to verify, I don't know, 1 million transactions, then it corresponds to 20 transactions. If I want to verify 1 billion transactions, then it corresponds to approximately 30 transactions. So this property allows us to, on one hand, scale the throughput of the system, but not require linearly more resources from whoever wants to verify.
00:12:08.310 - 00:13:19.590, Speaker B: Okay, so I've said a lot of things, and I've said that starknet brings a new paradigm, but what is actually starknet? Okay, so starknet in one sentence is a decentralized, permissionless Zk rollup, which we actually don't really like this term because there's nothing, zero knowledge about it. It's actually a validity roll up which offers scalable and secure Ethereum like state. So what does this actually mean? It means that stagnant is a L2 network that operates on top of Ethereum, and it offers the functionality of writing smart contracts, that those smart contracts are general computation, meaning they can have any computation that you want, the same way that you're familiar with Ethereum and those contracts can interact with each other. I don't know if there's any questions. Yeah, in the chat, there's no questions. Okay, great. So this is what is Starknet and why? I think Starknet is actually something that brings value to the world, because we came from the point of scalability.
00:13:19.590 - 00:14:11.614, Speaker B: But what starknet gives us is scalability without compromising on security and decentralization. And I will try to explain a little bit what I mean by that. So when we talk about scalability in a L2 solution, or specifically in a validity roll up, there are two main factors that we need to consider. One of them is how many proofs or how many transactions can you include in a proof? Right. If I can include only one transaction in a proof, it actually doesn't save anything at all. But if I'm able to include 600k transactions, 1 million transactions in a proof, then the marginal cost of each transaction is actually very small. And this is how I can achieve scalability in Starknet and I will get to it in a second.
00:14:11.614 - 00:15:47.466, Speaker B: But it relies on starks and stark provers, which are the strongest provers in the world and have repeatedly generated proof on Mainnet for thousand k's of transactions. So this is one aspect, but the other aspect is the data availability aspect of the scalability. And I want to take a look at it from the, let's try to go to the onchain data availability perspective. So if I look on onchain data in a roll up, what is the goal of the onchain data availability in roll up or in any system? The goal is security, right? Because if I do state uploaded on a roll up, I need to somehow be able to connect it to what state it actually proves. So what data do I need in the traditional or in blockchain or an optimistic roll up or anything like that? I actually need the transactions that execute the state because there's no way for me to reconstruct the state if I don't have those transactions. But if I'm looking on a validity roll up, the only thing that I need is some minimal state div from the previous state to the new state. And why is that? Because I know that the proof makes sure that the state transition is correct.
00:15:47.466 - 00:16:50.510, Speaker B: So this minimal data leads to a much higher scale. And I want to demonstrate it through an example from real application that we have today. DyDX is a customer of starkware and it runs on a ZK rollup which is not yet starknet. It will move to Starknet, but it runs on a validity rollup which is specific to DyDX. And DyDX is a derivatives trading which allows you to trade on assets that their price is verified through oracle price transactions. Now the YDX. Okay, so let's take for example the Oracle price transaction as an example on why on chain data in roll up is much much smaller than what it is, for example for an optimistic rollup.
00:16:50.510 - 00:17:55.718, Speaker B: So if I look at a price oracle transaction, the actual change to the state is only changing the price of a pair, for example. So if I look at one transaction, the change is one. But if I also look at, I don't know, one k transaction, the change is also one, because all of those transactions change the same price. So if I need to publish the full transactions on l one. The cost of the onchain data grows linearly with the number of transactions. But if I only need to publish the latest update to the state, then no matter how many oracle transactions I want to include in the state update, I only at the end publish one state change. And this actually allows the YDX to include a price oracle transactions before each trade in the l two.
00:17:55.718 - 00:19:05.830, Speaker B: And this led to an amazing number of in the cost reduction of between 100 to 200. And again, it's dependent on the number of transactions that we did in a proof, but compared to l one. And if the YDX had to build this kind of system on a non validity roll up system, the data availability requirements would never have allowed them to reach those kinds of numbers. So this is the scalability part. And why do I say that we offer scalability without compromising on security and decentralization? So first, security, security in Ezekiel up is guaranteed by the proofs, meaning every state update that I do is only possible if a valid proof was verified for it on l one. And this actually means that we inherit the security of l one because no state transition can happen if a valid proof was not verified to it. So this is security and decentralization.
00:19:05.830 - 00:20:37.240, Speaker B: Again, it goes back to what I said at the beginning, and let's take a look at it from the full node perspective. So if I'm a full node, what is my role as a full node? Basically I want to be able to be part of the network, I want to hold the state, I want to make sure I'm able to sync to the state, and I want to make sure I'm able to update it and be able to answer queries on it. So what does that require for me in any other scalability solution? It requires me to actually execute the transactions and in validity roll up. As I've already said, it only requires me to verify proofs. And again, this means that the scale with respect to this throughput is logarithmic, which allows us to maintain decentralization because anyone who wants can be part of the system and can be a node in the system. Okay, so yeah, I've talked a lot, some high level concepts why Starknet is good. What is Starknet? But I think that by now you should be asking yourself, what do you actually have? I mean, is it a story or the way I think about stuff, is it just deployed on Twitter or what do you actually have? Okay, so good question.
00:20:37.240 - 00:21:34.860, Speaker B: So maybe before I move to what we actually have, I see Peter asks, is it theoretically possible for transactions to cause expansion? That is, a lot of state is updated for a single transaction. Yes. So it's a very good question. So I think what Peter is asking, and correct me if I'm wrong, is maybe for some transactions, the witness or the transaction itself is much less data, is much smaller than the actual changes to the state. So I can indeed write some malicious contracts that what it does is just very small transactions that change a lot of places in the, in the state and actually cause a lot of data on l one. So you're right, the main thing that proofs allows us to compress is computation. It doesn't allow us to compress state.
00:21:34.860 - 00:22:36.110, Speaker B: So I have also another example which I didn't share, and this is the dark forest. So I expect that the most efficient way to use starknet and validity proofs will be to be prone to heavy computation and less storage. Because actual storage changes we don't save the full node still needs to maintain the state. But if I'm able to convert some of the storage changes to actual computation, for example, having a Merkel root and being able to prove or to change stuff via Merkel authentication path. So this will be very cheap in a validity proof because it has a lot of witness, the transaction might be very big and you have a lot of computation, but all of this is being compressed and the actual state change can be very efficient. I hope that answer.
00:22:36.260 - 00:23:00.950, Speaker A: Yeah, that answers the question. And thank you. It's what I thought. You probably get to this, but obviously you're going to get charged fees, but do you try and proportion the fees based on the amount of state update that your transaction does? Or can I sort of free ride on everyone else's and have lots of state update in my transaction?
00:23:04.250 - 00:23:48.294, Speaker B: So even if we don't take into account the l one cost, state update is also very expensive. State update corresponds to storage interaction, either read or write. Right? Um, so we can actually just charge by debt and, and this means that you don't free write anything because you first have an impact of just impacting the full node storage. And also the changes that you made to some storage that you wrote are directly related to you, so you must pay them. I hope that answers this question that makes sense.
00:23:48.332 - 00:23:49.160, Speaker A: Thank you.
00:23:49.610 - 00:25:00.090, Speaker B: There are stuff that are harder to take into account. For example, if you and me are trading with Uniswap, who paid for the change in the state of uniswap? Right? Should it be me? Should it be you? Because at the end it's only one change, but we're still debating on how to solve those specific problems. Okay, so what do we actually have? So today we have what we call Startnet Alpha and it's been live on robstand since mid June. So almost two months by now. And Startnet Alpha is a work in progress and it is our way of sharing with the ecosystem and with developers with you, what is the lazy state of Starknet and allowing everyone to start experimenting and playing with it. Right. So what do we actually have in the alpha? We have smart contracts, meaning you can run smart contracts, you can write smart contracts, you can deploy them, you can interact with them, send transactions to them, make API calls on them.
00:25:00.090 - 00:25:50.550, Speaker B: Those contracts can interact with layer one, meaning they can send messages to an l one contract, and l one contracts can send messages to those l two contracts, which is a very important property of an l two system, which allows us for example to do token bridges or stuff like that. And of course all of those transactions are proved off chain and are verified on chain, meaning it's not just some theory. State that hopefully one day we will also connect with the prover and the verifier. Everything is run as a Ziki rollup. And since it is a Ziki rollup or a validity roll up, the on chain data is also published on Robstand. So this is the functionality. We also have a growing list of tooling.
00:25:50.550 - 00:26:39.946, Speaker B: We have a web ide which I think alone will demonstrate. We have a CLI tool, we have a block explorer. And everything I've just said right now alone will demonstrate in few minutes when I will finish my rumbling. Okay, so this is what we have today, but I think that not less important is what are the foundations of Starknet. So Starquare didn't start it from working on Starknet. We actually started before that developing what we call the stark stack, which is a very battle tested and production proven software stack that are the basics for Starknet. So first of all we have Cairo, and again if you want I can dive into it a little bit later.
00:26:39.946 - 00:27:29.274, Speaker B: But basically Cairo is a language that allows developers to write programs and those programs to be proven as stock proofs. So basically it's a very efficient way to take computation or statement and transition it into proofs, which was very hard up until today because everything had to be compiled to circuits and et cetera. And Cairo changed this paradigm. And Cairo is the language that Starknet is written in and is also the language that developers write. Starknet contacts. The second thing are the stock provers. And as I've said already they are the most powerful provers in the world.
00:27:29.274 - 00:28:17.530, Speaker B: And it's quite hard to compare Apple to apples in that scenario, because you need to have, for example, a very specific statement and say, okay, what can this prover do? And what can this prover do? But we're fairly comfortable saying that those are the most powerful provost in the world. And when you say the most powerful, I mean the time it takes to generate, approve and the size of the statement that we can generate are by far between ten to 20 x more than what the competitors have. And lately it's Starkx. So Starkx is, I mentioned it with DyDx earlier, but this is a Zika roll of applications that we have in production. They're in production for over a year now. We started with diversify. We also have DyDx immutable, and Leslie Sorre joined.
00:28:17.530 - 00:29:19.710, Speaker B: So all those foundations allows us to make sure that what we build for Starknet is based on stuff that are actually tested in production. Okay, great. So I'm getting towards the end, and this is our roadmap ahead. So the foundation, as I've said, is already live. The alpha is already live, and we'll be constantly updating it. And constellations, which is our name for the first, I would call it better version, but the version which will be on Mainnet and won't be a work in progress, we expect it to be live by the end of this year. And basically the main differences between what we have today on the alpha to where we want to reach is our adding composability.
00:29:19.710 - 00:30:21.300, Speaker B: So the next update to the alpha would include the ability for contracts to interact with each other and after that. And this is also related to your questions, Peter, is to add gas metrics, right? So this is, we expect to be done by the end of the year and the next step afterwards. So constellations will deploy with a single sequencer, meaning the layer of the sequencers will still not be permissionless. And the next update afterwards, which we hope will be around q two in 2022, will be to decentralize this sequencer level. Okay, so this is the roadmap. The last thing I want to say is that we are collaborating with a lot of teams which are outside of Starquare, but are a big part of the Ethereum community. And I should actually also add to that consensus now, but this is very.
00:30:21.300 - 00:31:10.494, Speaker B: So step by step. So first of all, the full node infrastructure, as I've said, I see it as a crucial infrastructure for a blockchain. And we decided to work with the Aragon or the two boguette team, which is a client in ethereum, and they are building the full node infrastructure for Starknet. We're also working with Nethermind on two projects. First of all the block explorer that you will see, and also an EVM to Cairo compiler. So this will allow taking solidity code and compiling it to Starknet contract. I think it is an important step in the way for developers or applications to try Starknet.
00:31:10.494 - 00:32:00.020, Speaker B: But at the end I hope, and this is also my belief, that people will actually write the programs, not via this compilation, because it includes a lot of overhead and inefficiency. We're also working with open Zeppelin to have the same infrastructure of context authorization that we have on Ethereum for Starknet. And also we are working on a compiler from a functional language, which is an effort that's starting this. And as I've said, we also started working with the truffle and infura. So I should edit. Okay, perfect. Yeah.
00:32:00.020 - 00:32:49.780, Speaker B: Again, this is an invitation to join the teams that build Starknet, to join the individual contributors. There are many, many already developers that build very nice things compared to the state of the system with Starknet. So it is very nice to see it. And also together with the Makerdao, the last steps of forming a team that will expand the maker protocol to start. So this is the ecosystem and this is where the first part of this meetup ends. So thank you. I think that before we continue, I will go over the questions, and if you have more questions, then is a good time to ask.
00:32:49.780 - 00:33:58.860, Speaker B: Yeah, so Joey asked, are you using EVM for the smart contract? Okay, so good question. We're not using EVM for the smart contract. The main reason for that is that EVM was not designed to be efficient from proven perspective. And this is very important because in order to achieve scalability, as I've said, you have to be able to prove very big proofs. So it is not using EVM, but as I've said, maybe it was before I mentioned the compiler. We are building a compiler from EVM to Cairo, which is the language that the smart contracts are written in. The next question is, is it EVM compatible? So I assume the question you mean not only the smart contract, but also I would say, for example, the API or stuff like that.
00:33:58.860 - 00:35:04.400, Speaker B: Is this what you meant? Okay, I will assume it is. So Stacknet API will follow as closely as possible the Ethereum API. There are a few places where it won't be compatible, but I think it will be very minor. But we will probably first of all, standardize it better from the beginning. One of the downfalls of the theorem API is that it was standardized quite late. So multiple nodes and multiple API services have different implementations and we will probably expand it. We had a very good set of interviews with a lot of people from the ecosystem and we tried to understand what are the pain points for them, and we got some very good feedback and I think there's a way to keep it compatible as is, but expand it in a way that will try to answer those pain points.
00:35:04.400 - 00:35:51.982, Speaker B: Okay, next question from Joey. Do you have the Cairo smart contract environment specification implementation code available for public to look at? So, yes, Cairo Lang repository is public and you can install it locally and work with it alone will now demonstrate it. So hopefully it will be easier for you to do it afterwards. Yeah, everything is open and you can take a look and use it. Does that answer your question? And. Okay, so great. Okay, yes it is.
00:35:51.982 - 00:36:09.170, Speaker B: I'm glad to hear. So, yeah, I don't know how to say it. We will move to you alone and I'm here, and after alone will finish. We can have another question session. Okay, thanks.
00:36:09.240 - 00:36:19.750, Speaker C: Can you just stop the screen share? Okay, can everyone see my presentation?
00:36:22.330 - 00:36:23.878, Speaker B: I can see it, yes.
00:36:23.964 - 00:37:03.810, Speaker C: Okay. All right, so, hi everyone, and thank you, Tom. I'm Alon from Starkware's engineering team. Now that we're done getting that broad overview at a high level of Starknet, it's time to roll up our sleeves and do some more practical work. So in this talk, we're going to show you how to write and deploy your first startnet contract. And without further ado, as Tom mentioned, Startnet contracts are written in the Cairo language. Now, don't be alarmed if you're not familiar with the language, because we're not going to dive too closely into the details of the implementation.
00:37:03.810 - 00:37:56.226, Speaker C: But a few words before we do start is that the Chira language is optimized to write stark proofs. It's characterized by having immutable memory, which on one hand makes it easier to generate stark proofs, but on the other it makes things like writing loops a bit harder. For that, we use recursion to implement loops, much like functional languages like ML. Next up, I'm going to open my VSCO terminal and show you a very simple starknet contract. The contract will just implement some basic functionality so we can play around with it. We'll see how we can use the CLI commands to compile and deploy our contract to the Starknet system. We'll track our various transactions via CLI and also via the Voyager block Explorer.
00:37:56.226 - 00:38:45.140, Speaker C: And we'll show the difference between using the call or the invoke CLI command to interact with our contract. With that, let me switch to my vs code terminal. If anyone can see, let me know. So this is our first sample of a Starknet contract. It's a relatively good sample, most because it's short, short and easy to understand, and also because it covers a lot of the bases. So this makes for a good template to write contracts. It starts off with the lang directive, the lang Starknet, which gives the compiler indication that this code is to be compiled for the Startnet system.
00:38:45.140 - 00:39:43.750, Speaker C: It's still the car compiler, but there's a few notable differences when you use this directive, most notably that this code doesn't require a main function. Next up, we have the built ins and the imports, so imports are relatively self explanatory. Built ins is a dedicated directive for Cairo that includes dedicated modules that implement some non trivial functionality. We'll dive a bit closer into them when we switch back to the slides right onto the code itself. So a contract has variables and functions. So this variable here that's designated as storage VAR is actually a variable we want to use for storage in our startnet contract. In this case we're giving just one simple variable we call balance, which will hold a somewhat arbitrary balance that we want to keep track of in our contract.
00:39:43.750 - 00:40:28.090, Speaker C: Next up we implement two functions. The first is increase balance, which as its name implies, will allow us to increase the value of this storage variable given a certain amount. This function is designated as external, which allows the user to interact with it via the CLI. It also allows the user to actually interact with it and change the state of the contract because it actually changes the value of this storage variable. There's another type of externalized function which is the one designated by view. In this case it's get balance. So the difference being that get balance, as expected, just prints out the current balance stored on the contract.
00:40:28.090 - 00:41:22.694, Speaker C: And the designation for view means that it's a function that can be invoked without actually changing the state of the contract. In fact, calling this function doesn't actually need any sort of layer one interaction. Okay, so we have this contract, it's all ready and set to deploy. So how do we go about deploying? I'm going to switch to my terminal and the first thing we're going to do is we're going to call the startnet compile command here. So this command receives as input our code, which is called contract Cairo and it outputs two files. The first, designated by the output flag is simply our compiled code given in the JSON, and the second is our contract aBI. So we're going to need the compiled code in order to subsequently deploy this contract startn system.
00:41:22.694 - 00:42:01.202, Speaker C: And the ABI is for later use when we're going to invoke its functions. So with that, I'm just going to hit this, and assuming nothing goes wrong, we should have our files created, the contract API, and the contract compiled. So with these files we can now invoke the startnet deploy command. So the startnet deploy command, all it needs to receive as input is our compiled contract, which is contract compiled JSON, and this command will deploy it to the system.
00:42:01.256 - 00:42:01.474, Speaker B: Again.
00:42:01.512 - 00:42:39.690, Speaker C: This system is now the Starknet planet Alpha. And there we go. This is the indication that our transaction was sent to the system and our contract is now being deployed. Now we're going to want to keep track of this transaction and see when we're able to actually interact with this contract. There are two ways we can go about doing this. The first is via the ClI itself, so we can use the Starknet get transaction command and give it the id that matches our transaction, which is up here, and it'll print out the status, the current status of our transaction system. So right now this is all the metadata on this transaction.
00:42:39.690 - 00:43:38.366, Speaker C: The status is what we are more interested in, which is pending here. And eventually this transaction will be accepted on chain indicating that it was actually verified another way we can keep track of this transaction. So let's just copy over this transaction and I'm going to move to our block explorer. Now this block explorer was written by the very talented netamine team which have done stellar work with this and they still do. They keep upgrading this block explorer as new and newer versions of the Starknet Alpha are being deployed to the system. So with this Voyager system we can just input our transaction id here and try and find it just refresh real quick. All right, I'll type it in here.
00:43:38.366 - 00:44:18.000, Speaker C: But if you look at the bottom here of the latest transactions, you can actually see our transaction id here. So if we click it, we can actually see that it's still waiting to be included in the block. And as soon as it is, we're going to be able to do all these various interactions with the contract. But since it's pending, we can already start using some basic functionality. So I remind you, I'm just going to go back real quick to the contract itself, that we have two functions. We're able to interact, we have the get balance function which will just return what we can call the current state of the system, which is just a balance. And we have increased balance which allows us to change state of the system by increasing the balance according to some amount we want.
00:44:18.000 - 00:45:08.622, Speaker C: So let's start by using the get balance function. Now do note that this command is going to use darknet call. There are two different commands that allow you to interact with functions on the contract. The first being call, which we're demonstrating momentarily, and the second is invoke. The difference being that call guarantees that the contract state is not going to change by the command that I'm running, which makes it ideal to either dry run state changes without actually committing the state change and also to use view functions like we're going to use now. So first off, we're going to want to give the address of our contract, which we can find right up here in our transaction metadata. It's going to copy it over here.
00:45:08.622 - 00:45:55.600, Speaker C: We need to supply the contract API that we produced when we compiled the contract. Designate a function we want to call, in this case get balance here and we'll give it as input. Well, we don't need to give it any input for the moment because I'll remind you that this function, if you look here, doesn't actually receive any input. So if we invoke this function, or rather sorry, if we call this function, it looks like I have a small error here. Right. I must have made a slight error in the contract that I deployed because it expects me to have some variable here which I'm not supposed to support. Just get that.
00:45:55.600 - 00:46:33.570, Speaker C: There we go. I used the wrong API here. That's a quick debug here. So I was supposed to give it our contract AbI, not this distant contract that we'll show later. So just going to go and supply contract API, which is the one we just produced, and try again. And there we go. So as expected, since we actually haven't made any alterations to the current state, our balance stored in the contract is just zero.
00:46:33.570 - 00:47:01.354, Speaker C: So let's change that. Let's use invoke and call the increase balance function to increase that balance. So again, we're going to supply the contract address and make sure we got the AbI right this time, which we apparently do. We're calling the increase balance function. And as input we're going to give it an amount that is 1234. We'll send that. And there we go.
00:47:01.354 - 00:47:37.110, Speaker C: This is another transaction because I committed that with the invoke. I could also do the same exact function call. But instead of invoke I could use start net call. And this is not actually going to do anything too impressive at the moment because what I'm doing here is I'm invoking the function. I'm running it locally. It's a good way to find out if there are any bugs with something I've sent, but I haven't actually committed this state change. Now we can use get transaction again and track the status of our previous invoke transaction which was to increase the balance.
00:47:37.110 - 00:48:14.380, Speaker C: All right, so currently it's pending. Since it's already pending, we can probably already use the get balance function again in order to see what our balance is in the system now. And as expected, our balance has shifted from zero to 1234. Okay, any questions so far? Actually can't see the chat at the moment. Palmer, there are any questions you can see?
00:48:14.770 - 00:49:36.694, Speaker B: Yes, Peter asked, Joey asked do you have a local debugging environment like hard hat and local deployment environment like ganache? So this is a very good question right now. It is not and it is very, I mean, when I worked on Starknet and tried to debug the contract that I wrote, my appreciation to Ganache grew exponentially. Really? It's amazing. So in the next update for the alpha, we are planning to release a local testing framework which will hopefully, and this is a discussion that I have with the Ganache and traffic team, will hopefully allow them to expand Ganache to also support that. So it is in the works and really, really want it to happen as soon as possible because it's really needed. So, yeah, good question. And Peter asked how often are blocks published and will this be the same when the system is deployed to Mainnet? And what would happen if there is a congestion on Mainnet? Okay, so good question, Alan, do you want to answer? Do you want me to answer?
00:49:36.892 - 00:49:38.440, Speaker C: You can go ahead and answer.
00:49:39.690 - 00:50:16.242, Speaker B: Yeah. So right now it won't be the same. Right now it's a hosted service. Right. We define all the parameters and the goal right now is not to expose how the network will actually work, but just to allow developers to write contracts and interact with them. So right now I can change it in my terminal. I think currently we create a blocked every 30 minutes and it is published on l one.
00:50:16.242 - 00:51:21.030, Speaker B: I think it is supposed to be published two minutes afterwards and it won't be the same. And I still don't know exactly how it will behave on Mainnet in that sense. And if there is a congestion on Mainet then basically it will delay the finality of the proofs on l one, which the most immediate impact to it is that, for example, if you wanted to withdraw your tokens. So this is dependent on a message coming from l two to l one. So until you are able to finalize the state on l one, you won't be able to use the message on l one, but on l two, you are still able to continue execute transactions with some minor trust assumption until the congestion will be solved.
00:51:23.470 - 00:51:35.760, Speaker A: Sure, that makes sense. So how final are things on l two then on the actual roll up? And how quickly does that happen?
00:51:37.090 - 00:52:41.426, Speaker B: So, confirmations from the sequencer are instant and they have their own trust assumption, especially in the first phase, we have one sequencer. What we plan to have is actually to have Fes checkpoints on l two, which means that checkpoints on l two will happen, I don't know, every 15 seconds, something like that. And they will be backed by a validity proof that won't be published on l one. So USA full node will be able to say, okay, I know this state is final. I saw a commitment to it on l one. And I also can verify on l two a proof that says okay, this state is actually correct. And then once every, I don't know, it depends on many things, but it can be once every ten minutes, one every 1 hour, you aggregate all those checkpoints and generate one very big proof to it and send it on l one.
00:52:41.426 - 00:53:11.610, Speaker B: Right. So you on l two can still have trustless finality and everything can operate. But the actual final finality on l one can happen in bigger intervals and so provide greater scalability. But currently, as I've said, right now it's a hosted service, it's an alpha. Okay.
00:53:11.760 - 00:53:12.460, Speaker C: Yeah.
00:53:13.870 - 00:53:47.254, Speaker B: Joey asked, is the l two going to be decentralized? What is the reward for people running l two nodes? Basically trying to get an idea of the potential transaction cost. So yeah, it will be decentralized. Anyone will be able to run full node and anyone will be able to be a sequencer. Sequencer is a node which is equivalent to a minor. So it is responsible to sequence the transactions, generate a proof to them, and then send it to l one. And the reward will be transaction fees. Right.
00:53:47.254 - 00:54:33.830, Speaker B: So people will, you can batch, I don't know, 100k transactions in a proof, so you get fees for those transactions. And right now the leader election mechanism, or what is the decentralization mechanism for the sequencer level is in heavy research, we have few candidates for solutions, but basically there will be some kind of mechanism that people are competing for the privilege of being a sequencer and being able to post blocks on l one in a specific time frame. I hope that answers okay. Sorry, Alon.
00:54:34.490 - 00:55:11.090, Speaker C: It's okay. Okay, so we finished reviewing our first simple starknet contract. Now, you might have noticed parts of the code that might have not been so clear because they're very unique to the Cairo language and I want to very briefly discuss them. So first up is felt. So you might have noticed some variables like user defined as a felt. So it's just short for field element, which is a basic chiral variable type. For most intents and purposes, it just acts like a regular integer.
00:55:11.090 - 00:56:05.086, Speaker C: It has some weird sort of properties. For example, that negative numbers might look weird, like minus five can be this very large number. But again, for most intensive purposes, you can run computations as if that's a normal integer. Next up is built ins, which I've mentioned very briefly when we're looking at the code. So again, there are modules that implement some non trivial functionality in an efficient way. For Chiro, these functionalities include output hashes and even rain checks, because when you're dealing with finite fields, partial orders are not very well defined. And then you have implicit arguments.
00:56:05.086 - 00:57:17.226, Speaker C: So in some function calls in that file, you may have noticed that functions often had these squarely brackets following them before their arguments, and they contained these pointers like Raincheck pointer here. And these are what we call implicit arguments. Now, the way it was before we had implicit arguments in Cairo is that to use a certain built in like rain check, a user would have to explicitly pass the pointer for that built in to the function, and then return it as output, which made the whole process of writing tyra code a bit more cumbersome than it needed to be. As it stands with implicit arguments, a function call like foo here that uses rain check pointer implicitly can actually just be called like this foo 14, which just uses the x variable here, the x argument. And you don't actually have to think too much about the fact that this function internally uses the rank check pointer. It implicitly passes that argument to the function, and then also implicitly returns it as output and updates the pointer accordingly. Okay, so now we have those basics out of the way.
00:57:17.226 - 00:58:00.818, Speaker C: Let's make things a bit more interesting. So we'll take this sample contract that we've viewed now, and we'll add some better functionality to it. First off, we'll add support for users. So right now all we have is a simple contract that just stores this one balance variable that doesn't really do anything too interesting. So what if we had a balance kept for each individual user? It sounds complicated, but it actually is very simple and certain, and we'll show that in a second. We'll also add support for signature authentication. This is because assuming we're going to have different balances for different users, and then different users will be able to increase their balance accordingly.
00:58:00.818 - 00:58:55.862, Speaker C: We want to make sure that a balance is only increased if the user signed a valid transaction to do so. So we'll then once we have all that implemented, we'll actually sign an increased balance message and send it to the system and see that it works. Note that to sign the message, I've actually used part of the open source library, the Cairo Lang open source library, which you can also download and play around with even today. All right, so I'm going to switch back to the terminal and piece by piece, let's just add, first thing first support for users in our system. So first off we have this balance variable. Now we're just going to add as an argument to this variable user. So one thing that I haven't mentioned about storage variables up until now is that you can actually treat them like a map.
00:58:55.862 - 01:00:11.330, Speaker C: So balance here when we are defining the argument, user will keep a map between a given user and their associated balance given by rescue, which is a nice thing. Now you can make these storage variables simple maps like I'm going to do in this example, but you can also make them much more complicated. You can make them maps from various keys to a single or several values, and you can also have them be maps to maps and so on and so forth. Next up, we're going to change our increase downs function to receive not only an amount as an argument, but also the user that needs the amount changed. Note one thing I forgot to mention is that storage variables implicitly define two functions which are read and write. So we were using read and write, for example, in the increased balance to read the current value and then using write to update it accordingly. So now since we're supporting users in our balance, we need to supply read with the user for which we want to read the current balance, and the user for which we want to change the current balance, which is the same user for increased balance.
01:00:11.330 - 01:00:43.110, Speaker C: Of course we're going to have to change the get balance function as well. Adding the user argument here and also adding it to the balance read here. Okay, so that was step one. This is simply adding users to our code. Now we want to also support signature verification. That's going to add a bit more code to this contract. First off we're going to need the ECDSA built in up here which will allow us to verify ECDSA signatures.
01:00:43.110 - 01:01:35.502, Speaker C: Going to add a few more imports which I'm not going to delve too much into. And then we're going to update, increase balance down here. We'll add the two components of the. Sorry. We're going to add the built in pointer first off as an implicit argument and we're going to add the two components for the signature which are rns that we're going to pass as inputs to this function as well. And internally we're going to add this import that we've brought in which is verify ECBSA signature which basically the first step in this function now will verify that the given message, which is just going to be the amount that we want to add to the user's balance, was validly signed by the giver user. Okay, so now we're just going to save this.
01:01:35.502 - 01:01:56.498, Speaker C: We're going to repeat our steps. So first off we're just going to compile our code. Hopefully we've done nothing wrong.
01:01:56.584 - 01:01:56.882, Speaker B: Okay.
01:01:56.936 - 01:03:00.692, Speaker C: Everything's working accordingly. And we'll use deploy to deploy again to the starknet system. Great. So we have that contract being deployed now we can already start playing. Let's start by doing as before. We'll use the get balance function but this time we need to supply input. So we add the input flag and we're going to supply it with some arbitrary user, let's say 1234-5678 again, I've probably given it the wrong API or of course one thing I forgot to do here is that we've deployed a new contract and I was using this get balance command which was using the address of the old contract.
01:03:00.692 - 01:03:30.064, Speaker C: So I'm taking this new address that was given to me when I deployed the contract, which is here. I'll put it here. And again, as a user actually going to use something different, something that I pre prepared. I'm going to get this number which we'll discuss momentarily why this is important or why I selected this seemingly arbitrary number. Which is it? It is arbitrary. So again this user has zero balance. So let's change that.
01:03:30.064 - 01:04:00.970, Speaker C: We'll use invoke again and we'll make sure we do it correctly by first things first. Changing this address here. Yeah, this contract. Great. And we're going to call increased balance. Now we have four inputs we need to supply, the first being the user we want to change the balance for. So we'll just put this user key that we've created before.
01:04:00.970 - 01:04:33.780, Speaker C: We'll change their balance like we did before with the number 1234 as an amount. And now we need to supply two components, the r and es component of the signature. So I went ahead and again, I used the Cairo lang open source library to generate a signature for a message. Now, note that this message here I'll note now changes it signs on a message. That's 4321. Now, as we mentioned, the message we expect to receive is the changed amount. So the amount we are going to allow to change is 4321.
01:04:33.780 - 01:05:04.552, Speaker C: This is fine. I'll show you a momentarily how this works. But this also generated the two components needed for the signature here. So the first one being r just going to port over and s is given here. We'll put that in. Now, before we start, I'm going to change this command to call instead of invoke. And again, note that I've deliberately sent a transaction that's trying to change the amount differently to what I signed.
01:05:04.552 - 01:05:37.144, Speaker C: I'm just going to call it again because there was a bit of a tomfoolery on my terminal here. Okay, so we got some error. And this is to be expected because this transaction failed. Because I was asking the contract to change this user's balance by 1234. The contract expects to receive an authenticated signature for that message, but the message we've signed doesn't match. So let's do this again, but this time we'll provide the correct amount, which wasn't 1234, but was 4321. And again, I'm using call.
01:05:37.144 - 01:06:15.170, Speaker C: I remind you that using call with increased balance will call the function but will not actively change the state of the contract on chain. Now, again, since we didn't get an error, this indicates that this dry run was successful. So now we're comfortable in going back to this command and changing call to invoke to commit this change. Excellent. So this transaction was sent and let's see if we can already use get balance again on this user. Okay, it's going to take a bit of time for this transaction to process. We'll get back to it shortly and look at it.
01:06:15.170 - 01:07:01.554, Speaker C: Any questions so far specifically about implementation of contracts and the usage of this toolbox? Okay, let's check our transaction status. So I could just roll up and see that this was my transaction to increase balance. Let's see what the state is present. So it's pending. I think that when it's pending, we should be able to use this and see the change. There we go. So 4321 now again, it's already, like Tom mentioned, it's already a change that we can work with.
01:07:01.554 - 01:07:41.470, Speaker C: It just hasn't been verified on l one yet. Once this status changed to accepted on chain, we know that it actually terminated. Excellent. So lastly, going to move back to the slide, I want to talk about layer one to L2 interactions. Everything up so far was great and all, but we were just sort of arbitrarily changing some arbitrary users balances and not doing anything to note work. This is where the layer one to L2 interactions come in. Now, it's a two way street, which we'll go over now.
01:07:41.470 - 01:09:08.380, Speaker C: So it's an interaction between a layer one contract, given here in solidity code, to a L2 starknet contract and vice versa given here in tyro code. So how this interaction works is it's supported by the Startnet operating system. So for the layer one part of the communication, when we want to send a message to L2, we're going to use the starknet core send message to l two method, which receives as input the L2 contract address we want to address and the function we want to call given by a selector which we'll talk about momentarily. This simply indicates that when we address this contract, given by the address here, what function we're looking to execute, and a payload for that function which should include the arguments that function expects to receive. This message is then sent to and triggers this function given on the start of the contract. So we have this new designation, l one handler, which designates that the given function is meant to be called by a layer one interaction. The function foo here gets a selector generated based on its name as soon as you have the layer one designation, and that's the selector that we should provide when we send message to l two here.
01:09:08.380 - 01:10:30.398, Speaker C: On the other hand, if we want to send messages from L2 back to layer one, so we have for example here the function bar on our contract. This function will use the send message to l one function which as input receives the layer one contract address we want to contact, as well as the payload, which is the information you want to pass, and very importantly, the size of the payload beforehand. Now back to the layer one aspect of this interaction. A layer one contract that expects to receive information from L2 uses the starknet core consume message from l two method. So messages that are sent to l one just are stored on this dedicated contract we have on layer one, and they're basically pending there to be consumed by a given solidity contract on layer one, whose address matches this l one contract address here. So again, in this case here, the consume message from l two will designate the source of the message we accept to receive and then takes that payload from that message. Okay, so now I want to dive back into the code and move on to this contract here.
01:10:30.398 - 01:11:22.866, Speaker C: This contract implements the same contract that we've seen before with some layer one and L2 interactions added in. So to that end, we've added two new functions to this contract. We've added withdraw, which allows the user to take assets that they own on L2 and withdraw them back to layer one. We will then see that once they've executed this function, they are able to then go to the actual contract, the example contract that we have deployed, and withdraw these funds. This is just on ropes and we're not actually breaking anything. It's fake monopoly money for all intents and purposes. The second function we implement is deposit here, which is tagged as a layer one handler.
01:11:22.866 - 01:12:36.410, Speaker C: And this function will allow a user to deposit funds, or rather deposit funds that they've locked on layer one into L2 to increase their balance accordingly. So as you see in this function implementation, assuming everything went well, we are able to write the new balance to this user that responsibly. Okay, so given that this contract requires layer one to L2 interactions, we can't actually use some of these functions until the contract is accepted on chain. So I went ahead in advance and already deployed this contract in the separate terminal here in order for me to be able to interact with it. So first things first, I'm going to use this withdrawal transaction. Sorry, before we use this withdrawal transaction, I should say we want to make sure that a user has money to withdraw from our system. So to that end, let's invoke increased balance.
01:12:36.410 - 01:13:24.890, Speaker C: Okay, I'm just going to take this over to the next window. We'll take some user. So first off, before I forget, we're going to change this contract address to our freshly deployed contract. So our contract is deployed here. The ABI is l one, l two Abi Json, which I produced beforehand, we're calling prestowns. And the user will interact with will be 123-4567 let's just use this. Okay, let's see the balance for this user just to make sure we have some funds to withdraw from this contract.
01:13:24.890 - 01:13:55.074, Speaker C: Great. So we have some funds that we can withdraw. So I'm just going to invoke the withdraw transaction. Just making sure I have everything correct. We're going to withdraw from user 1234-5678 let's say 1000 tokens. Okay, so we've had the invoke transaction sent. Now again, I've already done this in advance.
01:13:55.074 - 01:14:57.926, Speaker C: I've just shown you how this is done. I'm going to go back to my browser and you'll note that on etherscan you can actually see on the Ropeston testnet we have this contract here which is the solidity contract we wrote to demonstrate this example. Now we actually have the code available for us here. It's a very simple contract that implements on its end withdraw and deposits amongst other things. But what withdraw does, accordingly, I remind you, withdraw from L2 was this function here that allowed the user to decrease their current balance and withdraw their funds from layer one. And accordingly this withdraw function from our solidity contract invokes the sharpness core consume message function to receive that payload. Likewise the deposit function here which locks users tokens on the contract and then adds to their balance.
01:14:57.926 - 01:15:37.700, Speaker C: On L2 we'll invoke the starnet core, send message to l two and pass as input the deposit function selector so we know we're calling the correct function. So again, back to our contract on Etherscan, let's withdraw our funds. So I have this metamask wallet set up here which I'm not popping up for me at the moment. It's connected. Okay. It's a bit slow, but hopefully it'll pop up. Okay.
01:15:38.150 - 01:15:39.730, Speaker B: Seems like it's connected.
01:15:40.230 - 01:16:09.322, Speaker C: It's connected, but I just wanted to show the difference in mouse. But it's not the most important part of this demonstration so we'll skip it for now. We pass as input the L2 contract address. We pass the user that we executed the withdraw for and we'll pass the amount that we want to withdraw. Oh, there we go. Now it pops up. And there we go we have this window pop up that asks me to confirm this withdrawal transaction.
01:16:09.322 - 01:16:21.398, Speaker C: Hit accept. And again. Now I don't think we'll be able to see that comfortably. Oh, there we go. Now my balance has increased accordingly. Now again, this is just rope city. I haven't actually cheated the system.
01:16:21.398 - 01:16:31.320, Speaker C: Okay, so let's review this interaction on the opposite. So I can go up here to the deposit function.
01:16:32.490 - 01:16:38.940, Speaker B: One moment. Yes, Peter? Just making sure that we're okay on.
01:16:40.750 - 01:16:49.326, Speaker A: Yeah, yeah, I think just keep on going. It's very interesting to see. And it sounds like you're heading towards the end anyway, so it's all good.
01:16:49.428 - 01:17:42.990, Speaker C: Yeah. Okay, great. We're just on the verge of finishing so I won't delve too deep into deposit, but there we go. If I hit deposit here, I can confirm this transaction as well. And eventually what we're going to see is that this deposit transaction will be accepted on the L2 blockchain and we will then see that the user's bound increased according to the amount that I deposited in this case, 600. Okay, so this concludes our layer one, L2 interactions. It's a great way of implementing things like token bridges that allow you to transfer tokens back and forth between layer one and L2, amongst many, many other things.
01:17:42.990 - 01:18:23.674, Speaker C: Okay, before we depart, I just want to reiterate and mention that this example and many, many more are all available in the startnet documentation. We maintain an ever expanding resource library that you can find. If you visit ww cairo lang.org, you can find our full documentation, the links to open source libraries, videos and the Cairo playground, and many more there. Also, we have an ever expanding community of developers, so we invite you to join our discord today. We look forward to seeing you there. And that concludes our talk.
01:18:23.674 - 01:18:24.700, Speaker C: Any questions?
01:18:29.730 - 01:18:43.540, Speaker B: Yeah, now it's time for questions both on the demonstration, on my presentation, and anything else. How's the COVID situation in Israel? Whatever you want for.
01:18:48.380 - 01:19:12.610, Speaker A: The contract emits an event. Who monitors for that event? When you've got multiple sequences, how do you work out? How does that happen? How does that transfer happen? And could you do some deposit something event getting emitted and could you be censored in some way?
01:19:14.100 - 01:20:18.032, Speaker B: Yes, very good question. So first of all, at the first phase there is one sequencer, so there is no problem of who's picking it up. I think the main problem is how do you incentivize it, right. How do you make sure that transferring your message also includes some fee? So it is not yet implemented, but there will be a fee mechanism in which sending the message to l one or sending the message to l two also includes some fee for the sequencer. And the second question was, sorry. From censorship point of view, the protocol does not enforce serving a message. And of course when you have a single sequencer, you are prone to censorship.
01:20:18.032 - 01:20:40.700, Speaker B: There are ways to ensure self custody, but when we have decentralized sequencer level, then the same way that transactions are getting included in the blocks, then we assume transactions will be included in, I mean, messages from l one will be included in blocks because again, they contain fee.
01:20:43.520 - 01:20:44.990, Speaker A: Okay, that makes sense.
01:20:45.700 - 01:21:03.380, Speaker B: Yeah. For example, when we implement the token bridge, a deposit message will also be, if it was not served for, I think, some time period. I think it's a day, then you can cancel it and reclaim your funds.
01:21:07.750 - 01:21:31.270, Speaker A: All right, that makes sense. Okay. Anyway, I'll have a look at the process more. Does anyone have any other questions? All right, well, look, thank you both for doing a fabulous talk. Very much appreciated. So thank you.
01:21:32.280 - 01:21:35.680, Speaker B: Thank you very much. It was a pleasure.
01:21:35.840 - 01:21:37.750, Speaker C: Yeah, it was. Thank you.
01:21:38.280 - 01:21:45.320, Speaker A: And I'm going to quickly share on another screen the forthcoming.
01:21:47.020 - 01:21:47.672, Speaker B: Sorry.
01:21:47.806 - 01:21:53.530, Speaker A: Yeah, don't worry, I've got it covered. So hopefully people can see my screen.
01:21:54.620 - 01:21:56.184, Speaker B: Yeah, we can see it.
01:21:56.382 - 01:22:29.140, Speaker A: Okay, so we've got a whole stack of things coming up. So in two weeks, we've got. Bernard Schultz is going to do one on off chain execution. And then we've got the recruitment event. So if you're looking to hire people, that could be a good one. Get in contact with me before the meetup. If you're looking to hire people after that, we're going to be talking bonsai trees and how they are improving the performance of Ethereum.
01:22:29.140 - 01:23:02.850, Speaker A: Rakavendra is going to talk about state expiry, and I'm going to talk about the GPAC ERC crosschain bridge after that. So a packed agenda. And if you're interested in doing a talk, please get in contact. But as you can see, we're pretty much booked to halfway through October already. Yeah. So look, thank you again. That was a really great talk and I'm sure people will have questions, so I'm sure they can reach out to you on LinkedIn or something like that.
01:23:02.850 - 01:23:06.400, Speaker A: I'll put the video up onto YouTube.
01:23:07.140 - 01:23:13.840, Speaker C: In the chat, Naomi already shared links to our discord channels and other valuable resources.
01:23:14.820 - 01:23:15.570, Speaker A: Cool.
01:23:16.420 - 01:23:16.992, Speaker C: Thank you.
01:23:17.046 - 01:23:23.492, Speaker A: All right, well, thank you again, everyone, and thank you guys for presenting. And talk to everyone later. Bye bye.
01:23:23.636 - 01:23:28.260, Speaker C: Thanks very much. Bye, everyone. Good day. Thank you. Bye.
