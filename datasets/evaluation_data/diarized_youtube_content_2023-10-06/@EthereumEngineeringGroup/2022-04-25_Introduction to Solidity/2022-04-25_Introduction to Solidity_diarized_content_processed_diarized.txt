00:00:00.650 - 00:00:12.000, Speaker A: All right, we are live. We have zero people on the channel, which is very nice. People want to.
00:00:12.850 - 00:00:13.454, Speaker B: So.
00:00:13.572 - 00:00:29.480, Speaker A: Hello, everyone, for the recording. This is the engineering group meetup, and Lucas is going to talk about solidity. We're about ten minutes before the meetup starts, so you might want to skip the video to for about another ten minutes.
00:00:33.610 - 00:00:34.390, Speaker B: That's.
00:00:38.010 - 00:00:38.760, Speaker C: Never.
00:00:42.810 - 00:00:43.560, Speaker D: Yeah.
00:00:49.610 - 00:00:51.120, Speaker C: But not.
00:01:05.650 - 00:01:06.254, Speaker D: Yeah.
00:01:06.372 - 00:01:07.470, Speaker A: Really busy.
00:01:12.130 - 00:01:13.280, Speaker D: Yeah, you're right.
00:01:13.810 - 00:01:15.640, Speaker B: How's your stuff going to stuff.
00:01:17.930 - 00:01:18.920, Speaker C: Lots of.
00:01:25.370 - 00:01:28.214, Speaker E: Get this up and get this up higher.
00:01:28.332 - 00:01:29.000, Speaker B: Yeah.
00:01:38.730 - 00:02:38.480, Speaker D: Really inquisitive supply. Yeah. I'm writing a paper and it's like, how.
00:02:47.330 - 00:02:48.286, Speaker A: Can I show this up?
00:02:48.308 - 00:02:54.400, Speaker D: Yeah. And, yes, I do. Yeah.
00:03:19.890 - 00:03:31.280, Speaker A: Help, but, yeah, but we can not do.
00:03:35.170 - 00:03:39.280, Speaker B: Yeah, yeah.
00:03:43.810 - 00:04:02.200, Speaker D: But, but, yeah, I think actually.
00:04:08.250 - 00:04:10.280, Speaker A: And then there's another one just.
00:05:02.160 - 00:05:02.910, Speaker D: Yeah.
00:05:14.610 - 00:05:18.720, Speaker A: We'Ll also live stream audio quality. So.
00:05:22.210 - 00:05:22.960, Speaker D: Yeah.
00:05:29.850 - 00:05:32.440, Speaker A: Yeah, it's amazing.
00:05:33.930 - 00:05:34.680, Speaker D: Yeah.
00:05:40.650 - 00:05:50.760, Speaker A: Do you want, you know, live stream, just say sure. And then, you know, like from what.
00:06:20.090 - 00:06:20.840, Speaker E: Yeah.
00:07:10.570 - 00:07:11.910, Speaker A: Take your advice.
00:07:22.170 - 00:07:22.920, Speaker B: Is.
00:07:29.370 - 00:07:32.840, Speaker E: And those teams need.
00:07:34.770 - 00:07:35.790, Speaker A: Maximize.
00:07:46.610 - 00:07:47.454, Speaker E: Yeah.
00:07:47.652 - 00:07:48.880, Speaker B: For every one.
00:07:50.690 - 00:07:52.510, Speaker C: But obviously good compliance.
00:07:57.490 - 00:07:59.022, Speaker A: So, Lucas, are you ready to go?
00:07:59.076 - 00:08:16.620, Speaker B: Yeah. Fix. Know what about.
00:08:22.190 - 00:08:23.210, Speaker E: You can get to.
00:08:23.280 - 00:08:28.750, Speaker A: Google Drive, then you can get engineering.
00:08:32.450 - 00:08:33.200, Speaker B: Okay.
00:08:35.730 - 00:08:36.542, Speaker A: Yeah. Right.
00:08:36.596 - 00:08:37.600, Speaker B: Looks good.
00:08:38.850 - 00:09:07.626, Speaker A: And present. Okay. Hello and welcome, everyone. Welcome to another fun packed Ethereum engineering group meetup. With us today. We've got Lucas Cullen, a solidity guru who also runs bitcoin and blockchain meetup and works at consensus and knows all sorts of stuff. So I'll hand it over to you.
00:09:07.808 - 00:09:45.510, Speaker E: All right, thanks, Pete. Yeah, a few familiar faces. All right, so today is, as it says, introduction to solidity. So I'm going to do a bit more code solidity by example, a little bit less slides. So I guess the opening is, what is solidity? I stole this from pete sludge, the first one. So, high level language which compiles down to these bytecodes. So when we had Rob Dawson's talk, he mentioned about the op codes, et cetera, in the Ethereum VM.
00:09:45.510 - 00:09:56.614, Speaker E: So for me, this is my take on solidity. The fun language is up the top, and for me, solidity sits down there a little bit above objective C and a visual basic.
00:09:56.662 - 00:09:57.660, Speaker B: Not by much.
00:09:58.990 - 00:10:57.962, Speaker E: So I'll point out what you can do and I'll point out what you can't do. And hopefully, if we will watch the language evolve, then you'll get to up to speed and be on point for my example today is what I want to build in the next. I think we got 40 minutes is to build an Uber replacement on a blockchain. So we think about why use a blockchain? It always comes up, why should we use a blockchain? Why should we use these smart contracts? And it's really to, I guess, get rid of the middleman. So we think around Uber and we can create contracts between a rider and a driver. Then we should ask the question, why do we need this Uber middleman? So like I said, today's demo, we're trying to build that and show some of the features of the language as we go. So let's consider, I guess it's kind of the requirements for a ride share scenario.
00:10:57.962 - 00:11:37.306, Speaker E: So we should be able to make these peer to peer markets between rider and driver. The rider perhaps can request to be picked up at a location and dropped off. Drivers could then query the blockchain and say, yeah, I want to accept that fare. We can then use, if we have Ethereum based currencies or digital tokens, we can lock up those funds in smart contracts and then we could use something like the commit reveal schema to ensure that this can't be gamed. So the idea is you could perhaps put in a ride request with some kind of key or.
00:11:37.328 - 00:11:37.802, Speaker B: Good.
00:11:37.936 - 00:12:07.762, Speaker E: Once the driver gets there and drops you off at the end, you could then pass on the hash of that and release the funds to try and stop. So there has to be some physical exchange or some information exchange that's off chain to make sure that event actually happened. It's very hard to assert, did this ride happen without know all data, GPS, et cetera, can be faked in. So I'm going to try and switch between slides. So slides and visual studio code.
00:12:07.816 - 00:12:09.140, Speaker B: So we'll see how we go.
00:12:11.830 - 00:12:50.206, Speaker E: All right, so who here has used visual studio code or something else to write solidity? So, pretty familiar. Okay, so for those who haven't, there's Microsoft product visual studio code, which looks like this guy. And if you want to start to get into solidity, we add these extensions and there's a consensus guy, Juan Blanco, he wrote the solidity extension. So just install that guy from Juan Blanco and then you'll be away. So that's really all you need to get up and running the smart contracts.
00:12:50.398 - 00:12:51.140, Speaker B: So.
00:12:52.870 - 00:12:54.706, Speaker E: First off, can we all see.
00:12:54.728 - 00:12:55.300, Speaker B: That.
00:13:00.070 - 00:13:03.700, Speaker A: Zoom is down the bottom problem?
00:13:08.570 - 00:13:11.160, Speaker E: All right, so can I see that? Is that good enough?
00:13:11.530 - 00:13:12.680, Speaker B: A bit more.
00:13:17.310 - 00:13:35.306, Speaker E: Okay, so we start off with our pragma, the intellisense complete setup. We got the extension and what we're just saying is identifying what version of solidity we want. It's actually, that's the current, but I've only got Solidity 23 on here. So I'll just put in that guy and then we just start our contract.
00:13:35.338 - 00:13:36.350, Speaker B: Which is kind of like a class.
00:13:36.420 - 00:14:13.382, Speaker E: Or I think more like a table or a store procedure. And I'm going to call this guy share. Pretty simple. So next thing we've got is your data types. So what data types does solidity have? We have your integers, unsigned and signed integers. We don't have decimals or floats, which I'll demonstrate some of the limitations. We have addresses which can be the Ethereum address you're paying to or the actual address of the contract.
00:14:13.382 - 00:14:25.822, Speaker E: We have bytes which are documented, just bytes. We can store hashes, et cetera, in them and booleans. And we also have the idea of structs which like other languages, java, et cetera, just hold data.
00:14:25.876 - 00:14:27.586, Speaker B: So what I'm going to do now.
00:14:27.608 - 00:14:29.460, Speaker E: Is just create a struct for our.
00:14:31.190 - 00:14:40.358, Speaker B: Right share so we can just call it ride request. Okay.
00:14:40.524 - 00:14:42.274, Speaker E: And then in here I'm going to have some properties.
00:14:42.322 - 00:15:09.162, Speaker B: So I'm going to have un to. So we want to lat and long. You went from lats and you went long.
00:15:09.216 - 00:15:57.690, Speaker E: All right, so what I'm going to do there is in this struct, I'm going to hold the data where when we make a request to the blockchain, we're going to store that in where we want to get picked up. So the other thing we can do with solidity is also have enumerations just like other languages. So I'm going to create an enum to basically go through the state. So when I make a request to the blockchain, it's like waiting for a ride. The driver accepts it, perhaps riding and perhaps completed. So simply we can just put in here Enum intellisense gives us some hints and then we can just, like I said, whatever I mentioned waiting.
00:16:01.010 - 00:16:04.510, Speaker B: And we're doing with commas, not thingos.
00:16:08.770 - 00:16:21.490, Speaker E: Also writing and complete now up in this guy here, we also then want to give it, give it the state and our struct. So we can just do, we can now use that enum.
00:16:28.270 - 00:16:32.620, Speaker B: And away we go. Maybe.
00:16:36.750 - 00:16:37.690, Speaker A: Txt.
00:16:38.750 - 00:16:40.140, Speaker B: There we go. Cool.
00:16:41.470 - 00:17:24.534, Speaker E: All right, so pretty straightforward. So what we're going to do is hold the state of as you go through your journey. So the next part, and as we go through we'll bring into some of the other data types of boolean, et cetera, but there you can just see some basic data types there. So the next part when we write a contract is we want to input data. So there's basically a few different ways we can add data. One way we should say functions, but functions can have, there's basically three different types of functions. We can have functions that change the state of the blockchain, which will cost gas to write to the change, write a state, change to the blockchain.
00:17:24.534 - 00:18:13.130, Speaker E: We can have views which can read data from the contract, but do not change the state of the contract. And I'll show you a good reason why we want to do that. And the next one that you just brought out in about solidity 20 off memory 4.20 is pure functions. So if you come from JavaScript, you might know these pure functions, which are just computational functions where they don't actually read any state or any data off the, off the chain. So if we think with respect to our ride share, maybe a good way to determine the price is just maybe use even pythagoras, a squared plus B squared equals C squared. And I'll show some limitations of that as well to try and get a quote.
00:18:13.130 - 00:18:26.334, Speaker E: So like I said, we want to jump into our, perhaps we want to open our app, we want to get a quote, we put it in, we don't want to consume gas. So we can just make a function that's a pure function. And away we go.
00:18:26.372 - 00:18:28.510, Speaker B: So function quote.
00:18:33.110 - 00:18:42.822, Speaker E: Now we also have scope. Public is, as it mentions, can be seen by everyone. But I'll talk a bit more in.
00:18:42.876 - 00:18:44.294, Speaker B: Scope at a moment.
00:18:44.412 - 00:18:54.142, Speaker E: And we can have returns which we give a data type at. Okay, so then we can simply put in here our param.
00:18:54.226 - 00:19:10.156, Speaker B: So I won't spell it out. So X, pull it, something like that. Right?
00:19:10.178 - 00:19:27.210, Speaker E: So they're going to be our two coordinates. And then what else we can do for a little bit more abstraction. Perhaps we can make a struct of location and we could put in there.
00:19:29.600 - 00:19:31.468, Speaker B: Something like that to make it a.
00:19:31.474 - 00:19:42.192, Speaker E: Little bit more abstract. And then obviously we can have in this struct down here, we could have a location that are un, just to make it a little bit cleaner if we wanted to.
00:19:42.246 - 00:20:03.476, Speaker B: So just to perhaps save some time, get that guy there. Just what I've done. All right, so you can see where.
00:20:03.498 - 00:20:11.764, Speaker E: We'Re going with this. To calculate the price, we just want to do, say the delta.
00:20:11.812 - 00:20:18.520, Speaker B: So we can say delta.
00:20:21.120 - 00:20:23.768, Speaker E: This is where we can start to do about basic math operations.
00:20:23.864 - 00:20:37.990, Speaker B: So say x.
00:20:40.760 - 00:21:07.660, Speaker E: All right, so what I'm doing there is trying to get the delta between the two points. Then maybe use pythagoras to work out the length of the hypotenuse, for example. Now we can see some of the problems here. These are Ints, not decimals. So we're going to have some problems there. The other thing we notice is in solidity we don't have a math absolute. So you'd have to cater for those kind of scenarios.
00:21:07.660 - 00:21:29.196, Speaker E: Obviously we want the absolute delta between them. This would probably go into some negatives. If these are ints, then things could go wrong. So what I'm going to do now is create that location guy's.
00:21:29.228 - 00:21:35.110, Speaker B: Call it the long, sorry, call it two.
00:21:37.000 - 00:22:02.140, Speaker E: Okay, so what I'm going to say here now is I want to create that location struct and I'll show you how to create how to new up a new struct. Basically all you do is you don't use a new keyword. You just call the r struct and you pass in the parameters in order. So we got long as top lat as the second one. And you can actually do name parameters if you like. But for this example, we won't bother.
00:22:04.400 - 00:22:04.812, Speaker B: Right?
00:22:04.866 - 00:22:37.530, Speaker E: So then we just create a new location object. Now we got a few squiggles here. The squiggles are saying that I haven't used this guy yet. And the other one here is to say that this should be of a memory type because I don't want to actually write this guy to the blockchain because what I'm going to do is just use it in memory. So what I can do to get rid of that guy, it's just like a pointer in C plus. Plus is use that memory keyword. And now it's going to complain because I haven't used that car yet as well.
00:22:37.530 - 00:22:43.950, Speaker E: Okay, so just to speed things up.
00:22:44.480 - 00:22:50.670, Speaker B: Here'S one we've done earlier, a little bit better typed. Okay.
00:22:54.160 - 00:22:55.264, Speaker E: So away we go.
00:22:55.302 - 00:23:04.530, Speaker B: So the other things we'll note, I'll get rid of this guy for the moment that comes next is.
00:23:09.720 - 00:23:14.244, Speaker E: We can do squared with the double asterisk to.
00:23:14.282 - 00:23:16.096, Speaker B: Two if we want to do squared.
00:23:16.128 - 00:23:49.744, Speaker E: But we'll just do multiplication like that. So we can use the math operators, plus, minus, et cetera. And you got to look at rounding, et cetera, and errors. So there's a library where you can use math to try and make some of these a little bit safer. So next thing we note is if we get rid of this guy here, that the contract will say that we can actually make it a pure method because we're not actually writing anything to the chain. We're only doing this in computation, math here. So we can make that better by.
00:23:49.782 - 00:23:51.900, Speaker B: Writing a pure method.
00:23:51.980 - 00:24:05.556, Speaker E: So then we return that guy there. Now we've got a casting problem here. So with solidity, we can also just cast via, same as like some other languages like C sharp, and we can.
00:24:05.578 - 00:24:20.710, Speaker B: Just cast our object like that. Not sure where you're complaining. Yeah.
00:24:22.320 - 00:24:28.876, Speaker E: All right, so we can do a simple math operation. Now we can try and get a quote. As I mentioned, this is free to.
00:24:28.898 - 00:24:30.168, Speaker B: Read off the blockchain.
00:24:30.264 - 00:25:09.690, Speaker E: So we can call the EVM and keep getting data off it with some simple math operations. As we pointed out, there's a few limitations with the math. So you can't do two crazy things at the moment. So there aren't functions like absolute, there's no function like square root, there's no trig functions, and there's no constants like e, PI, et cetera. So to actually calculate a correct distance, calculating the curvature of the earth, you need to use like your arc sign of that. So to do something like that is very hard in solidity. So you need to be thinking about that when you write your code.
00:25:09.690 - 00:25:54.730, Speaker E: Okay, so we'll move along some other system style, variables or values, and we'll introduce them into the smart contract. Now is date times, block heights, and time functions. The EVM has hash functions, both sha two and was it whatever shaftry. And I'll show you how we can use them in a minute. So, with respect to our application, when a driver requests a ride, we might want to put a timestamp in. We maybe have a limitation on the way that this ride is available. So we might expire in 30 minutes.
00:25:54.730 - 00:26:26.210, Speaker E: Like I said, we're going to extend our contract to have a shared secret and doing it just as another thing, limitations again, that date parts can be tricky. So if you have to do all timestamps are in the epoch stuff, epoch times. So if you ever have to do, say, starts on Monday or the 1 June, it can be very complicated to do so. To show that example, we'll do a request write function.
00:26:39.900 - 00:26:46.650, Speaker B: This is going to be a function because it's going to actually write to the chain in a minute, make it public.
00:26:50.140 - 00:27:12.256, Speaker E: So functions can also call other functions. So we already have our quote function to get the value. But what we also might do is we need a price per kilometer. So solidity also has the idea of constants. Although with Uber, that ride, was it.
00:27:12.278 - 00:27:13.650, Speaker B: The load, what's it called?
00:27:16.420 - 00:27:23.032, Speaker E: That can price, so that can have that surcharge. But for this demo, we'll just call it or make it a constant just to show that constants can be done.
00:27:23.086 - 00:27:28.410, Speaker B: So actually.
00:27:35.710 - 00:27:37.114, Speaker E: We might make it infinity.
00:27:37.162 - 00:27:47.760, Speaker B: So just go here and probably might go here. Okay, so.
00:27:50.370 - 00:28:03.682, Speaker E: Remember back to our size. The other system values here we can have is gas and ethereum. So what I'm going to say in my contract here is this ride is based in 100 Finney.
00:28:03.826 - 00:28:04.182, Speaker B: Okay?
00:28:04.236 - 00:28:06.774, Speaker E: So we could use other values like.
00:28:06.812 - 00:28:11.830, Speaker B: Ether, sabo, et cetera.
00:28:12.330 - 00:28:29.114, Speaker E: But for this example, we use Finney. So to stop our contract being abused, we could make it check that the user has enough funds to be able to actually book this ride.
00:28:29.162 - 00:28:34.606, Speaker B: So we could have, say amount cost.
00:28:34.708 - 00:28:36.990, Speaker E: Again, we can call our quote function.
00:28:37.060 - 00:28:51.710, Speaker B: There'S no point doing it twice. Copy this guy here. Okay, so we've got our quote up.
00:28:51.720 - 00:28:53.174, Speaker E: The top, so we can call that guy there.
00:28:53.212 - 00:28:53.766, Speaker B: Get it?
00:28:53.868 - 00:29:24.986, Speaker E: Now what we can do is if we make the function actually payable so it can receive ether, so we can decorate that function with the payable method. Then when we hit this guy here, we can get the system value, message value, which is the amount in Sabo, what's the small waste?
00:29:25.018 - 00:29:25.646, Speaker B: That's it.
00:29:25.748 - 00:30:27.694, Speaker E: And we can make sure that the user then has enough funds to actually book this ride again to stop the dossing of the contract. We can also now with solidity we can have, if we don't want to use require, we can use revert with reason. So we can actually put in now a message to say, for example, so we can get some feedback as to why the contract failed. So once we've got that, and we've got past that line, so the user or the right has, they've done their quote, now they want to book it. We need somewhere to store the data to the blockchain. So with solidity we have two, I guess, collection types. We have maps and arrays, so arrays like JavaScript, and other types of arrays where we can iterate through them with an iterator.
00:30:27.694 - 00:30:59.666, Speaker E: And we can have a property of dot length to get the end of the array. And we have mappings which are more like a key value pair, so we can assign a unique identifier to that object or to that collection to get it back. So that sometimes creates a problem. Sometimes you need to have both. You can't iterate through a mapping, so sometimes you need to have both, which is kind of an anti pattern, I guess. But that's the limitation of the system. So with respect to this, we may have a set of rides.
00:30:59.666 - 00:31:13.220, Speaker E: We then might assign them to the user via their key, and then we might iterate through them to do some interesting stuff like perhaps history or calculator rating. So to book this guy here.
00:31:15.030 - 00:31:15.346, Speaker B: We.
00:31:15.368 - 00:31:17.938, Speaker E: Just need to do an array, which.
00:31:18.104 - 00:31:21.794, Speaker B: Of our state here, ride request, put.
00:31:21.832 - 00:31:22.946, Speaker E: It up here so we can see.
00:31:22.968 - 00:31:32.150, Speaker B: It, which is like that for an array. Make it public, we can see it and we'll just call it rides.
00:31:32.970 - 00:31:42.060, Speaker E: Pretty exciting stuff. So down in here we can new up a new ride object.
00:31:42.430 - 00:31:44.140, Speaker B: It's a bit hard to see.
00:31:48.590 - 00:31:58.206, Speaker E: So we just knew up a new ride request. And then like I said, we just have those name parameters or we can just put them in order.
00:31:58.308 - 00:32:18.670, Speaker B: So cut that guy across. All right, so I'll just cut all these guys here.
00:32:24.030 - 00:32:29.878, Speaker E: So we get our coordinates now in the structs, just for brevity.
00:32:30.054 - 00:32:32.720, Speaker B: Then we won't do this guy at the moment.
00:32:33.730 - 00:33:08.294, Speaker E: Then we can just new up a new ride here, as I mentioned, just throw those name parameters. But what we can also do is just use the push function. So this is the collection. So we're just pushing a new ride request into there. I could put that on another line to make it a bit more readable. And we also, in our ride request we want to have the state. So to set that we can just do simply ride request state.
00:33:08.294 - 00:34:01.894, Speaker E: And on this example, I pulled up waiting. Okay, so we can use our enum to create this new object and push it into the collection. So then once that's done, we have the collection of rides where then a driver can come along and pick that up and request it. So as I mentioned before, we might want to do something to just like that commit reveal process. So we can use the sharp function here that to pass in a code that we can show the driver the smart contract will hash it and then it'll push it into the ride request object. And then maybe when the driver and the rider meet, they could do that physical exchange of that secret to assert that the event actually happened.
00:34:02.092 - 00:34:20.390, Speaker B: So I just copy this guy across. Okay, now it get back to loops.
00:34:21.930 - 00:35:03.718, Speaker E: The only other thing we want to mention is how do we monitor the state of the blockchain? And we have what we call events. So if we think like the observer pattern, we can have an application, if it's JavaScript, et cetera, watch for events. That event might be something like a new ride has been added. Our app then is notified and we can display some data. So a driver could sit there and monitor and say, hey, a new request has been put in your area, go and pick them up. So an event is simply just event. And then I like to do kind of the opposite now.
00:35:03.718 - 00:35:09.720, Speaker E: So request, ride, ride requested. And then we can put in here.
00:35:12.570 - 00:35:13.538, Speaker B: Index.
00:35:13.714 - 00:36:03.882, Speaker E: Okay, so then I can pass through to this event to say, hey, a new writer has been added at the index of those collections of rights. So then how we then call that function, we used to just be able to call it like that, but with the new version of Solidity 23, we use the emit keyword. So I'm doing there is calling this guy here to say, hey, raise the notification. As I mentioned before, the rides collection has a property length. So we just want to do length minus one because it's a zero base index to say, hey, this new guy's been added so we can do loops. I'm just going to complete the part.
00:36:03.936 - 00:36:04.540, Speaker B: About.
00:36:06.510 - 00:36:10.170, Speaker E: The driver requesting the driver actually.
00:36:10.320 - 00:36:19.600, Speaker B: Accepting the ride just for, just to complete it quickly. We can just put this guy in.
00:36:20.690 - 00:36:55.706, Speaker E: So it's a pretty simple function. On the other end, we just accept full key and we pass through perhaps the index, and then we're just going to change the state. So as soon as we call this line here, which was that enumerator, we're just changing to the enumerator to accepted. So this is actually changing the state of the blockchain. So that object of ride request in that collection would now be accepted. So we could do some kind of assertions there, whatever, some kind of logic to make sure that we're being picked up. Accept something there.
00:36:55.728 - 00:36:56.554, Speaker D: I don't know.
00:36:56.752 - 00:37:12.100, Speaker E: So that's just a basic simple booking. We could also maybe make it payable so people can't spam and just dos the contract. So you actually have to put down money to accept that ride as a driver. Okay, so.
00:37:13.990 - 00:37:15.202, Speaker B: Up in my other guy.
00:37:15.256 - 00:37:57.038, Speaker E: Here, I also thought with a ride request so I can refactor this struct now to have some other properties in here. So like I mentioned, we can change it to user complex types. And what I might have in here is also a rating. So a reason perhaps to do a loop would be to get the user's rating. So the other collection type we mentioned was mappings. So I haven't got a mapping here. So what I might do is have a mapping where my key is an address.
00:37:57.038 - 00:38:39.290, Speaker E: So that's my rider's ethereum address to a collection of ride requests. And I'll call this history. Okay, so each time a writer makes a request, we can assign it a collection to their actual key. Now to get that out, to make it usable, we'll make a function. Now this will be a constant function or a view because it's not going to change the state of the contract. So we can have something function racing.
00:38:43.310 - 00:38:52.020, Speaker B: A view returns event two, five, six.
00:38:53.270 - 00:38:59.074, Speaker E: So the first thing I want to do is get that collection out based.
00:38:59.112 - 00:39:11.654, Speaker B: On their keyboard history, so that's local history.
00:39:11.852 - 00:39:37.920, Speaker E: And then I make that. Now all I simply do is pass in the key. So up here we've mapped a collection to someone's address and we come back here and we just get that collection based out. Now it's going to complain because I don't have it and I could probably put in memory as well.
00:39:40.290 - 00:39:41.040, Speaker B: Okay.
00:39:45.190 - 00:39:48.594, Speaker E: So now if I can, I can simply do a for loop just.
00:39:48.632 - 00:40:07.350, Speaker B: Like JavaScript I is less than local history length and then we can do.
00:40:07.420 - 00:40:15.738, Speaker E: Your same as JavaScript and other languages. I plus plus so I'm just creating an iterator there, then I might want.
00:40:15.744 - 00:40:24.190, Speaker B: To do something like here's.
00:40:28.210 - 00:40:34.846, Speaker E: Again, same as JavaScript, we can just do like y plus equals plus minus plus multiply plus divide and I can just simply.
00:40:34.878 - 00:40:42.050, Speaker B: Do history, I call it a rating.
00:40:42.470 - 00:40:58.826, Speaker E: Now it's going to complain because of casting where this guy's a un and I think I caught it up there, a un eight because your rating might be one to five. So we can just use a un eight the same size on the blockchain. So we might just want to do again, we can just cast it like.
00:40:58.848 - 00:41:01.306, Speaker B: That if we need to, and then.
00:41:01.328 - 00:41:04.300, Speaker E: We can just simply here return.
00:41:07.330 - 00:41:07.742, Speaker B: Okay.
00:41:07.796 - 00:42:15.986, Speaker E: So we could do something like that and get their rating and it's just complaining because I haven't set the scope. So we obviously want to make that function public. So when a driver comes along hey, what's your rating? So we could down here say have accept ride, we might do something like require, require that user's rating is above some arbitrary value. Okay, so through our process now we've got a quote, we've booked our cab, the riders accepted it, we've been notified of it, the users have put payment in there. So the only other thing to do is to say once we've received the destination, the driver may want to make a request for payment. So the funds have gone into this smart contract, and then I said at the other end the driver might want to say hey, pay me for this fare, I've got the code because we made that exchange, that key exchange, I'll pass it into the contract and I'll show you how to send Ethereum back out.
00:42:16.168 - 00:42:16.900, Speaker B: So.
00:42:19.830 - 00:42:36.422, Speaker A: Lucas, when they were putting the funds into the contract, was that other function which was. So is the amount of money they send across equal to the quote? Or it could be an arbitrary amount. As long as it's bigger than the quote, then the amount that's gone in.
00:42:36.476 - 00:42:36.694, Speaker B: Yeah.
00:42:36.732 - 00:42:56.880, Speaker E: So what Pete said is, how do we stop? Like, the payments come in. There's no real logic in this guy here to make sure it's equal. So we might have to have some kind of if over refund, et cetera. We could extend our ride to say something like cost and.
00:43:04.900 - 00:43:05.616, Speaker B: Like that, or.
00:43:05.638 - 00:43:10.370, Speaker E: Whatever, store it there. But I never like sending back money.
00:43:11.620 - 00:43:13.664, Speaker A: Pays you too much if they've given a tip.
00:43:13.712 - 00:43:14.550, Speaker B: Yeah, exactly.
00:43:15.080 - 00:43:15.984, Speaker E: Treat as a tip.
00:43:16.032 - 00:43:16.630, Speaker B: So.
00:43:22.280 - 00:43:28.264, Speaker E: And then again, we'll just use that same pattern of index of the contract and we'll pass through just as.
00:43:28.302 - 00:43:33.336, Speaker B: A string code public view.
00:43:33.438 - 00:43:34.090, Speaker E: Because.
00:43:35.500 - 00:43:39.630, Speaker B: No, because we're going to change the state of the code. We won't make it as that.
00:43:42.560 - 00:43:43.676, Speaker E: So then here we can get the.
00:43:43.698 - 00:43:49.336, Speaker B: Booking out, which is pretty straightforward.
00:43:49.368 - 00:43:50.504, Speaker E: We can just use the index.
00:43:50.552 - 00:44:08.370, Speaker B: So we can just do. Just copy this guide a lot easier. Right. Okay.
00:44:09.240 - 00:44:49.904, Speaker E: So we can make sure up the top here that we have used to, again use our require keyword. So we get the code that was stored in the smart and the rights collection of that index. We can then create the hash of the code to make sure they match. So the driver says, hey, this is the code I got. It goes through the contract, does the hash, if they match, the code will then proceed back to those system value types. We also have message sender, so we're going to assume the person calling this function is the driver. I guess there could be a gamer where the writer could also know the code and get the funds back.
00:44:49.904 - 00:45:32.190, Speaker E: But for this demo, we won't worry about that. So we get the address as the message sender, and then on the address we simply have a transfer function, which to me is like counterintuitive. I always think it's transferred to, but it's transferred from, but it's transferred to. And then we can just simply get their fee that we stored up in the contract. Or like Pete said, we could perhaps store the whole ETH, et cetera. If we wanted to make an Uber, we could put up in here our own fee. So if we want to deploy this live, we could take our own fee, a percentage or whatever based on the contract, the ride, and make money off this.
00:45:32.190 - 00:45:41.330, Speaker E: So then, yes, that will then send the ether on to the driver and we are pretty much done.
00:45:41.700 - 00:45:49.284, Speaker B: So one more thing. That's the last bit too.
00:45:49.322 - 00:46:20.476, Speaker E: So the only other thing we can do here is what we call modifiers. We go back to our slides modifiers. We can abstract parts of our code to make them reusable. I see them as like, attributes in other languages, like C sharp and Java and Python. We can check for invariants, like require, et cetera. Like I said, I'll make one for is pending.
00:46:20.628 - 00:46:28.650, Speaker B: So we just use the modifier keyword.
00:46:35.390 - 00:46:49.242, Speaker E: The idea is here is to have a bit of code that we could say perhaps on the accept booking. We can only accept the booking if is pending.
00:46:49.386 - 00:46:50.080, Speaker B: Okay.
00:46:50.690 - 00:47:12.882, Speaker E: And we pass through the index. So just to maybe stop having requires everywhere. So you'll see this a fair bit on, like require only owner. Again, try and just encapsulate that logic to do it. I personally don't like this. Viper gets rid of this. So I've been doing a talk on Viper and their reasoning not to do this, but it's in solidity.
00:47:12.946 - 00:47:13.974, Speaker B: So we do it.
00:47:14.092 - 00:47:22.650, Speaker E: So we can now have here, like, just whatever logic we want here. So then require rights.
00:47:27.870 - 00:47:33.120, Speaker B: Equals right state.
00:47:34.930 - 00:48:03.442, Speaker E: Et cetera. So then we put all our logic in here, and then after that guy, that's where the code will continue from there down. So that's basically there where your require sits, or where that. Sorry, that modifier sits. So, like I said, it's just a nice way to extract. All right, that's just about it. So that is like building an Uber app in half an hour, which kind of maybe illustrates the power of smart contracts.
00:48:03.442 - 00:48:35.294, Speaker E: We can hold funds in escrow. We don't need people in the middle to arbitrate those conditions. We might think of ways we can do it ourselves. And as I mentioned before, some of the math functions are hard. So this is the one I wrote on doing your square root function, which isn't nice, but if we want to do that, because if we remember back to our guy here, that's not true, Pythagoras. We need to do the square root of that as well. So how we can then use that guy is with solidity.
00:48:35.294 - 00:49:06.820, Speaker E: We can also have the concept of libraries, which are, I guess, bits of code that aren't contracts, and we can just simply import that into the contract. So just using the import statement. Import statement. So there's a lot of libraries coming out now, and obviously very well tested. I think Pete's got his random number generator one coming in. Watch this space. Maybe disclosed too much.
00:49:06.820 - 00:49:12.740, Speaker E: And then we can just here then use that function in here, wherever it's called.
00:49:16.800 - 00:49:18.110, Speaker B: And away you go.
00:49:19.440 - 00:49:24.584, Speaker E: All right, so that's solidity in a nutshell.
00:49:24.632 - 00:49:25.976, Speaker B: Like I said, building, hopefully.
00:49:26.008 - 00:50:00.760, Speaker E: It's kind of shown you some of the things you can do with smart contracts. Build little decentralized applications that can reduce the use for middlemen or middle people. And then obviously you wire up interface to this. And this is kind of just containing all that logic and the thinking being that contract is the law. So we can read these as codes, as terms and conditions, as opposed to other terms and conditions, and know like the conditions we're getting into when we enter the cap. So that's pretty much it.
00:50:00.830 - 00:50:04.584, Speaker B: I hope that was informative. Any other questions?
00:50:04.782 - 00:50:12.392, Speaker F: Joey, with the memory modifiers variables, they're only for those complex types.
00:50:12.456 - 00:50:22.448, Speaker E: Yeah, I think strings as well, but not the value. Yeah, not the value types, the data types, I think. I'm pretty sure.
00:50:22.614 - 00:50:23.040, Speaker B: Yeah.
00:50:23.110 - 00:50:30.770, Speaker F: And also I think when you're getting the rating memory as well.
00:50:33.380 - 00:50:48.250, Speaker E: So this is one I did like with a bit not on the spot. So this is probably a bit better. So I just got that. The history of the user put it in memory, then iterate round. But yeah, we don't need to because it's an Int. We don't need to put a memory guy in there.
00:50:49.180 - 00:50:55.828, Speaker F: I was going to say for the history, because the history capital H is like a variable in the contract.
00:50:55.924 - 00:50:59.320, Speaker E: Is that this guy here?
00:50:59.470 - 00:51:01.950, Speaker F: No, for the one that you're assigning it.
00:51:02.640 - 00:51:07.096, Speaker E: In this example I made, the convention is to make the public guys uppercase.
00:51:07.208 - 00:51:07.870, Speaker B: Yeah.
00:51:09.040 - 00:51:15.488, Speaker F: So you're using that memory modifier even though you're kind of assigning a value.
00:51:15.654 - 00:51:16.896, Speaker B: For the key that are.
00:51:16.998 - 00:51:33.056, Speaker E: Yeah, you could just do it without. You could call the other guy the mapping directly. But I'm just basically pulling in here for a bit of readability, I guess. And just because I don't want to really. I mean, it's really just a pointer to the other guy. Anyway, I was just wondering, if it's.
00:51:33.088 - 00:51:35.828, Speaker F: A pointer, does it still need the memory one?
00:51:35.914 - 00:52:01.410, Speaker A: If that country is good, I guess. Another question which is possibly related is if you did use just history with the square brackets in the two or three locations you've got there, would that end up generating more EVM code? Or is the solidity compiler smart enough to realize you've just got a pointer, would you end up with more code?
00:52:01.780 - 00:52:02.770, Speaker B: Good question.
00:52:03.380 - 00:52:22.020, Speaker E: So what we can do, if we wanted to, we could put it in this guy here, which is remix. We can compile down and then we could see the op codes if we wanted to. I don't know, the compiler works in a funny way. So I'd be hesitant to give an answer.
00:52:22.170 - 00:52:24.550, Speaker A: Yeah, it'd be something to research.
00:52:25.000 - 00:52:25.844, Speaker B: Yeah.
00:52:26.042 - 00:52:36.072, Speaker E: If you look at the INTs, actually worse int eight are worse than like in two, five, six. So yeah, we could deploy our contract using this. Then we could actually call our quote.
00:52:36.216 - 00:52:39.630, Speaker B: And receive some values back.
00:52:43.280 - 00:52:57.280, Speaker E: And the other thing too, I noticed, is doing that division can be dangerous with rounding. So you need to maybe use safe math or make sure that that's tested well because of underflows and overflows.
00:52:58.820 - 00:53:00.176, Speaker B: Yeah. Any other.
00:53:00.278 - 00:53:46.576, Speaker C: Sven Lucas, maybe you want to mention that one point blockchain programming is very different from standard programming. So if you use any loops, it might work out in any test case. But once you deploy it in reality, then somebody might have 10,000 writes and you would loop in this simple case through all this old writes to simulate reputation. And then it would fail because it would run out of gas. So that's something which is very different to a normal program where it just might take another millisecond. In this case it would actually crash the whole system. It might look nice during testing, but later, if it's in real production, it might break.
00:53:46.758 - 00:54:16.392, Speaker E: Yeah, so that's a good point. Spencer's highlighting that the functions take gas to run, and there's limitations on gas. So when you have big loops and big functions that they can stop halfway through or not run. So you might look at different partitioning ways of your arrays, but it's a good point. And someone might as an attack fill the rides with lots of data just to dos you, given that's in a view.
00:54:16.446 - 00:54:38.512, Speaker A: So if you could construct your code so that you were doing no for loops in your transaction based functions, but just in your view based functions, say that was going to execute and take, I don't know, 1 second to execute, would a local, say, death node, say, look, this view function has just taken too long, I'm sorry, I'm not going to process it.
00:54:38.566 - 00:54:45.940, Speaker E: Would it be happy they don't know until they do it, because it's not like a functional programming language, so they don't know.
00:54:46.010 - 00:54:46.292, Speaker A: Yeah.
00:54:46.346 - 00:54:46.950, Speaker B: Okay.
00:54:47.400 - 00:55:31.540, Speaker E: All right, so that was pretty much it on the demo. So the other things, like I said, there's different scopes of public can be read by the contract, private, internal and external. They're pretty much self explanatory. I did have a look at libraries quickly. You do have the idea of interfaces and multiple inheritance as well, which are just like general other languages. So if you have base classes, et cetera, you can just extend. All right, so the other housekeeping, Pete Robinson down here.
00:55:31.540 - 00:55:52.730, Speaker E: Security, part two. So it's probably going to be a sellout. So make sure RSVP early for that guy. That's our June 13. I'm also doing a talk on Viper, which we'll do later in this series of meetups. So I'm liking Viper a lot more. So come along to that one to see the differences between it.
00:55:52.730 - 00:55:55.528, Speaker E: There's my public key.
00:55:55.694 - 00:55:56.730, Speaker B: Email me.
00:55:58.460 - 00:55:59.530, Speaker E: Thank you very much.
00:56:00.140 - 00:56:07.160, Speaker A: Thank you. Thank you, Lucas.
00:56:07.620 - 00:56:08.370, Speaker B: Great.
00:56:12.340 - 00:56:14.220, Speaker A: See you later, everyone. Who's on the live feed.
