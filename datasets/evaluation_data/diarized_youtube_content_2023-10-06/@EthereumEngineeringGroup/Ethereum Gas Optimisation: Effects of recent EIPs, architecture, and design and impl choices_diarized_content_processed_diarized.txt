00:00:01.290 - 00:00:33.670, Speaker A: Hello and welcome everyone. I'm Peter Robinson, and this is the Ethereum Engineering Group. Meetup. Hello and welcome. So today I'm going to deliver a talk and so I normally get other people to introduce themselves. So I guess I should introduce myself. So I'm a cryptographer, but also worked and cologne design and in the last several years have been working on cross blockchain roll up and sidechain communications protocols.
00:00:33.670 - 00:01:26.950, Speaker A: OK, so I'm going to share my slides. All right, so Joanne, can you give me a thumbs up if you can see them? Cool. All right, let's go. So gas optimization and let's try and work out how we can improve gas usage in Ethereum. So I'm going to talk about a whole lot of stuff, but we're going to start at the basics. And so the basics are that a transaction in Ethereum is 21,000 gas and any code that gets executed over and above this is going to be charged on top. So no matter what you do, you are not going to get below that base gas fee.
00:01:26.950 - 00:02:30.006, Speaker A: And so when code executes, it always starts at offset zero. And so you can think of that first instruction invariably is say push 80. But you know, so you've got bytecode that is actual some opcodes that the EVM can understand and process. And so when you're executing your code, you start off by doing things like setting up the free memory pointer. So that when you're using memory, you know, where you can allocate and you do things like checking if the whole value is zero or not. And hence are you trying to have a payable transaction or not. And so before you've even done anything, you're doing some execution and then you do some code that will say have a look at the function selector, which is a four byte value and try and work out well is the value that's been passed in that function selector.
00:02:30.006 - 00:03:40.260, Speaker A: And if it is, let's jump to that function. And so there's a link I've got at the bottom there where you can get a whole listing of different function selectors that people use. And so you can put in the signature and get the possible functions signatures or you can go the other way as well and give a function signature and then see what the function selector is for that. And so there are obviously many different function signatures that will map to the 132 bit value. But anyway, so you're executing that code. And so that means that even if you have something like this, which is a function that does absolutely nothing, it's still going to cost a bit of gas. So you've got 21,000 for that base gas fee and 253 to essentially just go around the code and set up that free memory pointer and do that if then else let's jump here.
00:03:40.260 - 00:04:52.550, Speaker A: You're burning 253 gas for just getting to the function. And so that's worth keeping in mind of course, if you did want to say, implement everything in assembler, which you could do, then maybe you could say, well, there's only one function in this contract and it does nothing. And so when the first Opcode executes at offset zero, I'm just going to have the Opcode as stop and stop costs nothing. So then transactions to my contract will be only 21,000 gas. So you're obviously going to save a little bit of gas, but then if you're going to write everything and assemble it, it is going to be super complicated. It's a trade off that you're making between complexity of writing the code, analyzing the code, and the probability that you may have bugs in your code compared to writing something in a higher level language. So if the thing you were implementing was super simple, maybe you could do it in assembler and maybe you could save a few hundred gas.
00:04:52.550 - 00:06:01.374, Speaker A: But is it really worth it? So assuming you should assume that you're going to be implementing in solidity, I think so. In recent times there have been some EIPS that have come out that have affected storage costs and account access and refunds. And so these EIPS, which are ethereum improvement proposals, they essentially modify how the underlying platform works. So you've got ERCs, which are essentially ideas for contracts and things that sit on top of the platform, and you've got EIPS that change the platform itself. And so if you look at the recent forks that we've had, you've had Istanbul, which happened back in late 2019, which was all about gas costs really. And then we've had Berlin, which is again, gas costs, and then we've had London, which was the gas market, EIP 1559 refunds. So there were some changes there as well.
00:06:01.374 - 00:07:09.942, Speaker A: And so there's also been a lot related to the difficulty bomb and some related to the beacon chain. So you can see that gas cost changes are things that happen quite regularly. And so in the Berlin fork there was EIP 29 29, which has multiple components to it, and it was really all about getting things ready for stateless. And so the idea is that you have the idea that a storage slot is either warm, so it's being used, or cold and it's never been used. And so if a storage slot is cold, then you need to pay an access fee to access it initially and then after that, any load or store doesn't cost as much. And so that initial access fee is 2100 gas. And so before Berlin your first S load would have been 800, but now it's going to be 2100.
00:07:09.942 - 00:08:09.242, Speaker A: So S load is storage load and subsequent loads would have been 800, whereas after Berlin it's only 100. So this is trying to reflect the idea that once you've got that storage location available, you could have it cached and it's more easier for the EVM implementer to do it. And it's going to be a lower CPU burn for the EVM implementer. And then S store, well, I'm going to put it out there. That S store is really complicated. And so when EIP 2200 came in, which was a pre Berlin fork, EIP, you had this algorithm for working out how much gas should be paid when you're storing a value. And I'm going to work through it.
00:08:09.242 - 00:08:58.582, Speaker A: And so the first if is essentially are you out of gas? So let's forget that. So if the current value equals the new value, so if the value that you've got, so you've got original value is prior to the transaction happening, it's the value of the storage slot, then you do some changes and now to the storage slot. And that's the current value. And the new value is the value that you're planning to store in that storage slot. And so if the current value equals the value that you're going to change to, then it's a no op. So essentially you are only paying for essentially loading up that storage slot to compare it. So an s load gas.
00:08:58.582 - 00:10:21.090, Speaker A: And so as we just heard, that's 800. So if the current value and the new value don't match, then if the original value equals the current value. So in other words, if the value before the transaction equals what we're up to, and so it hasn't been really changed in the whole execution context. And if the original value was zero, so in other words, we're going from zero and now we're setting it to a non zero value, then you're going to have this S store set gas so that's that 20,000 is charged. So if that's not the case, so if you've had the original value was not zero, but the original value equals the current value. So say if it was, I don't know, 35, and then the current value is 35 and now you're going to set it to 36, then what we do is we say, all right, well we're changing it, so we're going to set it and charge 5000. But if on the other hand, the new value we're setting it to is zero, then what we're going to do is we're going to say, hey, we're clearing it, so let's charge that reset value of 5000, but put 15,000 into the refund counter.
00:10:21.090 - 00:11:39.146, Speaker A: And so the idea is this refund counter is something that goes up, whereas the gas that is being used also is going up. So the gas available is going down. And so then we've got, all right, so if the original value doesn't equal the current value, so in other words, the original values was some value, you've changed it in the context and now what you're doing is you're saying, all right, so what are we up to? So the first thing you do is you're going to charge that S load gas so that's 800. And then you've got to see, well, was the original value something other than zero. And then anyway, so you've got more things to go through there and I'll leave it for yourselves to work through all of the possible scenarios. And so we had 820,005 thousand. And so after Berlin, after 29 29, then you've got the initial storage slot, access fee gets put in, plus the reset gas gets set to 2900 and S load is 100.
00:11:39.146 - 00:12:41.040, Speaker A: So this is of course clear as mud as what on earth is going on for everyone. And so I ended up creating a table. So imagine the original value is zero. Wherever you see one, essentially think of it as a non zero value. And if you see two, then it's a non zero value that isn't the same as one or as the other value. And so you can see that essentially if you're going to go from an empty slot to one where you do have a value in it, then it really comes down to, well, is this the initial access or not? And then you end up with that value. And then you can see that if you're changing values, it's all then again going to be either 5000 or 2900, depending on whether it's the initial access.
00:12:41.040 - 00:13:39.970, Speaker A: And then you've also got, if you've got it a certain value and then you're resetting it, then you are going to get that refund. More possibilities here as well. And you can see that in many situations now you're going to be paying much less than if you were pre Berlin. And in particular you can see that, say if the original value was a certain value, you change it and then you set it back. Then after Berlin you might only be paying 100 gas. Or even if you go from you've got an initial value, another value and another value again, then it could be 100 as well. So that's starting to become quite cheap.
00:13:39.970 - 00:14:51.530, Speaker A: So one thing though, that happened was that there was this crowd called Gas Token IO, and they said, hey, this idea that you can get a refund sounds really cool. And that maybe what you could do is you could set some storage locations when the gas price overall is low, and then you could delete those storage locations later on when the gas price is high. And so you could use that as essentially a value storage mechanism and a way to essentially game the system. And so people weren't very happy with this. So EIP 32 98 was proposed, which would have abolished all refunds, but that didn't get up, but 35 29 did. And so 35 29 says that, look, pre London fork, the refunds were capped at 50% of the gas use used. So after London and with this EIP, you're capped at 20%.
00:14:51.530 - 00:15:37.446, Speaker A: So a fifth of the gas used. So it sort of greatly restricts the amount of advantage you could have from something like that. Gas Token so let's have a think about this. So imagine that your say, initial value was zero and then you set the value to one in your contract, you call to Contract B. Contract B then calls back to Contract A and says, hey, what's the value? And then contract day. Then when the Contract B returns, sets the value to zero. And so before Berlin you have 20,000.
00:15:37.446 - 00:16:48.142, Speaker A: And then when you set it, you read the value, it's going to be 800. And then when you set the value to zero, it's going to be 800. However, after Berlin, but before London, you're going to have the 20. You know, you're going to be paying a little bit more for the S store, less for the S load and less for that second S store, and the amount of refund is going to be slightly more. And then after London though, the thing is that now the refund is going to be decreased or the maximum refund you can get and so changes the dynamics a bit. So if you had that value set to a certain value before though, and then things change a bit. So if we look rather than it being 20,000 for that initial S door, it's only 5000 because we're only changing it, but then we are changing it again and we get to pay 5000 the second time too.
00:16:48.142 - 00:17:38.960, Speaker A: So you might notice it was last time it was only 800 that you paid. And so now we're paying if you are setting up value, you pay more. So after between Berlin and London, you're again going to be paying more rather than 100 for that final one, it's 5000. But rather than it being 22,200 for the initial store, you're only paying 5000. So it's sort of cheaper. However, you could also say, well look, let's just assume the storage location is dirty the whole time and then set it in contract day. And so if you do it that way and assume it's always dirty, then you actually end up with the minimum gas cost the whole way through.
00:17:38.960 - 00:18:44.386, Speaker A: Another thing that's changed with EIP 29 29 is account access. So if you go account balance, or if you do a cross contract call and then have to load up the contract if you want to find out the code size or code hash, which are rarer things, but I think the call is the big one. You pay an initial access fee of 2600, but then after you've paid that initial access fee, it's zero. And I've said the call is complicated because it is. The parameters involved in how much get charged for an actual call is super, super complicated. So I'm not even going to try and put it all into one slide. And so EIP 29 29 though breaks things.
00:18:44.386 - 00:19:33.860, Speaker A: And so if you look at this code here, so on the right we've got Contract B, which has got to require that stuff doesn't equal zero. And if it does, then we blow up. So that S load there used to cost 800, but now it costs 2600. So in contract A here, we've got other do stuff, so we're calling that function. And what you can do is you can limit the amount of gas that you're actually passing in to execute the code in contract B. So essentially to execute that do stuff function. And by the way, thank you, Joanne and Harassio, for hunting down the various parts of this.
00:19:33.860 - 00:21:30.282, Speaker A: As far as exactly how this works, you could limit the gas to 1200. And if you did, though, so prior to Berlin, this would have worked because you're only using 800 for the S load, but now after Berlin, you're using 2600. So control lists, which is 29, 30 were introduced. And so the idea of a control list is it's a new transaction type and it allows you to prepay for initial storage access and it aims to fix problems caused by 2029 and also, again, ease the transition to stateless. And so in the access control list, you've got the new transaction type that includes a list of addresses that you're going to touch, and then a list of address and an array of storage locations within an address that you're going to touch and you prepay for them. And so you pay 2400 per account that you're going to access, and 1900 per storage location that you're going to prepay for. If you think about it, then if it's in the access list, then when you do that initial access, you're going to be paying for 2400 plus the 100 access because it's already been accessed now rather than 2600, or you're going to pay 1900 plus 100 or 2100.
00:21:30.282 - 00:22:57.042, Speaker A: So you're going to be able to essentially save 100 gas or 200 gas for account access if they're in the access control list, which is not too bad. However, you're going to need to simulate the contract logic to know whether you're going to what accounts and storage you're going to access. And as well, if you have a storage location that you think you're going to access and then you don't access it, you still pay for it. So there's swings and roundabouts and you could imagine that you have your transaction goes in that you've simulated, but then immediately before your one goes through, another one goes through, that changes the storage locations that you actually access. And in that case, it's going to cost more and it might fail, because now if you had that code there where you're limiting the gas that gets passed in, then your code could fail. Um, another EIP that's come through is 2028. And this is all around making roll ups cheaper.
00:22:57.042 - 00:24:06.826, Speaker A: And so the idea is that with call data, if a byte is zero, then it costs four gas per byte. But if you have a non zero byte, then prior to this EIP, it was 68 gas per byte, but now it's only 16 gas per byte. So it's reducing the cost of using call data and putting information into call data. Okay, so they're the EIPS that have happened recently and their changes. And now I'm going to hit on some architectural considerations. And these are just my ideas, and I'm sure other people have other ideas that are equally valid, too. And so when you think about a contract that you own and you control when you're going to deploy it, so that's definitely something within your control and you're only going to do it once.
00:24:06.826 - 00:25:00.178, Speaker A: Generally, you've probably got some admin functions in the contract, and usually you're going to be able to control when those admin functions need to be called. So say David becomes some administrator person or some important person in the contract. I could say, Look, David, we're going to add you in sometime in the next 48 hours. And I could pick a time that I know is likely to have lower gas costs, but then maybe a hack has happened. And in that case, maybe I need to execute that admin function right now, and in which case I don't control it. So admin functions are probably going to happen rarely. And so the user functions, they're going to be executed by users.
00:25:00.178 - 00:25:41.290, Speaker A: And you don't really control when users call functions. And so you're hoping that they're going to do that often, but maybe they won't. So at this handy little website, they map for your time zone how much gas costs in the week. And so this was, I think, last week. And as you can see, the lighter it is, the cheaper it is. And if it's really dark like it was on 07:00 a.m. Brisbane time on Monday, then it would be super expensive.
00:25:41.290 - 00:26:53.506, Speaker A: And so what you can think about this is that if you live in America, america's afternoon and evening is Brisbane morning. And so you can see that generally it's darker when people in Americas are awake by the time they're heading home or stopping work at 06:00 or so, five or 06:00 in the afternoon. So about seven or 08:00 a.m. Here in Brisbane, then it generally becomes a bit lighter. And then as the people in Europe wake up and start doing things, it becomes busier again. So essentially, having people in Asia Pacific time zones could be a cheap way or at least deploying your contracts then could be good. And obviously on so essentially Saturday night in Americas or Sunday during the day here in Australia is an ideal time.
00:26:53.506 - 00:28:53.650, Speaker A: And so if you're going to deploy a contract which is typically going to cost a lot, deploy it on Sunday afternoon. Australia time deployment happens only once. And so maybe what you could do is you could design your contract so that the actual admin functions and user functions, maybe you could have them so that they're smaller and more compact at the cost of more happening during deployment time. Because if you could have your be deploying at a time when gas is, say, five or ten or even 100 times less than when a user is going to execute a function, then you could be saving a huge amount of gas for the user by just maybe making a bigger contract that has a much cheaper execution for the user. Also you need to think about the admin functions versus the user functions. And so if you look at the code we've got here on the right, you've got this admin function and essentially so forget the fact that there's no authentication everyone, but for the admin function you just pass in an amount and then balance is message sender plus equals to amount and so their balance gets updated. But then in the actual user function you go oh, is the user blocked? And anyway, I think you'll get the idea the actual code here is a bit hokey, but you can see I'm checking blocked and then balance.
00:28:53.650 - 00:30:10.930, Speaker A: So imagine rather than message center if I had checked admin or something like that and so then I guess what I'm trying to say is that if you could do a check in that admin function and then it still applies when the user function is executing, then maybe that's a good thing. Another thing to really think about is what data is stored on chain. And so when you look at the code to the right there and storing bytes, I don't know, what do people think? Does anyone have an opinion on that? From my experience, I think it's worth saving addresses, it's worth to save them bytes if there may be hashes that pack some information to give validity. But beside that, better keep that on a database, it will be far, far cheaper. Yes, exactly, I agree. And so thank you. So bytes are variable lengths.
00:30:10.930 - 00:31:40.650, Speaker A: The amount of storage is going to depend on how long the bytes is. But it means that your cost is going to be variable and say if you're going to store, say 96 bytes, it's going to be a lot. So if you could store the hash of it, it would be much cheaper. And what about this then? Is this good? Or maybe we're going to end up in the same place and say if we could hash it and so at least the gas cost is now fixed and but yes, as Patricio was saying, if we could store a hash so a bytes 32, that is going to be cheaper because you're only using one storage location. All right, now we've got a more complex scenario and I'll give you everyone a few secs to try and think about it. So we've got stuff is a structure and we've got a storage variable struct stuff. And so we set that variable in a function and then we do stuff based on the contents of the structure.
00:31:40.650 - 00:32:34.978, Speaker A: And then later on, we have another function and we check that the values are what we expect they are. And if they are, then we do stuff based on C. And so if you look at that so the struct is passed in both times. But does it need to be stored? If you're saying well look, we require the value to be equal, maybe what you could do is you could calculate the hash of that structure and store that hash of the structure. So now you notice that we're storing the hash of the structure and not the structure itself. So we're only using one location rather than three. And now what we do is in do things.
00:32:34.978 - 00:33:23.440, Speaker A: We have the hash of the structure and we require that the stored hash equals the actual hash. And then we do stuff based on C. So it's a different way of doing things, but it will mean that you're storing only one value and only reading one value rather than three. Yeah, another thing to think about is say authorization. And so you can imagine you've got a system where you've got an admin where you're calling add user and then you've got a user who does stuff. And so maybe you could have a mapping of address to bull. And that has the list of authorized people.
00:33:23.440 - 00:34:30.962, Speaker A: And then you have this add user function where you take the address of a user and you say, all right, that user is authorized. And you set authorized user to true. And then later on you go require to make sure that they're authorized so that storage is going to be 22,000 and the read is going to end up being 2100 as well in do stuff. So another model you could imagine is you could have an admin server that provides access and provides access tokens. And so in this case, you could imagine that you could have, say, an expiry and a signature. And so Admin returns a signature to the user, and then the user submits the signature, the Vcomma, R and S values and an expiry date. And then you could say, all right, well, let's hash this being the contract address, the message sender.
00:34:30.962 - 00:35:51.280, Speaker A: So who's sending the message and the expiry date? And check that the signer of that actually matches the admin. So making sure that it's been validly, signed and then assuming that the token hasn't expired, then you do stuff. And so now rather than having to do that S store in the setting up the user, you don't have to do that and the do stuff rather than the 2100. Now you don't have to do that but you do have to do other things. The admin cost has gone down but the user cost has probably gone up a bit and as well another thing to think through is the decentralization impact of this. So if that admin server dies or goes offline, then the whole system stops. Whereas the previous example the system was all good and so I think that's worth thinking about just even by itself independent of gas costs is the decentralization but yeah, I think trying to think through something like this where you've moved gas costs from one user to another user is an interesting thing to at least think about.
00:35:51.280 - 00:35:55.874, Speaker A: All right memory is another area.
00:35:56.072 - 00:36:12.280, Speaker B: Peter, before you move on, Patricio has a question and he's written it in the chat so he doesn't wake his daughter while sleeping. So I'm going to ask for him, he says, have you seen scenarios where storing a Bloom filter on chain is worth it?
00:36:14.890 - 00:37:43.652, Speaker A: Okay, that is a good question. So a Bloom filter is an array of bits and you do a hash to work out or you work out what is likely. I haven't seen anyone actually storing a Bloom filter on chain so that would be a bit array and the thing is that solidity and the EVM generally isn't a very good bit manipulator, so no, I haven't yet. So ANU yeah, that's correct. You are you're essentially a time based cookie which is very web two, isn't it? Even using the term cookie, it's exactly that. It is far more a web two way of doing things and also I'm not sure about I mean you're assuming you're hoping that the users are going to do stuff regularly. Moving cost from the admin to the user is an interesting one because hopefully calling do stuff regularly does business within your contract and is how you make money.
00:37:43.652 - 00:37:50.570, Speaker A: So if you can make it so that the users feel that your service is easy to use, you're probably going to be better off.
00:37:52.300 - 00:38:21.010, Speaker C: With the admin token there also, as you said, it's not decentralized with the checking the user. Each user controls their own keys in whatever MetaMask or whatever and one user's keys are perfectly secured compared to everyone else's. In this case, if you can crack that admin server you get the master kin you can issue as many tokens for whoever you want to.
00:38:22.980 - 00:38:44.570, Speaker A: Exactly, yes. Although equally though, if we go back one slide yeah, if we go back one few slides here so if on the other hand though, if I crack the admin password then I can add user as many times as I like as well.
00:38:45.180 - 00:38:50.968, Speaker C: I guess it depends if it's doing anything per user or if it's just being a user.
00:38:51.144 - 00:39:04.752, Speaker A: Yeah, it's an interesting working through the architectural ramifications of something like that are pretty big. Yeah.
00:39:04.806 - 00:39:11.410, Speaker C: You might save a whole lot of cost and then backed yourself into a corner where you have no security.
00:39:12.500 - 00:40:07.910, Speaker A: Yeah, exactly. So memory costs money within hyperledger besu you've got this memory cost algorithm where length is the number of bytes that you're creating and essentially you have a base cost which is length squared divided by 512 where it's integer division. So if it's a fractional amount you're just going to get zero and then. It is a mem cost times the length plus this base cost and the mem cost per is three. So there you go. All right, actually that's interesting, it says memory word gas cost. I'm pretty sure it's memory byte gas cost.
00:40:07.910 - 00:41:12.472, Speaker A: I'll have to check that. I think that variable name might be incorrect. And yes, another thing to consider is that it's not actually the memory cost, it's the memory expansion cost. So if your operation reduces the amount of memory and then adds memory, so overall you're increasing, then you've got a memory expansion and so you have a memory expansion cost. But if you're just assuming that you're always creating memory, then that's probably a good mental model. So trying to work through that equation, then if you need one byte of memory, then it's only costing three, whereas as you go up, it does go up, not quite exponentially, but it goes up quite quickly because you've got a linear factor of three times the cost. And then you've got this length squared divided by 512, which, as you can see, you're going from 32 to 128.
00:41:12.472 - 00:43:18.770, Speaker A: So whereas you're doubling, you're effectively tripling quadrupling rather quadrupling, no? Yeah, what is quadrupling, isn't it? So yeah, whereas you're doubling the length, you're quadrupling the actual gas cost for the base fee. So memory is used all over the place and events is one place that you do use them. And so events are a great way of getting information out about what on earth is going on in your contract, but you need to use them quite carefully. And so there's a base cost and then there's a data length cost and then there's the actual topic cost. And so the actual function signature of the event is one topic and then any indexed parameters are other topics and so you pay a cost per byte. And so if we have a look at a really simple event where you have emit an event called Add and it just takes a UN 256, then what you're looking at is say the 375 for let's just do an event and then you're going to have the base cost, which was eight times 32 is 256 for the actual Valve parameter. And then you've only got one topic which is the event signature and the memory expansion is going to cost you 98 because for that value the parameter so overall you're looking at about 1104 gas just to emit that event.
00:43:18.770 - 00:44:31.448, Speaker A: And so I think you need to be think really carefully about what events are being emitted. So you also need to be thinking about what parameters you've got going into those events. So if you've got a bytes then that could actually end up being a lot and maybe you look at that function signature there if yet more data only gets emitted sometimes and not other times, it might actually be cheaper to not emit that. So have huge cost, one and huge cost two events and sometimes emit it and sometimes not emit it, that may end up being cheaper. And also maybe if you know what the information could be or can derive it somehow, maybe just having a hash of the information could be enough. And again that would just be 132 byte value rather than a whole lot of information. And another thing to think about is those indexed values do cost.
00:44:31.448 - 00:46:00.852, Speaker A: And so you really want to think well do I really want to have that as an indexed value or not? So as a topic, yet another area is Abi decode. So Abi encode and decode are a great way of bringing arbitrary structures into code. And so you can imagine if you look at process Blob one here we've got a bytes blob that you abi decode and you extract the values and then can do stuff with them. And if you're going to be using every single value in there or even most of the values in there, it is probably going to be very efficient and very a good way of doing things. And it's code that the Solidity is created by the Solidity compiler so it's far less likely to have bugs than something that you might create yourself. So in this situation though we're just going to store one value being the third value, the value C of UN 256. If you look at then say process Blob two they're even quite explicitly saying look, I'm not going to use all of the output values and then storing it.
00:46:00.852 - 00:47:21.816, Speaker A: Process blob three it says well actually I'm going to give you this bytes but I'm not even going to tell you all of the parameters, I'm only going to tell you about the ones that are before the thing I want to extract and the thing I want to extract. Doing that is interesting because you'll see that the gas costs for the first two are approximately the same and the differences there are probably just related to the function calling. And so essentially which function selector was higher up in the order in the if then else table at the start of the contract. Process Blob three is substantially different. It's what, 700 or so less and that is simply because the Abi decode function isn't trying to decode a string at the end of it. Once it gets to the UN 256, it stops trying to decode. But what about assembler? I hear you say, well you could bring the blob into memory and then know that the start off set was going to be after those two values there was a bytes 32 and bull.
00:47:21.816 - 00:48:31.956, Speaker A: So it's going to be after the bytes 32 and bull and then you just load it out of memory. Load it into memory and then assign it to a value. So you could do it like that and just load up that specific memory location into essentially a temporary variable that would be on the stack being x. You could also though, put it into call data and so what you could do or do is rather you could extract it directly from call data and so you could say, all right, well I know exactly where it's going to be in call data and just take it directly out of there. And then I'm going to put it into a temporary memory location being location zero. And then I'm going to put location zero onto the stack and then put that stack value into a storage location. And as you can see we've gone from having say, 28,000 or so gas 28,200, to now we're down to 26,000.
00:48:31.956 - 00:49:31.190, Speaker A: But obviously this process blob five starts to become pretty complicated. And as you can see, I've done some calculations to show you how I've come up with 132. And also obviously you got to be a bit careful because I'm smashing that temporary memory location. Okay, so I can see there's a lot going on here in the chat, but I can see that there's a lot of discussion. So discussion is good. And what we'll do is at the end of all of this, I'll ask if anyone has any final questions. So, reducing contract size, so unused functions, so if you've got an internal or a private function that isn't used, don't worry, it's going to be automatically removed and so it's not going to contribute to contract size.
00:49:31.190 - 00:50:36.488, Speaker A: If on the other hand, you've got a public or external function, then it is going to go in there. So if you're not going to use it, you should remove it. Another area that you can use to reduce code size is have a look at your require statements. And so the actual strings inside of the require so that say 0123 in the example there, they end up being in code space. And so if you use the same message from multiple different locations, then you may end up, I mean, it'll essentially reference that same piece of code and so you'll end up using the same little code snippet. And depending on how you've configured your optimizer, you might jump to a certain location and get that and then jump back or it might be duplicated. So depending on how the optimizer is set up, it may or may not be more efficient.
00:50:36.488 - 00:51:34.136, Speaker A: One thing to think about is that these messages are loaded up as 32 byte blocks. So you'll have an opcode push 32 and then 32 bytes, which is the message. And so you can see that 0123 is that hex code there. So what I guess I'm saying is if your messages are 32 bytes long or less, even if they're 31 bytes long, it's all good. So have something which is very informative and don't think you've got to try and fit it into three characters or something like that because you're not saving anything. Another thing to think about is that when you have your variables public. So your storage variables public, you get auto generated, getters, for instance, the mapping of TX info.
00:51:34.136 - 00:52:36.528, Speaker A: There you will automatically get a function that looks like this one here, where you've got an external view and it's referencing the map and returning the UN 256. And so that's going to be some code. And if you don't need that code, you don't need that functionality, then maybe you should not have it public and just have it as a private storage location. So it's worthwhile thinking about. All right, what else could you do? So people talk about this idea of having compact storage and so this is where you've got values that are smaller than a UN 256 and they're all pushed into the one storage slot, one after the other. And so imagine you've got add and then you've got set. So add, we're adding the three values together.
00:52:36.528 - 00:53:39.088, Speaker A: And so ideally you would imagine you would load them up and then you'd just add them and set. You would imagine that you are just going to set the values. And so if they were UN 256s, each of them, then add would have three loads and the set would have three stores and that would be it. So being UN 16s, if you don't have the optimizer on, then add ends up being three loads and not one. And as well, because they're 16 bit values, each time you load one of them up, they mask off and do shifts so that the bits are in the right location. And the set, it requires three loads and then three stores to do it, which is just crazy stuff without the optimizer. It's super inefficient with the opcode optimizer on.
00:53:39.088 - 00:54:12.610, Speaker A: The S store is just one S store, which is good, and the ad is an S load and an S store, which is still a bit hokey. And I think actually the admin set there are around the wrong way. So here, I'll even fix that whilst I'm here. Yeah, sorry about that. Good. All right. Yes.
00:54:12.610 - 00:55:34.540, Speaker A: So yet another way you can reduce the code that you're using is check out for impossible states. And so if you know that, say, look at this code here, val can't be some invalid value and then you set it to some val, some storage location, so later on you shouldn't need to check that val is this invalid value, so that should be pretty safe. Another thing to think about is that sometimes, say, these open zeppelin comes with lots of really cool added extras that you could potentially use. So you've got Access control, and then you've got access control Enumerable. So Enumerable gives you the ability to find out who has access. But do you need that capability? If you do need that capability, could you do it off chain? So could you monitor events that are being emitted when access is given and access is removed and then keep the list of parties that have access off chain. Another thing you can do to reduce gas usage is caching.
00:55:34.540 - 00:56:33.524, Speaker A: And so you can see here we've got some storage location addr and you first check it against say, the parameter that's being passed in. Then you call some function that does something and then maybe you call require message sender as well. But what you could do is you could set the storage location to a stack variable and then you could do the comparisons and in this way you're going to save from having to load up that location twice. So it might be interesting to see if you ran the optimizer, whether you would still have that load twice. Maybe you wouldn't, not sure. But certainly with the optimizer off you end up with multiple loads which you don't need. So there are two optimizers.
00:56:33.524 - 00:57:51.130, Speaker A: There's the Opcode optimizer, which is the old one, and there's the your intermediate representation optimizer and there is an enormous amount of documentation on them and they seem pretty complicated. And so I started looking at them and then decided they are a whole discussion point all by themselves and I might try and find out who works in that optimizer team and maybe invite them along to do a talk. So sometimes I know that you can by mistake be saying that a variable is memory when you couldn't have it directly accessed from call data. And I haven't analyzed this, but my gut feel is that when you do that you might end up using more, converting it to memory and paying for it when you don't need to. Someone reckoned, and I haven't looked into this one, that if a function is public then the parameters automatically get copied to memory, whereas if it's external, they don't. And this doesn't quite make sense to me and I didn't have time to look into it. So this is something that could be interesting for someone to another rabbit hole to go down.
00:57:51.130 - 00:58:37.612, Speaker A: There's also been some ideas bandied around that I'm not really sure about. So one was you do call data compression. So you have all of your parameters for a function squished down. So maybe if you see zero, you say, how many zeros have I got in a row? And somehow rather do some sort of compression. And especially given that recent EIP reducing the gas cost, I think this is highly questionable whether this is going to help you or hinder you. Okay, roll ups and sidechains. So all of the stuff I've talked about is Ethereum Mainnet.
00:58:37.612 - 01:00:26.568, Speaker A: But there are other blockchains in the world and there are roll ups and there are side chains and trying to work out how much Opcodes cost in these different chains. And have they got the same EIPS applied as Ethereum Mainnet or are they lagging behind? Or have they gone their own completely separate way? It's really hard to tell. So Arbitrum's AVM has some documentation which is good and so you could compare, but I think that what this means is that code that's really efficient for say, ethereum mainnet or some roll up or some other blockchain may not be efficient on a different blockchain. And I would even go further as to say that something that's efficient today may not be efficient in the future. And so I think you've got to be thinking carefully about that and thinking about, well, what functionality do I want, is it secure? Is it giving us the right security aspects? Okay, now let's start looking at how we can reduce the gas costs and then trying to work out what are the target VMs that you're going to go for and try and understand how it works on those different VMs. So, in summary, storage costs a lot, memory costs a fair bit too, and there are a lot of side chains roll ups out there that have got different gas costs and right at the moment it's pretty hard to work out what those costs are and I dare say they are evolving as time goes on. So, yeah, it'll be a challenge, I think, at the moment to write a highly optimized app for any roll up because gas costs are likely to change.
01:00:26.568 - 01:01:09.008, Speaker A: So, yeah, I think you try and try out and see how you go. So if you're joined this meetup, it's also going to be available. The talk is going to be available on YouTube as a recording. There's a Slack Workspace where you can join the conversation. If you're watching on YouTube, you can join the talks live. I'm going to try and push my example code that I've used in this talk up to that GitHub repo under a directory called Gas. It's a bit of a hack because a lot of it's all in one contract.
01:01:09.008 - 01:02:23.520, Speaker A: So it's a bit messy, but it would give you somewhere to start from if you want to play with this stuff. There's also a formal methods reading group that is run by Frank and with participation from Joanne Lad and Arathio and others, and join the Slack Workspace and go to the formal methods reading group channel to learn more about formal methods and blockchain. Coming up, what have we got? So we've got some lawyers talking about NFT copyright, moral rights and the legal implications of NFTs. We're going to have Mikhail talking about the merge towards the end of May and then at the start of June, myself, Ermius, Zhenyang, Lucas and Angela are going to talk about cross chain applications and how you can create cross chain applications using the technology that we've created. And yep, we're going to talk about checkpoint sync some point. We're going to talk about a security deep dive. We're also going to have a Truffle talk as well.
01:02:23.520 - 01:03:02.964, Speaker A: So those are still to be planned and could I copy the Slack invitation? Yes, I can. Let's do that now. Okay, so that's the slack invitation. And so that is all, everyone. And so the question is, of course, do you have any questions? All right, I'll ask. Go ahead, Frank. Go ahead, Frank.
01:03:02.964 - 01:03:03.284, Speaker A: Yeah.
01:03:03.342 - 01:03:11.500, Speaker D: So in your talk, you covered a lot of optimizations, I would say, related to data structures.
01:03:12.580 - 01:03:13.232, Speaker A: Right.
01:03:13.366 - 01:04:05.696, Speaker D: And in my experience, looking at some contracts, something that's somehow not very often addressed, is optimizing the algorithms to save some gas, too. So that could be important as well, because with some tests that we've been doing in our team, for instance, doing a loop and some tests in the loop that always turn out to be true or something like that, could incur quite a lot of gas. So there's also the algorithmic side on saying if you can have more information on your code, you can optimize your algorithm and save some cost as well. So the data structures side that you covered, it's really good, but it doesn't mean that it's the end of the story, I guess. And you should be careful when you write your algorithms that you take care of optimizing as well.
01:04:05.718 - 01:04:41.768, Speaker A: The code true, and it's interesting. Having briefly read the Yule optimizer information, I have a feeling that it might try and magically do that for people. But yeah, why would you rely on an optimizer to do something for you when you should do something like that? Because that's a silly thing if you're checking a condition inside a loop that should be checked outside. And that's a really good point. So any other thoughts or questions? Peter?
01:04:41.864 - 01:05:26.410, Speaker B: There was some discussion on the chat about potential hash collisions and whether it was worth risking a hash collision for gas optimization. Some people thought no, and some people thought yes. I think the issue is what kind of hash is being used in any particular situation? Because I seem to recall a couple of years ago, we looked into the code and we found that there were quite a number of different hash types used. Do I remember that incorrectly, or can you comment on that?
01:05:26.780 - 01:06:47.616, Speaker A: Yeah, sure. So there are multiple hash algorithms available. And in fact, if you think about the function selector, it's essentially a message digest too, but it's only 32 bits long, but a 256 bit Kikak 256, which is essentially Sha three message digest. Even if someone has a quantum computer and has, what is it, Grover's algorithm, that's the database search one, isn't it? Then it's still going to be really good for many years, I think. Even with that, I think the search space ends up being for hash collision. But this wouldn't be a hash collision anyway, because you've got to think so a collision is when you can choose the two values, but if you've got a known value and you're trying to find a collision with that known value, then really it's second pre image resistance, isn't it? Anyway, so I think you've got 256 bits of security. So you're good anytime this Millennia, probably.
01:06:47.616 - 01:06:57.510, Speaker A: But I don't know, maybe that's going too strong. You should be okay at least till 2050, I think. I'll give you 2050 and who knows what happens after that?
01:07:00.940 - 01:07:12.520, Speaker B: I think that would beat the average life expectancy of hashes to date, but that doesn't mean it's not true.
01:07:12.670 - 01:08:08.376, Speaker A: Well, that's true, and someone could find a hack in it. So there's a big difference between security strength and how long the hash algorithm is going to work. But even, say, Sha One or even MD Five, which is 64 bits, I recall. And so even with MD Five, there has been a collision, collisions found. But as far as essentially having the hash and finding the pre image or the second pre image resistance, it's still pretty hard. And certainly for Shah One, which is 128 bit or 160 bits, it's still really I think they found one collision and that took a whole gang of computers three years. Then you've had Sha Two algorithms and now we've got Sharp.
01:08:08.376 - 01:08:42.584, Speaker A: This is a Sha Three algorithm. So I think you've got a fair bit of security there. Probably the bigger thing to think about is in 50 years time or 100 years time, will Ethereum still be up and running or will it be superseded? Will all of you who know Solidity will be the COBOL and programmers of the future and be the one person on the planet who still knows Solidity, who knows it's something to think through as well.
01:08:42.622 - 01:08:49.850, Speaker B: I guess we can all jump on Metacolis and predict what the Ethereum price will be in 2050.
01:08:51.580 - 01:09:01.986, Speaker A: For sure. So, Sandra, did you learn anything? Yes, heaps.
01:09:02.018 - 01:09:38.290, Speaker E: Thanks, Peter. And I was just impressed at the effort that's gone into putting this together when you've not had that much time. And it's been really interesting just going into the detail of exactly how you look at it. And also, I was actually not aware of how much prep has actually gone into getting ready for Stateless. So to see that early on already, the things that have been talked about have already in place, like the whole concept of warm and cold storage. So that was a new one on me. So that was a really interesting talk.
01:09:38.360 - 01:10:15.978, Speaker A: By the worked. Having been part of the team of Sandra working on Stateless, i, too was surprised and thought, oh, I didn't know they got around to doing that. Yeah, so we briefly worked on Stateless for, what, six months back? Two years ago? Yeah, 2020. There you go. All right, look, thank you, everyone, for joining the call. Have a great day. And this will be up on YouTube tube at some point, and hopefully I haven't forgotten to answer anyone who had a question in the chat.
01:10:15.978 - 01:10:18.780, Speaker A: Bye bye. Thanks.
