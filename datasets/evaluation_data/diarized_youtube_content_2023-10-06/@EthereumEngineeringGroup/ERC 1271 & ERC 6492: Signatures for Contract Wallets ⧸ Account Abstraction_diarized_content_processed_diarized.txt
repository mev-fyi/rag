00:00:00.330 - 00:00:39.110, Speaker A: You. Hello and welcome everyone. My name is Peter Robinson. Today at the Ethereum engineering group meetup, I'm going to talk about EIP 1271. So it's about signatures and contracts, about account abstraction. So who am I? So I'm Peter, I work as the head of Blockchain Research at a company called Immutable, which is developing a games platform, has some games as well. And it's all about web, three games and game phi.
00:00:39.110 - 00:01:10.820, Speaker A: So without further ado, let's just click on mute there. Yes, I'll just share my screen. Just a SEC. Okay. Can people see my slides? Okay, brilliant. I'm just going to get that out of the way. Okay, so as I was saying, let's talk about ERC 1271.
00:01:10.820 - 00:01:48.858, Speaker A: So I got some feedback from Philip, so thank you a lot. From Philip. Who's? From Horizon Games. So we're going to talk about the ERC and usage of it and how you go about using it and then talk about the standard and talk about what it isn't, because I think there's a lot of confusion about what this is all about. We're going to talk about the flexible signatures and what it actually means. And then account abstraction is pretty hot. So let's talk about that as well and how this all interrelates.
00:01:48.858 - 00:02:52.160, Speaker A: And we'll talk about counterfactual wallets and ERC 64 92, which is a new one. And is this actually used after I've been talking about it for all this time? So let's keep on going. So is it an ERC or an EIP? So if you go and look at EIP one, it tells you all the different types of things. And so an EIP that's actually an ERC is one that's an application level standard. And so this is about smart contracts and applications. So it's an ERC, not an EIP, but you'll often see it down as EIP 1271. So normally when you've got wallet contracts, the idea is you've got a human and they're using some wallet library where they write the function calls that they want to execute to the transactions.
00:02:52.160 - 00:03:41.810, Speaker A: And the idea is that they pass this off to the relayer service, and the relayer service actually submits the transactions for them. They personally do not have to worry about nonces and all that. That's really down to the relayer service. So they're not paying for gas directly. And then the wallet contract then does stuff, executes the transactions, and then you've got application contracts that are the receiver of those transactions, of those function calls. And so that's normally how you do things with contract wallets. And so what you often have though, is a situation where you want to prove that you're the owner of an account.
00:03:41.810 - 00:04:51.704, Speaker A: And so what you might have happen then is you'd have, all right, look, I've got this account and then the application says, do you really have that account? Are you really that person or that account holder? And so they'll send you a challenge and that challenge could be a random number and then you send back a signed response back to the application. And so you sign that with your wallet. And so essentially you've got some part of it that is off chain and you're signing with the off chain part and then the validation of that signature happens with the on chain part. So the actual wallet. So then the app then talks to that wallet and says is this a valid signature that I've just been given? And so you could imagine, say, I think some of us have used decentraland. And so in decentraland you've got some NFTs and the NFT say represents a hoodie or some article of clothing. Before you can access that you have to say, well I'm this account.
00:04:51.704 - 00:05:38.244, Speaker A: And one of the first things that the decentraland application the game wants you to do is prove that you're that account holder. So if you've got an EOA it's just a matter of signing a challenge. But if you're not an EOA and you've got a contract wallet, this would be how you would do it. Another thing you could do is you could have a signed message. So you want to do some off chain message that you use for something, say an auction or something. And so you submit an off chain message that you've signed. And then the application, it really needs to check that that signed message is valid before it say, lodges your bid in an auction or something like that.
00:05:38.244 - 00:07:07.172, Speaker A: So it's going to go is valid signature and then later on say you win the auction, then it's going to submit the signed message to some application and then that application is then going to go is valid signature to check to see if it's a valid signature or not. And so doing that just, yeah, so doing that then means that on chain the application is able to check and then assuming that that message has been signed and you know, you've got that winning bid, then maybe you get the article that you've bid for. So of course the messages can be anything. And an important thing to think about is that unlike say, ethereum transactions, they're not going to necessarily have nonces, they could have a nonce but it doesn't have to, that's going to be down to the wallet and the application. So you could have message that could sit around for a very long time and not have to be used immediately and be used out of order. Okay, so what is the standard then? So it's a standard way of verifying signatures when the account is a smart contract. And so the idea is that, so EOAS have got private keys but contracts don't.
00:07:07.172 - 00:08:02.640, Speaker A: So it's a way that you can have an API that can be called to verify a signature. And so you can have is valid signature, hash signature. And so looking at that, the idea is that the contract wallet has this API where you pass in the hash of the message that you're trying to sign and then you pass in the signature and then you're going to return a magic value. And the magic value happens to be the function selector for is valid signature. And if it's true otherwise you return some other value if the signature verification fails for some reason. And so the hash relates to that data. And that data is application specific, but the signature is wallet specific.
00:08:02.640 - 00:09:15.304, Speaker A: So if you're building your own wallet, you get to choose what's in that signature and work out how you're going to verify that signature. And as I said, that fancy number there is just the function selector for the function. And so I know, I looked at that and thought, what, why aren't they returning a Boolean, valid or not valid? And in the EIP it says the specific return value is expected to be returned instead of a Boolean in order to have stricter and simpler verification of a signature. So I don't know if you have a look at the first set of code and then you have a look at the second set of code where I've said, well, what happens if you return to Boolean? And to me the second bit of code looks easier and simpler and it's going to be cost less gas as well. But anyway, so that's the standard. So I don't know, maybe you could bang in some extra error codes into that bytes four later, but an enum would have been a better option. So yeah, I don't know why that doesn't make sense to me.
00:09:15.304 - 00:09:56.640, Speaker A: But anyway, it is what it is. So the ERC isn't about, say, using it for contract level authentication. So say you've got required message sender is some authorized party. It's not a replacement for that. You would use message sender in that case. So if you're looking, is it the wallet calling me? It's also not going to replace, say, when you're using, say, message sender in the context of, say, an address map or anything else where you're using addresses. So it's not used in that context.
00:09:56.640 - 00:11:27.050, Speaker A: It's just for do I own the account and can I sign off chain messages that are later used on chain? How does this all work then with the account abstraction and the flexible signature verification? So having a contract signature opens up many possibilities, though. The thing of course is that you're doing this verification within the EVM though, and you've got to think that that is valid signature is called by other contracts, so you can't have it using millions of gas if at all possible. And so normally we've got the EOA, so not signature verification. You've got one signer and you've got one specific curve that you've got to use. Whereas if you're using this standard or contract wallets, generally you could have multiple EOAS signing to sign for the wallet. So you could require that every single EOA signs. So you could have each EOA signed separately and they then put it into the wallet and then if all of them have signed then the actual message gets executed.
00:11:27.050 - 00:12:34.130, Speaker A: You could have a threshold number of signers so you could say all right, we're going to have three of five. You could have weighting as well. So you could say well this particular signer has a weight of three and these other signers only have a weight of one and so three of those have to sign to be equivalent to that other signer. But you can also have changing validity which is an interesting one. So imagine you've got one of those multi sync techniques we've just talked about so you could have user A and user B could sign and so you could return is valid, is true. Then you could remove user B from the multisfig and add user C and then when you then next go to validate that same signature is valid signature is going to return false. And so obviously you could put in logic to honor the historic signature but just using a simplistic scheme you would fail the signature verification.
00:12:34.130 - 00:14:09.738, Speaker A: Obviously with contract wallets it also means that you can do other things. You could use BLS or Entru or some other scheme where you're not going to use up too much gas because you've got to remember you're trying to verify those signatures within the EVM. You could imagine, you could have expiring signatures so you could say well look, I'm going to sign this message but I don't care what the application says, I'm expiring this signature within 24 hours and so then that again means that a signature might be valid at one time but later on it might not be valid. Obviously though, when you're doing this sort of scheme the time is going to have to be part of the hash that you then sign. So in other words what you do is you'd have the data hash supplied to you and then you would have the expiry time and that data hash that you would rehash and then sign the overall hash because otherwise anyone could arbitrarily just modify the expiry time. So you could also have a unique ID per signature. And so what you could do then is you could disable specific signatures so you could decide that you don't like that particular transaction so you want to revoke it and so you could have given an ID and say it's ID 17.
00:14:09.738 - 00:15:44.030, Speaker A: Then after some time you could invalidate that signature which again would mean is valid signature returns false. You could also imagine doing something a bit silly where off chain you return true but if you get the same request on chain then you return false. And so if we're thinking of this scenario where you had an off chain message that the application checks to be correct, you'd return true but then say if it was an auction, you could put it in an infinite bid, knowing that when you actually get around to executing step four, it's going to fail. And so you could do all sorts of nefarious things. Another thing to think about is that so even if you audit the Wallet implementation code and you fully understand how it works, most of them are designed as proxies, so it can upgrade to a new version of code. So there is that possibility that even if you start out with something good, a type of signature which is revocable in some way could occur. So really, then I think when we look at the standard and those last few words there, whether a signature verify, whether a signature on behalf of a given contract is valid, where it should be, is valid at a certain point of time and given a certain state.
00:15:44.030 - 00:16:38.938, Speaker A: So it's really is the signature valid now is really what the API should be and in fact, what open Zeppelin have used. So when we think of normal signatures, normal digital signatures, you've got authentication properties and non repudiation. So authentication is saying, I'm the one who signed, and non repudiation is you can't get out of an action. And so the EOA signatures definitely give you both. Once you've signed, you can't really get out of it. I guess you could claim that someone has compromised your private key, but beyond that, it's really impossible to say. You didn't sign, but with the 1271 signatures, you've definitely got authentication.
00:16:38.938 - 00:17:28.640, Speaker A: But the non repudiation really does depend and a big question should come then. So for the intended use cases, does this really matter? And so, all right, so authentication, I'm the owner of this account. Those NFTs that are associated with my account can be used by me in the game. And so the example being the NFT T shirt born by my character in the, you know, authentication, it all works, that's all good. And again, if we think I'm the owner of this account, I've got the right to transact because I own that information or those tokens. And so again, you'd have your bid accepted. So that would be all good.
00:17:28.640 - 00:18:19.870, Speaker A: Non repudiation, which was preventing you denying that you'd done something or you'd sign some message. So I want to do an action, say, buy something at a certain price, and then I change my mind because actually I don't like the price has fallen, so I'm not interested anymore. And so non repudiation should lock you in. So you can't say I don't want to do it anymore. And so that's the property that we're not quite got with this in all. And as I'm saying here, so the lack of non repudiation means that the winning bidder can make the transaction to do the final transfer fail. Whereas if you're an EOA, you couldn't do that.
00:18:19.870 - 00:19:37.894, Speaker A: It would go through. Okay, so what about account abstraction? So account abstraction is really just contract wallets really when it comes down to it. And so not all contract wallets need ERC 1271. So if say, your use cases don't require the use cases that are covered by er 1271, like proof of who owns what wallet or signing off chain messages, then you don't need it. However, I would have thought if I was going to be implementing account abstraction from scratch, I could imagine putting it in simply because it's a feature that some people will want because that whole proof of ownership business seems to be pretty fundamental, I think. So out of factual wallets and ERC 1692. So counterfactual means expressing something that hasn't happened or won't happen, so isn't the case.
00:19:37.894 - 00:21:11.590, Speaker A: So in the case of a counterfactual wallet, the idea is you give a user an address, an account, but you don't deploy the wallet until they need it, using that word counterfactual, meaning you haven't actually deployed the wallet yet or the wallet doesn't exist yet. That's what it's meant by a counterfactual wallet. And so create a counterfactual wallet, you need to know the address that it's going to have before you deploy it. And so you use create two to have a deterministic contract address and so the create two uses the address of the deploying contract salt and the creation code for the proxy contract that you're going to create. And so you can imagine a simplistic flow that looks like this, where you've got a relayer that deploys a wallet factory that creates the wallet proxy. And then you say execute some function call and it does a delegate call into some wallet implementation. So that all looks fine, but what happens if I call is valid signature before the wallet proxy has been deployed? So at the moment that's just going to fail because the contract doesn't exist.
00:21:11.590 - 00:22:34.734, Speaker A: But you can imagine that would be a really bad UI because say if you've got some game and you've given a character, a user, I don't know, an axe or whatever some implement, they might not have done a transaction, chances are they haven't. They might only need to do transactions later in the gameplay, if at all. And so you don't want to have to deploy contracts for everyone. So you need to be able to handle the fact that the user does not have a contract deployed yet. And so ERC 6492 aims to cover this situation. And so when you sign so if the contract has been deployed you just use normal ERC 1271. But if it hasn't been deployed then you end up having the address of the factory that you're going to use, the call data that you're going to pass into the factory including which is going to include the bytes to be deployed or some information that you're going to call and then also the original signature.
00:22:34.734 - 00:24:10.574, Speaker A: So the actual ERC 1271 plus some magic bytes that you've got that are defined in the standard and so we've got the factory address or factory address, the call data that we're passing into the factory to get the contract deployed, which is going to include the salt and then the signature on the verification side. So if the signature ends in those magic bytes, which indicates, hey, this signature was generated before the contract was deployed, then rather than doing a transaction, you do an ETH call. So a View call, and what you do is you call the factory with that factory call data to get the contract deployed. And then what you do is you call is valid signature. So because you're doing all of this in the context of an ETH call, the distributed database, which is the blockchain, so the distributed ledger doesn't get updated, it's only the copy of that that you've got temporarily whilst you're executing this function to verify the signature. If that's not the case, then you use ERC 1271 if the contract code has already been deployed. And if there is no contract, then you use EC recover because you assume it's an EOA, again, highlighting because you're calling E call.
00:24:10.574 - 00:24:51.184, Speaker A: It's just a view. Call. You're not actually going to update the blockchain, but you are going to in your temporary version of the blockchain, deploy the wallet, and then call is valid signature on that temporarily deployed wallet. So who implements this standard? Does anyone? So there are at least three wallets that implement it. Gnosis sequence and argent. There are some libraries out there that help you implement it or do implement it. And as well, there are some products that implement it as well.
00:24:51.184 - 00:26:05.560, Speaker A: So there's a range of users. And I imagine as account abstraction becomes popular, pretty much everyone will move to using this for those situations of proof that you have the account or are the owner of the account and signing off chain messages. So, in summary, this EIP or ERC really gives you a way of proofing ownership of an account and doing off chain messages. Most account abstraction wallets are going to need to implement this. You can have a multitude of signature schemes, but signatures are only definitively valid at a certain point in time, so they can expire or the configuration can change. And there are a whole stack of forthcoming talks, pretty much one a week in May and lots of interesting talks. And you can engage with the community, watch us on YouTube or join the meetups.
00:26:05.560 - 00:26:55.590, Speaker A: So let's stop sharing and look at the questions. Okay? All right. Hayden, I have a question for oh, Hayden's got his hand up. There you go. He's OOH. I want to answer a question. So, Hayden, my question to you was what chains natively Support account abstraction?
00:26:57.210 - 00:27:05.130, Speaker B: As far as I know, it's just Cksync and the other one sorry. With its own language.
00:27:06.190 - 00:27:09.802, Speaker A: Okay. Yes, stockware. So StockX or something.
00:27:09.936 - 00:27:23.040, Speaker B: Yes, Stocknet. I actually had a question. So you mentioned the Nefarious signatures that verify off chain but not on chain. Are there any potential mitigations for that?
00:27:25.090 - 00:28:24.980, Speaker A: I don't think so. I think how you can think of this is you can think of this as a new type of signature. And you can think of it as, well, if I had an account, say, if I was an EOA and I did the winning bid for something, I could then move money out of my address into, move all my ETH out of my address. So then when the actual transfer goes through for me to buy the NFT, it's going to fail anyway. So it's probably not as bad as it sounds, if that makes sense, that you could still fail, agree to do something and then fail it anyway because of due to insufficient funds at the moment and there's very little legal recourse that you could have.
00:28:26.790 - 00:28:28.340, Speaker B: Right, thank you.
00:28:36.090 - 00:28:45.210, Speaker C: I have a question, Peter. Is valid signature, that's something you can write as you wish.
00:28:46.110 - 00:28:51.100, Speaker A: Yeah. You're writing your wallet so you get sign your own.
00:28:52.030 - 00:28:58.720, Speaker C: It doesn't have to satisfy some properties being securely semantically secure or whatever?
00:28:59.490 - 00:29:02.026, Speaker A: No, you could return true or return false.
00:29:02.058 - 00:29:02.640, Speaker B: Yeah.
00:29:05.650 - 00:29:17.890, Speaker C: Because then it somehow allows users or developers of smart contracts to write their own recipe for signatures.
00:29:18.470 - 00:29:43.530, Speaker A: Yeah, it's true. But I think normally underneath, I think you're going to see that it's normally just a multi sick wallet where you've got, say, two different signers and it's just doing EC recover or something like that. I don't think people are generally going to write their own signature scheme. Even writing a multi SIG wallet is nontrivial.
00:29:44.510 - 00:30:41.070, Speaker D: I reckon you could put as much information as possible. It's more for the user because user is signing it. So user would like to know what information they signing. A good example is the one inch fusion order. They let you sign a really long message in your MetaMask. You will see the prompt of what asset, what taker assets swap to what maker asset expiration like ten minutes and then at what minimum price all the information and then you sign and then they can allowing the contract to take your money to do the swap. So I think it's more a UI thing that you want your user to know what you're signing.
00:30:42.930 - 00:31:05.110, Speaker A: I think in that case, isn't that all data from the application as opposed to wallet stuff? Because this is slightly separate, this is you in the wallet itself saying, because I can imagine applications having timeouts makes sense, you don't want a message hanging around forever.
00:31:07.770 - 00:32:00.840, Speaker C: I've got a second question, I guess. Now, the account abstraction concept, it's not, let's say, ethereum specific, right. It could be applied on other chains running something different to an EVM. The specification that you presented, and I think it's not you, but most of the specifications are written in solidity, but it's probably something that could be defined at the EVM level or I don't know. But writing it at the solidity level doesn't seem right to me because it's not the semantics of the machine that you're running on. So is there something, let's say, more abstract to read about it defined in a more, let's say, rigorous way rather than solidity? Or is it just the interface that they interface? Okay.
00:32:01.690 - 00:32:13.514, Speaker A: And even if you read the language, which I know you and even myself, I look at it and I think, well, that language is a bit loose and just the verbiage around it.
00:32:13.712 - 00:32:23.690, Speaker C: Okay. So actually you have to have the signature, the four bytes of the Ketchup and so on in your contract to be compatible or compliant.
00:32:23.850 - 00:32:47.080, Speaker A: Yeah, there's really very little that it's locking you down. But to me, I read it and I think, oh golly, it's a standard. I don't know. Standards are a negotiation between lots of different people with lots of different interests. So you arrive at something that no one's really happy with, but everyone can sort of agree on.
00:32:47.530 - 00:33:11.360, Speaker C: So then there's something I also was curious about on the defensive side. I wouldn't like users to be able to think that they can write their own signature schemes. So I would provide some predefined schemes, for instance, and could it be defined as pre compiled or things like that? Or is it something.
00:33:15.650 - 00:34:31.240, Speaker A: I will admit, I've looked at the Sequence code a great deal. I have not looked at the Gnosis or Argent code in detail because you could well find, I dare say Gnosis has been around the longest. And it would be really interesting to look at the Gnosis code and see whether the signature scheme that is used by Gnosis is the same or very similar to what is used by Sequence and Argent, or more to the point, whether the two of them have inherited the formats that Gnosis have used. But at the end of the day, though, they don't need to be interoperable because you generate a signature using your library. And the only thing that can verify that signature is the contract on chain. So it's really up to you to write your library and your contract. Yeah, and the other thing as well, Frank, is I don't think, given it's open source software, and I would have thought people will generally look at one of the wallets and just copy the code or use the code rather than inventing their very own wallet.
00:34:33.020 - 00:34:53.160, Speaker C: Yes, so I agree, but I'm not an expert in crypto, but what I learned is that you shouldn't try to cook your own signature scheme or Mac scheme or whatever. You should use standardized ones. So I'm a bit worried about this opportunity to write your own signature scheme.
00:34:53.240 - 00:35:55.620, Speaker A: Yeah, I mean, it's like the bit where I said about including the timestamp you could easily muck that up to have a very good secure signature scheme and make it very insecure by mistake, just by doing some incorrect formatting. There you go. So I did have a question. What physical form do private keys take in these systems of off chain wallets? UB keys or something else? Really good question. So some people do have hardware wallets, some people have in memory stuff, so MetaMask, but MetaMask can use wallets as well or hardware wallets. Some people will use HSMs in the cloud, so in AWS or Microsoft Azure. So I think that there's a wide variety.
00:35:55.620 - 00:36:01.670, Speaker A: And Hayden, I can see you've got your hand up.
00:36:03.160 - 00:36:15.530, Speaker B: Yes. What implications does this have for non atomic transactions? Like, say, a non atomic cross chain bridge? Yeah. Do you see anything there?
00:36:15.900 - 00:37:21.170, Speaker A: Yeah, having something that can be signed that is then unsigned is not going to work. But yes, I guess you would have to be careful about any scenario where you weren't going to immediately action something. So a non atomic or a bridge where there was more than one action. But I guess the thing is that that contract wallet only works on a certain chain. So you could, I guess, potentially deploy the same wallet on a different chain. And I guess assuming that the other chain supports the same semantics, you should end up with the same address, assuming that the factory was deployed to the same address. So I guess you could verify the signature on multiple chains, assuming you could deploy it to the same address.
00:37:21.170 - 00:37:31.600, Speaker A: But I think anytime when you're going to be verifying at different times to when you're signing, it's going to be messy.
00:37:36.520 - 00:37:43.604, Speaker C: So that means that for wall ups, for instance, it could be an issue. They have to have the context and replay the transactions in the similar context.
00:37:43.652 - 00:37:52.270, Speaker A: And so yeah, sorry Frank, go ahead, say that again please.
00:37:52.800 - 00:38:09.984, Speaker C: Well, in a roll up, let's say with the fraud proof or whatever, you have sometimes to replay the transaction. So you need to save the context of the transaction on the L two to be able to replay it. So that's something they can do, but that could be something as well that.
00:38:10.022 - 00:38:11.170, Speaker B: We'Ll have to do.
00:38:12.020 - 00:39:28.564, Speaker A: But to invalidate the transaction, the user has to do a transaction to update state on chain, which is that means they've got to get a transaction in. And so even if you're replaying, as long as you're replaying them in order, it shouldn't matter because they can't put a new transaction in in the middle. Have a question, would you be able to expand on why non repudiation does not owe for ERC, 1271? Yeah, sure. So it doesn't always hold. So in fact, I dare say all of the wallets that are available today, as far as I could see, none of them supported having time based repute like timeouts of signatures. But if a contract wallet did, then the fact that you can go from having signed something and is valid signature returning true to later having is valid signature returning false, that allows you to. Repudiate stuff.
00:39:28.564 - 00:39:48.984, Speaker A: So you can sign something, and then later on you can say, no, I didn't sign that. You try and verify it. So that's why non repudiation doesn't hold. You can potentially write a wallet where it ought. Right, yeah. It doesn't necessarily owe, but you can.
00:39:49.022 - 00:39:50.528, Speaker B: Write a wallet where it ought.
00:39:50.564 - 00:39:50.764, Speaker C: Yeah.
00:39:50.802 - 00:41:12.720, Speaker A: And in fact, all of the wallets that I think are available today, as far as I know, non repudiation holds for. But then what I said about upgradable wallets, all of that applies. That's definitely something. So the fact that they're all proxies with implementations and you can upgrade to a new implementation, and when you do that, then potentially the implementation could allow for revoking signatures. Obviously, though, you've got to put the information in the signature in the first place. So you've got off chain code and you've got to work out a way of putting something in so you'd know whether you wanted to revoke a signature or not, because it's got to be in that signature blob. Are there any other questions? You I think we're all out.
00:41:12.720 - 00:41:25.790, Speaker A: Okay, well, thank you very much everyone, and see you in about two weeks time. Have a great day. Bye bye. Thanks Peter, for a great presentation. See ya.
