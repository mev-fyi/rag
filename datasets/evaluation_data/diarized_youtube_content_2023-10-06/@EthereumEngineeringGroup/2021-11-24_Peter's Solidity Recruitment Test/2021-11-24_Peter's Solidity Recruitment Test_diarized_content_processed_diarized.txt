00:00:00.890 - 00:00:57.022, Speaker A: Hello and welcome everyone. My name is Peter Robinson and today I am going to be presenting a talk on Ethereum and solidity and how you might choose to run a solidity test. And if I can get to the right window, it'll even work even better. Is obvious, I guess, by the fact that this is going to be up on YouTube. I'm going to have to come up with a new test, which is okay, it's all good. But yeah, so something to keep in mind. So I'm going to talk about the overall process because I think it's good to.
00:00:57.022 - 00:01:45.402, Speaker A: I know there are a few people who have specifically joined the meetup to understand how you might do a solidity interview. And I think it's interesting and useful to stress this is not the whole interview process. This is a very small piece. I'll go through the test and some more code that you could use to get people to think and some thoughts. So the overall process that we follow generally at consensus, and it's not completely uniform and there might be extra steps. And obviously it depends on the role as to which of these steps you actually do. And maybe for a different role, say if you were becoming a product marketing manager, I dare say you're not going to do a pair programming test, but this is the general approach.
00:01:45.402 - 00:03:12.234, Speaker A: And so we have an application review and that's really, you've submitted your resume and a cover letter and we have a look at that to try and understand. Do you appear on paper to have the skills, background to do the role? Is it likely that you could be successful? And then we'll have a screening interview where it's really, let's introduce consensus and the role just to make sure that you understand what you're applying for and just check that you appear to have applicability to the role. So look at your background and talk about what you've done and what you want to do and make sure what you want to do aligns with what the role is. And also we'd allow people to work pretty much anywhere in the world, but you've got to be able to legally work in the country you're living in. So if you can't work legally there, then we can't employ you. And as well, there also could be part of it, like some, even though you can work remote and work anywhere in the world if the team is, say, in GMT plus ten. So essentially Brisbane, Australia, maybe we're happy if you're living in New Zealand or Japan or say somewhere two or 3 hours, either side.
00:03:12.234 - 00:04:31.090, Speaker A: But if you're working at the other end of the planet in, say, the Canary Islands, then it might just be too hard for the team to work with you. So that might be something that we'll make sure about availability. When could you start? Also, just check, are you just applying for this role because we're a software company and you're after a software role, or is it that you're really interested in blockchain? You think consensus would be an awesome company to work for and in particular you want to do this thing. Also, some people have accelerated expectations that are off the planet, and that's great that they have those expectations, but if we're just not going to be able to give them, if it's not going to match what we perceive that they're worth and where we perceive they might end up in our overall levels, then it's pointless proceeding with the interview process. And as well, this initial interview will work out. Can you communicate over Zoom? Given we do so much over Zoom and via messaging, the ability to communicate over Zoom is pretty important. So the pair programming interview is the one that we're going to talk about today.
00:04:31.090 - 00:06:12.638, Speaker A: And in fact, normally you wouldn't be just doing a solidity test. You're going to be doing solidity and maybe some other language. So you're trying to fit two programming tests all in one, and really you're trying to work out if they said, I'm a superstar developer with 20 years experience in this language, does their actual demonstrable experience match that? And can they communicate over Zoom about software and code? If that's going to be a big part of their role, then if they can't communicate about software, then it's not going to work. And can they understand complex questions and respond to them and think on their feet? We also have learning exercises, so essentially you're going to have some domain specific area that they're going to work in. And so you might come up with an area that they need to learn about, and maybe it might be in the form of a presentation or maybe just a discussion. And again, this is about can the candidate think about technical concepts, explain them, communicate, think on their feet? We have a culture fit interview at the end, and that's really a matter of talking with some people who haven't been involved in the overall process thus far to work out whether you're likely to fit into consensus and the team, and whether your values are generally going to be aligned with the company values, then all the people who've been involved in the hiring process, get together and discuss whether they think you should be hired or not. And if, say, there were being multiple candidates were being interviewed at the same time for the one role.
00:06:12.638 - 00:07:40.478, Speaker A: It's going to be a matter of working out who the job should be offered to, if anyone. And finally there's an offer interview. And by the time you're at the offer interview, you should know that your salary expectations are going to broadly match with what's going to be offered and you're going to be offered a job. So it's pretty fantastic at that point you should be feeling very happy. So big long process and we're just going to talk about a part of the pair programming interview, which is the solidity test. So I guess the thing to always think about when you're going to have an interview is what do you want to get out of it? What I want to get out of the solidity interview is can you read code, comprehend it and discuss it? Do you know solidity? Can you do problem solving? And do you understand common solidity coding conventions? It'd be great if I can probe into your knowledge of EVM and gas usage and see if you know about commonly used libraries as well. And the goal is as well, given we've got all this mega interview process is, and you probably want to be testing for more than one language, it means the whole solidity test has to run for 25 minutes.
00:07:40.478 - 00:08:02.600, Speaker A: So my goal is to have something where the candidate is comprehending the test, communicating about the test and doing it all in 25 minutes online. So if everyone can crack open remix. So I've got a link there and what I'll do is.
00:08:05.770 - 00:08:06.662, Speaker B: If I was.
00:08:06.716 - 00:09:01.820, Speaker A: Really good here, if I give you this, you may even end up. I think that may take you directly to the actual thing. Or you might just want to type in HTTPs remix ethereum.org or maybe just that. So crack open remix as a starting point and you can vote. So if I was really smart, I'd get the participant window up, which is over here. So if you can do a hands show in your participant screen.
00:09:01.820 - 00:09:11.454, Speaker A: So you should be able to do some sort of signaling thing. We've got a two, three thumbs up.
00:09:11.492 - 00:09:12.400, Speaker C: That's good.
00:09:15.490 - 00:09:27.954, Speaker A: Do a thumbs up. We've got a few thumbs. Seven thumbs up. All right, I think we've got enough people who are someone's thumb went up and down. Or maybe your thumb goes up temporarily and then comes down again.
00:09:28.072 - 00:09:28.740, Speaker B: Anyway.
00:09:31.030 - 00:09:41.666, Speaker C: Can I just ask, if I click on a link, it opens remix, but it doesn't actually open your workspace. So I'm just assuming that you want to just open remix.
00:09:41.778 - 00:10:12.800, Speaker A: Yeah, just open remix at the moment. Because what I'm going to do is I'm going to copy, and then I'm going to get the chat, and I'm going to paste the code in. And this is actually what I'll do in the interview, is I'll paste the code straight into chat on Zoom. So if you open that up, so have a little look see of that. And so what I'm going to do is so that you can't see my cheat slides where I know what to do next.
00:10:14.230 - 00:10:14.594, Speaker B: Yeah.
00:10:14.632 - 00:10:52.094, Speaker A: So have a look at that code and just have a think about it. And, Chris, do you want to be the brave soul to start talking about the code and what you would do about it as a starting point? How do we get this to compile? What things do we need to change? And it's okay if you don't want to be the brave person. Are you talking to Chris with a K? Chris with a C, actually, but I'll shut up. Chris, you're pretty good, I'm sure.
00:10:52.132 - 00:10:52.750, Speaker B: You're.
00:10:54.530 - 00:11:01.822, Speaker A: Definitely not. All right, Joanne. All right, Joanne, why don't you help us?
00:11:01.876 - 00:11:05.154, Speaker B: So when you try and compile, like.
00:11:05.192 - 00:11:17.700, Speaker A: I'm going to compile the code and you can see on my screen what I'm seeing, so you talk to me and you tell me what you would like me to do to fix the code.
00:11:18.630 - 00:11:42.000, Speaker D: Okay. I was just trying to organize my windows. Sorry. And I should say, and I don't know how many other people have this. I still have the thing when I open up remix, that I can't make a new file, I have to copy and paste into one of the ones that exists. I just have never solved that problem since we last spoke. Okay, so we're looking at line 23.
00:11:42.000 - 00:11:46.640, Speaker D: Sorry, I just need to make my. Got too many things open.
00:11:50.050 - 00:11:50.478, Speaker B: So I.
00:11:50.484 - 00:11:51.870, Speaker D: Can see it a bit bigger.
00:11:59.670 - 00:12:06.280, Speaker A: So, Ronnie, Gabrielle has suggested moving override. So let's do that as a starting point.
00:12:06.970 - 00:12:07.960, Speaker B: All right.
00:12:12.410 - 00:12:23.930, Speaker A: And he suggested not a view. All right, so let's see if we can compile now. All right, we're in business. We've compiled.
00:12:24.510 - 00:12:25.194, Speaker B: That's good.
00:12:25.232 - 00:12:46.260, Speaker A: So we've got some compiling wants to. So, Ronnie, you've already answered two, so it's going to go to someone who's not you and Joanne, you've had a go. So I'm happy for it to be a third person who can talk me through what they think this code is trying to do.
00:12:49.910 - 00:12:52.226, Speaker C: Happy to give it a go. Shiranjit here.
00:12:52.328 - 00:12:53.394, Speaker A: Yep, sure.
00:12:53.592 - 00:13:20.250, Speaker C: Looks like you are storing a list of authorized users. And the authorized users are stored in a public array called OD users. And basically all the functions are doing is that adding authorized users and basically checking whether the modifier basically is something you put in other functions to check whether the person who's calling is basically an authorized user.
00:13:22.930 - 00:13:45.460, Speaker A: So you've described the access control mechanism, which is good, but why would I be, I wouldn't just deploy a contract just to do access control, would I? So what is the overall thing that the contract is trying to do? You've identified access control, but what's the contract trying to do?
00:13:46.090 - 00:14:23.662, Speaker C: It's trying to verify that the originator of the person who calls the function is an authorized user. Again, for example, I'm not certain of certain things, but I think based on this, what I see in the function is that it's trying to verify. The modifier is trying to verify that the originator of the person calling the function is basically an authorized user.
00:14:23.806 - 00:14:44.120, Speaker E: Yeah, but in terms of the purpose, it appears that the purpose is a contract that allows an authorized user to set the value of important, important being a private unsigned integer, 256K whatever important actually means. We can't tell from the code sample that you're given.
00:14:44.650 - 00:14:46.200, Speaker B: Yeah, okay.
00:14:46.570 - 00:14:48.760, Speaker F: Utility for something else maybe?
00:14:49.690 - 00:14:53.420, Speaker A: No, it is pretty much what?
00:14:53.870 - 00:14:55.370, Speaker F: Just a very simple thing.
00:14:55.520 - 00:15:28.486, Speaker A: It's just very simple because we've got to think that we've got to try and do this in 25 minutes. But you're right though, that it is about setting important. So the access control was limiting who could set important. And so that's good. So let's have a look in remix. So we've compiled it and then if we have a look over here and we deploy the code, then we've got some deployed code here. We've got this important function.
00:15:28.486 - 00:15:48.940, Speaker A: We've got add auth users that we can see. We've got add auth users set important. We've also got auth users and owner here. Does anyone want to take a guess at why we haven't defined those functions and yet we seem to have them available to us. Does anyone know why they are there?
00:15:51.170 - 00:16:10.180, Speaker G: The owner is there so that the function to add authenticated users should only be available to the contract. So you should probably write some function which modifier for all the honor, and then allow add authority for.
00:16:13.270 - 00:16:17.270, Speaker F: Default accesses for the public properties.
00:16:17.610 - 00:16:18.390, Speaker A: That's right.
00:16:18.460 - 00:16:19.798, Speaker E: That's what I was going for.
00:16:19.964 - 00:16:50.222, Speaker A: Yeah, you're right. We're getting automatic accesses because they're public. But Ronnie gave us a good idea. He's saying that he's concerned that at the moment, anyone could add auth users. So we should have either an accessor or we should have something like message sender equals owner. That's good.
00:16:50.276 - 00:16:53.538, Speaker B: All right, so if you look at.
00:16:53.544 - 00:17:02.260, Speaker A: The code, then is this going to work? If you were going to run it? So, Sly, you're a smart guy.
00:17:02.870 - 00:17:05.186, Speaker B: Yeah, I know.
00:17:05.208 - 00:17:06.686, Speaker A: Joanne. Joanne's even smarter.
00:17:06.718 - 00:17:07.620, Speaker B: She's going to.
00:17:09.510 - 00:17:09.934, Speaker C: Saw.
00:17:09.992 - 00:17:14.546, Speaker D: And Frank's put it in the chat as well. There's no constructor to set the owner.
00:17:14.738 - 00:17:24.620, Speaker A: Yeah, that's going to. If we deploy this at the moment, it's going to be limiting ourselves to owner, but owner is just going to be the default value, which is zero.
00:17:25.150 - 00:17:26.140, Speaker B: All right.
00:17:26.830 - 00:17:43.726, Speaker A: And the good thing about this is, in a normal interview, of course, the actual person who's doing the interview would have been sharing their screen, and so you'd be watching them type, which is all good fun because it helps give them insight into the degree to which they know solidity.
00:17:43.918 - 00:17:44.322, Speaker B: But.
00:17:44.376 - 00:17:52.500, Speaker A: All right, so we're going to have constructor. And you can see, for people like myself, you can see what great spelling mistakes they do.
00:17:54.310 - 00:18:04.550, Speaker B: Is that the right term? Let's do that. Constructor. Why is that not red? That's not good.
00:18:04.620 - 00:18:18.620, Speaker A: All right. And we want to have owner equals message sender. All right, so now we should be, I think, a lot further along.
00:18:20.370 - 00:18:26.190, Speaker B: Yeah. Okay. All right.
00:18:26.260 - 00:18:27.360, Speaker A: What other things.
00:18:32.370 - 00:18:32.878, Speaker B: Need.
00:18:32.964 - 00:19:08.218, Speaker A: So, JD said, don't we need a way to record important for each user? So we don't. The idea is these users. So say, if Sly, Joanne and myself are the authorized users, any of us can set important. And so we don't need to have important on a per user basis. It's more we want to have it just one value, but limit it to them. So can anyone. So Cronjit said he's not so sure about TX origin.
00:19:08.218 - 00:19:14.430, Speaker A: So, Cronjit, do you want to tell people what's the difference between TX origin and, say, message sender?
00:19:17.010 - 00:19:56.566, Speaker C: From my understanding, TX origin basically could be someone actually starting a function call, but it could then go through another smart contract, which then basically calls it. However, the DX origin doesn't actually verify that. Doesn't verify that the person or the contract calling the function is the same as the message sender. I think that that is it, but I'm not super certain about it. It's just that I know to be very careful with TX origin and rather to use message sender.
00:19:56.758 - 00:20:07.600, Speaker A: Yeah, so TX Origin is the externally owned account that submitted the transaction overall, whereas message sender is the contract that called this function.
00:20:08.530 - 00:20:15.490, Speaker E: And while you're in there, can you bomb out of the. If once you've found true, otherwise you'd be just like scanning through the entire array.
00:20:16.310 - 00:20:25.422, Speaker A: Yeah, sure, we could do that. That's going to be a break, isn't it?
00:20:25.496 - 00:20:26.120, Speaker B: Yeah.
00:20:29.050 - 00:20:30.600, Speaker A: Sure, we can do that.
00:20:33.770 - 00:20:35.446, Speaker B: All right, let's deploy it.
00:20:35.468 - 00:20:50.274, Speaker A: Let's compile and deploy it. I can see a few issues, but it's nothing like running some code to help focus people. All right, so we've deployed it. All right, so let's go owner.
00:20:50.342 - 00:20:50.990, Speaker B: Who are we?
00:20:51.060 - 00:21:08.180, Speaker A: Let's get a copy of owner. We'll add ourselves as an auth user. Add auth user. Let's go. Set important. Let's set important to two because I'm an auth user now. Set important.
00:21:08.180 - 00:21:39.690, Speaker A: And it is Eric's saying we should maybe change it from an array to a mapping. That's good. And index is not reset after the first run and we've got all sorts of things flying through. All right, so here's something to think about. So where is index stored?
00:21:43.600 - 00:21:44.540, Speaker B: Storage.
00:21:45.200 - 00:22:09.380, Speaker A: Yes, exactly. Go to the top of the class. So index is actually stored in storage. So there's a few things wrong here. One is I've got an equals here rather than a single equals, which as we all know, if you do that, then index when it starts out as b zero. So then index will start at one, which would be pretty bad. But even if we do that, index is in storage.
00:22:09.380 - 00:22:56.150, Speaker A: So what this means is we go read from storage and then we're going to write to storage when we go plus plus. And then as we iterate through that array, we're going to be reading out of storage all the time. And reading out of storage all the time is going to be a complete nightmare because it's going to use a ton of gas. So an iterative thing towards fixing this would be just to have u in 256 here. But then, as someone has rightly pointed out, maybe what we really want to do is make this a mapping. So what's it going to be? A mapping between though?
00:23:02.410 - 00:23:04.070, Speaker D: Address to Boolean.
00:23:04.410 - 00:23:05.160, Speaker B: Yeah.
00:23:06.970 - 00:23:24.360, Speaker A: All right, let's make that public again. All right, so now we've got to change this in some way. So how are we changing this?
00:23:24.850 - 00:23:27.360, Speaker B: It's a.
00:23:27.810 - 00:23:38.184, Speaker A: So obviously we're going to do auth users. All right, I'll do it.
00:23:38.382 - 00:23:39.930, Speaker C: OD users address.
00:23:43.660 - 00:23:46.044, Speaker B: Yeah, so I think so.
00:23:46.082 - 00:24:07.510, Speaker A: If we do that now, we're not iterating through a loop in an array and we're all good. So message sender is an address. This will equate to a Boolean, which will be true if the user has been added. So obviously we now need to change this code here as well.
00:24:12.760 - 00:24:14.070, Speaker B: It, yeah.
00:24:15.880 - 00:24:30.104, Speaker A: So there we go. So we've done that little bit of code. So now I think we're standing on top of the world. So now we go back, we recompile it, no compilation errors, which is all good.
00:24:30.302 - 00:24:45.710, Speaker F: So the TX versus the origin versus message gender, is that because you use TX origin there could be a Trojan attack on a real person where you go and.
00:24:46.160 - 00:24:48.624, Speaker A: Yeah, look, I think having tricks them.
00:24:48.662 - 00:24:50.450, Speaker F: Into sending you a message.
00:24:51.540 - 00:25:51.430, Speaker A: Yeah, you could have some ERC 20 buried like 50 layers deep in the call stack and then you could have TX Origin say, which calls a contract, which calls another contract, which ends up calling the ERC 20 and says transfer money. And if you just were checking TX origin, then you'd be in trouble. But if you were checking message sender, then you're saying, does the contract that's calling me have the right. So you might use TX origin. So in the GPAC code I've used TX origin to compare it with message sender to say, well, is the thing that called this an externally owned account now, because obviously you can't call from an externally owned account to a contract and back to the EOA and then back to another contract. So if TX origin equals message sender, then the contract call must have come from an externally owned account. Beyond that, I'm not sure why you would use TX origin.
00:25:51.430 - 00:26:28.364, Speaker A: Okay, so let's deploy. All right, so we've deployed it. Let's have a look at owner. Copy that. Add me as an authorized user. And now if we look at zero auth users, what's happened here? Invalid address. Yes, because now it's not give me out a certain index.
00:26:28.364 - 00:26:46.340, Speaker A: It's going to be if I put an address in, it's going to return true or false and it returned boolean true. Whereas if I get that address and say change it from C four to C three and do that call, it should hopefully return false.
00:26:47.000 - 00:26:47.860, Speaker B: Mmm.
00:26:52.220 - 00:26:54.356, Speaker A: Okay, you've done a required.
00:26:54.388 - 00:26:59.370, Speaker E: So it's going to throw an exception, isn't it, on twelve?
00:27:04.080 - 00:27:06.956, Speaker A: No, because I'm actually calling the automatic function.
00:27:07.058 - 00:27:08.430, Speaker E: Oh no, it's 22.
00:27:09.440 - 00:27:29.590, Speaker A: Which one are we firing? I'm calling the automatic function that's generated here auth users. And I'm putting in the address and it should be coming back false. What about if we do like zero? Is it going to say.
00:27:31.800 - 00:27:32.276, Speaker B: All right.
00:27:32.298 - 00:27:36.980, Speaker A: It doesn't like zero, x zero as an address, which is just what you want.
00:27:37.050 - 00:27:37.750, Speaker B: All right.
00:27:39.500 - 00:27:43.850, Speaker C: You should be able to copy an address from up there in the address.
00:27:45.980 - 00:27:48.856, Speaker A: Add address, check some, oh, I know what the problem is.
00:27:48.878 - 00:27:49.112, Speaker B: Yeah.
00:27:49.166 - 00:27:55.416, Speaker A: It's an invalid address. So what I really need to do is find a real address, which shouldn't.
00:27:55.448 - 00:28:04.140, Speaker C: Be too hard, should be up the guest limit there. Above there's a whole list of addresses under accounts.
00:28:04.880 - 00:28:07.456, Speaker A: So under where accounts, if you click.
00:28:07.478 - 00:28:13.936, Speaker C: On the accounts, it'll give you a whole list of accounts and you can actually copy. If you scroll up. There you go, under account.
00:28:14.118 - 00:28:14.850, Speaker A: Okay.
00:28:15.780 - 00:28:18.550, Speaker C: So you can just choose whichever one copy from.
00:28:18.920 - 00:28:19.492, Speaker B: All right.
00:28:19.546 - 00:28:28.104, Speaker A: There you go. Learn a new thing every day. No need to use your false. All right, that's good.
00:28:28.222 - 00:28:29.112, Speaker B: That's very good.
00:28:29.166 - 00:28:33.770, Speaker A: All right, thank you. All right, let's get important.
00:28:38.580 - 00:28:39.330, Speaker B: Yeah.
00:28:40.100 - 00:28:42.480, Speaker A: Yes, exactly. True. Good on you, Mark.
00:28:42.550 - 00:28:43.248, Speaker B: You're right.
00:28:43.334 - 00:28:50.820, Speaker A: So at the moment, now we've got to the point that we've said, oh, just a sec, important is private and there's no getter. So let's add a getter.
00:28:52.440 - 00:28:53.092, Speaker B: Yeah.
00:28:53.226 - 00:29:18.220, Speaker A: Okay. So we'll get rid of them, go back here, compile it. So now we should be able to go in here, deploy the contract, have a look, get the owner, copy that, make the owner an auth user. And now we should be able to set important three and go important and get three back.
00:29:18.290 - 00:29:18.684, Speaker B: All right.
00:29:18.722 - 00:29:22.928, Speaker A: Cooking with gas. We're all doing very well, which is good.
00:29:23.094 - 00:29:38.870, Speaker E: Just to expose my solidity ignorance and fail the interview test. Does that mean that when public properties of the contract, they don't have a set function automatically, like public is effectively making it a read only? There's no such thing as a read write property.
00:29:39.720 - 00:29:42.100, Speaker A: Yes, that's correct. There's no such thing as.
00:29:42.250 - 00:29:46.984, Speaker E: Yeah, I was thinking of other languages where if you said public, you'd be effectively making it a read write property.
00:29:47.182 - 00:29:47.640, Speaker B: Yeah.
00:29:47.710 - 00:30:08.700, Speaker A: Whereas public is just saying. So for properties, it's meaning create an automatic reader. If it's a function, it's meaning I can be called within the contract or externally. And then there's internal, private and external.
00:30:11.300 - 00:30:11.760, Speaker B: Yeah.
00:30:11.830 - 00:30:13.916, Speaker A: Do we want to have a way of revoking?
00:30:14.028 - 00:30:14.400, Speaker B: Yes.
00:30:14.470 - 00:30:23.816, Speaker A: So what's that going to be like? So that would be copying that. And now we've got, say revoke.
00:30:23.868 - 00:30:25.350, Speaker B: Yeah, revoke. Why not?
00:30:27.240 - 00:30:32.240, Speaker A: And so we're going to have them. You've got to make sure they're right. And then we've got false.
00:30:32.320 - 00:30:33.508, Speaker B: That's a good one.
00:30:33.674 - 00:30:41.032, Speaker A: Can do that. All right, so we've done that.
00:30:41.086 - 00:30:41.544, Speaker C: Done that.
00:30:41.582 - 00:30:42.410, Speaker B: That's good.
00:30:43.740 - 00:31:00.830, Speaker A: All right, let's add an event to the code so we know when important is changed and changed by who. So we're saying we've got a pool of users who can change important. So how do we create an event?
00:31:05.840 - 00:31:38.490, Speaker H: U I think just we define the event above the cope, maybe just below the important variable. And then we define what kind of variable that the event is going to output. First of all, we have to give the name to event. Maybe we can say important has been set and then we put the address as well as the value of the important as well. And afterwards we put the emit function inside the set. Important function.
00:31:39.340 - 00:31:51.010, Speaker B: Yeah, it.
00:31:56.900 - 00:32:01.970, Speaker A: All right, so we've got that now we've said important. All right, so that's good.
00:32:02.600 - 00:32:05.844, Speaker B: So now the next one is what.
00:32:05.882 - 00:32:47.250, Speaker A: We'D really like to do is identify who are the authorized users. So we want to have a string, but we're not going to worry about the actual string type. So we're going to use just ascii strings. And so we want to be able to look up, so have a mapping between an address and a string and a string and address. So we want to be able to essentially be able to have a string and find out what the address is of that authorized user. So how should things change to do that?
00:32:56.500 - 00:33:05.600, Speaker F: So you want basically give a tag to the addresses that you're storing in add author. So you probably want to add the string as a parameter.
00:33:06.840 - 00:33:07.588, Speaker B: Yeah.
00:33:07.754 - 00:33:08.944, Speaker A: Another mapping.
00:33:09.072 - 00:33:09.750, Speaker B: Correct.
00:33:10.760 - 00:33:11.984, Speaker A: And another parameter.
00:33:12.032 - 00:33:12.340, Speaker B: Correct.
00:33:12.410 - 00:33:30.410, Speaker A: So let's have it as a bytes. So add auth user, we're going to have a bytes and then we'll call that name and then maybe a mapping up here. So we're going to have a mapping. So what's it going to be between though? What's the mapping going to be between.
00:33:35.960 - 00:33:37.770, Speaker B: String to address? Right?
00:33:38.620 - 00:33:46.650, Speaker A: Yeah. All right, let's try that bytes. So there is going to be a problem with this. You'll find out when we try and compile the code.
00:33:49.200 - 00:33:49.900, Speaker B: Public.
00:33:50.050 - 00:33:55.820, Speaker A: And then that is auth users lookup.
00:33:58.880 - 00:34:00.930, Speaker F: Instead of a bool, we can use.
00:34:02.580 - 00:34:05.010, Speaker B: The bytes up there. True.
00:34:05.700 - 00:34:12.080, Speaker E: Then we need to change all the logic so that it's like calling the contains or whatever function of the map.
00:34:13.400 - 00:34:16.260, Speaker A: Yeah, it's not default.
00:34:18.520 - 00:34:19.300, Speaker F: Length.
00:34:19.720 - 00:34:45.790, Speaker A: Yeah, length is right. So that's good. And then we've got, all right, so here we're thinking we're going to have auth users lookup and we go in with, it's going to be what name equals, and then auth user. All right, so that's that.
00:34:46.720 - 00:34:49.288, Speaker F: And change the true to the name.
00:34:49.474 - 00:34:52.050, Speaker A: Yeah, change the true to the name.
00:34:52.500 - 00:34:56.450, Speaker F: And is length what's going to bite you in the.
00:34:56.900 - 00:34:59.948, Speaker A: No, something far more, far more complicated.
00:35:00.044 - 00:35:04.688, Speaker B: And I wonder here, let's go back here. Compile. Boom.
00:35:04.864 - 00:35:09.828, Speaker A: All right. We've got to say that that is call data. Call data.
00:35:09.994 - 00:35:15.928, Speaker B: So that's good. Compile, no matching type declaration. Ten.
00:35:16.014 - 00:35:16.532, Speaker F: Lookup.
00:35:16.596 - 00:35:19.050, Speaker A: Line 15, comma, nine.
00:35:23.500 - 00:35:28.324, Speaker B: That should work, shouldn't it? Just a sec.
00:35:28.462 - 00:35:29.260, Speaker A: Length.
00:35:31.120 - 00:35:32.076, Speaker B: All right.
00:35:32.258 - 00:35:39.070, Speaker A: Because you're getting the value, which is not a boolean. It'll be a uint 256. So let's compile the code again.
00:35:39.760 - 00:35:40.704, Speaker B: Bool is not set.
00:35:40.742 - 00:35:42.050, Speaker A: Line 32.
00:35:42.500 - 00:35:43.250, Speaker B: Yes.
00:35:43.780 - 00:35:53.200, Speaker A: So given that we're saying we're doing that, so what we now need to do is make that byte. So it's an empty string.
00:35:57.780 - 00:35:58.530, Speaker B: Up.
00:36:02.670 - 00:36:05.900, Speaker A: Is it going to be memory byte zero?
00:36:08.290 - 00:36:10.830, Speaker G: Can I just delete the mapping?
00:36:13.170 - 00:36:15.646, Speaker A: Oh, yeah, that'll be another way of doing it.
00:36:15.668 - 00:36:20.580, Speaker B: Yeah. Will that work?
00:36:23.670 - 00:36:47.562, Speaker A: That's interesting. This must be an ABI. So I was hoping that this was actually going to fail. And it must be a solidity nine thing or something like that. So historically that would have failed and you would have had to use a bytes 32 there. And then the question is, if you're using a bytes 32. So let's assume that we do want to use a bytes 32 there.
00:36:47.562 - 00:36:55.354, Speaker A: How are we going to create a hash or bytes 32K?
00:36:55.472 - 00:36:58.700, Speaker B: Yes. Yeah.
00:37:01.870 - 00:37:06.302, Speaker A: So we've got keck 256.
00:37:06.436 - 00:37:17.780, Speaker F: Yeah, because I don't know, how does a variable link, that's what I was trying to refer to in terms of the size. How does a variable link byte the users the key?
00:37:18.550 - 00:37:45.846, Speaker A: Yeah, it's doing this internally. So then at this point, then it's Abi encode packed. So this is obviously in the latest and greatest version of solidity being done under the covers, which is why solidity is so. Yeah, that's true. So it's going to return. Yeah, true. So we don't actually need to do the AbI encode pact.
00:37:45.958 - 00:37:46.620, Speaker B: True.
00:37:48.510 - 00:37:54.190, Speaker A: But anyway, the kick Act 256 will get us there. And then at that point we'd use name hash here.
00:37:54.340 - 00:38:16.950, Speaker I: So I have a question, Peter. I don't really understand one thing. So bytes is supposed to be an array of bytes one. So if it's empty, your test with length is not going to work. So you should prevent anybody to add a user with a name that's an empty array.
00:38:17.530 - 00:38:28.890, Speaker A: Yes, well, that's true. Very true. So when you were here, we should be require. Let's see. Name length.
00:38:33.070 - 00:38:33.820, Speaker B: Yeah.
00:38:41.010 - 00:38:48.720, Speaker A: Good on you, Frank, for detecting the bug. You didn't need to do formal verification for that either.
00:38:49.270 - 00:38:53.570, Speaker I: I did. I was in real time coding your contract in Daphne.
00:38:53.990 - 00:38:54.594, Speaker B: Yeah.
00:38:54.712 - 00:39:15.050, Speaker E: I've got a question on line 15 where it's got like dot length. If you were to give it a well formed address, but an address that hadn't been added into the mapping, would that give you the solidity equivalent of a null pointer violation? Because there's no bytes array to be returned.
00:39:16.430 - 00:39:42.500, Speaker A: No, because there's no null. Yeah, there's no null. What will happen is the bytes where the memory location is all zeros is the equivalent of. If you interpret that, you work out that the lengths of the byte array is zero. So its solidity is very well designed so that the default for anything is something that makes sense.
00:39:44.390 - 00:39:49.250, Speaker F: Mapping always has a value. If it hasn't been said, it's the default.
00:39:50.070 - 00:40:43.560, Speaker A: Yeah, and that's the same for any memory location. All right, so then at this point I then was going to dive into libraries, which is a good thing to do. So as far as at the moment we've gone and used, done our ownable essentially. And we could also have things like pausing, which would be another good thing. What would be good to then do is try and talk about things like open Zeppelin where you've got these contracts that have been put together by a group of people and lots and lots of people have looked at them. I don't know if they've been formally verified, frank, but I guess there's enough people. And actually I think there was some effort to do some level of verification on them, but.
00:40:44.570 - 00:40:45.320, Speaker B: Yeah.
00:40:48.330 - 00:41:33.606, Speaker A: Yes, well actually Hayden has said, look, revoke auth user doesn't delete the auth user's lookup so it doesn't need to. However, if it did, you would get 5000 gas back. So it would save you gas when you did this call. All right, so we've done a fair bit on that one and that's actually kept us going for one and a quarter hours. Quite amazing. All right, and so the next bit of code is going to be. Here we go.
00:41:33.788 - 00:41:34.710, Speaker B: Copy.
00:41:39.690 - 00:42:16.640, Speaker A: All right, so this is some smaller code. I'll put this into the chat as well. So have a look at this code. This is some code I did quite a while ago for someone as a birthday present. And there was a bit of ether stored inside the contract or the deployed contract. Have a look at this code and tell me what it's doing and how you could extract the ether, especially if you happen to have a big, were given on a piece of paper a very big long number as well.
00:42:20.850 - 00:42:21.800, Speaker B: You it.
00:42:56.570 - 00:44:03.760, Speaker A: Okay, repeat the question. And so the question was, what is the code doing and how would you extract the cache? So Qi Chuan has said, is it about brute forcing the hash? So it's not quite brute forcing the hash, but you're not too far off. So what you've got is you've got a user is defined, and I've even given a hint by the variable name as it being a masked user. And we can have a look here and we can see that masked user must equal the message digest of message sender. So I figured given I was deploying a contract onto Ethereum Mainnet, it seemed to be a really good idea to limit who could take the money to the intended recipient, the person whose birthday it was. So the big long number, or there were two big long numbers. One was the deployed contract address and the other was the private key, which you could then convert into a public key and then you'd have the address.
00:44:03.760 - 00:45:22.390, Speaker A: So the idea was that then if you've got the private key, you submit a salt to happy function, and then what it does is it does the salted message digest of the address of the user and that's the mask. And then what you've got to do is work out a mask that will, when modulo two to the 16 plus one will give you zero. And so if you can do that, then you end up getting the value. So you do need to brute force to work out salt, but you're only trying for two to the 16 combinations. So once you've got your little bit of JavaScript or Java or pick your programming language, then you're all good. Yeah. So why did I do the salt? Rather than just saying, look, if you've got this far, why do we need to have this extra check? I just thought it'd be interesting to force the person to learn a bit of solidity and a bit of cryptography.
00:45:22.390 - 00:45:42.254, Speaker A: So just something for them to learn about. I was studying a math degree, so I didn't think doing a bit of crypto would be too hard. So I can drag this across to.
00:45:42.292 - 00:45:42.880, Speaker B: Here.
00:45:44.610 - 00:45:57.300, Speaker E: Just to check one thing, because the happy recipient doesn't have to actually write to the contract, write any data to the blockchain. They shouldn't get gas fees, should they, for just calling it.
00:45:59.670 - 00:46:05.170, Speaker A: It is a transaction and you are updating the ledger because you're transferring balance.
00:46:06.710 - 00:46:11.234, Speaker E: If they don't succeed, if they don't get the right value, yeah, then they'll.
00:46:11.282 - 00:46:31.462, Speaker A: Fail the require and they'll burn the amount of gas they've put up to execute. So yeah, they will burn gas. So what you'd want to do is work this all out offline so that you only present the right salt. You wouldn't be banging in 65,000 dud transactions. Otherwise you're going to burn a lot of gas.
00:46:31.606 - 00:46:33.100, Speaker E: More than the birthday present.
00:46:33.870 - 00:46:50.690, Speaker A: Yeah, well, it depends how much the birthday present was. Now you're making thinking of a cheapskate and only you had five birthday present. But yeah, these days, if it was on Ethereum main net and you were at two or $300 a transaction, yes, you'd want to have a rather large birthday present for it. Worthwhile.
00:46:51.030 - 00:46:52.900, Speaker F: One or two e should be okay.
00:46:53.430 - 00:46:57.990, Speaker G: The constructor didn't hash the name of the user.
00:46:58.570 - 00:47:48.600, Speaker A: No, it didn't, because if it did that, then I was concerned that you could have an attack where maybe if you had that address just available to anyone, it might be. It should be quite safe. But the addresses are only 160 bits in Ethereum. And I thought doing essentially rehashing it made it slightly harder for people to just general attackers to break, because then they were trying to break kick Act 256, the full digest. But I mean, by the time where someone got their quantum computer and broken 160 bit hashes, I think we're all in trouble. Anyway. That's a bit by the by.
00:47:48.600 - 00:47:58.200, Speaker A: So that was something that I didn't need to do. But it also, again, added some complexity into what was actually going on.
00:48:00.110 - 00:48:00.474, Speaker B: And.
00:48:00.512 - 00:48:02.730, Speaker G: Shouldn'T function happy be payable.
00:48:05.630 - 00:49:07.530, Speaker A: Yeah, it's ancient solidity, so not in that era, but yes, new things have been added to make it payable. So a big question. Is the original test, is it too hard or too easy or is it just right? Because it's going to allow people to demonstrate their knowledge and the speed with which they can do it and the degree of help and handholding needed will define how good they are at solidity. I think that's where I got to. You could have other things in it, but I don't think you really need it. And I know we skated over the whole EVM gas cost thing, but I think. Yeah, all right, so one person has at least said that they think the test should be a bit harder.
00:49:07.530 - 00:50:02.526, Speaker A: And I guess it really comes down to what are we trying to prove here, are we trying to differentiate between people who are awesome and people who know enough? And if it was really about trying to find some top star solidity developer, then I could imagine that what you're going to be doing is having more weight in the overall interview process on solidity, which comes back to the process, and that is that this is part of a much bigger process. And really, the test is a lot more than just reading and writing solidity. It's going to be about how good you are at communicating and whether you can problem solve and work out stuff on the fly, which is what working in one of these jobs is all about.
00:50:02.628 - 00:50:20.020, Speaker F: I don't think in 25 minutes you're going to learn much more than the basics of what a person in terms of the depth of their knowledge. The harder you make it, probably the less you'll actually learn about them.
00:50:22.250 - 00:50:38.970, Speaker A: You risk losing the fine grain. We had one candidate who was worried about the fact that there were external functions, because anyone on the Internet could call that function, and it's like, well, how does this thing going to work if you don't have externals?
00:50:41.250 - 00:50:42.000, Speaker B: Yeah.
00:50:47.090 - 00:50:50.640, Speaker A: Are there any other thoughts on this before I talk about what's coming up next?
00:50:51.490 - 00:51:06.566, Speaker G: Some basic security checks, like how the user knows about the developer knows about security, like checks that check effects before transferring or doing any kind of. So that could be interesting to add.
00:51:06.748 - 00:51:07.574, Speaker B: Yeah, okay.
00:51:07.692 - 00:51:09.510, Speaker G: Or reentrancy checks.
00:51:11.610 - 00:51:13.330, Speaker A: I just like to clarify.
00:51:13.490 - 00:51:55.970, Speaker C: I'd like to ask if you could clarify, is this the level of complexity that we would be expecting from an interview? Because I've always been afraid to apply, because I always feel like, hey, look, beyond reentrancy controls and stuff like that, I don't have any further in depth knowledge. Things like using hardhead and stuff like that, whereas this seems relatively easy. And it's just asking the basics, which I think I'm fairly comfortable with. So I just like to ask if you could clarify, what exactly is the level of knowledge you expect from someone who is actually applying for various roles?
00:51:56.390 - 00:52:39.330, Speaker A: Well, it really depends on who they are and what role they're applying for. So this was aimed at someone who was going to be part of the cross chain team, and solidity was one of many, many things that they needed to know. So it wasn't like they weren't waking up and all they were doing was solidity. And in fact, it was something, a skill that was good for them to have, but not something they'd need. So I'd say having some familiarity with truffle and metamask. But then you're starting to talk about an overall JavaScript as well as solidity as well, which would be part of a much bigger type of interview.
00:52:43.550 - 00:52:44.860, Speaker C: Okay, thank you.
00:52:46.190 - 00:53:20.470, Speaker F: Coding tests. What we often used to do is we would do a do it yourself, here's a problem, go away, solve it, submit the result, and then that way we could review it asynchronously. That was earlier in the review process, then later in the view review process, we'd have that one on one pair programming where we'd actually bring up one of the samples that they had written.
00:53:24.330 - 00:53:58.660, Speaker A: We found that we've had various forms of that sort of initial test, and in fact we had a hacker rank thing at one point, and we've had a take home test of other types, and it doesn't filter out heaps of people, or it ends up being very labor intensive to mark. So if you can do automated marking, then it doesn't filter out many people. And if you have something that maybe does start to filter people out, then it's pretty intensive. We've ended up dropping it.
00:54:00.070 - 00:54:00.820, Speaker B: But.
00:54:03.850 - 00:54:11.670, Speaker F: Yeah, you still need the review because otherwise people go and copy it from the Internet.
00:54:12.970 - 00:55:14.570, Speaker A: Yeah. And at the end of the day, consensus is a big company and I'm one person, and I think having different processes and different interviews that people go through that are job specific make a lot of sense. But yeah, look, as far as various people being concerned about whether they should or shouldn't apply, go for it. If there's a job available where they're asking about skills that you've got, go for it. I mean, consensus is very busily hiring lots of people, which comes to the next event in two weeks time. We're having a networking and recruitment event. And so if you're an employer and you're looking to hire some people, please get in contact, and if you're not looking for a job, please turn up anyway and we'll have breakout rooms and you can meet people and just get to know some more people in the ecosystem.
00:55:14.570 - 00:55:43.010, Speaker A: After that, I'm going to do a talk on more advanced solidity, because I did a talk on advanced solidity quite a few years ago and I was just thinking maybe having an update on that could be interesting. And then Lecky is going to do an e two staking as a service talk, and then that QbfT consensus protocol talk is going to come up in February.
00:55:53.720 - 00:55:56.756, Speaker B: So, yeah, so we've got it.
00:55:56.778 - 00:56:05.230, Speaker A: I'm just monitoring the chat. But anyway, look, I think it's all good. All right, look, thank you, everyone. Have a great day and.
00:56:07.440 - 00:56:09.848, Speaker B: Talk to you all later. Bye bye.
00:56:09.944 - 00:56:10.760, Speaker I: Thank you, Peter.
00:56:10.840 - 00:56:11.592, Speaker D: Thanks, Peter.
00:56:11.656 - 00:56:12.216, Speaker B: Thank you, Peter.
00:56:12.248 - 00:56:13.180, Speaker F: It was excellent.
00:56:15.040 - 00:56:15.960, Speaker C: Thanks, Peter.
00:56:16.040 - 00:56:21.290, Speaker B: Bye. That was the best e zoom I've ever been to. Thank you very much.
