00:00:00.410 - 00:00:37.510, Speaker A: Hello and welcome, everyone. I'm Peter Robinson, and this is the Ethereum engineering group meetup. So today I'm the one who's going to give the talk. And it's all about security. So smart contract security and solidity security. So a tiny little bit about me, about 30 years experience developing products, of which I did 13 years at RSA doing cryptography and that sort of stuff, and five years at consensus working on blockchain things. And with that, I'll share my slides.
00:00:37.510 - 00:01:05.004, Speaker A: Ok, so can people see some slides? I'm getting some thumbs. That's good. Thank you. All right, so I didn't do all of this by myself. I've had help, and it's nothing like being able to run slides past people and have them go, they're good, they're bad. And I don't know that I've got all the names. Joanne, your name should be there because didn't you.
00:01:05.004 - 00:01:26.760, Speaker A: You pointed something. You did. All right, Joanne's name's there as. And there's probably a few other people who I didn't get back and edit the names in. So anyway, so sorry about that, and thank you, everyone. So today I'm going to give a. Sure, we can have a transcript.
00:01:26.760 - 00:02:17.592, Speaker A: All right. So today I'm going to go and give some overall context. And then we're going to talk about the Ethereum client, the EVM, Abi, and solidity, and then talk about high level things to consider. And then we're going to dive into solidity and work out some of the issues related to that. And then we're going to work on some complex stuff and also some tools that are out there. And so by the end of this talk, I'm actually going to go over a really interesting thing, and that is how to change the bytecode of a deployed contract. And this is without actually using proxies, this is actually the deployed code at a certain address, how to change that code.
00:02:17.592 - 00:03:05.972, Speaker A: And I didn't think it was possible before I started working on this talk, but I now know it is. So you might notice the dark forest background. And so the dark forest was a term introduced by a Sci-Fi author. And I'm not going to even try and say the name, but I believe it's something like Yui Xi Shen. But that's probably completely wrong. So anyway, they were a science fiction author, and they had some world where as soon as you identified someone else's location, then there were these super predator things that would come along and kill them. And so Dan Robinson and Georgia Costentinopoulos, they brought the term to the crypto space to identify the adversarial environment of the Ethereum mem pool.
00:03:05.972 - 00:04:11.684, Speaker A: And so what that was all about was that once you say, here's a transaction that could earn some money, then other people see that and they say, hey, and they grab that and they get in front of you and they front run your transaction. So I'm going to reuse that term in a slightly different way, because if you've got a weakness in your contract, then you should expect people and bots that are created by these people to find weaknesses and exploit it. So Ethereum is a dark forest, and so you should watch out when you're working on stuff. We're going to journey through this dark forest and hopefully survive. So some context. So there are two subtly different, but maybe the interrelated things, and there's smart contract security, and then there's solidity security. So smart contract security is security where it's really defined by the properties of the EVM, whereas solidity security, it's really you're writing that smart contract in the solidity programming language.
00:04:11.684 - 00:05:04.716, Speaker A: And so maybe there are some overlays on top of that. And so what does a contract actually have? So it's got some code, storage, balance and nonce, and generally the code can't be updated. So I am going to tell you how to update the code later on, but in most situations that's just not going to happen. So you're worried about the storage and balance and the nonce unexpectedly changing in ways that you would prefer they didn't. And that includes self destruct, which is obviously a really special condition where you essentially wipe out everything and remove the whole contract. So that's a rather undesirable state change, potentially. And then another one is that you've also got the possibility of the whole contract getting stuck.
00:05:04.716 - 00:05:48.888, Speaker A: And so what that means is that the contract suddenly can't be used anymore. And if you have the contract so it can't be used, then that's also going to be really annoying and not what you want. So when you're thinking about blockchain, you've got to be thinking about the whole application you're writing. And so invariably you've got a set of contracts. It's not normally just one single contract, it's a set of contracts that call each other. Maybe you've got some off chain node that talks to those contracts. It might use infura or some other gateway service to talk to the blockchain.
00:05:48.888 - 00:06:41.220, Speaker A: You're going to have some admin that's going to use metamask to fire some transactions in. You're also going to have users that are going to have metamask or maybe some other wallet, and they're going to interact with some website, and that website is going to have linkage so that then you can open up metamask to submit some transaction for some on chain activity. That's a pretty typical sort of application. The thing to think about is that the smart contracts are just part of this, larger applications, and these attackers often target other bits of the application. They don't necessarily target your smart contracts. And also, as I was saying, you got to think that these smart contracts aren't just by themselves, they're NLT and typically like in a group. So you got to look at the whole group of contracts and also you got to analyze them separately.
00:06:41.220 - 00:07:44.240, Speaker A: So you've got to think about the whole context and you've also got to think about the users. So with a recent attack, it was really about very complex social engineering. I mean, it was about bad DevOps as well, but it was also about really clever social engineering of the administrators. And so you really got to think that the security of your application is more than that, just the contracts. So when you're looking at your threat modeling, and I encourage everyone to do threat modeling of their application, you need to look at your attack surfaces. And obviously the smart contracts are going to be a really big public attack surface, but there are others, and so don't ignore them, otherwise you will be hacked, and it won't be by your smart contracts, it'll be by other things. So saying all of that, now let's actually look at those contracts.
00:07:44.240 - 00:08:29.388, Speaker A: And so when we think of smart contract security, really we're overlaying a few different things altogether. So you've got your Ethereum client, which is the software that runs the Ethereum node. You've got the EVM, which is something that executes inside of that software. You've got the ABI, which defines how you interface with the overall program and the solidity programming language itself. And so you really need to understand all of these things to be able to do good smart contract security. And so what does the Ethereum client software give you? Well, really you've got two different types of calls that you can have. So you can have ETH call RPC method, and that's typically used for view calls.
00:08:29.388 - 00:09:27.350, Speaker A: And so what you're doing there is you execute the contract on a local node and you get a value back. So you're not including that call in a block and so you can't change state. So even if you called something that could change state, those state updates aren't going to become part of the blockchain simply because you're just executing on a local node. If you use, on the other hand, ETH sent raw transaction RPC method, then you are giving yourself the opportunity. So you submit a transaction, it gets included in a block and then it gets executed. And so the EVM will either commit or discard those updates depending on what the last opcode that executes is. So if the last opcode is stop, return or self destruct, you will update the state, but if it's revert or invalid, then you're not.
00:09:27.350 - 00:10:06.636, Speaker A: And so it really comes down to how the code executes. But I think it's really important to understand that just at a very high level, just the Ethereum client software can say whether these states are going to be applied or not, just based on which method you call. So normally you're going to call send raw transaction to update the state and call when you're doing a view call. But it's useful to understand those two. Then you've got the EVM. So the Ethereum virtual machine, and so this is defined by the yellow paper. And so the yellow paper has been updated quite regularly.
00:10:06.636 - 00:11:02.800, Speaker A: And so when you have forks in Ethereum you'll find that often part of it is to update the EVM, maybe the gas costing or something along those lines. And so all of the byte codes are talked about described in the yellow paper. And so with the EVM, every single contract starts at offset zero. And so doesn't matter what functions you've got, what you've got, what language it's written in. As far as the EVM is concerned, everything starts at zero and it just goes through and executes each individual instruction one at a time. You've got to think that whether it be a view call or a transaction, you're doing a cross contract call or it's in an code segment, that's what's so. The other thing that the EVM is giving you is things like return.
00:11:02.800 - 00:11:53.040, Speaker A: And so for instance with an init code fragment, you're copying the code that you're going to return to offset to a certain offset. And then the return code is used to say, well, data at this offset and this length should be taken as the return value. And then the EVM, when it's the init code, it uses that returned information as the contract. Yeah, so that's down to the EVM. The ABI is something which is completely separate to the EVM, and it defines how contracts of any programming language should communicate with each. So it's strongly typed. And so that means, and it's defined at compilation time.
00:11:53.040 - 00:12:45.376, Speaker A: So what that means is that you have functions in your contracts, and they define what parameters they're going to have. So the ABI doesn't support the idea of having some dynamic parameters going into a function, it just doesn't support that. And so the ABI defines how functions are called. And so it talks about, say the four byte function selector. So that's essentially the truncated hash of the function signature, and it then has the parameters. So all the parameters are done as 32 byte blocks in the overall call data. And so for instance, you've got that 20 byte address, and it's stuffed in with twelve bytes padding.
00:12:45.376 - 00:13:41.044, Speaker A: And you can have arrays and anything that you can think of that you have as parameters to a function, they are encoded using the ABI. And so it really comes down to, you can read the ABI spec to understand how all that encoding occurs. And so the ABI isn't just used when you're calling functions, it's also used in return values. So say, if you've got, say you're returning a Uint 256 and an address that will be ABI encoded. Also, when you've got reverts or panics happening, you will get the actual function selector followed by the function parameters are encoded as a return in that case. So you have panic you int 256 or error string. And you can also with recent solidity versions, have your own custom different error messages as well.
00:13:41.044 - 00:14:31.504, Speaker A: Event parameters are also encoded using ABI encoding. And then we've got solidity. So it is a language which compiles down to EVM bytecode that can be executed in the EVM. So it's not just that it compiles to bytecode, but it's bytecode that is designed to start at offset zero, has an init code that will return the code to be executed at runtime, and follows all of the other rules of the EVM. And it also follows the ABI encoding rules. So it knows about function selectors and it decodes parameters based on that ABI specification. And so solidity has actually a lot of extra features that are not part of the EVM.
00:14:31.504 - 00:15:51.784, Speaker A: So often people think of stuff as being just part of the smart contract. And as Joanne pointed out, there is actually a lot more and really understanding. So understanding the difference between what the EVM supplies and what the smart contract supplies or other the solidity compiler supplies is really important. So when you think of payable and the enforcement of payable, it is really down to the people who created the solidity compiler noticing that keyword and then saying, all right, well, the value of this transaction, if it's not zero, then we should fail because this function is non payable. And then there's a whole stack of things you can see there that are things that exist in solidity but don't exist in the EVM. And so to really understand what the EVM specifically gives, you have a look at that YouTube video that I've got a link to there. And so all of these features, and some of them are really security features like payable certainly is, and say the revert chaining across contracts, things like that are certainly security features.
00:15:51.784 - 00:16:39.470, Speaker A: And when you're using solidity, you're assuming that the compiler creators created it without bugs. And that's probably the case. But the compiler hasn't been fully verified, and so there may be bugs in the solidity compiler itself. And as well, in solidity you can dive into assembler code, and a lot of my examples I'm going to have later on do dive into assembler code. And so once you're an assembler, you can do anything. Anything the EVM can do, you can do. Given that you can dive into assembler code from solidity, then maybe smart contract security and solidity security are the same thing.
00:16:39.470 - 00:17:15.296, Speaker A: And I don't know, what do people think? Is that a fair comment? Well, there are obviously other smart contract languages like Viper, for example. I guess. True. That is true. But is Viper security the same as solidity security and the same as smart contract security? Have we got down to the same thing? I guess the EVM is the fundamental. Right. So there's also a huge trend at.
00:17:15.318 - 00:17:19.564, Speaker B: The moment, which is building secure languages to deal with security features.
00:17:19.612 - 00:17:23.732, Speaker A: So that has not made it yet to the smart contracts world.
00:17:23.786 - 00:17:27.940, Speaker B: But there are some people designing secure languages.
00:17:30.200 - 00:18:08.092, Speaker A: Yeah, that's true. So I guess at that point you would have a separation. All right, so what about security? So here we are. We haven't actually talked about security yet, so let's talk about security. And my top level advice before I talk about security is have as little in your contract as possible. If you could get away with one line of code that just stores one uint 256 and gets it, then maybe that's what you should do. So it's going to be cheaper it's going to be simpler, there'll be less to go wrong and it'll be harder for people to hack.
00:18:08.092 - 00:18:44.744, Speaker A: So less is more when it comes to smart contracts. Top level thought. So some high level things to consider. Let's talk about upgrade. And so there's the proxy pattern, and then there's the pattern where you have data separated from your business logic as ways of upgrading. But the proxy pattern is a really good one, and I think quite commonly used. So upgrade, it's a good thing because let's face it, coder has bugs and you might come across a bug and you want to upgrade your logic.
00:18:44.744 - 00:19:21.140, Speaker A: And so that's good. And also you might think, hey, I want to add a new feature to my code. But of course, when you upgrade, you can inadvertently introduce some errors. And so that could be either in the data used for the upgrade or the code itself that you're upgrading. So someone could have been using a contract for years that was nice and solid, and now you upgrade it, and now you've suddenly made your user vulnerable. So that's a big thing as well. Some people, they'll look at the code and they'll say, well, this code can be upgraded, so you could add in some attack method like withdraw all coins.
00:19:21.140 - 00:20:21.884, Speaker A: And that's not a good thing. I wanted to not be able to have people just steal all my money. And so the other thing is, well, who gets to do this upgrade? Who chooses what group of people or single person? And what security procedures do they use and can they be hacked? So, say, if you need three out of four people to do stuff, but they all have their password stored in plain text somewhere on their computer or on Google Drive or, I don't know, somewhere, and they get hacked, some malicious person could do the upgrade and maybe they could put in the withdrawal all coins thing. So even if you trust people running the thing, if you don't trust them to be secure, it's a big issue. So upgrade is a top level, really hard thing to think through. Nomad recently did an upgrade and they've got hacked for 150,000,000. And Ermius is going to talk a bit about that.
00:20:21.884 - 00:21:16.684, Speaker A: So he's doing a cross chain security talk in the coming weeks and not going into the details and not even fully understanding all the details because Hermes is the one who's really hammering hone on this. But at the end of the day, it's an upgrade issue. And so upgrading is something that needs to be not done lightly and done extremely carefully. Another thing to think about is pausing, freezing and banning. And so pausing is the ability to pause a contract in case of an emergency. So for instance, in the nomad contract, if they had have had a pause feature at the right spot, maybe they noticed 20 million disappear and they go, oh my God, they could have hit pause and stopped the other 130,000,000 going out the door. So that would have been a good thing.
00:21:16.684 - 00:22:14.412, Speaker A: And so before I talk about pause a bit more, you got to think you've got these insolidity. You've got something called modifiers. And so the idea is you define a modifier, and then you say, you define a function that uses the modifier, say a mod which takes a, you went 256. And so that effectively means you've got that function and it's now surrounded by this modifier code. So that some code executes before the main function's typical code does and some code executes after. And so it's good if you've got a lot of functions that need the same type of modification, like require owner equals this authorized or message sender equals owner or something like that. So in the context of pausing, if you look at open zeppelin, they've got a pausability contract.
00:22:14.412 - 00:22:51.480, Speaker A: And the idea is you inherit from that and you get this modifier. And so essentially it says, well, if I'm not paused, then let's just keep on executing. And so at a cost of just 2100 gas, you're able to add that capability to your contract or to a specific function in your contract. And so you could just add that. And then you then have the ability to pause. Freezing and banning are slightly different things. So say there's someone who, you decide a person non gratis.
00:22:51.480 - 00:23:47.016, Speaker A: So say, for instance, the recipient of that $150,000,000 that has been stolen, maybe you think that they should be banned. Banning would be to stop them using your service, stop them from depositing or withdrawing. Frozen would be that they can deposit but they can't withdraw. And so you could use that to control addresses that you decide are no longer able to use your contract. And that could be particularly important if, say, you had a law enforcement agency telling you, look, this address is related to some north korean hacker group and they're just not allowed to use your service anymore. And so that would be a way of doing that. And again, you're going to be, say, dealing with every time you're reading a value, it's going to cost you 2100 gas.
00:23:47.016 - 00:24:34.030, Speaker A: And say, if you've got two addresses in some sort of transaction, then that's going to be 4200. So it's going to cost a bit of gas, but then it would give you the ability to freeze or ban addresses. Okay, so what about front running? So I'm borrowing this code from a guy called. Yeah, Rodrigo. And so I've sort of boiled it down a little bit. But have a look at this code. The idea is that you deploy the contract and then anyone can send money to the contract, and then anyone later on can call the underscore transfer method to get the balance of the contract sent back to them.
00:24:34.030 - 00:25:03.350, Speaker A: You can just have money sent to you. So someone deposits money, then anyone on the planet can call this and get the money back. Does anyone know what's wrong with this contract? What's the issue? Is the issue that there's most likely, all right, but Freddishio, why don't you go?
00:25:05.980 - 00:25:08.104, Speaker B: Well, it's more likely that if you.
00:25:08.142 - 00:25:10.632, Speaker A: Call this, someone will front run you.
00:25:10.766 - 00:25:18.670, Speaker B: Put an extra tip on the gas and will execute the transaction before.
00:25:19.440 - 00:25:52.390, Speaker A: Exactly right. Exactly right. I'm sure that's what you're going to say too, David. Yeah, I was just going to say because it's unprotected, right. Anyone can send it, which means anyone else can send it if they see that you're trying to send to it. Exactly. And that's what these general, I think how the general purpose front runners work is they'll look at a transaction that's being executed and they will just try and execute the same thing with their own message sender and then look at what the outcome is.
00:25:52.390 - 00:26:55.908, Speaker A: Is the balance of the message sender now suddenly higher? Okay, it's worthwhile sending, or if they send that transaction, is there any of the other available functions on that contract available that they could call it, and then their balance would be higher. So that's what it's all about, is determining is there any transaction they could do that's being executed or secondary transaction. They also look for cross contract calls as well. So say this resulted in a cross contract call. They would also look at them to work out is there a way of message sender becoming more wealthy? And so how you can prevent front running attacks is using commit reveal schemes. So essentially you commit to some action and you tie it to message sender, and then the contract stores that commitment. And then to execute the action, you reveal your secret.
00:26:55.908 - 00:27:55.880, Speaker A: And so you can imagine you could have, say, claiming a bounty, proposing the purchase or sale of something, or even that simple example we've just had. And so I've compiled this code, but I haven't actually run it. So there may be a bug. But how I can imagine you doing it is you would have a register function. And so you would register to say that you want to do a withdrawal, and you'd put in a commitment. And then from then on, you've got one day to do the withdrawal before someone else can come in and propose another commitment. You propose the commitment and then the transfer, you notice in that line, it's got commitment equals Kak of the encoded secret comma message sender.
00:27:55.880 - 00:28:48.184, Speaker A: And because you're hashing in message sender, it really is going to link it to you, the message sender. And there's no way that someone else is going to be able to front run you on that. But maybe you don't want to hold it up for one day between when you submit the register transaction and transfer, because that might be, or limit that. So the other way you could do it is allow everyone to put their commitments in in parallel. And so in that case, what you do is you'd put your commitment in and it goes into a map of all the possible addresses. And then you say, well, for you, have you got the right secret? And I would speculate that a front runner would not be able to work this out. Not a robotic front runner.
00:28:48.184 - 00:29:18.570, Speaker A: If there was a human involved, they could sit down, look at the code, work it out and do it. But surely, unless there was lots and lots of money involved in this, no one, I'd think, is going to have enough time to invest in trying to write a specific front runner for this. So a generic front runner, I don't think, would be able to do that. Does that look good? Do people understand what that code is doing? I guess, is probably the bigger question.
00:29:21.340 - 00:29:22.680, Speaker C: Yes, it's reboot.
00:29:26.620 - 00:29:35.932, Speaker A: David, you're staring intently. You've got your video on, so I can see that you're staring intently. Does it look. Yeah, you'll look at it later on.
00:29:36.066 - 00:29:37.852, Speaker C: Pete, can I ask a question?
00:29:37.986 - 00:29:38.910, Speaker A: Yeah, sure.
00:29:39.620 - 00:29:49.680, Speaker C: So can you just drill into this a bit more? Can you explain how somebody would use, would generate the secret and use the secret to work this contract?
00:29:51.540 - 00:30:27.432, Speaker A: Yeah, sure, Barry. So what you would do is offline, you would generate secret. So secret's got to be a bytes, 32. So 32 bytes to 56 bits. I'd generate a random number. Then you notice that we're using encode packed. So that means that message sender, which is a 20 byte address, is going to be encoded as a 32 byte value with zero filled so you would create that 64 byte blob, which will be what you'll get when you go Abi encode packed.
00:30:27.432 - 00:30:41.810, Speaker A: And then you would do the kick Act 256 and work out the commitment first. And so you'd submit the commitment first, and then you'd just be able to submit the secret, and it should just work.
00:30:45.400 - 00:30:48.452, Speaker C: So when you say work out the commitment, what do you mean?
00:30:48.586 - 00:31:00.776, Speaker A: Oh, you would calculate the hash. So kickak 256 of that 64 byte value being the secret concatenated with the message sender address. Yeah.
00:31:00.798 - 00:31:05.176, Speaker C: Okay, so the commitment is actually just a concatenation of the secret and your address.
00:31:05.358 - 00:31:33.792, Speaker A: Yeah. And hashed. Hashed, yeah. And the hash is the important thing because the output of it is a bytes 32, and because there's no way that anyone is going to be able to find a collision. So find another secret message sender combination that will collide with it. Not with kick Act 256. It's a very secure algorithm, so it should be good.
00:31:33.926 - 00:31:39.780, Speaker C: I'm just curious that you said that a human might be able to work this out, and I don't see how a human could.
00:31:39.930 - 00:32:16.130, Speaker A: Yeah, how they could is if I was sitting there, I go, oh, this is how the algorithm works. So then I would then register my own commitment. So I'd have, obviously a different message sender because I've got a different EOA, and I could come up with a different secret because that doesn't matter. And then I would calculate a commitment, and then I would put that commitment in, and then I would call transfer. And because the only guard here is that require statement, it's whoever gets in first for the calling transfer.
00:32:16.900 - 00:32:20.380, Speaker C: Oh, I see, right, you're just creating your own commitment.
00:32:20.460 - 00:32:42.628, Speaker A: Okay. Yeah. And that's the thing. That is the difference. So that previous example, which I've now got on the screen, hopefully you'll see in a few secs. This previous one, there was only one person. So one person got to call register, and then they got to call transfer, and no one else could call register unless it was timestamp was greater than timeout.
00:32:42.628 - 00:32:56.300, Speaker A: And timeout is set to now plus one day. So essentially, even if you register and you plan to call transfer, but then you don't, you've only got one day, and then someone else could come along and register.
00:32:59.840 - 00:33:01.280, Speaker C: Cool, thanks, Pete.
00:33:03.700 - 00:33:55.940, Speaker A: Okay, another way of handling the front running is batch auctions. And so the idea is that rather than having individual orders go in and then people saying, hey, there's an order going on here, I'll try and get in early. And then manipulate the price. If everyone goes in at the same time, or if everyone's orders go in for one whole day, and then you process them at a batch and you essentially get the average price, then there's no time incentive to front run, because it doesn't matter whether you jump in first or jump in last. As long as you're within the time period, everyone's going to pay the same price. And so that's another way around it. Okay, another high level thing to think about is checking the deployed configuration.
00:33:55.940 - 00:34:41.196, Speaker A: And so cello optics, that's actually another cross chain protocol. It wasn't a hack. They just had an incident where their whole system went into what's called recovery mode, and so the whole thing stopped working. And there's a big saga related to someone being fired for a misdemeanor, and then 15 minutes later the whole thing stopping. But it turned out it wasn't James Preswich, the person who was fired, who did it. It was someone else. The bigger question is, what on earth happened? So the recovery mode should have been controlled by a multi sig, but it was only an EOA.
00:34:41.196 - 00:35:14.316, Speaker A: So it was only a single externally owned account was the controlling address for this recovery mode thing and not a multi sig. And then there's this recovery mode time lock that supposedly gives people enough time to go, oh no, I don't like what's being proposed. I'm exiting my money, I'm taking my cricket back and going home. But it was only set to 1 second. So you should have been multi sig. Should have been, I don't know, a day. And instead it was one EOA and it was 1 second.
00:35:14.316 - 00:36:08.904, Speaker A: So what I think this is telling us all is that even if you've got these great intentions, you really do need to check the configuration of the deployed project to make sure that someone hasn't deployed the whole brilliant system you've got in a really bad configuration. And as well, if the idea was that this time lock was going to give people enough time to react, then maybe they should have had a sane minimum value in the contract which said, look, that must be at least, I don't know, one day. And 1 second is just not a possible value. And I think that that would have been a good thing. Okay, so we've talked about high level stuff, now let's talk about solidity. First one is a really simple one, sort of. And that is you should use the latest version of the compiler.
00:36:08.904 - 00:37:10.928, Speaker A: I know this is really obvious, but defects are fixed all the time in Sol C. So check the release notes and like these older versions, they're going to generate issues that might have a bug in it. And if some attacker looks at that bug and says oh, I could exploit that in your code, then they might be able to work out some way of leveraging the bug fix on your code. So you should wherever possible use the latest version of the compiler and so you can use this pragma which is link it to a very specific version and that way you might say right, we've tested it with zero point 8015 and so we want to deploy it with that version because that's what we've tested. Could be fair enough. Another way is you use that little up arrow and that means I want to be between that value and the next major release version. So 0.9.
00:37:10.928 - 00:38:24.920, Speaker A: And so you can think that what's going to happen is they're going to be bug fixes between zero point 815 and nine that you will be able to take into account and be able to use. So obviously you've got to be using that later compiler as well. But it means that you're saying my contract is compatible with those versions. And so I guess what it means is though your code will fail when zero point 91 comes out or zero point 90, but that's probably a good thing because what it'll tell you to trigger you to do is have a look at your code and say oh, maybe I should be using this new security feature and implementing that in the code, and that's a good thing. And so I've heard this advice, which is don't use the latest version of the compiler because there might be some undiscovered bug, and I don't think that's a good idea. I think that if there's some brand new feature that's come out, maybe don't be the first person to use it, maybe wait a few versions, but if you're only using older features then chances are they're going to have bug fixes in them for those features. So I reckon you should use the latest version and not like the second latest.
00:38:24.920 - 00:39:10.964, Speaker A: Obviously you shouldn't be using the test version, the latest build, but if you're using that little up hat thing, you're not going to be using that. You've got to specify them if you want to use them. Okay, next part function visibility. So in solidity you can have external, public, internal and private. So external and public you can call them from outside. So whether it be a transaction, a view call or a cross contract call, you can also have in public and internal, you can have a contract that inherits another contract, can call an internal function. And similarly, if you're within the same contract, you can call public, internal or private.
00:39:10.964 - 00:39:56.144, Speaker A: So you've got these visibility things to try and control who can call what. And so in nontip trivial contracts, though, you'll find that you start including an awful lot of other interfaces and other contracts. It's very typical. And so it's really easy to miss some external function that you just don't even know about. Like here I've got my contracts B and f, and B's got C, D and E, and in C somewhere you've got, I bet you didn't even know about me function. And so that is quite a common thing. And so if you go use sol C and go hashes, you'll get the list of function signatures and function selectors.
00:39:56.144 - 00:40:49.076, Speaker A: And so that'll tell you all of the public and external functions that are available in your contract. And so you should audit that list and go, oh, I didn't even know about that. I wonder what that function does and maybe change or remove those functions. So I think that is something that I've actually seen people have problems with, where they've deployed something with a function that shouldn't have been public that was okay, access control. So you can limit who can call external and public functions. This is to limit who can call the external and public functions by essentially having a require statement. So you could have say, message center equals some authorized party like owner, or maybe you've got a map of authorized addresses.
00:40:49.076 - 00:41:45.268, Speaker A: And as long as you're within authorized, then you're good. And so authorized will be a mapping from address to Boolean in that case. And so the thing to remember is you don't need to do this sort of require statement if it's a view call, because all the data in the blockchain is public. So there's no reason why you need to be trying to limit scope because anyone can read the stuff. So you only need to be putting in these require statements if it's a transaction function. And in fact, this sort of lack of access control was exploited, say, in the parity wallet hack in 2017. Now I'm simplifying the code a little bit, but essentially they had init wallet owner, and someone was able to call that and then get the whole thing to self destruct.
00:41:45.268 - 00:42:28.970, Speaker A: And so that locked up 513,000 E, which is an awful lot of money these days. Okay, let's talk about fallback. And receive. So if someone transfers ether, so essentially you've got a transaction with no call data, then the receive function will get called. And so notice that it doesn't have function receive. You've just got receive and fallback, and no need to have the function identify, and so it'll get called if you're just sending value. If receive doesn't exist and you've got a payable fallback, then that'll get called.
00:42:28.970 - 00:43:18.360, Speaker A: And so you can have fallback without payable, and it'll get called if there's any call data or there's no receive. And if you have bytes input, then you can even try and understand what you've been called with. There was an old ethos that people had that if someone sends you ETH, then possibly by mistake, then accept it, say thank you. But I think it's probably not a good ethos to have, because if you don't plan to manage ETH in your contract, then maybe you shouldn't have any payable functions. And that includes receive and fallback. You should be trying to make sure that you don't have to worry about that. All right, let's talk about reentrancy.
00:43:18.360 - 00:44:20.920, Speaker A: So, reentrancy is where you have a call from an externally owned account, and you have a contract, which maybe calls another contract, and then eventually it loops around and the code that you have ends up calling back into its own code. And so there was even a reentrancy hack of the Dow attack back in 2016. And so it can be for a value transfer or a function call. And so if you look at this code here, we've got some shares, and then you call the withdraw function, and then you're going, and you're sending the share to message sender, and that's how much you're sending. And then if it's successful, then you say, all right, let's update the state. So someone who hasn't put in a comment before, who's on the, let's see. Joanne.
00:44:20.920 - 00:45:02.752, Speaker A: Joanne, what's wrong with this? I don't think my brain's thinking quick. Yeah, it's too cold in Melbourne. There is a reentrancy problem. So I guess that should help because you're not setting it to zero until after exactly when you do the call. The call can start the code in the contract just transferring to. And so it could come back in because you're only then setting the shares to zero after. Exactly.
00:45:02.752 - 00:45:48.380, Speaker A: That is exactly what the problem is. And yes, so the call is a cross contract call and it hands over all remaining gas. And then the receive function is going to be called, and it can call back into withdrawal. And so that user message sender could go and then drain lots of money out of the so. And how you should do it is, as per what Joanne was just saying, that you should work out what the share is, and then you should set their share to zero. So you do the state update first, and then you do the transfer, the external interaction. And so this is really the check effects interactions pattern.
00:45:48.380 - 00:46:30.780, Speaker A: And so you do your requires, or whatever checks you're going to do right at the start. And then you update your state variables, and then you do your interactions with external contracts. Another way you can do things is use what's called re entrance guard. And so Openzeppelin have got an example contract that you can use that does it. And essentially you put this modifier, non reentrant, around your code. And so it allows you to make sure that there's only one instance of the code running and you can't run call back into it. So you can imagine here, I'll just go here.
00:46:30.780 - 00:47:22.284, Speaker A: So if this is put on a function, it's going to go required, not entered. And it might be not entered initially, then you set it to entered, and then finally you set it to not entered when you exit. And so that means that you can't call through that non reentrant twice. And if you think about the gas being used and the gas being refunded, then you end up having, I think it's 2300 gas there in total is used. So it's not too expensive, but it's a way of doing it. If you can't do that check state effects paradigm, another thing you could do is limit the gas supplied. And so with each call down from one contract to another, you only pass on 63, 64 of the remaining gas available.
00:47:22.284 - 00:48:15.230, Speaker A: And so even if you say started with 10 million gas for an initial transaction, then you're going to be maybe only being able to do 500 times through shimming. You want to end up with, say, 3200 gas at the end. And you can also restrict it by say, specifying the amount of gas to be passed in for some function call. And so you could use this sort of code to work out how much gas a function is using. So gas left just calls down to an EVM op code, and it tells you how much gas is remaining. And then you call that function, and it's going to say, tell you how much it's used. And so you could quite finely work that out.
00:48:15.230 - 00:49:22.810, Speaker A: But the thing to think about is that opcode prices change and for that matter, the thing you're calling could change as well. And so if you finally work out how much gas it's going to cost and then say some things like this, s door change happens where storing stuff costs more, then you're going to break your code. And so you do need to be very careful with limiting the amount of gas you're actually passing through. All right, modifiers, so I've already talked a little bit about them, but modifiers was where you essentially insert your code from your function between two parts of modifier. The thing is that modifiers are often defined in faraway places. They can obviously be defined in the contract you're using, but sometimes they're defined in something that you've inherited or something that's like ten levels of inheritance away. And so you don't necessarily come top of mind what that modifier is actually doing, and that's a bit dangerous.
00:49:22.810 - 00:50:18.998, Speaker A: The other thing is that you can have the modifier, have code before and after. And I know there was, that reentrancy guard was an example where they did have code after, but generally people aren't expecting that code after because usually it's just require blah. So yeah, be a bit careful about that. You also want to be careful that you're only doing checks and you're not doing lots of code in a modifier. And so here we're just using two maps to say should the required statement go through or not? And as you can see, you can have more than one modifier and you don't want to be doing something like this. So we've got, is eligible here and we've got registry and is a voter and you're passing in message sender. So calling out to another contract is not what people are expecting to happen in a modifier.
00:50:18.998 - 00:50:58.982, Speaker A: And that's like you're handing control away and potentially could have reenteracy issues as well. So that seems like not the right thing to do. Okay, value transfer, we've already talked a little bit about this, so there's a few different ways of doing value transfer. So we've got the transfer and send and send returns a boolean to say whether it's passed or not, whether it failed or not. Transfer doesn't return anything. And then you've got call and call. It's like a normal function call.
00:50:58.982 - 00:51:35.650, Speaker A: And so you find out you can have a boolean and you get to pass as much gas as you like. So it could have arbitrarily complicated code in the receive method whereas if it's transfer and send they've only got 2300. So the 2300 helps to stop reentrancy but it also limits the scope of those functions. So what about this? Let's have a look at this code. Yes. All right. So Barry are you still available?
00:51:37.220 - 00:51:38.464, Speaker C: Yep, still here.
00:51:38.582 - 00:51:40.996, Speaker A: OK Barry, this is a harder one I thought.
00:51:41.098 - 00:51:42.470, Speaker C: Great, thanks a lot.
00:51:43.960 - 00:51:53.610, Speaker A: Have a look at this code. How is this code broken? What problem does this code have?
00:51:55.580 - 00:52:25.280, Speaker C: Okay so richest is a payable. Okay so the constructor is payable so you could pay the contract, become richest. So if the value sent is less than the most sent then complain, revert, otherwise transfer that amount from richest.
00:52:30.200 - 00:52:50.250, Speaker A: Yeah. So it's transferring the amount that was there previously. So someone would deploy and put in one ETH and then because you wanted to be big name yourself and say I am the richest then you, Barry, would put in two ETH to become richest and you would get that one.
00:52:51.020 - 00:52:54.120, Speaker C: Okay so it gets returned to the previous richest.
00:52:54.640 - 00:53:01.550, Speaker A: Yeah actually the two ETH gets returned to the previous richest. That's true. Yes.
00:53:02.160 - 00:53:11.248, Speaker C: And then the new richest becomes whoever sent the funds most centers in the value. Looks good to me.
00:53:11.414 - 00:53:14.130, Speaker A: Yeah. What could go wrong?
00:53:15.380 - 00:53:17.088, Speaker C: There's nothing that jumps out.
00:53:17.254 - 00:54:25.290, Speaker A: Yeah. And so an attacker could set this up to point at a contract and so when the transfer goes through you could revert and so here you are, you've gone and designed this lovely game and now the person who's decided to become the richest and they don't like this game anymore, they break the whole contract simply by every time transfer is called reverting. So they don't actually make any money, they just frustrate the contract. And so this is one of those things where you've allowed someone to make the state of the contract broken which is quite frustrating. So for something as simple as this, it doesn't matter, but if it was something like your automatic market maker or something and they were able to lock up the whole contract that'd be super frustrating. And so how you can get around that bug or that security issue is the withdrawal pattern. And so the constructor is the same, become richest is pretty much the same.
00:54:25.290 - 00:55:08.362, Speaker A: But now you have some pending withdrawals so you become the richest, you've got a pending withdrawal and then you can withdraw yourself. And so if you did that attack where you reverted on transfer all you would be doing is stopping yourself from withdrawing your money but you wouldn't stop the contract from operating. So it's a simple pattern that stops that sort of attack. Okay, mappings. Patricia, go ahead. Were you going to say something? No, just a little tip from the old days of solidity development. It's always better to let the user.
00:55:08.426 - 00:55:12.160, Speaker B: Withdraw their funds instead of you sending them.
00:55:15.030 - 00:56:11.986, Speaker A: Yeah, very true, very true. Okay, mappings, so mappings are like say un to un 256. It's a way of mapping one key and values. And so how that's actually set up by the EVM is you have these storage slots and the values are stored in Cacaac 256 of the storage key. The storage slot number, say the map is the second variable in the contract, then it's going to be in storage slot one. And so that's the storage slot number. And so you work out the Kitka 256 of the storage key, dot that slot number and that's what the value is and that's where you get to store it.
00:56:11.986 - 00:57:22.902, Speaker A: And so you don't actually store anything at that storage slot one. You only get to store it based on that equation there. And so imagine you've got this code here, and I'll give everyone a few secs to think it or look at it, but working through from the top, you've got an array and it's an array of mappings. And then you allocate a whole set of new maps by pushing on to the array some new mappings and then you've got write map, which takes, which map do we want to talk to the key and the value, and then read map, you say which map you want to use and the key. And then you've got this arrays maps function where you delete the whole array. And so the thing to think about is calling delete on that array will delete the array, but it can't delete the mappings because it doesn't know where those variables are stored because the keys that are used are not kept anywhere. You're not storing the keys, you're only storing the actual values in a map.
00:57:22.902 - 00:58:06.870, Speaker A: Makes it cheaper, but it means you don't have those keys. And so imagine we have this sequence you call allocate to allocate one new map, and then you call write map. And what you do is you write with a key value key of two and the value of five, and then you call arrays maps to get rid of all the maps. And then you allocate and you allocate one map again. And now I called read zero comma two. So I read that value that was written originally and despite having gone delete on that array, I will get five returned from read map. And that's because the map value has in fact not been deleted.
00:58:06.870 - 00:59:20.180, Speaker A: Okay, integers, so in integers, in solidity, integers are integers. So the numbers are integers and they're not floating point or anything, which I think is obvious, but it's important to realize that three divided by two is just one and not 1.5. And so if you have something like this where you're paying out equally, then if holdings isn't divisible by num owners then you're going to have money left at the end and that's not good. And so you could imagine if you've got some voting like this, we'll walk it through, you count the votes and then you go for all the people who voted. We'll see if they've voted for and if they have we'll add the number of votes and then you want to return true or false depending on whether votes for is more than half of the number of votes. And so if you have it just like that, you're going to have a problem because the number of votes, even if no one votes, you'll still end up being true. And so that's not good.
00:59:20.180 - 01:00:11.230, Speaker A: And so that's not what you really want to do. You don't want to be returning true even if no one votes. And then you might have like this where you've got, all right, well what we'll do is we'll just do greater than, and again, that's not going to work too well for you because say, if you've got six people in total, you were hoping that it would be three or more people voting to get the right number. So essentially you just need to do that, which is not hard, but it's just something to think through and sometimes has unexpected consequences. Another part of integers to think through is underflow and overflow. And so essentially if it's a U in 8255 plus one is going to cause the problem. And so by default everything now is checked.
01:00:11.230 - 01:00:42.060, Speaker A: And so if you do do that sort of addition, you're going to have a panic thrown. So it'll be a revert in a panic. And this could leave your contract unusable because if every time you execute a function it causes a panic, you're not going to be able to use it anymore. So you could put unchecked around it. And in that case though you're going to be returning zero because 255 plus one is 256, which is zero. And again, that could have some problems too. So you do need to think about that.
01:00:42.060 - 01:00:56.670, Speaker A: TX origin is another one. So what's this code doing? Ok, so who hasn't talked? Darren Rogan, are you able to talk?
01:00:56.820 - 01:00:58.146, Speaker B: Yeah, I can talk.
01:00:58.328 - 01:01:03.186, Speaker A: All right, Darren, what do you reckon TX origin equals message sender could be doing for us?
01:01:03.288 - 01:01:09.510, Speaker B: It's trying to ensure that the person sending the transaction is the starter of the transaction.
01:01:11.210 - 01:02:03.218, Speaker A: Exactly right. So given the TX origin is going to be an EOA, that means that message sender is going to have to be an EOA as well, because there's no way of looping from a contract to an EOA. So that's essentially saying this must be an EOA. You can also imagine, though, you had this code where you had your transfer two and you're saying, well, the TX origin has to be owner. So if you look, have a think about that, that's actually got a big problem. So this is your user wallet and you're wanting to transfer some amount. And the issue that you're going to have is that you could have an attack wallet between your user wallet and your real wallet.
01:02:03.218 - 01:02:40.050, Speaker A: And if you could persuade the user to do a transaction, send some ETH to this attack wallet, then it will get it in the receive. And then what it can do is it can call TX wallet so that user wallet and then call it to essentially execute the transfer, because it's looking at TX origin and not message sender. So essentially you're masquerading as the user and inserting yourself in the middle of the actual call flow. So you're able to execute, but that.
01:02:40.120 - 01:02:45.026, Speaker B: Could have a valid use case to do gasless transactions, for example.
01:02:45.128 - 01:02:50.326, Speaker A: Would that be a case gas so.
01:02:50.348 - 01:03:09.370, Speaker B: Somebody could do a cheaper operation and you sort of use this as the funder of a more complex scenario. So let's say I wanted to mint something and I could just do like an easy one before. Would that be a valid usage of this, sort of almost like a proxy?
01:03:10.350 - 01:03:40.566, Speaker A: Yeah, you could, but you would. Then in that case, though, you could be trying to do something like that. But in that case, you're going to have to be very careful with exactly what's happening in transfer two to make sure that maybe what you would do in that case is. Sorry. Maybe in that case, what you would do is you'd make sure that message sender was a known proxy. So you'd say if message sender is a known proxy, yeah, I'd have it.
01:03:40.588 - 01:03:43.400, Speaker B: In a Merkel tree and make sure it's in the Merkel tree first?
01:03:44.330 - 01:04:03.002, Speaker A: Something like that, yeah. Okay. All right. We're up to 1 hour. I'm going to keep on going. Got a few people help, few dogs helping here. All right, Pathy.
01:04:03.002 - 01:04:54.382, Speaker A: Just a sec. All right, the puppies, I think are going to go outside, so let's not worry about them. All right, so reverting. So in solidity there is a whole stack of different ways of causing reverting. And so one is obviously revert bracket string, and then you can revert with the custom error, you can require a condition, require condition and provide a string to be returned, or you can have an assert they'll all call the revert op code, but what you actually get for return data is quite different. And so you'll get error string if it's a revert or revert condition. And if it's an assert, you'll get a panic with a panic code of one.
01:04:54.382 - 01:06:05.566, Speaker A: And so the asserts are used with static analysis tools. And so the thing to think about with reverting, so you've got these panic codes, and so it's worthwhile knowing what those panic codes is so that you can try and decode them and understand what's going on with your code, because sometimes you get these panics and it's quite confusing. You can also have error called, but without any parameters. And that can happen for a whole range of reasons. And one of them is that you call a contract address where there is actually no code. So invariably that's because your contract address isn't really a contract address at all, it's just an incorrect address. If you try and receive some ether and the receive function isn't payable or the fallback function isn't payable, and if again you try and send ether to a public or external function and it's not payable if there's not enough call data supplied.
01:06:05.566 - 01:07:01.542, Speaker A: So if you've say, got one byte but not say four bytes, so not enough for a function selector and not enough for the parameters, then again that'll get called. Another thing to understand is about error propagation. So if there's something happens in contract C, it can cascade the whole way through and revert the whole transaction, and it typically does, but it doesn't have to. If you call transfer, that'll fail and that'll cascade. If you go new for a contract, again, that'll fail. If you do a normal function call that'll fail and cause the cascading revert. If on the other hand, you do a lower level type of call where you capture the success or failure and the return code, then you can work out what you're going to do from that point.
01:07:01.542 - 01:08:01.290, Speaker A: So you could catch it or you could discard it, and that could mean that contract C's function call could revert, but contract B and a might not, and so they might do different things depending on that. You've also got this try catch style feature in recent versions of solidity, and you can see that you're catching it if an error happens or a panic happens, but if there's some other low level error. So essentially there is no return code at all, you're not catching that. In fact, you're just absorbing it and keeping on going as if nothing's happening. And so that's actually pretty bad because now you're not even reporting the error to anyone. And so you've got to be careful when you're analyzing code to make sure that reverts are being cascaded back and handled correctly. Okay, timestamp manipulation.
01:08:01.290 - 01:08:58.886, Speaker A: So proof of work, block creators, so miners, they can specify the block creation time within about a 15 2nd window. And when you're looking at your code, you can have block timestamp and be doing stuff based on that. And so you could imagine that someone could manipulate the timestamp, a miner could manipulate that timestamp to change the effects of your code. Once we're at proof of stake in another couple of months time, another three months time or so. Actually, it's not three months, it's only two. It's real soon, then all this timestamp manipulation is going to pretty much go out the window and it's not going to be able to be manipulated. And so you've got to be really careful then with timestamps.
01:08:58.886 - 01:09:57.760, Speaker A: And another thing you've got to be careful about is if you say, all right, I want some action to happen in some time window, then you wouldn't want to limit that time window. So there was some gambling game, and the idea was that after something had happened, you then had some winning period, that you had to claim your prize. And the attacker, they just filled all of the blocks in that period for win period so that no one else could submit a transaction. And in that way they won because no one else was able to submit a counter transaction. So that was done back in 2016 or 17, something like that. So I don't think it would be necessarily possible now because the blocks are bigger and the gas prices are more. So it would seem unlikely, but that was done at one point.
01:09:57.760 - 01:10:50.926, Speaker A: All right, so I've talked about easy stuff, now let's talk about complex stuff. So storage collisions, part one. So there's a proxy contract pattern, which I talked about in the advanced security talk some time ago, and the links there. And so you use delegate call and call code to have, say, contract B operating in the context of a different contract. And so what you can then do is you can be upgrading the contract, or so you can have two contracts upgradable. But the thing to think about is that you've got the proxy contract and the contract being proxied. So the contract that's actually got the code in it.
01:10:50.926 - 01:11:43.406, Speaker A: And so the storage slots are in the proxy contract, and most of the code is in that code that's being proxied. And so the issue that you can have is though, that you can have a collision between the proxy contract and the contract being proxied. And so for instance, save contract a has val one and Val two and contract B, the one that you're using delegate call to, has B Val and address. Then they're at the actual same locations. And so contract B is going to interpret Val one. And similarly contract a will be interpreting B Val. And so that would then potentially lead to issues as well as if you're doing upgrades, you've got this sort of overwrite thing where you've got version one of a contract and version two.
01:11:43.406 - 01:12:26.558, Speaker A: And so if you insert an extra variable, then suddenly the storage locations are going to be interpreted differently. And so that's another storage clash. And these storage clash things are real. So this is days ago, like literally a week or two ago, there was this admin proxy, and it was using storage location zero, and that was storage slot zero. And that was the proxy admin was that storage slot. And that was then also available in the proxied contract. And some hacker was able to essentially change what proxy admin was and then steal all the money.
01:12:26.558 - 01:13:16.480, Speaker A: So having two storage slots at the same location is wrong, obviously. And if they had have used the open Zeppelin proxy, they would have not had this problem. There's also another type of storage collision, and this one is more of a malicious type. And so if you look at this code here, we've got a map, and you've got, so because it's public, there will be a getter on that map, and you'll be able to get a value based on a key. We've also got set Val, which sets up a key. Given a key and a value, it sets the value in the map. We've also got set Val one and get Val.
01:13:16.480 - 01:14:16.820, Speaker A: And they use this get uint 256 slot, and that dives into a bit of assembler there. And so what that's doing is it's actually setting the storage slot for that particular variable, which is that return value r there. So r is being returned at a certain storage slot specified by the parameter. And so what you do is you Abi encode and kick hack the key value comma, the storage slot. And once you've done that, then you know you've got exactly the value that the storage slot being used by the map for that key. And so set Val one essentially stores that Val into that storage slot, which is essentially setting that value, and get Val does it the other way around. It calculates the storage slot and then returns the value.
01:14:16.820 - 01:15:23.910, Speaker A: So the map can be accessed by map and set Val, but it can also be accessed by get Val and set Val one. And so what this is showing is that if you just searched for map and usages of that map variable and say, all right, I fully understand where that map is being accessed, and you didn't notice this set Val one code here, then you wouldn't notice that someone was able to overwrite map values. And this obviously can be used for anything. And this is just showing that you can access any location that a contract has, whether, whatever data type it is. And so it would obviously only be being used for malicious purposes doing something like this. But it's worth noting that just says what I've just said. Okay, so now is the exciting bit, how to change the bytecode of the deployed contract.
01:15:23.910 - 01:16:24.220, Speaker A: Okay, so there's this thing called create two, which is you want to create a contract at a known address. And the contract depends on the contract address depends on the address of the creator. So message sender, the bytecode of the contract, the parameters supplied to the constructor, and a salt value supplied by the creator. So it allows you to, say, deploy the same contract with the same parameters many times, just with different salt values, and you'll get a whole host of different addresses. The use case was that you wanted to be able to predict the address of a contract, and so you could have all these off chain interactions. And then if there was some dispute, you would then deploy the contract afterwards and say, all right, here's the contract, and now let's settle the dispute. That's the use case.
01:16:24.220 - 01:17:44.254, Speaker A: And so what the code looks like is something like this, where you've got contract D is the contract to be created, and it's got a constructor that takes no parameters, and it has a self destruct where it sends the ETH of the contract to the owner and create. It uses just a salt of zero X one, but that should be some obviously 256 bit salt, but uses that salt and it deploys the contract and then predict address calculates what the address should be. And so the address of D will be the address of predict address. And so that's how you can deploy a contract using create two. You could use that though, and all the things we've learned today. So you could have this overwrite soul which deploys using create to a contract called choice. And in choices init code, it could actually say, hey, what should actually be deployed? And so it could talk to a contract called loader and the loader could return to it the contract code to be deployed.
01:17:44.254 - 01:18:14.080, Speaker A: And the choice could then say, hey, this is what should be deployed. And so it could choose to deploy, say, code one or code two. So let's see what that code looks like. So we'll have an interface where we've got get and we've got withdraw. And so get just returns a UN 256. And so for instance, get can return one or it could return two for code two. And in both cases it's just going to return.
01:18:14.080 - 01:19:14.510, Speaker A: When you self destruct the contract, it returns the value, the balance to the current address of the contract. And then that loader has two constants and the little lines there, they're the rest of the code, but in font, like one size font or two point font or something, just in case you want to later on copy and paste the code. Okay, and so you have set choice, so you can choose which one you want. Obviously you could have had set code, which could have set the actual bytes to be returned. And then you got get code which will return the bytes memory so the actual bytecode to use. Okay, and then choice, which is obviously the interesting one. So it's got a constructor and it knows the address of the loader contract.
01:19:14.510 - 01:19:58.640, Speaker A: And so it gets the loader contract and then it says to loader get code. So give me the code that I want to use and that's going to put it into a memory object. And then what you do is data pointer is so you can see on the right hand side there's some really small code there. And so I've left that there so that people can grab it later from the slides. But it's some boilerplate plate code that gives you the pointer to the actual, not the data within a byte. So bytes have got the length of the bytes followed by the actual data within the bytes. And so that'll give you the actual pointer to the data itself.
01:19:58.640 - 01:20:53.470, Speaker A: And then you work out what the length is. So we've got the offset in memory and we've got the length of that bytes and then copy does a low level copy of from memoffset. And then the offset that you're copying to is location zero and then length, which is just the length. And so that's doing a low level Evm like copying of data. The final one is assembly return zero comma len. So return zero is the offset of the code to be returned. So the idea is in it code, when you return, you return the offset and the length of the code that's going to become, or the data that's going to become the code of the contract.
01:20:53.470 - 01:22:00.770, Speaker A: And so what you're saying here is, all right, I've copied it to offset zero. So now let's just return that length. And in fact, I guess I could have simplified all of this and got rid of that copy memo offset zero and just gone return mem offset commal, didn't think of that anyway, would have been less code. And so that will then return the code to be the contract. And so you can imagine now choice isn't going to be the choice contract, it's going to be code one or code two and overwrite. So it is similar to that other code that we had where you're just deploying choice with a certain salt value and you can even work out the predicted address as well. So the loader could have had a function set code bytes, which would have let it set anything it liked and the constructor.
01:22:00.770 - 01:22:56.950, Speaker A: So it returned before the actual returned out of the init code fragment before the overall constructor was finished. And so that's a bit of a problem in itself because there could have been all sorts of variables being initialized and so that didn't happen. So block explorers are going to look at the source code and go, oh, that's not what's been deployed. And so they'll detect it. So if you were going to be a tricky hacker, you would want that initial version of choice to match the actual code that you initially deployed and just have the ability to change it over. So the big thing to do though, which maybe I've gone over quite lightly, is you need to do that withdraw function because the withdrawal function self destructs. So it removes the contract from storage.
01:22:56.950 - 01:23:48.456, Speaker A: So let's work through this through again. We deploy using create two choice loads up and gets code one or code two. The next thing that then you use the contract and then overwrite, then calls withdraw and withdraw, then self destructs the contract, and then you can call create two again. And meanwhile you could have changed loader to change the value to be returned. So does that make sense to people getting sort of head nod? Sort of, yeah, makes sense. If I was brave, I'd live do it.
01:23:48.478 - 01:23:55.930, Speaker C: But anyway, so, Pete, if a contract has had self destruct calls on it, then you can recreate it using create too.
01:23:56.400 - 01:24:08.784, Speaker A: That's right, yeah. But it's got to have been. So you've got to have done it. You've got to have created the first contract using create two, otherwise you're not going to be.
01:24:08.822 - 01:24:11.170, Speaker C: Otherwise you won't be able to get the same address. Yeah.
01:24:14.980 - 01:24:20.630, Speaker A: Exactly. So you can go and change the code around.
01:24:23.720 - 01:24:25.776, Speaker C: Yeah, it's mind blowing.
01:24:25.968 - 01:24:36.490, Speaker A: It is. After all these years of using solidity and EVM and Ethereum, and now we can change the code. Not what we expected. So is this a problem?
01:24:38.380 - 01:24:54.780, Speaker B: I was just about to ask that question. So if I was to look at a contract and I see a self destruct in there, is there any way to detect that it was created using create two, or is this just a risk that you have with every self destruct contract?
01:24:56.240 - 01:25:49.680, Speaker A: Yeah, that's a good question. No, I don't think there is a way, actually. Yes, there is a way. You'd look at a block explorer and that is going to tell you that information. I am almost certain, though, trying to tell your users, just look at the block explorer and if you look at this part here, if it's got create and two at the end, then look to see if there's a self destruct op code in the middle of it, it starts to get a bit confusing. But I think the big thing is you're going to audit the code, and if you see some assembler code in the constructor of a contract, I'd start to get a bit worried. I think that's probably the big thing, especially something that's going return in the code, because that's definitely going to be strange.
01:25:49.680 - 01:26:29.230, Speaker A: So, look, if some attacker could sneak some code in like that, then I think rather than going to all these extreme lengths, they could just do simpler stuff. Surely there's simpler attacks they could do, like send all the money to me or something. Surely. Also, all of the storage is going to be lost when you call self destruct. So sure, if it's just got ETH value, then you're good. But if you've got any storage locations all of them are going to be wiped out. So it's only going to be very certain attack cases that this could be used for.
01:26:29.230 - 01:27:07.160, Speaker A: Ethereum foundation know about it. In fact, if you look closely at create two, there is this text here. And so as a final thing, if you're thinking, hey, well, I could upgrade my contract using this, I don't think so. I don't think it's a good way of doing it, you lose all your storage. So doesn't sound like a good idea. Okay, can you transfer value to this contract? So this contract is essentially this contract. So receive, don't give me any e, so I don't want it.
01:27:07.160 - 01:27:38.388, Speaker A: So is it possible to do that and confuse things? And the answer, of course, is yes. You go self destruct with an address, and the value is transferred there directly. There is no call to receive. It just goes there directly. So it is possible to bypass. And of course, with create two, you know what the address is going to be before the contract is created. So again, you could send e there, and there's even something called force feeding attack.
01:27:38.388 - 01:28:12.030, Speaker A: So if a contract is doing stuff based on its balance, then you can force the balance to be something that the person is not expecting, and that might cause something funny to happen. So you should have your accounting for how much money you've got separate to the actual balance. You shouldn't have the two of them intermixed. Okay, heading towards the end. Obscure functionality. Who wants to volunteer? What on earth this code is doing? Or what is it telling us? What's going on? We've got a boolean. Doing a function call.
01:28:12.030 - 01:28:44.280, Speaker A: Yeah, all right. Everyone is just going, no, that's just not possible. Unfortunately, it is. So there's this using keyword where you can say, I'm using some other library for, say, you went 256 or bull or whatever, or star. Star meaning everything. And then you can just say, all right, bull. And then there's some function, and then you have some logic, and I find that super confusing.
01:28:44.280 - 01:29:45.000, Speaker A: All right, who has heard of function types before? And so the idea here is you've got a function and it's funk to use. And so that funk to use is the function, and it's a private and it's of that type. And so the idea is that you can change the storage location funk to use to say, oh, well, now we want to use funk one or funk two. And funk one and two can be different functions doing different things. And so rather than in call funk having if choices one do this, else do this, you can just call funk to use and it will call that function directly. And so again, this is some really obscure functionality that I know I've never hadn't heard of before I did this talk and then. Yeah, all right, so here's another piece of obscure code.
01:29:45.000 - 01:30:28.436, Speaker A: Now, what was. Oh, yes, this one here is really hard. So I know we're up to one and a half hours, so everyone's brain is in meltdown for some really hard code. But you've got a constructor or you've got some secret number and the owner, and then if you can guess that secret number and it's payable when you deploy it, you put some money in. And so every time you try and guess, you try and guess what that secret number is. So as we all know, that secret number is public because it's just on the blockchain, so you can just read the state. And so you think, all right, I'm going to put in an ETH and try and get that prize.
01:30:28.436 - 01:31:08.816, Speaker A: So you check the prize to see if you've won. And if n is right, then you transfer your money. Otherwise, not. So forgetting the fact that this should be a withdrawal and not a transfer, can anyone see or guess what the problem is? It's hard to see what the problem is here, but can you guess what the problem is? Is it something to do with the fact that you've got that kill down the bottom and so you're going to self destruct that contract and then do something different or something, construct it? Yeah, with a different value. Again, no, this is far worse. This one. This one's awful.
01:31:08.816 - 01:31:55.988, Speaker A: And this one, you can't see the problem. So in remix though, you can. What is it? The Unicode you've got right to left override and left to right override. And so, in fact, this is what the text really looks like. So we were seeing this when it was displayed, but what it really looks like is this, which is pretty scary. So that means that n and p are reversed. And so you would be there saying, all right, so you're passing in your address who to be paid, and you're thinking you're passing in n the value, your guess.
01:31:55.988 - 01:32:49.716, Speaker A: And in fact, invariably you're going to be wrong because your address isn't going to be the number. And so people could be just keeping on guessing and never getting it right and going, but why aren't I right? And it's because you've flipped the variables around, which is I don't understand. Okay, so if you open up that in a normal ide, you see this and so you're passing in, that's what you're seeing. So when you look at this, that's what you're seeing. However, when you actually pass it in though, what's really going on is that, and if you look at the. So it's nNp rather than Pnn. And so the variables get flipped around and it all comes down to.
01:32:49.716 - 01:33:06.280, Speaker A: So when your IDe is displaying it, it's displaying it including the text direction overrides. Whereas in remix it's kindly saying oh, we don't think that you really need those text overrides.
01:33:07.200 - 01:33:09.550, Speaker B: But that's pretty deliberate, right?
01:33:10.080 - 01:33:22.080, Speaker A: Oh yeah, this is malicious coke and this is being silly, but still it's a thing, it's a possibility.
01:33:24.260 - 01:33:28.930, Speaker B: Stack overflow attack because it's hidden characters, you see it all the time.
01:33:29.620 - 01:33:30.592, Speaker A: Yeah. Crazy.
01:33:30.646 - 01:33:35.328, Speaker C: So the characters there, they just affect the comment, they don't affect the actual parameters.
01:33:35.504 - 01:33:51.770, Speaker A: Yeah, they affect the actual parameters. Here we're seeing, we're viewing, when we look at it with our eyes, we're seeing P comma n because that's how it's being displayed on the screen to us by the IDE. But the actual compiler is seeing n comma p.
01:33:54.700 - 01:33:59.900, Speaker C: Hang on, so that right to left over right. Is that talking to the IDE or the compiler?
01:34:00.640 - 01:34:04.844, Speaker A: I think it's talking to the IDE. The display, I think.
01:34:04.962 - 01:34:09.084, Speaker C: So if you opened it in just a normal text editor, you'd see this.
01:34:09.282 - 01:35:02.124, Speaker A: Yes you would if it was a simple text. Yeah. So Barry using notepad or Vi or something rather. I'm not sure what Xcode would do. I don't know, but as someone, I think it's Darren or someone said that someone's going to be malicious doing this and that would be pretty strange. So my summary on the obscure functionality is it's really obscure and I reckon that it'd be really good if some of this was deprecated or something. Or maybe you could have special ways of enabling some of this obscure functionality because if it's obscure then people will come across it, not understand it, and then there's going to be bugs in the code because they're not going to be able to interpret it correctly or fix bugs in it.
01:35:02.124 - 01:35:32.484, Speaker A: So yeah, I reckon it'd be good if some of that was removed from the language. Okay. Security tools SOLC compiler. So the SOLC compiler has been improved massively over the last seven years or so. Six or seven years. Six years. And in fact there's this registry of issues with security issues in smart contracts.
01:35:32.484 - 01:36:12.372, Speaker A: And these days the vast majority of those issues are actually being resolved, and you'll be getting either fatal errors or warnings if you have them in your code. So what that really tells you is you shouldn't just muck around and not get rid of compiler warnings. I mean, pretty obvious. They've also got something called an SMT checker. I have not used this, but it should be able to, according to the documentation, find a set of reasonably simple, simplistic issues. And there are a stack of other tools too. I have not used any of these either.
01:36:12.372 - 01:37:14.756, Speaker A: And in fact, you could imagine someone could spend a whole talk working through these different tools, and maybe some new tools. So which are free, which are web services, which support recent versions of solidity, and which is the best, I have no idea. And within consensus, we've got a group of people who are called the TSE trustworthy smart contracts team. So David Pierce and Joanne Frank. And so they're working on a actual language thing that will allow us should use their words. The TSC team are developing techniques and tools to deploy high assurance, bug free smart contracts. And so they've even got a paper that's being accepted into a really top level conference, and they've got an archive paper, and so they're working on a way of writing contracts in Daphne.
01:37:14.756 - 01:38:05.864, Speaker A: So you should hopefully be able to have more trust in them to not have bugs. Okay, in summary, so smart contract development is super complex, and this is just the start of your journey through this dark forest. And application security is a lot more than just smart contract security. And so sure, the contracts are a very public part of the attack surface, but there's a whole lot of other stuff as well. And you shouldn't ignore it, because a lot of the recent really big, hundreds of millions of dollar hacks have been on the non contract bits, but there have also been bits that have been on the contracts as well. There's a lot of links of a lot of different information. There are a stack of talks coming up.
01:38:05.864 - 01:38:55.892, Speaker A: So Harathio is going to be talking in a week's time about the Ethereum reference tests. And so what they are, how they work and why. Ermius, in two weeks time is talking about cross chain security and really going to be looking at some of those recent attacks as well, and trying to pick them apart and how have they really happened and what does it really mean? Paul Ashley is going to talk about decentralized identity. We're going to have the chief scientist of chain analysis on, and then going forward, we've got a few PhD students, Lachlan and Minfeng, talking about their PhDs. There is social stuff like, we've got a YouTube channel. If you're watching this on YouTube, we've got a meetup that this is on that you can freely join. There's a slack workspace.
01:38:55.892 - 01:39:50.866, Speaker A: Use that invitation link. The code that I've written today, most of it is in that Ethereum engineering group samples under the security folder. And there's also a formal methods reading group as well that you can attend and go to the slack to talk to people there about joining that group. And that is all, folks. And I can see we've got a lot of chat which have just not been looking at. So I wonder if there are any questions that weren't resolved in there and it. All right, yeah.
01:39:50.866 - 01:40:19.960, Speaker A: Okay. Anyway, I don't think there's anything, any questions in there? Are there any questions? We're at 1 hour, 40 minutes. Maybe just post them in the YouTube when it's done. I. All right, look, thank you everyone for coming along and have a great week. And I guess we all look forward to Harathio's talk next week, so talk later, everyone. Bye bye.
01:40:19.960 - 01:40:23.944, Speaker A: Thanks, Peter. Thank you so much.
01:40:24.062 - 01:40:25.530, Speaker C: Thanks, Pete. That was awesome.
01:40:25.900 - 01:40:30.660, Speaker B: Thank you. Thanks, Peter.
