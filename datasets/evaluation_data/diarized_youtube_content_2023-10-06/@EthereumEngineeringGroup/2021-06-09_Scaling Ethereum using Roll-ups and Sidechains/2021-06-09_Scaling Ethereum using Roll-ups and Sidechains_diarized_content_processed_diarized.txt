00:00:01.370 - 00:00:38.060, Speaker A: So hello and welcome everyone who's just looking at this recording. This is the Ethereum engineering group meetup and I'm Peter Robinson. Ok, I'll share my screen. Ok, so can people see my slides? Yep, I saw some thumbs up. That's always a good sign. End. Okay, so I am going to try and do a quick overview of what it's about and then we're going to dive into the detail before we come back to the summary at the end.
00:00:38.060 - 00:01:58.050, Speaker A: So side chains at a very top level, how the sidechain technology works is you've got a blockchain, you submit a transaction into an EVM like system and then one of the people who was operating, or maybe a coalition of people operating that side chain, put a pin into Ethereum main net. So this is at a high level, this is how it works for side chains. And if you have a dispute though, you need to contact someone to resolve this dispute. So you need to get external enforcement. Whereas another technology that we'll talk through is optimistic roll ups. What optimistic roll ups are all about is you can have an EVM like environment, or maybe a UtxO environment and you put transactions onto it. And the idea is that you have a sequencer, so another operator sort of person, and they put a compressed version of those transactions and state onto a contract in mainnet.
00:01:58.050 - 00:03:20.954, Speaker A: And the big difference with the initial technology is how do you prove that bad stuff's happened? And in this case, one of the other operators of that roll up are going to submit a fraud proof. And then the final technology that we're going to talk about today, ZK roll ups, zero knowledge roll ups, how they work is you put a transaction in and again you've got a UtXO or some sort of VM environment, and you put a very compressed transaction and a proof onto a contract on main net. And the big thing about the ZK ones is that no fraud proof is required because you've put forward a proof that what you've done is correct, what you're proposing is correct. So you can think that we've got three different types of technologies, side chains, optimistic roll ups and ZK roll ups. And how they operate is different. So the consensus on a side chain is whatever you like, it's not related to the chain that it's related to. So you could be using a POA, a POW PoS consensus.
00:03:20.954 - 00:04:00.970, Speaker A: It doesn't matter. And because it's an independent blockchain, you could have it 100% EVM compatible. And what it's all about as far as that. So it's isolated. But then you've got the question of if you want to do a withdrawal, how can you be sure of when it's valid to do a withdrawal? And really that comes down to when you have finality for a side chain. So that's essentially at the dispute window. And as I said, it's all about reputation and trust for the security model and resolving disputes.
00:04:00.970 - 00:05:06.814, Speaker A: So whereas if you think of optimistic roll ups, it's all around crypto economics and fraud proofs, whereas ZK roll ups, it's all around having a proof. So it's cryptographic enforcement, and so it's really resolving things around ZK. Is there a knowledge? So that is at a really high level. Now, I wanted to give that at the start, just to try and give an overview of the three different types of technologies from a very, very high level and what the differences are, really. So let's go and get a bit closer to the actual technology. But before we do that, I guess the big question is why do we need layer two? Why can't we just have more layer one? Well, people want to do scaling generally for all of the reasons listed here, and I've got a whole stack of reasons, but really the big one is they want the transaction fees to be less. That's what it's all about, really.
00:05:06.814 - 00:06:00.670, Speaker A: You want to have your $0.01 transaction or $0.10, not $10. Something to keep in mind, though, is that these layer two solutions will provide more capacity, but similar to a road. If you build a road and it's one lane each way, if you put another lane on that road, invariably you'll get more traffic because it's easier to commute between those two locations that the road connects. And as you add more capacity, it will fill up. And so the only real solution to this is to have infinite scaling, so that as you provide more scaling, the transaction fees goes down, you have more people use it, the transaction fees go up, you can then add more scaling and more scaling.
00:06:00.670 - 00:06:39.814, Speaker A: And so that's really something to keep in mind with any of these solutions. Side chains. So from my perspective, a side chain, it's just a blockchain. That's really what it comes down to. It is a blockchain, but then I guess you can say, well, look, just a sec, we've got Ethereum mainnet and we've got the testnets. We've got other networks that are out there that are even copies of Ethereum mainnet. You've got other blockchain systems completely.
00:06:39.814 - 00:07:50.638, Speaker A: Are they side chains? What about consortium blockchains? So for instance, go quorum deployments, are they side chains? And so there's a bit of a nuance here. So a side chain is a blockchain that relies on some other blockchain for its security and the blockchain. So the side chain could have different consensus algorithm, even a different transaction model or execution engine. So it could be a Utxo model rather than an account based EVM model. And often the chain that you're going to rely on for security is Ethereum Mainnet. So what do I mean by security? So if you look at this diagram here, you've got a side chain at the bottom that's banging out transactions or blocks, and it is pinning to mainnet. So when it's pinning a pin is a block hash.
00:07:50.638 - 00:09:25.694, Speaker A: So essentially you're posting your block hash onto a contract on Mainnet. And so by having that state hash you're saying, well, this is what we're up to. And so what that's trying to protect you against is say if you're a user of a side chain, maybe the people operating the side chain go, oh, we don't like where we are up to with block six. Wouldn't it be good if we reverted a transaction back in block four and change state history? So you might find that greatly disadvantageous. But if it's only, say, a small consortium network, they might all collude to do it. So if you've pinned the state of the blockchain of the side chain to Mainnet, then you will have the ability to show people, hey look, the state should have been this at block five, and yet now people are, the consortium are saying it's this, so they've changed things, and so the aggrieved party can show the state history, the transaction history and the pins that are on main net to something like a court of law to try and have the blockchain changed. And so the mechanism for actually having the contract on Mainnet to put the pins into the state hashes, it depends on the technology use.
00:09:25.694 - 00:10:14.050, Speaker A: So there's a great variety. So you could be voting on which are the valid pins. You could have multi sig signing off chain of the block hashes, you could use BLS signing. You could even have some sort of anonymous pinning approach so that you didn't reveal the participants on the side chain. So there are many approaches, but all of them really come back to you put a transaction on the side chain and then you pin it to some contract on main net. But if anything bad happens, you're going to have to talk to someone outside of the blockchain to try and resolve the dispute. And so the big take home is there's no data availability, so there's no automatic way to prove that the pins are invalid.
00:10:14.050 - 00:11:33.206, Speaker A: Though if you joined a side chain and you got the Genesis block and the complete transaction history, assuming that the transaction history that you're being given isn't modified, you'd be able to work out the current state of the blockchain. But if obviously they change the transaction history that you're getting, then you wouldn't notice. So the big issue is that you don't have the transaction history available somewhere. So optimistic roll ups try to solve this problem. And so you put transactions onto the roll up and then you post a compressed transaction and state route to Mainnet. And then if something bad happens, if you decide that someone's changed the state incorrectly, one of the people operating the roll up will post a fraud proof. So I guess the thing to think about is how does this actually work? So what we've got is we've got a solidity contract, you've got some code off chain which is running the roll up, and then you're optimistically publishing the transaction results without actually executing them on Mainnet.
00:11:33.206 - 00:12:17.286, Speaker A: So we're taking execution away from Ethereum. Mainnet and the execution engine can generally be reasonably EVM compatible, sort of. And there are a few different approaches and probably more than I've got here. And so let's have a look at fuel as a starting point. So fuel is not an EVM based one, it's a Utxo. So like in bitcoin. And I specifically decided that we'd go with fuel first because it helps you to start thinking about the fact that you don't have to have an EVM as the thing that you're running on the roll up.
00:12:17.286 - 00:13:45.950, Speaker A: So with Utxo you have a number of inputs, you do a transaction and then you have outputs and it's all about value transfer. And so how fuel works is that anyone can create a block off chain and it has a set of transactions that you're going to create and then you put that fuel block onto the blockchain. And so each block has to build off the previous block. And if you post an invalid block, then anyone can post a proof to say hey, the block that you've posted is invalid. And after the timeout period to prove that the block was invalid, you'll get your deposit back for posting it. So when you're posting a block of transactions, you post with a deposit, and then you get the deposit back, and you can move coins out of there by burning coins on the roll up and then getting them back on main. So how these blocks work is you have a set of transactions which you've got a Merkel tree, so you've got then array of these roots of Merkel trees.
00:13:45.950 - 00:14:45.970, Speaker A: And so then you have a whole stack of transactions which you're then putting in. So you can see that you're greatly compressing, so that you've only got, say, one block will represent hundreds or thousands of transactions, though all of that transaction data still needs to end up appearing on main net, but it can just appear as an array of bytes and doesn't need to be processed. And so, to get value onto fuel, what you do is you have an ERC 20 contract. You do an approve and then a transfer. Or they've got this idea of a token funnel. And so with the token funnel, the idea is you transfer the value to an address, and then you use a create to instruction to create a contract at that address. So essentially you'll be pre funding the contract, and then the contract does the transfer and self destructs.
00:14:45.970 - 00:15:50.474, Speaker A: And so the idea is that then you'll have a node on the roll up, we'll notice that the transfer has happened, and then they'll then go and mint some tokens on the roll up. So for the exit from the roll up, normally you have to wait for two weeks for the fraud proof window to complete. However, they also have a HTLC, so hashtag lock, contract, exit. And so this means that you're essentially swapping with someone your tokens. So someone, say, Charlie would get some Alice's tokens on the roll up, and Alice will get Charlie's tokens on mainnet or the other blockchain. It doesn't have to be Ethereum mainnet, but a blockchain. So fuel supports a whole stack of coins.
00:15:50.474 - 00:16:52.882, Speaker A: It's not just one type of coin. And in the next version, they're going to bring a virtual machine to the system. Okay, optimism is the next technology. So, in optimism, a user submits a transaction to a bonded sequencer. So, similar to fuel, you've got a node and it's paid a bond on mainnet to make sure that it doesn't act incorrectly. And then for each transaction that you have that the sequencer has, it creates an OVM message, which is a compressed transaction, and then it executes the OVM message in the optimism virtual machine. So this is actually executing it in the roll up.
00:16:52.882 - 00:17:42.960, Speaker A: So essentially the roll up is essentially a modified version of geth, so go ethereum. And so it'll execute in the roll up. And then as part of the overall state execution, you might update the state and that might get stored on the roll up, and then you'll have a new state route which will be calculated for that transaction. And so the sequencer publishes batches of transactions and. Sorry, someone. Our configuration, sorry, I don't know if other people can hear it, but the configuration of Zoom seems to have changed such that we're having noises every time someone joins. I'll just try and work out.
00:17:42.960 - 00:18:29.850, Speaker A: No, I can't work it out. Sorry. Come on. Sorry, I've just, here, I'll just play from current slide and I'll just reshare. Sorry. All right, back. Yes, the sequencer publishes batches of transactions and state routes to the optimism contract on Mainnet.
00:18:29.850 - 00:19:14.560, Speaker A: And that gets put into the canonical transaction chain contract and the state commitment contract. So anyone can then submit a fraud proof on Mainnet to revert the bad state. Though note that they're not reverting transactions. And so the sequencer that published the fraudulent state is going to get slashed. Additionally, any sequencer that built off the bad state also gets slashed. And so what this does is it induces sequences to make sure that state routes are valid. And the fraud proof window is one week.
00:19:14.560 - 00:20:07.790, Speaker A: So I mentioned OVM transactions or OVM messages. And so on the left we've got ethereum transactions and the amount of space they use up. And on the right we've got OVm transactions. And one of the big things that you'll notice that we don't have in an OVM message is the amount field. So in the OVM there is no concept of ether as such, not as a native type of currency. You've only got wrapped ether inside of an ERC 20. And the reason for that is that you're trying to create an environment where everything can be simulated by the execution contract on main net for when you're doing a fraud proof.
00:20:07.790 - 00:21:13.220, Speaker A: And so you'll notice that we've got, say for nonce, gas limit and price. We've shrunk them from 32 bytes down to three, but we've still got the two field and the signature field as big bits. And in particular, if you look at that signature, it is a massive proportion of the overall transaction. So for these OVM messages, what happens is you've got a modified go Ethereum version. And so you put your transaction into that geth client and internally it will get all of these fields that are part of the message and it will put them into the payload for a new transaction. And so that new payload is the OVM message, and then that transaction gets submitted to the actual EVM to get executed. And so it will then execute the actual.
00:21:13.220 - 00:22:22.300, Speaker A: Yeah, so you can think you're putting all of this into the data field or the payload field for the message. And so the OVM execution is similar to EVM execution, but some of the instructions aren't available and some of them are available by calling out to another contract. And so to create this code that can execute in the OVM, you need to use a forked solidity compiler that will generate the appropriate code. And so the instructions which aren't available are the ones shown here. And you'll notice that say call value and balance, they're all related to the actual ether. Because there is no ether, you can't get access to it. Difficulty doesn't make sense because we don't have a proof of work algorithm or anything like that.
00:22:22.300 - 00:23:38.114, Speaker A: These are the instructions that just don't exist and the equivalents in solidity land. But then there are a whole stack more of instructions that when you call them, you're actually calling a function in a contract. And the important things here that I'll highlight is say the s loaded s store. So whenever you're storing state, you're actually storing it via a contract. So you're not directly storing into the EVM state as well when you're doing calls, so doing cross contract calls, they're again going via a function call, anything related to, say code copy code size, that again is going via a function call. And so what this looks like on the left hand side we've got how it would work if you're in the EVM, whereas on the right is what it looks like when you're running in the OVM. So you want to go foo and then that does a store s store.
00:23:38.114 - 00:24:54.380, Speaker A: So it stores something, a word to storage and then you'll get a transaction receipt. Whereas now what happens is you're going to submit your transaction, the forked go Ethereum is going to turn it into an OVM message and then it's going to call run on the execution manager and then that's going to call out to Foo, which the entry point. And then it's going to go, well, OVM store, I want to store something. And then that's going to call to the state manager to actually put a value into state storage. And then if you say we're doing a cross contract call, so you did Foo, which was going to call bar, then what you're going to do is you're going to call Foo, it's going to do the OVM call. So it's going to call bar via the execution manager. And so rather than these things being just single instructions, now you've suddenly got a whole stack of code that's going to execute and obviously it's more code to actually do the call itself.
00:24:54.380 - 00:25:59.310, Speaker A: There's also this thing called the OVM safety checker. And so what it's all about is trying to make sure that you don't use any unsupported opcodes and that your code has been correctly translated. But this checker doesn't check code that you could execute as part of a parameter into the constructor. So essentially if you try really hard you can break the system, but you're not generally going to run into that. So the state manager, I said that there was that state manager when you were storing a value. So you can imagine it's got a two dimensional array state where one dimension is by contract address and the other dimension is by storage location that you're storing to. And in the roll up this state manager is implemented as a pre compile so that you have fast state access on the Ethereum main net.
00:25:59.310 - 00:27:01.026, Speaker A: However this is actually implemented as a real contract and it's used for the fraud proof checking. So fraud proofs, how do they work? So we've got that state commitment chain and we've got the canonical transaction chain and you have one transaction per block. So you've actually got blocks, but you've only have one transaction per block. But then you have batches of transactions. But by the time you're in the canonical transaction chain you've just got an array of transactions and each transaction relates to a state update. And so essentially transaction six combined with state five gives you state six. And so when you want to submit a fraud proof, you initialize the system to say well this is the state that I'm concerned about.
00:27:01.026 - 00:27:55.570, Speaker A: So this is the state change that's being disputed. You then deploy contracts on Mainnet. So you then deploy some contracts that are the ones that are involved in the execution. And you tell the system which contracts are linked to what contracts on l two. So the contracts on l two are going to be at a different address to the contracts on l one. So you need to link the two and then you've got to set up the relevant state and you'll be supplying Merkel proofs to prove that these values were part of the state that the previous state route related to. So once you've got all of the contracts and you've linked them up with their l two addresses, and you've got all the state set up, then you can run the transaction.
00:27:55.570 - 00:29:10.986, Speaker A: And when you run the transaction, it will probably update the state. And so you may need to then supply yet more Merkel proofs and state to show, or Merkel proofs to show that the new state, how it relates to the overall system, so that then you can show and derive a final updated state. And then what you do is you do the fraud verification. And so you've got your calculated state and the existing state that's in the state commitment chain, and you compare the two and if they don't match, then obviously you've had an invalid state transition and in which case the appropriate parties get slashed and you'll get a benefit from posting that fraud proof. So you can imagine state seven, eight and nine would then be removed because they've now been deemed to be illegal. So if state seven is illegal, then you can't state seven, eight and everything beyond there has to be illegal because state eight builds off state seven. So even if they're different contracts that have been updated, the state has still been changed.
00:29:10.986 - 00:30:10.240, Speaker A: However, one of the things to look at is that those transactions are still there, they're still good, and they're canonical, they are in sequence. You're not changing the order of those transactions. So then anyone could then reexecute. And so that, yeah, state transactions are retained in order and so you've just got to re execute them and provide off chain and then provide the new state updates. So a sequencer can then provide the correct states for those transactions so that you don't limit the number of fraud proofs happening. The fraud proofs can actually execute in parallel. So say if you wanted to dispute that state seven, you could have state seven b as being the fraudulent state and you could be showing that there is this other state.
00:30:10.240 - 00:31:21.430, Speaker A: Actually, no, I'm saying this the wrong way around. You can imagine that state seven a was already in the chain and there was also state eight a. But you could be saying, look, I'm doing a fraud proof based on state six and then someone else could be doing a fraud proof based on seven a. And the reason why you want to be able to do this is if you could only have one fraud proof at a time, then you could have done something bad, put in a fraud proof, which you know is going to fail, and then you might be allowing your bigger fraud to slip past the fraud proof window. And so it's important to allow multiple fraud proofs to be executed at the same time, and that's how they do it. So ether, as I said earlier, ether is represented as an ERC 20 contract on the roll up at a certain address. And so when you say call f, get balance on the client, go Ethereum fork, it's actually going to talk to that ERC 20 contract.
00:31:21.430 - 00:32:15.160, Speaker A: And so transactions that you send directly to the roll up, you pay a bit of gas, which is really going to be that ERC 20 ether. And then on top of that, the sequences are probably going to charge some sort of transaction fee as well. So transfers to and from the OVM, so you can send messages, they're cross blockchain function calls, but they're not atomic, they don't have safety. So you're essentially doing message passing. You're saying, hey, can you call this function? But you're not sure whether that function is going to execute correctly or not. It might revert or it might not be able to execute for whatever reason. Maybe there's not enough ether, or maybe the state is such that it can't happen.
00:32:15.160 - 00:33:27.758, Speaker A: And so l one to l two, the idea is that you transfer the ERC 20 to the roll up contract, transaction occurs mits an event, and then that event goes into an outgoing message queue. The OVM message is forward to l two, and then on l two you mint some new tokens. And then from l two to l one, how you were publishing these OVM messages to the l one, you're doing the same thing again as for these messages. And then you can say, hey, here's some special message and it's past the fraud proof window. So now let's act on it. And the important thing here is that one week fraud proof window is there to ensure that you haven't had censorship resistance or to have censorship resistance for Mainnet. So say if someone commits a fraud, they might then bombard Ethereum mainnet with transactions to try and make it so that no one can put a fraud proof in.
00:33:27.758 - 00:34:21.534, Speaker A: And so to cover that possibility, you've got a one week fraud proof window. So one week sounds like a long time. Could we use htlcs or GPact to get around it? So for a HTLC. You could imagine that on the roll up you've got one HTLC, and then you've got the contract on another blockchain, which could be mainnet, and you've got Alice. She deploys the two contracts and she says, look, I want to swap five apple coins for two banana coins. She posts her commitment h to both contracts and she sets it up so that she can withdraw on the other blockchain if she submits her secret. And Bob can withdraw if he submits the secret on the roll up.
00:34:21.534 - 00:35:31.324, Speaker A: So she wants to swap for Bob. So open question to the audience, can Bob safely deposit two banana coins into the contract? Okay, everyone's rushing to answer. Joseph Chow, I can see you were on the call. What do you reckon? Can Bob safely deposit the two banana coins in? Well, rushing to unmute if hours has a timeout of 2 hours, then after one and a half hours, Bob can't withdraw, but Alice can. That would seem to be a yeah, but the reason why you would do that is because then Alice can reveal the secret just on the 1 hour mark, actually. Yeah. So Bob can withdraw if the thing's not going anywhere.
00:35:31.324 - 00:36:49.912, Speaker A: So essentially what that means is you've got a 1 hour window on for Alice to submit the secret. All right. So the thing is, though, the big thing is if we look at our window one week, so obviously the HTLC timing is going to be within that week, isn't it? And so Bob needs to know, well, within 1 hour, does he trust that state? Does he think that t 32, the contract that it deployed, does it really exist? Because if he puts his two banana coins into the contract on main net, and then it turns out that the contract on the roll up doesn't exist, then he's in trouble, isn't he? So maybe there's a fraudulent state being posted. So maybe that contract doesn't exist at all. So even though it looks like it exists based on state 32, maybe it doesn't exist. And even if the transaction t 32 sets up the contract, Alice might not have had enough money to deploy the contract, in which case she would have submitted the transaction. But maybe it can't go through.
00:36:49.912 - 00:38:04.130, Speaker A: So there might be some reason why despite t 32 existing in the blockchain, it might actually have no effect. So what he can do is Bob could combine state five with all of the states that he can, all the transactions he can see to essentially confirm the validity of the contract and confirm essentially the validity of the states. So obviously that's going to be a lot of transactions to process, but that's my take on how you could do it, and I can't see any other way of doing it. I think Bob has to look at what the state from just before the fraud proof window, and then process all the transactions to make sure that the part of the state that he cares about actually exists. So then he can deposit his coins, and then Alice submits the secret and withdraws her two coins. And then Bob will read the secret and then submit the secret and withdraw the apple coins. So what about GPact? So it's in exactly the same situation.
00:38:04.130 - 00:39:04.530, Speaker A: If you have a start transaction and then you have a subordinate transaction, then you have the root transaction. You're not really going to know what that root transaction, if it's valid or not until after the fraud proof window. But if the whole point is to try and exit and do something prior to the end of the fraud proof window, you're going to need to make your own evaluation of whether you think it's valid or not. And the only way to do that is by looking at the state immediately before the fraud proof window and then processing all the transactions yourself to convince yourself that it's right. And hence I can process the output of that root transaction. So of course with any of these cross chain things. So whether it be just the message passing from optimism itself or HTLCs or GPact, you need to watch out for front running.
00:39:04.530 - 00:39:54.724, Speaker A: And so essentially you're advertising to people, hey, I'm going to do this. Here's a function call that I want to do on layer two. Or here's a function call that I want to do on layer one. And for the layer two to layer one, it's one whole week fraud proof window that you've got to wait and that everyone can see you're going to do that transaction. And so if you've got a contract, which is an auction contract, and it says bid $2 more than the previous highest bidder, then that would be really bad, because I could look at it and I could be the owner of the thing, and I could see that sly has definitely agreed that he's going to bid on a contract on that item. And so I'll just put it at a million dollars. And now suddenly he's committing himself to pay $1,000,002.
00:39:54.724 - 00:40:48.448, Speaker A: So as with anything to try and prevent front running attacks, you've got to be looking at using absolute values, not relative, or looking at the previous state and specifying your new state relative to the previous state. So at the moment, they've got a test net, and they say that they're going to have a main net publicly in July. I've heard on the rumor vine that they may be running a little late. I'm not sure. So, things to consider about optimism. So replacing those opcodes with functions, the amount of gas that's going to be used is going to be more than if you were running the code on main net. So you're going to use more gas.
00:40:48.448 - 00:41:31.292, Speaker A: The other thing is that the code size is going to blow out. So if your code was already right on that 24k limit, it might become illegal now. And as well, there's a lot of stuff being stored on main net still, you're storing all those transactions or that transaction information. There are lots of bytes there, and so someone's got to pay for that. And so you could imagine that that might mean that it becomes not as cheap as you'd hope. If you're planning on submitting a fraud proof, it's going to cost a ton of gas. There can be state reversion, but not transaction reversion.
00:41:31.292 - 00:42:16.290, Speaker A: So it's really a matter of thinking what that means. Yeah. Also, though, there are limits to what fraud proofs do, so it's about invalid state transitions and the transactions are still there. However, a transaction might become invalid. So I consider the example that I say that I'm going to transfer one banana token from me to sly. If there's something has happened such that I don't have one banana token at the time, then it doesn't mean that that transaction is going to work. So you've got to think about the limits of this.
00:42:16.290 - 00:43:22.672, Speaker A: So another thing that to keep in mind is how many sequences are there? And also, are the main net contracts upgradable? I'm not sure if they are, but I think guy read somewhere they might be. And so if they are, then you've got to think, well, that's good if there's a hack, but also, it means that all the logic could change as well. So, yeah, it's an interesting security thing to think through. Arbitrum are another system. They're a competitor to optimism, and I have not had time to go through their system in detail. But when I was reading through the blog posts and looking at stuff, my feel was that optimism and arbitrum have worked with, have seen each other's developments, and at times maybe fed off each other's ideas. And for instance, in one blog post, they were saying in arbitram that optimism has a single pass fraud proof, whereas arbitrum has multipass.
00:43:22.672 - 00:44:13.796, Speaker A: And yet, I don't know, at least my take on how optimism seems to be doing their fraud proof. It now seems to be multi pass. But maybe I'm wrong. But anyway, if you come from the Arbitrum team and you'd like to do a deep dive on your tech, please contact me and we can do a meetup talk at some point as well. Raghavendra and I chatted. So Raghavendra is another consensus software r D researcher, and we were looking at this whole tech, and we were thinking, all these state routes don't need to be on main net, and you could be saving gas by not putting them all on main net. And maybe you could just have 128 of them, say, and have a merkel root of all of them.
00:44:13.796 - 00:44:59.776, Speaker A: Or maybe you could even have an arbitrary number, but have a seven depth binary Merkel tree. And then when you were doing a fraud proof, you could submit a Merkel proof. And so I don't know if anyone in the optimistic roll up area has decided, thought about doing this, but it seems like a good idea. And after talking with Nicola Liuchon, this is actually what's going to happen for Ethereum, for the data shards, which I'll talk about soon. Okay, ZK roll ups. So ZK is zero knowledge, and essentially you're doing roll ups, but using zero knowledge proofs. And so the big thing is that ZK is going to tell you that stuff's been executed correctly.
00:44:59.776 - 00:46:05.476, Speaker A: And if you want some good intros to ZK technology, please have a look at those links. So, in summary, again, you put a transaction into the roll up, and then essentially the transaction and state route, and a proof is put up into a contract on main net. So you don't need to do a fraud proof because you know that the stuff that's there is correct, because you've got a zero knowledge proof to say it is. And so there are a lot of alternative schemes for zero knowledge proof stuff. And so I'm just going to walk through one. There are many steps involved in creating these ZK snark things, but one of the important steps is arithmetic circuits. And so the idea is that you try and represent information as an equation, and you have a result based on this arithmetic circuit.
00:46:05.476 - 00:47:28.900, Speaker A: And so you can change the values of the inputs and get different outputs, but you've got the same equation being executed each time. When we're thinking about these zero knowledge proof solutions, one of the things to think about is the amount of computation involved, and they do require a lot of computation. And so for the technology that I'm going to talk about soon, typical batches of transactions take in the order of minutes to execute or to prove. And so at the moment, that is probably too long for what most people will want to have. They want to be able to do lots of transactions per second. And I guess the only way of doing that would be to have lots of parallel computation, to be able to do lots of minutes worth proof creation in parallel. But the actual length of time depends on how big that circuit is, that arithmetic circuit, and also some of the other choices in the actual proving zcash, which is a simpler than say, doing an EVM like transaction, they only take about one or 2 seconds.
00:47:28.900 - 00:48:30.328, Speaker A: So for the verification, so that was the creation. But for the verification, it's invariably a fixed duration, fixed length of time, but it still is going to require a fair bit of gas to do because you're doing two easy pairing operations. And the proof size does depend on the scheme. So plonk, which is the one that's used by ZK sync, it uses 400 bytes, but then groth uses less, but plonk lets you do more. So let's talk about ZK sync. Zk sync initially they were going to have their own virtual machine, and they were going to have a language called zinc, and it's similar to rust, and it was optimized for these circuits. And one of the issues though that they had was they couldn't get it to be turing complete.
00:48:30.328 - 00:49:30.380, Speaker A: So you had to have fixed length for loops, for instance, and you couldn't do recursion. And so you ended up not being able to have it. There were a lot of things that would have been broken. Essentially application developers gave them feedback and say, look, we've been using solidity, and if we're going to use your system, we need to be able to use solidity in pretty much the way that we have been. And so I think anyone who's going to be involved in creating custom vms needs to keep this in mind. And so they came up with Zksync two. And so a lot of what I'm going to talk about now is derived from a YouTube video I watched and my summary trying to compress down that talk into only half a dozen slides.
00:49:30.380 - 00:50:54.900, Speaker A: So you can think of you've got a state transition function is something that you can have. And so you start out, say with a Merkel tree of state, and say when you want to transfer value between one account to another account, you have this state transition function, which tells you how to change the root of the tree based on the state change. And for those people who've been around for a while watching these talks, you'll recall that this actually feels a lot like stateless ethereum, where you're changing state and you're presenting, here's some Merkel proofs, and here's a bit of information, and here's proving that that information is correct using the Merkel proofs. And we're going to change the root from this to that using some state transition function. And so the state transition function gets converted to one of those arithmetic circuits that we talked about. And the transactions, the accounts, the Merkel proofs, they end up being the input to that state transition function. And so you go from the arithmetic circuit using a prover, and you create a proof.
00:50:54.900 - 00:51:51.064, Speaker A: And so then separately, there's this concept of a tiny ram, and it's a way that someone came up with of executing arbitrary computation. And so imagine that the circuit is the thing at the top there, if the operation is add, and then have the accumulator equal the accumulator plus the input. Else if it's a multiply, then the accumulator is the accumulator times the input. And so you're able to then have the arithmetic circuit process. And so you start off with zero, you add two, you get two, you multiply by three, you get six. Multiply. Oh, yeah, I think I've mucked up my arithmetic circuit there.
00:51:51.064 - 00:53:01.740, Speaker A: That should be multiply by five to get 30, not add. But you can see how just by applying the same circuit to multiple pieces of input, you're able to do some arbitrary logic, and I could just change the operations or the input, and you would end up with a different output. Or the issue is that the tiny ram needs 1000 times more gates. So in that arithmetic circuit, you need 1000 times more gates than you would if you were hand wiring the whole thing together. And so what you could do, though, is you can create some handcrafted stuff, say, for complex operations, and then just use the general computation using tiny ram for the general purpose operations. Another technology that they came up with was recursive snarks. And so each prover has to be hardwired for a specific circuit.
00:53:01.740 - 00:53:57.068, Speaker A: But what you could do is you could have a prover that proves the circuit where this circuit is another prover. And so what that really means is that you get approver to prove a program and then a prover to prove the other prover. And so that's what it's all about you use recursive snarks to create a circuit to verify other proofs. And so how it works is you have, your tiny ram is used for your contract logic. And so that was going to have that thousand times expansion rather than if you had a hardwired circuit. And then you're going to use your optimized circuit, say Kak for doing message digest. So it'll be hardwired because it's a hugely complicated algorithm.
00:53:57.068 - 00:54:46.112, Speaker A: And if you just use tiny Ram, it'd be too big. But if you hardwire it, it's of reasonable size and then you've got your state access as well that you have separate. And so the idea is that you do a recursive proof and then you have a proof for the whole block. And so based on the website, so they say that you should be able to deploy most solidity projects without modification. But then there did seem to be some caveats. So I think it's everything. But there'll be some stuff that won't work, like say see how it's now.
00:54:46.112 - 00:56:00.056, Speaker A: And block hash and block number is my perception of what they mean by undefined behavior. So gas is going to be charged differently in Zksync to in the EVM and the prices are going to fluctuate based on l one prices. So essentially on the price of posting to Mainnet. So what is actually stored on main net? Because earlier on I talked about very compressed transactions. And so at the moment you've got your old hash root and you've got your new root hash and then you've got a proof and you've got from to amount nonce for each transaction. And I guess you look at that and you think well just a sec, there are no signatures so how can you be sure of the transactions? And the transactions might need to get re executed, say if another operator looks at them and they want to recreate state. But you don't need those signatures because the proof proves that the signatures were correct.
00:56:00.056 - 00:57:20.576, Speaker A: And so that means that you get to store less stuff on main net. So rather than it being 67 bytes for a signature, you're only storing 20 bytes for the address of from. So ZK sync aiming to have main net up in August. So they've also come up with as well as the ZK sync which gives you a roll up based on Mainnet. They're also saying look, rather than having the availability on Mainnet, what about if we have the availability on something that's a little bit like a side chain so we could operate a chain separately and have the state, the availability posted to it, and that way you wouldn't have to be paying the transaction fees for Ethereum mainnet. And they say that this is more secure than just a sidechain because you're only approving proofs and so you have no ability to change transactions, but you don't have that data availability on Mainnet. Starquare is another player in this space.
00:57:20.576 - 00:58:46.860, Speaker A: I've run out of time and slides to talk about them, but if you come from Starquare and want to do a talk, please get in contact. So consensus is doing heaps of stuff in this space too, and some stuff we can't quite announce quite yet, but in due course we will. But one of our groups is developing Narc, which is a ZK snark library used by lots of people, and there are a whole heap of research that we've published. So 1 hour in and now we're up to maybe the bit that lots of people are interested in. How does this actually affect Ethereum? So right at the moment, we've got the Ethereum two beacon chain, which is proof of stake, and we've got main net, which is proof of work. So sometime, maybe Q one next year, you're going to have Ethereum main net will be both of those combined, and what is currently Ethereum main net will just be an execution chain, and your beacon chain is going to be the consensus chain. So where you do the consensus protocol and get agreement and it'll be proof of stake, and you can think of those two chains as being tightly coupled.
00:58:46.860 - 01:00:07.690, Speaker A: So then you've got the data shards, and so you're going to have 64 data shards are going to come along, and so they'll be posting cross links and then roll ups. How they can work is that they can be posting most of their information onto the data shards, and then the execution of the information from the data shards can be happening on the execution chain. So say if you need to update the state route, then you would do that in the execution chain based on the information that's in the data shard. So you might say be doing some update that might involve updating one word on the execution chain, whereas you might have, say, thousands of words being updated on the data shard. And so in this way, it allows you to have scalability. So you're putting computation onto the roll up, data availability onto the data shard, and just a little bit of computation on the execution chain and that's how you get scalability. And this is pretty much the same thing set in words.
01:00:07.690 - 01:00:57.480, Speaker A: So this is the comparison slide said way at the start. So the consensus, the roll ups rely on main net consensus, whereas side chains are separate EPM compatibility. So the side chain has got 100% compatibility. For both optimistic and ZK you're going to need some sort of specialized compiler. And the ZK technology, it feels like it's going to be slightly more limited than the optimistic, but I think what we really need to do maybe is see where both of them are by the end of the year. And so maybe try out each of them. So, fraud window.
01:00:57.480 - 01:02:07.996, Speaker A: So once a pin has been posted for a side chain, I guess there's some sort of dispute window. In optimistic roll ups, there's some fraud proof window, and in the roll ups, the ZK roll up, everything is immediate once it's posted, but then the question is how often is it posted? So the security for a side chain, it's based on trust, and you're relying on the reputation of the people running the side chain and them not wanting to be in a court of law. For optimistic, it's all about crypto economics and people not wanting to be slashed. And you're going to use fraud proofs to prove that they should be slashed. And for ZK you're using zero knowledge proof, so you're using cryptography to secure them. So data availability. So the stuff on the side chain isn't available, whereas for optimistic and ZK it is obviously something that would be lovely to have on this graph would be cost.
01:02:07.996 - 01:03:03.084, Speaker A: But I don't think anyone knows the answer to that yet. So mattelabs, or the people behind Zksync, they created this slide here, or this diagram, and I've stolen it straight from a medium post of theirs. And so they're saying, well, the security for a side chain is not that low. You're relying on these trusted parties and they don't think it's that decentralized. So I think for those two dimensions, it really depends on which side chain programmability. Obviously it's fully EVM compatible and can be very scalable because you can really ramp up the transactions per second and you could have a whole heap of them as well. Optimistic roll ups, they're saying it's fully programmable, more secure, more decentralized.
01:03:03.084 - 01:04:04.612, Speaker A: And so the security is based on the fact of the data availability and the scalability offers some level of scaling. And then their ZK sync, they were saying that porter is the orangey brown, whereas blue is just the ZK roll up. And so they're saying that it pretty much hits all of the targets. And then once you add eth two in, then it's perfect. So I put a few bits in there. So for me, whether it be optimistic or zk, the programmability isn't going to be exactly the same as you could get in a side chain. Maybe they'll get there, but right at the moment it feels like the programmability isn't quite there.
01:04:04.612 - 01:04:53.672, Speaker A: You've got say 80% or 90% of what you can do, but it's not 100%. So I guess that's my main point of contention for the comparison. Another thing to think about is that fraud proofs only work if at least one party is looking out for the fraud and submits a fraud proof. The optimistic roll ups, those vms are super complicated and they're leveraging the EVM. But if you have a look at the contracts, there's a lot in them. So it'll be interesting to see whether they're proven to be correct or if any issues are found. The ZK roll ups.
01:04:53.672 - 01:05:44.420, Speaker A: So they're using relatively new cryptography. I mean, it's been around for a while now, but still it's newish, and there's a lot of tooling involved in creating those circuits and analyzing the circuit to make sure it's the right code, I think is a massive challenge. So again, it's super complicated technology, so it'll be interesting to see how they go over time. So there's withdrawal latency versus finality. So you can withdraw from a ZK roll up quicker than an optimistic roll up. However, you've got transaction finality sooner. Probably, though that obviously depends on how quickly the ZK rollups get as their state posted.
01:05:44.420 - 01:06:53.060, Speaker A: Some issues overall is composability. So in Ethereum at the moment, you can have a program where it's got multiple functions, multiple contracts, and they can call each other if you've got something splattered across multiple L two s. At the moment, it's going to be hard for them to talk to each other, and you're really going to need to have something like GPact to let you do atomic cross chain or cross roll up function calls. The offboarding experience is also hard because of those fraud proof windows. And so there's going to be cost of moving assets, and it means that you're going to have liquidity pools potentially, say someone, some l two someone, another l two someone mainnet. And so having a good cross chain communications will help resolve that. So Nicola had a thought bubble as well that we could combine optimistic and zk roll ups.
01:06:53.060 - 01:07:56.990, Speaker A: So you could use optimistic for that complicated execution engine and ZK for removing the signatures and just having the from address and that thus creating the compressed transactions. So that's another possibility for the future. So in summary, side chains, you have a transaction, you can post a pin of the state route, but if there's any dispute you're going to something external, optimistic roll ups. Again, you're posting transactions to the roll up, you're posting compressed transactions in a state route and then you're relying on fraud proofs, ZK roll ups, you're posting a transaction and you know that what's posted on Mainnet is right from the start. However, creating the transaction in the first place. So creating the proof is going to take some time. There are lots and lots of links for you to all go through.
01:07:56.990 - 01:08:42.620, Speaker A: I thank all of these people here. They've really helped a lot. It's been really good to work on this slide deck collaboratively and have feedback because there's a lot of stuff here which I didn't know as much about at the start as I do now and it's been a great learning experience. There are a stack of talks coming up and the regulation of CDBC is going to be really good. Supply chain and blockchain conference is only in a few more weeks time, little under a month now. So get in for the free registration. I'm going to put the agenda up on the website sometime real soon, maybe tomorrow.
01:08:42.620 - 01:09:44.660, Speaker A: And anyway, lots of more talks coming up and that is it. Does anyone have any questions? There are lots and lots of stuff in the chat which I have not got around to reading. Okay? Yep. So what James Zackie and Peter Powell said for Joseph Chow is correct. There is no dispute in ZK roll ups because you've got a proof, cryptographic proof, so you're okay and going backwards. Maybe I need to go to the top. Yeah.
01:09:44.660 - 01:10:53.438, Speaker A: Can ZK roll ups do full EVM stuff or nearish full EVM stuff? Now my understanding is they've got a testnet that's available right now. And the thing is that those proofs take minutes to create. So my guess is that each of those proofs is going to take a minute or so to create, but then the proofs are across multiple transactions. So maybe the individual user doesn't create the proof. So maybe it's the validator or sequencer or whatever that creates those proofs. I know that individual value transfer is available now and there has been a lot of talk of two to three years, but then they're saying they're going to have something up and running real soon. So is a roll up state channel plus a side chain? No, it isn't because you don't have the data availability.
01:10:53.438 - 01:11:26.522, Speaker A: You can't do the fraud proof or you don't have the transactions available. Yeah. And for Peter, yes, it's going to be on YouTube. And yeah, I haven't put it on there. Let's see. I just had a question about the fraud proof there. Can you hear me okay? Yes, I can.
01:11:26.522 - 01:12:07.686, Speaker A: And I'll stop sharing. Yeah, I was just wondering, you said that the data availability isn't there. So is it only the. For optimism sake, is it only the states that are going on l one, or was it at each time there's the state and the parameters that make the transition? Yeah. So my understanding was that all the data for roll ups. No, I was looking at, someone had said I should have read out the question in the chat. There was the question, is it the same as state channels and a side channel, that one, for roll ups.
01:12:07.686 - 01:12:50.726, Speaker A: The big thing is data availability. So transactions and state and so that somehow or other anyone can re execute and come up with the same result. Doesn't matter who you are, you should be able to execute, say, everything that's happened in an optimistic roll up using either the forked version of geth. Or you could have your own side chain, your own, say Besu node that you're running just all by itself, not linked to anything. Deploy the various contracts and then put the state in to just make sure that you can execute the chain. Great, thanks.
01:12:50.828 - 01:13:25.170, Speaker B: I had a question about fraud proof as well. So you went through it pretty quickly in the slides. It was interesting that you said, yeah. So for fraud proof, it's like on the layer two, you pass the Merkel proofs for the things that are not on main net. So the main net contract. I thought that was interesting because I would have thought that it might have been like the other way around. I haven't had too much time to think about it yet.
01:13:25.320 - 01:14:16.354, Speaker A: Yeah, it's really interesting. So what's happened is you've got, everything's on the roll up and now suddenly someone says, hey, there's been a fraud. That state plus that transaction does not equal that updated state. And so what's got to happen is you've got to then recreate the whole state that is needed for the transaction. So it's very much like stateless, isn't it. So you need to be able to have the contract because you need the code that's going to be able to be executed by the EVM and you're going to need to have all of the state that is needed for execution. And so you need to be providing fraud proofs for all of that and the code as well.
01:14:16.354 - 01:14:22.690, Speaker A: And so it's a matter of putting it all together and then executing.
01:14:23.770 - 01:14:46.780, Speaker B: Okay, I guess my question there was, I thought you would run the transactions on main. Then it's like use Merkle proofs from the main net to tell the layer two roll up that there was an invalid state transition, whereas you kind of described it the other way around.
01:14:47.630 - 01:15:34.774, Speaker A: It is the other way around because you want the execution to happen on the roll up and all of the state to be stored on the roll up. So the idea is you don't have all the state on the roll up, rather on the main net. So you don't have to have all the state on the main net and you don't have to have all of the information. In fact, an interesting thing which I didn't cover is that they actually use ring buffers. And so they say let's have the fraud proof window. So one week's worth of transactions and state routes, and after that we don't care so much. And the reason for that is that prior to that it's beyond the fraud proof.
01:15:34.774 - 01:16:12.040, Speaker A: So it has to be correct. And so the idea is that in ethereum, if you write to a memory location that already exists, then you don't have to pay as much gas. So rather than 20,000 gas, you only pay 5000 gas. And it's a way of allowing the system to be cheaper. So normally you're deploying the contracts and doing everything on the roll up, but when you're doing a fraud proof, you've then got to get everything so you can run it all on main net.
01:16:17.120 - 01:16:20.750, Speaker B: Okay, yeah, I can ask that later.
01:16:24.020 - 01:16:59.228, Speaker A: I think all of this is going to become much clearer as we all get to play with the technology. I think. I think that'll be really good. And you can. At the moment there are tools and I did actually have a go at using the tools, but then I ran out of time, so I didn't. Are there any other questions? All right, well, thank you everyone for being on this very long call. And yeah, I hope you have a good day.
01:16:59.228 - 01:16:59.656, Speaker A: Bye.
