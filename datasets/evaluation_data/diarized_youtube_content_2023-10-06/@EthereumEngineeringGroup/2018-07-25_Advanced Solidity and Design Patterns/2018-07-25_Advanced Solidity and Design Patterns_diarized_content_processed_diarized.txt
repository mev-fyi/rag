00:00:06.120 - 00:00:18.910, Speaker A: Okay. Hello. Welcome, everyone. We're live to YouTube and so we'll be kicking off in about ten minutes. So just fast forward to ten minutes. Thanks. Hello.
00:00:18.910 - 00:00:49.140, Speaker A: Yes. Hello. Yeah, Michelle. Michelle. Yeah. Fantastic. Fantastic open source.
00:00:49.140 - 00:01:33.668, Speaker A: Different project. Yeah. And. But I need to talk to Michael over there. Yes. I was thinking that person looks like Michael. Hello.
00:01:33.668 - 00:02:57.470, Speaker A: Talking to you yesterday. How are you? Yeah, you should put personally people over there as well. But they're all conventional percentage. Yeah, we ended up doing airplane. Yeah. Touching button. But I'm pretty sure I are ready for the early.
00:02:57.470 - 00:04:47.990, Speaker A: But. Yeah, like. Yeah, but I don't think that's. Yeah, I thought. Oh, yeah, there's. Is that. Hello.
00:04:47.990 - 00:05:37.556, Speaker A: Dying? Yeah, yeah, should be. Should. Good advance, but we'll see. Well, this is an open source project, so it's a great opportunity to get involved. People will get involved and give feedback and everything because you work at consensus special and are they based here? Global company. We got a Brisbane base. Yeah.
00:05:37.556 - 00:07:12.660, Speaker A: We've got about 20 people and. Yeah. Employee. Yeah. Money for product managers and technical drivers. Very strange for transition. Through that transition.
00:07:12.660 - 00:08:54.836, Speaker A: I won't hold you up because you'll be. Yeah, but I'll be coming. It's. Yeah, but I'll be coming for the weeks. Yeah, it's all right on. Okay. Hello and welcome, everyone.
00:08:54.836 - 00:09:31.792, Speaker A: Please grab a seat. Rob, grab a seat. Okay. Hello and welcome, everyone. So today I'm going to talk about advanced Slippy and some design patterns around that. And I will admit that we came up with the agenda of what the schedule of talks were going to be, I don't know, month or so ago. And then I'm banging this presentation together over the last week.
00:09:31.792 - 00:10:34.500, Speaker A: And I'm thinking, why on earth did I call this advanced? What was I thinking? And I guess I was thinking more advanced than what Lucas had done, which was introductory. But then I'm thinking, you know, some people are going to look at this and they're going to go, that's not. So anyway, please feel free to throw stones if you don't think it's advanced enough. And so I've been involved in blockchain and doing solidity code in particular for about two and a half years. And this is based on my experience. And also I've got some examples that I've released open source on that repo there. And in fact, the idea, I guess, is going forward, say if we do the EVM talk like in two weeks time and there's some code that someone puts together to explain something, then we'll probably put it up there and equally, if you've got some example that you've developed that shows something in particular, then please feel free to put a pull request in.
00:10:34.500 - 00:11:17.570, Speaker A: And as you'll see with the example that I've put together, it's not entirely complete. And in fact, I've even found, been thinking about it overnight, thinking, why did I do that? That's a bug. That's not a bug, but that's not how you the best way to do it. So please feel free to come up with improvements, put pull requests in, and we've got a slack workspace. Why don't we use it to discuss the code? And I know that some people have said that they'd like to do a hackathon sort of thing, and other people have said, why don't we do a slow hackathon, so essentially do it over time where we develop something. And so I think this is a way that we can do that. And so if you're new to solidity, this also will give you a working example with tests which you can use as a starting point.
00:11:17.570 - 00:11:54.350, Speaker A: I am not specifically not going to cover these two topics here. And so one of them is ether transfer. I realize that ether transfer deserves a whole presentation unto itself because there are so many ways of mucking that up that one presentation couldn't handle it all. It's really complicated. And so that's something by itself. And also ERC contracts or other token based contracts and things like that, I'm not going to cover them. So they will have to be talks that will be done at some future point.
00:11:54.350 - 00:12:39.548, Speaker A: So I'm going to talk about design. I'm going to talk about the good old greeter example that we've all seen, and then we're going to dive into a bit of assembler. So when you think about Ethereum, you've really got to think about the design constraints that you've got. So one of them is that your code and your data is public, so you've got no private state that you can use. And once you've deployed some code, a contract, you can't update it, it's locked in. So that version of that code is never going to change. You can redeploy another contract that's very similar to it, but you can't change the existing code that's already deployed when you update the state.
00:12:39.548 - 00:13:13.220, Speaker A: So the data in a contract. So when you do a transaction, it costs money, so it costs gas to execute and it doesn't return a value. So you write it and then you can read back the value sometime later, but not immediately. In fact, it's six blocks later. So a good minute or minute and a half later, you can find out what was actually written and whether it was successfully written. So there are design constraints and there are other sort of finer detail. Ones like you can't have variable length arrays returning.
00:13:13.220 - 00:13:45.596, Speaker A: When you do a map. There are no keys in the map. So normally you've got a key value sort of store as a map. Well, if you don't have a copy of those keys somewhere, there's no way of getting those values back. So there are other things to keep in mind. So when we talked about the transactions and reading and writing, the thing to think about with the transactions is that you really want to make them simple. So you want to make them simple because you're worried about how much it's going to cost gas wise.
00:13:45.596 - 00:14:17.180, Speaker A: But also, these are the vulnerabilities that you're going to have. And for reading back, it's not costing you anything to read, so you can make them more complex. When you're writing, it's going to cost gas. It's a vulnerability. So this is the call where you can update your state of your contract. So if there's a way of updating the state of the contract such that you're able to exploit something, then this is where you're going to do it. It's not going to be in a read call, it's going to be in a transaction, in a write.
00:14:17.180 - 00:14:50.884, Speaker A: So hence this is another reason why making it simple is very important. So have your functions as small as possible, full transactions. And even if you do want to have a complicated transaction, you got to remember that within a block you've got an overall gas limit. So the maximum number of operations, essentially, that you can execute, and it's 7.7 million. So each time you store a value, it costs 20,000. And so you can imagine that's sort of placing an upper bound on the amount of computation that can be done.
00:14:50.884 - 00:15:48.420, Speaker A: So obviously, if you're on a side chain or some sort of consortium chain, you can tweak those parameters and change them. But if you're on main net, this is something that you've got to deal with. And so for the view function, so they don't cost anything to execute, but they still have Costa or have a virtual gas usage, and so you need to keep that in the back of your mind. And so nominally there's a 50 million gas limit. And so the idea is that when you're executing some code you can execute sort of arbitrarily complicated, but once you get to using 50 million, then that's deemed too much. Now say if you were using infura or some other solidity, well, Ethereum gateway service, you could imagine that they might put a title limit than 50 million. They might say 3 million is the limit.
00:15:48.420 - 00:16:23.252, Speaker A: And the reason for that is otherwise you could do a denial of service attack. You could for I equals zero to 100 million, and you could knock out an infura node. And so if you do that a thousand times, you've knocked out infuria. So they're obviously going to be trying to rate limit you and trying to stop you from using an infinite amount of gas. But if you're running your own ethereum node, obviously you can tweak that parameter and I guess actually hitting that second bullet point there. So flaws in your code. So say you do have a bug in your code.
00:16:23.252 - 00:17:01.570, Speaker A: When you're reading, it's not going to update the state of the contract, so it doesn't matter. So in other words, if your code was simpler to write, but that means that the trade off was that it's more complicated to read, then that's okay because the reading doesn't cost anything. And as well, if you do have a bug in your code when you're reading, then it's not as much of an issue. So let's deal with the, or talk about the greater example. So have a look at this example code. I'm going to have a sip of my drink whilst you're ruminating on this code. Stand back here so I'm not standing in the way.
00:17:01.570 - 00:17:42.808, Speaker A: Okay, you've had a few secs. Who wants to give me the first problem with this? There's no setup for the treatment apart from the constructor. You can't update it. That's true, you can't update it. Second problem with the greeting, imagine this is behind a web service. Yeah, no parameter validation. So if it's behind a web service and you're allowing anyone on the Internet to set the greeting, and then you're going to pay for the gas, then I might make a million character long greeting.
00:17:42.808 - 00:18:29.944, Speaker A: And then you will go million long actually would probably hit the 7.7 million gas limit. But you could still force someone to be spending an awful lot of money because that string is variable length. So when you do greeting equals greeting, you're storing into the blockchain a variable amount of data. And so that's going to cost you a variable amount of gas, which will cost you a variable amount of money and variable amounts of money that you might be spending. Sounds to me to be really dangerous. Another thing to think about here is that say we've got this value here, so this is some persistent data, and say we decide that we want to upgrade the business logic.
00:18:29.944 - 00:19:26.110, Speaker A: And I know there's not much business logic here, but imagine there was business logic when we tried to upgrade that. We've locked our data in directly into that contract, and so somehow rather we've got to suck that data out and write it into the new upgraded version somehow. Another thing is that at the moment this is just plain greeting contract and there's no interface. So when we're writing our application, we're going to write it directly to the concrete class and not to an interface to this class. And so what that means is that we need to know the gory details and lock in. So if we change the way we want to store greetings, change the data structure, then we doomed because we've publicly made this available and I'm sure I've got a few more stream. Not being variable length is a problem.
00:19:26.110 - 00:20:13.240, Speaker A: The greeting, it used an automatic getter. So because it was just greeting public, what that means is you have an automatic getter function that you can call as a view. And what that means is that if you did have an interface, there's no way of getting to that automatic getter except if you put it in and then if you change to variable or your data type, you're in trouble. So you're tying your interface into your implementation. So that's not good. And I've talked about persistent data and of course, as you said, the greeting is set up in the constructor so you can't change it. But maybe if you could set the greeting, wouldn't it be good? And if you could set it though, maybe you'd have more than one person participating.
00:20:13.240 - 00:21:05.268, Speaker A: So maybe we have a range of us participate in the greeting contract. But if we were going to participate, then I think we'd want to vote, wouldn't we? We'd all want to vote on who's going to what the new greeting is going to be, because we want to be democratic and everything. But if we're going to vote, then we need to be able to have a pluggable voting algorithm because we might change the algorithm that we want to use. We might have different voting parameters that we want to use and we need to be able to vote on changing them too. So what you might end up with is something a little bit like this. So if I've got my uml wrong, I'm not a real big uml fanboy. So what have we got here? We've got voting greeting.
00:21:05.268 - 00:21:40.068, Speaker A: And so voting greeting is your implementation. And so it's where you've got your core business logic. You've got a data holder which stores the actual long term persistent data. So you've got long term persistent data and ephemeral persistent data. So when you're doing a vote, it's a short term thing, but the greeting itself is longer term, isn't it? We've got an interface. And so the idea of the interface is that it's the thing that you're going to write your application to. You're not going to write your application to the voting greeting, you're going to write it to the interface.
00:21:40.068 - 00:22:25.850, Speaker A: So then if we change the internals of voting greeting, then you're still going to be good. The other thing it does is it means that you're sure that in fact, your interface you're writing to is what you're thinking you're exporting, because sometimes you might by mistake tie your application to some internal thing in here and not notice. Then when you go to upgrade, you sort of find out they're in trouble. The voting algorithm interface is that is an interface for this pluggable algorithm. And so we've got two algorithms here, voting old majority. So that's essentially saying the majority of people who are participants have to say yes and voting old majority who voted. So in other words, the majority of people who voted said yes.
00:22:25.850 - 00:23:14.260, Speaker A: And I've got one final class here, voting analysis. So I've said that you can have really complicated views and simpler transaction functions, so hence the view functions are more likely to be broken, you're more likely to have bugs in them, so why not separate them out into completely separate contracts? And in that way, you're having as simpler code as possible in your actual contract, which is going to update the state of the ledger. Now let's see what I've forgotten. Okay. All right, so let's look at this. So the voting analysis contains no data at all. It just contains functions that then call into the voting greeting to do analysis.
00:23:14.260 - 00:24:06.280, Speaker A: So is there a vote going on at the moment? Who's voting on what? Voting greeting contains ephemeral, persistent data. So in other words, data that you're writing to the ledger, but it's just ephemeral. What are we voting on? Who's voted? Voting and greeting data holders. That's the long term consistent data like the greeting itself. And then down here, these voting algorithms are just pure, so they don't reference the state of the ledger at all. Let's think about upgrade, which is obviously an important pattern to think about. So how we've done that is we've got long term persistent data is in that contract, and any updates to the data holder are linked to voting greeting.
00:24:06.280 - 00:24:36.390, Speaker A: And we only use the interface. And as well we've got a get version, so your application knows what version it's using and you could use ens to switch. Now I'm going to be brave and I'm going to hit alt tab and we're going to end up in Intellij and it's all just going to work fine. And Sally's there, who was could be. Yes. Whoa. Oh, fantastic.
00:24:36.390 - 00:25:12.690, Speaker A: Golly. For those of you who don't know, Intellij has a presentation mode. I'm not sure everybody in the audience understands DNS Ethereum name service. So it's a way of going from, I think it's a six character name, six characters ens, and it'll give you an address. And so it's a way of, in your application just having a name that you use. So it's a way of doing a. You remember how I said there's the GitHub repo? So this is the code that's in the GitHub repo.
00:25:12.690 - 00:25:47.746, Speaker A: And I think the only difference is I fixed a spelling mistake I noticed, which I haven't pushed yet. So what I'm doing is we've got, our contracts are in solidity and we've got a whole lot of tests that are written in using truffle. And so truffle is a testing framework at the moment. It all just runs local. So truffle develop and runs on your local development internal fate network. So let's look at the interface. And so voting interface, aren't you.
00:25:47.746 - 00:26:07.374, Speaker A: That's the voting algorithm. Interface. All right. Voting algorithm interface. So this is, remember how we had a pluggable voting algorithm? So the only thing it's got is a set and it's got the number of participants, the number of people who voted for, number who voted against. And it's a pure function because it doesn't use anything and it's going to return. Brilliant.
00:26:07.374 - 00:26:49.014, Speaker A: True or false, did the voting win? And then in our voting elk majority, so was the number of people voted times two greater than participants, which sort of means. So if you had, say, six people voted and you've got ten participants, you're going to end up with twelve. So you're all good. So that's nice that it's simple. And number voted is greater than number against. Okay, so now we've done the voting, let's have a look at the interface. So the interface has got its lazinian functions in it.
00:26:49.014 - 00:27:46.594, Speaker A: And so essentially what you do is you can propose a vote and the address is the participant. So you're going to add participants or remove participants. So the participant, you're going to add the action. So are we adding or removing and additional data, which for participant voting is numb. But if the participant is zero, then the action could be to say, change their voting period or to change the voting algorithm or even to upgrade the contract so you could vote to upgrade. And so once you've voted, then whoever's proposed the vote automatically is the one who votes yes. And then you've got other people who can vote, then you can action vote and then you've got a whole heap of views that return state and you've got get version.
00:27:46.594 - 00:28:32.562, Speaker A: And so the idea is get version, it's going to give you the version of the contract that you're actually using. So if we get in here to the implementation. So version one returns version one and I've actually created version two as well. And that's just to demonstrate upgrade. And so essentially the get version function will return version two, but everything else will work the same. So in the greeting thing, we've got the types of votes we could do and then we've got the initial owner. And so you set up the initial owner in the constructor and then you link it through to the data holder.
00:28:32.562 - 00:29:24.166, Speaker A: And the reason why you need to do this is in the data holder we've got our long term persistent data. And when you set the voting implementation from that method we just looked at, you're essentially saying, all right, voting greeting equal equals this. So in other words, the implementation which is the current deployed version is this. And then you have a modifier. So what a modifier does is when you use the modifier, it essentially slips in that code at the start of the function. And so what that function is saying is that what the modifier is saying is if the message sender isn't the current voting implementation, then blow up, throw an exception essentially. And that dash means just keep on going, whatever code we've got.
00:29:24.166 - 00:29:57.326, Speaker A: So for instance, a set greeting can only be done by the voting greeter implementation that's currently set. So when we upgrade, we're going to change that implementation from the version deployed version one to the deployed version two. And similarly for all these other things could possibly do like adding and removing participants, changing the voting algorithm. Let's go back to voting greetings. So that was one thing. So we've had the interface that we've got. We've got the fact that we're linking things in and we need a way of upgrade.
00:29:57.326 - 00:30:40.874, Speaker A: And so what we do is someone proposes the vote. And so the vote that they're going to propose is set new implementation. So in other words, hey, I want to upgrade the code. And so someone's going to propose a vote, and the voting action is going to be to upgrade the contract. And then that will then get put into the map, and then a vote will happen so people can vote on it. And then after the voting period is finished, you can then action it. And then in voting set new implementation, we call that data holder set voting greeting implementation.
00:30:40.874 - 00:31:06.600, Speaker A: So that'll affect an upgrade of the contract. Okay, so that was upgrade. And we've talked about all of those things. So that's how you can do upgrade. Other questions about upgrade and how I've done upgrade for that contract, and if you like, I can look at the truffle test, which might illuminate it a little bit more as well. No. Okay.
00:31:06.600 - 00:31:56.914, Speaker A: The next thing was flexible algorithms. One of the things that we've got is that voting algorithm. You can specify a new algorithm or you could extend it. And so if we again, exit. So how that works is we're back in voting, greeting, the actual implementation, and in action votes. We go along and we get the voting type, and then we say, are we at the end of the voting period? Is that all good? And then we go voting elk assess. And where we get the voting algorithm from is by changing the voting algorithm.
00:31:56.914 - 00:32:43.050, Speaker A: And so somewhere in here. So one of the things that you could have voted for, you remember how there was that additional information. One of the pieces of additional information can be the address of the new voting algorithm. And so that's a way of you specifying the voting algorithm to have that the data type that you need to have is here somewhere. Somewhere in, I know where it is. The voting algorithm, obviously is a persistent item, and so hence we've got the voting algorithm here. There we go.
00:32:43.050 - 00:33:31.630, Speaker A: Voting algorithm contract. So you might remember how I said for the greeting, I said, well, you don't want to just have these automatic getters. That's public. So I've got automatic getters in the data holder contract. And the reason why I've allowed that to happen is that you're never going to have an interface between your data holder contract and your implementation. You're only ever hopefully going to have one instance of that data holder contract, aren't you? Because you're never going to upgrade that data holder because it's nice and simple. Okay, I hear so maps don't store their keys.
00:33:31.630 - 00:34:32.280, Speaker A: So because they don't, you need to be able to have arrays that have the keys in them and then be able to work through the arrays, which I think there's code in there to do that. And we've talked about the modifiers, sorry, back on that with where you've got an address and you've got your contract. So is it like a two factor thing where in your interface you're saying, I know that the method is always going to be this name, but it could be at any given address. And I go to look at this variable, see what this address is, but I'm always looking for this name of that method at that address. Does that help? So this is for the interface, this is for the voting algorithm. Yeah, for that voting, yeah. So interfaces in solidity, really it's just giving you the list of functions you can call in that type.
00:34:32.280 - 00:35:15.106, Speaker A: And yes, you've supplying the address of something that implements that interface. Say you were to change that address. Right. You'd still have to have a contract at that address with that same name of that, that still has that access function in it. So as long as it has an access function that's got the same function, function name, function name and parameters and such like that, then it should be all good. So yeah, you could have something that implements that interface and it would still be good. So it doesn't have to be some little tiny contract like I've written.
00:35:15.106 - 00:36:08.230, Speaker A: You could have some massive thing which has all sorts of stuff in it if you wanted to, because any contract can implement multiple interfaces. Yeah. So one of the things that we're trying to have constant gas. So when someone's calling your function, the more data you've got in it, the more gas you use. So how you get around that is not having fixed length data types but also not looping. And there is one place in the code where I loop and there is a way around it. In fact at some point if someone's interested enough, they can fix the code up or do a pull request for the code.
00:36:08.230 - 00:37:01.382, Speaker A: So in the voting analysis, when we do a vote in the voting code, so when you propose a vote, propose a vote right at the end what you do is you go activevotes push. So what that is doing is it's pushing a value onto the end of the array. And then when the votes actioned, then we zero that value, we delete it. And so that means that memory location is free, but it means that we've got this array that's getting longer and longer and longer and longer. And so if we've got a function which says, tell me what votes are active, then you're going to have to do a fair bit of looping. Potentially, after a million votes, you could be looping around a million times. And so how I've got, there are two ways of getting around this.
00:37:01.382 - 00:37:24.080, Speaker A: One would be to start at zero. Actually, three ways of getting around this. One is to start at zero. One is to have an offset. So have the application know what offset we're up to. So in other words, know that all the votes from zero to here are done. And these are the active votes starting at, say, 1 million to 1,000,020.
00:37:24.080 - 00:38:08.400, Speaker A: And so you could just loop around knowing that it's only going to be a small number of loops. The other way you could do it is you could compact that array. But compacting the array and physically moving values from one part of memory and writing them into another is going to be really expensive because it's going to be, what, 20,000 gas for each write. You got to sort of weigh up how you want to do it. And so being able to, by passing in a parameter which says where to start looking. And at the moment in this class, you might notice there's a to do. And at the moment, there's no analysis methods on what's actually being voted on at the moment.
00:38:08.400 - 00:39:10.798, Speaker A: Okay, so before I dive into the assembler, it is worthwhile having a quick look at the truffle code. So I've got some common code which is included in pretty much all of the different tests. And so it does things like has a fake thing to minor block because obviously we're voting over a set of blocks. The other thing that I've got is this here. So you know how we've got the implementation and then you have the interface. And so I've poorly named these variables. I think at one point I had voting greeting input and voting greeting, and then I changed voting greeting and voting greeting interface.
00:39:10.798 - 00:40:04.290, Speaker A: So these variables haven't caught up with that. So there's another pull request for you. But anyway, the idea is, though, that we get the voting greeting interface implementation, and then we say, all right, what we really want to do is just view that implementation using the interface. And so when we're doing something in testing, we invariably get the interface and not the actual implementation, because we want to write tests to the interface and not the implementation. So then by mistake, we don't start using something that's actually in the implementation but not the interface. Okay. All right, assembler.
00:40:04.290 - 00:41:22.178, Speaker A: So why would you use assembler in Ethereum? If you're not having enough fun with trying to get your solidity code to work, why not go one order of magnitude harder? So there seem to be two reasons to do it. It lets you do things that solidity doesn't let you do. And there are things like you can access the code, not the data, but the code of another contract, or you could access the code of your own contract. And I think, I'm not sure why you would do that from within solidity, but you can do it, and you can do other things, like say you can't call a function that returns a variable length array. So if you know ahead of time how long the variable length array is, you could do that call. So you could do some funny things you can't do, but also lets you optimize your code. One thing that you definitely can't do that's useful, and is incredibly useful, is if you want to call a pre compile, like the scalar multiplication pre compile, then you can't do that from normal solidity code, but you can from assembler.
00:41:22.178 - 00:42:29.324, Speaker A: And so that's an example of something that you can do, and you can do things faster. And so I've stolen this from stack exchange. So this is not my code, but it works. So on the Ethereum engineering group meetup on the GitHub site, there's a assembler directory and it's got this code in there and actually does the gas analysis of how much gas they use. And so this one does use less gas, quite a lot of a few thousand less gas. So that's good. And so what it's doing is, what's that? Okay, so what that doing there is that it's got an address that comes in and you want that information as a bytes byte row, and there's no simple way of doing that.
00:42:29.324 - 00:44:05.048, Speaker A: So if you did it in solidity down here, or if you're doing it in highly optimized assembler or doing it up there, and Ben Edginton, someone who actually works in protocol engineering over in Reggie, just before he started at consensus, wrote an analysis of what this is actually doing. Which I'm grateful for because I wouldn't have had a clue. And I think that this, like I've done a fair bit in Ethereum over the time, and the fact that I look at that and go, I could spend a good day working that out shows you that when you're thinking I'm going to write some highly optimized assembler, you really need to take a step back and think how hard is it going to be for people to analyze my code and me to analyze bugs in my code? What benefit am I getting? And I guess if it's a highly used function and you're going to save a million dollars, then go for it, have a lots of tests, so write it in solidity, then write it in assembler, have a million tests to make sure that it all works perfectly. So maybe that makes sense, but otherwise I think you've really got to have a long, hard think about it all. Yeah, I didn't really find any other strong usages of assembler and in fact there are very few examples, so it's actually quite hard. So in summary, keep your long term persistent data separate from your business logic and your transactions. They should be really small if at all possible.
00:44:05.048 - 00:44:47.380, Speaker A: And it's better to have your complex functions in things that are doing views and right against interfaces and not against the actual implementation. So that then you're sure that everything that you need to be in the interface is. So when you go to upgrade and say, change how you're storing your data or anything like that, you're not in great trouble. An assembler only uses that make sense. So it could make sense if you're doing lots and lots of transactions and you're going to save lots of money, or if you're trying to do something that you can't do in solidity. But in the general case, I think you would be nuts to use a 71. I mean, it'd be a bit like using assembler on a desktop computer or a laptop.
00:44:47.380 - 00:45:58.536, Speaker A: You could do it, but there are trade offs. Okay, I have talked for a while and well, there are some links to some things that will help you and there are the list of talks out to the end of October. Are there any questions? You mentioned the reads were free, but is that also true? If a contract you're calling like function on them reads, does that cost the gaps that cost? But that's sort of a transaction. But then the person who's doing that call would really want to know what code because it's a security issue as well. I guess that's another area that we haven't really talked about is security. But if you're calling, say, some general library function and you've no idea what sits behind it, then that's probably pretty bad because they can do all sorts of bad stuff. So when in solidity or in Ethereum, if you're calling to something, you've got to know what is on the other side there.
00:45:58.536 - 00:46:36.676, Speaker A: But you're right, Dave. Where can people find the URL? So it's on the slack workspace. It will be when the YouTube video here goes live. So it's obviously live streaming. But once I click stop on that plus about 2 hours, then I'll be able to go into the editor suite and I'll be able to add the link to that in YouTube. And I can probably put it on the meetup as well. But yeah, it'd be really great if people looked at it and we collaborated on it.
00:46:36.676 - 00:47:31.316, Speaker A: Because another area that I've noticed when thinking about it that actually I find to be a bit of a bug, is so at the moment when you propose a vote, it's about 200,000 gas or so, or 215 or 20 or something like that. And so 200,000 gas of that is ten rights. And some of the reasons for some of those rights are all around being able to track who's done what in the voting arena. A better way of doing it would have been for those sections to emit an event, and then applications could have watched for those events and it would have been much cheaper because that data doesn't need to be there. So I'm sure people could look at that and then you'd want to write some test code around watching for those events as they're emitted. So you know who's voted on what. So anyway, I think there are all sorts.
00:47:31.316 - 00:48:09.040, Speaker A: I mean, that code was banged together in less than a week and I've been busy doing other stuff. So I'm sure there are lots of areas of improvement. Are there any other questions? Okay, cool. Well, thank you everyone, and we hope to see you at the Ethereum virtual machine meetup. And Rob Dawson, who is at the back there waving, is probably, possibly, maybe, probably going to be the person to deliver it, but it could be someone else too. Anyway, all right, thank you everyone. Bye bye.
00:48:09.040 - 00:49:42.050, Speaker A: Just get this sorted out. It's still streaming live. I should have pressed it, done it on here and not there. It's still streaming. I've just got a. It'll just, it'll do it in effect. I just got it? Yeah.
00:49:42.050 - 00:49:44.220, Speaker A: Come on. Find the. Find the camera.
