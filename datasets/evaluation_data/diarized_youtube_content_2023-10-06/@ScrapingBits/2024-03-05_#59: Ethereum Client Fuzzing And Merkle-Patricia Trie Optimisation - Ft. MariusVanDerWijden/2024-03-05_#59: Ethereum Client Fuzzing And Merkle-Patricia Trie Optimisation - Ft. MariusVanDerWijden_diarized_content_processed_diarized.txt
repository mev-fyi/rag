00:00:00.330 - 00:00:23.550, Speaker A: We had this issue where gas nodes were getting DDos by transactions. There was a research group came out with a paper about different attacks on the geth transaction pool. We fixed some of them and some of them we didn't. Someone saw this paper and started attacking geth nodes. Because Nethermind has implemented the transaction pool in a different way. They couldn't be attacked. Everything still worked fine.
00:00:23.550 - 00:00:26.226, Speaker A: We would still create blocks and Nethermind.
00:00:26.258 - 00:01:06.574, Speaker B: Will create scraping bits. Is brought to you by the following sponsors MeV protocol maximize your etH staking value with me V exclusively on MeV IO and composable execute any intent on any chain. Coming soon to Mantis app. That's man Tisap and fastline labs, the only mev and intent centric team that has a daily deodorant application rate of over 68% gm. Gm. Everyone, my name is Sigachi, the host of scraping bits, and today I have Marius from GEF development team. How's it going?
00:01:06.692 - 00:01:08.898, Speaker A: Going good. Going good. Thank you for having me on.
00:01:08.984 - 00:01:13.858, Speaker B: Thank you for coming on. Just for the people that aren't familiar with who you are, who are you and what do you do?
00:01:13.944 - 00:01:47.982, Speaker A: Yeah, my name is Marius. Been working at the Ethereum foundation for three years, a bit over three years now. I started in the beginning of 2020, and I'm working on the guest team, or go Ethereum team, doing kind of everything that needs to be done. So there are some people in the team that have specific roles or they have a specific part of the code they're working on, but I'm looking at everything that I can find. So I did a bunch of fuzzing in the past, worked a lot on the merch stuff. Yeah.
00:01:48.036 - 00:01:53.754, Speaker B: So that's kind of me interesting. So you kind of just do everything really, and not a specific part?
00:01:53.892 - 00:02:07.026, Speaker A: Yeah, I'm very interested in performance and making get better and faster. I kind of look into every package and see if there's something that can be done there and do od jobs around the code.
00:02:07.128 - 00:02:15.330, Speaker B: How did you actually get into this stuff? How did you get into crypto? What were you doing before it? How did it lead you into joining the Ethereum foundation?
00:02:15.410 - 00:02:44.880, Speaker A: It's a great question. I had a course in university that was about programming gpus with CUDA, and I was like, okay, this is like very interesting. So that was back in 2015. I was like, this is very interesting. I want to see how this language is used. So I went to GitHub and looked for projects using CuDA, and the first one that I found was the east miner. And so I looked through the code and there was something that I didn't understand.
00:02:44.880 - 00:03:30.302, Speaker A: So I looked it up in the documentation and the documentation was like, yeah, you shouldn't use this anymore, you should use this other thing. And I was like, oh, that's interesting. I sent a pr to Eastminer fixing this issue, and then they sent me, it was this open source thing. It was maintained by a guy from the Ethereum Foundation. I asked if there were any tasks or any things that need to be done, and he sent me a bunch of things that I could work on. And I didn't have a gpu back then. Basically the development process was me just changing some code, trying to compile it, sending it to when it compiled it, I uploaded it, I sent it to someone and I think it was an american guy.
00:03:30.302 - 00:04:23.618, Speaker A: And 4 hours later he would reply, yeah, so this, and this broke, and this is the error message. And so this went on for a week, and then I was just getting fed up with it. So I went into the store and bought the cheapest gpu I could buy just to test it and finish the pr. But the gpu was so bad, it was a 1050 that had like an extremely loud fan. So I finished the pr, I'm with it for two days and I just went to the store and gave it back. And then later on I bought a real GPU and became part of this team because I was getting interested in these kind of things. I joined a course in university on blockchain, and the professor sent a message.
00:04:23.618 - 00:05:03.994, Speaker A: He was looking for someone to join a startup or join his group, and then I joined his group and then we tried to create our own startup for two years, doing payment and state channels. So that was from 2018 to 2020. I learned a lot during that time. The professor was very nice. He would enable us to do a bunch of really cool things. So like, we talked a lot with other l two teams at that time, magmo and the guys from, I think they were called l four. What later became kind of became optimism.
00:05:03.994 - 00:05:33.414, Speaker A: It was a really interesting time. I went to Defcon Prague. That was like a real moment for me. I was meeting all of these interesting people that I only ever saw online and getting to know them and getting to share some of the ideas. That was around the time we had the big proc power discussion. And because I was working on the minor, I was very much involved in that. And that was an interesting time.
00:05:33.414 - 00:06:43.450, Speaker A: And after two years, I kind of decided I wanted to finish my master's and I put in my four weeks of notice into the startup, or, well, company wasn't founded, but we were employed by the university to work on this. And so I put in my four weeks of notice and we used geth internally or go Ethereum internally as a library for this payment and state channel stuff. And so when I left, I had four weeks and up some of the stuff that I wanted to change in Gath and Aprs. And then I got an email from Felix from the Gaff team, who was like, yeah, do you want to join? And email went straight to my spam folder. Fortunately, I looked through the spam folder every now and then and I found it and I was kind of convinced that it wasn't real, but I decided to reply anyway. And so yeah, that was how I joined the foundation. And then I did finish my master's while working at the foundation, and I wrote my thesis almost exactly a year later on EVM fuzzing.
00:06:43.450 - 00:07:08.402, Speaker A: So I created tools to test the different EVM implementations of the different clients against each other and see if they produce any differences. And yeah, I did find some. So I found two consensus issues, one like a class of consensus issues in Nethermind and one in biso. And yeah, it was a great time back then.
00:07:08.536 - 00:07:16.534, Speaker B: So when you made these fuzzing tools, did you make it from scratch or did you hitchhike off something else like Afl? How did you dwayne loss so the.
00:07:16.572 - 00:08:05.190, Speaker A: Idea for the fuzzing already came from martin. He created salmon tools to test different EVM clients against each other. So the idea is you create a state test, which is basically a pre state in a transaction and a post state, and all of the clients implement a EVM tool. They call it differently in different clients, but basically you can give them the state test and they will trace every opcode, and then you verify that the opcode traces are the same. So this infrastructure to execute the test and verify that the opcodes are the same, that one was already written by Martin. And I use gophas because I started out with gophers. And I quickly realized, okay, this is not producing anything.
00:08:05.190 - 00:08:47.982, Speaker A: This is just like, you can never have a valid call to pre compile with gophers, or you can never have a valid call even with gophers. Like you need to set up the stack, you need to set up the memory. So I created these generators that take the input from gofast and do something creative with it. And so you have different strategies. For example, you take some randomness and you push it onto the stack or you take some randomness and you call a random address with it. This strategy was extremely good at finding very weird issues. So for example, one issue it found was if you call the mod x precompiler.
00:08:47.982 - 00:09:44.470, Speaker A: So we have this pre compiler that does modular exponentiation, basically x to the power of y modulo p. And in order to call it, you have to send it the x, y and p, and the length of x, the length of y and the length of p. And there was an issue that if you set the length to zero, but you don't send zero, but you send some arbitrary data, then some clients would try to execute it without checking that the parameter is actually zero. So if you do x to the power of y, mod zero is always zero. Like if you take a modulus of any number modulus zero, it is zero. So some clients would actually execute this extremely complex operation. It would cost like a huge amount of gas, but in the end it wouldn't produce anything.
00:09:44.470 - 00:09:57.062, Speaker A: And so that was one of the issues that I found back then, that was only found because I could create more complex programs with this puzzle.
00:09:57.126 - 00:10:02.522, Speaker B: And when you do the fuzzing, do you have to create a new one for each module component in the client?
00:10:02.666 - 00:10:54.158, Speaker A: Yes. So I haven't worked on it in a while, but back then I had, I think, around 15 or 20 strategies that do different things. The basic strategy is just take a randomness, turn it into an opcode, and execute that opcode. And that can find some stuff, but it's not very useful for these more complex interactions. So I added more and more right now, actually, this week I was working on it again to create some docker files to automatically deploy it on our infrastructure. And when that is done, because the deployment process of it was always the hardest thing, because you have to compile these tools, like these EBM tools, for five clients. And everyone is a different language, everyone has a different pipeline, everyone uses different libraries and stuff.
00:10:54.158 - 00:12:03.970, Speaker A: So my local build server just went out of date really quickly. And so now I'm adapting a docker file that Martin knows when they build to create these seven clients. Right now it's seven clients actually. So we pushed really hard for clients to implement this so that we can just easily add them to our fuzzing infrastructure and have them have the same coverage as geth does. That is one of the big improvements that we made over the last couple of years, is that in the beginning it was Gaeth, and there were the other client teams, like smaller client teams, and they didn't have the funding and the manpower to test their clients properly or to create these tools. So what we've always strived for is to create tools and to create test cases that can be used by all of the different clients so they can actually focus on implementing new eips and whatever, and making that client run fast, and we kind of help them a bit with the security of it.
00:12:04.040 - 00:12:11.686, Speaker B: Interesting. How do you do fuzzing for the consensus stuff as well? You mentioned you found some bugs in the consensus side process of finding that stuff.
00:12:11.788 - 00:12:49.250, Speaker A: There was consensus issues, wasn't on the consensus side. There are a lot of initiatives to do fuzzing on the consensus side. It's actually because they have executable spec consensus back. It is very easy for them to create fuzzers for specific fixed functions. So, for example, in the consensus spec, there is this function that is like, I think it's called validate block or validate body or something is very well defined. And so there are a bunch of fuzzers built for the consensus layer. So for example, beakly fuzz was one.
00:12:49.250 - 00:13:05.170, Speaker A: It was based on lighthouse, if I remember correctly. Another thing that the consensus layer has, or that we have on both layers, is malicious block producers has mallory on the consensus layer, and I think I called it bad block generator.
00:13:05.330 - 00:13:06.038, Speaker B: Okay.
00:13:06.204 - 00:14:08.982, Speaker A: I'm not very creative with the names. There's something on the execution layer that also creates bad blocks. And these bad block generators, they are extremely helpful because they test just the rules around verification that a block is correct or incorrect. And we have seen this on the merge test nets. There was one issue that was found by one of the bad block generators, where basically it replaced in a block, it replaced the hash with a parent hash, and nodes would take the block, and some nodes would verify that the hash is correct. I think it was another mind that would look up the hash in cache and see, did I verify this block correctly before? And because the hash was set to the parent hash, to a hash that was verified before, it would just accept the block. And even though the block itself wasn't a valid block, because it wasn't hashing correctly.
00:14:08.982 - 00:14:16.138, Speaker A: So these are things that are very hard to test where fuzzers can help us quite a bit in these bad block generators.
00:14:16.234 - 00:14:52.506, Speaker B: Yeah, that seems quite interesting. If there's no vulnerability on a single client, but then you switch over to another client, there is one, then that's quite interesting, because everyone might implement it differently. So there might be a vulnerability in one of them. Is there any cross client interactions that can cause a vulnerability? Well, just like a smart contract, you can interact with contract a and then contract b in the same transaction. Is there something similar like that where you can do with clients? I know you can spam false transactions to people. I think people did that for mev purposes to ruin their mempools. Is there anything similar to that?
00:14:52.608 - 00:15:42.458, Speaker A: There are things where clients have to implement the same thing, and this is basically the EVM where all the clients have to do exactly the same thing. And then there are degrees of freedom that we have. So for example, in the engine API, there are some degrees of freedom that we have. One example that I stumbled over actually two or three days ago, Peter, from the execution specs, we are on this interrupt, and we had a really long walk, and we've been running rath and Aragon. And what we figured out is that when we get a block, when gath gets a block. So in the engine API, you have two different calls, you have new payload and Folkchoice updated and new payload basically gives you a block and says, this is the block. Please verify it for me.
00:15:42.458 - 00:16:18.166, Speaker A: Like you can execute it, you don't have to mark it as canonical. And then Folkchoice updated marks it as canonical and says, this is the head of the chain. So what we do is we execute the block when we get it, and when we get the fork choice updated, we only mark it as canonical. What rest does is when they get the block, they only verify very few things about the block. And then when someone calls for choice updated, then they actually execute the block and market as converted. And so there's like timing differences there. Fortunately, it cannot be exploited, but there are different behaviors there.
00:16:18.166 - 00:16:57.234, Speaker A: And it's the same thing with a transaction pool. We had this issue where gas nodes were getting dedosed by transactions. I think it's almost a year ago there was a research group who came out with a paper about different attacks on the Geth transaction pool. And we fixed some of them, and some of them we didn't. And at some point someone saw this paper, the paper was published, and they made a pr and someone saw this and started attacking Geth nodes. And because Nethermind had implemented the transaction pool in a different way, they couldn't be attacked. And so everything still worked fine.
00:16:57.234 - 00:17:08.100, Speaker A: Even though some guest nodes would not have the transaction or wouldn't have many transactions in their transaction pool, we would still create blocks and Nethermind would create.
00:17:09.770 - 00:17:16.774, Speaker B: What were these attacks? And the only reason they didn't get exploited is because the mind implementation was different, right?
00:17:16.892 - 00:17:51.070, Speaker A: Well, they did exploit it, but it was only for like a couple of hours. We saw this and we knew exactly what was going on. And we did have a kind of stale branch that had the fix for it. We just never really bothered merging it. And so we just verified that it was correct and that it stopped these attacks. And then we merged it and then asked everyone to update to the newest version who was affected by it. It wasn't a big deal, fortunately.
00:17:51.070 - 00:18:06.790, Speaker A: So if there's an issue in these surrounding areas where we have certain degrees of freedom, fixing it is usually extremely quickly an issue. In the EVM, consensus finding is a very different beast.
00:18:07.450 - 00:18:12.760, Speaker B: So what are like the main areas that people modify that you notice usually.
00:18:13.210 - 00:19:20.858, Speaker A: There last two or three years ago, other l ones would fork and modify the consensus. So they would leave everything as is, and they would just go in, find, replace the theorem with their blockchain name, which would create a very interesting issue, because we have a protocol, the networking protocol of Ethereum is called ETH. So we have e 65 66, the different wire protocol versions. And they would rename this to whatever. I think there was polygon did it, it was boar 66. And we had one check that said if we have this other protocol enabled, snap, and we have a protocol that is enabled that is not EtH, then we would spit out a warning. So there was a time where gas nodes would warn all the time, because people would try to connect to them from a node that was not on an ethereum node, but a polygon node or other nodes.
00:19:20.858 - 00:20:01.100, Speaker A: Nowadays there's been a big push of L two s roles to use to be based on gas. And so people there, usually they're also modifying the consensus a bit, but they often add system transactions. They're adding pre compiles, because a pre compile is like the easiest way of getting your code into the EVM, and you're still EVM compatible. You implement the same opcodes. The smart contracts that work on Mainnet will also work on your roll up. You're not really modifying. And then there are the meb people.
00:20:01.100 - 00:20:52.878, Speaker A: We don't really see a lot of changes from them being upstream. Sometimes they see some stuff, but they don't want to lose their competitive advantage, which is pretty sad in my opinion, because they're extracting a lot of value from the ecosystem, from us, and they're not contributing back. And that is kind of sad. So if you're an MVV person, you're getting out of the game upstream, your changes, we might even have a job for you. And I think those people, we have like a bunch of hard rails in place. Just sanity checks, things that we compute that don't really need to be computed, but it's always good to check it twice. And they remove those to be the fastest one, to be the quickest one.
00:20:53.044 - 00:21:01.754, Speaker B: Right. And probably integrate their own searches into the nodes as well, so you don't have to do all these API calls and whatnot.
00:21:01.882 - 00:21:31.980, Speaker A: Yeah, exactly. Just having the marshalling and unmarshling via the JSON LPC is so costly that it makes no sense to use it. And then there are some people who send something or complain about something that probably, most likely MeV people, builders, but they're using the JSON RPC. And I'm like, if this is really what you're doing, then I don't think you're doing the right thing.
00:21:32.590 - 00:21:54.974, Speaker B: Yeah, I think if you want to be competitive, you got to put it all into the node itself, get as granular as you can, because every little bit counts, basically. What do you think are other kind of modifications people can do to make it a lot faster or more efficient in any way, since that's what you're kind of focusing on with performance nodes.
00:21:55.102 - 00:22:28.694, Speaker A: So one thing that we realized yesterday, we had a great discussion yesterday, and we realized that we have the bloom filter. Every header has a bloom filter for all of the logs that are in this block. And every transaction has a bloom filter for all of the logs that happened within this transaction. These bloom filters, if you add them up for all transactions, for all receipts, they add up to over 500gb. It's crazy. It's only bloom filters. It's only eight bit sets.
00:22:28.694 - 00:23:22.066, Speaker A: And for nodes have realized this a long time ago, that it doesn't make sense to store them like we store them for the header chain, but we don't store them for the transactions and for the receipts. And so all nodes have dropped this 500 gigabyte data set. But if you start a node now, you will ask for the full block. You will ask for the full receipts. That means that the peer that you're asking this from will pull up the receipts, will pull up the block, and will create the bloom filter on the fly, send it to you, you receive the full thing with the bloom filter. You yourself will verify that everything is correct. And then you will throw away the bloom filter because you store it without the bloom filter.
00:23:22.066 - 00:24:12.000, Speaker A: That means you induce a lot of work on the other side to create the bloom filter that you are going to check anyway and that you are going to throw away in the end and you have an additional 500gb of bandwidth that you need to sync a node. So every node has, in addition to the 600gb of history, you will sync another 500gb of these bloom filters, which is crazy, just throw them away. And so what we're thinking right now is to create a new protocol version where we just don't send the bloom filters because it makes no sense to send them. Like to recreate them, send them and then throw them away.
00:24:12.690 - 00:24:16.014, Speaker B: Yeah. Bit inefficient. Just a little bit.
00:24:16.132 - 00:24:58.602, Speaker A: Yeah. Every node that syncs needs to sync those 500gb. It's kind of stupid. And we would also love to remove it from the header, because if we do that, the header would almost be reduced by almost 50%, from 508 bytes to t bytes or something. Basically the size of the header will half, almost half. And so the header chain chain will almost half, at least for the coming blocks. So for the future, and that would mean if you run a live client, you would only need to get half of the data.
00:24:58.602 - 00:25:43.786, Speaker A: So yeah, those are things that are still in the protocol and no one really kind of figured that out, but those are protocol wide changes. And we also discussed a change to the way we do the try computation that might actually make it quicker. But this is something that you will save maybe two milliseconds, maybe five. And at this point it's not worth it for us, for gas to implement it. It might be worth for other people to do it because they want to save these five milliseconds. But for a normal node it wouldn't be worth it.
00:25:43.808 - 00:25:46.410, Speaker B: Definitely. If you're not going to implement it, what actually is it?
00:25:46.480 - 00:26:21.906, Speaker A: Or you want the juicy alpha. So it's not that easy to implement. You need to be a reasonably good developer to do it. If you did it, send me a message. That would be really nice to see actually how much the difference would be and if it can be done. So basically in the header you have the transaction route, right? This is the Merkel Patricia route of the transactions. What you do with the transactions is you insert them with just the index encoded as RP.
00:26:21.906 - 00:27:41.326, Speaker A: So basically the try that looks like if you have two blocks, one block with transaction ABC and another block with transaction def, the structure of the transaction twice is always the same as long as they are the same number of transactions in it. So what you can do is there's not that many different numbers of transactions in a block, right. You can have one transactions, you can have 100, and you can have like, I don't know, I don't know what the max is, like 500 or 600 transactions per block or something. So you would just pre compute the structure of the try, and then you can insert the values that you want of the transaction hashes and then hash it all together. And that would be way quicker than what we're doing right now is we start with an empty try, we insert the first transaction, then we insert the second transaction, and we build up this try. One optimization would be for someone to go and say, I have this under 27 transactions. So I pick the pre computed try structure with 127 slots, and I'll insert the transaction hashes, and then I hash it together.
00:27:41.326 - 00:28:26.730, Speaker A: The thing is, creating the transaction hash is dominated by the hashing itself, not by the construction of the trial. So that's why I'm saying it's most likely only very slight improvement over what we have right now. And it would make the code quite a bit. You need to pre compute everything up to 1000 transactions or something. You would need to fall back to the normal try for everything above that, and you would need to create the thing. How to cache basically the try structure.
00:28:26.810 - 00:28:44.302, Speaker B: I've always been thinking about whether you need everything in the block, or you could just have small select part of the essentials, basically, or could you really just take like a few things and have the essentials and then get rid of everything else to avoid all that computation? So kind of like a bare bones node.
00:28:44.446 - 00:29:33.650, Speaker A: Yeah. We recently had this issue where a builder would propose bad blocks and not realize that they propose bad blocks. One thing where you cut corners in order to improve your performance, but at the cost of security, basically at the cost of the health of the network. And I know people are trying to make money, but I think it's way more important that the network actually stays healthy. And yes, you can not validate the block that you get and just build on top of it or something, but that would mean that potentially one bad block would induce a series of bad blocks, or we would have these bad block side chains or whatever. And it's dangerous out there, so tread carefully. I'd say, sure, it's possible to remove some of the checks that we do.
00:29:33.650 - 00:29:34.830, Speaker A: At what cost?
00:29:35.000 - 00:29:42.338, Speaker B: Yeah, for speed, you're removing security, of course. What are your thoughts on ref, the rust ethereum node?
00:29:42.434 - 00:30:10.142, Speaker A: I'm not a rust developer, so I cannot really speak to their code or what I like. I really like the team. I really like Draga. I've met him a bunch of times. He's been extremely nice to work with. Also, I met a bunch of the other west developers, and they seem extremely bright. What I like about it is there's a big company behind it, so there's bit firepower, and I think they're capturing a lot of minds with it.
00:30:10.142 - 00:30:50.214, Speaker A: So there's a lot of people who are interested in rust development and like breath is one of the coolest, newest projects in rust to work on. So there's a bunch of rust developers and there's a bunch of Ethereum developers that get nerd sniped by it. And I think it's really good. I think that's really healthy. I'm hoping that they're in it for the long haul. I think sometimes people kind of announce clients or start work on clients, and when the initial work is done, they don't want to go into the maintainer mode. So they are hackers, they are builders.
00:30:50.214 - 00:31:09.294, Speaker A: In order to be successful as a client team, you have to be maintainers. You have to have this maintainer mindset. And I hope that when the initial development, like all of this exciting stuff or rest is done, that they can then switch into this maintainer mode and maintain the client.
00:31:09.342 - 00:31:15.458, Speaker B: Well, since maintaining is such a important thing, how do you become a great maintainer then?
00:31:15.544 - 00:31:38.966, Speaker A: I don't know. I'm not a great maintainer. Oh God. Now Peter is our team lead. He's a great maintainer. You have to be strict about what you let into the client. We get really interesting and we get really stupid feature requests, and you have to be very careful about what you allow into the client because you have to maintain it forever.
00:31:38.966 - 00:32:36.270, Speaker A: So for example, we have the personal namespace that was included into Ethereum nodes because of the mist browser. Back in the day, basically Fabian Fogsteler worked on the mist browser and he wanted to connect to a guest node or to an Ethereum node and let the Ethereum node sign transactions. So we have a key store because of this. Like you can have your keys unlocked in your Ethereum node, no one needs this, no one should have this, no one does this. But it's still used by someone out there and so we cannot remove it and gives us so much headache because we even have for this key store we have USB support, so we need USB support in the clients because can connect your hardware wallet to this key store. So you can sign transactions over the personal namespace. All of these things no one ever does.
00:32:36.270 - 00:33:48.018, Speaker A: But if we remove them, someone will start and complain. That's the thing about a great maintainer, is you have to be able to differentiate the useful features that are useful for a lot of people from the non useful features. And then you also need to see, are these features going to stay? Are these features worthwhile to maintain over the long haul? How are they introducing new complexity into the code? Can you maybe factor them out in a way so that they don't introduce this complexity and you don't have to maintain, like keep this complexity within your code or have it as an optional module, have someone else maintain it. And so these are the kind of the things. And yeah, it's very hard to find great maintainers, and you have to be nice to people on one hand, but you also have to be strict on the other hand to not just say, yeah, sure, let's do this, let's and let's merge this horrible looking code. We might actually be able to fix it up afterwards, and no one ever does.
00:33:48.184 - 00:34:09.162, Speaker B: Interesting. How do you see Ethereum progressing from here? We had proof of work to proof of stake merge in 2022 and following memboost and all this other stuff, and those are like really big things. So where do you hope to see Ethereum goes in the future? And how should people kind of upskill for this, or work towards building this?
00:34:09.296 - 00:34:58.938, Speaker A: I really like this idea of Ethereum being the settlement layer for other things, and having this decentralized validator set that doesn't censor, that doesn't create weird things, that follows the rules, and that people can rely on. And I think this is one of the big advantages of bits. It's clear that it's stable, it's not changing. There are a lot of issues with bitcoin because it's not changing. But one thing can be clear, that it's the same thing in like five years. And I hope we will at some point, be at this place where we can do this ossification of Ethereum. Then Ethereum needs to be perfect.
00:34:58.938 - 00:35:23.486, Speaker A: Like, it makes no sense for me to ossify something that is not perfect. And I think that is the biggest problem of bitcoin, is that they ossified something that is not perfect. I think we'll need a few more years, probably quite a few more years, until we get to this point. But I think that we're slowly moving in this direction where we're actually thinking about what will be the end state of Ethereum.
00:35:23.598 - 00:35:25.620, Speaker B: What do you think the next step is then?
00:35:29.370 - 00:36:28.886, Speaker A: So I'm a big fan of worker Guillaume from our team has been working for almost three years on it now, and it looks really good. We did have a light client that was working lds up until the merge. It unfortunately got broken with the merge and we removed it. But right now we're actually Schultz. Felix from our team are working on introducing the light client. We have a beacon lite client, so we can follow the beacon chain and then we will also create a live client that you can verify proofs from. So someone sends you a proof that I don't know, this is the balance of your account and you can see, okay, yes, this proof is correct because I can follow it to the block header and I know that the block header is correct, but then you're still relying on someone to create these proofs for you.
00:36:28.886 - 00:37:24.838, Speaker A: A full node, a server and glenates us is we can trust this, we follow the chain, someone would send us a block and they would send us a witness and we can verify the witness and see that this block was actually correct. And I think that is extremely powerful because right now we have maybe ten k, maybe 15k nodes verifying BCM blockchain. And with work server we can scale this up, hopefully ten x 100 x. So have like hundreds of thousands of nodes verify that the state transition is correct. That would be really good. And then we can also have these. Yeah, basically right now if you send a transaction with your wallet, you're trusting your RPC provider, that they don't do anything weird, show you your funds correctly, that they create a transaction for you correctly.
00:37:24.838 - 00:37:43.486, Speaker A: I would hope that in the future we will move to a space where your wallet actually verifies the blockchain and your wallet actually buys everything that you do. It's all cryptographically secured. So every wallet should be its own light client. In my opinion, in the future, definitely.
00:37:43.588 - 00:38:02.360, Speaker B: Just like how chat GBT could be pre installed into an iPhone, for example. And just to pivot just to this final question, if you were to restart your career, would you pursue anything differently? Or do you have any advice for people pursuing their careers now? And what were some of the most impactful mistakes you did that people might come across?
00:38:03.770 - 00:38:42.974, Speaker A: That's an interesting question. I would do the same thing over again. I don't really regret anything, except for maybe being too harsh to some people, some points because I was myself overworked, but from my actions I don't regret anything. They all led to the point where I am right now. When I left the startup, I did have some thoughts about like did I leave too late, did I leave too early? I learned so much working with the people back then that really set me on the way. Biggest mistakes. I do have this character flow where I'm a bit too hot headed.
00:38:42.974 - 00:39:11.294, Speaker A: So there's been times where I was aggressive in discussions and one thing that I really liked about Ethereum from the beginning was its people and its community. I took it for granted, the beginning, and it's not. And there's a lot of communities out there that are not as nice to be in as the Ethereum community. And I think it's very important for everyone to actively strive for that.
00:39:11.412 - 00:39:35.474, Speaker B: Yeah, I've recently noticed this as well. Being calm in every situation is super important. I was getting a little bit hot headed as well last year for no reason, like very simple reasons. Maybe it was, I don't know. Yeah. At the end of the day, I think it's super important because just communication alone changes the trajectory of things. It just takes one mess up and it can screw everything up.
00:39:35.474 - 00:39:36.974, Speaker B: So I can relate.
00:39:37.102 - 00:40:29.410, Speaker A: It's not bad if you mess up. You just have to apologize and people will accept your apology. And if you try to do better, it will be. One thing I noticed is I'm trying to help as many people as possible. So if people come to me and send me something and be like, oh, I want to propose this EIP, can you take a look or something? I will try to help them and unfortunately now cannot do this as much anymore as I used to because I just have so much other work to do. But a bunch of people that I've helped in the past have ended up becoming really great developers, really good people, and contributed great things and has helped me on my way after I helped them on their journey. So I think that's something that I would encourage everyone to do is help other people.
00:40:29.410 - 00:40:34.422, Speaker A: So you will see that they can create great stuff and they'll help you out.
00:40:34.556 - 00:40:59.630, Speaker B: Yeah, pay it forward. Well, man, I super appreciate you coming on, and I think I've learned a lot, and I'm sure a lot of people learn a lot and look back at this, just like how I started my Mev journey. I was listening to Mev Sempire. It's like a defining moment. So I think it's hard to find conversations like this, and I'm hopeful that people will find a lot of value in this. So, Marius, thank you so much for coming on. I really appreciate it.
00:40:59.700 - 00:41:12.174, Speaker A: Yes, thank you so much for having me. It was great talking to you and I hope that your listeners took something away from it, even if it's just like, don't be an ass. I think it's a great message.
00:41:12.292 - 00:41:17.300, Speaker B: Definitely, man. I'm sure we'll have another conversation. A few, sure. But until then, everyone take care.
