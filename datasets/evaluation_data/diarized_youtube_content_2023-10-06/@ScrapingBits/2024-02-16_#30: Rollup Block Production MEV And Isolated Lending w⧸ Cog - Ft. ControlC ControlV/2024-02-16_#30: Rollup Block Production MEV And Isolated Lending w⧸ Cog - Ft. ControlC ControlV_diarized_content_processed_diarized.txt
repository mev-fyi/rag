00:00:00.170 - 00:00:25.750, Speaker A: And if you own a bunch of ethereum validators, and you own a bunch of layer two block production tokens, you could in theory organize multiple blocks within a block. It'll lead to a lot of interesting cross rollup stuff, especially now that we're seeing more ZK rollups, because you could in theory do a lot more things atomically. In essence, you could actually arbitrage between ZK rollups within the same lock.
00:00:26.810 - 00:00:37.574, Speaker B: GM, GM everyone, my name is Dugati, your host of scraping bits, and today I am with control C plus control V. How's it going, man? It's a pleasure to have you on.
00:00:37.612 - 00:00:40.422, Speaker A: It's going good. I'm happy to be on.
00:00:40.476 - 00:00:44.378, Speaker B: Yeah, happy to bring you on. Intro yourself. Who are you and what do you do?
00:00:44.464 - 00:01:29.042, Speaker A: Yeah, so I'm a control c plus control V, commonly known as control C, if that's quicker. I am a developer, I'm in high school. I mainly write in Viper and Solidity now, doing a lot of smart contract dev work. Previously I worked at Fuel Labs as a core node developer that was in rust for Fuel's layer two client. I've also done a lot of projects pretty much everywhere. I have contributions ranging from like Rust Verkel, which is the Verkel tree implementation in Rust, to a compiler for Yule, to polygonmiden assembly. And I've actually written with two other guys a good part of Polygon, Maiden's standard library and assembly.
00:01:29.106 - 00:01:31.494, Speaker B: What is that? What is MidN on Polygon?
00:01:31.622 - 00:01:55.018, Speaker A: So Polygon has like their three ZK epms, right? They have Hermes, or Hermes if you want to be fancy. They have nightfall and they have MIDN. Miten is like based off a company they bought out, which had a really super efficient proving system. And that was like its main claim to fame. And I believe recently they've been working on some privacy oriented designs for midnight.
00:01:55.034 - 00:02:02.066, Speaker B: How did you get into all of that stuff? It's like a wide range of different fields. So how did you kind of jump from one to another?
00:02:02.168 - 00:02:18.550, Speaker A: One way of jump from things is because I'm in high school, I am still trying to learn a lot about computer science stuff. And so I found that it's like this project based learning for computer science by just doing one item at each level in the stack.
00:02:19.690 - 00:02:26.342, Speaker B: And so you basically just started from high level, which was like solidity, right? And then you just went down even further.
00:02:26.486 - 00:02:43.342, Speaker A: Yeah, so I started like high level of solidity. Then I went to core node stuff and then I went to compiler stuff, which sounds weird, but it actually makes more sense if you understand the VM on an architectural level before you start writing assembly for it.
00:02:43.396 - 00:03:03.398, Speaker B: Yeah, definitely. I took like a different route. I went basically solidity single piler, and now I'm just stuck in the compiler hole. I don't see myself coming out, but yeah. How did you go from basically solidity straight to nodes? That must have been like an extremely lengthy process to kind of understand what nodes do and how they work.
00:03:03.484 - 00:03:29.934, Speaker A: It's definitely quite the leap. It's easier if you start the virtual machine. Since I had gotten very close with solidity assembly or Yule, it's not actually assembly that's like a knit I have every single time. And I'm sure you probably feel somewhat similar. People call Yule assembly, but it's actually not. This is a tangent. So I started writing in Yule plus, which had gotten me introduced to fuel Yule plus.
00:03:29.934 - 00:04:05.962, Speaker A: If you don't know, it's a superset of Yule which transpiles to Yule and then ultimately EVM opcodes. And so I had started writing Yule plus mostly for fun. And that had gotten me introduced to fuel labs. And from there, when I started with them, I was either really there, it's an alternate VM design, if you're not aware. And so I really just wanted to start working on. I was given the option of either the sway compiler, which is a really good language, or the core node. And I thought that the core node would be more fun because it was something I wanted to learn more about.
00:04:05.962 - 00:04:10.950, Speaker A: And so I was really given the opportunity to learn about more of this stuff through that.
00:04:11.040 - 00:04:13.146, Speaker B: Right. And how did you get into fuel?
00:04:13.178 - 00:04:38.610, Speaker A: Basically Twitter DM from John Adler. Well, I had been annoying him on the fuel labs discord before. It was like big. It was like 30 people and no activity. And every couple of weeks, every few weeks I would just post a Yule plus question and annoy him. And then eventually he got more familiar with me. And so when the sway Alpha came out, he sent me an invite.
00:04:38.610 - 00:04:58.154, Speaker A: It's called the Swayor boot camp. I don't know if this is actually documented anywhere, but there's like the sway alpha. It was like December of 2021, I want to say it was me, Libby, VM and transmissions eleven. And we all got to try out fork and sway for the first time.
00:04:58.272 - 00:04:58.874, Speaker B: Oh, what?
00:04:58.912 - 00:05:00.890, Speaker A: And so that was really my intro to fuel?
00:05:01.390 - 00:05:10.078, Speaker B: Yeah. And then eventually you just kind of like came on board, I guess, through all these interaction and being more familiar with John.
00:05:10.164 - 00:05:14.046, Speaker A: Yeah, it was actually when I met them at ETH Denver, and they found out I was in high school.
00:05:14.228 - 00:05:15.054, Speaker B: Oh, wow.
00:05:15.172 - 00:05:24.082, Speaker A: They're like, oh, they had tried to hire me before that full time and I declined, but I never gave them a reason why. And then they finally understood when I had actually met them.
00:05:24.136 - 00:05:29.320, Speaker B: Right, yeah, that would make sense. But they still got you in the end. They still got you in the end, right?
00:05:29.770 - 00:05:38.780, Speaker A: Oh, yeah, no, after that, they're willing to help out, and it's definitely a very fun place to work. A lot of really smart people.
00:05:39.950 - 00:05:44.090, Speaker B: And then you left and basically started doing your own thing, right?
00:05:44.160 - 00:06:21.106, Speaker A: Yeah, I've been doing a little bit of my own thing after leaving fuel. I really wanted to get back into smart contract work because I feel like there's a lot of people right now building shovels and not a lot of people digging for gold. And so while core node work is very rewarding from that perspective, it kind of looked to me like, wow, I'm one of a lot of people building out more infrastructure for space that's already saturated, like infrastructure supply. And so I wanted to get back into the DaP side and building things that people would actually use and bring value to infrastructure.
00:06:21.218 - 00:06:34.780, Speaker B: Yeah, I think infrastructure is quite interesting, but you could have taken multiple routes. Like you kind of went into Mev, but you obviously didn't went to the dap side. So what made you avoid that kind of field?
00:06:37.470 - 00:07:06.142, Speaker A: Mev is an interesting field, for what it's worth. I did actually briefly have like a stint in there. I think the biggest problem with it comes down to time invested. It's not as good as people think it is. Thou zero x kind of broke that with his one Twitter post. He got a bunch of people to join in thinking it was easy money, and it is in some spaces, but that was mainly during a bull market. And it's like wildly inconsistent.
00:07:06.206 - 00:07:36.800, Speaker B: Yeah, you basically have to be elite and be in a really big team or have some insane edge that other people don't. And everybody starts at zero. And you basically play catch up until you get to a point where you're at the same level as other people, which will take a while, like years or months, and then even then you still have no guarantee. So it's like basically a massive gamble at that point. And then you have to find your strategies and, okay, are you actually better than the people you just called up to?
00:07:37.810 - 00:08:15.946, Speaker A: It's not even, is it, stuff like that? There's like an insane level of entrenchment. Like, I don't know if you know this. You know Edgar route. Yeah, so I think he's geo mapped out most of the nodes across the continental United States and built his own block propagation network by positioning specific nodes within clusters and then setting their peers correctly. In competing with that to the point where I think he said he was faster than blocks route. And that's an insane level to catch up to. And you're looking at several tens of thousands of dollars a month in infra costs to approach that.
00:08:15.946 - 00:08:22.590, Speaker A: And if you're even like a millisecond slower, it doesn't matter. You make no money versus making some money.
00:08:22.660 - 00:08:47.826, Speaker B: I guess the only way to avoid competing with these people is if you have some insane, I guess, alpha, basically, like literally no one else has it, or you're just fighting some other small fish for their alpha, I guess. Not making big money in a sense. Short tail. But long tail is the only way you can go when you first start, or at least a chain where there's not a lot of people building out this kind of infrastructure.
00:08:47.938 - 00:09:11.478, Speaker A: The big thing too is you're competing against actors with more of an advantage than you would think. Like all those non devs moonlighting for lending protocols also happen to know how to build liquidation bots and just so happen to also be very intimately familiar with the code and how everything is structured. And so you're really competing against an unfair advantage.
00:09:11.574 - 00:09:26.574, Speaker B: Well, yeah, completely unfair. Not just like kind of unfair, you're like, Miles, it's like you just started high school and these people have already got like a decade of experience kind of stuff. Which can be the case in some.
00:09:26.612 - 00:09:52.390, Speaker A: Cases, especially like the people coming in with HFT experience. I trying to remember. Let me make sure he's like doxed. Actually, I won't say his name. And that fixes it. I know a guy who's working on Mev and on chain trading strategies. And when I talked with him, he was like HFT team manager.
00:09:52.470 - 00:10:12.480, Speaker B: Yeah. I've had quite a lot of people reach out to me, like hedge funds coming trying to get into know massive prop firms. I had one of the biggest prop firms, or HFT firms in Australia reach out to me to be their lead dev in their branch of Mev. Yeah, it's quite a lot, but yeah. Sorry to cut you off.
00:10:13.010 - 00:10:35.670, Speaker A: Yeah. Just to see people like that joining in with teams who had raised money, brought over engineers, and he was talking about how you an HFT, it's called from the switchback, I think, or something like that, where you don't even really have an operating system for speed. You hit an insane level pretty quickly that requires too extensive of knowledge to compete with on your own.
00:10:35.740 - 00:11:12.222, Speaker B: Yeah, people think it's just kind of like, okay, let me build this quick bot to make millions of dollars overnight and then I'll be good. It's honestly the hardest work you can do because it's not only development 24/7 it's competing 24/7 because people are iterating. Twenty four seven. So you have to do the same, otherwise you're going to be left behind. So it's kind of like a full time job, but full time in a sense that you're working literally 24 hours. Like you have your alerts on, on your phone, it pings you and someone's beating you or you're losing, and then you have to wake up in the middle of the night and upgrade.
00:11:12.286 - 00:11:22.594, Speaker A: There are people, my understanding with a lot of the mev people I have met, it is like a very intense lifestyle. Not just a job, but like a full on lifestyle.
00:11:22.642 - 00:11:23.094, Speaker B: Yeah.
00:11:23.212 - 00:11:29.094, Speaker A: With the intention that you will make enough to exit so you don't have to live like that for more than a couple of years.
00:11:29.212 - 00:11:45.406, Speaker B: Yeah, exactly. Because it's very unsustainable long term, and you're basically not even living. You're kind of just a robot. But, yeah, it's interesting that you took the node route and didn't go down there, but you seem knowledgeable enough to know that it's quite difficult and you need like a team behind you to do this. So.
00:11:45.428 - 00:11:45.566, Speaker A: Yeah.
00:11:45.588 - 00:11:52.666, Speaker B: What happened after that? What happened after the node stuff at fuel and then building, basically dapps.
00:11:52.778 - 00:12:42.350, Speaker A: Yeah. So I think one thing, when I came to writing dapps again, is solidity is not a good language, and it's not even passable, in my opinion. So at fuel, we had our own language sway, which was like a rust based DSL for smart contracts. And coming back to solidity, I just couldn't get it used to all of its quirks. Again, I know so much trivia about the solidity compiler that it's not even funny, but that doesn't make it fun to write, especially when it came to isolated lending. So this was like very shortly I had had the idea for Cog finance, which is one of the main things I've been working on for a while now, as like an isolated lending protocol. But after the Euler hack, I realized security is like a really big issue in lending.
00:12:42.350 - 00:13:20.010, Speaker A: And so I went to Viper to look for simplicity. And one key thing I'm very proud of is I think we'll actually have a page where you can do an audit yourself, even if you're not very technical, because the code is that readable. It's very simple. And Viper, weirdly too, is actually more efficient than solidity on a couple of layer twos, depending upon the situation. Just because it has so many nice creature comforts that make it easy to do things like you can predefine the value of a parameter in a function call, so you can say like this will be message sender if it's not specified.
00:13:20.510 - 00:13:43.300, Speaker B: The only weird thing about that though is from what I've noticed, sorry to cut you off again, but it basically creates like another function that you have to call. So it duplicates the code of that though. So then, yeah, it's like a preset parameter, but it basically duplicates the function. It's more deployment cost, but I guess UX is a bit better.
00:13:44.470 - 00:14:00.466, Speaker A: It's more deployment cost, but you have to remember on layer twos your main cost is call data when calling your functions. And so if you can reduce your call data size by a third or two thirds while still remaining compliant with an interface, it's a huge benefit.
00:14:00.578 - 00:14:12.986, Speaker B: True. But I guess on layer one, if someone's doing that, it kind of makes. Yeah, I guess there's two different ways of looking at it. If you're willing to trade off deployment costs for execution, which is what most.
00:14:13.008 - 00:14:14.798, Speaker A: People do with assembly now.
00:14:14.964 - 00:14:51.814, Speaker B: Yeah, it makes sense because the whole goal is to have your users pay less gas than you paying like one upfront. I mean, that's what cport is doing. That's why they're kind of going all assembly. And that's why you see MEV contracts also do that, basically just going functions specifically optimized for one call instead of, I guess, having multiple strategies on a single contract that adhere to multiple function selectors. I guess it's more of just like super optimized for one specific use case and then copy and paste for another, and copy and paste, and then it's just a massive contract with specialized function calls.
00:14:51.862 - 00:15:10.880, Speaker A: But I do have a special hatred for MeV contracts because they keep the self destruct opcode. Its usage metrics are inflated so much because of MEV contracts. It would have been so much easier to get it removed if they hadn't shot up its usage by 300%.
00:15:11.490 - 00:15:24.206, Speaker B: I did like the functionality of it, even though it's kind of detrimental in exploits. I like those kind of EVM special opcodes. They're like my favorite thing, like external.
00:15:24.238 - 00:15:28.694, Speaker A: Code copy, just like really bizarre but fun things yeah, exactly.
00:15:28.812 - 00:15:32.600, Speaker B: I love that kind of stuff. Like transaction origin. I've got to love those.
00:15:34.890 - 00:15:37.282, Speaker A: Sign extend, sign extend.
00:15:37.346 - 00:15:48.554, Speaker B: Another favorite. A crowd favorite. Yeah, love that stuff. But, yeah. Tell me more about Cog. How did this all come about and why did you get into it?
00:15:48.592 - 00:16:43.390, Speaker A: So cog is like a combination of a couple of issues I saw with isolated lending. So even though it's very easy to launch, like, a uniswap pool for a token, when you make a new token, right, like your shitcoin, you can just spin up a uniswap pool and you can trade it. The goal is to have the same effect for lending, because right now there's a lot of tokens I see out there. One major cause and catalyst for me was actually seeing coins like Luna implode and thinking, I wish I could short that somewhere. Or like, every time I see someone delusional about hex, I'm like, I wish I could short hex easily. And so the idea is to allow people to just spin up an isolated lending pool for any two tokens. You have one collateral token and one asset token, and anyone can just supply liquidity and then borrow with collateral that's deemed acceptable.
00:16:43.390 - 00:17:00.386, Speaker A: And so you get to choose your own risk. Because another thing is, when I was like, I'm no longer a USDT truth er, but when I was at one point, I was scared to use Aave, because having USDT as a collateral meant that everything could get rugged on the protocol. Right?
00:17:00.488 - 00:17:00.850, Speaker B: Yeah.
00:17:00.920 - 00:17:26.970, Speaker A: And so not being able to tailor that risk profile to what I wanted to at the time was a big catalyst for me as well, because if you're lending out something like ether on a protocol like Ave, it's all or nothing. Now, I think with emode, this is kind of different, but we can ignore that for now. The idea, though, is you should be able to choose what collateral you want your lended asset to be exposed to. And so the idea was kind of to combine all this together.
00:17:27.120 - 00:17:34.510, Speaker B: Yeah. So if you wanted to, basically, wouldn't that just create fragmented kind of collateral pools, though, of the same token?
00:17:37.410 - 00:17:42.718, Speaker A: Yes. And this is where another idea came in for me.
00:17:42.804 - 00:17:43.102, Speaker B: Okay.
00:17:43.156 - 00:18:04.290, Speaker A: If you make all the lending pools, er, 4626 compliant, so they're like yield bearing interest vaults, you actually can plug them into urine v three as strategies. And so you can have a urine vault, which you tell all your acceptable collaterals. Right. And then it just balances your lended asset among all those pools.
00:18:04.370 - 00:18:13.018, Speaker B: Balances the asset among all the pools. Okay. They're all fragmented. You can merge them all into a.
00:18:13.024 - 00:18:14.666, Speaker A: Single pool, kind of.
00:18:14.768 - 00:18:16.250, Speaker B: Okay, where am I going wrong?
00:18:16.320 - 00:18:25.982, Speaker A: Yes. So each pool still remains like its own separate thing, but liquidity comes and goes from it as needed based on the urine vault managing it.
00:18:26.036 - 00:18:31.600, Speaker B: So people can basically come into the vault and add liquidity, or I'm not familiar with.
00:18:33.490 - 00:18:51.090, Speaker A: Like a. It started out as a lending optimizer, actually, to move between you deposit into a urine vault, and then it would move your money between compound or ave, depending upon which one had the best rate. This will do that for isolated cog pools, and then you can just choose what cog pools it'll do that among.
00:18:51.170 - 00:18:59.094, Speaker B: Oh, interesting. Okay, and how long have you been basically building this? Are you building it by yourself or with multiple people?
00:18:59.212 - 00:19:13.066, Speaker A: I've been building it with hype quant and then another non dev, and we've been building, trying to think. It's like been a couple of months now, like three, four, maybe even five. Honestly, I don't know.
00:19:13.248 - 00:19:24.346, Speaker B: It's been a. Yeah, yeah. And what's the kind of like, go to strategy? Are you trying to turn this into a startup or just something public tooling, public contract?
00:19:24.538 - 00:20:07.118, Speaker A: It's kind of like a startup defi protocol. I'm trying to think. That being said, I just want to build it and see what people think. I think a lot of people get trapped when building failing projects by continuing to build them and thinking, oh, it needs this feature. If only it had this feature, we'd get users, which isn't really that true, because crypto users will tolerate so much that they really shouldn't tolerate in terms of like ux barriers or lack of features. And so I want to build it and I want to see what happens and I want to give it a shot because I don't think there is good isolated lending around. And so I want to see if the market actually wants it.
00:20:07.284 - 00:20:15.474, Speaker B: Yeah. Are you going to have some previews and stuff so people can kind of test it out and see if it's product market fit?
00:20:15.592 - 00:20:30.230, Speaker A: Yes. We plan on having a testnet launch coming up soon, audits for July 31, and then we'll be launching with scroll on main net in September. So if you want to farm your scroll airdrop, please deposit into cog.
00:20:31.770 - 00:20:34.582, Speaker B: Deposit the cog. Interesting.
00:20:34.716 - 00:20:40.102, Speaker A: Shrine. The gears. We also have zero nation as our tokenomics advisor. I should mention that.
00:20:40.156 - 00:20:42.410, Speaker B: Oh, interesting. Okay, so you're going to have a token as well.
00:20:42.480 - 00:21:42.926, Speaker A: I usually like to avoid announcing tokens early, but one of the key features is it'll essentially accrue protocol owned liquidity in times of volatility. I'll try not to get too technical on why that's, like, an amazing thing, but essentially, there's an attack on proportional integral derivative interest rate controllers in the way we've implemented protocol owned liquidity. Is it makes it non advantageous to perform this attack okay by nature. Essentially, if you're like a massive whale on a tiny, isolated lending pool, where you're lending out, like, 90% of the tokens. Right. What you can do is once someone takes out a loan of, like, half the tokens, you can, as yourself, deposit collateral and take out another massive loan. Now, this will spike up the interest rate for all borrowers, but because you're the biggest lender, you'll get all the interest you're paying yourself back, and the other outstanding loan will be paying a much higher interest rate.
00:21:43.028 - 00:21:48.974, Speaker B: Got you. For sure. And the solution that you propose is.
00:21:49.012 - 00:22:22.790, Speaker A: If the interest rate changes by a certain amount, let's say like 10%, within three days, you change the protocol fee to 100% for three days. And so what this does is when the whale takes out that massive loan spiking interest, they don't actually make any profit for three days. And that three days gives time for mercenary liquidity to see a lending APR of, like, 1000% and decide to go deposit into that pool, which then brings the interest rate back down to a more reasonable.
00:22:22.950 - 00:22:26.394, Speaker B: Interesting. Hmm. And nobody's done this before?
00:22:26.512 - 00:22:27.030, Speaker A: Nope.
00:22:27.110 - 00:22:33.418, Speaker B: Yeah. I wonder if there's any kind of little long tail opportunities that occur here.
00:22:33.584 - 00:23:09.418, Speaker A: There's definitely a lot of interesting stuff. Tarun is actually one of the people who got me thinking about this. He has a paper on it off the look for that, but he has a paper which explains this attack. And one of the solutions he mentioned was protocol owned liquidity, although not necessarily in this way, but I think that it's definitely really interesting to try out. And having protocol owned liquidity also fixes a lot of the liquidity fragmentation, you see, because if each pool has, like, a certain amount of pool owned liquidity, it just means that there's more liquidity that stays within the system.
00:23:09.504 - 00:23:40.770, Speaker B: Yeah. Protocol owned liquidity is definitely an amazing thing for any protocol that deals with liquidity, because the traditional liquidity provision is basically renting out liquidity. Right. And you're giving rewards in a way of, like, master chef, I guess. For example, when times get rough, people just take out all the liquidity and then say goodbye to slippage, basically, and the conversion rates. So protocol own liquidity is really like a padding. That's permanent, I guess.
00:23:40.770 - 00:23:45.540, Speaker B: And it ensures that you basically own the liquidity instead of renting it. So how do you.
00:23:46.410 - 00:23:56.310, Speaker A: I'm sorry, I was going to say, the way I've always seen it is protocol owned liquidity transforms the protocol from the platform to the counterparty.
00:23:56.650 - 00:24:02.790, Speaker B: Yeah, exactly. So how do you basically obtain this protocol owned liquidity charge fees.
00:24:02.870 - 00:24:22.946, Speaker A: So you essentially take 100% of the interest earned during these periods of volatility, and that accumulates this protocol on liquidity. Then there's also a small fixed fee for taking out a borrow, which just prevents some minor greeting stuff. And then there's also just a flat protocol fee on interest earned, and then.
00:24:22.968 - 00:24:31.054, Speaker B: It'S always three days that this fee happens, and then after three days, it's back to normal.
00:24:31.182 - 00:24:54.266, Speaker A: Yes. I am still toying around with the time period window, though, so it's like not set in stone. So one of the reasons we actually wrote this stuff in Viper is you can plug it into a Jupyter notebook, and so you actually can then import all the python visualization libraries, and you can make some really fun graphs and then toy around with parameters like this.
00:24:54.368 - 00:24:59.562, Speaker B: So you're basically spending all your time on cog. Are you doing any kind of freelancing at the moment, or just.
00:24:59.616 - 00:25:30.486, Speaker A: I'm doing freelancing for an upcoming LSD protocol, which will be launching. And then I recently started working on Dell as well, on their new fixed rate bond trading or fixed rate yields trading or fixed rate yield amm, that's the correct way to describe it. Fixed rate, which is like, for. The best way to think of it is you can essentially feed in any, er, 4626 yield source, and sell or buy bonds based off that.
00:25:30.588 - 00:25:33.746, Speaker B: Okay, so it's kind of like an exchange for bonds.
00:25:33.858 - 00:25:52.818, Speaker A: Yes, it's exactly what it is, an exchange for bonds. And it makes a couple of key improvements on top of element v one. And it was definitely really interesting for me, and I think fixed rates kind of coming back now that interest rates are higher from the fed and we have more liquid staking protocols.
00:25:52.854 - 00:25:58.430, Speaker B: I'm super curious of how you got into all this. Kind of like, what would you call this? Like economic theory or something?
00:25:58.500 - 00:26:00.640, Speaker A: I mean, like ponzoo nomics, I think.
00:26:01.570 - 00:26:16.018, Speaker B: Yeah. How did you even get into all this? I remember this is the kind of stuff I avoided because I think, thought it was like math heavy, and I'm not good at math, so kind of just steered away. How did you get into this stuff?
00:26:16.184 - 00:26:43.982, Speaker A: I think I mainly got into it when I was trying to be an active member of sushi swap. And so I was like, I need to learn everything about Defi. And so I did one really big proposal push. And through that I started thinking about, because it was about reshaping the dow. And so that got me thinking a lot about tokenomics. And then especially Sam Bacha from Manifold finance. He's actually sent me a lot of really good stuff on that.
00:26:43.982 - 00:26:57.282, Speaker A: And just like reading things he sent me, I've accumulated a good bit of knowledge because he's really deep in the mev space, of course. And so then you start thinking more about actors incentives, things like that.
00:26:57.336 - 00:27:06.370, Speaker B: So basically you're just doing freelancing and cog. Is there anything on kind of like your mind for the future of dabbling into, apart from obviously cog?
00:27:06.450 - 00:27:09.160, Speaker A: Mev on cog. Oh my God.
00:27:10.090 - 00:27:26.378, Speaker B: Do you intentionally think of, I guess, mev solutions or even creating basically mev from scratch? Because that's what basically dapps do. Dapps are what forms meV. So are you keeping that in mind or you're not really worried about it too much?
00:27:26.464 - 00:28:08.842, Speaker A: I'll give a little bit of alpha for the people listening in that do Mev. I think the future is multilayer Mev between layer one and layer two ordering. And so with that, I think your main conclusion comes down to whoever can produce the first layer two with decentralized block production, that ultimately will be the winner, because it'll drive meV, which will more or less drive users over to that roll up. That's like a big reason. I'm actually kind of bearish optimism, because I think it's going to take them a long time to get that done. And I think someone else will probably work something out before then.
00:28:08.896 - 00:28:15.562, Speaker B: And by fully decentralized, basically block production, what do you mean by that?
00:28:15.696 - 00:28:28.526, Speaker A: The model I've seen a lot of people throw around is essentially a layer two token, which you stake, and then that gives you the right to be sequencer for a block. Every end blocks the idea. Go ahead, sir.
00:28:28.628 - 00:28:41.586, Speaker B: So giving that knowledge, you can basically just have, if you have a bunch of money, you could basically create a bunch of accounts and kind of guarantee x amount of blocks in y amount of time, right?
00:28:41.688 - 00:28:53.298, Speaker A: Yes. And if you own a bunch of Ethereum validators, and you own a bunch of layer two block production tokens, you could in theory organize multiple blocks within a block.
00:28:53.394 - 00:28:59.178, Speaker B: Yeah, you basically get like massive control at that point. So how does decentralizing it work then?
00:28:59.264 - 00:29:11.654, Speaker A: Well, decentralizing it just means that you can do that instead of arbitrum, because arbitrum will take their sequencer fee or whatever a decentralized block production means, you actually start getting that fee.
00:29:11.782 - 00:29:38.098, Speaker B: Okay, but I mean, it could still happen, right? If these kind of like builder tokens, if that's what you call them, if I still have my validator and I still want to make multiple counts and have these kind of block producers, I could still do that just in a decentralized way where I get the fee. But the same thing can still happen where basically someone can just take control of the network. Well, x amount of the network.
00:29:38.194 - 00:30:27.990, Speaker A: I still think it's going to be ultimately better, though, because it means layer two tokens actually provide value. And being able to build your own blocks for layer two is really powerful. And I think it'll lead to a lot of interesting cross roll up stuff, especially now that we're seeing more ZK roll ups, because you could, in theory, do a lot more things atomically. Do you see what I'm saying? If you control like ZK sync and scroll, for an example, and Ethereum, all those probabilities line up, you'll make the next block for each. You could order transaction on scroll that would bridge from scroll to Ethereum. Then you could order a transaction on Ethereum that would deposit into the ZK sync bridge. Then you could order a transaction on ZK sync that would deposit onto the Zksync chain from the other side.
00:30:27.990 - 00:30:35.350, Speaker A: Right. And so in essence, you could actually arbitrage between ZK roll ups within the same block.
00:30:35.690 - 00:30:42.970, Speaker B: Yeah. As a person that's basically done this whole chain, they can predetermine what's going to happen.
00:30:43.120 - 00:30:45.594, Speaker A: Yes. On like a much larger scale. Now.
00:30:45.632 - 00:30:50.810, Speaker B: I feel like that's kind of bad, though, but I think that goes into the way of decentralization. Right.
00:30:50.960 - 00:31:02.474, Speaker A: Well, it's definitely very scary if you start thinking about all of the externalities that creates. But it's also very interesting. I think it's still definitely better than a centralized sequencer.
00:31:02.522 - 00:31:03.120, Speaker B: Yeah.
00:31:03.510 - 00:31:09.300, Speaker A: But I don't know how much better that'll be. At least you won't be mining arbitrum websockets, though.
00:31:11.910 - 00:32:11.320, Speaker B: Yeah, I think the MeV game definitely gets deep into who basically controls the network. It gets quite interesting when you get to the node level and the block builders of how much transaction inflow they have, especially the question of how do we remove sandwiches or prevent them from being included all the time. It's such a difficult question because they provide more transaction flow than, let's say, a positive arbitrage which fixes the prices between two exchanges, because that's only one transaction versus a sandwich, which is two transactions. So obviously, the builder is going to want to take the sandwich over the arbitrage, but it also depends on how much money they make from it as well, in an incentive standpoint. Yeah, it'll be interesting. I'm also curious to see how MEV will work on ZK as well for anonymous transactions. Right?
00:32:12.570 - 00:32:49.358, Speaker A: Yeah, it'll be very interesting. Well, scroll itself is a ZK EVM, so it'll be just like the EVM. But on Aztec, things get really interesting. The one thing that also makes me curious about Aztec is, if I recall correctly, their vm three, I think it's called, or they're just calling it Aztec, which I think is kind of dumb. But on like a side note, it's Utxo based. And Utxo and MeV are very interesting because you can essentially very easily verify that two bundles won't collide with each other. And so if you do that, you can actually have multi bundle blocks fairly easily.
00:32:49.454 - 00:32:53.550, Speaker B: And you can't do that. Why can't you do that with current EVM?
00:32:53.630 - 00:33:06.758, Speaker A: I think you can. And flashbots might actually have something for that now. It just becomes easier with Utxos. You also can execute them in parallel if you know that they don't contend on state, which is very nice.
00:33:06.844 - 00:33:24.334, Speaker B: Yeah. I'm also curious to see how auditing will work post deployment on ZK as well, because then you have transactions that you have blackouts that are basically anonymous. Yeah, in a way.
00:33:24.452 - 00:33:27.934, Speaker A: I predict certix revenue is going to go up 400%.
00:33:28.052 - 00:33:30.750, Speaker B: 400% for ZK.
00:33:31.890 - 00:33:34.450, Speaker A: Isn't that always the meme? They hack their clients.
00:33:36.470 - 00:33:41.490, Speaker B: They approve it, and then hack after they get paid on both ends.
00:33:42.230 - 00:33:46.660, Speaker A: It's the ultimate MeV auditor extractable value.
00:33:47.990 - 00:33:55.730, Speaker B: Speaking about auditing, mev, have you seen the public contests and their bot races?
00:33:55.890 - 00:33:58.758, Speaker A: For what? I'm actually kind of interested now.
00:33:58.844 - 00:34:52.266, Speaker B: Yeah. So basically they're doing the public contest, how? They have hundreds of people competing, and they all kind of find these low hanging fruits that are just dilute the pool entirely. So what they introduced was a bot race, which, what does it do? Basically, all these bots have, like, a certain time period where they find as many, basically vulnerabilities as possible information, or whatever severity, and then whatever that is, or what they find becomes out of scope. And so all these people that were diluting the pool originally, let's say 100 people, found the same kind of severity bug, same exact bug. And now they've just diluted that whole pool. And someone, let's say they all found like a high or like a medium. So let's say 100 people found the same medium, but one person found a low.
00:34:52.266 - 00:35:09.790, Speaker B: That one person that found a low gets paid more than all the people that found the medium. So in order to solve that problem, they made bot races, which basically, okay, they automatically find these low hanging fruits when they're no longer in scope and people no longer can dilute the pool, so they're more incentivized to find unique findings.
00:35:11.730 - 00:35:47.830, Speaker A: Code Farina was like such underrated as MeV because every top auditor I kind of knew of didn't really audit code. They just wrote really good static analyzers. I know there's like a couple auditors who would just go through pretty much every code. For ENA contest, you run a bot that does static analysis atop the contracts, generates a report, you cross reference it a couple of times, look, see if there's anything else, and then just submit that. And so people would just be developing their own static analyzers in private to win code Forina contests.
00:35:47.910 - 00:36:32.380, Speaker B: Yeah. And now they've built like bot races to kind of get rid of them. But these bots aren't too sophisticated, though. They're not finding tons of vulnerabilities, but I think they only get like 10% of the pool as well, so it's not a big portion. Yeah, if it was more, it'd be interesting, but I mean, that's what I was planning to do as well. And what I am doing is instead of a static analyzer, it's like a dynamic analysis tool. So it actually executes the code and creates the state and the context initially and then goes through it all.
00:36:32.380 - 00:36:41.520, Speaker B: It's quite complex, but it's a good task to get involved in. And you also have done compiler dev, haven't you? Yeah. Have you ever been interested in that stuff?
00:36:42.690 - 00:36:46.480, Speaker A: I've always been interested in code gen side of the compiler more.
00:36:47.250 - 00:36:47.758, Speaker B: Okay.
00:36:47.844 - 00:36:50.142, Speaker A: To give like a quick. What did you say? Sorry.
00:36:50.196 - 00:36:52.814, Speaker B: Like forward engineering, like generating code.
00:36:52.932 - 00:37:14.280, Speaker A: Yes, because I've always been closer to the vm and node side, so it's always been more interesting for me to work on that. Also, parsing is never really interesting because it's like a lot of weird edge cases and just import this library and define grammar rules, and then AST is so difficult to visualize that it's never any fun to do.
00:37:14.650 - 00:37:33.034, Speaker B: Okay. I'm a pretty big fan of all kind of analysis. Pretty interested in the recon side, basically getting as much information as you can about something. And then I'm super interested in dynamic analysis for fuzzing and symbolic execution. Have you tried any of that stuff for cog?
00:37:33.082 - 00:38:16.518, Speaker A: I've actually been writing a lot more state machine tests than usual. Fuzzing. I've kind of gone on a curve on, because I really do like fuzzing, but I feel like it's over treated as some holy solution when it's really not that great. For library functions, yes, 100%. But for most contracts, its chance of generating a meaningful sequence of vulnerable actions is much lower than compared to something like a state machine. You essentially define a list of actions that you can do on your contract so that it's like add liquidity, take out a loan, repay a loan, and then it'll randomly execute those steps in different orders to try and get it to violate an invariant.
00:38:16.614 - 00:38:31.038, Speaker B: Got you. So it's like a sequence of different kind of functions. It's like function fuzzing, basically like function ordering fuzzing, but in a predetermined way. Not kind of random at all.
00:38:31.204 - 00:38:39.380, Speaker A: Exactly. And so I think it still gets that edge case catching, but it's a lot more meaningful in how it's going about doing that.
00:38:40.150 - 00:38:54.646, Speaker B: And that's called state machine testing. Interesting. Yeah, I heard. I think it was. Who was it? I had someone on before, but that's what they were doing at seaport. Oh, horsefax. Yeah.
00:38:54.646 - 00:39:19.914, Speaker B: So the symbolic engine, I think that's what you said. The fuzzing engine. Yeah, the fuzzing engine that they were building. There was that exact thing. So they had a preset, I guess they had like an enemy of different actions that you could take. It's like a buy order, sell order, or whatever. And it was just thrown into a generative kind of thing where it sequenced them in different orders, and that was quite effective.
00:39:19.914 - 00:39:28.466, Speaker B: But they built that in house for that specific thing. So I think it is quite good. So you built that from scratch, or were you just like kind of porting it from something else?
00:39:28.568 - 00:40:10.480, Speaker A: So, fun little fact about Viper, we use titanoboa, which is a Python viper interpreter, which, as a little side note, I want to brag on behalf of Charles, it's faster and more feature complete than foundry. It's faster than foundry, even though it's written in Python, because Viper Ast is so similar to Python ast, it can translate to Python ast on the fly. And so it's getting executed on native instructions. Calendar can't really match that. And then it supports things like coverage and it integrates with Pytest, so you can use all the pytest and python testing libraries to test your viper code.
00:40:10.850 - 00:40:15.614, Speaker B: Interesting. Yeah, because Viper is basically python, but for blockchain.
00:40:15.742 - 00:40:17.650, Speaker A: Exactly like, they're very similar.
00:40:17.800 - 00:40:22.450, Speaker B: Yeah, interesting. So it's actually faster than foundry even though it's in python.
00:40:23.590 - 00:40:38.680, Speaker A: I know, yeah. And the only way foundry can really match that is if it translated solidity to LLVM, which would be a nightmare. And I don't even think that's worth doing. Like foundry is already fast enough and LlVm is very.
00:40:41.370 - 00:40:46.266, Speaker B: Yeah, yeah, for sure. What makes an, um, are there just.
00:40:46.288 - 00:41:08.690, Speaker A: Like a lot of instructions to support? I know there's a lot of instructions to support, as far as I understand, and not a lot of people are familiar with it. Or the chance that you would have some subtlety change when transpiling solidity to llvm that'd be different from the evm. Doesn't really make it worth going from like 2 seconds to 0.5 seconds.
00:41:09.270 - 00:41:21.174, Speaker B: Yeah, I guess it's like a ton of work just to have like a marginal difference. Well, I guess it's not, I mean, it's a big difference, but the amount of work that would take to kind of implement that would be quite severe. Right.
00:41:21.212 - 00:41:24.082, Speaker A: You would have to write a new backend for the solidity compiler.
00:41:24.146 - 00:41:30.262, Speaker B: Yeah, nobody wants to do that. Yeah, maybe they can.
00:41:30.316 - 00:41:33.180, Speaker A: They would rewrite Solsi and rust before they did that.
00:41:33.870 - 00:41:38.074, Speaker B: Oh, that would be quite good. I would love that.
00:41:38.112 - 00:41:38.314, Speaker A: Yeah.
00:41:38.352 - 00:41:44.298, Speaker B: But probably won't see that happen for some time. I'm pretty sad that they wrote it in. I think it was in c, right? C or C plus plus.
00:41:44.384 - 00:41:45.534, Speaker A: C plus plus.
00:41:45.732 - 00:41:54.522, Speaker B: Yeah. I was like thinking of going and reading into it, but I don't know, C plus plus and I didn't want to learn C plus plus just to learn the compiler.
00:41:54.586 - 00:42:16.360, Speaker A: I've heard this anecdotally. It may not be true, but the rumor I had heard is that they wrote it the way they did, so it'd be a very readable compiler. But then they wrote it in C plus plus, so it doesn't implement that many optimizations on a compiler level to keep the compiler readable. But the compiler is in C plus plus anyway, so that doesn't really help.
00:42:18.430 - 00:42:23.500, Speaker B: It's just like, okay, we have good intentions, but the execution was bad.
00:42:27.310 - 00:42:36.062, Speaker A: I have so many complaints about the solidity compiler, one of which being if you have nested mapping, so that's like really gas inefficient yeah.
00:42:36.196 - 00:42:36.958, Speaker B: Oh my God.
00:42:37.044 - 00:42:48.580, Speaker A: They should just combine the keys and hash both keys the same time. It would break the slot format, like the way it can be expected now, but it would be so much more efficient that I just want it to happen.
00:42:49.590 - 00:43:00.450, Speaker B: Yeah. I wonder how many people would do that, though. I know I did, actually, I did it a few times. And I guess with ERC 20. Yeah, even with ERC 20, it has nested mappings.
00:43:00.530 - 00:43:01.954, Speaker A: Not straight with allowance.
00:43:02.082 - 00:43:14.794, Speaker B: Yeah, exactly. Yeah. I wonder. It's kind of like unfortunate that you can't really optimize to compile like this or make your own. They would have had to made all these decisions basically apps day one. Right.
00:43:14.992 - 00:43:30.554, Speaker A: They could make a breaking change now, and honestly, they're not at version one yet, and I think they should. There's a lot of weird quirks like that though, that exist. Another one of them that's actually fairly interesting. So Viper stores all of its variables in memory. Solidity stores them on the stack.
00:43:30.602 - 00:43:30.814, Speaker B: Right.
00:43:30.852 - 00:43:54.162, Speaker A: That's why you traditionally get stacked too deep. One quirk of this is that in balance of function calls, it's cheaper in Viper than it can ever be in solidity, because the value goes from call data straight to memory rather than onto the stack. Then it's like already in memory. So when you do the hash for mapping, you don't have an additional move there, so it's like marginally cheaper.
00:43:54.306 - 00:43:58.970, Speaker B: An additional move, I mean, it wouldn't be that much more expensive.
00:43:59.310 - 00:44:01.340, Speaker A: It's like 50 gas or something.
00:44:01.790 - 00:44:05.900, Speaker B: Yeah, but when you're thinking about that, it's not that much.
00:44:08.030 - 00:44:14.320, Speaker A: It'S viper beating solidity. And Viper was always known as gas inefficient. That's why it surprised me.
00:44:15.490 - 00:44:38.742, Speaker B: Yeah, I remember there was like a time on Twitter where just people came and started mentioning Viper was just popping off. And it's like way more optimized than solidity. But then you also have like solidity inline assembly. Solidity I think it's called, you know that repo in pure inline by vectorized. Yeah. Which is like now kind of the standard for whatever.
00:44:38.876 - 00:44:40.374, Speaker A: Are you on the discord for it?
00:44:40.492 - 00:44:54.460, Speaker B: I'm not, no. They're doing like a public order for it as well. With spirit's new thing, Cantina. I think they raise like they are.
00:44:54.830 - 00:44:59.210, Speaker A: That's the optimism public goods thing, right? With like velodrominal.
00:45:01.150 - 00:45:17.282, Speaker B: Yeah. And I was even talking to him before, I'm like, okay, why don't you just write pure assembly? But integration with inline assembly is much easier. Know, custom assembly stuff, or it's actually more optimized, I can't remember. Or it's perfect. Inline assembly is quite good, though.
00:45:17.416 - 00:45:33.350, Speaker A: It is. The one thing I actually wanted to get JT Riley to do is inline huff libraries inside of Viper, because then you would have all the readability of Viper and all the ease of use, but you would have something more efficient than assembly blocks.
00:45:33.690 - 00:45:39.180, Speaker B: Okay, but imagine trying to manage the stack when like halfway through a function call.
00:45:41.470 - 00:45:45.142, Speaker A: Viper doesn't use the stack though. Stores variables in memory.
00:45:45.286 - 00:45:51.546, Speaker B: Oh, okay. But then you can't actually be more efficient. How was that? Yeah, that's breaking my mind.
00:45:51.568 - 00:46:04.720, Speaker A: It's not actually that much better. I was talking with Charles too, and he's like, yeah, but then your compiler can't do any optimization passes on this blob of bytecode. And so it's not really that much.
00:46:06.930 - 00:46:50.800, Speaker B: Fun. The whole point of using HoF instead of assembly or solidity is because you can do all your calculations in the stack instead of memory, and basically instead of, yeah, exactly. So you can dupe multiple times and then do your calculations on that and swap it in and out, whereas memory, you're just reading and writing to memory all the time, which is, I guess fine, but even just like expanding the memory to what you need, let's say you had like five different variables. You're going to have to expand it 32 bytes times five, unless you bit pack them all. But good luck with that. Making something stand of that.
00:46:51.650 - 00:47:04.100, Speaker A: Well, bit packing doesn't even make that much sense on the EVM because you have a 256 bit word size. So for it to be useful it has to be in the full 256 bits anyway.
00:47:05.450 - 00:47:25.820, Speaker B: Yeah, but then if you're talking about a struct and you have like a un eight and a so forth and so on, or like an address, un eight, un eight, Boolean, that kind of stuff, then it makes sense. But yeah, anything over that doesn't make sense.
00:47:26.670 - 00:47:33.946, Speaker A: On a side note, actually, is it weird to write your memory addresses in hex instead of decimal?
00:47:34.138 - 00:47:45.780, Speaker B: Your memory addresses in hex? I mean, I've been using half for so long, I can't even go back to normal solidity. I'm at the point of no return.
00:47:48.950 - 00:47:54.862, Speaker A: That's like good, though. Solidity is something we should abandon and not die.
00:47:55.006 - 00:47:57.190, Speaker B: Are you trying to pill me into Viper?
00:47:58.730 - 00:48:08.790, Speaker A: I am, because when you need the efficiency, you write in HoF. When you need the readability and security, you write in Viper. Now why would you write in solidity?
00:48:09.450 - 00:48:14.298, Speaker B: Why would you write in Viper? Just go huff, sir. Yeah, exactly.
00:48:14.384 - 00:48:20.486, Speaker A: Do you want to re implement my lending pool implementation of roughly 1200 lines of viper into huff?
00:48:20.598 - 00:48:27.680, Speaker B: I could do that. Contract me@nibbleandbites.com. Not sponsored having said that, I think it's getting to a close.
00:48:30.530 - 00:48:41.460, Speaker A: Okay, now try paying for the audit though. As soon as we get like generic bytecode analysis auditing tools, then Huff can become a lot better I believe.
00:48:41.830 - 00:49:05.466, Speaker B: Oh yeah, that's also what I'm working@nibblerbytes.com. Not sponsored so yeah, hopefully in the future if you get into that, then hit me up happily supply. But until then, thank you so much for jumping on the podcast. I think this is a very interesting conversation. I learned a lot because I'm pretty stupid, but yeah, thank you so much.
00:49:05.488 - 00:49:06.780, Speaker A: I learned a lot as well.
00:49:08.270 - 00:49:12.618, Speaker B: What year are you in? High school. If you want to announce that I'll.
00:49:12.634 - 00:49:20.880, Speaker A: Be a senior next year or this year so I'll be out pretty quickly. But it's not that. Yeah, I'm not like twelve.
00:49:21.330 - 00:49:25.700, Speaker B: Okay sir. Primary school.
00:49:28.790 - 00:49:30.980, Speaker A: I did this in my middle school gym class.
00:49:33.030 - 00:49:37.198, Speaker B: In your computer science class. Just like instead of scratch you just code.
00:49:37.304 - 00:49:51.974, Speaker A: It's actually kind of funny. There's another kid I met who I won't doc, but he's somewhat well known. He audits for a firm and he was a freshman. So there are legitimately high schools with just like crypto devs everywhere.
00:49:52.102 - 00:49:59.740, Speaker B: Crazy. I wish I did that when I was in high school. I look back at it every day.
00:50:00.450 - 00:50:04.080, Speaker A: We raise college tuition 300% and this is what we get.
00:50:06.690 - 00:50:20.010, Speaker B: People basically skipping college. Anyway, man. Yeah, it's been quite good. Yeah man, it was lovely having you on. Thank you so much for spending the time and even great to meet you as well. This is our first conversation.
00:50:20.090 - 00:50:22.670, Speaker A: No, it's great to be on. I'll talk to you later.
00:50:22.740 - 00:50:40.050, Speaker B: See and if anybody has anyone they want to recommend for the podcast, dm me on twitter at dugachi or at scrapingbits or send an email to scrapingbits@gmail.com but until then this has been dugachi with scraping bits and goodbye.
