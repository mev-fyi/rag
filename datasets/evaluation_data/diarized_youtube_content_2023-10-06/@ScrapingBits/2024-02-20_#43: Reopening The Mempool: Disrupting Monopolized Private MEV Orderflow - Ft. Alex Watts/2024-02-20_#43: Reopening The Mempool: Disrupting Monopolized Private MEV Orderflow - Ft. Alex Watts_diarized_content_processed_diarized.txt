00:00:00.330 - 00:00:22.080, Speaker A: Just by virtue of not having a private relay to validators. There's two neat things that happen. First, we virtually never see sandwich attacks, because if anyone tries a sandwich attack, then the sandwich attacker will just themselves get attacked by some other bot out there. The other neat thing that happens is private order flow. Nonexistent. Everything becomes public.
00:00:22.850 - 00:00:52.598, Speaker B: Scraping bits is brought to you by the following sponsors. Mev protocol. Maximize your eth staking value with me v, exclusively on MeV IO and composable execute any intent on any chain. Coming soon to mantis app. That's M-A-N-T-I-S-A-P gm. Gm. Everyone, my name is Sugarchi, the host of scraping bits, and today I'm with alex from fast lane labs.
00:00:52.598 - 00:00:53.514, Speaker B: How's it going?
00:00:53.632 - 00:00:56.046, Speaker A: It is going pretty well, man. How are you doing?
00:00:56.148 - 00:01:03.922, Speaker B: Not bad. Doing pretty well as well. It's a pleasure to have you on. And for the people that aren't familiar with you, who are you and what do you do?
00:01:04.056 - 00:01:53.470, Speaker A: My name is Alex, aka Thogard, and I am building over at fastlane Labs, and we are, for lack of a better phrase, an MeV protocol. But we take a very different approach to Mev than many of the other types of MeV systems out there. And specifically, what I mean by that is that we focus heavily on smart contracts just by virtue of not having a private relay to validators. There's two neat things that happen. First, we virtually never see sandwich attacks, because if anyone tries a sandwich attack, then the sandwich attacker will just themselves get attacked by some other bot out there. The other neat thing that happens is private order flow nonexistent. Everything becomes public.
00:01:53.620 - 00:02:04.958, Speaker B: Okay, interesting. And in a past life, you were a searcher. I remember when you first got into the space. That's kind of what you did with Fallowx. You both were kind of doing that I don't know if you were doing on polygon.
00:02:05.054 - 00:02:22.246, Speaker A: I was, interestingly enough, with thalex, I actually asked him to team up with me in the very beginning. And funny story, he said, maybe. Let me think about it. And I ended up sending him, just, like, giving him access to my bot. And I was like, hey, yeah, check this out. This is the strategy. Let's go.
00:02:22.246 - 00:02:32.246, Speaker A: It's an extremely high level of trust. And the very next day, he came back to me. He's like, hey, man. Yeah. I don't really want to work together. I want to kind of do this on my own. I was like, oh, shit.
00:02:32.246 - 00:02:48.210, Speaker A: This fucker is going to steal my strategy. Fuck. But to his credit, even though he could have. He didn't. And I watched, too, because I knew his address, he knew mine. I watched him. He did not steal it, even though it would have been so easy for him to just start competing with me.
00:02:48.210 - 00:03:02.918, Speaker A: And to this day, he is one of the people I have the most explicit trust for in Defi, because I know, and I have that experience, that he could have really screwed me over if he wanted to, and he didn't. He's a really good dude. Absolutely.
00:03:03.084 - 00:03:08.242, Speaker B: Interesting. I don't think he's doing an mev anymore as well. He kind of moved on to protocols.
00:03:08.386 - 00:03:12.710, Speaker A: He is working over at Skip now, I believe, in the cosmos ecosystem.
00:03:12.870 - 00:03:25.518, Speaker B: I wonder why he didn't just team up with you at the end of the day. Yeah. So why did you go on Polygon instead of Ethereum? And why even get into searching in the first place?
00:03:25.684 - 00:04:05.174, Speaker A: That's a really good question. I don't have a super noble reason for it. The actual chain of events was that during COVID I was just being a dgen, like a lot of other people, and I stumbled across this protocol on polygon called Iron finance, which was a fractional reserve stablecoin. And at the time, I was working in, you know, it was during COVID so I had some spare time on my hands, and I looked at the protocol specifications. I went through the docs. I didn't really know how to code that well at the time, which is why I had asked stalks to join me. And as I was going through the docs, I was like, wait a second.
00:04:05.174 - 00:05:00.982, Speaker A: There's, like, a very easy arbitrage here. And then I looked at the price chart, and you could kind of tell just from looking at the price chart that this time weighted average price oracle arbitrage, you would mint the stablecoin and then sell it or buy the stablecoin and then redeem it, that there was this arbitrage that you could literally tell just from looking at the price chart no one was actually doing. And so I manually did it, like, once or twice, and it worked. I was like, yo, because in tradfi, it's not supposed to be that easy, right? Like, in tradfi, everything's supposed to be, like, crazy hyper competitive, and you're just entrained from the very beginning that easy money just isn't possible. And yet there it was. And so I ended up trying to learn how to code a bot. I think there was this meme around the time that I had written a 12,000 line python bot, where it's just all one file.
00:05:00.982 - 00:05:34.038, Speaker A: And that's actually not true. The truth is that it was a 20,000 line python bot that was all one file. And I am not exaggerating, you can ask people, this is genuine, because it was my very first computer program. I just dove straight into it, and it was just a whole bunch of nested, like, if this. Do this, if this, do this, if this, just like, thousands of lines. Because I was coming from tradfi and not quant tradfy either, but Excel spreadsheet style. And I made way more money than I thought I would.
00:05:34.038 - 00:06:03.690, Speaker A: Not just with the iron finance, too. I then started getting into regular atomic arbitrage. Then I got front run, and I took that personally, which set me down this path of, you know, being competitive and the villainaut, learning more about that. And I recruited a team. We got just like, really talented teammates. I think I'd mentioned you before. We got an engineer from Google, an infrastructure guy from AWS, from Citadel, and people who were interested in collaborating.
00:06:03.690 - 00:06:55.360, Speaker A: And so I was just surrounded by all these gigabrains, right? Just the chattiest of chat people in their respective categories, and they were just funneling knowledge into my brain. And it was for an entire year, and actually no longer, like two years. And anytime I had a question, some of the most knowledgeable people in the world in that field were there. And here I am, still trying to workshop my 20,000 line python. From there, we kind of grew a little bit. We then started working on Polygon Fastlane as an MeV protocol for Polygon, because back in February of 2022, I think it was, there was a lot of reorgs and a lot of network instability, and we ended up making a lot of money on one really good trade. And then it got reorbed away.
00:06:55.360 - 00:07:20.290, Speaker A: It was so painful. It was so painful. And I was like, fuck this. I'm going to make an MEV protocol. How hard can it be? I'm going to make it, and, like, two months later, it'll just be done, and then I'll just go back to trading, and everything will be perfect. And that was roughly two years ago, and I ended up stopping trading. I ended up leaving the team for Mev that I had founded.
00:07:20.290 - 00:08:11.458, Speaker A: Just because on one hand, you can't really do mev and also run an MEV relay. That's a huge conflict of interest, right. It's not very decentralized, but I fell in love with the mechanism design and protocol design, and honestly, it's still very pvp when you're making an MEV protocol, because you have to assume that all of the searchers, I mean, you've done mev, you know, they're always looking for an edge, and if they can find a way to do things that your system doesn't necessarily want them to do, then they will, especially if it makes the money. And even if it doesn't make the money, a lot of times they'll take any chance they can to dunk on you just for the clout. It was a lot of fun, and I really fell in love with it. I keep telling myself, one of these days I'm going to spin up a bot because now I'm fairly proficient in solidity and golang. I'm even writing some stuff in assembly.
00:08:11.458 - 00:08:34.354, Speaker A: One of these days I'm going to learn rust. But I keep telling myself, I'm like, all right, I'm going to take like two weeks off from work and I'm just going to go over to some chain that I'll never, ever build a relay for and build a bot there and just see what happens. But I keep getting pulled back because just new stuff just keeps happening in the Mev world that I want to work on in terms of protocol design.
00:08:34.472 - 00:08:40.798, Speaker B: Yeah. So what was the switch like from making tons of money and searching to now starting from scratch?
00:08:40.894 - 00:09:29.342, Speaker A: It was interesting. So originally that actually was the plan was to keep the bot going and then have the bot kind of pay the bills or like building the MEV relay. And for the first eight months of the existence of polygon fastline, which we now call fast polygon, because apparently if we put the word polygon in front, it makes us sound like we're part of polygon, which is genuine and we are not. So we first started doing both because we weren't profitable. We didn't have any way to monetize at all. And even if we did, we wouldn't have, because it's going to be harder to onboard new validators that way. Right? And so we started just keeping the bots going, but the conflict of interest became so obvious, especially when the whole FTX thing happened and we were looking at SBF and Alameda.
00:09:29.342 - 00:10:32.454, Speaker A: I'm reading about this in the news, and I'm like, oh, we probably shouldn't do this. So around that time, we started talking to some venture capitalists who were super interested in the concepts and also our approach to meV, too. We were very focused on not just infrastructure style MeV, like what you would see with the MeV ogs, which would absolutely be flashbots we were interested in a hybrid approach to MeV, where it's part infrastructure, part smart contracts. And by doing it this way, it really created some extra guarantees, not necessarily for the validators, although they benefited from this as well as the searchers, they also benefited. But the main reason why we were looking to do this was actually to keep the polygon ecosystem's users protected from sandwich attacks. It's something where the polygon community and the polygon ecosystem is not as large as Ethereum. It's kind of a layer one, it's kind of a layer two.
00:10:32.454 - 00:10:38.530, Speaker A: I like to call it a layer 1.5, but it's kind of got like 1ft over on Ethereum and then 1ft on its own network.
00:10:38.610 - 00:10:46.410, Speaker B: I feel like nothing is really as big as Ethereum, and maybe never will be, because it was the first mover. And I think all the mines are on Ethereum anyway.
00:10:46.560 - 00:11:32.858, Speaker A: Exactly. And it's like a lot of the validators on Polygon were also validators on Ethereum. But what's interesting on Polygon is that, and I think this is true for a lot of alts, l ones, and layer twos, is that there's definitely a strong sense of community. And when you're looking at Ethereum, there's a lot of really adversarial assumptions that go into the network topology. And I think that that's important, especially because Ethereum is so focused on, first and foremost, just being extremely decentralized, right? Because it is the base layer. If its security is compromised, then a lot of other networks also have their security compromised by default. And so having it put an extra emphasis on that security does make a lot of sense.
00:11:32.858 - 00:13:02.002, Speaker A: But on polygon, there's more, I think, room to trust things like the social layer, and more room to sort of innovate. And because of that, we were able to build an MEV protocol where users on polygon are hardly ever sandwiched, less than 1% of the frequency of being sandwich attacked on Ethereum. And this isn't to say that it's because all of the users on polygon are using some sort of private relay. Quite the opposite, actually. The way we designed the MeV system on polygon is that nobody on polygon gets to use a private relay, because as soon as someone starts using a private relay, then all of a sudden they have this direct path to validators, and they can get some transactions in that other people might not be able to see and potentially not respond to either. If you think back, I want to say it was like, roughly march of this year, there was this beacon chain exploit, the low carb crusader exploit, where a validator was able to trick some searchers, really like sandwich bots, into sending some sandwich attacks. And then the validator, the exploiter, really kind of the MeV relay and was able to get the transactions from the searchers, and then the validator back ran the transactions and just absolutely wrecked all of the sandwich attackers.
00:13:02.002 - 00:13:46.286, Speaker A: Now, I personally just think, like, great, good for him. I think it was like $24 million that were lost by the sandwich bots that were trying to sandwich someone who themselves ended up getting sandwiched. It's still an exploit because of how the low carb crusader went about getting the transactions from the sandwich bots. He or she did have to genuinely exploit and trick the MEV relay to get the contents. But the overall theme there is that sandwich attacking is a very risky thing. It's only risky if you're able to do it, or it's only riskless if you're able to do it in a safe, protected environment.
00:13:46.398 - 00:13:48.198, Speaker B: Yeah, like a private thing.
00:13:48.284 - 00:14:33.550, Speaker A: Exactly. And so what we do is we just say, no, not going to let that through. And just by virtue of not having a private relay to validators, there's two neat things that happen. First, we virtually never see sandwich attacks, because if anyone tries to sandwich attack, then the sandwich attacker will just themselves get attacked by some other bot out there in the not so dark forest. It's extremely illuminated on account of there not being any private relays and everything being public. The other neat thing that happens is private order flow nonexistent, everything becomes public. And so it's a really fascinating dynamic where it's just very different from anything you would see on Ethereum.
00:14:33.550 - 00:14:39.158, Speaker A: I'm not going to say it's better or worse. There's definitely some nuances to it.
00:14:39.244 - 00:15:21.006, Speaker B: I'd say, like flashbots kind of private mem pool was a detriment, really, because they just introduced so much. I don't know if it was unexpected or expected, but I think unexpected consequences in terms of basically just introduced guarantee sandwiching and strategies. Well, risk free sandwiches, basically, you submit a bundle for free. You're just sending an RPC call, and then if it works, it works. If it doesn't, then you don't really pay anything, right? It's not accepted. And with all the other chains, there is the inherent risk of, how do you even sandwich if there's no guarantee? And so if you miss one of the transactions in a sandwich now, you have this risk now, or you're holding a new token that maybe you didn't.
00:15:21.038 - 00:15:23.598, Speaker A: Want to or you paid swap fees.
00:15:23.694 - 00:16:05.202, Speaker B: Yeah. And I think as well with the private relaying in flashbots is block builders can then corner the market if they have the entire chain and order flow. You can set up exclusive order flow by partnering with searchers and then kind of share profits or something similar. A big trend we see now at MEV is switching to building a block builder versus actually having your own searcher. So it's like the evolution of MeV because you can basically do MeV on your own order flow. A good example is like Beaver build, for example, they run their own search, and I think it's pretty well known, the searching community, that they have their own builder and they run their own search on top of their builder. And everybody does it really.
00:16:05.202 - 00:16:15.954, Speaker B: Actually, it just makes sense. Maybe not conflicting MeV, but also MeV, because it's the exact same algorithm. You're just maximizing profit, a set of transactions. So it just makes sense. Right?
00:16:16.072 - 00:16:43.086, Speaker A: Yeah, I agree with everything that you just said. However, I would also point out that there is a counterargument to be made, which is perhaps the outside looking in. This could be construed as the major weakness of the Fastlane system. I personally don't think it's a weakness. It's something that I spent a lot of time researching before we built Fastlane. But it's one of the things that might not work as well on Ethereum mainet as it does on polygon. Although maybe it will.
00:16:43.086 - 00:17:55.722, Speaker A: I honestly have no idea. But it's the fact that in our system, where we take every transaction and broadcast it back out into the mempool, it means that no searchers can safely sandwich users and that users are generally protected inside of the public mempool from searchers. But there is one party that they are not protected from, and that is the validator itself. The validator. And this would be the argument against the Fastlane system, as I'm sort of playing devil's advocate here. The validator could themselves run a sandwich bot and they would then be in a very privileged position to do so because they alone would be able to sandwich users and capture that revenue. And if you sort of extrapolate that on outwards over a long time period, the concern is that that validator will grow stake faster because they're going to have a higher apy and they're going to be earning more mev and eventually that'll lead to centralization of the validators.
00:17:55.722 - 00:19:01.158, Speaker A: My thoughts on that concern are that on Polygon, I had already spent a year and a half searching searchers. By the way, we are a very suspicious type. You know how like, when you're playing video games and someone beats you, you're always like, oh, that guy might be hacking. It's like a common meme, right? In searching, especially on layer twos or all l ones, the equivalent of that guy might be hacking is, oh, that guy's a validator. Because it's this auto win button where you could be getting outplayed, or maybe it's vertically integrated searcher inside of a validator. And I myself was awfully suspicious anytime I lost something that I thought I shouldn't have lost. And so I spent a lot of time doing research, like extensive statistical analysis, just like looking at, okay, so for this searcher, how many of the transactions originated around the same geolocation as this validator? Just really in depth.
00:19:01.158 - 00:19:43.686, Speaker A: And because of that, I was very confident that there was not a single validator on polygon running any sort of sandwich bot. And there still isn't. However, if any of them ever start running a sandwich bot, then that is something that would be concerning. And I think at such a time, maybe we would, perhaps. I'm not going to say we would change everything, because I really do think it's really important for users not to get maximally fucked every time they do a transaction through the only decentralized propagation system. But it is something that would need to be addressed, potentially. But so far, thankfully, no validators are doing it.
00:19:43.686 - 00:19:45.670, Speaker A: So if it ain't broke, don't fix it.
00:19:45.740 - 00:20:24.430, Speaker B: Yeah, but another argument is that not everyone, not the normal people, everyday users retail, are going through flashbots when they're submitting a uniswap transaction, or even just going through anything. They're always in the public mempool. And so, like, flashbots is really just for searches. Honestly, that's really all it is, because every other transaction is open in the public mempool, because if everything was private, then there wouldn't be any MeV. And also the validators, unless you can deterministically predict you'll be selected each time, the statistics of that, and run it every time, then, given how many there are and how much money you have, maybe it's not really feasible.
00:20:24.590 - 00:21:00.782, Speaker A: Well, with that, I know for sure you can predict when a validator is going to be going on Polygon. That's a core part of our logic is predicting in advance, because the blocks are so fast. We have to know who the next validator is when we are running these auctions. But I'm pretty sure you can do that for Ethereum as well. I could be wrong. There was something else you had mentioned too, about the users, and you brought up an interesting point, and I think this is something that's really, really important, which is for users. Yeah, users do have this ability to install these custom private RPCs, Mev blocker and Mev share and like flashbots protect, which are great.
00:21:00.782 - 00:21:46.398, Speaker A: They help users. Those are good things. The problem is that the users who most need MeV protection are the users who are just probably getting ready to do their very first trade on uniswap for their life. And maybe, probably they don't even know what slippage means. Maybe they see like 2%, like, oh no, higher numbers, bigger. I'll put 100 people who are like kind of people who, they do a trade and then right afterwards they google, what does slippage mean? Those are the people that need protection. And those are people who aren't going to know that they need to go out and install some sort of like custom MEV protection system, because they don't even know what MEV is.
00:21:46.398 - 00:22:34.194, Speaker A: They don't even know what slippage is. And it's just this like catch 22 that I think is pretty brutal. I want to say roughly 15% of the MEV on, not 15% of the transactions on Ethereum come through some sort of private ofa or some sort of private relay that then allows searchers to backrun and potentially even refund the users if they generate any MEV. But if you look at the actual revenue and the actual MEV generated from these systems, it is extremely small. Like disproportionately just like tiny 15% of Ethereum transactions. That's a lot of transactions. And the MEV numbers are just puny.
00:22:34.194 - 00:22:45.650, Speaker A: And the reason why is because the 15% of users that are using these systems are the 15% of users who are sophisticated enough not to do anything dumb enough that would generate a ton of MEV to begin with.
00:22:45.800 - 00:23:11.538, Speaker B: Before we did this, we talked before about basically mev and account abstraction and how you're using it a fast lane, or at least implementing it. And you've also mentioned you've seen some new type of MEV, if you want to share that. Everybody sees MEV as this already defined as long tail, short tail, long tail. Just very random things. New protocols, long tail, obviously liquidation sandwich, and all this here, one back running. Yes.
00:23:11.564 - 00:23:12.534, Speaker A: So many different types.
00:23:12.582 - 00:23:16.300, Speaker B: So it's like, yeah, what is this new MEV you found what's the.
00:23:16.830 - 00:23:44.494, Speaker A: So this is like a genuine alpha, I think, and credit where credit is due. This was actually brought to my attention by biconomy. There is this fascinating game developing on the polygon ecosystem. This is happening live as we're recording. This has probably happened dozens of times already with account abstraction. There is this concept of a bundler and an account abstraction. Like an account abstraction bundle would be different from an MEV bundle.
00:23:44.494 - 00:24:39.042, Speaker A: An MEV bundle would be a group of transactions that are being delivered in a certain order, because they're desired to be sequenced in that order. With account abstraction, a Bundler is an entity that will go out and take user operations, which are these EIP 712 type hash signed messages. So not full transactions. The user doesn't pay any gas, but they just sign a message. If you've ever done a swap within the last year or so on Uniswap, the token approvals where you just sign the message is an example of these user operations are a little bit more specific, though, but the user experience is similar, and a lot of the cryptography is similar. But what's interesting is that these user operations, they're not transactions by themselves. They have to be put into transactions in order to be put in a block by a validator.
00:24:39.042 - 00:25:42.778, Speaker A: And in account abstraction, the bundler is the one responsible for doing that. The bundler ends up paying the gas of the transaction, but in return the user operations will usually pay the bundler back in some manner or another, either through some reimbursement of gas, maybe like a value transfer at the very end of the operation, or perhaps even in a different currency, which is a fascinating use case of account abstraction. But what's interesting about all this is that over on polygon, as we've just discussed, there are no private relays. What that means is that the only way a bundler can get one of these bundles, which really is just a transaction with user operation inside of it. The only way the bundler can get these transactions to a validator is through the mempool. And that means that other bundlers, oh no, even other searchers can see them. And so here's where it gets really interesting.
00:25:42.778 - 00:27:06.934, Speaker A: So because these transactions are public, and because the operation is what's signed by the user, the operation is really just call data. It's just like the data inside of the transaction that can just be plucked out by a searcher or on a competing bundler. And this competing searcher bundler can then take this user operation that they plucked out of one transaction, make their own transaction to bundle the operation, put the operation inside of it, and front run the original Bundler. And the reason that they would do this is if they're expecting the reimbursement from the user up for the gas to outweigh the actual gas cost. And so it's this really fascinating dynamic where it's like it's not really mev, because that's kind of how account abstraction is supposed to work, because anyone, a core tenant of EIP 43 37, which is sort of right now probably the most dominant specification for how smart contract wallets and how account traction is supposed to work. One of the core tenets of that spec is that anyone can be a bundler. And because anyone can be a bundler, that means that anyone can pluck an operation out of a bundler's transaction and put it into their own and just front run.
00:27:06.934 - 00:27:35.914, Speaker A: And so yes, we're seeing all these really fascinating priority gas auctions and other sorts of competitions between bundlers. And the real tragedy is that the original bundler ends up still having to pay their gas. Right. No free reverts. Thankfully, this is Polygon, so it's like a 10th of a penny. But still, over time, if you do thousands of these a day, it can add up. And so it's just a really interesting scenario where it's a new type of mev.
00:27:35.914 - 00:29:03.254, Speaker A: And I don't think anyone's doing this yet on ethereum main net. And if they were, they could probably use some sort of private relay. But that then begs the question of why would the validator allow a private relay if just by virtue of providing this private relay, they're lowering their own revenue? Because think about it, if these bundlers are competing, and if the winning bundler is the one who ends up with the highest gas price or ends up with the highest payment to the validator, then that's a good competition for the validator, right? Like the validator wants bundlers to be competing over who can bid the highest for these user auctions, because the validators are the beneficiaries of this. And so it's one of the long term things that I spend a lot of time thinking about what is really in the validator's best interest. And especially as more and more transactions and more and more order flow becomes private, when might it start making more sense for validators to maybe move away from enabling private transactions so that they can capture the revenue and the value from these private transactions by virtue of making everything into a public open access auction? Like that we do on Fastlane.
00:29:03.382 - 00:29:35.730, Speaker B: I think it comes down to the builders making the most profitable block, though. So how can you compete with someone that's always making the most profitable block if it's private or public? Built from either public or private. Right. And that's why flashbots recently switched to profit maximization over top of block guarantees is because they just get beat out by the people doing maximum profit. Because they all send it to the relay. Then relay sends it, basically gives the validator the option, which would always choose the most profitable one. Right.
00:29:35.730 - 00:29:39.542, Speaker B: So then there's not really any solution to that. I think.
00:29:39.676 - 00:30:21.890, Speaker A: I think proposer builder separation is a really fascinating thing, because I do think that it unlocks some really interesting combinations. I think the downside is that a lot of the neat things that you can do with PBS are currently being done through backroom deals and actual legal contracts. Yeah, I do think that there is some fascinating future with PBS. And I'm not against PBS in general. I think my major concern with PBS, and why I'm a little bit against bringing it to polygon in its current form, is that it does. To your point, it does encourage the extraction of maximum value.
00:30:21.960 - 00:30:22.290, Speaker B: Right.
00:30:22.360 - 00:31:46.014, Speaker A: Because as long as these builders are competing in an auction to make the most valuable block to the validator or the proposer, then whichever one can extract the most is going to have the most valuable block, or whichever one has the most private order flow. And so, yeah, it's this really interesting dynamic where I view it as sort of this kind of like middle layer, right? Where it all kind of flows up to the proposer, but it kind of was already flowing in that direction anyway. So I do think that there's some efficiency gains because of PBS. I just don't know that the efficiency in this context is necessarily a good thing for the users. Because a lot of times when we say efficient, what we really mean is giving users worse execution. But going back to how that plays into bundling and with account abstraction, it's fascinating, because with this EIP 43 37 spec, one of the core features is that there will be this, and you've probably heard mention of this, an alternate mem pool, which is going to be designed not for transactions, as we're used to with the regular mempool, but for user operations. And what's interesting is that, just like with transactions that end up in the regular mempool, all of the builders have access to them.
00:31:46.014 - 00:32:53.598, Speaker A: Which means whichever builder can extract the most value is the one that will be most likely to win the block auction for the proposer. But as we're looking at this account abstraction, this EIP 43 37 game of bundlers competing to see who can build the most profitable bundle, as long as all of the builders and all of the bundlers. And as an aside, it's extremely likely that those two roles will become vertically integrated in the same way that searchers and builders became vertically integrated. But as they are competing, what's going to end up happening is whichever builderbundler searcher is able to extract the most value from these user operations, that's going to be the one that ends up getting to be the bundler. And it's like inevitable. We're already seeing exactly that same thing happen with regular mempool transactions. But what's really fascinating about all this is that when you look at user operations, one of the biggest potential use case of user operations is this entire concept of intents.
00:32:53.598 - 00:33:27.034, Speaker A: And I don't want to get too deep into what an intent is, because it's just such a nebulous concept, sort of by design. It's kind of the point to keep them very broad. But the overall premise is with a transaction, you're giving a set of instructions, like a set of actions, like go to this exchange like this Dex and buy this amount, whereas with an intent, you're just giving an outcome and you're saying, hey, I don't care how you do it, I just want this outcome.
00:33:27.162 - 00:34:20.606, Speaker B: Yeah, I talked to Brooks Medley from flashbots about this on the podcast as well. And I mentioned if you have the intent right, and with the account abstraction mempool, you can do limit orders. And I think that's what uniswap X does. Maybe I'm wrong, but I imagine that's what they would do. But then there's kind of like two things you could do with this account abstraction mempool is, first of all, you can have the intent of a hack of a black hat, and someone else would execute it for you. And so does that mean the legal obligation is now on their behalf as number one? And you could do this from obfuscating the bytecode so where if they have like a custom bytecode or cold data decoder, it might not be as sophisticated as their techniques. And number two, there's all these pending transactions that change state monetarily in, let's say like some liquidity pools or a liquidation platform.
00:34:20.606 - 00:34:58.406, Speaker B: Then if you were a searcher, you would set them up. If they're already pending, you kind of set up the state, or combine it with a mem pool normal mempool transaction. Mempool transaction. And you could kind of combine them, mix and match these combinations and unlock the account abstraction transactions with the mempool ones to make like embedded mev or something similar. So those were like my two faults on account abstraction naively, but I think the black hatting one would be very interesting. Imagine just someone like executing someone's 200 million dollar hack and be like, oh well, shit, dude.
00:34:58.438 - 00:35:40.710, Speaker A: I remember, for all I know this is still out there. But there was this generalized front runner on Ethereum, and for those of you that don't know. So a generalized front runner is someone where they see a transaction in the mempool and they simulate it with maybe like injecting their own address in place of a different address. And if it makes them money at the end of the simulation, then they just do it. The premise being that they don't really spend too much time thinking about what's actually happening, they just spend time thinking about if they can do it in front of someone else. And what's interesting is that these generalized front runners have a history of accidentally front running exploits and hacks. And I remember there's this one generalized front runner.
00:35:40.710 - 00:36:13.940, Speaker A: I want to say it was one of the really big ones. That definitely wasn't me. But yeah, in their ether scan, if you went to their contract address in ether scan, they actually had like an email address, and it was like, hey, if we accidentally exploited your protocol, please send us an email and we'll refund the money. And I'm just like, I'm looking at that and I'm like, one, that's cool, right? It's a good thing for the protocols, and I'm pretty sure quite a few protocols have been refunded this way. But two, I don't imagine that's going to hold up too well in a court of law.
00:36:14.310 - 00:36:17.240, Speaker B: Hey man, just email us and we'll refund you.
00:36:18.730 - 00:36:20.390, Speaker A: It's a few hundred million dollars.
00:36:20.540 - 00:36:21.110, Speaker B: How bad?
00:36:21.180 - 00:36:24.918, Speaker A: Between an know, we're still early, we're still early.
00:36:25.004 - 00:36:27.880, Speaker B: They'll just be like, how bad? We did not mean that.
00:36:28.330 - 00:37:40.926, Speaker A: Sorry bro, it's the bot, not us. But the other thing you mentioned is actually something that is a passion of mine, and it's what we're currently working on over on Fastline, which is the combination of operations in such a way to, I don't want to say create or even extract MeV, but from our perspective, we're more interested in retaining MEV and preventing MeV leaks. As we'd been talking about before with 43, 37, and with this alternate public mem pool, as with the regular mem pool, if someone's using it, then who's going to be the bundler or the builder of their operation? Whoever extracts the most money from them. And that's just how the incentive structure is designed. And there's not really any way around it, even on Polygon, where we've, I'm not going to say solved sandwiches, but where we've made sandwiches, not a problem even there. The same thing still applies there. So what we wanted to do was build a solution that is very compatible with intents, but also still extremely decentralized, trustless and as permissionless as possible.
00:37:40.926 - 00:38:26.846, Speaker A: And we went about doing that actually using exactly what your intuition was, which is by taking user operations and also by taking searcher operations, which we're now calling solver operations, because that's apparently what searchers are going by now. Solvers, searcher solvers, same thing. And so what we do is we take these two operations and we combine them together into a single transaction. And what we then do is we allow the Dapps that the user is interfacing with. Because at the end of the day, the Dapps are the ones that control the front end. They're the ones with the real power, because they're the ones who control the call data that the user generates. They're the ones who control really what the user is going to try to do.
00:38:26.846 - 00:40:25.186, Speaker A: Everything, really, truly everything. What we've done is created the system where Dapps can create hooks, and these hooks will be in front of the user's operation, after the user's operation, in front of the searcher solver's operation, after the searcher solver's operation. And it allows these Dapps to have these guarantees at the smart contract level, like trustless, decentralized guarantees over how the user's operation is executed, because we can run these arbitrary hooks at every stage, as well as verifying things before and after the solver. And it allows just this extra layer of safety that we think is extremely valuable. What I think is even more valuable, though, just in general, broadly for the ecosystem, is the fact that thanks to account abstraction, we can actually set this up so that Dapps can have all of their users benefit from this by default. If you think back on those mev blocking rpcs, not to signal out mev blocker in particular, but just in general, you have to be fairly sophisticated to know that you need one, right? If you know what a mev blocking RPC is, you're probably not going to generate a lot of mev, but the same thing is not necessarily true here. What this system does, thanks to account abstraction, is it allows any user, even if it is their very first trade in DeFi, any user that is interacting with a front end, that is using this new system that we've developed to have not just the full mev protection that they would get from an RPC, but they can do it trustlessly and they can do it in a decentralized manner where we can even take these fully bundled transactions, we can even put them in the mem pool if we want to.
00:40:25.186 - 00:41:12.114, Speaker A: We don't even need a custom relay. And to be clear, custom relays are still awesome because they're fast and there's a lot of really cool things you can do with them, but they're not a requirement here. And so super excited about this ability to allow Dapps to natively protect their users. And just in general, like, there's so many like neat things you can do with these, like hooks, I think with hooks we think a lot about like, you know, uniswap v. Four. But in this case we're really focused on the execution style of what happens for the users. As an example, as solvers are competing to see which one of them can back run the user's transaction, not front run.
00:41:12.114 - 00:41:48.974, Speaker A: We don't want to let them sandwich, obviously, but as they're competing to see which one can backrun it, or if it's an intent, to see which one of them can fulfill the intent. Like for instance, if it's a limit order, we don't want the solver who just gives the bare minimum and then extracts the most on top of that. So like just the limit, we don't want that to happen. We want whoever actually gives the most to the user, period, to be the one that fulfills the intent. And we can do that with this system, like trustlessly. The key behind it all. And the reason why we're able to do it, is thanks to two things.
00:41:48.974 - 00:42:22.714, Speaker A: First is not permissionless. It is something that could be permissionless if the DAP wants it to be. But at the end of the day, we want to avoid a scenario like what we've been seeing on Polygon with just regular user ops, which is where whichever bundler can extract the most is the one that can end up being the actual bundler because they'll pay the validator the most. We want to avoid that type of game because that type of game is won by usually the bundler that we least want to actually bundle us.
00:42:22.752 - 00:42:23.242, Speaker B: Right.
00:42:23.376 - 00:43:34.730, Speaker A: And so by allowing Dapps to have arbitrary logic over who can be the bundler, and really by making the potential bundlers compete in this space for competition, this vector where the beneficiary is the user rather than the validator, we think that's very powerful, and we're extremely excited about it, because there's not really anything else like it right now. There are other networks that have similar, arguably even more robust systems like Innoma, which stuff like that, I think is really fascinating. And I really wish I had enough math phds to understand. Yeah. So we're super excited about all this, because it's going to take some of the really neat protections for users that everyone on Polygon has, just by nature of how we've done the mev system there, and we're going to be able to give it to everyone on pretty much all of these EVM chains. And I think that's really cool. Genuinely outcompete flashbots.
00:43:34.730 - 00:44:40.354, Speaker A: Well, that's the thing, is that we're not competing with flashbots at all. They're one of key partners here. I don't want to go too much into describing someone else's product, but suave is really fucking cool. And we are really excited about suave in particular, because this thing that we're building over at Fastlane, which we're calling atlas, really, it's fundamentally an entry point. It's a smart contract that allows for the trustless interactions between three parties, the DAP, the user, and the searcher solvers. And suave, if you think about it, is really meant more for builders to compete, right? It's a marketplace where different builders will be able to use programmable privacy and complex smart contract logic in order to compete over which one can do the most with order flow under conditions that are beneficial for the users of that order flow. So in that sense, Atlas is not competing with suave.
00:44:40.354 - 00:45:50.970, Speaker A: We're actually a source of order flow for suave. And the reason why we're particularly excited about suave is that we can actually, through the smart contract functionality and through the smart contract logic on swab, we can do some really fucking cool stuff. For example, we can send a user operation to swab, we can bundle it with solver operations on swab. We can then auction it to builders on swab. We can take the proceeds from that auction on swab, give it to the users on swab, and then take the net result of that and just turn it into a transaction. Not even like a bundled thing, just like a bare bones transaction that just has the balance, transfers and then execute that on Ethereum in such a way that it's going to be like very little gas, fully trustless, like maximal value returned to the user. And so that kind of thing is, I think, so powerful.
00:45:50.970 - 00:46:15.746, Speaker A: I think that and things like it are absolutely the future of account abstraction in general, which is where it's so abstracted that the AA doesn't actually happen on mainnet itself, but it's still all atomic, because it's all happening through this. I don't even know what to call swap. Like a roll up. It's not really, but kind of, sort of. Honestly, I don't even know. You'd have to ask the flashbots guys that.
00:46:15.768 - 00:46:18.918, Speaker B: Yeah, I've been meaning to get. Want to talk about it a bit.
00:46:19.004 - 00:46:40.582, Speaker A: Yeah, but, yeah, so we're super excited about it. I've been talking to the flashbots team a lot about it, too. They're super excited about Atlas. And our hope is that we'll actually be the very first. They're using the term suap. I'm not sure if I'm the biggest fan of that, but if it sticks, it sticks. So, right now, we're tentatively hoping that we'll be the very first suap.
00:46:40.582 - 00:47:31.146, Speaker A: Because there's just like, not only can we protect the user from harmful Mev, it's like all of a sudden even just things like gas rebates and just making the builders auction, making them compete just to get. There's just so much cool stuff you can do with programmable privacy and programmable smart contract logic, that just really just turbocharged the intent layer. And so, yeah, no, we're absolutely not competing with flashbots. They're key allies. Now, I will say that the one downside of suave, and this is a pretty big downside, is that it's slow. Right now, I think the block times are roughly 3 seconds. And that might not seem like a long time, but it kind of is.
00:47:31.146 - 00:48:27.914, Speaker A: But whether or not the 3 seconds matters, I think, depends a lot on what the user is trying to do. It also depends on what chain they're rolling up to. Because if they're rolling up to Ethereum, then it's probably not a big deal. Maybe the user needs to get a guarantee back from a builder instantly. And so for cases like that, maybe a system like blocksroute, that really prioritizes just like ultra fast response times, and just really fast communication, maybe something like that would be more ideal. It really depends on what the DAP is targeting for the user experience and for what we're building for Atlas, we don't want to be prescriptive about that. And I know paradigm just released like a piece a month ago, like arguing the exact opposite, but they don't want there to be too much fragmentation of operation pools.
00:48:27.914 - 00:49:30.210, Speaker A: I personally think that the infrastructure choices are important, and I think that those infrastructure choices can have a huge impact on the user experience. Something like suave, you've got a high level of potential value transfer, you've got programmable privacy, something like blocksroute, you've got speed, something like lit protocol, you've got genuine decentralization, something like Pemlico. You've got some really cool stuff you can do with paying for gas and other currencies. There's just like so many different potential infrastructure providers. And for us, for Fastlane, as we're building atlas, we don't want to be prescriptive over what type of user experience the DAP should have. And so our approach to this is just for us to go out to Dapps and say, hey, there's a lot of different choices you guys have here. You can pick programmable privacy, you can pick fast, you can pick decentralized, you can pick paying gas in a different currency.
00:49:30.210 - 00:49:59.706, Speaker A: It's up to them. And so to that end, we're not planning to make an infrastructure system of our own. We're just planning to be maximally composable with all of the different ones, because most of them are really cool. We even want to be composable with some of the intent specific infrastructure systems that are being developed. Like, I think Banana's got like one that we're super, super excited about. Yeah, Banana HQ is a. I don't even know how to classify them.
00:49:59.706 - 00:50:18.802, Speaker A: It's like an intent network that they're working on that is very account abstraction focused as well. Really cool solving, but with an EVM lean to it. I don't believe it's one of those intent systems where you have to learn an entirely new language just to use it.
00:50:18.936 - 00:50:22.818, Speaker B: Yeah, the UX and onboarding is just too much.
00:50:22.984 - 00:51:49.194, Speaker A: Yeah, that's one thing. I genuinely think that a lot of these intent systems that are out there are clearly being run by Giga brains. But if you think about what they're trying to do, what are some of these intent systems trying to accomplish? Well, they're trying to get a system where the users can cross match each other and really just have amazing execution quality, which means the better the outcome for the users, the worse the potential for profit for the solvers. And so when I think about it from the point of view of being someone who spent two years leading an mev team and then two years working on an mev protocol myself, and for the last year, we've been working on atlas, which is, for all intents and purposes, also an intent, a very lightweight intent structure. I feel like I've got a pretty good understanding of, I've got a pretty good background for being a solver in one of these networks, right? And it's like, when I'm making the decision, like, should I start solving on one of these networks? It's like 01:00 a.m.. I going to be able to make any money doing it. And if the entire point of one of these intent networks is to not let the solvers make any money by giving the most value back to the user, then that's a little bit discouraging.
00:51:49.194 - 00:53:47.190, Speaker A: And then I have to weigh this in the context of, is there a lot of order flow? Are there a lot of actual intents being sent over there? And then most importantly, what's the infrastructure and what is the learning curve? Am I going to have to spin up a whole bunch of new nodes and new systems, and am I going to have to learn an entirely new programming language and perform all new security audits and redo all of my market making code? Because maybe this new intent system only wants to run inside of a certain enclave with a certain. It's friction, not necessarily for users, but for solvers. And I think that the interesting thing with intents is that solver friction is sort of passed on to the users. Right? Because if there's a lot of solver friction, then solving is not going to be very competitive. And when solving is not competitive, then the users don't get a very good outcome, and that then leads to a bad user experience, and it leads to fewer users, which leads to less order flow, which leads to fewer solvers being interested in competing. Yeah, it's this pretty gnarly cold start problem that can arise with intents in general, I think. And for us at Fastlane, one of our main advantages in this space, probably our biggest advantage in this space, is the fact that we're the only company in the world that has experienced going through building out a network of searchers, solvers, same thing, who are used to dealing, not with just sending transactions to a relay, but with making transactions that are really operations at the end of the day, that are nested inside of and calls to an entry point contract which is how our mev system on Polygon works.
00:53:47.190 - 00:54:18.750, Speaker A: And so we've been talking to a lot of the searchers there. They're super interested in using the Atlas system and fulfilling intents, or even just back running. Honestly, they'll take whatever they can get. I think the polygon system are super excited to come to Ethereum. I think they're super excited about it. And the main thing is that this atlas system for them, almost exactly the same in terms of how to integrate it into their own searcher smart contracts as the fast lane on polygon system is. So it's like very little actually is changed.
00:54:19.330 - 00:55:00.414, Speaker B: What do you think about monetizing order flow? I don't think you can really do it on polygon or anything other than Ethereum or maybe. I don't know about the block building situation on polygon, but obviously if you have monopoly on block builders like Ethereum, there's only like four that really control it all. I think it's like Titan R Sync Beaver. And there might be one more. I don't know who it is though, but they're like the top three really. And obviously they can really monetize order flow, right? Or even RPCs as well, actually, because all the order flow is going through them. So, yeah, I wonder what your thoughts on that are as well.
00:55:00.532 - 00:55:58.814, Speaker A: It's a really good question. I think it depends a lot on the network topology and the architecture on polygon. Order flow is pretty much worthless to anybody just because of the fact that everything always goes in the public mempool. So all of that goes to the validator no matter what, which is by design. That's like a good thing in that it prevents sandwiches, but it's also a bad thing in that it prevents user rebates in the event that a user does an extremely inefficient swap. So pros and cons, pros and cons. But when I think more to the order flow market outside of polygon, if I look at some of the ecosystems where I'm more of an observer than someone with the power to impact it, one of the first things that comes to my mind is that at the end of the day, and I think you had mentioned this earlier too, it's all the front end.
00:55:58.814 - 00:56:16.726, Speaker A: The front ends are the very top of the food chain. And I think that using account abstraction and using atlas, and I'm sure other systems will pop up too, that do something similar. Front ends are able to.
00:56:16.828 - 00:56:29.218, Speaker B: I feel like RPC providers are above that. Whatever the default one is for metamask, especially the default one for metamask or any wallet, I think they really control it all, not apps.
00:56:29.314 - 00:57:27.878, Speaker A: I would disagree there, but I also think that a lot of people think along the same lines as you do. So, and let's actually use the specific example of metamask and infuria, because I think that's probably where the majority of the valuable order flow is. So metamask does this thing. It's a very interesting thing because it's had a very profound impact on the order flow market. And what this thing is, is that anytime somebody signs a transaction with their metamask wallet, metamask will immediately propagate that transaction to the RPC that that user has selected. And what this means is that if you are a frontend and you want the user to sign a transaction, then you can't then take that signed transaction and try to do anything exclusive with it, because as soon as it's signed, it just goes off to the RPC, which is probably infura, because infura is the default RPC for metamask. And that's great, because infuria and metamask both owned by consensus.
00:57:27.878 - 00:58:01.202, Speaker A: So that is the driving force behind how a lot of things were. But that is only relevant for transactions. That is not true for operations. So with operations, what we have is the ability for the DAP to have the user sign this EIP 712 type message. The user signs it using their metamask wallet. But it's just an operation, it's not a transaction. It's not going to get propagated anywhere, which means the front end can hold on to this operation.
00:58:01.202 - 00:59:05.574, Speaker A: The front end can then take it, maybe nest it inside of another actual transaction that includes the mev capture. In our example with atlas, it would be a transaction that includes both the user operation that was signed using the user's metamask wallet, as well as solver operations that are transmitted in via some sort of relay or even compiled on a chain like suave. And we're able to build this full transaction so that by the time the user is signing it, the MEV has already been captured. And captured isn't even like the right word. I think retained is the better word, because in this sense, we're actually locking in the MEV capture before the RPC even knows that the transaction exists. And so I like to tell people, let's say that the user isn't using inferior, let's say that this is a sophisticated user, and they've got mev blocker as their RPC, but the user is interacting with a front end that uses Atlas. Atlas searchers will get the first dibs on the MEV.
00:59:05.574 - 00:59:46.674, Speaker A: Mevlocker searchers will get to pick up any leftovers. And with Atlas there really aren't a lot of leftovers because we allow and encourage really multiple searchers, solvers to submit operations. And it's this really interesting dynamic. And really this is where account abstraction comes in because we couldn't do this before account abstraction. Before account abstraction, the user was signing the transaction and then poof, off it goes. The front end can't really have any way to retain the value. But with account abstraction and with the ability to bundle operations into a single transaction before the transaction is even signed, we now have the ability to capture the MEV.
00:59:46.674 - 01:00:23.762, Speaker A: And again, capture is the wrong word. Retain the MEV upstream of the RPC and there is nothing that the RPC can do about it. There is nothing that the builder can do about it other than censor it. But let's game that up. If the builder censors this transaction, they're not just censoring the solver op or the searcher op that captures the MEV, they're also censoring the user op that creates the MEV to begin with. And so they're in a situation where a builder who censors the transaction, for starters, are going to have one less transaction than all their competitors. So that's not going to be super great for them.
01:00:23.762 - 01:01:34.954, Speaker A: The other thing though is it kind of begs the question of, well, what if this transaction is a swap intent? And what if the builder happens to be Beaver builder? And what if the filler on the swap happens to be SCP, which may or may not be affiliated with Beaver builder? And in that situation, there might be an incentive for the builder to censor the full transaction, not because they want to capture the MEV, but because they just don't want to actually do the swap because maybe the price moved against them on a centralized exchange somewhere because they're a market maker. And there are some interesting sets of incentives that develop around this. And the way that we have built around that with Atlas is we don't just have one searcher solver sending in the operation. And our overall goal here with Atlas, and it's actually like fairly straightforward, literally, we just have the solver operations sorted based on whichever one bids the most. And we just try catch. It's a for loop and a try catch just going down the list. Each of the solvers has to escrow gas ahead of time.
01:01:34.954 - 01:02:31.766, Speaker A: So that if their solution, if their operation does revert or fail, the user doesn't end up paying for it. I mean, the user doesn't end up paying for it. Either way, in this case, we don't want solvers to be able to gas attack or vampire attack each other. So the solvers do have to escrow gas, and if they do revert, then they still have to pay the gas. So in a way, it's kind of a return to the old school days, like back when everyone was doing a PGA. But the overall idea here is that we want to make it so that for builders, their profit maximizing play isn't to censor the full transaction, it's just to censor their own operation. So if you look at, like, let's know, Beaver builder, if the Beaver builder, SCP market maker was the number one highest biding solver, then we want it to make it cheaper for them to just censor the number one solver operation, presumably through just some flag in their own smart contract that they can just like, hey, 21k gas.
01:02:31.766 - 01:03:37.886, Speaker A: Maybe another like, flip a storage script or something, like, hey, there's 40k gas. And all of a sudden our switch is flipped and our operation reverts. And so then the Atlas transaction will just keep looping through the operations and go on to the next one, which is presumably, which will then not be censored by the beaver builder SCP because they're competitors. And meanwhile, the winter mute builder, same situation. They might want to censor their own operation, but they're not going to want to censor the SCP Beaver builder operation. And so as long as there's this competitive dynamic between the builders, and as long as we are submitting multiple solutions, like multiple search or solver operations, and as long as it is cheaper for an individual builder to censor just their operation than it is for them to censor the entire transaction, we're very confident that we can have a really good outcome for the user. In a way, it kind of turns into this, like, reverse engineer a second price auction.
01:03:37.886 - 01:04:27.294, Speaker A: In a sense, if you assume that the winning builder is going to place value in winning the block just so that they can censor their own operation, in a sense, it does come about where we run into this second price type auction, where we get like, second price, but also the second fulfillment. But that's not bad for the user. That's still really fucking good for the user. And then you add in something like suave, and we don't even have to worry about that, because on suave we can just do the whole thing with smart contract logic. There's so much cool stuff that we can do, but even if we don't want to do anything cool, and we just want to use the regular public, public mem pool on Ethereum, we can. And I am very very happy about that because I genuinely think that users being able to use the public in a decentralized manner, I don't know, I think that's pretty cool and I'm super excited to be able to bring that to Ethereum.
01:04:27.422 - 01:04:53.162, Speaker B: I wish it was all decentralized like the old dark forest days, but it's just the world we live in now I find unfortunate, but is what it is. If someone does a hack, they'll just go through private vempool if they're smart enough. It kind of eliminates live vulnerability or exploit detection to a degree, depending on how good they are. If they are good, they would obviously go through private and mask their ip. But most people aren't doing that, though.
01:04:53.216 - 01:05:09.050, Speaker A: I've always been fascinated by that because it does seem like a lot of extremely sophisticated hacks just have very poor understanding of the mev supply chain. It's like an interesting little paradox where in my mind when I think exploiter, I think super sophisticated full stack.
01:05:09.130 - 01:05:28.694, Speaker B: But no, that's just usually like some teenager that just submits to public mempool and then gets front ran or somehow gets through. It's a bit weird. I don't know how, but it happens. Why they go through public mempool? This doesn't make sense. Maybe they just don't think about it too much. They're just kind of playing around with the protocol and testing and like, oh, I make money. Whoa, okay, let's do this.
01:05:28.812 - 01:05:31.960, Speaker A: Mom, I just accidentally. $200 million.
01:05:33.290 - 01:05:51.398, Speaker B: That's actually, I think, what happened with the Yula guy, he was just like testing with the protocol and kind of found it and then, well, prison. Whoops. Yeah, and he's not that old either, so yeah, I think it must be like these naive young folk and then the actual expert nation state, like North Korea, Lazarus, whatnot.
01:05:51.494 - 01:06:11.394, Speaker A: The funny thing is, if I think back on how I acted and just in general how aware I was of this kind of thing when I was 15 or 16, I can't help but think that if I had actually known how to code at that age, I would have done the exact, I would have done something just as stupid. I would have been like, hey, here's this thing that I can do. So I'll just do it, don't think.
01:06:11.432 - 01:06:20.726, Speaker B: Of any of the consequences. And you're like, oh, well, shit, now I'm in prison, it just sucks for them. Damn. Kind of out in the way I'm feeling. There's an argument to be made though.
01:06:20.748 - 01:06:26.738, Speaker A: That when they get out of prison, it might look good to some potential employers. On a resume.
01:06:26.834 - 01:06:42.938, Speaker B: Oh yeah, on the resume, maybe one or two, yeah. Found 200 million dollar hack on protocol. Like, damn, went to prison because of it. Yeah, okay, hire me, bro. But then again, it's like, I probably wouldn't hire you if you did an exploit on a protocol. They would think you would do it on their protocol. Maybe.
01:06:42.938 - 01:07:13.494, Speaker B: But maybe the occasional lesson learned, the occasional open minded employer would be like, oh sure, this is kind of based, I wouldn't my team go work for a different exploiter? No. But yeah, man, it's been great chatting, and I'm keen to see how Atlas comes out to fruition and how it kind of changes everything. Even suave as well, how all these new systems play out. I'm keen to see how the ecosystem evolves and hopefully doesn't get completely destroyed by regulatory stuff. That wouldn't be too fun.
01:07:13.532 - 01:07:15.366, Speaker A: Yeah, that's a whole thing, isn't it?
01:07:15.468 - 01:07:25.178, Speaker B: Yeah. Even like the ZK ecosystem, it's going to be a tough one. Imagine like ZK, private public mem pools with account abstractions like triple mem pools. That'd be pretty fun.
01:07:25.264 - 01:09:00.550, Speaker A: Yeah, it'll be interesting too, because a lot of that stuff with ZK, you have this latency element to it, where especially with some of the encryption, you're not necessarily preventing MEV, you're just delaying it and limiting who can access it, which is one of the interesting things there, is that it sort of precludes the ability to divert and redirect the MEV back to the user if you disrupt the atomicity between the mev identification and the mev capture, which is, I think, what a lot of the encryption stuff does, the exception, and this is something where I genuinely, like, I just found out what this word meant less than a month ago. But one of the things like intrigued by is the potential for something like fhe to maybe change that and allow searcher solvers to actually have this MEV capture and then return while still having a fully encrypted mempool. And in a sense, suave does that as well, in a slightly different manner, I think using like, SGX, which is also something that I didn't really know too much about until relatively recently, but I do think there's a lot of interesting developments in that space and what I'm most intrigued by is how a lot of them unlock features of the others where it's like just an encrypted mempool. Not a fan. I don't like it. Just like SGX. I mean cool, but it's like once you start combining a lot of these things together, then you start to unlock atomicity and diverting the value and posability and I think that's really cool.
01:09:00.550 - 01:09:04.198, Speaker A: Super excited to see how all of that pans out.
01:09:04.284 - 01:09:13.626, Speaker B: I'm keen to see how it all evolves, but it's going to be weird. A lot going to happen in a year, so we'll see. Hopefully atlas changes everything, same as suave, but who knows.
01:09:13.738 - 01:09:14.538, Speaker A: Hopefully.
01:09:14.714 - 01:09:19.374, Speaker B: But until then I think we'll probably have another episode when that happens later down the road.
01:09:19.412 - 01:09:21.070, Speaker A: Anyway, I'm looking forward to it.
01:09:21.140 - 01:09:25.854, Speaker B: Oh yeah, same. But in the meantime, thank you so much for jumping on. Really appreciate your time.
01:09:25.892 - 01:09:27.438, Speaker A: Alex, thanks for having me.
01:09:27.524 - 01:09:29.950, Speaker B: Of course. And we'll probably have you later on.
01:09:30.020 - 01:09:30.700, Speaker A: Can forward to it.
