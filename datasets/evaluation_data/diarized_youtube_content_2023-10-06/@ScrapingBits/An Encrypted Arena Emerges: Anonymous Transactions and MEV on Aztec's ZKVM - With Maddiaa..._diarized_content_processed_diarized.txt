00:00:00.650 - 00:00:25.560, Speaker A: You do the private execution on your device and then you send it to the sequencer and the sequencer will take care of all the public stuff. What happens when the sequencer does all of the public stuff? It can't webhook back to your phone and say, this happened as a result of executing your public function. Now, I do this because then you've linked the two together completely. But your public function can create commitments and you can spend those commitments private quickly.
00:00:26.890 - 00:00:34.342, Speaker B: GM. GM, everyone. My name is Tagarchi, the host of Scraping Bits, and today I'm with a person named Madaya. How's it going?
00:00:34.396 - 00:00:39.260, Speaker A: Hey, guys. How's it going? Nice to be on here. Nice to be on this side of the chair, I guess.
00:00:39.630 - 00:00:43.580, Speaker B: Yeah, nice to have you on. From the Hoft discord to now friends.
00:00:44.270 - 00:00:45.980, Speaker A: Quite a journey. Yeah.
00:00:47.070 - 00:00:51.534, Speaker B: Maybe just for some background. Introduce yourself. Who are you and what do you do? Yeah.
00:00:51.572 - 00:01:15.140, Speaker A: My name's Medaya. I work at Aztec. Currently, I'm working on the team focusing on building the Node. Sometimes I stretch myself into Noir, which is a domain specific language for writing ZK circuits. I also spent some time doing some open source stuff, mainly like Huff. So I currently maintain Huffrs. Not a whole lot, but I do.
00:01:15.140 - 00:01:29.000, Speaker A: So my whole path has kind of just been getting Nerd sniped into Huff and then getting Nerd sniped into ZK. And then I'm here and I have a job. That's what's happening. Nice.
00:01:29.450 - 00:01:33.386, Speaker B: So what were you doing before? Basically Aztec and this Huff stuff?
00:01:33.488 - 00:02:21.030, Speaker A: Yeah. Well, I suppose it makes sense to talk about how I got into Web Three in the first place. So I had a friend who was very well, he introduced me to this stuff. So it was D Five summer and he was kind of showing me all this kind of yield farming stuff. And I was like, well, this is pretty weird and interesting. Sign me up. So I did a lot of research about it and then find myself I was currently at the time in my last year of university or just going into so I found myself a professor who knew a decent amount about Blockchain and asked him if I could do a thesis project with him, if we could kind of dive into DeFi or any kind of open questions there are in Blockchain.
00:02:21.030 - 00:02:53.422, Speaker A: Well, specifically ethereum, because that's what I've been spending a lot of my time on. So I ended up working with him on some kind of cryptography based stuff, like kind of social recovery wallets before they became a thing. It's kind of what we worked on. But my friend who introduced me to the whole DeFi sphere started working on mevbots for his thesis. So he was working on triangular arbitrage. And this was like at the beginning of DeFi summer. So I spent a lot of my time with him just kind of diving down that rabbit hole.
00:02:53.422 - 00:03:38.254, Speaker A: And then I got very interested in kind of ethereum infrastructure in general. So then whenever I finished uni myself and him and some random person we met in the flashballs discord, who we'd never met before, we moved to London together and started, like, a node company, Validators. And kind of the whole the whole idea was that we wanted to have some kind of Mevaware infrastructure for Validators. But then obviously Mevboost came out and that was literally a lot better than what we'd been working on. So we kind of packed up the shop there. And then I started just kind of doing a little bit of side projects here and there, just kind of working on whatever we could. And then that's when I spent a lot of time on Huff.
00:03:38.254 - 00:04:02.010, Speaker A: And it was actually at that first company where I met, like, a mentor who introduced me to Yule because he'd been writing a lot of nice Bots. And, yeah, that's kind of where I got nerd sniped into the whole optimizing EVM contracts and that world. Then that's how I ended up doing the Huff stuff and by extension, the Aztec stuff.
00:04:02.080 - 00:04:08.074, Speaker B: Yeah. So did they reach out when they saw you doing Huff stuff, or did you kind of reach out?
00:04:08.192 - 00:04:43.926, Speaker A: No, what happened with the Huff stuff is that I applied for the Paradigm Fellowship and then got lucky and got accepted into that, and then they introduced me to Aztec. But then what was that like? That was good fun. Yeah, it was just kind of like just a week of just brainstorming, really. Just workshops and just hanging out, talking about stuff like you imagine just what a general conference vibe is like in general, or like a hacker heist kind of thing. And we just kind of discussed what could you build, what should you build?
00:04:44.028 - 00:04:44.680, Speaker B: Right.
00:04:45.210 - 00:05:20.980, Speaker A: It was interesting. It was really fun. And then yeah, so I did that, and then they kind of introduced me to the Aztec people. But I kind of, in my own time, did a hackathon project where I was like, oh, you could do governance, like private governance through the Asset Connect product. So I built that and then did it at a hackathon, and then they reached out that way as well. So I went formally through the hiring process and then did the hackathon under this pseudonym. And then they reached out to my pseudonym, and then I was like, oh, yeah, we're the same person.
00:05:20.980 - 00:05:25.602, Speaker A: That was, oh, okay.
00:05:25.736 - 00:05:30.754, Speaker B: And you didn't know anything about ZK before joining this? You only really knew about node development.
00:05:30.802 - 00:06:02.410, Speaker A: Because the Mev not exactly. So I came across ZK for the first time whenever I was doing my thesis, me and my professor kind of discussed it briefly as a possible solution to what we were trying to do, just to explore it. But then we both came to the conclusion that it was a bit too deep for where we were at at the time, but across that we discussed, that was when I first came across Plonk and Zach Williamson.
00:06:02.570 - 00:06:03.134, Speaker B: All right.
00:06:03.172 - 00:06:03.326, Speaker A: Yeah.
00:06:03.348 - 00:06:03.882, Speaker B: The creator.
00:06:03.946 - 00:06:43.962, Speaker A: Yeah. So then whenever I started, like, I saw Huff again, I was like, oh, shit, this is the same guy. What the fuck? They're like, completely different veins. Industry. And I was like, for me, he's popped up again. And it was actually at that point when I started doing a lot of I started upscaling again in cryptography. I did the Crypto 101 shit when I was doing my thesis, but I kind of restudied all that and then started kind of looking into how does smarts work? So I'd already kind of done a lot of that stuff, and I'd written a lot of Circum and stuff before I joined Aztec.
00:06:44.026 - 00:06:48.778, Speaker B: But you didn't do, I guess, Validators, did you? You just did kind of like nodes.
00:06:48.874 - 00:06:51.098, Speaker A: No, we were doing Validator infrastructure.
00:06:51.194 - 00:06:52.718, Speaker B: Oh, you were as. Oh, okay.
00:06:52.804 - 00:07:00.322, Speaker A: And that was good fun. I really enjoyed that. That company was great because there's like six or seven of us and we were just hacking on stuff.
00:07:00.376 - 00:07:02.834, Speaker B: Did you ever sell it, or was it just kind of so we had.
00:07:02.872 - 00:07:15.766, Speaker A: Stuff in production, but we never sold it or anything. It was pretty small scale. We had, like, one investor whose money we put into stuff, but it was never that big, I guess.
00:07:15.868 - 00:07:17.814, Speaker B: What happened to the investor's money?
00:07:18.012 - 00:07:18.950, Speaker A: Pardon?
00:07:19.530 - 00:07:22.474, Speaker B: What happened to the investor's money? Do you end up giving it back?
00:07:22.592 - 00:07:29.258, Speaker A: We did a lot of other mercenary work where we got paid enough that we got covered our costs okay.
00:07:29.344 - 00:07:38.480, Speaker B: Because I've never received money from a startup, and I'm sure some other people haven't. So if you get investor money and then it doesn't work out, what happens?
00:07:39.250 - 00:07:50.882, Speaker A: What usually happens is it's just their loss. But we ended up on pretty good terms where we'd earned enough money from just doing stuff that there was no real deficit whenever we closed up.
00:07:50.936 - 00:07:56.482, Speaker B: Got you. Yeah. I guess you can basically just leave and be like, oh, we lost it.
00:07:56.536 - 00:08:01.494, Speaker A: Yeah. Literally. It's like a sunk cost. They take on that risk, I guess.
00:08:01.532 - 00:08:07.960, Speaker B: When do you even decide to take on investor money as well? At what point are you like, okay, I need money?
00:08:08.570 - 00:08:09.910, Speaker A: The very beginning.
00:08:11.370 - 00:08:13.890, Speaker B: Oh, really? I guess you have to cover costs.
00:08:13.970 - 00:08:18.658, Speaker A: For hire people or any of this stuff. You need to raise some funds.
00:08:18.754 - 00:08:19.882, Speaker B: And we were lucky.
00:08:20.066 - 00:08:33.742, Speaker A: For most of us, it was just from friends and family of the guy we moved to London for. So it was like he has some pretty rich friends who kind of funded the whole thing. Well, that's fun. It was a good yeah.
00:08:33.796 - 00:08:41.570, Speaker B: Yeah. So how was the transition getting into then? Like, how did it really start, the process of kind of getting hired?
00:08:42.070 - 00:08:46.040, Speaker A: It was a lot of interviews, I guess. I think there were six in the end.
00:08:47.130 - 00:08:48.200, Speaker B: Oh my God.
00:08:49.050 - 00:09:06.122, Speaker A: But the hiring process isn't that daunting anymore. It was a bit more whenever I joined, but it was just like classic chat coding interview and then solidity coding interview, architecture interview presentation on something that you're interested in, stuff like that.
00:09:06.176 - 00:09:12.490, Speaker B: Got you. And what really is a ZK virtual machine or I guess like Aztec's equivalent.
00:09:12.650 - 00:09:49.946, Speaker A: Okay, hard questions. So what Aztec is building right now is like a private and public state roll up. So the whole idea is that you have two different execution environments. So you have one which operates solely over private state and that has like a UTXO model for representing state updates. And then you have also attached to it is the public state model. And that's just like your classic accounts on Ethereum. So you have kind of two environments that weave into one and they can orchestrate with each other and the reason why there are two.
00:09:49.946 - 00:10:48.246, Speaker A: Just to take it back to the basics. If you imagine you have an account on Ethereum and it sits in an ERC 20 contract somewhere and it has a balance of like 20 ETH or whatever, or like 20 tokens, if you in any transaction later on, update that same state, then you can link the two transactions together, even if you don't know who the sender is. So if you have an account based model, you can pretty easily tie transactions together. And that is why you need this kind of UTXO model. So if you just kind of take the approach where I'm just not going to update the same piece of state twice. If I have new state, I'm going to create new state and I'm going to then have some way of telling the people who know about that state that it's been changed or updated by having this thing that we call nullifiers. Yeah, this was pioneered by Zcash.
00:10:48.246 - 00:11:28.058, Speaker A: And the whole idea is if you don't want to link state together, just don't update it. If you want to make sure that you can't double spend the same state, if you want to spend the state, you create a nullifier. And the way a nullifier is created is usually like a hash of the information plus some deterministic secret. Like maybe it's the account's private key or something so that the next time you try and spend it, you can see that this nullifier already exists in the tree. But unless you know this private key, you won't know which nullifier links to which piece of committed state in the first place. So you don't actually leak anything to anyone else. That's kind of how it works in a way.
00:11:28.058 - 00:11:32.940, Speaker A: It's the same way tornado works. It's kind of the model we've fallen into.
00:11:33.870 - 00:11:41.454, Speaker B: Yeah, it's basically like a blockchain using a tornado kind of a protocol, I guess.
00:11:41.652 - 00:11:54.766, Speaker A: Yeah, sort of. I don't want to say that. No, it's not. You can have private state and anything so it doesn't have to be like transferred it can be literally anything and.
00:11:54.788 - 00:11:58.658, Speaker B: The way that it's private is because it doesn't update both states because you.
00:11:58.664 - 00:12:02.082, Speaker A: Can'T reliably link transactions together got you.
00:12:02.216 - 00:12:06.040, Speaker B: And I guess how do you they can't look in the node and do anything?
00:12:06.490 - 00:12:48.194, Speaker A: No, because if you look at the commitments that are being created and added, all of them are just hashes. What actually happens is what gets stored in the state. Trees are just commitments to values. And then you, through either an external channel, can communicate the pre image of this commitment to somebody else. So let's say that the value I've sent is like 100 die, and I've sent it to address zero XA. Then I can encrypt that piece of information and broadcast it with my transaction. And then the person who's meant to receive that information can decrypt it.
00:12:48.194 - 00:12:58.022, Speaker A: Or I can just not emit anything. I can just text the person and say, I've sent you this amount of money. Here's how you can create the commitment so you can spend it.
00:12:58.076 - 00:13:03.558, Speaker B: When you say broadcast together, wouldn't they both be broadcasted publicly then?
00:13:03.644 - 00:13:06.440, Speaker A: Yeah, but it's an encrypted piece of information.
00:13:06.970 - 00:13:07.590, Speaker B: Got you.
00:13:07.660 - 00:13:11.102, Speaker A: So you don't actually see what has been broadcasted.
00:13:11.186 - 00:13:17.450, Speaker B: And then this is what basically allows anonymity within public blockchain.
00:13:18.350 - 00:13:19.526, Speaker A: Everything's encrypted.
00:13:19.638 - 00:13:23.390, Speaker B: Yeah. So you have a public mempool and basically a private one as well.
00:13:23.540 - 00:14:08.822, Speaker A: And the reason behind that is if you look at kind of any useful application in DeFi well, you need something that's public to kind of verify. So imagine you have a pair on a Dex, let's say it's like east and Dai. You need to know that there's liquidity in that pool. You need to know what the price is at that point in time. Those are public state. So if everything was private, you couldn't reliably trade into that pair and know that you're not going to slip massively or I don't even know if you could in the first place. You need something public to kind of you need to leak some information to make an app usable.
00:14:08.822 - 00:14:14.510, Speaker A: And the whole idea of SEG Three is that you can do that and you can still have parts of it private.
00:14:15.410 - 00:14:20.666, Speaker B: Since there's two different mempools, I wonder if there's mev on both mempools.
00:14:20.778 - 00:15:08.910, Speaker A: So it's actually technically one transactions. What it looks like from the outside world is the private part of the transaction actually happens on a user's device. So there's no mempool for that whatsoever. So if I have state I want to update and it's private state, so only I know about it, then I can just create proofs of the transactions that I want to make on my local device and then send those. It's only if I want to update public state that those transactions need to be ordered because you have race conditions over what public state you're actually interacting with. So let's say that for private state, I'm not going to be spending somebody else's tokens. I'm not going to be spending a group of tokens, I'm just going to be spending mine.
00:15:08.910 - 00:15:52.922, Speaker A: But if it's public state, then maybe I'm changing weights in a pool that multiple people can change. Or maybe I'm trading in and out of token pairs or whatever. So what you actually do is you execute one part of the transaction on your device. You then send with it a transaction payload for like if you want to include a public transaction after that you can submit them together and have the mining of your private transaction depend on the public transactions output. Or you can just submit a private transaction where it'll just get included. You bid for it as you want or you can submit a public one where people can see what's going to happen. So they all go through the same mempool, but some have different outcomes.
00:15:52.986 - 00:16:00.254, Speaker B: Right. So if I want to do a private transfer to you, I could do this as like an encrypted transaction, right?
00:16:00.452 - 00:16:07.058, Speaker A: Yeah. You send one proof to the network and that's right.
00:16:07.144 - 00:16:08.306, Speaker B: So it's just sending the proof and.
00:16:08.328 - 00:16:14.850, Speaker A: That'S the proof and new commitments or whatever nullifiers you've created and then they just get sequenced.
00:16:15.750 - 00:16:42.330, Speaker B: Then can you see, I guess like the state of contracts as well, the public suit or private suit, I guess it's public. Like, let's say there's an ERC 20 balance of that's public, right. Let's say I transferred 100. The only thing changing is who that is going to but wouldn't you still be able to access that through that function of checking balance of your address?
00:16:42.480 - 00:16:48.510, Speaker A: So if you were trying to see the balance of somebody's address and it was in private state, you wouldn't get anything back.
00:16:48.580 - 00:16:52.000, Speaker B: Okay, so I'm assuming something like an ERC 20 would be public state.
00:16:52.470 - 00:17:09.080, Speaker A: Yeah. So you could have some of the contracts happens in public, like all the minting happens publicly, but then somebody shields those and then got you private. You don't know where it is?
00:17:11.370 - 00:17:19.478, Speaker B: Yeah, because I'm just thinking how would I guess tracing exploits work question, that's the issue.
00:17:19.564 - 00:17:28.490, Speaker A: So if you have a bug in your private contracts where you can inflict like have an infinite span bug, it's very unlikely that anyone will know.
00:17:28.560 - 00:17:31.534, Speaker B: But if it is a public state, like the ELC 20 yeah.
00:17:31.572 - 00:17:41.226, Speaker A: So if they withdraw it, if you require them to unshield it to do anything with it, then okay, so it's.
00:17:41.258 - 00:17:43.422, Speaker B: Like a new function kind of thing.
00:17:43.476 - 00:18:09.970, Speaker A: That well you could have this so that you can design it in whatever way you want. But let's say you're some kind of like you say you're USDC and you're pretty strict in the rules of using your token. You would probably have some kind of unshield before you bridge it kind of thing. In that case, then maybe you would see it. When it comes into public state, you would see it. But anything that happens in private is private.
00:18:10.050 - 00:18:15.994, Speaker B: So is this private and public kind of shielding done at like the contract level or the transaction level? I guess.
00:18:16.032 - 00:18:18.330, Speaker A: So it's all contract, so it's all programmable.
00:18:19.470 - 00:18:22.480, Speaker B: Okay, so it's like a new opcode, I guess.
00:18:25.330 - 00:18:26.720, Speaker A: Yeah, for sure.
00:18:27.810 - 00:18:45.650, Speaker B: Okay, interesting. And I guess why would someone want to make something private if it's, let's say, a uniswap fork, but they want to make it a private dark pool kind of thing? Why would someone want to do private if there's the potential of getting hacked and nobody knowing?
00:18:46.330 - 00:19:30.260, Speaker A: Maybe somebody needs that use case. Well, if you want privacy through your trades, there's a couple of ways you could do it. The way asset connect works currently, whenever you do like a uniswap swap, all the amounts are public, but who's performing them is private and the anonymity set of who it could be is large enough that you get pretty good privacy. It's trade offs so you can design in whatever way you want, so you can be more granular or have it in that kind of design where amongst republic, but who's doing it isn't, and all of this kind of stuff and the world's your oyster. You can program whatever you want.
00:19:31.110 - 00:19:34.420, Speaker B: Interesting. Yeah, it's going to be a very interesting space in the future.
00:19:35.830 - 00:19:48.700, Speaker A: The design space is massive. We've got some contracts in our Aztec packages repo, if you want to look. They're pretty rough cut. Like the noir syntax isn't there, but there's like working examples of a lot of this stuff.
00:19:51.070 - 00:19:58.860, Speaker B: And I wonder what the auditing kind of space will look like in the Zkvm space.
00:19:59.230 - 00:20:16.770, Speaker A: Yeah, it's going to be pretty fascinating. Yeah. So I mean, like auditing circuits in general, the talent pool for it is pretty small right now, especially for lower level languages like Circum.
00:20:17.990 - 00:20:19.890, Speaker B: And what is a circuit though?
00:20:19.960 - 00:20:24.500, Speaker A: Okay, so this could be ten episodes in itself.
00:20:25.290 - 00:20:26.550, Speaker B: TLDR.
00:20:27.850 - 00:20:43.050, Speaker A: TLDR. So a circuit is really just a program, but defined in I'll make a big generalization here, but it's kind of a program that's defined as only pluses or multiplications.
00:20:44.350 - 00:20:44.810, Speaker B: Okay.
00:20:44.880 - 00:21:03.458, Speaker A: So it's called a circuit because if you look at it topologically or like whenever this stuff was first being designed, it's all kind of designed as like fan two in, one out, like arithmetic circuits and it generally looks like a circuit on paper, but now a lot of that is abstracted away.
00:21:03.624 - 00:21:04.194, Speaker B: Got you.
00:21:04.232 - 00:21:35.050, Speaker A: So all it is is something that constrains what values can be inputs to a function and what values can be outputs, and it also constrains all of the intermediate values as well. So if you can imagine a function as just like a line, so depending on the number of variables you have to a function, it's just a line through space that are all the possible things that satisfy that function. Circuit is just kind of a way of representing that that's provable.
00:21:36.430 - 00:21:39.740, Speaker B: Okay, so it's like the Verifier kind of thing for.
00:21:41.490 - 00:22:14.680, Speaker A: Yeah, you can prove a circuit, and you can have a satisfying witness to a circuit and then have a verifier that will accept that all these abstractions don't matter too much. Like, a circuit is really just a program with a set of rules that you want to constrain. So let's say I want to constrain that my circuit will only accept outputs where input one plus input two equal input three. Then I can create kind of a circuit that will accept all of those.
00:22:15.450 - 00:22:23.402, Speaker B: So a circuit is like a function, right? Or is it just a function and it's specific to each contract, or is it a global thing?
00:22:23.536 - 00:22:45.810, Speaker A: It'll be specific to each contract. So you can write circuits like normal code by using Noir. So you just write it like it's a normal program, like a solidity program or a rust program or whatever you fancy. And then behind the scenes, it will turn this into some kind of into mathematical constraints. But those constraints just represent the circuit, the program that you've defined.
00:22:47.270 - 00:22:54.270, Speaker B: Right. Okay, cool. So then people have to learn about these circuits, or is it, like, hard to learn, do you reckon?
00:22:54.430 - 00:23:36.770, Speaker A: It's not really. So at a surface level, the devex with Noir is great. So you can just write it like it's normal code. If you want to optimize it, then you probably have to go down the rabbit hole a little bit, because there's something we're introducing to Noir in the next update, which is called unconstrained functions. So you can kind of I'll paint the picture a little bit. So right now, when you're creating circuits, you can only use additions and multiplications, like behind the scenes, or else there's custom gates and all this kind of stuff, but we'll forget about that. For the meantime, if you imagine how do you perform a division using only additions and multiplications? That's extremely expensive.
00:23:36.770 - 00:24:00.906, Speaker A: What you would actually do is provide something that's called a witness, provide a witness value externally, which is like the result of that division, and then you can just verify that the inverse is true. So let's say I want to prove that A divided by B equals C. What I can do instead is prove that C times B equals A.
00:24:01.008 - 00:24:01.322, Speaker B: Okay?
00:24:01.376 - 00:24:57.610, Speaker A: And then I can do that in one or two constraints rather than having to perform that multiplication, rather than having to perform the division, actually. So it turns out that you can enhance the performance of your circuits a lot by reducing the constraints, by looking at things that have this relationship and kind of optimizing what the witness values you end up using. And this is really interesting because you get into the point this is where lookup tables come in, you can massively increase performance for certain things. So anything that's non native and difficult to do inside the field that you're working in, or you will end up swapping this over to being some kind of lookup of something you've pre computed. And then you can constrain this pre computed table using something like ultraflunk or pluckup or whatever, like some kind of proving system that lets you make these lookup arguments.
00:24:59.550 - 00:25:17.090, Speaker B: Yeah, you hear prover a lot when you talk about ZK. And there's so many new ZK startups as well. You have polygon. You've got scroll. Aztec. So yeah, I guess it's like a race to become the ethereum of ZK.
00:25:17.510 - 00:25:18.658, Speaker A: Yeah, I guess so.
00:25:18.744 - 00:25:22.274, Speaker B: Right now there's a couple of different.
00:25:22.312 - 00:25:36.674, Speaker A: Races taking place, right? So there's the people doing it for scaling and then there's people who want to kind of have base layer privacy. There's kind of two different races going on, but yeah, they're all pretty competitive.
00:25:36.802 - 00:25:42.650, Speaker B: I wonder what Bridging would be like from one ZK thing to another. Anonymous Bridging.
00:25:43.710 - 00:25:53.710, Speaker A: Yeah. So from two base layers which have privacy built in. I reckon you could do that where you get privacy in Bridging.
00:25:57.250 - 00:26:00.254, Speaker B: But then they'll still have like a centralized kind.
00:26:00.292 - 00:26:41.760, Speaker A: Of you'll always need a relayer and a bridge for L two S. It's not too bad because usually your relayer is your sequencer, so you can trust them. So like in the case of Aztecs design, or if you look at any of the roll ups in general, they have this enshrined bridge. So you can send messages to some contract or even some contract that the sequencer trusts, and then it will just read events from that message and then store those messages on the other side for people to act against. Them or even just perform arbitrary calls for you, which is a lot more secure than having some other party which picks up the messages, kind of signs a multi SIG, and then sends it over to the other side.
00:26:42.850 - 00:26:50.206, Speaker B: Yeah. I wonder what there wouldn't be any kind of bundling system like there is with Flashbots in ZK. I can't imagine that.
00:26:50.388 - 00:27:05.090, Speaker A: So I think it can exist well, in our design anyway, because we have all this public state in general. There will be biding wars around this. So classical mev will exist.
00:27:08.250 - 00:27:24.534, Speaker B: But you wouldn't be able to see who's basically sending what to what. It would just kind of be like sections of it. It's like slices of transactions. You have to kind of like yeah.
00:27:24.572 - 00:27:35.360, Speaker A: They'Ll be fill in the gap. It'll be a different set of information to what we see on Ethereum now, but someone will find a way to extract value from it.
00:27:35.890 - 00:27:37.390, Speaker B: I wonder if there will be any.
00:27:37.540 - 00:27:42.190, Speaker A: Kind of implies that there is value to be extracted in the sequencing of transactions.
00:27:42.550 - 00:27:48.500, Speaker B: Yeah. Can contracts be fully anonymous as well?
00:27:49.990 - 00:27:54.420, Speaker A: You can have contracts which don't have any public functions in them at all.
00:27:55.430 - 00:28:01.122, Speaker B: Or something that you cannot see on the blockchain at all. It's just kind of the address and you can't see the bytecode.
00:28:01.186 - 00:28:37.440, Speaker A: Yeah. Each address will have stored at it like a contract tree. So to make sure that somebody is actually executing something that somebody has deployed, you have to prove that the contract you're executing exists. That's something you have to do first. And the way you do that is just a merkel tree. Check against the contract address to say, because each contract will store a merkle tree of the functions that it contains. But those functions will just be hashes so you can't actually see the bytecode that makes them up.
00:28:37.440 - 00:28:44.318, Speaker A: All you get is a verification key that allows you to prove, like, to verify that this has been done correctly.
00:28:44.414 - 00:28:52.310, Speaker B: So reverse engineering sounds like it wouldn't actually work in this environment if something was fully private. For example, MEB.
00:28:52.810 - 00:29:01.850, Speaker A: For private transactions, no, but for public ones, yes, you absolutely could, because if you want a transaction to be public, you have to publish the bytecode.
00:29:03.710 - 00:29:05.082, Speaker B: Oh, even if it's just one?
00:29:05.136 - 00:29:06.380, Speaker A: What do you mean just one?
00:29:06.750 - 00:29:21.966, Speaker B: Like just one public. Let's say I have an mev bot, right? And I'm interacting with like, a uniswap clone that I guess has at least one public function. So that means that uniswap clone is.
00:29:21.988 - 00:29:26.830, Speaker A: Actually public, just that function. The rest of it isn't.
00:29:27.410 - 00:29:28.914, Speaker B: Oh, okay, got you.
00:29:29.032 - 00:29:43.810, Speaker A: Yeah. So that's probably another difference towards the EVM is that in Aztec, every function has its own bytecode, not an entire contract. Contract is just a way of scoping state to a set of functions.
00:29:43.890 - 00:29:49.802, Speaker B: Yeah, it'll be interesting to see. Oh, can a public function interact with a private function?
00:29:49.936 - 00:30:31.970, Speaker A: So this is where it gets interesting. Technically you can send messages to them, but it's asynchronous. This is where it gets really funky, is you do the private execution on your device and then you send it to the sequencer and the sequencer will take care of all the public stuff. What happens when the sequencer does all of the public stuff? It can't webhook back to your phone and say, this happened as a result of executing your public function. Now I do this because then you've linked the two together completely. But your public function can create commitments and you can spend those commitments privately.
00:30:32.050 - 00:30:33.990, Speaker B: This is a really interesting area.
00:30:34.140 - 00:30:41.340, Speaker A: Yeah, I've not actually had to explain it before. There's a lot of stuff to it, I guess.
00:30:41.710 - 00:30:45.654, Speaker B: Yeah, it sounds like it's going to be a massive playground.
00:30:45.702 - 00:30:50.106, Speaker A: Fun to think about. There's so many open questions to it as well.
00:30:50.288 - 00:31:16.962, Speaker B: Yeah. Okay, so let's say I have an Mev Bot, right? And I'm running a bunch of strategies and one of them just so happens to hit like a public transfer of an ERC 20. Would you only see that public transfer within this whole sequence of, let's say they chain different private functions and then in the middle of it, it has one public function, but then the rest are private. Would you only see that public one?
00:31:17.016 - 00:31:46.430, Speaker A: Yeah, the public one would have to come at. The end, you can't go from public back into private. But yeah, you can do as many private function calls as you want before you go public. And what's great, well, there isn't a really limit because what actually happens under the hood is that you prove each of these functions and then you recursively compress the domain into one little proof. So you send one proof of what could have been an arbitrary number of function calls to network.
00:31:48.690 - 00:32:00.850, Speaker B: I imagine in hacks, it would just be like you would just see, like, one public function, which is just like the public bytecode, and it's just like all the money's moved.
00:32:03.510 - 00:32:14.246, Speaker A: The possibility that could happen gives me gray hair. But I mean, the hope is that the security tooling would be able to be good enough that that won't happen or hopefully, yeah.
00:32:14.268 - 00:32:26.780, Speaker B: I wonder what the security tooling would be like then. If something is private, I guess, like, post deployment audits will be like, a thing of the past. Unless it's all public.
00:32:29.310 - 00:32:33.600, Speaker A: You can publish the code always if you want to. Right.
00:32:35.170 - 00:32:38.394, Speaker B: People don't do that, though. They do, like, unverified contracts in Ethereum.
00:32:38.442 - 00:32:52.100, Speaker A: Yeah, for unverified contracts. Good luck. But at the same time, nobody can create proofs for your application unless they have your proving key, which is created by compiling your contract, which you need the source for.
00:32:52.470 - 00:33:23.290, Speaker B: I imagine someone would make like, okay, let's say I make a protocol and I'm just going to keep using this uniswap. But it's a private uniswap. Everything is private, but I build a front end with my, I guess, prover key. Right. And I already know everything in the tree, so then people will be able to interact with the private functions. So you need a private key to basically know what's happening and the tree right. Of what's all the private functions technically.
00:33:23.630 - 00:33:48.190, Speaker A: Sort of every function has a verification key that everyone knows, but those verification keys are just commitments to the shape of the circuit, so they don't actually really verify. You can look at them as, like, hash functions. They don't really reveal that much about what it's actually doing. You publish all of those. You have to publish those.
00:33:48.280 - 00:33:52.486, Speaker B: Oh, okay. So for anyone to interact with a private function, they would they need the.
00:33:52.508 - 00:34:17.920, Speaker A: Proving key to create a proof to interact with the function. But the block, like Aztec, will always need the verification key to be able to verify that those proofs are valid. So that's why you have to publish it. So you have to publish a verification key. You only have to publish the proving key to people that you want to be able to create proofs for your app, which doesn't have to be everyone. It can just be you and your friend. If it's like, what if you just had a channel between you two?
00:34:18.610 - 00:34:24.926, Speaker B: Okay, can multiple people use the same proving key? Is that what proving? Yeah.
00:34:24.948 - 00:34:33.922, Speaker A: So a proven key is just like you can think of a proven key is everything that you need to create a proof for a function.
00:34:34.056 - 00:34:36.980, Speaker B: Got you. So we can have just one for everybody, right?
00:34:38.630 - 00:34:43.654, Speaker A: I think maybe calling it a key is like the wrong way to describe it.
00:34:43.772 - 00:34:44.246, Speaker B: Okay.
00:34:44.348 - 00:35:02.220, Speaker A: It's literally just source code. You can think of it as just the source code. Okay, well if you compile the source code, you'll get the proving key, which will allow you to create proofs. But that key isn't like a key that's unique. It's not like a private key or anything. It's literally just bytecode basically just by code, really.
00:35:02.670 - 00:35:27.630, Speaker B: Okay, so we can just put this bytecode on our front end and so nobody directly knows it unless they go through the repo. And I don't know, maybe you scavenge through the inspect on the browser, but theoretically, if they didn't do that or couldn't do that, then it's technically public. But private, like they're using private functions.
00:35:27.710 - 00:35:50.220, Speaker A: I mean, you could have a model, like this would be a completely terrible design, but you could have the proven key only exists in your server and you ask people to send you inputs and then somebody creates the if you trust this person, they will create the proof for you. But again, that's terrible because they can literally replace any of the witness values of whatever they want.
00:35:50.690 - 00:35:53.854, Speaker B: Oh, yeah. So nobody would actually use don't trust.
00:35:53.892 - 00:35:55.934, Speaker A: Your prover unless the prover is yourself.
00:35:56.052 - 00:36:01.822, Speaker B: Right, okay. Nobody would ever use their own these private functions then.
00:36:01.956 - 00:36:05.620, Speaker A: No. Well, it defeats the whole point of using a snark in the first place.
00:36:06.390 - 00:36:06.898, Speaker B: Yeah.
00:36:06.984 - 00:36:11.780, Speaker A: Okay. You can distribute the source code and have people do it themselves.
00:36:12.710 - 00:36:26.600, Speaker B: Yeah. Interesting. I'm really keen to kind of dig into the reverse engineering and I guess automated analysis on this stuff as well. It sounds like it's going to be super complex, but it's going to be fun.
00:36:26.970 - 00:36:35.514, Speaker A: I'm really excited for the ecosystem that pops up after this is deployed and it's going to be super interesting.
00:36:35.632 - 00:36:55.250, Speaker B: Yeah. So let's say you wanted to do some automated analysis. I know that you don't do it, but since you have the foundational knowledge of ZK VMs, you kind of know what needs to be done. So I guess in your kind of perspective, what would you think that needs to be done or what is actually possible?
00:36:55.400 - 00:37:36.494, Speaker A: So there's so many scopes to this. You could pretty easily create something that could verify Noir code itself. And I mean, you could just use traditional tooling that you would use to do formal methods on solidity. In this case, existing tooling would probably work as long as you can create something that models the language accurately. The problem is noir itself. Even if Noir is secure in its compiler output, and its compiler output is something called the seer, this is a rabbit hole, but we're going to go down it. Okay, so the architecture of Noir is actually quite fascinating in a way.
00:37:36.494 - 00:38:33.282, Speaker A: So it itself is just a front end that compiles to this back end that we well, this IR that we call abstract circuit intermediate representation. So it is kind of what we think is a way that you could represent anything you want the proving system to prove, and it will then interface with a proving system to turn that into constraints. So the workflow that we use internally or that Noir ships with by default is the Noir program compiles to this Asir, which then compiles gets sent to our cryptography backend called Bretenberg, and it turns it into constraints. So there's two points that you can prove here. You can formally verify that Noir compiles now into a sear correctly and that everything happens as you expect. And then there's the other step that you'll have to verify because Noir doesn't have to target just Bretenberg as its back end. Currently, there's people making a halo two back end for it.
00:38:33.282 - 00:38:55.654, Speaker A: And I mean, it works. So you can write Noir that turns into hilo two circuits. But the problem is that that step between a sear to the back end is also something you would need to verify. It's kind of a language within itself. You can verify Noir pretty easily, I think.
00:38:55.772 - 00:39:05.980, Speaker B: Okay, well, Noir is basically in the contract, right? So you could easily do that. But apart from that, there's another step.
00:39:06.430 - 00:39:22.320, Speaker A: You then I just described. You have to be 100% sure that Noir is accurately turning those into gates. There's no flaw there because it's another flow just like, let's say.
00:39:24.070 - 00:39:26.098, Speaker B: And how are you sure of that, though?
00:39:26.264 - 00:39:30.420, Speaker A: We just write lots of tests and we'll have to get it formally verified at some point.
00:39:31.110 - 00:39:32.580, Speaker B: Okay, right, got you.
00:39:33.910 - 00:39:36.470, Speaker A: Yeah. And we use it in production.
00:39:39.050 - 00:40:02.794, Speaker B: So let's say you wanted to kind of reverse engineer a contract, right? Yeah, and see if it had any exploits because people are going to do this or just do like White Hatting for these protocols, I guess. What were the steps you would have to take to do this if it had like, partial public functions, some private.
00:40:02.842 - 00:40:08.414, Speaker A: I want to answer this question. Okay?
00:40:08.452 - 00:40:09.790, Speaker B: No, this is White Hat.
00:40:13.970 - 00:41:20.680, Speaker A: Thanks for clarifying. So, yeah, there'll be a blockage floor like usual, and all public functions, this is where there's another massive divergence. So public functions take place on a VM. So there is a Zkvm for public functions, and it takes in just bytecode and executes this bytecode in this massive ZK circuit that basically verifies that every single clock cycle of the VM is done correctly or every step is done correctly. And this is the exact same model that Zkavms have, except they have a tougher job because they're proving a VM that wasn't really designed to be proved in that kind of way. So, I mean, the exact same kind of things apply in this case, so you would look at the bytecode, look at how that executes on an ACVM simulator and then look at how the output differs to what the VM circuit should be constraining or what the bytecode thinks is constraining. And that's where the difference is.
00:41:21.050 - 00:41:21.510, Speaker B: Interesting.
00:41:21.580 - 00:42:00.210, Speaker A: I want to primer on Zkvms in general. Yeah. So a Zkvm is literally just like a monolithic circuit or like a circuit that is composed of lots of subsurcuits that are there to specifically prove behavior about a virtual machine. So let's say we have a simple virtual machine that has like five opcodes and they are add subtract, comparison operator and let's say return or something. I know that was four, but we'll stick with that for example. That makes sense. So what you would have is kind of like each addition constraint is pretty simple.
00:42:00.210 - 00:42:59.730, Speaker A: You can imagine as it's literally like a plus B equals C or the subtraction is kind of similar like A a inverse, like a b inverse equals C because you're in a finite field. Like if you want to subtract you just add your inverse, the same kind of thing for a comparison you can constrain your numbers to be bits or you can well, I mean, comparisons are pretty difficult to do in ZK world in general. You have to do bit decomposition, do range checks and then compare them after that. And then our return function is basically just something that pushes something into a register or you imagine. And for all of these, assume we're like working on some kind of register machine, right? Two things out of like say I take values out of register A and B and then output them into some kind of result register or something and the bytecode defines where all these are. You basically just have to write a circuit that constrains. All of this occurs correctly.
00:42:59.730 - 00:43:50.174, Speaker A: So if you imagine what that would look like before it's proved is like one massive execution trace. So you can think of having a column in a table every single register and every single opcode that's being executed. And then let's say the opcode that's being executed is add. You then have to basically say that in the next row. Does everything fit to the constraints that I expect from my VM? So if it's an addition, is the output register the addition of the two input registers at step T minus one. And if you imagine if you're just writing a massive circuit to do all of this, that's essentially what a Zkvm is. Okay, if anybody wants to dig into this, the idea was kind of first introduced by the starware guy Ben Sasson in Tinyram.
00:43:50.174 - 00:44:18.814, Speaker A: If you just google Tinyram you'll see the paper that kind of describes the first idea of how to do this. And then if you want to get into really fun stuff, the Zkevm done by Polygon and polygon zero is really interesting. They created a whole new language called Polynomial Identity Language to define all of the circuits. And reading through that is just like a gold mine of really cool.
00:44:18.932 - 00:44:19.262, Speaker B: Okay.
00:44:19.316 - 00:44:19.930, Speaker A: Alpha.
00:44:20.010 - 00:44:20.254, Speaker B: Yeah.
00:44:20.292 - 00:44:41.480, Speaker A: It's just really interesting. And then if you want to go even deeper and design your own ZK VMs, there's actually a framework being built by Chris East who created Solidity called Poiter that's actually really usable. So if somebody wants to get Nerd snipes and try and build a ZK VM out of Poiter, then that would be a pretty cool project.
00:44:43.050 - 00:44:54.010, Speaker B: Yeah, I'm pretty interested in this because to build something like an automated analysis tool, you would need to build your own VM.
00:44:57.470 - 00:44:58.986, Speaker A: For analysis tool, you need to build.
00:44:59.008 - 00:45:16.386, Speaker B: A VM well, especially for dynamic analysis because you have to basically execute what's happening, whereas static analysis, you can kind of just be like, okay, this is the opcode, this is what it outputs, this is what it takes in.
00:45:16.488 - 00:45:17.300, Speaker A: Got you.
00:45:17.670 - 00:45:32.600, Speaker B: But for dynamic, you actually have to execute it. Yeah, it doesn't sound as easy as EVM, so you basically have to build your own circuits in it or this registry kind of thing.
00:45:33.290 - 00:45:58.138, Speaker A: It's kind of interesting that you say to evaluate all of this, you need to build your own VM because that's actually what Noir does behind the scenes to evaluate everything. It has this thing called the AC VM, which executes which executes the Seer Opcodes to basically build what your circuit would look like. And then inside that VM, if you want to do unconstrained things, it has a VM inside the VM to then inject Witnesses.
00:45:58.234 - 00:46:00.110, Speaker B: Oh my God. Nested VMs.
00:46:00.690 - 00:46:10.226, Speaker A: Yeah. So that's why the unconstrained function thing that's coming out is pretty interesting because it is literally like running a VM and a VM that you can kind of inject values into. Yeah.
00:46:10.248 - 00:46:13.650, Speaker B: I wonder how audit firms are going to adjust to ZK.
00:46:15.050 - 00:46:16.438, Speaker A: They're doing a pretty good job at.
00:46:16.444 - 00:46:20.070, Speaker B: It, to be honest with cairo is Cairo VM?
00:46:20.650 - 00:46:21.206, Speaker A: Yeah.
00:46:21.308 - 00:46:23.640, Speaker B: Oh, right. Yeah. Okay, so people have already done.
00:46:26.490 - 00:46:32.018, Speaker A: Like the general Zkvm stuff isn't too much of an open problem, right?
00:46:32.124 - 00:46:33.990, Speaker B: It's more of like the specific privacy.
00:46:34.070 - 00:46:59.970, Speaker A: Stuff and just having developers or even auditors that are kind of familiar with just general circuit vulnerabilities on top of logic vulnerabilities. Just going to be important to have people with that skill set or that muscle memory to be able to identify that stuff. The real problem is that there's not enough projects that I mean, there's more and more by the day, but a lot of the old leaders just haven't had the practice.
00:47:02.070 - 00:47:06.886, Speaker B: Yes, there's going to be a lot of screw ups initially, and then as.
00:47:06.908 - 00:47:25.420, Speaker A: It matures, obviously, everyone now kind of looks at Reentrancy as this obvious thing in the world, but everything's obvious in retrospect. And it's like you train those muscles and know what to look for in the first place. And usually we learn the lessons by things getting hacked we just have to pray that that doesn't happen.
00:47:30.430 - 00:47:32.170, Speaker B: Do a hard fork of ours.
00:47:34.050 - 00:47:40.640, Speaker A: That's why it's so important that people use Noir NOI before people get familiar with it.
00:47:42.050 - 00:47:52.180, Speaker B: Yeah, that sounds super interesting. Yeah, very interesting. I want to get into that now. Pilling me.
00:47:53.510 - 00:47:55.090, Speaker A: Mission accomplished.
00:47:57.530 - 00:48:26.110, Speaker B: Yeah, I'm super keen for the kind of whole automated space. How that's going to work, like mev and automated analysis is going to be very interesting. So how would you get someone that's currently in Solidity EVM type deals into basically building apps on something like Aztec or a ZK?
00:48:27.330 - 00:49:32.530, Speaker A: I think that the developer experience will be pretty good. So I don't think anyone who's familiar with Solidity kind of has the basics of have most of what they need to know to write a Noir app. The semantics will be the same. So you have storage variables, you have kind of functions that kind of really operate over those storage variables and that's kind of like all a Solidity contract really is at the end of the day. You can do that on Noir pretty simply. I mean, it's like in Solidity it kind of has, what do you call it? Like a nice little skill curve where you go from just writing basic Solidity what are they? ERC, 20 forks, uniswap forks, whatever, and you go into building something like Cport where you do it all as efficiently as possible or you start writing half the Arc will be quite similar, where you can do 90%, 99% of what you need to do just with like standard Noir and it will write like a normal contract. And the parrot items are pretty much the same as Solidity.
00:49:32.530 - 00:49:38.920, Speaker A: And then if you want to go crazy optimizing, there's room for you to do that.
00:49:40.730 - 00:49:46.534, Speaker B: So it's basically just the same opcodes, just with some extra stuff like that shielding of private and public.
00:49:46.652 - 00:50:07.694, Speaker A: Yeah. So even that shielding thing isn't even expressly. It's not like there's an opcode to shield. It's like you can just create commitments or you can create public state or you can have storage state, if you know what I mean. You can just create UTXOs. You can create whatever you need. So you can do whatever you want in those it doesn't have to particularly be shielding, unshielding and all those kind of things.
00:50:07.694 - 00:50:12.400, Speaker A: It can be whatever you want. Just you can use whichever storage paradigm fits the job the best.
00:50:12.930 - 00:50:39.282, Speaker B: Okay, so is there like a public and private storage kind of thing? Okay, let's say in one byte. Okay, I think this relates back to what we initially said, but to do with the public and private. So these are two different opcodes, right? Public and private storage. So if I have a private, completely private thing, but I have one public storage, will it show everything that's private?
00:50:39.426 - 00:51:05.230, Speaker A: So, yeah, that's something you want to be careful about. It won't show everything as private. But let's say in one transaction, you're doing a load of private things in one contract, and then at the end of your transaction, you're doing something to a public storage variable. Like, as I said beforehand, if you had the EVM and you update two pieces of state in one transaction, you kind of reveal exactly what you've been doing. You just want to design such that you're thinking about that.
00:51:05.380 - 00:51:14.018, Speaker B: So if we did, like, a private initially had all this kind of filler code and then a public at the end, you wouldn't be able to see the private, would you?
00:51:14.104 - 00:51:24.566, Speaker A: You wouldn't see what happened in the private. But I mean, if there's only ten code paths that get you to that public function, you know, which it's got to be one of those paths that we're taking.
00:51:24.668 - 00:51:33.634, Speaker B: So you kind of want to set it up. So it's like a setup function into a public one, I guess. So a set up private into a public, like separate transactions?
00:51:33.682 - 00:51:34.546, Speaker A: Something like that? Yeah.
00:51:34.588 - 00:51:53.920, Speaker B: And I guess you can think of contracts as kind of like modules instead. So it's like bytecode or functions instead of like a whole contract. Is that right? I guess that's done for, I guess, the private and public modularity. Right? Like, why isn't it all in one single source code?
00:51:54.550 - 00:52:27.130, Speaker A: Yeah, so that's kind of if you want to be able to have some functions that you keep that are private, like, let's say for this Use case, I'm a bank and I want to settle something on Aztec, but I don't really want to show my banking competitors what I'm doing. If I publish, like, if my source code had bytecode for everything, if my contract stored bytecode for all of the private transactions as well, then they'd be able to see exactly what I'm doing. But if you want to keep it private, you also need to keep what functions are being executed private and what those functions actually do.
00:52:27.200 - 00:52:27.770, Speaker B: Got you.
00:52:27.840 - 00:52:34.960, Speaker A: In the Use case, where you're a private kind of mini loan, I don't know, a private bank or something.
00:52:36.370 - 00:52:44.030, Speaker B: Yeah, you can see this being private, completely private, I guess functions being used for something like a hospital or anything with sensitive data.
00:52:44.100 - 00:52:45.040, Speaker A: Yeah, exactly.
00:52:45.410 - 00:52:46.090, Speaker B: Got you.
00:52:46.180 - 00:53:39.602, Speaker A: That's who it's useful for. The reason I think Aztec is so powerful in general is if you look at what public blockchains give you, they give you kind of some element of trustlessness so you can execute whatever you want and kind of know that it will get executed. What Aztec gives you on top of that is like, all of those guarantees, except you don't need to worry about leaking information to everyone. So you get all of the coordination all of the coordination benefits of blockchains, along with also being able to know that I have a private life if I want to interact exactly the instance you were giving, if I want to interact with my hospital or whatever. You can do that privately. If you think of all these people talking about, I want to buy coffee with ethereum in the future. Think of if every time you bought a coffee, everyone could see that that was happening.
00:53:39.602 - 00:53:47.430, Speaker A: Like the amount of analytics that could be done on you. Everyone knows what time of day you're in a coffee shop, and everyone knows when you leave your house.
00:53:47.580 - 00:53:48.520, Speaker B: Oh, yeah.
00:53:49.370 - 00:53:50.866, Speaker A: It's just not acceptable.
00:53:50.978 - 00:53:52.230, Speaker B: Yeah, for sure.
00:53:52.380 - 00:54:04.506, Speaker A: That perspective is kind of clear why something like this needs to exist, or even why not even needs to exist. Just look at it from a product perspective. It's like something people clearly want.
00:54:04.608 - 00:54:08.326, Speaker B: Yeah. Need. I don't think anybody wants to get traced to that degree.
00:54:08.518 - 00:54:31.298, Speaker A: Yeah, but if you think of the reality that a public blockchain gives, it gives you all these great properties everyone talks about, but nobody kind of well, I think people are smart enough to know that you get everything dystopian as well, and that the whole utopia that crypto is meant to provide isn't really a utopia at all.
00:54:31.464 - 00:54:43.430, Speaker B: It's like a really great experiment that's kind of sparked this, though. And now I think Zika is probably the thing that everybody imagined it would like the original kind of blockchain should be.
00:54:43.580 - 00:55:09.840, Speaker A: I think so, yeah. Just like taking looking at it quite holistically from my back. If you look at what a blockchain does, it verifies every single node, verifies everything that happened, and executes every single line of every single program. That itself is just ridiculous. It should just be checking proofs in the first place. Why does it ever have to execute everything again?
00:55:10.290 - 00:55:24.334, Speaker B: I wonder if there's way to this is probably not true, but I wonder if there's any way of, I guess, reversing proofs or sending malicious ones that don't match. But I guess that's like a protocol.
00:55:24.462 - 00:55:49.370, Speaker A: Yeah, no, there's absolutely ways to do that. So there's like this whole area of like you can have slowness errors in your proving systems. You can have non perfect zero knowledge or not zero knowledge at all. So if you look at most in production, stark systems don't have zero knowledge, so it leaks information about what was executed in the proof.
00:55:51.410 - 00:55:56.080, Speaker B: The core protocol kind of security error. Not really.
00:55:57.170 - 00:56:04.490, Speaker A: Yeah, it could be a core protocol security error. Like, if there is a fineness error in any proving system, it's not grit.
00:56:04.570 - 00:56:18.174, Speaker B: And do people have to write their own proving systems or is it just getting sent to the Mempool, and then that does it all for them? And are all these essential to kind of getting into building, I guess, DApps on Aztec?
00:56:18.302 - 00:56:20.534, Speaker A: No, absolutely not. No, there if you want to like.
00:56:20.652 - 00:56:22.038, Speaker B: If you want to dive into if.
00:56:22.044 - 00:56:30.794, Speaker A: You want to dive into DK, do that. If you want to write apps on Aztec, you just need to learn more. If you can write solidity, you're 99% of the way there.
00:56:30.912 - 00:56:34.186, Speaker B: Got you. Okay, cool. So hopefully people start trying it out.
00:56:34.288 - 00:56:34.842, Speaker A: Yeah.
00:56:34.976 - 00:56:38.774, Speaker B: And is there a testnet people can use right now as well, or still involved?
00:56:38.902 - 00:57:07.330, Speaker A: No testnet right now. We're aiming to have a local DevNet by the end of Q Three, so very soon. That means you can run a docker container and deploy Noir apps to it and send transactions. So it's basically just like an app with a test net with no consensus, but you just run it on your computer. Like, you can run a local node, like something like anvil essentially, and write tests for contracts and stuff. That'll be coming pretty soon, but that'll be like alpha alpha version.
00:57:08.150 - 00:57:10.274, Speaker B: Yeah. A lot of changes.
00:57:10.392 - 00:57:20.200, Speaker A: Oh, yeah. Like, loads. But if you want to get dug into it, like, send me a DM on Twitter, it's Maria Zero or on Discord or wherever. We'll walk you through it.
00:57:20.650 - 00:57:54.014, Speaker B: Yeah. It'll be interesting to see how the tooling evolves as well. For Zkvms, there's so many opportunities start of a new kind of field and error in the blockchain space. So a lot of first mover advantages for different kind of stuff. But yeah. Thank you so much for coming on and I'm sure a lot of people are going to be super interested from this talk as well, especially talking about mev, the kind of the buzword. But it is an interesting area and I think it's going to be very fun to kind of play around in this space.
00:57:54.212 - 00:57:58.200, Speaker A: Yeah. Don't have a nerd snipe shoe whatsoever. Apply for a job.
00:58:00.090 - 00:58:10.802, Speaker B: We're hiring. But yeah, man, thank you so much for coming on and we'll definitely chat soon on when launches and how the space kind of evolves.
00:58:10.866 - 00:58:11.590, Speaker A: Yeah, cool.
00:58:11.660 - 00:58:13.030, Speaker B: All right, take care, everyone.
00:58:13.180 - 00:58:14.200, Speaker A: See you guys.
