00:00:00.170 - 00:00:20.030, Speaker A: I didn't want to get into it and become liable if he was trying to hack the contract or something because he had a pretty specific request. Knowing what the Mevbot is doing in the solidity contract is only half the battle. You actually have to know their strategy, know when it's being triggered, etc. To have that alpha GM, GM everyone.
00:00:20.100 - 00:00:39.730, Speaker B: My name is Dugatchi, your host of scraping bits, and today I have the pleasure of speaking to John Becker, a wonderful friend of mine that has helped me get into my journey of formal verification automated analysis. So it's great to have you on. I just want to quickly touch on what you do and who you are.
00:00:39.820 - 00:01:11.022, Speaker A: Nice. So my name is John Becker. I guess I'm an EVM ninja, pretty much. I kind of just deal with low level data and ethereum data in general, especially at my X company, which just got acquired by chain analysis. It was transpose data a few years ago. Last year I built Heimdall, which is a really big EVM toolkit for decompiling contracts. So it converts the raw bytecode, which is the only thing that's on chain really, to a readable solidity format.
00:01:11.022 - 00:01:12.962, Speaker A: That's pretty much the idea of it.
00:01:13.016 - 00:01:20.498, Speaker B: How did you even get into building this advanced EVM toolkit specializing in bytecode analysis?
00:01:20.594 - 00:01:45.390, Speaker A: So I started out in crypto a while back, and I wasn't really doing much with EVM. I was just looking into little contracts. Like I made a proof of concept for recurring payments on Ethereum, like subscriptions. And then I wasn't really happy with it, to be honest. It was kind of annoying to deal with the developer environment. At the time, there was no foundry. It was just hard hat and it was rough.
00:01:45.390 - 00:02:33.006, Speaker A: I made my own UI that basically let me develop contracts in a way that I thought was nicer. And then I started getting into a little bit of the security side of Ethereum and coding, and I was publishing some articles about, I guess it was Opensea that really sparked it, the Opensea phishing exploit, I think. And I was trying to look at their contract and determine what actually went down, but it wasn't verified. And I ran it through like panoramics, which is the other decompiler out there, like the other main one other than Debob. And I had no idea what was happening. I wrote my article and I was like, yeah, so I think this is a switch case. But it turns out that it was just the function dispatcher and I had no idea what I was talking about.
00:02:33.006 - 00:02:57.186, Speaker A: After seeing how bad that decompiler was and how much it could be improved. That's really what sparked my journey into building it. So I started with a Python version, which was pretty bad and honestly wasn't better than what I was trying to do, but I eventually ported it over to rust, and now it's continuing. One of the best.
00:02:57.368 - 00:03:31.630, Speaker B: Yeah, yeah, definitely. Whenever someone mentions basically a disassembler decompiler, they always mention Heimdall. It's kind of just grown into this go to kind of tool, and it's amazing. It's got like 700 styles on GitHub right now, and it's killing it. You keep on making content updates, new patches with new features, and people just love it. Right. And what's the goal? Like, the end goal of keep on, basically why you keep on building this.
00:03:31.700 - 00:03:48.550, Speaker A: I don't really have an end goal monetarily or anything. I really just want it to be a public good that's always open source. So it's a learning resource for people as well as just there for the community, so that we can make ethereum a little bit more transparent when it comes to contracts and stuff.
00:03:48.620 - 00:04:29.186, Speaker B: I think it's definitely important because a lot of contracts don't verify on efascant, and you don't really know what's happening. Right. And so people just put in their money blindly, and it can be like a rug pool or a scam and something like this. The more comprehensive it is, the more transparent things can get. And ultimately, I guess it is kind of Etherscan's fault, or the block explorer's fault, but tools like this basically help that and improve the space until things get fixed. Right. Yeah, I think it's incredibly important.
00:04:29.186 - 00:04:34.580, Speaker B: And efascan does rely on this stuff as well, in some ways, yeah.
00:04:35.530 - 00:04:46.162, Speaker A: They currently have a decompiler integrated, but it's panoramics, which is very old, doesn't support the Chappella upgrade, so most contracts would probably fail.
00:04:46.226 - 00:04:50.726, Speaker B: What was the kind of process of getting into all of this and building Heimdall from scratch?
00:04:50.758 - 00:05:21.682, Speaker A: I guess I used EVM codes a lot. Like, a lot, a lot. I started with python, and I started building just a vm, like the evm in python, in my own words, my own code. And building the EVM really helped me understand exactly what happens on the EVM. It's like a really very elegant kind of, but simple system where every opcode just has a specific function. It's really nice. So through building that EVM, that's kind of how I learned it.
00:05:21.736 - 00:05:38.280, Speaker B: And then how did you get into disassembly and branch analysis and all this kind of stuff? You had to learn all these different theories and techniques, I guess. Where did you start and how did you keep on progressing, getting into new techniques and stuff like that?
00:05:39.050 - 00:06:15.830, Speaker A: Yeah, so I started with building the evM, and then from there I just kind of dove in. I built the disassembler first because it's the simplest thing. You're basically just iterating over the bytecode and extracting it. It's not like x 86 assembly or whatever, where you need to have seven different arguments for each thing. It's pretty much just either it's an opcode like add, or it's a push with bytes after it, or now there's push zero which has zero bytes after it. So building the disassembler was really easy. It was like one of the first things I launched, I think V 0.0
00:06:15.830 - 00:06:33.946, Speaker A: or 0.1 maybe. All it had was a disassembler and some decoding modules for call data. But yeah. So after building the EVM, building the disassembler, I started to just jump into the decompiler. I just dove in. I had no clue what I was doing.
00:06:33.946 - 00:07:11.574, Speaker A: Yeah, I never went deep into compiler theory at all, kind of just looking for patterns in the code. So I wrote a symbolic execution tool which would basically just execute all of the bytecode or try to execute every single possible path of the bytecode. So whenever it reaches like a jump I opcode, it'll take the true and the false path, which does lead to some problems down the line with dynamic jumps with you call code or call alert. Yeah, you like code copy and then you jump. I don't support that yet because I haven't figured it out.
00:07:11.612 - 00:07:56.402, Speaker B: But yeah, it's hard, man. Even I'm doing the same thing, but my one's private for monetary reasons. But yeah, the jump I problem, the dynamic problem is extremely difficult. I've been stuck on that for a while. And the deeper you go into all this stuff it gets even more complex and the problems just become even harder and you need even better solutions. But you need to do trade offs as well and design these whole architectures. Building something like a decompilation tool is an extremely challenging task, and I don't think people really understand the hurdle of really implementing everything and making something seem, well, return something readable and useful.
00:07:56.402 - 00:07:58.710, Speaker B: It's extremely challenging.
00:08:00.170 - 00:08:26.542, Speaker A: It's very nondeterministic. I guess it's not a straightforward task at all. You have to deal with things like compiler optimizations, bytecode obfuscation. You have to deal with people purposely and deliberately trying to make your decompiler not work like the current contracts. Some of the devs told me that they purposely made sure that it didn't work on my tool.
00:08:26.676 - 00:08:27.600, Speaker B: Oh wow.
00:08:29.490 - 00:08:41.122, Speaker A: I forget who it was, but they reached out to me and they were like, yeah, I made sure you couldn't just run it through Heimdall and figure out the call data. It's a very tough problem to solve and it's a pretty fun one to solve too.
00:08:41.256 - 00:08:50.082, Speaker B: Yeah, for sure. It definitely keeps you occupied, to say the least. But it's so interesting that people were building. I'm assuming it was huff.
00:08:50.146 - 00:09:11.078, Speaker A: Yeah, it was in huff, which uses, I think, call code copy and then dynamic jumps. They also use push two instead of push four function signatures sometimes, which is not what I expected. So I have to solve those edge cases. There's like so many edge cases to everything, it just impossible.
00:09:11.254 - 00:09:36.278, Speaker B: Yeah, it takes a lot of work and a lot of thinking. At least that's what it has done to me. I have basically a notepad to deal with this stuff and it's half full already of just like problems and solutions. And then once you think of one solution, you reach another problem and you're like, oh wow. That previous solution doesn't actually support this new problem. You need some more information relating to it or something around that.
00:09:36.364 - 00:10:13.394, Speaker A: Yeah. My current problem is dealing with Abby encoded data and decoding the strings on the fly decode. Because if you go decompile a contract right now and you look at, let's say you just do wrapped ether, you look at the name and the symbol functions that Heimdall spits out at you. They both have this really gross recursive huge if statement tree, but under the hood it's actually just an RLP encode or decode. That's one of the edge cases I have to cover and that's on my roadmap. It's one of the next things I want to do.
00:10:13.512 - 00:10:43.420, Speaker B: I've seen people just create basically jump eyes for just spamming them, just spam all these new control flows and then it's just horrible to read. But yeah, the heuristics you need to add just are essential. But it's also a lot of thinking, unfortunately. But yeah. How did you get into basically like branch analysis and all this other stuff? And you're basically creating a CFG, right?
00:10:43.790 - 00:11:24.182, Speaker A: Yeah. So that's what the symbolic execution stage does. My evm that I wrote is actually really useful, like the fact that I wrote it myself, because every opcode that it executes has, it's like part of a struct called a VM trace in my mind and in the code. And that struct just holds like the input output, other opcode, not VM trace. It's called a wrapped op. It holds the input, the output, and all the operations that went into that opcode. So essentially the idea is, at any point in time, you'll be able to say this call data load took 32 bytes from the call data, and then it got sent to, I don't know, an M store.
00:11:24.182 - 00:12:02.482, Speaker A: And then that got used later in a static call. And basically that would get executed by my symbolic execution with the VM that I wrote. And then it can later be analyzed and converted to a solidity like format just by analyzing the inputs and outputs and stuff. So yeah, basically the symbolic execution stage builds the CFG by creating these. I guess it's a tree of like wrapped opcodes. And you get every single path just branches off to more VM traces. And yeah, it becomes really simple to convert things.
00:12:02.482 - 00:12:05.354, Speaker A: But then you need to do a shit ton of post processing.
00:12:05.422 - 00:12:09.106, Speaker B: Yeah, a lot of computational power needs to occur.
00:12:09.138 - 00:12:09.478, Speaker A: A lot of.
00:12:09.484 - 00:12:10.546, Speaker B: For loops.
00:12:10.738 - 00:13:28.240, Speaker A: Yeah, that's also one of the biggest challenges I've ran into with generating this control flow graph from bytecode is the recursive loop problem. Because if the jump I sends itself back up to a previous branch, and then it'll keep going forever. And there's not a really good way to avoid that because you can say, yeah, okay, if we already covered this branch, don't cover it again. But then you're going to lose out when the stack or the memory is different, you're going to be missing a ton of edge cases and branches. So the way I've currently solved that is by checking if we've already covered that branch with the exact memory and call data or exact memory and stack, and that solves most of the loop problems. But anything EVM is never going to be perfect. There's still always just loops in the wild that someone will report to me and they'll be like, yeah, I ran this contract and it's been running for seven days, and I thought homedoor was supposed to be first.
00:13:28.240 - 00:13:33.566, Speaker A: It does a lot of checks to try to break out of loops.
00:13:33.758 - 00:14:00.870, Speaker B: Yeah, recursive loops are definitely a difficult task to basically solve. It is quite difficult, because if it's going, it could loop forever. Right. And you need some kind of heuristic to stop it. But you need to also check what's being affected within that loop. Right. And if you're just going to skip it when it comes back to the same destination.
00:14:00.870 - 00:14:23.682, Speaker B: Then basically you're not covering the whole code. You're skipping on a large chunk potentially. And it could be detrimental. It could be like a really crucial part of the code that you're skipping. So, yeah, it's basically like building one of these. It's all just small little modules that you're kind of getting together. But I think the hardest part is getting the reconnaissance at the start.
00:14:23.682 - 00:14:51.386, Speaker B: Because if you don't have the. Right, I guess reconnaissance in terms of basically. Okay, what do I need to test? What do I need to store with each kind of opcode. And how do they all relate to each other? If you don't get that right, everything else kind of crumbles and you can't progress. At least that's what I've experienced. And I've even had to rewrite my entire thing from scratch in the past two days because. Exactly that.
00:14:51.386 - 00:15:13.460, Speaker B: My reconnaissance wasn't really working too well. And I found a problem that required a lot more information than what I currently had. But yeah, and you're also determining whether something is like a view function or pure or mutable, I guess. How do you go about discovering that?
00:15:14.310 - 00:15:43.590, Speaker A: Yeah, so there's heuristics for everything in the EVM. Basically Heimdall aims to just be solidity specific. Because there's no standard for any of these languages. Pretty much like solidity and Viper might share a few similarities, but not at all. So basically for view functions you can just look at the opcodes that are executed in the tree. If you have functions that potentially modify state. Like external calls or storing in storage or mstore.
00:15:43.670 - 00:15:49.962, Speaker B: But basically anything that mutates right is not a part of a view function, right?
00:15:50.016 - 00:16:13.570, Speaker A: Yeah. So that's like the simplest thing you can determine. So if it touches state at all, even with like if it's a state accessing instruction. The function is no longer pure. And that just happens in the VM trace analysis. Which is the step after symbolic execution in my decompiler. And it's analyzing all the traces that it has and building the actual solidity code.
00:16:13.570 - 00:16:54.894, Speaker A: So it's just checking if any of the opcodes that it ran within that function are like non pure opcodes. And it does the same for view. So pure and view, like the visibility of the function is pretty easy to determine. It gets harder when you're looking at the payable, because payable sometimes has a different dispatcher and they'll revert early. If you send ether, it's a non payable function. So basically I just check for a jump I that is reverting if there's any message value sent, and if it's reverting because it has some value sent with that transaction, then we're going to assume it's a non payable.
00:16:54.942 - 00:17:38.030, Speaker B: Another thing I've kind of ran into while doing my stuff, which we mentioned before was like the dynamic inputs, right? Like what bits are being used, where, and how can a user basically influence the contract? It's actually quite difficult to think of a solution for this, and I've been stuck on it for a while as well, but I don't know if you've kind of touched on it at all with the call data inputs for solidity and how it can be used even like the message value. You can still use message value as even like a parameter input, right? If they use it correctly.
00:17:38.770 - 00:17:44.994, Speaker A: I know mocks do that a lot. They'll send like three way or something and it's some variable they have to use.
00:17:45.112 - 00:17:51.170, Speaker B: Exactly. Yeah. So have you thought about this at all? Or any kind of theories on how to solve this?
00:17:51.320 - 00:18:41.874, Speaker A: Theoretically, if you have the branches of all the execute possible executions, you'll see where these variables are used as parameters. I guess you just have to look at, if you're copying call data into memory, then you have to keep track of where it got copied in some storage somehow. And then when memory is accessed, you check where that memory came from. So if it was like call data from zero to 64 bytes, then you know that that's going to be used. Same thing for message value. If it's being sent like the entire message value is being sent to some external call, then it'll show up there and it's just kind of in the way that I built the tracing and the analyzing, it just kind of happens.
00:18:41.992 - 00:18:51.240, Speaker B: Has anyone ever approached you to basically reverse engineer a contract or. Yeah. Has anyone basically approached you to reverse engineer a contract for them?
00:18:51.610 - 00:19:28.926, Speaker A: Yeah, it was, I guess either last year or two years ago. I got a DM on Twitter and some guy wanted to partner with me to decompile some like it's a fully open source tool, you can install it and decompile it yourself. And then I was like, knowing what the Mevbot is doing in the solidity contract is only half the battle. You actually have to know their strategy, know when it's being triggered, et cetera, to have that alpha. I didn't want to get into it and become liable if he was trying to hack the contract or something because he had a pretty specific request.
00:19:29.118 - 00:19:33.602, Speaker B: All right, got you. How can I mutate it to do whatever I want?
00:19:33.656 - 00:20:07.102, Speaker A: How can I get the money out? That's one of the things I want to look at, is, like, somehow determining what call data is required to reach a certain path in the. So, like, if we're going back to Kurda and it's like, you know, you want this function to return. True. I don't know if it's even possible because there's so many parameters and whatever, but if there was some way for it to like, oh, we jump here because this value is too low, you just increase it and continue until you have valid call data. That would be pretty cool.
00:20:07.156 - 00:20:29.766, Speaker B: Yeah, I think that's a powerful tool, and that's actually something I'm working on. That's my latest problem. But it gets very complex when you basically use, like, a call load and then one byte of that call data load for another call data load, and then that's where my tracking system kind of gets screwed up because I haven't thought of a better way to kind of track this stuff.
00:20:29.868 - 00:20:32.360, Speaker A: Do you have a specific contract that did that?
00:20:32.810 - 00:21:38.540, Speaker B: I just write all my contracts from scratch because I've been doing it for a fair while and both writing in half and obfuscation kind of stuff. And I want to kind of COVID everything. So whatever I think of that as a possibility, I try to cover. Another interesting thing that I've seen is are they using bits as their variables? So in one byte there's eight bits, and then they mask, basically a specific bit within the byte. This kind of sounds weird, but basically they use one bit in this byte as like, the variable, and then basically one byte can contain eight different booleans, and the position of the bit is basically the value. So I wanted to account for that, but I think it's also incredibly difficult to account for without symbolic execution to see what can pass and what's failing. Right.
00:21:38.540 - 00:22:22.794, Speaker B: Yeah, I think you can do this kind of like bit tracker with solidity because, you know, there's no nested call data loads. That one is dependent on another, and it just becomes like this whole tracking mess. But I think, yeah, solidity doesn't do dynamic inputs like that, so it's much easier to track bits. But when you get into custom bytecode, it's, oh, my God, it's a nightmare. But I think that's where the majority of alpha and interesting things occur. So that's why we kind of took different paths. Like I went directly bytecode analysis and you went into solidity, right?
00:22:22.992 - 00:22:32.010, Speaker A: Yeah, I think that's interesting. I didn't know ave literally broke apart bytes into each bit and use it as a boolean. That's wild.
00:22:32.510 - 00:23:03.670, Speaker B: Yeah. I think this was when I was kind of learning about bitmasking and bit shifting. I think a few of the people in the huff discord shout out huff discord were showing me like a repo of that being used. And I also learned about different kind of combinations of bitwise operations. So there's like this one called Demorgan, and it uses oars and nots basically to do the exact same thing as an and. But it's just a lot more complicated. So I was trying to account for that as well.
00:23:03.670 - 00:23:29.162, Speaker B: And I think one of the solutions they came up with was checking for a chained bitwise operations to see if something was being casted in some way. And obviously in solidity that's so much easier because it's kind of a standard to use like a shift left, shift right, or just an end, but if someone's trying to obfuscate their code, they're going to use something like demorgan or something more advanced.
00:23:29.226 - 00:23:45.800, Speaker A: I think I only handle for variable casting. I'm Dol only handles shifts left right. Then it uses and or bitmasking as well. But it doesn't care about if you're like obfuscating your contract, I can't help you.
00:23:46.810 - 00:24:11.580, Speaker B: Yeah, it gets way too hard and it's super time consuming, but I think that's also the fun in it. Right. I want to occupy my mind and think of complex solutions to complex problems. I think that's where I get joy in life, at least. I get so bored with basic solidity my mind just shuts down.
00:24:12.290 - 00:24:14.590, Speaker A: Got to be writing pure bytecode.
00:24:14.930 - 00:24:15.680, Speaker B: Exactly.
00:24:16.450 - 00:24:21.770, Speaker A: I see Guy Kefik, I don't know how to pronounce his name. The guy who made the EVM and the EVM.
00:24:21.930 - 00:24:27.250, Speaker B: Oh yeah, I saw that. And he was like writing pure bytecode from memory.
00:24:27.750 - 00:24:31.140, Speaker A: Oh man, 60 80, 60 40.
00:24:31.990 - 00:24:32.658, Speaker B: Oh yeah.
00:24:32.744 - 00:24:40.418, Speaker A: That's as much as I know the solidity dispatcher start thing. That's actually the free memory pointer.
00:24:40.514 - 00:24:52.330, Speaker B: I want to ask what are some kind of common patterns you see in the solidity compiler and what are some patterns you've basically seen while decompiling?
00:24:53.470 - 00:25:26.294, Speaker A: Yeah. So the largest pattern I've seen that I have unsolved I already mentioned was the RLP and the Abby encoding stuff. That's pretty much one of them. What else? It does a lot of like the optimizer does a lot of weird stuff with when you're setting storage, sometimes it'll bitwise or it with the current value that's in storage and it's kind of trippy. I don't know why it does that, to be honest. Yet that's one of the patterns I also have to look at.
00:25:26.412 - 00:25:30.390, Speaker B: But reading the solidity compiler itself would be quite useful.
00:25:30.810 - 00:25:31.830, Speaker A: Yeah, for sure.
00:25:31.900 - 00:25:33.366, Speaker B: Have you done that at all?
00:25:33.548 - 00:25:34.280, Speaker A: No.
00:25:35.370 - 00:25:39.542, Speaker B: Building decompilation tools without actually looking at the decompiler.
00:25:39.686 - 00:25:44.790, Speaker A: I've glanced over it very briefly, but I haven't looked into it in depth.
00:25:44.950 - 00:25:47.580, Speaker B: I think it's in c, isn't it?
00:25:47.950 - 00:25:51.146, Speaker A: Oh God. Okay, so I probably never will look at it.
00:25:51.248 - 00:26:06.294, Speaker B: Yeah, I remember I was thinking of it. I'm like, okay, what's the easiest way to understand how the compiler works? And I was like, okay, let's read the compiler. But it was in c or c plus plus, something like that. And I was like, no, not doing that. I'll take the hardware.
00:26:06.442 - 00:26:09.330, Speaker A: We just got to recode and rust and then we're all good.
00:26:09.480 - 00:26:34.758, Speaker B: Yeah, man, I hope someone does do that. I think even doing what we do is quite interesting in a career pathway choice as well. We can basically go into compiler dev optimization, I think. Even like forward engineering as well. Reverse engineering and. Yeah, basically formal verification. That's the way I've kind of gone, like the formal verification route.
00:26:34.854 - 00:26:47.470, Speaker A: Yeah, there's like so many things that go into building a tool, kind of like this. There's like so many paths forward you can take pretty much. I'm taking my first course on compilers next semester.
00:26:47.970 - 00:26:48.960, Speaker B: Oh, interesting.
00:26:49.970 - 00:26:51.246, Speaker A: It'll be fun.
00:26:51.428 - 00:26:56.130, Speaker B: Yeah, you've already kind of got a head start though, building this stuff, but.
00:26:56.200 - 00:27:09.414, Speaker A: Yeah, I knew absolutely nothing before I started this journey. I started with just the EVM, looking up opcodes and EVM codes and implementing them.
00:27:09.612 - 00:27:15.670, Speaker B: Were you doing like a rust, I mean, not rust. Were you doing like solidity before, or. It was like complete scratch.
00:27:16.730 - 00:27:44.702, Speaker A: I was doing solidity. I wrote, I think one contract that I published was the Ethereum recurring payments because I think subscriptions are very important to any financial ecosystem, and there's really no solution for that on Ethereum yet. There was one that got proposed but never got past proposal. And I just wanted to get into Ethereum, get my work out there. So I spent probably a weekend writing this contract that was like one of my first Ethereum contracts.
00:27:44.766 - 00:27:50.930, Speaker B: Yeah, I think there's something like that called Sabler or something around those lines.
00:27:52.390 - 00:27:54.258, Speaker A: Sorry, what's it called?
00:27:54.344 - 00:28:13.706, Speaker B: Like Sabler. Sabler. Basically it's like reoccurring, but it's not 100% decentralized. Or maybe it is now, but it basically just uses like block timestamp and then some math to calculate. Okay, total amount put in, how much time has passed, how much is yoed? Something like that.
00:28:13.888 - 00:28:33.562, Speaker A: Yeah. Mine was extremely simple. It literally just wrapped ERC's transfer from and you'd approve to the contract and either party when the subscription was due would be able to pay it. It was, I think, fully decentralized. Just need a front end. Started coding one and then got distracted by Heimdall. Gave up on it.
00:28:33.716 - 00:28:43.540, Speaker B: Yeah. Building a UI for one of these tools is actually quite difficult as well. Have you done any UI stuff at all?
00:28:45.610 - 00:29:02.380, Speaker A: For other things, yes, but not for Heimdall. Someone named Ape Dev on Twitter made a UI for Heimdall, and it's very simple. You put in the contract address and it'll spit out whatever Heimdall has at the time.
00:29:02.830 - 00:29:04.874, Speaker B: I think I remember seeing. Yeah, yeah.
00:29:04.912 - 00:29:28.850, Speaker A: It's called decompile tools. Yeah. It stays relatively up to date with the Heimdall version. So I have a release coming very soon, hopefully within the next few days. And I think he picks it up almost instantly whenever I release on GitHub. He told me he set up a cron job or something to just look for updates. Yeah, it's pretty cool.
00:29:28.850 - 00:29:41.298, Speaker A: It makes it a lot easier to use the tool because if you're compiling rust, it takes literally 10 minutes, 15 minutes to build the binary. And not many people want to trust a binary that you just download from GitHub.
00:29:41.474 - 00:29:42.742, Speaker B: Oh yeah, for sure.
00:29:42.876 - 00:29:44.262, Speaker A: I understand all that.
00:29:44.396 - 00:29:48.220, Speaker B: It could be like malware or some ransomware or something like that.
00:29:48.590 - 00:29:49.434, Speaker A: Yeah.
00:29:49.632 - 00:30:01.280, Speaker B: Speaking of ransomware and malware, have you ever wondered about the world of outside crypto in assembly and apply like this to web two kind of stuff?
00:30:02.050 - 00:30:32.280, Speaker A: Not really. I've looked into some x 86 assembly and like Ghidra and stuff. I've tried reversing things before, but I never really fell in love with it like I did with EvM. I'm not really sure why. I think EVM is just really simple in my mind now. It makes sense to me, but if I ever did want to port or convert to web two stuff, I don't think it would be that much of a lift to get back into assembly and reverse engineering stuff.
00:30:33.050 - 00:31:07.700, Speaker B: Yeah, I think reverse engineering on web3 is more financially incentivized because I think a lot of teams are willing to pay or even just like basically black hats or anybody. Yeah, basically anybody wanting to take money or analyze a contract to exploit it, that's the only way you can really do it. If they don't have a verified contract and if you're trying to be like a white hat, that's also a way you're going to have to do it.
00:31:08.950 - 00:31:23.638, Speaker A: You'd be surprised at how many unverified, exploitable. Actually, you probably wouldn't be surprised, but there's so many unverified, exploitable contracts out there just through things like they use message origin and stuff like that.
00:31:23.804 - 00:31:46.030, Speaker B: Yeah, I'm pretty sure that's what grog capital was doing when he was doing exploits on. I think that's what he was doing. It might not have been him, to be honest, but there was like this time, a period that really, that's actually the thing that got me into all of this, is seeing basically people attack each other in Mevland where they were exploiting each other's binaries.
00:31:47.410 - 00:31:50.254, Speaker A: Yeah, there was a lot of drama with that.
00:31:50.452 - 00:32:12.738, Speaker B: Yeah, that was like the most interesting thing at the time for me. And I remember looking at that on Twitter. I'm like, wow, I want to get into this. And then I saw you already building it and I was like, okay, it was public good as well. So I started actually learning your one and then building my own alongside it. And now we're both still going. I wonder if you're ever going to get into formal verification.
00:32:12.738 - 00:32:15.378, Speaker B: I think that would be a very fun kind of arc.
00:32:15.474 - 00:32:25.306, Speaker A: Yeah, I think it would be very fun, too. That's like, just correct me if I'm wrong, but formal verification is like just doing math to figure out if contracts do exactly what they say they're going to do, right?
00:32:25.488 - 00:32:30.150, Speaker B: Yeah, I think it's along the lines of like, okay, is this doing what it's meant to do?
00:32:30.240 - 00:32:48.002, Speaker A: I think I would eventually look into that. I tried making an audit module for Heimdall, which would look for common vulnerabilities like reentrancy, just analyzing the CFG and stuff. But that's not really formal verification. I think it'd be pretty interesting to look into.
00:32:48.136 - 00:33:32.574, Speaker B: Yeah, I think the best tool out there right now is Brock's pyrometer, where it shows you the bounds. Yeah, the bounds would basically show you ranges of how the upper bound and lower bound is the maximum value, that can be that. Basically this value can be variable. Sorry. And the lowest and highest value, this variable can be basically. And then it just goes through the whole list, kind of like an intermediate representation using like A-B-C all that kind of stuff as unique values. And then going through the code like that, which is pretty interesting.
00:33:32.574 - 00:34:13.998, Speaker B: And I think he's also got like taint analysis on the horizon. I'm not sure how much they're working on that stuff, but I implemented taint analysis and it's pretty good. It's TLDR. It's basically you taint or opcode quote unquote taint, which is like dyeing something like, let's say you put some dye in like a water stream, and then the water stream has different pipes. You get to see where or maybe not die, but let's say like a little boat. And the boat goes down the water stream and you can see which way it goes down. And I guess the flow in this instance is basically the opcodes that are consuming that.
00:34:13.998 - 00:34:52.486, Speaker B: And then you can see basically what that original tainted opcode is influencing down the line, which is very useful if you want to see. Okay, specifically what cold auto load is affecting what, right. And what m store at a specific value is affecting other stuff. And then through that, that's how you kind of identify what to target if you're analyzing something. Well, at least that's the route I've taken. I could be different, I could be wrong, could be inefficient. But I don't really know if there's.
00:34:52.518 - 00:35:07.920, Speaker A: Anything else that sounds really familiar to what the wrapped opcodes do. Because you can pinpoint exactly which opcode instruction, whatever came or gave that value to the operation you're looking at.
00:35:09.170 - 00:35:50.910, Speaker B: Yeah, symbolic. I can't speak today. Symbolic analysis is super interesting, but it is also very computationally heavy. And when you have basically like for loops and for loops and if statements, it's basically like how many, it gets exponentially more difficult and more lengthy to compute. So let's say you have a for loop going for ten rounds, and then for each loop you have a for loop nested inside for another ten rounds. And then basically that's ten times ten. That's basically your computation.
00:35:50.910 - 00:36:28.278, Speaker B: But yeah, it gets quite challenging. But I guess that's what symbolic analysis is. And I guess if you're doing this bound analysis with the symbolic stuff, it lowers it quite a lot. But even then, let's say the maximum value for something is like a uint two, five, six. And then you've got a lot of stuff to iterate over, right? And you've got to find something that will pass a require statement or something like that. Yeah, it's interesting, but I guess what is next for Heimdall on the horizon?
00:36:28.454 - 00:37:35.402, Speaker A: I have a roadmap laid out right now. I'm working on a new module called snapshot, and it's going to be very similar to decompile, but with more accurate data and only on the function level. So it's going to look for all the functions in the contract, determine their types or determine their parameter types, and then it'll report back a list of all these functions, their signatures, selectors, and then it'll also include things like access control. So if you're not the address in storage zero, like you're not the admin, you can't call this function. And it'll do gas analysis as well to see what's the highest, lowest, and average gas for that function. That's going to require an overhaul of my vm, because my VM doesn't have dynamic gas at all, it just has static values. It doesn't care about warmer, cool storage slots, but basically TLDR.
00:37:35.402 - 00:37:44.500, Speaker A: And the module is just going to dump a list of all the functions in the contract and then tell you a lot of useful information about each function.
00:37:45.350 - 00:37:56.626, Speaker B: I think this would even be useful for gas optimizations as well. So basically, using Heimdall to see, okay, what is consuming the most gas and where can we change it.
00:37:56.648 - 00:37:59.222, Speaker A: But I think, like, on an upgrade level.
00:37:59.356 - 00:38:05.080, Speaker B: But I guess people really want gas optimizations at a solidity level, so I wonder if that would even be.
00:38:06.250 - 00:38:31.760, Speaker A: I know, I think it's foundry probably has a way to measure gas as well. Yeah, it would be cool if Heimdall had a way to measure the gas or the average gas that an opcode consumes for the entire execution. I guess it runs the execution like 100,000 times. And it's like, on average, this opcode got called 90,000 of the times. And you could probably remove it if you did this.
00:38:32.370 - 00:38:39.218, Speaker B: Yeah, sure. Okay. Yeah. So if it's not being used a lot, you can kind of replace it with something else, right?
00:38:39.304 - 00:38:47.330, Speaker A: Yeah, but then you get into problems with ether scan never verifying contracts that aren't directly coded, directly compiled by solidity.
00:38:47.830 - 00:39:00.360, Speaker B: Yeah, that's a thing. So maybe alternatively, we should just work on the solidity compiler and make it better. Just drop whatever, everything would probably improve it. We should just make a rust version, right?
00:39:00.970 - 00:39:03.770, Speaker A: Oh yeah, just compile rust to EVM.
00:39:04.590 - 00:39:38.520, Speaker B: I think nascent just picked up plotchy as well, so that they should be getting quite some new improvements. But I've spoken to quite a few people in the space, and they say the formal verification scene is quite bad. So I think definitely you should take this route and get into formal verification. I think personally it's insanely interesting, and I think the upside is way higher than what you'd think it would be, because it's such a niche, right?
00:39:38.890 - 00:39:39.542, Speaker A: Yeah.
00:39:39.676 - 00:40:01.146, Speaker B: Who wants to learn this stuff? I think I can count like five people, including us, who are actively building basically these kind of tools. And from like the huff or maybe six people. But yeah, it's so hard and it's such a missing market. Like, there's nothing out there to the.
00:40:01.168 - 00:40:03.482, Speaker A: Little community of EVM hackers.
00:40:03.626 - 00:40:47.862, Speaker B: Yeah, tooling is such a necessary thing, but it's lacking. I think even I spoke to Harrison about this, even like some kind of automated tool to find in solidity where you could improve. So it's hyper optimized. So for example, using, instead of using storage, and then storing that stored value in a memory slot in a for loop, and then using that memory slot, you could identify that, and if it's using the same value, you can push it outside of the for loop. And so it could loop over just like a memory value instead, or. Yeah, just like that. So you're not calling the storage each time, so maybe that would be pretty useful.
00:40:47.862 - 00:40:52.990, Speaker B: Or have you thought about doing that for Heimdall, especially since your one's catered for?
00:40:53.140 - 00:41:27.762, Speaker A: Yeah, I think Heimdall is going to stay relatively close to bytecode. So if I were to go into analyzing just direct solidity files, it would probably end up being a new project just to keep the scope the same. But yeah, I do think there is more of a need for people like us doing EVM stuff, because formal verification can discover any exploit in any contract. It's like a very thorough and useful thing. I think it can even find compiler bugs, if I'm not mistaken.
00:41:27.826 - 00:41:32.538, Speaker B: Yeah, I think you can do kind of everything if you make it the right way, right?
00:41:32.704 - 00:41:37.130, Speaker A: Yeah, but it requires a ton of work, and there's so many edge cases.
00:41:38.270 - 00:42:13.062, Speaker B: Yeah, you basically have to be in order though, and also know the compiler really well. You basically need to be like a jack of all trades, but like a master at everything. Because without knowing the compiler, you won't be able to build the fundamental, I guess not tools, the fundamental groundworks. And then without knowing auditing, you won't know what to actually look for and make heuristics for. Right. So you've got to do that, and then you've also got to make it efficient so it doesn't take days to run. And it's also got to find the things as well.
00:42:13.062 - 00:43:20.640, Speaker B: Yeah. My tool specifically is built for critical findings only and unique findings. So how does it interact? Basically, how can I manipulate the bytecode in a way where I can select what input is being used, where, and what storage I can interact with and influence, and then also, how can I basically take tokens from this or EFA, if it's even possible? My methodology was, if the only thing that's really necessary to basically exploit something is taking the money and mutating a state, then that's all you should look for, right? Like, you don't need to look for mediums or lows or any of that stuff because it's not critical. And the only thing that blackheads look for are the critical things, things that can steal money. So that's kind of like what I'm doing, which should be quite interesting. If it fails, then, well, I've just learned a lot of stuff and I can go work for someone else, like maybe NASA or something.
00:43:22.050 - 00:43:48.130, Speaker A: That's one of the fun things. If your project doesn't take off or if no one uses it, it's still learning opportunity. No one used Heimdall like the first python version. I would still be working for transpose. And now chain analysis. I would have all this EVM knowledge, not to the extent I do now, but still have that knowledge. It'd be a great experience.
00:43:48.130 - 00:43:52.600, Speaker A: And then I could move on with my life and probably find something else great to do.
00:43:53.290 - 00:44:25.342, Speaker B: Exactly. Yeah, it's such a great set of tools to learn. I think anybody should really, if they want to get a thorough understanding of basically like bytecode level and basically even learn Hof, you can learn huff through this because I started without even knowing huff. I was just reading EVM codes just like you, and trying to implement my own vm. And to do that, you have to know how everything works, right? And then through that you can learn other skills. And for me, that was huff. And then I kind of specialized in that for a couple of months.
00:44:25.342 - 00:44:41.320, Speaker B: I'm still in contract work and then still doing this on the side. Touching on that. How do you schedule your days? You're working on Heimdall consistently while working your full time job? Because if you don't work on something consistently, you kind of doesn't really take off, does it.
00:44:41.930 - 00:45:05.070, Speaker A: Yeah, I think one of the main things to making a project take off is being active and making sure you're engaging with people and putting yourself out there and getting them to actually use your product. Even if it's open source and it's just a project that you do in your free time. I think it's important to do all that. But basically I work for 8 hours a day.
00:45:05.220 - 00:45:05.630, Speaker B: Nice.
00:45:05.700 - 00:45:30.230, Speaker A: Then I come home, go on a walk, go to the gym, and then anytime I have left, I just pretty much work on Heimdall or other projects. During the school year it's pretty much the same, except I have school as well. So most of my work gets pushed to the weekends and most of my Heimdall work gets pushed to the weekends as well. But it's a fun balancing act between work, school and Heimdall.
00:45:30.650 - 00:45:59.162, Speaker B: Yeah. Passion project. Yeah, I think it would definitely be interesting to see how it all plays out in the future. Maybe someone tries to hire you for something like that, or pay. Even a vc might come along and just want to throw you money to build it out or like a sponsorship endorsement kind of thing. But yeah, I think you're definitely on the right path and it's going to be exciting to see what's up next. We are getting close to the end now, but I would like to say thank you very much for coming on the podcast.
00:45:59.162 - 00:46:03.360, Speaker B: I know this is your first time and hopefully it's been a good one.
00:46:04.150 - 00:46:05.378, Speaker A: Thank you for having me.
00:46:05.464 - 00:46:39.306, Speaker B: Yeah, of course. And I think it's very insightful as well. Maybe this has inspired someone to basically pursue the path you've taken and basically dabble in the harder in these hard problems and try and create these solutions. Because I know when I started, I got inspired from the people I wanted to be like and then basically tried it myself and there wasn't a lot of content on those people talking. So I think it is very useful and very valuable for people in general when they listen to this. Well, if they listen to this.
00:46:39.328 - 00:46:53.182, Speaker A: Right. Yeah, I think if you're looking to get into EVM stuff, you should definitely do it because you're going to learn. It's going to be fun. There's a community of people who all just support each other. It's pretty great.
00:46:53.236 - 00:47:15.446, Speaker B: Yeah. And I think don't be discouraged that it's just crypto. It relates to web two as well. Right. Even if it doesn't turn out well, you can always go into malware analysis or something to do with that, or working with compilers anything. The world is really your oyster when you get into this kind of stuff, at least from my point of view.
00:47:15.548 - 00:47:19.640, Speaker A: Yeah, it's just like a niche of much bigger things.
00:47:20.010 - 00:47:24.230, Speaker B: Yeah, pretty much how much a niche can expand into more niches.
00:47:24.570 - 00:47:25.320, Speaker A: Yeah.
00:47:26.570 - 00:47:31.040, Speaker B: But, yeah, man, it's been such a pleasure and I hope had a good time.
00:47:31.730 - 00:47:32.960, Speaker A: It was really fun.
00:47:33.490 - 00:47:40.860, Speaker B: I'm glad. Yeah. I hope the audience has an enjoyable time. And until the next one.
