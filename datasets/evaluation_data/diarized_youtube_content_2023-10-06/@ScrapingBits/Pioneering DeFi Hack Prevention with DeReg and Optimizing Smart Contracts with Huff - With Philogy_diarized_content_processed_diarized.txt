00:00:00.570 - 00:00:53.674, Speaker A: It. So what Solidity does is if you use data types and they actually fit together within the 256 bits is it'll actually put them in the same storage slot. And this will save you a lot of gas because outside of the operation itself of reading and writing to storage, like reading from two different slots costs more than reading twice from the same slot because there's this concept of warm and cold in the EVM, so there's warm and called storage slots and addresses. The first time in a transaction where you read a slot, it'll have like a one time fixed cost because if you imagine what the blockchain client is basically doing in the background is that it has to read the disk and then afterwards it's in Ram, right? So it can just quickly access it. But that first overhead, it basically has to account for that. So that alone is a lot of the savings. And then also, like modifying the same slot multiple times is cheaper than modifying two separate slots.
00:00:53.674 - 00:01:02.830, Speaker A: Packing basically allows you to leverage those savings without really having to worry about it yourself, just by using smaller data types in your structs and variable definitions.
00:01:04.130 - 00:01:07.198, Speaker B: GMGM Villagey. How's it going?
00:01:07.364 - 00:01:12.210, Speaker A: GMGM Digotchi great to be here. Cool that you're starting a podcast.
00:01:13.350 - 00:01:20.678, Speaker B: Yeah. This is a first time and we're going to see how this goes, but let's start off with who you are and what you do.
00:01:20.844 - 00:01:34.806, Speaker A: My name is Philip. I'm known online as Philogy, and I'm a smart contract developer, auditor, and just like, general Optimizer and currently working as a co founder on Drag, a security project that focuses on circuit breakers.
00:01:34.998 - 00:01:51.002, Speaker B: Circuit breakers, interesting. So past auditor, now optimizer developer. So I want to learn about a bit of your starting of your career. So let's start with that. Let's dive into the start of your career and see how it progresses.
00:01:51.146 - 00:02:16.630, Speaker A: Yeah, so I started coding very early. Actually, the first time I coded was like, at the age of ten, but then I didn't really know how to code. I wasn't very good at it. I almost gave up with it, but I continued doing it on the side very slightly. But I stupidly. As a small kid, tried to start with really hard languages like C plus plus and C sharp. But eventually, at the age of 14, a friend showed me Python, and that's where everything kicked off.
00:02:16.630 - 00:03:03.974, Speaker A: And I really got into just like, programming and doing just different bits and bobs of my computer. And that was actually really cool. And at the age of 15, I got my first unpaid internship at, like, a tech startup, which was really cool because 15, yeah, I was like, writing. I mean, it was part of high school. We had to get an internship at a company, and most people, they just went to kindergartens or like, a hospital or somewhere to just like all right, got you. Do their one week, but my brother was working at a tech startup at the time and I asked him, hey, could I do something cool for my internship? Do you think I could maybe get a spot at the start you're working at it's like, okay, I have to ask my bosses. And then I said, okay, well, they're a startup and they don't really have time to babysit a kid, but if you can pass this small coding test, then they know you can actually maybe even help them a little bit during the one week.
00:03:03.974 - 00:03:23.722, Speaker A: So they gave me like a small coding test that I did on my phone in the school, like lunch break, and then I actually passed, so that was cool. And then I got the one week there and then I actually asked them if I could work for them in the summer and then when I was 16 in the summer holidays, I went back to work for them full time for like one and a half months.
00:03:23.776 - 00:03:24.074, Speaker B: Oh, nice.
00:03:24.112 - 00:03:38.082, Speaker A: Which is also really cool. So I was just like doing front end development and debugging actually it was really annoying because I was the only person who had like a Windows laptop, everybody's working on Linux, so what they had me do all the time was debug the Internet Explorer bugs in their front end.
00:03:38.136 - 00:03:39.140, Speaker B: Oh, interesting.
00:03:39.990 - 00:03:42.354, Speaker A: It was a really annoying start, but.
00:03:42.392 - 00:03:44.260, Speaker B: Mini auditor at the start.
00:03:45.190 - 00:04:46.342, Speaker A: Yeah, basically that's like how I got my intro to Tech and then it just went on from there. I continued to work at the startups where my brother was working at and eventually he founded his own and I worked for him there for a while before quitting that to just be a freelance smart contract developer. When I was at the age of 17, next to high school, I started freelancing for just random different companies. And this Dow that I worked for for a while called Onehive, I worked for them for, I think almost a year. Got you next to high school, just like working different projects, which was actually really fun and also earned me like a bit of pocket money, which was cool as a high school student. And then eventually I went to university, started my CS degree, but then I very quickly realized that was not for me. And then when Quant Stamp, the security company, gave me an out via a job offer, I was like, yeah, hell yeah, I'm going to take this because instead of learning about CS fundamentals, I get to learn about crypto and earn a pretty decent salary, especially for 19 year old kid straight out of Uni.
00:04:46.342 - 00:04:47.640, Speaker A: So I took that.
00:04:48.650 - 00:05:01.814, Speaker B: How did you get that offer from Quant Stamp if you just came out of Uni, didn't have any experience, was it just kind of like you had a connection there or did you do sort of auditing on the side and gave reports and made sort of a resume.
00:05:01.942 - 00:05:25.714, Speaker A: So it was my first real security job. But before, as I was freelancing, I already taught myself about security just as an effort to become a better dev. Because I realized, yeah, I'm a developer. I'm writing these things for the Dao. But what's the next step to getting better? And then I realized, hey, a big part of DeFi projects is that they get hacked. And as a good developer, maybe I should write code that doesn't get hacked. So I started learning about security just from the perspective of a dev.
00:05:25.714 - 00:06:01.194, Speaker A: So I did the Ethernet challenges and the puzzles and just learning about security. And it was very fun to just try and take apart code and see how you can write code in a more intentional way. And then how I got the job, actually was that at university they had like, this hackathon, and then there are all these big old boring web two companies, I forgot how they're called, but Salesforce, these really big companies, conglomerates that do these different types of softwares. But Quantstamp was like the only crypto company there. I was like I was so excited because I was really into crypto at that time. I was like, okay, only crypto company there let me do their hackathon. Which is like a security challenge.
00:06:01.194 - 00:06:41.514, Speaker A: So basically, you had like two phases. First, you had your team as part of a hackathon, you always have to make a team. And it was this really cool challenge because the first step you had to develop a smart contract that fits like a spec. And then at the second step, you had to deploy your smart contract to a testnet, and they had to try to hack the smart contracts of the others. So obviously we were at a real advantage because I was basically the only person in the entire hackathon participating in the challenge who had any major smart contract experience, let alone security experience. So we kind of crushed it because of that. And then after that, the guys at Quantum were like, hey, that was actually a really cool performance on your part.
00:06:41.514 - 00:06:49.760, Speaker A: Do you want to apply and see if you get a job? And I was like, hey, I'm a first semester CS student. I don't think I have a chance here. And I said, yeah, just try, just apply. Let's see.
00:06:50.130 - 00:07:02.340, Speaker B: Right. Sorry. It all started at like a hackathon, basically. And you just performed? Yeah, exactly. And then they just were like, yo, come apply, you've got a chance. Don't worry about it.
00:07:03.190 - 00:07:04.850, Speaker A: Exactly. That's how it was.
00:07:04.920 - 00:07:22.634, Speaker B: Word. And so from that you applied and then you obviously got in. Right? I guess what was kind of like that onboarding process of, okay, going from a smart contract dev to, I guess, like a junior auditor at the time. How was that actually?
00:07:22.672 - 00:07:57.410, Speaker A: Funny thing, they hired me directly as a senior auditor there. Yeah, but the way that worked so yeah, I had the coding interviews. They had like a three step interview process. The first was like solidity security tests. Then they had like a general web two security test and then they had a general coding test. But apparently I did so well in the first two that they said, yeah, we'll just skip the third and I'll just go straight to salary negotiation stuff. So we went to that and I just chatted with them and then I accepted the offer.
00:07:57.410 - 00:08:07.254, Speaker A: Initially it was part time because intended to I had like this small side project I was working on that I wanted to continue building next to my job. So that's why initially I went part time for them.
00:08:07.292 - 00:08:07.898, Speaker B: Got you.
00:08:07.984 - 00:08:31.230, Speaker A: And then the onboarding process was pretty cool, I think, almost immediately. So the first one, two weeks was just like re auditing an old client because they had like the standard basically repo that they had new auditors basically just look at and find issues on to basically get them familiar with the process, with how you write notes.
00:08:31.970 - 00:08:33.630, Speaker B: A bit of shadow auditors.
00:08:34.790 - 00:09:05.020, Speaker A: Exactly. And then I got assigned to my first audit, which was actually really terrible just from the perspective of what I had to audit. Yeah, because it was like this really messy, really bad code base, which was like a fork of urine. And they had like 20 different strategies and adapters that were all really badly tested and written. Okay. No coding practices and just like finding issue after issue, just like really basic things you're basically thrown into the weekend. Yeah, basically.
00:09:05.630 - 00:09:27.040, Speaker B: But it was cool and kind of like the worst of the worst, right? I guess. How do you even deal with that kind of raw project? And how did you approach going against that? Because usually what you would hope is a project would have great tests, great documentation, and that wasn't provided. Right. So how did you go about doing that?
00:09:28.050 - 00:10:01.846, Speaker A: I just went through it step by step. So I looked at the project as a whole. I spoke to the team and we understood what they want their project to do. Right. Was it like a yield aggregator? There are different strategies and then just going through the files one by one, seeing based on what they were named, like what they were meant to do. So, okay, this is like a strategy for compound token, compound USDC or whatever it was. And this strategy, because basically the way urine vaults work is you have the vault and you have all the strategies that plug in essentially those g contracts, like this modular architecture.
00:10:01.846 - 00:10:36.934, Speaker A: And so I was looking at the individual strategies and like, okay, here there's no slippage checks like, here, okay. Some decimal, whatever. And just like going through it. And that was basically the process, like going through it and doing a manual review. And also when you have a code base like that, it's basically just like uncovering the amount of huge mountain of issues you're going to find and giving that to the client. And then hopefully they'll realize, okay, our code is really bad, and they go back to the drawing board or do more heavy testing on their end. But I feel like that's kind of common.
00:10:36.934 - 00:10:54.830, Speaker A: Or not that common, but it did happen a lot that you had clients that just didn't have the best code bases, or at least not the way you wish they were as an auditor. Okay, ideally they have these great tests, they have a specification, they have docs, they have Natspec comments everywhere. But yeah, it's rarely like that.
00:10:54.900 - 00:10:59.646, Speaker B: All your expectations were just not there, basically.
00:10:59.828 - 00:11:26.546, Speaker A: Yeah, exactly. Because at the time, I didn't know how much firms charge for audits to their clients. But I imagined, like, hey, if you're going to hire these external professionals to look at your code, I'd imagine you would first invest, like, a tiny bit of effort into just at least applying a code formatter, maybe adding a few comments, maybe docs, hopefully. Hopefully, yeah, that was really present, which was very surprising, like, okay, yeah, it's.
00:11:26.578 - 00:11:52.526, Speaker B: Quite interesting that projects don't do that because it definitely helps with the process of building the projects in the first place. But then you have these outside contributors basically criticizing code and trying to understand it like a whole project from scratch, basically in a couple days or weeks and they have nothing to reference. So it's kind of crazy that it's not common. But then what happened after Quantsep? You're not working there now. So what kind of happened after?
00:11:52.628 - 00:12:32.534, Speaker A: Yeah, so what happened after is I was working there and then eventually I realized I don't want to be an auditor. Not only because I wasn't really having that much fun, I realized that also internally when we were given a bit of side time to do side projects, I was just really interested into how do you develop smart contracts better your focus. On one hand you see the path. Yeah, exactly. And also just realizing I just didn't enjoy auditing that much. It was just like looking at these code bases with kind of the similar vulnerabilities and it's just like projects basically forking each other and it wasn't really that interesting to me, I realized. And then eventually I also realized as a person, I wanted to have more impact or more scale.
00:12:32.534 - 00:12:46.654, Speaker A: And whenever you're working as an auditor, as a software developer, it feels like you're very limited in terms of the scope of your impact. So I just wanted to go back to working my own projects and so I left to start a project with my brother.
00:12:46.782 - 00:12:51.090, Speaker B: Oh, with your brother. So that's your project, Drag, right, exactly.
00:12:51.160 - 00:12:51.538, Speaker A: Yeah.
00:12:51.624 - 00:13:01.682, Speaker B: And that focuses on security standards and infrastructure. So I guess what are you building now with Drag and what's kind of in the pipeline?
00:13:01.826 - 00:13:53.094, Speaker A: Yeah, so what we're building right now is so we're building on two paths because me and my brother, we have different expertise and focuses, but they will overlap and combine down the road. But basically we're building on the one hand, we're building circuit breakers. This is like on the smart contract development side, this is meant to be like a standard and library. You can integrate into your code to easily add, like a backstop, essentially, in your code. So even if your core logic is faulty or has a mistake, the losses from an exploit will be capped, like whatever rate limits you set. And then on the other side, we're building infrastructure to monitor transactions and DeFi protocols. So that'll plug into the circle breaker in the sense that once you have the circle breaker, you want to know when rate limits are hit or when suspicious activity is engaged, that you can intervene and pause the protocol when needed.
00:13:53.212 - 00:14:03.242, Speaker B: Okay, so basically it's like a pause when there's a certain amount of activity happening. Got you. And what kind of got you into building this stuff.
00:14:03.376 - 00:14:54.890, Speaker A: Yeah. So I actually had the idea for this while I was working as an auditor, and I was just thinking, is there a low technical complexity way that is like, general purpose for DeFi projects, for them to secure their code base against logic failures in the main code? And then I thought of this really simple architecture where what if you have your DeFi application and then you just put it in a standardized container that just delays all the outflows of assets so that you can track them off chain and then stop them if they're malicious? Because this can be applied to basically any DeFi protocol where its main targets are its assets. You can just put it in a wrapper that says, hey, anytime an asset goes out, it'll leave, but only after delay. So we can just keep track of it and see if anything goes wrong. We can block it.
00:14:54.960 - 00:15:08.080, Speaker B: Right. So if someone basically an exploit, you would see like a massive amount of tokens being in like a backlog. Basically you'd be able to identify that and just stop it. Correct, exactly.
00:15:08.770 - 00:15:21.202, Speaker A: That's the goal. So it doesn't say, like, hey, we'll prevent your code from ever having bugs. We'll say, okay, we'll assume your code has bugs. But when it does, how do we create a system that can catch that in a general way and be applied to basically any project?
00:15:21.336 - 00:15:38.566, Speaker B: Right. And I guess one of the cons of that, that's a terrific pro, but I guess one of the cons is, what if someone desperately needed that at an instant? Is that something like configurable or something for a protocol? Because it's kind of like a double edged sword in a way.
00:15:38.748 - 00:16:22.306, Speaker A: Yeah. So that's one issue you don't get like direct atomicity. So there's basically two ways you can kind of mitigate this, but you can't fully solve it is on the one hand you can use a rate limiter. So instead of delaying everything by default, you can have your project have like an on chain rate limiter that basically tracks the in and outgoing volume and then it says, okay, funds can flow freely instantly in one transaction as long as the general volume is within a certain bound. And basically what that does is let's say you can at most withdraw 10% of the TVL within 24 hours. So in most cases funds will flow freely. And if there's ever an exploit, then you'll cap your losses at the max drawdown which you can set as a parameter.
00:16:22.306 - 00:16:32.810, Speaker A: So if it's like 10%, then you'll lose only up to 10% of your TBL within the 24 hours. And then if you have a monitoring system, you can react fast enough and shut it down. That's the first way.
00:16:32.880 - 00:16:33.450, Speaker B: Got you.
00:16:33.520 - 00:17:20.826, Speaker A: And the second way, what we're working on, what we haven't quite started working on, but what we think will be like the big thing is real time underwriting. So basically what you can do is you can have a risk taker, a third party that basically pays out the value of your transaction in advance and basically gets paid out once the actual outflow gets settled. And what this does is that for users of the protocol, it looks like they're having like an atomic interaction in the sense that in one transaction they're submitting it to the chain, it gets mined and then they gets included in the block and then they get their assets out of the protocol. But what happened in the back end is that actually they got paid out by a third party that is actually getting their withdrawal and then they have to pay like a tiny spread or fee on it.
00:17:20.928 - 00:17:26.218, Speaker B: Interesting, right? And again, what made you think of this to build?
00:17:26.304 - 00:18:15.430, Speaker A: What made me think of the underwriting part? I know, I was just like just thinking from it from first principles. So you have this fundamental reality that transactions are slowed down now. So what are ways where you can basically still have the security properties of you can essentially reverse or block the backlog, but you can still have end users or have it seem like for end users, their transactions are instant, and then basically, it's like the only way you can do that is if somebody else pays out the funds. But that creates a cool ecosystem where you can have multiple real time underwriters competing and being experts in underwriting different transactions and basically pushing down the spreads for users so that fees are extremely low. And also just like calculating what rate of return these underwriters might expect, like the fee is probably going to be super low like in the low basis point range.
00:18:15.510 - 00:18:48.070, Speaker B: Yeah. Got you. And some other projects you've made have also been in Huff. So basically the lowest level you can get basically writing in bytecode except a step higher. So mnemonics. And you've written the most optimized version of weave as far as I know. Can you run us through that? How did you even get into that? And why did you think of doing that in the first place? Was that kind of like a yeah, continue.
00:18:48.070 - 00:18:49.240, Speaker B: Sorry, my bad.
00:18:49.850 - 00:19:34.286, Speaker A: Yeah, so wrapped ether. So also from my auditing days, I saw a lot of times where people were using wrapped ether with certain patterns, I would say. So like a very common pattern that is even present in uniswap is like the deposit and transfer pattern. So you would one time call wrapped ether to deposit ETH, essentially wrapping it to wrapped ETH and then transferring it using an ERC 20 transfer to an address. And other times where you transfer from and then unwrap it into ETH and then send the ETH somewhere. And all these super common patterns. So that's kind of like the first thing, like creating contracts that allow you to execute those within one call because it's not only about essentially bundling all of these steps into one call to save on the call overhead, but it's also under the hood.
00:19:34.286 - 00:20:24.174, Speaker A: What happens is that you have these ERC 20 balancers that are changing for the sender and recipient and then changing the recipient again and all these gas calls add up. So just like having a contract that allows you to bundle these patterns into one call, but then looking deeper into wrapped ether, I saw how fundamentally was the ecosystem in terms of how much gas is spent yearly in ethereum, just like interacting with wrapped ether. I think from the numbers I've seen, it's like 5% to 7% of all gas on ethereum is spent within wrapped ether. So I thought, okay, it might be really worth it to rewrite it from scratch at the lowest level to save every single gas possible because these functions are going to get called like millions of times. So if you can actually get people to use your new implementation, you can potentially save the ecosystem like millions of dollars yearly in gas fees.
00:20:24.222 - 00:20:28.680, Speaker B: Yeah, 5% or whatever they're using. Well, not 5%, but like a portion of that.
00:20:29.690 - 00:20:30.598, Speaker A: Yeah, exactly.
00:20:30.764 - 00:21:22.594, Speaker B: Wrapped Efer is in almost every protocol or it's integrated in some way. So I wonder why maybe you can make like a standard and people adopt it. But I guess the only downfall is like the tooling for huff and testing it is honestly not the best from experience. Maybe someone looks into tooling. But you see big protocols like Seaport, like OpenSea, they had tons of transactions going in. Like the biggest NFT platform in the world is just millions of transactions. People are spending unnecessary gas because the Solidity compiler isn't as optimized as writing a hyper efficient contract like this hyper optimized weave contract.
00:21:22.594 - 00:21:27.960, Speaker B: So it's definitely like a massive market, but I guess why don't people use it in know.
00:21:29.690 - 00:21:30.878, Speaker A: You mean my weave.
00:21:30.914 - 00:21:33.430, Speaker B: Implementation or Huff just in general, like Huff.
00:21:33.590 - 00:22:30.170, Speaker A: Yeah, I mean, the issue with Huff is that, number one, the amount of auditors you have in the industry is already kind of limited. And then if you look at auditors that are able to really give you good guarantees when auditing, Huff is probably even smaller. And then in general, as you mentioned, the tooling is not that great. And also, there's so many foot guns. There's a reason Solidity has all the overhead it does on the lower level is because it really maximizes safety and it says, yeah, rather than risk having a bug in the compiler by doing this small shortcut here, we'll just have it in a verbose safety first way and then ensures, I think, in the history of Solidity. Also, I think there's very few times, if ever, that you had a really severe bug in the actual compiler itself. I think there's only one or two you can recount for the entire history, which is quite impressive for a code base that is as complex as Solidity.
00:22:30.170 - 00:22:54.146, Speaker A: And then if you write Huff, you get all the advantage of having direct access to the bare metal of the EVM. But then you have all these things that you can do wrong. Now you don't need it anymore. But an old trick used to be they use the return data size opcode. So you can push a zero to the stack with two gas instead of three. But for example, if you call another contract, it can change the return data size. And if you're still using it afterwards to push zero, it might actually push another value.
00:22:54.146 - 00:23:10.378, Speaker A: And then it can have a bunch of cascades skating effects. Or if you have your custom memory layout, then you can accidentally overwrite things, can override each other in memory or custom storage layouts. You can have collisions between different mappings and all kinds of funky things.
00:23:10.464 - 00:23:39.650, Speaker B: Just basically like a master. You're just introducing new attack vectors and maybe you're not experienced with it. It's very easy to basically forget about what's happening on the stack. Even if you write it out. It's quite difficult to kind of keep everything in your head, especially jumping from implementing stuff. And then, okay, I've got this, I have to change the start of it because you're basically managing the stack and what's going on in that. Yeah, it's quite difficult.
00:23:39.650 - 00:23:53.110, Speaker B: But you've also built other projects like ERC Seven Two One H, which is a Huff Rewritten version of ERC Seven Two One A. So I guess that's kind of like the same thing, isn't it?
00:23:53.180 - 00:24:43.318, Speaker A: Yeah, that was like my first big Huff project. So I just wanted to really get into Huff and use Huff. And then I saw that ERC 721 A was like the hyper optimized implementation of ERC 721 that everybody was using at the time during the NFT Hype because you could batch mint like thousands of tokens for really cheap in comparison to other implementations. So I thought, yeah, that would be like a cool contender because that's also what kind of like, nerd snipe me into using Huff. It was a way to kind of show off your skills as a dev and show that you can write like a more optimal contract than others. And then I saw everybody putting because by the way, like ERC 721 A by Vectorized is an extremely great contract, but I saw everybody putting this contract, this implementation on the pedestals, like, oh, look at how much gas it's saving me on my newest NFT Mint. And I was like, okay, I want to write this better and show people.
00:24:43.318 - 00:24:51.766, Speaker A: And then, yeah, I just started writing into it and weekend after weekend, just bring it forward because it does take a really long time to rewrite things in half, especially when you're first getting into it.
00:24:51.788 - 00:24:52.390, Speaker B: Yeah, definitely.
00:24:52.460 - 00:25:11.022, Speaker A: But yeah, eventually I finished it off and you constantly get better as a dev. So even looking back to it now because I haven't looked at the code base in a while, there's so many new tricks I've learned writing Huff, even like, looking at my old Huff code, it's not as optimal as it could be or as I would write it today for sure. But yeah, it was a really fun project to build.
00:25:11.156 - 00:25:28.350, Speaker B: So that was your first big project to really get into Huff, I guess. If you were to redo it, what would you do again to basically accelerate this learning? And what kind of difficulties did you have first learning that you wish you knew prior?
00:25:28.510 - 00:26:05.506, Speaker A: I think in terms of relearning, I don't know if I'd really do anything differently, to be honest. I think it's all about the practice because there aren't that many resources about half in the wild. So it really is just like you're almost down to your own to basically learn it and get better. I think another thing that I probably would have done earlier is join communities with top tier devs. Just join the Huff Discord or other discords where people are really focused on yourself. So public discords I can recommend for this are like the Huff Discord and the Solady Discord. There people are really focused on optimization and just making sure contract going to be around people.
00:26:05.608 - 00:26:59.874, Speaker B: You definitely want to be like, right? And I think the Huff Discord is perfect for that. You're getting into the bare bones of smart contract development and it's a very niche skill. And I wonder if there's ever going to be like a Huff auditing market maybe in the future if people start to adopt low level kind of contract development, even though it's quite difficult to build production ready contracts, possibly. I mean, I have no clue. If people continue to use Ethereum as much as now versus like L two S where gas isn't really as important, then we'll see. But yeah, you've. Also built like an ERC seven free free seven.
00:26:59.874 - 00:27:07.560, Speaker B: I mean, four free free seven wallet implementation. Again, another efficient contract. How did you get into that again?
00:27:08.650 - 00:27:59.718, Speaker A: Yeah, it was another nerd snipe. So if you've got a cop here on you, just different people. It was actually a funny story because I made this new friend at Zazalo, like, in Montenegro, and she was basically dev, like, working working on a four three seven wallet. And she was telling me how four three seven wallets are really expensive in production and that they're like, ten x more expensive than, like, an EOA wallet. And at the time, I have never written a four three seven wallet, but I was familiar with the standard, and I was, like, wondering, that cannot be, because in my head, just running some really back of the napkin calculations, I was like, actually, four three seven should be barely more expensive than an Eway, if not cheaper, if you batch, like, transactions. And I thought, okay, this is interesting. Why are they getting, like, ten x worse gas performance? That was, like, kind of the nerd snipe of like, okay, can I do it better?
00:27:59.804 - 00:28:05.702, Speaker B: What exactly is four three seven, just to let people know that don't know.
00:28:05.836 - 00:28:07.558, Speaker A: Oh, yeah, definitely. That's a good point.
00:28:07.644 - 00:28:07.798, Speaker B: Yeah.
00:28:07.804 - 00:28:51.330, Speaker A: So four three C seven is an ERC, meaning it's an application level standard and not the Ethereum, like, blockchain consensus level standard. And basically it's a way to standardize how smart contract wallets can have customized authentication logic, but have a standardized way to validate and basically sponsor gas for these smart contract wallets. Because the issue today in Ethereum is that every top level transaction has to be initiated by an EOA, which stands for Externally Owned Account. So this is an account that's exactly. So these are, like, accounts that are owned by a private key directly, so there's no smart contract code associated with them. It's just like the blockchain says, hey, can you give me a signature for this account? If yes, you can run the transaction. If no, you can't.
00:28:51.330 - 00:29:38.066, Speaker A: Versus smart contracts, which can have any custom logic. And then basically what ERC four Three seven does is it standardizes a way how you can bundle transactions and then have somebody else, like another EOA, which was basically your bundler, that pays for the gas that then actually runs the code of your smart contract wallet. And then your smart contract wallet obviously pays for its own fees, but you need, like, a standardized way to do that because there's, like, a bunch of security issues that you can get if you try to implement that yourself. You can dos bundlers, you can steal wallets. There's, like, a bunch of different things that can go wrong. So the standard basically gives you, like, a secure framework of doing that. And then, yeah, basically I was nerd snipe into, like, hey, this seems like way too much like ten X.
00:29:38.066 - 00:29:55.770, Speaker A: So I just looked into it, started writing my own implementation, and I did get it down, but I did find out at the end that, yeah, ERC, four, three, seven wallets are definitely going to be more expensive than EOAS, but they don't have to be that much more expensive, for sure.
00:29:55.840 - 00:29:58.186, Speaker B: And it's all done in half as well, isn't it?
00:29:58.288 - 00:30:27.454, Speaker A: No, it's not all done in half. So the main optimizations actually come from high level design choices. That's also what I tell people a lot, especially people who are newer to smart contract development. Most of your savings will come from the high level design decisions you make and just using the really expensive resources like storage efficiently. And then half will get you the last mile basically, right, removing Celezity's overhead. But that's really you can get a lot of savings just from the high level.
00:30:27.592 - 00:30:34.706, Speaker B: So what are some examples of some high level pitfalls that people are sort of implementing when it comes to wallets?
00:30:34.738 - 00:30:35.570, Speaker A: Or you mean like generally?
00:30:35.650 - 00:31:00.622, Speaker B: Just generally like Hoppers obviously hyper optimized, the best of the best? Obviously not a lot of people are doing that because it's so niche and unnecessary. A lot of people are doing solidity, that's how they get into it, that's how it's easy to maintain as well. So if high level architecture is a difficult thing to be a master at, what are people doing that they're getting wrong?
00:31:00.756 - 00:31:57.074, Speaker A: Okay, so there's a few things I want to start by. Kind of like a meme rant on the diamond standard. So I would say too many people jump to trying to use the diamond proxy standard for their contracts, which is really unnecessary and has a bunch of other pitfalls besides efficiency. So that's one I would call out here because when you write code using the diamond proxy standard, it can look very elegant, it can look cool, but the end result is often not so cool and unnecessarily complex. But in general it's just like the most expensive thing in the EVM is like permanent storage, like what gets stored between transactions. And basically just making sure you use that effectively is probably one of the larger things that people get wrong. So there's really basic things like if you load a value from storage, like bounds of a token or thing and you need it for a calculation, just store that in a local variable and reuse that a bunch of times.
00:31:57.074 - 00:33:00.322, Speaker A: Or just look through and calculate the bounds on your logic, like how large will a variable ever possibly be? And then you might realize that, hey, this timestamp it will never need more than 32 bits so I can store it in a um, 32 and then this will allow you to basically pack things together. That's like where really big savings come from. So packing is something the solidity compiler does for you automatically. So there's different data types and sizes they take up. So like a um, 32 means it takes up 32 bits the range, and then you have UN 256, which is kind of like the quote unquote default integer type, which is like up to 256 bits, which is also the EVM's internal word size. And that's also kind of if you look at storage, it's written and read from in these 32 byte or 256 bit increments. So what Solidity does is if you use data types that are smaller than that and they actually fit together within the 256 bits is it'll actually put them in the same storage slot.
00:33:00.322 - 00:33:48.686, Speaker A: And this will save you a lot of gas because outside of the operation itself of reading and writing to storage, like reading from two different slots costs more than reading twice from the same slot because there's this concept of warm and cold in the EVM. So there's warm and cold storage slots and addresses. So warm and cold storage slots basically means that the first time in a transaction where you read a slot, it'll have like a one time fixed cost. Because if you imagine what the blockchain client is basically doing in the background is that it has to read the disk, it has to put it into Ram, and then afterwards it's in Ram, right, so it can just quickly access it. But that first overhead, it basically has to account for that. So that alone is a lot of the savings. And then also modifying the same slot multiple times is cheaper than modifying two separate slots.
00:33:48.686 - 00:33:59.446, Speaker A: So things like that. And then that's packing basically allows you to leverage those savings without really having to worry about it yourself just by using smaller data types in your structs and variable definitions.
00:33:59.638 - 00:35:07.600, Speaker B: Yeah, the main high level I think is definitely storage access. So loading in data from storage or even storing data into storage is quite expensive and you want to kind of minimize that as much as possible. And I think another big one is using memory properly because when you declare memory from a storage slot, you're actually loading that storage slot into the memory first and then you're going to use that memory after. So you want to make sure that if you're doing a for loop, you don't want to keep loading it into memory in each iteration because you're going to access it either way, right? So you want to just access the storage directly instead of spending the extra gas just to put it into memory, then use the memory again. You get what I mean? So yeah, I think that's another big thing and I wonder if there's going to be any type of gas auditing industry within like I think that's starting to appear already.
00:35:07.970 - 00:35:38.614, Speaker A: I don't know about you, but when I was looking for freelance work, a lot of projects contacted me just for my optimization skills. And also Harrison on Twitter, he flexes or talks about it a lot, how clients will pay him a lot to do gas audits for them and basically look at their code base and optimize it. So I do think there's a lot of potential there already. And then as people realize how big your savings can be, they will look for that more.
00:35:38.812 - 00:36:12.786, Speaker B: Yeah, Harrison is quite unique. He started the industry of gas auditing by himself through just a few memes and tweeting on Twitter, basically. And now he's basically running the industry. He's like a pioneer. He's just created a new kind of sector. It's like gas optimization audits instead of traditional security audits, which is very unique to blockchain because gas is kind of how you pay for transactions. And so you want to obviously minimize that as much as possible, especially if you're using a protocol that has millions of transactions coming in.
00:36:12.786 - 00:36:38.250, Speaker B: You want to reduce the fees for your users so they can do more transactions and not pay as much money. But there's also another thing that you've created, and it's a Dex. So how have you just switched from going from an auditor doing all these hyper optimized contracts to building circuit breakers and security standards to now Dex?
00:36:38.750 - 00:36:42.326, Speaker A: So the Dex was also just a side project. I was kind of nerd sniped by Uniswap.
00:36:42.358 - 00:36:44.522, Speaker B: Again, someone's on a kill.
00:36:44.576 - 00:36:46.090, Speaker A: Yeah, it's another snipe.
00:36:46.590 - 00:36:47.850, Speaker B: Call them the UAV.
00:36:48.850 - 00:37:35.454, Speaker A: I get sniped very easily. That's also a big drag on my productivity because whenever something just like, I get a cool idea that stimulates my brain and like, oh, I have to do this because it'd be fun to implement. And also I can show it off to people, I get hypercharged and I have to stop myself and delegate that. Now, the way I structure my week is basically I don't always stick to it, but it has kind of worked till now is that I say, okay, Friday to Sunday is my nerd snipe time, and then Monday to Thursday is like, my drag primary project time. Pointing your but basically yeah. The Dex was another nerd snipe because I saw Uniswap released their V four implementation. I forgot what the industry agreed the terminology would be, but they didn't open source it.
00:37:35.454 - 00:37:49.374, Speaker A: They source available. It's got, like a license. Yeah, exactly. So you can read the source code. It'll be open source in like, four years. But till then it belongs to Uniswap. So if you make any business license.
00:37:49.422 - 00:37:51.426, Speaker B: Or something yeah, exactly.
00:37:51.528 - 00:38:47.086, Speaker A: They have a business license. So basically, the terms I read, the business license, basically what it says is that first four years is proprietary, and then after four years, it automatically transitions into, like, a GPL copy left license, which is like a traditional open source. Yeah, but basically, till then, if you contribute to Uniswap, it'll belong to Uniswap. They'll be making money off it. So I recommend you don't if you're really interested in, like, sure, contribute to Uniswap. But yeah, just noting that if you contribute to Uniswap right now, it'll just be free work in the hands of a for profit company, which there's nothing wrong in being like a for profit startup, it's just like yeah, don't get confused by their quote unquote open source marketing. But yeah, that aside, basically the Dex I wrote was inspired by Uniswap before because they didn't introduce like, other DEXes had this before, but basically they at least brought it to my attention, this cool pattern of flash accounting.
00:38:47.086 - 00:39:57.930, Speaker A: So where you have a bunch of transactions that can happen within a single contract, and then you just settle the result of that at the end, which is especially relevant for a decks where you have multiple pools that hold different tokens that have different ticks, different liquidity, different fees, different hooks. And then you may be routing your trade across ten different pools just to get, like, one token out. And it costs a lot of gas to transfer tokens from one pool to the next because every time you transfer token, you have to call the token contract, it has to change the balances and then change the balances again. So instead what Uniswap does is that it stores these changes internally. In the future, it'll use EIP 1153 and then basically just the difference at the end is what you have to settle and transfer tokens for. So, yeah, if you imagine like a swap going from USDC to USDT to ETH to the uni token to the compound token to whatever, at the end, the only thing you have to transfer in is the beginnings, like the USDC and at the end, like your comp tokens or whatever, and then all the changes in between didn't have to register.
00:39:58.350 - 00:40:17.746, Speaker B: Yeah, so it's like basically from its previous versions, it's not doing all these independent contract calls which are 2100 gas or not 2100, it's even more it must be a bit more, right?
00:40:17.848 - 00:40:31.954, Speaker A: No, a call costs 100 gas and then you have overhead from solidity to format the memory. And if it's the first time you're calling a certain contract, then it'll add another 2500 gas.
00:40:32.002 - 00:40:32.438, Speaker B: That's what I was saying.
00:40:32.444 - 00:40:34.614, Speaker A: To quote unquote warm the address.
00:40:34.812 - 00:41:08.180, Speaker B: Previous iterations were basically just calling each other from one pool to another pool to another pool, depending on how long it was. And so you're sending tokens back and forth through all these pools. But basically V four is just a centralized point of where all the contracts are not actually centralized. This is still on a decentralized network ethereum, but it's where everything is sort of hosted, right? And when you do one transaction, it doesn't route through external contracts, it just routes through itself. So it's using much less gas, isn't it?
00:41:09.270 - 00:41:10.338, Speaker A: Yeah, exactly.
00:41:10.504 - 00:41:14.018, Speaker B: So your decks, compared to that, what is it like?
00:41:14.184 - 00:41:59.662, Speaker A: Yeah, so it does something similar, but the flash accounting, instead of using storage or in the future, transient storage, it does it in memory because the way uniswap V Four is intended to be used is you still have, like, a periphery router contract. But what it does is it'll call into the V Four contract a bunch of times to do the individual swaps, but it's calling into the same contract that saves gas. So you're calling multiple times into one contract, but you're saving a lot of gas because you don't have different contracts, which saves a lot of overheads of just like, external calls. And also you're saving on the cost of warming separate accounts. My implementation takes it one step further. So all the swaps can be done within one single call, directly within the Dex contract. You don't need a periphery contract.
00:41:59.662 - 00:42:51.570, Speaker A: And all the flash accounting is not done in storage or transient storage. It's done in memory, which is cheaper than transient storage, but not that much cheaper, it turns out, but it is a bit cheaper. So basically the way this works is that the Dex has its own mini instruction set to do different things, and then you can pack these together to make a swap. So there's one instruction for swapping from one pool to the other and then another. And then there's one instruction for withdrawing or depositing tokens, and then you can also set limits. And then that allows you to basically off chain form, like a script or what I call a program with these different instructions. You put them together and then send it to the Dex contract, and then it'll execute them across the different pools and then give you the result.
00:42:51.720 - 00:42:55.940, Speaker B: Sure. So it's basically just like hyper optimized version of before, really.
00:42:56.470 - 00:43:13.094, Speaker A: I mean, it's not that optimized because I haven't spent too much time on it, but the base like, yeah, the flash accounting is on memory, which is quite efficient. But I'm sure there's a lot because I didn't write a lot of it in inline assembly. So there's probably a lot of gas I could save here and there. For sure that I did naively, but yeah, it is kind of optimized.
00:43:13.222 - 00:43:23.134, Speaker B: Right? So was I right with the V Four and V Two comparison and then your one's basically switching the storage to memory? Really?
00:43:23.252 - 00:43:24.160, Speaker A: Yeah, exactly.
00:43:26.130 - 00:43:44.306, Speaker B: Okay, perfect. I would like to touch on just the productivity for a little bit and then we might wrap it up. But during your kind of journey, how did you kind of stay focused and make sure you were on the right track and not kind of getting distracted procrastinating, as most of us do?
00:43:44.408 - 00:44:20.366, Speaker A: Yeah, that's actually something I've been struggling with recently. I might have trouble answering that, but in the past it's been, like, bursts of productivity. I'm not sure if this is just because my attention span has been messed up by modern social media, but the way I work is not really concentrated for long time spans. It basically comes in bursts throughout the day. So I'll get distracted for a few minutes or like, half an hour, and then I'll get back to work. And then I have a focused burst of, like, one and a half hours of work, and then I'll do something else, like a chore at home, and then I'll have another burst of productivity. And that's how it's been done.
00:44:20.366 - 00:45:09.550, Speaker A: And just making sure that I create the space and flexibility for me to be able to have these bursts is basically what has helped a lot. But I'm trying to also just get a more organized schedule in general. So I've been doing things like the Pomodoro technique to basically just push myself to get these bursts more often as well as just like increasing the barrier to entry. So to say, to go to these distractions, to just make it harder for myself. So when I really want to focus, I'll put my phone on Do Not Disturb, I'll log out of Twitter so that if I want to go to Twitter, I actually have to log in and enter my credentials. So that's just like just that barrier alone often just stops me from opening it because unless I'm actually taking a break in the day, I won't go through the effort of unlocking my password manager or putting in the Twitter password or whatever, doing the two factor. So just creating a barrier to reach those distractions has also helped.
00:45:09.550 - 00:45:37.254, Speaker A: And yeah, just like setting time limits on the distractions, just like trying to minimize the distractions wherever possible, but also being kind of like reasonable with yourself because yeah, you're human after all and you do want to let loose and just doom scroll sometimes. Just like being intentional about that because if you're being realistic, you're probably never going to eliminate that entirely. So just like allocating specific times of the day where you do that can be really helpful as well.
00:45:37.372 - 00:46:31.938, Speaker B: Yeah, just have blocks of insane focus. It could even be like 4 hours or something then that's kind of in 4 hours of insane laser focus you can do a lot. It's highly underlooked of how much you can do in such a short amount of time. If you have laser focus, if you really want to get rid of procrastinating and all that stuff, get rid of the distractions in your environment, kind of limit yourself to what you're going to set a task, to set a schedule. Building the habits is really what matters. And then even on the days you don't feel like doing it emotionally and spiritually or even physically when you burn out, you still have those habits of giving your time sufficient rest and then having those short periods of laser focused and resting again, taking care of your body and mind so you just can be consistent. And that's kind of how you compound learning and progress.
00:46:31.938 - 00:46:38.882, Speaker B: But I think on that note, I think it's been a terrific podcast. It was lovely having you on, Philip.
00:46:39.026 - 00:46:40.190, Speaker A: Yeah, thanks. For having me.
00:46:40.300 - 00:46:55.450, Speaker B: I'm glad we got to do this so quickly. A short notice as well. Just DM'd you you're like yo, but yeah. Thank you so much. And I'm sure we'll jump on another one sooner.
