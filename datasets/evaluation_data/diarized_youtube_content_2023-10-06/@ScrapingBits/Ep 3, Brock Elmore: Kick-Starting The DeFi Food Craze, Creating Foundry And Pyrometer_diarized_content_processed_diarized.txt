00:00:00.250 - 00:00:26.530, Speaker A: How these tools will evolve is leveraging other tools to kind of do more of the logic. Right. So Chat GPT Four, it has plugins like, you can ask it to use Wolfram Alpha, that sort of thing. And I think that's kind of the path that we'll need to go down, where it's augmenting the ML AI auditor by these other tools so that it can actually do what it's good at, which is pattern recognition.
00:00:26.610 - 00:00:34.098, Speaker B: GM. GM, everyone. My name's Degash, your host of scraping bits. And today I'm with a special guest, brock Elmore.
00:00:34.194 - 00:00:35.240, Speaker A: How's it going?
00:00:36.010 - 00:00:36.566, Speaker B: Good.
00:00:36.668 - 00:00:37.686, Speaker A: Great to be here.
00:00:37.788 - 00:00:52.080, Speaker B: Great to have you on. I know you're a very busy man and you've kind of just given me some time to get to know you and dive deep into the brain of Brock. So I think we should do a quick intro. Well, you should do a quick intro of who you are and what you do.
00:00:52.530 - 00:01:19.826, Speaker A: Yeah. Hey, everyone. I am Brock Elmore. I am the chief architect at Nascent. Nascent is a venture firm that we like to think of ourselves who are builders that are invested. So we invest in early stage startups and we try to also build a bunch of tooling and focus on the dev side of things. So a little bit about my background.
00:01:19.826 - 00:02:09.446, Speaker A: I've been in the space full time since 2017. I actually dropped out of school to go full time, starting a small fund. Then early 2019 did a yield aggregator kind of first of its kind. It was prior to yearn, but it was effectively the same as urine. Couldn't do much fundraising for it at the time and then got Nerd Sniped into MEB and from there did that for a little while and then co founder of Nascent, Dan Elitzer, reached out and said, hey, do you want to do this fun side project called Yam Finance? And oh, I said sure. And so my brother Trent Elmore and I joined the team and we went from idea to production in ten days.
00:02:09.548 - 00:02:10.118, Speaker B: Oh, wow.
00:02:10.204 - 00:02:46.482, Speaker A: That project was very interesting. Obviously it had its issues, but really kicked off a lot of the DFI summer yield farming activities. First food coin. Yeah. And then after, I stuck around at Yam for about six months trying to write the ship after the bug. And at that point, Dan reached out and was like, hey, I'm starting Nascent. Do you want to come join? And I am very entrepreneurial at heart, and so I was very hesitant, but ultimately decided that Dan is awesome and the team that he was building around him is awesome.
00:02:46.482 - 00:03:18.490, Speaker A: And so I joined as chief architect there. And so most of my day to day is building open source tools. So I was a core contributor foundry, basically helped it get off the ground. And then I recently started Pyrometer, which is a security tool for solidity. Also put out content around security. So we put out simple security toolkit. And recently I put out an article called you're Writing Required statements wrong.
00:03:18.490 - 00:03:38.270, Speaker A: That goes into kind of a new smart contract security pattern for improving the security of your protocol. And then I also help our existing portfolio companies with strategic and technical issues and due diligence on new deals.
00:03:38.350 - 00:03:57.878, Speaker B: Yeah, a super exhaustive background and very interesting to say the least. This could be a massive episode just from that. But I would like to start of just coming from the start of your background getting into you got into high frequency trading. You built a firm from that and you didn't finish your degree either. Were you doing computer science at the time?
00:03:58.044 - 00:04:24.866, Speaker A: I was actually a stats and operations, so I was at University of Pennsylvania Wharton Undergrad, doing stats primarily, and I had an interest in machine learning. And so I taught myself how to code because I wanted to actually implement these machine learning models. And so I also had an interest in Bitcoin and so started a small firm and just kicked that off and ended up dropping out of school to do that full time.
00:04:24.968 - 00:04:28.978, Speaker B: What kind of happened with that? Did you just kind of leave it or sell it?
00:04:29.064 - 00:04:56.410, Speaker A: Yeah, so I operated it for about two years and then when DeFi started to pick up, I was really interested in DeFi and getting less and less interested in running the minutiae of this very small it was basically just me and I just wanted to end it. Investors made good money from it and we beat the market, but it just was not enticing me.
00:04:56.480 - 00:05:02.766, Speaker B: And then basically you went from that into mev straight away, or how did that kind of go?
00:05:02.948 - 00:05:35.958, Speaker A: Yeah, so I went into starting a yield aggregator. It was called Topo Finance. We're actually a fork of dYdX's solo margin contract. This was dYdX's second product. And with that fork we basically would balance people. So I was a beta user of dYdX, this version two that they had. And effectively I recognized, okay, I'm earning 49% on dYdX compound at the time was offering 6%.
00:05:35.958 - 00:06:12.014, Speaker A: Immediately I saw, okay, people are going to want to rebalance their money to go wherever has the highest yield. And so that was the start of Topo for me. And so started to build out the smart contracts. I was not very talented. It basically kicked off my solidity career as well. I had a whole bunch of Python experience and I tried to write it in Viper first, but Viper at that time was very new and didn't really support what I needed to do. So fork Dwaydx got it to a beta stage.
00:06:12.014 - 00:06:45.494, Speaker A: So the contract works. It's actually still live on main net. I think it has a few thousand bucks in there still just from beta users. But while I was building that and thinking about the liquidations of my system being built on top of these other systems because we actually not only supported the lending side, we also supported the borrowing side. So optimized rates on the borrowing side. And so as I was thinking through the liquidation process and Oracles and whatnot I actually discovered back running before it was called back running. Yeah.
00:06:45.494 - 00:07:18.314, Speaker A: I don't know if people are familiar with back running, but effectively when you have an Oracle update, that Oracle update is what kind of triggers an account to be liquidatable. And so I built a system and discovered that you could basically be in the same block as the Oracle update by looking at the mempool. And at the time that was like no one was doing that. And so that led to my brother and I, who was working with me on this being the largest liquidator on Dwaydx for probably about five months.
00:07:18.432 - 00:07:20.330, Speaker B: Yeah. With no competition.
00:07:21.230 - 00:07:46.862, Speaker A: Yeah, we basically had no competition. The mev market adapted relatively quickly and geth was changing at the time they introduced FIFO, first In, First Out, which changed the game and it became this spam game effectively. And we really just didn't like playing that spam game. So we expanded our horizons and started to explore more mev opportunities.
00:07:47.006 - 00:07:52.980, Speaker B: So then after basically this mev kind of phase, what did you kind of pivot to off of that?
00:07:53.510 - 00:08:44.978, Speaker A: Yeah, so we were actually still doing mev oh, interesting. For a little while until so we would be doing balancer. At the time, comp tokens were getting distributed and whatnot. And there's a function on balancer pools called Gulp where basically if there were extra tokens that weren't claimed, you could call this function Gulp, which would distribute the extra tokens per radta to all the token holders. And so we would do flash loans and whatnot to basically capture all of the gulpable comp tokens and whatnot. And so we were doing things like that as well as a whole bunch of other random mev games pretty much at that time it was like you look at a protocol and you could basically just find money smart and the code. Yeah.
00:08:44.978 - 00:09:26.626, Speaker A: And that kind of wore on us. Our infrastructure was designed for liquidation, it was not designed for doing a whole bunch of random activities on chain that we ended up doing. So I was getting pretty burnt out and at that time Dan Elitzer and Will Price reached out. Dan's, co founder of Nascent. Will Price is an extremely smart guy, just been in the space for a while and came to my brother and I saying, hey, we have this idea for what ended up being Yam. It was rebasing token with we were looking at ample and we said it wouldn't make this better. A treasury that set a floor to kind of how far this could go down and that sort of thing.
00:09:26.626 - 00:09:33.106, Speaker A: And so we went from idea to production in ten days.
00:09:33.208 - 00:09:34.354, Speaker B: Yeah, quite fast.
00:09:34.472 - 00:09:40.326, Speaker A: Quite fast. And obviously that had kind of a downside. We ended up having a bug in.
00:09:40.348 - 00:09:43.254, Speaker B: That contract when it was getting really big as well.
00:09:43.452 - 00:09:58.394, Speaker A: Yeah. By day two we had 750,000,000 in our Staking contracts and it kicked off the Food coin craze and a lot of DFI Summer in 2020.
00:09:58.592 - 00:10:04.350, Speaker B: Yeah. How did you basically go about that bug that came in when it was live? Basically, yeah.
00:10:04.420 - 00:10:44.074, Speaker A: What was interesting about Yam is it was a fair launch. US as individuals, we had no control over that system at all. And so what we determined the best course of action was was to get basically everyone in the community to delegate their Yam to me so that we could get governance passed as soon as governance was enabled and try and get a proposal through and fix some of the bugs or fix the bug. And so that kicked off what was called Save Yam. It was quite the movement. Everyone I talk to people now and they say how much fun they had during that time. I'm glad other people had fun because, boy, was it stressful for me.
00:10:44.112 - 00:10:47.498, Speaker B: Yeah, I can imagine. It was like the golden age of crypto, I think.
00:10:47.584 - 00:11:12.338, Speaker A: Yeah, it was a lot, a lot of fun. But ultimately the bug didn't work due to some technical details on compound governance, tokens quorum requirements and the rebasing. And so effectively the bug fix didn't work. But what it did kick off for me personally is we did have tests for our contracts, but we're using Truffle at the time.
00:11:12.424 - 00:11:13.586, Speaker B: Oh, man. Yeah.
00:11:13.688 - 00:11:43.006, Speaker A: Hard Hat was still in its early days. It was called Builder at the time and DAP Tools was there in the background, but not really something that I knew about or many people knew about. Yeah. But then Mariano from Maker reached out and said, hey, I think you might be interested in Daptools. And so he ended up getting me Daptool pilled, which eventually led to the formation of Foundry as it is today.
00:11:43.108 - 00:12:04.580, Speaker B: You had like a problem of, okay, testing suites aren't really there yet. And then luckily that tools was there and you kind of captured the opportunity at a prime time and then basically helped build Foundry to what it is now basically a titan in the industry and basically the standard of yeah.
00:12:04.970 - 00:12:09.942, Speaker A: And I can talk about how kind of foundry came to be if you want.
00:12:10.076 - 00:12:14.680, Speaker B: Yeah, sure. Yeah. I guess also like difficulties going through and building those.
00:12:15.050 - 00:12:51.950, Speaker A: Yeah. My first interaction with Daptools was, this is awesome, and then I started using fork tests, which are pretty commonplace these days, but on DAP Tools, they were exceedingly slow, like molasses. It was absurd how slow they were. And so I looked at that, I was like, okay, I'm just going to rewrite DAP Tools in Rust. And so I wrote something called I think it's still archived on my GitHub, but called Rust cevm. So rust composability EVM. Basically it was DAP Tools so I could use all basically the same testing infrastructure.
00:12:51.950 - 00:13:21.680, Speaker A: Well, same tests, but run it a lot faster via my Rust implementation. That was like the precursor to Foundry. And so when Giorgio saw that on My and it was just something I used, it wasn't very public. Like, yes, it was on My GitHub, but no one else was using it. It was not production ready in any capacity. It was just, I need a tool, I'm going to go build the tool and build something that I need. And so Diorgios reached out.
00:13:21.680 - 00:13:48.066, Speaker A: We had been friends and chatted quite a bit, and he saw that and was like, yo, we should productionize this and make it something that everyone can use. And at the time, I was too busy with other things and I was like, yeah, I agree, we should. But I don't really want to kind of lead that charge in the open source issues that are associated because maintaining open source is a bit of a challenge.
00:13:48.178 - 00:13:48.840, Speaker B: Yeah.
00:13:50.010 - 00:14:24.080, Speaker A: So he kicked off a lot of the core work on it. And then I'd built up a bunch of features for my DAP tools, Alternative and Rust, and then basically brought all of that over into Foundry. And so like the tracing. So anytime you add fees to your Foundry test, forge test, I built that. I built the debugger. I built gas reports, helped build the fuzzer. So a lot of the core components in Foundry were directly from kind of My.
00:14:24.080 - 00:14:51.434, Speaker A: There are a ton of super other talented developers that did it, that worked on Foundry, Giorgios, especially Matt and onberg Oliver, they were very foundational and built all of this infrastructure that makes Foundry what it is today. I built a few features on top that kind of are core to the user experience, but it's definitely a team effort for sure.
00:14:51.472 - 00:15:00.220, Speaker B: Yeah. And it's quite interesting that you did all the tracing and the Fuzzing. Did you have any prior experience to basically building all this stuff?
00:15:02.350 - 00:15:03.594, Speaker A: Basically no.
00:15:03.712 - 00:15:05.742, Speaker B: It was how you got your experience, right?
00:15:05.876 - 00:15:30.658, Speaker A: Yeah, I just basically looked at the existing tools and was like, this is good, but I generally have a pretty good understanding of what I want and I view myself as a very good customer. Right. So I am probably a good proxy for what other people want as well. And so just kind of leaned on that fact to generate these features.
00:15:30.754 - 00:15:49.194, Speaker B: Yeah. And how did you go about basically getting these traces? Because you obviously need an RPC, so you had to learn about nodes. Right. And then for a Fuzzer, you had to go into basically dynamic analysis and all that. These routes gets quite deep. Right. So I think we should start with basically the tracing first and then dive into the other one.
00:15:49.392 - 00:16:26.502, Speaker A: Yeah. So with tracing, we do tracing differently than how geth does it necessarily. So Foundry, you interact directly with the EVM. Actually, you don't have an RPC. And so what it actually did is actually gave me a ton of experience understanding the EVM. So I would say that's how I really learned what the EVM is doing under the hood. And so I had a vision for this is the end product, and then I just dove into the EVM code base and figured out, okay, this is the data structure that I need.
00:16:26.502 - 00:16:32.458, Speaker A: This is how I can build up the data along the way to recognize the calls and that sort of thing.
00:16:32.544 - 00:16:36.170, Speaker B: And this was the GEEF node, right, that you're looking in for reference.
00:16:37.230 - 00:16:47.486, Speaker A: So technically it was this Rust implementation of the EVM called Sputnik. I believe it's what some of the Ethereum classic people were using.
00:16:47.588 - 00:16:53.054, Speaker B: So it wasn't even a mainstream node that everyone was using. It was just kind of like some aside one that you just found.
00:16:53.092 - 00:17:11.474, Speaker A: Yeah, it was just an EVM implementation in Rust, and I had used it for Rust cevm. And so I kind of learned the EVM via looking through that repo and understanding it and kind of just trial and error.
00:17:11.522 - 00:17:11.974, Speaker B: Right?
00:17:12.092 - 00:17:21.442, Speaker A: Trial and error. And thinking about, okay, this is how I plug into this. Consuming it as a library forking. It adding what I needed and using my fork.
00:17:21.506 - 00:17:30.186, Speaker B: And then with the fuzzing, how did you go about that? Because that's a completely different field to EVM in general. So did you have any prior experience with that, or was it just, you.
00:17:30.208 - 00:18:02.274, Speaker A: Know what, I need this on the fuzzing side. It wasn't just me, to be clear. But there's an existing so again, it was looking at what libraries are out there. As much as I, like reinventing the wheel, there's a case to be made like, hey, just go take what's off the shelf and get something that works well. And so there's a Rust crate called prop test. We leveraged Prop Test inside of foundry and kind of went that way with iteration.
00:18:02.322 - 00:18:02.678, Speaker B: Right?
00:18:02.764 - 00:18:09.510, Speaker A: Yeah. And so I would say most of my contributions on the fuzzer were actually making it more intelligent.
00:18:09.590 - 00:18:09.834, Speaker B: Right.
00:18:09.872 - 00:18:42.350, Speaker A: So for some context fuzing, it's generating random inputs, but ideally you want to generate best guesses, and we could talk a little bit about how to make those guesses better. And that kind of goes into the program analysis side of things. And so my first improvement was like, all right, what if we just if you think about your code and you have like, an if statement, if x is greater than 100, right. And x is some input to the function. Just reading the bytecode for pushes.
00:18:42.430 - 00:18:42.770, Speaker B: Right.
00:18:42.840 - 00:19:11.866, Speaker A: You see a push 100. Those push values are actually generally going to be important to your contract and the control flow of your contract. And so pulling those out, adding them to a dictionary, and keeping those in mind for using the fuzzer, using as inputs for the fuzzer. And so it was a lot of thinking about what the fuzzer is doing and trying to have it generate more intelligent inputs and any tricks and hacks I could do to make that better.
00:19:11.968 - 00:19:51.178, Speaker B: Yeah. And the only way you can really do this is by understanding the contracts at a deep level. If you can't read and write basically at the lowest level, then you're not going to understand how to build something that's automating this in a specific way for, I guess, niches within or like unique kind of identifiers in the lowest level, as you said, like these pushes. Let's say that was followed by a jump or a jump. I then you obviously know then it's a hard coded, basically jump desk destination. Where it's going to go. So you could basically gather all those and then you can have kind of like a jump table in memory or something.
00:19:51.178 - 00:20:08.750, Speaker B: But I guess it gets way more harder when you have dynamic variables and people, they make custom bytecode, right? And then you have dynamic, basically jumps and jump eyes. And I guess that's when it gets super complex. But it's definitely a great first step. And obviously what was essential for solidity, right?
00:20:08.900 - 00:20:48.374, Speaker A: Yeah, exactly. And my most recent work is on something called Pyrometer, which uses what's called abstract interpretation. So it reads your solidity code and it's a mix between symbolic execution, I would say, and kind of static analysis. It's a mix of a few different things, right. Where it's almost symbolic execution, where you're going through the control flow of your program, but you're not running it on an EVM, a small EBM or whatnot. You're just looking at the code. And let's say you have X and you do a require statement.
00:20:48.374 - 00:21:48.782, Speaker A: The X is less than 100. And so what parameter does is it now knows that if X was a unit 256, x has to be within zero and 99, right, if X is less than 100. And so now we know, okay, it's symbolic, but it's bounded variables. And so kind of bringing this back to the fuzzing side of things. And what I'm currently building with Pyrometer is you can take all of this information and if there's an if statement to reach this code path or an else to reach this other code path. We actually now know in very easy to understand constraint system where it says X has to be zero to 99 to reach this or in this other code path, it's 100 and above. We can actually now plug that information into the Fuzzer and make sure that we get close to as close to 100% code coverage as we can.
00:21:48.782 - 00:22:43.170, Speaker A: And there's a fuzzing benchmark put out by consensus called Dataluz, and it's basically this maze system that comes from traditional fuzzing in traditional software to benchmark fuzzers. And Foundry right now is kind of number two in this benchmark, Harvey, which is consensus's closed source. Yeah, gray, I think it's gray box fuzzer. I think they do some relatively similar stuff and then a kidneys third right now, but with parameter, we'll be able to basically solve data luz in. What we're hoping is we'll be able to really improve foundries Fuzzers that will be best in class by far.
00:22:43.320 - 00:22:57.074, Speaker B: Yeah, that'd be interesting. Having an open source, basically testing suite with an elite Fuzzer that'll be better than the closed source specifically built for tool. Super interesting.
00:22:57.272 - 00:23:09.640, Speaker A: Ideally, how this if you're a Foundry user, eventually you'll just be able to run Foundry up and all of a sudden your Fuzzer will just be ten times better than it was, which I think is super cool.
00:23:10.250 - 00:23:29.550, Speaker B: It's going to be very interesting. But obviously having an open source, these closed source projects, you'll be able to see and try and iterate on them. How did you get from basically Fuzzing to static analysis? Because they're two different things. And you basically built Pyrometer after you did Fuzzing. So why did you choose to go down the static analysis route instead of dynamic?
00:23:30.930 - 00:24:20.510, Speaker A: It really came from ironically, I had about like five or six different ideas for public good tools that I wanted to see in the world. And I ran a Twitter poll saying, hey, what should I go build? And people voted for this little security tool. And basically it came from this idea that if you're auditing code or looking at code, I have found some very strange, like, overflow bugs and whatnot that it feels like it should be easier to find those. And so it came from this idea, well, we have all this type information, we have these require statements. It should be easier to know what the bounds are at any given point for any given variable. And that's what Pyrometer does under the hood. As I said, the requirement X is less than 100.
00:24:20.510 - 00:24:58.678, Speaker A: It keeps track of this. And so it came from a need of, oh, I need to understand where overflows may happen. I need to understand what are the total. Like, Polygon had some bug where basically you could transfer as much matic that the zero address had based on ECDSA. Basically EC recover can return zero. Right? And wanting to know, okay, what are the possible addresses that could come out of this function? Like if you're calling transfer, what could the from address be? And this sort of thing. And so that's what Pyrometer can do under the hood.
00:24:58.678 - 00:25:04.478, Speaker A: It can highlight this for you and say, yes, this value can possibly be zero.
00:25:04.644 - 00:25:55.674, Speaker B: And that's bad because addresses are basically just a bound of zero bytes to 20 bytes. And in Hex, those are all basically numeric values. So that's how it really works. It's just basically finding the lowest value it can possibly be and also the highest value it can possibly be. The more, I guess, constraints that come along using the same value, you can kind of narrow that down even more and make this tool more efficient. So you're not waiting for unnecessary iterations that aren't even going to be hitting any new code coverage? Basically yes, because all it comes down to with these tools is time complexity and how can you minimize that of getting the most amount of coverage possible. So bound analysis is a terrific technique to basically get that and there's obviously other techniques as well which you have in your to do list which like Taint analysis as well, which I think is terrific.
00:25:55.674 - 00:26:37.660, Speaker B: I've built that out. That was kind of like my first technique I've ever used. You quote unquote taint something or in a better context dye it. Let's say, let's do like a data stream or a stream of water per se. You can basically put like red dye into it and that would be a specific opcode. And then after that opcode you can see what that tainted one or one that we dyed red influences. And so the data stream, or in this case the water, you can see where the red dye is going and you can see what's being influenced in I guess the data flow, which would be the future opcodes that are being used by that original red dyed one.
00:26:37.660 - 00:26:49.230, Speaker B: And it's just stuff like this that basically gets you to be more efficient and reduces time complexity. You've also do symbolic execution in it as well. So how do you use that in Pyrometer?
00:26:50.050 - 00:28:05.506, Speaker A: Yeah, that's like a concrete case right, where the values are hard coded. In ours in Pyrometer you can kind of think of it as I guess think of it more like slither, where in Slither, the best way to explain it, I would say in the context of Taint analysis is we offer better pattern matching and more powerful pattern matching. Well, not yet. Kind of where we're taking it is we construct a dag under the hood that is this variable flows into this variable and there's these relationships between these and they're all nodes in this graph. And so what that allows you to do is actually query based on we're going to probably implement something called cipherlang which is a graph querying language. And so in slither where you have to write Python to kind of iterate through all these their intermediate representation, their IR in parameter you'll basically just be able to ask variable as an input to a function then the output yada, yada, yada and basically be able to detect. Okay, you called this other contract.
00:28:05.506 - 00:28:46.100, Speaker A: It gave you some value back, and you're not actually checking that value? So now that's considered tainted. Right? That value is tainted until you do validation on it, making sure that it's within your parameters that you think it's going to return or that if it spits back out an address and then you're going to call that address. Right. So it's using the tainted value. And so with parameter basically we have a mockup of what that query would look like, and it's two lines of what's called cipherlang that is pretty understandable. This node connects to this node via this property.
00:28:47.590 - 00:29:38.760, Speaker B: Yeah, stuff like that is quite interesting with that tension analysis technique. For example, if let's say we're using uniswap and we're checking, I guess the reserves, for example, and something depends on this, I guess in an Oracle sense, it depends on it for pricing. One way you could check for a vulnerability of Oracle manipulation would be to check basically okay, our core contract relies on reserves of this uniswap pool. And we have basically a condition that says, okay, uniswap reserves have to be above this amount, and then token A, token B amounts have to be above basically X amount. So they're like ratioed in the right way. And that's a way of basically doing the same. Like Taint analysis is what you explained, right?
00:29:39.930 - 00:30:51.980, Speaker A: Yeah, exactly. It's kind of before the fact, right? You want to make sure. So if you're an auditor and you're looking at a code base, we mentioned a little bit before the call about code arenas, bot races, and so allowing auditors to speed through this process, design their own patterns and whatnot, in a simple way I think will be super powerful for users. On the kind of Oracle side, I recently put out a pattern called security pattern called, you know, free Pi, fray Pi, however you want to say the first part. It's like an expansion on checks, effects interactions, but it stands for Function requirements, effects Interactions plus protocol invariance. I like to attack security not just from a dev tooling side, but also content creation and thinking through sort of a whole bunch of the issues associated with smart contract security and trying to help developers write more secure contracts because we can't keep having billions of dollars hacked every year.
00:30:52.510 - 00:31:04.000, Speaker B: Yeah. What kind of made you go down the open source route instead of making, I guess, a company and then a SaaS and selling it instead? Kind of just like helping the community instead of taking.
00:31:08.550 - 00:32:02.354, Speaker A: Thankfully, I'm in a very privileged position where at Nascent we are a venture team and we do some liquid stuff as well. But the venture side is all of that depends on the space going mainstream. And so anything we can do as a company to help the space become more mature and more secure, we just get a whole bunch of positive externalities. But also, additionally, I just have a personal belief in open source goods. I think public goods are extremely important and awesome. And so I personally, as well as the entire company, is super aligned with that. But that being said, if I were on my own, not a part of Nascent, I would absolutely be looking at ways to do monetization and this and that.
00:32:02.354 - 00:32:55.678, Speaker A: And there are a bunch of the things, like in the Twitter poll, most of those I'm fairly confident I could convert into a. Real. Yeah, as a startup. But I'm in a privileged position where the money I make is not dependent on that product, it's dependent on the space growing and I just get a whole bunch of warm, fuzzy feelings by putting something good out into the world. But I'm fully supportive of people who do want to create a product around these sorts of issues, but it really comes down to seeing a need and attacking that need with kind of intuition about yourself, how you would want to see this product and going after it that way.
00:32:55.864 - 00:33:17.450, Speaker B: Yeah. And now that you've kind of built Pyrometer and solved basically the problem you initially had, while to a degree, you still have a lot more to go on the roadmap. But I guess apart from that and when it's done, what do you think is missing from the security tooling space at the moment? And if you could bring that tool into existence, what would it be?
00:33:17.600 - 00:34:03.674, Speaker A: I see a lot of sort of AI startups around this and basically just improving what you can do as a pre audit. Right? So we put out Nascent. And I helped write this. The simple security toolkit. And it basically has a pre audit checklist and an incident response plan and this and that. And really, I think, improving the pre audit flow and pushing more and more of the things that an auditor will do that you're paying them six figures for a lot of times to do, pushing more of that down into the developer lifecycle. Of, I'm starting a project.
00:34:03.674 - 00:35:05.854, Speaker A: I'm going to use this product to make sure I am ready for audit. Because the number one thing that scares me the most is when a protocol gets audited and there's a bunch of high vulnerabilities, and then they go get another audit and there's still a bunch of high vulnerabilities, it's like okay? I basically will never trust that protocol. Even though they've been audited twice, three times, or whatever, purely based on the fact that there's been so many vulnerabilities at that point. And so as far as concrete tools, I'm not exactly sure. I think my focus has been very much on Pyrometer recently and so I'm sure I'll cook something up in the not too distant future of being in an audit, reviewing code and saying, oh, I need this tool to improve my workflow, and then pushing that out, either making it a product or that sort of thing. And I think AI can help with that. I don't think we're there yet and I'm very skeptical of any of the existing products out there currently.
00:35:05.854 - 00:35:21.410, Speaker A: I think they're on a good track, but personally, I wouldn't pay for anything before trying to use it. I saw some protocol, I won't name names, they said, We've been audited by Chat GPT Four and I'm like, yeah, sir, that is not an audit.
00:35:22.070 - 00:35:44.858, Speaker B: Yeah, speaking of Chat GPT Four and also your machine learning background. I wonder how you see the kind of smart contract security sector now in its direction, as it's highly methodological and involves pattern recognition, which are both strong skills of AI. So what are your thoughts on that?
00:35:44.944 - 00:36:35.210, Speaker A: I think if you look at Chat GPT Four, its logic has improved, but I think really kind of the sweet spot of how these tools will evolve is leveraging other tools to kind of do more of the logic. Right, so Chat GPT Four, it has plugins like you can ask it to use Wolfram Alpha, that sort of thing. And I think that's kind of the path that we'll need to go down where it's augmenting the ML AI auditor via these other tools. So plugging the output of Pyrometer into Chat GPT Four I think is a potential path or whatever tool you're building just to give it more context and offload some of the heavy logic so that it can actually do what it's good at, which is pattern recognition.
00:36:36.430 - 00:37:16.470, Speaker B: Continue. Sorry. Yeah, since machine learning. And AI is really basically great at pattern recognition, and that's basically what auditing is. And then coming up with basically how to attack this, I guess AI would be great for understanding business logic kind of the only thing you can't really automate in a meaningful way because it does require human interpretation, and that's what AI is good for. It is great at pattern recognition and interpretation, but I think in pre deployment it would be quite useful. But I wonder what kind of mindset will be needed for post deployment, which I don't think anybody's really working on apart from myself and Pentestify.
00:37:16.470 - 00:37:21.126, Speaker B: That's all I know about. What do you think about post deployment automation?
00:37:21.238 - 00:38:32.314, Speaker A: Yeah, post deployment is really it definitely is sort of underserved. I would say the only real there's sort of the immune phi post deployment audit in a sense, where you can view a high bug bounty as an ongoing post deployment audit in a sense. And then there are a few, like scanning the mempool and trying to front run. So there's company called Skylock, they're trying to analyze the mempool and basically front run hacks to make them white hat. And so I think there's definitely room for more post audit or post deployment tooling. I don't have a good sense of what it looks like though, besides kind of the big honeypot of money or the big pot of gold at the end of the rainbow of finding a hack. And hopefully if you're a hacker, you see the bouncy and you're like, that entices me more than doing a black hat hack and potentially going to prison.
00:38:32.314 - 00:38:34.960, Speaker A: But yeah, it's an interesting area.
00:38:35.650 - 00:39:00.122, Speaker B: Yeah, it's definitely not worth having the government in the whole world on your back for the rest of your life. I think there's even be stories of someone like Blackhatting, and then six years later they get arrested when they think they're in the free. Yeah, don't recommend it. But it's also interesting you could classify black hats as a long tail mev, I guess, or the way you do it.
00:39:00.176 - 00:39:11.834, Speaker A: I mean, we've seen generalized front runners accidentally front run hacks before and so it'll be interesting to see how that space evolves. For sure.
00:39:11.952 - 00:39:30.980, Speaker B: Yeah, it's like a gray area for sure because I guess there's different ways of doing a blackout as well. Of course you could take millions at the same time at like one atomic transaction, but you could also just take little by little and it kind of looks like a long tail opportunity, right?
00:39:31.830 - 00:39:33.460, Speaker A: Yeah, exactly.
00:39:34.710 - 00:39:43.590, Speaker B: It would be hard to kind of gauge this in a way because all mev is technically an exploit to some degree.
00:39:45.050 - 00:39:53.158, Speaker A: Not all mev. Most a lot of mev is at least an abuse of intents.
00:39:53.254 - 00:39:53.562, Speaker B: Right.
00:39:53.616 - 00:40:00.822, Speaker A: So intents are copy users leaving their intents under specified effectively.
00:40:00.966 - 00:40:32.182, Speaker B: And speaking about post deployment auditing, one advantage about it is you already have an initialized state. So I wonder how people basically initialize their state pre deployment for audits without, I guess unit tests. Right. So I guess how would you go about that? Kind of gone around. It like you don't have any kind of context to go off. So let's say for example, uniswap, let's say there were pre deployment needed, an audit, but you don't have any context or any tests. Right.
00:40:32.182 - 00:40:38.726, Speaker B: So I guess how do you kind of build that context for your proof of concept kind of attack contract.
00:40:38.918 - 00:40:46.454, Speaker A: So you're saying pre audit basically initializing what the contract is going to look like once it's deployed.
00:40:46.582 - 00:40:50.042, Speaker B: Yeah, exactly. But without any reference, basically or any help.
00:40:50.096 - 00:40:54.446, Speaker A: No reference. So you don't have access to the repo and the deploy scripts and stuff?
00:40:54.468 - 00:40:58.270, Speaker B: No. Yeah, you do, but maybe not the deploy scripts.
00:40:58.610 - 00:41:19.702, Speaker A: Okay. Because I was going to say I helped design the you know, it's mostly my brainchild and implemented by Joshi. And I think if you are for my context is this you are an auditor or what hat should I put on here when evaluating this?
00:41:19.756 - 00:41:22.790, Speaker B: I mean, we can do a gray hat. You're best of both worlds.
00:41:23.210 - 00:41:36.730, Speaker A: Yeah, it brings up an interesting thought, like auditors leaving bugs on the table because they know there's going to be a bug bounty and they'll make more from the bug bounty than just submitting it during the audit.
00:41:37.150 - 00:41:58.580, Speaker B: Yeah, I think a common thing I would see or yeah, just like if someone didn't have a test in, let's say a public contest and you don't know basically the initialized state, then how will you make a proof of concept to basically create an attack contract and show them that there's actually an exploit? Because you don't have this world state that's already there.
00:41:59.270 - 00:42:32.186, Speaker A: Yeah, that can be difficult. I think just like the best thing you can do is write a forged script that deploys what you're expected. You make assumptions about what the state of the world is and going from there. Right. So you say, all right, I'm assuming that you're going to deploy this with these parameters based on whatever information you have and then given that assumption, this is how you would exploit it. If I were to personally do this, I would do it all in forge script with a Foundry proof concept thing.
00:42:32.368 - 00:43:20.140, Speaker B: Usually the best way, a little biased, but of course, yeah, I think that's definitely the way you would have to basically read the code and understand it to the point where you would have to deploy it. Just say you're now the owner of this contract and then go through that and basically mock up an initialized state, I guess for, let's say, a uniswap pool. Then you would have to basically get these tokens and adhere to the formula, have the perfect ratio and whatnot, and then go from there. Hopefully there's enough liquidity to do what you want to do with a swap, but that's how you would do it. And that's been kind of something that's been on my mind. And how would you automate that as well? So you don't have to keep initializing all these.
00:43:22.770 - 00:43:51.830, Speaker A: You know, Foundry has fork tests, so a fork of mainnet. So basically it uses an RPC under the hood to read state from. So if you have a s load of a contract that exists on mainnet, it'll actually reach out via RPC, grab it from a real node and use that as the state inside the EVM. And so I've used that a ton for all sorts of things.
00:43:51.900 - 00:44:04.042, Speaker B: It's such a great feature and I think people even getting into that and learning the depths of it, how it works, I'm pretty sure it just caches the state at that block. Right? Yes.
00:44:04.176 - 00:44:48.742, Speaker A: You specify the block you want to use as the state. And then in combination with Forge standard, which I wrote, we have something called Deal. And so it's basically a cheat code that lets you if you do VM Deal, it will give you ether. But then if you just do standard cheat steel, it can basically give you any, ERC, 20. And it does that by another cheat code called Accesses and Records. And it records all of the state accesses. And then we do some interesting things to kind of okay, you read slot four by this call, we can now go write that and then check the function again.
00:44:48.742 - 00:45:15.998, Speaker A: So if it's balance of, right, we'll call one balance of, then you can do a write and then we'll check it again and make sure it updated correctly. And so you can give yourself even on these fork main nets or fork tests, you can give yourself as much dye as you want, effectively or USDC or pretty much any token. There's some caveats with this. It doesn't work for things with packed balance state and that sort of thing. But it's very powerful.
00:45:16.094 - 00:45:44.540, Speaker B: Emulation is quite an interesting field for me as well. I guess in the realm of program analysis, it's quite fun to play around with. But there are two more questions, or three more questions, maybe. Hopefully we can crown them in. But what field do you kind of see as the most lucrative yet unexplored in the crypto world? Let's say ZK or security, something like that, around the lines. But yeah, in your opinion, what do you think?
00:45:48.270 - 00:45:49.500, Speaker A: It's interesting.
00:45:51.570 - 00:45:55.658, Speaker B: Even in terms of tooling as well, like being early in tooling, et cetera.
00:45:55.754 - 00:46:31.206, Speaker A: Yeah, I think in the broader crypto ecosystem, I would say most alt l ones have mostly stopped being able to raise a massive amount. Now it's layer twos and ZK. And so if you're looking at startup, but it's also extremely competitive, where you have a ton of startups in those spaces. And so at Nascent, we've done some ZK stuff, we're invested in optimism. And so I think those are really interesting. I think there's just a ton of competition, but also if you win, it is massive.
00:46:31.398 - 00:46:48.270, Speaker B: Yeah, of course. And I guess that kind of like is a segue into basically what you look at as kind of like a VC investors. What's the criteria for finding a perfect investment? Or something that has potential?
00:46:49.410 - 00:46:56.894, Speaker A: Yeah, first and foremost, it's generally the founder. Do they pass the vibe check? Are they values aligned?
00:46:56.942 - 00:46:57.442, Speaker B: Right?
00:46:57.576 - 00:47:44.398, Speaker A: Do they actually get the crypto ethos and what Ethereum is all about? We'll dabble in cosmos as well, but we generally like to stick around the Ethereum space. And we love infrastructure, we love DeFi and security. We're investors in spearbit code, arena, macro. And so then it's about sort of where I specialize in, is sort of the technical diligence. I always hop on the call and just have a blast with founders, getting to chat about what they're doing technically, how they're thinking about things from a technical perspective. And that really resonates with founders a lot of times. And so I really enjoy that aspect.
00:47:44.398 - 00:48:08.460, Speaker A: And so just making sure the technical side is there, whether it's the founder or people around the founder, just making sure that they can execute on their vision. And the idea obviously matters as well, making sure they're not doing something where we instantly are like, why are you even going after this? This has to be an investable idea.
00:48:08.990 - 00:48:10.250, Speaker B: Another NFT?
00:48:10.750 - 00:48:17.946, Speaker A: Yeah. Oh, you're a fork of uniswap V two sick. No thanks.
00:48:18.048 - 00:48:40.990, Speaker B: Got the market chef on there. Perfect. Yeah. I would like to diverge this a little bit to kind of personality how you think. So I guess to start off as like a lead in architecture, how much do you code versus how much do you think about kind of what needs to be coded?
00:48:41.070 - 00:49:28.930, Speaker A: It's interesting. I would say it bounces back and forth. A lot of the initial side of things is thinking broadly about kind of it even transcends the technical side of things. And it's thinking almost in, like, a Product Manager style role about what does the product actually need to do? And then, okay, here's kind of the sketch for how to execute that. And then it's about coding. And so when I am talking with founders and whatnot, then I definitely have more of the thinking through things and architectural design choices. How do you architect the system to make it gas efficient? It's not something we talked about much today, but I have historically done a ton of gas optimizations.
00:49:28.930 - 00:49:37.494, Speaker A: It really depends on what stage the product is in and figuring out from there.
00:49:37.612 - 00:49:51.210, Speaker B: Yeah. For an example, let's say Pyrometer, what was the process of kind of thinking about, okay, I have this problem, here's a solution. How do we basically build this out step by step to get to the end goal?
00:49:52.590 - 00:50:39.062, Speaker A: Yeah, it basically started as I have this problem and I just kind of ruminated on the problem for a while and eventually it came to me, oh, this would be the solution to do it, or this would be a solution to it. And then once I had the solution, it was, okay, I need the conviction to go and execute on it. And then once I had that conviction, I just started coding and coding and coding. And so then as I'm coding, new ideas pop up here's how this could be expanded, that sort of thing. But I kind of mostly kept a lot of that stuff on the side and just kept them in the back of my head while I executed on the current vision, trying to reduce scope creep until actually ready for those new features.
00:50:39.206 - 00:50:46.986, Speaker B: Yeah. So you basically just create like an MVP of what was completely necessary and then start iterating on that, right?
00:50:47.168 - 00:51:26.774, Speaker A: Yeah, see if this is even possible because I didn't know if it was going to be possible. I had an idea and I got something that worked on a single contract and then I got it to work, then I expanded. Okay, now it can support these solidity features, et cetera, et cetera. So now we support most solidity features. There are some absolutely cursed solidity out there though. Initial pop up on the repo, I'm like, I didn't even know that was valid solidity. Let's say you have an array you can do push with empty insert like nothing in the parentheses equals some value.
00:51:26.774 - 00:51:34.230, Speaker A: And I didn't know that. Right. Why would you do that? I didn't know, but apparently you can. Just quite strange.
00:51:34.390 - 00:51:43.870, Speaker B: Yeah. This is why I kind of went into like the bytecode level. It just all the compiler stuff and I don't want to deal with that.
00:51:43.940 - 00:52:20.678, Speaker A: I'll get right to the yeah, like that's what Sir Tora does. Right. So they're formal verification and it's very common for these kinds of tools to go down into the bytecode. But what I wanted to do with Pyrometer is surface some of these code insights to the developer, to the person reading because we just go to the bytecode. Yeah, it's great for actually finding automated bugs but it doesn't allow you to give context to the developer, the person sitting in front of the computer. It either is just like yeah, we found a bug. No, we didn't find a bug.
00:52:20.678 - 00:52:41.866, Speaker A: And so I think the kind of back and forth of make a change, see what actually is happening to my bounds and whatnot that can be a very useful thing. The user experience of that is very challenging and I have ideas for improving it because if you use Pyrometer today it'll probably work in a contract.
00:52:41.898 - 00:52:44.206, Speaker B: It may not highly experimental, it's highly.
00:52:44.238 - 00:52:55.010, Speaker A: Experimental but then the output, if you have a super large repo, it's massive and so trying to balance that user experience can be challenging.
00:52:55.510 - 00:53:21.498, Speaker B: Yeah, I've spoken to a few people that have used Pyrometer and that was kind of like the biggest pitfall right now is just for a large contract or even a normal sized contract. It's just the visual representation overflows the screen and it's just kind of hard to read even though it's a great tool, it's just the conveying information part which is the hard part to do. Yes.
00:53:21.584 - 00:53:35.054, Speaker A: And this is why we're in beta and whatnot have ideas to improve that and it should still be as kind of foundation for a lot of extra tools built on top like the fuzzer and the other static analysis type stuff.
00:53:35.172 - 00:53:58.582, Speaker B: Yeah, it's all there but it's getting there, right? Yeah. And just like the final question before I let you go, I want to know how you basically schedule your day and basically have an optimal kind of a route for successful day and having great progress. Maybe you have a schedule of some sorts where you wake up at a certain time or you eat a certain way, all that kind of stuff. I want to know about that. So you can become optimal.
00:53:58.646 - 00:55:00.810, Speaker A: Yeah. So I generally am a relatively early riser, 07:00 a.m. Or so and I've drink green tea, I've stopped drinking coffee for the most part and I find you get the caffeine benefit without any of the kind of jitteriness or anything like that and so I don't have breakfast, I skip breakfast and just wait till lunch. And my days are relatively on the venture side, right. I have to hop on calls with founders, and we have our team calls and that sort of thing. And so I try to only take calls and meetings on Monday, Wednesday, Friday, so that my Tuesdays and Thursdays I can be heads down building and coding the products that I want to build and code. And so I find that to be and I do still code on Monday, Wednesday, Friday as well, but trying to just like, yeah, I very much am unable to.
00:55:00.810 - 00:55:32.082, Speaker A: All right, I have a meeting, and then I have a 30 minutes break. Then I have another meeting. That 30 minutes is mostly dead to me. And so trying to optimize my day to where it's okay, all my meetings are before noon, and it's just back to back to back. And then the afternoon, I have free to kind of dive into code and get in that flow. And while I'm an early riser, my natural tendency is to go late at night. I had married, so that doesn't work so much for me anyway anymore.
00:55:32.082 - 00:56:04.490, Speaker A: So I do still try and just like, if I'm in a zone, I try and stay in the zone as long as I can. Sometimes I'll skip lunch, sometimes I'll skip dinner. When I'm in a zone, I try to not let anything derail me, because when I'm in that zone, I am one of the most productive people, period, where it's just I can kick something out faster than a lot of people. And so that's where I like to get to. It's really hard to get to that flow. It's a combination of motivation and having that space and time to dive deep.
00:56:04.570 - 00:56:29.962, Speaker B: Yeah. Zero distractions. With just, like, even a couple of hours of this flow state, you can really accomplish a lot more than what people can accomplish in a couple of days. So it's highly, I guess, lucrative in that sense. And you should always try and cater your day towards building this flow state. And that's also what I've done. I've tried to do that in the past.
00:56:29.962 - 00:56:36.490, Speaker B: I've done, like, one meal per day fasted, even three days straight at one point. And that was just insanely productive.
00:56:36.910 - 00:56:54.740, Speaker A: Yeah, there's something about being low on stuff in your stomach where if you have a full feeling, I feel that I am generally way less productive, and so I try to just keep my food intake relatively low throughout the day and have a big dinner or something.
00:56:57.110 - 00:57:13.560, Speaker B: And just one extra question just for anybody wondering how it's basically, I guess, get to your level or even get hired by you or someone of your caliber, what would you kind of suggest to get to that kind of level that you're looking for?
00:57:14.890 - 00:58:22.320, Speaker A: Yeah, I would say going deep on so there's a couple pieces here. I think going super deep and having a deep understanding of the EVM is super important. Being able to just talk and look at something and understand, okay, this is actually what's happening under the hood is super important. And then really, it comes down to time to build up that expertise, but then not just the, okay, great, you have the understanding, but being able to communicate that, I think, is a very underrated skill. So putting out a content piece about how you solved this CTF and just putting your voice out there about how you think will be one of the greatest things you can do for recognition and improving your chances of getting hired someplace or at Nascent or someone wanting to start a company with you, for example, bringing you on as the CTO, that sort of thing. And so it comes from expertise time and putting your thoughts out there.
00:58:23.010 - 00:59:17.658, Speaker B: I would even like to add to the final point of basically putting your work out there. It also gives you a sense of mastery because if you can't convey it to someone in a meaningful way, do you really know it at that level? You should be able to basically explain it really easily, even if it's a complex problem, or at least to some degree that's easier than how you actually did it. At least that's what I thousand percent. That's what I've learned while doing all my stuff, like learning how to decode call data. That was not easy, that took me days to write that article, but now I'm at the point where I can explain it on the fly without like a graph type of stuff. It's great for reputation, great for mastery, great for getting your name out there, which is opportunities, et cetera. So, yeah, definitely go deep into something and do what people don't want to do because that's how it will yield to the most results.
00:59:17.834 - 00:59:40.562, Speaker A: An interview question I've asked in the past is like, what do you feel is one of your expertises? And then, okay, explain it to me as simple as possible. And that tells me so much about, all right, are they actually an expert in this and kind of can they communicate about it? And so that is a very important skill.
00:59:40.626 - 01:00:02.814, Speaker B: Yeah, communication, especially as a dev, if you're working with people that aren't devs, then you're going to have a hard time. But yeah, I totally agree. But yeah, man, it's been such a pleasure. I think this was a terrific conversation. I thoroughly enjoyed this. I hope you did as well. Hopefully it wasn't like normal conversations and finally express yourself in a nerdy way.
01:00:03.012 - 01:00:05.022, Speaker A: Yeah, I had a blast. Thank you.
01:00:05.156 - 01:00:36.406, Speaker B: Of course, Brock Elmore, everyone from Nascent. And make sure to look at Pyrometer. It could definitely help improve your dev experience and hopefully find some bugs along the way. But if you want someone else on the podcast, please DM me on Twitter, at Degachi or at scraping Bits, or even send an email to scrapingbits@gmail.com and I'll review the person you sent. Otherwise, everyone have a great day or night, depending on where you are. And thank you so much, Brock, for coming on.
01:00:36.428 - 01:00:37.700, Speaker A: Once again, thanks for having me.
