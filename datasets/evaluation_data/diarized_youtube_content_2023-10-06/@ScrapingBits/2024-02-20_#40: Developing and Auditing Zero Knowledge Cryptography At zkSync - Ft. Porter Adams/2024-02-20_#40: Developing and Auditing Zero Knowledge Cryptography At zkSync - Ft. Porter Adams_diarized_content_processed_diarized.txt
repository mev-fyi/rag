00:00:00.330 - 00:00:22.490, Speaker A: AI has almost no chance of creating cryptography. Think of a hash function. You take in an input, and you just mash it together and you get out a random looking short string of characters. And AI can't really predict that because one single change in an input in a hash function completely changes the output. But for AI, similar inputs lead pretty similar outputs.
00:00:22.650 - 00:00:56.430, Speaker B: Scraping bits is brought to you by the following spawn fastlane Labs trustless mev mev protocol. Maximize your eth staking value with me v e exclusively on mev IO and composable execute any intent on any chain. Coming soon to manchis app that is M-A-N-T-I-S-A-P. Gmgm, everyone, my name's togatchi, the host of scraping bits, and today I have another special guest holder from labs. How's it going, friend?
00:00:56.580 - 00:01:00.686, Speaker A: GmGm. It's good. I'm excited to finally get to talk to you.
00:01:00.788 - 00:01:12.914, Speaker B: Finally. Yeah, we've been delaying it for so long, but we're finally here and we get to talk about cryptography, the Zk realm. Just for the people that aren't familiar with you. Who are you and what do you do?
00:01:13.032 - 00:01:33.402, Speaker A: Yeah, my name is Porter. I work at Matterlabs as a security engineer. Matterlabs is the company that works on Zksync. So pretty much people just think I work at Zksync within the company. I'm on the security team, and specifically I help with a lot of our cryptography. So auditing actual ZK code, that makes zksync now, too interesting.
00:01:33.536 - 00:01:43.626, Speaker B: How did you even get into this? This is very niche thing, being able to audit cryptography. What made you go down this path, and how did you really get into all this?
00:01:43.728 - 00:01:58.850, Speaker A: Okay, so the full backstory is, when I was really little, I thought pretty much just codes and code breaking was, like the coolest thing you could do. And so I was always into secret messages and then cryptography, and obviously that ended up leading me here.
00:01:58.920 - 00:02:04.686, Speaker B: There's got to be, like, a lot of math involved as well. Did you go to uni to study math, cryptography, or did you just do self taught?
00:02:04.798 - 00:02:10.594, Speaker A: Yeah, I went to Harvey Mudd college outside of Los Angeles in the United States, and I studied math and computer science.
00:02:10.722 - 00:02:11.702, Speaker B: Okay, interesting.
00:02:11.836 - 00:02:12.690, Speaker A: Damn.
00:02:12.850 - 00:02:21.478, Speaker B: How did you make your way into ZK sync, then? You mentioned before this you were doing Solana auditing. I think that's quite different to auditing cryptography.
00:02:21.574 - 00:02:47.182, Speaker A: It is a little bit different. So, yeah, when I first got into the crypto industry, I was at a company called Kadolski Security. And we did a lot of the early audits in the solana ecosystem, and I just kind of signed up for a crypto job. I didn't know what to expect. I didn't know much about Solana at the time. I didn't know really anything. But I had always had that dream, since I was a kid, of doing more cryptography.
00:02:47.182 - 00:02:57.598, Speaker A: And so I asked continuously to put on any of the projects that have more math or any of the projects that actually roll their own cryptography. One thing led to another and eventually ended up at Matterlabs.
00:02:57.694 - 00:03:16.422, Speaker B: So what do you think is a prerequisite? Being able to get into cryptography? Auditing. Obviously, you know a lot of math and cryptography, but to what degree? Those fields are practically infinite if you wanted to go master each topic in each of them. Right. What do you really need to get into this kind of stuff and to start applying and become practical?
00:03:16.566 - 00:03:22.502, Speaker A: Yeah, I was just giving a lot of people's advice because ZK sync did like a $1.1 million bug bounty contest.
00:03:22.566 - 00:03:23.740, Speaker B: Yeah, I saw that.
00:03:24.270 - 00:04:05.414, Speaker A: It was crazy. That's so much money. I still can't believe we did that. And part of what was cool was that the first time there'd ever been ZKA circuits included in the bug bounty. And so a lot of people were asking, how do I get started? And I think there's always kind of two good ways to learn something, and you should probably do some combination of both. One is just like, look at bugs that other people have found before, just read previous audit reports, look at CK bugs that have happened in production to other companies and stuff, and then try to find those same bugs and said CK sync and then other is really understand the protocol and what's supposed to be happening. And if you can do that, then sometimes it's really obvious what's missing.
00:04:05.462 - 00:04:19.390, Speaker B: Yeah, 100%. You have to understand the underlying architecture and all its game theory, how it all interacts with different parts of it. Did you do much smart contract auditing within ZK as well? Or did you just really focus on actually building the l two itself?
00:04:19.540 - 00:04:33.646, Speaker A: Mostly? At least AZK think all of our ZK is focused on building the l two itself. We don't do too much of the application layer, although I think that there's tons of cool application layer ZK projects. I mean like Tornado Cash was one of my favorites.
00:04:33.758 - 00:05:16.322, Speaker B: I wonder your opinion on the advancement of ZK chains. Because when you think about something like tornado cash, right, they got sanctioned, put in prison, but now there's these entire chains dedicated to enabling basically the same thing. And I guess it depends on whether the company is completely decentralized, not as in people can run their own nodes like ethereum, or if it's just a centralized entity, but if it is decentralized. Right. It's a major red flag for governments and regulators, because if you just sanction tornado cash now, you have an entire chain of the equivalent things, which is great for us but horrible for them. So do you have any spicy takes on that one?
00:05:16.376 - 00:05:45.942, Speaker A: Is that tornado cash is still running? It's still there. You could still use it. Yeah, they can't really stop it. And then in general, I just think governments are always going to be on the losing end of this back and forth battle because you just have to find one country that's okay with everything. And there's so many, for example, small island countries who would be so happy to have all this revenue and stuff. They would love to change their laws to make crypto very acceptable.
00:05:46.086 - 00:05:59.946, Speaker B: Interesting. When building out the cryptography in ZKsync, what are some potential vulnerabilities associated with the implementation of zero knowledge proofs in this technology? And how do you really mitigate these vulnerabilities?
00:06:00.058 - 00:06:30.374, Speaker A: Yeah, first, what does CK sync use the Zk for? Is proving the state transitions. So like moving the chain forward. And so if there are flaws in that proof, then you can prove bad state transitions. You could prove, for example, that all the money now belongs to you or pretty much anything else. It's kind of crazy. Almost any bug inside of the ZK code quickly becomes critical unless there's external checks that are not part of the ZK system.
00:06:30.492 - 00:06:57.730, Speaker B: Yeah, and I feel like it'll be really hard to find it. There's just so much rigor that goes into it. And when it does come up and running, right, then imagine it just going on for months or years, and then eventually you find an exploit and you're like, oh shit, someone can just completely screw up the entire network and give themselves tons of money or screw other people over. How do you even manage to go past from that? When you find something, you just have to spin it up again or what happens?
00:06:57.880 - 00:07:24.794, Speaker A: So I have a fun example of that. Well, one ZK sync. First of all, we don't use privacy, and so we would at least see something bad happening. And for the moment, we do have a 20 hours execution delay, which means pretty much we have 20 hours to notice something, stop it, go back and fix things. Hopefully we never have to use that. But it is there as a safety feature. For now, but eventually we're going to remove it and thing like that, that happens, will just happen.
00:07:24.794 - 00:07:36.650, Speaker A: But the story I wanted to share was from Zcash. So Zcash is actually private. And in the first version of their ZK code. Have you ever heard of trusted setups?
00:07:36.730 - 00:07:37.854, Speaker B: I haven't, no.
00:07:37.972 - 00:08:16.358, Speaker A: Okay, so some ZK algorithms require you to basically, there needs to be some secret that no one in the world knows. And so everyone kind of adds a little randomness into the pot. And then hopefully if enough people do that, then the pot's pretty random. Anyways, Zcash found a bug in their trusted setup program. Because everything on Zcash is private anyways. There's no way to know whether this was ever exploited or what happened. It's a complete mystery whether this was caught or done by malicious people before the actual developers.
00:08:16.358 - 00:08:19.114, Speaker A: ZK sync, like an electric coin company fixed it.
00:08:19.152 - 00:08:24.906, Speaker B: Damn, that's really interesting, actually. So why didn't ZK sync go private? Why did they not go that route?
00:08:25.018 - 00:08:36.270, Speaker A: I do think we want some privacy eventually, but for now the goal is just scale. Ethereum. Ethereum is not private, so default scaling Ethereum doesn't require privacy yet.
00:08:36.340 - 00:08:43.666, Speaker B: That makes sense. Yeah. I mean, if you go private, just completely 180 is the inherent vision of it, which is complete transparency, right?
00:08:43.768 - 00:08:59.894, Speaker A: Yeah, I don't know if that needs to be the vision. I don't know if complete transparency is actually that much of a feature. I think it may be partly it's just a. Like Satoshi even commented on for in posts he would have made bitcoin included ZK privacy if it was more advanced back in the day.
00:09:00.012 - 00:09:21.274, Speaker B: Oh, I mean, that would be good, though. I would totally be down for an Ethereum ZK based model where basically everything is private. I mean, that would be an insane arena, though. Imagine all the black hat activity on a complete private chain. All the MeV. I don't even know how that would work though. If the transactions are private, right, then would MeV even exist?
00:09:21.402 - 00:09:32.500, Speaker A: That is a question. Sometimes you can guess which transactions are coming, even if you don't know for sure. But anyways, all this like Aztecs building this, so we're going to get to see this in real world.
00:09:32.870 - 00:09:52.858, Speaker B: Yeah, yeah. I'm super keen for Aztecs because they have like a public and private mempool. It's kind of like a mixture of both. But yeah, it's going to be super interesting. I think I was talking to Uri from Blockster out just yesterday. I mentioned this as well with him. If you have this system where you can't see the actual transactions, like the details, like no call data.
00:09:52.858 - 00:10:31.590, Speaker B: You only see the value. And then you have the block builders, and you order them in a way where you always put the highest in there and not biased towards the transaction to create MeV or the naval partners that do MeV. I wonder if that would be an interesting scenario. But there again, it is a game that if there is MeV to be captured, then you could theoretically create some system to kind of guess which transactions would be ordered in different ways. I don't know, maybe based off the time it was submitted, or maybe the value indicates something. Even though it's scarce information, there's not really much feedback to be had. It might be an interesting concept, and I guess you never know until you really try it, to be honest.
00:10:31.590 - 00:10:33.350, Speaker B: But it was just something that popped up.
00:10:33.420 - 00:10:37.366, Speaker A: Mev is terrifying. I think it'll always exist, at least a little bit in some form.
00:10:37.468 - 00:11:01.710, Speaker B: I think MeV without private transactions is actually quite, I think, interesting. It's a tough game, but I like the arbitrages. Those are good for the market, but front running and sandwiching probably isn't the best. You don't want to have that in your model. We're trying to replace CFI, right? You're getting front ran every single time you do a swap. It's just built in. That's a feature, it's not a bug.
00:11:01.710 - 00:11:21.670, Speaker B: What do you think where the industry is moving versus where do you think it needs to move? Now you've kind of got two perspectives. You got like the ZK realm and the traditional l one and normal l two s, but you kind of hit them all now. So what do you think from a macro point of view? The industry really needs to go towards and where it's moving right now?
00:11:21.820 - 00:11:55.826, Speaker A: Yeah, that's a great question. I think, first, the cryptographers, I think, in general, are doing great work. Zero knowledge. Cryptography has gotten so much better and so much faster, and there's still lots of new ideas being pushed. And I think the cryptographers are doing really well, completely going in the right direction. The rest of the industry, or the industry overall, I don't know where things are going to end up. Everyone's competing on all these different metrics, but then these completely random chains have tons of money and tons of users in other parts of the world and stuff.
00:11:56.008 - 00:12:38.622, Speaker B: I'm very interested to see ZK bridges and maybe even cross chain interactions of l ones interacting with ZKL two s, and maybe even some kind of conglomerate of all them, intertwining like a web in some ways. I know there's a few people like composable that's doing a cross chain kind of aggregator. And I think the bridging system is really needed because it's all spread across multiple chains, the same liquidity pools. It's so weird, but that's just kind of something I've noticed. And then you've got the MeV game. So people are trying to screw people over for a smallest amount of money, just screws the user over. And then you have like the inherent hacks, if you invest or you become LP provider, right, you're kind of just getting screwed over because people just perform jit on you.
00:12:38.622 - 00:13:01.990, Speaker B: So you actually exit liquidity. And the inherent hacking of contracts. They're all zero days, probably on, let's say 1% of the contracts out there, but they're zero days. So you never know until you go through all of the possible options. That's why you need a fuzzer or some kind of AI fuzzer. Probably an AI fuzzer, because I mean, I was building a fuzzer and the amount of combinations you can create is infinite. You need a lot of compute to do it.
00:13:01.990 - 00:13:33.694, Speaker B: And just the amount of options there are, like when you change one variable, it creates a whole chain reaction of possibilities. I think AI is actually needed for large scale cybersecurity and blockchain, even in general, though. Speaking of AI, and in the realm of that, do you ever think it would be able to crack cryptography? And what are your thoughts on quantum computing as well, since that is really in the realm of if it is able to crack it, then kind of the world collapses in some ways, until there is something better than what is crackable.
00:13:33.822 - 00:14:19.882, Speaker A: I think AI actually has almost no chance of breaking cryptography. There was even a scare like a month ago when Sam Altman got overthrown from OpenAI, and people were saying internally, maybe the AI had cracked cryptography, and that was like, what was spooky, and it was going to destroy the world. And even just think of a hash function, which is one of the more simpler pieces of cryptography. You take in an input and you just mash it together and you get out a random looking short string of characters. And AI can't really predict that very well because one single change in an input, in a hash function completely changes the output. But for AI, similar inputs lead to pretty similar outputs.
00:14:19.946 - 00:14:38.290, Speaker B: Normally, yeah, there isn't really any passing towards it, it's just or maybe there is, and we just don't really know it. But the smallest input completely changes the entire thing. And computationally, it would be very difficult to crack something with a lot of characters. But you never know.
00:14:38.360 - 00:14:44.850, Speaker A: Yeah, you can't do it by brute force. So the AI would have to notice something unique that no one else has noticed.
00:14:44.930 - 00:15:07.710, Speaker B: Yeah, I think it is possible. It's really specialized in finding patterns, right? So maybe it does it. I think it is the best hope at it than humans, at least if it can just live on for. Because we just die after x amount of years. But computers can virtually live on forever, right? If you just hook it up to Internet. Hook it up to like a solar panel farm, and just have infinite compute, right? I don't know. It can just live forever.
00:15:08.050 - 00:15:08.510, Speaker A: Maybe.
00:15:08.580 - 00:15:27.154, Speaker B: We'll see. That'd be a crazy world to live in. If it does crack it, though, that'd be like a giant collapse. But, man, can you explain the cryptographic principles that kind of underpin ZK proofs and how they ensure privacy and security in blockchain applications for the people that aren't really familiar?
00:15:27.282 - 00:16:20.818, Speaker A: So it really starts actually from error correcting codes. I'm surprised more people in ZK don't kind of talk about the history of where this came from, because I think error correcting codes are very intuitive. If you send some data. And what happens if it gets kind of corrupted halfway like a cross being sent? Are you able to correct the ears yourself on your side, or do you have to ask me to resend the whole file? And where this is particularly important is, let's say we send some satellite way out in space and it's taking a picture, and it's going to send it light years back home. We don't want to have to ask that satellite to resend the photo. The back and forth is going to be egregious. So a naive error correcting code algorithm would just be send me the whole message three times in a row.
00:16:20.818 - 00:17:15.042, Speaker A: Now, that's kind of inefficient because you're kind of sending a lot of extra information. But if there's just like one error somewhere along there, like two of the messages are the same, so you can decrypt and you're good. That's kind of a long background, but that should give a lot of intuition. So then bringing that to ZK, what we want to do is prove that some computation was done correctly, and you want the verifier to be able to check it very easily. And so actually pretty much all the ZK codes and circuits do is you encode the computation and then you do error correction on it so that if there are any errors, instead of doing error correction, you kind of do like error amplification. So if there's an error in the computation, it ends up affecting everything else, and then the verifier can catch it very easily. That's my explanation.
00:17:15.186 - 00:17:24.070, Speaker B: Okay. And I guess, what are the practical limits of using the proofs as well? I guess in terms of transaction speed and resource requirements?
00:17:24.230 - 00:17:50.786, Speaker A: Yeah. So the overhead of ZK right now is about like a 1 million x. So if you were to do some normal computation, compare it to doing it with ZK, it's about a million times worse. So what's beneficial is that the verifier doesn't have to do that work. You can put all of the hard work on just one prover somewhere in the world.
00:17:50.888 - 00:17:53.458, Speaker B: But wouldn't that be centralized? I guess it doesn't matter.
00:17:53.544 - 00:18:08.550, Speaker A: Well, as long as the verifier is decentralized, because the prover can't cheat, because the verifier knows what's coming and will only verify valid proofs. So you don't have to trust the prover really at all, actually.
00:18:08.700 - 00:18:14.182, Speaker B: Okay, can anyone spin up their own proverb? I guess. Does it have to be centralized?
00:18:14.326 - 00:18:23.242, Speaker A: Yeah, it's called decentralizing the proverb. We haven't done that yet for ZK sync, but it's relatively straightforward to do. You just let anyone submit the proof to the l one.
00:18:23.376 - 00:18:25.950, Speaker B: Okay. Then someone just picks it up and then kind of does it.
00:18:26.020 - 00:18:43.294, Speaker A: And so you can do some fancy designs around who picks it up and making sure somebody's doing it, taking turns. You can offer rewards for whoever does it first, but relatively, it's relatively straightforward. The decentralizing the proverb part of decentralizing.
00:18:43.342 - 00:18:50.530, Speaker B: L two s. Okay, interesting. What does the prover do and what happens after that with the verifiers?
00:18:50.610 - 00:19:24.046, Speaker A: Yeah, so the verifier is like a smart contract on Ethereum, and it, ahead of time has a verifying key, which is like. So it knows sort of what the circuits look like, and it knows kind of like what should be coming. So it knows how to do its checks properly. Besides that, anywhere in the world, anywhere can just generate a proof of the recent transactions and add it onto the front of the chain. And then the verifier checks the proof. And once the verifiers check the proof, that's when Zksync officially updates to the new state.
00:19:24.228 - 00:19:32.722, Speaker B: Interesting updates to the new state. Why do they have to be on chain, though? Like, the verifiers can't be off chain, right?
00:19:32.856 - 00:19:47.074, Speaker A: In theory. With Zk, you can put the verifiers anywhere you want. You can verify it on a cell phone. But for the purposes of an l two, we want ethereum to be checking everything. And so we put the verifier on Ethereum.
00:19:47.122 - 00:19:58.460, Speaker B: Okay, so it's just like the verifiers are all on Ethereum, and you kind of offload it all onto the prover on the l two, right? Oh, wait, that's not on the l two.
00:19:58.990 - 00:20:06.734, Speaker A: I'd say like the prover kind of goes between. It takes everything from the l two and sort of proves it to the l one.
00:20:06.852 - 00:20:16.642, Speaker B: Okay. But then they still have to send, I guess when you're doing like this l two, you're sending all the transactions to the l two. Wouldn't that cost gas in itself, though?
00:20:16.696 - 00:20:17.826, Speaker A: Yeah, there's a little bit of l.
00:20:17.848 - 00:20:24.434, Speaker B: Two gas, but it still comes out more efficient than actually just confirming it all on the l one.
00:20:24.472 - 00:20:36.022, Speaker A: Right? Yeah. I'm not actually sure what ethereum transaction fees have been recently, but Ck syncs are about like twelve cents now. Ten to twelve cents per transaction, which is good.
00:20:36.076 - 00:20:59.166, Speaker B: Okay. Yeah, I guess it depends on the time during the bull market. It's ridiculous. I was paying $50 per transaction. It seems all right. Seems like a decent benefit. I see the word like zk, snarks and stocks, what are the difference between them? Never really gone too deep into the Zk world, but I hear this all the time.
00:20:59.348 - 00:21:55.114, Speaker A: Yes, this is a hot topic because even the cryptographers love to debate this. The words stark and stark, obviously, like the t and the n are different, but also the leading s is different. So stark stands for scalable, transparent argument of knowledge, and stark stands for succinct, non interactive argument of knowledge. That's just the definition. In practice, there is a slight difference, like a meaningful difference in the cryptography, where starks, I think, allow the verifier or the proof size to be a little bigger, or the verifier can be a little slower. But for my opinion, for most of the general world, everyone should think of starks as a specific type of snark. I think starks are like the general category, and starks are just like a specific instance.
00:21:55.114 - 00:22:03.102, Speaker A: And there is a minute niche cryptography difference. Why starks technically sometimes might not be snarks, but it's silly.
00:22:03.246 - 00:22:07.314, Speaker B: So when would you use a snark over a stark? And vice versa.
00:22:07.442 - 00:22:52.530, Speaker A: Yeah. So ethereum already has some elliptic curve recompiles that make it very easy to verify snarks, because a lot of snarks are based on elliptic curves, and then starks are generally based on hash functions. So in practice, at least right now, starks have kind of been taking over. I mean, zksync. We just rolled out our new proof system, boojim, where we switched to using a stark, or at least fry proofs. And so in practice, what happens is then we do a whole stark proof, but then we want to verify it cheaply on Ethereum. So we actually then prove with a snark that the stark proof was valid, because you can prove anything.
00:22:52.530 - 00:22:59.720, Speaker A: So you can prove that another proof is valid. And so that way people just get the best of both worlds from whichever thing you want.
00:23:00.170 - 00:23:12.140, Speaker B: Interesting. And is this like state of the art, I guess, designs as well, or is it kind of like AI, where people are coming up with new stuff all the time and you're kind of implementing it and seeing how well it works?
00:23:12.590 - 00:23:54.758, Speaker A: Yeah, people come up with new stuff all the time. One recent development has been almost everyone uses what's called prime fields, which are these large prime numbers that are od. But normal computers run on, like, bits, 64 bits at a time, which is not an od number. And so there's a recent paper from Olatana that's on how you could do snarks over a binary field, which might allow you to do a lot of normal computations a lot faster. But it's only been like a month since that paper, so I don't know, I think it just got done in practice once. But we'll see actually how efficient it.
00:23:54.764 - 00:24:10.262, Speaker B: Ends up being, because all I see in the ZK world of, I guess, blockchain is all the same stuff. It's like snark stark proofs. That's kind of it, I guess. Not really. Many people are experimenting I guess, as much, maybe I'm just not very naive.
00:24:10.326 - 00:24:10.714, Speaker A: Not really.
00:24:10.752 - 00:24:11.606, Speaker B: In the spaces.
00:24:11.718 - 00:24:20.714, Speaker A: Yeah. I would say there's actually a ton of experimentation. It's just all sort of like minute levels, and it all counts. There is tons of little differences.
00:24:20.842 - 00:24:27.140, Speaker B: Interesting. What has been your favorite? Have you kind of done your own experimentation at all?
00:24:28.070 - 00:24:57.754, Speaker A: I'm biased towards elliptic curves. My math background probably. But if you've heard of fermas less theorem and all his great number theory things like the Langlin's program, a lot of big theoretical math problems use elliptic curves and are very cool. And so I like when elliptic curves show up in cryptography, it's just a completely biased opinion. ZK sync has just switched to starks, which only use hash functions. So we're kind of moving away from the elliptic curve some, but I miss.
00:24:57.792 - 00:25:28.534, Speaker B: The elliptic curves elliptic curve. I remember that was kind of like my first gateway into just like cryptography in general. I think it was pretty interesting, but then it's always increasing, like the Shah Shah algorithms, like Shah two, Sha three. And you start studying that when you get into, I guess, bytecode stuff, you don't really see it too much, but it is quite interesting. I wonder if anyone's really. I feel like when you get into crypto, there's a few routes you can get into. Beaker was the only one I really didn't get into.
00:25:28.534 - 00:26:20.326, Speaker B: You can go on like Mev, you can do really low level, I guess, bytecode smart contract stuff, which is also what I did. You can go on the infrastructure play, protocol play, or you go onto ZK, or just build chains. I think building chains is quite interesting. You can get a ridiculous amount of funding, and if it does work, if it does work, then you've just built like an entire ecosystem, right? But it's so difficult to build these chains and these ecosystems because you have to build the devtooling as well. I remember doing something on hetero hashgraph, I think it was called back in the day, and they modified the EVM, but didn't supply the right block explorer. You couldn't really look at the contracts on chain at all. You couldn't even get the bytecode, I believe, and you couldn't use Soundgie, it wasn't compatible with it.
00:26:20.326 - 00:26:35.706, Speaker B: So they had really no testing ground for forking. And so it made it incredibly hard to test. I wonder, is there anything, what's the devtooling experience like on the ZK sync? And are you much involved in that at all?
00:26:35.888 - 00:27:22.890, Speaker A: Yeah, well, because it ends up relating to the proof system. So Zksync is currently language compatible, which means you can take your solidity, take your viper and compile it, and then we have a different bytecode format from what the EVM uses. The reason for that is mostly historical. It's because when the founders of ZKsync were first trying to build this three or four years ago, ZK was pretty slow and pretty difficult to do. And so it was tough at the time to directly prove Evyte code. It was better to make like a more ZK friendly bytecode. So that's what we have now, but we've realized that you're right.
00:27:22.890 - 00:27:37.770, Speaker A: The whole dev compatibility experience, like block explorers, are so important, and it's impossible to rebuild how much devtooling there's been done for Ethereum. And so we're moving back towards full Ethereum compatibility.
00:27:37.850 - 00:28:03.766, Speaker B: Now, when someone does a transaction with the use of ZK proofs, how does it affect the finality of the transaction? And what is, like, the trade offs of this? When you think about Ethereum? Is it really just similar to Ethereum, where you just throw it into a mempool and then it's not getting ordered? Right. So it's not like a block builder is choosing which transactions to put in which order and kind of manipulating it in a way and sending off a bundle. Right.
00:28:03.948 - 00:28:20.538, Speaker A: The transaction flow for an l two is. Yeah, you throw it into the l two mem pool. There's something called a sequencer, which is like our block builder, and that creates the blocks. And then after the sequence area, the proverb proves the blocks to the l one.
00:28:20.624 - 00:28:29.022, Speaker B: You know what I saw recently? I think it was arbitram, but it was like a sequence that got overloaded quite recently. I don't know if you saw that.
00:28:29.156 - 00:28:32.974, Speaker A: Yeah. That was literally two days ago, those inscriptions. Yeah.
00:28:33.012 - 00:28:48.934, Speaker B: What happened there? I think that's a big point of failure. Right. If it's just a single sequencer, that's, I guess, centralized. And if it fails, like, what happened there, then what happens? What are the complications that arise after that?
00:28:49.052 - 00:29:06.940, Speaker A: Right. Yeah. Arbitrary stuff. As a security person, I always want these systems to be secure, so I feel bad. Like anytime something crashes, it's hard to be perfect. And I'll talk about Zksync. We also had descriptions yesterday, and I could talk about those.
00:29:06.940 - 00:29:43.650, Speaker A: What happened with that, too? But first, sequencers for the whole l two, the point of an l two is you don't have to trust any of it. We're not always there yet. But if the sequencer fails, which is the block builder, there's sort of two things you should be able to do. One is, from Ethereum itself, you should be able to create new transactions on arbitrum. And then also from Ethereum itself, you should be able to leave and withdraw your money back from Arbitram. As long as you can do those two things, you can pretty much just use arbitram through the l one. The fees will be more expensive.
00:29:43.650 - 00:29:59.260, Speaker A: At least you can get your money out. And so no matter what happens with arbitram, you should be able to both enter and leave on your own. So even if the sequencer goes down, in theory, long term, it shouldn't be too much of a problem.
00:30:00.110 - 00:30:02.246, Speaker B: And what happened with ZK sync?
00:30:02.358 - 00:30:42.154, Speaker A: Yeah, so I guess, in summary, encryptions happening, which is like tons of people spamming the chain. Arbitram first hit like an all time transaction high for them, and then ended up the sequencer crashed, and it took them like 6 hours to get back online. I think ZK sync, we got hit the next day. We were going at 150 transactions per second for several hours, which is very impressive because normally we do about ten. We know we can go faster than ten. That's just like what user demand is at. But we'd never actually gone at 150 tps in production, so it's pretty cool that our system was holding up for several hours.
00:30:42.154 - 00:31:04.514, Speaker A: The only thing that happened was we literally had to upgrade to better hardware halfway through. And so for 15 minutes, we did like a live upgrade. And technically we were down for those 15 minutes, but all of our code still worked. So I'm counting it mostly as a win. But technically we did go down too, because inscriptions are too powerful, there are too many people.
00:31:04.632 - 00:31:25.750, Speaker B: Yeah. There's two questions that arise, I guess. When it goes down, what happens? Is there any detriment? Any, I guess, exploits that could be done to deal with in itself? But if the sequencer is like, I guess, the intermediary, then it would just stop working completely, right? Or is that not correct?
00:31:25.900 - 00:31:50.378, Speaker A: Yeah. Arbitram sequencer couldn't create new blocks, and for the 15 minutes ZK sync users couldn't submit transactions. But because arbitrum has fraud proofs and Zksync has ZK proofs, there's no way for anything bad to happen. Users just can't really use the chain for a little bit. Or theoretically, you could use the chain through the l one itself, but it's kind of annoying.
00:31:50.474 - 00:31:58.962, Speaker B: Yeah, I guess if you're saying the average was like ten transactions per second, that was user demand, like 15 x.
00:31:59.016 - 00:31:59.426, Speaker A: That.
00:31:59.528 - 00:32:15.798, Speaker B: That's so unexpected. Right? It's either an influx of people have converted to ZK land, or it was like a targeted event, I guess. But where are the incentives of doing a targeted event? So it must be.
00:32:15.964 - 00:32:20.118, Speaker A: Are you familiar with inscriptions at all? Or. I can explain inscriptions.
00:32:20.214 - 00:32:21.340, Speaker B: You're going to have to explain.
00:32:21.870 - 00:32:55.646, Speaker A: It's. It's an NFT thing mostly, or kind of a token thing now. And apparently it actually started on Cardano, but really recently it started on bitcoin. And the point is, bitcoin doesn't have smart contracts, so you can't really make nfts. We can just post blobs of data that have pngs in them and then sort of like monkey trade them. Bitcoin doesn't check or verify anything, so you have to run these sort of external stuff to check and see who owns what. That's the idea of encryptions.
00:32:55.838 - 00:33:09.386, Speaker B: But okay, if they're doing that on bitcoin and you're just sending flops of data to someone, can't you? Well, what if someone just copies and pastes? How do you know where the original came from? What's the value in that? I don't understand that.
00:33:09.488 - 00:33:41.838, Speaker A: Yeah, it's pretty weird. Basically the bitcoin itself doesn't track anything. You need to basically run an external node that just tracks who owns these subscriptions. And so it's kind of silly. It kind of makes sense on bitcoin. But then people started, for whatever degen reason, which I think is kind of hilarious, I support it, but go experiment. But people started doing the same stuff of just posting blobs of jpegs on other chains.
00:33:41.838 - 00:34:05.830, Speaker A: So they've been going around one blockchain at a time. And whenever these mints happen, people spam the chain like crazy trying to post all these nfts to get them in. There's no reason to do that on a chain that has smart contracts because you could just do like a normal ERC 721. But that's not what the djens are doing. They're doing inscriptions.
00:34:05.910 - 00:34:28.820, Speaker B: It's so random. Is there even any financial incentive to, I guess even target something like Zk sync? Apart from obviously getting to the point of verifying and I guess manipulating the proverb. But apart from that, is there any other attack vectors that are really aligned with incentives? It just seems not really, not too much.
00:34:29.350 - 00:34:54.570, Speaker A: To really break Zk sync, you need to need to break our proof system, find a bug there, and even then we have some backup checks that you'd have to get past too, or try and compromise core dev as like another attack vector. But even then you'd have to push some update without anyone noticing. And it's pretty unlikely. These things are getting pretty secure already. I'm actually very impressed with how fast we've gotten pretty mature security wise.
00:34:55.230 - 00:35:19.058, Speaker B: I wonder how something like Zksync will maintain compatibility with future upgrades when Ethereum switched to stake from proof of work. Well, it's a new upgrade, right? But Ethereum sharding is anticipated, right? Unless it's already implemented, if I'm mistaken. But when it's implemented, how is it going to maintain compatibility with that if it's a big change?
00:35:19.224 - 00:35:55.658, Speaker A: Yeah, that's one of the challenges. Everyone talks about immutability, but if Ethereum itself keeps changing, and then as an LT, we want to stay compatible with that, so we're going to have to keep changing, where does it end? So I'm not exactly sure what it looks like super long term. I think in terms of security and decentralization, I think almost everything about l two s is solved in theory. We need to do a lot of stuff in practice. Still, the last thing to solve in theory is that long term keeping up with Ethereum, how do you do upgrades, how do you do governance and stuff? It's going to be tough.
00:35:55.834 - 00:36:06.094, Speaker B: I wonder, when we talk about the sequencer, actually, I was just thinking, if that's a centralized entity, couldn't there be decentralized versions of it as well? Kind of like the equivalent of block builders on Ethereum?
00:36:06.222 - 00:36:44.010, Speaker A: Yeah, within all the l two protocols, this has been the hot topic for the last several months. Decentralized the sequencer. And it's kind of interesting because the reason to decentralize the sequencer is the same reason you want decentralized block builders on l one. It's for the censorship resistance. But also we want these l two s to be able to go much, much faster than l one. And at some point, if you're just rebuilding everything that nl one has, you're going to end up at l one speeds. So it's kind of a little tricky to decentralize a sequencer while keeping speeds very high in practice.
00:36:44.010 - 00:36:46.638, Speaker A: I don't think any teams figured that out yet.
00:36:46.724 - 00:36:55.562, Speaker B: What if it was already decentralized by nature, but you ran your own sequencer as a default? Well, then it would be the exact same thing, but with the ability to have decentralization.
00:36:55.706 - 00:36:59.086, Speaker A: You mean like any user could run their own sequencer?
00:36:59.198 - 00:37:36.186, Speaker B: Yeah, exactly. I guess it would be the same as block building, where I guess, perfect example is like flashbots, right? They created flashbots, and then they run their own builder and relayer. And it's not centralized because you can basically spin up your own and people can send to other ones as well. So there is like a centralized aspect. There's also the option to not choose that entity. So maybe that's an option because then you have your own sequencer, which could doing the 150 transactions per second. But then there's also the option for someone else just to app the decentralization aspect.
00:37:36.186 - 00:38:10.118, Speaker B: Because imagine if the company got hit by a government and regulations came, they had to shut down. Well, now the sequence is gone, and then the whole thing's completely gone. But I guess it depends on how much. If the entire stack is decentralized, it's capable of being decentralized, but it's just food for thought, I think. And it would actually be super interesting to see what a block builder would be like with a sequence, because now there's just a new kind of mev game, which I'm always interested in about the game theory behind that. It's just block building for l two s. I wonder if that's a thing, though.
00:38:10.204 - 00:38:56.038, Speaker A: It's something like, I don't think I've ever been asked, and I don't think anyone ever asks. Maybe it's like a forbidden question for l two s. But if you wanted to know, ZK sync just does first come, first serve transaction ordering, because we don't want to be accused of mevving our own users, some people say. Because for the moment, each of these l two s is pretty much the only entity running their own sequencer. And so each of these companies is doing all the blockbuilding themselves. And so we can front run all of our users and make money, but obviously we don't want to do that. So that's another reason to decentralize sequencer is it actually spreads out the MEV a lot more, instead of having it just be us.
00:38:56.124 - 00:39:29.010, Speaker B: That's a crazy thing, because I think the l two s are the biggest, I guess, gas consumers on the network, and obviously they have like insane, imagine partnering with an Mev team. It would just be ridiculous. Obviously it would be completely wrong because it's a centralized entity, just like completely destroying front running everyone. That's a good game plan. Nobody noticed because it's all, I guess it's not private. Actually, if it was private, that would be quite a good game plan, but it's not. But yeah, I don't know, that would be really interesting to see play out.
00:39:29.010 - 00:39:39.254, Speaker B: Who knows, maybe someone does. It spins up a layer two for the alternative motive, ulterior motive to front run everyone.
00:39:39.372 - 00:39:44.358, Speaker A: Yeah, I think if FTX had their own FTX chain, they probably would have done it.
00:39:44.444 - 00:40:18.846, Speaker B: Oh, 100%. I think that's good food for thought, though. I don't know if anybody's really talked about that before. I really am interested in the Zkmev though. If you find, even if it's not private, I don't know anywhere where there's, I guess, something similar to a sequencer or autoflow being sent to something else. There's always an opportunity there somewhere. But, yeah, I'm also wondering, how would you even do auditing on cryptography? Can you even run like, a static analyzer or a fuzzer? Can you build tools for this stuff? Or does it have to be completely manual?
00:40:18.958 - 00:40:52.506, Speaker A: Yeah. Well, first I want to answer about the Zkmev a little bit. So the reason aztec and these other chains have both public and private states, because if all state was private, there's nothing for you to interact with. You need some shared state between multiple users. And so you need that to be public. Pretty much. And so what this means is if you're all trading in a dex, your transactions private and the other transactions in your same block are all kind of like, blended together with yours.
00:40:52.506 - 00:41:08.210, Speaker A: But the price is known before your block and after your block publicly. And so within a block, you're kind of maybe safe from it, maybe because no one can tell, but there's still some. And maybe they could happen between blocks.
00:41:09.270 - 00:42:05.538, Speaker B: I remember hearing from a control c. Control v. I think it was a while ago, but he mentioned, like, l two Mev, where you could convert l one and l two. I think if I remember correctly, this was a couple of months ago. Yeah. He mentioned something along the lines of, like, l two and l one block building Mev kind of thing, where if you have a block builder, and I guess you have these tokens on l two s, I can't remember correctly, but you could basically predict which blocks were going to be accepted and kind of, I guess, monopolize it in some way of being able to confirm two blocks on different chains, one on each chain, and kind of make a chain of them to perform, like cross layer Mev, which I thought was really interesting. I never really thought of that, but maybe there's probably some game theory that you could mess around with that is similar to that.
00:42:05.538 - 00:42:12.178, Speaker B: It does require some expertise, though, obviously of very niche skills of end domains.
00:42:12.274 - 00:42:20.006, Speaker A: It's pretty cool, I think. We actually hired some researchers recently from some college students to think more about these types of problems.
00:42:20.108 - 00:42:23.162, Speaker B: Oh, nice. What have they discovered? If you can share it.
00:42:23.296 - 00:42:35.726, Speaker A: I think it just started. We just announced, or we just accepted them, like, a few weeks ago. I'm not even sure if it starts until the new year, but the research team hires like, 20 college students or.
00:42:35.748 - 00:42:37.760, Speaker B: Something, just like a whole class.
00:42:38.530 - 00:42:48.020, Speaker A: I don't know if they're even all college students. It could just be anyone. But we just accepted research proposals recently, and I know one of the big topics is, like, el Tuna maybe.
00:42:48.870 - 00:43:08.294, Speaker B: Yeah. Cross chain. Cross layer would be crazy. Combine them all together, damn, that'd be pretty interesting, but obviously very difficult. I think the hardest thing is like the bridge interaction with cross chain and anything similar to it is you need some kind of way of interconnecting them or connecting them.
00:43:08.332 - 00:43:08.678, Speaker A: Right.
00:43:08.764 - 00:43:56.678, Speaker B: And if you're just going for a bridge like multi chain, well, first of all, centralized entity, I think they got done for something a while ago, but then it's also really slow. If you're doing something on chain a and then chain b or layer one and l two, you have this time delay of whatever it is. And I guess if it's running on that other chain or whatever, then it might just be gone. If there's like a race condition. So then you're left off worse. Like risk management is just out the window. Some kind of stuff I've thought about in ways, but I think a lot of people talk about cross chain Mev, but I don't know who's actually doing it because it seems really difficult.
00:43:56.678 - 00:43:58.686, Speaker B: Who knows if it's even feasible?
00:43:58.818 - 00:44:03.820, Speaker A: I'm not sure. Bridgetly, always one of the big problems.
00:44:04.670 - 00:44:11.366, Speaker B: Going back to that question about the auditing cryptography, can you even make tools? I assume the best tool would be formal verification for it.
00:44:11.408 - 00:44:32.194, Speaker A: Yeah, the dream is to formally verify all your cryptography, but the ZK landscape changes so quickly and you have to change your code every time Ethereum updates that it's actually not that worthwhile to. You want to formally audit something that's just not going to change, it's just going to stay the same for a long time.
00:44:32.312 - 00:44:32.738, Speaker B: Right.
00:44:32.824 - 00:45:01.430, Speaker A: And with all the updates, it's kind of tricky to do that. Yeah, that does help. But you are able to make custom security tooling specifically for ZK. I know veradice is one company who's done very well in trying to formally verify some ZK things. Also doing some fuzzing and in general just like static analysis of ZK code to look for different types of CK bugs.
00:45:01.510 - 00:45:15.246, Speaker B: Interesting. I guess it'll be different if you were running circuits and you have to kind of order those. Yeah, I don't know. Interesting. And you're saying it's different bytecode as well. How is it going to be different bytecode if it's all hexadecimals? Are you just not using hexadecimal?
00:45:15.438 - 00:45:20.078, Speaker A: It still ends up being hexadecimal but like different opcodes from Ethereum.
00:45:20.174 - 00:45:48.726, Speaker B: Yeah. Okay. That makes sense for an entirely new machine language. What kind of math. Do you really need to know to get into cryptography? As you mentioned, the people in that audit, like the c four contest or whatever it was, that was a big thing. I remember everyone was switching over to ZK, trying to learn how to do it. But I think it's good to upskill into ZK if you're just stuck in security, it's always good to upskill into something else instead of being static.
00:45:48.726 - 00:45:55.598, Speaker B: So, yeah, I guess. How would someone, I guess, upskill onto ZK if they are not in it and we're doing something else?
00:45:55.764 - 00:46:27.074, Speaker A: Yeah, I was very encouraging of people who tried to do this. They started one week before the c four contest, and we're like, all right, I know nothing about ZK. Let's go. I want to be able to find million dollar bugs next week. And part of how I broke it down was to just pick sort of one of the layers. So the deepest layer of the ZK is the math. And at the very bottom, there's a field and an elliptic curve.
00:46:27.074 - 00:47:13.954, Speaker A: But then building on that elliptic curve, there might be a hash function. And then building on the hash function is the actual kind of lazy protocol. And then, building on how the proving works, there's the circuit, which describes the code that you're even trying to prove in the first place. And so each of these layers can kind of abstract away the one below it. So you can find bugs in the circuits relatively easily without knowing too much math, because the circuits are just supposed to be describing EC recover or shot 256, like fairly standard stuff. And you don't have to worry about the math layers below if that's not your shang suit.
00:47:14.002 - 00:47:20.342, Speaker B: But it's never not a bad idea to learn math. You can't learn math and be like, oh, damn, I just learned math. What have I done?
00:47:20.476 - 00:47:49.170, Speaker A: Now? If you really want to learn the math, I mean, first of all, just message me on Twitter. I'll give you all the resources you want, but at a high level, you need a little bit of number theory and then a little bit of familiarity with finite fields. That'll take you a long way. Like finite fields, like modular arithmetic clocks go in circles, and the numbers repeat after a finite amount. So a lot of cryptography depends on that.
00:47:49.240 - 00:47:53.874, Speaker B: Interesting. Finite fields and number fury. That should get you a long way.
00:47:53.992 - 00:48:12.700, Speaker A: Yeah, a lot of ZK ends up just being polynomials and prime numbers. Actually, most of cryptography is like that. You obviously can go really deep, making it sound like simple, but I've studied elliptic curves for years and still don't understand even a fraction of everything that happens with them.
00:48:13.150 - 00:48:32.842, Speaker B: Nice. Interesting. Yeah, I'm like getting into math myself recently, but more towards methods and probability, but I guess that's towards more like AI and predicting uncertainty instead. But math is great. I think it's super hard to get into if you've never really done it before. But it's just like a language. Yeah, it's just a language.
00:48:32.842 - 00:48:43.234, Speaker B: So obviously it's super hard, but you just got to keep doing it every day until eventually you gain some intuition for it. It all clicks and then you're happy because you're understanding it and you keep going.
00:48:43.352 - 00:48:45.266, Speaker A: The feeling when it clicks is so good.
00:48:45.368 - 00:48:58.294, Speaker B: Oh yeah, I mean that's what I had when I was learning rust and all that stuff. Eventually it just clicks and you're like, wow, I can actually do this competently. This is insane, man. I'm super happy to talk to you finally after all these weeks.
00:48:58.412 - 00:49:00.886, Speaker A: Yeah, we had to reschedule, but it was super good.
00:49:00.988 - 00:49:20.574, Speaker B: Yeah. Thank you so much for jumping on. I really appreciate your time and hopefully the people got something out of this. I know, I sure did. And I'm sure we can revisit down the road as well when we both progress in our fields and hopefully the world is a bit different. Maybe the crypto space is entirely ZK by then, who knows? That'll be really cool. But until then, thank you so much for jumping on.
00:49:20.574 - 00:49:21.260, Speaker B: I'll talk to you soon.
