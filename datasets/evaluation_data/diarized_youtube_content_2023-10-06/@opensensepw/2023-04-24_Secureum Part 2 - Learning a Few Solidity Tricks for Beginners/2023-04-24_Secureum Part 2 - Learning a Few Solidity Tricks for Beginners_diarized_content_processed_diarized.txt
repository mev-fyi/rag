00:00:00.120 - 00:00:03.914, Speaker A: Start recording. I'm gonna close these and we're gonna go for.
00:00:08.614 - 00:00:09.670, Speaker B: Google and then we're gonna.
00:00:09.702 - 00:00:15.326, Speaker A: Go for securion Solidity, Solidity 101.
00:00:15.470 - 00:00:17.314, Speaker B: Okay, so let's go.
00:00:19.334 - 00:00:25.274, Speaker A: If you, if you try to watch the video, you're gonna take, you know, much more time to do it.
00:00:25.994 - 00:00:28.174, Speaker B: It's really better when we do it like this.
00:00:29.034 - 00:00:36.770, Speaker A: Okay, everybody's ready? I'll take that as a yes, we're ready.
00:00:36.922 - 00:00:43.850, Speaker B: Nice, you guys. Sorry for my terrible reading English, but.
00:00:43.882 - 00:01:22.374, Speaker A: You know, let's do it. So solidity is a high level language for implementing smart contracts on ethereum and targeting the evm. Solidity was proposed by Gavin Wood and was later developed by the Ethereum solidity team led by Kristen, Alex and others. It's influenced mainly by C, a little from Python and early on from JavaScript. The syntax is op, which means object oriented, and concepts are from C. Solidity, modifiers, multiple inheritance, c three, linearization. I don't know what that is.
00:01:22.374 - 00:01:23.730, Speaker A: Let me find out.
00:01:23.882 - 00:01:29.654, Speaker B: Anybody knows what this is? It's relinearization.
00:01:32.434 - 00:01:35.894, Speaker A: Oh, is how you resolve conflict between inheritance?
00:01:37.154 - 00:01:38.258, Speaker B: We have several.
00:01:38.386 - 00:02:20.934, Speaker A: Okay, better not to talk about that now. And the super keyword are influences from Python, function level scoping and varque world where JavaScript influences early on, but those have been reduced. Okay, so we know that since zero four we have less JavaScript influence is really important to be tied on the version thing, you know, you guys need always to be thinking on the version thing here. Solidity statically typed supports inheritance libraries and complex user defined type is a full future high level language. The layout of a solidity source file can contain an arbitrary number of directives.
00:02:21.954 - 00:02:27.026, Speaker B: Now, okay, because I can have a.
00:02:27.050 - 00:02:49.138, Speaker A: Pragma that is from four to nine, you know, so that would be like more than one. Okay, import directives and struct norms and contract definition. The best practice for layouts to print a contract is following the order. The following order state variables, events, modifier, constructor and functions.
00:02:49.306 - 00:02:50.014, Speaker B: So.
00:02:52.514 - 00:02:55.054, Speaker A: Variables, storage variables of the contract.
00:02:55.994 - 00:02:59.546, Speaker B: Go forced all the events, then you.
00:02:59.570 - 00:03:17.560, Speaker A: Put the modifiers, then the constructors and inside the functions, if I'm not mistaken, you gotta put the all the visible you're gonna order by visibility. And always finish with the internal functions till the end of your contract will always be, you know, full of internal functions.
00:03:17.632 - 00:03:18.404, Speaker B: Okay.
00:03:20.864 - 00:03:30.232, Speaker A: So we have the spdx. I wonder what scpdx means. Solidity search files are recommended to start.
00:03:30.288 - 00:03:34.640, Speaker B: With a commenting indicating its license where.
00:03:34.672 - 00:03:45.908, Speaker A: The compiler includes the supply string in the bytecode metadata to make it machine readable. The access stands for software package exchange. Okay, now we know it.
00:03:45.996 - 00:03:48.064, Speaker B: This is going to be one of the questions for sure.
00:03:48.684 - 00:04:09.784, Speaker A: Pragmas the pragma keyword is used to enable certain compiler feature objects. A pragma directive is always local to a source file. So you have to add a pragma to all your files if you want to enable it in your whole project. If you want to import another file, the pragma from the file does not automatically apply to the importance file.
00:04:09.944 - 00:04:17.128, Speaker B: There are two types. Version a, compiler version b, Abi coder version two.
00:04:17.176 - 00:05:05.582, Speaker A: Okay, so we don't even need to think about this right now. The thing is the important piece of information here, that the prime does not automatically apply to the importing file, which means that if I have different compilers for different files, I'll have different functionality for the same function. Now there is something important here that I forgot to mention that you can import not only contract definitions, but you can import also ennums and structure. And I guess a good way to see that if you have this really complex, really big contract, you know, abstraction, really huge code base, you want to have all your enums, you know, enum types in a separate certain place, and maybe you want to have all your structs in another place, you know? Anyone want to say anything?
00:05:05.718 - 00:05:06.318, Speaker B: Hey winner.
00:05:06.366 - 00:05:07.894, Speaker A: Hey ethnico, how's it going?
00:05:08.054 - 00:05:10.302, Speaker B: Hey anybody?
00:05:10.358 - 00:05:22.674, Speaker A: Everybody here? Okay, let's go for someone is with a mic open? Let me. Winner, can you close your mic please?
00:05:26.054 - 00:05:29.064, Speaker B: Let me close your microphone.
00:05:30.874 - 00:05:46.074, Speaker A: Okay, now let's talk about the version pragma. This indicates the specific solidity compile version usage for that file and is used as pragma solidity Xyz, where xyz indicates.
00:05:46.114 - 00:05:48.826, Speaker B: The version of the compiler using the.
00:05:48.850 - 00:06:04.924, Speaker A: Version pragma does not change the version of the compiler. It also does not enable or disable features of the compiler. It just instructs the compiler to check whether the version matches is the one required by the pragma, and if there's not issues in compiler error.
00:06:05.664 - 00:06:06.404, Speaker B: So.
00:06:09.544 - 00:06:13.684, Speaker A: I guess the important take out of this is that when you specify.
00:06:14.264 - 00:06:16.952, Speaker B: The pragma in your smart contract, you're.
00:06:16.968 - 00:06:19.352, Speaker A: Not actually setting the compiler, you just.
00:06:19.448 - 00:06:21.932, Speaker B: Setting a check that version.
00:06:22.068 - 00:06:57.404, Speaker A: The compiler is actually specified during the execution of Soc. So yeah, I thought that just by setting the pragma you would be actually setting the compiler, but it's just a check to see if that version matches. The latest compiler versions are in the 0.8 z range. A different y in z indicates pre changes. So this is a little bit about Simon semantic versioning. Let me talk to you guys about this really fast release from the stand.
00:06:57.404 - 00:07:02.992, Speaker A: Okay, so you guys going to see software with things like, you know, 1.0.
00:07:03.088 - 00:07:07.960, Speaker B: Dot one, you know, and so what.
00:07:07.992 - 00:07:10.844, Speaker A: This number means is first is major.
00:07:11.384 - 00:07:19.652, Speaker B: Okay, second is, yeah, I think this is major.
00:07:19.748 - 00:07:31.332, Speaker A: This is breaking changes and this is minor changes. So every time you see a software and you see that something like this.
00:07:31.388 - 00:07:35.004, Speaker B: Happened, those could be breaking changes.
00:07:35.084 - 00:07:56.460, Speaker A: And when you see something like this happen, it's just like some fix for optimization, security bug fix, you know. And when you see then the first number changes is like completely new software. And of course this is a completely stupid explanation, but you guys can just check the invert website semantic versioning. So you guys can check what is the actual specification.
00:07:56.532 - 00:07:58.508, Speaker B: You know, mine is going to be.
00:07:58.516 - 00:08:01.428, Speaker A: In Portuguese here, but yours going to be in your language and you're going.
00:08:01.436 - 00:08:02.748, Speaker B: To explain how to swing.
00:08:02.916 - 00:08:06.520, Speaker A: So we know that solidity staking basis on semantic versioning.
00:08:06.552 - 00:08:08.480, Speaker B: Okay, now he's talking a little bit.
00:08:08.512 - 00:08:15.924, Speaker A: About the floating point operator that we know that how it works. So he's going to take state functions up to that.
00:08:17.864 - 00:08:18.688, Speaker B: Let's read it.
00:08:18.736 - 00:08:18.968, Speaker A: Right.
00:08:19.016 - 00:08:19.560, Speaker B: Okay.
00:08:19.672 - 00:09:02.200, Speaker A: The float pragma symbol prefixed in y x, y z in the pragma indicates that the source file may be compiled only from versions starting with xyz until x y z plus one, y plus one. So if we do pragma solidity float zero eight three indicates that the source may be compiled with version starting from zero point a three. Any 0.8 z, so any variation in the middle number, but no variation in the major number. So when we have solidity 0.9, this won't catch those compilers.
00:09:02.272 - 00:09:07.584, Speaker B: Okay, this is known as a floating pragma complex.
00:09:07.664 - 00:09:14.032, Speaker A: This is also not recommended on deployment, you know, production smart contracts. For obvious reasons you don't want to.
00:09:14.048 - 00:09:17.384, Speaker B: Have any sort of changing the compiler.
00:09:17.424 - 00:09:23.456, Speaker A: Running the code, you know, so you always going to have a fixed version. I don't know if this is a rule, like a rule, but I guess.
00:09:23.480 - 00:09:26.090, Speaker B: It'S a common, common guideline.
00:09:26.282 - 00:10:03.674, Speaker A: Complex pragmas are also possible. So you can use equals equal, bigger or equal. So I can say, okay, you can run these from 0.0 h to 0.03 and one use case for these would be after 0.03. We don't have this opcode anymore, so the code can be a little bit more expensive to run. So this kind of hacks, you know, then we have the ABI coder pragma this indicates the choice between the two implementations of the ABI encoder and decoder, the v one and v two.
00:10:03.674 - 00:10:27.104, Speaker A: The new ABI coder is able to co encode and decode arbitrary nested arrays instruct it might produce less optimal code and it has not received as much testing as the older encoder. This is activated by default, so by default we're using the ABI coder V two.
00:10:27.184 - 00:10:31.200, Speaker B: Okay, the set of design I think.
00:10:31.232 - 00:11:06.116, Speaker A: This was introduced after 0.8. I'm not sure though. The set of types supported by the new encoder is a strict superset of the one supporters by the old one. Set of types supported by the new encoder is a strict separate set of the one supported by the old one. Contracts that use it can interact with the ones that do not without limitations. The reserve is possible only as long no Avi encoder v two does not try to make calls that would require decoding types only supported by the new.
00:11:06.140 - 00:11:09.756, Speaker B: Encoder, the compiler and the tacties and.
00:11:09.780 - 00:11:20.900, Speaker A: We wish you an error simply by enable. Simply we wish an error, simply enable ABI coder d true for your contract is enough to make the error as always. Let me just go back a little.
00:11:20.932 - 00:11:26.004, Speaker B: Bit in this and the set of.
00:11:26.044 - 00:12:08.158, Speaker A: Types supported by the new encoder is a strict superset of the supported by the old one. Contracts they use it can interact with with ones that do not without limitations. The reverse is possible only as long known ABI code or retroup contract tries to make calls that will require the coding types only supported by the new encoder. So I guess that means you're doing some sort of, you know, hashing or signature calculating signatures using structs or nested arrays like his here, and that would break. So whenever you're using API encoding encoding.
00:12:08.246 - 00:12:13.222, Speaker B: Be aware everything is compatible because otherwise.
00:12:13.278 - 00:12:33.094, Speaker A: The compiler can detect these. And we should enable enabling Aviv for your contract will make the error go away. So if you have an old contract, you can go there, enable the AVi Aviv two and maybe deploy a new address and change the implementation or point to the implementation.
00:12:33.214 - 00:12:33.994, Speaker B: Okay.
00:12:35.134 - 00:13:02.292, Speaker A: The pragma applies to all code defined in the file where it's activated, regardless of where the code ends up eventually. This means that a contract whose source file is selected to compile with ABI coder V one and still contain code that the new ABI coder that uses the new MBI coder by inherited from another contract. This is really like this really shady, really shady thing, you know, so, so.
00:13:02.468 - 00:13:04.772, Speaker B: Go back to this again, this pragma.
00:13:04.828 - 00:13:13.184, Speaker A: Applies to all code defined in the file when it is activated, regardless of where that code ends up eventually.
00:13:13.644 - 00:13:18.068, Speaker B: Okay, this means that a contract with.
00:13:18.116 - 00:13:20.508, Speaker A: Source file is selected to compile with.
00:13:20.556 - 00:13:24.540, Speaker B: ABI coder V one and still contain.
00:13:24.612 - 00:14:15.794, Speaker A: Code that uses the new MBI encoder by inheriting it from another contract. So if we are inheriting functions and they use the new MBI encoder, you're going to be getting, even though you specified ABI coder V one, you're still going to be getting ABI coder V two. This is the kind of thing to make you find some good findings. You know, this is allowed if the new types are used internally and not externally. There's also this detail, a lot of things to wrap our minds around experimental pragma. This can be used to enable features of the compiler or language that are not yet enabled by default. The SMT checker the use of pragma experimental SMT checker performs additional safety checks by querying the SMT solver.
00:14:16.244 - 00:14:24.436, Speaker B: Are you guys there hearing anybody? Yeah, exactly.
00:14:24.540 - 00:14:58.666, Speaker A: Awesome. So the SMT checker model automatically tries to prove that the code satisfies the specification given by requiring asserting statement. That is, it considered the requirement statement as assumptions, and tries to prove that the conditions inside the assert statements are always true. If an uncertain failure is found, a contra example may be given to the user showing how the assertion can be violated. If no warnings given by the SMT checker, it means the property is safe. Is we're talking about different kinds of checks.
00:14:58.730 - 00:15:01.346, Speaker B: I think there's eight or eight or.
00:15:01.410 - 00:15:37.484, Speaker A: Nine different kinds of checks. One very famous one is for the underflows. So here we have a list. We have arithmetic underflows, division by zero, trivial conditions and unreachable code, popping an empty array, out of bounds index access, insufficient forms or transfers. By the way, wiper fixes all these things by default. Yeah, so whenever you're using. So you don't need, you don't really need to use the SMT checker after version 0.8.
00:15:37.484 - 00:16:09.648, Speaker A: At least that's what I understand, because it's already there, it's already enabled by default. But what's going to happen is when you're doing some calculation in your code, let's say you summing two numbers and you have a code using the SMT checker and the coders not using the SMT checker, when you go to compare both bytecodes of the same function, you're going to see that the function using the SMT checker has a lot of code, like a lot of more code doing the protection against underflows, protection against overflows. You don't see all these things, but they are out there.
00:16:09.696 - 00:16:13.456, Speaker B: Okay, so here he's explaining about, you.
00:16:13.480 - 00:16:27.520, Speaker A: Know, all checks regarding arithmetic, underfloor and overflow, division by zero, trivial conditions, original code, popping an empty array up out of bind, out of bounds, index access and issue sent funds for a transfer.
00:16:27.592 - 00:16:30.416, Speaker B: Okay, a little bit about imports.
00:16:30.560 - 00:16:36.856, Speaker A: Solidity supports import statements to help modularize your code that are similar to those available in JavaScript.
00:16:36.920 - 00:16:38.888, Speaker B: You can do some import file name.
00:16:39.056 - 00:16:47.720, Speaker A: You can do comments with I think slashes. Right. You can also do multi line comments.
00:16:47.912 - 00:16:48.844, Speaker B: Very nice.
00:16:51.304 - 00:17:14.812, Speaker A: The comments are recommended as inline documentation of what your contracts are doing. So yes, as you read the contract, you know you're going to see people over commenting contracts overall in development, people don't recommend you using too much comments. They say code should speak by itself but with solidity. I think it's cool because it's a cheap critical usage that has no way to fix that.
00:17:14.908 - 00:17:17.276, Speaker B: It's really important that you can have.
00:17:17.300 - 00:17:19.944, Speaker A: Like the proper english line and.
00:17:23.864 - 00:17:24.464, Speaker B: And.
00:17:24.584 - 00:17:25.968, Speaker A: Yeah, let me see who's here.
00:17:26.016 - 00:17:28.404, Speaker B: A lot of cool people here.
00:17:29.904 - 00:17:48.364, Speaker A: Let's talk a little bit about Nat spec. I won't be, I won't be reading all these fangles. I will just explain that to you really fast. So let me open a solid file. So if you guys go on Google and search for Nat spec.
00:17:50.174 - 00:17:50.686, Speaker B: Pretty much.
00:17:50.710 - 00:17:58.914, Speaker A: A standard way of doing comments of leaving special notation, that's a word here. Okay, guys, notation in the comments.
00:17:59.614 - 00:18:04.022, Speaker B: So we talking, we're talking about, you.
00:18:04.038 - 00:18:19.744, Speaker A: Know, having the, I know the title. So I have the title, the author, the notice, you know, just like I can do here in this, in this code that I have here on my screen, I can come in this function here and say something like, you know.
00:18:20.204 - 00:18:23.972, Speaker B: Out or, and then, you know, I.
00:18:23.988 - 00:18:33.984, Speaker A: Can say, yeah, this is an aspect pretty much so, pretty much ways of specifying, you know, pieces of your code.
00:18:35.564 - 00:18:36.628, Speaker B: Like we see all the time.
00:18:36.676 - 00:18:49.130, Speaker A: So here they are saying the title, the output notice depth and you can even have, for us there are authors, there's a solidity visual developer that they add a few tags like you can.
00:18:49.162 - 00:18:54.282, Speaker B: Have some like audit out notes, you.
00:18:54.298 - 00:19:18.308, Speaker A: Know, or audit, you know, or true audit. So they have all these cool additional net spec. Okay. So I hope everybody understood that. It's just pretty much the way we do. So just to go over each one of them, title, alter, notice, explain to an end user what this does. So instead of signal, instead of being description, someone decide to call it notice.
00:19:18.356 - 00:19:21.444, Speaker B: For some reason dev explain to a.
00:19:21.484 - 00:19:32.876, Speaker A: Developer any actual details for documents the parameters, so you can have, you know, an explanation for each one of the parameters. And return, what is the return type?
00:19:33.060 - 00:19:36.076, Speaker B: Inherit Doc this is a good one.
00:19:36.100 - 00:20:08.866, Speaker A: Is a special one. So these, so let's say I'm overwriting a function and inheriting something from another contract. Whenever I do this inherit doc, I'll be inheriting all the documentation on that, on that function. So usually we do these things so we can run a software in the end and create this sort of documentation of the platform, of the software. And you can just read, you know, what with what all the functions are doing. And it's also useful for editors to give you a little bit of context of syntax and everything.
00:20:08.980 - 00:20:12.230, Speaker B: Okay, now let's go over contracts.
00:20:12.262 - 00:20:58.704, Speaker A: This is a big one. They're similar to classes in our objected oriented language in that they contain persistent data in state variables and functions that can only modify these variables. Contracts can inherit from another contracts, but we can have a chain of contracts, okay? And whenever a contract is calling another contract inside the, inside the compiler, we'll say the program counter, you have something called the call stack, and the call stack is pretty much the list of contracts calling each other. So if contract b calls contract c or a calls b and b c, you're going to have your call stack being a, b and c.
00:21:01.384 - 00:21:02.096, Speaker B: Contracts can.
00:21:02.120 - 00:21:11.604, Speaker A: Contain declarations of state variables, functions, function modifiers, events, errors, issued types and enum types. And if I knew that we forgot in here, let me think.
00:21:13.784 - 00:21:14.924, Speaker B: I think so.
00:21:16.904 - 00:21:29.640, Speaker A: State variables, those are variables that can be accessed by all functions of the contract and whose values are permanently stored in the contract storage it visibility be specifier.
00:21:29.712 - 00:21:34.248, Speaker B: So here we're talking about public internal private.
00:21:34.376 - 00:21:57.664, Speaker A: So let's go over each one of the visibility public. Those are part of the contract interface and can be assessed either internally or via messages. You know, so whenever we do something internally we are, what is the best way of doing that? We are doing a call.
00:21:59.404 - 00:22:00.980, Speaker B: And whenever.
00:22:01.052 - 00:22:07.476, Speaker A: We do things with transactions, we are sending messages. So there's a little bit of a.
00:22:07.500 - 00:22:11.668, Speaker B: Difference in that internal, internal state variables.
00:22:11.716 - 00:22:21.944, Speaker A: Can only be accessed internally from within the current contracts or contracts deriving from you. So let's go over this one. So if I have a contract.
00:22:24.154 - 00:22:24.658, Speaker B: Contract.
00:22:24.746 - 00:22:34.174, Speaker A: A, contract b, let's see if we can be really nice for us to be able to just, you know, put up the Sphinx pretty fast. Let me just try to.
00:22:36.554 - 00:22:37.106, Speaker B: Also, if.
00:22:37.130 - 00:22:39.434, Speaker A: You guys understood, I can also not.
00:22:39.474 - 00:22:41.574, Speaker B: Do this, you know.
00:22:43.594 - 00:23:08.016, Speaker A: But I'll just copy these. So you guys understand. I'll have contract a. Contract B. And I'll say that b and I'll say that b is a. Okay, so you have it from it. And then according to the documentation that we're just reading, the internal variables can only be accessed from a current contract.
00:23:08.120 - 00:23:10.144, Speaker B: Or contracts deriving from it.
00:23:10.304 - 00:23:16.900, Speaker A: So that means that if we have or even is maybe on remix, maybe.
00:23:16.932 - 00:23:20.864, Speaker B: That'S easier for us if we go remix here.
00:23:24.964 - 00:23:38.372, Speaker A: It's really long session, I hope everybody's comfy. And if anyone has anything to say, please feel free guys.
00:23:38.428 - 00:23:52.944, Speaker B: Okay, let me, let me go over contracts and open contract. Any contract can be on here.
00:23:54.364 - 00:23:55.104, Speaker A: This.
00:23:56.324 - 00:24:04.804, Speaker B: So we are saying that whenever we have a select back here, whenever we.
00:24:04.844 - 00:24:12.224, Speaker A: Have a internal state variable, it can only be accessed here. So I guess I could do.
00:24:15.884 - 00:24:16.664, Speaker B: Maybe.
00:24:18.804 - 00:24:23.340, Speaker A: Address internal. Can I do that?
00:24:23.412 - 00:24:26.460, Speaker B: Internal owner technical you dare.
00:24:26.492 - 00:24:27.548, Speaker A: This works, right?
00:24:27.716 - 00:24:32.572, Speaker B: So, so in this contract here, you.
00:24:32.588 - 00:24:37.566, Speaker A: Know like you could do it. I know if it's construct or constructor.
00:24:37.630 - 00:24:39.114, Speaker B: I think it's constructor.
00:24:41.374 - 00:24:46.594, Speaker A: Here. I could do like something like, you know, if I have this console log.
00:24:46.974 - 00:24:51.702, Speaker B: Let me just do this import I.
00:24:51.758 - 00:24:56.354, Speaker A: Think is hard hat console dot saw.
00:24:59.214 - 00:25:45.874, Speaker B: And if we do function test and we can see the test returns and see text external and returns the address. Someone helped me here, overshadowed him, asking fix this.
00:25:48.334 - 00:25:50.354, Speaker A: Fix this contract.
00:25:59.794 - 00:26:01.066, Speaker B: Oh bro, really?
00:26:01.130 - 00:26:02.474, Speaker A: You're gonna take like the whole fucking.
00:26:02.514 - 00:26:10.658, Speaker B: Year to do this? The code is right, isn't it? No, something was wrong.
00:26:10.746 - 00:26:12.014, Speaker A: I wonder what it is.
00:26:13.594 - 00:26:18.974, Speaker B: Oh, there was no code. Anybody see the difference?
00:26:21.604 - 00:26:23.624, Speaker A: This was the one that's broken.
00:26:24.044 - 00:26:28.116, Speaker B: Not broken anymore. So we could do something.
00:26:28.180 - 00:26:39.504, Speaker A: I guess we could do something like console dot log owner. And here we have access to owner even though it's internal because we inheriting from the contract, you know?
00:26:40.164 - 00:26:42.024, Speaker B: Yeah, this is where I was trying to talk. So.
00:26:44.384 - 00:26:48.840, Speaker A: Private, private can only be accessed from the contract.
00:26:48.952 - 00:26:51.776, Speaker B: They are defined not even in the.
00:26:51.800 - 00:26:53.944, Speaker A: Wired in the private contracts.
00:26:54.024 - 00:27:00.776, Speaker B: So if this was private, I wouldn't.
00:27:00.800 - 00:27:05.136, Speaker A: Be able to access owner. Actually a think I can do this.
00:27:05.200 - 00:27:11.474, Speaker B: A owner here, because this variable know is private.
00:27:11.894 - 00:27:14.354, Speaker A: So let's see if there is regarding that.
00:27:15.214 - 00:27:18.766, Speaker B: Yeah, you see, not found no visibility.
00:27:18.910 - 00:27:22.074, Speaker A: Let's change to internal and see if that works.
00:27:25.214 - 00:27:26.638, Speaker B: We change it to internal.
00:27:26.686 - 00:27:27.794, Speaker A: Wait a little bit.
00:27:28.694 - 00:27:31.354, Speaker B: Looks like we don't have a problem anymore. Okay.
00:27:31.734 - 00:27:56.662, Speaker A: For private owning the contract that you are and private is not really private. Private is only private in the context of the smart contracts, you know, so you can always look at the storage of the smart contracts through the RPC nodes using commons and check out the value in there. Okay, let's go for state variables, constant and immutable.
00:27:56.798 - 00:27:57.594, Speaker B: Okay.
00:27:59.574 - 00:28:14.284, Speaker A: So they can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. This means that if this variable is immutable.
00:28:17.944 - 00:28:20.888, Speaker B: I can only set it during the deployment.
00:28:20.976 - 00:29:02.974, Speaker A: So I can only do like, you know, constructor. Immutable equals address, no, zero, okay, multiple, sorry zone. So this is really the only time I can, I can come here and set this value. If I don't do this at this point, I won't be able to do it anymore. So, yeah, that was that. And it has to be fixed at compile time, while for immutable, it can still be assigned at construct on time. But let me just go back over that.
00:29:04.714 - 00:29:07.146, Speaker B: For constant variables, the value has to.
00:29:07.170 - 00:29:19.134, Speaker A: Be fixed at compile time, while for immutable, it can still be assigned as constructor time or point of declaration, meaning that it can be, has to be declared once, you know.
00:29:20.974 - 00:29:21.714, Speaker B: So.
00:29:23.534 - 00:29:55.552, Speaker A: Just one thing here, one detail when he's saying this has to be fixed at compile time, means that every time I have the constant. So if I have the u in 256, you know, let's say price, price is not really good to be a constant. So let's do something else. Let's do one, one ether, okay? And I can say constant, and I can say, hey, one iter is equal.
00:29:55.608 - 00:30:04.528, Speaker B: One plus that is 180 or something. So this is like how much units.
00:30:04.616 - 00:30:50.956, Speaker A: Composed one eater, you know, and, and I could have like the biggest contract here, going over and doing all the code. I could have like these, you know, I could have something like, you know, whatever price you win, 256 price is equal one liter times two. Let's say, you know, I could have something like that. The, when he say, when we're looking at the, the tax value needs to be fixed at compile time. It means that in the compile, what's going to happen is the vet, the variable will be replaced by this. So we're going to replace all instances of the constant by the value at compile time.
00:30:51.020 - 00:30:56.612, Speaker B: Okay, for constant, the value and for.
00:30:56.748 - 00:30:58.076, Speaker A: For your multiple, I don't know if.
00:30:58.100 - 00:31:00.812, Speaker B: This is the same or if we.
00:31:00.828 - 00:31:21.790, Speaker A: If we go into storage. Okay, for constant variables, the value has to be a constant at compile time, and it has to be assigned with where the variable is declared. So, which means that, you know, whenever I'm doing a constant, I cannot do this. I cannot do like one ethers these and say that one ether, I think.
00:31:21.822 - 00:31:22.590, Speaker B: I cannot do this.
00:31:22.662 - 00:31:28.934, Speaker A: Z coach. Yeah, okay. I can't do, I know I can't.
00:31:28.974 - 00:31:30.542, Speaker B: Okay, nice.
00:31:30.678 - 00:31:41.074, Speaker A: So if I'm doing a constant, I need to just declare whatever, like I need to declare it. Right, right. You know, properly at the right place, you should put the value right in there.
00:31:42.054 - 00:31:56.954, Speaker B: Um, go back and any expression that access storage, blockchain data, balance execution data.
00:31:57.574 - 00:32:05.978, Speaker A: Or makes calls is disallowed. So if you try to be a smart guy and say, hey, my constant.
00:32:06.026 - 00:32:12.858, Speaker B: Is block dot timestamp, for some reason you should break.
00:32:13.026 - 00:32:18.090, Speaker A: I shouldn't work. And we have an error here. Seeing this type is not callable.
00:32:18.282 - 00:32:19.174, Speaker B: Okay.
00:32:21.554 - 00:32:26.094, Speaker A: Are you guys, are you guys following? Is this being good enough? Can you guys give me some feedback?
00:32:43.214 - 00:32:52.234, Speaker B: Can you hear me? Yes. Yeah. Okay, no problem.
00:32:53.074 - 00:33:14.174, Speaker A: Multiple variables can be assigned an arbitrary value in the constructor of the contract. At the point of their declaration. They cannot be read at constructor time, can only be assigned. This is really like really like important and small, you know?
00:33:17.114 - 00:33:20.412, Speaker B: So we're basically saying that, okay, so.
00:33:20.508 - 00:33:26.104, Speaker A: I want, I'm gonna have this immutable variable, right? So let's see, is the owner. So I'm gonna do like I have the owner in there.
00:33:27.524 - 00:33:34.500, Speaker B: Let's say I did this address zero. I don't think that this is possible.
00:33:34.572 - 00:33:37.148, Speaker A: But let's say that I went here and did like the zero.
00:33:37.316 - 00:33:39.932, Speaker B: You know, I typed it myself.
00:33:40.068 - 00:33:42.316, Speaker A: Don't need to get it right here, the amount of zeros.
00:33:42.340 - 00:33:46.578, Speaker B: But you guys understood and, and I.
00:33:46.626 - 00:34:12.790, Speaker A: Couldn'T check that here, that wouldn't be available for me. And the whole reason is whatever is happening inside the constructor, this code doesn't really exist yet. The constructor will still create all the code. So that's why you cannot read things from, from the constructor. You can only set them. So what I will be able to do, let me do some control zs. Here is what we have here.
00:34:12.790 - 00:34:18.902, Speaker A: Now I'm able to create the verb, declare it, and then set a value on the constructor because of the immutable.
00:34:19.038 - 00:34:22.354, Speaker B: Okay, cool.
00:34:23.774 - 00:34:28.234, Speaker A: We don't see anything. Okay, I think my screen sharing.
00:34:29.814 - 00:34:30.554, Speaker B: No.
00:34:34.014 - 00:34:36.434, Speaker A: But the whole time we just, now, just now, right.
00:34:47.674 - 00:34:48.494, Speaker B: Awesome.
00:34:50.474 - 00:35:40.286, Speaker A: The compiler does not reserve a storage lot for these variables and every occurrence. Okay, so this goes back to what we talked before, that whenever you, you have a value, you know, so if I have like you in 256, immovable 1 meter equals 118, like, that, sorry, one exponential to 18 units. Whatever I do with this variable, I'll always be using that. There's no storage that goes, is the same for multiple and is the same for constant. No storage is involved. Everything is replaced at compiler time, meaning during the compilation, the bytecode, we will use that. That's much more efficient.
00:35:40.286 - 00:35:47.286, Speaker A: I don't have to do swaps, you know, all the bytecode processing, the stack processing to have these values around.
00:35:47.350 - 00:35:50.678, Speaker B: Okay, well this will take a lot.
00:35:50.686 - 00:36:24.034, Speaker A: Of time, but the speed we're doing this, compared to regular state variables, the gas cost of a constant and immutable is much lower. This is really important. Every time you guys can use immutable, every time you guys can use constant, use it because the gas is much lower. Imagine having to do all the storage operations to get a value, or just having the value in there, you know, like because of this, you know, because of this thing in here, you know. Can you guys see my screen good. Or is very small? Should I make the letter bigger?
00:36:27.374 - 00:36:36.896, Speaker B: Yeah, we see it. Awesome. So because of, okay, so because, so.
00:36:36.920 - 00:36:37.784, Speaker A: Let'S go back to that.
00:36:37.824 - 00:36:38.564, Speaker B: Okay.
00:36:39.024 - 00:36:47.144, Speaker A: Every time you have the chance of using a immutable variable, and this is really easy to miss because here in the 1 meter I could just say.
00:36:47.224 - 00:36:51.200, Speaker B: Not say this, you know, and have.
00:36:51.232 - 00:36:54.408, Speaker A: The variable to be, you know, I could even have it private or something.
00:36:54.456 - 00:36:56.352, Speaker B: But, but when I do it immutable.
00:36:56.408 - 00:37:04.062, Speaker A: There'S no stores, there's no storage operations to get it, we just replace the values. So be aware, be very aware of that.
00:37:04.118 - 00:37:04.874, Speaker B: Okay.
00:37:08.134 - 00:37:17.914, Speaker A: Let'S talk a little bit about the gas details of this. For a constant variable, let me just see how much time of recording I have at this point.
00:37:22.094 - 00:37:24.274, Speaker B: I just want to open. Yes.
00:37:26.974 - 00:37:54.590, Speaker A: Okay. 37 minutes. Okay. Okay, so for a constant variable, the expression sign to is copied to all places where it's accessed and is also reevaluated each time. This allows for local optimizations. Multiples are evaluated once at construction time and their values copied to all places. For these values, 32 bytes are reserved, even if they would fit in fewer bytes.
00:37:54.590 - 00:38:33.514, Speaker A: Due to these, constant values can sometimes be cheaper than immutable values. So you need to consider really well your use case to see, you know, if that's really what you're going for. The only supported types are strings only. For constants and value types, functions are the executable units of code. Functions are really defined inside a contract, but they can be defined outside contract. They have different levels of visibility towards other contracts. Always talking about how I have function.
00:38:33.514 - 00:38:45.154, Speaker A: There external, there's internal. And what kind of functions I can see in the other contracts, other kind of functions I can't. Let's go for function parameters.
00:38:45.194 - 00:38:45.730, Speaker B: Okay.
00:38:45.842 - 00:38:48.634, Speaker A: Parameters are declared the same way as.
00:38:48.674 - 00:38:51.734, Speaker B: Variable and the name is used.
00:38:52.554 - 00:39:00.004, Speaker A: Name used of the parameters can be omitted. The function parameters can be used as a local. So it's a really cool thing with solidity.
00:39:00.164 - 00:39:01.132, Speaker B: People will consider it.
00:39:01.148 - 00:39:01.404, Speaker A: Cool.
00:39:01.444 - 00:39:03.596, Speaker B: Some people will not consider, oh, I'll.
00:39:03.620 - 00:39:08.212, Speaker A: Just do this just because I know, maybe, I don't know, probably you guys all know this stuff, but I'll just.
00:39:08.268 - 00:39:12.664, Speaker B: You know, just to make sure we're talking about functions.
00:39:13.844 - 00:39:16.292, Speaker A: So this is a function is a piece of code that we're going to.
00:39:16.348 - 00:39:17.692, Speaker B: Run to do something.
00:39:17.748 - 00:39:29.316, Speaker A: In this case we just log in on the owner, but we could be doing something different here. And I don't even need the anymore because I'm not heading to the contract. And parameters are things that we put inside the function.
00:39:29.340 - 00:39:32.332, Speaker B: So if these functions will sum, I.
00:39:32.348 - 00:39:34.556, Speaker A: Could have to, you would, you know.
00:39:34.580 - 00:39:40.636, Speaker B: 256 and you know, anyone, and you.
00:39:40.660 - 00:39:44.732, Speaker A: Will never use numbers for your variable names. Okay. And I can just do here, you.
00:39:44.748 - 00:39:52.904, Speaker B: Know, something like return one plus or something, no change. This true URL.
00:39:54.444 - 00:40:07.904, Speaker A: So these are the parameters and this is the function. Now there's something really cool with solidity. I can have a function with the same name.
00:40:09.604 - 00:40:11.224, Speaker B: But more parameters.
00:40:12.284 - 00:40:23.594, Speaker A: So what means that I can have like different implementations, order functions we can have here a version of sum also takes a third number.
00:40:24.214 - 00:40:27.374, Speaker B: So what, here we have the same.
00:40:27.414 - 00:40:44.294, Speaker A: Function with the same name. The contract is not broken. What's changing is the total of parameters. And this only works because the way we compose the Abi, sorry, I did some fuck up here.
00:40:46.754 - 00:40:48.414, Speaker B: Yeah, I think was just a bug.
00:40:49.714 - 00:40:58.842, Speaker A: Because when we doing the signature, we also take any consideration the parameters. Thus this signature will be different from this signature.
00:40:58.938 - 00:41:01.194, Speaker B: Okay, so this is what we're talking.
00:41:01.234 - 00:41:15.900, Speaker A: About when we talked about that. Function parameters can be declared and the name of unused parameters can be omitted from. Function parameters can be used as, as any other local variable that can be.
00:41:15.932 - 00:41:18.388, Speaker B: Assigned to, okay, now let's talk a.
00:41:18.396 - 00:41:19.664, Speaker A: Little bit about return.
00:41:21.564 - 00:41:23.476, Speaker B: Function return variables.
00:41:23.620 - 00:42:07.060, Speaker A: Function return variables are declared with the same syntax. After the returns keyword, the names of the return variables can be omitted. So return variables can be used as any other local variables you can expect assign. So you can either split the assign the return variable and leave the function as above, or you can provide the return value. If you use an early return. To leave a function that has returned variables, you must provide the return values together with the return statement. When a function has multiple return types, can be used, can be used to return different values.
00:42:07.060 - 00:42:30.300, Speaker A: Let's talk a little bit about returns here. Okay, so first thing I want to show you guys about returns is when they say number, the name can be omitted is because I could have here the result as a name of the return. And if I'm not, and if I'm not mistaken, if I do this, I don't even need the word kit return here.
00:42:30.332 - 00:42:32.396, Speaker B: I can just to that and he.
00:42:32.420 - 00:42:57.596, Speaker A: Will automatically return that for me. I think it's a little bit less readable, but it goes for, it goes from each developer, each one of you has a favorite preference over that. Okay, so returning multiple values, right. And also solidly, you can also return.
00:42:57.700 - 00:43:00.986, Speaker B: You know, different things.
00:43:01.050 - 00:43:17.134, Speaker A: So I think I can return these like, okay, so Boolean and I can say return the result and let's return a boolean. If the number is, you know, if number one is bigger than number two or something. So I can say boolean and anyone is bigger.
00:43:17.874 - 00:43:19.374, Speaker B: I think I can do this.
00:43:20.034 - 00:43:23.094, Speaker A: I just don't know if I need to put those into an array.
00:43:24.294 - 00:43:30.862, Speaker B: You see that? Yeah.
00:43:30.878 - 00:43:34.794, Speaker A: And use it parameter. And I think.
00:43:37.534 - 00:43:43.034, Speaker B: I wonder how this return works if I just say anyone is bigger.
00:43:44.814 - 00:43:47.654, Speaker A: How this works if I just can say, like, I can say something like.
00:43:47.694 - 00:43:54.330, Speaker B: Return these, return these plus true or.
00:43:54.362 - 00:43:58.066, Speaker A: Something, you know, and then I'm returning.
00:43:58.130 - 00:44:02.186, Speaker B: So what I'm returning here is number.
00:44:02.250 - 00:44:19.914, Speaker A: One and plus number two and number one is bigger. But I think the syntax is probably wrong. It's not returns, it's just return. And let's, and I need a semicolon here too. Let's see if that actually works. No.
00:44:22.414 - 00:44:29.714, Speaker B: I wonder I should do this is even possible.
00:44:34.094 - 00:44:38.214, Speaker A: Yeah, looks like this works. So with these I'm returning.
00:44:38.254 - 00:44:41.270, Speaker B: So now this function returns the son.
00:44:41.302 - 00:44:53.590, Speaker A: Of both numbers and a true. Let's see if that works. I'm really curious about that thing now. So we're gonna just go over. So this is remix your best friend from now on. Probably. You guys know it already.
00:44:53.662 - 00:44:55.862, Speaker B: I'm gonna even make the fonts a.
00:44:55.878 - 00:44:58.914, Speaker A: Little bit bigger here so we can get really used to it.
00:44:59.334 - 00:45:00.542, Speaker B: There's not a little bit, there's not.
00:45:00.558 - 00:45:19.274, Speaker A: A lot of secrets to remix. Usually we're gonna be using these tab and this one is one to choose the compiler. Let's go with 8.0 18. You're gonna see that, you know, I'm only being able to use that compiler because I'm using the float pragma that allows us to start from zero eight.
00:45:19.314 - 00:45:25.730, Speaker B: And go to the next change to.
00:45:25.762 - 00:45:44.154, Speaker A: The next not breaking change. I also have this auto compile tag so every time I change the code the compiler automatically I don't need to keep on and it will make fast. That should test it really fast. Instead of having to deploy things and make it really complicated, you can just.
00:45:44.194 - 00:45:52.282, Speaker B: Deploy it on the virtual VM off of Ethereum. So you have merge, this is a.
00:45:52.378 - 00:46:23.544, Speaker A: JavaScript virtual machine so you can just test things. I can just deploy. The contract is deployed and I can say, and I have this, I have choose, you see that I have choose some functions. One for the that will return, you know, picks two numbers and one that takes three. Let's make a test here and let's go for, let's try to sum. I'm going to go for ether scan unit converter. Let me just try something first.
00:46:23.544 - 00:46:39.104, Speaker A: I'm going to just try to do one and two and see what we get back. Yeah, the function work. Let me see something. But we're not getting the result in here. I'm not going to be focusing on that right now.
00:46:39.224 - 00:46:40.444, Speaker B: Okay, let's go.
00:46:44.544 - 00:46:51.136, Speaker A: You can either explicitly assign return variables to in leave function as above or.
00:46:51.160 - 00:46:54.656, Speaker B: You can provide a return value directly.
00:46:54.760 - 00:47:33.052, Speaker A: Within the return statement. You can use an early return to leave a function that has return variables. You must provide the return values together with the return function. Now function has multiple return types. The statement return can be used to return multiple values. These number of components must be the same number of components of the variable and the types to match. Just don't think about this functions to sum here I just wanted to talk really think really fast with you guys is being specified.
00:47:33.052 - 00:48:02.418, Speaker A: The ways here doesn't make a lot of sense because we're not really using no storage from the blockchain. So I guess safe for us to set these as views maybe pure but I think it's safe for us to sell to set these functions as views and we can do sternal, sternal view on both. I don't know if you viewer poor is better here but we're going to go that over the documentation. I just want to know if now having the view instrumentation I can see.
00:48:02.466 - 00:48:04.692, Speaker B: Actually see the result.
00:48:04.788 - 00:48:19.104, Speaker A: That's what I want to see. Yes. So I have the result here for tree and so I'm returning to types. And now one of the tests I want to do is if I remove the return keyword and just deploy it and just do the same thing.
00:48:21.844 - 00:48:22.132, Speaker B: You.
00:48:22.148 - 00:48:24.424, Speaker A: Guys can see that I don't have.
00:48:24.764 - 00:48:25.504, Speaker B: The.
00:48:27.844 - 00:48:33.756, Speaker A: Basically the return is not automatically. Is not returning automatically. So yeah, so always need to add.
00:48:33.780 - 00:48:37.668, Speaker B: A return key, but it didn't broke the code too.
00:48:37.716 - 00:48:38.684, Speaker A: So be aware of that.
00:48:38.724 - 00:48:39.852, Speaker B: Let's go back.
00:48:40.028 - 00:48:50.664, Speaker A: Function modifiers. Okay, we know about the modifiers. They are really important in solidity. They act like cards for certain functions.
00:48:53.404 - 00:48:56.412, Speaker B: So thinking on this function here, we.
00:48:56.428 - 00:48:59.478, Speaker A: Could have a modifier that say only.
00:48:59.566 - 00:49:07.594, Speaker B: Like I can see only numbers below zone five.
00:49:09.494 - 00:49:17.446, Speaker A: Modifier. I think it's modifier number below five. Only number below five.
00:49:17.510 - 00:49:22.354, Speaker B: And here I need to pass the numbers.
00:49:25.314 - 00:49:28.410, Speaker A: So what I can do here, let me just see.
00:49:28.482 - 00:49:32.214, Speaker B: Problem verify. Okay.
00:49:32.594 - 00:49:35.722, Speaker A: It's not important. What I can do here is I.
00:49:35.738 - 00:49:45.690, Speaker B: Can say, hey, acquire that. And one is bigger than five.
00:49:45.802 - 00:49:47.014, Speaker A: Are smaller.
00:49:48.114 - 00:49:51.314, Speaker B: Smaller five. Okay.
00:49:53.294 - 00:50:02.350, Speaker A: Or smaller or equal. No, smaller. You said below. And, and two also needs to be smaller than five.
00:50:02.502 - 00:50:11.994, Speaker B: I don't know if I can do things such as, you know, like those complex logic stuff. So when I do this.
00:50:13.694 - 00:50:41.360, Speaker A: So let me explain to you guys. A modifier is a way of assuring that the code will only happen if certain things are matched. Is commonly used for the owner. So you're going to have the only owner all the time because we're talking about summing numbers here. I'm just giving you guys an example of how we could use this. If we are only accepting to sum numbers below five.
00:50:41.522 - 00:50:43.556, Speaker B: And I can even put a message.
00:50:43.620 - 00:50:51.876, Speaker A: Here or create a nice error type and say, hey, only below five. And I can just add this to.
00:50:51.900 - 00:50:54.124, Speaker B: My functions right after the view.
00:50:54.204 - 00:51:06.428, Speaker A: I can say, hey, only numbers below five. And I also think I need to specify the parameters here. I'm not sure though.
00:51:06.596 - 00:51:10.214, Speaker B: Okay, we're going to find out that right now.
00:51:10.954 - 00:51:14.374, Speaker A: If we try to test this, I try to deploy this contract.
00:51:17.754 - 00:51:18.186, Speaker B: And I.
00:51:18.210 - 00:51:22.854, Speaker A: Do sum of seven and five.
00:51:24.074 - 00:51:27.586, Speaker B: I get a revert and now I.
00:51:27.610 - 00:51:30.534, Speaker A: Have the only below five.
00:51:31.234 - 00:51:42.150, Speaker B: So first thing, line 15, this underscore, it means do this and execute whatever.
00:51:42.182 - 00:51:46.670, Speaker A: Is the code that's coming. So all the coders here pretty much this, this line.
00:51:46.742 - 00:51:47.474, Speaker B: Okay.
00:51:48.374 - 00:51:59.222, Speaker A: I could also have something else here. You know, I could also have some other logic happening here. So I could say, hey, otherwise do that. This is a little bit of a more complex case. I don't see it a lot.
00:51:59.398 - 00:52:00.542, Speaker B: But just so you guys know, I.
00:52:00.558 - 00:52:06.814, Speaker A: Can have something running at the beginning of the function. Run the code of the function and at the end of the function too.
00:52:06.894 - 00:52:07.674, Speaker B: Okay.
00:52:10.694 - 00:52:17.674, Speaker A: Yeah, I want to make a few questions. Are you guys understanding the modifier. Any questions about it?
00:52:25.034 - 00:52:27.934, Speaker B: The fuck understand?
00:52:44.194 - 00:52:47.574, Speaker A: Hey guys, did I, did I leave the call? What happened?
00:52:53.614 - 00:52:54.046, Speaker B: Hello?
00:52:54.110 - 00:52:56.274, Speaker A: Hello, can you hear me? Hello?
00:52:59.774 - 00:53:00.902, Speaker B: Hello, can you hear me?
00:53:00.918 - 00:53:01.514, Speaker A: Guys.
00:53:04.854 - 00:53:06.238, Speaker B: Did I left, did I leave the call?
00:53:06.286 - 00:54:02.550, Speaker A: Did you guys saw what I was doing? My discord is simply like restarting. Okay, I'm gonna go back. So you guys are seeing everything, right? Let me do a little bit of. I wanted to do a little bit of a pause. We just saw the modifiers. They allow you to, you know, protect your function and do some assertments and requirements in a more decoupled way, meaning that you can use those modifiers in different functions.
00:54:02.702 - 00:54:05.638, Speaker B: Okay, let's talk a little bit about.
00:54:05.726 - 00:54:07.314, Speaker A: I'm just gonna see something.
00:54:09.604 - 00:54:10.196, Speaker B: Yes.
00:54:10.300 - 00:54:13.372, Speaker A: Okay, okay, okay, okay, okay.
00:54:13.388 - 00:54:16.784, Speaker B: Okay. Ready to go? Let's go back.
00:54:18.444 - 00:54:24.012, Speaker A: Let's talk a little bit about visibility specifiers here we talk enough.
00:54:24.188 - 00:54:29.044, Speaker B: If you rather see my screen here.
00:54:29.164 - 00:54:43.120, Speaker A: We'Re talking about, you know, the visibility of each function. So it could be public, external, internal or private. Okay, so let's go over each one of them in detail because as those basic thesis is always good to be.
00:54:43.152 - 00:54:45.764, Speaker B: Remembered and reminded of the momentum.
00:54:46.384 - 00:54:54.032, Speaker A: Public functions are part of the contract interface and can be accessed either, you know, internally or via messages.
00:54:54.128 - 00:54:57.824, Speaker B: We talked about calls and transactions when.
00:54:57.904 - 00:55:17.670, Speaker A: Distinction internally and via a messager. Startup functions are part of a contract interface, which means they can be called from other contracts and via transaction. External function f cannot be called internally and does not work.
00:55:17.862 - 00:55:23.150, Speaker B: But these dot f works is whenever.
00:55:23.182 - 00:55:28.714, Speaker A: You use these, you preserve the context. No need to worry or think about that right now.
00:55:29.414 - 00:55:33.308, Speaker B: Internal internal functions can only be called.
00:55:33.476 - 00:55:36.932, Speaker A: Within the current contract or contracts deriving from it.
00:55:36.988 - 00:55:37.716, Speaker B: Okay.
00:55:37.860 - 00:55:47.844, Speaker A: And private functions can only be accessed in the contract area. Define means that if I have a function, there's private. Not even if I inherited, I'll be.
00:55:47.884 - 00:55:50.900, Speaker B: Able to run over it.
00:55:50.932 - 00:55:53.356, Speaker A: Okay, so let's go over functions.
00:55:53.420 - 00:56:01.032, Speaker B: Multiple specifiers functions can be specified as pure or view.
00:56:01.128 - 00:56:10.560, Speaker A: We just talked about that while doing the same thing to see the return. A view function can read the contract.
00:56:10.672 - 00:56:13.964, Speaker B: State a but cannot modify it.
00:56:16.624 - 00:56:26.692, Speaker A: This is enforced at runtime via the static call up. Following are considered state modifier writing to.
00:56:26.748 - 00:56:32.564, Speaker B: State variables, emitting events, creating other contracts.
00:56:32.724 - 00:56:53.004, Speaker A: Using self destruct, sending an ether via call, calling any function not marked as your word, using low level calls, using inline assembly that contains certain opcodes. So here we pretty much saying that a view cannot do all these things.
00:56:53.584 - 00:57:04.080, Speaker B: Okay, now let's see what is the difference for the pure function? Well, peer function can either read contract.
00:57:04.152 - 00:57:05.680, Speaker A: State or modify it.
00:57:05.752 - 00:57:09.848, Speaker B: This is purely for doing helpers.
00:57:10.016 - 00:57:51.580, Speaker A: Maybe some calculations you know the following are considered reading from the state reading variables assessing balance assessing any members of block tx or message so message call block timestamp calling tx origin calling any function not marked as pure using inline assembly that contains certain opcodes. One good question here would be for interviews and things is like can you use inline assembly for peer review functions? And yes you can, but not for all bytecodes. It's not possible to prevent functions reading this state at a level of the EVM.
00:57:51.732 - 00:57:54.596, Speaker B: But now we're talking about I can.
00:57:54.620 - 00:57:56.004, Speaker A: Always look at the storage.
00:57:56.164 - 00:57:57.724, Speaker B: I can always look at the storage.
00:57:57.884 - 00:58:11.924, Speaker A: It's only possible to prevent them from writing to this true from writing to the state via static call. Therefore, only view can be enforced at EVM level, but not pure.
00:58:11.964 - 00:58:15.500, Speaker B: You or didn't quite understood this one.
00:58:15.652 - 00:58:45.650, Speaker A: It is not possible to prevent functions from reading state at the level of the EVM. It is only possible to prevent them from writing to state via via start a call. So you know that when you do a study call you cannot be writing anything. Therefore only view. Only view can be enforced at the EVM level, but not peer. So I guess at the EVM level a pure function will not be treated differently from another function. Okay, just the solidity level allows you to protect it a bit, a bit better.
00:58:45.842 - 00:58:59.494, Speaker B: Function overloading a contract can have oh.
00:59:00.794 - 00:59:34.330, Speaker A: A contract can have multiple functions of the same name, but with different parameter types. This process is called overloading. So we talked about how we had different kinds of some functions. Overloaded functions are selected by matching the function declarations in the current scope. The arguments supplied in the function call return parameters are not taken into account for overload resolution. Return parameters are not taken into account for overload resolution. An interesting one, I guess what we.
00:59:34.362 - 00:59:36.304, Speaker B: Mean here is that I have two.
00:59:36.344 - 01:00:10.142, Speaker A: Functions with different parameters. The return part will not be will not be taken into account when considering data. New maybe is not part of the signature. Three functions are functions that are defined outside the contract, and they always have implicit internal visibility. Their code is included in all contract that call them, similar to a library function. This pretty much means that I can have functions outside the contract. I could have a function like this.
01:00:10.198 - 01:00:15.582, Speaker B: One here, I could have one here outside the contract, and I think I.
01:00:15.598 - 01:00:25.726, Speaker A: Will only have to change these. I think I don't need to put up the visibility, I can just say that is a view and I can then use some now on all contracts they are here.
01:00:25.870 - 01:00:29.590, Speaker B: This is called the free function events.
01:00:29.702 - 01:01:23.902, Speaker A: Are abstraction at the top of the evms in which your log, everything. These logs are associated with the address of the coin track and are incorporated into the blockchain instead. As long as the blocks is accessible, the log is event data is not accessible from referencing contracts. Applications can subscribe and listen through the RPC interface. So basically you cannot read logs from the smart contract events from the smart contracts, but you can do redempt from off chain, you know, whatever. Index event parameters add in the attribute index up for up to three parameters, adds them to spatial data structure known as topic. Instead of data part of the log, you use arrays and bytes as indexed argument Sketch Act 256 hash is stored as a topic instead.
01:01:23.902 - 01:01:43.744, Speaker A: This is because a topic can only hold a single word. All parameters without the index are ABI encoded into the data part of the log topics will allow you to search for events when filtering a sequence of blocks for certain events, you can also filter events by the address of the contract that emitted the event.
01:01:44.284 - 01:01:49.076, Speaker B: Here are we talking about events?
01:01:49.100 - 01:01:58.624, Speaker A: Okay, so I could have an event here. I can say event number number sums, I guess.
01:02:00.164 - 01:02:01.932, Speaker B: I don't really remember the syntax, but.
01:02:01.948 - 01:02:09.940, Speaker A: I think is usually number one and two, six number two.
01:02:10.052 - 01:02:11.988, Speaker B: And I can have, you know, yeah.
01:02:12.036 - 01:02:36.624, Speaker A: Okay, so this is an event, right? And, and, but this event is not really searchable for me the way it is right here. To make it more searchable I need to make it index indexed. And I can do that up to three parameters before 8.0. I think we can do it with four. After 8.008 you can do it with.
01:02:40.044 - 01:02:40.784, Speaker B: Three.
01:02:41.324 - 01:02:56.984, Speaker A: And when I say searchable is now I can go on the, my RPC client through, let's say the terminal and I can search all the sums that happen using then this anyone, so anyone tree. So everybody the sum tree to something.
01:02:57.314 - 01:02:57.882, Speaker B: I know.
01:02:57.938 - 01:02:59.454, Speaker A: So this is what we're talking.
01:03:02.994 - 01:03:03.854, Speaker B: Emits.
01:03:04.554 - 01:03:33.134, Speaker A: Events are emitted using emit followed by the name of the event. If I wanted to emit event, I'll pretty much go over here and you know, I could have one more line or not. I'm just going to do an email number sum and one and two and putting out the event. And I think it's emits or I don't know if it's problem.
01:03:35.074 - 01:03:37.322, Speaker B: Yeah, I cannot, it's nice because it.
01:03:37.338 - 01:03:44.018, Speaker A: Goes back to the other point we just talked about. So internal, you know, I cannot have an internal view.
01:03:44.186 - 01:03:47.170, Speaker B: I cannot have a view that will emit events.
01:03:47.202 - 01:03:48.546, Speaker A: Okay, but if this was not a.
01:03:48.570 - 01:03:57.574, Speaker B: View, there'll be no problem structs.
01:03:58.474 - 01:04:01.498, Speaker A: They are custom types, you know, they're.
01:04:01.546 - 01:04:05.922, Speaker B: Groups, several variables, and they are assessed.
01:04:05.978 - 01:04:20.416, Speaker A: Using the dots like a JavaScript object, you know, so let's just copy the structure here. Uh, so I can show you guys.
01:04:20.560 - 01:04:23.824, Speaker B: Radical example, so I can have a.
01:04:23.864 - 01:04:35.204, Speaker A: Structure here called, you know, and say, you know, Alc oculator.
01:04:37.984 - 01:04:42.044, Speaker B: Is not the best. Okay, well maybe jump this one for now.
01:04:43.684 - 01:04:58.264, Speaker A: Enums, enums can be used to create constant values to improve readability. The minimum of those, the minimum of one member, they need a minimum of one member. It can have a maximum of 250.
01:04:58.964 - 01:05:01.732, Speaker B: They can be explicitly converted from.
01:05:01.788 - 01:05:10.398, Speaker A: Choose three integers and the options are represented by unsigned integer values starting from zero. The default value is the.
01:05:10.476 - 01:05:12.994, Speaker B: Remember, enums are just a way of.
01:05:13.034 - 01:05:15.282, Speaker A: Making your code look nicer. Okay?
01:05:15.418 - 01:05:18.434, Speaker B: Usually you don't want to be comparing.
01:05:18.474 - 01:05:23.898, Speaker A: Things with number, so you don't want to, you don't want to be saying if, you know, whatever, if x equal.
01:05:23.946 - 01:05:26.778, Speaker B: One, do these, you know, but if.
01:05:26.786 - 01:05:32.146, Speaker A: You have an enum that says that one equals, let's say one enum, whatever.
01:05:32.250 - 01:05:46.926, Speaker B: Like I say enum and I can say past, you know, this is probably not the waiting. Okay, I don't know how to create.
01:05:47.030 - 01:05:49.354, Speaker A: Nouns here, but something like that.
01:05:51.294 - 01:05:51.606, Speaker B: I.
01:05:51.630 - 01:05:55.594, Speaker A: Can now say, yeah, okay, so if x got equals test of past.
01:05:57.294 - 01:05:57.606, Speaker B: You.
01:05:57.630 - 01:06:53.704, Speaker A: See, that's much easier to read than having a one here. So that's when enhance so they can be used to create custom types with a final constant values to improve readability. This is the important part of the in thing. We are improving readability is better than having one in there. You know, solidity is a static type language, which means that the type of each variable needs to be specified in the code at the compiler type. This is unlike dynamically typed languages where types are required only within runtime values and statically typed languages to perform compiler type checking according to the language rules. Other examples are c, c, java, rust, go, and scala, pretty much talking about how we need to declare all the types and everything.
01:06:53.704 - 01:07:08.928, Speaker A: Okay, so solidity has sugarcourse of types, value type, and a reference type. This is an interesting one. Okay, value types are called so because variables of these types will pass by.
01:07:08.976 - 01:07:12.480, Speaker B: The value will pass by value.
01:07:12.632 - 01:07:22.144, Speaker A: They are always copy when they are used as functions, arguments in assignments. Read that again. Okay.
01:07:22.804 - 01:07:26.092, Speaker B: Literally has two categories of types, value.
01:07:26.148 - 01:08:02.144, Speaker A: Types and reference types. Value types are called so because the variables of these types will always be passed by value. They are always copped copied when they are used in a function argument or in assignments, which means that every time that I'm using that variable and another function I'm actually at the compiler level copying that value. Okay, but I can also have a reference type. And I think here we're talking about the call data variation for the variables where they can be a.
01:08:03.884 - 01:08:04.740, Speaker B: Reference types.
01:08:04.772 - 01:08:48.864, Speaker A: Can be modified through different names, references through the same underlying variable. Actually, I don't know if this is a call data thing. Value types value types are best are passed by value. They are always copped when they are used in fusion arguments or an assignment. Booleans integers, exit point numbers, address contract, fixed size by the arrays like literals, address, rational integer, unicode, xML enums and functions. These are all value types. And for reference types what we have is we have arrays including dynamically size bytes, arrays and strings.
01:08:48.864 - 01:09:03.640, Speaker A: So if we do so, this is really important to know if we do, if we talking about dynamically size arrays and strings, we're talking about reference types, you know, in first trucks and mappings.
01:09:03.712 - 01:09:09.338, Speaker B: To, okay, default value this is pretty.
01:09:09.386 - 01:09:28.218, Speaker A: Much talking about I think let's read this better. A variable which is declared will have an initial default value which is a byte representation is all zeros. The default values of variables are typical zero state of whatever the type is.
01:09:28.306 - 01:09:32.334, Speaker B: For example, default value for a bowl is false.
01:09:32.734 - 01:09:59.834, Speaker A: The default value for a unit is zero. For a statically sized array of bytes and bytes one to bytes 32. Each individual element will be initialized at corresponding choose type. For dynamically sized array, bytes and strings, the default value is an empty array or string for the inn type. The default value is the first member.
01:10:00.894 - 01:10:05.694, Speaker B: Open scoping solidity follows the widespread scoping.
01:10:05.734 - 01:10:17.366, Speaker A: Rules of c 99. So in the c days we had all these versions of c, c 89 c 99 variables are visible to the point right after the declaration I'm going to be reading about scope.
01:10:17.390 - 01:10:18.086, Speaker B: Sorry.
01:10:18.270 - 01:10:28.746, Speaker A: Boolean a Boolean keyword and its possible values are constants, true and false operators like exclamation mark, which is a logical.
01:10:28.810 - 01:10:36.362, Speaker B: Negation and logical conjunction, logical disjunction or equals.
01:10:36.458 - 01:10:38.098, Speaker A: Okay, this is all, these are all.
01:10:38.146 - 01:10:43.834, Speaker B: Booleans operators that say or and apply.
01:10:43.874 - 01:10:53.274, Speaker A: The common short secluding rules. This means that the expression f or g if x evaluates to true g will not be evaluated.
01:10:53.574 - 01:10:57.834, Speaker B: Okay, integers.
01:11:00.094 - 01:11:02.478, Speaker A: Sign and unsigned integers of.
01:11:02.526 - 01:11:07.294, Speaker B: Various size sorry towards u ink eight.
01:11:07.374 - 01:11:10.422, Speaker A: To u win 256 in steps of.
01:11:10.478 - 01:11:13.854, Speaker B: Eight and a sign of eight up.
01:11:13.894 - 01:11:26.640, Speaker A: To 256 and in eight, two in 256 uint and int our alliances for for both using 256 in the end.
01:11:26.672 - 01:11:29.736, Speaker B: Okay, and here are all the comparisons.
01:11:29.760 - 01:12:05.452, Speaker A: You can do bigger than equals left shift, you know, a bitwise operations and beautiful. We just see something integers in solidity, they are restricted to a certain range. For example uint 32 disease from zero up to two exponentiated to 32 minus one. There are two models in which arithmetic two modes in which arithmetic is performed.
01:12:05.468 - 01:12:11.304, Speaker B: On this types by wrapping or unchecked.
01:12:12.314 - 01:12:24.854, Speaker A: Meaning that the wrapping for checked or unchecked by default, arithmetic is always checked. When we're talking about check it, we're talking about the SMTP checker that we talk.
01:12:26.274 - 01:12:29.946, Speaker B: It's not really smtpfn the checker that.
01:12:29.970 - 01:12:31.974, Speaker A: We talked in the beginning and.
01:12:34.394 - 01:12:34.682, Speaker B: I.
01:12:34.698 - 01:13:08.038, Speaker A: Can now and I like I told you guys that if you do use this checker, you're gonna be adding a lot of bytecode to the operations and you can use unchecked operations that will deny all the safety features in there. Okay, the call is reserved through a falling assertion. You can switch to unchecked mode using the unchecked. It was introduced in compiler 0.8 because in 0.8 everything checked by default. So if you want to do unchecked it, you're going to be doing that.
01:13:08.038 - 01:13:20.366, Speaker A: And usually the way the reason why people use the unchecked operations is to save gas in some sort, you know, or because they are really sure that that operation specifically will never be overflowing.
01:13:20.430 - 01:13:28.814, Speaker B: Because everything is very controlled. Fixed point numbers fixed point numbers using.
01:13:28.894 - 01:13:36.210, Speaker A: Fixed fixed are not fully supported by solidity yet. They can be declared, but cannot be.
01:13:36.242 - 01:13:40.258, Speaker B: Assigned or from assigned to or from.
01:13:40.426 - 01:13:48.474, Speaker A: There are fixed point libraries that are used like Tsmat, BRB math, and AbDk math.
01:13:48.554 - 01:13:51.314, Speaker B: So these are some of the libraries.
01:13:51.354 - 01:13:56.054, Speaker A: You can use to do more advanced mathematics and maybe more precise mathematics.
01:13:56.914 - 01:13:58.414, Speaker B: So address types.
01:13:59.314 - 01:14:06.834, Speaker A: So an address comes in two type one that holds a 20 byte value the size of an ethereum value. This is also another one of those.
01:14:06.874 - 01:14:10.146, Speaker B: Interview questions, and another is payable the.
01:14:10.170 - 01:15:08.448, Speaker A: Same address, but they have the additional bytecode to send and receive assets. Okay, you can also use these operators for addresses. And when talking about conversions from address payable to address are allowed, whereas conversions from address to. While address payable must be explicit via the PI, the payable keyword. That means that whatever works for address payable works for address, naturally. But if you need thanks from address payable and you haven't declared that as payable, you need to cast it to convert it that address to a payable address. Okay, explicit conversions through and from address are allowed for ubint 156, interlatural bytes 20, and contract types.
01:15:08.536 - 01:15:09.284, Speaker B: Okay.
01:15:11.464 - 01:15:17.156, Speaker A: Only expression of type address and contract type can be converted to type.
01:15:17.220 - 01:15:26.020, Speaker B: Address payable via explicit conversion of payable. The contract type or contract type is.
01:15:26.052 - 01:15:38.704, Speaker A: Conversion is only allowed if the contract can receive it or the contract has the contract either has received or payable a payable function. So what is saying here is that.
01:15:42.624 - 01:15:42.936, Speaker B: So?
01:15:42.960 - 01:15:50.560, Speaker A: Let's read it again. Only expressions of type address and contract type can be converted to type address.
01:15:50.632 - 01:15:58.256, Speaker B: Payable via the explicit conversion payable for contract type.
01:15:58.360 - 01:16:58.398, Speaker A: This conversion is only allowed if the contract can receive either or. The contract has a receiver payable function. So if you have a contract does not have a receive or a payable function, you won't be able to convert to cast that into a payable contract into a payable address. Okay, but what is the member, what are the members of the address type? We have the balance that we always using the code, the code at the address, the code hash, which is kind of the id to load the code in the database. Transfer function send function returns delegate call static call. Let's go over each one of those what they do from transfer. So sends giving amount of wage and address revert some failure enter in and force the 250 guys spent.
01:16:58.446 - 01:17:00.898, Speaker B: Okay, then we have send.
01:17:01.066 - 01:17:31.794, Speaker A: Okay, send giving you the amount of weight. Then address return false on failure orders to the gas and is not adjustable. Have call which issues a low level call with even payload return success and condition and return data for its all available gas. Delegate call also does a low level with the payload, but now he's going to be keeping all the contacts will be the same as the sender will be the same.
01:17:31.874 - 01:17:37.250, Speaker B: Everything that initiated the transaction in static.
01:17:37.282 - 01:17:41.186, Speaker A: Call, we know that for calling views basically things that will not change.
01:17:41.250 - 01:17:44.410, Speaker B: Okay, so let's talk a little bit about the transfer.
01:17:44.522 - 01:18:07.862, Speaker A: The transfer function fails if the balance of the current contract is not large enough and if the entry the contract is rejected by the receiving account. The transfer function reverts on failure. The coding receive function the coding receive function, or if not present in the fallback function, is executed with a transfer call.
01:18:07.918 - 01:18:08.594, Speaker B: Sorry.
01:18:08.934 - 01:18:10.822, Speaker A: Transfer function failures if the balance of.
01:18:10.838 - 01:18:14.414, Speaker B: The contract is not large enough, or.
01:18:14.494 - 01:18:15.918, Speaker A: If the contract is rejected by the.
01:18:15.926 - 01:18:19.674, Speaker B: Receiving account, the transfer reverts on failure.
01:18:20.184 - 01:18:26.120, Speaker A: The coding received function, or if not present in the fallback function is executed.
01:18:26.192 - 01:18:29.376, Speaker B: With a transfer call that execution runs.
01:18:29.400 - 01:19:01.478, Speaker A: Out of gas or failure inua the ether transferred will be reverted and the current contract will stop the execution. The send function is the low level counterpart of transfer. If the execution fails, then send only return false and does not revert unlike transfer, so the return value of send must be checked by the caller. This is also another point, really big point in interviews for security, they're going to be asking you transfer, vest send.
01:19:01.606 - 01:19:04.834, Speaker B: And you better have these things to answer them.
01:19:05.574 - 01:19:09.194, Speaker A: Let's talk a little bit about call delegate call and start a call.
01:19:11.954 - 01:19:12.242, Speaker B: In.
01:19:12.258 - 01:19:48.180, Speaker A: Order to interface with contracts that do not adhere to the ABI or get more direct control over the encode, the function call, delegate call and state call are provided. They are like they all take a single bytes memory parameter and return the success condition and the return data. The functions ABI encode and Abi encode packet and ABi encode reselector. ABI encode resignature signature can be used to encode structured data. Gas and value modifiers can be used with these functions.
01:19:48.372 - 01:19:59.716, Speaker B: Delegate call doesn't support value delegate call doesn't support value. This is really important to specify the.
01:19:59.740 - 01:20:26.214, Speaker A: Amount of gas and ether value passed to the colleague to delegate call. The only code of only the code of the given address is used. All other aspects, storage balance and message sender are taken from the current contract. Purpose of delegate call is to use a library logic which stored in the Kali contract, but operate on the state of the caller.
01:20:26.254 - 01:20:30.390, Speaker B: Contract okay with static call, execution will.
01:20:30.422 - 01:20:52.174, Speaker A: Revert if the college function modifies the state in anyway. Contract type every contract defined its own type. Contracts can be explicit, converted through and from an address type. Contract types do not support any operators.
01:20:52.514 - 01:20:56.154, Speaker B: The members of contract types are external.
01:20:56.194 - 01:21:05.034, Speaker A: Functions of the contract, including any state variable marked as public. I'm going to stop for here today, guys.
