00:00:03.720 - 00:00:38.362, Speaker A: Hi there, I'm Max Waldulin. Also go by strikeout. Earlier today we did a recording of a talk on the recent Sushiswap hack. However, we had some technical difficulties and so we've decided to rerecord it. So I'm just going to get into it then. So on April 8, the prominent security researcher trust tweeted this. It was igis whitehacked Sifu for 100 deeds.
00:00:38.362 - 00:01:00.114, Speaker A: I would like to return it. Please contact me in the DM's. And this started a whole chain of actions. If you look down here, you can now see this is insane. Meve bots have deployed contracts to copy the attack before it could save everything. That was pretty wild. And it turned out that there was actually a lot of funds that were at risk and in a contract that was only four days old.
00:01:00.114 - 00:01:37.858, Speaker A: Now, Peck Shield picked up on this and said that there's a copycat, has some links to some addresses and they said that there were a lot of funds that were directly at risk, particularly SiFU. Had about $3.3 million worth of ETH stolen. Now this is a pretty big deal because it's sushiswap, right? It's a pretty popular automated market maker. Because of this, slowmist decided to do some coverage on it. And this was when I really started getting interested. Like how does this actually work? According to Slow, Misc ended up being, or Depechshield in a different, different post.
00:01:37.858 - 00:02:20.644, Speaker A: They had ended up being a approval related bug. You see here that. Please revoke approvals ASAP. And slow miss then goes through the entry point to see how an attacker can hit this, which is where I got most of my information prior to launching an ATT and CK. So in this presentation or this video, whatever you want to call it, we're going to go through the exploitation, this bug. We're going to go through the bug discovery, but we're not just going to exploit for one user. We're going to create a script that goes through the discovery of the vulnerable users and pwns every single user that was vulnerable to this attack.
00:02:20.644 - 00:03:17.814, Speaker A: We're going to do some of this live, which I think is pretty fun. So if we go back to the slowmist report, we see that the root cause is that the process route does not perform any checks on user provided route parameter. This allows the attacker to exploit this issue by constructing malicious route parameters, a cause of the contract to read a pool created by the attacker. We see that process route is the external call you can make and they are hitting the Uniswap v three functionality within there, the value last called pool is actually what's hit. Important thing to note about uniswap v three is unlike uniswap v two where you approve the contract to spend funds on your behalf, you actually don't do that anymore. Instead there is a callback function. And this callback function uses the contract's approval in order to transfer the funds to it.
00:03:17.814 - 00:03:54.184, Speaker A: And that is what this is talking about. So from reading this we know that swap uni v three is the function you want to hit process route is the location. We're actually trying to hit this from. The issue comes down to uniswap v three callback function. Now we can go find this code pretty easily. We can google this and with the name of this would be router processor two and we can find it. But I just copied it here for insanity.
00:03:54.184 - 00:04:55.352, Speaker A: We can go to this location on etherscan and we can see all the transactions. More importantly, we can find the code so you can copy this code and analyze it locally. Now I have my own development set up here and I've already downloaded this code right here. So once I had the code locally, I wanted to figure out what the vulnerability was. But how do we actually hit this functionality? I decided that if I took some time to understand what the code does had that functionality, that the vulnerability would probably be pretty apparent. To start with, we are in the swap uni v three functionality. You can either go source to sync or sync to source where source is where the input comes from and sync is the location in the code or the kind of like the gadget or the ending location that you want to hit in the code.
00:04:55.352 - 00:05:25.314, Speaker A: In this case, I find that going all the way back up from the sink is the easiest way to go. So we have the function swap univ three and this calls, this takes in our pool. What's this pool come from or where does it come from? It comes in from the stream parameter. So we're going to follow what that stream parameter is all the way up. We're to search for us. There's only one place it's called. It's called in swap.
00:05:25.314 - 00:05:59.860, Speaker A: Now we should document this just for insanity. We are going from uni, uni e three swap. That's where our entry point, that's the place we want to end up at. And we have process routes we want to go. So we have some stuff in the middle that we need to now fill in. We have the swap function. And where is this call at? Probably not going to be the unity two pair that we care about.
00:05:59.860 - 00:06:18.644, Speaker A: That's not the swap we actually want. This could be it, but we're not doing anything with Bento so probably not it. Process one pool. Process is ERC 20 token. For cases when the token has only one output pool. That seems like a good option for us. We can try to find that.
00:06:18.644 - 00:06:59.376, Speaker A: Cool. So this is within process route internal. So we see swap and this is called with process one pool. And that is in process route. Turn off. Making progress. Now we are in processroute internal and process route internal is called by process route.
00:06:59.376 - 00:07:41.484, Speaker A: And this is that route parameter we were talking about. Now we know how to actually hit that functionality. We should probably run all the way through our input. So the route is the actual input we want to use for this attack because the route ends up controlling the input pool route gets turned into a stream, which we'll talk about what a stream actually is. Just consider it to be this Abi packed encoded. The first thing that the stream does is it takes out a value. It's reading a one byte or an eight bit integer.
00:07:41.484 - 00:08:18.784, Speaker A: And this needs to be four because we want to hit process one pool, the command code needs to be four. That's where the command code comes from. So the first thing we get out of the stream is command. And this needs to be for undate. Now if we go into process one pool takes out an address and this is the token that's going to use. Cool. So we have token.
00:08:18.784 - 00:08:45.164, Speaker A: We don't know what we want this to be or if it needs to be anything specific. And we have an address. Now we're going to call swap. And within swap we're reading the pool type. And to hit the uniswap b three functionality, pool type must be one. So pool type one. And this is another unit.
00:08:45.164 - 00:09:24.656, Speaker A: Within the uniswap v three functionality we are taking out a pool which is reading address. We're taking out un eight for a boolean and we are reading the address for recipient. Pool is an address but we don't know the value. We're taking out boolean of some sort. One. I actually don't know what this actually does within that needs to be. And this is a boolean u because those are actually score exactly the same same.
00:09:24.656 - 00:10:00.184, Speaker A: And then we have the recipient. That's going to be another address. We don't know what we want. Cool. So we know in order to hit this functionality we need to call process route with a very particular route. Actually to hit this, let's see if we can find the vulnerability. When we're making a call to Uniswap, we have an interface with this and it's calling the pool address with swap.
00:10:00.184 - 00:10:48.394, Speaker A: Makes sense. We're calling swap on Uniswap v three pool. But the magic lies here and here. You see, like I said before, the callback function, Uniswap needs to use the permissions of the contract in order to send funds to it itself. So Uniswap v three callback is used in order to get the funds from Uniswap. And you can see that we are getting data, and within data is the token that Uswap wants us to transfer. And for what user? At the very end of this, we can see a call to save transfer from that has.
00:10:48.394 - 00:11:28.952, Speaker A: So what this allows it to do is Uniswap V three doesn't have to actually have the permissions or the approval for this, only this contract does. Because this contract has permissions to use this address and send tokens from this user because the user approved it. They can then send it to message sender, which in this case should be new swap feature pool. It's all pretty straightforward. It's just how Uniswap v three works. We're probably wondering is, oh my gosh, that's an amazing security issue because we can just directly call this and transfer any user funds to ourselves of any amount. That's awesome.
00:11:28.952 - 00:12:08.696, Speaker A: But it's not that simple. The developer thought of this and there is a check right here that makes sure that message sender is same to last called pool. If you go back to Uniswap v three, where this is actually set at, we see that last called pool is equal to pool and that pool isn't called on. So let's make sure that only a trusted entity, in particular the Uniswap v three pool, is able to call this back. But it has to be the exact pool address that we made on this call. Well, that's pretty cool. I like that.
00:12:08.696 - 00:12:56.654, Speaker A: But is that going to work for us? Problem here is that the pool address is directly controlled by attacker. There's no validation. This is in fact a valid Uniswap address. What this means is that we can call the uniswap v. Three pool on our own contract, because we've called it with our own contract, and pool is set to last called pool and we in fact control the pool. We can call the USwap v three call back ourselves. By doing that, we can bypass this verification and use this to exploit the inherent trust that users have with this router, the users approved more than they actually spent for this router.
00:12:56.654 - 00:13:39.722, Speaker A: That means we can transfer their funds on their token to ourselves. The vulnerability is pretty straightforward and I actually have a pretty good snippet on a blog post I just wrote about this that shows us in even simpler light. We have two functions here, function one and function two. Function one has a address called pool address that is being set. Function two then validates that the pool is equal to the message sender because we called function one. That is true. That is exactly what we hope for.
00:13:39.722 - 00:14:43.204, Speaker A: Then we can do any sort of sensitive action like transfer the funds. This is a really watered down version of this vulnerability. Now we understand the vulnerability, we're going to exploit this inherent trust. But what's the actual plan for this? We can create a first we need to call process route. In particular we need to set the pool within the route parameter. Once we've done that, the pool that we're setting needs to have a swap function. This is so that when process route calls swap as it should for a uniswap v three pool, we actually have that functionality there.
00:14:43.204 - 00:15:41.174, Speaker A: Once we're inside of the swap function, we need to call the uniswap v three callback and this can be used to abuse. This is abusing the trust on the last called pool. Once there we call the Uniswap v three callback function. What we want to do is send a token of the user that's form that they've allowed. We want to send the amount of funds and we want to send in our victim. That's a high level review of what we want to do for this attack. And we're going to write this proof of concept live.
00:15:41.174 - 00:16:09.674, Speaker A: So we're starting with a brand new contract. We're going to call it exploit live. So you start with a pragma first. I'm blanking right now. Live recording is hard with solidity. Thank you. And this can be 0.8.
00:16:09.674 - 00:16:28.776, Speaker A: Usually that auto fills. I don't know why I did it this time. That's okay though. We'll call this exploit live. We're going to start by writing this contract with some magic values. First thing we need to know is the router. This is the sushiswap router that we were looking at before.
00:16:28.776 - 00:17:09.392, Speaker A: So we can do address router equals this. And this is the sushi swap route processor two. We then need a token that we can exploit and a victim. In this case we're going to use the user sifu because that's where this launched on. And the address of Sifu is going to be our victim. That's this. And the token that was stolen from Sifu was wrappy.
00:17:09.392 - 00:17:39.412, Speaker A: So we're going to then set the token here. You could define these values dynamically. I just searched for the Sifu address. I looked through some of the transactions on Etherscan. Then for the token you just look at the event logs to see what token was exploited. So with those setup we can call the Att and CK function. Within this attack function we need to call processroute.
00:17:39.412 - 00:18:26.560, Speaker A: But we don't have anything actually defined to do this. We're going to create an interface that we can then use in order to call process route. So I'm going to say interface sushiswap router like and then I'm going to go back to processor route and copy in the function we want to call copy in this function. We're going to remove that. Great. Now we can instantiate an object here. Let's say sushi router like sushi router equals sushiswap like router.
00:18:26.560 - 00:19:09.194, Speaker A: Now we can make calls to the CC router using this interface we've set up. The only function that we want to call right now is this process route. If we go back we can see what we actually need to provide for this. And if you read this code carefully we can find out that a lot of it's garbage. We're looking at process round internal which just has the same parameters. And it takes in the token in and it does a balance check here. It does a balance check here for the balance in and balance out initial and then it is checking later down here as some sanity checks.
00:19:09.194 - 00:19:51.324, Speaker A: Well we just need a valid token here. But you see in this inline if statement, if the token in is native address, it just does address of this balance. Now this native address is meant to act as e that we've set so we can do native address. You just copy this in there and use that instead. And this makes their exploit a little more gas efficient, but it makes it a little bit easier to follow. So for the token in and token out, we can just set native address. The amount in is the amount of tokens that we're initially going to pass in.
00:19:51.324 - 00:20:18.852, Speaker A: But we can actually set this to zero. There's no Sandy check to make sure it's greater than that. And then that amount out minimum is the amount of tokens that should be transferred out at an absolute minimum because of slippage. So we can also set that to zero because we don't care about that. And the two is really not used for exploit. So we can say zero. And the route is the only thing we actually haven't set.
00:20:18.852 - 00:20:53.844, Speaker A: So route is going to be bytes, memory route. This is going to be API coded. Now if we look at what we had here, we already talked about what values you need to hit this. The first thing is an eight bit integer. So one byte in this command code is going to be four. So unit eight four we have an address. After that that address ends up not being used.
00:20:53.844 - 00:21:25.044, Speaker A: So we can just set zero. Then we go back to here and we have a pool type of one unit eight again. So we're going to write un eight one. Then we have an address. And this is actually the key to this exploit here. If you go back to uni v, this function, this is where this pool is going to come from. And this is where we actually make the call.
00:21:25.044 - 00:22:10.520, Speaker A: In order to make our exploit easier and have multiple contractors set up, we're going to set up one contract and set up swap here. We're going to fill that code in a minute, but we want the pool to be this. So we're setting the address of this to be the pool. Now we have zero for one in recipient and because both of these get used in the call where we don't really care, normally this would be sent to the actual use being sent ourselves. So we can ignore that un eight is the same as a bool. So I'm just going to set that to be zero. Then we can do the address of zero again because we're not going to use it at this point.
00:22:10.520 - 00:22:44.598, Speaker A: We've created a proper route, but we need to implement this swap function, go to the route processor itself. It actually has a interface for your soft v three pool. So we can just copy this in for our contract. Great. Now when we call process route, we'll actually hit a callback on this. But just to make sure, we're going to do a const blog because we're using hard hat. We can do that.
00:22:44.598 - 00:23:25.808, Speaker A: I say hit swap function, right? That's pretty rad. I need to import that still. And I'm like live import hard hat console. So that should go away. And now we can use hard compile and in a few seconds I should compile code. Cool. We don't have any bugs.
00:23:25.808 - 00:23:58.572, Speaker A: That's awesome. So in this tab we have the code we're going to execute. In this tab we have a uniswap v three node that is, sorry, use v three node. We have a node that's run locally. And I forked this right before the exploits took place. We're going to do yarn hard hat run, and we need to set up a script in order to do this. So I made the script earlier just because it's easier to do it that way.
00:23:58.572 - 00:24:29.128, Speaker A: But it's a pretty standard hard hat deploy contract execute. We're getting our exploit live contract. We're calling deploy, we're calling deployed, making sure that this actually did deploy. Then we were calling the attack function on this contract, and then we're waiting. So pretty straightforward. It's gonna be scripts and hacksushi live. Oop, I actually messed that up.
00:24:29.128 - 00:24:58.664, Speaker A: I need to specify the network for this too. Otherwise we'll clean that. Let's deploy our contract. And it launched it and it reverted. Well, dang it, what does it say? Unknown command code. Oh, I know why that happened. If we go back to our contract here next live, we'll notice that this is using encode.
00:24:58.664 - 00:25:29.644, Speaker A: There are actually two different ABI encoding functions. There's one that takes all of the static sizes and places them into 32 bytes, which means that a unit eight would actually be 32 bytes instead of one byte. Like it could. If you use encoding pact, it will set it. This four will now be one byte exactly, instead of being 32 bytes. This threw me off initially when I actually ran this code. But if we look at the stream processing, it's read an assembler.
00:25:29.644 - 00:26:09.344, Speaker A: And I was a little terrified of this at first. But if we look at it, there's a pretty good giveaway. You see, read unint eight and read unint 16. And the only differences between these are one and two. Because of these slight differences, it made me think that this was likely processing data in a packed format. It was going to take out one byte and return that versus unit 16 was going to take out two bytes. So this is putting an eight bit integer, one byte, and taking out one byte, which indicates that this is likely using the pact format instead.
00:26:09.344 - 00:26:38.568, Speaker A: So we've saved this and we've used the coding pact. This should work again. Compiler code. Now we should try to deploy our contract. This gave us another error. Do we do something wrong? Not really. If we go back to our contract, we can see that this is an error message from the router itself.
00:26:38.568 - 00:27:08.676, Speaker A: See route processor uniswap v three. Unexpected. When does this occur? It occurs directly after our call to swap within uniswap v. This is used in order to confirm that the callback was actually made. So it's saying that last called pool should be set to impossible pool address. If we go back to use swap v three callback, we can see that's exactly what this function does in our exploit code. We haven't called the use swap v three callback yet.
00:27:08.676 - 00:27:41.902, Speaker A: We've just called swap. Are we sure we actually called swap though? Yes, we are. You can look at the console log from the node that we ran that we can see our console log, which is pretty rad. So we were able to successfully call swap on our own contract from the context of processroute. That's awesome. At this point, we need to implement the uniswap v three callback function. We can do the same thing we did before.
00:27:41.902 - 00:28:23.314, Speaker A: We can go and grab this callback from here and just add it to our contract interface that we've set up. We go here and we can add this to our interface. Perfect. And now we can call this function once again. So this is create a router. And on our router we want to call the copies. What's wrong with this? You specify the visibility.
00:28:23.314 - 00:29:00.776, Speaker A: So you swap v three callback, and this takes in three parameters that we care about. The delta delta zero, amount delta one, and the data. We can go read the code for this. So mat delta zero and amount delta one are only used on this single line. This is saying amount delta zero. If it's greater than zero, then use amount delta zero. Otherwise use amount delta one.
00:29:00.776 - 00:29:37.644, Speaker A: I don't know too much of how this callback actually works, but it looks like it's intended to use amount delta zero if it's positive, and use amount delta one if it's positive. In practice, all we have to do is set amount delta zero to be the amount we actually want to steal. Then this amount is used in the safe transfer from call. Cool. So for the amount one delta, and we set it to zero. And then we need an amount, which we will need to calculate. Then we also need the data.
00:29:37.644 - 00:30:46.614, Speaker A: I'll create these up here. And redo bytes data, two equals types. Memory data, two equals ABI code. In this case, we actually want ABI and code instead of ABI code hacked because this is using Abid code, not B code. So how do we actually calculate the amount of funds we want to steal? And it turns out that this comes directly back to rc 20 standard. We can, we want to see the amount of funds that this contract, the router processor two, is allowed to spend because we're abusing that trust, enormous funds. So in order to calculate this, we're going to calculate two values first we're going to calculate the balance and then we're going to calculate the allowance.
00:30:46.614 - 00:31:57.974, Speaker A: I believe that we have that this contract is actually going to be using the open supplements FRC 20. So we can actually use that ourselves in here. Great. And this will allow us to use the IERC 20 interface. And remember how we set the token for exploitation before we can now set that to here and we can call balance of on our and this will get amount of token for our victim. Similarly we're going to call ERC 20 token and we're going to call allows and this allowance call is going to say we're going to check the allowance that victim is allowing this router to span. So we're going to then put in router there mount token that the router and spend of victim.
00:31:57.974 - 00:32:45.192, Speaker A: In order to calculate the amount. We want to take the minimum of these because if they have a very high allowance but a lesser balance, then if you try to send the allowance they're not going to have enough funds to send and we'll revert if we do it the other way though where we try to send more balance than they're allowed to send then we'll also get a revert because we've broken up our user. So I'm going to say balance is greater than allowance then we're going to use allowance. Otherwise we're going to use the balance for this call. Cool. So now we know how many funds, amount of funds to steal. We've calculated that, but we still have one more parameter fill out.
00:32:45.192 - 00:33:15.124, Speaker A: We have data too. Within processor the data parameter has two values encoded. It has token in and from. Tokenin is the token we want to steal from, in this case rapi. And from is the user we want to steal from aka victim. So we can use token in and victim for this call. Cool.
00:33:15.124 - 00:34:18.908, Speaker A: The mistake I made is that we need to convert this to int 256 because that is what this actually takes in. And that would have been a unit and hopefully that works. Before we actually run this exploit though, I wanted to show you guys the user. I have some etherscan tools that I've written or etherscan, ether Pc, that sort of thing. And in this, if you look at or address this is calling our local node that's running is checking for the our users. So sifu balance of wrapped ETH. Here we're creating a contract with our coin address which is again wrapped ETH.
00:34:18.908 - 00:35:01.262, Speaker A: And then we are going to check the balance of our user. Then we were checking for the allowance that the user is allowed to send off to a particular browser. Sorry. We're using the user address for allowance and seeing how much funds does this user allow this other user to use. In this case, the router address, it will show us the balance and allowance. This is about three ish million dollars worth of ETH and this is essentially unlimited allowance. So in this case we can only transfer this much e, which is still 1616.
00:35:01.262 - 00:35:42.114, Speaker A: ETH is still a lot. If we go back and run our exploit again, we can see if this runs and there is a non zero chance that I have some bugs in my code or I had some really subtle flaws that we need to fix in a moment. Cool. So what's the first flaw? First flaw is amount. I am not saying that to type again. It's like a compiled successfully. Now we can see if this call succeeded.
00:35:42.114 - 00:36:14.410, Speaker A: Let's try to launch the attack. And the attack worked great. Now if we run the script once again, you can see changed. The balance of this user is now zero and the allowance has gone down. It's hard to tell, but you can see that some of these numbers have changed. Where has it changed? Changing here somewhere. Yeah, so that's pretty awesome.
00:36:14.410 - 00:36:53.794, Speaker A: We just stolen $3 million worth of ETH in this. In this relatively simple bug. To recap within process router, there is a vulnerability that allows us to set the pool. And this pool is a very trusted entity. Once we control that pool, we can then have it call our own swap function. Because of that trusted aspect of this call, we are able to make a call to swap v three callback, which allows us to spend arbitrary funds for arbitrary users that have approved this contract. This is a classic confused deputy problem if you ever heard that.
00:36:53.794 - 00:37:55.774, Speaker A: But what if I told you we can make this much worse? We can do so much better. See, we only stole it from this one user. How would we actually go about stealing this from all of the users? Easy way to go about this would be going to here on Etherscan and looking at all of the transactions. If we look at all the transactions and imagine that this was in the past, prior to this exploit, we could have checked to see which users were actually approving this. So we have a execution here. And on this call to the Sushiswap contract, this user would have had to have approved this contract to send funds. And that is a pretty big difference that it's a pretty easy way to analyze what users we can exploit.
00:37:55.774 - 00:38:52.166, Speaker A: When I click on this user and within the receipt of a transaction are the logs, we can see that there is a from, there is a to and there is a value within this. We can actually check to see what was used here. We can check to see this user had to approve funds to be transferred by this contract. We can see what token they allowed and the amount they sent. Using this information we can script looking at all of the transactions that the Sushiswap router has used and find a list of vulnerable users with their vulnerable token. Now one way you could go about this is look at popular tokens and look for events on the approved function. But I found this to be pretty or much easier and a lot more direct.
00:38:52.166 - 00:39:30.632, Speaker A: All these users are likely to be vulnerable unless they only approve what they were required to. So this one, unfortunately I can't write live. I'm not that cool. So we are going to look at some code I already wrote in order to do this. The first thing that I'm doing here is I am calling the etherscan API. I would show you this but I don't want to give up my API key. We are calling list transactions for the Uniswap v three router to Etherscan and we're sending it off.
00:39:30.632 - 00:39:56.894, Speaker A: Once we send that off we are removing the first entry because it will be the contract creation and I didn't want to do that. I didn't want that transaction after that. We are set this to be our local node. Once again we are importing the RC 20 API for future calls. Now here's where things get a little bit tricky. We're going to make calls directly to get transaction receipt. And in order to make this call we need the transactions.
00:39:56.894 - 00:40:59.904, Speaker A: I didn't know of an easy way to get the transactions associated with a particular address, but etherscan has that indexed for us. So I use that and then told it to get the address of all transactions. Once we have the address, get all the transaction receipts. Once we have all the receipts we can then get the logs which has all the event data inside of it. Once we're looking at all the events, we want to add identify the transfer event because that is the transfer from call that we want to look at. In particular, we want to find all transactions that have the from of this to be the from of the transaction. So who sent this transaction initially to the from the event? This allows us to find all the users that call this directly who are vulnerable to this attack.
00:40:59.904 - 00:41:46.634, Speaker A: We can do this by looking at the token address, the from address and the to address of a particular event. With this we append this to a, to a list. We append the token address. So this, in our original exploit, this was the rapt ethan and then this was the sufu user. But because we want to find all users, we need to do this dynamically. Once we have a list of users and tokens that are potentially exploitable, we want to find the amount of exploitation that's possible or if they're exploitable at all. So this contract, or this contract, this function is iterating over that list we just made right here of all the users.
00:41:46.634 - 00:42:38.198, Speaker A: And it is going to create an ERC 20 contract for that particular token is then calling balance of for that user, then allowance for the user and the sushi router. Because we're abusing this trust. If both of these are greater than zero, it means that there are some funds that we can steal. Once we run this and there are funds to steal, it will append to our exploit data. And this will output to a JSON file which we will iterate over a little bit, but also prints out the token, the user, the balance, the allowance for MC. So to recap, this script is going over a list of transactions from the sushis router. Once it's done doing that, it will get the transaction receipt for all the transactions from the sushi router.
00:42:38.198 - 00:43:20.924, Speaker A: From the transaction receipt we're going to look over all of the events within those events. We're going to look for the transfer event and we can then find the token and the user that we're vulnerable to the attack because of that. Then we can find out how much we can actually steal from that user once we know that information. Great. Before we actually iterate over this. So we're going to modify our contract slightly, be a little bit more robust. And we actually need to reset our node because we stole some funds from it for the attacker contract.
00:43:20.924 - 00:43:54.804, Speaker A: We now don't just want a single victim in a single token. So we're going to set that ourselves. We're going to do address of token and address of victim. And we're going to set these dynamically now. So we're set token to be underscore token. We'll provide our script and we're going to set victim to be. So this is setting exploit settings.
00:43:54.804 - 00:44:40.794, Speaker A: Now when we call swap, it will use a proper victim and the proper token for this exploit. What does the script actually look like in action? You get logs for address and if this is not set up correctly, you can see that is actually calling get transaction receipt there. I just don't have any login for this. But eventually this will stop or start appearing with the values that we want to see, particularly the vulnerable users. There we go. So you can see tether, USD. There is a user with this amount of balance disallowance, which means we can only take this much funds.
00:44:40.794 - 00:45:02.114, Speaker A: We have uniswap, we can take a lot of funds from this one. We have a bunch of tether. This is about $38,000 if I recall. Sorry. 360 maybe. Wait, we have six, this is a six decimal coin. So yeah, $3,800.
00:45:02.114 - 00:45:36.414, Speaker A: But this wrapped ether user is still the most by far the Sifu user. But now we have a pretty good sized list of users that we know are exploitable, which is freaking awesome. So if we're going to perform this white hat hack, in retrospect, this is what we could do. Or if you're a bad guy and actually want to exploit this, which shame on you, don't do that. This is also what we could have done. Now like I said, there's probably a better way you could have done this. You may have been able to look for popular tokens who approved this because that also has an event, but I found this to be the easiest and most efficient way to do it.
00:45:36.414 - 00:46:42.054, Speaker A: So now when you go back to our sushiswap live contract and we need to rewrite this code, we're going to read from a file. So we are going to use this require statement here. And once we're in that require statement, we can now do we have that required? We can now read from a file and we're going to iterate over each one of these users. Now this is where this output is and we're going to iterate over all these users. Before I equals zero, I less than users length, I plus plus. And this attack logging code is something we actually want to put within this loop because we want to run this over and over again. A little thing here, make sure.
00:46:42.054 - 00:47:49.832, Speaker A: Now we need to get all of the users for that, all the information from the users. So we want the victim address. If we look at our file here, we can see that it's victim address, the token name for readability, victim token address, the victim balance, the victim allowance. So we'll log all that stuff just to, so we can see everything users of I and we're going to get the victim address. So we actually need to repeat this a few more times. We're going to do victim token, we're going to do token name, victim balance, and victim allowance. Now we have all these values just to see this attack in action.
00:47:49.832 - 00:48:43.302, Speaker A: We're going to print this out and we can do some fun string interpolation with this. And what do we want to see? We want to see the victim address. Great. We want to see the token name and we probably want to see the amount of funds we can actually steal. So we can do the same logic. So amount to steel equals. This is going to be the reason before balance is greater than use the allowance.
00:48:43.302 - 00:49:11.554, Speaker A: If the allowance is greater then use the balance. We always want to use the smaller of these two. So the amount to steal can then go here. Great. Now we can call this when you go back to our contract and see what we were using for this call. We use. So it's token then victim.
00:49:11.554 - 00:49:36.854, Speaker A: So victim, token and victim. Cool. Clarify. It's token, victim, victim. But I still think we have one other thing we want to do here. I want to see the victim balance afterwards. So just to like make sure we're stealing the right off, we are stealing some funds.
00:49:36.854 - 00:50:46.900, Speaker A: I'm just going to put this at the beginning just so it's even easier to see for us. We're getting the IRC 20 contract at the victim token address is what we're doing here. And then we can to get the new balance, we can do after equals wait, you can call token contract, I could type balance of and this is going to be the victim grass. And if we output that amount left and use amount after, we should see that coming. So hopefully I didn't mess up anything but that is highly unlikely. So we reset this. We are now iterating over a list of users that we ran a script to find.
00:50:46.900 - 00:51:19.674, Speaker A: We are going to specify a token. The token and the user that we want to exploit using this. Everything else is exactly the same as before. We create this loop with the users and we made this call dynamic. So if you call this one more time, we can start iterating through all the users. Assuming that my JavaScript works properly, which there's a good chance it doesn't, it actually worked. Nice.
00:51:19.674 - 00:51:40.474, Speaker A: So we can see here that this amount of funds we need to steal, but we don't have the balance there. That's my bad. So, but with this you can see the amount of funds to steal. And now they have zero left in their bank account. We stole all of their funds. In that case we stole a good amount of funds. In this case we stole all of their funds.
00:51:40.474 - 00:52:07.662, Speaker A: All of their funds. Anything time you see amount left, zero. We stole all of the funds. And this is a pretty horrific exploit when you think about that now. And what this actually could or what this could have been in this context, this is our Sifu user who we just stole about 1600 ETH. So cool. That is the exploits.
00:52:07.662 - 00:52:43.114, Speaker A: And this can keep running. If you're going to do this in the real world and do a white hat hack this way, you would probably use something like flashbots or obfuscate your contract in some way. But as trust pointed out in his tweets, the dark forest is real, man. It really is. Like, you got to think it's ten times more powerful than you probably think it is, because as soon as something's up, it's going to get. As soon as something goes public, everyone and their mom is going to try start exploiting this to steal money. It's really unfortunate.
00:52:43.114 - 00:53:23.802, Speaker A: From the live recording, I had some questions that might be worth going through. Not from the live recording. Yeah, yeah. From the live recording that we're not going to post. The hardest, the first one was what was the hardest part for me about this? And I think the hardest part for me was actually scripting the etherscan and ether PC. I'd never done that before, but I found the documentation for Etherscan and ETH RPC to actually be pretty good. So I think it was just a matter of how to use those APIs correctly and get the data back and then parsing it.
00:53:23.802 - 00:54:03.844, Speaker A: But it was also hard because I don't know what data is where. It took me some time to figure out that the events would only be in the transaction or the receipt of a given transaction. The other hard part was just understand the vulnerability I felt like once I understood this, it felt pretty straightforward. But not being the most familiar with Uniswap v three protocol, it was a little bit to grasp, but after I did some reading, everything made sense to me. So cool. That's what I got for you guys. This is within the open sense discord channel.
00:54:03.844 - 00:54:25.922, Speaker A: It's really awesome. I've jumped on calls a few times with people asking questions and it was amazing how responsive and awesome people were about stuff. So join that. Follow my blog. I write random stuff all the time. I have blog posts about blockchain security things, but also I had to scoreboard last year. That was pretty fun.
00:54:25.922 - 00:54:52.546, Speaker A: I have a resources page that I document all my notes on. Recently I've been reading there was an article released about different proxies. I wrote some notes on that, learned about urine finance hacking. So I have. I have a lot of notes here as well. My twitter is at Duflin five. I think this should do.
00:54:52.546 - 00:55:04.474, Speaker A: Flint five hacker handle strikeout. Yeah, feel free to reach out to anything. Thanks for the open test community for this opportunity to do this.
