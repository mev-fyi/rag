00:00:01.400 - 00:00:24.794, Speaker A: Yeah. So basically, give me, let me give, give you the story a bit. You know, usually people do bug hunting. It's, they do it, they focus on protocol and try to find bugs. Right. But this didn't happen for me. I never went through immunophi, never deliberately haunted bugs.
00:00:24.794 - 00:01:01.676, Speaker A: This was just like coincidence. And I consider myself lucky. And basically I think the takeaway here is that, you know, we have to, if you, if you learn new stuff, you work on new protocols, you will figure out new stuff. And basically the Uniswap X, they did something very similar that I had developed. Awesome for clients. So it's a really similar, almost exactly the same type of protocol.
00:01:01.780 - 00:01:04.864, Speaker B: Can you explain what is uniswap X?
00:01:05.364 - 00:02:08.220, Speaker A: So it's basically intense intent space protocol. What that means is that people make orders by gasless signatures. So they sign off chain and the signature basically says that, okay, I want to, I want 50 of token a, I have 100 token b that I will give you for that 50 token a. Okay, so that's the signature. And the idea is that the user just specifies what they want and what they want to give and they don't care about have that procured. Right. So they sign the signature and then there are off chain calculations that try to find the best route for that, for the first series of swaps to occur.
00:02:08.220 - 00:02:39.060, Speaker A: And those swaps are not, they don't care about the protocol, uh, as well. So it will go through in Swapx. But they can use any other protocol so they don't have to use just in swap. They can use, in swap they can use uh, they can use awesome balancer. Yeah. So they can like an aggregator. But the idea, like the main difference is that you just give a signature and then uh, you tell what you want.
00:02:39.060 - 00:03:15.166, Speaker A: Because in a traditional aggregator, like one inch, you just, you make a transaction that tells the exact path that the, the swaps should occur. But that's not the case in uniswap X. And the protocol that I have built with flood. So the flood is the protocol I built with flood team. And that's basically very similar. Yeah, so that's, that's, that's uniswap accents. The reason I was able to find it was because I developed something very similar.
00:03:15.166 - 00:03:25.638, Speaker A: And when I saw uniswap x, I checked it and realized they did the same mistake as me, basically.
00:03:25.806 - 00:03:33.834, Speaker B: That's really cool, man. And can you explain how permits, you, allow the signature process to happen?
00:03:35.054 - 00:03:35.742, Speaker A: Sorry.
00:03:35.878 - 00:03:40.430, Speaker B: Can you explain how. Permit you. Permit to. Yes, yes.
00:03:40.542 - 00:04:05.544, Speaker A: Oh yeah. Permit to. So normally when you are using a contract and you want a contract to spend your tokens. Right. Because let's get back to the initial example. You said I will give 100 token b and you will give me 50 token a. So the contract has to spend 100 token b on your behalf.
00:04:05.544 - 00:04:36.222, Speaker A: And that is traditionally done by approval. So ERC 20 standard has token approvals. You have to do, you have to approve that token. You have to approve the contract to spend that token amount. But that's not the permit tool. Tries to streamline that procedure. Yeah, bahurum is the, is the guy who actually found the bug.
00:04:36.318 - 00:04:37.598, Speaker B: I see on my.
00:04:37.726 - 00:04:49.070, Speaker A: Yeah, I. When I wrote it, the Bahrain found the bug and. But he, he found the bug in my course and then I used that and found the bug. A new softbank.
00:04:49.102 - 00:04:51.278, Speaker B: So amazing. Buddy credit.
00:04:51.326 - 00:04:54.338, Speaker A: I think the credit could go to Bahrain mostly.
00:04:54.446 - 00:05:08.174, Speaker B: Can we go through the attack? So the offer signs a flood order exchanging ether for die. Okay. The offer has also an open door on seaport. What does that mean, having an open.
00:05:09.154 - 00:05:26.694, Speaker A: Let's go to the. Let's go to the chat box at the end of the end of the blog post. So there's a. Like that. There is this, there's this Poc I wrote. So let's get it. Let's go to the beginning of the chat box.
00:05:26.694 - 00:05:53.276, Speaker A: So here by Fran, it's like a regular user. Opensea uses signature based orders as well. So you make an off chain signature. But what OpenSea doesn't do is that it doesn't allow you to use those tokens in other protocols. So let's say you want to give, you want to buy some NF. Sorry, you want to sell your NFT. That's NFT.
00:05:53.276 - 00:06:30.004, Speaker A: Let's say one babe, you sell that, but it's not used in any other protocol. And what happens is that the person filling that order has to send you what you want. So it happens inside C port. C port. So everything has to happen there within C port. It doesn't use any external protocols. So let's say the, the user created an order on openC port.
00:06:30.004 - 00:07:19.124, Speaker A: There's a signature, off chain signature being kept in the servers of OpenSeA. And then the user creates an order on Uniswap X. Now there is another signature on the Uniswap servers. And if someone has access to both of these signatures, they can fill these orders. But the problem arises when two of these orders have the same token requested. And what happens is that when you are filling the order, you can only fill, you can only fill the open sea order. You don't fill the Uniswap order, you just fill the open sea order.
00:07:19.124 - 00:07:33.698, Speaker A: And the balance that you have received from filling the open sea order will be reflected on the Uniswap X. So it will think that you have given the extra amount, but you haven't, you haven't given the full correct amount.
00:07:33.786 - 00:07:34.454, Speaker B: Wow.
00:07:35.074 - 00:07:37.258, Speaker A: Yeah, sure.
00:07:37.306 - 00:07:42.570, Speaker B: Can you show, can you send me the link to the fix? So we take a look at the code what was trying to fix.
00:07:42.602 - 00:07:50.694, Speaker A: It should be linked in the article. If you go a little bit up, down. No, here.
00:07:51.474 - 00:07:53.974, Speaker B: Call that Poc fixed the issue here.
00:07:54.874 - 00:07:57.214, Speaker A: Yeah, that the second one fixed issue.
00:07:57.874 - 00:08:46.484, Speaker B: Let's take a look at that. So let's read this through. So this commit fixes fundamental issue with expected balance slip balance check if the settlement balance checks for the settlement methodology, if a swapper creates an order when you swap X, and also an order with similar input output tokens on another protocol, they can fill the order during the reactor callback to satisfy the balance. To satisfy the balance checks without actually feeding the uniswap order x itself. This comment fixes the issue by switching back to an approved transfer model. So every order is transferred explicitly from the fuel content during fuel contract. During settlement.
00:08:46.484 - 00:09:07.090, Speaker B: To alleviate securities with being able to transfer from fuel contracts in the reactor, we add a new constraint. That message sender is always used as fuel contracts. This means all fuel contracts implementations must themselves call reactor execute called reactor go up.
00:09:07.282 - 00:09:24.778, Speaker A: Sorry. So did that paragraph, that's, that's a separate thing they have done. It wasn't necessary. Okay, basically, basically it requires that whoever filling the order is making the call to uniswap x. So it's like a circular whole chain.
00:09:24.866 - 00:09:25.458, Speaker B: Okay.
00:09:25.546 - 00:09:45.214, Speaker A: Like the order filler contract has to call in swap, extending swap x during the reactor. Callback calls that contract. Before that, you could directly call in Swapx instead of using another contract in between. This change they made wasn't necessary. I think.
00:09:46.274 - 00:09:47.974, Speaker B: Let's take a look here.
00:09:49.174 - 00:09:58.754, Speaker A: Yeah, so they, they made all these changes, change in one, one week or so. It was very fast. They did it all. I was impressed with that.
00:10:00.854 - 00:10:09.994, Speaker B: Execute bash with callback. What changed it here? Just the, just the printing.
00:10:10.854 - 00:10:11.754, Speaker A: Okay.
00:10:13.014 - 00:10:16.034, Speaker B: They changed a lot here, here's a callback.
00:10:20.394 - 00:11:23.654, Speaker A: But I can give you a takeaway from like why this pack happens, why basically it was like if someone is writing this quote, they would, it's not likely that they would write that they would introduce this bug, but the reason that I have introduced it and the reason the Uniswap X team introduced it is that, it's for gas savings. So basically it just takes all the token balances before the callback and checks it after. So this is, this saves more gas. But the normal way of doing it should be just using a transfer from, instead of waiting, waiting the fulfilling contract to send you the tokens, you just forcefully transfer from it.
00:11:24.994 - 00:11:44.834, Speaker B: Okay. Okay. Okay. But bro, this seems like a hard bug to spot. You know, it's kind of a signature replay attack, isn't it? A little bit. Because this is the problem, right? I'm using the same signature in two places.
00:11:46.934 - 00:12:03.618, Speaker A: No, you don't repeat the same signature. It's just that when you fill an order during the callback to the, you are filling an order on another protocol during the callback.
00:12:03.746 - 00:12:05.854, Speaker B: Okay. Okay.
00:12:06.474 - 00:12:44.174, Speaker A: Makes a call back to your contract that will manage all the swaps. So that's the by fulfiller contract. I mean that, I mean the contract that will do any arbitrary swaps. So in swap makes a call back to the contract and that fulfiller contract can do anything. So it can, it can go to uniswap, do this, do some swaps there, then go to balance or do some other swaps. So it can do anything to source, source items requested by the order creator. And then what? Uniswap X does this.
00:12:44.174 - 00:12:52.278, Speaker A: It checks the balances before and after they made a call to the, it may, it makes a call to the fulfiller contract.
00:12:52.366 - 00:12:53.022, Speaker B: I understand.
00:12:53.158 - 00:12:57.154, Speaker A: Okay. And by reactor callback. That's what they mean.
00:12:57.774 - 00:13:12.594, Speaker B: Really cool. Now you guys gotta have questions. Come on, everybody understood everything. Guys, help me here. Open your mics and start talking. Let me see here.
00:13:14.214 - 00:13:19.314, Speaker C: So what did you do when you found this out? Like how did you reach out to your SAP?
00:13:22.054 - 00:14:28.166, Speaker A: Yeah, uh, bug bounty page? Uh, they are not, they are not part of immunify. They are independent. So I uh, they request that you email the, email the finding. So uh, I basically wrote a protocod pocket and the instruct uses foundry. So it was easy to just write a coded POC and wrote few paragraphs of explanation and then just edit the POC. And like, I realized the issue when I just, when I just glanced at the code in swap xcode because I was already very into uh, developing something very similar. And I had, I went into the same pitfall, I made the same mistake and I just immediately realized from the design they made.
00:14:28.166 - 00:15:05.424, Speaker A: So I, yeah, they, I just immediately saw it. Yeah, they made the same mistake and uh, then, yeah, I, but I may, I wanted to make sure because I wasn't very familiar with the Uniswap X code itself, but just, just protocol design, like the design of that kind of an intent based protocol. I was familiar with that, but not the insolf x code itself. So it was easier for me to write a PoC and confirm the issue, then read the code and understand everything and confirm it that way.
00:15:05.924 - 00:15:07.784, Speaker B: That's really cool, buddy.
00:15:08.204 - 00:15:53.232, Speaker A: Yeah. I wrote a PoC sundit by email and, and received a reply in one day. And, you know, it goes to their support team. And I just, once I, once they received it, I sent another email. So they make sure that it's being taken seriously. And while being taken seriously, they basically, one day after they removed it from their website, the Uniswap extra Uniswap x toggle still stayed on their swap page. So, like, main uniswap update, uniswap.org.
00:15:53.232 - 00:16:21.404, Speaker A: So swap on the swap page, there was Uniswap xtoc that stayed there, but it wasn't doing anything they like. I understand why they did that because this is not something you want to disclose it, because this is not a upgradable protocol. So I assume they didn't share this with me, but I assume they waited for the signatures to expire just in case.
00:16:24.264 - 00:16:38.354, Speaker B: Amazing shank since you here, bro. You know, one, you are one of the few auditors that are really conceived. You know, you really have a unique way of viewing and auditing code. How long are you doing this?
00:16:40.014 - 00:16:47.862, Speaker A: So I was first in. I first. Did I start from the beginning?
00:16:47.958 - 00:16:50.314, Speaker B: Yeah, go. Go from the beginning, please.
00:16:50.814 - 00:17:25.992, Speaker A: Okay. So in the beginning, I was always had, like, this libertarian thought state that, you know, be your own bank, I guess. Don't leave my savings to other people under other people's control. So I was interested in bitcoin, but what really pushed me was the line going up, because it was, you know, it's not easy thing to just switch from. You're moving your savings from your bank account to bitcoin. Like, like, it's, uh, you have to do it consciously. You cannot just do it, uh, blindly.
00:17:25.992 - 00:18:10.428, Speaker A: You have to know how to manage keys and such. So, uh, it wasn't easy. I need some, I needed some motivation, and the line going up was a motivation for that. So I got into bitcoin, and then at the beginning of 2021, so January 2021, just at the beginning of the bull run, and then the line wasn't going up fast, so my, uh, my intentions started changing and I got into all these altcoins and such. I got really into avox ecosystem. So I started, yeah, DJ and Djan stuff, defi stuff. I didn't, I didn't, I wasn't into Ethereum, but in Avox there was always some fork from Ethereum coming every new week.
00:18:10.428 - 00:18:46.614, Speaker A: So every new week I was learning a new protocol as a user. Basic, like once it was landing, but like first it was unispop, b two, then it was landing. I was learning that as a user I started to get more into the background of how it all works because I want to make sure that it's, you know, it's actually decentralized and I'm not doing something I'm, I do not know. And it led into doing my own NFT project. Then I got into Pangolin as a solid developer.
00:18:48.934 - 00:18:53.274, Speaker B: Got really good, big. I mean I remember everybody talking about it back in the day.
00:18:53.734 - 00:19:29.270, Speaker A: Yeah, it was, it had like 500, no, I don't think it was half a billion, but was 200 million at some point I think. Why? Yeah, it's at the peak of Kabura but yeah. And then I got into more into security, did some coderina stuff, started reading, studying and yeah, I ended up here.
00:19:29.302 - 00:19:36.814, Speaker B: Now, but before, but before getting into web3 you were working as a developer, you were doing some other.
00:19:36.934 - 00:20:27.964, Speaker A: No, I was just like, I did some college like a three year diploma degree in civil engineering. So I didn't do programming, but my attention, it doesn't last more than one year. My interest, so at the first year of my, in my program I was, I was really interested in getting good grades and such, but at the second year my interest started getting into more into free and open source stuff. So I got nice, you know, using Linux and then writing scripts for everything, optimizing everything in my, in my daily usage. So I automated everything.
00:20:28.464 - 00:20:35.594, Speaker B: You guys make me feel like slug, like I slug every time. So you're telling me that you're only on development now for three years or something?
00:20:38.694 - 00:20:46.646, Speaker A: Solid development, yes. Let me see. Yeah, it's two years.
00:20:46.750 - 00:21:00.394, Speaker B: And how did you got a sense of security, how did you got your sense of security to increase and just do security, you gotta be safe, you know, I think you did so many protocols, I don't know if you read reports, what is your method of acquiring information?
00:21:01.734 - 00:21:35.694, Speaker A: I did so many developments, I think the whole thing is the best way to acquiring information. Reading is reading is very passive. If you can do it, if you can do it. For example, along with testing, let's say you are reading but you're also writing, testing and such, then that can work. Out. But I don't like writing test. I like, I prefer development stuff and you know, just maybe writing basic tests to see what I have written works.
00:21:35.694 - 00:22:09.584, Speaker A: But extensive testing, especially for something that I haven't written, for example, if it's a code I've written, I would, I could enjoy writing tests, but for others, people's codes, I wouldn't enjoy writing tests. So it's, I think the other thing is very passive and I don't think how much you can, you can really learn that way and you can learn a lot, but I don't think it can stuck with you that much. So I understand developing a lot, so.
00:22:09.624 - 00:22:31.764, Speaker B: That'S what I understand. And what about threat modeling? I mean, what is the usual mindset? You approach code, let's say you're looking at a function because recently we did this old lady audit together and you found some problems related to ZK sync and create zero in the sole lady code.
00:22:32.624 - 00:22:33.256, Speaker A: Yeah.
00:22:33.360 - 00:22:40.964, Speaker B: How did you approach, I mean, what's the least, you're taking these things, you have a list of bugs you look for. How does it look like?
00:22:41.784 - 00:23:23.706, Speaker A: Yes. So lady was one was fairly easy because it's a single contract, doesn't interact with anything. What's interesting with, with pre compilers is that it's not, when you're writing it in low level, you can see directly that it's a call to the precompiled. So it's, it was identity pre compile installated. And I think it's, it's zero x four. Like the address of the profile is zero x four. So you see it directly and you know it's not, or part of EVM.
00:23:23.706 - 00:24:25.710, Speaker A: I think like I don't know how the standard is defined in that regard. Is it or part of EVM or not, but like it's because if you're writing solidity, then the compiler will do the, do these low level stuff for you. And if you are, let's say compiling for ZKsync, they have their separate compiler, we have to use that. So you wouldn't have this problem, it would just give you a warning at the very least. But when you're writing a new, if when you're writing an assembly, you are making a call to the, just an address, pre compiled is just an address and, and you might just deploy that to Zksync as well. There can be a problem or any other, any other chain that doesn't have the, that has to compile. Yeah.
00:24:25.742 - 00:24:44.294, Speaker C: So since you are not fully familiar with Uniswap X and you did not go through the whole code. How did you find out that the similar bug that you found elsewhere was also in Uniswap X? Did you like use a tool to like look it up or how did that work?
00:24:44.674 - 00:25:29.418, Speaker A: Well, I just checked. How did they handle settlement? That's the only thing I checked because the flood team I was working with, they wanted me to check how to integrate in sub x as well. So to see how can I integrate it, I have to see how they handle the settlement. And basically they were not doing transfer from. So if you're not doing transfer from, I saw that they were checking balances. So it's easy to see that they are looking at the balance of the order creator. So the order creator checks the balance before making a callback.
00:25:29.418 - 00:26:08.936, Speaker A: Within Swapx, before making callback checks the balance soft order creator and checks adapter. It was like immediately, this is the same design I had come up with and it has to have the same issue. Like, because I had thought about it before, you cannot do it this way with that issue. Like if you use this design, you will have that issue 100%. There isn't any, any way you can get rid of that issue while keeping this design. So I saw that design, they must have that issue. But maybe there's something I don't know.
00:26:08.936 - 00:26:17.684, Speaker A: So I just wrote the USC and yeah, they, they had the same problem. Gotcha.
00:26:24.344 - 00:26:43.984, Speaker B: I'm gonna stop taking your time. Thank you so much, bro, for coming, for explaining this to us. So you guys know Shung is very respected, very renowned auditor, someone that you can definitely learn from. So be sure to follow him on Twitter. Okay? Be sure to follow him on Twitter. Shun, you have any closing thoughts? Anything you would like to say?
00:26:44.604 - 00:26:54.204, Speaker A: Yeah, thanks. Thanks for having me. And I hope in one listening I've learned something or. Yeah, I hope this was helpful.
00:26:54.324 - 00:27:00.864, Speaker B: Yeah, it was very helpful. I mean, I'm going through this video back to take a look and really understand that bug. I think it was really important.
00:27:03.064 - 00:27:03.424, Speaker A: And.
00:27:03.464 - 00:27:08.256, Speaker B: Yes, thank you so much, guys, and talk to you later. Okay, thank you. Bye.
