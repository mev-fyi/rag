00:00:00.320 - 00:00:07.054, Speaker A: About who I am, what I do, why the paradigm CTF is, if you don't know, and I'll explain it briefly.
00:00:07.174 - 00:00:09.390, Speaker B: And then the solutions to this, these.
00:00:09.462 - 00:00:11.934, Speaker A: Six challenges which I managed to solve.
00:00:11.974 - 00:00:16.110, Speaker B: In a day and a half. Actually, I will say I'll tell you.
00:00:16.142 - 00:00:23.354, Speaker A: Why the last half of the day wasn't really that productive for me. And then, well, some closing remarks.
00:00:23.814 - 00:00:25.350, Speaker B: There's a lot of space for questions.
00:00:25.382 - 00:00:31.224, Speaker A: If anybody has them. Do feel free to interrupt me at any time, either for the chat or.
00:00:31.264 - 00:00:33.968, Speaker B: Miss, just jump in, throw a question.
00:00:34.016 - 00:00:35.644, Speaker A: I'm more than glad to take them.
00:00:36.224 - 00:00:39.408, Speaker B: And yeah, so who am I?
00:00:39.456 - 00:00:54.884, Speaker A: I'm LJ Lucas, if you want. I'm a student at a university. I'm doing my master's thesis currently, and I'm working on some stuff in parallel. Mainly I'm doing bug hunting since the beginning of this year.
00:00:55.394 - 00:01:01.842, Speaker B: Seriously, as a career. Before that I would just do like some CTF challenges, find some bugs here.
00:01:01.858 - 00:01:03.370, Speaker A: And there while reading some random code.
00:01:03.402 - 00:01:13.930, Speaker B: But nothing that was like I was making a living off of. Apart from that, I'm a CTO at.
00:01:13.962 - 00:01:16.810, Speaker A: A company in Uruguay, which I've co.
00:01:16.842 - 00:01:22.622, Speaker B: Founded with some funders. And yeah, other than that, in the.
00:01:22.638 - 00:01:24.790, Speaker A: Remaining time I have, which isn't that.
00:01:24.822 - 00:01:30.638, Speaker B: Much, but it's enough for like a Sunday afternoon. I do some random contributions to projects.
00:01:30.686 - 00:01:35.190, Speaker A: That I find cool. Mostly lately it's been rust based projects.
00:01:35.222 - 00:01:39.198, Speaker B: So mainly foundry, half compiler, and, I.
00:01:39.206 - 00:01:40.790, Speaker A: Don'T know, some random stuff that comes.
00:01:40.822 - 00:01:47.866, Speaker B: To mind whenever I feel bored from what I do generally. Yeah, some small background.
00:01:47.930 - 00:01:49.866, Speaker A: I started off in crypto in 2017.
00:01:50.050 - 00:01:51.570, Speaker B: When I found out about bitcoin and.
00:01:51.602 - 00:02:03.346, Speaker A: Company and like all the other coin named coins, excuse me for the wordplay, by doing essentially arbitrage bots with my.
00:02:03.370 - 00:02:06.954, Speaker B: Father, we noticed that there were a.
00:02:06.954 - 00:02:11.174, Speaker A: Lot of inconsistencies, a lot of beneficiaries in the market at that time. There still are, actually, but.
00:02:11.614 - 00:02:19.870, Speaker B: And yeah, well, we built some arbitrage bots. We taught ourselves coding through that, and that lasted a couple of years before.
00:02:19.982 - 00:02:22.870, Speaker A: More sophisticated people, people that actually knew.
00:02:23.022 - 00:02:24.154, Speaker B: What they were doing.
00:02:25.134 - 00:02:28.954, Speaker A: They basically ate our lunch and destroyed our poor bots.
00:02:29.734 - 00:02:33.518, Speaker B: From that, I went to university for a couple of years.
00:02:33.526 - 00:02:40.276, Speaker A: I didn't really do much in crypto, and after that, when I graduated from my first degree from my bachelor's, I.
00:02:40.300 - 00:02:45.076, Speaker B: Joined Nethermind as a blockchain engineer. So I was on the road to.
00:02:45.100 - 00:02:52.664, Speaker A: Becoming a core dev for their client, which now you would call execution client at the time was just a client.
00:02:53.124 - 00:02:55.068, Speaker B: And, yeah, that lasted for a summer.
00:02:55.116 - 00:03:01.916, Speaker A: And after that I went into my masters, during which the last bull run happened. So I did some more mev on.
00:03:01.940 - 00:03:09.624, Speaker B: My side, which was still arbs and then some long tail stuff. And, yeah, I got part of that.
00:03:09.784 - 00:03:12.232, Speaker A: At the end of 2022, more or.
00:03:12.248 - 00:03:23.248, Speaker B: Less like a year ago, because it's just so lonely. I didn't really like being so lonely and in such a psyops filled environment.
00:03:23.376 - 00:03:27.360, Speaker A: Which is Mev searching. And I left for security, which is.
00:03:27.392 - 00:03:29.624, Speaker B: More community aligned, I would say.
00:03:29.704 - 00:03:31.800, Speaker A: There's a lot of incentives to help.
00:03:31.832 - 00:03:42.264, Speaker B: Each other out and push the security space forward, right. And, yeah, so that's me. What is the paradigm.
00:03:44.804 - 00:03:45.316, Speaker A: If you guys.
00:03:45.340 - 00:03:49.844, Speaker B: Want to know real quick, it's a set of job challenges.
00:03:49.884 - 00:03:51.916, Speaker A: You have 48 hours to solve them.
00:03:52.100 - 00:03:54.492, Speaker B: Each challenge grants you points based on.
00:03:54.508 - 00:04:01.594, Speaker A: The number of other teams that have solved the challenge. The idea is to solve as many challenges, get the most points, win.
00:04:01.714 - 00:04:06.450, Speaker B: What are some caveats to the paradigm? CTF, the head of the whole thing.
00:04:06.482 - 00:04:10.402, Speaker A: The mastermind behind it is Sam Cz son, which I hope you know of.
00:04:10.458 - 00:04:13.922, Speaker B: If not, look him up, which is a madman.
00:04:13.978 - 00:04:19.162, Speaker A: He proposes the hardest challenges that are in web3, I would say up to this date.
00:04:19.338 - 00:04:27.210, Speaker B: And, yeah, this year I decided to go full masochist on myself because I.
00:04:27.242 - 00:04:38.574, Speaker A: Booked myself for like a hackathon from it was like Tuesday to Friday on the week that the CTF started. That lasted for 72 hours. I slept nothing those days.
00:04:38.694 - 00:04:40.742, Speaker B: We ended up coming in third for.
00:04:40.758 - 00:04:46.274, Speaker A: That hackathon out of like 15 teams and the same day that finished the CTF started.
00:04:46.654 - 00:04:49.974, Speaker B: So, yeah, I mean, going alone into.
00:04:50.014 - 00:04:54.102, Speaker A: The hardest set of challenges in web3 coming from an average of four.
00:04:54.158 - 00:04:58.540, Speaker B: To 5 hours sleep for three nights before.
00:04:58.612 - 00:05:00.812, Speaker A: It wasn't really the best setup for me.
00:05:00.988 - 00:05:03.452, Speaker B: But, yeah, I mean, when you have.
00:05:03.468 - 00:05:04.668, Speaker A: To do something, you have to do something.
00:05:04.716 - 00:05:06.204, Speaker B: So that's what.
00:05:06.244 - 00:05:10.900, Speaker A: That's what. That was my setup for this year. I don't think I will replicate it next year.
00:05:10.932 - 00:05:20.196, Speaker B: Maybe I'll take a bit. A bit more chill and maybe find a team. But, yeah, that's basically it. So if there are no questions, if.
00:05:20.220 - 00:05:22.716, Speaker A: Nobody has any doubts or preliminary questions.
00:05:22.740 - 00:05:25.494, Speaker B: To ask, I'll jump into the first.
00:05:25.534 - 00:05:27.114, Speaker A: Problem, which is hello, world.
00:05:28.494 - 00:05:39.030, Speaker B: Okay, so. No, no. Yeah.
00:05:39.062 - 00:05:42.674, Speaker A: Sorry, I said I was jumping into the first problem. Actually, I have this slide yet.
00:05:43.254 - 00:05:45.038, Speaker B: This is just to show my placement.
00:05:45.086 - 00:05:47.790, Speaker A: In the CTF this year. You can verify this on the.
00:05:47.902 - 00:05:57.224, Speaker B: On the website. But, yeah, 37th out of 220 ish teams which manage at least one solve.
00:05:58.044 - 00:06:02.108, Speaker A: The total should be like 800, but there's like 600 teams which have zero.
00:06:02.156 - 00:06:07.356, Speaker B: Points, so I'm not counting that. I'm pretty proud of this result, though.
00:06:07.540 - 00:06:12.984, Speaker A: I think I could have done better. And I will explain to you why at the end of this talk, but.
00:06:13.684 - 00:06:17.784, Speaker B: Okay, so first problem was hello world.
00:06:18.904 - 00:06:27.160, Speaker A: The name is pretty self explanatory. If you've done anything related to programming, it's the basics, let's say, for the CTF.
00:06:27.352 - 00:06:30.912, Speaker B: And the whole idea is to essentially.
00:06:31.088 - 00:06:35.244, Speaker A: Make sure that the targets balance increases of a certain prefix amount.
00:06:38.144 - 00:06:42.124, Speaker B: There's two ways we could tackle this, and this is how I write it down.
00:06:42.984 - 00:06:51.144, Speaker A: You could either grab the target's address, go read the code, find out that it's the contract that hosts all the beacon chain deposits.
00:06:52.044 - 00:06:54.276, Speaker B: Understand that there's no fallback, there's no.
00:06:54.300 - 00:06:57.748, Speaker A: Way to like straight up send it ETH. You'd have to go through a method.
00:06:57.796 - 00:07:03.004, Speaker B: You have to craft a valid beacon deposit. Or you can just go full brute.
00:07:03.044 - 00:07:08.504, Speaker A: Force and say, okay, I will create a contract self destructed and push force the ether into the contract.
00:07:09.284 - 00:07:11.636, Speaker B: And of course, I mean, I hope.
00:07:11.660 - 00:07:14.184, Speaker A: You can guess which is the fastest.
00:07:15.204 - 00:07:23.988, Speaker B: Of the two to get that flag. And of course you just write a simple contract which self destructs if you.
00:07:23.996 - 00:07:27.236, Speaker A: Don'T know what self destruct does. It's an opcode that essentially deletes the.
00:07:27.260 - 00:07:29.420, Speaker B: Contract from the Ethereum storage.
00:07:29.532 - 00:07:30.740, Speaker A: And all of the ETH that sells.
00:07:30.772 - 00:07:32.700, Speaker B: From the account is pushed.
00:07:32.732 - 00:07:36.756, Speaker A: It's forced into a receiving target, which you can specify.
00:07:36.820 - 00:07:43.888, Speaker B: So here on the screen you can see my three line exploit contract and.
00:07:43.936 - 00:07:49.072, Speaker A: How I deployed it using the foundry test tool suite.
00:07:49.128 - 00:07:50.004, Speaker B: Excuse me.
00:07:51.664 - 00:07:53.440, Speaker A: For some reason I tried doing this.
00:07:53.472 - 00:08:00.416, Speaker B: With a forged script, but I don't know why. My fort strips were compiling with some.
00:08:00.480 - 00:08:02.184, Speaker A: Weird exception, and it was finding an.
00:08:02.224 - 00:08:09.584, Speaker B: I character in the bytecode, which I is not a hex value.
00:08:10.244 - 00:08:16.504, Speaker A: This shouldn't be in bytecode. I just found this workaround of using forge create, deploying the forwarder.
00:08:20.564 - 00:08:21.108, Speaker B: And then.
00:08:21.156 - 00:08:25.344, Speaker A: Doing just a cast send to trigger the push method. Sure.
00:08:25.644 - 00:08:26.624, Speaker B: Let's hear it.
00:08:28.284 - 00:08:31.064, Speaker C: So, can you show us the hello word contract?
00:08:32.424 - 00:08:39.924, Speaker B: That forwarder one? Yeah. No, I mean, there's no real contract, there's just a challenge.
00:08:40.384 - 00:08:41.960, Speaker A: And this is the real contract.
00:08:42.032 - 00:08:44.168, Speaker C: Okay. You need to take the altar of the address.
00:08:44.256 - 00:08:44.960, Speaker A: Yeah.
00:08:45.152 - 00:08:47.924, Speaker B: You just grab this to 190 a.
00:08:48.224 - 00:08:51.816, Speaker A: And the idea is that is solved has returned. True.
00:08:51.920 - 00:09:00.326, Speaker B: So when the challenge is constructed, you cache targets, balance, and then somehow this.
00:09:00.350 - 00:09:01.174, Speaker A: Has to hold true.
00:09:01.254 - 00:09:05.750, Speaker B: So you have to increase the balance of this address target. Really cool.
00:09:05.822 - 00:09:07.342, Speaker A: And how you do that is essentially.
00:09:07.398 - 00:09:12.582, Speaker B: You just send 14 ETH through a self destruct and you get the flag.
00:09:12.718 - 00:09:15.354, Speaker C: If you try to send very straight. It won't work.
00:09:17.374 - 00:09:20.990, Speaker B: No, it won't. Because if you look up the code.
00:09:21.022 - 00:09:23.154, Speaker A: For this address, you can just Google.
00:09:23.554 - 00:09:28.882, Speaker B: Um, beacon chain deposit contract. Etherscan will pop up.
00:09:28.938 - 00:09:36.466, Speaker A: You will, you could go to the code and then you will see that it has no payable fallback, it has no payable receive function.
00:09:36.650 - 00:09:44.722, Speaker B: So straight ETH transfers revert. And the only payable method is a deposit method. It has. And well, for that, you have to.
00:09:44.738 - 00:09:48.134, Speaker A: Craft a valid signature, you have to graph a valid deposit.
00:09:48.434 - 00:09:50.472, Speaker B: And that's a lot of work.
00:09:50.528 - 00:09:54.752, Speaker A: So the easiest thing is to just force the ether into the contract and.
00:09:54.768 - 00:09:55.644, Speaker B: Call it a day.
00:09:57.864 - 00:09:58.696, Speaker A: Yeah.
00:09:58.880 - 00:10:18.676, Speaker B: Are we good to go on the next one? Okay, so black sheep. Black sheep is a huff based challenge. The idea is that you have a simple bank contract which holds some ether and it is written in huff.
00:10:18.820 - 00:10:22.744, Speaker A: And the whole idea of the challenge is empty the bank.
00:10:23.364 - 00:10:41.468, Speaker B: It's pretty straightforward. So I don't present the whole code for the, for the simple bank, but I'll just give you like the main points for it. The challenge itself may be like one.
00:10:41.476 - 00:10:42.820, Speaker A: Of the easiest ones because it has.
00:10:42.852 - 00:11:00.044, Speaker B: One of the most solves, although it does require some, I would say, intermediate level knowledge. It's not advanced, it's not basic. So you have to understand how precompiles are called at a very low level. So at like the opcode level, you.
00:11:00.044 - 00:11:03.244, Speaker A: Have to understand what the fuck an ACDSA signature is.
00:11:03.404 - 00:11:05.916, Speaker B: You have to understand and be able.
00:11:05.940 - 00:11:09.228, Speaker A: To read huff code, because simple banking is huff.
00:11:09.396 - 00:11:11.356, Speaker B: And then you have to be able.
00:11:11.380 - 00:11:13.964, Speaker A: To put all of that together and actually break the bank.
00:11:14.084 - 00:11:14.340, Speaker B: Right.
00:11:14.372 - 00:11:15.824, Speaker A: You have to run with the money.
00:11:16.724 - 00:11:27.364, Speaker B: So the challenge is presented in a like 80 line huff contract, for which I have presented here the main entry.
00:11:27.404 - 00:11:31.580, Speaker A: Point, which is essentially this is where code starts executing in huff contracts, where.
00:11:31.612 - 00:11:33.824, Speaker B: The main macro is defined.
00:11:34.524 - 00:11:36.524, Speaker A: And all it does is essentially it.
00:11:36.684 - 00:11:47.692, Speaker B: Has two methods, which are deposit method, which is just a fallback, and a withdraw method. So if we want to break the.
00:11:47.708 - 00:11:53.908, Speaker A: Bank, the first thing we look at is the withdraw method, of course. And we notice that there are some.
00:11:53.996 - 00:11:59.504, Speaker B: Kind of funky looking macros, namely check value and checksig.
00:12:01.444 - 00:12:05.004, Speaker A: Let's start from the last one, and let's work backwards from the exploit.
00:12:05.544 - 00:12:08.304, Speaker B: So reading through the contract, you will.
00:12:08.344 - 00:12:11.576, Speaker A: Find that a checksig macro, which is.
00:12:11.600 - 00:12:15.640, Speaker B: Responsible for receiving four arguments and checking.
00:12:15.792 - 00:12:19.624, Speaker A: That those four arguments actually form a.
00:12:19.784 - 00:12:31.628, Speaker B: Valid ECDSA signature are actually valid. And if that is so, it will push a true value, a true flag, to the stack, which will then signal.
00:12:31.676 - 00:12:35.636, Speaker A: To the withdrawal macro that effectively the.
00:12:35.660 - 00:12:40.104, Speaker B: Sender is authorized to withdraw all of the funds from the bank.
00:12:40.444 - 00:12:43.396, Speaker A: And there's a pretty weird situation reading.
00:12:43.420 - 00:12:54.184, Speaker B: Through the code in which there may not be a flag push to the stack to signal that effectively this caller is authorized.
00:12:54.604 - 00:12:59.730, Speaker A: So we have what's called an imbalance stack at the end of this branch.
00:12:59.842 - 00:13:01.294, Speaker B: Of execution of the contract.
00:13:02.194 - 00:13:05.810, Speaker A: So one immediately thinks, oh, if a.
00:13:05.842 - 00:13:10.842, Speaker B: Value is missing, if no push is expected to be done, then what is.
00:13:10.858 - 00:13:13.082, Speaker A: On the stack immediately after that value?
00:13:13.178 - 00:13:34.590, Speaker B: So what will be used as the flag? And it turns out that it's the flag which a call done within the check value macro returns. So within the check value, all the contract does is it checks that it's been transferred 16 or less way or.
00:13:34.662 - 00:13:37.766, Speaker A: Less than 16 way in the withdrawal method.
00:13:37.910 - 00:13:42.494, Speaker B: And if that is so, it will just grab the number of way sent.
00:13:42.534 - 00:13:44.062, Speaker A: To it, multiply it by two, and.
00:13:44.078 - 00:13:57.178, Speaker B: Send it back to the caller. The boolean flag returned by this low level call is what ultimately is used to check that the sender is authorized.
00:13:57.226 - 00:13:59.370, Speaker A: To withdraw the funds from the bank.
00:13:59.562 - 00:14:08.442, Speaker B: In the case in which that famous branch with no push, the stack happens. That's a lot of words.
00:14:08.538 - 00:14:11.018, Speaker A: It's kind of complicated. I can explain it again if you.
00:14:11.026 - 00:14:14.306, Speaker B: Guys want to, but essentially what the.
00:14:14.330 - 00:14:16.978, Speaker A: Whole idea behind it is. Okay, so I know that check value.
00:14:17.026 - 00:14:25.436, Speaker B: Will send value to me, and I will have to receive a transfer, and I will have to fail that in.
00:14:25.460 - 00:14:31.424, Speaker A: Order for me to not be considered an unauthorized actor.
00:14:32.164 - 00:14:47.368, Speaker B: So if I trigger the check value macro and I revert the internal transfer, that will grant me access to withdraw all of the funds, essentially. So the whole idea, and here you.
00:14:47.376 - 00:14:49.284, Speaker A: Can see the exploit, is to.
00:14:51.064 - 00:14:59.496, Speaker B: The bank is instantiated, it already has funds within, and we just create a contract which implements a receive function which will.
00:14:59.520 - 00:15:03.004, Speaker A: Revert if it receives, if it receives zero value.
00:15:04.464 - 00:15:11.944, Speaker B: So we then grab the bank and call withdraw on it. We send an invalid ECDSA signature.
00:15:15.444 - 00:15:20.924, Speaker A: So that we can trigger the branch of the checksick macro in which no push happens.
00:15:21.044 - 00:15:32.772, Speaker B: And then we send zero ether with the withdraw method. This way, when we are transferred back two times the amount of ETH we transfer to the withdraw method, it will.
00:15:32.788 - 00:15:34.044, Speaker A: Be zero, and we will be able.
00:15:34.084 - 00:15:43.760, Speaker B: To recognize that edge case. So we will call withdraw with zero way, the bank will transfer back two.
00:15:43.792 - 00:15:45.164, Speaker A: Times zero which is zero.
00:15:46.024 - 00:15:52.384, Speaker B: We will revert that internal transfer. The check Sig will try to verify.
00:15:52.464 - 00:15:54.200, Speaker A: The signature, which is invalid.
00:15:54.352 - 00:16:14.664, Speaker B: Being the signature invalid, it will not push a flag, the false flag that we have provided before by reverting the execution of the internal call. And as a result, we will receive the whole balance of the bank, essentially.
00:16:19.284 - 00:16:23.836, Speaker A: Similarly to the exploit. Before, I didn't do this with a forged script.
00:16:24.020 - 00:16:36.284, Speaker B: Rather I just left it up to two commands from the forge suite to create the contract and then trigger the call. Any questions?
00:16:43.944 - 00:16:51.772, Speaker A: Okay. Okay, cool. As a final remark, I realized that.
00:16:51.968 - 00:16:53.812, Speaker B: The explanation has been pretty fast, and.
00:16:53.828 - 00:16:59.324, Speaker A: It'S a pretty complicated thing to think about without seeing the code. If you ever want to run this.
00:16:59.364 - 00:17:10.812, Speaker B: Back and try to find the exploit yourself, grab the huff contract and start commenting to the right of the code, the whole stack. This is a process that is always.
00:17:10.868 - 00:17:13.148, Speaker A: Done when you're writing huff. You have to keep track of the.
00:17:13.156 - 00:17:21.501, Speaker B: Stack and how you manage it. If you do that, you will eventually see that there's a push missing and you will say, oh, what's used?
00:17:21.557 - 00:17:23.589, Speaker A: Instead of the value that should be pushed.
00:17:23.741 - 00:17:27.301, Speaker B: And then you will get to the exploit. Yeah, I guess this challenge is about.
00:17:27.357 - 00:17:32.165, Speaker C: Storing, branching and huff itself. So no obvious paths.
00:17:32.189 - 00:17:33.953, Speaker A: Yeah, it's a perfect excuse.
00:17:34.853 - 00:17:37.141, Speaker B: It's a perfect excuse to get into huff.
00:17:37.317 - 00:17:41.869, Speaker A: If you haven't yet, definitely do, because it will teach you a lot about.
00:17:42.021 - 00:17:44.333, Speaker B: The EVM and about solidity as well.
00:17:44.413 - 00:17:45.701, Speaker A: Even if you're not, you won't be.
00:17:45.717 - 00:17:56.444, Speaker B: Doing any solidity, but very, very, very highly recommended. Okay, on to the next 1100%.
00:17:57.864 - 00:18:01.368, Speaker A: This challenge provides two contracts, two main contracts.
00:18:01.416 - 00:18:04.136, Speaker B: The split contract that enables users to.
00:18:04.160 - 00:18:11.192, Speaker A: Create what the challenge calls split wallets. And these split wallets basically enable specified.
00:18:11.248 - 00:18:17.088, Speaker B: Addresses to receive the wallet's balance divided.
00:18:17.136 - 00:18:20.072, Speaker A: By a ratio that has been specified at deployment.
00:18:20.208 - 00:19:01.256, Speaker B: So you could imagine this as a multisig in which we already define how the balance of the contract will be will be divided between signers of this quote unquote multisig. The objective of the challenge is to drain the balance of a split wallet to which we have no connection to. So you can imagine that Alice and Bob have their own split wallets and we just have to drain it. Just take all of their ETH and run with the money. I realize I don't have the challenge here, but trust me on that.
00:19:01.400 - 00:19:04.364, Speaker A: There's two key points to the whole.
00:19:05.164 - 00:19:08.628, Speaker B: To the whole challenge. And the thing is that the split.
00:19:08.676 - 00:19:13.732, Speaker A: Wallet will receive some parameter meters. Create the split, sorry, split contract will.
00:19:13.748 - 00:19:16.492, Speaker B: Receive some parameters create a split wallet.
00:19:16.548 - 00:19:23.624, Speaker A: And then it will essentially leave the wallet there. Anybody can then independently deposit funds to the split wallet.
00:19:23.924 - 00:19:39.224, Speaker B: And then once you're done with the wallet, anybody can come and call distributed in the split contract, and that will essentially pull all funds from the split wallet, leave it there, and then within.
00:19:39.264 - 00:19:41.924, Speaker A: The split contract, it will assign balances.
00:19:42.384 - 00:19:56.128, Speaker B: In an internal accounting system to the beneficiaries. So the whole center of this is a split contract. Split wallet is just a stupid contract that receives ether and tokens, and then.
00:19:56.256 - 00:19:58.560, Speaker A: The split contract can pull those tokens from it.
00:19:58.632 - 00:20:10.000, Speaker B: So let's focus on the split, right? And split has a very curious way of understanding. If you're providing a wallet that exists, that exists.
00:20:10.072 - 00:20:11.600, Speaker A: If you're trying to distribute funds that.
00:20:11.632 - 00:20:23.180, Speaker B: Actually have been already allocated to a wallet that split knows of, that it has created, and it does so by checking a hash of some data.
00:20:23.332 - 00:20:25.588, Speaker A: The data is the accounts which are.
00:20:25.596 - 00:20:29.620, Speaker B: The beneficiaries of the, of the split wallet.
00:20:29.772 - 00:20:32.332, Speaker A: The percentages to which the values are.
00:20:32.348 - 00:20:41.524, Speaker B: Divided, which can be 30%, 10%, whatever. These are denominated in six decimal positions, and then the relayer fee.
00:20:41.604 - 00:20:44.916, Speaker A: The relayer fee we will not consider because it's always zero in the challenge.
00:20:45.020 - 00:20:48.180, Speaker B: So don't care about that. But if you're looking at this code.
00:20:48.212 - 00:20:50.902, Speaker A: I hope you've kind of said, oh.
00:20:50.958 - 00:20:55.790, Speaker B: This is, this isn't right. I've kind of said this to you.
00:20:55.822 - 00:20:57.942, Speaker A: Because I said, it's a huge cold smell.
00:20:58.078 - 00:21:09.766, Speaker B: But whenever you see an API encode pact and its arguments are of dynamic size, and these arguments are close to each other, then you know there's an.
00:21:09.790 - 00:21:13.470, Speaker A: Issue, then you'll immediately think, okay, how can I break, how can I use.
00:21:13.502 - 00:21:17.084, Speaker B: This to break other stuff? And the reason to this is because.
00:21:17.664 - 00:21:21.360, Speaker A: Encode packing is ambiguous with dynamic science.
00:21:21.512 - 00:21:25.400, Speaker B: Data, which are string bytes, dynamic arrays.
00:21:25.432 - 00:21:28.416, Speaker A: Of address, dynamic arrays of unit 32s.
00:21:28.560 - 00:21:51.762, Speaker B: Which is essentially what we have here, right? And knowing that the encoding is ambiguous, then what is its hash? Can we mess with the hash? And the answer is yes, because given that the encode pact returns the same thing for these two examples that I present below, which are addresses that have.
00:21:51.818 - 00:21:54.866, Speaker A: Addresses a, address a, address b, and.
00:21:54.890 - 00:21:57.850, Speaker B: Unit one two, and then an array.
00:21:57.882 - 00:22:00.694, Speaker A: That just has address a and an array that has the rest data.
00:22:01.234 - 00:22:07.802, Speaker B: When you pack those together, you get the same array, you always get a, b, one and two, and the hash.
00:22:07.818 - 00:22:09.814, Speaker A: Of the same data is the same hash.
00:22:10.274 - 00:22:28.130, Speaker B: Therefore, we can mess with the beneficiaries and their percentage to be distributed within the split contract. And how do we use this? Well, we need to find a way.
00:22:28.162 - 00:22:30.654, Speaker A: To essentially pull funds from the victim.
00:22:31.274 - 00:22:37.380, Speaker B: Try to get a huge balance in the split, and then withdraw what, what funds we need. And how.
00:22:37.532 - 00:22:42.784, Speaker A: Here is the step by step exploit that I've used in my, my solution.
00:22:43.244 - 00:22:46.356, Speaker B: To which I call distribute on the split wallet.
00:22:46.460 - 00:22:47.284, Speaker A: Anybody can do this.
00:22:47.324 - 00:22:50.116, Speaker B: It's open, essentially, that pulls the funds.
00:22:50.140 - 00:22:54.036, Speaker A: From the wall, from the victim wallet into split, and it allocates, says, okay.
00:22:54.060 - 00:23:00.772, Speaker B: Alice has, I don't know, one ETH, Bob has one ETH. They can claim it whenever they want. It does not send it.
00:23:00.788 - 00:23:02.304, Speaker A: It just holds it in escrow.
00:23:03.124 - 00:23:05.084, Speaker B: And once the funds are pulled, then.
00:23:05.164 - 00:23:07.756, Speaker A: I create my own Trojan split wallet.
00:23:07.900 - 00:23:16.984, Speaker B: To which I give two beneficiaries and two percentages. So the first beneficiary is myself. The second beneficiary is this weird number.
00:23:17.724 - 00:23:23.784, Speaker A: Address two to the 32 minus one, which is the maximum number that a UN 32 can hold.
00:23:25.404 - 00:23:28.412, Speaker B: And then the percentages are just five and five.
00:23:28.468 - 00:23:30.104, Speaker A: So 50% and 50%.
00:23:30.514 - 00:23:45.914, Speaker B: And why would I put that second beneficiary there? What point does that have? And the whole idea is to exploit that ambiguous packed encoding that I showed you before. Right?
00:23:46.034 - 00:23:47.522, Speaker A: So when I go to distribute the.
00:23:47.538 - 00:24:00.194, Speaker B: Split, I can provide just myself as the beneficiary and provide two to the 32 minus one and 50% and 50% as the splits.
00:24:01.614 - 00:24:05.314, Speaker A: The split percentages will not be validated to sum to one.
00:24:06.094 - 00:24:09.950, Speaker B: And what essentially split distribute will do.
00:24:10.102 - 00:24:18.710, Speaker A: Is it will grab the balance from my own trojan split wallet, which I can set to whatever I want. I can send it one ETH 1000 doesn't matter.
00:24:18.902 - 00:24:21.062, Speaker B: And it will say, okay, so based.
00:24:21.118 - 00:24:24.796, Speaker A: On the percentage that this beneficiary has.
00:24:24.940 - 00:24:32.508, Speaker B: It will receive the balance times the first split divided by 100%. And you can see right there in.
00:24:32.516 - 00:24:33.988, Speaker A: The formula that I've presented that that.
00:24:34.036 - 00:24:37.212, Speaker B: Will be a huge balance allocated to.
00:24:37.228 - 00:24:38.664, Speaker A: Me within the split contract.
00:24:40.004 - 00:24:41.764, Speaker B: So now I'm just able to say.
00:24:41.804 - 00:24:43.508, Speaker A: Okay, let me withdraw everything.
00:24:43.636 - 00:24:45.636, Speaker B: And the cool thing about the challenge.
00:24:45.660 - 00:24:54.172, Speaker A: Also is that it enables you to say, if you have an 100 ETH balance accounted for within the split contract, you can just withdraw 50.
00:24:54.268 - 00:24:57.188, Speaker B: So you don't have to perfectly calculate.
00:24:57.236 - 00:24:58.780, Speaker A: The amount that you will need.
00:24:58.932 - 00:25:13.116, Speaker B: It's just a thing of let's get a huge balance and then let's take what we need. And here is the whole encoded script which I use to exploit the contract. Essentially, this is just a split contract.
00:25:13.180 - 00:25:20.104, Speaker A: That I will be targeting. I'm distributing the victim split. So I'm reconstructing the data that I.
00:25:20.144 - 00:25:27.296, Speaker B: Need to use to provide a valid hash. The challenge had a small typo in.
00:25:27.320 - 00:25:30.608, Speaker A: Which it assigned twice the account zero.
00:25:30.696 - 00:25:35.968, Speaker B: So don't mind this. And after the split distribute, all of.
00:25:35.976 - 00:25:37.656, Speaker A: The funds in the split wallet will.
00:25:37.680 - 00:25:42.184, Speaker B: Be pushed to split. And that's where we try to attack it.
00:25:42.224 - 00:25:45.996, Speaker A: We try to attack the split contract by creating our own trojan.
00:25:46.180 - 00:25:57.860, Speaker B: We create the split, we deposit some value to it, and then we distribute it with that ambiguous encoding data that I explained to you. We distribute it so that we get.
00:25:57.892 - 00:25:59.380, Speaker A: A huge allocation, and then we just.
00:25:59.412 - 00:26:14.400, Speaker B: Withdraw whatever we need. Done. Deal. Flag captured. Any questions? The only part a little bit hard for me to understand is why did.
00:26:14.432 - 00:26:19.964, Speaker C: You need it to go with the full, you winged representation, you know?
00:26:20.984 - 00:26:22.084, Speaker B: Oh, I didn't.
00:26:22.584 - 00:26:35.444, Speaker C: Online, you could have put, you put like account zero equal message sender, and then you have account one converting that to an address. Why did you need that address specifically?
00:26:37.154 - 00:26:38.122, Speaker A: I didn't.
00:26:38.258 - 00:26:43.538, Speaker B: The idea is that that address that's there, it will later be used as.
00:26:43.666 - 00:26:47.882, Speaker A: The numerator of the calculation that allocates.
00:26:47.978 - 00:26:50.974, Speaker C: Yeah, because the way the API is packed, right?
00:26:51.954 - 00:26:54.434, Speaker A: Yeah, because of the way that distribute.
00:26:54.474 - 00:26:57.490, Speaker B: Will essentially distribute value.
00:26:57.602 - 00:26:59.522, Speaker A: It will grab the first address and.
00:26:59.538 - 00:27:02.590, Speaker B: The first percentage, and it will say.
00:27:02.622 - 00:27:03.926, Speaker A: Okay, this address has this percent.
00:27:04.030 - 00:27:07.554, Speaker B: Interesting. And then we grab the second and the second and the third. And the third.
00:27:08.254 - 00:27:14.894, Speaker A: The caveat there is that the code loops over the accounts array provided to the distribute method.
00:27:15.054 - 00:27:26.886, Speaker B: It doesn't loop over the percentages. So we can just provide a smaller array for the accounts and the extra percentages won't even be looked at. I went with two to the 32.
00:27:26.910 - 00:27:29.876, Speaker A: Minus one, just because, one, I didn't.
00:27:29.900 - 00:27:37.572, Speaker B: Have much time, I just wanted to solve the challenge. And two, because the contract allows you.
00:27:37.588 - 00:27:42.212, Speaker A: To specify how much value you want to withdraw. It won't try to send you all.
00:27:42.228 - 00:27:49.028, Speaker B: Of your balance at once. So if you just need to withdraw ten, you can just go to, you.
00:27:49.036 - 00:27:50.964, Speaker A: Can just try to get an internal.
00:27:51.004 - 00:27:58.360, Speaker B: Balance of more than ten and you will be good. So, and there's no need to calculate.
00:27:58.392 - 00:28:05.072, Speaker A: The exact numerator for which you will be granted a balance that will map to the whole balance of the split contract.
00:28:05.208 - 00:28:08.944, Speaker B: Right. I just overshot it. I could have used 10,000 and it.
00:28:08.944 - 00:28:09.536, Speaker A: Would have been okay.
00:28:09.560 - 00:28:16.352, Speaker B: I could have used ten ether and would have been okay. Just didn't want to miss anything and.
00:28:16.368 - 00:28:17.884, Speaker A: Just went with the maximum value.
00:28:22.244 - 00:28:23.064, Speaker B: Okay.
00:28:23.804 - 00:28:25.184, Speaker A: Skill based game.
00:28:25.524 - 00:28:29.700, Speaker B: Skill based game was my favorite challenge that I've solved.
00:28:29.852 - 00:28:30.660, Speaker A: It was very fun.
00:28:30.692 - 00:28:33.444, Speaker B: It was kind of tricky, especially because.
00:28:33.484 - 00:28:37.584, Speaker A: It involved doing something else other than writing a contract and signing a transaction.
00:28:38.124 - 00:28:49.070, Speaker B: So the challenge is essentially a blackjack table on chain. And the objective is to drain the blackjack contract of its 50 e, which.
00:28:49.102 - 00:28:58.030, Speaker A: It'S allocated at the deployment of the challenge. And Anon, I hope that as soon as I said blackjack and on chain.
00:28:58.222 - 00:29:00.158, Speaker B: In the same sentence, you jumped in.
00:29:00.166 - 00:29:02.674, Speaker A: Your seat and you said, okay, how do you generate randomness?
00:29:03.294 - 00:29:07.126, Speaker B: Because I hope you know. And if you don't, well, here I'm.
00:29:07.150 - 00:29:08.934, Speaker A: Telling you, when you try to generate.
00:29:08.974 - 00:29:12.902, Speaker B: Randomness from stuff that is fully on.
00:29:12.918 - 00:29:15.234, Speaker A: A blockchain, stuff that is fully data.
00:29:15.274 - 00:29:18.858, Speaker B: That is fully public and deterministic, you.
00:29:18.906 - 00:29:20.906, Speaker A: Won'T get full randomness.
00:29:20.970 - 00:29:23.882, Speaker B: Right? It might look like it's random, but.
00:29:23.938 - 00:29:31.394, Speaker A: Anybody will be able to precompute that before calling your own method or before triggering your own method.
00:29:31.474 - 00:29:33.934, Speaker B: So that's not good randomness.
00:29:35.394 - 00:29:38.762, Speaker A: The blackjack contract uses a deck library.
00:29:38.898 - 00:29:43.336, Speaker B: To essentially deal your cards. It's just some utility it has.
00:29:43.440 - 00:29:48.124, Speaker A: And here you can see how it generates the card that you are allocated.
00:29:48.704 - 00:29:55.128, Speaker B: Essentially, it's a number from zero to 51. It has its own nomenclature.
00:29:55.216 - 00:30:02.576, Speaker A: It doesn't really matter here. What's important is that we see that the random number or the card that.
00:30:02.600 - 00:30:10.964, Speaker B: You are dealt depends on the hash of the current block. Hash. The player that is trying to play.
00:30:11.004 - 00:30:12.868, Speaker A: The current hand of blackjack.
00:30:13.036 - 00:30:16.668, Speaker B: The card number, which is an index.
00:30:16.716 - 00:30:21.932, Speaker A: Of how many cards you've requested while playing blackjack. If you don't know how blackjack works.
00:30:22.028 - 00:30:25.108, Speaker B: You can keep asking questions. You keep asking cards.
00:30:25.156 - 00:30:30.540, Speaker A: Sorry. And either you go over a certain value or you can stop before.
00:30:30.612 - 00:30:33.204, Speaker B: And whoever has the, the highest value.
00:30:33.244 - 00:30:35.104, Speaker A: Of cards wins hand.
00:30:36.484 - 00:30:40.916, Speaker B: And then the timestamp. So the idea here is that if.
00:30:40.940 - 00:30:45.624, Speaker A: You win a hand of blackjack, you will get like two times your bet.
00:30:46.004 - 00:31:05.744, Speaker B: If you lose, you lose your whole bet, of course. So how do we break this? How do you tackle this? The idea is you need a contract, right? You need a couple of contracts. You know, a couple of contracts to do what specifically? You.
00:31:05.784 - 00:31:07.472, Speaker A: You need a couple of contracts because.
00:31:07.648 - 00:31:10.960, Speaker B: You will have n players trying to.
00:31:10.992 - 00:31:20.684, Speaker A: Play a game of blackjack. But before actually playing the hand, before actually starting the match, you will need a sort of controller. A sort of.
00:31:21.384 - 00:31:45.116, Speaker B: Yeah, controller contract that will try to compute this hash and try to understand which cards you will be dealt in this current block. And by pre calculating the cards you receive, you can understand if the hand that you would be given is a winning or a losing hand. And based on that, you will play.
00:31:45.140 - 00:31:46.500, Speaker A: Or you will not play.
00:31:46.692 - 00:31:57.732, Speaker B: So essentially, broken randomness equates to I will never lose a hand of blackjack. I will always win because I can pre compute it and I can understand.
00:31:57.828 - 00:32:06.612, Speaker A: Okay, in this block, I will play. Hence the controller will trigger a player to play. If the controller understands, in this hand, in this block, I will not play.
00:32:06.708 - 00:32:16.304, Speaker B: Then just skip the block, do nothing onto the next one, and do it again. So how to flag?
00:32:17.704 - 00:32:29.056, Speaker A: Essentially, you make a player contract that is supposed to play a hand of blackjack, and you make a controller contract that manages n players. And the controller, you will always trigger.
00:32:29.080 - 00:32:32.560, Speaker B: The controller saying, I don't calling its.
00:32:32.592 - 00:32:37.832, Speaker A: Method try win or whatever. And the try win method will grab each player's address.
00:32:37.968 - 00:32:46.060, Speaker B: It will try to understand, will this player win in this current block? If yes, call player play or player win.
00:32:46.132 - 00:32:48.748, Speaker A: Actually, you could also call it because you're sure that you're going to win.
00:32:48.876 - 00:32:51.444, Speaker B: And if not, then okay, do nothing.
00:32:51.524 - 00:32:53.612, Speaker A: Let the transaction terminate.
00:32:53.788 - 00:32:59.836, Speaker B: Do it again the next block. So how do you tie this all together? How do you do this in a.
00:32:59.860 - 00:33:03.124, Speaker A: Timely manner in which you're not doing this by hand every time?
00:33:03.244 - 00:33:09.718, Speaker B: You just write some simple scripts? I tried doing it with Python, and then I realized it was too much.
00:33:09.766 - 00:33:14.454, Speaker A: Work, I guess, even if Python is very quick to write. And I just went in some basic.
00:33:14.494 - 00:33:18.926, Speaker B: Bash scripts using the forge tools and.
00:33:19.070 - 00:33:35.702, Speaker A: Yeah, so essentially you just deploy n players. You deploy a controller. You tell the controller who the players are, and then you just keep spamming. A try wins. Try wins. Either plays or it advances the block, or, I mean, it either plays and wins and advances the block, or it.
00:33:35.718 - 00:33:41.408, Speaker B: Just advances the block. So you just got to keep doing that until you join the contract.
00:33:41.536 - 00:33:43.432, Speaker A: So you set up some minimal monitoring.
00:33:43.568 - 00:33:48.272, Speaker B: To track blackjack's balance so that when it hits zero, you can collect the.
00:33:48.288 - 00:33:50.844, Speaker A: Flag, and then you're, you're basically done.
00:33:54.984 - 00:33:56.216, Speaker B: I can show you guys the code.
00:33:56.240 - 00:33:57.644, Speaker A: If you want to go through it.
00:33:57.984 - 00:34:00.000, Speaker B: I didn't really bring it up because.
00:34:00.072 - 00:34:05.764, Speaker A: It'S kind of long and it's kind of ugly. I can show you, like the scripts in bash. You want to see them?
00:34:05.844 - 00:34:10.184, Speaker C: What was used as a source of randomness here? The block hash. What was.
00:34:11.564 - 00:34:14.784, Speaker B: Yeah, yeah, the hash of the block hash.
00:34:15.404 - 00:34:17.276, Speaker A: Some data which is public and which.
00:34:17.340 - 00:34:20.164, Speaker B: You can precompute, and the block timestamp.
00:34:20.284 - 00:34:21.104, Speaker A: I see.
00:34:21.764 - 00:34:25.932, Speaker B: The idea is that this data, the.
00:34:25.948 - 00:34:37.634, Speaker A: First thing that came to mind to me was, ok, so I will set up like a monitoring tool. And whenever that says true, I will trigger a transaction. Yeah.
00:34:39.334 - 00:34:41.046, Speaker B: That came into play, I guess.
00:34:41.230 - 00:34:45.154, Speaker A: But the thing is that you can't really pre compute this outside of the block.
00:34:45.614 - 00:34:46.614, Speaker B: I was trying to do that.
00:34:46.654 - 00:34:47.646, Speaker A: Right? I was trying to.
00:34:47.710 - 00:34:49.398, Speaker B: I was advancing the block and I.
00:34:49.406 - 00:34:55.995, Speaker A: Was grabbing the latest blocks, block hash and time stamp. And I was trying to understand, would I win in this block?
00:34:56.149 - 00:35:00.599, Speaker B: And if so, then I would send a transaction. But it turns out that that doesn't.
00:35:00.631 - 00:35:02.351, Speaker A: Work because by sending a transaction, you.
00:35:02.367 - 00:35:04.215, Speaker B: Generate a new block with a new.
00:35:04.239 - 00:35:06.199, Speaker A: Block hash and a new timestamp.
00:35:06.391 - 00:35:14.943, Speaker B: So the cards you are dealt are different. So that won't work. So all of the precomputation, all of the, let's say.
00:35:14.983 - 00:35:17.775, Speaker A: Yeah, precomputation of the cards are dealt.
00:35:17.919 - 00:35:29.488, Speaker B: That will have to happen on chain. Right before calling, uh, the play method. Right. Right before playing the blackjack hand, which. That.
00:35:29.536 - 00:35:35.392, Speaker A: Which was a mistake that I did initially. But, yeah.
00:35:35.448 - 00:35:37.272, Speaker B: Um. Bad randomness.
00:35:37.408 - 00:35:41.392, Speaker A: It's a very important thing. If you need randomness in blockchain, please.
00:35:41.448 - 00:35:52.862, Speaker B: Use chainlink, VRF, use a seed provided externally from a trusted oracle. Or don't do it with block hash and timestamp. Don't hash stuff because you.
00:35:52.878 - 00:35:55.474, Speaker A: You will break it and people will drain your.
00:35:55.974 - 00:36:11.462, Speaker B: Your blackjack game. Yeah. So two more to go. Um, though, don't. I have to be honest, I know.
00:36:11.558 - 00:36:15.052, Speaker A: Pretty much nothing about the contracts in this challenge.
00:36:15.198 - 00:36:19.560, Speaker B: The challenge just gives you a DVM contract, and you just.
00:36:19.632 - 00:36:22.044, Speaker A: You have to empty its wrapped ETH balance.
00:36:23.744 - 00:36:28.044, Speaker B: The DVM contract is. I, um.
00:36:29.144 - 00:36:32.632, Speaker A: I wish I knew. I think it's something with.
00:36:32.808 - 00:36:35.044, Speaker B: I think it stands for dodo vending machine.
00:36:35.424 - 00:36:37.600, Speaker A: I looked it up quickly before this.
00:36:37.632 - 00:36:39.736, Speaker B: Call, but I don't know.
00:36:39.840 - 00:36:43.172, Speaker A: Honestly, I don't even know. I just know it's a clone of.
00:36:43.368 - 00:36:47.932, Speaker B: Ox to BBD, whatever address, which is.
00:36:47.948 - 00:36:50.464, Speaker A: A dodo contract for naming mempool or something.
00:36:51.204 - 00:36:52.332, Speaker B: Still, I don't know.
00:36:52.468 - 00:36:54.540, Speaker A: And at this point, I hope you're.
00:36:54.572 - 00:36:56.436, Speaker B: Asking like, what the fuck?
00:36:56.460 - 00:36:57.676, Speaker A: Sir, how did you solve this if.
00:36:57.700 - 00:37:04.144, Speaker B: You don't know what you're talking about? And the answer is, I just asked google.
00:37:05.084 - 00:37:09.326, Speaker A: I just googled Dodo exploit. I googled the address, I googled some.
00:37:09.350 - 00:37:12.758, Speaker B: Stuff, and eventually I hit the second.
00:37:12.806 - 00:37:16.274, Speaker A: Link that you see in the screenshot to the right of the slide.
00:37:16.934 - 00:37:19.766, Speaker B: And as what happens, what turns out.
00:37:19.790 - 00:37:29.262, Speaker A: Is that Holborn was so kind to provide the exploit. Essentially it says, oh, the address to BBD, which is our target that we.
00:37:29.278 - 00:38:00.964, Speaker B: Have here, has suffered a 4 million something hack. It lost all of it wrapped ethan balance. And you read it again and you said, same contract lost all of its wrapped ETH balance. And then you read it again and then your brain goes, okay, no more work. Do this, get flagged. And that's essentially where any t attack, no, no, no, it's a unprotected initializer type of attack.
00:38:01.344 - 00:38:08.258, Speaker A: If you want to look up the, the exploit, just google Dodo exploit and look for this explainer from Halborn.
00:38:08.346 - 00:38:10.122, Speaker B: They do a much better work than me.
00:38:10.298 - 00:38:12.866, Speaker A: But it just says straight up, the.
00:38:12.890 - 00:38:17.314, Speaker B: Attacker deployed a ERC 20 token, it.
00:38:17.394 - 00:38:20.642, Speaker A: Called the unprotected initializer function, the DVM.
00:38:20.698 - 00:38:28.482, Speaker B: Contract swapping out wrapped ETH for this dummy token. It created it, synced it so that.
00:38:28.578 - 00:38:33.210, Speaker A: The reserves go to zero. Then it reset the wrapped ETH token.
00:38:33.322 - 00:39:08.634, Speaker B: And finally he took a flash loan. And what these three actions before the flash do is the flash loan then will not have any reserve to which check that the fee or the flash loan was repaid against. So what these three calls do, the init, the sync and the reunit, what they do is essentially they give you a free flashlight. So you just take the flashlight, you never repay it back. And the contract is like, okay, nice, good job done. Really cool. Problem solved.
00:39:09.054 - 00:39:11.078, Speaker A: This was the fastest challenge that I solved.
00:39:11.126 - 00:39:14.198, Speaker B: It took me like 40 minutes, I would say.
00:39:14.246 - 00:39:21.302, Speaker A: I read a little bit of the contract. I said, oh, this is huge. Let me try a different way before actually delving into the weeds of it.
00:39:21.358 - 00:39:21.994, Speaker C: Nice.
00:39:22.294 - 00:39:24.598, Speaker A: Google sent me to the Holborn report.
00:39:24.686 - 00:39:27.092, Speaker B: And then, and then they came up.
00:39:27.108 - 00:39:30.996, Speaker A: With a special quote, work hard and on, but don't be stupid.
00:39:31.140 - 00:39:31.692, Speaker B: Yeah, man.
00:39:31.748 - 00:39:34.544, Speaker A: Remember that before going down rabbit holes.
00:39:35.364 - 00:39:49.684, Speaker C: I don't know if you know, but there's a huge problem with blockchain ctfs, which is there are people, they just copied other people bytecode and they just solve all solutions just by resending. Because sometimes these challenges, they use the same server, they don't span any instance.
00:39:49.724 - 00:39:52.084, Speaker B: Just for you, you know, so.
00:39:52.424 - 00:39:54.408, Speaker C: And I guess you can consider it solved.
00:39:54.576 - 00:39:59.992, Speaker B: So, yeah, I mean, it's part of the game, right?
00:40:00.088 - 00:40:00.456, Speaker C: Yeah.
00:40:00.520 - 00:40:02.896, Speaker A: The people that made this, they looked.
00:40:02.920 - 00:40:06.144, Speaker B: At a past exploit and they knew.
00:40:06.184 - 00:40:12.296, Speaker A: That everything was there. It's not cheating, it's not something that you're supposed to not do.
00:40:12.400 - 00:40:15.792, Speaker B: It's just somebody finds it looking at.
00:40:15.808 - 00:40:17.244, Speaker A: The code for 4 hours.
00:40:17.764 - 00:40:19.780, Speaker B: I found it by googling some stuff.
00:40:19.812 - 00:40:24.532, Speaker A: And writing and trying to understand the little pieces of code that I needed for like 20 minutes.
00:40:24.588 - 00:40:28.572, Speaker B: And then ggs, I guess I'm on to the next challenge.
00:40:28.588 - 00:40:30.024, Speaker A: You're still on to that one?
00:40:31.164 - 00:40:37.220, Speaker B: Okay. And the final one is enterprise blockchain. Enterprise blockchain.
00:40:37.292 - 00:40:45.816, Speaker A: Enterprise blockchain, excuse me. Presents a bridge between two chains. Each chain holds a bridge contract.
00:40:45.920 - 00:40:48.224, Speaker B: So like a gateway of sorts in.
00:40:48.264 - 00:41:01.312, Speaker A: Which you can send tokens to it. The bridge contract will emit a message. An off chain relayer will pick up that message and then it will relay the message onto the second chain, and then you will get your bridge tokens.
00:41:01.408 - 00:41:02.924, Speaker B: And you can do this back and forth.
00:41:04.224 - 00:41:06.624, Speaker A: So the idea of the challenge is.
00:41:06.664 - 00:41:08.936, Speaker B: To drain the chain.
00:41:09.000 - 00:41:12.124, Speaker A: One layer, one bridge, call it whatever you want.
00:41:13.254 - 00:41:20.494, Speaker B: Contracts flag token balance below 90 ETH worth of these tokens.
00:41:20.574 - 00:41:25.274, Speaker A: So it starts off with like 100 if I'm correct. I don't really remember the amount.
00:41:25.614 - 00:41:37.698, Speaker B: You just got to transfer a bunch of it, get them out, some little details. Flag token is deployed on chain one initially, and then it is bridged to.
00:41:37.726 - 00:41:50.498, Speaker A: To chain two, where it has its own bridged wrapper version like you could imagine with USDCe on Avalanche, which is an IOU. Essentially, it's not a native deployment of.
00:41:50.506 - 00:42:04.450, Speaker B: The token, it's just an IOU and the relayer code, and funnily enough, the relayer code is provided, which is Python, which. Yeah, I don't know, this is a solidity CTF, right?
00:42:04.482 - 00:42:08.630, Speaker A: What is Python provided? We need to read Python. And it turns out you really need.
00:42:08.662 - 00:42:25.006, Speaker B: Python because the relayer does two things. It listens for send remote message logs. So bridge will emit a send remote message event and the relayer will pick those up, and then it will send.
00:42:25.030 - 00:42:27.394, Speaker A: A corresponding transaction on the destination chain.
00:42:28.494 - 00:42:44.744, Speaker B: And particularly it will call the destination chains bridge relay message function. And hopefully you're thinking something's missing. There's one particular thing that's missing. Okay, how do you get the bridge.
00:42:44.784 - 00:42:47.164, Speaker A: To emit a send remote message?
00:42:47.544 - 00:42:49.528, Speaker B: You just control f on the bridge.
00:42:49.656 - 00:42:53.884, Speaker A: And you do emit send remove message and you get one hit.
00:42:54.824 - 00:42:58.656, Speaker B: And it's on this method public payable.
00:42:58.840 - 00:43:01.354, Speaker A: With basically no input validation.
00:43:01.464 - 00:43:40.508, Speaker B: I see it. Just send a remote message. Okay, um, where is it, though? What, what did you put it anon? Who can trigger the send remote message event? Who, who's the trusted party there? Who's authorized to do such? Nobody. So, I mean, no, everybody. There's no validation, is there? So the idea is to just grab send message, send remote message and tell it, hey, do this. And the relator would just be like, okay, nice.
00:43:40.556 - 00:43:43.260, Speaker A: Yeah, sure. Sends it over to the other bridge.
00:43:43.372 - 00:43:46.092, Speaker B: And the bridge will go through its.
00:43:46.188 - 00:43:47.836, Speaker A: Relay message function, which I have not.
00:43:47.860 - 00:43:52.652, Speaker B: Provided, but trust the fact that there's no validation there, and the bridge will.
00:43:52.708 - 00:43:55.904, Speaker A: Execute whatever external call that you provided.
00:43:56.454 - 00:44:00.230, Speaker B: And what's the external call that allows.
00:44:00.262 - 00:44:02.394, Speaker A: Us to do what we want to?
00:44:02.894 - 00:44:05.754, Speaker B: Oh, I do provide the relay message. Sorry.
00:44:06.614 - 00:44:07.158, Speaker A: Yeah.
00:44:07.246 - 00:44:13.790, Speaker B: Here you can see that when the destination bridge receives a message, it does.
00:44:13.822 - 00:44:16.118, Speaker A: Make sure that it's the relayer that sent it.
00:44:16.246 - 00:44:26.950, Speaker B: This is a correct implementation of this modifier, but it just checks like the chain id isn't the same as this bridge. So and then it does this hash.
00:44:26.982 - 00:44:28.790, Speaker A: And it checks that the message wasn't.
00:44:28.822 - 00:44:57.652, Speaker B: Already executed, and then it does a target address dot call with whatever data you just gave it with the relayer gave him. So for this last explainer, I kind of wanted to flip the script and I just wanted to provide you guys with the exploit. And I wanted to ask you, what is the exploit then take your time. I'm, we're not in a rush, but.
00:44:57.668 - 00:44:59.184, Speaker A: I would like to hear from somebody.
00:44:59.644 - 00:45:00.956, Speaker B: Oh, this is what you're doing.
00:45:01.020 - 00:45:05.132, Speaker C: Can you go down? Can you go down?
00:45:05.188 - 00:45:07.944, Speaker B: Yeah. Can you see the, on the cast?
00:45:08.364 - 00:45:09.428, Speaker C: Okay, 1 second.
00:45:09.516 - 00:45:18.040, Speaker B: Yeah, cast sent. Can you go back to the previous.
00:45:18.112 - 00:45:19.992, Speaker C: Screen so we can see the code for the relayer?
00:45:20.088 - 00:45:23.424, Speaker B: Sure, sure. The code for the relayer.
00:45:23.504 - 00:45:24.312, Speaker A: Want to see this one?
00:45:24.368 - 00:45:26.888, Speaker C: No. Okay, this one just processes it.
00:45:26.936 - 00:45:27.144, Speaker B: Right.
00:45:27.184 - 00:45:29.088, Speaker C: I want to see, yeah, this guy.
00:45:29.136 - 00:45:29.924, Speaker B: 1 second.
00:45:30.744 - 00:45:31.524, Speaker A: Yeah.
00:45:35.024 - 00:45:37.536, Speaker B: So the idea is that we are.
00:45:37.680 - 00:45:40.512, Speaker A: Sending a message from L2 to.
00:45:40.528 - 00:45:44.408, Speaker B: Layer one, and we can send any.
00:45:44.456 - 00:45:46.616, Speaker A: Message we want to from L2 to layer one.
00:45:46.720 - 00:45:51.124, Speaker B: And then layer one will execute whatever message we gave it.
00:45:52.304 - 00:45:55.084, Speaker A: Remember our objective for the challenge.
00:45:56.144 - 00:46:06.032, Speaker B: And. Yeah, just know that this send is giving a chain id, which is 78704.
00:46:06.088 - 00:46:07.404, Speaker A: Which is chain one's id.
00:46:07.784 - 00:46:27.040, Speaker B: It gives a address which is a target, which I explained to you what this is. And then it gives some call data. And who can tell me what this selector is? You should know this by heart if you're a security researcher. A 9059 CBb.
00:46:27.232 - 00:46:28.084, Speaker A: That's.
00:46:31.424 - 00:46:37.436, Speaker B: That'S the basics. Just messing with you. But the only thing I'm confused about.
00:46:37.500 - 00:46:39.468, Speaker C: Is the message value because, okay, I.
00:46:39.476 - 00:46:42.796, Speaker B: Can just send any message, but the.
00:46:42.820 - 00:46:44.624, Speaker C: Value itself would be.
00:46:46.124 - 00:46:52.284, Speaker B: We considered that. Right? And you mean the ether we're sending?
00:46:52.364 - 00:46:53.024, Speaker C: Yes.
00:46:55.324 - 00:46:59.624, Speaker B: No, that's not really important. As you can see in this transaction.
00:46:59.664 - 00:47:02.992, Speaker A: I'm sending zero value. There's no value flag, there's no nothing.
00:47:03.048 - 00:47:13.784, Speaker B: So I'm sending zero ETH. Don't be shy, guys.
00:47:13.864 - 00:47:15.504, Speaker A: If you want to talk. If you want to send a message.
00:47:15.544 - 00:47:59.684, Speaker B: I'm looking at the chat we invite more people to. Oh, ff, got it. So the selector, a 9059 CBB, is the transfer address you into 56 selector. So what is the payload doing then? Ff or anybody? What is the payload doing? If we were calling the transfer method on the flag token.
00:48:04.064 - 00:48:06.404, Speaker C: Most likely transferring tokens to you.
00:48:07.984 - 00:48:18.556, Speaker B: Exactly. I'm not transferring them to myself, because if we dissect this call data, we will see. Okay, so the first eight hex characters.
00:48:18.620 - 00:48:20.732, Speaker A: Or four bytes are the selector.
00:48:20.908 - 00:48:32.996, Speaker B: And then the first 32 bytes, or the first word you can just read up to zeros is an address because of how the signature, the method works.
00:48:33.020 - 00:48:38.824, Speaker A: Right, so we're sending funds to nine e, nine ob, whatever, aa.
00:48:39.324 - 00:48:42.572, Speaker B: And this is sort of very similar.
00:48:42.628 - 00:48:49.104, Speaker A: To what the flag token address is. I could have done this differently, I just couldn't be bothered. And I changed this from b to a.
00:48:50.324 - 00:48:53.124, Speaker B: So we're sending tokens to an address.
00:48:53.244 - 00:48:55.484, Speaker A: That has no code, we know nothing.
00:48:55.524 - 00:49:12.714, Speaker B: About this address, and then we're sending an amount. And if you decode this amount, this should equate to 50 e to the 18. So essentially anybody can grab the relayer.
00:49:12.834 - 00:49:23.734, Speaker A: From, can convince the relayer to relay a message saying, bridge one, you should call flag token and transfer all of your tokens to whatever address.
00:49:25.554 - 00:49:30.170, Speaker B: And that's what we're doing. This way we can get the balance.
00:49:30.282 - 00:49:34.242, Speaker A: Of the layer one bridge to be below the threshold that we need it.
00:49:34.258 - 00:49:46.292, Speaker B: To be to capture the token. Really interesting. Yeah, essentially improper access control and a.
00:49:46.308 - 00:49:49.124, Speaker A: Little bit of magic steps to get you to the answer.
00:49:49.164 - 00:50:02.108, Speaker B: But good job, Ff, thanks for your help. And okay, so with that transaction I.
00:50:02.156 - 00:50:04.196, Speaker A: Made, the chain two bridge instance, emit.
00:50:04.260 - 00:50:22.254, Speaker B: A send remote message targeting chain one, the target of the relayed call. The address that will be called is flag token, and the call data is to trigger a transfer from chain one's bridge to an arbitrary address.
00:50:22.334 - 00:50:25.514, Speaker A: Doesn't really matter who it is, it just has to leave the bridge.
00:50:26.014 - 00:50:54.964, Speaker B: And because of all the reasons that I've said, the transfer will go through, the balance of the bridge will be lower than the threshold, and we will get that sweet flag. So good job, Anon. And that's essentially it. Those are my solutions to the challenge to these challenges. It took me, I would say, close to 34 hours counting in, obviously having.
00:50:55.084 - 00:51:03.072, Speaker A: Eating, sleeping, doing stuff normally, because I lived also during the weekend, although you.
00:51:03.088 - 00:51:08.872, Speaker B: May not believe that. And yeah, the last 10 hours, I.
00:51:08.968 - 00:51:15.764, Speaker A: Didn'T really manage to do much. I solved enterprise blockchain. I went for a walk and I said, okay, let's do die.
00:51:16.784 - 00:51:21.896, Speaker B: And nothing. I couldn't find anything.
00:51:21.960 - 00:51:23.800, Speaker A: I was just stumped by the challenge.
00:51:23.832 - 00:51:26.736, Speaker B: I said, let's try suspicious charity again.
00:51:26.840 - 00:51:29.616, Speaker A: I could not see how I could get in.
00:51:29.800 - 00:51:41.088, Speaker B: I could not find a single flaw. And essentially what happened is that by reading both contracts, both challenges, I made.
00:51:41.136 - 00:51:50.448, Speaker A: Some assumptions, I made some pretty strong assumptions about how the exploit would look like. So in die, I was assuming that.
00:51:50.616 - 00:51:53.800, Speaker B: A particular dynamic array that I can.
00:51:53.832 - 00:51:58.504, Speaker A: Provide as input was, was always supposed to be empty. Was always supposed to be an empty array.
00:51:58.964 - 00:52:01.996, Speaker B: And by doing that assumption, I cocked.
00:52:02.020 - 00:52:05.156, Speaker A: Myself, essentially because the exploit involved giving.
00:52:05.260 - 00:52:14.476, Speaker B: A non empty array and I could not see the solution. I spent like 10 hours trying to see the vulnerabilities, but I was not.
00:52:14.500 - 00:52:16.504, Speaker A: Able to because I had this.
00:52:18.604 - 00:52:20.940, Speaker B: Impediment. Let's say I could not get over.
00:52:20.972 - 00:52:24.494, Speaker A: This, this wall that I had built myself around.
00:52:25.154 - 00:52:29.258, Speaker B: And yeah, the time came to close up the CTF.
00:52:29.346 - 00:52:30.490, Speaker A: I went to sleep and the next.
00:52:30.522 - 00:52:34.154, Speaker B: Morning I woke up in my 37th.
00:52:34.194 - 00:52:37.322, Speaker A: Placement, placing me on the top, on.
00:52:37.338 - 00:52:45.418, Speaker B: Top of about 83% of teams that participated, which is a pretty darn good episode.
00:52:45.546 - 00:52:47.934, Speaker A: Congratulations. Very proud of it.
00:52:50.804 - 00:52:53.332, Speaker B: I wish that I could have kept.
00:52:53.388 - 00:53:02.668, Speaker A: My composure for type because once you see the exploit, if you have read the write up. If not, I recommend it. Once you see the solution, it is.
00:53:02.836 - 00:53:15.656, Speaker B: Five lines of code and it's so incredibly numbing to know that I missed that. That's the last part of details.
00:53:15.720 - 00:53:24.844, Speaker A: I want to give some closing remarks to aspiring security searchers or people that have participated this year and are looking towards next year.
00:53:25.384 - 00:53:29.672, Speaker B: I really recommend playing solo if you.
00:53:29.688 - 00:53:47.726, Speaker A: Are up to one of the biggest challenges that you can find. I would say that similar size challenges would be getting top three in a code arena or in a Sherlock contest, or finding a high or as critical in immunify. These are very hard challenges to do.
00:53:47.870 - 00:53:49.158, Speaker B: And if you're going to do them.
00:53:49.206 - 00:53:52.710, Speaker A: Alone, it is going to be very hard, very taxing.
00:53:52.742 - 00:54:01.702, Speaker B: It's going to be very stressful on you and you will not have teammates to bend towards. You will not have a room to.
00:54:01.718 - 00:54:07.070, Speaker A: Say, okay, listen, I have to take a break. You do most of the work. Let me copilot for a bit.
00:54:07.102 - 00:54:11.098, Speaker B: Let me take the backseat. But if you're up to the challenge.
00:54:11.266 - 00:54:18.538, Speaker A: If you want to measure yourself against industry level people, you know the best compete in this.
00:54:18.626 - 00:54:21.050, Speaker B: And everybody tries to make a name.
00:54:21.082 - 00:54:22.754, Speaker A: For themselves in these challenges.
00:54:22.914 - 00:54:25.426, Speaker B: So if you're up to the challenge.
00:54:25.450 - 00:54:28.850, Speaker A: Of doing this alone, measuring yourself against.
00:54:28.962 - 00:54:33.434, Speaker B: Full teams of security researchers, then just do it man.
00:54:33.594 - 00:54:40.134, Speaker A: I recommend it 100%. It will be very fun. It will be. It will teach you a lot of.
00:54:40.514 - 00:54:43.386, Speaker B: A lot of things and if you.
00:54:43.410 - 00:54:57.090, Speaker A: Manage to get a decent position then a lot of people will actually recognize you. I myself have gotten DM's messages invites to chat with people that didn't really.
00:54:57.122 - 00:55:05.300, Speaker B: Take a notice of me before my CTF performance. So yeah, if you want to chat.
00:55:05.332 - 00:55:08.612, Speaker A: About this a bit more, definitely send me a DM. DM's are always open.
00:55:08.668 - 00:55:16.444, Speaker B: I'm always glad to talk with people starting out, people that are kind of established, people that are looking to team.
00:55:16.484 - 00:55:18.824, Speaker A: Up for contest for bug bounties, whatever. I'm always.
00:55:19.484 - 00:55:23.860, Speaker B: I'm always very happy to chat. So don't hold back.
00:55:23.892 - 00:55:25.904, Speaker A: If you want to send me a DM, please do.
00:55:26.524 - 00:55:45.074, Speaker B: And yeah, hopefully I will be back next year with a team and gunning for a top 10% placement which was my initial goal. Yeah, thank you everyone for for your time for listening. Thank you miss and opensense for having.
00:55:45.114 - 00:55:48.530, Speaker A: Me give this talk. You can see my socials here to.
00:55:48.562 - 00:55:50.674, Speaker B: Drop me a follow on twitter or.
00:55:50.714 - 00:55:51.934, Speaker A: Message me on Telegram.
00:55:52.394 - 00:55:53.610, Speaker B: Whatever suits you.
00:55:53.762 - 00:55:58.614, Speaker C: Amazing presentation. Let me see if people have some questions here.
00:55:59.654 - 00:56:00.382, Speaker B: Anybody?
00:56:00.438 - 00:56:02.714, Speaker C: I think someone is writing right now.
00:56:04.294 - 00:56:06.074, Speaker B: Are you going to Istanbul bro?
00:56:08.254 - 00:56:09.874, Speaker A: No, unfortunately.
00:56:11.734 - 00:56:13.314, Speaker B: I was planning on it.
00:56:13.734 - 00:56:18.454, Speaker A: I mean I wasn't planning on it initially. Then after the paradigm CTF I got a lot of dms saying.
