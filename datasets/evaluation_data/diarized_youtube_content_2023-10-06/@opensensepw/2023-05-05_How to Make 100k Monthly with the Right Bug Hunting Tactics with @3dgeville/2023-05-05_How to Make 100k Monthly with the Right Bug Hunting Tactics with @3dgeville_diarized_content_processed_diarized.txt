00:00:00.120 - 00:00:00.660, Speaker A: Yes.
00:00:02.774 - 00:01:03.244, Speaker B: So we have this paper called here, demystifying exploitable bugs in smart contracts. Just to give everyone a bit of motivation, they made a system slash a plan. There were three people. So they found they made their strategy, and with that strategy, they made $100,000 in one month. So that's why I think this paper is pretty good, because it talks about which kinds of bugs that you should look for in contests and which type of bugs you should look at when you're doing a bug bounty, because they are different. So at the start, most of us enjoy auditing. So.
00:01:05.624 - 00:01:07.728, Speaker A: Yeah, yeah.
00:01:07.776 - 00:02:48.060, Speaker B: Right. Okay. So right in the beginning, they talk about that 80% of bugs can only be found by manual auditing, while only 20% of bugs can be found by tools. Tools such as fuzzing or you have static analyzations tools. And that makes it very like, that makes it very important for us as auditors or aspiring auditors, which I am to be good at the solidity language. So they start at looking at, they have three research, four research questions, which are, what kind of exploitable bugs are machine audible by existing tools? How many real world exploitable bugs are machine audible? How difficult is it to audit exploitable bugs? What are the root causes, categories, distinction of machine audible bugs? And what are the symptoms and fixes of machine audible bugs? And can they properly abstract such automated oracles can be devised? They use the data. The thing that's very good about smart contract security is that everything is open, like a lot.
00:02:48.060 - 00:03:01.344, Speaker B: I don't know if any of you have, any of you guys have experience with normal security, where most of the times bugs.
00:03:02.284 - 00:03:03.624, Speaker C: You mean web two security.
00:03:04.414 - 00:03:05.278, Speaker D: Yeah, web two.
00:03:05.326 - 00:03:07.954, Speaker B: Web two. Because in web two. Yeah. Thank you.
00:03:08.254 - 00:03:11.782, Speaker A: Yeah, because web two, most of the.
00:03:11.798 - 00:03:20.614, Speaker B: Bugs, some, some are security researchers or the companies. Most of the time it's not shared, but here it's.
00:03:20.694 - 00:03:23.766, Speaker A: It is shared, which is a very.
00:03:23.790 - 00:03:58.984, Speaker B: Good opportunity to look at past attacks and learn from them. So they used code for arena reports to look at. To look at what's it called? The bugs and the findings and what the auditors used. And when we go down here, they just talk about the different kind of tools. Like we have fuzzing, where Adena is very popular.
00:03:59.134 - 00:04:03.204, Speaker A: We have static analysis, where people use.
00:04:03.284 - 00:04:13.824, Speaker B: Remix and slither, which is very popular. And formal verification is becoming popular right now. And you also have symbolic execution.
00:04:14.484 - 00:04:15.384, Speaker A: Sorry for.
00:04:15.924 - 00:04:41.914, Speaker B: Please explain what formal verification really means. I am sadly to say that I cannot answer that because there was a contest and I didn't. I was, I didn't take part of it, but I think it's a mathematical way to find bugs. I don't know if mystic wants to answer that question or can you guys.
00:04:43.574 - 00:04:49.630, Speaker C: Give me like just a short answer for what I see a lot of people talk about formal verification. What does it mean exactly?
00:04:49.702 - 00:05:19.934, Speaker E: I think so. So here's what I know about it. Okay, I'm stopped saying there's right, I know there's a way to assert the mathematical properties of the application. So you would rewrite the functions, you know, in a mathematical sense and test with formula. I think highly tools maybe can give us a little bit of a introduction or highly to do anything about. Actually anyone, if you guys know anything about formal verification, just open your mic and talk. Okay.
00:05:28.654 - 00:05:36.234, Speaker B: I think hopefully in the future maybe we can have a talk about formal verification. I'm sorry that I cannot answer that question.
00:05:38.174 - 00:05:45.834, Speaker E: There are v here to talk about that, and he is now working at Sertora, which is the biggest formal verification company. So we're going to solve that, no worries.
00:05:48.754 - 00:05:49.658, Speaker A: That's good.
00:05:49.786 - 00:07:27.554, Speaker B: Yes. You know, if any of you have done ethereum, and it's very easy to, if there's some developers that use transfer or transfer from instead of safetransfer and save transfer from, that's very easy finding.
00:07:28.294 - 00:07:30.154, Speaker A: So let's just.
00:08:43.234 - 00:09:01.094, Speaker B: Most contracts to have found this and they have categories like from lending, Dex yields, etcetera. And yeah, should I'm going to take a look at my notes. Yeah, I'm going to take a look from my notes.
00:09:01.254 - 00:09:01.954, Speaker A: So.
00:09:05.134 - 00:10:55.786, Speaker B: A price oracle manipulation is when, the thing is, it's very easy to not have this problem. How price Oracle attacks happen is that when a project uses a very bad way to source the data. So what they do is that instead of calculating the price of price of the pool from the oracle feed, they calculate the price from like the ratio of the pool. So if you have a ratio of dai and ether, and if that ratio, if a person buys a lot of, takes a lot of dye out of the pool, then the ethereum becomes very vulnerable, becomes very expensive. If a person injects a lot of the dye to the pool, then the ethereum becomes very cheap. So the price manipulation happens when projects use a very bad way to derive price, not deriving the price from directly the oracle, but using a ratio which you would think that it is fixed, but not, no, there still happens. Anyways, horrendous accounting is that is more of a business business logic fault where that there are small miscalculations when you're adding up some calculations and if you have a lot of small, small false calculation, then it adds up.
00:10:55.786 - 00:12:03.360, Speaker B: So maybe it adds up to the price, maybe it adds up to the state variable. So that is how, what that is the thing about id uniqueness violation is that sometimes there are bugs because of developers haven't taken into account that the assets are unique and should be stored, but instead that they can be copied and hence where a hacker can take, can take. You can use that. Yes, we have privilege escalation and privilege escalation. As you know it says in the world, word like the privilege is escalated. This is caused by teams or developers where they have a weak access control, role based control, and which leads to easily privileged escalation. Atomicity violations.
00:12:03.360 - 00:13:09.684, Speaker B: Is that where you have several business flaws, transactions run at the same time and they all are dependent at the same arrays or state variables. Developers may think that atomicity is guaranteed, but it's not. But this is a very rare bug. And then we have contract implementation specific bugs, and these are specific bugs to them. These are specific bugs to variables. Sometimes they update incorrectly or not at all, which could lead to the called being vulnerable.
00:13:12.624 - 00:13:13.364, Speaker A: Further.
00:13:18.264 - 00:14:07.618, Speaker B: Further, the paper dives more deeply into three bugs. These bugs are price oracle manipulation, horrendous accounting and privilege escalation. These are the three bugs that. These are the three bugs that the paper found are most consistent. That happens recur a lot. So as I said, price oracle attacks happens with dexs or automated market makers. To calculate the value of the assets, price oracles are used.
00:14:07.618 - 00:14:32.934, Speaker B: Price oracle and manipulations has nothing to do with the bug in oracle about the misuse of the application contract. Let's say Uniswap has a price API that can help calculate the price. Some developers use the own query to calculate the price. Instead of the API of Uniswap.
00:14:41.554 - 00:14:42.250, Speaker A: Calculate.
00:14:42.322 - 00:14:44.618, Speaker B: The price based on a pair ratio.
00:14:44.706 - 00:14:48.186, Speaker A: Which could mean that if we have.
00:14:48.250 - 00:14:56.594, Speaker B: A pool consistent of 100 400,000 USDC, the price.
00:14:58.334 - 00:15:00.874, Speaker A: Of the IS 4000 USDC.
00:15:01.894 - 00:16:11.204, Speaker B: Let's say this ratio has been changed to 200,000 USD. Then the price of the wrapped ETH is 1000 USDC, which opens the project up to price manipulation attacks. To prevent this most common solution is to use a time weighted average price or a twap. So as I said earlier, price oracle attacks are attacks that are attacks on the ratio of the pool. Let's go further. Further privilege escalation. This is about gaining more access in a way that the developer has not thought about and get access to the contract funds unprotected external functions should, should know how world should be under some unprotected external functions should have admin access.
00:16:11.204 - 00:16:43.254, Speaker B: This is what is price escalation and atomicity violation. Sorry for my bad pronunciation. These are bugs that occur because some flows need to happen together or in sequence. If this is broken, the contract is vulnerable to attacks. This could mean that having a correct amount of required statements as other functions.
00:16:43.794 - 00:16:52.234, Speaker A: As example in the paper, so.
00:16:54.974 - 00:17:11.394, Speaker B: Audible vulnerabilities. These are price oracle manipulation and privilege escalation. And from this they have audited different projects. They protected $22 million worth of funds.
00:17:12.054 - 00:17:13.514, Speaker A: And with this.
00:17:20.003 - 00:18:08.694, Speaker B: And then, and then to, to give out the gist or the secret sauce. I'm going to share to you what I've learned. I've shared to you what I've learned from the paper. But what you can gain from this paper at most is a very unique strategy when you're doing bug bounties or contests. So have a pen and paper, or if you guys have good memory, you can just remember. For bug bounties, look for bugs related to price oracle manipulation and privilege escalation. Because a lot of these projects, these are like the bugs that will pay higher bounties for contest.
00:18:08.694 - 00:18:47.534, Speaker B: Look for bugs like erroneous accounting privilege escalation, inconsistent state update, optimisticity violation. Sorry for my bad pronunciation. And id uniqueness. Thank you. And id uniqueness violations. So that's a wrap. And I was wondering if you guys, if you found this talk, if you valuable, just follow me on, on Twitter.
00:18:47.654 - 00:18:53.198, Speaker A: But other than. Are there any questions?
00:18:53.246 - 00:19:09.026, Speaker E: Thank you so much. That was amazing. The juice in the end there, the alpha was key. I think that someone, Pangolin, maybe you could talk him through that situation you were feeling before and it kind of fits you.
00:19:09.050 - 00:19:09.282, Speaker B: This.
00:19:09.338 - 00:19:09.934, Speaker E: No.
00:19:12.074 - 00:19:13.014, Speaker A: Could you.
00:19:14.234 - 00:19:17.214, Speaker B: Sorry, could you repeat the question again?
00:19:24.914 - 00:19:40.444, Speaker E: He was having problems finding the right strategy when approaching, but bounty when, when, you know, extracting value from the hours working and everything. But I'll let him speak and I think that will be really valuable.
00:19:43.344 - 00:19:44.104, Speaker A: Thank you, man.
00:19:44.144 - 00:19:46.844, Speaker F: Thank you. Yeah, appreciate the talk.
00:19:47.864 - 00:19:49.568, Speaker B: From what you've said as well, it.
00:19:49.576 - 00:19:52.736, Speaker F: Just sparked something that I was thinking that I was talking about earlier on.
00:19:52.760 - 00:19:56.586, Speaker D: The other call around the, I reported.
00:19:56.770 - 00:20:00.294, Speaker B: Three vulnerabilities and they rejected them.
00:20:02.954 - 00:20:06.450, Speaker A: They said that third party being invalid.
00:20:06.482 - 00:20:07.330, Speaker F: Was out of scope.
00:20:07.362 - 00:20:15.002, Speaker D: So basically oracle, oracle data, you know, when they use the last updated feed.
00:20:15.098 - 00:20:17.610, Speaker F: To get the, you know, the price or whatsoever, if it comes back as.
00:20:17.642 - 00:20:20.808, Speaker D: Scale, then that can be a problem.
00:20:20.856 - 00:20:22.320, Speaker F: If it comes back or it reverts.
00:20:22.352 - 00:20:24.344, Speaker D: If the, if the oracles went down.
00:20:24.384 - 00:20:30.644, Speaker F: So I looked into these ones at the time and reported these twice as a medium.
00:20:33.824 - 00:20:37.648, Speaker B: I'm just wondering, your heart, your mic is coming in very hot.
00:20:37.816 - 00:20:51.044, Speaker A: Is it anywhere? 1 second there.
00:20:51.164 - 00:20:55.504, Speaker B: Maybe it helps now, but speak a little bit closer to the mic as well.
00:20:56.284 - 00:20:58.380, Speaker D: Yeah, I think it's the, is that any better?
00:20:58.572 - 00:21:00.004, Speaker B: Yeah, yeah, much better.
00:21:00.084 - 00:21:02.504, Speaker F: Yeah, I think it was the headset I've got on. Sorry.
00:21:02.844 - 00:21:04.412, Speaker A: No problem. Yeah, sorry.
00:21:04.588 - 00:21:18.872, Speaker F: I'll come to the question. But what you just said about oracle manipulation just sparked me to remember what I was talking about before. I'd reported three things related to the oracles on a project and unfortunately they were rejected too out of scope. And the other one kind of out.
00:21:18.888 - 00:21:21.376, Speaker D: Of scope and invalid or whatsoever else.
00:21:21.400 - 00:21:38.120, Speaker F: But that was just because it was to do with the data feed. So if it comes back as stale or reverse. But so that was, that's interesting to look at. I never looked at the oracle manipulation as much because I guess it's down to understanding. But one of the things that I was saying on another call earlier on.
00:21:38.152 - 00:21:44.340, Speaker D: Was from what you've said as well, what to look for is the difficulty.
00:21:44.412 - 00:21:48.340, Speaker F: I have and others that I've come across is knowing what to go to.
00:21:48.492 - 00:21:50.956, Speaker D: When you open up a project or.
00:21:50.980 - 00:21:53.588, Speaker F: You do a book bounty or you're going to do, you know, a competition.
00:21:53.636 - 00:21:56.036, Speaker D: On c four whatsoever, it's knowing what.
00:21:56.060 - 00:22:00.144, Speaker F: To, where to start, like how, what do my, what should I be looking for?
00:22:01.804 - 00:23:39.964, Speaker B: Okay, so as I said, like, so in a contest, what you're, you are rewarded because you can, you can be potentially rewarded because of, hopefully there has not been audit on the code base before, but in the contest you find more bugs. So in a contest I would as again, the thing, I think it's much easier, first look at the package Json, look at which are they using soulmate or are they using open Zeppelin for the contracts? Okay, look at the version of Open Zeppelin or soulmate they're using because sometimes there can be a bug in that. Like after that I would look at the access control, I would look if they're using a role based access control, I would look at if they're using an ownable check if they are, if they have used like the recommendations that Openceplin or Soulmate has from that I would check what type of, like if it's fork, I would check if the fork, like what the project has fork forked has had the, has had any bugs or updates and if those updates are not gone through to the project.
00:23:40.264 - 00:23:42.272, Speaker A: But if it's not fork.
00:23:42.408 - 00:24:19.028, Speaker B: I would look at is it an NFT project? Because a lot of NFT project have like pretty much rookie developers. So there I will look for common vulnerabilities if it's an AEM or what is it called a Dex. Or like I would look for first access control and then I would look for if the state updates are updated properly and then just go down the list. I just said, is there a chat here?
00:24:19.156 - 00:24:20.036, Speaker A: Because if there are.
00:24:20.060 - 00:24:20.664, Speaker G: Chat.
00:24:20.964 - 00:24:28.060, Speaker B: Yeah, yeah, yeah. Because if there is a chat here, I can just write it down on the chat for you guys.
00:24:28.252 - 00:24:29.260, Speaker D: Yeah, that'd be great.
00:24:29.372 - 00:24:40.596, Speaker F: I think that does help. I focus mostly on decks as well, only because I've started off in looking at them first and looking what an amm is and how the liquidity pools work.
00:24:40.660 - 00:24:43.924, Speaker D: And I think one of the biggest.
00:24:43.964 - 00:25:04.106, Speaker F: Issues I had was everyone's like, oh, I'm looking at this, I'm looking for lows, highs, medians, and I'm like, I don't even know what low I should be looking for. Like, is there a, I was saying to someone before, I said, is there a list that someone goes, right, these are the kind of common lows that I will go for first. If I don't see any of these, then I'll move to mediums and highs. I don't even have a list of common lows.
00:25:04.130 - 00:25:06.266, Speaker D: I know there's, I've looked at reports.
00:25:06.330 - 00:25:12.250, Speaker F: And stuff and seen, you know, I've got solo date, I've looked at c four reports, I've looked at even audits from other companies.
00:25:12.322 - 00:25:14.530, Speaker D: But I'm like, I don't know how.
00:25:14.562 - 00:25:17.192, Speaker F: To kind of, I guess categorize and.
00:25:17.208 - 00:25:19.512, Speaker D: Go, right, these lows should be the.
00:25:19.528 - 00:25:22.880, Speaker F: First thing I look for in this project, regardless of what project it is.
00:25:22.992 - 00:25:24.912, Speaker D: And then from there I can start.
00:25:24.928 - 00:25:32.124, Speaker F: To now look at this stuff instead. Like if it's Dex, I can look at this, this and this. This is where I feel like I'm struggling, where I can't, I don't have that initial.
00:25:32.624 - 00:25:34.520, Speaker D: Start off with this and then move.
00:25:34.552 - 00:25:38.564, Speaker F: On to the other stuff. And if you've read about something, maybe look at that, you know.
00:25:39.704 - 00:26:10.116, Speaker B: Yeah, I think you're not the only one struggling with that. We're, we're all struggling with, with that. But it's just to look at, if I was you, I would look at like just search on Google, NFT markets, what are the most common vulnerabilities? Amms, what are the most vulnerabilities? And then just either make a list or just make a mental model of it, right?
00:26:10.180 - 00:26:12.988, Speaker A: Yeah, yeah, you're right. Yeah. Yeah.
00:26:12.996 - 00:26:15.060, Speaker F: That's a good start, to be fair. Cool.
00:26:15.092 - 00:26:20.504, Speaker B: How long have you been like doing smart contract already?
00:26:21.084 - 00:26:32.148, Speaker F: Yeah, so, I mean, I actually started off in web two, but I found the competition was too high. And then in August of 2021, I came across immunify. I was like, oh, wow, this looks interesting.
00:26:32.276 - 00:26:33.116, Speaker D: Started looking into it.
00:26:33.140 - 00:26:41.922, Speaker F: I did the white hat scholarship for three months. I learned how to use Brownie ETH and do some solidity and testing, and then I had to go back to full time work.
00:26:42.058 - 00:26:43.466, Speaker D: So I've been on and off for.
00:26:43.490 - 00:26:44.450, Speaker F: Like a year and a half just.
00:26:44.482 - 00:26:46.770, Speaker D: Trying to get to grips with how.
00:26:46.802 - 00:26:51.514, Speaker F: To do, how to write contracts and then how to read them and how to test them.
00:26:51.674 - 00:26:52.866, Speaker D: And I'm at the point now where.
00:26:52.930 - 00:26:56.954, Speaker F: I'm starting to use foundry because I wanted to practice more in solidity rather.
00:26:56.994 - 00:26:59.890, Speaker D: Than because I use Python a lot and JavaScript.
00:26:59.922 - 00:27:27.864, Speaker F: I was learning, but I was like, I don't want to learn a new language now just to do this. So I've focused on solidity and foundry and I spent a lot of time just recently in the past few months really going through, really getting down into it. So I feel like I can read the solidity, I can follow a path and, you know, I can write a simple testing foundry. I've done all right with the last, the submitted reports I did, but then I still feel as though I'm missing.
00:27:27.904 - 00:27:29.936, Speaker D: This part where I go, right, I've.
00:27:29.960 - 00:27:39.634, Speaker F: Read the docs, I've made some summaries, I've asked loads of questions myself. That is, I've written a list of questions and stuff. Now what am I meant to start looking for?
00:27:39.974 - 00:27:40.374, Speaker B: Yeah.
00:27:40.414 - 00:27:45.982, Speaker D: Like what lows should I have as a kind of a framework of this.
00:27:45.998 - 00:27:51.622, Speaker F: Is the stuff I'll always look for, and then I'll move upward from that when experience and, you know, depending on.
00:27:51.678 - 00:27:52.874, Speaker D: What the project is.
00:27:53.454 - 00:27:53.878, Speaker A: Yeah.
00:27:53.926 - 00:28:12.254, Speaker B: And, and you can also, like, when you're looking at the contracts, just start with the shortest one and then work your way up and then make a mental model of it.
00:28:12.954 - 00:28:14.898, Speaker F: I did that with one of, yeah, I did.
00:28:15.026 - 00:28:16.026, Speaker D: I think that was the only reason.
00:28:16.050 - 00:28:19.466, Speaker F: I could actually report the three things I did that got rejected because I'd.
00:28:19.490 - 00:28:23.906, Speaker D: Sat there for a week going through. I read the docs and I kind.
00:28:23.930 - 00:28:29.760, Speaker F: Of made a mental model of what a user experience, you know, customer experience would be, your customer path.
00:28:29.792 - 00:28:31.320, Speaker D: And then I read, when I started.
00:28:31.352 - 00:28:54.624, Speaker F: Reading the contracts, they didn't actually, they weren't that complex. And it wasn't a massive project, which is good. But then I ended up being able to skip to different parts of the code going, oh, I know where that is, and I know what that does. And going there and going there and then. But then even with all of that, the only reason I went to the oracle stuff is because I came across a report on solo day and I.
00:28:54.624 - 00:28:59.568, Speaker D: Was like, oh, stale liquidity feed using.
00:28:59.616 - 00:29:03.112, Speaker F: The last updated or whatever. I was like, oh, I've seen that.
00:29:03.208 - 00:29:04.312, Speaker D: And then I looked at it and.
00:29:04.328 - 00:29:05.936, Speaker F: That'S when I tried to build from there.
00:29:05.960 - 00:29:08.280, Speaker D: But I know there's been other reports.
00:29:08.352 - 00:29:23.992, Speaker F: That haven't been released yet that have been reported to, but I was like, what am I missing? For me, that's a medium or a high. Why have I not found any lows? You know, why can't I seem to focus on a low where I go? Yeah, you know what? I'm going to look for these lows and then cross them off when I.
00:29:24.008 - 00:29:25.284, Speaker D: Don'T find them as such.
00:29:26.164 - 00:29:38.744, Speaker B: Yeah, yeah, no, sorry, but keep going, man. And you will come to the place that you have reported bugs and hopefully report more, and then some of them will be valid.
00:29:39.364 - 00:29:42.904, Speaker F: Yeah, I don't even mind a dupe, to be honest right now.
00:29:43.924 - 00:29:44.904, Speaker B: That's true.
00:29:45.284 - 00:29:45.940, Speaker F: Thank you, man.
00:29:45.972 - 00:29:46.420, Speaker D: Thanks.
00:29:46.532 - 00:29:47.436, Speaker B: No problem.
00:29:47.620 - 00:30:22.464, Speaker G: I will have something maybe to add to Pangolin's approach. Like, I'm more or less in the same situation. Maybe I've been a little more time coding in solidity. I have more experience there. But I was before when I started in web3 security, I was like, you. Like, I wanted to go like, a straight path, you know, first I'm gonna focus on some lows, then let's search for some maths, mediums and all that. But I ended up, like, not liking that approach because.
00:30:24.204 - 00:30:25.052, Speaker B: First of all, you.
00:30:25.068 - 00:30:45.740, Speaker G: Need to understand, like, this is common to every auditor. I think you need to understand the project, read the docs, read the paper and all that. Okay. You got that? You more or less have a high level view on that. And then you read the code. And as you are reading the code, you might find things that doesn't sound right. Like rings the bell to you.
00:30:45.740 - 00:31:04.316, Speaker G: Like, I read this in the docs and it's not the same in the code. Then my point is, don't go, I need to find first lows and then mediums and all that. You find things and then you decide what severity it has. That's my point. Like, you first need to focus on finding things, whatever they are.
00:31:04.460 - 00:31:05.372, Speaker A: And then you decide.
00:31:05.508 - 00:31:06.740, Speaker F: I agree definitely with that.
00:31:06.772 - 00:31:07.308, Speaker A: Definitely.
00:31:07.396 - 00:31:09.664, Speaker B: Well, that's a very good point.
00:31:11.224 - 00:31:38.284, Speaker G: Yeah, I was in the same point, and just by frustration, I ended up like, fuck it, I'm gonna read and maybe find something. If I don't find anything, then fuck it. And I started like, oh, maybe this is just a low because it only affects this small part of the code. Oh, this. This might be a math because I can write a POC that actually breaks this state variable or whatever, you know. So first find something and then decide on what. What it is.
00:31:44.274 - 00:31:48.414, Speaker B: Are there any other inputs, questions?
00:31:49.234 - 00:32:15.514, Speaker G: Oh, sorry again. It's me. In the formal verification stuff, I didn't interrupt before because I was like, confirming some stuff. I studied something similar in my degree, my computer engineering degree. So a brief overview on what formal verification consists of is something actually misanthropic. Also describe it very, very well.
00:32:17.014 - 00:32:17.614, Speaker A: Solidity.
00:32:17.654 - 00:32:58.904, Speaker G: And any programming language is built upon some rules. That's why we can say whether a programming language is turing complete or not, because it. It has some rules, and we can check these rules. And if they check all the rules, then it's during complete, and if they don't, it isn't. Okay? And every programming language, and actually every program that you write in any programming language, the smart contract, for example, is a subset of the whole language. And this subset of the language can be represented in a mathematical way, but not mathematical, like for every x in the. Whatever.
00:32:58.904 - 00:33:06.984, Speaker G: Also automatas. You know what automata is like, this state transitions and all that?
00:33:10.644 - 00:33:10.980, Speaker A: Yeah.
00:33:11.012 - 00:33:34.982, Speaker G: So an automata is basically a graph, a directed graph that you go from one state to another based on some condition. Okay, that's. That's an automata. And you can imagine it. Yeah. Just like a graph. Like circles that are joined with some arrows, and each circle represents a state of the program.
00:33:35.118 - 00:33:35.870, Speaker A: Okay?
00:33:36.022 - 00:33:57.444, Speaker G: So every program can be also represented like that. And those, those graphs, those automatas also must comply to some rules. So for multiplication is making sure that those rules are being like, done, you know, explain myself.
00:34:00.624 - 00:34:08.884, Speaker E: I mean, I understand there's a way to translate the application into a represent mathematical representation that can be verified easily.
00:34:11.224 - 00:34:11.632, Speaker A: Yes.
00:34:11.688 - 00:34:21.344, Speaker E: Tricky stuff. I mean, three D. I don't know if you have to go. I'm gonna just keep on the group talk here, here, because it's okay. Nice for us to talk about, which is auditing and everything.
00:34:22.564 - 00:34:24.744, Speaker B: I have 15 more minutes.
00:34:25.404 - 00:34:26.012, Speaker F: Awesome.
00:34:26.108 - 00:34:28.424, Speaker E: Muhab, you want to add anything? You have more experience.
00:34:47.264 - 00:34:57.284, Speaker C: Thank you for explaining the formal verification. If you have some time, maybe some other day. You can. You can give us a demonstration for the formal verification process.
00:34:57.704 - 00:35:02.240, Speaker A: And I think that's it for now. Thank you.
00:35:02.392 - 00:35:04.444, Speaker C: Thank you for the presentation too.
00:35:05.264 - 00:35:06.444, Speaker A: It was really good.
00:35:07.144 - 00:35:09.160, Speaker B: Thank you very much. You guys are welcome.
00:35:09.232 - 00:35:44.532, Speaker A: It just, just a question.
00:35:44.708 - 00:35:51.940, Speaker C: What's your, what's your name? What should we call you? It's a, it's a really long name. Yeah.
00:35:52.132 - 00:35:53.100, Speaker G: Okay.
00:35:53.292 - 00:35:54.504, Speaker E: My name is Alex.
00:35:56.284 - 00:35:57.104, Speaker A: Alex.
00:35:59.724 - 00:36:39.288, Speaker B: Okay. I have actually a question because I'm just doing c four now at the code for arena. But I was wondering, I was looking at immunify and then I saw like most of the contracts, they are live at like Etherscan or whatever blockchain they're based in. So I was just wondering like to download the code basis or making like a file list. What do you guys do? Do you like, copy it off ether scan or is it an easier way to get the contracts? Depth of ether?
00:36:39.376 - 00:36:40.524, Speaker E: Do you know this website?
00:36:41.544 - 00:36:41.904, Speaker A: No.
00:36:41.944 - 00:36:43.080, Speaker B: Can you write.
00:36:43.272 - 00:36:49.564, Speaker E: Oh, you guys gonna love this shit. Can you let me just find it? I just need to find it.
00:36:52.944 - 00:36:53.424, Speaker C: Come on.
