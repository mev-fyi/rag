00:00:02.080 - 00:00:06.154, Speaker A: How's it going, humiliated master?
00:00:07.174 - 00:00:09.474, Speaker B: Okay, it's going good.
00:00:10.094 - 00:00:14.234, Speaker A: So yesterday you just got that audit. Easy like that.
00:00:15.014 - 00:00:20.434, Speaker B: Yes, it was the biggest news of solid history.
00:00:21.974 - 00:00:40.084, Speaker A: Fucking amazing. Bruno, I was super excited to do the audit here, but. But, you know, I'm still going to do it, but we're probably going to fail hard. The good thing is, now you have the. As you're going to have the audit, we're going to be able to compare, you know, our result with whatever happened on the audit.
00:00:40.744 - 00:00:45.724, Speaker B: I'm very afraid that they find some critical bug and I'm still going to be screwed, man.
00:00:46.424 - 00:01:00.028, Speaker A: No, but that's okay, that's okay, that's okay. I mean, I was thinking that with the solidi lipo, at least it's easy to test, you know, because, well, you can further, you know, the limits for everything.
00:01:00.116 - 00:01:04.508, Speaker C: You know, every file is like on its own, right?
00:01:04.556 - 00:01:07.156, Speaker B: It's like not ten files interacting with.
00:01:07.180 - 00:01:09.704, Speaker C: Ten other files in square.
00:01:10.844 - 00:01:32.150, Speaker A: Yeah, I mean, maybe. I think it's gonna be nice. It's gonna be a nice challenge for us, you know, at least for me to learn something, because this cannot be complicated, right? This is so easy, right? So we just, like, multiplying bytes. We're not really doing any math, you know, mostly copying some algorithm, like you told me yesterday, you know, maybe except.
00:01:32.182 - 00:01:36.914, Speaker B: For a bit of the fixed math, like fixed point math library.
00:01:37.814 - 00:01:38.446, Speaker C: Oh, wait, wait.
00:01:38.470 - 00:01:39.822, Speaker B: Let me, let me share my screen.
00:01:39.878 - 00:01:44.674, Speaker A: Yeah, let's. Let's start. Let me entire screen.
00:01:46.774 - 00:02:01.294, Speaker B: Uh, my computer is quite a old computer, so if I lag out, please, please, if somehow my voice breaks, just tag me in the main chat. Okay?
00:02:03.794 - 00:02:05.186, Speaker A: Awesome, awesome.
00:02:05.370 - 00:02:11.994, Speaker B: Yeah, yeah. I'm very afraid that my, my Internet or my computer hangs or some shit.
00:02:12.154 - 00:02:13.090, Speaker C: And I don't know.
00:02:13.162 - 00:02:25.604, Speaker B: Okay, so if anything, if my voice paused for more than, like 10 seconds or 30 seconds, just tag me. Okay. Yeah. Are you seeing my screen? Like, am I scrolling the slides?
00:02:25.904 - 00:02:29.164, Speaker A: Yeah, we are seeing both this card and the slides.
00:02:29.984 - 00:02:30.504, Speaker C: Okay.
00:02:30.544 - 00:02:36.404, Speaker B: Okay. That's. I just maximize the slides.
00:02:38.664 - 00:02:39.764, Speaker A: Yes, nice.
00:02:40.624 - 00:02:51.788, Speaker B: Of course, we are on solid. Okay, so let me see. We just grow. Okay. Disclaimer. Disclaimer. Just have to say.
00:02:51.788 - 00:02:59.944, Speaker B: Okay. Okay, so some pre registics, what is prerequisite sticks? Show single page.
00:03:00.444 - 00:03:05.224, Speaker C: Ah, okay, because, um, there's no time to repeat everything.
00:03:05.684 - 00:03:07.324, Speaker B: I have to assume that you, you.
00:03:07.364 - 00:03:12.864, Speaker C: Guys know a bit of no in night assembly?
00:03:14.004 - 00:03:15.744, Speaker A: Yeah, yeah, we know a little bit.
00:03:16.124 - 00:03:26.664, Speaker B: Yeah. Okay, what happened? Okay, so these two numbers, zero x 40 and zero x 60. I.
00:03:27.164 - 00:03:29.020, Speaker C: So this is the free memory pointer.
00:03:29.092 - 00:03:42.104, Speaker B: This is the zero pointer. I think if you don't know, let me know. Okay. Then I know how to go slower. Okay, you know how strings, bytes and arrays are represented in memory?
00:03:43.044 - 00:03:43.684, Speaker A: Yes.
00:03:43.804 - 00:04:20.548, Speaker B: If you don't know how they are represented in storage, call data is okay. I sometimes also forget, then I have to like use remix and debug. Okay. And you know, it's openzepkin and stormy, because you need, you need to know like what, what are the original implementations, what they do, what they didn't do. Yes. Okay, so, okay, philosophy about solely is kind of like a martial art. Like some things, some magic numbers, they serve multiple purpose, some tricks.
00:04:20.548 - 00:05:01.564, Speaker B: I use the custom storage layout. It's a single move that achieves multiple objectives by attack and defend at the same time. So in solidity, in inline assembly, you have to clean the upper bits of addresses. So you know, addresses are 160 bits, the solidity word is 256 bits. All the variables is 256 bits. So the upper 96 bits, if they are dirty, shit will happen and you have to clean it. So sometimes I will use advanced tricks to auto clean the upper 96 bits in a single move and also store the variable in storage.
00:05:03.534 - 00:05:08.914, Speaker A: You take a lot of inspiration, right? To do those, you take a lot of inspiration from other languages, right?
00:05:09.654 - 00:05:19.314, Speaker B: Yes, I think C a bit, python a bit. I don't have a fixed language per se, but I optimize.
00:05:21.534 - 00:05:24.274, Speaker C: Pretty much many things.
00:05:25.694 - 00:05:33.988, Speaker B: But now solidity is the juicy thing because it's real dollars and cents. You can see optimize the front end.
00:05:34.036 - 00:05:37.644, Speaker C: People, just maybe the slower computers feel.
00:05:37.684 - 00:05:40.224, Speaker B: Faster and that's all. Yeah.
00:05:42.884 - 00:05:44.724, Speaker C: Nice. Yeah.
00:05:44.764 - 00:05:49.924, Speaker B: So sometimes it's like, you know, EVM is very constrained.
00:05:50.004 - 00:05:52.860, Speaker C: There's only so many things you can.
00:05:52.892 - 00:05:58.544, Speaker B: Do with all those bytecodes, and sometimes you have to be a bit creative with how you use the bytecode.
00:06:00.514 - 00:06:06.134, Speaker C: I will show two lines. Okay.
00:06:06.754 - 00:06:10.642, Speaker B: Freestyle. Sometimes it's general knowledge, like some of.
00:06:10.658 - 00:06:15.186, Speaker C: The, sometimes it come up with ideas.
00:06:15.250 - 00:06:30.302, Speaker B: I don't know where it comes from. Maybe it came from a bit of this and that. Yeah, but you have to know a bit of everything to, to combine moves together.
00:06:30.398 - 00:06:41.446, Speaker C: You know, combine, combination, inspiration from everywhere. Okay, so background why I started soul.
00:06:41.470 - 00:07:07.754, Speaker B: Lady in July 2022. So there was this soulmate, there was this open zeppelin. Open zeppelin is like general library. Everyone use them. Most of the time they only use 20% of open sapling. And Solmake is like a very minimalist library, very hard to add things in. So I find that there is a middle ground somewhere.
00:07:07.754 - 00:07:12.874, Speaker B: There's a vacuum in the market that.
00:07:14.254 - 00:07:15.514, Speaker C: Is good to feel.
00:07:16.174 - 00:07:23.940, Speaker B: So I don't put all these crazy assembly into open zeppelin, because open zeppelin is for, is for wide audience, it's.
00:07:23.972 - 00:07:33.900, Speaker C: For readability, audiority, where soulmate is for minimalism. So I can't find a place to.
00:07:33.932 - 00:07:37.304, Speaker B: Put all this new stuff. So that's why I create soul lady.
00:07:37.844 - 00:07:40.012, Speaker C: And there's no meme.
00:07:40.148 - 00:07:50.220, Speaker B: I love you. This is a mid lady meme. Okay, so just run down some of the philosophy on how I write.
00:07:50.252 - 00:07:53.956, Speaker C: So lady, in solidity you have to.
00:07:53.980 - 00:08:04.988, Speaker B: Balance between two things. One time guess and bytecode size. For example, you want to clean the upper bits of addresses. You can mask with a 160 bit.
00:08:05.116 - 00:08:09.092, Speaker C: Number, which is like very big in bike code size.
00:08:09.148 - 00:08:35.544, Speaker B: Or you can do a shift left and then shift right by 96, which is lesser bike code. Then also solely tries to minimize dependencies. Like you know, NPM projects, node projects, they have like one dependent, they have like thousands of dependencies that have thousands of other dependencies. So lady, the only dependency is.
00:08:39.404 - 00:08:40.196, Speaker C: Not a lot.
00:08:40.260 - 00:08:43.664, Speaker B: There is, let me see, there's foundry.
00:08:44.144 - 00:08:54.688, Speaker C: There is DS test, which stands for DX two something something.
00:08:54.776 - 00:09:26.154, Speaker B: It's a very ancient testing stuff. Okay, I think pretty much that's it. The libraries are like right, independent. And third is like we try to make the API as need as nice to use as possible. So inside is all those crazy logic, but outside it feels easy to use like you are using some high level language. You don't need to worry too much.
00:09:27.774 - 00:09:33.830, Speaker C: So the idea is. So lady helps you write lesser assembly.
00:09:33.902 - 00:09:35.394, Speaker B: In high level logic.
00:09:36.014 - 00:09:38.110, Speaker C: So when you write a high level.
00:09:38.262 - 00:09:57.106, Speaker B: Protocol, you don't want to pollute your high level code with all those assembly. If not, your reviewers or auditors will have a harder time reading. So solidly tries to wrap up all the assembly inside a library.
00:09:57.250 - 00:09:59.898, Speaker C: Then you can just import, write a.
00:09:59.906 - 00:10:07.330, Speaker B: Few lines and call it a day. You copy and paste the assembly. Your project will have a lot of.
00:10:07.362 - 00:10:09.764, Speaker C: Extra code, a lot of build.
00:10:09.924 - 00:10:11.624, Speaker B: So yeah, everything.
00:10:12.044 - 00:10:20.500, Speaker C: Try to modularize, print solidly. Okay, so these are all the files.
00:10:20.612 - 00:10:22.676, Speaker B: I think there's a new file called Libc.
00:10:22.860 - 00:10:27.264, Speaker C: Anyway, the thing is that if you.
00:10:27.604 - 00:10:53.924, Speaker B: Do a text find of what files import other files, you find that there is no, but every file is very self contained. So this means that if you have a team of 20 auditors, you can give one file to each auditor and tell them to audit in parallel. Makes things efficient. Every file is independent.
00:10:55.424 - 00:11:08.364, Speaker A: Don't we have more files that are more critical for auditing that files that, you know, like maybe the base 64 library or the Lib zip library. You know what are the best libraries to start auditing so lately?
00:11:10.024 - 00:11:14.192, Speaker C: Okay, I will explain in the next slide.
00:11:14.288 - 00:11:31.242, Speaker B: So some of the files I am a bit more confident because I use in my work exam XYZ. I asked the viewers to look through them. Some of the files are new.
00:11:31.418 - 00:11:35.254, Speaker C: So for a full audit the three.
00:11:35.674 - 00:11:42.494, Speaker B: Most urgent files are the tokens. Because tokens have state.
00:11:42.794 - 00:11:43.754, Speaker C: Not like libraries.
00:11:43.794 - 00:11:55.890, Speaker B: Libraries don't have state so it's easier to fastest, but tokens have state and if I scrub a custom mapping shit will happen. So I highly feel that tokens should.
00:11:55.922 - 00:11:59.404, Speaker C: Be audited first and after that the.
00:11:59.444 - 00:12:03.744, Speaker B: Most important libraries like safe transfer leak. See whether there's any memory.
00:12:05.804 - 00:12:06.944, Speaker C: Memory issues.
00:12:07.484 - 00:12:36.808, Speaker B: Fully, not because a lot of people look through it. ERC 1967 factory this one hasn't been widely adopted because people feel a bit less adventurous. But actually from a first principal's point of view it is superior to any of the current existing upgradable proxies approach. There's a signature checker lead which is related to ECDSA.
00:12:36.976 - 00:12:38.764, Speaker C: It's a Mercur proof leak.
00:12:39.344 - 00:12:45.644, Speaker B: These two I'm pretty confident, but I just want to double check because many people use it.
00:12:46.024 - 00:12:56.774, Speaker C: It's very critical in many code IP 712 also worth checking out whether it has any bugs.
00:12:58.634 - 00:13:04.098, Speaker B: I'm also pretty confident, but just, just to be safe, you know, one question.
00:13:04.266 - 00:13:14.414, Speaker A: One question reacts during your job, during your time working at sound waxy, do you just got the time to work on solid? Did they just gave you some research time or you did that on your free time?
00:13:15.754 - 00:13:24.322, Speaker B: Okay, let me talk about my boss. So my boss, his name is David Greenstein and yeah, he's a super nice.
00:13:24.378 - 00:13:34.890, Speaker C: And very base person. He's a very cool person. So when he hire people, he has.
00:13:34.922 - 00:13:54.754, Speaker B: This philosophy of hire across the whole world. Don't just hire in LA, SF or NYC, although he's in NYC, hires across the whole world. So we have people from Poland, we have people from like me in Singapore, and we have people from.
00:13:58.014 - 00:13:58.998, Speaker C: Taiwan.
00:13:59.166 - 00:14:12.406, Speaker B: Actually wasn't from Taiwan, he moved to somewhere in Europe. So we have people from all over the world, okay? And have like very diverse team, higher base of marriage. But our team is like very diverse.
00:14:12.430 - 00:14:19.690, Speaker C: Because we, they open, okay, and how.
00:14:19.722 - 00:14:25.374, Speaker B: We hire is how sound XYZ hire we load based on the GitHub contributions.
00:14:27.274 - 00:14:31.322, Speaker C: And GitHub contributions means a lot of.
00:14:31.338 - 00:14:35.734, Speaker B: The people we hire are very prominent open source contributors.
00:14:38.274 - 00:14:41.374, Speaker A: Do you usually take parts in the interviews?
00:14:44.384 - 00:14:49.928, Speaker C: They're not hiring smart contract guys. Right now they are hiring.
00:14:49.976 - 00:15:03.696, Speaker B: Maybe, I think back in full stack. The kind of guys. Yeah. So the thing about sound is that, you know, you don't need ten people to write a protocol. You just need one or two guys.
00:15:03.880 - 00:15:07.312, Speaker C: Right. You get it.
00:15:07.328 - 00:15:11.564, Speaker B: It's like, how many ways are you going to rewrite a Mercur proof lead?
00:15:11.994 - 00:15:13.734, Speaker A: Yeah, yeah, I do get it.
00:15:15.474 - 00:15:16.162, Speaker B: Yeah.
00:15:16.298 - 00:15:26.574, Speaker A: At the same time, the work that these guys doing are kind of challenging, you know, because you guys are doing nfts. Gotta be super optimized. So, you know, getting these guys is not easy. Hiring at the level is not easy.
00:15:28.074 - 00:15:28.722, Speaker B: Once.
00:15:28.858 - 00:15:32.290, Speaker C: Yeah, they need to refresh.
00:15:32.322 - 00:15:39.014, Speaker B: Refresh. If you refresh a code too often people, people will cry like, blockchain is not meant to be mutable.
00:15:40.974 - 00:15:43.062, Speaker C: You can upgrade your contracts, but that.
00:15:43.078 - 00:16:03.086, Speaker B: Is not a very nice pattern, you know, like upgrading. Although there's upgraded upgrading stuff down here, like 196 and factory. If you can make your up, you can make your contracts non upgradable is still better. That's my, my feel. So try to consolidate your changes to.
00:16:03.110 - 00:16:06.394, Speaker C: Contracts like once every few months.
00:16:06.754 - 00:16:19.014, Speaker B: Make sure your contracts are very properly reviewed. And you have to think a bit future proof of contracts. A bit. Think about what are the future use case so that you don't need to change too much.
00:16:19.714 - 00:16:29.414, Speaker A: What is the problem, VX, with the current proxy implementation of the diamond stand there because I know you guys are not reading favor of it.
00:16:30.314 - 00:16:41.300, Speaker B: I'm not an expert in diamond, so I don't comment too much. Maybe I give two opinions on diamonds.
00:16:41.332 - 00:16:46.540, Speaker C: That might not be true for all cases. So.
00:16:46.612 - 00:16:50.612, Speaker B: Okay, one thing is that diamonds, you know, the storage might overlap.
00:16:50.668 - 00:16:54.164, Speaker C: So auditing, yeah, it takes more effort.
00:16:54.204 - 00:16:56.052, Speaker B: You have to, the auditors have to.
00:16:56.188 - 00:17:04.576, Speaker C: Let'S say there are ten facets. So. And it can be like the amount.
00:17:04.600 - 00:17:32.344, Speaker B: Of interactions is n squared. So ten times ten divided by two pairs. So the amount of facets grow. The amount of interactions grow in terms of n squared. So to make a very thorough audit, it does not scale very well. You know, it's quite hard to audit nature because it's too flexible.
00:17:36.004 - 00:17:37.180, Speaker C: That's awesome.
00:17:37.252 - 00:17:37.708, Speaker A: Awesome.
00:17:37.796 - 00:17:38.020, Speaker B: Sorry.
00:17:38.052 - 00:17:40.276, Speaker C: Contraption vex, can you, can you move.
00:17:40.300 - 00:17:41.996, Speaker B: Your cursor across the screen?
00:17:42.060 - 00:17:48.584, Speaker C: I think the slides are freezing. Yeah. Do you see guys? Because the guy said, like, yeah, it's all good.
00:17:48.884 - 00:17:52.372, Speaker A: No, everything's worth vex connection.
00:17:52.428 - 00:17:57.746, Speaker C: Sometimes, like, the sound is like glitching not only for me, but for the other guys.
00:17:57.930 - 00:17:58.466, Speaker A: Yeah.
00:17:58.570 - 00:17:59.334, Speaker B: Okay.
00:18:00.874 - 00:18:03.174, Speaker A: Keep on, keep on, keep on, keep on.
00:18:04.034 - 00:18:08.962, Speaker C: Okay. So. Oh, I will tell.
00:18:09.018 - 00:18:10.506, Speaker B: I will talk about the 196 sound.
00:18:10.530 - 00:18:13.314, Speaker C: Factory like in five minutes.
00:18:13.354 - 00:18:14.014, Speaker B: Okay.
00:18:16.474 - 00:18:17.214, Speaker C: So.
00:18:19.234 - 00:18:35.704, Speaker B: Ladies, testing is a bit unique because of how heavy assembly is used. So we do some extra tests, like brutalizing the memory, brutalizing the beats. We also test with extra paranoia.
00:18:36.564 - 00:18:38.044, Speaker C: We try to make a test as.
00:18:38.124 - 00:18:41.244, Speaker B: Fast, as fast testing as possible.
00:18:41.324 - 00:18:44.876, Speaker C: As much fast testing because, like, we.
00:18:44.900 - 00:18:47.064, Speaker B: Don'T know what we don't know, you know?
00:18:49.044 - 00:18:52.604, Speaker C: Of course we write unique and h test, but it will write.
00:18:54.624 - 00:18:56.564, Speaker B: Most of it is in fast testing.
00:18:57.144 - 00:19:03.640, Speaker C: And we test until we are very sure. Before we merge the p's, we also.
00:19:03.712 - 00:19:16.044, Speaker B: Consider the adversarial conditions, like what if the free memory pointer is not aligned? What if the. Okay, a lot of what if conditions.
00:19:20.604 - 00:19:23.364, Speaker C: Parameters, patterns.
00:19:23.404 - 00:19:27.664, Speaker B: Patterns. So they tries to be flexible, fast.
00:19:28.564 - 00:19:37.252, Speaker C: And everything except for easy to read. Okay, so for flexible, how we provide.
00:19:37.308 - 00:20:11.824, Speaker B: It is that all our contracts are upgradable by default. But you have to read the next step. Okay? Just read the next pack. If you try to use it in upgradable contracts that none of the contracts in Solidi have constructed with arguments because we want out of the box compatibility with clones, upgradable proxies, etcetera. We also heavily abuse custom storage layouts. We craft our own storage layout that.
00:20:13.284 - 00:20:22.118, Speaker C: Somehow abuses the way store memory in.
00:20:22.126 - 00:20:32.990, Speaker B: The scratch space to clear the upper 96 bits of addresses. And the way we clear upper 96 bits, there's no single fixed ways.
00:20:33.062 - 00:20:36.434, Speaker C: Depending on the circumstances.
00:20:37.414 - 00:20:41.206, Speaker B: We use different opportunities to do different tricks.
00:20:41.390 - 00:20:46.114, Speaker C: Is most suited for specific cases.
00:20:49.934 - 00:21:03.874, Speaker B: And there is a lot of OCD things in the sole ad. Like our comments. We have to end them with a full stop variable. Names. Comments must be enclosed within backticks.
00:21:06.374 - 00:21:06.726, Speaker C: Okay.
00:21:06.750 - 00:21:09.194, Speaker B: All these are just like OCD stuff.
00:21:13.394 - 00:21:17.234, Speaker C: So the idea is that if the.
00:21:17.274 - 00:21:22.174, Speaker B: Code feels good, you will naturally make less mistakes.
00:21:23.354 - 00:21:24.214, Speaker C: Okay.
00:21:28.314 - 00:21:29.234, Speaker B: There is a lot of things.
00:21:29.274 - 00:21:34.094, Speaker C: To say about this, so if you want, I can.
00:21:34.554 - 00:21:41.014, Speaker B: You can ask me questions. But anyway, this is just a lot of conventions, right?
00:21:41.174 - 00:21:46.034, Speaker A: So Kira. Kira. Headers are centered, left. What is Kirakira? Headers, please.
00:21:46.414 - 00:21:54.314, Speaker B: Okay, so our soul lady has a very cute looking headers. A lot of stars. Shiny.
00:21:54.774 - 00:21:55.554, Speaker A: Nice.
00:21:56.014 - 00:22:01.550, Speaker B: Okay, so the text is centered, but.
00:22:01.582 - 00:22:10.622, Speaker C: Let'S say if the left have ten space and the red has a ten space, the text isn't like centered.
00:22:10.798 - 00:22:25.074, Speaker B: We will put one space to the right instead of to the left. So basically some. All these small comments like how you align them. We care the small details even.
00:22:25.774 - 00:22:30.114, Speaker A: Can you talk a little bit about. Don't constrain your thoughts to the limits of the english language.
00:22:32.164 - 00:22:34.812, Speaker C: Okay, yeah, this, this is a thing.
00:22:34.868 - 00:22:51.236, Speaker B: I have been thinking about, like, okay, I've seen seaport, and seaport, they have a convention that they try to give every constant english name. I was thinking like, yeah, I kind.
00:22:51.260 - 00:22:59.200, Speaker C: Of get it, but why, why should I restrict my thinking to realms of.
00:22:59.232 - 00:23:05.644, Speaker B: What english language can express? What if I have a new concept that I can't find an english word to express?
00:23:06.784 - 00:23:07.524, Speaker C: So.
00:23:09.424 - 00:23:28.684, Speaker B: Mathematics, that's why we have mathematical notation, because somehow the english words cannot succinctly express the high level abstract concepts. I think that this is quite true of highly logical subjects like programming. So there are some constants that you just cannot find the words to explain them.
00:23:28.724 - 00:23:31.132, Speaker C: You just, just have to hard code.
00:23:31.148 - 00:23:46.824, Speaker B: The constant down there. Right there. And for people to understand that this is a magic number, that people have to be careful because it is something that is original. There's no english words to describe it yet.
00:23:50.664 - 00:23:51.804, Speaker A: Amazing, bro.
00:23:55.624 - 00:23:57.832, Speaker B: Okay, then I think this is the.
00:23:57.848 - 00:23:59.976, Speaker C: Last slide for memory.
00:24:00.040 - 00:24:09.040, Speaker B: We try to play it. Okay, there is this Joe x 40 and Joe x 60. We abuse it to store some temporary.
00:24:09.112 - 00:24:12.808, Speaker C: Variables, but we always restore it if.
00:24:12.936 - 00:24:24.430, Speaker B: We do not direct return from the function. Okay, but never mind. Anyway, the point is, although the official documentation says that we are not supposed.
00:24:24.462 - 00:24:28.230, Speaker C: To write over them, the practice is.
00:24:28.262 - 00:25:04.504, Speaker B: Actually safe because the solidity compiler won't modify these two slots in the middle of an assembly block. Let's say if the solidity compiler modifies it, it will cause catastrophic damage even to code with. Okay, so if the compiler somehow breaks this, breaks this rule, even if you don't mark it with memory safe, shit will happen. So by logical deduction, you can deduce that it must be safe.
00:25:06.284 - 00:25:10.584, Speaker C: Okay, if an SMB block temporary use.
00:25:11.004 - 00:25:40.024, Speaker B: Envelope, we do not mark it as safe. Memory safe should be memory. Sorry. Memory safe. Okay, this one is just like some aesthetic thing. It's not for safety, it's more for aesthetic, because some front ends, they have issues displaying strings and bytes, but at the end of the name they have some weird characters. It's not a safety issue, more like.
00:25:41.684 - 00:25:43.812, Speaker A: More of a conventional thing. I understand.
00:25:43.988 - 00:25:44.460, Speaker C: Yeah.
00:25:44.532 - 00:26:00.784, Speaker B: For making our library friendly towards some front ends. These front ends are like the old Etherscan UI. Now, the new etherscan UI fixed the bug, so it's okay. The old Etherscan Ui had some bugs with some SMB strings.
00:26:03.664 - 00:26:12.004, Speaker A: Awesome, bro. Can you talk a little bit about lib zip and how that can make out shoes three times faster and lighter?
00:26:15.624 - 00:26:30.104, Speaker B: Okay, let's see the code right now. Okay, let's jump to the code. I think I zoom in a bit. Source.
00:26:33.124 - 00:26:38.224, Speaker C: I think it's utilities. I think it's called leap zip.
00:26:38.524 - 00:26:42.724, Speaker B: Okay, this library is a very powerful.
00:26:42.764 - 00:26:52.436, Speaker C: Library for l two, actually. All these like flz, flz stands for fast lz.
00:26:52.540 - 00:27:16.076, Speaker B: It's a LZ 77 implementation. This is more for like compressing and decompressing on chain svgs or on chain bitmaps for those like fancy nfts, that is, they like to boast its on chain. Yeah, they can use this shit. Okay. But the important part of the library is the core data compressed and decompressed.
00:27:16.260 - 00:27:17.104, Speaker C: Okay?
00:27:18.444 - 00:27:27.772, Speaker B: So the thing is, I have a contract down here. Contract is very simple. Okay, okay, here is deep zip. Ignore it.
00:27:27.868 - 00:27:42.954, Speaker C: The contract is full screening. I zoom in a bit more. Okay, so basically there's some storage variables.
00:27:43.294 - 00:27:49.834, Speaker B: And there are some function I pass in an array of numbers.
00:27:56.474 - 00:27:57.454, Speaker C: Okay?
00:27:58.474 - 00:27:59.214, Speaker B: So.
00:28:02.034 - 00:28:27.278, Speaker C: The thing is, if you call this function cost transaction on optimism or other l two s, like arbitrum, is alternate by size of these numbers, I explained. So two transactions, one is the compressed.
00:28:27.366 - 00:28:29.274, Speaker B: And one is the non compressed.
00:28:29.734 - 00:28:32.834, Speaker C: Okay, let's look at the non compressors.
00:28:34.934 - 00:28:47.714, Speaker B: It costs $3.50, so it call the store number hash. It has all these fancy huge s core data, very big core data.
00:28:49.454 - 00:28:49.742, Speaker C: And.
00:28:49.758 - 00:28:54.848, Speaker B: It costs $3.05 if I use deep zip.
00:28:55.006 - 00:28:58.740, Speaker C: See the cost $0.63.
00:28:58.932 - 00:28:59.704, Speaker A: Wow.
00:29:01.004 - 00:29:04.916, Speaker B: I compress the core data. So instead of passing this whole chunk.
00:29:04.980 - 00:29:06.864, Speaker C: Here, it becomes.
00:29:08.804 - 00:29:11.784, Speaker A: What is the algorithm of this compression?
00:29:13.404 - 00:29:17.188, Speaker C: Oh, it's uh, this and this.
00:29:17.316 - 00:29:17.988, Speaker B: Krabby.
00:29:18.076 - 00:29:25.080, Speaker C: Krabby is a very awesome, important programmer at optimism.
00:29:25.272 - 00:30:00.384, Speaker B: He won the recent if global hackathon with the op compressor. So we discussed how to save the core data compressing it. So he has this amazing idea that we can use round length encoding on the zero bytes, because zero bytes are the most common bytes in solidly. Coredata. What I mean is like, you see all this zero down here and this is zero bytes. So I improved upon the algorithm by also compressing the ff bytes. Because ff bytes are the second most common.
00:30:00.384 - 00:30:12.164, Speaker B: Most people always pass in the like, you have to approve maximum amount of tokens you pass in f all the way. So I compress the zero bytes and the ff bytes.
00:30:13.684 - 00:30:15.420, Speaker C: So I do the run dang encoding.
00:30:15.452 - 00:30:34.756, Speaker B: Of zero and the ff. So there's also one trick in the CD CD compress. So after I compress, I also flip the first four bytes so that it won't collide with any function selector.
00:30:34.900 - 00:30:43.106, Speaker C: Then it will so called function dispatch in the contract will pass the compressed.
00:30:43.130 - 00:30:50.614, Speaker B: Call data to the CD fallback and it will uncompress, decompress the core data and dedicate core to itself.
00:30:51.074 - 00:30:58.374, Speaker C: So this way, let's see the contract again. Okay.
00:30:59.594 - 00:31:05.946, Speaker B: You just need to override these two functions and call deep zip CD fallback.
00:31:06.010 - 00:31:11.384, Speaker C: And a contract is instant compatible with compressed core data.
00:31:12.284 - 00:31:18.064, Speaker B: You can save, you can save some serious money on amazing stuff, man.
00:31:18.444 - 00:31:33.864, Speaker A: I mean, just coming up with these ideas sounds quite crazy. The idea that I can compress bytes to make calls cheaper, I mean, this like, looks to me like some sort of evolution of whatever multi call we have today, you know?
00:31:34.464 - 00:31:35.244, Speaker C: Yeah.
00:31:35.544 - 00:31:40.328, Speaker B: Okay, I need to show something like l one gas, right? There's the l two gas and the l one gas.
00:31:40.376 - 00:31:44.352, Speaker C: Okay, this is what you have to pay attention to.
00:31:44.408 - 00:31:55.924, Speaker B: L1 gas used by transaction is seven k. And I think this is thirty six k. I think with EIP 4844, this one would drop drastically.
00:31:56.984 - 00:32:03.244, Speaker C: But, you know, if everyone has the same like.
00:32:05.224 - 00:32:14.504, Speaker B: Cost drop by ten times or 50 times, then people start spamming the network. So the person who have the more.
00:32:14.544 - 00:32:18.496, Speaker C: Optimized code will help the customers save.
00:32:18.560 - 00:32:44.374, Speaker B: The money because all the gas costs suddenly drop today. Then people will start spamming the network. People buy more shitcoins, buy more, trade more nfts, and then the gas price will go up. So having the more efficient core data or the more efficient contract will make your customers, you know, enjoy the game for longer. Enjoy the game longer.
00:32:44.794 - 00:32:45.490, Speaker C: Yeah.
00:32:45.642 - 00:32:55.654, Speaker A: Makes a lot of sense, bro. I have a few questions for people here. The first is it's already been used in production by some project.
00:32:57.854 - 00:32:58.914, Speaker C: Oh yeah.
00:33:01.734 - 00:33:09.394, Speaker B: I think most prominently is sound. Sound XYZ. But I work at.
00:33:12.054 - 00:33:12.686, Speaker C: I'm not sure.
00:33:12.710 - 00:33:14.634, Speaker B: Where Opensea use it. I haven't checked.
00:33:15.774 - 00:33:19.274, Speaker A: I think milady. Milady uses it dotted.
00:33:20.414 - 00:33:27.186, Speaker B: Yeah, the bonkers. But that is by me, so that's not considered. Okay. Okay.
00:33:27.370 - 00:33:27.746, Speaker C: Okay.
00:33:27.770 - 00:33:30.854, Speaker B: It's production. But I'm trying to think of other.
00:33:31.714 - 00:33:41.334, Speaker C: People who are not me, geo experts. I think their upcoming contracts might use our leap clone.
00:33:42.274 - 00:33:50.974, Speaker B: There is optimism, bedrock. I think they might. I don't know, I forgot which part of solely, but a small part.
00:33:53.874 - 00:34:34.634, Speaker A: Okay, I don't really get your question here, team. So Tim is saying, is saving guys always memory performance? So let's say I save 2%, guys like increasing 50% in performance. I don't really get the question. If you want to open your mic team, and talk. Another question that I have is from atapara and he's saying when I write a new Librium solely, what is your thought process, you know, to make it as optimized as possible?
00:34:38.574 - 00:34:39.354, Speaker C: Oh.
00:34:43.654 - 00:35:03.503, Speaker B: This is a case saving always. Okay, I answer team's question first. Okay, so in, in the, in the EVM.
00:35:05.203 - 00:35:07.827, Speaker C: Yeah, memory is being text also.
00:35:07.995 - 00:35:18.204, Speaker B: So there's this thing called a memory expansion cost. Every extra byte of memory that you first access, you will be charged a certain amount of gas.
00:35:19.104 - 00:35:24.432, Speaker C: So that means if your solidity code.
00:35:24.488 - 00:35:54.714, Speaker B: Takes up a lot of memory to run on all those validators, you will be charged quite a lot of gas. And this cost, called the memory expansion cost, grows quadratically. So you have to guess. Saving is always like, it's kind of proportional to how well your algorithm runs on the validators.
00:35:57.414 - 00:36:02.874, Speaker C: Okay, I answer Atapara question.
00:36:04.954 - 00:36:06.654, Speaker B: What is my thought process?
00:36:08.514 - 00:36:09.374, Speaker C: Okay.
00:36:12.114 - 00:36:19.410, Speaker B: There is this PDF called advice to a young mathematician. So, the idea is that sometimes you.
00:36:19.442 - 00:36:23.730, Speaker C: Have the gut feel that you go.
00:36:23.762 - 00:36:28.374, Speaker B: In a certain direction, you can find some improvements.
00:36:28.834 - 00:36:34.424, Speaker C: So sometimes you have to train your gut feel.
00:36:34.804 - 00:36:49.264, Speaker B: Your gut feel is not 100% correct. You need to know when you can trust it, when you cannot. So sometimes when I write an algorithm and it just looks wrong to me, I know that there's some part that can be optimized.
00:36:53.804 - 00:36:55.436, Speaker C: I will just try my best to.
00:36:55.460 - 00:37:07.224, Speaker B: Hunt for the hunt for where I can optimize it. The algorithm looks correct to looks optimized to me, then I know I'm more or less at the point of diminishing returns.
00:37:12.124 - 00:37:17.820, Speaker C: Okay. Okay.
00:37:17.852 - 00:37:22.764, Speaker B: Actually, I do think that if you deploy on l two s, most of.
00:37:22.804 - 00:37:27.240, Speaker C: The guests problems can be solved, and.
00:37:27.312 - 00:37:36.684, Speaker B: L two s will become, like, much more scalable when this AIP 4844 hits the market. Right now, coredata costs.
00:37:38.584 - 00:37:39.520, Speaker C: Four gwei per.
00:37:39.552 - 00:37:59.064, Speaker B: Zero byte, and I think 16 gwei per non zero byte. I think next time you'll be. Some people say it's 50 times cheaper, so it would be much more scalable. Next time, l two s will be much cheaper. Instead of paying $0.60, you might pay $0.03.
00:37:59.484 - 00:38:03.444, Speaker C: So I think the incentive to use.
00:38:03.484 - 00:38:18.344, Speaker B: L two s will grow up as time goes by. It becomes so cheap that you feel there is no reason not to use it right now at transaction. It's cheap, but not cheap enough, actually.
00:38:24.154 - 00:38:24.650, Speaker C: Nice.
00:38:24.722 - 00:38:32.134, Speaker A: Really nice, bro. More questions from the crowd. Anyone want to open their mic and make a question to vx?
00:38:33.594 - 00:38:39.574, Speaker B: Let me see whether. Okay, I tell you about the ERc, this thingy.
00:38:40.474 - 00:38:41.498, Speaker C: What is this?
00:38:41.666 - 00:38:42.494, Speaker B: Okay.
00:39:01.894 - 00:39:12.418, Speaker C: Is the address only two people.
00:39:12.466 - 00:39:22.654, Speaker B: Using it right now because people don't trust the product yet. We have already tried our best to make sure that it's correct. But that's how it is.
00:39:23.714 - 00:39:25.122, Speaker C: The trust is an issue.
00:39:25.178 - 00:39:29.698, Speaker B: Okay, so anyway, the thing is that, let's say I deploy a contract.
00:39:29.866 - 00:39:33.774, Speaker C: They deployed some contract down here.
00:39:35.174 - 00:40:27.624, Speaker B: This is an upgradeable contract. It creates a contract. So the thing is that read as proxy and as a write as proxy. So what etoscan doesn't support right now is people just see this bytecode down here, then they will get a bit scared. But whereas bytecode, you can actually trace it back to the factory and make sure that it's verified and click here, then see the factory and verify that this bytecode is indeed safe. So think about this upgradeable proxy approach is that you don't need to verify your contracts because obviously this bytecode, there's no way to verify it other than ask etherscan to support it by hiding this code.
00:40:27.774 - 00:40:33.584, Speaker C: Adding this tab, etoscan will most likely not entertain.
00:40:35.044 - 00:40:37.356, Speaker B: Yeah, they are pretty slow to do things.
00:40:37.500 - 00:40:41.316, Speaker C: So the second thing is that every.
00:40:41.340 - 00:41:10.244, Speaker B: Time you deploy a transparent, transparent upgradeable proxy, you have to deploy like two extra constraints. Then you have to verify two extra constraints. So whereas this, you just have to use the factory deploy. That's it. Yeah, you don't need to verify your extra contracts. And let's say, okay, let's talk about the. So, lady, if you are using Nim zip, we also provide a library for soda.
00:41:10.244 - 00:41:35.234, Speaker B: I intentionally use typescript because I want everyone to easily use it anywhere without installing all those tooling. So you can call the compress in the front end, in the back end, wherever. If as long as there's JavaScript, then you can pass it to the contract. So we try to make everything as easy as possible for users.
00:41:37.734 - 00:41:43.074, Speaker A: It's really cool, bro. How long would be the audit? One week, two weeks, one month? You have any ideas.
00:41:48.254 - 00:42:24.804, Speaker B: What other. Yeah, I do think that getting an audit is quite important to establish trust because like it's like users also have to answer to their devs have to answer to their users. Let's say if something gets hacked, then people start pointing fingers. Why isn't this auditor? Why isn't that auditor? Yeah, that kind of shit and drama will come up.
00:42:27.424 - 00:42:33.804, Speaker C: Okay, what are the advantages and disadvantages of.
00:42:36.704 - 00:42:37.964, Speaker A: It's really cool.
00:42:39.464 - 00:42:51.484, Speaker B: Okay, so Solidi is designed in a way that you can just copy and paste the code into your code base. But then you have to consider, let's say if your code base has a CI that does something like code coverage.
00:42:53.944 - 00:42:56.472, Speaker C: And the amount of code you copied.
00:42:56.528 - 00:43:10.804, Speaker B: Will screw up your code coverage cost. Okay. For solady, we don't lose code coverage because like, obviously you can, like tag, you can't cover handwritten by code. And there are some assembly that is totally not suitable for code coverage.
00:43:11.904 - 00:43:12.336, Speaker C: So.
00:43:12.400 - 00:43:13.044, Speaker B: Yeah.
00:43:15.584 - 00:43:18.136, Speaker C: But the thing is that if.
00:43:18.160 - 00:43:20.528, Speaker B: You import like sole lady versus copying.
00:43:20.576 - 00:43:23.584, Speaker C: To your code base, you can, can.
00:43:23.744 - 00:43:29.084, Speaker B: Help improve your CI compile times your code meter.
00:43:35.344 - 00:43:35.912, Speaker C: Okay.
00:43:35.968 - 00:43:37.284, Speaker B: Yeah. Any more questions?
00:43:37.824 - 00:43:55.356, Speaker A: I think this is it. Vx, I wanted to thank you so much for coming up today, you know, and giving your time again. You know, you came here three months ago or something. We did the interview and. Thank you so much, bro. You know, I have one last question.
00:43:55.420 - 00:43:56.464, Speaker B: Thank you so much.
00:43:57.404 - 00:43:58.144, Speaker C: Yeah.
00:44:05.364 - 00:44:09.864, Speaker B: Oh, single variable instructor struck. Okay, I explain, I explain.
00:44:11.724 - 00:44:17.584, Speaker C: Um, let me go to a new window.
00:44:20.284 - 00:44:20.716, Speaker B: Okay.
00:44:20.740 - 00:44:21.424, Speaker C: Okay.
00:44:27.404 - 00:44:34.784, Speaker B: I think I have an example that can, that can demonstrate. Okay, so in this there's a.
00:44:38.244 - 00:44:38.724, Speaker C: Contract.
00:44:38.804 - 00:44:39.424, Speaker B: Called.
00:44:42.994 - 00:44:44.722, Speaker C: Ah, so this is a struct.
00:44:44.778 - 00:44:47.134, Speaker B: That has a single value.
00:44:49.794 - 00:44:53.074, Speaker C: So the thing is that you use.
00:44:53.114 - 00:44:56.494, Speaker B: A struct with a single value. You can.
00:44:59.954 - 00:45:00.826, Speaker C: Show you where is it.
00:45:00.850 - 00:45:01.414, Speaker B: Using.
00:45:05.974 - 00:45:10.366, Speaker C: But you can do, uh, and.
00:45:10.390 - 00:45:11.446, Speaker B: Do something like that.
00:45:11.590 - 00:45:16.454, Speaker C: Like something, something storage from the mapping.
00:45:16.614 - 00:45:44.454, Speaker B: Then if you do some other stuff, you don't need to recalculate the slot. Also you can directly get the storage slot in assembly without doing all those keycap 256 sheets. Yeah. Sometimes these pattern makes it easier to use the value handle the mapping values.
00:45:47.834 - 00:45:49.346, Speaker A: Very nice. Very nice.
00:45:49.490 - 00:45:50.026, Speaker C: Cool, bro.
00:45:50.090 - 00:45:54.214, Speaker A: I think this is it. Vex, anything you want to say? Any closing thoughts?
00:45:55.234 - 00:46:21.966, Speaker B: Let me see. Yeah, I really hope that everything will be good for the audit. Awesome. I'm keeping my fingers crossed. Also, like, would like to thank all of you for your support and your immense support, your love and your time.
00:46:22.110 - 00:46:31.514, Speaker A: Yeah, we're gonna thank you so much. And we also gonna do the audit here so we can compare in the end just to see how much we got wrong and right. Okay, thank you so much.
00:46:32.734 - 00:46:40.630, Speaker B: Don't be too hard. Sorry. Yes, sorry. One thing before we go. What do you think we should do to get ready for the audit? How can we help you as much?
00:46:40.662 - 00:46:47.314, Speaker C: Like, how can we be helpful? Oh, um. You have some advice?
00:46:49.414 - 00:47:11.384, Speaker B: Um. Oh my God, I'm sorry, man. It seems like. No, no, no. So, okay, because soul lady is like every part of code, every part of solid is written in slightly different ways. There's no one fixed rule to audit everything. Okay.
00:47:12.924 - 00:47:13.404, Speaker C: Okay.
00:47:13.444 - 00:47:21.804, Speaker B: If some functions that are too complicated to understand. 9.9. So for those functions, I will check.
00:47:21.844 - 00:47:25.544, Speaker C: Whether the fast test is enough.
00:47:27.504 - 00:47:29.204, Speaker A: Awesome. Awesome.
00:47:29.824 - 00:47:37.964, Speaker B: Like there are like some stuff like the meh functions. Okay, I'll show you one example.
00:47:46.184 - 00:47:46.824, Speaker C: I'll show you.
00:47:46.864 - 00:47:58.384, Speaker B: I'll show you one example. Source. Where is it? Is it here?
00:48:02.684 - 00:48:03.984, Speaker C: Explain math.
00:48:09.604 - 00:48:17.372, Speaker B: So, for example, this function, if I don't understand any of the math behind it, I would just have to look at the fastest to make sure that.
00:48:17.388 - 00:48:24.574, Speaker C: The fastest makes sense then. Fastest as much as possible.
00:48:26.074 - 00:48:28.850, Speaker A: Awesome. Makes me happy that you know nothing about it. Okay.
00:48:28.882 - 00:48:30.134, Speaker C: Makes me more hopeful.
00:48:31.354 - 00:48:40.682, Speaker B: Sometimes I don't know everything. Also, I understand. Where does this number come from? We will do our best to be.
00:48:40.698 - 00:48:41.978, Speaker C: Helpful as much as possible.
00:48:41.986 - 00:48:57.392, Speaker A: Yeah. We're gonna have, you know, we're gonna have a training session, which is truly before. And then he's gonna give us the UPU. Then we're going to prepare probably to start this weekend on this audit. You know, I want to do something live that will be on camera. You know, that's fun. We're doing groups.
00:48:57.392 - 00:49:15.626, Speaker A: I think one week should give us something. You know, if we like, like the x did, we split the code base between teams and then we can exchange files and everything. Okay, thank you so much. Vectorized. You're a fucking king. Whenever you need to come here, just come. Okay.
00:49:15.626 - 00:49:23.054, Speaker A: Thank you so much. Yeah. Bye bye, brothers. Thank you so much, everyone. Bye.
