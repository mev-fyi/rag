00:00:00.560 - 00:00:26.246, Speaker A: Sorry, everybody. Thank you so much, Dmitry, for your time. Sorry for the problem with the mic again. And yeah, today, Dimitri, our good friend, will give us a small lesson into the deaf mysteries, the deep mysteries of MeV. So, everybody be ready, and, yeah, let's do this, bro. Right? Yeah. So you're seeing this.
00:00:26.246 - 00:01:50.184, Speaker A: Let me just click play. You can see fine, right? Very clear. Okay, cool. All right, so I decided to do sort of, sort of everything about that. Everything, because there are pretty much tons of repositories available for you to learn on GitHub where you can read the code, various bots, including the Dex to Dexar liquidation. So I decided to go a bit different way and just tell you more about where to think, how to think, and what can you use to be successful in 2023, as obviously, you know, MeV is getting more and more complex, lots of generalized frontrunners, people using various technologies to actually be the first ones to submit the bundle, to lend the bundle, etcetera. So we gonna talk about generally first about their pc client, as probably you would know.
00:01:50.184 - 00:03:18.000, Speaker A: And I would assume most of you guys are using public notes, or any paid versions of public notes, let's say alchemy. You can buy yourself a slot, but that won't be entirely your note. So it will still have a bottleneck of. In the busy times, let's say when people send many requests, they, they can overload the node, and your responses will be pretty slow, which is extremely critical for you as you're trying to solve something fast, especially in the faster blockchains, like if we take polygon or Avax or anything, anything that is fast enough even by smart chain. 3 seconds block. So your general objective will be to minimize the amount of ETH calls you send, at the same time keeping the entire state of ease that you need in order to execute your strategy somewhere, either in memory or cached. So for that reason, for that reason, I do propose you a solution by storing the state on your machine.
00:03:18.000 - 00:04:36.628, Speaker A: So what am I doing normally for anything I do not only even related to any, but it could be also C 5D fire, could be anything, anything. Where you interact with smart contracts, there is a great library called, which allows you to simulate any transactions, any interactions with Ethereum blockchain. So it works the following way. You create accounts, you populate accounts inside the RevM object with storage slots, with corresponding keys, everything, everything very familiar to those who know EVM. And it allows you to simulate the transactions pretty much like you would fork. You would fork a blockchain via foundry via Unreal, you would fork it and then you would try something out, right? So pretty much unveil is actually under the hood. Anvil is RevM with tweaks, let's put it this way.
00:04:36.628 - 00:05:44.942, Speaker A: So ARVM provides execution layer and you can simulate locally everything. And it has a in memory database, which is far as I remember it is a trait. So you can re implement it your way if you think you can do faster, which in fact I did, because they are using the in memory DB. But if you are, let's say doing Dextodex arp, you need to keep track of let's say 2000 pools and the reserves, then you wouldn't probably want to have it in memory, you would want to store it somewhere. And for that reason there is a great library in rust called cache, which is extremely performant library I believe initially was written in c. So obviously as you already could have guessed, I'm using rust pretty much for everything I do, as I do like the performance and I do like the zero abstraction concept. So let's have a look.
00:05:44.942 - 00:06:35.504, Speaker A: Yeah, for sure, let's have a look on the GitHub of ArAVM. So when I first saw this repository, there was pretty much nothing in terms of examples or any good readme. It was pretty naked, let's say. So I like figuring out myself, I spent a week trying to understand how it works. And the funny bit, actually there is a guy called Degaci, you probably know him from the same group, so he was doing exactly the same thing as me at the same time. And we were chatting over discord, who understands it first. And there are some secrets and how it works.
00:06:35.504 - 00:07:34.426, Speaker A: Once I learned it, I created the example, which in fact is the only one example for now which you can find and learn from it. I tried to put as many comments as I could. So as you can see, actually this library has also a mod, let's say that allows you to copy the state of the account, pretty much get storage ad but with a few sugar coating so it is nicer and everything is already passed. So you can see there we download ethosDb, that's the name of the DB. Actually I wrote this DB as well for RevM. So basic we're just getting the account. Basic properties of the account, including the bytecode.
00:07:34.426 - 00:08:29.014, Speaker A: It gives you the bytecode straight away, which is nice. Then we query our value at our desired storage. So flotate is the reserve or you need to like pull and then we store it into the cached db, which is in fact in memory DB, not the cached on your hard drive. We insert the account, blah blah blah, then create the evm object, initialize and add the DB to the EVM object. And then we can transact. In order to transact, you need to create the basic basic field, the basic fields caller transact to data that you would want to send the transaction data. So call data and the value, the value that you would want to send as well.
00:08:29.014 - 00:09:46.442, Speaker A: And then you pretty much have an option to either transact ref, which will return you the result of the interaction with the EVM without writing to the database, or you can do just transact. So without the ref, that would be the actual execution plus the recording in your ReVM database. So if you emulate in something, and that includes a few lifespan of several blocks, let's say, then you would want to transact and record for obvious reasons. And by learning this tool you will be able to do crazy stuff. By crazy stuff, I can tell you that in order to arbitrage like Dex two, Dex arbitrage, let's take the simplest example with uni v two, no tick liquidity, nothing really fancy. It's pretty easy to implement the get amounts out. Everything can be re implemented very easily with any language off chain, so you don't have to send these ETH calls all the time.
00:09:46.442 - 00:11:05.704, Speaker A: But what if I tell you that you can pretty much make something that is completely agnostic of how the protocol works and at the same time gives you the desired result? And for that reason there is an RevM because you pretty much don't need to know how uniswap v three calculates the fee, or whatever it does inside. All you need to do is to find the methodology, how you can use the revM, what storage slots you need to copy to simulate, and then all you need to do is just binary searching so you're literally brute forcing the outputs, sorry, not outputs, the inputs, because you know what output you want to see. So our EVM does help you to standardize pretty much any strategy given that it can execute, I believe, million iterations in under 1 second, I think. Oh sorry, one millisecond? One millisecond, sorry, not even second. That's crazy bro. This thing is extremely powerful. There is also a good telegram chat in RevM official one, so all the maintainers are there.
00:11:05.704 - 00:12:04.086, Speaker A: I'm there as well. So if you guys have any questions, feel free to hop there. Very smart people there, especially Dragon Vaquita who wrote EVM RevM initially and now it is a core block for foundry, and it is a core block for our Ethereum as well. So the paradigm client, they actually use many of the logic from Revm there. So that was my biggest, let's say biggest finding and thing that actually helped me to improve a lot, because initially I started with Python, which was extremely slow. Obviously I wasn't able to capture anything, so I had to readjust. And people obviously learning fast, and especially those who already were doing it for a while, things that I was trying to do, we just completely outdated.
00:12:04.086 - 00:13:28.976, Speaker A: And anything that is publicly available is obviously not going to work now anymore. So those are just for you to actually learn and understand what are they trying to do, rather than copy and try to replicate something. So the second thing that I kind of found to be a bottleneck for me when I was trying to do the polygon, polygon Dex two Dex arm as blocks are extremely fast, and I was trying to target as many Dex, many pairs as possible. Obviously robust filtering is very important, and I would highly recommend when you filter pairs. I remember there was a guy who was doing the meV, talked about Dexter Dex Arp in go a few weeks ago, I believe, and he was using graph, which really did surprise me, to be honest, because I've never seen anyone using graph. I'm not saying it's bad, I was just never thinking about it. So I was initially just, I just wrote like a very small query contract that gets you reserves or pairs in batches, but that will lead to spamming their pc node.
00:13:28.976 - 00:15:57.634, Speaker A: And if you do have any other processes communicating with the node, you would rather not do it, because that can slow it down. Even if you have a private node? Even if you have a private node. So for that reason I thought, wow, okay, why would I update everything every time? If I can just run the first update that would update every single pair, and then after that I would just find the signal for those pairs that actually are touched and their reserves potentially changed, and just refetch those exclusively. So for that reason, I decided to pack logs, just look into logs of the block and extract all the addresses and create a large future, basically to actually fetch for each object individually. As you can see on the right hand side, the first code snippet on top is actually pretty much the entire logic for the update that consumes the vector of logs, pretty much source them out for unique addresses in a hashtag, and then pushes the pair update, which is a method you can see below, which is a method on the pair itself, and it yields the future together with writing for the reserves into the reserve slot of the pair. So with that way you're able to very quickly execute the entire update of those pairs that you have to update because they've been potentially touched in the logs and you save a lot as you only need to send five, six normally, as was what I saw is even in a very, very quick market conditions, when we see huge price appreciation for depreciations, maximum 2030 in the block. So yes, that's not a lot, right? So it is pretty easy to fetch.
00:15:57.634 - 00:17:33.528, Speaker A: And moreover you can even improve this algorithm by for example, using the batch batch call, so you can pack them into one single batch call, which will normally be fine as most of the RPCs allow you to send batches of hundred via websocket and I believe 200 via just the normal RPC connection. And this idea can be used pretty much everywhere. So not only related to Dex, to Dex ARP, you can and you have to use pretty much the same concept for any strategy that keeps track of some storage keys in the account and it emits any of the events. So you can see it in the logs. So definitely do look up into logs and utilize logs properly. And there is also a side note that subscribing to logs sometimes some libraries love you to subscribe to logs, or you can write your own and subscribe to logs. But I found some problem with that, as sometimes if the node is very busy and the new logs are in the queue, basically two portions of logs are in the queue, then you will only listen and receive the latest one, so you can skip the entire chunk of logs, which is bad.
00:17:33.528 - 00:18:20.310, Speaker A: So that's why I decided to actually send them specifically the request for logs and then processes. So I'm targeting more like log heads rather than the logs themselves. Yeah, rust, rust for the wind, that's preferred. I try go, itroid, typescript, python, whatever. Nothing, nothing is as fast as robust as rust. And given the amount of libraries like ethers, RS is the best library pretty much for a few I've ever seen, and I've tried a few in many other different languages. It might sound funny, as obviously Geth is in go and go should technically be the most the best lib.
00:18:20.310 - 00:20:13.084, Speaker A: But RSU ethers RS is just so well designed with such a great support and telegram as well by the guys, both Georges and James Prest, which anytime can help you. Any stupid questions which I initially had because Rust is pretty tough and learning rust and learning ethers rs at the first place wasn't, wasn't as easy as I initially thought, and I don't know, some of you might be aware that the fastest searchers, I'm not sure if they still do it, but they used to do it for sure when Ethereum was proof of work, they were actually forking the Go Ethereum client same way as flashbots did, but in fact they were changing the client to actually embed to have their own bots logic. So you're pretty much making a client that executes the transactions that you want to execute. So I don't know if anyone is coming from Trafi or knows something about FPGA's, which is a field programmable gate arrays. So kind of produced like hardware, hardware that already has predefined set of instructions. So that's the fastest you can be to execute anything pretty much anywhere. I'm not, unfortunately, not very proficient in hardware, but FPGA's is definitely a thing in tradfi.
00:20:13.084 - 00:21:08.664, Speaker A: And I believe that more and more people will be moving to forking GAF, and maybe, maybe, and potentially not even maybe. And I think soon it's going to be our ethereum that will be forked and modified to actually process the transactions for the strategies that Turkish is run. So our ethereum is definitely the newcomer, and it will stay and it will develop into something big, I believe. So for that reason, I think Rust is all you need to have pretty much from the off chain, let's say languages. So yeah, it covers both Ethereum, which is consensus and execution. And then there is like a revm, which just executions, you can simulate and caching. Then ethers, RS allows you communication with RPC.
00:21:08.664 - 00:22:01.154, Speaker A: So Rust is definitely the way. And for that reason, I will share as well a very great channel for us that helped me a lot to actually learn it. Once you read the Rust book and know the core concepts, then I would highly recommend you watching these videos. They are very long and don't get discouraged, but they incredibly informative, and that is designed to be something intermediate kind of level. So you have to have basic understanding. So the guy is pretty much reimplementing the standard library, the standard library from scratch for most of the things how arc atomic referencing work, and that's extremely important. So you write the good coherent and efficient code and going back to this.
00:22:01.154 - 00:23:21.350, Speaker A: Yeah, how to win. Yeah, how to win. Basically, if you read it on crypto Twitter, it's too late, bro. Most likely you're never gonna find something on crypto Twitter or anywhere else, any public resource, and replicate something so that you make money. So the best approach for me, has always been doing my own research by inspecting and reading new protocols in defi space or even in gaming space sometimes that come to the market before anyone actually sees it, maybe even in earlier stages, not even main stages, then understanding the briefly, briefly understanding the concept, understanding what is what, and asking yourself a question. If you can somehow profit by reordering something or putting your transaction before or after the user's transaction, and after that you would obviously read the code and understand if those functions external at all. Or can you call it actually, can you read something and then pretty much jumping straight away into implementation.
00:23:21.350 - 00:24:33.556, Speaker A: And because you have Revm, you can simulate anything, but at the same time don't spend too much time on implementing something and then making it live because some other people can find it earlier and you will be kind of in disadvantage or maybe even discouraged of doing that. So I would highly recommend to write a fast prototype and then build on top of it, because you will clearly see when you bought this life what is actually lacking. Are you lacking speed? Or maybe you need better filtering, better signal processing, or whichever it can be. So. And yeah, and it's important to take the entire opportunity as well. So I saw like we can clearly see, especially with those who actually brute force the outputs the standard way, let's say, how they brute force the outputs for the unit and they sent. And I think this guy was actually saying the same thing, that he was sending one ethereum for each of the arbitrage opportunities he finds.
00:24:33.556 - 00:25:58.080, Speaker A: And then sometimes he can even create another arbitrage opportunity because it was too much. So finding and an opportunity is one thing, but optimizing the code in such way that it covers the entire arbitrage, not more and not less, is essentially your main goal, because then no one, not no one, okay, it will be much harder to see and find the opportunity only if the guy actually like is you actually executing transactions, then he can pretty much copy your think how he can outplay you. And that's. I said don't implement something that is like been on the market for a long time, like Dexter, Dex arcs, liquidations and sandwiches. Because if you are starting, most likely, I mean, not even, most likely for sure, you're not gonna be able to compete with the people who's been doing that for a long time. So don't do something that so many searches are already doing unless you definitely know you have an edge that will give you a good competitive advantage and you will be able to actually get something out of it, because you probably aware that most of the time for Dex two. Dex are for liquidation of sandwich.
00:25:58.080 - 00:27:02.684, Speaker A: You're going to pay like 99% of the fees of the profits to miners as a coin based transfer. So it's pretty much a fee for them to actually execute you. So the potential profit is pretty relatively small right now, especially right now in a very stale and slow market, unlike when you can invest time into researching something more interesting and something that no one does. And I remember I was doing like a fuel of NFT stuff. NFT MeV was pretty good, especially when the market was, when the market was very active. So you, when we had so many mints every day, and sometimes people list stuff at the ridiculous levels and then there is a public sale next day. So you can literally, all you need to do is mint on the public sale and spell into best bid.
00:27:02.684 - 00:27:55.194, Speaker A: That was the case as well. Then there was even longer ago, there was a rebase like Olympus Dao, everyone knows this stuff. So Olympusdao wasn't as crazy as some of its forks, especially on Phantom that were giving you like 5% or 7% on rebase, each rebase. So you could have just swapped for their tokens, stake it just before the rebase, trigger the rebase, unstake it together with the collected rebase, swap it back to what it was or USDC or E, and check for balance in the end. So if you're winning, those kind of things are much less competitive, much less competitive and harder to find, obviously. And unfortunately they don't last long. That's the biggest drawback.
00:27:55.194 - 00:28:50.136, Speaker A: I am currently working more on generalized kind of bot, but it's very early to actually say something and because I'm not really sure if it's going to work. Yeah, and the key is just keep using RevM is really like, I cannot stress it enough how important it was and it is in everything I do, including Defi to C five trading blogs. Yeah, logs as well. So I'm open to any questions. Any. If you have any questions, you can always reach me on Twitter, GitHub, Discord, same nickname everywhere, or even email, same, same email, proton.com. Any questions you have, definitely, definitely do ask.
00:28:50.136 - 00:29:44.278, Speaker A: I'm more than happy to help anyone. And if anyone has any questions now as well, feel free. Thank you so much bro, for that and anyone questions. So I do have a question. It's like regarding the morality and the legality of all this and that, you know, it differs from where you live, but how do you deal with all of that? I don't know where you live, but how can you. Is there a resource to find all that and so forth? The resource for legality and morality? I mean, I'm just a libertarian person who thinks that if anything is not illegal, then it's sort of legal. So it doesn't contradict to my values, basically.
00:29:44.278 - 00:30:09.130, Speaker A: And I don't think it breaks the law where I live. That's kind of my approach. Not saying anyone should follow it, but I'm kind of a defi native. Got it. Thanks. Yeah, it doesn't go against my morals either, but I'm more interested in legality in specific. Yeah, be very careful, actually.
00:30:09.130 - 00:30:46.112, Speaker A: Yeah, actually, that's a good. That's a very good question. Be careful, because if you're using like, something like alchemy, infuria, all of these guys are sending your IP addresses, like, and saving them so they can. Easy. You can easily be discovered, basically, if you're doing something shady or, I don't know, your bot, I don't know, hacked. If you wrote a generalized something and you front run the hacker, then you can't have problems with that. So I would definitely recommend you running your own node.
00:30:46.112 - 00:31:06.360, Speaker A: Your own node is always a great solution. Or using a service that provides you like a Tor relay. There is like a service called smoke zmok IO. They actually have like a. You can connect via Tor. So onion router. Right.
00:31:06.360 - 00:31:51.542, Speaker A: So I don't know how safe is it, but definitely do research and see, like, especially if you live in the United States of America where you can. I mean, you know, you can be caught even if you did something unintentionally. It's better be safe, basically. Thank you for that. Anyone else have there? I mean, on the topic legality, have there any or have any bots actually been prosecuted? I haven't heard of anything like that happening at this point. No, me neither, to be honest. I've not heard anything.
00:31:51.542 - 00:32:33.824, Speaker A: I mean, I'm pretty sure if it has happened, then we would have known from Twitter, because Twitter is kind of spreading everything. Yeah. All right, thanks. And also, by the way, I will be able to send a list of good resources that I think are useful just to a discord chat, let's say, like, store to say, bookmarks export or something. Money group cloudy body chat. Dimitri, I think this is it, bro. Thank you so very much.
00:32:33.824 - 00:32:49.432, Speaker A: That was beautiful. Probably the first real mev class someone ever gave. Thank you so much. I'll link you everywhere on YouTube and on Twitter. And. Yeah, thank you so much, bro. You fucking killed it.
00:32:49.432 - 00:33:06.456, Speaker A: Okay. Yeah, thank you, bro. Thank you bro. Very happy to join you guys. And next time, we're just gonna go deeper in more topics. So probably I'll just make a questionnaire or something in any topics that. That most of the people would want to know.
00:33:06.456 - 00:33:22.184, Speaker A: So obviously, for obvious reasons, I can't say everything that they know. I understand. But. But, yeah, we definitely. I definitely can show things up and at least, like, direct people into right direction, basically. Thank you for the alpha, bro. Okay.
