00:00:02.080 - 00:00:40.014, Speaker A: Okay, so hello everyone, this is red. Today I'm going to give a presentation on some motivations of learning EVM. So it's going to be pretty beginner friendly, like simple and easy, 30 to 45 minutes. And then after that we can ask questions for 15 minutes to make the whole session hour. Okay, so for a quick who am I? I'm a web3 security researcher. I'm doing the security engineering intern at Sigma prime. Also I play CTF is the Defi hack labs community.
00:00:40.014 - 00:01:10.044, Speaker A: I'm from a pure math cryptography, binary exploitation background. And here's my twitter. So I'm happy to connect with everyone. I think I need to share the link, right? With the audience. Yeah, I need to share the link. Where's the comments section? Oh, I see. As.
00:01:10.044 - 00:01:55.686, Speaker A: Okay, okay, so what's the motivation behind learning EVM? First, obviously when I learned EVM, I use that to play CTF. After that, actually you can doing EVM research and get a job. For example, you can do that at authors at Kansas league. I have friends who work there. They play CDF really well. Their strength is in UBM, so it's possible to get a job, but it's pretty hard like doing EVM alone. Right? Third, you probably need EVM knowledge in your day job.
00:01:55.686 - 00:02:49.664, Speaker A: For example, right now I'm auditing Rev, which is a ROS version of Go Ethereum for auditing that you have to understand how EVM works or you can just because of you have curiosity. So you want to learn everything. The first step I recommend checking out this collection by Mina. Mina is just a CTF player in my team. He collected these EVM puzzles, everything that he had done in the past two years. I think I also recommend solving these two challenges in only ponder. So this is a rather new platform by opface and I think these two challenges are pretty good.
00:02:49.664 - 00:03:25.834, Speaker A: You can do this just after the session I share the slides with everyone. So you still have the links how to learn EVM. I collected a list of resources you can follow. They are publicly online. These resources I think you know. So the most notable things here is just this whole series by open Zeppelin. This is an older one, probably like five years old right now.
00:03:25.834 - 00:04:14.494, Speaker A: This is the a list of articles by Knox. These are pretty new. After that you can learn how to read opcodes and eventually you have to read the geth source code. So you have to learn go first, learn the go language and then follow these medium articles and then eventually read the evm go source code. This is what I recommend everybody to do in your free time. Okay, so today the main topic is I want to do a few case studies. Basically the top two.
00:04:14.494 - 00:04:47.544, Speaker A: The first one is I will talk about Abi encoding for the dynamic types. Also this is a really sneaky bug. The return in solidity and returning your. They are different. Also I have like a homework assignment. You can do it on your own. Is the pretty famous, the Openzeppelin ERC 200 7271 contacts plus the multicore library bug.
00:04:47.544 - 00:05:19.244, Speaker A: Do we have questions so far? No. If no question I'm going to do the technical part. No way. My, my english is pretty rusty. Okay, now if no question we are going to do the technical part. So the first case study, actually I have done this last year on Twitter. Right.
00:05:19.244 - 00:06:09.274, Speaker A: You can check my tweet, but I have some new thoughts to add into that. Basically, think of this, when you calling an external contract, you have to prepare your call data. If you are just calling a normal function, you can just call the name. But if you want to do a low level call, you have to do the ABI dot in code family. For example, the most commonly used, I think it is encode this signature like you do that in a low level call. Then you prepare the function selector and fill in the parameters. But I don't think everyone knows what's happening behind that.
00:06:09.274 - 00:06:57.254, Speaker A: So under the hood, Abi encoding has a specification. For example, you can think of this dynamic type as just string. For example, hello world. It is a dynamic type is the ABI encoding of that is breaking down into three parts. The first part is the offset length and the actual data is okay if you don't understand, because we are going into remix ide very soon. I will show you an example. Okay, but the simple way is you can use this cast in foundry toolkit.
00:06:57.254 - 00:07:27.674, Speaker A: I will show you in terminal. For example, you can do this and the call data of this function. This function takes three parameters. The first and third are dynamic types, they are strings. And the second is just a static type is u into 56. Right. And I'm making it just like simple, like hello and 1337 world.
00:07:27.674 - 00:07:45.410, Speaker A: If this doesn't make sense to you, it's okay, I'm just showcasing like you can use a tool to get quick call data so you can analyze manually. Right? We are going to remix right now.
00:07:45.522 - 00:07:48.214, Speaker B: Brad, maybe for, can you show the terminal again?
00:07:49.314 - 00:07:50.734, Speaker A: Show terminal again?
00:07:51.194 - 00:07:58.712, Speaker B: Maybe for the youngsters out there. Can you explain for us a little bit about how the parameters convert into these numbers, into these x codes?
00:07:58.768 - 00:08:02.016, Speaker A: Yes, I will, because I will do that in the contract.
00:08:02.160 - 00:08:02.964, Speaker B: Awesome.
00:08:03.544 - 00:08:39.384, Speaker A: Yeah, yeah, it's right here. It's the same thing you see? Yeah, so I'm just saying you can get coded this way. Yeah, I'm just showcasing this tool. The actual analysis is here. So in remix I wrote a simple test contract. There are five functions. The first is just ABI encode API, encode pack, encode with signature, with selector and encode call.
00:08:39.384 - 00:09:12.634, Speaker A: Let's take a look at the first one. This one is the most vendor ABI dot in code that follows the specification defined in the solidity doc. Right. So I am encoding three parameters here. You can just think of the, these are the same, right? This is the same though. First parameter, dynamic type, static type. Dynamic type.
00:09:12.634 - 00:09:55.724, Speaker A: I'm just making the, making things up. So, so it feels more interesting because if you do like all dynamic type or all static type, it's easier to understand. But yeah, I'm just making like a complex situation. Let's deploy the contract here, show as compile it, deploy and not this one. We are deploying test API. So contract is deployed. Let's call encode and see what we got here.
00:09:55.724 - 00:10:36.154, Speaker A: So I actually already analyzed the call data, but I will do that one more time to show you how I manually parsed it. Okay, so I just copied here, delete zero x. First thing you notice probably I will say here is the first 32 bytes. So I just press under here, press under here because they are all like 32 bytes. Right. I just keep doing that, keep doing that same thing. So that's how I got this data.
00:10:36.154 - 00:11:14.884, Speaker A: I put in the, in the comments there. Okay, so let's look at the call data, the first 32 slot. And it is the offset of, hello, you can think of this is like a stub. I is in the slice. I think of this as a stub. So what is a stub? I don't know if you guys learned the like dynamic linking in c language. There is a concept of like function stub.
00:11:14.884 - 00:11:58.544, Speaker A: Basically just in dynamic linking the function definition will only be copied from libc when the function gets executed. So before that, the function stub is just like a name is. So inside that is anti. It is the same story here. So this offset is telling us there is some dynamic type like at location zero x 60, which is here, I believe. Okay, so this is like, you can think of it like a placeholder probably. So it's telling me.
00:11:58.544 - 00:12:34.084, Speaker A: Okay, so the first parameter is at location zero x 62nd parameter is 539, but in hex that's the same as this number. Okay, so the third parameter is offset of world maps. So this part is like a placeholder, the actual data of the static type and placeholder. Again, do we understand this part? You can ask question. Now.
00:12:35.784 - 00:12:39.404, Speaker B: We'Re talking about the pointers and the data itself, right?
00:12:39.824 - 00:12:51.164, Speaker A: Yeah. It is called offset in half tutorial. So I'm calling it offset, but in some other literature it is called pointer. They are the same.
00:12:51.824 - 00:12:55.804, Speaker B: So basically where the data starts and where the next part.
00:12:57.064 - 00:13:37.284, Speaker A: Yeah, you can think like a, as a placeholder. So there is nothing here but is pointing somewhere in the, in the end, like is this pointer points to this data. This pointer pointing to here. Yeah, I think when I added the space is pretty easy to see. Right. And pointer pointing to the length of the first string, which is five because we have five characters here. The actual data is padded on the right.
00:13:37.284 - 00:14:25.404, Speaker A: The actual content of the ASCII code is here. You can just use an online tool to translate this is hello, this is world. And this is the length of hello, this is the length of world. Both five. This pointer, the first, the first pointer pointing to location zero x 60 here. The second pointer pointing to location zero x a zero which is here. And the actual data is this part string is, the string consists of two parts, length and data.
00:14:25.404 - 00:14:48.268, Speaker A: The pointer is like a placeholder. Do we understand this part? You can ask question. Okay, okay, okay. You all got, okay, that's, that's. So let's move on to encode. Pack. This one is pretty easy to understand.
00:14:48.268 - 00:15:38.922, Speaker A: You just pack everything together. You see the data is this part and then this is hello. This part is one, three, seven, hex and this part is world. Yeah, this is pretty easy to understand. So when you are talking to an external contract, you must be using API encode because this is the definition. If you sound like a chunk of data to another contract is not going to understand it because this is nonsense. Okay, there are three other method, but they are just like wrappers around API that encode.
00:15:38.922 - 00:16:25.034, Speaker A: You can see this, call it encode, this signature, this one you just append the function selector on the top. The rest of the data, they are the same. They are the same as API that encode same data. Just one more function selector on the top. So the other contract knows which function you calling in. Callbase selector, same thing, just semantics. Like the syntax is different name story in cold call same story, different now I mean different, different syntax.
00:16:25.034 - 00:17:57.960, Speaker A: Okay, so the confusion is just some people think a string only has a, like a two part encoding only length and data because this is what they see in the actual memory. If you are inspecting running EVM in the memory, it is only two part, but when you see three part encoding, that's the ABI encoding specification. So that's commonly the call data. So for like the easier memorization, I will say just memorize it as two parts in memory and three parts in cordata because call data needs extra like the offset slash pointer definition here. Okay, so that's the everything for the first case study. Do we understand this? Any questions? Yes, so the confusing part is just like some documentation says two part and some says three parts. For example, in solid doc, there's one section saying string has two parts, but that means in memory, in half tutorial, you see string is three parts.
00:17:57.960 - 00:18:25.780, Speaker A: That's the Abi encoding, so they are different. Okay, so we, we finish with this one. If you want to try to debug on your own, you can follow this link and read the solidity dock. You can read hub tutorial. And also I post the sabi. So in this GitHub gist you can follow. Okay, okay, if.
00:18:25.780 - 00:19:31.272, Speaker A: No question, let's move on to the second one. So this is slightly more advanced topic. Basically I discovered this during a securing race, I think is race 19, probably. So the main idea of here of this one is you have a return statement in solidity, you have a return in your, and they are different. So the main difference is the lithium return is actually not like a, is not the end of the function call. Right. So for your, if you trigger that return, it's gonna terminate immediately, but validity, after seeing the return, it is still going to execute everything beyond that.
00:19:31.272 - 00:19:57.714, Speaker A: For example, like a modifier. Yeah. I will show you the code. I have this test contract here. Let's read the code a little bit. So in this setting, non reentrant is a reentrancy log. So there is a state variable status defined to be defaults to one.
00:19:57.714 - 00:20:31.890, Speaker A: First it checks if this is not two, so pass. And then it says the state variable to two. Do the actual function call here and then reset everything back to normal. Normal. Is this one default? And there are two functions. The first one is we do a normal return call. Insolidity.
00:20:31.890 - 00:21:23.774, Speaker A: The second one is return your, because this is assembly block. Okay, so what's this line? This line is I put zero x 42 into memory location. Zero x zero zero, which is obviously this is not safe because the first 80 bytes are reserved by memory. But this is just like a simple demonstration, so it doesn't matter. So I put this number to the top of the memory, and then I return that location, which consists of this value. So they are equivalent. They are like semantically equivalent, but the effect are different.
00:21:23.774 - 00:21:49.982, Speaker A: So I'm calling this as the your return. Your return. This is a solution. Let's deploy the contract and see what happens here. First we double check that status is correct. It is correct because it's not entered. We are not calling anything.
00:21:49.982 - 00:22:26.914, Speaker A: Okay, right now it is what? Correct. So first we call salty return. And it is still what? Okay, so let's see what's going on inside the call. Let's click this debug. So going to the debugger. Let's face down this execution. So he's doing some setup here.
00:22:26.914 - 00:22:47.194, Speaker A: Okay, so this part is pretty interesting. Just look. Okay, right now is in the modifier. I'm doing like a store to, to modify this stay variable. Right. This is normal. Normal.
00:22:47.194 - 00:23:31.290, Speaker A: Everything looks good. Okay, so we are going into the function. Look this way. Are we noticing something interesting actually, like this part is, the highlight is only on the number is now on return because it's not calling return. Right now you see there is no return opcode. So although we, although we executed the return statement, actually return opcode is not here. It's not actually calling the return opcode.
00:23:31.290 - 00:24:04.790, Speaker A: This is pretty interesting. Why? Because, yeah, because, look, so when we are here, right, we are actually on this step, we are in this underscore. So there is code behind that. And solidity is very smart. The compiler knows there is one line of code after that. So it is not calling return. It's actually what it does is push for zero.
00:24:04.790 - 00:24:15.172, Speaker A: This means zero x 40. It is pushing zero x 40 onto the stack. You see, push one, push it to.
00:24:15.188 - 00:24:21.524, Speaker B: The stack and then return. That should be the case, right? We should stack and then after the execution, return it.
00:24:21.604 - 00:24:52.400, Speaker A: Yes it is. But let's see what happens now. You see, it's actually going back to this line. It's not terminating. Yeah. So actually the solidity only stores this number onto the stack for a future return because eventually it will return, but in the very end, so is storing the rise for zero onto the stack for future use. And right now we are executing the last line.
00:24:52.400 - 00:25:39.688, Speaker A: This line, we unlock the what? The Reengineclub right here. We are unlocking it. After that it goes back to this function, return it, blah, blah, blah, blah, blah. Eventually, in the end, you are going to see the return. So the control flow is we execute these two lines first, and then we go to this function. Because this underscore, we store zero x 40 onto the stack. And then we go back to the modifier to unlock the reenginecy call and then go back to the function to increment everything.
00:25:39.688 - 00:26:20.874, Speaker A: This is solidity return. Okay, so this is, this is what we want because we are doing this modifier thing here. By writing this code, semantically, we mean every lines of the code will be executed. That's what the developer, like the developer wants, right? So everything good here? Everything nice. And let's look at the ugly ace, which is your return. Look at this. I'm calling test assemblyreturn.
00:26:20.874 - 00:26:58.824, Speaker A: I call it, it works. However, you see what is changed. That is changing. This is really bad because right now status is true. Why is true? Because it says entered. Even though the execution of this function finish, we are completely out of this function. The reentrancy lock is not unlocked, which means you are, your contract is locked forever.
00:26:58.824 - 00:27:00.132, Speaker A: You see.
00:27:00.188 - 00:27:01.908, Speaker B: But I do have a question.
00:27:02.036 - 00:27:02.676, Speaker A: Forever.
00:27:02.780 - 00:27:17.244, Speaker B: I have a question. Can you go down a little bit? So why. So you're telling me that you restoring the entered status on zero x 52. Um, that's storage address.
00:27:17.364 - 00:27:22.804, Speaker A: Your, your, your voice is kind of broken on my side. Can you just type on the.
00:27:22.964 - 00:27:36.024, Speaker B: Sorry. Yeah, 1 second. Better now. Is it better now, bro?
00:27:36.724 - 00:27:38.352, Speaker A: Oh yeah, it's better now.
00:27:38.468 - 00:27:50.724, Speaker B: Thank you. Thank you. Sorry, I have problems with the mic. So the question is where in the memory or in the storage are you storing the status on zero x 52?
00:27:54.784 - 00:27:58.524, Speaker A: This part is in storage and this is memory only.
00:28:02.504 - 00:28:09.524, Speaker B: Yeah, but my questions go down. So you're telling me that zero x 20 is holding the status data.
00:28:10.904 - 00:28:48.744, Speaker A: Oh, you are about this. Okay, so this means you are storing this number to this location. So offset that value. You are storing the value into this offset. Right now, our memory, the map summary location. Eight.
00:28:52.244 - 00:28:57.310, Speaker B: I mean, yeah, just keep on, sorry I had problems with the mic. Just keep on explaining.
00:28:57.492 - 00:29:35.454, Speaker A: Okay. Okay, where am I? Oh, oh, I just demonstrated that. So, so, so we are expecting that both function after calling both function status should be one because we already leave that context. But in this case, the, the re entrancy log is never allowed. So this is pretty bad. Which means this line of code is never triggered by this function. It is never triggered.
00:29:35.454 - 00:29:38.974, Speaker A: So the control flow ends here.
00:29:39.914 - 00:29:41.130, Speaker B: Okay, interesting.
00:29:41.202 - 00:30:00.944, Speaker A: So if you don't believe it, I can show you the, show you in the debugger. This is the call. Let's go into the debugger. I think this s assembly. Yes. So executing this line. Okay.
00:30:00.944 - 00:30:25.034, Speaker A: Require, require, require updating the state variable. Lock it, lock it, lock it. Lock it, go into the assembly. This is just one to one. You see, I push 40. No, I mean I push four two onto the stack. I push for two onto the stack is here.
00:30:25.034 - 00:30:47.100, Speaker A: I do add store. Now memory should be updated. Memory has four two. I push onto the stack, stack change and then return. Boom, finish.
00:30:47.172 - 00:30:50.724, Speaker B: Basically the modifier is being ignored by this time leaf.
00:30:50.764 - 00:30:57.084, Speaker A: Basically this line is never executed because this is just like a leap.
00:30:57.204 - 00:30:58.308, Speaker B: Oh, okay.
00:30:58.356 - 00:30:59.252, Speaker A: It's returned.
00:30:59.348 - 00:30:59.844, Speaker B: Understand?
00:30:59.964 - 00:31:42.984, Speaker A: So yeah, just remember in solidity everything looks good. But in your, if you do this return, don't expect anything to happen after, right? Yeah. So, so even though you write code after it, the function is not going to trigger it. So just beware. In this case it is pretty bad because it is like a dos to your contract after calling this. Like the lock is never got a lock. So anything, any call after that, reverse our contract at doS.
00:31:42.984 - 00:31:49.224, Speaker A: Okay, so do we understand this part?
00:31:49.804 - 00:31:50.544, Speaker B: Yes.
00:31:52.204 - 00:31:53.664, Speaker A: Let me see the comment.
00:31:59.804 - 00:32:08.384, Speaker B: So basically from what I understood, whenever you're dealing with you, when you call return, you actually call in the return of code and nothing will happen after that.
00:32:10.404 - 00:32:26.944, Speaker A: Yeah, basically like that. Yes. Yeah. So solidity has that, uh, like the smart part, but in Yuo is just like a brutal return. Returns earned. I think people understand. Yes.
00:32:26.944 - 00:32:53.124, Speaker A: Yeah, this, this is the return. The size. Yes, this is the return data. The actual data location, which is memory. Yeah, I think people understand it. Yeah, pretty sure, yeah, this is pretty interesting.
00:32:53.584 - 00:32:54.376, Speaker B: Really?
00:32:54.560 - 00:33:17.720, Speaker A: This one is interesting. Yeah. I think the first one is just like a warm up. But the second bug, I don't think many people understand this, so same. If you want to try on your own, just follow my step. You copy my code. I share my code here, copy my code and go into there.
00:33:17.720 - 00:34:10.310, Speaker A: Just like click something and then hit debug and then just trace the opcode one by one. Let's move on to the third one. So we are 40 minutes in. I'm not going to be very thorough on this one, but it is a homework assignment for you anyway. So basically everything starts here. Openzep in December 7 last year, disclose a bug happened in their library where you have to combine like your contract, have to inherit two contracts. The first one is 27 71.
00:34:10.310 - 00:35:00.624, Speaker A: The second one is multicol. You have to have both contracts inherited. So ERC 271 is a metadata transaction, which means metadata transaction. Just for example, like a user doesn't hold eTh or any native token on the certain chain, but they want to send a transaction. However, because they don't have the native token, they can't pay gas, right. So mad transaction means you make a offline, I mean off chain, off chain agreement with some third party and then they pay you the gas. So for example, you want to withdraw like $20, right.
00:35:00.624 - 00:35:41.854, Speaker A: The third party probably argue like $0.50 for gas and then they give you 19.5 token and then the lost part is just like used as fee. So they are paying the gas. If you look at the diagram, basically this user doesn't have the native token and then this trusted forwarder is paying the gas. This is like a third party company, they are doing this as a service. So this one is the target contract.
00:35:41.854 - 00:36:35.084, Speaker A: And in the case of attacker, just user is attacker. The victim contract is this. So this one is actually pretty easy to understand from the high level. But if you want to figure out the detail, it's gonna take I would say more than 2 hours to figure out the details. Basically the idea is you are calling the trustee forwarder, but the victim contract doesn't know who you are. So they only know this trusty forwarder and this guy knows who is the, the actual message are sender. Right.
00:36:35.084 - 00:37:27.390, Speaker A: For example, if I want to, if I want to know who is the message that sender, it is using this function inside the Openzep clean library. So the definition of this one is just, it's gonna look for the last 20 bytes of your call data. So this is a pretty, pretty naive implementation, right. So it's only looking at the last 20 bytes of the call data. So somehow you can, you can just manipulate that. Right. How to manipulate the coordinated part is you executing multicall to the trusted forwarder.
00:37:27.390 - 00:37:52.234, Speaker A: So inside multicol it is like a delegate call. So although the name is multicall, but you are just using that to do one call. So we are just utilizing the delegate call part. So we do a delegate call. Here it is. The forwarder calls. Multicall is when trusted so they can communicate.
00:37:52.234 - 00:38:28.640, Speaker A: And then you are just manipulating the call data to add the trusted third party at their address to the end of the call data. So the message does that. So message sender function in the victim contract is going to parse that part and think this one is legit. I think it's probably pretty hard to understand.
00:38:28.832 - 00:38:32.924, Speaker B: Yeah, I mean we can have an idea, but it's a little bit hard to understand.
00:38:34.104 - 00:39:05.924, Speaker A: Yeah. So I'm, yeah, so I just want to make it as a homework assignment so you can very nice learn on your own because it's pretty hard to explain. So the idea is just you, you have to have ERC 2007. Also we have to have multicolored. You have these two functionalities combined to make this call data, like call data manipulation attack. I will call. Okay.
00:39:05.924 - 00:39:33.938, Speaker A: And so I suggest you follow this one. Follow the top one. The causes like 85 ethers lost. It gets you into a falcon ide and you can just play with that falcon.
00:39:33.986 - 00:39:35.094, Speaker B: That's really cool.
00:39:36.954 - 00:39:44.994, Speaker A: You can do that in the tip. Yeah. I'm not going to work this through with you.
00:39:45.454 - 00:39:46.334, Speaker B: No problem, bro.
00:39:46.374 - 00:40:02.294, Speaker A: Put it on your own. Okay. Yeah. It's gonna take more than hour to explain everything. This one is slightly more complex. Yeah, the idea. The idea.
00:40:02.294 - 00:40:29.774, Speaker A: I just said it. But I don't think anyone understands some help that you can use. Actually 30K had this article. This article is pretty nice. It is actually pretty correct. This one is the best article on this hack I found on the Internet. And if you are doing this on your own, make sure you go into openzepping library.
00:40:29.774 - 00:40:57.186, Speaker A: But don't look at the like the latest code because they already fix everything. You just click on the. On the commit and then go back to probably like half a year ago. That version was 4.8 or something. Like you can look at the old code, right. I have this coded analysis here if you want to check it.
00:40:57.186 - 00:41:22.690, Speaker A: Also last week, I think it was last week, we can openzap. Lin hosted Ethernet CPF and there was a challenge based on this hack. You can try that on your own. They released the infrastructure, also the challenge code so it can deploy everything locally and stop it unroll. Yeah. Okay. Thank you.
00:41:22.690 - 00:41:24.410, Speaker A: That's everything for today.
00:41:24.602 - 00:41:25.218, Speaker B: Awesome.
00:41:25.266 - 00:41:26.414, Speaker A: Any question?
00:41:26.724 - 00:41:33.304, Speaker B: Also, dog man, congratulations on the talk. Very nice. Um, you guys have.
00:41:35.004 - 00:41:36.024, Speaker A: Live event?
00:41:36.644 - 00:41:42.204, Speaker B: Nah, you did super great, bro. Let me see if people have questions here. Most likely.
00:41:42.284 - 00:41:52.724, Speaker A: No, ask me like, like any question. Uh, not necessarily on the technical part. You can ask me like general question.
00:41:52.804 - 00:41:53.390, Speaker B: Awesome.
00:41:53.492 - 00:41:55.650, Speaker A: I want to know. Too personal.
00:41:55.802 - 00:42:07.214, Speaker B: Okay. I want to know a little bit about the experience of being an intern on a auditing forum. What your day to day looks like, how much you've been learning from that.
00:42:09.514 - 00:42:37.404, Speaker A: Yeah, I can talk about it. So basically when I got into the internship, they are. They almost finished with a taiko audit. Taiko right now is running a contest on Coderina. That's the same one. I read their report and then I studied Zika. Roll up that things for like two weeks.
00:42:37.404 - 00:42:58.790, Speaker A: And then after that I got into the rest audit. I just mentioned that. So it is like a Ros version of Go Ethereum written by paradigm, right? That one is pretty hard. Actually. It is pretty hard. First is written in rust. I didn't have experience on rust.
00:42:58.790 - 00:43:17.922, Speaker A: I just learned the language from zero. And then I have to learn gas first. And because that's pretty hard, you have to understand gaffer in order to audit graph. So I learned go.
00:43:18.018 - 00:43:18.634, Speaker B: Awesome.
00:43:18.714 - 00:43:38.226, Speaker A: Go then. And then I. I studied gap and then I go back to study Roth once more and then I come back to rath. But it's still pretty challenging. I still have like two more weeks here. I have to find some bug to prove myself. But.
00:43:38.226 - 00:44:12.874, Speaker A: But I don't think the. The internship is hard for everyone because I am doing this audit because I think it is because like my supervisor is the manager of this project. So if you got into Sigma prime, probably you will get some easier experience. If you are a supervisor is handling like some normal smart contracting. You know, it is always easier to audit solidity.
00:44:12.914 - 00:44:26.734, Speaker B: I will say, can you talk a little bit. Sorry, can you talk a little bit about not. You don't need to disclose the details of. But what is the interview process like? You have one interview with the manager, then you have to do a technical test.
00:44:28.874 - 00:44:43.894, Speaker A: Yeah, I can talk about it. Interview it. Just the first round was a technical interview with dual senior authors. And then the second interview is a co founder.
00:44:44.054 - 00:44:47.474, Speaker B: So the technical challenge were solidity based.
00:44:49.534 - 00:45:13.880, Speaker A: Technical challenge? Yeah. They will ask you solidity, but there is a personalized part. So basically you have to introduce yourself, introduce your background. If the interviewer knows some challenges other than solidity, and you mentioned that you know it, they will find out if you really know it.
00:45:14.032 - 00:45:14.844, Speaker B: Awesome.
00:45:15.944 - 00:45:38.904, Speaker A: Yeah. Let me check. Check out the comment area. Follow the EVM course on ciphering. Abstract EVM course I think is the foundry plus solid course. Right.
00:45:40.764 - 00:45:41.784, Speaker B: Must be.
00:45:43.724 - 00:46:10.074, Speaker A: Learn anything. I recommend you to learn e five in general. For example, uniswap, compound, optimism, those famous names. You have to know the defi primitives. I actually think the solidity part is less important. Defi is important.
00:46:10.574 - 00:46:17.434, Speaker B: There's any trick to learning defi, any path you follow. They gave you some sort of advice on how to learn that.
00:46:18.194 - 00:46:38.014, Speaker A: Basically you have to read documentation, you have to read the source code. After that you can just find like a similar context. On Coderina, for example, I will say learn compound first and then go to code arena and search for Venice prime.
00:46:38.954 - 00:46:39.914, Speaker B: Really nice.
00:46:40.074 - 00:46:59.114, Speaker A: It's Venice and Venice prime. So this project is pretty similar to compound and it was audited last year. And you can read the report or if you have time, you can just like shadow audit everything. Right.
00:46:59.974 - 00:47:12.460, Speaker B: How busy have you been recently? You know, I mean, how. How auditing is influencing your life? I mean, are you feeling more stressed? Are you being able to handle.
00:47:12.572 - 00:47:14.548, Speaker A: Pretty busy? I'm depressed.
00:47:14.676 - 00:47:17.212, Speaker B: No, bro, you're so good. Don't be depressed.
00:47:17.268 - 00:47:18.148, Speaker A: We don't know, man.
00:47:18.236 - 00:47:23.716, Speaker B: We hear, man. Don't be depressed. Don't be depressed. We here. Okay. Yeah.
00:47:23.740 - 00:47:30.668, Speaker A: I'm joking. Yeah. Just because I had to with Roscoe. Roscoe did pretty hard on me.
00:47:30.756 - 00:47:45.654, Speaker B: Pretty true. Amazing. Amazing, brother. I mean, very nice presentation. Do you have any closing thoughts, any message, one of the people that will hear this in the future?
00:47:49.114 - 00:48:25.598, Speaker A: I actually have one, but yeah. Anyway, I will just mention. So DK hack that community. Just reach out to me saying they want me to host a moon math DK manual study group on their score. So it's probably happening in April. But on their side, they are still discussing, like they want to invite the author team, also the CEO of this authority. They want to invite somebody there.
00:48:25.598 - 00:48:37.192, Speaker A: Right. So once we figure out the. How it's going to run the. The opening date, I will share link here.
00:48:37.368 - 00:48:41.844, Speaker B: Awesome. I'll be super excited. Also, I'll make sure everybody goes there.
00:48:42.664 - 00:48:48.644, Speaker A: Yes. So I know you should only do that if you really want to learn.
00:48:50.144 - 00:48:57.284, Speaker B: And I guess we have one last question from switch Gen E. How long you've been auditing when you got your first payout?
00:48:59.204 - 00:49:08.900, Speaker A: My first payout? I think. I think about half year to make my significant payout.
00:49:09.012 - 00:49:09.824, Speaker B: Awesome.
00:49:10.564 - 00:49:16.676, Speaker A: Yeah, before that, it's just like, if I just like bullshit. $20, $50.
00:49:16.860 - 00:49:31.572, Speaker B: But that's. Yeah, yeah, that's. That's the standard. I mean, that's. That's the standard. Most guys, they'll get. Yeah, they'll get shitty payments and she wait months and then start to have mid payments and after a year they start having like a.
00:49:31.572 - 00:49:33.784, Speaker B: Then, you know, then it just goes up.
00:49:34.884 - 00:49:59.774, Speaker A: Yeah. I think the. The key is just you have to find out, like, which subfield that you are good at. For example, if you want to do rust, if you want to do DK or even rust. Plus DK is what I'm doing, you have to find like, a niche that you are good at, which can distinguish you from other people.
00:50:00.634 - 00:50:01.534, Speaker B: Amazing.
00:50:02.234 - 00:50:16.054, Speaker A: So just. Yeah, just focus on that. For example, you can do l two. You can focus on DK. Roll up and focus on Dkevm, right? Yeah, something like that.
00:50:16.554 - 00:50:19.954, Speaker B: Awesome. I think this is it. Thank you so much for coming.
00:50:21.174 - 00:50:21.774, Speaker A: Thank you.
00:50:21.814 - 00:50:34.474, Speaker B: It's a pleasure talking to you. Every time. You're always super available in a super cool and smart dude. I hope we bring more people like you here. Feel free to come anytime you want. And this is it, everyone. Thank you guys for showing up.
00:50:35.174 - 00:50:36.622, Speaker A: Yeah, thank you, Irwa.
00:50:36.758 - 00:50:37.174, Speaker B: See ya.
