00:00:00.490 - 00:00:17.310, Speaker A: Hello everybody. Really, really excited to be chatting today with Jocelyn from the trail of Bits team. As a lot of you know, I'm a big trail of bits fan because of all the tools that they make, all the content that they make, all the security, just mindset that they instill in everybody. So, Jocelyn, thank you so much for being here. How are you doing today?
00:00:17.380 - 00:00:22.362, Speaker B: Hey Patrick, thanks for having me here today. Doing really good and looking forward for this discussion.
00:00:22.426 - 00:00:37.942, Speaker A: Awesome. Yeah, we have a lot of really cool stuff to talk about. We were chatting on Twitter about formal verification, symbolic execution, security in web3 and all this good stuff. And so we're going to jump into all that. But yeah, Jocelyn. So why don't you introduce yourself? Who are you? What are you working on? Perfect.
00:00:37.996 - 00:01:01.562, Speaker B: Yeah, sure. So my name is Jocelyn Feist. I'm montilly on GitHub, Twitter and different social media. I am the engineering director of the blockchain team at Trello. I've been working in the infosec space for about a decade now with a focus on blockchain security for the past six years. I would say my background is mostly a mix of vulnerability research and program analysis. I have a PhD in static analysis and symbolic execution.
00:01:01.562 - 00:01:19.410, Speaker B: I am the author of a couple of security tools you might know Slitter, which is a static analyzer for solidity regarding what I'm working on. So I basically split my time between leading the team, helping the different team member whenever they have a need, working on our security assessment, and working on the development of our different tools.
00:01:19.490 - 00:01:27.334, Speaker A: Badass. Yeah. And actually when I was going through slither the first time, I remember, what is it? Montley, how did you pronounce that?
00:01:27.372 - 00:01:28.950, Speaker B: Montely. Montle.
00:01:29.290 - 00:01:44.906, Speaker A: Yeah, yeah. Your GitHub name. And I remember seeing montely everywhere and I was like, who is this guy? And it was you. And it was the director of engineering at Trail of Bits. Yeah, big fan of Slither. Big fan of all these tools. So you got your PhD in, what did you say? You said form of verification and symbolic execution.
00:01:44.906 - 00:01:45.914, Speaker A: Form of verification.
00:01:46.042 - 00:02:00.466, Speaker B: So it was static analysis in general and symbolic execution. But at the time I was not working on blockchain. So it was like for traditional program and traditional program analysis for binary execution and stuff like that before working on.
00:02:00.488 - 00:02:18.278, Speaker A: Any blockchain things, that was just kind of general software in the general. So why don't we dive into that a little bit? So a lot of people, especially in the security space, are not familiar with formal verification, symbolic execution, even static analysis to a lesser extent. What are those?
00:02:18.364 - 00:02:50.222, Speaker B: Okay, that's a really good question, because we see a lot of confusion and we see a lot of questions in the space. So on a high level, formal verification is going to be the act of proving or disproving a given property of the system. This is usually done through a mathematical model of the system and the property. I'm saying property. Some people say invariant. Both words are meaning the same. A property can be things like, I have a token, I have an ERC 20 token, and the balance of a user should not be greater than the total supply.
00:02:50.222 - 00:03:13.162, Speaker B: If you have a total supply of 1 million and the balance of a user is 2 million, something is wrong. Right. This is an example of property. You can also have property at the function level. For example, if you have a function that compute a price, the price should be in a way that no one can get an asset for free. Symbolic execution is then one of the techniques that you can use to do formal verification. It's not the only one.
00:03:13.162 - 00:03:25.130, Speaker B: For example, another technique which is also used and common in the space is called abstract interpretation. If you want, I can give you a quick walkthrough of the difference of symbolic execution and abstract interpretation to give a bit more insight.
00:03:25.210 - 00:03:33.386, Speaker A: Yes. So just real quickly so that I am on the same page. So the definition you just gave is for symbolic execution or formal verification.
00:03:33.498 - 00:03:41.230, Speaker B: So formal verification as a whole. So formal verification is going to include different techniques. Symbolic execution is one of this technique.
00:03:41.390 - 00:03:52.470, Speaker A: Right. Okay. So formal verification is this technique of mathematically proving something in your software. And symbolic execution right now is just one of the most popular ways to do that.
00:03:52.540 - 00:03:54.614, Speaker B: Yeah, it's one of the way to do that.
00:03:54.732 - 00:04:02.218, Speaker A: Okay. Or one of the ways to do that, yeah. So you said you brought up a new term that I'm not familiar with. It was abstract. What was that one?
00:04:02.304 - 00:04:03.670, Speaker B: Abstract interpretation.
00:04:03.750 - 00:04:05.978, Speaker A: Abstract interpretation, yes. What is that?
00:04:06.064 - 00:04:58.310, Speaker B: So it's another technique to do formal verification. So it's just to keep in mind that there are different technique and family of things that you can do to prove a mathematical property over like a program. Symbolic execution on a high level is going to be a technique where you are going to have your program and you are going to try to explore the different path of the program. And for every path, for every execution path, you are going to create a mathematical representation. Abstract interpretation takes a slightly different kind of, instead of going to explore all the different paths of the program, what AbSac interpretation is going to do is that it's going to try to represent all the different path as like one step so while simplic execution is going to explore the different path, abstract interpretation is going to kind of track the different paths in one representation.
00:04:58.470 - 00:05:18.194, Speaker A: Yeah. So just kind of hearing the definition, I feel like that's really difficult to grasp. I've done my deep dives into symbolic execution and like exploring paths, I get it. But now you're saying, okay, abstract interpretation, to me it almost sounds like the same thing. I'm trying to abstract the paths, I guess. Is there an example that you can give?
00:05:18.232 - 00:05:20.178, Speaker B: Yeah, maybe I can share my screen.
00:05:20.264 - 00:05:25.906, Speaker A: And then maybe we probably even should do a symbolic execution example for those who are a little confused though.
00:05:26.008 - 00:06:17.006, Speaker B: And the thing is that all this technique might, seems kind of difficult to follow, difficult to understand. But once you get an example, usually it's not that difficult. There is a lot of terminology that you might need to learn or you might need to get into, but the core of this technique are not that complex for symbolic execution. As I mentioned at the beginning, it's a technique where alpha is going to try to explore a different path of the program. If you take this function, there is only one path, right? There is no condition, there is no loop, there is nothing, there is no control for it, only one straight path. And the way symbolic execution is going to look at this is that it's going to instruction by instruction and it's going to create a formula which is going to be a mathematical representation of what this does. So for example here it's going to say a is symbolic because it's an input.
00:06:17.006 - 00:07:01.874, Speaker B: It can be like any type of value here is going to say a is equal to a plus one, right? And here is going to what? So if you think in term of pass here, basically you have one pass, which is exactly what I mentioned, right? Is equal to a plus one and what one. So here there is one things to consider. If you have overflow enabled for the protection, this is going to revert, right? Because if you give as an input a, which is going to be the max urine. When you do an addition here, you can have an overflow and you can revert. So there is actually two paths. There is one path, which I just described, and the second one, which is going to be where a is equal to Max U. Sorry.
00:07:01.874 - 00:07:06.638, Speaker B: Which also makes the assumption that the other path has inverted this. Right.
00:07:06.744 - 00:07:46.634, Speaker A: Interesting. Okay, so you're saying. So symbolic execution is going to look at, see that these two paths can exist and do what? Because I was originally thinking that symbolic execution is going to be trying to convert these to some mathematical formula you stick that into like a sat solver or something. You're saying, no, it's almost like, hey, all right, here are all the paths. There's no conditionals, so there's no branches there, but there is this overflow chance. So because of that, now there are two paths, I guess. Why is my mental model of symbolic execution not quite matching up here? Are we not converting this to a set of mathematical formulas?
00:07:46.762 - 00:08:32.170, Speaker B: So you are going to convert to a mathematical formula, and this can be seen as a mathematical formula where you have an assertion that a is not equal to some value, and then you have another assertion in your mathematical formula that a is increased by one. This is going to be one formula. Now you can provide this formula to a solver. You mentioned a sad solver. You're going to use a solver, which is usually like an SMT solver. People are using z three, for example, a lot. And now that you have this formula and the solver, you can ask the solver, is this path feasible? Can you find an input? Can you find a valuation of a such as, this is true here, the solver might reply with any value for which this formula is true, basically any value of a, unless the max.
00:08:32.250 - 00:08:47.074, Speaker A: Now for this symbolic execution, do we kind of manually have to be the ones to walk down the paths and basically figure out these paths? Or is this something that there's automated programs can do for us?
00:08:47.112 - 00:08:48.978, Speaker B: Yeah, the automated program will do it for us.
00:08:49.064 - 00:08:49.458, Speaker A: Okay.
00:08:49.544 - 00:09:02.422, Speaker B: And as you can imagine, there are different technique in the way you're going to explore the path. If you have a loop, if you have different kind of structure, you might take different direction. So this is going to be dependent on the engine of the simplic execution, right?
00:09:02.556 - 00:09:37.810, Speaker A: So just to take a step back, give the summary for people. So we have a couple of concepts that we've introduced here. We have formal verification, which, as we said, is a way to mathematically prove that software does something, right, or doesn't do something. Is that also accurate? All right, cool form of verification, way to mathematically prove software does or does not do something. Symbolic execution is one of those methods where the process of symbolic execution involves finding all the different paths and branches that your software can take and then converting them to expressions. Is that part of symbolic execution as well as converting the paths to expressions?
00:09:37.890 - 00:09:38.902, Speaker B: Yeah, that's correct.
00:09:39.036 - 00:09:39.622, Speaker A: Great.
00:09:39.756 - 00:09:52.178, Speaker B: And now that you have this formula, you might want to add additional conference to them, but in this example it might not be that useful because it's a function that just does plus one, right?
00:09:52.284 - 00:10:01.382, Speaker A: But it's good for the high level, the easy. All right, we have a minimal example. Yeah. All right, so example two, now we're getting tricky. Now we have some conditionals that exist.
00:10:01.526 - 00:10:42.938, Speaker B: Exactly. So here we have a condition, and if we think about the different paths that are here, you still have two paths, both of them terminate. There is no vert, like there is no overflow here, because if a is greater than ten, you just return zero, right? So here in the first path, you will have first pass, you will have a this and then return zero. And the second one is mostly the same as here. But so here you have two paths. The first one, you just go through it, you have a is greater than ten, which run zero. Second one, a is below or equal to ten, and you do exactly the same operation as before.
00:10:42.938 - 00:11:32.602, Speaker B: Now you have two formula for the two path. Okay? So now you might want to add additional information. You might want to have a properties in this system. Let's say you want to check if this function can return 100, whatever, right? So now you can take the two path and you can add as a condition that return 100. So for the first one, it's obvious that it's not going to happen, right? But now for the second one, it's a bit more tricky, right? Because you have this condition here, a human can solve the equation, but you can imagine that within the execution of a contract, with the addition of the difference, operation, assertion, and so on, the formula might become complex. And here you can ask a solver to solve this. The solver is going to tell you that's not possible.
00:11:32.602 - 00:11:43.134, Speaker B: You cannot have a path where this function return 100, because here it returns zero, and here it return a plus one, but a is below greater or equal to ten, so it's not possible.
00:11:43.332 - 00:12:08.098, Speaker A: Now this additional piece that I kind of jumped in, and now we're kind of talking about. So we, symbolic execution, we take this function, we convert it to these mathematical expressions like path one, path two, et cetera. And then we're talking about now sticking it into a solver, right? What is this solver? Is this an important step? Does symbolic execution always follow this step of a solver?
00:12:08.194 - 00:12:38.234, Speaker B: Yes. The reason for that is that if you don't have a solver, you're going to create formula. But maybe the formula is not reachable. Like let's say if you have this, and then you have another condition. If a is equal to zero, something, this is not possible, right? Like you cannot have an input that is greater than ten and equal to zero. So here you will have like a pass, which is not feasible. That's why when you use symbolic execution, you have to ask a solver to see if what you are exploring is feasible.
00:12:38.234 - 00:12:56.050, Speaker B: This is a toy example, but in more complex system, you might have a loop, right? And you might iterate over some condition on the loop. And you have to check if you can continue to iterate and go into an additional iteration of the loop. If you don't have a solver, you are just going to create formulas that does not represent actual execution of the program.
00:12:56.200 - 00:13:03.798, Speaker A: And so what are these solvers called? What are these solvers called? So you do your path, you stick it into a what?
00:13:03.884 - 00:13:31.038, Speaker B: So most of the people are going to use SMT solver. There is kind of a standard which is called smtlib. It's like this, which is a standard representation in the way you are going to create this formula. So you have like kind of a standard to represent this formula. You follow the smtelib and then you can use a couple of the shell solvers, such as web3, burektor, yikes. And everything. There's like a panel of different solver that you can use.
00:13:31.038 - 00:13:55.010, Speaker B: And the solver is really just here to take the formula, try to solve it, either provide you with an input that solves the equation or tells you that not visible. Sometimes the solver might not be able to solve the equation too. Like if the equation is too complex, you usually provide a timeout to the solver, just because if you have to invert hash functions, good luck to do that with the solver.
00:13:55.090 - 00:14:39.926, Speaker A: So these solvers were asking questions. Obviously, when we ask a solver a question, it's not going to be like, hey, solver, does this thing work in Web three? Let's say I want to do this process, I want to do symbolic execution, and then I want to stick my formulas into a sad solver so that I can find out, hey, can I be rugged, right? Or can the amount of liquid staked tokens be more than the deposits? Or. These are the type of questions we would want to ask this to make us safer in web3, right? Are the popular tools or what does this look like in practice in Web three? So you mentioned Z three, you mentioned some of these other solvers. What is this process? What are the tools that I would use to do this?
00:14:40.028 - 00:15:14.394, Speaker B: Okay, so if you want to do symbolic execution, you are not going to build the formula yourself. You're going to use something which is already existing. There are a couple of tools such as Mantico, the one time verification folks with KVM is also something that is similar to that. There is SMT checker in the solidity compiler, there is Mahate, which is another tool from twelve bits. There is in the DAP tool, there is assembly execution in HeVM. There are a couple of tools that you can use. When you're going to use them, you are not going to need to wizard about the path exploration as a user.
00:15:14.394 - 00:16:03.818, Speaker B: Basically you are probably going just to provide a property, something that you want to test. For example here the only property that you want to test is can the function return 100. The way you are going to express this property is going to depend on the tool. Some tool are just going to use solidity of the actuality code. For example here we'll use like the assertion from solidity and say this for example, sorry, and try to see if this can be reached. So here symbolic execution engine is going to express a different path. It's going to reach this and it's going to try to generate a formula and serve the formula such as this is other tool, for example searchora or the one from one term verification where you specify specification in a NaDoc language, which we call DSL for domain specific language.
00:16:03.818 - 00:16:16.290, Speaker B: So here instead of using solidity, you will use some specific kind of script to provide. So here there is like a way to express a function. Two can return 100 in some kind of script environment.
00:16:16.710 - 00:16:54.462, Speaker A: Jocelyn, so this seems like obviously like a really powerful tool, right? I know for everybody who's watching, this is kind of a smaller example, right? Can the function return 100? But as we said, we could do something bigger, like hey, does the total supply ever get too big? Right? Does somebody pull out more money than they put in or et cetera. Those are things we formally verify. We can say, hey, this is mathematically guaranteed to be ruggable. I feel like that might be a horrible marketing term that would come about from this. But how practical is this to do in real life? How practical is it to take all these steps? How hard is this to really do?
00:16:54.596 - 00:17:41.306, Speaker B: There are a couple of things to consider. The first one is that this specific technique, symbolic execution, has a couple of limitations. As you're going to explore the different path of the program, there is a problem which is called the path explosion problem, which is basically if you have too many paths to explore in the program, it's going to take forever. If you have an infinite loop, you're going to have a trouble, right? Because you might just generate paths thin like the end of the time. If the solver cannot solve an equation, you might time out, you might not be able to give you an answer. Usually this technique, simplic execution, tends to do what we call under approximation, in the sense that it might not represent all the possible behavior of the system and only a subset of them. Because of this pass explosion problem, there are other techniques that perform differently.
00:17:41.306 - 00:18:21.110, Speaker B: I mentioned abstract interpretation. Abstract interpretation is a technique that is going to, instead of doing under approximation and give you only a subset of the behavior of the program, it's going to do the opposite, and it's going to give another approximation. So it's going to give you an approximation which contain behavior that might not be real, but it's kind of like a safer subset. Now, how this technique behave in practice, it's a really good question. It's a tricky one, because when you want to use this technique, you might need domain specific expertise to use them properly. As I mentioned, you might need to help the engine to deal with the loop. You might need to write manually a loop invariant.
00:18:21.110 - 00:18:50.614, Speaker B: You might need to rewrite part of the code base to make it amendable for formal verification. Two functions that does exactly the same, but written in different way with different pattern, might not be as good for formal verification, because depending on the code pattern, the tool might be able to reason easily or not reason in practice. We used Manticore, which is assembly execution engine in the past, during our audit, and the way we are using it is that. What was this tool?
00:18:50.652 - 00:18:51.750, Speaker A: Sorry, I missed it.
00:18:51.900 - 00:18:52.818, Speaker B: Manticore.
00:18:52.914 - 00:18:54.534, Speaker A: Oh, you used Manticore in the past? Okay.
00:18:54.572 - 00:19:48.582, Speaker B: Yeah, and we use it as kind of a targeted tool for specific piece of code that were really critical with a lot of concern. However, what we kind of learned over the years is that one kind of the promise of formal method and formal verification to prove the absence of bug does not really hold. The reason for that is the thing I mentioned. You might need to rewrite code, you might need to provide custom summary of the function, so you might make a mistake, the solver might time out, you might not explore all the different parts of the program as a result. If you are looking to have a proof of that sample of bug, it's going to be difficult. It might work for some specific situation, but in a generic and absolute sense, it's probably going to be out of reach. This technique requires significant effort to be used.
00:19:48.582 - 00:20:50.506, Speaker B: You need to understand how they work, and you need to understand their limitation and how to help them, and also significant effort to be maintained, because as you can imagine, there is a lot of engineering going there. At the end of the day, I think what kind of really matters are the properties, the things that you want to reason about your code, or so called invariant. In this example it was, can we turn 100? But in any more complex system, you need to think about complex properties. Now, if you want to check your properties, if you want to know if a bug can occur and if the property can be broken, you don't necessarily need formal method for that. And you can use a further, which is way easier to use and provide kind of the same type of value. The way a further is going to work is that it's going to take your contract and it's going to generate more or less random value as input for the contract. So here a further is going to say, okay, there is an unit, I'm going to try to run it with one zero, ten, one hundred, one million and so on.
00:20:50.506 - 00:20:52.554, Speaker B: So it's just going to provide one dom value.
00:20:52.672 - 00:21:54.490, Speaker A: So actually, before we go into fuzzing, just so that we kind of, kind of like tie that piece together, we're basically saying symbolic execution, even symbolic execution or form of verification, that isn't even necessarily a way to guarantee your code is bug free. It's a way to guarantee the answer to some question is such. Right? But you're saying a number of things here, right? Hey, maybe you have hundreds of questions that could possibly ask. You have to be the one to ask all those questions. And if you forget a question like, oh, you forget to ask your solver, can this be flash loan attacked? Right? Okay, cool. Then some weird exploit that you didn't think of, that's going to happen. You're also saying that, correct me if I'm wrong on any of this, you're saying that doing this method requires a lot of effort, right? You have to do all these extra pieces, you have to work with Manticore, you have to input the stuff into the SAT solver, and you have to be knowledgeable to know to understand the output, understand how to do the inputs.
00:21:54.490 - 00:22:11.430, Speaker A: And so you're saying, hey, in practice, maybe it doesn't make sense to use this a lot. You can use an easier tool, which is where we started talking about fuzzers. But you're saying at kind of the high level, most people probably aren't going to need to use formal verification. Is that right?
00:22:11.500 - 00:22:16.530, Speaker B: Yeah, correct. It's a bit sad because I love formal verification and I love symbolic execution.
00:22:16.610 - 00:22:20.246, Speaker A: I was going to say you got your PhD in it, right? So you're like, oh, man, I love.
00:22:20.268 - 00:22:43.870, Speaker B: To work on this technique, right? But from a practical point of view, it might not be like the best usage of resource for most of the people. Most of the time, public execution or formal method is going to give you one additional step, but it's going to be valuable only if you have reached some level of maturity, which fairly, like most of the team, don't reach. So.
00:22:43.940 - 00:23:05.142, Speaker A: So let me ask you this then, Jocelyn. So if, let's say we get fairly mature, right? And I go, I'm protocol y, I go, I want to guarantee that XYZ can happen. I'm going to get formally verified, and I go ahead and I take these extra steps, I take the extra time, I go ahead, my code is now formally verified. Is it bug free?
00:23:05.276 - 00:24:06.794, Speaker B: It's not. Something that kind of hinted is that there's this notion of property or invariant. And the best that you can do with this technique is to prove or disprove a specific property or specific invariant. So yes, you can prove your property, your invariant, but if your invariant is bad, if your invariant is not meaningful, sure, you prove something that is not meaningful, right? In this example, can the function return 100? It's probably not that meaningful, right? So sure, I can prove it, but maybe there is still a bug in there. And what really matter is really to think about invariant and to think about the property that you want to check. If you have a good list of invariants, even if you check them manually, with unit test, with furthering or with formal method, it doesn't matter as much as having a good understanding and coverage of what are the properties and invent of your system. If you have even a list in markdown, like a straightforward list, saying my system should, does ABC, whatever, you are kind of 80%.
00:24:06.794 - 00:24:31.810, Speaker B: How you check them, how you test them, how you verify them, is like the next step. But really sitting down and thinking about your system in term of invariant and property is the most important part. And from experience, people that does formal verification and even furthering sometimes end up finding bugs even before running the tool, just because they were thinking about the invariant and they look at the code and something obvious might pop up, right?
00:24:31.880 - 00:24:39.586, Speaker A: And so we didn't actually define this. So, for those of you who don't know, excuse me, for those of you who don't know, Jocelyn, what is a property? What is an invariant?
00:24:39.698 - 00:25:12.702, Speaker B: So it's things that you can express with respect to your system. Again, we are like the example of the token. We are the total supply. The balance of a user should be below or equal to the total supply, it can know. Like if you have an arithmetic, a plus B is equal to B plus A, depending on the type of arithmetic you use. If you have lending protocol your compound interest only, it's going to depend on the system. There is some property that you might be able to reuse over time, but a lot of them are going to be dependent on the system.
00:25:12.836 - 00:25:33.334, Speaker A: Right? So it's a property, an invariant is something about your system that needs to always hold, that needs to always be true. Right. You mentioned the one about compounding interest. Right. That's something very applicable to defi. It's a protocol like compound, the exchange rate of the C tokens of their interest bearing tokens. That always needs to be going up.
00:25:33.334 - 00:25:49.420, Speaker A: Otherwise a lot of bad stuff happens. Exactly. So fair enough. So that's what a property and invariant is. Okay, great. So sorry, I derailed this a little bit here. So we were talking about, hey, how practical was this? We're saying it's probably not that practical, maybe for a very specific use case.
00:25:49.420 - 00:26:04.330, Speaker A: How often do you actually use symbolic acquisition or form of verification in an audit? There's a lot of auditors, a lot of people trying to get into security here. How will they be using this tool to do their audits?
00:26:04.490 - 00:27:15.394, Speaker B: We used to use Monticorm more in the past, but as we are moving forward, we kind of realized that the value added by this technique versus using a further was not just like a good comparison. So while we were using this type of technique in the past, during two or three years ago, as of today, we use mostly fuzzing because from a practical standpoint, it's going to provide more value. If you have two or three weeks to work on the security aspect of a system, you are going to have way more coverage and you have to go and have more confidence with a further on what you can do with symbolic execution, formal methods in general. Now, if you have six months of resource to work and to verify your codebase, sure, go for it. If you have a couple of weeks to dedicate it just for security, maybe consider what tool provides the best value for what you are trying to do. There is kind of a marketing benefit of using formal methods, because as you mentioned, people have formal methods and they think, yeah, it's bug free, it's formally verified, but from an engineering standpoint, from a practical point of view, might not be like the best outcome.
00:27:15.442 - 00:27:33.662, Speaker A: No, that makes a lot of sense to me, and I think there's definitely that sentiment in the industry. Okay, cool. We got formally verified. We're bug free. Ha. And then, prize surprise, some of those protocols that are formally verified end up getting exploited. Because exactly what we talked about, right? Maybe the path exploration wasn't good.
00:27:33.662 - 00:28:13.106, Speaker A: Maybe the properties and variants that they asked the software to do weren't very good. And people go, oh, how could that happen? Well, this conversation hopefully shed some light there, so I'd love to ask this too. So you guys at trail of bits, a lot of your tools, actually, most of your tools are open source. Like Slither is a static analysis tool, which we have not defined yet. We will. Manticore we talked about, which is symbolic execution form of verification tool. There's optic and echidna, which are smart fuzzers, hybrid fuzzers that kind of do this weird symbolic execution in the background to make fuzzing better, which we didn't define fuzzing either.
00:28:13.106 - 00:28:25.642, Speaker A: I'll ask us to do that as well. Why do you guys make all these tools open source? There are a lot of other companies out there who say, hey, everything's closed sourced. If you want access to our tools, you got to pay us a bunch of money. Why do you guys make them all open source?
00:28:25.706 - 00:28:44.242, Speaker B: Okay, that's a great question. First, we are building the tools that we need. So we're already building them. It's something that we are using during audit. Because I provide value to our engineer on a high level. I think we are genuinely happy to help back the community. We believe in open source, we believe in open research.
00:28:44.242 - 00:29:45.762, Speaker B: I think it's great when you work impact and help other I know external team that found critical bug using and I think it's really nice to be able to give back. We kind of want to help with industry security practices and as we are one of the leader in the space, we can actually do it. If we were doing the opposite and keeping everything for ourselves would be more difficult. Finally, I think we are usually lazy by nature, and I am in that sense, like, if I'm finding the same bug in five different project manually, I just don't want to find it again manually. I want a tool that does it for me. And the landscape of vulnerabilities is large enough that if you can kill a percentage of bug using tool, you should just do it. If you can automatize part of your workflow and then you can focus on more complex and in depth issue, you can really focus on what is related to the project and have all the simple bugs fixed before even you reach like a security assessment.
00:29:45.762 - 00:29:48.966, Speaker B: I mean, I think it's great to.
00:29:48.988 - 00:30:19.090, Speaker A: Summarize so yeah, you want to give back, you want to increase the space, but also you got sick and tired of seeing the same shit in people's code and you were like, just stop here, here's the tooling to make yourself safe. Just stop giving me the scrappy code. That's kind of what happened. Yeah, basically I kind of like that description a little bit more because I think it's a little funnier. But yeah. So thank you guys for giving back to the space and for making these tools open source. I know I use slither all the time.
00:30:19.090 - 00:30:36.754, Speaker A: I've used the kid. I'm trying to use optic more. But yeah, I absolutely love it. But I did want to kind of formally ask these as well because we've kind of been dropping definition or dropping introducing terms that people might not be familiar with. Two of them in particular. First one is, what is static analysis?
00:30:36.882 - 00:31:15.474, Speaker B: That's a broad topic. So on a really high level, static analysis is a type of program analysis that is used to analyze the code without executing it. The one with an engineer and developing software is using static analysis with a compiler. It's like probably the most common static analyzer that people are using. It's going to look at your source code, it's going to analyze the source code and at the end it's going to produce a bytecode. There are other tools like, or like linter or different technique, but it's kind of a world topic that combine everything that relates to program analysis, of analyzing a program without executing it.
00:31:15.512 - 00:31:39.514, Speaker A: So it's analyzing your program without actually executing it. Got you. Well, so there is one, it's a tool that kind of reads through your code, doesn't actually execute anything. Another one that you mentioned that people probably don't know is the solidity compiler in a way that is static analysis. It's not actually executing your code, it's just kind of reading it and looking for things that it finds. Slither is a great example of static analysis tool. I recommend everybody run it.
00:31:39.514 - 00:32:11.938, Speaker A: It's got a lot of hard coded. Hey, is there a reentrancy here? Is there the poor solidity versions that you're using? Are you shadowing variable declarations? Although I think the solidity compiler does that too. Perfect. That's what static analysis is now. So the other tool term that we've been dropping a lot and we've been dropping this and we're saying, hey, yeah, symbolic execution form of verification, probably not worth a time investment. Usually most people instead could just do some type of smart fuzzing now, what is fuzzing?
00:32:12.034 - 00:32:58.050, Speaker B: So fuzzing is an old technique in security. The idea is really you take a program and you send a random input to the program just to stress it. For example, the most basic further that you can think of is you take your keyboard and you randomly hit your keyboard, like on some specific input just to see how your program reacts. In traditional software, people are using fuzzing to find crash, for example, memory corruption or segmentation fault or these type of things that you might have seen in C, C plus plus, and this type of language. For smart contract, we don't have memory corruption or it's kind of not that common. What we are looking more are issue with the logic. And here comes the invariant.
00:32:58.050 - 00:33:17.110, Speaker B: Here comes the property that we mentioned for formal verification. So the way we use fuzzing in the smart contract space, it's called property based testing, or property based fuzzing because we have a property that we want to work, and we are using fuzzing just to generate input to try to see if the property can be broken.
00:33:17.190 - 00:33:58.998, Speaker A: So if I can see if I can summarize here. So fuzzing is this methodology of providing random inputs to test. And property testing is the kind of overall umbrella of we're trying to break some property of our system or some invariant, which again, we've defined as a forceme that always holds true. To use compound, for an example, the invariant or property of the system is the C token exchange rate should always go up. Right. That is the property that we're going to try to break. And we're going to use fuzzing as our methodology to apply to this, where we're going to add random data, we're going to do random function calls to try to break this.
00:33:58.998 - 00:33:59.430, Speaker A: Awesome.
00:33:59.500 - 00:33:59.782, Speaker B: Exactly.
00:33:59.836 - 00:34:29.842, Speaker A: Now, we chatted about this a little bit. This is actually when you originally dm'd me foundry. So foundry kind of has a little bit of confusing terminology where their invariant tests are basically this type of stateful fuzzing where it's just a bunch of random function calls and random data. They also have fuzz tests, though, which are just doing random data. And we're saying like, both of those are technically property based tests using fuzzing. They just have kind of their own naming conventions for those. Is that.
00:34:29.896 - 00:35:25.634, Speaker B: Yeah, the convention is a bit confusing. We actually open a GitHub issue on foundry to kind of try to clarify the terminology. But yeah, in foundry, they are making a separation between first test and invariant testing, and it's currently the same the way they do the separation is that, as I mentioned at the beginning, you can have invariants that are with respect to a function or that are stateless, or you can have invariants that are with respect to the system that are stateful. Like for example, the token is an example of stateful invariant where any user should have, no one should have a balance greater than the total supply. This is something within the system. It's a system invariant, a stateful invariant. Another example of function level testing was this situation where you have a function that compute a price, that just take like some parameter and return like a number of assets, an invariant there can be that you should not receive asset for free.
00:35:25.634 - 00:35:36.520, Speaker B: You should not receive asset if you send zero amount. And you might be able to check this without any state. You might be just stateless if the function is, for example, a pure or a view function.
00:35:37.370 - 00:36:06.238, Speaker A: Got you. And I did just want to comment too for everybody out there. So I would definitely agree that fuzzing and using this methodology is much quicker. And although I haven't used symbolic execution enough, fuzzing is a much quicker way to find results quickly. In one of my first competitive audits, actually, I used a fuzz test to find a really kind of random edge case where somebody could steal a ton of money. And that was one of my first findings in a competitive audit. So it's definitely a very powerful tool.
00:36:06.238 - 00:36:38.954, Speaker A: So I do want to ask though, so just let's kind of tie out this formal verification symbolic execution piece here. What do you think of the landscape of formal verification right now? How important is it for me to use a tool like certora versus me? Just saying. All right, I'm just going to use solidity's built in SMT checker versus I'm going to use the z three there. I'm going to write my own path execution thing for those very specific few edge cases where I'm like, you know what? No, I do need to use symbolic execution. What do you think of the landscape right now?
00:36:38.992 - 00:37:10.626, Speaker B: That's a good question. There are actually a lot of tools out there that does this type of techniques. In fairness, I don't think all of them are usable for production. They might work with toy example, they might work with some piece of code. But if you try to do something like analyzing compound or maker dow or a complex system, it might not hold, for example, the SMT checker or the symbolic execution in HeVM. I think they are okay for small code. I haven't seen them used in complex contract.
00:37:10.626 - 00:37:54.766, Speaker B: To the best of my knowledge. Some other team are doing good work and some other team are legit and have powerful tool one time verification. They have tools that have been used in more complex system, however they are going to be more complex to use. The one time verification one with KVM is free. So you can try it by yourself or is it like a paid services? I think if you kind of seek for malverification, you can ask yourself are you trying to do that because you are curious and you want to learn more or you just want to explore and then you can just try the different tools that are out there. If it's for production really code, then it's really like a question of resource and engineering budget. So if you're not using a further which is free and there are a lot of further.
00:37:54.766 - 00:38:07.606, Speaker B: I know we have a kidnapper, but there is one in Daptool, there is one in foundry, there is one in Bonnie, all of them are free, right? So should try to start by that before spending resource on something which is more time and patreon of intensive makes.
00:38:07.628 - 00:38:29.422, Speaker A: A lot of sense. Is there some other tool or some other technique, some advanced security thing that we in web3 are not using that we should be using? Or for those who are curious, who want to get deeper, is there something more than these fuz tests and these property based tests that we can or should go down?
00:38:29.556 - 00:39:03.978, Speaker B: That's a good question. I think something that community might not benefit enough is all the things that comes with Slitter. Slitter as you mentioned, is a static analysis tool. I think 95% of the people that are using it, are just using it through the command line, running Slitter and reading the result. We actually have a lot of features that are open source and provided with Slitter. For example, we have the inbuilt printers which are visual representation of the code base and we use them a lot in audit. For example, you can print a control for graph or things like that.
00:39:03.978 - 00:39:33.650, Speaker B: But I don't think as many people use them as we do. Slitter comes with also a couple of additional tools. For example, we have a tool to check for upgradability. We have a tool to check for ERC confirmments or to read on chain storage value. They are open source, they are there, but I don't think a lot of people benefit from them. Something that we recently open source is a property repo. This repo contain pre built uh, properties for common ERC and for arithmetic library.
00:39:33.650 - 00:39:55.574, Speaker B: We talk kind of a lot about the properties and defining invariant and things like that. This repo actually provide a lot of inbuilt invariant and properties that you can just reuse directly. You can use them in unit or directly with contain ERC 20, C 4626 and a fixed point invariant. Fixed point arithmetically invariant.
00:39:55.702 - 00:40:38.134, Speaker A: So this repo is almost like a, hey, copy and paste our tests in a way. Oh, so yeah, this definitely seems like something that people should be using. So this is kind of more, instead of a tool, this is almost like a repo with just a lot of information. They say, hey, it almost sounds like to me we have most of the tooling that we need. We just need people to understand what's going on behind the scenes better. We need to have places like this where we say, hey, here's kind of the boilerplate tests that you should be running or that you should be thinking about. Is that accurate? It sounds like you're saying, hey, we have most of the tools, we just need people to be educated to learn more of this stuff.
00:40:38.134 - 00:40:38.758, Speaker A: Is that right?
00:40:38.844 - 00:41:20.070, Speaker B: I think in comparison to three or four years ago, where a lot of the knowledge was not public and all the tools were not necessarily mature and was difficult to use, I think nowadays information is tool available. Everyone can use a feather, everyone can use this property. So it's really a matter of start to you. Sometimes. From time to time, we see an incident on an exploit on a vulnerability that slitter can find. And it's always like, maybe just one slitter in your CI, it's free and it might prevent a tragic incident. Something that is sometimes difficult for people is really to understand how to create this property and how to create invariant for themselves.
00:41:20.070 - 00:41:55.662, Speaker B: If someone wants to learn a bit more, we have this website, it's called securetrack.com, where we go a lot of guidance and best practices. And among other we have tutorial on how to use akinna, how to define invariant, how to think about properties. We also have a fuzzing workshop, which is a theory of stream where some of our engineers go through the process of writing invariant for simple to complex systems. So if you want to learn more about how to use this, and if you want to learn more about the process of writing this property, I would recommend to go through securecontract.com and fuzzing workshop.
00:41:55.726 - 00:42:23.930, Speaker A: Securecontract.com and also the properties crytic is that you say it. Properties crytic GitHub repo two resources to do exactly what we said, to learn more about security, to get smarter about security, and then copy paste some tests so that you can build some really cool tests in your protocols out there. Awesome. Yeah. Jocelyn, is there anything else that the web3 security space should know about? Yeah. Do you have any other thoughts about web3 security?
00:42:24.080 - 00:42:43.886, Speaker B: I think we cover kind of like the main point. I think we have reached a level of maturity where in 2023, if you are not thinking about properties, if you're not using at least one fuzzer in your development process, you're probably doing it wrong. So no content here are public and free. There's no reason to not at least try them.
00:42:43.988 - 00:43:07.494, Speaker A: So if you're not using a fuzzer, if you're not using pretty based testing, you're probably doing it wrong. You heard it here first. I actually 100% agree with you. I think fuzzing these days should probably be the bare minimum. Right? I think everyone should be doing fuzzing at some point. Cool. And then anything you'd like to say to coming up, security engineers or auditors who are learning, who are looking to get in the space, anything you'd like to say to them?
00:43:07.532 - 00:43:42.114, Speaker B: Okay, good question. Yeah, I think the blockchain space for the security industry is really interesting in the sense that a lot of things are public, a lot of things are open. This is different from traditional security where people might be more conservative about the information. So you have an opportunity to learn from existing foundation and existing tool, existing research, existing projects. So don't know to try to contribute, don't hesitate to try to learn from other because I think the community, like the security community in the blockchain space, is welcoming. So if you want to learn, if you want to go, don't hesitate to participate and ask questions.
00:43:42.232 - 00:44:19.470, Speaker A: Awesome. Well, Jocelyn, thank you so much for chatting with us today and giving us all this amazing alpha about security, about the web3 auditing journey, about just security in web3 in general. Thank you for building all the amazing open source tools. And thank you as well for doing all the amazing auditing work and getting sick of seeing the same bugs to the point where you go, I'm just going to make a tool so I don't have to see that anymore. So in a weird way, thank you to everybody who putting code on Jocelyn's plate that had the exact same bugs because you pissed him off to the point that he made the security of this space better. So thank you for doing that.
00:44:19.540 - 00:44:22.990, Speaker B: Thank you for inviting me. It was a really nice conversation.
00:44:23.570 - 00:44:28.620, Speaker A: All right, well, thank you so much for being here. We really appreciate it. Thank you everybody else, and we'll see you all soon.
