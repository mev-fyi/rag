00:00:00.410 - 00:00:00.960, Speaker A: It.
00:00:02.210 - 00:00:05.040, Speaker B: Okay, so it says we're live. We're not actually live. Don't worry.
00:00:07.410 - 00:00:08.654, Speaker A: Okay. Yeah.
00:00:08.852 - 00:00:26.406, Speaker B: Welcome, everybody, to another cypher interview. We've been on a formal verification roll right now, and today we're going to continue that with karma from a 16 z, who's been working on the Halmos tool, and we're very excited to have you here. Karma, how are you doing?
00:00:26.588 - 00:00:29.926, Speaker A: Hey, Patrick. I'm doing good. Thanks for having me on. Super excited to be here.
00:00:30.028 - 00:00:39.570, Speaker B: Absolutely. Well, thank you so much for being here. So, karma, what do you actually prefer to go by, by the way? Is it karma? Is it karma coma? What is your preferred tag?
00:00:39.730 - 00:00:42.866, Speaker A: Yeah, karma works. It's short for karmicoma.
00:00:42.978 - 00:00:47.082, Speaker B: Short for karmicoma. All right, cool. And then karmacoma. That's your tag on Twitter, right?
00:00:47.216 - 00:00:49.802, Speaker A: That's right, yeah, that's my web three Persona, I guess.
00:00:49.856 - 00:01:15.890, Speaker B: Web three Persona. Okay, cool. Well, anybody who wants to follow karmicona on Twitter, I highly recommend you do so, because he posts a ton of very niche memes that are very funny, but you have to have a lot of context for them to be funny. He's posted, like, formal verification memes and stuff, but nobody gets them, except for the few of us that understand formal verification or fuzzing. But eventually, karma, one day everyone will understand them, right?
00:01:16.040 - 00:01:19.800, Speaker A: I know twelve people understand my memes, but feels good.
00:01:20.810 - 00:01:31.386, Speaker B: All right, cool. Well, karma. Yeah, just to jump into it. So you're working at a 16 z as a formal verification security research engineer, actually. What is your title there?
00:01:31.568 - 00:01:33.542, Speaker A: I'm a research engineering partner.
00:01:33.686 - 00:01:39.180, Speaker B: Research engineering partner. Okay, so partner, what does the partner bit mean?
00:01:39.550 - 00:01:50.734, Speaker A: It's part of the investment firm terminology, but really what it means is my job is research and engineering. Right. We have a research team and an engineering team, and I'm sort of struggling both.
00:01:50.852 - 00:01:54.660, Speaker B: Yeah, gotcha. Makes sense. And then what do you do mainly? What are you mainly working on?
00:01:55.750 - 00:02:27.180, Speaker A: So right now, I'm really mostly focusing on Halmos. Right. So improving the tool and communicating about it. And that's probably, like, one half of the job. The primary part of the job, really, is helping portfolio companies. Right. So basically working with other engineers, protocol engineers, people trying to test or could be reviewing designs, architecture, pull requests, incentive design, all this sort of good stuff at the solidity level.
00:02:28.030 - 00:02:33.260, Speaker B: So just anything a security person would be interested in, that's what you're working on?
00:02:33.790 - 00:02:52.706, Speaker A: Yeah. So I'm not just focused on security. We do have proper security people. Dejun, who I worked a lot with, is very much focused on correctness. We have Matt Gleason, who's amazing at actual security, reviewing, auditing, looking for vulnerabilities, type of things. I'm more focused on protocol design and testing. So a little different.
00:02:52.706 - 00:02:55.810, Speaker A: We all have different flavors that we're focusing on.
00:02:55.880 - 00:03:13.094, Speaker B: So protocol design and testing. So I guess here's where my mental model starts to break down a little bit, because I thought you were the lead maintainer of Halmos, and if you're working on Hamos and then you're also doing this protocol design, how are you balancing that? Is that something that you constantly struggle with?
00:03:13.292 - 00:03:32.510, Speaker A: It's about 50 50, yeah. So sometimes it's frustrating because I have some ideas. I have basically too much ideas and not enough time. Right. So I have a bunch of things I would like to work on to improve helmets, but I also need to help these companies work on their protocol because they want feedback. And it's also super exciting. But literally, my problem is that the days are too short.
00:03:32.510 - 00:03:40.210, Speaker A: Right. Right. That's the balancing act, is just trying to fit everything in one day. But that's only 24 hours, so that's the difficult part.
00:03:40.280 - 00:04:00.918, Speaker B: Well, thank you for spending some time here to tell other people about what you're doing. I really appreciate it. Okay, so spending 50 50, spending 50% of your time doing protocol design, helping these projects just get better. And the other 50% working on Hamos. So, something that is really interesting to me. So we've spoken with. And we were talking a little bit about this before we started recording.
00:04:00.918 - 00:04:16.554, Speaker B: We've spoken with Chandra from Certora. Right. She's working on the tool working on Certora. And their whole thing is form verification. We've spoken with Paulina from runtime verification. Same thing. Their whole thing is formal verification.
00:04:16.554 - 00:04:39.030, Speaker B: And now we're speaking with you, and you're working at a 16 z, whose whole thing is not formal verification. How does a formal verification tool play into a 16 z's? Well, I mean, obviously, you don't have to tell us the roadmap or anything, but, yeah. How does it play into that? How does it make sense for an investment firm to have this arm?
00:04:39.850 - 00:04:55.734, Speaker A: Yeah. So, I think initially, the project was started about last year by Dejun, my coworker. And that's really because he wanted it. Right. He needed a tool like that because he does a lot of auditing. Right. And so he wanted a different kind of tool to help him basically perform, essentially, audits.
00:04:55.734 - 00:05:23.122, Speaker A: Right. Correctness focused kind of audits of portfolio companies and their code bases and I was not at the firm yet, and I saw that, I was like, wow, that looks really cool. And I started playing with it for ctfs. Right. Initially I got nerd sniped into Curta. I was like, hey, can I try to use this tool to basically solve the challenges for me because these are basically too hard. And so for a smooth brain like me, if a tool can do it, sounds pretty good.
00:05:23.122 - 00:05:49.334, Speaker A: And I did, right. And so initially I was like, wow, okay, that thing actually works on real problems. Right. And so the idea overall of the tool is that we want to be able to say interesting things about EVM bytecode in general. And so it's super interesting in all sorts of ways. Right. So you have, the CTF aspect is kind of for fun, but it's also a nice way to benchmark the tool fundamentally, it's really also for bug finding.
00:05:49.334 - 00:06:12.066, Speaker A: Right. Like you're auditing a protocol and you want to get to those last beats, right. And you want to try to make sure either that it's retightened down or that you want to find some bugs. Right. And so having solid tools to help is nice. And there's already fuzzers out there. So we're taking a different approach and we can talk more about that if you want, but it's not a matter for me of which one is better.
00:06:12.066 - 00:06:31.674, Speaker A: But it's nice to have different tools that work differently, they have different strengths. Right. And so, yeah, for us it's really about, can we help? It was really scratching our own itch initially. Right. Can we help portfolio companies with this kind of tool that's a little different than what they're used to, maybe. And it's also like a research platform to some extent. Right.
00:06:31.674 - 00:06:57.460, Speaker A: Because it's in python, because it's different. We can talk about the other tools if you want. We're taking a different approach. Right. We're never going to be as complete as some of the other tools out there, but we're trying to be a little faster, a little more iterative, and sort of tailor the tool for different use cases. But yeah, the idea essentially is can we try to help make protocols more secure with these kind of tools? That's different from what we see.
00:06:59.270 - 00:07:17.000, Speaker B: Interesting. So you got nerd sniped into fe. I feel like that's kind of how everyone gets into form of verification. They're like, wow, this is a really cool topic. Let me divert over choose. So you were working on Curta, right. Which is a really cool capture the flag for anybody who watching definitely go check that out.
00:07:17.000 - 00:07:35.550, Speaker B: Why a form of verification tool to solve kurta puzzles. I got to move fast. I want to solve these. Like the quick in me goes, okay, I'm going to use a fuzzer. I'm going to do manual review. Why were you drawn to Halmos? Why were you drawn to this form of verification tool?
00:07:35.620 - 00:08:27.902, Speaker A: Right? But to some extent what you can do is you can sort of disregard the whole formal aspect of it. To me, in my context, what formal verification means is it's a tool that knows how to reason about it's code that can reason about other code, right? And that's kind of difficult, right? You have all the halting problem and path explosion and all these kind of things, but really fundamentally that's what it is. It's a program that can ingest another program and say stuff about it, right? Which is kind of what we're trying to do, right. When you edit a code, what you're doing is you're running an interpreter in your mind, right? And if you're good enough and your interpreter is like feature complete, you can maybe find a little something that the others who are running a different emulator in their mind, they didn't see, right. And so to me that's cool and it feels good when you find something, but it doesn't scale, right? Very much. So. Ideally, I would like to turn this kind of process into a tool.
00:08:27.902 - 00:09:06.650, Speaker A: And that's where formal version comes in, is you need to define the interpreter in a way that can let the program reason about it, right? And so when we go to something like a CTF, we're trying to find a solution to a problem, right? And you're literally asking the tool like, hey, here's a problem, give me a solution, right? And if the tool is good enough and you formulated the problem in the right way, it may be able to actually come up with a solution for you, right? It's kind of like instead of doing mental calculus, just use a calculator that works really well for that type of problem, right? So that's the idea here. It's like, okay, if you can use a tool that does this for you, why would you use your brain power on that and do something else?
00:09:06.800 - 00:09:08.006, Speaker B: But why not a fuzzer?
00:09:08.038 - 00:10:06.302, Speaker A: Then? If a fuzzer works for your problem, it's cool, use that, right? The problem is with a further is you're going to hit a wall at some point. So to me, the strength of a fuzzer is if you're looking literally randomly, right, by definition. So what we are trying to do is you're trying to explore a search space for your problem, and some inputs sprinkled somewhere in that search space are going to trigger an issue, maybe, right. And so then the question is like, okay, you have a haystack and some needles, and so how efficient the fuzer is going to be is going to depend on the size of the haystack and how many needles you put in there. So if you have exactly one needle in a massive planet size haystack, this fuzer is not going to work. Right. But if you have a bunch of handfuls of needles all over in a fairly small haystack, then, yeah, the fuzzer is going to go through it and after a couple of thousand runs, maybe find something.
00:10:06.302 - 00:10:40.118, Speaker A: And that's cool, right? But it doesn't scale much beyond that once you go past, I don't know, actual numbers, but even a million runs start getting a little expensive with something like the foundry fuzzer. So if you're talking about trillions of runs at this point, it's hopeless, you're not going to find it. It's not a matter of just showing more compute. You're hitting the randomized threshold, basically at some point that's not going to get you anywhere. If you have one wrong value in all of the U into 56 space, you're not going to find it. Right.
00:10:40.284 - 00:10:49.450, Speaker B: So kind of the completeness of FV is something that is more exciting to you. You feel like kind of a random walk isn't good enough is what you're saying.
00:10:49.600 - 00:11:37.660, Speaker A: Right? So random walk is cool, right? I mean, if you can find something quickly with it, it's great, do that. But at some point you will stop finding stuff. You will time out. And so then what do you do? Right? So what's cool with something like a v is by reasoning about the actual semantics of your program, you take it from a different direction, like you're sort of turning inside out and say, okay, can I look at this? Can I reason about the loops and the storage and the memory and the Abi, all these things? And maybe actually you can say stuff about it, right? You can say, well, no, this storage location will never be overwritten or this type of whatever is relevant to the problem. And once you've established that you can move past, right, you can progress and say, okay, I don't need to spend days of compute on this. It's like I've proved it, I can move on to the next thing. Right.
00:11:37.660 - 00:12:01.986, Speaker A: So that's what's interesting for me. Is like if randomizer works and you can pick something up quickly, it's all cool. But yeah, at some point you're going to hit a wall, you're going to time out and you don't know. That's the real problem here is once you hit a wall and you're not finding a bug, is it because there is no bug, right. Or is it because there is one? But it's just kind of too hidden, right? I mean, too rare. Right?
00:12:02.168 - 00:12:05.714, Speaker B: This was part of your talk at the. What was it? Dev connect, I believe.
00:12:05.752 - 00:12:08.050, Speaker A: Right? Yeah, the solid summit.
00:12:08.630 - 00:12:36.490, Speaker B: Everybody who is watching this should definitely go watch that, by the way. Go watch karma's talk. He talked about exactly this. Right? Hey, if you use a fuzzer, great, you're going to find issues, but you're always going to have this question. Are there any left where what you're saying is, hey, form of verification, you do not have that question, fuzzer. You will find bugs quickly. Yes, but there will always be a small percent chance that there's another needle that you didn't pull out of the haystack.
00:12:36.490 - 00:12:46.002, Speaker B: So cool. Makes a lot of sense. So have you always had this mentality, what were you doing before a 16 z? Have you always been like, oh, I want to work on these. Really cool. Complete.
00:12:46.056 - 00:12:46.226, Speaker A: Yeah.
00:12:46.248 - 00:12:48.100, Speaker B: What were you doing before a 16 z?
00:12:48.630 - 00:12:57.230, Speaker A: Yeah. So there is a little bit of a cheat code there, which is I did a PhD in formal verification, but that was something like 15 years ago.
00:12:57.320 - 00:13:00.040, Speaker B: Cheat code. Getting a PhD is a cheat code.
00:13:00.490 - 00:13:21.742, Speaker A: Yes. It does help with this kind of stuff. I do have a background in this kind of low level semantics, trying to reason about logic and this type of stuff. And that's how I came to the US in the first place. Then I took a sort of long detour in basically fang. Right? So I got a job at Apple. I was doing compiler stuff there.
00:13:21.742 - 00:13:47.650, Speaker A: Super interesting, but much less academic, much more applied, obviously. Then I took another long detour at Netflix. I was doing distributed systems. So completely different things, just more like the craft of the actual software engineering, learning distributed systems, managing incidents, the cloud, like pure web two stuff. Completely. And recently I sort of went back. I didn't go back, actually.
00:13:47.650 - 00:13:57.318, Speaker A: I picked up web three and the vms skill. And I think it's going to probably be used to you, but I went through your boot camp two years ago.
00:13:57.404 - 00:13:59.560, Speaker B: No way. Which one?
00:14:00.170 - 00:14:23.530, Speaker A: It was summer 21. 2021 is the year I decided. Okay, I've been reading about the EVM, I've been reading about bitcoin and all these things sort of as a spectator. And I've tried some demos and stuff like that. At some point I was like, okay, I need to learn this thing inside out. I want to learn solidity and how the VM actually works. And so I went through your smart contract bootcamp.
00:14:23.610 - 00:14:24.510, Speaker B: Oh, badass.
00:14:24.670 - 00:14:26.146, Speaker A: Was it the yellow paper?
00:14:26.328 - 00:14:29.566, Speaker B: Was it the brownie one or the hard hat one? Probably one of the two brownie.
00:14:29.598 - 00:14:31.810, Speaker A: Yeah, it was Python.
00:14:33.750 - 00:14:44.646, Speaker B: No way. Oh, cool. That's fantastic to said. So basically you were like, all right, cool. Fang is cool, but, like, overrated. Whatever. Let's jump into this evm thing.
00:14:44.646 - 00:14:55.178, Speaker B: I'm going to go check out this random dude on freecodecamp who kind of talks kind of loudly about how much he loves python and stuff. And now here you are.
00:14:55.344 - 00:14:56.586, Speaker A: Exactly. Yes.
00:14:56.768 - 00:14:57.974, Speaker B: Wow, I love that journey.
00:14:58.022 - 00:14:58.490, Speaker A: Oh, wow.
00:14:58.560 - 00:15:00.122, Speaker B: Oh, that's so exciting that you took the course.
00:15:00.176 - 00:15:01.030, Speaker A: Yes, excellent.
00:15:01.110 - 00:15:01.740, Speaker B: Cool.
00:15:03.150 - 00:15:03.514, Speaker A: Great.
00:15:03.552 - 00:15:08.746, Speaker B: Okay, so now you're here. Now you're like, okay, I'm going to try Hamos on curta ctfs.
00:15:08.858 - 00:15:09.466, Speaker A: Boom.
00:15:09.578 - 00:15:29.846, Speaker B: Did really well. I want to keep doing this. This is really cool. And now you reach out to Hamos, or Hamos reached out to you, something happens. You start doing Fe at a 16 z. You mentioned something a little bit earlier. You said Hamos is never going to be as complete as some of the other tools out there.
00:15:29.846 - 00:15:42.620, Speaker B: And that kind of stands out to me, I guess. Why did you say that? What is the goal of Hamos, if you know why? Yeah, why not? Why will it never be as complete as some of the other tools out there?
00:15:43.150 - 00:16:13.940, Speaker A: Well, just to give you an example, we don't do gas at all. There is not a single mention of gas anywhere in the tool. So that's one thing we just don't model at all. So if your logic relies on gas anywhere, we're not modeling it literally, which means we're not a full EVM compliant interpreter. We cannot pass the tests that regular Guest EVM has. We're not actually a full EVM. Right.
00:16:14.310 - 00:16:30.114, Speaker B: And actually, hold on real quick before we keep going. So for those of you who are unfamiliar with form of verification or symbolic execution, go back and watch the talk with either Chandra or Paulina. We went over it a little bit more in one of those. So that's your homework. If you're coming to this with nothing but. Sorry.
00:16:30.172 - 00:16:30.346, Speaker A: Yes.
00:16:30.368 - 00:16:38.460, Speaker B: Okay, so, Hamas, you're not doing any gas. You're also not doing any. What did you say? You're not doing any EVM modeling. What was that last bit?
00:16:39.950 - 00:17:21.026, Speaker A: Yeah, just to give some idea. Okay, what is Hamas really, fundamentally? It's an EVM, right. My previous project was small EVM. So the idea was like, hey, can we take the yellow paper, the PDF, and turn it into like a working Python small implementation just for learning purposes. And Halmos to some extent is the same thing, just kind of more serious and more industry grade. But it's still, at the end of the day, just a Python interpreter for EVM bytecode, right? But the way we interpret it, instead of executing it directly on your cpu is we encode it into SMT formulas. And that's kind of where the magic of simplicity comes in.
00:17:21.026 - 00:17:46.994, Speaker A: We don't execute directly. We translate it. Right. So you can think of it as a sort of transpiler, in a sense, right? So we have SMT solvers out there like z three and stuff like that, that are great, and we sort of treat as a black box. But what they do, they don't know about DVM, right? All they ingest is SMT formulas. So basically complicated symbols, you feed it into them, and they come back with a yes or no, like, does this work or does this not work? That's the job. That's what I do.
00:17:46.994 - 00:17:47.378, Speaker A: Right.
00:17:47.464 - 00:18:22.042, Speaker B: So Hamos is almost like. Whereas Python is like an interpreted language, right? It compiles well, it takes your code and it figures out what you're trying to do and turns that to machine code, whereas something like rust or c plus plus is compiled. It actually takes it and goes, boom. Here's the binary for this. Hamos is kind of similar to Python in this regard. You're saying it interprets it into this SMT language. And then again, for those who are unfamiliar, z three is one of the most popular SMT languages for doing formal verification.
00:18:22.042 - 00:19:07.420, Speaker B: Right? You can basically think of it as transpiling your code into a massive set of booleans that can be evaluated to true or false at the end. What Halmos is doing, you're saying it's literally a transpiler for s and t lib. I don't know how much we want to talk about other tools here. I was under the impression that kind of all tools under the hood were using z three, right? Or not some type of s and t lib, right? But you're saying they're not necessarily actually transpiling it. They are using z three, but yours is almost kind of more of, I don't want to say like directly, indirectly, but just taking it, translating into z three, running z three and then calling it a day.
00:19:08.190 - 00:19:40.440, Speaker A: I think we work in that sense roughly in the same way. So we all use some kind of SmT solver as a back end, right? Right. Z three is pretty common because it comes out of Microsoft research, and it has nice bindings in all sorts of languages, which makes it super nice to integrate, especially in Python. So if you're a Python developer, you should really pick up on z three python. It's super amazing. It lets you type essentially natural idiomatic python and then ask, hey, solve this equation for me. So it's great for homework, it's great for all sorts of cool things.
00:19:40.440 - 00:20:02.090, Speaker A: Not enough people know about this. It kind of feels like magic when you use it. Literally encode anything you want, and you say, hey, solve this for me. Sometimes it will time out or return unknown because it cannot necessarily tree everything. But it does solve a lot of super cool stuff anyway. So we use that as a back end. Most people use either exactly this one or something similar because it's easy to integrate.
00:20:02.090 - 00:20:49.398, Speaker A: Now, I think the main difference is in the way we encode and what we choose to encode, right? So because we choose to not encode gas, for instance, we say, hey, we're a gas free evm interpreter in a sense, which means we can run by code forever. We will not run out of gas because we just choose to not model it because it's going to be more efficient. So what that means is the SMT formulas that we produce are going to be smaller because that's what we choose to focus on. Right. So I haven't looked at the internals, but I think control by runtime verification is probably a lot more complete. It will model the semantics, like exactly one to one, the way they're supposed to be interpreted. They can probably pass the whole EVM compliance test suite.
00:20:49.398 - 00:21:14.820, Speaker A: So that's not a goal for us. Right. It's important to understand the limitations of the tool you're using. And so our focus is like, not producing false positives, but we can produce false negatives, right. Because we choose to not encode some things. If you ask us the question like, hey, can this ever revert without of gas? We will answer, no, it's not possible because we don't know about gas. Right.
00:21:14.820 - 00:21:36.620, Speaker A: But some of the tools may be able to answer that question and say, oh, yes, actually, if you run that loop a thousand times, you will run out of gas, right. But they sort of all work the same in that sense. They all take your EVM bytecode and somehow transpile it into something that an SMT solver can reason about and start answering questions.
00:21:37.070 - 00:21:50.014, Speaker B: Gotcha. Interesting. I feel like I'm learning so much more. And it's pythonic, which to me always just feels really good. Right. Big fan of python stuff, hence that brownie video that you saw a few years ago. Okay, cool.
00:21:50.014 - 00:22:37.262, Speaker B: So the goal is, hey, we want to make this easy to use tool that is going to be kind of very quickly with really solid developer experience. Karma was nice enough to actually jump on a call with me. I was having an issue trying to recreate this square root verification thing that I was doing. He jumped on and I was like, oh, this is so hard, blah, blah, blah. And he's like, dude, you can just run this command on one of your foundry tests and you're good. And I was like blown away by that. I was like, what? And yeah, this very kind of developer friendly form verification tool where as you're saying, okay, maybe it's going to miss out on gas or something, but what it's not going to do is it's not going to steer you wrong.
00:22:37.262 - 00:22:42.794, Speaker B: Worst case scenario, it's going to tell you something breaks when it doesn't, just because you're not modeling gas.
00:22:42.842 - 00:22:43.102, Speaker A: Right.
00:22:43.156 - 00:22:47.890, Speaker B: So the goal is to have this very quick, easy to use form of verification tool. Is that kind of the goal?
00:22:48.470 - 00:23:02.694, Speaker A: Yeah, kind of. Basically a couple of design goals. So, like, not being complete, I mean, that's not a design goal, being easy to pick up. That to me is the key. Right. I want something just like foundry. I'm a foundry power user, I guess you could say.
00:23:02.732 - 00:23:03.302, Speaker B: Yes, sure.
00:23:03.356 - 00:23:13.594, Speaker A: And I love it. And I love writing my test in solidity. Right. And I love the cheat codes and I love this whole interface. Right. I don't want to have to deal with Javascript or any of these other ecosystems. Right.
00:23:13.594 - 00:23:34.434, Speaker A: So I like staying within solidity. I think it's super expressive. It just feels natural. Right. You write your code, you write your tests, you can iterate fast, no context switching. The tool was designed like that initially, but we're already sort of doubling down on this type of interaction model just because it's super readable, super expressive, so you don't need to learn a whole new thing. Right.
00:23:34.434 - 00:24:03.030, Speaker A: If you're already familiar with this type of testing that's been popularized by DAP tools, I think initially, and then foundry, I mean, it's great. You're already in that ecosystem, you're already familiar with this type of stuff. It's super comfortable. Right. So we're doubling down on that. You literally don't even need to learn about anything about SMT or z three. I mean, we're talking about it now, but to some extent this is all abstracted away, right? That's what the tool provides for you is you write solidity, we get the output of the compiler.
00:24:03.030 - 00:24:33.250, Speaker A: All we know about is EVM bytecode. We don't actually know about solidity, even with a pure EVM bytecode tool. Which means we can also test Viper, we can test Huff. All we care about is EvM bytecode, right? We turn that into Smtlib, we run v three on it for you so you don't have to. And that's it. That's kind of the kind of iteration we have in mind. So having a good developer experience to me is super important, having performance as good as we can make it.
00:24:33.250 - 00:25:05.622, Speaker A: So that's why potentially making trade offs like gas and stuff like that, being Python also means it's super easy to customize. That's what I did for the curtain CTF is I was missing a feature. And because it's Python, it's super easy to just pick up on it, tweak something, use it as an API. That's what I really like about Python is how flexible it is. You can easily import it as a library, make some changes and customize it. So for this type of workflow, it's super place for me it's super comfortable. And yeah, that's about it.
00:25:05.622 - 00:25:34.086, Speaker A: And no false positives. That to me is the other tool. The other thing that's super important. If I run one of these tools, I don't want to go through like ten warnings and only to find out that only one of them is valid. And the other nine I can ignore, because you do that enough times and then you just kind of ignore everything, right. Your brain shuts off. So that's another big design goal is like we don't want to subject developers to this type of stuff, and it's kind of a strong constraint, right, because potentially you may miss things.
00:25:34.086 - 00:26:09.278, Speaker A: So there's a spectrum, right? You have security auditors and you have developers, right? They're potentially going to use the same tool, but they may not want the same thing out of it. And so I'm putting the blanket towards the developer side there, right? Because to me you can't subject the developer to false positive, right? Maybe it's more okay on the security auditing side because you do want to get that one valid bug, even if you have a couple invalid ones that you can filter, I'm not sure. But coming from the developer background. I know, I just refuse to use a tool that gives me false positives.
00:26:09.454 - 00:26:14.002, Speaker B: No. Same page. 100% cool.
00:26:14.056 - 00:26:14.322, Speaker A: No.
00:26:14.376 - 00:26:39.706, Speaker B: So I feel like I learned more about the mission of Hamos, kind of what you guys are doing. And yeah, this is all really interesting. So before we started recording, we were actually fiddling with how to share screen. I would love to share this video, but I feel like I'm ill equipped to give the context of this. What's this video that we're going to show? What's the context of this video?
00:26:39.888 - 00:27:10.738, Speaker A: Right. So, yeah, it's going to be a CFrin exclusive because I haven't shared it yet. All right, so here's the context. So we have really two big problems when we try to reason formally about programs. On one side, you have the path explosion problem, right? As soon as you have loops and branches, you can have many, many paths. And so it's just hard to reason about this kind of volume that can rise exponentially. And once you've done that, you have constraint solving.
00:27:10.738 - 00:27:50.690, Speaker A: So two completely different coins. Constraint solving is just fundamentally hard, too. And if you've done ctfs, you know what it's about, right? Some challenges are going to be you just have a bunch of functions, and each of them are complicated and they're making calls, and there's complicated loops with complicated conditions. This is all path explosion that you need to run in your head. Some ctfs are just basically straight line, but it's just math, right? And solving the math is like, well, you just need to come up with a valid u into 56. That solves the challenge, but that's hard. So very different problems, right? On one side, supercompleted control flow, and you need to find your way through, and that's maybe the challenge.
00:27:50.690 - 00:28:31.182, Speaker A: Other side, straight line code, just supercompleted expressions, nonlinear stuff, just difficult to reason about. And so we deal with these kind of issues basically on a daily basis, especially with DeFi protocols. Right? You have a lot of nonlinear math. Anyway, so these are the two main problems we have. I wanted to focus a little bit more on the path explosion prom, because that's something we can actually be more active, more hands on with. As a tool for the constraint solving, we sort of rely on the black box, the constraint solver for us, right? We sort of hand off the query and say, okay, please do the math for us. We don't know how to do this.
00:28:31.182 - 00:28:50.054, Speaker A: And they try, and it's kind of hard. And sometimes they may take a long time, take a lot of memory. So for this it's a little black box. There is not much we can do there. So I wanted a benchmark to focus on the pure path exploration phase. So you really have to think of it as almost two separate problems. Right.
00:28:50.054 - 00:29:17.054, Speaker A: So, constraint solving, difficult, but not much we can do because we're not developing a SMT solver ourselves. Path explosion. There is something we maybe can do, we can try to be smart about. Okay, which path do you explore first? Do you have to explore everything? Can you ignore some of them? These type of things? Can you be faster in the way you explore them? So I wanted a benchmark to explore this. So what I did was I literally modeled a maze. There we go. We should sit on screen.
00:29:17.054 - 00:29:32.514, Speaker A: So, yeah, I wanted a maze as a smart contract and to visually see what's going on. So maybe before we see the animation, I can actually show the code. Maybe that's going to make more sense. Sure. Yeah. Okay, so I have this code here.
00:29:32.712 - 00:29:35.650, Speaker B: This one you'll have to zoom in. Yeah, you have to zoom in a couple.
00:29:35.800 - 00:29:37.222, Speaker A: All right, is this good enough?
00:29:37.356 - 00:29:44.200, Speaker B: One more, one more, one more. Just because the window is kind of tight. All right, that looks good.
00:29:45.130 - 00:29:58.890, Speaker A: Okay, so this is a simple test. It's made to be readable. Have a couple of enums there. So the idea, you already know it's a maze. So I have this abstract contract. You have a starting position. You have some states.
00:29:58.890 - 00:30:16.602, Speaker A: We're going to go over that a little bit later. You have some utility functions, okay. And here are the interesting things, the public interface. So once that contract is deployed, you can go up, you can go down left or right. These are the four things you can invoke on that contract.
00:30:16.746 - 00:30:17.354, Speaker B: Okay?
00:30:17.492 - 00:30:34.886, Speaker A: Then I have some actual proper implementations that inherit from it, and that's where you're going to see the actual state. So I have this one right. We're going to start with a super easy maze. Okay, super easy maze. We have our starting position. We start at zero, one. And so you can see how the state is initialized here.
00:30:34.886 - 00:30:57.710, Speaker A: So it's actually an array of strings in storage. The hashtag symbols, whatever it's called. These are walls, right? So we can't go there. Our starting position is the s. Then we have empty spaces. That's where we can move. And what we're trying to reach is that e symbol at the end there.
00:30:57.780 - 00:31:06.626, Speaker B: So is this going to be showing us? So we're going to have some mazes and we're going to use formal verification to get through it. We're going to use fuzzing to get through.
00:31:06.808 - 00:31:38.394, Speaker A: Yes. So I wanted to compare, essentially Halmas, how we explore path and foundry. Actually, I'll go through it in just a second. But what we can do here is we can instantiate a bunch of these different mazes. So in order of difficulty. So this one, the only thing you need to do is you only need four moves to get to the end, right, because you start here, and I mean, as a human, it's not very hard to figure out, but, you know, you need to go, to go write down, down and then write again. And that gets you to the end.
00:31:38.394 - 00:32:00.366, Speaker A: Right. So for us, it's not super hard because we have a super nice visual cortex, and that's cool. But for foundry, which does not have that, it's going to be a lot harder and then you can increase the difficulty. Right. So this maze is a little bit more complicated. You need eight moves and so on. So you have different mazes, right, can go a little crazy there at the end and then some Halmos tests.
00:32:00.366 - 00:32:09.410, Speaker A: Right, so here is how you say that you want to explore this in Helmos, basically. So we don't support invariant testing.
00:32:10.970 - 00:32:18.258, Speaker B: For those of you listening, by the way, you'll just have to watch this. Sorry, this is some cool code on YouTube.
00:32:18.434 - 00:33:17.500, Speaker A: Sorry, I'm just working through the code right now. The idea is Helmas doesn't support invariant testing out of the box, but you can sort of emulate it. So what we can do here is I define a Super easy test where I instantiate my super easy maze, and then I want to ask Helmus, hey, find me a sequence of calls that get me to that end state, right? And the way I do that in foundry, I would do a pure invariant test saying, hey, I bet you cannot get to the enriched, right? And foundry is going to be like, yeah, I can, I'm going to make a bunch of calls until I do it. And so for Hamas, we simulate that with a loop, like an explicit loop. So we have one test that does a loop. In this case, we limit it to four moves and can say, hey, just call anything you can on that maze, and I bet you cannot reach the end, right? And if it can, then it will print the contact example. And so the equivalent in foundry, we have it here.
00:33:17.500 - 00:33:24.320, Speaker A: All you need to do is define an invariant. Say you cannot reach the end of that maze, right?
00:33:25.170 - 00:33:27.760, Speaker B: Or a stateful fuzz for those.
00:33:29.170 - 00:34:10.974, Speaker A: So you define your environment, you call it with the right convention. So once you've gone through the setup for the harness, expressing the property is super easy. You can just tell foundry, hey, you cannot reach the end of this maze, right? And it will generate a sequence of calls, and if it does reach the end, then it will print a sequence that gets there. Essentially what I'm doing here is I'm simulating the foundry style stateful, fuzzing environment testing in Helmos. So just a little bit more code to write because you need to do the loop explicitly yourself, but not too complicated. And so at the end, what I do is after each sequence of calls, I dump the state and then you can see it visually. Right.
00:34:10.974 - 00:34:34.706, Speaker A: And so video now. So I'm invoking the test and you can see what's going on. I might pause the video here for a second. So here you can see that we have a sequence of twelve moves and I'm putting a dot on the places we've already explored. So you can see we're already sort of making a little bit of progress. But that's it, twelve moves and we don't see twelve dots. Right.
00:34:34.706 - 00:35:01.050, Speaker A: So what's going on is sometimes what's going on is we explore a path, but we go backwards, which to us feels super weird, but to the tool is a valid move. So in this case it's probably going right, and then a bunch of up, down, up, down, up down, and then it decides to finally go down the maze. So I'm going to resume a little bit. You can see that sometimes we hit a wall and there's an x on the wall.
00:35:01.120 - 00:35:08.960, Speaker B: If we had, like, switches in the state where it would have to click a switch to close a wall, then going backwards might make sense.
00:35:09.730 - 00:35:40.810, Speaker A: Right. I'm going to find another example that looks a little weird, but there you go. So in this one, the s disappeared. So what that means is we went down the maze and we came all the way back to the start point, which again, sounds weird to us because we see the thing, we're like, why don't you just go down the path? I mean, it's right there. But for the tool, it's valid, right? All it knows about is when it does an invalid move because it reverts. Right. If you hit a wall, you know that's invalid.
00:35:40.810 - 00:36:20.126, Speaker A: But, yeah, for us, doesn't make sense for the tool. It's literally exploring systematically. And so we can finish the video here. What you can see is going on is it's literally hitting every wall it can on the way, but it is making progress and eventually it says, aha, I did reach the end and then it's printing the values of the enum that it used to get there. So, yeah, what I wanted to show is a big difference between the randomized work. Right. So we can't even make an animation like that in foundry because every sequence is purely random.
00:36:20.126 - 00:36:32.306, Speaker A: So we're all over the place. We would hit stuff. Right. You can't reanimate it. It would just blink all over the place until maybe, if you're lucky, boom. At some point, you hit a path that actually does reach the end. In the case of Helmos, all possible paths.
00:36:32.306 - 00:36:52.560, Speaker A: Right. And you can see it in video. In the beginning, we progress very little in the maze. And then at some point, oh, we take the turn and then we go up, and then we take another turn. So it's still hitting every wall, but it is slowly progressing forward. Right. So what it's showing is the systematic aspect of the exploration gives you a different feel.
00:36:52.560 - 00:36:59.874, Speaker A: That's what a randomized walk within the maze would be, if that makes sense. Yeah.
00:36:59.912 - 00:37:05.460, Speaker B: Would this be sort of like a breadth first search? Like a depth first search?
00:37:05.910 - 00:37:07.862, Speaker A: Exactly. We're doing a depth first search, actually.
00:37:07.916 - 00:37:08.918, Speaker B: Depth first search. Okay.
00:37:09.004 - 00:37:34.190, Speaker A: Yeah. Literally in the code, the whole path exploration is implemented as a single pass depth first search. And there's some technical reasons for that. We tried to make it a bit more parallel, but then we were running out of memory because each solver instance takes a lot of memory. And so now, anyway, we had to change how we're doing things a little bit. But, yeah, debt search is our current strategy.
00:37:34.610 - 00:37:35.310, Speaker B: Got you.
00:37:35.380 - 00:37:35.614, Speaker A: Yeah.
00:37:35.652 - 00:37:51.860, Speaker B: This is really cool. So anybody who wants to see or show somebody kind of an animation of doing symbolic execution on solidity. Here you go. So where's this code base? Is this code base public? Can other people go to.
00:37:54.890 - 00:38:29.978, Speaker A: Specific for this specific test? I just dumped it in my Halma sandbox, which is a bunch know. I mean, it's technically public, but it's really me dumping ideas in a GitHub. But yeah, if you want, it's out there, it exists. So it's on my personal GitHub, Alma sandbox. And you can see with the number, it's based on morale. Had this idea of a solidity sandbox, and so he had a couple of scripts to make it super easy to just come up with new tests, try a bunch of ideas. And so I stole the idea and made it a Halmos sandbox.
00:38:30.154 - 00:38:41.940, Speaker B: So if you want to see what karma's tinkering with next, go peek the Halmo sandbox and go peek this test as well. If you want to recreate some of the coolness of what you just saw.
00:38:42.470 - 00:38:51.590, Speaker A: That's right. That's what's good about working in open source, is if you want, you can literally see everything I'm doing, all my commits, everything is public by default.
00:38:52.010 - 00:39:10.090, Speaker B: Yeah, great. Big fan of the open source. Just the fact that web three is almost like open source by default. I've always thought as one of the coolest parts of working in this industry, but very cool. Thank you for sharing that. And everyone should go play with that. Everyone should go try out Hamos because there's a lot of really cool stuff there.
00:39:10.090 - 00:39:13.900, Speaker B: So, karma. So what are you working on now? What's next?
00:39:15.790 - 00:39:49.320, Speaker A: Yeah, there's still too many things to work on. There's a bunch of developer experience things I would like to improve in Helmus. Once you start using mean, you've tried it yourself. And so there's a lot of small things that are a little annoying that we could always improve. Performance is obviously a big one. Right. I'm still convinced we can still find things that are going to make things not just a little bit better, but not 10% better, but like ten x better if we're smart about the kind of algorithms, the kind of heuristics we're doing.
00:39:49.320 - 00:40:27.618, Speaker A: So I'm still looking for these and experimenting with those. I'm also studying the Halmas book because I think what makes it hard to use is people come sometimes with the wrong mindset for it. Right. And it's partly on us because that's how we communicated it initially. But what some people do is they write their protocols and they have their foundry test suite and they think, sweet, I can run the same test with Helmos. And typically then they're going to end up disappointed because you can't really just expect to run a foundry unit or first test in Helmos because the metal model should be a little different. Right.
00:40:27.704 - 00:40:29.554, Speaker B: That was my don't exactly.
00:40:29.592 - 00:41:22.886, Speaker A: If you don't know what to expect, you're going to expect magic and then you're going to be disappointed. So I don't want that to happen. And so what I think is super interesting is if you come with the right mental model for what is happening, if you think about the maze. Right, and how exploration works and how the constraint solving works, then it becomes super comfortable actually, to write express what you want. Write express through your properties in sort of a generic way, as opposed to just appeasing foundry or. I'm really extremely bullish on this idea that you can just express super clean property tests that are about your code itself and not just going through the motions and then having that test being picked up by a tool. And that actually helps you figure out, okay, is that property actually correct and enforced throughout? So that's what we're going for.
00:41:22.886 - 00:41:52.910, Speaker A: So, yeah, I'm writing the Halmas book to give people that sort of a tutorial format, right. Where I take you by the hand, I show you these kind of examples. I encourage you to write these yourself. And, yeah, hopefully at the end people are able to come up, express themselves. It's literally about, can you put your ideas into solidity, form in a test and have the tool actually understand it and run it efficiently for you? That's the dream.
00:41:53.570 - 00:42:08.386, Speaker B: That sounds very exciting. Yeah, I feel like, kind of like the rust inspired book. A lot of projects have kind of taken that on because, yeah, it's really solid. Yeah. That rust format of like, cool. Step one, do this. Step two, do this.
00:42:08.386 - 00:42:51.730, Speaker B: And you just learn as you go. Love that. That's really exciting. So kind of a question out of the left field. Do you think that a lot of the projects that you work with that you use hamos on, do you think they fully grasp or understand the value that you're adding? And the reason that I ask that is because I feel like I put out some polls recently about, hey, how many of you use formal verification? How many of you think form verification is important? A lot of people usually say, hey, form of verification is really important, but yet use it, which has always been, like, weird to me. I'm like, why are you trying to, are you trying to virtue signal on, like, an anonymous poll?
00:42:53.270 - 00:42:54.738, Speaker A: It feels important. Right?
00:42:54.824 - 00:42:55.086, Speaker B: Yeah.
00:42:55.128 - 00:42:55.574, Speaker A: Right.
00:42:55.692 - 00:42:59.800, Speaker B: So do you feel like enough people really get it.
00:43:01.610 - 00:43:26.922, Speaker A: For sure? No, to be completely honest, modulo epsilon, nobody uses it for sure. Right? I mean, I've spent over a decade in industry. Literally no one uses it. It's a super hard sell. Right? To be fair, it's still super complex. It's unclear what you're going to get out of it. I tried to sell the idea on the job before I was at a team at Netflix.
00:43:26.922 - 00:44:10.294, Speaker A: We're working on distributed systems. In some parts, you could try to formalize some of these message queues, and some systems lend themselves super well to these type of properties, like, oh, my message queue. Is it eventually consistent? You can formalize all these properties, but it's still a super hard sell because realistically speaking, every developer is already too busy. Right. We all have a backlog that's just always growing. So what that means is you already know that you have a bunch of bugs that you literally don't have the time to get to. That's the reality of life as a working developer is like you have a big pile of features that you want to implement and you have a growing backlog of stuff you should be fixing, but you can't.
00:44:10.294 - 00:44:48.614, Speaker A: And then you implement new features that introduce new issues. So basically it's juggling stuff that you punt and dealing with priorities and conflicting requests. On the other side it's kind of impossible. And then on the side you have people saying, hey, you should re formally verify your stuff. And now I'm supposed to learn a new thing and it's unclear and my manager is not going to hear any of it. I mean, it's just a very hard sell, right? But yeah, for me the striking realization was, okay, I tried to pitch the idea that, hey, we can model this in Tla plus, which is really nice for distributed concurrent systems. And literally the manager was like, look, we have a thousand things in Jira here.
00:44:48.614 - 00:45:38.322, Speaker A: What are you going to do, throw more bugs in there? Like, no, no interest. And especially in traditional software, okay, you have a bug that's bad enough, well, you're just going to fix it, you're going to prioritize it and fix it and you just live with them, right? It's fine. So either they don't occur very often, or if they do and they're bad, then you're going to fix them and it's going to be fine. And with smart contracts that doesn't work anymore, you can just say, well, we're going to ship fast and if we have a bug where we're just going to fix it in prod, right, on main net, that's not going to work. So I think for smart contract developers, it should probably feel like an easy sl. Your program is like, it's a lot smaller, the smart contracts, couple of hundred lines, maybe a couple of thousand if it's a big one. We're not talking millions of lines of code or this kind of scale.
00:45:38.322 - 00:46:07.650, Speaker A: We're not talking about verifying a kernel or anything or a browser or anything insane like that. Right? So we have fairly small contracts, fairly small code bases. The amount of state that they're managing is fairly small, but the value they're managing is disproportionate. Right. And so I think the balance is shifting on the other side where bugs are a lot more expensive and you're strongly incentivized to actually try and fix them before you deploy. Right. And where it falls short is.
00:46:07.650 - 00:46:36.090, Speaker A: So now you feel like, okay, I think everybody has internalized that. We know the bugs are there, we know they're expensive, and it feels like you should probably do something about them. But how exactly? Not everybody can go get a PhD. Informal verification, informal methods. These tools are still super complex to use and it's still not clear that they're going to work for your use case. Right. Very few tools today are geared to them.
00:46:36.090 - 00:47:29.946, Speaker A: So even if you did go and learn alloy and TLA plus and Daphne and all these cool systems, it's not clear that it's going to help you with the VM and solidity and managing this type of stuff. So that's where we come in. It's like, okay, we're trying to solve that and we all feel the need for more security and more confidence before you deploy. And we're trying to fill the gap where it's actually hard to get confidence. So you do have fuzzers and engineering testing and they're cool. But like I said before, I think at some point you hit a wall, you're going to get dim machine returns out of these and you can try to throw more computes. But at some point when your invent test returns pass, you shouldn't feel good about it, right? It's a timeout, right? So initially it's good, it finds issues, you fix them, it's cool.
00:47:29.946 - 00:48:25.466, Speaker A: At some point it stops finding issues. Right? And we always go back to the same thing is ask the developer, you don't know. When it says pass, does it mean you have no issues or does it mean it didn't find any issues? You don't know. You're trying to answer that question, right? So I think we need a different breed of tools that are easy to use where you don't need to hire experts. You're the developer, you're the one who knows your protocol, right? You're the one who knows what it means for you to have a bug, right? And so again, if you go back to further, like if you look at traditional stuff like AFL, like binary fuzzers, right? A lot of the time they're looking for stuff like memory corruption crashes, right? And so for me what this means is this kind of software, it comes with an implicit spec and the spec is you should not crash. Crashing is bad. It's always a bug, right? So implicitly these are easy to find, right.
00:48:25.466 - 00:48:30.810, Speaker A: You take a binary and you run the thing. You don't need to provide the spec. The spec is written for you because it says don't crash.
00:48:30.890 - 00:48:36.746, Speaker B: Right. The spec in web three is very different. It's don't lose all the money first.
00:48:36.788 - 00:49:00.646, Speaker A: It's different. You can't even say don't revert because sometimes revert is part of the normal flow. Right. So now it's a little harder because you, the developer, need to express, you need to define what a bug is, that's what a spec is. You need to tell a tool, somehow communicate, this is correct and this is incorrect, and you need to help me make sure that the incorrect stuff is not happening. So that's what I call a spec is. It's your job now.
00:49:00.646 - 00:49:27.230, Speaker A: It's your responsibility to find a way to express that somehow. And so sometimes you need to learn a different language. If you want to use Sartora, you need to use the verification language. And so for us, we made the choice to let you express these in solidity, right. So we're trying to help you basically express what it means for you to have a bug and then help you find the said bugs or show that you don't have them. Sorry, that was a long ramble.
00:49:27.310 - 00:50:02.170, Speaker B: No, you're good. No, it's all really good context here. What do you think your, let's say in two, three years, web three developers are still web threeing protocol goes, hey, we're about to go live. We're using all the new hottest tech, we're using all the new hottest stack, or maybe two years or even just one year. You know what, screw it. Just one year, next year. What is your optimal tech stack? End to end suite, including form verification, fuzzers, et cetera.
00:50:02.170 - 00:50:20.930, Speaker B: I know that there's no such thing as like a perfect flow, but what is your like, hey, if you're doing at least this stuff, you're going to be pretty sophisticated. What are you hoping developers or protocols pick up and use to make sure their stuff is secure?
00:50:22.710 - 00:50:30.578, Speaker A: It's actually super hard to answer because as you know, like two, three years, especially in this space, everything's going to change again. Right? Just keeping up is hard.
00:50:30.664 - 00:50:45.306, Speaker B: So one year, one year, one year. Like next year, protocol is like, boom, we're going to go live. You go. Okay, cool. Let me check out your code base. Click, you're going to click their GitHub and you're going to be like, I'm expecting to see x, Y and z. What are those things that you are like, these need to be in this code base for me to say.
00:50:45.306 - 00:50:47.034, Speaker B: It's an awesome code base.
00:50:47.232 - 00:51:08.880, Speaker A: Yeah. So yeah, shorter, medium term, I think it's a lot more realistic to expect people to actually pick up some form of symbolic execution or some form of modeling can be anything they want. Right. I'm not pushing halmas. The good news is there are a lot of teams doing a lot of interesting stuff in there. But, yeah, for sure today, you wouldn't release code without unit tests. Right.
00:51:08.880 - 00:51:22.134, Speaker A: It's literally a given. If you don't have any tests, people are going to look at you like a weirdo. Right. So at least we made some progress, right, compared to when I started, maybe in the late 90s. So now it's expected. Okay, you need to have unit tests. In web three, it's like not enough.
00:51:22.134 - 00:51:50.878, Speaker A: Right. Web two, it's like probably, okay, some unit test, some integration tests, ship it, you're fine. In web three, you probably expect a bit more. You expect some form of first testing, some form of invariant testing, and if you're a DeFi application, defi protocol, probably a couple of audits, right? And that's probably where we are today, because that's the best people can do, practically speaking. Right, in being pragmatic. And I fully expect that by next year. I'm trying to make that happen.
00:51:50.878 - 00:52:14.790, Speaker A: We need to have good enough formal tooling that it should become part of the standard flow. Like you need to have some kind of symbolic execution or some modeling in some fashion. It could be the way halmus is doing. It could be some other way. But I think you need some way to express these type of properties and have some other thing that's not just randomized. Right. Not just randomized testing.
00:52:14.790 - 00:52:34.240, Speaker A: And it should be part of the packages. If you're releasing an app without that, it should be a little weird. It should be a little red flag saying, well, maybe you haven't tested actually properly. Right. So hopefully that's going to become table stakes. So I'm hoping that the most advanced developers today are curious enough, right. I'm on a mission to nerf nine people.
00:52:34.240 - 00:53:01.400, Speaker A: I'm hoping that these most advanced developers and security tutors will see the value in these tools are going to help us improve them. That's why it's super helpful when you and other people pick those up, give us feedback, tell us, hey, I'm expecting this to work. And it's not. And that's actually super useful because we need to make sure it works. But, yeah, we have to change reality. Right? We have to make it actually happen and put it in the hands of developers and auditors. And I think it really goes together.
00:53:02.010 - 00:53:14.506, Speaker B: Okay. So I'm watching. You heard it here first. You have one year to pick up formal verification. Doesn't matter which one. Otherwise karma will be very disappointed in you and will make memes about you.
00:53:14.608 - 00:53:16.300, Speaker A: And you should feel bad. Yes.
00:53:17.630 - 00:53:32.494, Speaker B: And the other thing is, if you do pick up formal verification, you will understand karma's memes, and they are very funny. And it feels like you're in on this super niche inside joke. So you can join the inside jokes that karma posts, which is a lot of.
00:53:32.532 - 00:53:34.506, Speaker A: That's right. By next year, there will be dozens.
00:53:34.538 - 00:53:46.360, Speaker B: Of excellent, excellent cool karma. So we're pretty much at time here. Is there anything else you wanted to talk about? Anything else you wanted to get into before we jump off?
00:53:48.170 - 00:54:26.334, Speaker A: Yeah. So maybe something just out of left field? Maybe an advice for the younger people out there coming up. You're probably not going to hear me if you're less than 30, but you should be taking care of your body. And I know it's hard to hear, but you should sleep, and you should eat well, and you should exercise. And I'm not kidding, because I think we're in a field where people think that they're pure intellects, right? We all live in the cyberspace and this web free stuff, and we're all doing super advanced and cool things, and people think they're creatures of the mind, but you're not a mind. You are a body. Right.
00:54:26.334 - 00:54:49.130, Speaker A: You are leaving that vessel, in that vessel. And I think people have a tendency to ignore it until it's too late. And then you're going to end up when you're 40, and you're going to realize, oh, man, my body's actually falling apart now. So that's my advice to younger people listening out there. You should be taking care of your body. You're going to need it. And I know it sounds cheesy, but that's my dad advice.
00:54:49.130 - 00:54:51.466, Speaker A: You should be taking care of it.
00:54:51.568 - 00:55:14.794, Speaker B: No, I love how that's where we went, and I'm a little disappointed we didn't spend 15 minutes talking about gym tips. Maybe we can do that another time. But absolutely, 100%, your brain is part of your body if you don't take care of it. Yeah, I know. For me, if I don't go to the gym, I'm miserable, I'm depressed, and I'm less productive. So, boom, yeah, go to the gym.
00:55:14.922 - 00:55:27.762, Speaker A: Yeah. You can justify it like that. You can say, hey, you want to be maximally productive and have perfect cognition and all that stuff, you should do it. But there's more to it. Right. You also want to be healthy and all that stuff. Yeah.
00:55:27.762 - 00:55:32.066, Speaker A: I mean, people should really consider investing in their body. It's going to pay off long term.
00:55:32.178 - 00:55:45.270, Speaker B: Definitely, 100% agree. Well, karma, thank you so much for the gym advice at the end. And then thank you for all the conversations here about form of verification, about Hamos, about what you're working on. Really appreciate it. Thank you so much for being here.
00:55:45.420 - 00:55:47.190, Speaker A: All right. Thank you so much for having me on.
00:55:47.260 - 00:55:48.930, Speaker B: All right, thank you all. Bye.
