00:00:04.050 - 00:00:04.600, Speaker A: You.
00:00:07.130 - 00:00:24.086, Speaker B: Hello, hello and welcome to a fantastic interview. Here we have Raza from the scroll team here to talk to us about scroll, about l two s, about ZK stuff. He's a good budy of mine. We've been friends for some time. I'm excited to get into this candid conversation. Raza, how are you doing, man?
00:00:24.268 - 00:00:29.326, Speaker A: Hey, Patrick. Well, thanks for having me. Doing great and super stoked to get this session going with you.
00:00:29.428 - 00:00:40.494, Speaker B: All right, badass. Me too. So we were talking a little bit backstage before we started this up. We were going to jump into a couple of questions, but Raza actually came prepared. You have a little slide deck for us?
00:00:40.532 - 00:00:56.826, Speaker A: Yeah. Yes, sir. Awesome. I'm just going to go ahead and share my screen present. Share screenplay.
00:00:56.958 - 00:00:58.360, Speaker B: Boom. We got it.
00:01:00.010 - 00:01:24.110, Speaker A: Slideshow mode. Let's go. Yeah. So before we go deep into the conversation, want to give everyone sort of context, make sure we explain a little bit about what we're going to talk about today and then we can go deeper. And I will let Patrick grill me, but yeah, I'll get started. Zero knowledge and scaling Ethereum, talking about scroll.
00:01:25.010 - 00:01:29.438, Speaker B: We're going to put you under the gun. We're going to have you do some share screen, show some code. Yeah.
00:01:29.604 - 00:01:30.830, Speaker A: All right, sounds good.
00:01:30.900 - 00:01:31.354, Speaker B: Excellent.
00:01:31.402 - 00:01:52.130, Speaker A: Well, a little bit about me. If you don't know me, I'm Raza. Raza codes on the Internet. I'm a Devrel. I love playing with tech at Razakodes where you can find me. So yeah, let's talk today about ZK rollups. EvM types, the holy grill of scaling solutions as mentioned before by Vitalik.
00:01:52.130 - 00:02:39.974, Speaker A: I quickly want to set tone of what is a roll up? This crypto. Twitter gets crazy about this defining a roll up, but in simple terms, you have an off chain network, not an l one batches transactions and then posts these transactions on l one. Why? Because it solves the scalability problem that ethereum has different. The two biggest types of roll ups that you find out there right now is optimistic and ZK roll ups. We're going to talk about ZK roll ups, but an l one needs to prove that the transactions are valid. Two types of proof, validity proofs used in Zk roll ups and fraud proofs in optimistic roll ups. So in a Zk roll up, what is a validity proof? It's a zero knowledge proof that submitted by the Zk roll up.
00:02:39.974 - 00:03:07.018, Speaker A: And the proof is submitted on an l one and verified on l one. Transactions are generated on off chain and l two on the Zk roll up. And what the Zk rollup does is generates a proof that these transactions are valid. And so the way that the l one knows the truth is that when the transactions are posted from l two to l one, a proof is submitted alongside. So finality is reached.
00:03:07.114 - 00:03:13.418, Speaker B: So can I jump in here? Are you going to go over the difference between validity proofs and fraud proofs?
00:03:13.514 - 00:03:14.350, Speaker A: No, I'm not.
00:03:14.420 - 00:03:29.334, Speaker B: Okay, cool. Can I ask that right here? So, for listeners who don't know, what is the difference between a validity proof, which is what a Zk roll up does, versus a fraud proof, which is what something like an optimistic roll up, like an arbitram or an optimism does? What's the difference there?
00:03:29.452 - 00:04:16.150, Speaker A: Yeah. So I guess I should have never removed the slide, but none of the presentation. I guess in simple terms, when you look at an optimistic roll up, when the transactions are basically executed on an l two, what happens is when that l two communicates or submits the transactions on l one, there is a period for an honest party, any trusted party, to come and challenge whether the transactions are valid or not. And so in that arbitrary period, one week is most common used. But really, it's arbitrary, meaning it can be any period. A fraud proof can be submitted where a fraud proof would be proof that a fraud has been committed or like a malicious transaction. A validity proof is the other way around.
00:04:16.150 - 00:04:27.770, Speaker A: So when an l two submits transactions, you kind of get a receipt and saying, hey, this is the proof that these transactions are valid.
00:04:29.950 - 00:04:54.350, Speaker B: Awesome. Love it. So just for people who are watching, the major difference there is, these validity proofs enable you to kind of have this much quicker finality on the l one, because you're saying, hey, here's the proof that these transactions happen, versus an optimistic roll up. They say, here's the transactions. And does anyone disagree that these are the transactions? No, we'll wait a week. Cool. Nobody disagreed.
00:04:54.430 - 00:04:54.722, Speaker A: Great.
00:04:54.776 - 00:04:58.642, Speaker B: These are finalized. So is that kind of the main difference there?
00:04:58.776 - 00:04:59.362, Speaker A: Yeah.
00:04:59.496 - 00:04:59.986, Speaker B: Awesome.
00:05:00.088 - 00:05:29.850, Speaker A: Cool. So why ZK roll ups is actually maybe to one sense on that as well is that maybe the listeners already kind of figured it out. But the whole idea would be, is when the transactions are submitted by this l two, immediately or immediately, close to immediately, not immediately, but approve is generated. And so we know. Okay, cool. We don't have to go back and challenge these transactions or look for a malicious transaction. It has been done beforehand, sort of your checks and balances.
00:05:29.850 - 00:06:03.858, Speaker A: Cool. So that's how l one knows the truth. And then something I actually want to highlight for the ongoes as well. Is we will dive into later you see a graph. This was created by Vitalik to basically give context on the ZK roll up landscape. So if you're not familiar with type 1234 EVM, basically every ZK roll up is slightly different, being that, and they can be classified into types. And that has everything to do with how close a Zk roll up is to EVM.
00:06:03.858 - 00:07:24.450, Speaker A: Being that ethereum l one versus how fast does it take, what is the performance to generate a proof. Now, I like to simplify it. And if you look at this, basically what this picture shows you is if you're closer to Ethereum, it means that the l two will allow you to use solidity, will allow you to use Yule Viper, basically everything that you know right now, use right now, the dev to use right now, and you can utilize it on the Zk roll up. And that is also classified as EVM compatibility. So on a bytecode level, this Zk roll up acts and behaves the same as Ethereum, whereas a type four uses under the hood a different virtual machine, and thus you have a compiler before it. And this is also known as language compatible ZK roll up and also classified as type four. So just to give you a couple of examples, if you look today at linear Polygon and Scroll, we're floating between the type three, type two being that you can use hardhead truffle foundry and develop everything that you have utilizing those devtooling on these roll ups.
00:07:24.450 - 00:08:00.774, Speaker A: And then there is no compiler in between, but Zksync and Starquare. So matterlabs and Starquare, they have what's called a language compatible ZK roll up. And so there is some translation to be done. Now what is the trade off? So I spoke about EVM compatibility. Well, it's performance. So what would be the design choice to be closer to or not closer to EVM, actually being that you might face some incompatibility with today's tooling and language. Well, that's for the proof generation.
00:08:00.774 - 00:08:30.338, Speaker A: So if I go back, if I go back, what you see here on two axis is compatibility versus performance. And so you can see my mouse. Great. So what you see over here is that a type four generally is the fastest to generate a ZK proof. And we'll go into in a bit like how long does it take to generate a ZK proof and et cetera? And why is it a problem? But closer to EVM, generally speaking, means it takes a longer time to generate a proof further away, faster.
00:08:30.514 - 00:08:58.126, Speaker B: So basically, if I can jump in here, you're basically saying there are some trade offs to maybe having an l two. That isn't exactly EVM. Right. And the further away from the EVM you get, you can actually get these performance increases. However, you lose some of this compatibility, which is why you have this access here. So let me ask this. So why is, you said scroll polygon, ZKe, EVM linear? You said those are kind of flirting between type two and type three.
00:08:58.126 - 00:09:15.140, Speaker B: Right. It's kind of this gradient. Obviously, the more you modify the EVM, the less compatible it is. Why are they flirting between type two and type three? I guess we'll look at scroll in specific. What are some of the major changes, if I can ask? That scroll has made that make it kind of type two, type three.
00:09:15.930 - 00:09:57.394, Speaker A: Yeah. So as to why we would aim, let's say, a type four bytecode level instead of, let's say, language to answer that question. Well, scroll is actually very close to Ethereum foundation, so it almost sort of spun out of the EF. And that comes indeed in a bit when I'm going to talk about scroll is where we're convinced about the ethereum ecosystem and then the vision and mission of Ethereum. And so recognizing that community is huge for us and we want to be close to that community and ecosystem, it's kind of like the evidence. It's the obvious choice to say, okay, hey, we want to be EVM compatible and we stay close to that. As for linear and Polygon, obviously I can't comment on that.
00:09:57.394 - 00:10:20.710, Speaker A: They probably have their own choices to be made there. I will say what you saw perhaps as well with ZK sync is that solidity is also recognized. That's why they introduced the whole compiler and went that route. So generally speaking, the reason why we opt for a type two is because of that Ethereum aligned vision.
00:10:20.790 - 00:10:30.110, Speaker B: Right. Which is great. Right. So let me ask them, why isn't it type one? What are some of the major differences between scroll and pure Evm?
00:10:30.690 - 00:11:22.974, Speaker A: Yeah. So that becomes a very, to be very honest, I find it a little bit of difficult discussion because type one almost, for like a ZK roll up, I would say, would almost feel very difficult to achieve because type one would indicate that on a consensus level, the Zkevm operates. Right now, type one is classified as Ethereum. So you're one to one, equal to everything that Ethereum does. And we'll dive into the differences in a bit, like what does scroll support and what it does not support, which is only very little. And that's why I mean like we're moving towards type two but there are slight changes. Some pre compiled for instance that we don't support right now because it's very difficult to generate a ZK proof for that.
00:11:22.974 - 00:11:28.254, Speaker A: To be quite frank I won't be able to answer what anyone else is doing because the space is moving very fast.
00:11:28.292 - 00:11:45.910, Speaker B: Yeah obviously let's just focus on scroll here. But yeah, I don't know. The pre compile that always comes to mind is like what is it? Ec recover? My first question would be like hey is that supported or is that not a pre compile that works with scroll?
00:11:46.890 - 00:11:51.766, Speaker A: No. So I'm just going to pull it up. Just make sure I answer it.
00:11:51.868 - 00:11:52.838, Speaker B: Oh no worries.
00:11:53.004 - 00:11:54.070, Speaker A: It correctly.
00:11:55.370 - 00:12:00.474, Speaker B: And I know we're kind of getting super nerdy here. So if we go too deep and you don't know the answer that's cool too.
00:12:00.592 - 00:12:07.462, Speaker A: No that's all good. I'm just pulling it up from my notes.
00:12:07.526 - 00:12:33.780, Speaker B: But that's the pre compiled that just always comes to mind because I did like a hack analysis on one of the original polygon contracts where in one of the wrappers there was a check missing on the return value of that pre compile. And it's just always whenever someone says pre compile for some reason that's the first one that always comes to mind for me.
00:12:34.970 - 00:12:41.862, Speaker A: Yeah my list is actually not showing up but I will put it actually on my screen.
00:12:41.996 - 00:12:42.680, Speaker B: Nice.
00:12:43.530 - 00:12:44.038, Speaker A: Cool.
00:12:44.124 - 00:12:46.006, Speaker B: Oh this is great. So we're right in the docs here.
00:12:46.108 - 00:12:50.474, Speaker A: Yeah we're going to dive straight into the docs. But over here what you can see.
00:12:50.512 - 00:12:52.778, Speaker B: Is zoom in a little bit here.
00:12:52.864 - 00:12:53.354, Speaker A: Yeah sure.
00:12:53.392 - 00:13:11.982, Speaker B: And for people listening and not watching I'll try to summarize what we're seeing here. We're looking at the docs right now and we're looking at pre compiled contracts. And if you scroll up again what do you see? What was. Scroll up a little bit. And different opcodes as well. So there's some opcode differences and some pre compiled differences as well.
00:13:12.116 - 00:13:33.398, Speaker A: Yeah so there are a couple of opcodes that are disabled. I think that those would be the most interesting to have a look at. So if you look at base fee and self destruct if you would basically utilize or in our EVM would be ZKVM would be encountered. The transaction will be why?
00:13:33.484 - 00:14:05.866, Speaker B: I guess my question here is why are these. We don't have to go into each one but why would you make the decision to disable some of these opcodes? I mean for me seeing self destruct disabled is kind of like, oh, well, yeah, great. I understand why that one's disabled. The original idea of the EVM was like, oh, cool. Whenever contracts are done, we'll clean up after ourselves and call this self destruct thing. And then years later, nobody's doing, uh. In Codehox, we've done a bunch of competitive audits.
00:14:05.866 - 00:14:24.614, Speaker B: And we've seen a bunch of people, hey, like, you should add the self destruct function to this protocol so that when it's done, you can clean up. Nobody's going to do that. Maybe sometime in the future there will be some rent paid. But in any case, I understand why you did that, but. Yeah, why some of these differences here?
00:14:24.732 - 00:14:31.802, Speaker A: Yeah. So I think the simplest answer is. And we can go as deep as you want. But the simple answer is that it's a high level.
00:14:31.856 - 00:14:32.460, Speaker B: Yeah.
00:14:32.910 - 00:15:06.770, Speaker A: When you look at ZkevM, what the Zkevm is doing is it's proving that every behavior that would occur in EVM, it's valid and occurs exactly as it would be in EVM. So I've got a slide for. This is basically the process of. Basically proving every single of these steps is extremely intensive. And it's why. One of the reasons why up until a couple of years ago, it just wasn't possible. Or the overhead was enormous.
00:15:06.770 - 00:15:40.266, Speaker A: So what happens is the Zkevm in our architecture, we'll dive it in a bit. Takes the execution trace from the sequencer and enriched information. And basically every opcode and a specific sequence, it goes through that specific sequence. The steps of the execution of the opcodes. And then it has specific tables and circuits. And it all proves these opcodes that the execution is valid. And the behavior is exactly the same as it would be under EVM.
00:15:40.266 - 00:16:13.690, Speaker A: And this generates an enormous overhead. But due to hardware acceleration, you must have heard of polynomial sequences. So mathematical equations. We've been able to do this in, let's say, minutes instead of hours and hours of computation. However, there are opcodes still where I would say they're ZK unfriendly. So there's still work to be done in order for us to support this. And then that's also important that I think we have a sentence in our docs.
00:16:13.690 - 00:16:27.646, Speaker A: But basically in future, the goal is to support these opcodes and the pre compiled contracts. But not right now. So we will do that in future parts of our roadmap. Did that answer your question?
00:16:27.748 - 00:16:47.558, Speaker B: Yeah, no, this is actually great. This is exactly what I was looking for. So basically creating these proofs is computationally expensive. Makes a lot of sense to me. So to make it easier at the beginning, we just say, all right, screw it, we're just not going to have them. And moving forward, the plan is to add them on later. Can you actually scroll back up? So one in particular stands out to me.
00:16:47.558 - 00:16:56.200, Speaker B: So, difficulty Prevrando always returns zero. So does that mean that that opcode is supported, but it just always returns zero?
00:16:56.590 - 00:16:57.786, Speaker A: Yeah, at the moment.
00:16:57.888 - 00:17:41.638, Speaker B: Okay. So that's actually really interesting to me because it's something that anybody who's doing security and a protocol is planning on deploying to scroll. If you see somebody doing block prevrando or block difficulty, which a lot of protocols do, even though that's usually kind of bad if they're doing it, a lot of protocols are like, oh, cool, we'll use this as like a randomness seed, which is terrible for a lot of reasons, but if you are doing some type of security review and you see blocked difficulty or blocked prevando you go, which chains are you deploying to? Are you deploying to scroll? If you're deploying to scroll, it's super predictable because it's always going to be zero. So that's really good to know. That's really interesting. Cool, thank you for that.
00:17:41.724 - 00:17:57.500, Speaker A: Yeah. And I just want to clarify. It is possible to create the block difficulty. We do have that information, but not to introduce another bad way of randomization, but, yeah, this is just to clarify, anyone who might be confused on that end.
00:18:00.030 - 00:18:03.534, Speaker B: What do you mean it doesn't return zero?
00:18:03.732 - 00:18:14.846, Speaker A: This one doesn't return zero. But we do have in our block explorer, you'll see in a bit. So you can see the difficulty for creating the block. So there, we have block difficulty there specified.
00:18:14.958 - 00:18:22.580, Speaker B: Oh, wait, you guys have block difficulty. So is there like a proof of work happening? Where does the difficulty come from?
00:18:23.590 - 00:18:26.370, Speaker A: Oh, man, I put myself in a squeeze.
00:18:27.270 - 00:19:08.606, Speaker B: And then, for people who don't know, the reason that this difficulty opcode was changing to Prevrando is because previously in proof of work, the difficulty was like, how hard the work was to find the answer. But now that I explained that horribly, in any case, since we moved to proof of stake, we changed it to prev rando, which is kind of like the previous random validator value that's going to be used, and we say, hey, that's the value that this opcode returns. But so what Roz is saying is, hey, we actually do have the ability to have this difficulty, and that's associated with proof of work. So I'm like, oh, well, is scroll a proof of work chain?
00:19:08.798 - 00:19:11.314, Speaker A: What's going on there immediately clarified, no.
00:19:11.352 - 00:19:12.580, Speaker B: We'Re not proof of work.
00:19:14.250 - 00:19:39.950, Speaker A: Not to have that confusion in the world. Let me start by saying we haven't designed a consensus mechanism yet. We know that's not the stage that we're at right now. If you look at the ZK roles, they all run some sort of consensus mechanisms because you need that for distributed systems. And what we have right now is proof of authority that we utilize.
00:19:40.850 - 00:19:45.870, Speaker B: Got it. Makes sense. And what's the difficulty then? Where is that coming from?
00:19:46.020 - 00:19:59.954, Speaker A: Yeah, I can show that when we query, but right now the difficulty, we're running a centralized node, so I'm not sure how much exactly that would tell you and how much of information will provide.
00:20:00.072 - 00:20:10.760, Speaker B: Yeah, it's not super. So right now it's going to return zero. There is some difficulty thing, but it's kind of part of the bootstrapping of Scroll. Scroll main net isn't live yet, so all good. Makes sense.
00:20:11.370 - 00:20:16.358, Speaker A: Cool. Just going to go back to my slide over here.
00:20:16.444 - 00:20:19.366, Speaker B: Cool. And thank you for that tangent. That was super helpful.
00:20:19.478 - 00:20:53.620, Speaker A: No worries. All good here for all the tangents. So yeah, scroll aiming to be type two. So when you see ZK roll ups, you want to classify them either being bytecode equivalent, language equivalent, and then the trade off is compatibility for this performance. So now diving into scroll architecture. And if you look at the scroll architecture, this is basically a high level view and we will go deeper into it in a bit. But in essence what we have is an l two, which is the sequencing layer and proving layer together.
00:20:53.620 - 00:21:34.846, Speaker A: And then ethereum, the settlement layer. Now the way you interact with a ZK roll up like scroll is by, I'm going to start by saying you bridge your assets. So the native currency where gas is paid on Zkroll, on scroll is eth. So you need to bridge eth to execute transactions. I'm going to give you a quick rundown of what each node does, and then after that we'll go through a quick roll up process and then I promise we'll go into docs and code. So execution node, if I go back, that's this node over here. It's on the sequencing layer.
00:21:34.846 - 00:22:15.838, Speaker A: What the execution node does is it's responsible for gathering the transactions. It's comparable to the EVM. So it generates the blocks, your RPC URL, it connects to this node and it delivers the input for approvers, which if that doesn't say much to you right now, it will make sense in a bit. It interacts with the bridge and collects the l one message from the bridge, the roll up node over here, what it does is it batches the transactions. It commits the transaction data on l one. So over here in the roll up contract, two things are posted, the transaction data and the proofs. And the roll up node is responsible for both of those things.
00:22:15.838 - 00:23:00.938, Speaker A: And then something important, the roll up node pushes chunks and batches to the pool of proof with federally coordinated what are chunks and batches? Blocks are formed into chunks and chunks are formed into batches. And in a bit I'll show on the rollup Explorer exactly how that looks like. And then when we go up, you see over here the provers. And this is a pool of prover, which is actually decentralized, not permissionless yet, but it is decentralized, which is part of the answer. Why scroll that? I'll answer in a bit as well. But what the prover does is so we have a pool of provers, different nodes. They each take a chunk and per chunk a proof is generated.
00:23:00.938 - 00:23:36.406, Speaker A: It's done. Parallel parallelization occurs here. So the coordinator can assign to different provers, different chunks. Proofs are generated and then proofs. These proofs are aggregated because remember, a roll up posts a batch of transactions, and per batch there is a validity proof. And why do we aggregate proofs is because if we would post a proof per chunk, it would cost a lot in terms of gas fees. So we aggregate this and post it back on l one.
00:23:36.406 - 00:23:38.346, Speaker A: I'm going to pause. Patrick, any questions?
00:23:38.528 - 00:24:08.402, Speaker B: No. This isn't making sense to me. So real, very similar to some of the existing l two s that have main net right now. Right? So bridge contract. Maybe there's some function in there. The nerd of me is like, I want to see what the contracts actually look like. There's some function in there, something like wrap or bridge or something, where you take your eth, it converts it to, what are you calling it? Like s eth, scroll eth, or whatever it is.
00:24:08.402 - 00:24:36.218, Speaker B: And there's some node, I'm assuming it's the execution node, that's constantly reading this bridge contract. And you lock the EtH in that contract, and this bridge node reads oh, Raza locked ten ETH in the bridge contract. Let's unlock it. On this l two. The execution node does that. You can now do your normal stuff on scroll. You can do defi, you can send money, you can do everything like that.
00:24:36.218 - 00:24:51.054, Speaker B: And you do all your transactions. Eventually all those traces, all those transactions, they're going to go to this proving layer, which it looks all right, awesome. That's coming next.
00:24:51.172 - 00:24:52.334, Speaker A: Now you're doing my work.
00:24:52.452 - 00:24:55.034, Speaker B: I'm letting you do my work. I got you, Rob.
00:24:55.082 - 00:24:57.394, Speaker A: That's what I'm here for. I know you do.
00:24:57.512 - 00:25:14.920, Speaker B: So it goes to this proving layer. It does all the proving. It looks like it actually doesn't post to this execution node. It sends it to the roll up node, which is. Okay, that's really cool. So the proving process, the proving and the committing back to Mainet is almost like a separate thing.
00:25:17.690 - 00:25:39.040, Speaker A: You're sharp, so they're actually faces. But I'm going to walk through this first and then we'll go through the faces. So what you see over here is, I just want to quickly emphasize what you said. So there's a sync service. Indeed. We listen to the bridge. It collects the so called l one messages, queues them up.
00:25:39.040 - 00:25:45.818, Speaker A: And then the sequencer also obviously pulls it off from the mempool, generates the blocks.
00:25:45.914 - 00:25:57.906, Speaker B: Actually, can I jump in here? So the execution node. So right now I'm assuming that's going to be run by scroll, right? Okay, got it. Makes sense. So the execution node run by scroll. Great. Keep going.
00:25:58.008 - 00:26:32.090, Speaker A: Yeah. And just to be clear, I mean, we're open about that. So if you look at the execution node roll up and coordinated, these are centralized entities at the moment and totally have a roadmap for decentralization, but we'll touch upon that. Cool. So the execution node is, you can see it as your traditional EVM. Your roll up node is responsible for your interactions with l one when it comes to committing data and also pushing. So we have a database where we can push the chunks and batches so the coordinator can read from it efficiently and assign it to the pool of provers.
00:26:32.090 - 00:26:39.250, Speaker A: And over here you can see basically high level, we have like ZKV improver. And then the aggregated prover pushes it back to the coordinator.
00:26:39.670 - 00:26:43.506, Speaker B: What is that? Database structure. What kind of database is that?
00:26:43.688 - 00:26:45.606, Speaker A: A Db lang on top of my head.
00:26:45.708 - 00:26:47.062, Speaker B: Got it. Okay, cool.
00:26:47.196 - 00:27:09.760, Speaker A: Yeah. And then from the DB, it goes back to the roll up node and we post the proof. I actually have it over in the phase, so let's use that as a phase. One, two, three. Like what happens? So user submits transactions to l one bridge or sequencer. So that happens over here in the execution notes. Over here you can see it in practice and we'll see that in a bit.
00:27:09.760 - 00:27:56.918, Speaker A: That's the goal of EVM compatible. Just an RPC URL that you pass through your dev tool it generates the blocks from the transactions in the mempool and the message queue. And phase two is the roll up node monitors the blocks and fetches transactions, creates, or I should say proposes chunks, which is multiple blocks in one piece and then batches, are multiple chunks batched together. And then it writes to the Db, commits a transaction to l one. So in this phase one we call it pre commit. In phase two it's commit. So we will commit the data on Ethereum.
00:27:56.918 - 00:28:38.250, Speaker A: And then phase three is it happens all in parallel, where the core coordinator basically fetches the chunks, sends it to the prover network, generates the proof, goes back and the roll up nodes, sends it to the roll up contract. We'll actually go into sepolia in a bit and we'll see what the contract looks like, how the transactions, so the transactions are not compressed, they're obviously binary encoded. But we'll be able to take a look at that in a bit. So I'll try to finalize this quickly. So pre committed is phase one where if you trust scroll, the transactions are available in a couple of seconds, actually. So we have a block time. We aim for a block time of 3 seconds.
00:28:38.250 - 00:28:49.610, Speaker A: And the second phase is, what we call committed is where the roll up node posts the data, the transaction uncompressed on l one on the roll up contract.
00:28:49.950 - 00:29:08.930, Speaker B: When you say uncompressed, in my mind I'm thinking, okay, all transaction data is being posted to the eth l one. And then I go oh well, why are you even running on an l two if you're going to just dump all the transaction data back on the l one, isn't that going to cost a ton of gas?
00:29:09.510 - 00:29:33.850, Speaker A: That's a sharp question, and that's true. So we are going to compress it. We are looking at how to do that more efficiently. But right now, yeah, we post it as is. And by the way, I want to point out that's actually one of the differences like you asked me in the questions, like hey, what are the differences between zkvms? That's actually something for a developer. Also very important to know that some Zk roll ups only post state differences. For instance.
00:29:35.710 - 00:29:55.780, Speaker B: So this is the whole transaction trace tree that scroll is posting. Yeah, because immediately I'm just going, okay, well why am I even bridging to this l two then? Because if you're posting all the transactions, isn't that going to cost similar amounts of gas than just doing it on the l one?
00:29:58.310 - 00:30:26.810, Speaker A: I guess it doesn't like, there are a couple of things. First of all. If you look at throughput, scalability comes in various forms. It's both in gas prices and throughput. So you still get the throughput benefits on l two. The second of it is that yes, it costs a lot of gas, but we will compress it. But the way we post it and we'll see it actually in how much gas it cost, it doesn't outweigh the benefit of doing everything on the l two.
00:30:26.880 - 00:30:38.302, Speaker B: Interesting. So right now it's uncompressed. It's going to be compressed in the future. But it's not like a state proof or, excuse me, a state diff. It's literally the compressed transaction list.
00:30:38.436 - 00:30:38.926, Speaker A: Exactly.
00:30:39.028 - 00:30:40.240, Speaker B: Interesting. Okay.
00:30:41.670 - 00:30:58.354, Speaker A: And then so from committed we go to finalized, which is so finalized means the validity proof has been generated and been posted. And that can take at least ten minutes and sometimes longer depending on the network.
00:30:58.482 - 00:31:48.120, Speaker B: Interesting. So if there's like this ten minute finalized duration for the proof to be generated for to be posted, is there opportunity? So amida like okay, how do I attack this? Right? The security mind in me goes, all right, what do I do to break this? Is there an opportunity there for some type of mev to swap in, for some type of something malicious to happen? It sounds like so long as that validity proof comes through and is valid, you would just always wait for the validity proof before doing anything. Like if you're designing a protocol and you go okay, cool, scroll posted their stuff. If you don't wait for the validity proof, you're basically just doing it wrong. You just have to wait for the validity proof and then you're going to be safe as long as you wait for that proof. Is that right?
00:31:53.290 - 00:31:58.146, Speaker A: Well, yes. Well no, not entirely. Let me maybe spin a difference.
00:31:58.268 - 00:31:58.940, Speaker B: Sure.
00:32:03.950 - 00:32:58.810, Speaker A: When the phase two is when it comes into a committed state, I don't want to say like, oh, there is a guarantee that the validity proof will follow, but there are a lot of checks and balances that we do in order for, let's say, before we commit the data. Now the real question is actually when you look at the Z control, when we go to Mainnet, that's when we actually see the timings and the time arbitrage. Let's say if there's a period to do something about it, what some ZK roll ups do is they actually lock up the funds. So there is an arbitrary period, like optimistic roll ups where quote unquote, funds can't travel. While there are other ways, I know there are other ways to still do it, but just want to point that out as of now. I had a meeting this morning with the engineers. I actually asked this question, as well, and we went through all different scenarios.
00:32:58.810 - 00:33:35.122, Speaker A: The simple way I can say it is that that will be extremely difficult. Now, we are in a process of being audited, and most of it is audited, and it's going really well. But that would pose a serious problem in this case. I can basically say that there are checks and balances, safeguards in place that the data wouldn't be committed. And that's why it takes minutes. The data wouldn't be committed if there wasn't a chance of. If there's, like, even the slightest chance that the validity proof won't be generated, the data won't be committed.
00:33:35.266 - 00:33:46.522, Speaker B: I'm looking forward to that auto report, because the difference between very difficult and impossible are very large when it comes to a hacker. Right?
00:33:46.576 - 00:34:01.470, Speaker A: Yeah. And so here's the thing. The reason why I won't say something like, I just want to clarify, because we're on the record, I just want to clarify is that it was explained to me as being next to impossible.
00:34:01.910 - 00:34:29.990, Speaker B: Got it. Love it. As we all know, as engineers, nothing is technically impossible. There's computationally infeasible. So it sounds like the idea is for the committed phase to have it be computationally infeasible, for you to have to wait for that validity proof. So, that is really interesting to me. I'm really curious to see what this auto report looks like, because the security mind in me goes, no, you got to wait for that validity proof, and you got to wait a certain amount of confirmations.
00:34:29.990 - 00:34:42.762, Speaker B: But, yeah, really interested to see what that looks like. Although we're kind of getting super nuanced at the same time we're getting super nuanced here. But, yeah, really interested to see how that goes.
00:34:42.896 - 00:34:59.780, Speaker A: Yeah. And, no, it's all good. Whether that's online, offline, we can dive deeper into it, but as of now, I would say that checks and balances are safeguards in place. When it's out, I'll let you know.
00:35:00.150 - 00:35:03.890, Speaker B: Yeah. Do you know when the auto or the security reel will be finished?
00:35:04.470 - 00:35:46.258, Speaker A: No. Well, to be quite frank, I'll just quote Vitalik on this. Isn't that. He posted this meme where about the ZK circuit that was designed and had 34,000 lines of code. Our co founder himself, he said, things are bug free only for so long, especially when you're dealing with such large code bases. So a part of it is almost ongoing, where you see the research in the space Zikaro is working really hard together on going to the next level, and I will have to get back to you on that, on whether we're actually going to publish something or in what shape or form is going to come out.
00:35:46.344 - 00:35:51.090, Speaker B: Sure. Makes sense. Cool. Yeah, this has been really exciting. All right. Yeah, let's keep going.
00:35:51.240 - 00:36:12.806, Speaker A: Awesome. Okay. Yeah, I forgot to update it slide, so that's really bad for me. But we actually went through the differences between scroll and Ethereum, which is. I'm just going to go back to the doc, which was really this page when we went on a tangent. So we covered this a bit. But I think the most important when it comes to is the pre compiled contracts.
00:36:12.806 - 00:36:32.890, Speaker A: And I explained a little bit before already where the difficulty comes from, which is the ZK circuit and generating the proof. One thing I do want to emphasize is that we have it on our roadmap and we will be as much Ethereum aligned. Being Ethereum is basically the goal.
00:36:32.970 - 00:36:33.742, Speaker B: Love that.
00:36:33.876 - 00:36:37.982, Speaker A: Yeah. And that's why it's all set currently. That's the emphasis.
00:36:38.046 - 00:36:55.778, Speaker B: Got it. So something that actually came up. So Vasili is watching this right now. Leaves him notes. He asked a really good question that I'm kind of interested in as well. On your slides there, you were using two terms almost interchangeably, but kind of not. You were using chunks and batches.
00:36:55.778 - 00:36:59.898, Speaker B: Are those the same? Is there a difference there?
00:37:00.064 - 00:37:05.974, Speaker A: Yeah, there's a difference. A chunk is made out of blocks.
00:37:06.102 - 00:37:06.780, Speaker B: Okay.
00:37:07.150 - 00:37:09.210, Speaker A: And a batch is made out of chunks.
00:37:11.630 - 00:37:12.538, Speaker B: Got it? Okay.
00:37:12.624 - 00:37:27.586, Speaker A: Yeah. Where is the nuances? The importance is that the unit of proving for generating a ZK proof is on chunk level and the unit of the aggregated proof is on batch level.
00:37:27.688 - 00:37:28.626, Speaker B: Got it.
00:37:28.808 - 00:37:37.746, Speaker A: But I just want to emphasize that it doesn't mean that we do some high level proofing. We prove every behavior of the EVM.
00:37:37.858 - 00:37:38.760, Speaker B: Got it.
00:37:39.130 - 00:38:16.930, Speaker A: So we have circuits and let me just show you, because I think visual just makes it a lot better to show. So we have circuits that are specific for sets of opcodes or an opcode specific circuit. And what these circuits are designed to do is they have so called constraints. So let's say rules in place and they check. Exactly. Does this set of opcodes or execution steps behave exactly as EVM? If it does, it generates proof, if it doesn't, it doesn't generate proof.
00:38:17.350 - 00:38:19.140, Speaker B: Got it. Cool.
00:38:21.350 - 00:38:43.286, Speaker A: Okay. Yeah, I think that was actually most of my slide where I actually was going to say, okay, let's deploy on scroll and also dive into the docs. But I guess at this stage. I would like to go through the roll up explorer actually because we spoke about I guess here the whole idea of batches and chunks.
00:38:43.398 - 00:38:44.954, Speaker B: Can you zoom in a little bit here too?
00:38:45.072 - 00:38:45.498, Speaker A: Sure.
00:38:45.584 - 00:38:51.920, Speaker B: And for those of you who are just listening and not watching, sorry. You should also watch because he's showing us some cool stuff.
00:38:54.210 - 00:39:19.714, Speaker A: Purposely. His comment I'm just going to go, I think this is fine. So over here what we can see is a batch index. So this is a batch and it's made out of 13 chunks and 72 blocks. And so if I go into these 13 chunks, so over here this is a chunk and I click on it, you can see this chunk has seven blocks.
00:39:19.842 - 00:39:20.760, Speaker B: Got it.
00:39:21.210 - 00:39:30.442, Speaker A: And then here this is the block. And inside the block we can dive deeper and then we can go into the, well it's not indexed yet.
00:39:30.576 - 00:39:50.970, Speaker B: All good. So I think I get it though. So the chunk is what the validity proof is done on. That's what you're saying. So a chunk of x, number of blocks, boom. Validity proof created. And then you batch together these proven chunks in a batch and push that to the roll up contract.
00:39:51.130 - 00:39:51.758, Speaker A: Yes sir.
00:39:51.844 - 00:39:53.200, Speaker B: Got it. Very cool.
00:39:54.450 - 00:40:08.006, Speaker A: Over here. Let's see. So these are committed, it seems like. So over here you can see them finalized. Well these are 2 hours ago but these are the different stages that the roll up explorer shows.
00:40:08.108 - 00:40:14.822, Speaker B: And so finalized means the validity proof is there. You can move your money based off of the. Okay, very cool.
00:40:14.956 - 00:40:30.940, Speaker A: Yeah. The validity proof has been committed. And so this is the roll up contract. Just going to refresh the screen. So this is Sepolia. We're obviously on Testnet right now. So over here you can see this one is still pending as being, probably being committed as we speak.
00:40:30.940 - 00:40:47.214, Speaker A: This is 5 seconds ago. And so here you can see a committed batch and then a finalized batch which finalized being that like we just mentioned, the validity proof came in. And so over here you can see everything that we post to show the original. This is like what it looks like uncompressed.
00:40:47.342 - 00:40:48.260, Speaker B: Got it.
00:40:50.790 - 00:41:00.818, Speaker A: This is default view. So this is the roll up contract and then this is the bridging contract. So over here you can see all the messages that are being posted.
00:41:00.914 - 00:41:01.560, Speaker B: Cool.
00:41:03.770 - 00:41:13.110, Speaker A: Yeah. So what I guess I'll do is I will now dive into deploying on scroll.
00:41:13.190 - 00:41:43.662, Speaker B: Love it. Okay cool. So for those of you watching, now is a great time. Or for those of you watching or listening, now is a great time to take a quick break. We just covered a lot of information and we're about to switch context here to actually deploying something. So for those of you who are listening, you can listen to the sultry sound of raz's voice clicking away and deploying to scroll. For those of you watching, this is going to be really interesting because we're going to see how similar this is to something like foundry, how similar this is to something like ethereum.
00:41:43.662 - 00:42:11.120, Speaker B: Right. How much our current tooling actually works here. So if you're watching, hit that pause button, grab some wheaties, grab a coffee or something, and then come on back. If you're listening, same thing, but you won't get to see the coolness happen, but I'm sure you can imagine happening. So let's dive in. Raza, do you mind zooming in a whole lot so that people who are watching can. Yes.
00:42:11.120 - 00:42:13.680, Speaker B: Lovely. Okay, cool.
00:42:14.210 - 00:42:44.918, Speaker A: Awesome. So what I'm going to do is I'm just going to paste a simple contract ether wallet and we're going to deploy this using hard hat. I'm just renaming the file and then let me see, going to the script. Just making sure that I have the right script here.
00:42:45.004 - 00:42:48.970, Speaker B: You'd have to change the contract factory to ether wallet instead of lock.
00:42:49.310 - 00:42:50.060, Speaker A: Yeah.
00:42:53.550 - 00:42:54.506, Speaker B: Oh, nice. You got it.
00:42:54.528 - 00:43:16.494, Speaker A: Okay. Yeah. And then something that I'll actually take a minute to dive in, which is the config file. So I need to remove this one because we recently changed Testnet. So apologies, I need to paste it in new URL.
00:43:16.622 - 00:43:17.540, Speaker B: All good.
00:43:18.390 - 00:43:30.534, Speaker A: But I can show it how it looks like on our docs, the developer docs. So if you go to the developer docs, developers developer. Quick start over here we have.
00:43:30.572 - 00:43:32.006, Speaker B: Can you zoom in here a little bit too?
00:43:32.108 - 00:43:32.760, Speaker A: Sure.
00:43:33.450 - 00:43:35.830, Speaker B: One more, one more. Lovely.
00:43:36.650 - 00:43:58.606, Speaker A: So over here you can see all the details that you need as a developer to get started. The RPC URL chain, id everything you need. By the way, quick tip for listeners, I really like chainlist. So if you go to. Yeah, we're on there as well. So if you go there, scroll and then include Testnet, you can see us over here. So if you connect your wallet and.
00:43:58.628 - 00:44:05.620, Speaker B: Add it, then zoom in a little bit here. I guess we're done with this page anyway. Yeah, all good.
00:44:06.630 - 00:44:14.210, Speaker A: So yeah, I'm just going to copy this one, go back to my code editor, paste it over here and save it.
00:44:14.280 - 00:44:18.878, Speaker B: So that's for forking. Are we going to deploy to the chain or are we just going to fork?
00:44:18.974 - 00:44:48.846, Speaker A: No, we're going to deploy. The reason why I actually pasted is if we were going to go in testing, which probably to be won't but I just wanted to showcase the URL. Cool. And I also had the old one, but, yeah, the way I personally like to deploy when I'm just deploying real quick is travel dashboard because I don't have to pass private keys and whatever configuration I have, I can utilize. So what I'll do first is I'm going to do clear. Can you see it?
00:44:48.948 - 00:44:50.880, Speaker B: Well, by the way, yes, this is good.
00:44:52.070 - 00:44:54.190, Speaker A: So we'll compile the contract.
00:44:54.270 - 00:45:09.122, Speaker B: Okay, we just got to change the version right here in the hardhead JS config. So just change that zero 810. Sorry, I'm backseat driving. Go to the hardhead config and change the version 17.
00:45:09.186 - 00:45:15.320, Speaker A: Yeah. What would I do without you?
00:45:17.130 - 00:45:19.494, Speaker B: You're using hard hat. What's up with that?
00:45:19.612 - 00:45:28.650, Speaker A: Yeah, I'm sorry, just to be clear, I won't be showing it today. Foundry does work, but I will be honest right now, verifying.
00:45:29.150 - 00:45:33.502, Speaker B: Well, I wasn't expecting foundry or hat. I was expecting some python from.
00:45:33.556 - 00:45:34.240, Speaker A: I know.
00:45:36.450 - 00:45:38.186, Speaker B: You'Ve gone to the Javascript side, huh?
00:45:38.218 - 00:46:07.340, Speaker A: No, but I'm going to show you some web three py. No worries, I got you. All right, so what I'm just quickly going to show you, if you don't have truffle installed, you can do NPM, install globally truffle. And then I actually have to pull up my terminal because I need to run the truffle dashboard. So I'm just going to do that over here. Run the truffle dashboard before you actually deploy. So I'll just pull that up.
00:46:07.340 - 00:46:16.292, Speaker A: So we are running at localhost.
00:46:16.436 - 00:46:34.444, Speaker B: You want to minimize the terminal. So for those of you who are watching, he's running truffle dashboard in a separate terminal. And this will be similar to if you just put the RPC directly into your hardhead, config your founder, config your brownie, config, whatever. Yeah, zoom in a whole bunch. Awesome. Lovely. Truffle dashboard.
00:46:34.444 - 00:46:39.500, Speaker B: For those of you who don't know, I'll just kind of wait. Okay, it's fine. This is your testnet account anyways.
00:46:39.580 - 00:46:40.210, Speaker A: Yeah.
00:46:41.620 - 00:47:14.908, Speaker B: Quick, vasily, just block out how many him putting his password in for his metamask. I got you. Also, John, if you're editing, just. Just block that out and all good. So for those of you who don't know truffle dashboard, it's a way to deploy your smart contracts without having your private keys in a env, you basically hit deploy, it opens up the dashboard and you can just deploy right from your metamask. So you never have to expose your private key. A much safer way to deploy than actually exporting your env.
00:47:14.908 - 00:47:16.430, Speaker B: So they're using this?
00:47:17.120 - 00:47:40.452, Speaker A: Yes. Well, I've got it running in one terminal, so I'm going to go back to my vs code clear over here and then we're going to run the command, which is basically hard to run network and truffle dashboard. Instead of passing an RPC URL. You can if you want, but then when I do this, and there's nothing.
00:47:40.506 - 00:47:45.588, Speaker B: Special about your deploy. Oh, cool. And it just pops up as a signature request. Great.
00:47:45.674 - 00:47:46.116, Speaker A: Yes.
00:47:46.218 - 00:47:58.504, Speaker B: Connected. Awesome. And confirm, you can zoom out just a little bit on the dashboard. Yeah, there you go. Zoom in. One more. Oh, no, that's perfect.
00:47:58.504 - 00:48:06.590, Speaker B: All right, so cool. Metamask comes up. Oh, it looks like two came up, but all good. Yeah, let's see it.
00:48:07.200 - 00:48:09.980, Speaker A: Confirm. I clicked confirm twice.
00:48:10.400 - 00:48:17.744, Speaker B: Okay, so we confirm once. Yeah, great, lovely. So we're deploying this. Let's see it on the explorer if that works.
00:48:17.942 - 00:48:27.108, Speaker A: Yes, I'm going to go to. So we recently moved to Etherscan, so super happy with that.
00:48:27.194 - 00:48:40.310, Speaker B: Nice. But you might want to zoom way in. Yes, lovely. One more zoom in. Click. Yeah.
00:48:42.040 - 00:48:50.324, Speaker A: So just going to make sure I grab the right. I think I grabbed my wallet address. I'm not sure if I grabbed the right transaction. Yeah, so I grabbed my wallet address.
00:48:50.462 - 00:48:51.310, Speaker B: All good.
00:48:52.560 - 00:49:12.044, Speaker A: Let me see. Well, it's fine, actually. We can just go. So this one is 25 seconds ago. So we created, successfully deployed a smart contract on Sepolia. And over here you can see the transaction fees and the gas price that it took, which, yeah, as you can see. Woohoo.
00:49:12.044 - 00:49:30.180, Speaker A: Doesn't take that much. And yeah, one to one compared to ethereum, so for most solidity developers, they won't notice any difference. What I will do is go to the roll up explorer.
00:49:30.680 - 00:49:47.036, Speaker B: So Vasili asked another question. Who's off screen right now? Since this is an l two for Sepolia, is there an official faucet for the l two so that people can get Sepoli Eth bridge to scroll? Is that the current process for deploying to this scroll testnet here?
00:49:47.218 - 00:49:47.900, Speaker A: Good question.
00:49:47.970 - 00:49:51.228, Speaker B: Nice. Okay, cool. Can you zoom in just a little bit here?
00:49:51.314 - 00:49:51.996, Speaker A: Yeah.
00:49:52.178 - 00:49:52.904, Speaker B: Lovely.
00:49:53.032 - 00:49:58.220, Speaker A: So there are multiple ways. It's a great question, fasili. Sorry, facili or facility?
00:49:59.280 - 00:50:09.124, Speaker B: Facility. Okay, facilita. I shouldn't even say anything because my american accent is horrible, but yeah.
00:50:09.162 - 00:50:48.050, Speaker A: Okay, let's go two ways to get eth on scroll. One would be to bridge and I need to switch to Ethereum sepolia over here. So I'll switch and then over here, what I can do is bridge funds from Ethereum sepolia to scroll. So when I do deposit funds, confirm transaction and then it will send. While this is busy, what I'm going to do is go to our developer docs and showcase that. We also have faucets available to claim directly. So I can imagine that.
00:50:48.500 - 00:51:06.724, Speaker B: I believe you. We don't have to go to the faucet. I believe we go. Can we go back to your deploy JS script? Actually, yeah. So in the, the Rosa says there's a faucet. Awesome. So if we're looking at this deploy script, there's nothing different about EVM here.
00:51:06.724 - 00:51:30.750, Speaker B: There's absolutely nothing different here, which is awesome. So my question is then, so can we go to etherwallet Sol and let's play with this. If we go to Etherwallet Sol in here, let's just add a variable underneath address payable public owner. Can we add a un 256 public sum number?
00:51:31.440 - 00:51:36.432, Speaker A: Okay. Un 256, yes, public.
00:51:36.566 - 00:51:49.744, Speaker B: And then just some number, variable or number. Yeah, my fave. Okay. Nothing. And then semicolon.
00:51:49.872 - 00:51:50.420, Speaker A: All right.
00:51:50.490 - 00:52:12.348, Speaker B: And in the constructor, let's do my fave equals block difficulty underneath the owner. All right, so my fave and then equals block difficulty. And this compiles and everything, right?
00:52:12.514 - 00:52:13.036, Speaker A: Yeah.
00:52:13.138 - 00:52:18.972, Speaker B: What happens when we deploy this? I'm super curious. It'll just deploy fine.
00:52:19.026 - 00:52:22.108, Speaker A: Right. Let's take a look.
00:52:22.274 - 00:52:39.670, Speaker B: Right, so it compiles fine. Obviously, let's see if it deploys. So again, the reason I'm playing with this is this is one of the opcodes that is pseudo supported. It works, but it returns zero. Always.
00:52:40.520 - 00:52:41.028, Speaker A: Yes.
00:52:41.114 - 00:53:07.724, Speaker B: So it looks like it deployed fine. I'm willing to bet then if we pull the my fave number, once this actually deploys, it's just going to return zero. So that's really interesting to see. So for all of you security researchers out there, for all you developers out there, keep this in mind, right. If you do, this will work differently on scroll than other EVM chains or just this will work differently on scroll than another EVM. Very cool. Just wanted to showcase that.
00:53:07.724 - 00:53:12.190, Speaker B: That, yes, you can deploy this, but yes, it's going to be different. Very cool.
00:53:12.660 - 00:53:20.940, Speaker A: Yeah. By the way, actually, I wanted to show you, if that's okay real quick on the Rolex explorer.
00:53:21.100 - 00:53:24.080, Speaker B: It's completely okay.
00:53:24.150 - 00:53:38.740, Speaker A: Raza, if I dive into, let's say a chunk and then a block. Let's go. So over here you can see the difficulty.
00:53:39.320 - 00:53:55.388, Speaker B: Nice. Okay, so they're interesting. So what happens when you can you zoom weigh in? Yeah. So why don't you roll over that for minor, used to calibrate block generation time. No constant POA based networks. So it's just always going to be two then?
00:53:55.474 - 00:53:56.110, Speaker A: Yeah.
00:53:56.480 - 00:54:24.240, Speaker B: Okay, so it'll return zero now, maybe in the future it'll return two in any case. Really interesting, right. These are some of the subtle differences for you devs to be aware of when you're building systems here. And although I will say if you're using blocked difficulty as a random seed, please reconsider just for any EVM chain, not just scroll. So maybe it's good that scroll just says, hey, it doesn't really work because it's not great to use anyways.
00:54:24.400 - 00:54:35.748, Speaker A: Yeah. Maybe this is a good time to show or talk about the prover network and the decentralization that I touched upon.
00:54:35.844 - 00:54:37.768, Speaker B: Can you zoom in a whole bunch here?
00:54:37.854 - 00:54:38.890, Speaker A: Yeah, sorry.
00:54:40.800 - 00:54:41.660, Speaker B: Lovely.
00:54:42.640 - 00:55:13.700, Speaker A: So actually I won't show the slide or the roll up note. Sorry. It. Okay, I apologize. I kind of lost where all good.
00:55:13.850 - 00:55:41.980, Speaker B: So I think on the prover stuff, I think I kind of get it. I don't know if we need to go into that unless. Let me know if I don't have it right here. So once we do this execution on the sequencing layer on the scroll layer, right, there are these nodes on the proving layer listening to all these transactions that go through. And they go, okay, cool. Time for us to make the validity proof. And what's interesting is what you're saying is, so the provers are, it's not permissionless, but it is decentralized.
00:55:41.980 - 00:55:47.292, Speaker B: So I guess the question would be, so who are these provers? How are they selected?
00:55:47.436 - 00:56:26.636, Speaker A: Yeah. So right now we have a prover network and checked with engineering this morning, roughly one third is run by scroll and two thirds are some of our partners. Got it. And just to touch upon, let's say, the question that you had and bridging it to decentralization is you mentioned the differences. And also maybe a common question being asking, is the sequencer going to be decentralized? So first of all, it's not centralized right now. It's not decentralized right now, but that is definitely the goal. But I like to think that we really talk to talk and walk to walk by making the prover network decentralized from the get go.
00:56:26.636 - 00:56:45.660, Speaker A: And so what we're figuring out right now is how to make it also permissionless. And the way we want to do it is to make sure that we don't burden the community. And what do I mean with that? Is that right now the hardware requirements for approver are really high, so we want to make sure that there are.
00:56:45.750 - 00:56:47.284, Speaker B: Can I ask what those are?
00:56:47.482 - 00:56:59.872, Speaker A: Yes. So with my latest check this morning, it was 500gb of ram. Yeah. A couple of gpus enough.
00:56:59.946 - 00:57:08.472, Speaker B: Course, I run a bunch of nodes. Yeah, that's definitely on the heavier side. Very interesting. Thank you for the context there.
00:57:08.606 - 00:57:59.176, Speaker A: Yeah. And so we're definitely working on optimizations to be done on that end. But we wouldn't want to come back into the proof of work days, right, where you had all these rigs and people making a lot of money and then everyone out competing each other. By the way, the decentralization of the proving network and the sequencer, as I was told this morning, is very closely related. So hopefully this is like a good sign to people when you think about, okay, hey, what are the distinguishing factors? It's like we take decentralization super serious and we really want to make it happen as soon as possible, but never pace and speed, never at the cost of security and making sure that we don't have availability and security properly in order.
00:57:59.278 - 00:58:21.810, Speaker B: Yeah. Makes a lot of sense. So one of my main questions that I'm always thinking is, okay, well, why would I deploy here? And I think based off this call, I think I kind of understand the pitch here. Let me know if this is right or if I'm talking crazy Raza. So it sounds like number one, this is a type two zk l two.
00:58:23.780 - 00:58:26.992, Speaker A: We're between type three and two right now, but we'll be type two. Yeah.
00:58:27.046 - 00:58:49.556, Speaker B: Excuse me. Okay, so you're going to be type two between type two and type three. Mainly EVM compatible. The idea is that it's much faster, it's much cheaper, and it's a ZK roll up where you get this quicker finality. There is a lot of emphasis on decentrality right now. There's a lot of, I call them centrality training wheels. It's basically how every project starts.
00:58:49.556 - 00:59:09.888, Speaker B: You basically have to have centrality training wheels. It's got some centrality training wheels. It's going to be decentralized. It's going to be more and more decentralized as time goes on. And the ethos, which I actually do think is important, the ethos is, hey, we want to be really tight with theorem. We want to be tight with EVM, which I'm a big fan of. Is that right? Is there a piece that I missed here.
00:59:10.054 - 00:59:49.932, Speaker A: No, yeah, I think that something that I didn't emphasize enough is open source. So us being open source being huge. I'm definitely not pointing fingers or talking shit at this point, but community is being thrown out a lot. And the way we really try to showcase this is by really putting the efforts in decentralization and saying, hey, what does it mean for us to be part of the community? So we're really trying to talk, to talk, walk the walk. And so community on multiple angles. We're going to come out with a lot more cool stuff where we say, okay, hey, you can showcase that. Scroll is a place for community first.
00:59:49.932 - 00:59:52.776, Speaker A: Dev first. And yes, easy analytics.
00:59:52.968 - 01:00:11.264, Speaker B: Cool. Well, this has been awesome. This gave me a wonderful overview of scroll. I feel like I understand it much better now. Let me just look at my questions, see if there's any other questions I want to ask you. I feel like I get it. I feel like it looks intuitive, which I think is phenomenal.
01:00:11.264 - 01:00:37.804, Speaker B: I don't have to update my tutorials a whole bunch for this, which is great. I can just be like, use the tools that you use. Knowing those EVM opcodes, those pre compile opcodes, excuse me, those pre compiled differences, it seems like it's super straightforward. Go to the docs, you can see them right there. We could even test it out. That contract that Raza deployed. We could just call the my or fave number or whatever we called it and know the difficulty is zero or two or whatever.
01:00:37.804 - 01:00:52.720, Speaker B: It was really straightforward. This looks phenomenal to play on. I don't think I have any other questions. Razor, is there anything else that you want to show us that you want to walk through? Anything else for the dev community to know about scroll?
01:00:53.940 - 01:01:04.340, Speaker A: No, I think we covered a lot. Something that I didn't get to do and I have to do it because it only takes 1 minute, which is I actually have a Python script I want to showcase.
01:01:05.640 - 01:01:34.252, Speaker B: Okay, for those of you listening, raza on Twitter, his name is Raza Rython, big Python fan. And that was actually one of the reasons we became friends was we were like, yo, Python. What? Python. Because I'm a huge Python buff myself. And so to see him using Javascript, I was just a little surprised by. But yeah, seeing him do some python as well, that feels more correct to me.
01:01:34.386 - 01:02:01.652, Speaker A: So just to showcase and lots of python love, but just to showcase that, the whole idea, and I want to end on that note, is that indeed evm compatibility. Use your devtools. The languages that you're familiar with today is that I like to use webt Py. I think it's a great library to quickly query data on chain. And here you can see the latest data that I've just created. Like the latest. I'm just getting the latest block data using the webt py library.
01:02:01.652 - 01:02:46.310, Speaker A: And if I would go, it might not be indexed yet, but here I can see the gas used, but I didn't format it properly. But I'm looking for the block number which over here I can see 89760. And so if I would go back to the roll up explorer and I'm not sure if so over here you can see 40 seconds ago, it's this one and you can see basically the same data. But if you like it in your terminal the way I like it, then you can use all your current devtooling that you're familiar with and it works out of the box.
01:02:47.480 - 01:02:48.340, Speaker B: Lovely.
01:02:49.240 - 01:02:49.844, Speaker A: Cool.
01:02:49.962 - 01:03:04.430, Speaker B: Well, Raza, we went through a lot. We learned a lot about scroll here. This was great. Thank you so much for chatting with me here. Thank you so much for bringing scroll to us and showing us scroll and walking us through scroll. And thank you, everybody, for watching.
01:03:04.800 - 01:03:06.092, Speaker A: Thanks for having me.
01:03:06.226 - 01:03:07.724, Speaker B: All right, take care.
01:03:07.762 - 01:03:10.520, Speaker A: All bye.
