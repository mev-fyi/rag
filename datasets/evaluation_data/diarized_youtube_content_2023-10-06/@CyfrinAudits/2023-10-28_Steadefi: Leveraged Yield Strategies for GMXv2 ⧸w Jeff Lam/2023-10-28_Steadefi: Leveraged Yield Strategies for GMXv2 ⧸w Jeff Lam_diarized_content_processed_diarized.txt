00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:02.770 - 00:00:44.586, Speaker B: Gm. Gm. Everybody, welcome to the steadyfi leveraged yield strategies for GMXP two with our guest, Mr. Jeff from the steadyfi protocol. We are incredibly excited to be going through this code base. We're doing this kickoff call for you smart contract security researchers for you auditors to get to see under the hood the thinking behind how this protocol works, what it does, where to potentially look for bugs, and give you any and all Alpha to help make sure this protocol is secure as possible, because they've got some big plans to do some big things in the web3 ecosystem. Jeff, welcome.
00:00:44.586 - 00:00:45.770, Speaker B: How are you today?
00:00:45.920 - 00:00:52.138, Speaker A: I'm good. I'm probably not able to match your energy because it's late, but I'll do my best.
00:00:52.304 - 00:01:29.766, Speaker B: That's okay. I'm all about it. I mean, part of the reason why I love doing what I do is because I get to work with so many developers and yeah, I'm usually the one on the eccentric side of the developers, so. Cool. Well, Jeff, really, really excited for you to be here and for us to give these auditors, the security researchers, as much alpha as possible so they can make sure they do their absolute best to make sure your code base is as secure as possible. So, as many of the security researchers here know, the first step of any audit of any security review, which I'm wearing this cute little shirt here saying security review. Yes, audit, bad terminology.
00:01:29.766 - 00:01:47.406, Speaker B: But the first step of doing this, obviously, is going to be getting as much context as possible. So, Jeff, from a high level, could you walk us through what setify is? What is the goal? What is this protocol? And it looks like you're sharing your screen. Can I add this to the presentation here?
00:01:47.508 - 00:01:48.174, Speaker A: Sure. Yeah.
00:01:48.212 - 00:01:49.470, Speaker B: All right, cool. Great.
00:01:49.620 - 00:02:13.074, Speaker A: Awesome. So I'm going to reference the materials that I've already wrote on the public steadyfi code ops repository. So let me start first with what steadyfi is about. So, at a high level, we are a yield protocol, and we basically aim to create automated strategy vaults that allow users to earn yield on chain effectively and Passively.
00:02:13.122 - 00:02:16.582, Speaker B: Jeff, could you zoom in a couple of clicks here?
00:02:16.716 - 00:02:18.422, Speaker A: Sure. Okay. Is it too small?
00:02:18.556 - 00:02:19.734, Speaker B: Yeah, it's a little small.
00:02:19.852 - 00:02:21.174, Speaker A: Okay, let me.
00:02:21.372 - 00:02:22.418, Speaker B: Two more clicks.
00:02:22.514 - 00:02:23.958, Speaker A: There you go. How about.
00:02:23.964 - 00:02:29.034, Speaker B: That's better. Much better. I'll probably ask you to zoom in more in just a second. But this is great.
00:02:29.152 - 00:03:16.166, Speaker A: Let's just do it. Okay. All right, so just to recap, I'll continue where I left off. So essentially what we are aiming to do is to create automated strategy vaults that allow users to earn on chain D five protocols essentially that we're targeting into effectively and passively in any market conditions. So whether it's bull markets, crappish or sideways markets, or even bearish markets, we want to create automated vaults that can actually not just earn users yield. I mean, we use the word yield very frequent and it's thrown around a lot in defi, but to actually be profitable in doing so. And so how do we actually essentially achieve this? So this is where I could reference this diagram.
00:03:16.166 - 00:03:43.906, Speaker A: Essentially the core of citify are our leverage delta neutral or delta long strategy vaults. If you're not familiar with delta long or neutral, I could explain that a little bit more as well. But these strategy vaults, the most important thing is that they take leverage and it's under collateralized leverage. And that's why in the 35 protocol we also have lending vaults that essentially lend out assets to these strategy vaults that.
00:03:44.088 - 00:03:47.880, Speaker B: Could you zoom in just a hair? Again? A hair. Morgan on this?
00:03:48.250 - 00:03:56.262, Speaker A: Yeah. Let me see. Maybe I should make this bigger or can I click on this? No, this is probably better.
00:03:56.316 - 00:03:58.680, Speaker B: Yeah, the GitHub is kind of annoying with.
00:03:59.290 - 00:04:02.074, Speaker A: Should I. What's a better way to.
00:04:02.272 - 00:04:04.374, Speaker B: You're good. Are you on a Mac?
00:04:04.502 - 00:04:05.414, Speaker A: Yeah, I'm on a Mac.
00:04:05.462 - 00:04:12.234, Speaker B: If you just do command. Was it command plus? Command plus a couple of times.
00:04:12.352 - 00:04:13.742, Speaker A: It's what I've been doing actually.
00:04:13.876 - 00:04:24.970, Speaker B: Okay. Yeah, maybe one or two more times. Command plus. That's good. And then we just scroll back down and then just scroll down to the diagram.
00:04:25.130 - 00:04:26.722, Speaker A: This is huge. I feel like nice.
00:04:26.776 - 00:04:32.098, Speaker B: No, this is great. This is much better. Lovely, lovely. Thank you. We'll zoom back out in a minute, don't worry.
00:04:32.264 - 00:05:08.586, Speaker A: Okay, that works. Okay. Yes. So just to continue where I left off. So we talk about the strategy vaults that borrow assets from the lending vaults. And what these strategy vaults do is after it borrows assets from the lending vaults, it picks all these assets and deploy them to an underlying d five protocol. In this case, our first sort of launch for our strategy vault is to deploy assets as liquidity into version two of Gmx apost.
00:05:08.586 - 00:05:11.150, Speaker A: Anything I need to explain further?
00:05:11.650 - 00:05:25.494, Speaker B: Actually this is a great time, so anybody who's watching this, feel free to ask questions. This is the perfect time. We have just attention. So if there's any questions about this diagram, please ask now by the way.
00:05:25.532 - 00:05:26.854, Speaker A: Where should I be looking at to.
00:05:26.892 - 00:05:43.900, Speaker B: See if people don't just focus on you and I will spoon feed you all the questions. Don't worry, I'll make your job easy. So. No, this is great. So anything else on the high level of steadyfi? Anything else you want to talk about about how this works and what it does?
00:05:44.990 - 00:06:35.466, Speaker A: Yeah. So maybe I can talk a little bit about the difference between delta long and delta neutral and maybe just also to try it out there. So for folks that have been familiar in the defi space for the past couple of years, you might have already come across leverage you protocols. So some names that are really og in this space would be alpha Mora or alpaca finance. So one thing that we offer that's a little bit different from some of the existing leverage U protocols, I would say it's the strategy vaults that also execute not just on a long strategy, but on a neutral strategy. So just real quick to explain, long versus neutral or delta long versus delta neutral, essentially. And by the way, I might mess this up a little bit, so I'll do my best.
00:06:35.466 - 00:07:33.878, Speaker A: But essentially, the concept of a delta long is that your portfolio or your investment is directly correlated with the value or the price of the volatile asset. So let's say the liquidity pool in GMx version two, the ETh USDC liquidity pool. The volatile asset in this liquidity pool is e. So what we're saying in the long strategy is that the deposits that you put into the strategy vault your investment value, so to speak, it's directly correlated with the price of e. So if ETH is going up in value, then your deposit value should also go up along with ETH. Now, in the neutral strategy, it's essentially, I wouldn't say it's a direct opposite, but the concept is opposite. So in the neutral strategy, what we're trying to say is that the strategy is trying to hedge your deposit or your investment value against the price of ETH.
00:07:33.878 - 00:08:39.554, Speaker A: So you're saying that, okay, I don't know if ETh is going to go up or if it's going to go down, but either way, both ways, whether it's going up or going down, the strategy is doing some automated hedging for you. So if you are invested into a neutral strategy, you are more or less saying or praying that if price do not go up too much or go down too much, that's the difference between long and neutral. And so how this effectively is being executed by our strategy bots is quite simple, at least conceptually. So for a long strategy, you could think of it as the long strategy, borrowing more stable, more USDC to essentially buy more ETh. Right? So you're going long into more ETH, but in a neutral strategy, the neutral strategy actually doesn't just borrow USDC, it also borrows Eth. And by borrowing, if you are effectively taking a hedge on ETH as well, if you think about it. So the neutral strategy vault actually has to calculate how much if to hedge because you don't want to overhedge as well.
00:08:39.554 - 00:08:50.106, Speaker A: By overhedging, you could be essentially doing too much of a shot. And that's not the strategy that we're going for. We're going more for a neutral hedge. So that's the difference between long and neutral strategy.
00:08:50.238 - 00:09:15.982, Speaker B: So Jeff, let me ask this. So who would be a target user for something like this? So when I think three X long, I immediately go, okay, dgens who want to ape into something, those are obviously the ones who want to do three x long. The three x neutral is actually kind of more interesting because that reminds me of more kind of traditional hedge funds where we are hedging against as much risk as possible. So who are the target users looking to use products like this?
00:09:16.116 - 00:09:46.358, Speaker A: You pretty much hit the nail on the head. So for any leverage long strategies, they cater more to the quote unquote djens. And it's interesting that for tree x it's dgens for you. But we're going to have five x long actually. And for the neutral strategy, you tend to cater to more passive long term investors and depositors. And you brought up hedge funds and whatnot. And yeah, a lot of big crypto funds in the space when they are deploying large sums of money.
00:09:46.358 - 00:09:57.238, Speaker A: You tend to not want to go for short term leverage, insane leverage. You want something that's more market neutral, more long term, more passive, not too crazy. You go for a neutral strategy.
00:09:57.414 - 00:10:26.466, Speaker B: Yeah. So this is pretty common in the web two world. It sounds weird, but yeah, market neutral. For those of you who are unfamiliar, market neutral strategies are pretty common, even though they might sound weird where you don't actually want to be overexposed to one asset. You really want to try to balance your risk profile because maybe your client is something like a large teacher pension. Right. And you want to just make absolutely sure that when they retire that money is there as opposed to I'm going to shoot for the moon and hope I get there.
00:10:26.466 - 00:10:28.062, Speaker B: And when the teachers retire, you don't.
00:10:28.126 - 00:11:12.686, Speaker A: Have, I have like an analogy for this because I do struggle to explain this. Well, sometimes it's not a perfect analogy to how a neutral strategy is done, but think about it. A long leverage strategy is sort of like in a way you're sort of gambling and hoping that something goes up, and then you profit in the short term. But a neutral strategy is sort of like a money changer, right? When you go to a money changer and you exchange one currency for another currency, the money changer doesn't really care if one currency is going up or going down. He's just clipping a small service fee when he performs the service of swapping a currency for you. So in a way, a good currency or money changer is essentially doing like a delta neutral strategy. Just whatever your currency prices are, they're just clipping a fee.
00:11:12.686 - 00:11:15.266, Speaker A: By doing that trade for you makes.
00:11:15.288 - 00:11:45.630, Speaker B: A lot of sense to me. I like that analogy. There's the shoot for the moon, bet it all on black versus kind of dollar cost average, and save up, get rich slowly over time, and just protect your assets at all costs. So, Jeff, we have a couple of questions that have come in. Somebody asked, what is GMX in general? I think I want to skip that question, actually, because I feel like that's a whole rabbit hole. GMX has a lot of phenomenal documentation. I would recommend going to the GMX documentation and checking that out.
00:11:45.630 - 00:11:51.710, Speaker B: We have another question. Is this like an AmM, an automatic market maker?
00:11:53.010 - 00:11:54.894, Speaker A: You mean us or you mean GMX?
00:11:55.022 - 00:11:58.222, Speaker B: I think they're talking about this protocol.
00:11:58.366 - 00:12:20.118, Speaker A: Nope, automated market maker. But if you're familiar with an automated market maker, then you would be familiar with the concept of liquidity. So what we're doing is we're taking assets and deploying them as liquidity into GMX. And in a way, you could think of GMX as an automated market maker, but they're not an automated market maker, but same concept.
00:12:20.214 - 00:12:38.670, Speaker B: Yeah, makes sense. All right, next question. So does the protocol only use USDC as a stablecoin? That's lending, or does it support others? This is probably in the compatibility section of the readme as well. But yeah. Anyways, what stable coins does the protocol support for borrowing?
00:12:39.410 - 00:13:30.874, Speaker A: So for stable coins, it supports USDC, because currently for GMX version two, they only have USDC as a stable coin. But I think the question was also does it only use USDC as they were going to lend, or does it support others? So if the question is, does it support other stable coins, the answer right now is no, only because GMX doesn't support USDT or any type of stablecoins. But if the question is, do we support other assets to lend, the answer is yes. So, for example, there's an ETH lending pool. There's also a wrap bitcoin lending pool, because for every liquidity pool on GMX. So there's various liquidity pool, ETH, USDC rap, bitcoin, USDC ArpuSDC, so on and so forth. We have strategy vaults for those and for neutral strategy, we need to actually borrow those volatile assets in order to hedge.
00:13:30.874 - 00:13:37.490, Speaker A: And therefore we need a lending pool for those lending vault, I should say, for those volatile assets.
00:13:37.910 - 00:13:50.920, Speaker B: Great. Awesome. Thank you. Next, could you please explain the one x, two x and three x concept? So I guess more high level, how does the three x leverage work?
00:13:51.530 - 00:14:29.940, Speaker A: Okay, so one x, two x, three x. It simply means the leverage factor. So using the diagram here, let's say if you're a depositor, you put in one dollars worth of assets into. Let's just use the tree x long strategy vault. What the vault is saying by saying a tree x long is that it's a tree x leverage. So by you depositing your dollar, it would want to achieve a $3 worth of total, what we call asset value. So it needs to borrow two more dollars worth of assets on top of your one dollars in order to achieve that $3.
00:14:29.940 - 00:14:32.418, Speaker A: Awesome.
00:14:32.504 - 00:15:03.260, Speaker B: Hopefully that explains it. Yes. All right, cool. Next question. Can you explain the difference between the lending vaults and the strategy vaults, as in how do they interact with each other? Part of me thinks like the diagram here actually does a really good job of showing that relationship where in the lending vaults, that's where you borrow. And then in the strategy vaults, that's where they actually implement the money borrowed from the lending vault to three x leverage. Is that correct? Is that basically the relationship?
00:15:03.790 - 00:15:16.526, Speaker A: Yeah, you're almost right. I'll tweak your sentence just a little bit to say, think of it as the strategy vault being the borrower in this case, and the lending vault is supplying the assets to be borrowed to be lent out to the strategy vaults.
00:15:16.638 - 00:15:17.300, Speaker B: Great.
00:15:17.670 - 00:15:18.130, Speaker A: Cool.
00:15:18.200 - 00:15:41.802, Speaker B: Awesome. Well, thank you for this high level overview. So could we actually scroll down in the Readme here, I believe. Yeah, you can zoom out a little bit now. Thank you for that pause here. So there's a phenomenal recorded explainer. For those of you who are looking to learn more, that is a great place to just, again, prime your brain for what you're looking for, what you need to think about.
00:15:41.802 - 00:15:47.962, Speaker B: We have a list of roles and actors in the system here as well. Could we scroll down a little bit more?
00:15:48.096 - 00:15:48.780, Speaker A: Sure.
00:15:49.390 - 00:15:55.630, Speaker B: I believe towards the bottom. Yes, we have the scope. Obviously we keep scrolling.
00:15:55.970 - 00:16:20.086, Speaker A: Maybe I'll just highlight here too. Even though we talk about lending vaults versus strategy vaults, but the contracts that are in scope are really the strategy vault contracts as well as the oracle contracts. So over here, hopefully this is clear, which contracts are in scope and then the contracts that are out of scope. Basically the lending contracts are out of scope. The swap contracts are out of scope. So don't worry too much about those.
00:16:20.268 - 00:16:47.722, Speaker B: Awesome. And then we have compatibilities if we want to scroll down so it looks like arbitrum and avalanche. And then we have a ton of ERC twenty s and different assets that this protocol supports on both ETH and avalanche. So this is fantastic. Especially for you auditors who are looking for those very tricky, weird ERC 20 bugs. This is the list right here. If we do a quick look, we see eth, USDCGM.
00:16:47.722 - 00:16:50.666, Speaker B: I'm actually looking for the weird tokens.
00:16:50.698 - 00:16:59.940, Speaker A: In here, I would say actually, if you think about it, rap, bitcoin is kind of weird. One of the rare ones, eight decimal places. I have no idea what the history.
00:17:00.950 - 00:17:13.286, Speaker B: Yeah. And then it looks like we have on avalanche, we have USDC, which is obviously another weird ERC 20. So if you're looking for some of these weird ERC 20 bugs, this is where you're going to find them.
00:17:13.468 - 00:17:14.006, Speaker A: Cool.
00:17:14.108 - 00:17:18.200, Speaker B: So let's keep scrolling down. We have setup, which is great.
00:17:19.690 - 00:17:25.450, Speaker A: We use foundry for the test. So even though it's a hard hat project. So just kind of take note of that.
00:17:25.600 - 00:17:37.200, Speaker B: Excellent, excellent. So we have foundry envs. Scroll down a lot quicker. I think there's one more thing I wanted to look at. Scroll down quick. More context. Yes, scroll down more.
00:17:37.200 - 00:18:07.906, Speaker B: Is there anything else that I wanted to. Okay, great attack ideas. Now let's talk about. So before we do, I would love to do a quick code walkthrough. And I know you recorded that, but before we actually do that, let's answer this question. Where do you think this protocol is most acceptable? Where do you want auditors to more specifically look at? What are the attack ideas? What are the pieces of your code base that you're like, hey, this needs to be right. This is where we can look for bugs.
00:18:08.098 - 00:18:59.930, Speaker A: Yeah, well, okay, firstly, I'm not going to go through the stuff that I already wrote here because I think folks can read here. These ones are actually written by one of our solidity engineers who is familiar with audits. So he wrote his thoughts to add on to stuff, maybe more high level parts. Where I feel more worried about would be the fact I have to tie it into the fact that GMX version two has a very unique way of handling transactions. It's not a one step transaction flow, where if folks that are familiar with most normal transactions, if anything in that transaction is wrong, the whole transaction can revert. And in a way, meaning to say the transaction didn't even go true. So you can sort of be a little bit more defensive.
00:18:59.930 - 00:19:45.640, Speaker A: But one of the biggest challenges that we face in creating our strategy vaults is that because GMX has a two step process, so you could actually be sending assets out in the first transaction, and then you have to wait for GMX to follow up the rest of the transaction in a follow on second transaction. And that's where we need to have these callback functions for GMX to call in order for our strategy boards to say, okay, GMX is done with those transactions, let's proceed on with the rest of the flow. So I did record this or try to explain this in the video recording as well. So for folks that are not familiar, do check out my video recording. If not, you could ask in the discord chat, too.
00:19:47.050 - 00:20:01.070, Speaker B: Awesome. Thank you for that. And we had a question come in. So how are lenders protected from impermanent loss? It sounds like that's not something that your protocol would actually deal with here.
00:20:01.220 - 00:20:09.550, Speaker A: No. Yeah. And also, the question is a bit weird, because impermanent loss is a concept that only applies for liquidity providers like amms.
00:20:12.370 - 00:20:30.238, Speaker B: Yeah. So the answer here is, it doesn't have to deal with that, which is nice. All right, cool. So that was one of the best attack ideas. Somebody asked, where is the video to find the recording? So equius posted the link. It is also in this readme. What I would love to do now.
00:20:30.264 - 00:20:30.454, Speaker A: Yeah.
00:20:30.492 - 00:21:07.680, Speaker B: So there are more attack ideas where to look for bugs. Definitely be sure to give this a read, everybody who's watching this, because this is where the ideas are. They did a phenomenal work, even talking about the main invariants. So all the test suite is written in foundry. So those of you who have watched a lot of our invariant testing tutorials, this is a perfect opportunity to try to use those skills that we learned there. Right? How do we actually write these invariant tests? How do we make sure that this protocol keeps these invariants? This is a perfect way to start writing invariant testing handlers. Right.
00:21:07.680 - 00:21:28.838, Speaker B: We at Cypher have literally spent time just taking a day to write invariant tests, and we've been able to find critical bugs. Just doing that. When I first got into competitive auditing, that was one of the ways I called it, like cheating that I found a lot of bugs. I was just like, all right, cool. Let me just write an invariant test suite real quick. Boom, found a couple bugs. Right.
00:21:28.838 - 00:21:42.540, Speaker B: So great way to actually do that. And we have the invariance written out here. So, Jeff, I know we recorded the walkthrough. I'd love to do kind of a quicker TlDR of the code walkthrough if we want to scroll up and do that.
00:21:43.150 - 00:21:56.138, Speaker A: Sure. Yeah. Okay. So I'll use skidk to do that. So guide me through how you think I should better do or best kind of do this code walkthrough. Should I talk about the high level of how the contracts?
00:21:56.234 - 00:22:16.040, Speaker B: Yeah, good question. So here's how I usually like to start thinking about protocols, especially when I'm thinking about attacking them. What are going to be some of the main functions that users are going to be taking? So it sounds like taking out leveraged positions. Right. That's going to be one of the main things. Where is that function? What is that entry point to your system?
00:22:16.650 - 00:22:44.570, Speaker A: Yeah. Okay, so maybe before I go into the code walkthrough, I actually think explaining it with the diagram, with another diagram would make a lot more sense. Let me open it up for folks that are looking at this too. So we have a docs folder. The document that I just talked about was in the readme, but we do have a docs folder with more sequence diagrams and whatnot. Sorry. Just open one here.
00:22:44.570 - 00:23:15.034, Speaker A: So if things are a little bit confusing on the flow, I do recommend you also check out this folder. This is a little bit more of a detailed one. And then there's also a technical documentation markdown file here that goes a little bit more in depth here. You can see I explained what delta long and neutral is and so on and so forth. But let me hold on, strategy faults here. Contract architecture. Yeah.
00:23:15.034 - 00:24:22.702, Speaker A: So the bulk of the contracts that we want most folks to really look at, I would say, is our strategy vault contracts, which is essentially everything in this folder here, strategy GMX. So all these contracts are needed for a strategy vault, which seems like it's a lot of contracts, which I would say it is, but the way that we structure it is that we break it out into many numerous contracts, because we were struggling to put all the functions into one contract due to the contract size limit of solidity. So by breaking it out, it makes it a lot more modular. And we also realized that we could deploy them as external libraries. So it's actually reusable by other new contracts that we deploy as well. And so because of all these numerous contracts, it can be a little bit, I would say at first glance a little bit confusing or maybe intimidating as to how these contracts all work with each other. So this diagram I think is, I would recommend everyone to take a look first.
00:24:22.702 - 00:25:14.558, Speaker A: So it gives you a little bit more idea as to how to sort of navigate through these contracts. So first up, I'll talk about the color coding. So I mentioned that a lot of these contracts could be deployed or will be deployed as external reusable libraries. And so they are color coded here in blue, meaning to say that when we deploy them, we just deploy it once and they can be reused by any of the actual smart contracts for the strategy vault, which are here color coded in white. And I would start first by looking at the GMX vault contract. So every time we deploy a, let's say we deploy a tree x long if USDC strategy, and then we deploy a tree x neutral eFuSDC strategy. Each of these strategies will be deployed as a smart contract with an address tied to their own.
00:25:14.558 - 00:26:04.542, Speaker A: And this here is in white. But these contracts, as we deploy them, they can be referencing, or they will be referencing all these external library contracts that we deployed previously already. And hopefully the naming of the contracts makes it quite clear as to what the contract is responsible for or what it has functions for. So you can see that here are the various actions that user can take, or I should call them a depositor to the GMX vault can take. So we have deposit, which is conveniently named GMX deposit. And then we have, right, which is when a user wants to withdraw, we have something called compound. And compound is essentially when a strategy vault has some incentive tokens or bonus tokens or extra yield.
00:26:04.542 - 00:26:42.410, Speaker A: As you can think about it, we have a process that essentially takes that extra tokens, sells them and sells them for more liquidity. So therefore the vault increases in value. So that's a compound. We have something called rebalance and rebalance, which is something that isn't that common in this space, I would say, but essentially steady five vaults. We want to make things as automated as possible. We always talk about automated risk management. So for example, when we talk about tree x long strategy, in reality prices of assets move.
00:26:42.410 - 00:27:30.060, Speaker A: Your initial tree x long strategy may become higher. Four x, five x may become lower. And so to keep the strategy true and honest, we don't want to stray too far from the original amount that we say. So if, let's say you're at a tree x strategy and it goes too much leverage, you want to deleverage and vice versa. If your leverage is too low, it makes sense to borrow more to keep it up to three x again. So rebalance is essentially various functions that check for the status of the bot to see if there needs to be more borrowing or more repaying to add higher to the initial strategy of the bot. Again, I'm not sure if I explained that clearly, but feel free to ask me and then I can repeat it again.
00:27:30.060 - 00:28:19.178, Speaker A: And for the emergency library, as the name suggests, it's various functions that we only want to execute in an emergency. So things like pausing of the vault to try to protect funds as much as we can, as well as shutting down of the vault, as well as withdrawal for users to withdraw assets from the vault if, let's say we close the vault down for good as well. So these are the various actions we can take. Maybe I could also highlight what process deposit means here. So the process deposit and process withdraw libraries is a little bit awkward. It's just like a small little contract that has one function. But the reason why we have this is because, as I shared, GMX has a two step process.
00:28:19.178 - 00:29:23.390, Speaker A: So instead of having just one function, let's say we deposit instead of having it just all in one function, we need to also have a callback function for GMx in the second transaction when it calls the vault again for us to go through that second function. I'm not sure if anyone has questions on this I can kind of answer during the week again, because I would say this is really quite a unique structure of flow that's not very commonly seen in defi so far. So anyway, we have this process deposit and process withdrawal function for those callback functions. So all these functions are responsible for the particular have functions that are responsible for those things that we talk about. But everything should flow to a GMX manager library. And here the GMX manager again, we try to name it as much as we can to how it makes sense. So it's sort of like the manager of the strategy.
00:29:23.390 - 00:30:16.078, Speaker A: It's like a portfolio manager. So what does this manager do? It has various actions, or it's responsible for various functions like doing the actual borrowing of the assets, or repaying the assets, or actually adding the assets as liquidity to GMX, or removing it, or if there's any swaps that's needed to be done. The manager has all these functions within it. And then we have a GMX worker library function. And the reason why we have a separate worker contract is because we want to make a lot of these code as reusable as we can down the road as well. And the worker contract is really a dedicated contract that is very protocol specific. So today we might be creating a strategy into GMX, but tomorrow we might be creating a strategy into some other protocol.
00:30:16.078 - 00:30:56.442, Speaker A: And that other protocol would have very protocol specific functions for adding liquidity, removing liquidity, so on and so forth. And we would have to code those functions differently for that protocol. And that's where the worker contract is really responsible for. So it's a protocol specific function for doing things like adding liquidity or removing liquidity. And then maybe I can talk about the three contracts here that sort of not link, but in reality, all these contracts, all the three contracts at the bottom are used pretty much by a lot of these contracts all over. So I don't want to mess up the diagram too much. Therefore, I didn't put the arrows everywhere.
00:30:56.442 - 00:31:36.250, Speaker A: But the types contract is really just a contract. It's like a type definition contract for those of you that are familiar with what types are in other programming languages. So if you open it up, you'll see that it's essentially structs of different sort of variables in it. But there's no state, there's no logic or anything like that. So for us to store a lot of variables across our contract, we decide to put them all into one big strut called the store. And that's where you can reference it using GMX types. GMX checks is where we put all the functions that deal with checking of anything.
00:31:36.250 - 00:32:14.246, Speaker A: So before we do a deposit, before we do a withdrawal, or after we do the deposit as well, we want to check that everything is okay. That's where we put our checks functions. And for the GMX reader, it's a library that has all mostly read only functions. So there's a lot of data that we want to read. Things like the debt ratio, the leverage, what's the current delta, how much is the available capacity of this vault, so on and so forth. So we put all these read functions in the GMX reload. What else can I talk about? Okay, I think I can also talk about the ones on the left here.
00:32:14.246 - 00:32:35.402, Speaker A: I think someone asked about what the trove function is. But before I talk about the trove, I can talk about the callback. So the callback contract here. So notice that these two contracts are in white, they're not in blue. So these are not reusable. These will be deployed every time we deploy a new strategy vault. We would also deploy these new vaults and link it to the main strategy vault.
00:32:35.402 - 00:33:17.098, Speaker A: So the GMX callback contract is a dedicated contract that has all the callback functions for GMx to call. That's why it's called the GMX callback. So open that up and you'll see that. Okay. After a successful deposit into GMX or a successful withdrawal, it has the function to let GMX call. But because there are many different avenues in our strategy vault where a deposit to GMX can happen, therefore, in a after successful deposit callback, we still have to do some logic to check what is the follow up function to do? Maybe I can talk a little bit about this, or maybe I'll open up the file and then we can talk a little bit about this.
00:33:17.184 - 00:33:58.982, Speaker B: Sure. Actually, I do want to just pause for a quick second. A couple of questions that come in I want to answer real quick. So number one, just finished part one of your foundry course. Is it enough to start participating, auditing this protocols? The answer is kind of, you can pretty much always start doing security reviews and doing audits pretty much whenever you want. And that will actually hyper accelerate your learning because doing actual security reviews, doing actually audits will make you learn so much more, so much faster. I will advise that you should probably finish parts two and part three because we actually talk about a lot of defi stuff.
00:33:58.982 - 00:34:45.270, Speaker B: We talk about how to run some of these buzz tests and variant tests and just what good code smells like, which can actually be really helpful because if you read some code that just doesn't feel right, it doesn't seem like it follows good design principles that can be like a red flag. And maybe you just go down that rabbit hole and you find a bug because of that. So the answer is you can always jump in, but I would recommend you keep going. Or what you can do is you can try this right now, see how you do. And if it's challenging, you'll use that as fuel to go back to the course and keep learning. And then the next time you go try a competitive audit, you will hopefully do much better. What about centralization? Are there centralization risks associated with this protocol?
00:34:49.550 - 00:35:38.802, Speaker A: Short answer is yes. Short answer is yes. So there's an owner role as well in this protocol. And essentially I would say that for any functions that is accessible to an owner, there could be a centralization risk. There's really, I think two things I would point out. Firstly is, which is not really a smart contract thing, but we would have timelock controllers, and timelock controllers would be the actual owner of these contracts that we deploy. And the timelock controllers would be managed by a multisig.
00:35:38.802 - 00:36:14.850, Speaker A: So that is one step to try to reduce like a pure centralization risk of just one person being able to update things. The second is as much as we can. And this could be something for folks to point out. Auditors to point out would be that for very sensitive things, we would actually try to have checks within our contracts to limit the configuration that we can do as well. So I would say, yeah, we try to tackle this on two points, but if there's something that's very glaring, I would think it could be a good finding.
00:36:15.510 - 00:36:17.714, Speaker B: Nice. Awesome. Thanks for that.
00:36:17.912 - 00:36:18.286, Speaker A: Cool.
00:36:18.328 - 00:36:38.490, Speaker B: So there's a couple of different places we wanted to go down. I would love to actually jump into one of these contracts with one of these entry points and just see, hey, here's an external or public function that a user can call. And what are some of the main functions people are going to be calling when interacting with this protocol?
00:36:38.910 - 00:37:10.098, Speaker A: Yeah. Okay, let me maybe switch my screen to the code editor. It might be easier that way. Sure. Let me use this. Okay, so stop screen, share screen. I probably need to zoom in, I suspect.
00:37:10.194 - 00:37:12.614, Speaker B: Yes, you're going to need to zoom in a whole lot.
00:37:12.732 - 00:37:13.702, Speaker A: A lot more.
00:37:13.836 - 00:37:19.130, Speaker B: A little bit more. Yes. Okay, that's better. Yes. Good luck.
00:37:20.590 - 00:37:49.534, Speaker A: Okay, so continuing on where we left off. So let's focus on the strategy vault contracts. So I would really start off first by going into the GMx vault contract. Wow. Okay, this is so zoomed in. Okay, let's do this. So I'll check out the GMX vault contract because this is the main hub, I would say, of every strategy vault.
00:37:49.534 - 00:38:15.626, Speaker A: So check this out. I do recommend doing this for those of you using vs code, fold your code. So it might be useful to just look at what are the various functions here first. So we have a store function here. The store function basically just returns the store. And remember how we talked about, we try to pack all of our variables into a struct. So this is what it's essentially doing.
00:38:15.626 - 00:38:46.130, Speaker A: And maybe here is a good time to just open up the GMx types file, do the same thing, fold it again. So what does store mean? A store is this huge struct here that consists of all these variables that we throw in. Right. So this is all one struct and we store everything in there. And this function basically returns the store. So anyone can access the information within the store.
00:38:46.200 - 00:38:50.166, Speaker B: That's a wonderful little solidity workaround for stack two deep right there.
00:38:50.268 - 00:39:26.240, Speaker A: Exactly. Yeah. So as you can see, we have so many variables that I think once you go into 16, well, if you don't use this method, there's no way to have so many variables. But I think one interesting thing, one weird hack about solidity, two is that even if you use a struct, let's say if we use this struct and we put it into a contract, I think after 16 variables within the struct, we get into the stack, 2d error as well. But for some reason, when we put the struct in an external library, you could have more than 16 variables. And it's okay.
00:39:30.470 - 00:39:40.658, Speaker B: Last time I checked, they put a lot more of the struct stuff in memory. Last time I checked. So that's why. Because it's not on the stack anymore, right, so you don't get stacked too deep.
00:39:40.834 - 00:40:27.846, Speaker A: Yeah, it's interesting. Okay, so this is the types file, and this types file is being used everywhere across the contracts. Okay, so maybe what we can do is we can reference, maybe I'll just highlight a few things. So as shared, this contract is the main hub that users will interact with, the keepers will interact with, so on and so forth. So every time we want to do an interaction with the vault, we need to have a function in this vault contract. So whether for example, depositing, right? That's a very common action. But also when we want to read any data, we would have to have that same function in this vault as well.
00:40:27.846 - 00:41:06.402, Speaker A: So almost everything has to be in this vault. But the functions in this vault are really just passing the main logic to the library contract. So let's use a simple one. So let's say we want to find out what the debt value of this fault is. So we have a function in this contract that says debt value, but we open the function and all it does is that it's saying, okay, you just want to read this. Let's pass this function to the GMX reader contract, which is all the read functions, and we would then see that. So we go to the debt value function here.
00:41:06.402 - 00:41:32.060, Speaker A: And so this function here is where most of the logic lists, and this pattern basically repeats all the time. So even though there's so many functions here, there's pretty much almost no logic in this main contract here. We just pass that logic along to one of the library functions, which then has all the code logic to actually get the value correctly and return it. Should I go into one of the bigger functions, you think?
00:41:33.310 - 00:42:04.078, Speaker B: Personally? Yeah, I was going to say I would love to see the deposit function, because to me, this is going to be one of the most important functions of the contract. This is going to be what people are going to be using a lot, and it'll give a lot of really good context to auditors, because to me, I consider there to be like a couple of key entry points, and this is one of them, to really just, if you walk through the tree of deposit, the rest of the protocol can kind of come into the painting. The picture starts to become a little bit clearer.
00:42:04.174 - 00:42:46.340, Speaker A: You start to get the flow of things. Although I would say the rebalance part could be a little bit trickier. But yeah. Okay, let's go into deposit first. So, deposit functions, and as you can see here, most of the arguments that we pass into functions are not straight up variables like a string or uint, but we also reference it as a struct that is referencing type. So again, here we call it dp, stands for deposit parameters. And then if I open up Gmx types and I search for deposit param here you have a struct that has all these variables that we want to pass.
00:42:49.430 - 00:43:00.854, Speaker B: A. There's a slippage parameter, which is interesting. So when I deposit this, it's going over to Gmx to deposit it. Okay, got it.
00:43:00.892 - 00:43:57.240, Speaker A: Nice. Actually, this is quite a big one that I would say for auditors that are familiar with defi, beyond the code. This is something that could be a potential issue, because slippage, in this example here is, let's say if I deposit one dollars into Gmx, I should get back at least a dollar's worth of GMx liquidity token. But the slippage here is saying that if I don't get back, if my slippage is too high, essentially right, then GMX would actually not give you back those tokens, because it's saying that you want a better slippage rate, we can't give it to you. So it would return the assets back to you. And because, again, of the way of how it's a two transaction process, that's something that I think for most folks. We would love more eyes on this flow here.
00:43:57.240 - 00:44:24.660, Speaker A: Okay, let me go back to deposit, what to talk about. So, okay, we pass in the store, we pass in the deposit parameters, and then we have this thing called false. And instead of guessing what it is, let's just go into the library. So here it's a GMX deposit library. Keep folding this. Okay. And then here we go into the function itself.
00:44:24.660 - 00:44:54.134, Speaker A: And this would be a relatively longer function. Okay, what does the deposit function do? So, first argument is the store. So library contracts can't hold state. That's why we have to keep passing in the store parameter into all these libraries. And this is something that you keep seeing over and over again. This is the deposit parameter that was passed in earlier as well. And then here we have an argument for true or false, which is is native.
00:44:54.134 - 00:45:20.050, Speaker A: So if I go back to deposit, we have two functions here for deposit deposit and deposit native. And very simply because our strategy vaults could accept native eth or native avex, depending on which blockchain. So in order to handle that correctly, we have two different functions here to specify deposit, which is a non native asset. So it's an ERC 20 asset mostly, or deposit native.
00:45:23.670 - 00:45:25.538, Speaker B: Oh, it's the same thing. Just for true. Got it.
00:45:25.624 - 00:45:39.100, Speaker A: Just for true, of course. Yeah, that's right. But most of the logic is the same. That's why instead of having two different deposit native or deposit functions in the library itself, we just have native boot in here.
00:45:39.630 - 00:46:11.380, Speaker B: This first check here, if self dot token a balance of editors is greater than zero. I might have found a little tweak here already. We're assuming that we haven't checked if we're looking for native, right? So what would token a and token b be? Oh, no. Token a and token b. Never mind. Okay.
00:46:12.710 - 00:46:14.562, Speaker A: You don't want to give away the finding. I get it.
00:46:14.616 - 00:46:25.638, Speaker B: No, it's not that I don't want to give away the finding, it's just that I'm confusing myself. So we haven't checked for is native yet. Maybe that doesn't matter. Yeah, it sounds like that's actually fine.
00:46:25.804 - 00:46:26.134, Speaker A: Yeah.
00:46:26.172 - 00:46:27.718, Speaker B: Okay, cool. Sorry, keep going.
00:46:27.804 - 00:47:08.138, Speaker A: No problem, no problem. Here we suddenly bring in the word trove. So it might be a little bit od. Like, why are we doing this? And to be honest, this is something that we add on at the last minute. And the biggest reason is because we also would have strategy vaults that cater to ArpusDC on GMX. And we want to also prepare our strategy vaults to be able to properly receive ArP rewards that GMX will be giving. So in order to sort of prevent this mix up of Arp rewards that GMX will be giving versus users depositing ARP into this strategy vault.
00:47:08.138 - 00:47:23.014, Speaker A: Therefore, we have this flow of saying, okay, every time a user deposits, we make sure there's no sort of dust balancers or any random balances from anywhere. We clear it to one side first so that we can properly account for the user's deposit and take the relevant actions.
00:47:23.142 - 00:47:31.546, Speaker B: Jeff, this looks like such a fun audit. I'm like, kind of upset that I'm not going to be participating. This looks so fun. Cool. Sorry. Keep going.
00:47:31.648 - 00:47:49.234, Speaker A: Okay. No, problem. Yeah. So we do this check here first to sweep tokens to a site. We call it a trove, make it sound a little bit nicer of where the little rewards are. Then we have this thing called a refundee. And here is another kind of very GMX version two thing.
00:47:49.234 - 00:48:36.414, Speaker A: So because of the two step process, again, what we need to do when we call any functions that interact with GMx is that we have to pass something called an execution fee. So if you go back to types again, you'll see something that happens that shows up. Very common execution fee. An execution fee is literally native tokens like EtH in arbitrum or Avax on avalanche. So the user would have to pass in a small amount of native gas along with whatever deposit that they are depositing into. And the strategy contract here would pass those gas tokens along to GMX. GMX will actually use a portion of those gas tokens and there's usually some leftover.
00:48:36.414 - 00:49:05.258, Speaker A: And GMX would just refund those leftover back to this strategy bot contract. Now, we don't want to hold and be keeping users leftover native gas tokens for no good reason. And what we want to do is we want to actually refund the user who sent those tokens for gas in the first place. Therefore we have this thing called a refundee. And it's a payable function because it will be refunded in. We're dealing with native gas here, so it has to be a payable type.
00:49:05.424 - 00:49:23.182, Speaker B: So we only have a few minutes left here. We've covered a lot so far. Let's speed through the rest of this function. Then we'll spend the last couple of minutes for any last questions, and then we'll, we'll close it up here.
00:49:23.316 - 00:49:55.354, Speaker A: Yeah. Okay, so real quick, we have this thing called health params. And you'll see health params thrown around quite a few places as well. Hopefully it's quite self explainable. So we store things like what's the state of the vault before? And we do this because there's a lot of checks that we also have during the whole process. We want to make sure that during the whole journey of depositing, withdrawing, et cetera, that things make sense. For example, if you are depositing after a successful deposit, we want to make sure that the equity of the vault is higher.
00:49:55.354 - 00:50:18.930, Speaker A: If for whatever reason the equity is lower, we will want to do a revert because that's probably a buck somewhere. Really. So that's what alpharams is for. Here we talk about handling of a native token. In this case we have to do it like that, or ERC 20. Then we have this thing called a cache. And again, cache is something that we'll see very common in the types.
00:50:18.930 - 00:51:15.170, Speaker A: And once again, it's simply a place for us to store some details so that when GMX does its callback in the follow on contract, we can reference past data from the previous transaction. Okay, let's see. Here's maybe also another interesting thing to note, which is, so let's say for a ETH USDC strategy vault, the vault would be able to accept up to four different type of tokens, if you think about it. So there's native ETH, there's USDC, there's rep ef, and there's also the ETH USDC GM token or the LP token. So the vault is actually able to accept all these tokens. And if you think about it, accepting a liquidity token is a little bit different because of how you calculate the value of LP token. And for auditors, I would also say that this could be something to kind of take note to make sure that we calculate the value correctly despite all the different tokens that is being deposited.
00:51:15.170 - 00:51:54.800, Speaker A: Okay, then we go ahead and do various checks. And so like I shared earlier, for all check functions, we put it in GMX checks and then we change the state of the vault. And the reason we change the state of the vault is because there's so many things that can happen in this vault that can also be true, different transactions. So when someone is depositing, we don't want to allow, when a deposit is not complete, we don't want to allow another user to deposit as well because that's going to mess things up. So it's a very one transaction or one action at a time type thing. So status is very important to be set correctly as well. So we don't allow incorrect actions to happen.
00:51:54.800 - 00:52:27.322, Speaker A: We go ahead and mint fees to the protocol. We do some calculations for how much we need to borrow to leverage up and whatnot. Do the actual borrow, add the liquidity into GMX through the GMX manager, store this data and then immediate event. And this is the created event. So that's the first transaction that goes into GMX. And I'm skipping a little bit here into the contracts because I know we're running out of time, but real quick. So what happens after this first function? Now we go into the callback contract itself.
00:52:27.322 - 00:53:17.594, Speaker A: So in a successful deposit by GMX, GMX would call after deposit execution. And here is where we start to basically, we do checks to say, okay, so GMX calls these, but what is the reason? Like, what is the follow up action that we should do? So, in a normal deposit, because the status we set previously was deposit, we would just call process deposit, and process deposit is back. Here's also another gotcha. Because these are library functions, right? Libraries can't call libraries. They can't host state. So this library, or rather this contract, has to call this vault address function. So we go all the way back here again, GnX vault, which has a process deposit function, which just pass this along to the deposit library again.
00:53:17.594 - 00:53:38.980, Speaker A: And here is the actual logic of the process deposit function. And all this does is to check that if everything is okay, then it means the vault tokens to the user that deposited and say completed. And if things are not okay, that's where we need to start to do another flow of handling things, to kind of reset the vault again. So it gets a little bit complicated here.
00:53:39.510 - 00:54:13.840, Speaker B: Fair. Okay, cool. So, Jeff, this has been a phenomenal walkthrough, and it's going to give the auditors here a whole lot more insight. The diagrams, especially, have been spot on. So in the last two minutes that we have left here, for anybody watching, are there any final questions that you have for Jeff? And there's a slight delay between when I ask and when the comments come. So I'm going to fill the time up with me explaining that. Vignesh, I see your question here.
00:54:13.840 - 00:54:37.410, Speaker B: Looking for a quick clarification. But, yeah, if there's any other questions, obviously, if there's no other questions, Jeff is in the discord. He's been fantastically responsive in there. But, yeah, step one of these security reviews, as you all know, get context, right. Read the docs. These diagrams are phenomenal. Go through the walkthroughs, start taking notes.
00:54:37.410 - 00:54:47.720, Speaker B: Hopefully you've watched the video of Tincho and I walking through the ENS high level audit that he did. Take notes in the code base, ask questions.
00:54:49.370 - 00:54:49.734, Speaker A: Cool.
00:54:49.772 - 00:54:59.302, Speaker B: All right, no questions. Awesome. Well, Jeff, thank you so much for being here. This was really you.
00:54:59.356 - 00:55:00.126, Speaker A: Thank you.
00:55:00.268 - 00:55:20.142, Speaker B: Absolutely. And code hawks auditors, good luck finding bugs. It looks like this is a really fun you find. I hope you find what you're looking for. So, Jeff, thank you so much for being here, and good luck, auditors, and we will all talk soon.
00:55:20.276 - 00:55:21.050, Speaker A: All right, bye.
