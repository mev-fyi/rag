00:00:00.330 - 00:00:00.880, Speaker A: Welcome.
00:00:02.610 - 00:01:02.330, Speaker B: Hello, welcome all to another ciphernots formal verification interview. We've been doing a ton of these recently, and for good measure, because we want to get a lot more awareness to formal verification, what it can do for us, what it needs to do for us, because I don't know if you all noticed, but we lost another 1.7 billion with a B dollars last, last year in hacks and scams. And we need better testing, we need better security, and just need to have a higher level of maturity when it comes to tooling in the space. So that's why I'm incredibly excited today to continue the topic of formal verification. To speak here with mate from the Ethereum foundation, who's working on Hevm, one of these formal verification tools, karma, who we interviewed, who's one of the main lead devs on Halmos, was like, hey Patrick, you got to talk to mate. He's a gigabrain, he's doing all these cool stuff with form of verification.
00:01:02.330 - 00:01:08.258, Speaker B: You got to talk to him. And I was like, okay, let me see if I can track him down. So thank you so much for being here. How are you doing today?
00:01:08.424 - 00:01:14.642, Speaker A: Sure, thank you for having me. I'm good, thanks. Yeah, it's a good day. It's a good day.
00:01:14.696 - 00:01:19.800, Speaker B: Okay, great. Well, mate, let's jump into it. So who are you?
00:01:21.050 - 00:02:21.770, Speaker A: Well, I'm. Mate, I've been doing this kind of formal verification for a long time, actually longer than I would care to remember in some sense. I did my studies in Hungary, and then I did some work on security of RFID protocols, basically. And through that I got into using what's called SAP solvers, one of these tools in this space to break ciphers. And so I developed this tool called cryptominisat, which is obviously one of these thought solvers. And then through that, I kept doing more and more of this form of education, and now I ended up in EF. It's been a long journey, actually, but let's say I finally arrived, or something.
00:02:21.840 - 00:02:59.494, Speaker B: Of the sort, at least finally arrived in the crypto world. So we were kind of talking on Twitter a little bit before this, and you were saying, hey, I know about formal verification. If you want to ask me a bunch of solidity questions, maybe that's not going to be the best use of our time, but. So how did that process go? So you're working on formal verification. Did the EF approach you and be like, hey, we need someone to build this tool. Did you go seeking opportunities for formal verification? Because I feel like formal verification is so niche, right? So how did this come about?
00:02:59.692 - 00:03:56.182, Speaker A: It is very niche. I think what happened is that I've been writing this tool called crypto minisats for a long while, and then I started doing more and more research, actually, in the sense that I started going to university and actually publishing work and stuff in this kind of more formalized manner. Funnily enough, there's a name clash here. So in a more formal way, like actually publishing research papers and working in the university and things like that. And then at the time, I was working at a company doing it security, which is what I used to do for a very long time. And I mean, I still consider myself an IT security specialist in many ways. What happened is that I was looking for a different sort of opportunity.
00:03:56.182 - 00:04:44.082, Speaker A: I wasn't very happy at where I was at the time, and accidentally I saw on LinkedIn, of all places, even though I rarely visit. But I saw Leo, who is part of the formal verification team, some friend of mine, or somehow his post got on my feed and I was like, wait a moment, is there like formal verification at Ethereum Foundation? I didn't even know that existed. And I just wrote them. I wrote Leo, like, what's going on? Is there really a formal verification team? Are you part of that? And he's like, yeah, sure. And I'm like, hmm, well, I might be interested. And I think it went from there. So it was really random.
00:04:44.082 - 00:05:15.170, Speaker A: I wasn't even looking for formal verification as a work because I've always done it only as a hobby. So I was doing research as a hobby for almost ten years, like not actually getting paid or anything. And then for a few years I started doing it every a few months a year at a university. And then I was officially paid, of course, for three months a year. But I wasn't like, I was doing it. Security. It has little to do with formal education, of course.
00:05:15.170 - 00:05:43.130, Speaker A: Some things overlap a little bit, but in reality they're pretty far away. I wasn't really looking for it, but I found it and it's great. It's a lot of fun. It's a bit strange to have my work and my copy overlap so much. It's really a bit strange and weird and a new feeling to get paid for the thing that you love is rare. I mean, I love doing it. Security.
00:05:43.130 - 00:05:48.330, Speaker A: Honestly, I really do. But I always had a knack for formal verification.
00:05:49.710 - 00:05:54.830, Speaker B: So, yeah, you found the cheat code. They're paying you for what you'd be doing anyways.
00:05:55.170 - 00:06:37.722, Speaker A: I mean, literally, that's been happening before as well. I mean, I was doing this for quite a while without ever getting paid for it, and it wasn't for the money anyway. I mean, I really enjoyed doing it. It was good fun. It was like one nice thing about this space that I was in called soft solving, which is relatively far away from what we'll be talking about, called Hebm, is that there, there is quite a lot of competition. So it's a very competitive space. And competition means it's kind of fun because you can be at the top of the competition, you can be at the bottom, you can be anywhere, and then you can win, quote unquote, or you can lose by just writing code and submitting it to this platform.
00:06:37.722 - 00:07:11.430, Speaker A: And so that's quite different than normal academia, where the way to win is to write more and more research papers. That's how you win, right? Like, at the end of the day, you have this stack of research papers and now you have one, or, I don't know, you get a little medal for winning academia, right? But in this thought solving, it was actually like, you have to get to win the competition. You have to submit, you have to write code. And like, code I can write. I don't know how to. These research papers are still very strange to me. But, like, writing code, I'm fine with that.
00:07:11.580 - 00:07:13.106, Speaker B: Yeah, gotcha.
00:07:13.138 - 00:07:13.334, Speaker A: Okay.
00:07:13.372 - 00:07:42.350, Speaker B: Makes a lot of okay. So it kind of came across your feed. Leo's like, yeah, this is a real thing. Like, come over to the crypto world, come do your hobby full time. And you're. So you've been doing this for what, the past two years? I think you said you've been doing this the past two years. So what is a day in the life of mate? Working on this is it all right, today I'm full stop or full speed ahead.
00:07:42.350 - 00:07:56.994, Speaker B: I'm leveling up Hevm, is it I'm going to research some crazy new thing on how to formalize geth, or I'm going to do what does the day look like? Or what are the projects that you're currently working on or have you worked on?
00:07:57.032 - 00:08:15.230, Speaker A: I can tell you a little bit of a history and then what I'm working on right now, I think that might make some sense. So the previous year has been all about me trying to learn Haskell, because honestly, I've been writing to my own detriment, to be honest. A lot of c cythe.
00:08:15.250 - 00:08:20.202, Speaker B: Is Haskell like the it thing? Because, yeah, Hevm obviously is like Haskell. Right?
00:08:20.336 - 00:09:15.546, Speaker A: There's a couple other tools but it was written in Haskell and it is a very interesting programming language and there's a lot of very good people working on Haskell, and there is lots to be learned from it. Of course, that's true for CC Plus plus as well. But there's a deluge of just a long tail of people working on CC that is not this kind of research level quality work that sometimes goes into Haskell that you get to interact with more often, I feel, in the Haskell world, than you get to do in c plus plus because of the deluge of people using it, which is basically just the curse of a language that is used by so many people. So it's not like, oh, the terrible c plus plus. I love c plus plus. I write a lot of c plus plus. But the thing is that it is a very popular programming language.
00:09:15.546 - 00:09:58.490, Speaker A: And so because of that, it's slightly different, the kind of people that use it and what it's used for. And so I'm actually enjoying this experience of working with Haskell. But to be very fair, the first year it was very tough. So I'm just like learning what Hebm is and how it does things and also learning about Haskell and how do you write code in Haskell. That actually makes sense because it's not just like another programming language, like imperative programming language. Like you go from Python to c to c to, you know, assembly. All of these are imperative programming languages, but this is something else.
00:09:58.490 - 00:11:33.370, Speaker A: And so it's a functional programming language, of course. And so that took me a year. So that was one year, that was literally a year. And then the next year what I've done is I tried to help improve its performance. And the day of mine, the way it looks like is we have some idea that Lexi and I think up and discuss that, hey, would it be useful to do this? Like, what do you think of this? And when the two of us sort of agree that this might make sense to do, and then we usually also, depending on whether Zoe, my other colleague, is involved, and we also discuss with her and sort of make a plan of what should we do next? And then we either Lexi writes a PR or I write a pr, like a pull request, so sort of basically a change request and try to see if that makes sense. Does that make it faster? Does it make it more complete? There are different calls you can have, like you want the same thing but faster, or you want something that is better, it does more, it gives better user output, it's capable of doing more things. So that's what's been happening the last year, and I think we have made good improvements.
00:11:34.670 - 00:11:51.614, Speaker B: And has that been the full focus? Okay, so first year, want to learn Haskell, got to get to speed with Hevm, kind of what we're doing in this crypto world. And then last year was, okay, let's improve Hevm. Is that kind of the main focus of what you're working on?
00:11:51.812 - 00:13:07.826, Speaker A: Yes, but I think this year we are shifting focus. So this means that we're about to hopefully publish a paper about Hevm. So basically we're trying to move focus from getting it out of the door, making it do the things we want it to do, make it reasonable, fast, and we want to shift focus to external communication, documentation, usability, and making the tool approachable to users. This doesn't only mean that we're going to write documentation. It also means that maybe the options that it provides to the user needs to be more rich. Maybe the error codes or the output that it gives to the user needs to be more understandable or easier to parse. It might also mean that we're going to write blog posts, not just like formal documentation of what each whatever output means, but also sort of like an approachable, user readable sort of text of what it does hide.
00:13:07.826 - 00:13:28.330, Speaker A: Does it like examples, which I mean, I personally learned through examples. Some people love this kind of man page kind of stuff. It's very clearly written and perfectly tight text of what it does, but not a single example. Some people love that. I'm not like that, but I can see how that can be useful.
00:13:28.490 - 00:13:30.974, Speaker B: Lunatics. Lunatics like that.
00:13:31.172 - 00:14:24.030, Speaker A: Some of that. Maybe we'll. So my hope is that this year will do a lot more of this kind of communication and sort of approachability. I've been doing this forever, and all the research tools that I have tend to be unlike, I would say, many research tools. And I don't mean that in a derogatory way, because I think research doesn't unfortunately, reward a tool that is well documented, that is well packaged, that always can be compiled, that has good manual attached to it, has good examples. It's not like academia is mostly for a good research paper and a tool that you can hopefully download and at least run once kind of thing. There's likely, hopefully a binary, maybe there's some source code, if you're lucky.
00:14:24.030 - 00:15:02.550, Speaker A: Maybe it compiles, likely not. But maybe it does, because I haven't approached academia from this side. So I was approaching academia from the side of, I was just writing this tool and submitting this conference and I didn't care about the paper. So for me, what was important is for the tool to actually work and for people to actually use the tool and be able to use the tool. And so mine is one of the very few tools out there in this thought world that is like compiled for arm, Mac, Mac, Windows, Linux. It's packaged for all these different distributions. It just runs.
00:15:02.550 - 00:15:37.558, Speaker A: And then if there's an error, it actually gives you an error text of what's going on, why is it erroring and what could be wrong. I have like a GitHub, for example, for this with over 600 issues that have been closed. So it's like, I really do care about usability and I'm always making sure that it is usable. And so this is what I would like to do for HDM. Kind of take this part of the cake. I think there's like many different parts of this cake that can be taken, but one of them is this kind of communication, usability, approachability. And I would like to improve a little bit on that.
00:15:37.558 - 00:15:58.350, Speaker A: But I mean, it's not only mine. Lex is also working on this, of course, and Zoe is writing the paper in large part. So it's like, I'm not taking all this credit, but one of the things I would like to do for sure is to improve it. And I think both Zoe and Lexi are on the same page, which is.
00:15:58.420 - 00:16:30.886, Speaker B: They'Re my colleagues, by the sense. Makes sense. Okay, so a couple of different things that we're going to go into that sounds really exciting to me, by the way, because I feel like I've tried using Hevm a handful of times in my careers as a blockchain developer. I remember probably the first time I was exposed to it was probably 2020 when I was playing around with DaP tools. Rip dap tools. Although I guess DAP tools isn't really dead. But never mind, that's another story.
00:16:30.886 - 00:17:37.262, Speaker B: So I was playing around with DAP tools and I got introduced to this thing called HvM. That's back when I didn't know what form of verification was, and I was like, this is a waste of time, this is stupid. Now that I know what it's doing, more recently, I've played around with it more. And yeah, when it comes to documentation and developer experience, if you ever want to chat on that, by the way, after the call, I'm more than happy to chat because I love developer experience and making sure people do good. So let me ask you, you learned it for a year, you've been working out for two years now. Whenever I see something written in Haskell, my immediate response is, why? So I hear what you're saying about, hey, you're used to, you know, it's kind of nice, this more scientific programming language, but a part of me goes like, this is going to be really difficult for open source source people to contribute to. I approach Hevm, I can approach a rust tool, I can approach a python tool.
00:17:37.262 - 00:18:28.110, Speaker B: If I'm feeling really ambitious, I can approach a c plus plus tool. Normally I don't feel that ambitious though, but when I approach Haskell tool, my brain just kind of shuts off and I'm like, I don't know if I'm going to even bother contributing. I guess from an open source contribution standpoint, and from a tooling standpoint, should more people get into you, do you understand the choice behind what is about the Haskell that makes it good for this use case? Because yeah, we have Halmos obviously, which is written in Python control, which is written in, it's the runtime verification tool. I forget what it's written in, but it's on Haskell. Some of these other tools may be written in rust. Why Haskell?
00:18:28.850 - 00:19:18.000, Speaker A: Good question. So first of all, it was not my choice, so it was written in this language when I joined, and it was already a large code base, so I didn't choose it. And I would of course never have chosen it because I basically didn't even know about, like that's back then. Right now, I actually think there are some really good reasons why Haskell makes sense. I see all the points that you raised, and it's worth thinking about. It is really worth thinking about. Of course, it's a big step to say, oh well, let's just move on from Haskell and rewrite it in something else.
00:19:18.000 - 00:20:54.954, Speaker A: But if I want to defend Haskell as a choice of language, I could actually really defend it. I wasn't very sure of that two years ago, but now I feel like there are some good reasons to do it. One of them is that effectively if you write one of these simulc execution frameworks, which is what Hebm is, then eventually you'll be basically end up writing what's called a rewrite system. So there is a rewrite system is basically saying, well, a plus zero is a. Right, this is a trivial thing, right? But this is exactly what compilers do, right? If you write something like a line in C Plus plus, saying a is equal to a plus zero, that line doesn't exist. Like the C Plus plus compiler will eventually just get rid of it because it knows that it's complete nonsense, right? Like it's not actually required for it to do anything for that to hold, right? The similar execution systems, of course it has multiple parts, but the most important part in my view, or it's got three parts, one of them is we'll talk about it, maybe if we get the time, but at the beginning is sort of like ingest the input, then translates it into some intermediary representation, which is what most compilers will do. If you give it c, rust, whatever, it will take the input file in, put it into some internal representation of what it understands, and eventually moves that into a final sort of thing that it actually either outputs as an assembly.
00:20:54.954 - 00:22:11.174, Speaker A: For example, if it's rust or c or c plus plus or whatever, or in our case, it outputs it as a bunch of what's called SMT queries, a bunch of queries that eventually get solved by another system. And if you look at the symbolic execution framework as sort of a pipeline, then a rewrite system happens in two stages of this pipeline, actually the first one as well. But let's forget about that for a moment. So let's say that you have this intermediary representation that you have created out of the original code that came in, the original, let's say EvM assembly, like EvM bytecode that came in, you created this intermediate representation, and now you need to send this off to this solver to ask. So the solver can answer whether there really is a bug or there is no bug. And eventually what you want to do is you want to simplify this query as much as possible, right? And you want to remove stuff like a is equal to a plus zero, because this is just going to be nonsense for the solver. Like, you shouldn't be giving this to the solver, you want it as fast as possible.
00:22:11.292 - 00:22:15.926, Speaker B: And Haskell can just natively is good at getting rid of that stuff.
00:22:16.108 - 00:22:30.958, Speaker A: So what's nice is that writing a rewrite system in Haskell, it's just beautiful. You can literally write a plus two equals a. That's it. Almost like line. Like, I think there's like three character extra.
00:22:31.044 - 00:22:34.286, Speaker B: Wait, but a plus two does not equal a.
00:22:34.388 - 00:22:38.462, Speaker A: Sorry, a plus zero, right? That's a good point.
00:22:38.596 - 00:22:40.640, Speaker B: I was like, whoa, what is going on?
00:22:41.970 - 00:23:17.530, Speaker A: So in our case, it's actually, I could find you the line of code, but it's like. So you look at it and you can explain that line of code to a six year old, maybe you can't do that in c plus plus. If you do this, it's called an ASP. What's an abstract syntax? T. And if you do this in c plus plus or c, it's going to be like 15 lines minimum with like a bunch of pointer arithmetic and some like, whoa. You're like, whoa, your mind is going to get blown. I've seen this because SMT solvers, so the final tool that eventually solves our ferries is called an SMT solver.
00:23:17.530 - 00:23:49.154, Speaker A: And they of course do these kind of rewrites as well because they're not stupid. They want to do it as fast as possible. So sometimes we can do the rewrite, sometimes they can do the rewrite. So they do these kind of rewrites. But you should look at that code. It's like, you look at it and it's like, okay, strap yourself in. And the problem is, of course, you write one wrong letter and it's some messed up point rate matic and it's going to sec fault or do some kind of weird stuff that you're like, I did not want that.
00:23:49.154 - 00:24:05.978, Speaker A: And now I need to debug this thing. And good luck with that, because these rewrite rules keep on rewriting itself. Of course, you do this to fix points. So you keep on rewriting as much as you can until there's nothing more you can do, right? So like, oh, I've done everything. I've minimized this query as much as I possibly could.
00:24:06.064 - 00:24:08.460, Speaker B: So Haskell makes a lot of this.
00:24:08.830 - 00:24:19.870, Speaker A: Easy, super easy, and very easy to review. So you look at it and it's like, oh, this makes sense. Whereas if you look at c plus plus, you're just like, oh man, I need to take a nap.
00:24:20.850 - 00:24:23.354, Speaker B: I need to take some type of pill to get through this.
00:24:23.412 - 00:25:06.634, Speaker A: And the other thing I would say is that because Haskell is so compact, you can actually like compact in the sense that it's very expressive. It's not so many lines of code you need to write to actually make an important change. So in general, of course, these rewrite rooms are incredibly compact and insanely powerful, but this is because of this pattern matching and ADT that Haskell allows for. I mean, maybe you could do this with rust as well, actually. So there are something to think about. But yeah, I think it's actually a very powerful tool. Now, whether this is the right tool to do this work, it's also not for me to judge.
00:25:06.634 - 00:25:11.038, Speaker A: It's a lot of work that has already gone into scratch would be a.
00:25:11.044 - 00:25:30.982, Speaker B: Lot of work yeah, no, that makes a lot of sense to. So, okay, so I'd love to spend more time talking about Haskell, but there's like a couple other things I want to get to as mean. I asked the question, right? I opened the can of worms. I'm about it. I'm about. So I do want to ask you, though. So you're working on improving this tool.
00:25:30.982 - 00:25:59.022, Speaker B: You've learned Haskell. You're like, okay, great. I get to do my hobby form of verification. Is there a main user you're getting feedback from? Is it the EF giving you specifications? Is there a client? And the reason that I ask is, we've seen tools like Sator, for example. Right? They're basically like a SaaS model. Right. And so their whole thing is, okay, we want to make this tool as best as possible so we can have more people pay for this tool, get it out there.
00:25:59.022 - 00:26:44.000, Speaker B: You have something like Hamos, where it's run by a 16 z. They are kind of like a VC investment firm. They're like, hey, we want to just have a tool so we can give our portfolio products a higher quality of assurance. What is Hevm's target? Do they have a target? How does the EF fit into this? Is this the EF just going, we want to make a badass form of verification tool? I guess I'm asking like 18 questions rolled up into one here. Is there a client that you're soliciting feedback from to implement these changes? Or is it more kind of the nitty gritty kind of research R D project where you're just trying to make it the best it can? EF is just sponsoring you to do that.
00:26:44.690 - 00:26:55.694, Speaker A: I think it's somewhere in between. So there is actually a use case for it. The Echidna fuzzer is using it as a complete execution framework.
00:26:55.822 - 00:27:06.862, Speaker B: Really? I thought Echidna was using Mithril. I guess that wouldn't make or not Mithril Manticore. I guess it wouldn't make sense for the. I think Manticore is on.
00:27:06.936 - 00:28:03.240, Speaker A: Maybe that's for simulk execution, but for concrete execution. My understanding is that it's using. I'm really off now, but I'm always so confused about. I'm much more in the core of the system rather than what its use case is. But maybe that's kind of an issue, and that's the reason why I want to break out of it, in the sense that I want to do more documentation and more outreach and more feedback from users, et cetera, because I want to get to know how people want to use this tool so that we can actually make it more accessible to them so it becomes part of the workflow. I think we could try to add that to other systems. It's not too difficult, I think, to include it.
00:28:03.240 - 00:28:46.230, Speaker A: I don't know if you know about something called SMT checker that is part of solidity and does some kind of basic checking for you when you compile and when you run. I don't think it would be insane to add Hevm like that in the sense that it's default whenever you want to use, for example, some online platform for developing solidity code, let's say. And in there, this would be one of the things that just runs in the background.
00:28:46.970 - 00:28:57.874, Speaker B: Like you download sulk and it automatically downloads Hevm. Two or maybe still two separate downloads, but you pretty much will always download together.
00:28:58.012 - 00:29:47.318, Speaker A: I would like to have it more like sort of a seamless experience, user experience. Of course, everybody wants that. But I think it's also a question of who do we want this tool to be useful for. Let's say that there's like the very sort of academic or very researchy kind of stuff. It's like, hey, you have to write this kind of formal requirements and then we'll check whether with Hebm, whether you can meet these formal requirements with your tool. At the other end of the scale is like hey, we're going to grab through your solidity code and find potential issues, right? So this is like this steady code analysis versus symbolic execution. These are the two fighters in the game.
00:29:47.318 - 00:30:25.058, Speaker A: These are the two contender contestants in this game. The thing is that I personally would like to have a little bit more closer to the static code analysis in the sense that we have a bunch of pre written rules that most people would like to have. And we can check against that because right now what are you going to do with HevM? You can hit an assert, but other than that, if there's no asserts in your code or you didn't compile it with asserts enabled and HVM would just be like, okay, well, there's no asserts, I can't hit anything anyway.
00:30:25.144 - 00:30:27.220, Speaker B: Yeah, congrats. Everything looks good.
00:30:29.830 - 00:31:18.210, Speaker A: The other end of the scale, of course, is that you have some kind of graph. Of course intentionally making this sound stupid, but it can be quite smart grab. It can be like you build an ASD and then from the ASD you search for patterns in ast and you say, hey, there's a pattern in your ASD that sounds dangerous. Are you sure you want to do. And a lot of symbolic execution, I'm going to put them in air codes because they're not really as nowhere near as powerful as HVM symbolic execution frameworks that been out there. What they have done is that they apply these patterns to the source code compiled or not, like maybe the bytecode, and then said oh wait, there is something that we're not really sure this is safe. This sounds fishy to me.
00:31:18.210 - 00:32:22.406, Speaker A: And then instead of just outputting it to the user, they're like oh wait, you know what we're going to do? We're going to run a simulic execution system. And if the simulic execution system says hey, this cannot be reached, then we're not going to output it to the user. So the simulic executions framework was kind of like, if you think about it like almost like a final filter on your pipeline saying hey, should we really output this? I don't want to bother the user unless this is really something that you can hit. That's really a problem. And so that was sort of the role of simulic execution systems in many of these frameworks. And that's not true, of course for Halmosh, it's not true for Kevm, it's not true for Sertora, but it is true for many of the others that have been published. And the question is, can we do something similar but this time around with a full featured symbol execution framework? Because the way it works, of course, is that if the symbol execution framework encounters something that they cannot deal with, it just says well, what's the safest thing we can do? We're just going to output this thing to the user.
00:32:22.406 - 00:33:06.694, Speaker A: And whether it's a false positive or a true positive, we don't know. Right? So it's okay to fail, right. If this is code analysis thingy and at the end you just filter it out. If this simba execution framework fails, well, you just output it to the user and let the user deal with it, kind of. The user will figure it out. I think what we can do is do better because Hvm is just a more powerful framework. Of course, now the question is, okay, so we got the symbolic existing part, so we got the end of the chain, but what about the beginning, right? What about the static code analysis part? I hope we can do something about that.
00:33:06.694 - 00:33:09.446, Speaker A: I'm hoping that we can do something about that.
00:33:09.548 - 00:33:21.340, Speaker B: So you're almost thinking like, all right, the future of Hevm. You're almost kind of hoping it's okay. It's this symbolic execution tool. It's this form of application tool, but it's also like a static analysis tool. You're trying to do both.
00:33:22.190 - 00:33:49.419, Speaker A: I think we could do some kind of checks that Hevm is really good at. I'm not saying that we should do all the checks that all the static code Analysis tools are good at. That's what they're good at. I don't want to overtake the stuff they are really good at. Most likely we're going to be really bad at that. But maybe there's some hole in the middle kind of where they're not very good. We could get better there and we can fill a void almost.
00:33:49.419 - 00:33:53.702, Speaker B: Almost like, almost like a symbolic execution, static analysis, if that makes sense.
00:33:53.756 - 00:34:04.154, Speaker A: You're like, yeah, like something that is more symbolic and symbolic execution and less static code analysis, whereas their system is more static code analysis and less like.
00:34:04.192 - 00:34:26.898, Speaker B: So you're saying for a lot of these fe tools. Well, for a lot of these fv tools where solidity is kind of like the playground that they execute in, they're looking for these asserts. You're saying like, hey, maybe we have hevm figure out a way to not look for asserts, but still verify some invariant. Is that kind of the future? You're for example.
00:34:26.984 - 00:35:07.950, Speaker A: Yes, let's say that I can execute the contract in a way that I personally get money out of it and I never put any money into it. Well, that's something you want, right? So this is a very relatively simple to describe query. This query can be answered by HVM. Right now. There are some cases where it cannot be. So we would have false negatives right now, but maybe with some time I think we can make this almost good. Like of course, not always working perfectly, but I think we can make this much better, much better than with a static code analysis system.
00:35:08.020 - 00:35:08.394, Speaker B: Gotcha.
00:35:08.442 - 00:35:37.270, Speaker A: I think we could do really well. I mean, we need to find a place where this makes sense. To be honest, this is all my personal opinions, just to be clear. So this is not like opinion, this is not Zoe's opinion. I personally want to have it a bit more usable. We'll see. Once we write documentation and examples and stuff like that, I think then we'll start getting some feedback of people saying, hey, this is the kind of stuff I want to check.
00:35:37.270 - 00:36:17.430, Speaker A: How do I do that? Well, maybe we can pre write some of those things, you see, and that sort of moves us more towards static code analysis, of course, but it would be sort of user driven and based on a strong foundation, whereas I think the other way around, it's a bit of an afterthought. The symbolic execution is more like an afterthought. I'm not blaming those people because, of course they want to focus on the thing that they feel like they're good at, which is the static code analysis part. And I want to focus on the thing that I'm good at. And I think what Hevm is good at, well, I'm not very good at it, but Hevm is much better at it. This is symbolic execution.
00:36:19.370 - 00:36:37.110, Speaker B: Makes a lot of sense. So there's a lot of future plans for HuvM, which get me very excited. Yeah, the documentation bit, all this kind of talk about making it this way. More advanced tool. Yeah, really? I'm going to be watching you guys a little bit more closely now. So congratulations, you've set the bar. Just kidding.
00:36:37.110 - 00:37:12.840, Speaker B: So let me ask you a different know. On this YouTube channel, we've had somebody from Helmo, somebody from control, from Satora, now you as well. There's all these different formal verification tools. So my question for you now is, kind of at an ecosystem level, do you think having all these tools is a good thing? Do you think we should gather around one tool and just say, all right, let's go super fast on this one? Do you think we're doing redundancies? What are your thoughts on kind of like the ecosystem of tools that's out there right now?
00:37:13.610 - 00:38:12.170, Speaker A: It's a good question. So I come from a space called thought solving, where basically there were a few tools that people kept on sort of improving and adding to and stuff like that, but there's always been, like, many. And this multitude, you could say, oh, well, this is kind of insane. There's like 20 people, and we're maintaining seven tools. What's the point? At the end of the day, it's like all the same stuff somehow. And I personally had my own tool, by the way, and I just did that one tool and others did other tools. And it sounded kind of insane from the outside because we're just doing the same thing, and instead of going really fast on one tool, why don't we do that? But it turns out that many of these cases.
00:38:12.170 - 00:38:54.274, Speaker A: So once I tell you the idea, like, I tell you the idea, okay, it might take you, like, a day to understand it or to read through the paper, and maybe you see my presentation or you write me an email, and maybe it's in a code so you can actually see it and read it. Like, I sometimes read Halma's code, of course, and you're like, oh, that's kind of cool. And then it takes you like a week to implement it. So the thing is that the idea part is the hard part. And it turns out that there's a guy in thought solving called armin vierre. The person is really genius, but, okay, so he's extremely good at writing code and also very good at research. And it's pretty insane.
00:38:54.274 - 00:39:23.518, Speaker A: But he writes a new soft solver every year, basically every three years at most, okay, which is completely insane because these are like many thousands of lines of code, okay. Like really many lines of code. And you'd be like, this is stupid. Why would you do that? You can just improve the previous one. And he wins almost every time. Okay, so the reason for that is because he writes a piece of code and he's like, oh, this is what I learned from writing this code. Like, next time I'm going to do something else.
00:39:23.518 - 00:40:29.334, Speaker A: And at the end of the day, half of the ideas are not so important anyway because they are superseded by another idea. So you only need to keep in mind a certain set of ideas that you need to implement into a new piece of code. And so, of course, I'm not trying to diminish the amount of insane amount of work that went into HVM or the insane amount work that went into sertora and hallmotion stuff, but it is a fallacy to think that just because Sertora has built this tool for I don't know how many years, and it's like this masterwork of tool, you can't just come in and write it, let's say within a year, something similar. Of course I. And you and probably people who haven't been in the space for years can't. But the thing is that if you've been in the space and you know, what are the most important ideas that you really need to implement, I wouldn't be surprised if you take one of the Sartoro developers just took them out and say, okay, now you do this. They would be able to rewrite the core of the engine, of course, all these helpers and some gui and stuff like that.
00:40:29.334 - 00:40:48.906, Speaker A: Okay, well, that's a different ballgame, of course. And the error codes and the, I don't know, beautiful graphs and all this kind of stuff. Yeah, that takes time. But the thing is that the core of the engine, it's not the end of the world, I think, in case you know what you're doing. Okay, so the question is, are we wasting our time?
00:40:49.088 - 00:40:49.674, Speaker B: Maybe.
00:40:49.792 - 00:41:29.826, Speaker A: But I think in reality that's not the hardest part. The hard part is the ideas and the toad that goes into those ideas. And once you nail them down, you can't write another one without that idea. Just like, I mean, you can, but it's never going to even come close to compete. And if it's all about these main ideas that are relatively easy to write down, well, then it's not a waste of time, I think. But maybe it's not completely stupid to think about it. Join forces.
00:41:29.938 - 00:42:47.250, Speaker B: Yeah, I've had a lot of people ask a lot of questions and we've seen actually in some forums people saying, hey, why don't we just dump all these tools and just focus on one? And I feel like it goes back and forth. There's two sides to it. On one side it's like, yeah, that'd be great if we could all come together, say, hey, let's make this one best thing. But then the other side is, okay, well, we all have different ideas of what the one best thing is going to look like, right? So plus the open source mantra of competition is good, this, that, the other thing. And yeah, to me that makes a lot of sense. So one of the biggest things I wanted to get out of this chat with you is, what is the future of Huvm? It sounds like we've covered a decent bit of that where we're saying, hey, but it sounds like this kind of static analysis, symbolic execution middle piece to me that feels like way of the future, the more immediate future, it sounds like it's kind of, okay, let's level up the docs, let's get people able to use it better. The core engine, are there any crazy improvements that you see the team doing, or do you guys think that, hey, no, it works, it formally verified, it takes your list of booleans and dumps it into a sat solver and goes, tada.
00:42:47.250 - 00:42:55.730, Speaker B: Is the core of it done? Are there massive ten x improvements coming? What's the future? What else is the future of Hevm?
00:42:56.410 - 00:44:06.394, Speaker A: I think most of the core parts are done, but I personally am, from a research perspective, which is probably a bad way to drive something like this. Interested in one particular piece that I would like to put in place eventually, just for fun, just to play with it, but it's likely not sort of the most important thing from a usability perspective. And honestly, I will focus on the usability, as I said before, but I will also do a three month sort of gap going to university, and hopefully I'll be able to work on this piece, which is basically an invariant. Computation. This sounds like very researchy, but the bottom line is that let's say that there is a for loop and it keeps on doing something. Let's say it increments some value. Okay, well, I mean, everything else stays the same, right? Of course that one thing changed, okay? But everything else stays the same.
00:44:06.394 - 00:44:46.120, Speaker A: So the invariant here is that everything else stays the same, like that thing. We can't guarantee what happened there because there's some loop and it runs like 10,000 times and whatever, but everything else is the same. So the invariant here is that everything else is the same. And you can compute these kind of invariants about a contract and say, okay, well, I don't know what state the contract is in, okay, I have no idea. But I can only interact with the contract with these functions, right? So whatever state it is in, it must have got there from this constructor and all these functions, right? That's the only way it could have got there. So there must be some kind of sanity about it, right? You can't just like, oh, yeah, everything is completely random or everything is completely unknown. That's not true.
00:44:46.120 - 00:45:38.758, Speaker A: Likely. Maybe there's some, like when you initialize the contract, there's a total value of the contract, for example, and all the users total can only have that value summed up together. So there are some so called invariance, some kind of like, knowledge that you know about the state of the contract. And if you know this, then you can reason about the contract at any point in time, like not just at the beginning, not just when it's, let's say, destructed or whatever, but at any point in time and make sure that you don't give spurious counterexamples. And this sort of invariant competition, of course, is very hard, and it seems like research has also been struggling with it. And I think maybe we could do a little better. I want to do some kind of work on that space, and that's more like researchy kind of work.
00:45:38.758 - 00:46:26.226, Speaker A: This is one of those ideas, right? If they work out, then it's going to be one of those things that either you have it or you're just like, you're not going to work, it's just not going to work, right? Yeah. This is the kind of stuff I want to work on on a research level, but on an actual day to day, I want to make it more usable. I want to make it such that users can actually interact with the tool, easier, better. There are some handles where you can sort of go up the stairs and learn the ropes. Right. So I want to do that more. But to be fair, I think it's also something that I want to play with from this research perspective.
00:46:26.226 - 00:46:52.802, Speaker A: If it works out, then it's great, because then we can improve the state of the art. Which is to mean if this works out for know, like, sertoro will have it and, I don't know, Halmash would have. And like, just like, we have stuff from Halmosh. It's not like I'm so. No, there are stuff that is from Halvos and we just literally copy pasted it. Okay, so it's not like, also I was listening to Sera's presentation. I'm like, yes, maybe backwards symbolic execution is what I want.
00:46:52.802 - 00:47:13.942, Speaker A: Yes. We steal from each other. This is like, what is it? Culture is a remix. It's all a remix. Right. So if you're not remixing, you think that you're somehow like some genius? No. You have to get stuff from other people.
00:47:13.942 - 00:47:26.250, Speaker A: Of course. You remix it and you make new and it's more exciting and better and maybe you have some new ideas, but if you don't take stuff from others, then you're not going to get very far. I think you muted.
00:47:27.470 - 00:47:37.582, Speaker B: Whoops. Yes, I was muted. Yeah. The beauty of the open source world. Absolutely. So I want to be cognizant of your time, just because I know we have a hard stop for this. So I have two more questions.
00:47:37.582 - 00:48:00.534, Speaker B: So my first one is kind of almost like a wrap up e type question. It's really like, all right, so we have a few minutes left here. What are the things? So a lot of people watching this, they're going to be junior security researchers. They're going to be budding smart contract developers. And there's probably a whole bunch of people here who. Oh, my God, mate from the Ethereum foundation is here. I want to go see what he has to say.
00:48:00.534 - 00:48:15.660, Speaker B: What are some of the most important things you want people to know about Hevm or phone verification or really just anything in crypto? Is there anything in particular that you're like, you should know this, or you should try this or you should do this.
00:48:17.470 - 00:49:03.686, Speaker A: So this is more from my personal perspective as somebody who's worked a lot in IT security. So testing is a discipline. And I learned this when I was working at a company where I was in the test team because they didn't know where to put me as an IT security specialist. And I learned a lot from these people who were doing testing. And if you know how this works, then the way they build systems to test them is what's called a test pyramid. And the bottom is the unit test. And then there's the functional, like, there's module testing, then the intermodul testing, then there's the user acceptance testing.
00:49:03.686 - 00:49:38.790, Speaker A: At the very top, there's what's called like exploratory testing. And exploratory testing is when the person goes in and types stuff, right. And that's the most expensive, the slowest, the most error prone. Right. So you want to get all the other things done. Okay, my personal, let's say my recommendation for someone to do this kind of stuff is to read a little bit about the literature in testing. There's some very nice podcasts.
00:49:38.790 - 00:50:31.842, Speaker A: You can also read books. But I actually read a lot. I learned a lot from it, from podcast, where people talk about how they do this in a systematic, structured manner. And if you do it that way, of course you can do this kind of exploitative testing and flying around and find bugs all over the place, especially maybe not in crypto as much because there's more money on the table, so it's less likely. But if you're like in other parts, like just trying to hack some software or some web page or whatever, there's tons and tons of bugs you can find and you can do it this way. But the thing is that on the other side, when you are the person who's trying to defend, then the only way to bring any kind of sanity into this space is to have it structured. And that is to say, you have to have all these test cases written.
00:50:31.842 - 00:51:37.478, Speaker A: And if you find anything in an exploratory analysis, that is to say you mess around and you find something wrong, then that ought to become like a module test or integration test or unit test. It must be, because otherwise this going to plague you forever. It's not like it's going away. I see Hebm as part of this kind of like the sort of the icing on the cake, like something where you should have already written all these things. If you think you bring Hebm into the table and this is going to fix everything, or you bring certora into the mix and certify my thing, it's like, no, actually the most time you'll be spending on Sartora is describing what you want. If you talk to the Sartora people, the reason why they give you a consultant is because most people have trouble expressing what their contract is doing and what are the goals of the contract and what are the invariants? What are the things you actually want the contract to be at any different point of state. So that is kind of once you think that through, actually you might not even need certora.
00:51:37.478 - 00:52:07.794, Speaker A: Don't tell that Sir Tora, and don't tell that to developers of HVM because a good chunk of the work is actually you knowing what you want and what the system, its invariants are. What are the failure and what are the sort of the bad states, what are the good states? Sort of the positive test cases. Negative test cases. Like a lot of people, if you look at their code, they write a lot of positive test cases. So if you type in the correct password and the character username, then it lets you in. Well okay, that's a good test. But if I don't type in anything, it just lets me through.
00:52:07.794 - 00:52:28.006, Speaker A: That's a bit of a, like Apple has made these kind of mistakes. It's not like it was just empty username, empty password. You're in. I'm like, okay, so there was no negative test case. They didn't put any negative test case. Right? So you have to have these positive test cases, negative test cases and your invariance. And once you know, know, you might not even need Hevm.
00:52:28.006 - 00:53:48.638, Speaker A: Although of know what Hevm and Sartora and KevM and EBMC and all these kind of things do is that it sort of forces your hand to really think through these things. And without it, it's very difficult to come up with these positive, negative test cases and invariants. And so it's more like a tool to think through what you really want to do. And if you do that, then you're going to be in a good place in this pyramid because the pyramid sort of encodes a lot of these things. And HTTM is really just, or Sartora is really supposed to be just sort of like an exploratory test, like an expensive, complicated, slow test at the very top, just to find the last bit of the thing that is wrong. So that's my personal point of view, which is to say that it needs to be a structured approach with a test discipline, a testing discipline like applied to this problem that you're trying to solve, and then you'll do really well. And so Hebm is just a small part of the like, I think that's sort of the advice that I would give to someone who is new to this space.
00:53:48.638 - 00:54:35.086, Speaker A: If you start at Hebm, I don't think you might be in the wrong place. The right thing to do is add a lot of test cases and have a good description of what good mental model of what your contract is really supposed to do, what kind of state it's supposed to be in, what kind of state it's not supposed to be in, and what kind of responses you expect to certain kind of inputs. Of course, fuzzing helps with this, but it is also still just an exploratory test. At the top, you need to have the base. If you don't have this period built up, then you're like, your foundation is just going to crumble you. The fuzzer will just keep on finding bugs, and every time you run it, it's going to be another bug. It really is a discipline.
00:54:35.086 - 00:55:07.118, Speaker A: I know I've said this word more than once, but it is very important to look at it more as a problem that is whole and you sort of chunk away from it. And Hedm is one of the things that can take one piece out of this and help you a little bit, maybe the last mile sort of thing. That's what hem is supposed to. If you use HDM as the tool that's going to fix everything for you, well, that's not going to work. And it's the same case for unit test. Like if all unit tests is going to fix everything. No, you have to have a bunch of different tools that attacks this problem.
00:55:07.118 - 00:55:33.190, Speaker A: But in order to do that, you really need to have a good mental model of what you're attacking, because you need to, of course, put yourself in the shoes of an attacker. You need to understand what you're attacking. What are the kind of things you want this system to do and not to do? Like both to do, not to do. And also, if you're really in the symbolic execution in general, then also what state you want it to be in, what invariance you want the system to.
00:55:33.260 - 00:55:36.710, Speaker B: So we need to approach the testing process a lot more methodically.
00:55:38.170 - 00:56:04.142, Speaker A: It's fun to play around. It is a good idea to play around. I play around a lot, by the way. I really do play a lot, but it's one thing to play and it's another thing to switch. So I like switching from this play mode and messing around and whatever, and then go into the structure mode and like, okay, so this is what I've covered. What are the things I haven't covered? Do that sort of stuff, maybe play with that, cover it a little more, go back to the structure. So it's like you have to do both.
00:56:04.142 - 00:56:13.874, Speaker A: But if you only do one tool, the one thing that will help you do everything, I don't think that will help. So we have another billion and a half, like next year?
00:56:13.992 - 00:56:29.450, Speaker B: Definitely. I think this is probably some of the most valuable advice at the end here. So we have about 30 seconds left here before you have to jump off. Where can people find you and where can we stay posted with when all these amazing changes come to Hevm?
00:56:30.990 - 00:57:09.186, Speaker A: Well, you can definitely find me on GitHub and my email is there, so you can just contact me there and also write issues on Hevm. I'd love to have hear from people who have tried and maybe succeeded, maybe failed, maybe they have questions. It's not by any chance I said that I have over 600 issues fixed for my own personal tool. I do this all the time and if you have a look around, my response time is under 24 hours and usually under 15 minutes. At least an initial response is like, yeah, I got it. I understand what you're doing. Unless I'm asleep.
00:57:09.186 - 00:58:09.334, Speaker A: Okay, like if I'm asleep, not 15 minutes, but I try my very best to respond so people can feel like they can engage with me personally. That's just me. Of course, the team itself is larger than me, and if you have a look at their responses, they're always very happy to hear feedback and to fix any issues we have. It's not like we're going to fix it immediately, but what I can promise you is that we're not going to ignore it. I don't close issues with like, hey, I don't care or something like that. What I might say is that legitimately this is not something that we can do or not within a reasonable timeline, and then I will give you a reason for that and perhaps even suggest how you can go around this problem or maybe like another tool or another way of doing what you want to do. Of course I can't solve every issue, but if it's a legitimate issue that somebody has that they want to be solved, then I will try my very best.
00:58:09.334 - 00:58:15.030, Speaker A: And I think the team has tried their very best to address it. Whichever way we can address.
00:58:15.180 - 00:58:29.150, Speaker B: Definitely. Well, monte, we're actually 1 minute past where we're supposed to be, but thank you so much for being here. Really appreciate all the insights on HvM form of verification, everything that you're doing. Really appreciate you being on the stream here.
00:58:29.300 - 00:58:33.134, Speaker A: Yeah, thanks so much for having me. It was really a fun conversation. Thanks.
00:58:33.252 - 00:58:34.380, Speaker B: All right, great. Thank you all.
