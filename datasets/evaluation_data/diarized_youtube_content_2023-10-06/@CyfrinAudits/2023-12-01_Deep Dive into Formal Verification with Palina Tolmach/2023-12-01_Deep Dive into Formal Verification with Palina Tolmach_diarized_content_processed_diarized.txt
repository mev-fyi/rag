00:00:00.330 - 00:00:00.880, Speaker A: Thank.
00:00:02.930 - 00:00:32.374, Speaker B: Hello, everybody, and welcome back to another phenomenal interview this week and last week, it seems like we're. We've got a lot of focus on formal verification, and for good reason. Software in web3 is barely software. It is borderline hardware. If we mess these tools up, I don't know if you have noticed, but we lose a lot of money, and that's not a good thing. So with us today to talk about this, we have Paulina from runtime verification. Thank you so much for being here.
00:00:32.374 - 00:00:33.320, Speaker B: How are you?
00:00:34.090 - 00:00:39.606, Speaker A: Good, thanks. Thanks so much for having me here. Hey, Patrick. Hi, everyone. Yeah, super excited to be here.
00:00:39.708 - 00:00:59.760, Speaker B: Awesome. Well, I'm doing great. I'm doing better now that we're chatting. I'm also doing better now that I've looked at the control docs that seem like they got a big revamp and they're looking way easier to use than they used to look. But we can talk about that in a little bit. Paulina, why don't you tell us a little bit about yourself? Who are you? What are you doing? What are you working on?
00:01:00.290 - 00:01:27.814, Speaker A: Right, so, as Patrick said, I'm a formal verification engineer at runtime verification. I'm also a tech lead for the team developing control, which is our tool for symbolically testing smart contracts. Before that, I did my PhD in smart contract verification. I also did some work with Makerdao. So all in all, I guess I was just lucky to work on verifying smart contracts for the past around five years, I think. So I guess that's it. Is there anything else you would like to know about me?
00:01:27.852 - 00:01:51.386, Speaker B: No. Succinct. That's great. Yeah. And for those of you who are watching and listening, I came into contact, and we were talking a little bit about this before we started going live. I came into contact with your work because you had written an article on comparing a number of the different tools of formal verification. It was like HEV versus Hamos versus mithril versus a lot of these formal verification tools.
00:01:51.386 - 00:02:23.606, Speaker B: And for me, it was one of the first formal verification pieces of content that I'd written where it wasn't, ah, sorry, this is just too complicated. You'll never be smart enough to understand it. Go away. I felt like you were one of the first pieces of content that really broke it down. You were like, hey, we're going to take this really simple example, run it on these tools, and see how they work. And here's what it is. And I think the title of that one, I forget what the title of that one was, but then you made a follow up which the title, I do remember the title of that one, which was how to quit concrete testing.
00:02:23.606 - 00:02:32.460, Speaker B: I believe they were both phenomenal. How did those articles come about? How did those come to?
00:02:33.390 - 00:03:06.246, Speaker A: Right. Well, so as I said, I did some work with Makerdao. I was trying to see how we can apply some of the open source symbolic execution and verification tools in general to their contracts, adapt to their needs. The result is this blog post, from which I guess you can tell that it requires a bit of effort to make this tool work on some of the real world smart contracts. But yeah, I got a lot of support from Makerdao. I was working with the protocol engineering core unit there. I worked with Kurt Berry, who I think should get a lot of credit for these blog posts because he helped me a lot with them.
00:03:06.246 - 00:03:45.266, Speaker A: So at some point I guess we realized that trying out all these tools actually took a lot of time and I had to look into the internals of how this tool works to see why something fails, why something isn't working. We did some improvements to all of these tools. We just tweaked them a bit, adding some new features, debugging the issues. So we thought since we should get some result out of doing this, and since we really weren't able to fully make them super usable and applicable to the Makerdos contracts, at least we should probably write some educational material after that. So I'm glad you liked it and.
00:03:45.288 - 00:04:00.538, Speaker B: Found it came about. So you're working with Makerdao. They're like, hey, we want to trial this stuff. And you were like, great, I'm going to try all this stuff. It's kind of hard to actually add to maker, so let's at least tell people what we learned. Sounds like that's kind of the summary of it.
00:04:00.704 - 00:04:34.660, Speaker A: I guess that's an honest way to put it. In general, Makerdao and the engineering team take security very seriously, which I think is quite obvious. So even without me, they did some investigation into formally verifying things. I think they, at least while I was there, we're partnering with search war to do formal verification. They also have a very long term partnership with runtime verification that I'm currently working at. So yeah, I think that was just one other contribution to the security work that they do.
00:04:35.990 - 00:05:16.114, Speaker B: Definitely makes sense. And so for those of you who are unfamiliar with form of verification or a lot of the topics that we're talking about, definitely check out her blog on this. You can find it on her Twitter, on her hackmD, also on my YouTube as well. We've done a little bit of work on form of verification. And also in the security course part two, we're going to talk about formal verification even more. So if this is confusing to you, don't worry, there's a lot of content already out there, a lot more content coming because, yeah, at the end of the day, like we were saying, smart contracts are crazy fragile and we need high level testing to make sure that they're safe. And formal verification is one of the ways that we can do that.
00:05:16.114 - 00:05:40.410, Speaker B: Something in that I thought was really interesting in your article that you wrote, you said, how to quit concrete testing, and it almost like you were getting at like, hey, unit tests. Don't even bother doing unit tests anymore. It almost sounded like you were saying, hey, just go straight to formally verifying everything. Like, why bother doing unit tests? Is that the mentality that you hold? Is that kind of how you approach software?
00:05:40.990 - 00:05:53.930, Speaker A: No, of course not. It was meant to be a joke. I think the first post was called everything you want to know about symbolic testing or formal verification. I should know the title of this blog post, right?
00:05:54.000 - 00:05:56.302, Speaker B: I don't remember the title to my blog post. You're good.
00:05:56.436 - 00:06:14.866, Speaker A: Well, you didn't write it. That's kind of embarrassing. All right, but that was an illusion. Is that a word? So it's a paraphrase, title of some book, like a popular one. I have seen some papers being called the same way. It was just everything you wanted to know about something else. Yeah.
00:06:14.866 - 00:06:39.894, Speaker A: So it was just the title of the first one. And then for the second blog post, I thought, well, maybe I should name it after a book as well. And I think there is a book called Easy Way to quit smoking and a lot of other bad things. So concrete testing is definitely not one of them. Yeah, it was just supposed to be a joke. Of course I think that people should do testing. I honestly don't think that people should necessarily formally verify their smart contracts, though it would be highly beneficial.
00:06:39.894 - 00:07:05.060, Speaker A: But testing is definitely something everyone should do, and fading, for that matter. So I think I'm repeating what the trail of bets folks that you have interviewed have already said here. And yeah, honestly, I think that there is a very high return on investment for unit tests and fast tests. And then formal verification obviously requires more time and effort, but it also provides security guarantees that are hard to get anywhere else.
00:07:05.510 - 00:07:47.266, Speaker B: So that's really interesting to me. I've heard a couple people kind of go back and forth on this, actually. So I recently put out a poll on Twitter and I said, hey, for your smart contract security reviews, your audit engagements. I said, specifically for auditors, and we'll see who actually responded. But I said, how important is formal verification to you for a security review? And the poll showed that, hey, around 50% of people said, it's important, I'm going to do formal verification. I thought that was a little bit od, because I'm like, I feel like most of you don't really even know how to use the tools for formal verification, so maybe it was a weird virtue signal on an anonymous poll. I have no idea.
00:07:47.266 - 00:08:24.320, Speaker B: But then I went a step further and I said, okay, how many of you do formal verification on a competitive audit? Like something like Codehox, right? And the number went down to two or three or maybe 5%. And I was like, okay, that's kind of more what I was expecting that number to go much, much lower. So you're saying, hey, there is kind of this. It does take a lot more time and effort to do form verification, yet it's still super important. When should we be doing it? When do you think it needs to get involved? Is there a threshold where it's like we should just quit concrete testing and just formally verify everything? When do we need to cross that line?
00:08:25.330 - 00:09:17.790, Speaker A: Right. Well, I would say that the first few things that everyone should do before engaging in any formal verification sort of activity is making sure you have unit tests that have decent coverage and they're passing, and then you have fuzzing tests that are also passing. Because if these are failing, then you already found issues that you can fix, and you need formal verification to find some more intricate bugs. So I guess that is the good place to do it. And if you have these fuzzing tests in place, what I think is called property based tests in palm tree, which take parameters, then we can apply symbolic testing, which is symbolic execution that is restricted to the tests. And whatever happens within this test, that is something we do with control, that is something Helmas does. So that just offers a very easy way to start doing formal verification, because you already have this specification, you will be verified.
00:09:17.790 - 00:09:53.690, Speaker A: So we work with some companies and projects who we do formal verification, and generally it's very easy to engage with them if they have this test, with which of course, we can extend further, or we can rewrite the tests slightly to make sure that we are getting the most out of this formal verification that we are doing. So, yeah, I guess it should just be the next step after unit testing or static analysis. I guess that's something that Jocelyn mentioned yeah, using slither is definitely a very good thing you can do for yourself and for your code.
00:09:53.840 - 00:10:20.260, Speaker B: Yeah, it makes sense. So basically you're saying form of verification should get involved. But this is after you do all your prerequisites, a unit test. You got to do the static analysis. Why would you not run slither? You need to run fuzzer. And then the final piece of the pie is going to be formal verification. So I guess my question is, is it a cherry on top though, or is it an essential piece to baking the cake? If you'll humor my analogy here.
00:10:20.790 - 00:11:01.034, Speaker A: Well, I would say a very important one. Obviously we have projects that are doing fine without formal verification, and I hope they will keep doing fine. But there is a chance that the code has some bug that no one has identified up to a certain point. Right? And there is a chance that formal verification could have uncovered that. And it's relatively easy to do this exploit analysis in retrospect because you already know what the issue is. So you can write a specification that catches it. So that's also one of the challenges in using formal verification effectively and properly.
00:11:01.034 - 00:11:45.506, Speaker A: You also have to have the right and correct specification. You need to know what you are checking, otherwise you will not really verify anything meaningful, so it will not prove the absence of bugs. So yeah, I don't think that's strictly necessary for every project to be formally verified, but I personally see a lot of benefit in this and I would prefer if more smart contract code has been formally verified. But I feel the challenges of using it. And speaking about competitive audits and using formal verification, I haven't used it either. I would actually like to do this now. We have done a lot of work on control, on improvement, performance, on improvement, usability.
00:11:45.506 - 00:12:27.514, Speaker A: Thanks for noticing the docs. We did rewamp them, but at some point before I started at Makerdao, I think I decided to give some competitive audits a try. It was so easy then. I feel like they got so much more competitive and generally the level of expertise or maybe the projects that enter code arena now has become much higher. Maybe I was just lucky, but I earned like a couple of $1,000, which was just like crazy money compared to what that was like my monthly scholarship for my PhD. And I found some bug on my phone while I was brushing my teeth or something. So that was maybe I just got lucky, I don't know, but I felt like it was very easy.
00:12:27.514 - 00:13:05.766, Speaker A: But then I ran out of time, so that was it. But one thing that I did realize, which I think is more important than everything that I have mentioned is that even though I was developing this symbolic execution tools, it was still quite hard to very quickly, in this time span of this competitive audit, or the amount of time I had for it. Anyway, to adapt this tool to this code base to make it work, formulate the properties I want to check and then debug all these issues I ran into. I think the tooling has improved since then, significantly. That was a few years back. Control got better. Hevm got better that ethereum foundation is working on, and they also did some amazing progress on it.
00:13:05.766 - 00:13:20.330, Speaker A: Halmash, obviously is also another great tool that is very usable. So, yes, I think we got better, but I feel the pain of all these people who do not really, who would like to use it, but are not at the moment, especially in this time restricted setting.
00:13:20.990 - 00:13:28.960, Speaker B: Philly, we kind of brushed past that you were doing a competitive audit and you just were doing it on your phone and you found bugs just on your phone.
00:13:29.490 - 00:13:31.040, Speaker A: Yeah, but it was very obvious.
00:13:31.410 - 00:13:45.700, Speaker B: Okay, but you said you got paid thousands of dollars. I mean, if it was very obvious, a lot more people would have reported it. Right? So you're saying you found some fairly obvious bugs that paid out thousands of dollars just when you're brushing your teeth in the morning?
00:13:46.070 - 00:14:02.858, Speaker A: Well, there were other ones. So I think I found some other issues after that. I'm pretty sure I looked at the monitor, not just the phone, but yeah, as a matter of fact, I think there was a missing modifier or something like this. I can probably dig it up. I can find the report for this context. Maybe I should.
00:14:02.944 - 00:14:26.370, Speaker B: I'm like super curious. All right, this almost leads me to something even more interesting. Okay, so why are you spending your time doing building a formal verification tool when you could just be ripping through audits, finding bugs in your phone, brushing. You could have the TV on. Apparently you just find bugs ripping through your phone. Why are you working on formal verification? Why aren't you doing security reviews? Why is this where you've decided to go with your career?
00:14:27.430 - 00:14:58.582, Speaker A: Well, I value the work of auditors a lot, and we do some audits at runtime verification as well. And I think it's very important. And a lot of things really can only be done manually right now. We try to automate as much as formal verification. We do. We try to make it less invasive in a sense, but still, doing manual audits, thinking about the code is very important. Well, I have a formal verification background.
00:14:58.582 - 00:15:24.626, Speaker A: Right. That was my PhD was in it. I spent several years researching it. I like working on it because I know it's important. It's not more important than what auditors do, I guess, but it's just something that I have some background in, and I built up some expertise over the past couple of years. So I would rather spend my time bringing it to some stage where everyone, or at least most people, would be able to use it.
00:15:24.728 - 00:15:47.690, Speaker B: That's so interesting. So you're saying you think smart contracts here, to your viewers or auditors, you think their work is more important. So here's where my brain goes at heart. I'm an engineer, so I go, okay, humans suck. Humans are going to screw things up. Anything that you leave to human, manual, something, there's a chance that breaks down. You can't productionize.
00:15:47.690 - 00:16:13.330, Speaker B: You have to productionize humans, but you want to minimize that as much as you can. So in my mind, I'm like, okay, first priority should be making tools as good as possible, as effective as possible. But what you just said, you're saying, hey, I think that what the security researchers do is more important. That's really interesting. As somebody who works on it, you're saying the manual review part is more important than the formal verification part. Am I understanding that correctly?
00:16:13.750 - 00:16:45.040, Speaker A: Right. Well, okay. I'm not sure what to say that it is more important. Well, I would say this probably equally important, at least right now. Right? As you said, all these polls show that not everyone is able to use formal verification. So where does it leave us if we don't have security auditors? They do a very important task and have bear a lot of responsibility for this. I guess it would be good if we could assist them, but it's still good that we have them, I guess.
00:16:45.040 - 00:17:22.166, Speaker A: I'm also an engineer at heart, as you said, and I do think that crypto, as an industry, I say that a lot, but you can say a lot of things about crypto and its, well, the way it looks to people outside of the industry with all the scam and all other issues that occur. But it also fuels a lot of research and formal verification. So it's a good place to be in if you wanted a formal verification. And I personally would just like to use this opportunity to make formal verification more usable in general and not just specifically to smart contracts.
00:17:22.358 - 00:17:35.406, Speaker B: Oh, interesting. So you were just like, formal verification is awesome. Hey, you crypto suckers, you're bankrolling form of verification. Great. Keep doing that. Love doing that. So how did you get to formal verification? How was this the path that you.
00:17:35.428 - 00:18:09.842, Speaker A: Took that was just luck, to be honest, I don't have a very inspiring story of how I wanted to work in formal verification my whole life. I ended up in Singapore for an internship because my friend recommended me to go here and recommended me to his supervisor. And I thought, well, that's like a good opportunity, I should do this. And then I met my advisor. Then I met my other future advisor who I was working on some blockchain things. I was working on private blockchains, as a matter of fact, so it wasn't super exciting, but it looked like something that can get funding. It was relatively exciting.
00:18:09.842 - 00:18:31.486, Speaker A: I thought it's a good field to do my research in. And then, yeah, I got introduced to my future advisor and he said, we are doing verification. And this new smart contract blockchain thing is super hot. Everyone figured out that there are a lot of money locked there and it's actually a very safety critical application. So that's something we can apply for malarification too. Yeah. And he was just wondering if that's something I would be interested in.
00:18:31.486 - 00:18:44.340, Speaker A: And I said, well, yes, I guess that would be nice. So I owe a lot to him. That I guess was just pure luck for the most part. I could have funded up doing research in some other fields, but I'm not sure if I would still do this in this case.
00:18:44.950 - 00:19:03.110, Speaker B: I feel like that's kind of a similar story to a lot of formal verification experts. It's just kind of landed on their desk. They went, wow, this looks really cool. Got nerd sniped. And now that nerd Snipe is their career, which I think is great because it helps web3, because I'm on the other side. To me, I'm like, okay, I love web3. I love crypto.
00:19:03.110 - 00:19:14.518, Speaker B: Anything that helps web3, I'm about. I like, great form of verification. Helps web3. Awesome. Let's go be formal verification pros. Let's go talk about form of verification. So really interesting how you got here.
00:19:14.518 - 00:19:47.750, Speaker B: So now, though, we talked a little bit. You're working at runtime verification. You're working on a lot of the tooling there. What are some of the main things that you work on at runtime verification? Is it control? Is it doing some of these formal reports in the security course that we actually just released? One of my favorite things was we go over the uniswap V one auto report by runtime verification where they go over the X times y equals K. Sorry, that has nothing to do with the question. Just like a quick complete side tangent. Anyways, what are the main things you're working on at runtime verification.
00:19:48.670 - 00:19:59.898, Speaker A: Right. By the way, congrats on launching the course. I'm very excited about one of, actually, I think I applied for an access code yesterday or something like this.
00:20:00.064 - 00:20:14.110, Speaker B: Yeah. Excellent. We're going to slow roll them out. And then part two, well, I'm supposed to feel like, all right, part two you're going to have already all the knowledge for. Because part two is where form of verification comes out. You might be too pro already now. Just kidding.
00:20:14.110 - 00:20:16.720, Speaker B: There'll be some good stuff in there.
00:20:17.030 - 00:20:51.070, Speaker A: Yeah, I'm sure there are. Even if this one is something that I know which necessarily is true. Yeah, I'm very excited about everything else, so. Yeah, converts on that and in control. So I'm mostly working on the engineering part. We have the development team, but also it consists of several engineers who work on improving control and or engagements that we have with different companies for projects who come to us asking for a formal verification audit. So I'm just mostly trying to synchronize all the work that is being done on this.
00:20:51.070 - 00:21:16.040, Speaker A: So either I do some planning, I do development work, and whenever someone has any issues in their engagement or just in general with whatever they are doing, either me or someone else from the team should step up and we figure out what is their issue and see if we should fix it. So, yeah, it's just all this work centered around the tool that we have and its application in some commercial setting that we have.
00:21:17.290 - 00:22:06.580, Speaker B: Gotcha. Okay, very cool. So control, it's a tool that used to be kevm. Right? So why the rebrand of the tool? Because I remember jumping into one of the telegrams, one of the discords of runtime verification, and this must have been like six months to a year ago, just asking a flood of questions, being like, what is KVM? Why does it feel different from Hamos? And now it's been re rented to control, and it feels like it's the same tool, but just way more specific, I guess. Right? I feel like I can just take it and kind of, okay, now I can kind of do this stuff that I originally wanted to do, just take control and stick it on my smart contracts. Why the rebrand, if, you know?
00:22:07.830 - 00:22:36.286, Speaker A: I think I do, but honestly, I think I'm the newest addition to the control team. I've been with runtime verification for, I guess, half a year. So maybe you would have benefited from someone more experienced in terms of working at runtime verification. But since you got me, yeah, I read this discussion in the discord in our discord channel. It was in April. I reread it yesterday, preparing for this conversation. So KVM technically is still there.
00:22:36.286 - 00:23:33.442, Speaker A: So KVM is the definition or implementation of EVM semantics in key. And that is something that we use in order to reason about the contract. So whenever we encounter opcodes during the execution, we need to know how to interpret them. So that's what we use the semantics for, and it's still there. Control previously was called KVM Foundry, but I guess one of the reasons for rebrand is that its name was just too long and it was unclear what is the symbol between KVM Foundry? Is it KVM foundry or ant foundry or something else foundry? So I guess everyone was uncertain about how to write it correctly, including me. I personally think that it probably control just sounds a bit better and is more straightforward and it also kind of illustrates what it gives you. So it does give you the control over the security and things like this.
00:23:33.442 - 00:24:00.118, Speaker A: And plus also there are some advantages of using control over, I guess, other tools, and it generally is easier, I think, to instruct it how to perform the execution and reasoning even if the prover has been stuck. Okay, that's probably too specific, but yeah, I mean, it gives you some control and it also sounds better and it's shorter. I guess that's the main reason.
00:24:00.284 - 00:24:27.458, Speaker B: Maybe it's not too specific. So from my experience, and then for those listening, just a quick background, I guess. So when you go to part two of the security course, a lot of these tools are going to be in there. By the way, hint, hint. Halmos is one where I feel like I can pretty much stick hamos onto one of my fuzz tests and it'll more or less work. Sartora. I will have to rewrite the spec in the, I forget what the language for Sirtora is.
00:24:27.458 - 00:24:41.080, Speaker B: I'll run the language in their spec. Run it. Be good to go there. Control, what's the ease of use? I guess. How would you describe the developer experience? The difference there.
00:24:42.650 - 00:25:33.250, Speaker A: Right. So first of all, it is being applied in the same way as Hamish in certain sense. So if you have your test, which is foundries for the same test, then you can just run control on top of it and it should work. So it is being applied in the similar way. There are some differences in how they perform the verification, but one feature that I like a lot in control is that you can supply some additional lemmas or axioms. So if you look at the execution and you see that it's getting stuck or it takes a lot of time to process some particular stuff or just some smart contract takes a very long time to get verified and you don't see the result yet. The first thing you could do is you could visualize its execution.
00:25:33.250 - 00:25:53.760, Speaker A: So we have artifacts produced by the execution that is called KCFG. So it's K control flow graph. And it's basically some nodes that we encounter during the execution that we are writing to disk. So then you can open an interactive viewer and then you can look at all these nodes that were identified so you can visualize the execution. That's one thing.
00:25:55.810 - 00:26:31.420, Speaker B: In my mind. Again, for those of you who are unfamiliar with formal verification, the idea is like you are exploring paths mathematically. And what you're saying is one of these exploring paths of where the system, where the process can go. And what you're saying is with control, it actually keeps notes of those nodes, those positions, those branches, and it writes them to disk. And you're saying I can use some tool, open it up and visualize the paths that it's taken. That's pretty freaking cool. Yeah, sorry, keep going.
00:26:32.110 - 00:27:00.530, Speaker A: Right. Thank you. So it's going to show you the nodes and where it branched, what is the condition it has branched on, and also the configuration. So configuration is a key term that we use, but basically it's a lot of fields that contain information. So it contains the configuration for this environment. And the smart contracts you are running, what is the code of the contract you're running, what's the state of storage, what is the call data, what is the output, things like this. So the first thing you could do is look at this and visualize it.
00:27:00.530 - 00:27:32.718, Speaker A: One other thing we are working on is symbolic debugger. So that is the tool that is going to also do symbolic execution. But you could also debug this based on the solidity statements because we realize we do a lot of reading of all these instructions and opcode ourselves whenever we want to figure out if something had happened. So we thought probably everyone would benefit from having a better debugger on the solidity level. So that's something my colleague roll is working on, which I think is going to be released sometime soon. It's under the documentation under the name symbolic. I think it has been added there.
00:27:32.718 - 00:27:35.310, Speaker A: But anyway, sorry. So go ahead.
00:27:35.380 - 00:27:36.990, Speaker B: I was just going to say exciting.
00:27:37.970 - 00:28:13.050, Speaker A: Okay, thanks. Yeah, I think so too. I've seen it and it looks very useful. But yeah, so you can look at the key CFG and if something doesn't look right, for example, you see that we are collecting constraints, right, when we do the execution, because whenever some branching happens, we need to keep track of why that happens. So there is a statement saying X is less than ten, and that's a conditional statement. So if we choose the true branch, then we are going to add this to the set of constraints. If we're choosing the other branch, then we'll add the negation of that to the set of constraints, right.
00:28:13.050 - 00:29:12.410, Speaker A: I hope that makes sense. So for example, if you look at these constraints and you see that they got somewhat big, and it looks like they should be simplified, but they aren't getting simplified, then what you can do is you can provide some assistance to the tool in a somewhat interactive manner. So you can write some sort of axiom or a theorem or a rule, basically that will just say that whenever you see something like this, it should get rewritten to this different, simpler expression. And in a lot of cases that helps overcome this issue that the proverb is having and just finish the execution. There are a lot of things in smart contracts that are relatively challenging to analyze. There are a lot of these huge unsight integers, which in SMT representation are often. So there is no in most SMT solvers, which is this piece of software that is used under the hood of all these symbolic execution tools, or most of the symbolic execution tools at least, to do some certifiability checking.
00:29:12.410 - 00:29:51.534, Speaker A: Well, it helps us figure out if something is reachable or satisfiable. So a lot of these SMT solvers, they don't really have the direct mapping between solidity types and their internal types. So there are some tweaks around the support of unsaid integers, for example. But if you can represent them as large bit vectors, that's one way to do this. But it also brings some performance issues, and hashing is different, difficult to reason about. So there are a lot of things that are challenging, and occasionally the tool gets stuck. And if you have a way to help it, that actually helps get results which otherwise are very hard to obtain.
00:29:51.682 - 00:30:26.862, Speaker B: I appreciate how you kept stopping yourself, introducing a new concept. Then you're like oh wait, smt solver. Okay, maybe they don't know what that is, so satisfiability, oh wait, maybe they don't know what that is. I greatly appreciate that because, yeah, a lot of the people probably listening are not going to be super familiar with a lot of these terms because this is new to a lot of people in this industry. But so what? It sounds like you're telling me, and then correct me if I'm wrong. So if I have a solidity function and I have a conditional that says if X equals seven, go down this path. If X equals eight do this crazy nonsense.
00:30:26.862 - 00:30:41.500, Speaker B: And that's going to cause the form of verification to stall is what you're telling me. I can put some axiom or some configuration where I say hey, skip that crazy path that's going to take forever to go down. Is that what you're saying?
00:30:41.950 - 00:31:34.726, Speaker A: That's one way to do this, this particular example, it might hurt completeness, right? So if we don't execute one of the paths, then we don't have the results for it, but at least we get results for everything else. So I guess there's still some benefit in doing this. And you can also just provide some rules according to which this crazy condition that you have is going to be simplified if you can come up with the way to do this. Okay, one other example for this that I think I have is loop invariance. So we have some of these examples in the tutorial repository that I think we are either referencing in the documentation or should be referencing in the documentation. But one thing that you can get in smart contracts is loops, right? Loops are complicated for symbolic execution because potentially every loop iteration is a new branch. So if you don't know when you are supposed to stop, then it's unclear how many branches you should be exploring.
00:31:34.726 - 00:31:55.090, Speaker A: So a very common approach to do this is bounded verification. We do that as well. It's one of the things we do. So you can just provide a boundary. You can say we bound all loops at three. We do not execute anything beyond this third iteration. We just assume that's where the loop ends.
00:31:55.090 - 00:32:33.434, Speaker A: That helps us somehow deal with this problem. Otherwise we would never potentially be able to stop this execution. But, well, the downside is obvious, right? We don't execute all possible paths, we just execute a lot of them. Some of them what we can do with control and k in general is unbounded verification. And we allow the user to provide a loop invariant. So when we have a loop that does something right, for example, we have a loop that iterates some symbolic amount of time. So we don't know how many times depends on the input or just 5000 times, it's going to take a long time to execute it 5000 times.
00:32:33.434 - 00:33:14.410, Speaker A: What we can do instead is if in the loop we are adding one to some variable, we can just write a rule that says when we exit this loop we have incremented this variable 500 times, or however, whatever is the number of times that user had provided. So instead of actually executing it, we are skipping the loop and we just apply this side effect to the state that we know is going to happen. That's something we can do with control as well. We have this in our examples and with this, the execution finishes well. Otherwise I think it takes some enormous amount of time and memory and also the result is found because that is indeed what is happening within the loop.
00:33:15.070 - 00:34:05.686, Speaker B: So you're almost like, I don't want to say tricking it. So if you're going to do 5000 loops and you're going to be adding one, you're just going to say, okay, x is one times 5000, or, excuse me, it's going to be one times number of loops. And now I don't have 5000 different branches, it's just a mathematical equation. The noob form of verification in me goes, oh, well, why don't we just do that for everything? Why does it need to be a new branch for every single time we do a loop? Why can't we just. Because to me that's almost like what symbolic execution and form verification is. It is mathematizing your functions. So why don't we just mathematize? I know that's a non term.
00:34:05.686 - 00:34:09.930, Speaker B: I know that doesn't make sense. Why don't we just mathematize every statement in a loop?
00:34:10.990 - 00:34:29.154, Speaker A: It's not always extremely obvious what you can encapsulate it into, I think, if that makes sense. So it's not always clear what is the formula according to which the update is performed, I guess. And that's a problem with looping variance, like the potential problem, you should be able to specify one.
00:34:29.272 - 00:34:46.360, Speaker B: Yeah, no, that makes a lot of sense to me. So for these addition ones, right? So that one's pretty simple, right? If we're just adding one. Cool. That's no problem. Do I have to write something with control to have it skip that? Or does it automatically see that and go boom, I'm going to skip it. How does it know?
00:34:46.970 - 00:35:14.190, Speaker A: Oh, yes, thanks. I wanted to get into this. So at the moment, all these rules and llamas that are supplementary and help do this, they should be specified in a separate file that is defined using case index. So the challenge right now is that you should know case index. There are some tutorials, there are ways to do this. We can always help people in discord write it down. But yeah, you should be familiar with case index and with some specifics.
00:35:14.190 - 00:36:03.326, Speaker A: So this rule is so called matching rule, I think so what it does whenever it sees certain states that we want to apply to. It just automatically rewrites this configuration. So for example, we have something on the stack, right? That's basically the return result of the loop. We have something on the stack and then we see that if we encounter this jump I instruction, like a conditional jump with this path condition, which we know is the entry to this for loop the path condition. Sorry, program counter. So if you are at the specific program counter where we know we are entering the loop, then move to the other program counter after the loop, update the stack. So what I'm saying, I guess you.
00:36:03.348 - 00:36:05.890, Speaker B: Lost it there a little bit, I'm going to be honest. Sorry.
00:36:05.960 - 00:36:28.810, Speaker A: Right, sorry. Okay, so we have the configuration, right. When we execute this smart contract, we know we are in a certain state, we have certain values on the stack. That is something we return from the loop. And we also have the program counter. We know where we are and we can write a loop that's, sorry. We can write a rule that says that if we are at this program counter, we know that's where we enter the loop and perform all these checks.
00:36:28.810 - 00:36:46.350, Speaker A: Rewrite this program counter to the program counter that points to the point after the loop and update the stack with this five southern times incremented variable. So it's just going to change this configuration so that we end up at a different place in the execution.
00:36:46.690 - 00:37:09.510, Speaker B: Got you. Okay, interesting. And this is that case syntax. If you learn how to write this case syntax, you basically write a statement in this configuration that says, hey, at program counter X, skip to this new program counter. And it feels like this is almost again like a programming language of a programming language. Like a programming language for formal verification.
00:37:10.650 - 00:37:46.820, Speaker A: Yeah, exactly. But ideally we want to avoid people doing this as well. And we have some plans in an item in our backlog on improving this. So ideally we want to be able to give everyone the ability to write this loop invariance in solidity. It's in the works yet right now, but technically we should be able to do this because we do some rewriting, some automated rewriting between solidity and key. So we do this solidity to key conversion, and in the same fashion, we can just do the same thing with rules. We just haven't got to the flame yet.
00:37:47.590 - 00:38:19.180, Speaker B: But it sounds like it's on the to do list, which is great. Yeah, it is very interesting. I'm more excited to play with control the more we talk. I'm like, oh, these all sound really cool, actually. There's like eight different directions I want to go here so what's your favorite part of control? What's your favorite feature of control? What's your favorite technique of control? What's the coolest story you have? Control. I'm just looking for what's the coolest thing that's going on with control or that you've done with control.
00:38:20.770 - 00:39:21.242, Speaker A: Right. Well, I'm mostly working on the internal parts of control, so I'm sure people who work on engagements and do verification things probably have stories about how they identified some crazy bug with control. I do appreciate this ability to add these rules that facilitate the exploration. And one other thing that I really appreciate is whenever I try control on some different contracts, for example, the contracts that we have been fuzzing before, we have the product called ERCX, which performs fuzzing of ERC 20 and ERC for six to six, I guess. So different tokens, and we have the library of tests for them. So we did an experiment where we tried to execute the same tests with foundry and with control, or slightly updated tests for a symbolic execution. And I kept getting reverting statements, reverting notes and executions in some of these tokens and some smart contracts.
00:39:21.242 - 00:40:06.490, Speaker A: And at first I always distrust the tool. I always think that I eyeballed this code so I know it should work and it shouldn't revert, but in the end every time it ends up being correct. So there might be issues there though. But in this particular cases we always figure out that there is possible overflow. There are some compiler inserted checks that are failing that might be failing, and that's actually correct. You just don't see it because you don't look at the assembly, you look at the solidity high level code, or it's possible for the token to be paused. But if you execute this in the concrete setting, then if you never explicitly pause the contract, then it's not going to be paused and you will not catch it with your fuzzing tests or concrete tests you're executing.
00:40:06.490 - 00:40:38.746, Speaker A: If you're running it symbolically, and if you assume we have a feature that is called symbolic storage, I think most of the symbolic execution tools have it too. So we can just assume that all storage values for the contract are symbolic, which means that some, if post flag is also going to be symbolic, and if it's theoretically possible that this function is going to be called, then it actually might be the issue. It's just not something we can catch with concrete tests unless we think about it carefully. So I hope that does illustrate some of the benefits of using it.
00:40:38.848 - 00:41:03.534, Speaker B: No that definitely does. And that's really cool. That's the first thing that I always do whenever I run a tool. I'm like, my tool is broken, the code is probably fine. I probably messed up the tool. And that's why I think actually the usability of tools is so important because otherwise, if it's really difficult to use a tool, you're just always going to assume your tool is wrong. That's one of the tricky things right now.
00:41:03.534 - 00:41:46.880, Speaker B: I feel like with running like stateless or, excuse me, stateful fuzzing tests. If I'm running a stateful fuzzing test suite on a defi application, I got to do so many weird assumes conditionals, okay? Assume this person approved the contract and they have tokens and they're an LP or they're this or the other thing. And anytime I fail a stateful fuzz run, I'm like, okay, well, I clearly wrote the test wrong, but it's that one time when, no, you did it right. And it's actually an issue that you go, oh my God, I just found something insane. So, no, that's very helpful. I'm very excited to play with control. I'm excited to add control to part two of the security course coming out.
00:41:46.880 - 00:42:11.910, Speaker B: Actually no alpha because I don't know when I'm going to have time to finish it, but. Cool. So runtime verification. Excuse me, runtime verification planning. You guys are working on a lot of really cool stuff over there. What's the primary function of runtime verification? Is it to mainly do these formal verification audits or these formal verification specs? To write formal verification for some of their clients?
00:42:13.050 - 00:42:30.974, Speaker A: Right. So I think at the moment we have non blockchain teams as well. I'm not very involved in what they do. I know we have some C projects. Runtime verification has existed for, I guess, over ten years. So I'm not sure if I'm exactly in the right position to discuss to describe that. Fair enough.
00:42:30.974 - 00:42:56.870, Speaker A: Sorry, but no. I still have something to say, so that's fine. But as for blockchain, I think the blockchain department is quite big. So there. We do work with several ecosystems. So we have been working with, I think, algorand. We have some rust projects not directly related to blockchain, but still we've been working with Polkadot.
00:42:56.870 - 00:43:35.730, Speaker A: One of my colleagues recently released some implementation, some tooling for orbit. That's the benefit of using keyframework. If I can show key framework a bit. That's the upside of having this foundation, a formal foundation on which we can build different semantics. So we don't only work with idiom semantics, we can also define semantics for other platforms, and then we can build tooling around it, which is easier than to do this every time and write a very platform specific tool every time. So that's the obvious upside. The downside is it's very general.
00:43:35.730 - 00:44:14.750, Speaker A: So sometimes we have to deal with this issues stemming from the generality of the tool. But still, I guess the upside is still more important here, probably in terms of blockchain and ethereum in particular. We have traditional audits, which are manual audits. We have design reviews. So I believe that traditional audits mostly consist of two parts. So we do this high level design review, not necessarily high level, but we look into the modeling part and whether there are any issues with the design architecture. And then we do the actual code level analysis, like normal security audit.
00:44:14.750 - 00:44:46.998, Speaker A: We have this design review part as well. And we also do formal verification engagements where we are taking the code and formally verifying it with control. That is, I guess, in a lot of cases is based on tests. So since control works with foundry style tests, we are either using the ones that I think we're doing those like we're using the ones that protocol has, and we also writing some additional ones to see if we can prove more. Does it make sense?
00:44:47.164 - 00:45:25.700, Speaker B: Makes sense, no? Sounds great. So we have, looks like a little bit less than 50 minutes left here. I have a couple more questions. One of the big questions that I have that a lot of people ask, different tooling in the space, why open source? And then maybe this is another one, an unfair question, because you've only been in the company for about half a year. Maybe if you're not sure the answer to that question, we could just say, hey, why open source tools in general? But yeah, there are some closed sourced form verification tools, there's some closed sourced fuzzers, right? There's some closed source unit tests. Why make the choice for open source here?
00:45:26.790 - 00:46:22.790, Speaker A: Well, yeah, as you said, I'm not entirely sure what the answer to that is. Based on what I know, I can say that, well, almost everything is open source, right? Gay framework itself is open source, and it's based on the academic work that Gregorio Rochu, the CEO of Frontend verification, and a lot of people coming from his lab, so they're academics, right? So I think that's probably one of the things that they brought to the company, is this culture of being open and transparent and things being reproducible and accessible and so on. As to why control is open source. Well, EVM semantics is open source too. My cynical view is that I don't think that with most of the tools. So from the user perspective, I think a lot of users still need support even when they use our formal verification tooling. Right? So I don't think it would strip us from our job having this tool open source.
00:46:22.790 - 00:46:42.266, Speaker A: And I don't know if it could improve the security standard. If smart contracts could become more secure with our help and our expanse of the tool being open source. I guess that's still fair. That's probably the opinion that everyone else in the company has. But yeah, maybe I would recommend you to check with them.
00:46:42.448 - 00:47:08.194, Speaker B: Maybe I can ask them about, sorry, everyone listening. She does not speak for runtime verification. She's just given her thoughts. I'm covering you. I got you, don't worry. So let me ask a question just for you then, just for Paulina, where would you like to see the future of the blockchain space go? As far as this technology? Your, if you have one, what is your vision for where this space goes, right?
00:47:08.232 - 00:47:09.842, Speaker A: Oh, you mean blockchain space in general?
00:47:09.976 - 00:47:24.700, Speaker B: Well, blockchain space, form of verification. You know what, either one, both of them. Maybe it's two visions. Maybe you're like, hey, honestly, I don't give a shit about blockchain, just like form of verification to the moon. What's your vision? What do you wish to see next?
00:47:25.470 - 00:48:09.634, Speaker A: Right, yeah, I guess I'm very pragmatic in that sense. I'm not entirely sure that I have a very complete vision of where the blockchain space should go. I would like to see financial instruments being more accessible. That's my personal wish. I do have some vendetta with the traditional financial system, but as to formal verification, yeah, I guess we should just make it work better. If formal verification tools could be more usable and accessible, and they wouldn't require that much time to set it up, or they wouldn't require that much expertise to be able to set it up quickly and make it work, then I guess we would be good. I guess we've made a lot of progress on that, as in runtime verification and a lot of other teams working on their tools.
00:48:09.634 - 00:48:33.630, Speaker A: I think that what we can do now and what other tools and other companies providing formal verification services can do in 2023 is a very big step forward compared to what it was several years ago. So I would just probably like to see it, I don't know, brought to the point where you could. Most of the projects can do formal verification audits and it wouldn't be a hassle.
00:48:35.730 - 00:48:48.840, Speaker B: Makes a lot of sense to me. Yeah, that sounds like a future. I can get every. All right, so you heard it here first. Paulina says every single project at some point should be able to do form of verification without a hassle. Right? Yes, that's what we're saying.
00:48:49.210 - 00:48:50.630, Speaker A: Yeah. Thank you, Patrick.
00:48:51.770 - 00:49:02.860, Speaker B: I'm about it. Cool. Well, yeah, so I don't have any other questions. Is there anything else that you want to talk on? You want to talk about anything else cool. That you're working on?
00:49:03.630 - 00:50:01.562, Speaker A: Well, let me think about what I'm personally working on, but I have to say that with all of this we have said about people struggling with using formal verification and our approach, sorry, like our attempt to improve their experience, I have to say that formal verification is the fact that formal verification is widely known among developers, including the ones that have answered to your poll, totally 50% knew that formal verification exists. I think that's already better than the statistics from most of the industries. The fact that people know what is formal verification, and a lot of developers have tried fuzzing, I think is probably unheard of in my non very expert view in general software. So it's a very security aware crowd and I think it's great. I appreciate it a lot. There is a lot of security related content and thanks to you, Patrick as well, everybody.
00:50:01.616 - 00:50:04.270, Speaker B: A lot of people making yourself included.
00:50:05.170 - 00:50:37.286, Speaker A: Well, mine is a bit too specific, I guess. So a lot of people create kind of security. There are a lot of discussions around it. Everyone is aware that you should write secure, smart contracts, like think about what you do and try to make sure that it's bug free. And that probably is a side effect of all these smart contract exploits being, well, detrimental. But still. Yeah, so I guess overall it's a very good field to work in.
00:50:37.286 - 00:50:44.920, Speaker A: And formal verification, it's a very thankful, so to say, field to apply formal verification to.
00:50:45.630 - 00:51:00.720, Speaker B: Definitely, we definitely thank you for the work that you're doing and we're looking forward to all the new cool stuff that control has to offer and all the new cool features that you and runtime verification are building. So thank you for your work. Looking forward to all the cool stuff that you're so.
00:51:01.170 - 00:51:02.522, Speaker A: Thank you so much, Patrick.
00:51:02.666 - 00:51:22.066, Speaker B: And additionally, thank you for being here. Thank you for chatting. Thank you for talking about form of verification, about control, how you got into this industry, and kind of your view of what you see, what you like about form verification in the blockchain world. So thank you so much for being here. Really appreciate it. Paulina, where can people find you on Twitter?
00:51:22.178 - 00:51:34.742, Speaker A: I'm Paulina Tomach there, and we also have runtime verification discord where. Yeah. If you have any questions, please feel free to leave them there anytime. We'll try to help you as soon as possible.
00:51:34.876 - 00:51:54.480, Speaker B: I jumped to that discord maybe six months to a year ago. I did drop a lot of questions, and they were answered. The runtime verification community is verifiably phenomenal. So that's just my thumbs up there. So thank you so much again, and good luck with the next features you're building.
00:51:55.010 - 00:52:02.640, Speaker A: Thank you so much. Yeah, thanks a lot. I had a great time being here. And good luck with your course as well. Congrats once again on revisiting it and everything else you're working on.
00:52:03.010 - 00:52:03.420, Speaker B: Thank you.
