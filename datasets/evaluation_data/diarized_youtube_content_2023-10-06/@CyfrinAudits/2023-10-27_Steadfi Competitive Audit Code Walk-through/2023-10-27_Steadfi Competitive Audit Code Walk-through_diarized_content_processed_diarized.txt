00:00:01.130 - 00:00:02.202, Speaker A: Hey, everyone, I'm Jeff.
00:00:02.266 - 00:00:03.726, Speaker B: I'm the co founder and project lead.
00:00:03.748 - 00:00:12.846, Speaker A: Of Steadyfi, and I'm really excited to be running this public audit of the Steadyfi contracts with Codehox. So in this video, I hope to.
00:00:12.948 - 00:00:15.582, Speaker B: Explain a little bit more about what.
00:00:15.716 - 00:01:09.170, Speaker A: Steadyfi is trying to do. Talk a little bit about our high level architecture of the protocol, and to also go a little bit more in depth into the architecture of the strategy vault protocol, which forms the bulk of this public audit. So note that all the materials that I am going to use in this video is in the same statefi codehox code repository that you will have access to. So you can refer to them anytime that you want as well. If there's any questions that I am not able to answer, please feel free to ask me in the code pox discord channel, and I'll do my best to answer. So, first up, we have $35,000 in this public audit price pool. But as you can see, we are allocating most of the price pool to high and medium findings because we think that's more crucial.
00:01:09.170 - 00:01:58.302, Speaker A: And essentially, any findings that you can find that can result in a potential loss of funds to users, that's very important to us. So we hope that you can spend your attention into trying to find such issues. Okay, so what is Steadyfi? So, SteadyFi is a leverage hue protocol that creates leverage hue strategy vaults with automated risk management that allow users to earn yield effectively and passively in any market conditions. Bull crap or bear. So, a leverage hue strategy, as an example, works like this. If a user were to put in $1 into a tree x leverage strategy vault, that strategy vault needs to borrow.
00:01:58.366 - 00:02:00.626, Speaker B: Two more dollars of debt for a.
00:02:00.648 - 00:03:04.034, Speaker A: Total of $3 of assets. So $3 of final asset based on the $1 deposit. Therefore, it's a three x leverage strategy. For steady five, we could have strategy vaults with different type of leverage factors, but the more common ones would be three x leverage and probably five x leverage. If you are a DFI user, you might also be familiar with other leverage you protocols such as alpha Homora, alpaca finance, and so on. So how steadyFi differentiates from most of these leverage u protocols are that instead of allowing users to pick and select their own leverage factor, and therefore, then the users having to also monitor their own positions to prevent their positions from getting liquidated, steadyfi instead takes the position of creating different strategy vaults that works better for different market conditions. And users can deposit their assets into these strategy vaults.
00:03:04.034 - 00:03:09.962, Speaker A: And then we run keepers that will constantly monitor these different strategy vaults and.
00:03:10.016 - 00:03:12.602, Speaker B: Perform rebalances if needed.
00:03:12.736 - 00:03:27.326, Speaker A: Another difference that steadyfi vaults have is that it has different delta strategies. Namely there is a delta long strategy as well as a delta neutral strategy. Instead of explaining over this video what the differences between a long and a.
00:03:27.348 - 00:03:29.694, Speaker B: Neutral strategy is, I've written it down.
00:03:29.732 - 00:03:50.402, Speaker A: Here in the technical documentation file so you can look at an example. But at a high level, if you believe that the market is going to be going upwards, then you would want to deposit into a delta long strategy. But if you believe that the market is going to go more sideways or potentially even a little bit more bearish.
00:03:50.466 - 00:03:52.086, Speaker B: In the short run, you want to.
00:03:52.108 - 00:05:05.360, Speaker A: Deposit into the delta neutral strategy. Before I go into the high level architectural overview of the Statefi protocol, I just want to also highlight that the very first protocol that we are creating leverage use strategies into is GMX version two. And GMX version two currently is deployed on the arbitrum as well as the Avalanche blockchains. And there are different GM pools that we could create leverage view strategies into. However, we are only going to focus on creating strategy vaults into these assets. So you have ETH repbitcoin, arbitram link, Sol, Uniswap token as well as the USDC token for arbitrum and foreverlaunch we have the AvaX and repave AvAX and it's BTCB rep EF and there's also a Sol token as well as a USDC token that we will essentially interact with on these chains. These token addresses are also stored in the constants file in this repository, so you can refer to them anytime you need as well.
00:05:05.360 - 00:05:49.578, Speaker A: Okay, now I'm going to go through high level overview of the protocol architecture. Instead of using this file, I'm going to use the technical documentation file. Okay, so at a high level, this is how the steadyfi protocol is being architected. So there are two types of vaults. We have the leverage use strategy vaults that we talk about, and these leverage use strategy vaults need to borrow assets from somewhere in order to leverage up. So there are also lending vaults within this protocol. Additionally, there are also oracle contracts that.
00:05:49.664 - 00:05:51.866, Speaker B: We need to deploy in order for.
00:05:51.888 - 00:07:04.142, Speaker A: The strategy vaults to be able to accurately get the price and the value of certain assets. We use Chainlink mostly for our prices of the tokens. Therefore there is a Chainlink Oracle contract. There is also going to be a protocol specific oracle in this case, since we are only creating strategy box to GMx, there is a GMX oracle and the difference between the chainlink oracle as well as the GmX oracle is that the chain link. Oracle only returns prices of blue chip assets, whereas for the GMX Oracle it returns prices of more specific assets or tokens to GMX itself, such as the price of the GM token, as well as certain other information such as what is the token weight within the GM token itself. For example, in the e USDC GM pool, the token weight of ETH and USDC can fluctuate. As of this recording, it generally stays around 55% consisting of E and 45% consisting of USDC.
00:07:04.142 - 00:08:05.490, Speaker A: So the strategy vault contracts could, for the neutral contracts, could actually need this data in order to know how much ETH to borrow in order to hatch the eth exposure in a neutral strategy. So we require this token reserves and we implemented a GMX oracle contract so that for strategy vaults it's a lot easier to obtain this information. Another contract that we would require is a swap contract. So there are certain situations in the strategy vault that may require the strategy vault to swap one asset for another asset. So for example, when it needs to repay debt of a particular asset, but it doesn't have enough of that asset, so it needs to do a bit of a swap in order to have enough assets to repay the debt for if and for USDC separately, for example. So in our protocol right now, we essentially use Uniswap to swap for assets.
00:08:05.570 - 00:08:08.166, Speaker B: On arbitrum, and for everlaunch we would.
00:08:08.188 - 00:09:12.830, Speaker A: Be using Trader Joe. So there will be a separate swap contract that is deployed for both Uniswap as well as Trader Joe that the strategy vaults can interact with to swap against. It is also useful to note that the oracle contracts as well as the swap contracts are reusable by all the strategy vaults. So every time we deploy a new strategy vault, they can reference the Oracle contracts as well as the swap contracts that are previously deployed for the lending vault contracts. They are also reusable by strategy vault. But the certified protocol actually implements a isolated lending pool architecture. So most of the time if we deploy new strategy vault contracts to a different GM pool, let's say instead of the eth USDC GM pool, we have a wrap bitcoin USDC GM pool, we would essentially deploy new lending vault contracts for that new GM pool with different assets.
00:09:12.830 - 00:10:11.150, Speaker A: So as to recap different roles in the protocol, we would have namely four types of roles. We have a lender, a depositor, a keeper, as well as our owner. And in this diagram here, you can actually see three of the different roles. So lenders are essentially users that lend out assets to lending vaults depositors are referencing users that deposit into the strategy vaults itself. Keepers are actually bots or automated kind of scripts. We currently use Openzeppelin defender that runs on a scheduled basis to constantly check the strategy vault and see if it needs to be rebalanced for anything and also if there are extra bonus incentive rewards to compound, the keeper will do it. And the keeper is also has certain scripts that can in an emergency pause the strategy vaults contract.
00:10:11.150 - 00:10:13.758, Speaker A: What is not shown in this diagram.
00:10:13.854 - 00:10:15.534, Speaker B: Is the owner role.
00:10:15.662 - 00:11:23.350, Speaker A: So the owner role as the name suggests, are administrators that have the right to actually update certain variables in the contracts. And in practice this owner role would actually be a timelock controller contract of which it is managed by a multisig that will require at least two out of three signing for any transactions to happen. Now at this point I want to do a quick reminder as to what are the contracts that are in scope and what is out of scope. Because even though we do need all these contracts for the whole protocol to work for this public audit, not all the contracts are in scope. So the contracts that are in scope are namely the oracle contracts as well as the strategy vault contracts. The contracts that are not in scope are the lending vault contracts as well as the swap contracts. So if you just go back to the readme file, we have outlined it here, the contracts that are in scope and the following interfaces contracts as well, and the contracts that are out of scope.
00:11:23.770 - 00:11:25.074, Speaker B: One thing I do want to highlight.
00:11:25.122 - 00:12:19.078, Speaker A: On this is that if you look at the contracts Oracles folder, we actually have a chain link up oracle, a chain link oracle and a GMX Oracle. Now the chain link oracle and the chain link up Oracle are more or less the same, except that for the chainlink up oracle, there are some additional code that is being added for enhanced security for a chain link oracle contract on the arbitrage network. So if I were to just compare this with the chain link Oracle contract. So on the left you have the chain link up oracle and on the right is the chain link Oracle contract. You can see that for the chainlink Oracle contract, it doesn't have certain variables, that is namely for the arbitrum sequencer. So for this public audit it would make more sense that you just focus.
00:12:19.164 - 00:12:21.222, Speaker B: On auditing or looking at the code.
00:12:21.276 - 00:12:40.110, Speaker A: For chainlink up Oracle and not having to worry so much about the chain link oracle. That being said, the chain link up oracle is being used when we deploy a chain link oracle on arbitrum and if we want to deploy a chain link oracle on everlaunch we would actually use the chain link Oracle and not the chain link up Oracle.
00:12:40.610 - 00:12:48.578, Speaker B: So unlike most D five protocols out there, GMX version two has a two transaction step process.
00:12:48.744 - 00:12:49.460, Speaker A: So.
00:12:51.510 - 00:13:33.530, Speaker B: Let'S say a user wants to make a deposit into GMX. So in the first transaction the user, or in our case the strategy bot contract, would actually have to send the deposit tokens to GMX. Then it would also have to send some native gas tokens. So on arbitrum that's going to be eth, on avalanche that's going to be Avax tokens. As a execution fee for a GMX keeper, then it needs to make actual transaction a function call. So depending on deposit or withdrawal. But in this example, let's just stick to a deposit, it needs to make a create deposit request and send it over as the first transaction to GMX.
00:13:33.530 - 00:14:14.286, Speaker B: These are the different contracts that GMX has, and it's for illustrative purposes only. But depending on whether it's a deposit or withdrawal, the GMX router contract would route that transaction appropriately. So that's the first transaction. And then after the transaction is done, GMX would have keepers that then execute this transaction on their own time. So how long it takes really depends on how fast the GMX keepers execute those transactions. But generally from testing it could take anywhere from a couple of seconds, three, 4 seconds to maybe around 15 or 20 seconds. So it's pretty fast.
00:14:14.286 - 00:15:20.290, Speaker B: But the key thing is that it's not in one atomic transaction anymore. It's now broken up into two different blockchain transactions. So assuming that GMX keepers have successfully executed on the deposit request sent in the first transaction. So once that is done, GMX would then go ahead and send the GM LP tokens back to the contract that make the first transaction. It would refund any unused ETH or Avax for execution fee back to the contract as well. And then if in the first transaction we had passed along a callback handler contract address, GMX would then call this callback handler contract address with the appropriate callback function, such as the after deposit execution or after withdrawal execution. So what I just described over here as an example, I've also written it down here, but this is also just the deposit to GMX function.
00:15:20.290 - 00:15:54.662, Speaker B: In our strategy vault, there are other functions that would interact with GMX as well. So we talk about deposit, but there's also a withdrawal capability. When the strategy vault compounds, it's also adding liquidity to GMX. So that's also a two step flow. When we do an emergency pause of the vault, we are actually removing liquidity from GMX. So it's also a withdrawal flow when we do a rebalance of the strategy vault. When we rebalance up or we rebalance down, you're either adding or removing liquidity from GMX.
00:15:54.662 - 00:16:00.654, Speaker B: So each of these functions, once we interact with GMX to add or remove liquidity is a two step process and.
00:16:00.692 - 00:16:03.326, Speaker A: We need to write the appropriate or.
00:16:03.348 - 00:16:15.230, Speaker B: Relevant functions to handle this two step process. So because of all this extra code that we have to write to handle this process, as well as we need to really ensure that we have checks.
00:16:15.310 - 00:16:17.074, Speaker A: In every step of this process to.
00:16:17.112 - 00:17:29.526, Speaker B: Make sure that we are at the correct state of the vault. The code for our strategy vaults grew quite a bit and we very quickly hit the solidity contract size limit, which is why we have to architect or break out our strategy vault contract into very different, into numerous, multiple different contracts to keep within the contract size limits. Now, that being said in this diagram here, here's an overview of how the different contracts actually work with one another. So firstly, even though we have numerous contracts here for one strategy vault, actually for a lot of these contracts, they are external reusable libraries. So the ones that are in blue will be deployed as external reusable libraries and we can actually deploy them once and every time we deploy a new strategy vault contract, we can just simply have that strategy Vault contract refer to this previously deployed external libraries. So let's say we start with a three x long if USDC strategy vault. First we would have to deploy the strategy vault contracts.
00:17:29.526 - 00:18:13.338, Speaker B: We will also have to deploy the library contracts. But afterwards we want to deploy a tree x neutral if USDC strategy vault. We do not need to redeploy all these library contracts. We simply need to deploy a new vault contract for that new strategy vault and reference the previously deployed library contracts. For all intents and purposes, the main so called main contract, as well as the address that most users would interact with or keepers will also interact with, would be the GMX vault. So contract itself for all these external library addresses. Generally, users will not have to interact with them.
00:18:13.338 - 00:19:14.694, Speaker B: It would be more for the deployed vault contracts to interact with them. Hopefully with the naming of the various contracts, it's quite self explanatory what the contracts are responsible for. So take for example, if anything that has to do with a deposit. So let's say a user wants to deposit into a vault, they would actually be calling the deposit function to the GMX vault itself. But the GMX vault function for deposit would then go on and reference the GMX deposit function within this library itself, does whatever it needs to do and then passes it along to other libraries that then talks to other protocols as required. So even though there are many contracts, but hopefully the naming of these contracts makes it quite self explanatory what they are responsible for. So we have library contracts for deposit functions.
00:19:14.694 - 00:20:05.162, Speaker B: We have library contracts for withdrawal functions, compound rebalancing as well as emergency actions. The GMX manager contract, you could think of it as having all the functions that is responsible for interacting with external to default related functions. So any borrow or repayment to lending vault, these functions are stored in the GMX manager. Any function that needs to add or remove liquidity, it would go through the GMX manager as well. But then we also have a GMX worker contract which has protocol specific functions such as adding of liquidity or removing of liquidity to GMx itself. These function logics are all stored in a GMX worker as well as for swap.
00:20:05.226 - 00:20:09.194, Speaker A: So as I shared earlier, we use Uniswap to swap.
00:20:09.242 - 00:21:10.290, Speaker B: So the code logic for the swap function to Uniswap is also within GMX worker itself. And then here at the bottom you have three contracts, GMx types, GMx checks, and GMx reader. So types is merely a contract that has no logic in it. It simply has all the different structure types that is being used and referenced across all the code in the strategy vault contract. For GMX checks, this is where we put in all the function logic checks that is being utilized across all the contracts as well. For GMX reader, it consists of mostly the view or read only functions that all the different contracts may utilize as well as for any users that want to obtain any information of the vault such as its debt ratio, the delta, the equity value, so on and so forth. All these code logic is stored in the GMx reader external library.
00:21:10.290 - 00:22:26.810, Speaker B: So just to run through an example of how function may flow in this contract architecture, so let's say if a user were to make a deposit, they would be calling the deposit function in the GMx vault. And I'm going to open up the GMx vault contract here, fold it. And so this function will be called over here and you can see that this function would go ahead and pass on this call to the GMx deposit library right over here. Let me fold it. So the GMX library has all the functions that are relevant to handling a deposit flow. And in this deposit function it does whatever logic it needs to do and it goes ahead and pass along to GMx manager to add liquidity. And in this GMX manager library over here we have some functions, helper functions, to calculate how much to borrow or how much to repay.
00:22:26.810 - 00:23:09.334, Speaker B: We have the actual functions for borrowing and repaying from a lending vault, as well as adding or removing liquidity to GMX, as well as swapping of tokens as well. So in the deposit function, what it would do is it would borrow more assets and then after that it would go ahead and add liquidity. And let's just see here. So for example, it would reference the lending vault and borrow the relevant amount needed and then afterwards it would go ahead and add liquidity calling the GMX worker library contract. And here in this GMX worker contract we have the functions that are protocol specific for interaction. So in this case, if you recall.
00:23:09.382 - 00:23:10.666, Speaker A: Earlier, what we need to do is.
00:23:10.688 - 00:23:55.434, Speaker B: We need to send the deposit tokens to GMx. We need to send some native gas tokens to GMx for execution fee. And then we need to make a deposit, a create deposit request as well. So this is where it would then interact, or rather this is where the code logic is to interact with GMx itself. And that is the first transaction. Now, after GMX is done on the keeper processing the transaction, if you recall in the follow up second transaction, it would then return or send the tokens back to the vault itself, but it would also make a callback function call. And this is where the GMX callback contract comes into place.
00:23:55.434 - 00:24:12.938, Speaker B: And this callback contract is actually, we have to actually deploy one callback contract per vault. So this is not a reusable library contract because depending on the strategy vault, the GMx would need to know which exact address, separate address to call depending.
00:24:12.954 - 00:24:14.802, Speaker A: On which vault calls it in the first place.
00:24:14.856 - 00:25:10.514, Speaker B: So it cannot be a reusable address. So in this GMX callback contract, we have the callback functions that GMx will call. So there is an after deposit execution and cancellation if it fails, as well as after withdrawal execution and cancellation if it fails for withdrawal. And within this code logic here. So following on, let's say we have a successful deposit transaction, we could see that we have some code logic here that detects what is the state of the vault and to then go ahead and proceed to make the right follow on call to continue so that the vault would know what is the follow up actions to do after this callback function is called. In our case here, in a successful deposit, the correct function to go ahead and call is the process deposit function. And this process deposit function is.
00:25:10.514 - 00:25:27.414, Speaker B: So from the callback it would actually call the vault which has a process deposit function of which it would then call the GMx deposit function again. So let's come back here to the vault contract. You can see that after deposit we have a process deposit function here, which.
00:25:27.452 - 00:25:28.678, Speaker A: All it does is it calls the.
00:25:28.684 - 00:25:47.434, Speaker B: GMx deposit library process deposit. And then if we come back here to the GMx deposit library again, we have the process deposit function here, which then does various logic of checking that everything is okay. If everything is okay, it will go ahead and mint the strategy vault tokens.
00:25:47.482 - 00:25:48.970, Speaker A: To the initial depositor.
00:25:49.050 - 00:26:43.150, Speaker B: But if things are not okay, if it fails, then we would actually have a fail event of which we need to then have more other functions, another flow to revert the steps that are being taken by the strategy vault itself. So hopefully this is a little bit clearer on how things are being structured. If not, please feel free to ask me on the discord and what I've just shared is essentially the deposit flow. As you can see, there are different flows where we interact with photos, strategy vaults and how it interacts with GMX. So there's deposit, there's withdrawal, there's compound. So compound is when any bonus tokens, we essentially sell it and add it back as liquidity to GMx. Again, we have rebalance, which is depending on what the vault status is, it could rebalance up or rebalance down.
00:26:43.150 - 00:27:54.178, Speaker B: And then there's emergency functions as well, which withdraws liquidity when there's an emergency situation. For example, just to be careful, to help you to understand the different actions and the potential sequences that could happen in a strategy vault, there is in this docs sequences directory we have different diagrams that are being created. So this is a high level diagram of a compound sequence flow and we will have a high level one as well as a slightly more detailed one which hopefully could help you to better understand the sequence flow of how things are being called. Depending on what action is being taken. Our biggest worry is definitely if there can be certain situations or things that can happen that is not supposed to happen, that can result in a potential loss of funds or the strategy vault contract being stuck. So users are being grieved essentially. So any of these findings would be high or medium findings for sure.
00:27:54.178 - 00:28:00.714, Speaker B: You would be very happy and thankful if you could file them as such. And any more questions please just feel.
00:28:00.752 - 00:28:03.158, Speaker A: Free to ask me in the codehouse.
00:28:03.254 - 00:28:04.680, Speaker B: Discord and thank you.
