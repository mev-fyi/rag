00:00:11.970 - 00:01:06.662, Speaker A: You all right? Welcome back. Hope you had a fantastic break because we are about to get started with lesson or project nine. Once again, if you scroll down in the course down to lesson nine here we have the entire code base that we're going to be working with right here. And this is going to be a one project for your portfolio. Why? Because we are going to not only write an advanced lottery or raffle smart contract, we're going to give you even more best practices to work with so that not only can you build a really cool project, but you understand the best practices, and your code looks phenomenal. So we're going to be learning a lot in this lesson. We're going to learn about events, working with true random numbers, working with modulos, chainlink automation and so much more.
00:01:06.662 - 00:01:29.870, Speaker A: Now, I'm going to show you exactly what the final product is going to look like and all the code here. So don't follow along. Just go ahead and watch. But one of the things that's cool is we can actually just scroll down the readme and go ahead and just go right into the quickstart. Right. We have git, we have foundry. So if we were looking to contribute to this code base ourselves, we could just do a little git clone.
00:01:29.870 - 00:02:03.862, Speaker A: Now, if we do ls, we have this smart contract lottery, we could do a code or a file, open foundry smart contract lottery here. Open this up here. And here's going to be our final project. So now that we have this, we can see some of the contracts in the left here. We want to run a forge build or a make build, since we're going to do a make file, and this is going to install all the dependencies that we need and compile our code, of course. All right, great. And then we can even go into these contracts here, and we can see what we're actually going to be building here.
00:02:03.862 - 00:02:45.854, Speaker A: We've got some weird comments at the top, which we'll talk about in a little bit. And we have even more better looking and professional Nat spec for this project. And this is why this is such an amazing project to do, because, again, the code base looks good. You can often tell how good a software engineering group is just by how good the code looks. And we have this raffle or lottery smart contract. And what this contract will do is we have a way for users to enter the raffle, and we have this weird checkup keep stuff, which we'll talk about in a little bit. And we have this weird fulfill random words, but this fulfill random words basically picks a winner based off of those who entered and pays them money based off of the entered people.
00:02:45.854 - 00:03:18.586, Speaker A: So this is a provably fair, a provably random lottery. And then we have a whole bunch of getter functions down here. We're going to be building some more scripts as well to interact with this, and we're going to be using some more advanced foundry work. And this is just going to be a phenomenal project for us to have. So once we've done forge build, we can look in our make file and we can see all the different commands that we have here. We, of course, can deploy our smart contracts. We have a couple of scripts here that we haven't worked before to interact with the chainlink automation, much easier.
00:03:18.586 - 00:04:01.310, Speaker A: With all these scripts and all this code, we can actually deploy a provably fair and a provably random lottery, which, if you remember back at the beginning of the course, we talked about the lottery example, this would be a solution to actually solve that. So let's go ahead and let's start building this. If you did go ahead and get clone, we'll CD down a directory. We can type RMRF boundary smart contract lottery f 23. Be very careful with running this RMRF command. This stands for remove remove force. So only run this if you absolutely have to, but I'm going to remove this directory, and I'm going to go back to f 23, and we're going to go ahead and start from scratch.
00:04:01.310 - 00:04:33.032, Speaker A: So let's go ahead and dive in. Remember, repetition is the mother of skill. The more you do this, the more you code, the better you'll get. So code along with me if you want even feel free to pause as we're coding and try to code some of this yourself, maybe see how far you can get without me. But we're going to be explaining a lot of different things in here, so be sure to listen and follow along. And let's jump in. So, since we're creating a new foundry project, we're going to start with the basics.
00:04:33.032 - 00:05:06.040, Speaker A: We're going to make a new directory called Foundry Smart Contract Lottery f 23. And we're going to CD into it. Foundry smart contract lottery f 23. Again, I'm hitting tab to autocomplete. I'm going to do code, period. Now that I'm in that direction, now that I'm in that directory, to open up a new vs code in that folder, and again, you can do file, open that folder as well to get in here. Now that we're in here, you know, we're going to run forge init to create our new project.
00:05:06.040 - 00:05:30.192, Speaker A: And if you created some stuff in here, go ahead and write forge init. F. Cool. So now that we've started and created our initial project, one of the things that I actually like to do before I even start doing any coding is come up with a blueprint of what I want to do. Right. What am I even trying to get this to do? What do we want this lottery to do? So this is maybe where I'll open up a readme. I'll even start building the readme right now.
00:05:30.192 - 00:06:13.512, Speaker A: Right. This is going to be our provably random raffle contracts. And then maybe we'll do a little about this code is to create a provably random smart contract lottery. And I'll think, okay, well, what do we want this to do? Okay, number one, users can enter pay by paying for a ticket. Maybe I'll say the ticket fees are going to go to the winner during the draw. Cool. Then I want to say after x period of time, the lottery will automatically draw a winner.
00:06:13.512 - 00:06:49.764, Speaker A: And this will be done grammatically. So we're going to programmatically automatically draw a new winner every time the period is up. And we're going to be using Chainlink erf and Chainlink automation to do this. So Chainlink VRF is going to be to generate a true, provably random number. Chainlink automation is going to be a time based trigger for our lottery to automatically trigger. Now, we'll talk about randomness in a little bit and how getting true randomness on the blockchain can actually be really difficult. And we want to use Chainlink VRF to actually generate a random number outside of the blockchain.
00:06:49.764 - 00:07:25.652, Speaker A: Additionally, as you guys have been seeing, in order for something to happen on the blockchain, somebody has to pay some gas, somebody has to trigger something to happen. So if we need to rely on somebody to constantly trigger something, ideally we don't have to trust them to be honestly, we can just use chainlink automation, which is a more decentralized way of having some trigger happen every x time period. So lottery is going to automatically go, we're going to use chainlink Vrf for random number. Cool. This sounds good. So now we have a rough skeleton of what we want to do, and we want to keep this in mind when we're building our contracts. Okay, so let's begin.
00:07:25.652 - 00:07:42.248, Speaker A: So we have tests, src and script. I don't want any of these. So we're going to delete all three of them. I did command, click, to click all three. So I was able to delete them in just one delete. But if you're unfamiliar with that, just go ahead and right click and delete all of them. And let's create our raffle sol.
00:07:42.248 - 00:08:12.268, Speaker A: So I'm going to go to src new file, raffle sol. You already know where we're going to start with this SpDx license identifier MIT. Again, I have copilot on, which is what's allowing me to automatically do a lot of this stuff as of recording. Version 0.8.20 just came out, which is exciting. But we're going to use pragma solidity carrot 0.8.18 and this will be contract raffle.
00:08:12.268 - 00:08:34.004, Speaker A: Like this. We'll pull up our terminal just to make sure we're doing a little sanity check. We'll do forge build, and it looks like it's working. So we are good to go here. So let's do this. So you saw when we were going through the walkthrough of the code that we had some code here. Typically having Nat spec to describe what your contract should even do is a best practice.
00:08:34.004 - 00:08:56.140, Speaker A: So let's actually learn and do that ourselves. Oh, and it even added it in for. Oh, and we even got a little pop up to add it in. Title, author, and notice. Title is going to be a sample raffle contract author is Patrick Collins. Little notice here. This contract is for creating a sample raffle.
00:08:56.140 - 00:09:29.336, Speaker A: And then maybe we also do at dev implements chainlink vrf v two. Because we're going to use chainlink vrf v two. Cool. A little bit of nat spec here to give the people reading our code or the ais reading our code a little bit more. So what are some of the functions that we're going to want to do here? We're probably only going to want a few functions, right? We're going to want a function pick winner. The first one we're going to want is enter raffle. Right? We want users to be able to enter raffles, and we're probably going to want a function pick winner.
00:09:29.336 - 00:10:11.028, Speaker A: Right? At the end of the day, this is really all the lottery needs to do. Enter a raffle and pick a programmatic, verifiably random winner. That's it, right? The pick winner should randomly choose anybody who entered and give them all the money, right? We're not going to take a fee here or anything like that. Let's focus on our enter raffle function here. So we want people to pay for a ticket to enter the raffle, right? And we'll set some ticket price. We'll have the ticket price be an eth or whatever native currency. So we obviously want to make this function payable and then we'll probably want some ticket price, right? So up at the top we could do our un 256 private entrance fee.
00:10:11.028 - 00:10:54.672, Speaker A: And this is where you'll start to see me just automatically defaulting to making these state variables private and then creating getters later on in the section. But this kind of brings up a good point. Should this entrance fee be a constant? Because a constant is going to save the most money. Should this be an immutable? Because that's going to be cheaper as well. Should this be a storage variable and we can start having this gas conversation for us. I think we want to be able to update and change the entrance fee based off of the actual contract. So we could set that in a constructor untv six entrance fee and we'll say entrance fee equals entrance fee equals entrance fee.
00:10:54.672 - 00:11:34.148, Speaker A: I know that for this contract, I don't really want to have to bother updating the entrance fee so we can actually make this an immutable variable to save some gas. So private immutable I underscore entrance fee and we'll only be able to save I entrance fee once. At the same time though, we'll probably want the world to be able to get the entrance fee right. So at the bottom I'll do this thing called getter functions and we'll create a little function get entrance fee. This will be an external view that'll return a U into 256. We'll say returns, I underscore entrance c or excuse me, return I enthused c. Cool.
00:11:34.148 - 00:11:41.570, Speaker A: And this setup is going to bring me to a point about the layout of your contracts, how to make your code look really good.
