00:00:00.250 - 00:01:02.094, Speaker A: You. Thanks again for helping organize this guild DRGC. I mean, it's, it's always nice to be back in this office. So from, as a quick introduction from, from my side, I'm one of the founding partners at Ethereal Ventures and we're a web three encryptive venture fund that was originally formed by the former venture investment team at consensus is and I'd say we've had a very, very close alignment with staking as a concept. I've, for instance, been sitting on the board of rocket pools since inception. We've led or co led rounds, the seed rounds for Obol doing distributed validators Eigen layer, and we recently announced co leading the round for alluvial, who's doing institutional liquid staking. So it's awesome to see all of the crowd interested in staking as a whole and what it can really enable, but would love for my fellow panelists to kind of introduce themselves as well.
00:01:02.212 - 00:01:43.294, Speaker B: Okay, thanks. Hello everybody, I'm Jan Rizzianas. I'm from Nomadic Labs Company, one of the main company developing Tezos protocol, or at least making proposals to update this protocol that has governance on chain and is able to self evolve. So I'm here today to talk about smart rollups. That's our optimistic roll ups solution that has quite good properties from a modular point of view. I hope so. Yeah.
00:01:43.294 - 00:02:02.180, Speaker B: So I've been the lead of this project last year, so it's now running on Mainnet. And today I'm engineering manager of the whole team. We are moving forward to make smartwatch even better, but probably all for the moment.
00:02:02.550 - 00:02:30.342, Speaker C: Hello everyone. Thanks for the invitation. Kiln and TrGC. So I'm Adrian from Massa. We are building a new Lego one blockchain that is not really designed specifically for rollups, but a more general platform that is focused on scalability and enabling autonomous smart contracts at the base layer. Yeah, happy to be there and discuss modularity. It's at the heart of our design as well.
00:02:30.496 - 00:02:31.006, Speaker A: Awesome.
00:02:31.108 - 00:03:05.560, Speaker D: And I'm Nick, the CEO of fuel and we're building a modular execution layer. So really focusing more on the execution side of blockchain, the transaction models, the virtual machines and this kind of thing. You can think about fuel as basically, if you looked at all the available vms and transaction models in the space and you kind of took a bunch of notes and then tried to build the absolute best machine you could possibly think of, that's basically what fuel is. So it's what we're doing.
00:03:06.250 - 00:03:41.330, Speaker A: Awesome. I think I wanted to start off again from a notion of first principles, really, and think about what modularity represents. It means a whole lot of different notions across different disciplines in computer science and biology and mathematics. But I just wanted to kind of give the floor to you guys and give us all a sense of what would exactly you think about modularity when you kind of apply this in the context of blockchains and roll ups and how it might be the same or different from what we generally think about modularity.
00:03:42.950 - 00:04:25.860, Speaker B: I can take it if you. Yeah, actually, modularity is a very old idea. I mean, it dates back to a time where these paintings were state of the art. It comes back to Descartes. So this idea that when you have a complex problem in front of you, the only thing you need to do to tackle this principle, actually to decompose it into smaller problem again and again, applying this until you get problems that are so simple that you can grab them and make sure that when you have a solution, it's actually correct. Okay, so that's very first principle. It's very common knowledge, actually.
00:04:25.860 - 00:05:32.690, Speaker B: Then Descartes was not in the same business as house. Basically, he was targeting philosophical questions, so absolute ones that don't change a lot of time. While in our case, we have a moving target, so the business is moving. And in our case, decentralization is something that we are refining and understanding more and more along the time. And so there is another aspect of modulize, is this ability to be robust, to change, to adapt. And that's probably the two main problems that you're trying to achieve. And to do that in computer science, what we do as software engineers is to try to map the decomposition of problems to components, software components that are decoupled from the rest of the system as much as possible, and also that have a clear frontier, a clear coefficient, you know, what a component is solving, what is the problem that it is solving.
00:05:32.690 - 00:05:51.326, Speaker B: And thanks to that, you can approach the problem in a very focused way, in an efficient way. So, yeah, I don't know if that's understandable. Maybe a bit too abstract. And we can refine by just instantiating this idea to relapse if you want. But I don't know if you want.
00:05:51.348 - 00:06:32.794, Speaker D: To add something, maybe I would say to add to that as well. Just I think you nailed in terms of decoupling complex problems or complex processes, and then making them into more effectively streams that you can work on. I think the word that I use is more like specialization. So it enables more specialization for each concern. And then when you specialize, you can really throw resources at a problem in a very specific way and that allows you to more effectively solve the problem, especially when you're dealing with scale and problems at scale. So, yeah, specialization comes to mind as well.
00:06:32.992 - 00:07:19.462, Speaker A: So that's a great point. I think Tina earlier was speaking about taking into account different people's preferences, say, on the validator guess. I mean, the ability to kind of encode this kind of information and get components to work seamlessly and in a manner that actually reflects the separation of concerns is something that I believe this is the sentiment that you've kind of been echoing in some sense, but maybe to actually get it to a more tactical standpoint and to a less abstract standpoint, what exactly, for instance, Nick, is the benefit that modularity brings to application developers in this context, especially in the case of blockchain development, what have we kind of been lacking with, with monolithic systems?
00:07:19.526 - 00:08:53.720, Speaker D: Yeah, we probably want to come down to at least the reality of blockchains just to talk about modularity. So I think the big thing is, typically when you're designing these complex blockchains and systems, you get to a point where you start to realize maybe you can separate the concerns of these systems out and then potentially break them up into other networks or other different systems, that you can solve these concerns. So I think in relation to modularity and just sort of the movement around modular blockchains and this sort of thing, you're really looking at separating the concerns of a blockchain, which you can break down into many different ways. I think there's a lot of problems actually breaking down blockchains because typically different parts do override other parts, but you can kind of briefly look at it as execution, consensus as well, where the transaction data is stored, data availability, and as well, if you're finally notating something or disputing it, your settlement layer. So where things are settling. So breaking blockchains up into these concerns allows you to look at it sort of a different way and ask the question with each one of these things, can we actually build networks and systems to specialize for each one of them instead of trying to do them all in one place? So really modularity or modularity in blockchains is very much trying to break these up and look at how we can specialize in each area.
00:08:54.330 - 00:09:44.280, Speaker C: Yeah, I'd say that in some way it's about specialization, but in another way it's about also genericity. Because I think one example, if we want to go more specific, is account abstraction. I think it's about like, I don't know if everyone is familiar about count abstraction, but it's the fact of unlinking the signature scheme from the account that you use. And this enable a lot of use cases. And this is, I think, a typical example of modularity, where the process of designing what is an account is very generic, and then you can uncouple it and then it enables two fa, I don't know, native multisigs and things like that. And this is really nice.
00:09:45.610 - 00:10:17.902, Speaker D: Yes, I think just to specify too, I think there's the separation of concerns typically within blockchain architectures themselves, and then there's also just building more modular systems within blockchains. So just taking also different pieces like say compiler design or account design, and then making that more interoperable or making that more pluggable, or these are other ways you could express modularity, not just with the construction of the blockchain.
00:10:17.966 - 00:11:28.918, Speaker A: Yeah, that's a good point, I guess. It's interesting, I think I was kind of reading this account by this polymath in biology, who was also speaking about the evolution of modular systems in biology as a way for systems to kind of like organisms, to evolve and adapt to the changing external constraints of the environment around them. But fundamentally, in the case, I guess, of blockchain systems, one thing that had kind of interested me fundamentally about roll ups was the ability for developers to express their preferences as it relates to the capabilities of a runtime that they had to be working with, and that essentially might lead to more modular systems. But I just want to kind of ask people who've been working on modularity, is this something that you kind of clearly see? Is there a developer intent for people to kind of focus on different capabilities that your specific runtime can grant them? And if so, just curious what your perception is and how you're kind of thinking about taking that into consideration while you're kind of building these systems.
00:11:29.014 - 00:12:36.126, Speaker B: Yeah, I'll take this one. So what I think is super important is to make explicit what are the main concepts that you need to decompose your problems. And typically, in the case of holopsy, when you have decomposed things like I want the security of the l one to be lifted to an execution layer, then what you can say is actually the relevant concept is actually a proof generating virtual machine. It's the concept that you need to correctly model with the simplest interface as possible so that you can reason about it. Because modularity, we didn't say for the moment, but it's all about local reasoning. It's about being able to have the strongest security analysis on your components so that you make sure you just don't focus on implementation details. But you have the principle that makes all things provable, mathematically speaking.
00:12:36.126 - 00:13:27.662, Speaker B: Okay, so that's the main point. And for this I see no other way than decomposing, generalizing as much as possible, actually. So we are really different from that perspective. It's interesting to debase, for instance, in the case of the rollups that are in the Tezos protocol, actually what we provide inside the protocol itself is a general infrastructure for anyone to deploy a smart project. It's not a smart contract. It's actually built in the protocol. And it's actually parameterized by this notion of proof generating virtual machines so that we can change from one machine to another when the needs of our users change, actually, and it's that way all the way down at each point.
00:13:27.662 - 00:14:23.506, Speaker B: You want to be able to customize, to refine what you don't know about decentralization, what your user needs, et cetera. So that's the main philosophy that we are following. And it has very good strengths because it allows us to apply formal methods to make sure that we don't have security issue because we have a mathematical proof that it's actually correct. And at the same time it has weaknesses. Because if you talk with people that are developing hardware, these guys are applying modular methods since 40 years ago. And what they tell you is that actually the security breaches comes from the interfaces between the components. Because if you are not formalizing correctly, what you expect from the components that you're using and what you actually need to be correct.
00:14:23.506 - 00:14:58.860, Speaker B: If you don't do that in a very rigorous way, that's exactly where the security breaches are. People will just, I mean, if you look at vulnerabilities in hardware, in pc architecture, you will see that many times it's just about a specification of an interface that was not precise enough. And in each side they were doing slightly different assumptions that you can exploit from a security perspective. So that's the main way we use modularity in our case.
00:15:00.590 - 00:15:01.194, Speaker A: Go ahead.
00:15:01.232 - 00:15:57.626, Speaker D: Yeah, to come back to the question, so how does modularity enable new kinds of runtimes or this sort of thing? I would say, well, to start to look at the problem that blockchain currently faces, blockchains are typically completely inaccessible to normal people and developers to an extent as well. They're also really horrible to develop. Recently I was writing a list of terms for blockchains, just in terms of a modern updated list and I basically had to stop because there's just so many terms. I mean, for a developer to even understand half of this would be. It's a lot to ask, right? So blockchains are very inaccessible. What modularity gives you is the ability to have a lot more creativity as to how you might want to solve problems. So in the ethereum roll up space, the way that's typically seen is a lot of people are deploying EVM roll ups.
00:15:57.626 - 00:16:48.410, Speaker D: So they're saying, come to us and we'll give you the same experience that you had with Ethereum, but we'll make it cheaper, right? Thus making it more accessible with fuel. Because of the creativity aspect of modularity, rollups open up the ability to do whatever you like. You don't have to do the EVM. Now, obviously, if you want to make the best business decision upfront, in the short term you do the EVM, but in the long term, you could do anything you like, the execution layer. So if you can do anything you like, then basically you ask the question, okay, well, I want to make Ethereum and blockchains more accessible. So with a project like fuel, we sort of get to have the fun with all this and go, we'll build our execution layer, it'll settle on Ethereum, be fraud approval on Ethereum. Potentially the data availability will be on Ethereum.
00:16:48.410 - 00:17:22.762, Speaker D: We'll inherit the security of Ethereum, but will give developers and users a much better experience. And then we'll also give people a lot more capability to scale things. So really, modularity opens these doors of creativity, because you can do whatever you like. And before with typical blockchain architecture, you were very constrained. So I had to wait for Vitalik and the Ethereum group to come to consensus to update the protocol, to add an opcode that might be useful to solve this one user problem. Right. And that would take years.
00:17:22.762 - 00:17:46.420, Speaker D: Whereas now with rollups, I don't have to wait for Vitalik to come to consensus with the community. Not to say that Vitalik is the mastermind, but he kind of is behind Ethereum. I can now just expressively build what I want to build. So I would say modularity gives you a lot more creativity now with blockchain. So fuel looks to really heavily advantage that.
00:17:49.830 - 00:19:05.174, Speaker A: I think your point earlier was ultimately on formally, I guess, specifying the interface and making sure that these interactions ultimately happen in the way that they are supposed to, which is why I kind of said we were kind of jumping a little ahead because that was my next question. In the sense that modularity to your point, really unleashes creativity. I think it brings about open innovation. It gives people the ability to kind of choose to pick the components that they want and plug them in the way that they feel the most comfortable for their business needs or whatever else this might be, and still kind of put things together that ultimately rely on the security guarantees of an underlying l one. But the fundamental issue with modularity, and surprisingly even in biological systems, is the fact that you can have small perturbations, but between components that are meant to kind of interface with each other in a given manner. And if they don't, the whole thing kind of comes apart fundamentally. So I'm just curious about your thoughts on the issues with highly modular systems and how you feel you want to kind of address them when you kind of think about development from all of your perspectives.
00:19:05.174 - 00:19:05.820, Speaker A: Really?
00:19:06.670 - 00:20:11.390, Speaker D: Yeah, I mean, I'll take a stab at this one. I'll try to be short so that we can all answer, but from my perspective, so when you break these really complex blockchain systems out into different pieces or different parts, you do get the benefit of specialization. So you can potentially provide a lot more scale when you do this, but it also makes everything a lot more complicated. So everything in blockchain design has compromises, and it doesn't matter what way you want to frame anything, if you think you have a good idea to solve one problem, it likely has a bunch of problems associated as well. So basically, every time you break out a concern or you try to fix something, you're going to open up more potential areas where you're going to have security vulnerabilities. So you're always looking to try to build a system that's the most accessible and the most secure. But ultimately it can be really difficult because you're dealing with all kinds of different assumptions around how the system is going to work.
00:20:11.390 - 00:20:31.320, Speaker D: And sometimes just building the whole system in one thing in a monolithic way, you would say, is nice because at least you can try to have certain guarantees around your system. So there's trade offs with modularity in the sense that it makes things more complex, but there's the potential of it offering a lot more scale too.
00:20:32.330 - 00:21:11.300, Speaker C: I think it's well summarized because on a philosophical level it's easier to understand when you have different pieces, but at some point it becomes very hard to grasp. And if you have worked with AWS microservices, then it can become like a real headache. And there was a nice blog post on AWS on how they moved everything, like on Amazon prime from a bunch of microservices to a big monolithic thing. So they're trade off. And it introduced a lot of vulnerabilities. And sometimes it's not performing as well because there are some things that you don't understand. Exactly.
00:21:13.270 - 00:21:15.926, Speaker A: Is that why you're going with your own l one in that sense?
00:21:16.028 - 00:22:23.260, Speaker C: Yeah. I think it's also other reasons that, okay, I believe that you will have multiple chains, whether it's like l two on the same layer, one or different l ones, but you will still gain if you have better performances at the blockchain level, because you will want to move from one asset from one chain to the other. And this will be inevitably cheaper if you have more throughput. So this is why we are doing it also because there are some things that are lacking in the blockchain space at the moment, such as automation for smart contracts. And another thing that we do is that we allow people to host a website directly on chain to avoid hacks at the interface level, where people typically access the apps through a regular website. So you could ask, what's the point to have something decentralized if you access it through something hosted on a centralized server? So these are the reason, in a nutshell, enough.
00:22:24.030 - 00:22:50.898, Speaker A: I also wanted to maybe shift gears a little. And given the fact that you're kind of working on these systems, I wanted to focus more also on the organizational components of each of your teams, kind of working on the platforms that you're working on. And just to understand how, I guess the approach towards modularity has kind of maybe changed the way you've thought about building your teams and your organizations and.
00:22:50.984 - 00:24:13.950, Speaker D: The ecosystem around it in terms of building teams and organizations, I think to be honest, over the past, while I've come to realize that remote is actually not as great as people would have said, mainly because human beings are human, and it's nice to stare at the people in the face that you're working with on a regular basis. So in that sense, that's more of a human problem than a modularity problem. But I would say that I don't think modularity has really affected the way we designed or constructed our organization. And I actually think in order to build these really complex systems, you have to have a highly centralized and localized group of people that are really focusing on the problems to get them done, so that you can basically birth systems which are not highly centralized. But I think it would be dishonest to say that you would want to build these things in a modular setting because humans don't care. The human brain is not changing. So I, for me, would just prefer to have a highly localized team building these things, but to bring something into the world that is no longer at all reliant on a group of people or a centralized group of people.
00:24:13.950 - 00:24:16.160, Speaker D: So that's the way I would sort of see.
00:24:19.570 - 00:25:53.150, Speaker B: So, in the case of Tezos, our textbook example of the Conway law, the thing that says that actually the organization of your software has an impact on the organization of your organization, the structure of your organization. When we started in 2018 working on the layer one, it was about a lot about how we make, on chain governance, how we make the layer one, the ability to evolve to change its own protocol with an on chain and based on stake approach. And the natural architecture was about understanding a very simple decomposition. What is inside the protocol, what is outside, what is infrastructure that is required to run the protocol, like peer to peer layer block storage management, et cetera. So that's what we call the shell. It's this part of the system that actually runs a protocol, and then we want this ability to allow anyone to make a proposal of the protocol to actually participate in the democratic way of choosing the protocol. So we had this decomposition in two teams, because as Cordev, we make our own proposal for the protocol that people may change, anyone can change it a little bit customized to say, no, I don't want this inflation or this, and this.
00:25:53.150 - 00:26:29.642, Speaker B: And then you have the vote and you decide which one you want to activate on chain. And actually, yeah, in this case, we had this decomposition in two main teams. And today, now we have the share the protocol and the roll up teams. And it was natural to us because the concerns of each team were different, are different. And so actually, yeah, in this case, it looks like the Conway law is actually making sense. It's not universal. I perfectly understand, doesn't apply everywhere, obviously.
00:26:29.696 - 00:27:01.810, Speaker C: It depends on the scale of the project. For us, we moved from a very centralized by design project because we were three founders, to more decentralized project with 30 people and now community contributors. And of course, it's much easier to have community people working on the project. If your project is modular, then it's much like you have smaller prs to review. So, yeah, modular design is very important.
00:27:01.880 - 00:28:26.686, Speaker D: In that case, I would say as well, one final thing to add is as much as if fuel is just an organization, like any organization, I think the idea is still that you want people to be able to understand your ideas, and then if they want to, basically, if they have new ideas about how the system can upgrade. I think more in the roll up sense of things, at least the way that we see it is if you want to change the system, you can actually just deploy your own system and you make bridging and interoperability something that's very easy and flexible. So I see in the future this ability to upgrade without upgrade keys or without even votes, that it would actually just be passive in the sense of people would just bridge over to the next upgrade of the next roll up and making that process opt in and very smooth just to avoid what would effectively be tyranny of the majority and these kinds of things that I'm a philosophy dropout, so I'm pretty sensitive to tyranny. The majority typically, and I've seen most dows pretty much fail in the space. So I think the evidence supports that. Majority rule governance is bad for people and for dows and for systems typically. So highly contrarian view, but I don't think it's worth it.
00:28:26.686 - 00:28:32.800, Speaker D: And I think more vote by your feet actually feels more right to me. Yeah.
00:28:35.410 - 00:29:23.540, Speaker A: Maybe one more question to kind of run the discussion, at least from my side, would be should we say if there's like a new developer who wants to kind of work with roll ups, deploying roll ups, and is interested in kind of getting exposure to the kind of capabilities that modularity can give them, what are, I guess, the things that she should be focused on? What are the links that, that are what, what are the concepts and what are the bridging points that she should basically look at to make sure that they're thinking about things in the right manner and actually using the frameworks that you're developing in some sense.
00:29:24.470 - 00:30:10.800, Speaker D: Well, I would say at least from our side of things and looking at the tools that we don't work with Tezos. But Tezos is definitely very fascinating as far as a project and a system for roll ups, et cetera. But I would say that I think there's a few key things. One is where are you storing your data? And that's really important because with blockchains, you have to recreate the state of things. And so even if you're a ZK roll up, it's not really any good to have a ZK proof if you don't know what the proof means. So you need to store the data somewhere now, to what extent the data is stored and where it's going to vary on your solution. But basically, where you're storing data is going to be very important as well.
00:30:10.800 - 00:31:27.800, Speaker D: If you're proving something is wrong with your system, where and how are you proving that, and what does that mean really? And so there's a lot of passive and active ways to do this, but that's another component as well. How are things incentivized? So even though roll ups allow you to have what's called an honest minority assumption, where effectively you just have one party that's going to take a look at things and make sure it's safe, that's a really great property, but you still need at least one person to check, and there are probably many cases where that's not happening. So how are you incentivizing those systems? And then lastly, it's just sort of what kind of architecture are you looking for and what kind of community are you looking for? So if you're looking to get closer to Ethereum's world and the liquidity there, then Ethereum rollups are going to be one area to look toward. And I'm sure Tezos has as well, many different things that they bring to the table in terms of why you would want to use tezos for roll ups. So I think these are some common questions or common things to think about topically that you would look at when you're designing your system or your roll up.
00:31:28.330 - 00:31:35.830, Speaker A: Awesome. Do we have time for questions from the audience?
00:31:38.810 - 00:31:40.040, Speaker B: If there is one?
00:31:40.370 - 00:31:50.078, Speaker A: We should do that from the sign. Thank you, guys.
00:31:50.244 - 00:31:51.580, Speaker D: Perfect. Thank you.
