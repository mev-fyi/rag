00:00:00.330 - 00:00:30.306, Speaker A: You. Yeah. So consensus proofs for better staking pools, kind of two pieces here. What do I mean by consensus proof? And then how does it support better staking pools? By the end of this talk, you should understand both of those parts. I hope so. As you all know, you know, Ethereum is a proof of stake, and there was this huge event of the merge has gone pretty well. And a key thing here is that there's like two layers to the merge.
00:00:30.306 - 00:01:02.618, Speaker A: There's like the execution layer and the consensus layer. And as part of the way this was designed, it was really straightforward to kind of keep these two layers separate. So we had this execution layer that has been existing for quite some time now. Ethereum's birthday is actually coming up, but that's been going for a while. And then in parallel, we made this other chain, the beacon chain, and then the merge was actually bringing them together. But there's still some artifacts of having these two different layers. And so that leads to some downsides, a big one here being communication between the layers.
00:01:02.618 - 00:01:32.474, Speaker A: So what you can do is you can deposit your eth from the execution layer. When you go to get ETh on exchange, you withdraw just some wallet. You have even say, like metamask. This is like ETH in this execution layer when you use all these dapps. That's what we're talking about. If you want to become a staker in Ethereum, you deposit from the execution layer into the consensus layer. So there's sort of this one way communication there for just ETH, this token that we know after Chappella, you can now withdraw ETH back.
00:01:32.474 - 00:02:21.698, Speaker A: And we saw a bunch of considerations in the last talk around withdrawals and how that kind of works. The thing is that this is just ETH, right? So there's no way to communicate more about state between the two layers, at least trustlessly. And it turns out that there's all sorts of applications. Hopefully some of you in this room will come up with new and crazy ones that no one thought of before around using the state to do things like, for example, improve how we build staking pools. And. Yeah, so a big sort of piece here is that there's no way to, again, trustlessly get from the CL back into the El, where we would imagine writing smart contracts, applications, things that use this stuff to, again, drive towards more decentralized applications. And there's all sorts of stuff we can imagine.
00:02:21.698 - 00:02:54.702, Speaker A: There's three I'll call out. There's like a few others I've been kind of toying with. And either way, again, I think there's a lot that will just not be possible, and it'll be really exciting to see what people do with it. One of them like staking pools, as everyone talks about like liquid staking tokens. Another is restaking with things like Eigen layer, which you've probably heard of. There's probably some applications, Johnny MV management and I'll get into that later in the talk. But that being said, all these applications we can imagine happening in the execution layer.
00:02:54.702 - 00:03:44.690, Speaker A: So again, series of smart contracts do different cool things, but without a way to communicate between one to the other, the Cl to the El, you have to have some sort of trusted oracle in the mix to make this happen. Like if you need to know about some updates to some validator, say their effective balance changed, there's no way to know that right now without trusting some other operator to bring that into the chain. And commonly these things are implemented via essentially multisigs or things with even worse security properties. So that's not nice. And that was the point of this EIP, was to essentially, actually just remove this trust assumption entirely. EIP 4788. This is included in the next upcoming hard fork Cancun.
00:03:44.690 - 00:04:24.400, Speaker A: And yeah, this was an EIP written by myself and then with some collaboration with Ansgar and Danny at the F and many others. Yeah. So what does the IP do? Well, it solves this problem I was just painting for you in a way that we'll see, moves the beacon block route from the consensus layer into the EVM, where it can be used for all these different applications. So let's look at the design a know. Again, there's nice pieces we can kind of use to understand this change. The first one is this beacon block route, and the other one would be like in the EVM. So let's just break that down.
00:04:24.400 - 00:05:33.270, Speaker A: So with the beacon block route, what does this mean? So when we say roots in the consensus layer, we're talking about these cryptographic accumulators that we can make proofs against. And what is a cryptographic accumulator? It's this thing where you have these security properties that let you, well, make proofs about the thing. It's a way to have a very succinct object, a commitment to maybe a bunch of data, and you'd also like a way to make easily verifiable proofs against the accumulator. And in this case, what we want to is get to the state on the consensus layer. So again, there's going to be some very succinct thing, some very small thing that we can take from the Cl put into the El, and then we can sometime later have these proofs. So almost indirectly then verify, hey, I made a claim that at this point in the past the validator looked like this, and I can actually then provide a proof that was the case. In particular, the way this is structured is there's this whole scheme called simple serialization, that the way you can write everything within the consensus layer also sort of has this Merkel tree attached.
00:05:33.270 - 00:06:14.994, Speaker A: I'll just assume you know what those are. I'm familiar point is that it's again, this cryptographic construction where you can actually say, okay, I commit to some data and later I can prove what that data was. So this is essentially an example. I'll just kind of walk through this. So in this case, we have these accumulators, these roots, and the way to think about them, they're just 32 bytes, and they have this property that you can almost think of these as like expansions. And now, I didn't really draw this out, but the way to think about this is like each layer here is like sort of some part of some tree. Like the idea is this would be at the very top of some very big tree, which is like pointing to the Beacon state.
00:06:14.994 - 00:06:48.570, Speaker A: The beacon state is this very big thing. And then there's a subtree, which is a validator. And the idea here is we want to say, okay, I have the root at some slots. And I ultimately want to know, was this validator slashed? So you could say, okay, here's the root. In particular with the CIP, we work with block roots. So you have the block root that commits to the block. And here I just show the header of this block that commits to, say, the state, which then commits to the state object, or, sorry, I guess I'll say it commits to the state route, which commits to the state object, which has a list of validators.
00:06:48.570 - 00:07:24.890, Speaker A: You can pick the validator you want, get down into it, and eventually prove, for example, in this case, just this one byte slashed or not. So that's kind of the idea. So we have all this cryptography, which is pretty cool, so we can prove arbitrary things. And this is like, again, this is only a partial view of the state. There's a bunch of cool stuff in here. Essentially, anything we care about at the consensus layer is committed to in some way via some data structure in the state. So it really has opened up like a hopefully very large design space for all sorts of things that we could care about, including staking pools.
00:07:24.890 - 00:08:21.078, Speaker A: So now there's a question of, okay, we have this beacon block route and it lets us prove things about the state, and that's pretty cool, but how do we go from actually getting it where they sort of exist, let's say on the cl into the EVM? That's the next part of this EIP. So the way we're going to do that is essentially use this thing called the engine API, and I'll just keep it kind of high level. But basically, again, reflecting this sort of dual layer design of the merge, there's a consensus client and execution client. If you run nodes you might have heard of like Geth, Lighthouse, Prism, Besu, there are others. Point is, there are many client implementations for each layer. There's also vetter clients attached with the Katyas client. So when you actually go to run the software, this is the thing that's holding your staking keys.
00:08:21.078 - 00:09:18.110, Speaker A: This is the thing that's like managing the beacon state and reorgs on the beacon chain and all this. And then this would be the thing verifying the execution, whatever's in the block. The important bit here is that there's these APIs that connect all these pieces, and they're here because the idea is, again, you could have different implementations of the consensus client, interact with different implementations of execution client, and they should all work together. For this EIP in particular, what you're going to do is pass the beacon route along the engine API. So again, it's like in some sense it lives here. You're just going to pass along the way this kind of works is that for every block that the consensus client gets, it's going to check the validity of the execution payload, the execution part of the block by passing across as engine API. And under this EIP we just also then pass the block route.
00:09:18.110 - 00:09:58.650, Speaker A: So that's what this does here. You have the CL for every execution block you're going to pass along. Also the parent beacon block route. That part is important because if you pass along the block route, you'd have the circular dependency. It would basically get to a point where I use the root in some smart contract which is going to change the execution of the block, which isn't going to change the root of the thing, which changes the thing that goes into the EVM, and hopefully you can see where there's a cycle. So we send the parent beacon block route. So there's sort of this like latency of one slot, but not really a big deal.
00:09:58.650 - 00:10:37.552, Speaker A: So we're going to send the parent block route across the engine API that goes into the execution payload header. This is important because it supports syncing. I think I'll say a bit more about this in a second. Yeah, I'll get to that in a second. And yeah, then basically after that is with the root and the header, you then write it into the VM as this thing called a staple pre compile, which is also a kind of new concept the CIP introduces. And we'll look at that in a bit. So some questions that immediately come up is like, why the parent beacon block root? Well, it's kind of what I said, you have the circular dependency.
00:10:37.552 - 00:10:59.980, Speaker A: If you try to use the block root of that just doesn't make sense. There's this syncing question. So again, this is like an architectural decision of the merge. You kind of want the El and Cl to be as independent as possible. And so what that looks like is like the Cl could say, hey, here's the tip of some chain. It could then turn around the next slot and say, here's the tip of some other chain. And the El may not know about this.
00:10:59.980 - 00:11:29.910, Speaker A: So then it needs to run off and sync this other sort of fork of the chain. And it's nice to just have these be as uncoupled as possible. If they kind of worked in lockstep synchronously. Yeah, it wouldn't be as nice. Just take my word for it. And so because of that, what that means is that if the El is like off syncing some chain, then it needs this information, for example the parent beacon block root, without talking to the Cl necessarily. So that's why we put it into the header and.
00:11:29.910 - 00:11:58.810, Speaker A: Yeah, then you just go along and get to the head of whatever chain over here is. So I mentioned the stateful pre compile. This is actually pretty new. So inside ethereum we have this concept of pre compiles. And the basic idea is there's some things we want to do in EvM that are just too expensive to write as like smart contracts, as like EvM bytecode. So instead we can say, okay, for some things we all agree to. For example like sha two five six, the hash function.
00:11:58.810 - 00:12:31.666, Speaker A: We can point to the way to think about it as like a native implementation that just exists at some special place on chain, and we can all use that. So similarly, we wanted to do this with the CIP. And in particular there's now this new concept for the pre compiles that they're stateful. For example with like shop two five six. That's just like a hash function, you give it some bytes, it gives you back the hash. There's no state it needs to maintain. Well, now we want to actually have a history of these roots.
00:12:31.666 - 00:13:10.158, Speaker A: And so now there's this state that needs to be maintained within this contract. Again, for you as the end user, you probably don't really care about this, but it actually has interesting security implications. So it's worth calling out. The reason why is because this actually supports stateless clients. So if we move to, say, vertical tries or something like this, then we get to a place where you don't want, or I'll say this instead. How an analogous feature works today with the block hash of the execution layer is that you don't write them into the state, they're just in this history buffer. There's just like an ambient history of the last two to six hashes.
00:13:10.158 - 00:13:58.094, Speaker A: And what that means is that if you were to make the protocol today stateless, you would basically need to have the state and this other little thing, which is just kind of annoying. So this is actually much cleaner. If we have one very self contained thing, it makes it easier to make proofs and generally supports, again, a move to stateless clients. So we have these concepts, we're passing the root along. What are we going to do? So, like concretely, before you even execute any transactions, you're going to take the root, you're going to write it into the staple pre compile, which again is just like some address, there's some state, just like any other account on Ethereum, you write it in there. Now the idea is that any transaction in that block can call into the same pre compile, say, with the timestamp that it is interested in, and get back the root. And there we go.
00:13:58.094 - 00:14:26.726, Speaker A: We have trustless access to the consensus state. And that's what we wanted. We can now verify proofs, make all sorts of claims about the cl. That's pretty cool. So what I kind of described so far is like almost a design where every block you're sending the root over. And what that means is that with each new block you could imagine just overriding what was there before. You could do it this way.
00:14:26.726 - 00:15:04.910, Speaker A: But the issue is that you essentially need the next same slot inclusion to use this thing at all, because you would write the parent route, you would say, hey, I want to make some proof about the state there. You would go to the next slot, you would try to use it and it would be gone. So instead we want to do provide some amount of history and the way that the CIP implements. This is with the ring buffer. If you're not familiar, just like imagine there's just a fixed amount of these slots here. That's what this data structure is supposed to, or this picture represents, is the data structure. The idea is there's about a day of roots that are in the storage of this pre compile.
00:15:04.910 - 00:15:49.100, Speaker A: And what that means is that rather than have to be very precise about when the root is on chain and when you try to prove something against it, you have some buffer room, say a day. This also is nice because it bounds the state growth. An earlier iteration of this protocol, or this EIP rather, was basically going to just write them all forever and it wasn't going to be the end of the world. But it does have this unbounded state growth and generally we want to avoid that. So if we move to this world with this ring buffer and say a day of slots, sorry, a day of roots, then we have this problem with missed slots. What this means is that you could have the chain going. And again, if there's like reworks or something, which we've seen are increasing as if you saw the last talk.
00:15:49.100 - 00:16:47.354, Speaker A: So these things happen and they're out there. And what that means is that basically from the chain's perspective, there was like a block should have been there, but it wasn't. And this is a problem actually for this kind of design. So what I tried to communicate here is that you could imagine everything is full. Let's say we have written a day of history of these routes and then we are coming back around and then this slot was missed. What would happen is that basically you would miss this entry here into the ring buffer, meaning it would basically be like the prior day's entry. And that's a problem because if you went to say, okay, if I have the timestamp of this thing and that sort of maps into this slot or this index of this ring buffer, you would get yesterday's entry and then you would be able to do bad things, meaning prove for some time you would have basically making proofs about old state, which we don't want to do.
00:16:47.354 - 00:17:22.034, Speaker A: So the solution we came up with was basically to have two ring buffers, basically store the timestamp along with the route. And then you just check if I claim that I want the route at this timestamp, make sure it's the one that was written last. And if it is, return the root. If not, just abort. This was like an excerpt from the EIP, which is what I just said. If you're curious. You can look, but basically the idea is you have, well, there's more in the IP, so that's where all the details are, honestly.
00:17:22.034 - 00:18:15.220, Speaker A: But essentially the idea is you get the timestamp from the call data, do some sanity checks on the format of it. One way to make these ring buffers is you just use like a modulus operation. So modular arithmetic on the timestamp, modulo the size of the buffer that you want, that's used as an index into the first ring buffer. To get the timestamp, you can say, if this doesn't match, then just return like a garbage root, basically zero, and otherwise get it from the other ring buffer and return it to the caller. So that's a high level overview of the IP. Yeah, so that's pretty cool. And now I'll talk some about these applications that I was alluding to, perhaps more interesting, unless you're like one of these core devs who are willing to like the minutiae of this stuff.
00:18:15.220 - 00:19:11.072, Speaker A: So some things you could do, you could imagine this touching anything in Ethereum that needs access to the vatter state. So like things like staking pools, lido, rocket pool, perhaps even kiln restaking, like eigen layer. And also, again, this is one where I'm trying to brainstorm some more things, but I think essentially even different, maybe management techniques would use things like this. Anything that's going to try and use the consistent state is essentially touching the speaking route somehow. And with the CIP, suddenly the trust model for all of them is immediately improved because there's suddenly no reliance on this oracle. So just to call out some specifics, I mentioned staking pools. So one thing you could do is look at validator lifecycles.
00:19:11.072 - 00:19:54.960, Speaker A: So just very simply, does this validator exist? Has it deposited? You can imagine I'm trying to join some pool and maybe I'm griefing the pool somehow by just claiming, hey, I'm a validator and here's my pub key. But it's actually not even in the state yet. Something like that. You can look at validator performance. So the idea here is if you look at the history over time, we essentially record the performance of validators in terms of the rewards or penalties they get. You could imagine compiling this down into essentially like a report card almost, of how good the validator is. And then this gives you some quality of the operator that could be then used to essentially place them into some kind of risk bucket if you're making a liquid staking pool.
00:19:54.960 - 00:20:46.850, Speaker A: And yeah, I did add tossing the note if you're doing something like this, you'd probably want a zero knowledge proof to compress all of this computation. But it's something where you'd still want this route and the CIP still would apply. Another bucket is like restaking. So again, if you've been around this week, you've probably heard of this thing called Eigen layer. The idea is to take the ETH locked on this consensus layer and reuse it somewhere else. There's some very high level questions that Eigen layer today will ask, and again, they use an oracle to answer them, which is, for example, is a validator even registered correctly? The way things like Eigen layer work is that they point to a series of smart contracts into the El. And there's some data in the consensus layer, the withdrawal credentials that I think Mike mentioned.
00:20:46.850 - 00:21:45.110, Speaker A: And if those are not correct, then you can't trust the validator to validate your application. Another one, again, very simply, like, is the validator slashed? You could get to a case where you have a slashing on a consensus layer that basically then means your application is no longer secured. But the way these things are designed is you actually wouldn't know. And so this would be something that any sort of restaking application would really care about. Yeah, these get a little bit more speculative, kind of like I was suggesting, but I think even for MeV management. So one that's fairly concrete, there's this notion of registering your validator when you use know if you're running a validator in this room, you've probably heard of boost and you probably are running it. And one thing you could do in pools is basically try to rug the pool by changing this registration at the last moment.
00:21:45.110 - 00:22:32.660, Speaker A: And there's not any really way to get around this, at least with the current constructions, because there's no way to verify this behavior. One thing I'm trying to do is move towards a world where these registrations do end up on chain, so that you can then start to say, okay, well, maybe your operator in the pool is actually bonded, and you could imagine fraud proofs against this type of attack. So again, just improving trust assumptions all over the place. There's something here. I'll just say this is like, well, so what I said here was iterating towards an EPBS world. There's this whole research topic of this thing called PEPC. The way to think about it is rather than have the auction of medboost in one particular fixed format, you could imagine this being programmable.
00:22:32.660 - 00:23:06.780, Speaker A: Some would say that this is kind of what Eigen layer is driving towards. They're like very complementary ideas. Either way, you could imagine having access to the kids'estate helps you start to build these tools. Even today, for example, in EPBS designs, we think we're going to likely have builders bonded on chain. And you could prove that fact very much like you could if a validator slashed or not. Yeah, I'll just leave this here. If this is like stoking any ideas, let's chat afterwards.
00:23:06.780 - 00:23:43.800, Speaker A: And I think that was it. Otherwise, yeah, part of the EIP is that there's access now to this thing in a trustless way. And I'd really rather just be surprised with some new stake pool idea you come up with, or any of the other things. There's probably some overlap with light clients. I was trying this morning to think of a cool way that it maybe improves bridges, all of them. I was like, well, no, you could probably do that on the e already, or it didn't really make sense. But that being said, if you think of something afterward, I'll actually drop my Twitter handle way over here at the beginning.
00:23:43.800 - 00:24:00.690, Speaker A: We'll just loop back. Dms are open. Let's chat. Any questions?
00:24:05.780 - 00:24:07.570, Speaker B: Yeah, I want to ask.
00:24:08.180 - 00:24:28.330, Speaker C: I know you sound like storing historical roots right now, but is there a way of maybe doing that? If you use just store all the roots in a mountain range or some other mechanism apart from a ring buffer, is there a way of maybe providing historical consensus state as well?
00:24:30.220 - 00:24:36.830, Speaker A: Well, I mean, you could prove any of the consensus state that you want, right? So I guess. How do you mean history?
00:24:37.760 - 00:24:47.724, Speaker C: Store all the blot headers, or store all the roots from the past in some data structure and then provide a proof that it exists within that.
00:24:47.842 - 00:25:05.190, Speaker A: Right. So maybe what you're asking about, there are data structures on a consensus layer that commit to all historical states and all historical blocks. So that's actually probably worth pointing out that once you have this one route from 4788, you can basically prove like anything that's ever happened, which is really cool.
00:25:09.400 - 00:25:47.040, Speaker D: No more questions. Hi. So I had a question about the choice of design, like how this fits into the EVM and sort of how you landed on a pre compile. I know this is similar mechanism with the execution layer like block hash as an opcode that has a similar logically circular buffer where it's like you're only able to go 255 behind. And then the second sort of follow up question is why sort of put the state into the pre compiled contract itself instead of just treating it like a similar sort of like the execution layer, like magic value that it just holds onto an external storage.
00:25:47.780 - 00:26:22.350, Speaker A: Yeah, this is the point I was making about stateless clients. It's like much cleaner just to. Not really. There was even another eip to get rid of the block hash thing and do something very much like this. If we do want to get to a world where we're say, with vertical tries where everything is under this one route, then you can start to make proofs about everything very seamlessly. Even if we were to, I'm actually not sure how they're thinking about this, but if they don't change the block hash, the way it works, then you'll be able to make vertical proofs about whatever. And then also you'll still need to have this look aside thing.
00:26:22.350 - 00:26:51.110, Speaker A: Yeah, it's just like kind of an analogous of the sort of existing design, and this is a way to improve it. And then again, it will facilitate making proofs about the state if we move to paradigms like Berkeley tries. Does that make sense?
00:26:51.560 - 00:27:10.700, Speaker D: One small follow question, I guess. In devising these eips, do you consider, much like the effect that hard forks have on layer twos or other things that are somewhat EVM based, was that influencing the choice to use a pre compile to not intrusive opcode, or is that lower priority?
00:27:11.520 - 00:27:54.670, Speaker A: Yeah, I mean, this is actually a really good question. You could imagine mapping this to layer two and sort of actually, I'm not even really sure what that would mean. So there is actually optimism, for example, wants the same architecture of having, there's like a consensus node, an execution node, but I don't even think they really have a notion of consensus block in the same way. So I'm not even really sure what that would mean. And yeah, I guess the answer to your question is no one's really been focused on that, but we probably should have been a little bit more. Yeah, I know. It's something we generally think about within these core dev circles around l two compatibility and how they use it.
00:27:54.670 - 00:27:58.590, Speaker A: Yeah, it's a good point.
00:28:03.520 - 00:28:04.590, Speaker D: Someone else.
00:28:09.700 - 00:28:37.130, Speaker B: This is not super heavily linked to this subject. I might be a bit off topic, but I'm impressed we're at this level of connection. Although I can't access from the EVM to something simple like the transaction hash. I don't know. Do you know why?
00:28:39.180 - 00:28:42.680, Speaker A: The question is, why can't we get transaction hashes in the EVM.
00:28:43.340 - 00:28:59.970, Speaker B: Yeah, and seeing your talk, it makes even less sense to me than before, that this simple feature isn't possible, or maybe it is, and I just don't know.
00:29:00.740 - 00:29:41.080, Speaker A: Yeah, so already today, even before this, this block hash opcode that the other guy mentioned, from there, you can then get to, like, you could prove that this block header was like the pre image of this block hash. The block headers commit to all the transactions. And the kind of downside there is that one thing is the proof would be much bigger because there's just different data structure that just needs a lot more stuff to actually write the proof. So that's not great. And they're like, generally people find them unwieldy to work with this. Like Merkel, Patricia, try, if you've heard of this, so you can do this. And I mean, someone correct me if I'm wrong, but almost certainly, yeah, you would go from the transaction try route and you can make a proof down to some transaction hash.
00:29:41.080 - 00:29:50.930, Speaker A: So you can do that today. And then also too, we don't have the transaction ashes on the Cl, so this actually doesn't touch this, but you can already do your thing today.
00:29:51.620 - 00:29:53.490, Speaker B: Okay, thanks.
00:29:57.460 - 00:30:01.820, Speaker D: Anybody have a question? Thanks, Alex.
