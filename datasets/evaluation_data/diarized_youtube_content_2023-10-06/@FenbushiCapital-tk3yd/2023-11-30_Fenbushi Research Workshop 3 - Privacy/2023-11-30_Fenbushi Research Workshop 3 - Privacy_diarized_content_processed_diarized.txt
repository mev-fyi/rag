00:00:07.620 - 00:00:19.784, Speaker A: You all the privacy connoisseur that we have gathered here. Thank you all for coming today. I know it can be sometimes seen.
00:00:19.822 - 00:00:41.852, Speaker B: As a bit niche topics, privacy in the blockchain space, but regardless, it's a very important, I guess, properties that we should all values for broader crypto communities as well. So here for our first speaker, we have Matt from Puzzle.
00:00:41.916 - 00:00:43.810, Speaker C: So I'll let him take over.
00:00:48.120 - 00:01:34.176, Speaker B: All right, you guys going to kick this privacy talk off with something I like to do at every privacy workshop? This is one of favorite Sundance film festivals. Well, yeah, you can read it right there. But I do this because we've been working on privacy tech for onchain. Orgs for like two years now. And we get mixed results whenever we try to say like, hey, do you guys want privacy? Hey, how do you value privacy relative to other people? So I like to do a little poll at the start that says, okay, we have fun, we have privacy. You don't want to be naked or exposed to everyone. And we have money.
00:01:34.176 - 00:01:50.616, Speaker B: Of these three things, can I get a raise of hands if the one that you would kill would be fun? Can I raise a hands if the ones that you would kill out of.
00:01:50.638 - 00:01:51.930, Speaker C: These three would be money?
00:01:55.100 - 00:02:17.936, Speaker B: And last but not least, privacy. You know, it's a world of trade offs and if you have to choose, just like to see the crowd. So my name is Matt, I'm at Puzzle and here to talk to you about private multi sigs programmability and challenges with private shared state.
00:02:18.038 - 00:02:18.364, Speaker D: Note.
00:02:18.412 - 00:03:16.404, Speaker B: This is Alpha. These are really poorly thrown together from a couple of different slides. And we're planning to come out with more formal estimations of all the work that we've done in December. So jumping into it going to go over about Puzzle and some of the things that we're trying to do in the world and some of the things that we have already done as far as products, research, development. Then I'm going to dive into some of the challenges with multiparty privacy that we found, some of the solutions that we built like MPC private multi sigs on Aztec Connect and then programmable private multi sigs on Alio. And then look at some of the takeaways with the future of the client stack and blockchains in this new programmable, privacy World. So going in about Puzzle, what do we care about? Well, what are we even trying to do? Well, we think that there's a lot of problems in the world.
00:03:16.404 - 00:03:20.368, Speaker B: Like maybe pollution in the oceans isn't.
00:03:20.384 - 00:03:21.428, Speaker C: Being solved fast enough.
00:03:21.514 - 00:03:55.340, Speaker B: Climate change may not be solved fast enough. Inflation is pretty bad, especially here. People are losing their jobs, they're not getting replaced with things, so then they're getting sad. And then they take antidepressants, which makes people unhappy, which is good for the pharmaceuticals. So they get more money, but not exactly good for the everyday person. And on top of that, we step ourselves because we're trying to cope with all these problems in the world. So what do we do at Puzzle? We believe we can solve these puzzles with what we call a dynamic collective companies.
00:03:55.340 - 00:04:27.610, Speaker B: It's our take on what an onchain.org could look like in the future. But like, dude, what does that even mean? It means we care about bringing people together and multiparty tech, which is what we are focused on. So what have we done? We were founded in the wake of Constitution Dow as Nucleo. We built a wallet and private multisig solution on Aztec Connect. We also built the first ever private public Dow and private public Dow fundraiser with Constitution Dow Two. At the end of last year, I'll be walking over the solution and how we did a private multi SIG there.
00:04:27.610 - 00:04:53.570, Speaker B: And now we have a wallet with multisig and multiparty games on Alio. So we also have a multiparty stack. If you guys were interested in builders and trying to build your own multiparty games. Coming soon. If you guys want to see our wallet, it is there. If you guys want to take a picture of this one or it's recorded, that's a link to try it out there. And same with the mobile one there.
00:04:53.570 - 00:05:36.864, Speaker B: And if you want to play our game, it's there. Or you could just go to Puzle online. So what's hard about multiparty privacy? Well, I like to start this off because we care about organizations and looking at a simplified view of an organization and its shareholders. So typically a business can keep its own information private to itself. So anyone from the outside that they interact with, like shareholders, like lenders, customers, suppliers, employees, state and society, they don't have full transparency into everything that the business is doing. Can you guess what this looks like in web3? If you're trying to run your business on chain today, what do you believe? With all exactly. It looks like this.
00:05:36.864 - 00:06:11.070, Speaker B: You got no privacy anywhere. So obviously we want to try to get to this. And one of the ideas is like, okay, with let's make a private multi SIG on Aztec Connect. Let's bring ZKPs, maybe fhe FTC. Can we get this? This is the goal, right? Well, naively, if we just bring ZKPs and privacy on Aztec to our private multi SIG just to start, it actually looks more like this. Everything is opaque to everyone. So that's not good.
00:06:11.070 - 00:07:06.172, Speaker B: Even the people inside the business, it's opaque to each other. So how do we solve that? How do we get from that to that? I also want to point out smallly here that is this even what we want? And I would argue, no, that's not what we want. We want something closer to this where, let's say I as a business, want to share some certain data to the shareholders. They probably don't care about the logs on our servers probably care more about, like, hey, how much revenue have you been making since you've been around for two years? Tough questions like that. But we think that something like this is more accurate. Different parties are going to want to see different data because they value data differently. So how do we actually get from this to them? Well, the challenge with ZKP based privacy chains okay, this meme is way too fuzzy and small.
00:07:06.172 - 00:08:13.520, Speaker B: I'm sorry, but it's basically just saying that by locally executing things, we have now sharded the application state, which means that if I locally execute something and we are on a private multi stick together how are you supposed to see that thing if the state is only on my local device? Which I like to summarize by that movie called Honey, I sharded the application state. So what are some solutions to this? Let's look at what we did for private multi sigs on Aztec Connect. Getting into some more technical things here. What does this actually look like with the information state? Well, a person has plain text and they encrypt it with a view key to make ciphertext and nullifiers. And what gets posted on the chain is the input nullifiers and output notes and a ZK proof of what you've done. What does the ZK proof actually do? Well, it converts these two input notes into these two output notes, and it checks that it's a valid signature against the person that is listed as the owner on the plaintext in those notes. Then you compute whatever transition you're trying to do, execute and post that whole proof of that computation on chain.
00:08:13.520 - 00:08:39.476, Speaker B: A lot of words to say that there's two different keys. No, that got screwed up. I'm sorry. A lot of words to say that there's two different keys. And that's all I want to point out, that there's a view key that encrypts things. So it's encrypted there and there's a signing key, spending key, however you want to do it, there's, listed there with Aztec Connect. At the start, what they were doing was just hijacking your MetaMask to create on the fly.
00:08:39.476 - 00:08:56.850, Speaker B: If you're in your MetaMask, a view key and a spending key nocturn also just came out. So I tried adding it to the slides too, because they do the same thing, too. If you see that sign up message in your nocturn spending key, et cetera, also shout out Nocturne. The discount. Check them out.
00:08:58.020 - 00:08:58.770, Speaker E: Yeah.
00:08:59.380 - 00:09:11.076, Speaker B: So both of these keys are both stemmed from your local MetaMask. Have you ever seen a dow just share each other's MetaMask, seed phrases with each other that seemed like the future of onchain works?
00:09:11.178 - 00:09:11.780, Speaker E: No.
00:09:11.930 - 00:10:02.704, Speaker B: So how do we do this with the safe? Well, we looked at a bunch of ways to do this with the safe, and there's like, some methods that you could potentially do, but at the end of the day, you're not really going to get there with the safe. We tried building some extra modules and it was essentially doing what we ended up doing here, which is, okay, can we make this spending key? This is what we care about being multiparty. We care about, hey, you need two out of three signers or two out of two signers to be able to update the state transition. What we don't care about being multiparty here for our private Dow use case was the view key. We said, hey, that can be an encrypted one and shared amongst everyone else. But what we really don't want is for any single person to be able to update that state without it. So that's one NPC solution.
00:10:02.704 - 00:10:48.640, Speaker B: Speedyme SIG is a N of NPC algorithm to split up keys and these things together. So that is what we did there. That was our architecture for a private multi SIG and then for a private public Dow constitution dow two. We ended up having like public safe multisig and doing NFTs that you had purchased for the fundraiser campaign on there. And we had our nuclear multisig inside of Aztec and we used this mode to have some proxy on NSDS there. So this ended up being everything that we had a lot of work and that's just for the multi SIG. That doesn't even get programmability on signing rules.
00:10:48.640 - 00:11:21.870, Speaker B: That is just to force like, okay, you have two or three signers as an NPC algorithm normally does. It's hard to actually programmable NPC algorithm without some rules layer to force that programmability. So now I want to take a look at solutions to programmability like what we have with ayla right now, just a quick time. Oh, I forgot to delete these. I'm sorry. All right, I'm going to run.
00:11:23.860 - 00:11:24.432, Speaker D: Through this.
00:11:24.486 - 00:12:12.460, Speaker B: All right, so what you guys were looking at before was a small like N to one multiparty situation where we have N as in four signers on one account. So that's kind of like breaking down what multiparty really means. There's a ton of different multiparty scenarios. Like, I even argue later that Instagram and social media is a multiparty scenario as well. But in addition to a private multi stick there sorry, stuck with the SpongeBob theme. There's also a one v one multiparty scenario where let's say I am playing you in a game with ping pong. There's one game of ping pong that is between us two parties and that's what I'm going to walk through here.
00:12:12.460 - 00:13:20.788, Speaker B: So we have a game called Where's Alex? Which I think if this recorded, you guys can see the QR code at the beginning, but it is a one v one game where it's pretty naive. I don't have my coin on me right now, but just to explain the game of Where's Alex is, I have like these headphones and so I am going to challenge someone and say like, okay, which hand is the headphones in? And I'm going to put money in a multi SIG and say, okay, if you guess right and you put money in the multi SIG, then you win and you get all the money out of the multi SIG. If he gets wrong, then I win and I get all the money out of Alex. Prudent is just the CEO of Alio, built this on Alias. So we're just having fun. Where is Alex? So break this down on some slides. You have a challenger, they're the ones that are starting this game.
00:13:20.788 - 00:14:14.708, Speaker B: And you have like two boxes or two hands where you want to hide this beautiful little puzzle logo. And what the challenger is going to do is throw that money in a multi sick, put that puzzle somewhere in a box and they're going to send that to the opponent and say, hey, put money in a multi SIG and choose which box it's in. It's hidden to them which box it's actually in. But we still need a multiparty shared state to assure that I'm not just going to rug pull them and pull money out or anything. So they've got to put money in the multi SIG and then they can choose. And if they choose wrong, I'll reveal the answer and they get strong guarantee that, hey, it's the right answer and they were actually wrong and I'll get the money. So the game flow for this looks like is you have the challenger in red.
00:14:14.708 - 00:14:47.660, Speaker B: They'll compute something with their own. Every single state in this game is private to everyone, by the way. Nothing is ever revealed, like publicly. So person who starts the game, the challenger is in red. They do this first like, hey, we're going to start a new game. The person in blue will get that and submit their money into the multisig with their key and then with the multi SIG state, they accept the game and update the state of the game to say like, okay, now both the money is locked in the multi SIG. No one can back out anymore.
00:14:47.660 - 00:15:33.176, Speaker B: It's only up to whoever wins this thing. The guy in the red has the answer and he's going to reveal that answer. And based on what that answer is, he can update and finish the game as a multiple. So what I'm trying to show here is that there is a red account, a blue account, and a purple account. This may not show up well in the next couple of slides, but before we get there, can anyone guess what are some attack vectors here? If I am challenging you to a game, how might I screw you over? Yes, that is one. Anyone else? Any other? Okay, so one way I could screw you over is never responding. I just never reveal the answer and I'm just like, oh, you threw your money in that multi stick.
00:15:33.176 - 00:16:16.172, Speaker B: I'm sorry, I didn't really care about money sucks. That's one thing that you could do. And so we want to program some rules so that after a certain amount of time, the person in blue will be able to get either an automatic win, like, oh, we decided to make it the penalty on the person starting the game if they never respond and just make it an auto win to the blue person and then they can win the whole pot. Like you mentioned, you can just straight up lie about where you hid the answer. So I may give you these two boxes. I may have actually hid it in this box that I didn't even give you a choice to answer with, so that could happen. Also, the opponent can swipe left and just reject your stuff.
00:16:16.172 - 00:16:22.060, Speaker B: And you don't want your money stuck in multisig. So you kind of need to program all these rules.
00:16:22.900 - 00:16:24.352, Speaker E: So how do you mitigate these attack.
00:16:24.406 - 00:17:20.768, Speaker B: Vectors there's programmability with Leo. So it's on the new types of blockchains that you can have programmable private state with private smart contracts as you can with Aztec as well. And I have some takeaways for the future of the planet blockchain there. So one of the things that we found while doing this is that we can program these rules, but unconstrained circuits are needed to avoid some UTXO limitations on smart contract functions. So one of the issues here is that if I bet you ten USDC, UTXOs are like predefined. If you can't have unconstrained circuits, you have to define the number of UTXOs that you put into this multisig and the number that happen with every single multisig transaction. And that can be a problem.
00:17:20.768 - 00:18:28.176, Speaker B: If I put ten USDC in and maybe you have like three $5 USDC notes or something, UTXOs you can't ever match me and put your money in without joining those UTXOs together, which is both bad UX or if you want to use a custom token program and you don't put join split logic in there, then you'll not be able to So Aztec based has unconstrained functions for that. And another solution that happens there is unconstrained circuits and chains executions can solve some of the UX issues. So I will physically point out here that this is supposed to be purple and that's what I was scared it wouldn't show up. Well, but this is blue and this is purple. And on the UX of the app, what would be nice is, hey, you just submit this transaction with blue personal key and then this one with your purple one, the multi SIG key, and update that state all in one transaction. But one of the limitations in Alia right now is that you can't have chain transactions. You have to wait until this blue one gets posted on chain.
00:18:28.176 - 00:19:24.440, Speaker B: You have to wait a couple of minutes for it to settle, decrypt your records that have settled on chain and then use it to update the state at that game. Bad UX would really like unconstrained circuits and change executions to avoid that. Anyone can think of anything else that may need to be done to make this a better experience? Okay, maybe not. Wait, all that execution and encryption happens on the client device. It's private. So what does that mean? And this is the whole alpha for all of you guys to enjoy, we believe. And we have found that these gen three blockchains that are both modular and private, that can have local execution or global execution or anywhere in between is going to need a new client architecture.
00:19:24.440 - 00:19:53.760, Speaker B: What do I mean by that? You have gen three blockchains that act as a rules layer. You post your smart contract there, but you can actually execute some things locally. Your data could be stored on Celestia rather than on every single node that's running this thing. And then you have your client layer to access it. Right now it's basically just a key store to sign your messages in some way to retrieve the data from the chain. This is going to change. Also, all these things are just examples of different data here.
00:19:53.760 - 00:20:49.536, Speaker B: This may be hard to see next, I'm going to share this in a second, but just to frame the whole DAP setup that we have, again we have the challenger, who would you like to challenge? This is DAP setup. We have the opponent, you've been challenged except that wager or reject. And then we have the game multisig that's actually revealing the results and finishing the game. So on our rules layer, on our smart contracts here we have the game multisig which is allowed to call functions called accept game and finish game. So those are updating the game states on that multi SIG. We have the challenger which is allowed to propose a game and they have a private variable of Alex's location wherever they hit it and they can reveal the answer as well. Then we have the opponent that just submits the wager.
00:20:49.536 - 00:21:34.496, Speaker B: So we have three different parties on our rules layer that are in charge of executing different things. I've thrown the data store and execution stuff up there because you could define where you actually want to store your data if you're not trying to store anywhere else. So just going to throw some colors. There purple, red and blue according to the parties. And then I'll highlight again, you have rules, you have execution of those rules which doesn't have to happen by the nodes running the chain. That's the thing with like local ZKP client proving you're actually executing a state transition function on your phone. It's like edge device basically.
00:21:34.496 - 00:22:24.444, Speaker B: So these are the rules just put onto the execution layer and we'll see some things with that in a second. So you'll see propose game, submit wager, accepts game and reveal answer and finish game. I'll also note that this is in order of the way it happens in the game. First person proposes a game. Next the opponent submits the wager and then updates the state of the multi SIG. Last the challenger reveals their answer and finishes the game. So then there's data, the data associated with this game is game data the wager amount from each person Alex's location after you've accepted the game there is Alex's location guess an iteration of the game data and then also block height that's to prevent people from the timeout situation we're talking about earlier.
00:22:24.444 - 00:23:35.770, Speaker B: And then there is final state after the game is done there's the game data, the winner and the loser. So why I'm pointing this out and breaking it down is data is encrypted at every single one of these points and it's encrypted to either the challenger me who's shared the game, the opponent you guys or the game is multi sweep. So whenever I was talking about like hey, everything on this game is private, no outside world knows how degenerate you are if you're betting like $1,000 on some BS around like where is Alex? But you can't and this is the way that every single pieces of those data is encrypted. This purple and this blue is going to be tough. So game data encrypted to multi SIG each wager amount, each party put it in their own so they'll have that information. Alex's location is exclusively owned by the challenger and then Alex's location guest, the opponent will have knowledge of where that is but that also gets written to the game data block height is something public and then we have at the end the winner and the loser. Each party knows what the other one is because they have the multiparty state too.
00:23:35.770 - 00:25:03.120, Speaker B: Also we'll call that there is function differences. You can have a function done globally on public nodes, you can have a function done locally by an individual and then you can have a multiparty function as well. So highlighting I guess I changed the color, sorry guys, proposed game is done locally within individuals submit wager is also individual but accept game is the multisig reveal answer is individual and finish game is multisig. I'll point out that this client architecture isn't just specific, this should say where's Alex? Don't worry about trivia thing. So this is a well known thing. Woodai has kind of given talks on this before that ezk uniswap doesn't quite give you privacy because of that whole problem of private shared state and essentially what can you do to have private shared state? Well, there's talks around Fhe and ZK and Threshold Decryption, but what we want to say is that we have messed with all three of these. And that's where we started running into hey, you can break down multiparty privacy into different categories.
00:25:03.120 - 00:26:02.680, Speaker B: Like a small end to one, like a multi SIG doesn't quite mean full on Fhe or Threshold description schemes at all, but something like Penumbra, which is trying to build a huge private decks that anyone could use, actually does. So end to end DApps like constant function market makers or like Penumbra, they may need Threshold Decryption and Fhe. But for one to one DApps like this where's Alex game that may be asynchronous or you may need other things for real time or synchronous ones like Battleship, you don't need that. Same with one to end apps. This is like trivia social media depending on how you do it, may not need that either. And then lastly one to end to one and you could start breaking it down even further. But yeah, there are situations in which you just need one party to actually process a bunch of people's information and then just spit out the results.
00:26:02.680 - 00:26:11.688, Speaker B: So yeah, that's it. Four minutes.
00:26:11.774 - 00:26:13.370, Speaker D: All right, thanks.
00:26:17.020 - 00:26:17.640, Speaker C: All right.
00:26:17.710 - 00:26:24.444, Speaker A: So I guess actually before before I kind of open up to the floor.
00:26:24.492 - 00:26:27.456, Speaker C: For some questions, I also kind of.
00:26:27.478 - 00:26:30.944, Speaker B: Wanted to just throw some questions because.
00:26:30.982 - 00:26:33.536, Speaker C: It might kind of relate to the.
00:26:33.558 - 00:26:36.450, Speaker A: Rest of the privacy discussions here.
00:26:37.000 - 00:26:45.268, Speaker B: But I guess one question thinking that I was having was that, for example.
00:26:45.354 - 00:26:50.324, Speaker A: We had Ian talking about different private.
00:26:50.372 - 00:26:56.056, Speaker B: Executions on the previous cryptography days. And one of the things that she.
00:26:56.158 - 00:26:59.160, Speaker A: Was pointing at was the idea of.
00:26:59.310 - 00:27:05.376, Speaker B: Batching the states together. States in this case transactions and executions.
00:27:05.508 - 00:27:11.550, Speaker A: And how much you can batch kind of matters for how private your transactions actually becomes, right?
00:27:12.260 - 00:27:32.084, Speaker B: So to that point I see that there is ecosystem that is entirely private. There's an application that is locally private and there's a gadget that is only a feature private. So within this versatile privacy gadgets that.
00:27:32.122 - 00:27:34.276, Speaker C: We have in this space, how do.
00:27:34.298 - 00:27:42.424, Speaker B: You see those application level privacy and ecosystem level privacy adoptions to kind of differ over time. If you have any thoughts on that.
00:27:42.462 - 00:27:44.584, Speaker D: I guess this is also open to.
00:27:44.622 - 00:27:47.108, Speaker C: You all to kind of think perhaps.
00:27:47.204 - 00:28:40.824, Speaker B: Discuss about as well. If you guys have any opinions on that. Maybe a framework that we kind of have puzzle is like it's dual framework. No one wants privacy and a lot of people need privacy on some things and a lot of people don't want privacy on everything. So what we mean by that is everyone needs privacy that we have talked to with onchain orgs for having their funds on chain for hey, their strategic operations and what they want to do and they don't want to have their regular sales just automatically on chain. And then some of them actually do. Some of them want like hey, we want transparency on what this new initiative is doing.
00:28:40.824 - 00:29:40.792, Speaker B: People may propose like at MakerDAO, for instance, someone proposed like a fun budget and enjoyment budget and they were like, we would never make that thing private because that should be under everyone's scrutiny to make sure that the dollars are being utilized. Well, it's almost like hands if you guys want the government to be able to just spend your tax money privately without ever being able to audit it. Yeah, you kind of want the public, so there's some things that you want public, but everyone wants to have that private option. For us, we kind of think like, hey, size matters around. You don't want a bunch of specific UTXO node sizes because it may give away your privacy. But at the end of the day, that's probably fine for most people as long as they just have the option to have private state. That's just hard for other people to get to for their account balances.
00:29:40.792 - 00:30:28.700, Speaker B: So it's really like account balances, asset issuance. We think those, yes, some people may be able to backtrack and say, okay, this may actually be theirs, because we could tell that there's a pool of 25 and there's only been two people that have gone into that pool. So it's probably one of those two people, and they probably have less than 25. We think that's like a fine trade off so long as you can at least hide it from the average person. But, yeah, it's kind of like everyone should have account balance level privacy. A lot of people are going to want to have both, and not as many people are going to be super concerned about how much information they reveal on the edges as long as there's sufficiently large privacy puzzle.
00:30:31.280 - 00:30:36.944, Speaker C: Fair enough. Any specific questions that you guys may.
00:30:36.982 - 00:30:43.116, Speaker B: Have about this puzzle and the private.
00:30:43.148 - 00:30:45.810, Speaker C: Multi six stuff that they've been working out?
00:30:47.140 - 00:30:47.890, Speaker D: Okay.
00:30:48.660 - 00:30:49.744, Speaker C: All right then.
00:30:49.782 - 00:30:52.400, Speaker A: I guess a round of applause for Matt.
00:30:55.720 - 00:31:51.316, Speaker D: Thank you, everyone for coming to Fimbushi's privacy Day. Hearing about privacy, I'm going to be talking about our work at Aztec labs and specifically the private roll up we're building myself. I'm Adam Domrad. I am a full stack software engineer at Aztec. I work on various projects, kind of done a bit of everything you could say and going to get into it. So we're building a privacy focused roll up on ethereum. So layer two, and I guess I'll start by saying what it means for us when we're saying privacy, because I think as the previous doc alluded to, there's various definitions of levels of privacy and what's private to who I'll start with, differentiating from the EVM.
00:31:51.316 - 00:32:14.072, Speaker D: So the EVM, you could kind of say, one could argue that it's not exactly revealing all your information or anything like that. It's not listing your address, where to find you. You're kind of just a number in the system. And one could say that already there's a good amount of privacy in the EVM. If you just think about you're synonymous.
00:32:14.136 - 00:32:15.650, Speaker C: You'Re not giving your name.
00:32:16.740 - 00:32:28.528, Speaker D: So why would we be disappointed with the level of privacy of the EVM? And largely that comes around to the idea of transaction linking, the idea that once you say you've done something serious like an on trade mortgage, if we're.
00:32:28.544 - 00:32:29.156, Speaker E: In a world where that.
00:32:29.178 - 00:33:40.970, Speaker D: Was possible, and then you go to buy a coffee, and then you leaked all of that, or say that you're some notable figure and you found some funny NFT project, and you really don't want that to be implicit endorsement. And so you have to find some way or just give up on the idea of interacting with something fun. And this diagram, this very serious diagram here kind of illustrates our illustrates our position on our kind of realization that as you tug on the string of privacy and you want to make a system that extends the EVM and what it can do that you can make various programmable systems that as you tug that string, really, you do start to look away from the EVM and you start to look at systems where things are more possible to make private. And the EVM does fall short in that respect. One of the fundamental things about privacy is that if you have information, you own it. So if you think about what the EVM is based on, the BBM is based on account models. It does cool stuff like pools and order books are possible.
00:33:40.970 - 00:34:32.504, Speaker D: Stuff that wasn't possible on Bitcoin. And the reason that they moved to the account model and all that stuff is really cool. Also, actually, Aztec doesn't just have privacy, even though it was sort of asking for extra complexity. We very much wanted the public world where people can do finance and all the counterparty stuff like lending. And so the EVM, to enable this, moved to an account model. Whereas actually, the original Bitcoin model of kind of everyone having notes or UTXOs, as they're called, in very technical jargon, is more befitting privacy and a system that is built on these notes. So if you think about this fundamentally, why are notes better for privacy? And the idea really comes down to, if you're owning data and you're operating.
00:34:32.552 - 00:34:34.076, Speaker E: On it, you need to be able.
00:34:34.098 - 00:35:22.356, Speaker D: To operate on a complete picture of the data. And if you're sending someone money and you have just a shared variable representing the money, you can't really alter data you don't own. In a private world. There's no such concept. So I'll continue to talk about this, but essentially, the EVM model was something that we had to walk away from. And really, it also led us to kind of reimagine things and kind of do some best practices that work in a privacy world that the EVM doesn't really enable. So what does privacy mean for us, then? It means that we have a private identity that beyond just being synonymous, actually, your identity is never leaked.
00:35:22.356 - 00:36:27.250, Speaker D: The identity is not attached to the transaction. You have private state, the things you're operating on, the things you're changing, only you see the full picture. The system is verifying that you're doing essentially state transitions, but no one really sees what those state transitions are, which leads into the fact that you're executing functions essentially on the blockchain, but those functions are just known by you, and the details are just known by you. And through zero knowledge proof technology, which is the key enabler here, we're able to validate those state transitions with the zero knowledge property, that those state transitions are valid. And that's it. And even in cases where this makes sense, the contract code itself could be withheld, say, that you're just operating with a few parties, and it makes sense for you to use the Aztec chain, but actually there's nothing in the validation logic that requires you to post that code. And if you're just operating with a few parties, you totally could do that.
00:36:27.250 - 00:37:08.044, Speaker D: So we kind of have this catchphrase of something happened. So if you load up an Astec Block Explorer, what do you see? It's just something happened. Someone did something to some state, some function, and some contract, but you don't see any of what that is. And this is really the concept of transaction linkage breaking. So you could think that if any of this was shown, you could create a link between contracts sorry, link between transactions. If you just see that some time of day people are using some contract, you might be able to infer something. If you see, obviously the identity match, then you can start to try to guess what kind of activity they're doing based on what's happening.
00:37:08.044 - 00:38:01.336, Speaker D: On the public side of Aztec, we really believe it's important to have as much of this as possible, because privacy is kind of a holistic thing that people are able to piece together. Things probabilistically by time of day, by activity, volume. So for privacy, you really need as many of these properties as possible. Before I do want this to be a technical talk, but I also think that it's important to motivate why we're building what we're building, what we actually can build practically with the technology. Because fundamentally, while I think the technology is super cool and I can talk about it in a vacuum, there's a reason we're building the technology. So the sort of things that we imagine building, I have these kind of categories, and it's kind of my take on it. Everyone has their own take, but I kind of view as the core categories of use cases.
00:38:01.336 - 00:39:03.132, Speaker D: So one of them is something, just something, I call it extending trust. You could imagine that there's somebody that has audited your financials. They're in a position of trust, and you do not want to for any statement about your financial position as a company. You do not want to go to them again and ask them for an attestation to that. And one of the cool things you could do is if some trusted party has attested to your financial state, just your raw data, and you post a merkel group, you could then completely privately with our principle here, something happened. You can show, say that you've never operated with a certain actor or that you're in a good financial position, you're solvent, your liabilities aren't bigger than your asset value, which like the asset value would be the current asset value in dynamic conditions. And all of this could be completely private and then we have securing funds.
00:39:03.132 - 00:40:25.420, Speaker D: So one of the big problems in crypto just in general UX, is that people might like to own crypto directly but they're scared shitless of it really because it's very high stakes password remembering there's very interesting things you could do completely privately. So you might hesitate to attach your account identity to your citizenship card unless you're in this privacy world. And one of the things we can do while breaking from the EDM is we can have native account abstraction and you can think of really cool ways to do account extraction like verifying with a citizenship card. And actually one of the cool properties of citizenship cards is they tend to have so not only a cryptographic signature in them, but they tend to have if you reissue that citizenship card, there's a provable relation between the citizenship cards. So you have this idea that you can go to a party that we all have to trust at the end of the day the government and actually redo your identity and still be able to access your funds even if you've lost this or you have to get a new card or something like that. I always believe in second factor auth and you might then have another fun factor like a touch ID or something similar. And again, this is all going through private state.
00:40:25.420 - 00:41:16.008, Speaker D: This is no one seeing that you were correlated with the citizen card or anything like that. Other categories governance, it's very important that democracies are based on this principle of private voting for a reason. No one should be pressured if there's a controversial proposal, you should be able to vote confidently how you actually see it and not feel pressured by the fact that publicly associated with their identity there's finance. This is just the core idea of the uniswaps, the ave's of the world. And Aztec still does let you build that on the public side. But the important thing is that you're able to bridge from the private side very easily and you'll be able to use all of these with a private identity. And then somewhat more niche we have games, so people do build on chain games.
00:41:16.008 - 00:42:14.960, Speaker D: So imagine you have collectibles, you have some collectible card game like Magic the Gathering and you have a complete private collection. So someone that's big in the field, like vitilig, he doesn't hesitate to purchase your card because he doesn't hesitate that there's some implicit he's not saying, oh, yeah, this is a great product, he's just curious. And he doesn't have to hesitate with onchain activity that you would naturally do with this idea that people are going to associate the link and make inferences or anything like that. And there's also cool things you could do with ZK cart games. Like because ZK is succinct, you can post the proof of the result of a game and associate that with the NFTs that are actually on chain, the collectibles and all of this. Privately you have a completely private tournament and it's pretty cool. And there's analogies to protocol design as well.
00:42:14.960 - 00:43:21.584, Speaker D: You can imagine like any game, protocol design is often very good in game theory. So that's all I'll say about use cases. Now, to kind of go back to the technical side of things, I'm going to talk about how we build private abstractions because the whole idea of programmable privacy is kind of new and at Aztec we're making a new execution environment. So we had the task of taking all of this stuff and zero knowledge, which at first was a theoretical idea, and then became abstracted slowly from polynomials to circuits and Circum. And we're trying to make a developer experience that rivals, say, what the current solidity of user experience is. The fundamental technology that enables this for us is Noir. So Noir is a language that can compile to a circuit, but looks like a traditional programming language.
00:43:21.584 - 00:43:58.050, Speaker D: In fact, it looks as identically as possible to Rust. So here's just a simple function of adding but it has all the Rust features you would expect. Well, I won't say all, but as many of the Rust features you expect that you've sent in a ZK environment that we have implemented. So we have structs traits, functions, obviously. And what happens behind the scenes is that these are laying constraints, so the constraints are implicit. There's things like overflow checks to keep you safe. And really the idea is to take the developer experience of ZK and move it to the next level.
00:43:58.050 - 00:45:14.250, Speaker D: And I guess I'll contrast it with some approaches that other people take, which is to do Zkpms of traditional programming language environments like say, ZK WebAssembly, taking WebAssembly by code and proving it instruction by instruction. That is a cool idea. However, to then do privacy, to actually do a ZK privacy, that is not sufficient. You actually need to systematically still introduce the concept of privacy, which is something native to Noir and B, that's a large overhead. While the idea with Noir is that we have an optimized Compilator pipeline that is generating circuits. So it's the same concept of anything you could do with Circom, which for the people don't know is kind of definitely higher level than writing polynomials directly, which is kind of what the technology is based on, but it compiles to circuits, which is kind of more of like analogy to hardware design than software design. So this is kind of bringing it back to what the developer experience that software engineers expect.
00:45:14.250 - 00:46:22.510, Speaker D: Okay, now I allude to the fact that our model is moving away from the account model to one of notes and specifically encrypted notes, but I'll talk about them in a second. So what's in a note? So notes are fundamentally notes are pieces of data and they exist in our system as the building block. Really, I'm going to be using the card game example a bit here. Just it's a clean one. So in War, we have our Aztec library, which integrates with the abstractions we built that make up the Aztec private execution environment. And the data that you operate on as you fetch it is comprised of notes, which here we kind of have the payload, which is the cost and strength. So you can imagine this in kind of a magically gathering environment where this would be the actual thing used by the protocol and the rest of the data.
00:46:23.300 - 00:46:25.052, Speaker E: Definitely the owner.
00:46:25.196 - 00:47:28.702, Speaker D: It's. What it says is the person actually that has made that note and is expected to use it and as well as randomness. So that if you know the inputs that you're not able to do stuff like pre image attacks and sort of trace by virtue of, oh, I'm going to assume that the data is this and then I'm going to see what the encrypted results would be and then I've kind of guessed it. So I affirmatively found that this encrypted node is in the system. So randomness just kind of removes that determinism and as well as the node header, which is something we kind of use internally. All right, so if you have an unencrypted node, how do you get an encrypted node? The fundamental answer is hash functions. So we hash this idea of storage slot, which is kind of an abstract identifier of where in the contract the note lives.
00:47:28.702 - 00:48:08.730, Speaker D: But again, it's kind of abstract. It's not a physical position in our data or anything like that. We have the contract address, some nonce for the transaction and the data inside. And that data, as we showed earlier, has the payload, has some randomness and it encodes the user, the owner. So we get a hash kind of hash 101. You can go this way, you can't go that way, but you cannot just look at the hash and open the note. And really, there's no kind of such concept as opening the note.
00:48:08.730 - 00:49:07.590, Speaker D: And these closed envelopes as you will exist in a private data tree and you can figure out where they are. Sort of, yeah, as a user, you know where your notes are, what they are. However, to anybody else looking at this, this is just opaque, these notes. Actually, there's a few things going on. The notes could be in any contract owned by any user and actually not all of them are going to be active. There's this concept of notes in the system, they may have already been used and we don't want to use the same note twice specifically for the idea I had of transaction linking. If you could provably prove that a note has been used eight times, actually.
00:49:07.590 - 00:49:50.260, Speaker D: You know that that's the same person in those eight transactions. And that's exactly the kind of thing we want to avoid. And how do we achieve that kind of transaction linkage breaking? The core technology is nullifiers. There's a nullifier tree and nullifiers are also in essence, a hash of the note, but they're a different hash. And the two hashes don't have a clear relationship just looking at them. You can't just take one hash and say, oh, I know that this nullifier is corresponding to this Note hash, that is the encrypted node. So no one really knows.
00:49:50.260 - 00:50:55.116, Speaker D: Looking outside of the system, this is obviously something you know about your own notes, but no one looking outside the system knows which notes have been used. And this is kind of one of the fundamental ways that privacy is achieved through being able to break this transaction link, because no one really knows you've created a note, but there is no link to the point where you actually use a note. And that's kind of a key concept then, from here, that's sort of the basics, if you will, of the data model. And then on top of Noir, which is able to make zero knowledge proofs of state transitions, we use this data model to create higher level abstractions. So in our card game example, you don't just have one card note. So how do you operate on multiple card notes such that you can play a game? So in this card game example, there is incomplete information. Your deck is just known to you at the start of the game.
00:50:55.116 - 00:51:54.636, Speaker D: People might not know even what you own, so they might not know the cards that went into your deck. They're relying on the ZK proofs to step by step verify the validity of everything, such that they know you're playing by the rules of the game in the same way that you kind of just know by virtue of physics that a face down deck contains cards. And you're kind of able to know that people are being honest without really knowing what is in their deck. And then you might have the concept of a hand, and that is private, and you might have the concept of, well, at some point there is going to be a public part if you're actually playing a game with someone. Okay, so in this deck, this is from our card game example current. Currently in our repo, we have this concept of a set. So what is a set here? A set really is a way to derive the storage slot of this gnome.
00:51:54.636 - 00:53:06.144, Speaker D: And it isn't really in the traditional sense, a collection. How do you operate? What's the mental model you should think of when you operate on private state? The mental model I think of is if you were just making things up, you could play a card game. You could just be like, I have this, I have this right. And all you really need to do from there is to constrain that all you need to do is, okay, yeah, people can make things up, but they can only make the right things up. And that's kind of the mental model I have of private execution. The idea that we have this tree that we could look at notes and see if they exist and if they're valid, they don't have a nullifier, then we could take what the user is telling us, which is, okay, yeah, I'm coming in with this deck, these are my card notes. The user is just doing this on their local device, but they're able to take this encrypted tree, make statements about it in noir, create a zero knowledge proof, and that's how we're able to actually make a statement about the game without revealing anything but that we are coming in with a valid deck.
00:53:06.144 - 00:54:14.494, Speaker D: And then from that valid deck we're drawing a valid hand. And at this point we've done enough private state transitions that we're ready to get to a point where we're actually going to reveal something to the other players and make some logic that actually interacts with the other people. Because fundamentally there is a strong private part to this protocol that is this game. But we are playing with counterparties and they need to know, we all need to show what we have and the public part of the chain needs to well, the public part is the only part really that can then take what everyone has shown and make a result. Okay, so just showing a little more about how you might operate, the user might be coming in and saying, hey, these are my cards, these are the cards I own. And we would in this example, it's actually sort of an example of the cards you have are wagered on the game. We're actually removing them from the collection.
00:54:14.494 - 00:55:02.980, Speaker D: If the user is coming in and lying about their cards, actually this will fail and they'll not be able to make a ZK proof that all these cards they're claiming to have, I'm going to remove them and wager them. They would just be blocked. So if this execution, if this noir actually is able to be proved, then we say, okay, we are satisfied that the user is not lying about their cards and that these operations can continue and that they've made a valid state transition. And then the user updates their data again. They're the only one getting the full view of what's happening and they're remembering that. And then when they need to do their next day transitions, well, they better have that data because that's the data that's valid for them. Just a technical thing.
00:55:02.980 - 00:56:00.114, Speaker D: The users are always able to reconstruct their data because unless you're doing something weird, everything is going to be posted on chain. You're going to be able to decrypt your notes because you have the keys they're encrypted on chain when they're created, but you're able to look at them and see, okay, yes, this is actually my data. So a user can always recover this view, but no one else can. Okay, so I mentioned that there's both a public and private part. So even though this code looks well, this code is still in private world but the public part is still in noir. In the public part of the asset VM, we need to connect to it. And it's not just a simple matter of calling the public part because what does that actually mean? So the private part is running completely on the user's machine but the public part is not.
00:56:00.114 - 00:56:43.170, Speaker D: It's actually taking the information from all the users. And some shared sequencer like in Ethereum is actually looking at these facts and computing something. What we really have here is this kind of idea of a message bus so calling a public function here. So in this example someone has joined a game and then we need to do something on the public side to show other people that they've joined the game. This is constrained by the fact that only the smart contract can queue this on game join so no one can forge it. And the smart contract will only do that if you have a ZK proof on the private side. So that is sort of how we bridge the private to public world and are able to play a holistic.
00:56:43.170 - 00:57:25.120, Speaker D: You can kind of imagine this in general as how you do a private mixed private and public protocol. And all of this is in water. The public part is compiled a bit differently for our sequencers while the private part is compiled to run on user's local device with circuits. And this kind of segues into how do we integrate with Ethereum. And it's kind of the same idea, the same idea of these message buses really. The public part has more to do with Ethereum than the private part has to do with the public part. So we have a message bus for public to private and we have a message bus from layer one to layer two.
00:57:25.120 - 00:58:14.302, Speaker D: And you can kind of see the different models I alluded to here. We have a private note model on Aztec and we have a public account model on Ethereum. Reiterate the UTXO model is the only model really suited here for local users could locally operate on their data. Say the simple use case of I want to send you funds privately or I want to send you funds publicly. The use case that I want to send you funds privately. If we were to use an account based model and we were just doing ZK proofs on some number, that is your number well actually I can't just do that on my device. That's the fundamental thing.
00:58:14.302 - 00:59:23.006, Speaker D: If we were to share this somehow, even there would be race conditions, because then it matters who does what transaction private data you unilaterally own the note model, the idea of money being represented by little notes everywhere, or some variable number of notes, I should say you can join and split them arbitrarily. That is fundamentally the one that you can build privacy on. And conversely, if you have something that is a shared global variable, it only really makes sense in the public world because again of the race condition idea. And if you had notes, they're generally not as good for something like a pool. The idea there is that you have the converse problem that if you're giving transactions in a public shared world and you're doing it based on notes, well, you're probably being a little too specific. You're saying what exact notes to use. And that's the wrong level of abstraction for public state, because really you just want to give the intent to operate on some shared sum.
00:59:23.006 - 00:59:30.598, Speaker D: You don't want to be specifying exact notes and then have a sequencing problem because oh, those notes were then used before you actually specify that you want.
00:59:30.604 - 00:59:32.502, Speaker F: To operate on them in this world.
00:59:32.556 - 01:00:34.006, Speaker D: As I'm saying that users, everything starts with the user's device. If you own the data and the data is not posted on chain, well really you're the only one who could do anything on the private world. We have this concept of a private kernel proof. And fundamentally that's the ZK Gadget that takes your private functions, your call, stack and it makes a proof that satisfies the sequencer that you have done things correctly, that something happened. But something happened by the rules of a system, even though no one really knows what rules exactly you operated with. From there we go into the public world of sequencers improvers and these operate together to as it says, sequence approve everything. So the public side is now running on the sequencer and the public and private kernels are being combined to create roll up proofs.
01:00:34.006 - 01:02:01.420, Speaker D: And those roll up proofs fundamentally then are what convinces ethereum that this whole system played by the rules. I'm not going to go too much into this, but this kind of shows the segregation of the private in the public world. Everything in the private world can't really be done in the public world, everything in the public world can't really be done in private world. For reasons I mentioned that any kind of operating on publicly shared variables, that's not really something you can do on your device, you're just in the wrong setting. And anything conversely that the sequencer, the sequencer is not in the setting to operate on, your data doesn't have the database I'm going into crazy detail on, but this is sort of a view of our actual struct that represents a private context and it's roughly what goes into a private kernel proof. There's ideas like the nullifiers you've created, the commitments you've created but really all of this becomes abstracted away in a ZK proof in a way that, yeah, you're showing that you've created nullifiers, but that's really it. It's not associated with any specific account or contract or anything like that.
01:02:01.420 - 01:03:06.670, Speaker D: The public and private parts of Aztec, this is how they integrate. We have a recursive system of proofs, we have public. Once we get the private proofs, we combine them with the public proofs and we have kernel circuits for both of them. The sequencer, similarly to what's happening on the user's device, is simulating these things, making witnesses the values that kind of go into the ZK proof, which then get constrained by the ZK proof and assuming that you're able to make the proof, that you're playing by the rules of the system. And finally, once the prover network has recursively combined the public and private proofs, we're posting a single proof to the ethereum chain. Sort of a view of how it happens. There's a prover network, all these colors of different provers.
01:03:06.670 - 01:04:05.730, Speaker D: We're making merge roll ups of the results that these provers have made. Multiparty system and the leafs here are both either the private or public proofs. This is kind of the last detail I have. The system we're creating is decentralized in this way. Not only are we trying to solve privacy, we're trying to solve the decentralization problem in layer twos. And the way we do this is not only do we have things like sequencer election, but we have these proverb networks that people can cooperate with to help the sequencer to actually create the final result and create the roll up in a way that many parties can be picked part. And if anyone goes down, the system continues.
01:04:05.730 - 01:04:43.018, Speaker D: All right, that's sort of the whirlwind of details I have here. Thank you for listening. Just as a final note, if you have anything here you disagree with or want to discuss our discourse forum for the Aztec network, by all means. If you just want to casually talk us on our developer discord, it is kept developer only, so don't worry about too much noise there. We have our documentation, which is mainly suited for if you want to play in our sandbox. So where sandbox is, well, we're not currently at Mainnet, but we do have an end to end sandbox. So it integrates with an EVM that's on your machine.
01:04:43.018 - 01:05:04.118, Speaker D: It's running prover list, but it is running more. It's running the whole stack. There's a few things missing, like these. However, this is the perfect time for people to play with this, tell us their developer feedback, just like the puzzle guys are, which is really helpful. And yeah, there's no better time to give your stay in the ASIC framework. Thank you so much.
01:05:04.204 - 01:05:05.000, Speaker C: Thank you.
01:05:08.170 - 01:05:21.066, Speaker A: I think that was a very thorough overview of the entire Astec stack from bottom up. I guess there was even something I.
01:05:21.088 - 01:05:26.380, Speaker C: Personally didn't, I guess, notice specifically on.
01:05:26.930 - 01:05:28.942, Speaker D: The proof that is coming.
01:05:28.996 - 01:05:37.102, Speaker A: Out of the private kernels and the public kernel. And maybe correct me if I'm wrong, as I'm understanding right now, the public.
01:05:37.156 - 01:05:40.578, Speaker D: Kernel is where you have the public.
01:05:40.664 - 01:05:46.686, Speaker A: VM executed and then in the end you will have a proof that represents.
01:05:46.718 - 01:05:50.082, Speaker C: The execution trace of the entire public.
01:05:50.136 - 01:05:51.582, Speaker B: Kernel execution, right, yes.
01:05:51.656 - 01:05:59.266, Speaker A: And then the private kernel, where it's more like each entries of that private kernel is going to be a client.
01:05:59.298 - 01:06:03.430, Speaker D: Side proof that is submitted by the users.
01:06:04.250 - 01:06:05.846, Speaker A: And then you kind of process all.
01:06:05.868 - 01:06:08.006, Speaker D: Of it verified through the private kernel.
01:06:08.118 - 01:06:10.694, Speaker C: Which then kind of recursively gets combined.
01:06:10.742 - 01:06:24.158, Speaker D: With the yeah, exactly. The whole user's call stack, they've already recursively done that and then what they send is just the final result. So they're kind of part of this recursive scheme. Got you.
01:06:24.324 - 01:06:30.386, Speaker A: Well, I guess anyone in the crowd that has some questions or want to.
01:06:30.408 - 01:06:33.170, Speaker B: Throw some stuff in the ring.
01:06:34.630 - 01:06:35.490, Speaker D: Dex.
01:06:39.510 - 01:06:42.658, Speaker E: Okay, about the pirate functions.
01:06:42.754 - 01:07:00.410, Speaker C: So can pirate function modify some public state? For example, if my pirate function is a swap function, can this swap function be used to modify the amount of token in some public contract?
01:07:01.470 - 01:08:01.600, Speaker D: Yeah, that's a good question. I think it's something that everyone learning Aztec has to first ask themselves. And there's the things you can represent in private world, there's the things you can represent in public world and really they kind of operate as two blockchains that have a message bus and the data in the public chain. So what does it mean to swap something in public world when you're just running this on your local device? Can you then just go into something that's about to at a later time run on the sequencer and do it? Not really. So the only thing you can do is you can attach a message that is going to go on the contract and in the public world the sequencer, the sequencer can pick up that message and complete your action in the public world. So things like if you are operating on data that is known to an unknown number of parties, then you're in the public world and you're kind of using this message bus analogy to operate between private and public.
01:08:03.090 - 01:08:06.400, Speaker C: David actually I have a question on that.
01:08:09.830 - 01:08:10.580, Speaker E: Wait.
01:08:14.790 - 01:08:17.940, Speaker B: Is there some sort of like.
01:08:19.030 - 01:08:25.218, Speaker D: Information leakage that would be impossible by interacting with the private?
01:08:25.314 - 01:08:25.960, Speaker E: Yeah.
01:08:28.250 - 01:08:51.680, Speaker D: There'S a fundamental information theoretic thing of you need to publicly say something for the public world to be affected. And that is where you have to be careful, because there's definitely ways you could have a nice private design. And then if you're just like, oh, I'm just going to call this public function every time, then you might be in a situation where, in practice, the public part is leaking basically everything.
01:08:52.050 - 01:08:54.942, Speaker C: Right. They can guess basically what you're trying to do.
01:08:54.996 - 01:09:19.480, Speaker D: Yeah. So there's definitely design patterns there of like, okay, so if you're doing a swap you might be careful about what goes into that. But I think that there's going to be that small leakage to be able to do stuff with public which is similar to as if you exited to ethereum to do something, you have to go outside of Aspen, that kind of thing.
01:09:23.050 - 01:09:25.722, Speaker B: I think same thing happened for the Zcash, right?
01:09:25.776 - 01:09:29.978, Speaker A: Because Zcash, they have like public account and shell account.
01:09:30.064 - 01:09:30.506, Speaker D: Right.
01:09:30.608 - 01:09:37.326, Speaker B: And even though it's private champ. But 99% of transaction on Zcash is.
01:09:37.348 - 01:09:40.426, Speaker A: Actually Traceable because of what you just described.
01:09:40.458 - 01:09:44.414, Speaker B: Like interaction with ethereum and interaction with a public state.
01:09:44.612 - 01:09:45.022, Speaker C: Right.
01:09:45.076 - 01:09:55.658, Speaker B: If I transfer money to public state, basically this is a part where your money trees can become public, can be leaked, right?
01:09:55.764 - 01:09:56.642, Speaker C: Basically, yeah.
01:09:56.696 - 01:11:03.562, Speaker D: I think the thing here is that privacy is always holistic. You have to be careful about you could easily have someone just looking at your internet traffic, for example, like say it's a good idea to just use astic this web provider that's going to do things for me, then you could easily get a problem. Even though we built everything correctly. You've been practiced traceable and I think that's similar that if you're operating on the public side you have more concerns, but there's just more to consider. But the leakage should really just be confined to okay, at this time there is someone in the system that is doing a swap and if the majority of your transaction history, most of Zcash is not private. So if you're just like doing a few things in private and then mostly public, then yeah, you're in a position where you're not really being holistically private. But if you're careful about how you design things that really just at the edges you call into a private public world.
01:11:03.562 - 01:11:05.210, Speaker D: I think the trade off successful.
01:11:07.470 - 01:11:13.638, Speaker B: Another question. Is Aztec fully EVM. Like bicycle level compatible?
01:11:13.734 - 01:12:04.378, Speaker D: No, that's actually the first reason sort of trying to demonstrate that our public side is really optimized to be a holistic experience with our private side. And for Noir to have one smart contract that is able to go between private and public in all the same syntax and semantics. Sorry. No worries. Beyond that, the Zkevm overhead is crazy. People are talking about Ckevms that need a terabyte of Ram, whereas we want a public VM that you can do in like 16GB of Ram. So the EVM model for the private side, it's just incompatible for the public side.
01:12:04.378 - 01:12:29.780, Speaker D: It's too different from our private side to have a nice user experience and it's also too expensive for us to have a decentralized network. So, yeah, we have broken away from EVM, and we're trying to take advantage of that intentional break to do stuff properly. Like have account distraction from the get go. Have it's part of the core network so that people don't have to bend over backwards like they do on EBM and just rethink some things that were kind of dangerous in EBM as well.
01:12:30.150 - 01:12:31.106, Speaker B: Another question.
01:12:31.208 - 01:12:31.762, Speaker E: Yeah, no.
01:12:31.816 - 01:12:36.294, Speaker B: So for example, if one day Uniswap team decided to build a decks on.
01:12:36.332 - 01:12:38.722, Speaker C: Aztec, they have to build two solutions.
01:12:38.786 - 01:12:40.934, Speaker B: One is for the public, one is.
01:12:40.972 - 01:12:56.554, Speaker D: For the private one. Right? So not really. I mean, in the Uniswap example, there's really not much to build on the private like the public. Uniswap design is going to be similar.
01:12:56.592 - 01:12:57.898, Speaker C: To Uniswap on EVM.
01:12:57.994 - 01:13:22.440, Speaker D: And then on the private side, really, there's the idea that you have a private identity that comes from the private side and then you call a public function. That's what Uniswap would build on the private side. Well, there's not too much. It's really just the fact that if you have it on the public side, you have first class access to private identities from the private side.
01:13:23.930 - 01:13:25.254, Speaker C: I think I just want to also.
01:13:25.292 - 01:13:26.120, Speaker B: Add that.
01:13:29.130 - 01:13:33.498, Speaker A: Please argue with me if you don't think it's correct, but I.
01:13:33.504 - 01:13:36.762, Speaker B: Personally think that any privacy infrastructure that.
01:13:36.816 - 01:13:42.074, Speaker C: We see today fundamentally is a type.
01:13:42.112 - 01:13:47.882, Speaker B: Of a mixer in disguise. It can exist in many different forms.
01:13:47.946 - 01:13:50.474, Speaker C: But it's sort of like doing the ball mixing.
01:13:50.522 - 01:13:59.978, Speaker B: And as stated previously, if you have a small specific applications with privacy enclosed.
01:14:00.074 - 01:14:02.114, Speaker D: On paper on top of it, but.
01:14:02.152 - 01:14:09.026, Speaker B: Whenever it interact with public states, it starts leaking permissions. Right? Just like giving hints of, okay, this.
01:14:09.048 - 01:14:12.710, Speaker C: Is what it's trying to do, liquidity change. Okay, this is what probably happened.
01:14:12.860 - 01:14:15.430, Speaker A: So I think you can argue that.
01:14:15.500 - 01:14:19.298, Speaker B: The bigger the privacy enclave is covering.
01:14:19.314 - 01:14:22.310, Speaker C: The ecosystem, perhaps beyond just single DApps.
01:14:22.810 - 01:14:35.354, Speaker B: It probably provides more avenues for privacy that can't be easy to track. So the question is like, okay, do you have only single application that has.
01:14:35.392 - 01:14:38.390, Speaker C: Privacy or do you have ten hundred.
01:14:38.480 - 01:14:40.718, Speaker A: Application that has privacy that is also.
01:14:40.804 - 01:14:46.030, Speaker B: Composing, interacting with each other? I think that would have very different privacy tracking.
01:14:47.090 - 01:15:21.980, Speaker D: And just one thing I want to mention is that we definitely believe in the spectrum of privacy, that there's a big difference between complete on chain transaction linking which happens on EVM, and the idea that you have some so there's not everyone is trivially. Seeing that you're associated with a project that might be a bit controversial, you're giving to some cause that you don't really want your public brand to be associated with. I think that if you look at the system and you're able to reason about things, that's fine for most people. There's sort of the level of privacy that you really need that's going to be different for different people.
01:15:23.310 - 01:15:55.106, Speaker B: And I think to go back to your point, even if you don't interact with the public state, say for example, you take Penumbra and I'm market making on Penumbra, the fact that you trade with me, I'm going to go around and to the other side of the trade, which means that I'm going to leak information. Even though you never touch any public state right, it depends. Probably the information leak is going to be way faster if you touch public state. But you will see the information in the case.
01:15:55.208 - 01:16:11.898, Speaker D: Sure. Because privacy is hard, which is dead. I want to reiterate not everyone needs full privacy, but the absolute transaction linking on EBM is the way other side of the spectrum that we kind of believe that people should have tools to.
01:16:11.904 - 01:16:20.090, Speaker C: Break away from the information leakage. I think leakage is really just relative.
01:16:20.170 - 01:16:22.766, Speaker B: To specific application you're going to build.
01:16:22.868 - 01:16:37.170, Speaker C: So for me, I think I'm very interested in dock pool. So for dock pool, what I really want to keep private is just my order. But I only want to keep it private before it gets executed. After it gets executed, I don't care if it gets copy or not.
01:16:37.240 - 01:16:37.666, Speaker E: Right.
01:16:37.768 - 01:16:39.906, Speaker C: So in that case, as long as.
01:16:39.928 - 01:16:48.678, Speaker B: The information is kept private before the eventual game match for another order yeah, then I'm fine with it. Yeah.
01:16:48.764 - 01:17:18.400, Speaker D: I think to keep orders private, I think it's not super my area, but I think mostly you need fully homomorphic encryption. But you can do stuff like commit reveal schemes to commit to your order and then you have a right to reveal it later. But yeah, just with ZK, like keeping an order secret in an order book, unless you're doing a commit reveal scheme, that's kind of a different UX. Yeah, that's probably not something just like most things order books and pools do need to be on the side.
01:17:19.750 - 01:17:24.050, Speaker A: All right, thank you Adam, for the great presentation.
01:17:27.750 - 01:18:18.078, Speaker E: So first, I'm Bobin from Polygon, and I work on polygonmiden. Polygonmiden is kind of also like an L two that has one of its goals to preserve privacy. So in that way we're very similar to aspect. So I'm not going to reiterate all the things that Adam mentioned in terms of motivations, of why and we want to do that. And basic goals are very similar. The architecture though is different. So I want to kind of COVID the architecture and as part of that, also describe a few things that we're trying to achieve, like how we, for example, achieve confidentiality, how we break linkability between basically break transaction graphs so you can figure out who's transacting with whom.
01:18:18.078 - 01:19:18.294, Speaker E: Also touch on node discovery, so how we figure out who sends what to users, how you can figure out if something's been sent to you and so forth, so on and so forth. Yeah. So one other thing that I want to mention, so basically in terms of overall goals for the roll up that we have, the goals are we want to have increased privacy so that people can transact without the deal and everything. The way we want to do it is by pushing as much as and we also want to support much more scalability than is available on ethereum. So the way we want to achieve both goals is by pushing as much as possible to the user. So both computations and data storage can be done on the client side and then network would do as little work as possible. The other goal that I think is important and we're kind of like in this discussion here touched a little bit on it, is I believe that for privacy to become kind of ubiquitous you need to make it so that the private option is cheaper than the public option.
01:19:18.294 - 01:19:55.380, Speaker E: So if you want to transact publicly it actually should cost you more than transacting privately or vice versa. If you want to transact privately it should cost you less than being transacting publicly. And in that case most users would choose to be private just by incentives. So the situation for example, where a private transaction is more expensive than the public one is not the best one because it disincentivizes people from using private transactions. All right, so I'm going to compare a few things to Ethereum. So by show of hands, who is familiar with Ethereum and what Ethereum accounts are and things like that? Okay, some people. Most people.
01:19:55.380 - 01:20:20.860, Speaker E: All right, so I'll start again. There's a lot of terminology overlapposastic as well but the architecture is different so I'll use terms like nullifiers and nodes and things like that as well. But I'll start with kind of describing the basic building blocks of Mitron roll up and the most basic thing is an account. So let me kind of draw what an account would be. So let's say this is account.
01:20:24.180 - 01:20:24.496, Speaker D: I.
01:20:24.518 - 01:20:52.100, Speaker E: Also don't style variable so I might make mistakes. So an account consists of a few different things. There is an account ID, like a unique identifier. In our case it's a 64 bit value. There is account code. This is code. So we have midn VM which is specialized VM that we built specifically for polygonmiden.
01:20:52.100 - 01:21:49.496, Speaker E: I'm not going to go into details of my VM but this is basically a commitment and actually contains the code that can be executed mitbm and this defines the public interface of an account. This basically also means we have native account abstractions where any account has code. All of our accounts have code and this could be like a set of functions that are available publicly to be called on an account. Every account has storage and storage is the architecture is slightly different but you can think about it the same way as an Ethereum account storage where you can add like key value pairs. There's slight variations from that but basically you can put things in storage. Users can there are storage slots and you can store whatever you want in the storage and practically there is no limit of what you can put in the storage. Obviously the more you put the more the bigger it will be and creates.
01:21:49.528 - 01:21:50.110, Speaker B: Other.
01:21:53.440 - 01:22:25.696, Speaker E: You know, we have also have a nonce and this nonce needs to be incremented every time. Let's say storage value changes. Whenever state of the account changes, the nons needs to be incremented. And so far this looks relatively similar to this ID thing. It looks relatively similar to Ethereum accounts. We do have another thing here which is different. So in Ethereum accounts you usually have balance as something that stores native currency of Ethereum.
01:22:25.696 - 01:23:08.164, Speaker E: In mining we have something that we call vault. And this vault holds all assets that an account holds. So this is basically the actual implementation is like a sparse merkel tree. So you can think about it as a sparse merkel tree. And I'm not going to grow the whole tree, but basically each leaf in this merkel tree is either zero or a commitment to some asset. And an asset could be a fungible asset. You can imagine like, let's say ten e, it would be like here would be ten, or it could be a non fungible asset and that could be just like a hash of some NFT or whatever.
01:23:08.164 - 01:24:01.190, Speaker E: So like, it's zero x, one, two, three. So this is one of the main differences from Ethereum, for example, where in Ethereum, if you think about ERC 20 model, you have assets stored in different contracts, which means and I'll get to the benefits of this. A bit later, but which means every time you get a new token, for example, you need to create a record in another contract, and that consumes more and more state. In Ethereum, in this case, it does increase the size of the account, but for private accounts, it doesn't matter and I'll get to why. But here we store everything under the same account. So by examining the account, you know, all the assets that an account owns, you don't need to like in Ethereum, you frequently need to examine the entire state to figure out which assets you own and so on. So this is the basic construct of an account.
01:24:01.190 - 01:24:31.100, Speaker E: Now, as part of the state of mind roll up, we have something that we call account database. So account database is basically a commitment to all the account states that are currently active or not active, but current states of all accounts, basically. And this is also a sparse merkel tree where path in the tree is determined by the It. And the value in the leafs of the sparse merkel tree is actually cache of the current state of the account of all of these fields.
01:24:31.760 - 01:24:32.232, Speaker B: Okay.
01:24:32.306 - 01:24:38.930, Speaker E: Any questions? By the way, feel free to interrupt. Ask questions. If anything's unclear, ask. If it's unclear to you, it's likely unclear to everyone else.
01:24:40.100 - 01:24:46.324, Speaker B: How do you populate the lease? How do you know which lease is going to be the ten lease or whatever?
01:24:46.442 - 01:25:11.976, Speaker E: Yeah, so basically an asset actually is a 256 bit value, even for this one. And there is like a structure for different assets, but basically the 256 bit value determines the path in this tree for a given asset. Unique. Yeah, I mean, we don't put like ten ETH and like eleven E, the ETH will always end up in the same leaf, but each NFT will end up in a different leaf.
01:25:12.008 - 01:25:12.348, Speaker B: Okay?
01:25:12.434 - 01:25:55.292, Speaker E: And we ensure that there are no collisions by the rules of how you can create assets in the network and all that stuff. Okay, so far so good. So the next thing, what we have is a note. So a note is another kind of basic building block and a note consists of a few things. First it has a script. And this script script is basically also a commitment to my program. But unlike the code in the account, this is an executable program.
01:25:55.292 - 01:26:34.152, Speaker E: So a code in account just exposes a few functions or whatever. Could be a few, could be many interface functions the account exposes. But script is an executable program so you can execute the script from start to finish and I'll explain how the scripts come into play. Then it has some input values, so inputs and this inputs would be fed into the script when the script executes. So that's one of the things that the script can read and consume during its execution. It also has a vault. The structure of the vault for the node is a bit different.
01:26:34.152 - 01:27:02.492, Speaker E: It also holds assets. But here we don't have a sparse merkle sheet. We just have a sequential hash of all the assets that are in a node. And we limit the number of assets that a single node can carry to like I think 256 right now. So you can put like 256 NFTs in a single node or 256 different tokens, each with different amounts and all that stuff and it would be carried in a node. Then the next thing the node has is a serial number. I'll just say SN.
01:27:02.492 - 01:27:18.376, Speaker E: So this serial number is something that is used later to break linkability to when we create ulifiers and things like that. But this is like basically distracted node and this is like a 35 value and these are variable depending on what.
01:27:18.398 - 01:27:19.450, Speaker B: Is stored in there.
01:27:25.020 - 01:28:15.744, Speaker E: One of the things I should mention is how we compute hashes and nullifiers of the node. So I'm not going to go into exact details, but basically we take this information and we hash it in different ways to compute the hash and nullifier. So you can imagine for example, if you want to compute the hash of the node, like h would be hash, let's say script inputs, bold and serial number like that. And if we want to compute a nullifier, we do it actually differently. But I'm going to simplify it right now. We do it let's say in reverse order. So like say nullifier, hold inputs and script.
01:28:15.744 - 01:28:56.544, Speaker E: So this way if you have cache you cannot invert it and figure out what the nullifier for this node should be. Again, the exact computation is actually different. We structure it like we want to achieve some other properties as well. But I'm not going to overcomplicate it right now. But basically you need to have all this information to compute the nullifier and hash, obviously, but if you know the hash, you cannot infer what the nullifier is and nodes get created. I'll get to how the nodes get created, but they are stored in another database. What we call is this called a node database and this is actually merkel mountain range, which is you can think about as append only log.
01:28:56.544 - 01:29:38.556, Speaker E: So you always just append nodes, you create them and append to this log. You never remove them from that log. That has a few nice properties for various reasons, but it also has this drawback that you don't know which nodes have been consumed. So we need another database, which is a nullifier database and the nullifiers. So basically, whenever a transaction gets created or a transaction executed produces up nullifiers, they get recorded in the nullifier database, which is also a sparse merkel tree. And basically you check if a transaction produces a nullifier that already exists in nullifier database, then you can't execute that transaction because it would be double spend of some node and because the nullifiers are deterministically computed. This way every node will produce a unique nullifier.
01:29:38.556 - 01:30:20.350, Speaker E: You cannot change nullifiers as part of the node and yeah, so this is basic building blocks. Now let me talk about what is a transaction in midn. So a transaction in midn actually has a few restrictions, but you can think about this. So this is a transaction, it always works with a single account, or at least we can extend it in the later iterations. But for now a transaction involves only one account. So you would say let's say account as input and it could update the state. So a prime would be the output as a state, new state of the account.
01:30:20.350 - 01:31:02.090, Speaker E: And then the same transaction can consume many nodes. I don't remember exact limitation, but I think we'll put like up to 1000 nodes. So zero to, let's say 1000 nodes and it can produce again, I don't remember the exact number, but say zero to 1000 nodes. So you can think about a transaction. As I consume some nodes, I update the internal state of the account regarding the rules of what needs to be done in the process of consuming nodes. And then I can output more nodes.
01:31:03.650 - 01:31:07.070, Speaker C: That nodes count randomized.
01:31:08.130 - 01:31:08.814, Speaker E: What do you mean?
01:31:08.852 - 01:31:10.080, Speaker C: So, like, let's say.
01:31:13.810 - 01:31:14.766, Speaker A: You consume, I.
01:31:14.788 - 01:31:20.254, Speaker C: Don'T know, like 500 nodes for example, maybe related to multiple different accounts but.
01:31:20.292 - 01:31:22.100, Speaker E: When you always related to one account.
01:31:23.430 - 01:31:32.630, Speaker D: Yes, but then you could also say that, let's say when you have one account with multiple nodes.
01:31:34.410 - 01:31:36.790, Speaker C: What'S the condition for outputting?
01:31:37.450 - 01:31:40.322, Speaker D: I don't know, zero nodes versus 1000 nodes.
01:31:40.386 - 01:31:43.026, Speaker C: How do I determine how much actual nodes?
01:31:43.138 - 01:32:29.794, Speaker E: This is determined by the nodes that you consume and some other information. But each of the node scripts may force the account to create another node. So let's say as you execute a script of a node, it may say, okay, as part of the script, I want to move assets from this node into this account, and I also want to create a new node that takes some assets from the accounts and moves it somewhere else. So basically, every node, you can think about the script as a predicate that can force account to do things that account exposes via interface method. So maybe the best way to do it is illustrated kind of an example. Let me do this one quick thing before I go into this example. But yeah, basically it's determined by what you consume and what you produce.
01:32:29.794 - 01:33:31.010, Speaker E: But basically, if you think about a typical transaction on my end so let's say we have two actors and they want to do a transfer, right? So let's say there's Alice and Bob, and Alice wants to send some, let's say Alice has an account and there is like, let's say ten ETH in the account and Rob doesn't have anything. So what Alice would do is would create a node, and let's say Alice wants to send one ETH. So create a node with one ETH, and this would be first transaction, and then this node would get reported in the node database. The new state of Alice's account would be updated and that would be recorded in the blockchain. And then as a separate transaction, Bob would consume this node. So this would be TX two. And then once Bob consumes it, he gets this one e.
01:33:31.010 - 01:34:09.090, Speaker E: So in my model, you actually need two transactions to do this transfer. Now, you may say like, well, doesn't that double the number of transactions on a network? And depending on how you do it, the worst case scenario, it would double, but actually it doesn't have to. So you could wait for a week, for example, and then consume all the nodes sent to you during the week in a single transaction. And same, you can send out many notes in a single transaction, so you actually don't have to. Two x is a worst case scenario. Most likely it will be much, much closer to one. So it will be more than one, but it will be much, much closer to one.
01:34:09.090 - 01:34:57.416, Speaker E: All right? Now, how does this node actually get consumed, for example? Right, so this was your question. Let me actually say how this node gets produced in the first place. So when we execute a transaction, we have something we call transaction kernel, another terminology similarity. So a transaction kernel executes like this. So let's say this is the kernel and we start executing. And first we execute some probe. And this collects, for example, some information about, first of all, this verifies that all the nodes that are being consumed have been created.
01:34:57.416 - 01:35:52.036, Speaker E: So it would have access to the MMR of the state and it would say, okay, all the nodes that you're trying to consume, have they been created at some point or not? It will also compute some of all assets in an account plus all the nodes that are being consumed so that it has like global view of all the input assets into the transaction and does a few other things. Now then it looks like if you're consuming a number of nodes, it would actually execute node script sequentially. In our case we're not consuming anything, we just want to produce something. And then you can execute something we call a TX script that can be provided by the user. So there's a TX script and a TX script can be something custom that you can basically create. And what TX script can do, it can pull interface methods on the account. So now we have our account here and a TX script would make a call.
01:35:52.036 - 01:36:42.100, Speaker E: So let's say account exposes interface saying like Send Assets, right? So there's going to be a call here and this would be Send Assets and we'll say which asset to send. It will also contain like a signature verification to make sure that you authorize to send those assets. As part of executing the script or as part of executing this Send Assets you will need to provide signature. The actual authentication mechanism is slightly different but I'm not going to go into it now. But basically calls Send Assets and Send Assets is a function that exists on this account and as part of Send Assets it needs to create another node. So it will create Send assets, will take the assets out of the account vault and create a node. Send Assets will send like recipient or as a parameter you would probably provide.
01:36:42.170 - 01:36:42.790, Speaker B: A.
01:36:45.400 - 01:37:23.330, Speaker E: Recipient, I'll just put it R and you will need to provide the actual assets. So like as parameters to Send assets you will say okay, I want to send this assets to this recipient. And then it will create a node here that will have a script which is defined by this recipient and I'll get into this a bit later. So this recipient value will define the script of the node as well as inputs and then it will define the assets of the node. So like the output node will have this R value actually breaks down. So I should have drawn this node a bit bigger. But there will be this asset that the node takes.
01:37:23.330 - 01:37:59.384, Speaker E: It would have some script that is part of this recipient. It would have the inputs that are also defined by this recipient and would have the serial number and the serial number in our current implementation. Also like this recipient is basically a combination of these three fields. So now this nodes get created, this transaction gets executed, proven whatnot so this node gets reported on the change. Now next step, how do we consume this node? So I'll say yes, the TX.
01:37:59.432 - 01:38:00.300, Speaker D: Scripts.
01:38:00.800 - 01:39:06.922, Speaker E: Is that the script that was inside the node being consumed or is that TX script in this case is oh, sorry, I actually didn't finish. This TX script is a script that a user can provide with any transaction custom script that you can provide. Basically the semantics of this is that you execute all node scripts or input nodes and then you can execute it custom TX script at the very end. So the other thing that I didn't finish there is what we call epilogue, which does a few things, but the main thing that it does is it computes sum of all assets in the final account state and all output nodes. And it makes sure that sum of input assets is the same as sum of output assets. And that's how we make sure that there are no new assets created or destroyed during this transaction. So basically in this case, if you had ten ETH here in the beginning in the account, and then you created a node with one e here, but you didn't update the account state, the transaction will fail because you need to subtract one east from the word of the account.
01:39:06.922 - 01:39:53.842, Speaker E: Otherwise the sum of inputs will not match the sum of outputs and the Aplode will basically fail execution. So how do we consume this node? Am I running out of time? Okay, so let's say we have this node with our asset, our script, our inputs and serial number. And then there is like some other account, this is Bob's account. And Bob can create another transaction that will basically say, okay, I'm going to execute, so I'm going to have my sorry wasting.
01:39:53.986 - 01:39:54.680, Speaker D: But.
01:40:00.270 - 01:40:34.134, Speaker E: So this would be transactional kernel with a prologue. And now we start executing the scripts of the nodes that are being consumed. So this node that we created had this script that was created as part of the previous transaction. And this script could do a few things. And this is Bob's account. So first thing, we'd probably want to make sure that this node can be consumed only by Bob, by not somebody else. So the first thing it would do is check which account are we executing this note again.
01:40:34.134 - 01:41:06.190, Speaker E: So it would request like get ID from the account, compare it to some ID that was provided as part of the script or part of the inputs. And if it doesn't match Bob's ID, for example, it will not pass. So you would not be able to execute the script. If you're trying to execute this node against some other account, this is one way to do authentication. You can do it in many other ways using public keys like signatures, but this is like the simplistic way to do it. The second thing that let's say Bob's account exposes another method that is called receive asset. So that one will send assets.
01:41:06.190 - 01:42:04.066, Speaker E: So this node, as part of the script, this node will call receive asset on Bob's account and pass the asset that wants Bob to receive. So basically the condition is, does the ad match and if it matches, put the asset from the node into Bob's account and then yeah, that transaction also gets executed this way. So now we have basically for this to work, Bob's account needs to have this receive asset method. And this method needs to have very well defined semantics. We achieve this by the way we structure programs in mydin VM is that they are like Mercurialized Abstract Syntax trees of the actual program. So Hash actually commits to the entire program. So what it actually poses is the root of the Mercurialized Abstract Syntax of Mask for short.
01:42:04.066 - 01:42:42.782, Speaker E: So if you have receive assets, you cannot swap it out for different implementation. It will always has to be the same semantic which and you know exactly what receive asset, everybody will know exactly what receive asset does. And if Bob tries to cheat and do something else as part of this receive asset, I mean in this case there is not much to cheat with, but in some other cases there might be. This will not pass. So I didn't get as far as I was hoping, but I think I covered pretty well. But I think what this model allows us to do there are two things. First, every transaction can be proven individually.
01:42:42.782 - 01:43:29.770, Speaker E: Because every transaction touches only state of one account, it can be proven, all transactions can be proven in parallel. And also all of them can be not all of them, some of them, or hopefully most of them can be proven on the client side. So the fact that I'm sending some assets to Adam, for example, I create one transaction that sends out something out of my account, I prove it locally, submit it to the network, and then Adam consumes that node into his account and he creates another transaction, proves it locally, submits it to the network. So all of this can happen in parallel and most of it on the client side. What cannot happen on the client side is interaction with something like a uniswap, for example. So I didn't cover how something like uniswap would work. But basically what you would do is you would have one uniswap contract.
01:43:29.770 - 01:44:14.734, Speaker E: You would send a bunch of nodes to the different users, would send nodes toward the uniswap contract as part of the condition in the node. He would say for uniswap contract to consume the node and claim all the assets it needs to create a node that is directed back to my account. And then you would have a few nodes, or maybe many nodes targeting uniswap account. And then the block producer would actually put them and sequence them in a transaction, single transaction, apply all the nodes to uniswap account. By applying them, they would produce more nodes that go back to our individual accounts and then we can consume those nodes back privately. So you send something privately and you consume privately. Basically, what is seen on chain is that somebody is interacting with uniswap account.
01:44:14.734 - 01:44:21.082, Speaker E: They see amounts, but they don't know who is interacting or who is getting the funds back in the recipient funds.
01:44:21.146 - 01:44:27.306, Speaker C: Okay, and that part is some aspect of public space.
01:44:27.428 - 01:45:24.900, Speaker E: Correct. So the other aspect that I didn't describe is because of the structure of the account, we don't have like for private wallets and things like that, you don't have to store the state of the account on chain. The only thing that you store on chain is the hash of the account and the entire asset tree and the entire storage can be stored locally on your device. For low value accounts, maybe that makes sense. For more high value accounts, you probably want to have some backup solutions, either simple backups or like some data availability or not data availability, but recording in progress, like data storage solutions that maybe somebody signs off on this before you're allowed to update the state of your account and so forth and so on. But the idea is that for most accounts that don't need to have the shared public state, you don't need to put them on chain. You just put like 40 bytes, regardless of whether you own 100 assets, 1000 assets, whether your storage is 1GB or 10, things like that.
01:45:24.900 - 01:45:47.898, Speaker E: And similar with nodes, like, you can actually just put a hash of the node. It makes it more difficult to discover and you have to have a side channel. But if you have a side channel, you just put hash of the entire node on chain. You don't put anything else. If you don't have a side channel, you need to put an encrypted version of the node on chain and then yes, that's to the state. But that's kind of the trade offs you need to make. And that's also the question of cost.
01:45:47.898 - 01:46:21.522, Speaker E: So because you can do a lot of computations client side and you actually can do a lot of storage client side, you would assume that the fees associated with private transactions should be much lower. Like if I am doing all the computation myself and I'm storing all the data myself, I don't need to reveal it publicly. The network does not need to bear the cost of computing the transaction, verifying signatures and all that stuff, and the network doesn't need to carry my data. Therefore, if I'm private transactions for me would be cheaper and I wanted to cover a bit more, but hopefully this was useful.
01:46:21.666 - 01:46:22.310, Speaker A: Yeah.
01:46:22.460 - 01:46:25.606, Speaker C: Thank you very much, Bobby, for the Great Whiteboard Session.
01:46:25.638 - 01:46:26.540, Speaker B: Thank you very much.
01:46:29.070 - 01:46:29.900, Speaker C: All right.
01:46:31.310 - 01:47:20.050, Speaker F: Hi everybody. My name is Ravital. I'm the founder of Sunscreen, and you're going to hear all about fully homomorphic encryption. Some of the challenges we've experienced in trying to make fully homomorphic encryption accessible to developers, as well as some of the open challenges in the space to kind of start us off. Let me briefly go through what Fhe is. Hopefully this is just a recap, but at a high level you can think of fully homomorphic encryption, aka Fhe, as an extension to a public key encryption scheme, where in addition to being able to generate keys, encrypt and decrypt data, now you can perform computation directly on the encrypted data itself. And when we talk about performing computation on encrypted data, that's what the fully homomorphic part refers to.
01:47:20.050 - 01:48:24.050, Speaker F: We can add ciphertext together or we can multiply ciphertext together. Some applications folks are interested in Fhe Four are both in and out of Web Three. In Web Three, I would say the hotter applications people are speaking about at the moment are private auctions, private orders, whether they're for DEXes or for dark pools. There is quite a bit of interest in being able to implement private voting in Dows outside of the Web Three space, we've seen quite a bit of interest in private machine learning, so for example, private inference or private predictions, as well as private training. There is also quite a bit of interest in being able to do analytics for user data. Fhe has a much shorter history than comparable privacy technologies, so it's worth maybe briefly going over. The idea of constructing an Fhe scheme dates back to the 70s, around the time RSA was proposed, but it took over 30 years to successfully construct an Fhe scheme.
01:48:24.050 - 01:49:33.702, Speaker F: That was done in 2009 by Craig Gentry as part of his PhD thesis. The first generation of Fhe was incredibly slow, so I've heard all kinds of estimates but over ten minutes to multiply two encrypted numbers together using Gentry's original Fhe scheme, the second generation of Fhe kicked off around 2011 2012 ish, and has continued on to 2016. In terms of how the second generation of Fhe improved on the first generation, it significantly improved the times to do arithmetic over encrypted data. It dropped it down to, we'll say around milliseconds seconds time, but there were still some challenges around doing a specific operation called bootstrapping. So if you want to do truly arbitrary computation on encrypted data, you need this special operation called bootstrapping, and that was quite slow in the second generation of Fhe schemes. Some notable second generation fhe schemes include BGV, BFB, and Ckks. In terms of what's relevant to the Web Three space, I would probably focus on the BFB scheme.
01:49:33.702 - 01:50:38.030, Speaker F: The third and latest generation of Fhe started around 2016, and that's the same generation we're on right now. The main scheme from the third generation is the tfhe scheme. In terms of how the third generation improved on the second generation of Fhe, it now allowed for more arbitrary computation on encrypted data. So second generation was very much focused on being able to do arithmetic and build up to doing polynomials over encrypted data. With the third generation, you could now do comparisons on encrypted data for example, it also significantly improved the times to bootstrap. So going from a scheme that does, we'll say, kind of bounded depth computation to truly unlimited kind of depth computation, one thing to kind of point out here is that it isn't necessarily the case that the third generation of Fhe is all around better than the second generation. Depending on what you're trying to do, you may want to go with something in the second generation of Fhe.
01:50:38.030 - 01:52:21.250, Speaker F: Or if you're very heavy on doing things with comparisons, you probably want to stick with the latest generation of Fhe, which is tfhe. So you want to work with Fhe. What do you have to do to get started? I've decided to kind of compare and contrast the Fhe experience with ZKPs, since most people are a lot more familiar with that landscape. So when you're working with ZKPs, one of the first things you might think about is what is the most appropriate proof system? And that might involve asking yourself the following questions what kind of prover and verifier times am I okay with? What sorts of proof sizes do I need? And what kind of trust assumptions can I live with? The equivalent in Fhe land would be thinking through what the most appropriate Fhe scheme is, and that requires asking yourself, what kinds of computations am I going to do? Is it going to be very heavy on arithmetic or is it going to be very heavy on comparisons and sorting? You also want to ask yourself, what kinds of computation times am I okay with? Can I live with slower times or do I need very, very fast times for certain operations? You're also going to want to consider what kinds of ciphertext and key sizes are acceptable to you, because these can vary quite a bit from scheme to scheme. One of the other considerations in working with CKPS is thinking through how you're going to translate some program written in a high level language to a circuit. There is a very similar consideration in Fhe. Depending on what scheme you're working with, you have to think about translating your program into either a binary or arithmetic circuit.
01:52:21.250 - 01:53:20.610, Speaker F: The final piece with Fhe that I would say has no good CK equivalent has to do with picking parameters in Fhe. So it turns out in working with Fhe, you have to be very careful about how you choose scheme parameters because there can be a huge performance penalty if you choose parameters poorly. I don't think there's any good ZK equivalent for this. Choosing parameters with Fhe is a lot more challenging and there's quite a few more parameters to take into account. So in terms of the challenges in using Fhe in any kind of application, I would say the issues fall into one of two buckets. Either you have very serious performance issues because Fhe is very sensitive to how you choose parameters. You also have some challenges with thinking through how you are going to effectively translate your program into a circuit.
01:53:20.610 - 01:54:17.234, Speaker F: On the usability side, there are some challenges with regards to encoding. So how do you go from plain text data or totally unencrypted data to ciphertext? There are different encoding techniques with various trade offs. You have some challenges as well in terms of explaining a brand new programming paradigm to engineers. So when you're working with Fhe, you are not able to in any easy way do data dependent branching. How are you going to convey that problem to the developer? The other challenge I would like to point out in working with Fhe on the usability side has to do with operations. In addition to being able to do computation over encrypted data, encrypt decrypt, generate keys, you now have some very strange operations that engineers haven't seen when just working with public key cryptography. You have things like relinearization modulus, switching bootstrapping.
01:54:17.234 - 01:56:01.640, Speaker F: How are you going to explain these to the developer and how are they going to effectively use these? So to sum up the experience of using Fhe today, it's a technology created by cryptography experts for other cryptography experts to use. The question people started asking in this space, let's say around five to seven years ago, was can you build some sort of compiler that makes Fhe easy for engineers to use? The answer is yes, but with a fairly large caveat that any such Fhe compiler has to be domain specific. It turns out that an Fhe compiler for ML engineers, for example, is going to look very, very different to designing an Fhe compiler aimed at DeFi developers. So how can an Fhe compiler improve the overall developer experience? Well, you would hope it can broadly address the performance issues I mentioned, so it could help you in figuring out the best parameters to achieve a certain level of security, as well as give you the best performance possible for what you're trying to do. It should set up all the circuits for you because most developers don't want to think about programs in terms of arithmetic or binary circuits, and ideally for any Fhe specific optimization, the compiler should insert those in for you as well. On the usability side, you would hope that such an Fhe compiler can abstract away any Fhe specifics, it should abstract away anything to do with circuits. And for that kind of pesky encoding process of going from plain text to ciphertext, ideally the compiler handles that problem for you as well.
01:56:01.640 - 01:56:56.870, Speaker F: So that leads us to some of the work we've been doing at Sunscreen and we have built an Fhe compiler. The idea here is that the developer writes some Rust program, there are some restrictions on what they can write in their Rust program, and then our Fhe compiler will take your Rust program and translate it into its Fhe equivalent program for you. So concretely, our compiler figures out what are the best scheme parameters to get you the best performance possible. It inserts in Fhe specific optimizations for you, it hides away everything to do with circuits, and if the program can be parallelized, the compiler does that for you as well. We definitely believe that Fhe is an evolving landscape. There will continue to be new schemes proposed. So we designed our compiler in a very modular way so that it's scheme agnostic.
01:56:56.870 - 01:57:57.722, Speaker F: Right now our compiler supports the BFB scheme, which is one of the second generations of Fhe, very good at arithmetic over encrypted data, but not so good at comparisons over encrypted data. The next scheme we're working on supporting is the tfhe scheme, which is one of the third generations of Fhe, and that scheme is great for performing comparisons over encrypted data. There are still some challenges in designing an Fhe compiler. I would say not just for us, but very broadly speaking, fhe has a very different programming paradigm for engineers. What is the best way to expose this to the engineer is a bit of an open design question. The other challenge is that at least all the Fhe compilers I've seen, including our own, expect the developer to at least be familiar with the basics of public key cryptography. So it's not necessarily the case that any engineer can work with an Fhe compiler.
01:57:57.722 - 01:58:43.702, Speaker F: They at least need to know about public and private keys. Here's a little snippet of code and you can write a program that multiplies two encrypted numbers together using our Fhe compiler. You can see here that there is absolutely nothing about circuits, there is nothing about these weird Fhe operations. We have really tried to reduce using Fhe to working with a public key encryption scheme. But as I kind of mentioned before, to effectively work with our compiler, you still need to be familiar with concepts like plain text and ciphertext. You need to know about public and private keys and encryption and decryption as well. We're not the first people to design an Fhe compiler.
01:58:43.702 - 01:59:43.630, Speaker F: There are quite a few Fhe compilers out there in the space and some of them are fairly recent work as well. But it turns out that many of these Fhe compilers do a serious disservice to the technology with regards to performance. There was a fantastic systemization of knowledge paper from Oakland S and P 2021. I highly recommend you read that sok on Fhe compilers if you haven't seen it before. And the benchmark they used to compare the performance of various Fhe compilers was a chi squared test on an encrypted data set. And they looked at how long does it take to generate keys, encrypt data, do the homomorphic computation as well as decrypt data. It turns out if you sit down and you code this yourself directly and you're an expert who knows exactly how to manually optimize this and pick the best parameters, you can do all of these things in about 53 milliseconds.
01:59:43.630 - 02:00:15.754, Speaker F: So how do Fhe compilers stack up. It turns out that almost all Fhe compilers do a pretty poor job in terms of this translation. Most compilers introduce a very large overhead. There are two notable exceptions. There is Microsoft Eva from 2019 and that introduced a six x overhead. So you're going from 53 milliseconds to 328 milliseconds. We also have Sunscreen, our own compiler that introduces about a 1.3
02:00:15.754 - 02:01:17.550, Speaker F: x overhead, moving the computation from about 53 to 72 milliseconds. Some of the more recent work that was concurrent with ours includes Google's transpiler, which blows up the computation to over two minutes, as well as Zama's Concrete, which also blows up the computation to about two minutes. There are quite a few challenges remaining in the space, so let's maybe briefly look at those. The first major challenge with Fhe and Web Three has to do with deployment. Okay, you've built an Fhe compiler. Now what? How exactly do I use this Fhe compiler on a blockchain? Should I think about deploying Fhe as a brand new layer? One? Should I think about using Fhe on some sort of sidechain, or would I prefer to use it on a roll up? This is a very, I would say, open question that nobody has any good answers to right now. The next major challenge has to do with Fhe VK compatibility.
02:01:17.550 - 02:02:23.070, Speaker F: For most major applications of Fhe in Web Three, you really need it to work in conjunction with zero knowledge proofs. So you need zero knowledge proofs to essentially show that this encrypted data satisfies. Some, we'll say validity checks. What VKP is best suited to work in combination with Fhe? Even if you manage to figure that out, which I would say is kind of an open research theory question what will the developer experience look like? What is the integration going to look like? This is a very challenging area, and I would say this is just a giant can of worms that maybe deserves its own talk. The final piece has to do with the sorts of applications people are interested in using Fhe for in Web Three. So so far everything I've spoken about really has to do with single key Fhe, where the public private key pair belongs to a particular user. But for applications like DEXes for private voting, you very likely want to do computation on data belonging to different users.
02:02:23.070 - 02:03:19.166, Speaker F: So you need something like Threshold Fhe, where you've taken the secret key and broken it up into shares to actually get these applications working. It turns out that all of the challenges I've mentioned with single key Fhe also apply to threshold Fhe. But you now have new challenges. How exactly are you going to do that distributed key generation process? How exactly is Threshold Decryption going to work? What is the communication piece going to look like in a decentralized setting? That is also a fairly open question. Before ending, I just wanted to compare and contrast two very different experiences we've built at Sunscreen. We of course have our Fhe compiler that I've spoken about and you can access that via our Rust playground if you don't want to download and install it yourself. But we also have this demo app that we've supported on the Sepolia testnet.
02:03:19.166 - 02:03:58.826, Speaker F: The compiler is of course aimed at developers. It allows you to test out writing Fhe programs. But the obvious challenge is what you do with your Fhe program is entirely up to you. How you figure out how to deploy it is also up to you. And despite how good you make a compiler, there is some natural performance overhead when you go to use one. An entirely different experience that we launched last week is a first price seal bit auction and this uses Fhe behind the scenes. We have sat down and hand tuned the actual Fhe program to meet performance goals.
02:03:58.826 - 02:05:00.500, Speaker F: So we have gone beyond what any existing compiler, including our own, can do. We have sat down to figure out what is the exact precision we need to get the certain kind of performance met, we have figured out what the error rate should be. We have gone and figured out, we'll say, about ten different parameters ourselves. It of course required thinking through what the architecture of this program should look like. So how do you go from a program that doesn't have privacy to something that does have privacy with Fhe? How exactly are you going to expose Fhe to the end user? What should the UI look like? There was also some challenges with regards to deployment itself. So Fhe is quite expensive to use. How can you design the experience in such a way to minimize the cost? What parts of the application should be on chain versus off chain? And this is integrated entirely within the eat seapolia testnet, so feel free to try that out as well.
02:05:00.500 - 02:05:43.154, Speaker F: And that's basically it. I would love to hear any kind of opinions or chat with anybody about the following points. These are what's consuming most of my brain space at the moment. How can threshold Fhe work in a decentralized setting? All the kinds of good stuff about Bkfhe integration, how might we deploy Fhe in the real world? And as a bonus, we've been thinking a lot about hardware as well. And if you really need something like FPGAs to get Fhe to the performance folks need in the DeFi space. So, yeah, thank you so much and feel free to message me on Telegram and our company's Twitter is here as you thank you.
02:05:43.192 - 02:05:43.940, Speaker A: Round of.
02:05:45.910 - 02:05:46.226, Speaker B: You.
02:05:46.248 - 02:06:35.060, Speaker A: Thank you. I actually have some questions also wanted to kind of quickly ask you about, which was the levels of abstractions that you foresee with Fhe going into the future. So you mentioned that Fhe has a lot of parameter adjustments that you have to do to optimize the actual operations and overhead of the Fhe. I'm not sure how application specific that parameter adjustment is, and also how much of that can be abstracted such that future devs don't have to, I guess, bother with doing all those param adjustments type of work if you could elaborate on that side of things.
02:06:36.230 - 02:07:53.050, Speaker F: Yeah, so the way our compiler works and will work for even tfhe, you essentially give it your program and it figures out, okay, what parameters do I pick to meet a certain level of security? Say 128 bits? And then what is the best kind of performance I can get you? But say, for example, you have some flexibility for your application, so you don't necessarily need 64 bit precision. You're okay, maybe working with 32 bit precision, maybe you're also okay, for example, dropping the error rate. So if you're willing to play around with, okay, what if I have an error rate of two to the negative 40, but maybe I can also live with something like two to the negative 35. Making those kinds of adjustments can really allow you to boost performance pretty significantly, and that's not something very easy to expose in a compiler. I do believe it can be done, but it's definitely challenging. What I see as a much more viable route in the kind of short term is allowing for hardware acceleration so you don't have to go this kind of down the stack to think about things like error rate and precision to really squeeze that last bit of performance out of Fhe.
02:07:53.550 - 02:08:26.230, Speaker A: I see. Sorry, I have one more question before I open up to the floor. Obviously, people are everyone are talking about the performance and how the performance overhead might be hindering a lot of the practicality of the Fhe applications. But how do you foresee that eventually that Fhe can become more broadly adopted and what do you think will be the catalyst for it to become actually practical in our daily use cases?
02:08:27.290 - 02:08:47.770, Speaker F: Yeah, I would definitely say the FPGA piece. The times now are acceptable for certain classes of applications that are not super time restrictive, but once you have the FPGAs, it drops down the times by about two orders of magnitude. So you're competitive with things like multiparty computation and ZKPs.
02:08:48.930 - 02:08:58.720, Speaker A: I see. Well, I would love to also hear some questions from the crowd, so if you guys have any okay, maybe.
02:09:05.590 - 02:09:17.574, Speaker B: Yeah, thank you for the talk, especially since you mentioned multi computation. I'm a bit fuzzy on the difference of the goal of encryption and things.
02:09:17.612 - 02:09:20.034, Speaker E: Like garbled circuits where we have privacy.
02:09:20.082 - 02:09:23.270, Speaker B: Of inputs and like, obliviousness of operations. Done.
02:09:23.340 - 02:09:24.578, Speaker D: So could you speak a bit more.
02:09:24.604 - 02:09:30.250, Speaker E: To the difference between the goals of Fhe versus multiparty compute based on garbage surveillance?
02:09:31.550 - 02:10:08.322, Speaker F: Yeah, so I want to kind of preface it with I am not an MPC expert at all, and I wouldn't say single key Fhe is a good technology to compare directly against MPC. It would be more along the lines of threshold Fhe. So. Where people are thinking about threshold Fhe for example, is we'll do voting as our example. I want to vote we'll now maybe put in my vote, your vote, maybe Yuki's vote and we do want to know the result, but we don't want to share our specific inputs with anybody. And that would be a good use case for threshold Fhe. The other ones we're seeing have to do with dark pools.
02:10:08.322 - 02:10:55.380, Speaker F: So essentially matching things using Fhe, potentially threshold Fhe versus NPC. I don't know if that gives better context. My understanding at least is that garbled circuits are not super efficient. The other kind of overall challenge really has to do with what kind of communication you're expecting between the parties. I would say MPC is very well suited for web two use cases where you don't mind quite a bit of interactivity, maybe you don't mind doing some offline bit ahead, but threshold Fhe really reduces all of the communication. The party provides their encrypted data, they disappear, they don't really need to do much of anything. And that can be very nice depending on what kind of application you're looking at.
02:10:59.750 - 02:11:02.610, Speaker A: Any other questions from the floor?
02:11:18.820 - 02:11:35.590, Speaker D: Yeah, so, kind of broad question so has anyone done any tests? What amount has been done with stacking ZK with FHV? What do the numbers look like? Is there any practical implementation yet? I'm guessing no.
02:11:37.560 - 02:12:44.372, Speaker F: Yeah, so we have been doing some of this work. Ourself we have a ZKP compiler and the eventual goal is to be able to combine both the Fhe and ZKP compilers. So in terms of why even the code looks like this, the goal is eventually that in addition to being able to specify Fhe programs with a specific Fhe scheme, you will also be able to write things with VKP programs, specifying the particular VKP system you would like to work with, depending on what you want to do. The times can be pretty bad for all proof systems we've seen. So if you're kind of looking to prove that some input is well formed, the times are around 2030 2nd range for kind of a reasonable machine, say like my MacBook Pro that I'm on right now, verification times if you're willing to throw a decent amount of hardware at it. So we're talking bigger AWS instances you're getting around one to 2 seconds verification time. There is some work from other folks in the space to improve at least the prover times as well as some of the proof sizes.
02:12:44.372 - 02:12:53.340, Speaker F: So the proof sizes we were seeing were around one to 2 KB. There is some work to kind of drop it to the hundreds of bytes range.
02:12:55.760 - 02:13:38.110, Speaker A: Also just something I was thinking. Is it fair to say that if you are using Zkfhe then your assumption is that you are running your fhe on a single machine and that you don't obviously have to, I guess, trust the validity of the compute. But alternatively could be that you use tfhe in a way that you kind of have re execution of the same compute across different nodes that are sharing the keys. Is that sort of like the alternative options where you kind of have more trust based instead of the proof based approach here?
02:13:38.960 - 02:14:05.428, Speaker F: Yeah, you can definitely have that. So it is an option for everyone to re execute the Fhe computation. But for that to be particularly viable, you almost certainly need those parties to be using FPGAs to get very fast times. So if we're talking like we want maybe in 500 less milliseconds depending on the computation, you really do need the FPGA piece.
02:14:05.594 - 02:14:30.540, Speaker A: I see. So basically like you're saying, either way you will be adding some overhead from the tfhe side it would be like the key sharings as well as the node communications. And then on the ZK side it would be just like the proof generation side. It's kind of like a bit of a trade off and both are kind of like a trade off in terms of having more overhead on top of the Fhe compute.
02:14:31.440 - 02:14:33.372, Speaker F: Yes, I would say that is correct.
02:14:33.506 - 02:14:40.910, Speaker A: Gotcha there's a few more questions. Speak it up.
02:14:41.600 - 02:14:43.730, Speaker B: I want to ask a question.
02:14:44.180 - 02:14:47.244, Speaker E: What do you think about Fhvr versus.
02:14:47.292 - 02:14:50.210, Speaker B: VKV in terms of scaling problems?
02:14:54.680 - 02:15:27.836, Speaker F: Yeah, if I heard the question correctly, it was Fhe VM versus like vkvm. I don't think Fhe is like a good scaling solution. Personally. It's a great solution for applications where you need privacy and you need to do some computation on different users data. So I would stick very strongly to it's. Maybe great for DEXes, it's great for dark pools, it's great for mev related stuff, potentially blocks based auctions. But is this going to be like the scaling solution? I don't think so.
02:15:27.836 - 02:15:35.360, Speaker F: I think VK is much better suited to scalability, whereas Fhe is suitable for privacy.
02:15:37.220 - 02:15:59.960, Speaker B: Gotcha. Daniel hello. Yeah, I'm Daniel. So I just have some very interesting questions. Like I only have very basic knowledge about HD. I do know like in HD encryptions there are PhD partially and they are also like somewhat because somewhat.
02:16:02.140 - 02:16:03.204, Speaker A: Like FH.
02:16:03.332 - 02:16:08.030, Speaker B: Which is the ultimate goal of all the encryption. So what I'm thinking is.
02:16:10.080 - 02:16:10.796, Speaker E: Because right.
02:16:10.818 - 02:16:23.760, Speaker B: Now FHG still like we don't know whether we can actually achieve Fhom. Right? So why now? There are some application using somewhat.
02:16:27.620 - 02:16:28.396, Speaker C: Applications.
02:16:28.428 - 02:16:42.230, Speaker B: Because multiple chain, just multiplication and plus and minus, right? Even uniswap just x times y equals K. So why not let's do sh even.
02:16:47.500 - 02:16:48.970, Speaker C: What is the reason behind?
02:16:50.700 - 02:17:23.632, Speaker F: Yeah, so there are quite a few applications that don't do both operations on encrypted data. So you're right, there's kind of fully homomorphic encryption, there's partially homomorphic encryption and somewhat homomorphic encryption. There are places where you can just get away with doing addition and multiplication by a constant. So for example, there's Penumbra, which is trying to implement some kind of batch auction. They really only need to do addition on encrypted data. So they don't need Fhe, they just use El Gamal, if I'm not mistaken. But there are other cases.
02:17:23.632 - 02:17:50.300, Speaker F: So, for example, I want to do an auction and I want to sort it. Maybe I want to know what the second highest bid is. That cannot be done with the other technologies that really requires the full power of Fhe. So depends what you're looking to do. Plenty of applications can suffice with just doing one kind of operation over encrypted data. Other applications really need more to make them doable.
02:17:52.160 - 02:17:56.670, Speaker B: Thank you. Any more questions?
02:17:58.800 - 02:18:17.908, Speaker A: All good? All right. Okay. Thank you very much today, Rabbitawal. Sorry for the camera glitch here, but we are all smiling here and super excited for the FHG stuff. So thank you again, Rabbito, for the great presentation today. Thank you very much. Thank you.
02:18:17.994 - 02:18:19.590, Speaker F: Thank you. Bye, guys.
02:18:21.560 - 02:18:46.412, Speaker C: Hey, so thanks a lot, everyone, for speaking with us. This place like, it's 07:30 or something, and I know it's really late, and I'm the only roadblock between you and the dinner. I'm trying to be a little bit quick, and we are also late. I know it has been a long day, starting with vitalisto, so I know that you are all tired, so if.
02:18:46.466 - 02:18:47.916, Speaker E: You are lost, it's okay.
02:18:48.018 - 02:19:14.888, Speaker C: Just feel free to interrupt me and ask questions. Or if you are completely lost and you don't want to ask questions because you feel embarrassed, and then just read the paper. It's a nice cryptographic paper. Obviously, I'm biased. So it's called Cicada, which is a private, non interactive launch in voting and auctions. Joe's work with noemi Michael and Joe. And, yeah, let's start off with some interactive questions.
02:19:14.888 - 02:19:24.232, Speaker C: So how many of you have ever bidded or bought an NFT on OpenSea or whatever? All right, so I have a bad.
02:19:24.286 - 02:19:25.304, Speaker E: News for you guys.
02:19:25.422 - 02:20:28.636, Speaker C: All of your bids are on the public blockchain, so everyone sold them. How much you were willing to pay for those NFDS? How many of you have ever participated in a Dowel voting? Like uniswap voting or compound? Okay, I have bad news for you guys, because all of your ballots or your votes are publicly visible to everyone on layer one or layer two or wherever this vote took place. And the question is, like so there's this sad reality of the status quo of on chain voting and on chain auctions bidding. So the votes are public. There's a trusted third party sometimes if you know Macy, how many of you heard about Macy or Semaphore? So they are saying that it's okay because only the coordinator sees the vote. We should aim for something which is trust minimized. And usually all these even if they are providing some privacy, usually they follow the paradigm of commit review.
02:20:28.636 - 02:21:11.384, Speaker C: So the idea of commit review is real simple. People commit their bids or votes, and then there's a second phase where they rebuild their bids or vote. And so we don't really like I'm not a developer, so please chime in if you want, but I don't think, like, multi round protocols for voting or bidding will make it. So I think if I was a developer, I think it's a usability hurdle and there should be a lot of friction. So we would like something which is non interactive. So we want that all our NFT bits and on chain governance votes are private, remain hidden. We want a solution which is trust minimized.
02:21:11.384 - 02:21:42.420, Speaker C: We don't want to trust a single coordinator for privacy because it's not really private. So we don't want to trust in anybody. And we also don't want a multi round protocol. We want a non interactive protocol. You just submit your secret bid or secret ballot. You can go to Istanbul and enjoy the ETH dev, connect with your friends and of course, plus one. We also want this scheme to be efficient such that we can execute it on chain.
02:21:42.420 - 02:22:22.028, Speaker C: So if you don't want to read the paper, if you want something a little bit more lightweight, then you can read this great blog post by Michael on the A 16 D blog. Here's the link to it. I should have put QR code, sorry I didn't make it. But you could say cryptographic literature is Wasp. So there should be previous approaches in trying to tackle the problem of privacy, preserving, voting and auctions all these four things that we want to achieve, like none of them achieved. So commit, reveal. As I said, it's non interactive.
02:22:22.028 - 02:22:56.140, Speaker C: As we already heard in the previous talk, fully homomorphic encryption or timelock puzzles are non efficient, so they are also not going to make it on chain. Like it's kind of way out that we will be able to implement them in a solidity contract. MPC is also non interactive, so it's a multi round protocol and usually there's some form of trust assumption like K out of N or something like that. You have a question?
02:22:56.210 - 02:23:12.224, Speaker B: Yeah. Recently arguables published a paper about doctor. They introduced a concept named Ductal. It's based on SGX voting. And when you tell about these solution.
02:23:12.272 - 02:24:13.332, Speaker C: And approaches, I want to learn about maybe I'm too cyberpunk, but I don't like any STX solution. I don't want to trust intel and anyone, I just want to have an on chain smart contract and that's don't and I don't want to trust any American or other Chinese or so I just want to motivate that. Previous approaches in the cryptographic literature are not satisfactory for our purposes. So that's why we chose homomorphic timelock puzzles, which hopefully by the end of the talk you will all like and love. Okay, what is homomorphic time puzzles? So they were proposed in a paper by Julio Malavolt and Aravind Yagarayan. Sorry, I'm not good with Indian names, so feel free if there's an Indian to correct me. So the idea is that you have a message that you can put into, let's say, a time lock puzzle.
02:24:13.332 - 02:24:58.592, Speaker C: You can think of it as a ciphertext if you want, and anybody can open this ciphertext given some time. This is PA timelock puzzle. So if you want to open this time lock puzzle, I don't have a pointer, but what you need to do is you need to take the first component of this timelock puzzle. This timelock puzzle consists of two elements. The first one is an element modulo N. The second is an element modulo N squared. And if you want to open this ballot or bit, all you need to do is you need to take the first component and raise it to a delay parameter, a delay parameter which will basically repeated Squaring.
02:24:58.592 - 02:25:59.396, Speaker C: If you do enough repeated Squaring, then you will be able to recover S, which is some secret. And there's also typically secret, the time parameter is like two to the 40 or two to the 45, depending on how long will be the bidding period or the voting period. And there's also another type of timelock puzzle called exponential algama, because it's basically Algama encryption. But in the exponent, if you're not a cryptographer, it's fine, it's just only for the cryptographers or if you're interested in cryptography. But what we really want is to do some basic operations as Daniel's question alluded to why aren't we satisfied with partially homomorphic encryption or timelock puzzles. And this is enough for voting, for instance. And so what we want is not only timelock puzzles but homomorphic timelock puzzles.
02:25:59.396 - 02:27:10.560, Speaker C: So we want the ability to do some basic operations on top of the timelock puzzles, namely addition. So given three messages, we can combine these three messages time lock puzzles, combine them into a single time lock puzzle, which will now encode the sum of the underlying secrets. Or you should think of the secret as bid or a ballot that you bid for the NFT, or you vote in a uniswap governance something. And now you also see that in the exponential agile case in the exponent, suddenly you have so this is the beauty of homomorphism in the exponent, if you take two exponential algorithmal htlp and take the multiplication of the corresponding coordinates or elements, then suddenly in the exponent, you will have a sum. And this is in most voting schemes, this is what we need. Okay, so this is kind of our architecture. So even if you don't understand the cryptographic details, we can talk about it during the dinner or you can just forget about it.
02:27:10.560 - 02:27:54.668, Speaker C: But for a developer, this is how cicada looks like. So this is the on chain part that you can see in gray, and this is implemented as a smart contract. Now let's just talk about binary votes or yes or no. I don't know. Do you want Trump to be the president or no or biden or whatever? So you can vote either zero or one and the smart contract will run a running tally which we'll just call and aggregate Hdlp. The smart contract will run some checks on the Hdlp ballots. All the ballots or bids are homomorphic dimelog puzzles that I will just call Hdlps for short.
02:27:54.668 - 02:28:32.890, Speaker C: And the Smart Contract given some checks on these Hdlps, whether they are well formed or not, whether they are encoding bits or not, the Smart Contract will add all these votes together and after some time, an untrusted party. Can open this aggregate htlp and an untrusted party can open this htlp and send approved saying that this is the solution to the Aggregate htlp. So this is the result of the vote or the biding and.
02:28:35.040 - 02:28:35.644, Speaker D: Once you.
02:28:35.682 - 02:29:51.700, Speaker C: Opened or this untrusted server opened this aggregate HDRP, then we might do some computation on top of this sum of the secrets and then we can announce the winner in case of an NFT bidding or the result of the voting. Note that now we only have only have I mean, it's still better than the status quo. We only have privacy to the point where the untrusted server opened the aggregate Htrp because by the time anyone could have solved all the rest of the bid or ballot htrps. In the paper we also show how you can extend this partial privacy, if you will. But for instance, optimism said to us that for them in some of their applications, it's enough to have this partial privacy. But in the paper we will show with some clever crypto techniques we can have privacy forever even with htips, which is kind of a nice interesting new result. So that's the period where we have ballot privacy and then in the paper we show how to have privacy forever.
02:29:51.700 - 02:31:13.352, Speaker C: Okay, so what do we do is we show in the paper how to have how to support with homomorphic time loop puzzles different types of voting schemes because you might not only want to run binary voting, but maybe you want to do cumulative voting, range voting, quadratic voting. So in the paper we show how to implement with htlps these different types of voting schemes. Yeah, rank choice voting and so on, we show how to do sealed bid auctions with htlps. If you remember, my first question was like have you ever bidded for NFT? So if you would use or OpenSea would have used Cicada now all your NFT bids will remain private. Show in the paper how to have everlasting ballot privacy and this is not that important for this audience, but there's some more academic results in the paper. So basically what's the different properties of these voting schemes is summarized in the table. This might be too fancy before the dinner, there's not much carbohydrate in your brain.
02:31:13.352 - 02:32:19.250, Speaker C: But the point of this table is that cryptographically all these different schemes that the social scientists and political scientists came up with, it's kind of easy to cast in our formal languages or they are all homomorphic and nice. Basically we just need to add things up either on vectors of integers or just binary is the most simple because in a binary voting you just need to add integers. But let's say if you want to have binary voting for multiple, that's called approval voting. So if there's multiple candidates, then you can think of all these binary votes for the multiple candidates as a vector of integers. So even if just we have integers or vectors, they are the same. Okay? It's easy to represent vectors in case of multiple candidates, it's easy to represent vectors as integers. Basically you can think of like map all the vectors to some numeral system.
02:32:19.250 - 02:33:04.572, Speaker C: Let's say there are okay, I think I lost you guys. So there are many ways. Given an integer vector, it's easy to map the integer vector into an integer, which is obviously might be a huge integer in a bijective way. And basically we want that certain ballot is mapped to an integer because inside the prime log puzzle we can only put an integer, not an integer vector. And there are two ways to do it as far as we know. The second method is somewhat new and was never in the literature written down. Okay, so let's just stick to the most simple example binary vote.
02:33:04.572 - 02:33:49.776, Speaker C: Do you want Trump to become the new president or not? Or do you want Biden to remain? So again, R is some randomizer, s is the secret. So either zero or one. So this is how an exponential Hdlp ballot looks like. And the user, when they submit their vote to the smart contract, they need to prove that this ballot is valid form. What does it mean? It means that the user needs to prove that this discrete logarithm is either zero or one. This is what they need to prove with Nic case. So more formally, the statement is that the discrete logarithm between u and v is the same.
02:33:49.776 - 02:35:10.920, Speaker C: So the discrete logarithm between U and G is the same as the discrete logarithm between V and H. Or this is in the case if the user voted zero or the user needs to show that the discrete logarithm between u and G is the same and v times inverse of y and h so my point is that you can prove this with some you don't need ZK snarks like all the day we were hearing about ZK snarks and these heavy tools like nuclear bombs. But you can do this with some nice algebraic proofs called Sigma protocols. So with the Sigma protocols, you can prove that an htlp either encodes zero or one and the tally will look like. So if the smart contract accepts this proof, then the tally htlp, the aggregate htlp will encode, will be refreshed, will be updated and it will encode the sum of the due to the homomorphic properties of exponentiation, it will encode the sum of the votes. So you can imagine that as more and more users are adding their ballots to this running tully, you will have more and more S. One S, two S, three S, four, blah, blah, blah.
02:35:10.920 - 02:35:35.520, Speaker C: At the end of the protocol, someone will solve this aggregate HDRP and then we can recover this in the expo. Okay, here you can see how we can have Hdlp based voting scheme for cumulative voting or sealed bid. Maybe let's talk about it during the dinner.
02:35:37.140 - 02:35:38.864, Speaker B: Okay, so how can we essentially our.
02:35:38.902 - 02:36:11.108, Speaker C: Protocols, so, depending on the parameter meaning the number of candidates and the number of candidates and the number of users, you might want to use different types of cryptographic groups. Either you want to use exponential algamol HDRP or class group based Hdrps, or as I mentioned, like Pi based HDRP. Maybe this is already in the beach. I don't know how much time I have left. Some performance evaluation. So we have a nice implementation on GitHub. It's open source.
02:36:11.108 - 02:36:33.044, Speaker C: If you go to I will have a link to that. I will have a slide about that. So if you go to GitHub.com, asystakeda you can have a look at our open source implementation. We also wrote in the paper some performance evaluation. So as you can see, it's not that super efficient on chain. So maybe you want to do it on a layer two.
02:36:33.044 - 02:37:21.956, Speaker C: So, for instance, if you want to do a sealed bid, auction, bid 14, or this column, this row is the number of bids in the bid. So the precision of the bid. So let's say it's like a user, basically if they want to bid for an NFT, they need to pay like millions of gas. I know it sounds bad, but they will have price. Maybe it's not a satisfactory answer, but yeah, this is the state of the art. So we definitely should improve on these numbers for a binary vote. If you want to cast like whether you want to vote for biden or Trump, then half a million gas, let's say $10.
02:37:21.956 - 02:38:07.970, Speaker C: If you want to do a cumulative voting, then it gets heavier, like $100. Field predochan is again like $100 for eight bit bid. So you need to specify the precision of the bid. And the more bits of the bid there is, the more gas you need to pay for these ballot correctness proofs or bid correctness proofs. Because whenever a user submits a bid or a ballot, they need to prove that the bid or the ballot is well formed. And usually these proofs are quite heavy on chain, but obviously you could throw a snark on it and then it will become easier or more gas efficient to verify. But we didn't do that.
02:38:07.970 - 02:38:24.680, Speaker C: It's maybe left as an exercise for all of you guys because you are much better than me in implementing ZK snarks. So obviously you can prove all these statements inside a snark and then it will be much more efficient.
02:38:25.180 - 02:38:26.090, Speaker E: All right.
02:38:29.580 - 02:38:36.830, Speaker C: I'm not going to explain how we can have everlasting ballot privacy, although that's one of the interesting contributions that we had.
02:38:37.280 - 02:38:37.692, Speaker D: Yeah.
02:38:37.746 - 02:39:09.350, Speaker C: So this is where you should go. I think this is maybe more interesting to this audience. So we have a nice repo with all the code, which is open source future work. Hopefully optimism will implement it for the retroactive public good funding, who knows. Fingers crossed. If you're interested in implementing it or deploying it for some application in your Dao or I don't know, let me know. Would be really curious to hear it.
02:39:09.350 - 02:39:49.472, Speaker C: Yeah, we should definitely make CKDA more performance. We could use multiplication algorithm and so on, many other techniques. Or you could just prove everything inside the circuit, inside the CK snark and then like it's long or start or whatever, and then it will suddenly become much more efficient. But obviously it will also cost a lot of developer time. And sadly we need to rely on a trusted setup because we are using RSA groups. Okay, so there are many more details that I don't want to talk about.
02:39:49.526 - 02:39:49.792, Speaker B: Now.
02:39:49.846 - 02:40:14.650, Speaker C: Maybe we can expand on it during the dinner because I hope that all of your stomachs are empty. So maybe I will just wrap up. Feel free to shoot a mail to Noemi to me or Joe Michael. And if you're interested in this work and want to build on top of it or deploy it, let us know. But we'll be curious to hear your thoughts, comments, critics, whatever.
02:40:15.360 - 02:40:16.270, Speaker D: Thank you.
02:40:22.640 - 02:40:27.470, Speaker C: All right, any questions from the audience here?
02:40:31.200 - 02:40:32.780, Speaker D: Oh, Bobby.
02:40:36.900 - 02:40:38.064, Speaker E: Main part of the cost.
02:40:38.102 - 02:40:39.168, Speaker D: Of like whatever it means to be.
02:40:39.174 - 02:40:42.550, Speaker E: Done on chain is elliptic curve operations or is it something else?
02:40:44.280 - 02:41:16.664, Speaker C: Yeah, good question. So essentially the problem is that we don't use Elliott curves. We need to use so called groups of unknown order, like RSA groups. So these are large integers, integers with 1000 bits. And obviously these are not supported natively in Solidity. So Michael developed a nice library which builds on top of Solidity. So as you might all know, solidity only supports integer arithmetic for 256 bits.
02:41:16.664 - 02:42:09.628, Speaker C: But for factorization to be hard, we need much larger integers, integers of size more than grids. And the problem is that for the timelock, puzzles do not exist. As far as we know for elliptic curves only exist for groups of unknown order where the order is not known. Such groups are RSA groups or class groups of imaginary quadratic fields. Doesn't matter. So the bulk cost is to do all this integer arithmetic inside Solidity because all these proofs are we are using not Snarks but Sigma protocols. And inside the Sigma protocol verifying these Sigma protocols require a lot of large integer array method, exponentiation multiplication of large integers that are not natively supported inside EBM.
02:42:09.628 - 02:42:53.916, Speaker C: You know better, you are a way better developer than me. So I'm explaining to him so that's why it would be nice if you could just throw a stark proof on it or plumb proof on it and then all this integer arithmetic could be verified inside the circuit. That would be huge because then we would have just constant verification cost of 300 or 250,000 yards. But I suppose implementing integer arithmetic inside no, it's not that big, Bill, I don't know you could certainly do that if you want to chime in.
02:42:54.018 - 02:43:08.370, Speaker D: Okay. I mean like doing groups of unknown order. Yeah, no, I mean it's certainly that's kind of the core use case. I don't know how the form would be to blow up the compiler but.
02:43:09.700 - 02:43:13.016, Speaker E: Can you use non determinism to speed it up like inside the CKP?
02:43:13.068 - 02:43:13.670, Speaker D: Or.
02:43:15.720 - 02:43:18.950, Speaker E: You need to compute everything in a proper way.
02:43:20.280 - 02:43:22.340, Speaker C: What do you mean by non determinist? Now?
02:43:22.490 - 02:43:31.528, Speaker E: So in ZKPs we can, let's say provide the answer and if the answer is much easier to verify then you would compute it outside of the GKP, provide the answer and just verify the.
02:43:31.534 - 02:44:01.520, Speaker C: Answer inside the so for instance, I think you can have some techniques like this to verify multiplication for instance or exponentiation. I can see it for multiplication, not sure for exponentiation. So for such techniques I would be really interested to see to make, as Adam said, to not blow up the compiler. I'm not sure if those are the words you are using.
02:44:01.590 - 02:44:09.430, Speaker D: Yeah, maybe it shouldn't. It should work. It might just hit some practical issues that would just then be bug reports not going to work for you.
02:44:09.800 - 02:44:28.908, Speaker C: But generally I would be really interested to hear or learn about all these tricks that we could use not only for RSA, but I just have some.
02:44:28.994 - 02:44:50.676, Speaker B: Questions about the approach to reaching the private voting. I'm not saying like this approach is not right, but I'm just saying in terms of privacy, there are many ways to achieve first way is let's hide all the things. This is basically let's hide all the data, encrypt all the data similar to.
02:44:50.698 - 02:44:52.628, Speaker C: That'S what Fhe is doing.
02:44:52.794 - 02:45:29.870, Speaker B: And there are another way which is let's corrupt the data. This is what differential privacy is doing. Instead of encrypt everything, we just destroy the entire database. That make people not verify who is voting yes, who is voting no. So what I'm saying is I feel almost 90% of the privacy environment can actually be achieved through differential privacy. Like similar to do we really need to build a privacy preserving chain or we can just use EVM plus committal cash.
02:45:31.600 - 02:46:18.072, Speaker C: Let's just stick to differential privacy and if you don't like my answer or don't agree with it, then you can correct me. So I think a differentially private voting scheme on Ethereum would mean that as a user you need to prove that this ballot was computed correctly. So my vote is X. And I added Laplacian or Gaussian. Noise to this vote correctly. Again, I'm not Bobbin or Adam has way more knowledge in this, but I guess proving such a statement in a circuit, it's non trivial. So basically what you want to prove that my vote is x and I've added a gaussian sampled random number to this correct.
02:46:18.072 - 02:46:51.770, Speaker C: So my point is that differential privacy is not enough. What you want is it should be verifiably differentially private because the user needs to prove that their ballot is valid. Because if I just add some random stuff to the contract, then it would destroy everyone else's vote as well. So I'm a little bit skeptical about differentiated private voting because it might have also a lot of overhead. But generally the idea is interesting.
02:46:53.740 - 02:46:56.010, Speaker B: We can discuss more because it's been.
02:46:57.340 - 02:47:21.440, Speaker C: If you want to implement it and you need some help, I'm happy to look at it because I think it's interesting. But the thing is that you will need all these ballot correctness proofs anyways because you cannot assume that the users are honest. So the users might be malicious and then you need to ask all these correctness proofs from the users correctly.
02:47:22.260 - 02:47:31.076, Speaker B: Justifoya in Paris, the winner of Zik Lambda did a protocol on differential privacy on stackwork. So maybe for you.
02:47:31.178 - 02:47:33.030, Speaker C: So they just implemented what.
02:47:36.360 - 02:47:48.420, Speaker B: I'm not sure if it's exactly that problem, but you can in traditional database, differential privacy or encrypting data is very common. That's basically what AWS what they are trying to do.
02:47:48.510 - 02:47:50.396, Speaker D: So what I'm thinking is maybe you.
02:47:50.418 - 02:47:55.276, Speaker B: Can benefit this because not everyone is chasing fully privacy. Like, to be honest, I don't mind.
02:47:55.298 - 02:47:57.020, Speaker D: My go for think.
02:47:57.090 - 02:48:22.996, Speaker C: Okay, so going back to your question, I think it's an interesting question. For bidding it might make sense, but maybe for voting, I mean if there's noise for the number of trump votes and the noise for biden votes, it might be the case that not the actual winner. So if it's a closed vote, maybe the random noise will differentiate between them. So I'm not sure whether differential privacy.
02:48:23.028 - 02:48:24.920, Speaker D: Is applicable for voting.
02:48:25.340 - 02:48:29.128, Speaker B: Yeah, I just randomly saw about this.
02:48:29.214 - 02:48:46.430, Speaker C: Maybe there's some difference, but for auctions it might be useful. Thank you, Mark. There's maybe one more question here in the first row. One more question.
02:48:52.240 - 02:48:53.916, Speaker D: I'm just curious about this part because.
02:48:53.938 - 02:48:55.356, Speaker B: I'm debating when you hold half a.
02:48:55.378 - 02:49:00.720, Speaker E: Talk for this, but can you talk really briefly how you arrived at the Everlasting privacy?
02:49:03.240 - 02:49:22.090, Speaker C: Maybe we can cut here and then is there any other question? I'm happy to is there any other question? Because I don't want all the others to stay while they are already dreaming about dinner, but I'm super happy to answer.
02:49:24.380 - 02:49:44.108, Speaker A: All right, great. All right, another round of applause for respond. Okay, so that's it for today on the privacy workshop. I know you just came, but unfortunately.
02:49:44.284 - 02:49:45.408, Speaker B: Everything will be recorded.
02:49:45.494 - 02:49:55.908, Speaker A: So we'll publish it accordingly. But yes, thank you everyone for coming. And we have a dinner just right across.
02:49:55.994 - 02:49:57.796, Speaker B: So if you've been, you should know.
02:49:57.818 - 02:49:58.724, Speaker D: Where the dinners are.
02:49:58.762 - 02:50:00.308, Speaker B: Just in the other room.
02:50:00.474 - 02:50:05.716, Speaker A: And yeah, everyone else, please feel free to have dinner. And it's all free.
02:50:05.898 - 02:50:07.956, Speaker B: Do whatever you want time now, so.
02:50:08.058 - 02:50:10.550, Speaker A: Yes, please feel free to discuss more.
