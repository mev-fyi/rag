00:00:00.410 - 00:00:37.430, Speaker A: You Kenti from Aztec Protocol and just kind of like briefly on Aztec it's a privacy preserving L two. And within Aztec it's an end to end privacy preserved, meaning that you will have programmable and also token level privacy for your, I guess, on chain fractions. So in oknti, I guess feel free to take over and the stage is yours.
00:00:39.630 - 00:00:57.520, Speaker B: Yeah. Hi. Can you see the screen?
00:00:58.130 - 00:00:58.880, Speaker A: Yes.
00:01:00.130 - 00:01:47.950, Speaker B: Great. So, yeah, today I'll be talking about security consideration for ZK systems. First, I'd like to tell a bit about myself. So right now I'm working as an applied cryptographer at the clubs. My focus is mainly on the proving system, on the underlying components of the proving system, and on writing the lowest level circuit, for example, writing such important primitives as unfined integers, emulated fields, stuff like that. So I'm very close to the actual back end of the proving systems and all the complexity that has to do with that. In the past I worked as a reverse engineer and a digital forensic expert, so I had to deal with security quite a lot at a very low level.
00:01:47.950 - 00:03:21.930, Speaker B: And I have seen how attacks on organizations and our applications can unfold. So I have a lot of experience with analyzing what has happened and what you could do to prevent that. Some extra parts of my biography are I am responsible for the cryptographic part of the CTF CTF competition, which takes phase every year and once was a phone qualifier. I found various cryptographic, binary and one CPU bug in the park. And I'm the winner of the first decay. Just to understand what my background is with the security and with cryptographic, with the security of protocols and with the security of cryptographic systems, especially this talk aimed first and foremost at projects that use decay and that use proven systems at a very low level. So it is not aimed at projects that try to build off of such stuff as, for example, Circum, where you have a very small, maybe web application that encapsulates inside a small smart contract or a small Verifier with Teslco.
00:03:21.930 - 00:04:42.322, Speaker B: So this is aimed at projects that either build their own stuff from the ground up or maybe they're using very low level stuff such as artworks and building up on top of that. So in that case, you'll probably be composing your own proven system. So you'll have a lot of moving parts, you'll be writing your own primitives. So there will be huge opportunity for security issues and at the same time you won't be able to share the experience and you won't be able to share the security area and the security coverage with other projects that are using the same tool, like, for example, projects that use silicone. So the template library is regularly being tested by some interested auditors. So to talk a bit about abstec and what we're trying to do to understand what kind of project we are, so aspect is private product. Our Quresi is composable private and public smart contracts that finally settle on ethereum.
00:04:42.322 - 00:05:47.814, Speaker B: So the idea is you have fully private functions and fully private possible smart contracts. You have interaction with public functions where you have updatable public state where you can do operations on public data, so that you don't have to work with subsections nullifiers, just update shared variables and Ethereum is used as the last layer. So we are an L two. This obviously brings a lot of problems for us because we have to be very efficient if we want to implement an operational and viable composable smart contract system. Fully private smart contract system on layer two. Because for us, for example, we operate under the notion of full privacy here. So we have to use the notion of zero knowledge.
00:05:47.814 - 00:06:54.770, Speaker B: We can't just use the zero knowledge primitives for their compression functionality. We also, at least in the private part of the blockchain, aim to make all the functions fully private. So nobody supposed to know who executed this or their function. What was the result of that? You only know what's the public function in scenario to talk a bit more about what our project and what typical projects like this consist of. So obviously the most important part, especially to me is the ZK core. In our case it is a very complex piece of code which has a lot of various ZK technologies inside. I mean, some of the technologies that we created ourselves are our researchers, especially Zach.
00:06:54.770 - 00:08:06.022, Speaker B: Absolutely love weird names for proven systems. So we use a lot of different technologies at the same time. We try to compose them in such a way that we gain the most efficiency from each primitive. So we are one of the few projects that actually have to have this high degree of ZK composability. So apart from the ZK core itself, we need a sequence obviously for creating proofs to satellite ethereum. We also have nodes that need to store various data and we need some sort of web app so that users can interact with the system, so that at least they can maybe download and go and download some information about the system, just find out what we are. Most projects have a website and some sort of web app too.
00:08:06.022 - 00:09:10.170, Speaker B: So this is quite typical for ZK contract. We can't really talk about ZK security without talking about what kind of vulnerabilities are typical in the zero knowledge world. And I think one of the most convenient ways to explain what kind of stuff happens in the ZK security world is to look at it as a huge, just enormous underground system. So imagine that your goal is to go in in one place and go out there. Daddy is nobody should know how you move between the lines, at which station you got off, where you made a connection. Daddy is you just need to get from point A to point B. So if we look at ZK that way, there are three core issues that can happen with ZK systems.
00:09:10.170 - 00:10:46.596, Speaker B: The first assumption, this means that you can manipulate the system to your advantage in a way in which it was not supposed to be manipulated. So for example, you can jump the turnstile or maybe you can go into the driver's cabin in the train and redirect the train to a completely different line. So for example, in the actual zero launch groups circuits, one of the silence issues would be if you could provide, if you could prove that some input to a hash function ends up with the hash of all zeros, this would be completely wonderful. This is extremely unlikely, but if you manage to prove that it would probably be a sound issue. It is also one of the most grievous issues that can happen because this allows you quite often to complete a speed protocol. Imagine that you can prove that you have a million or a billion in your account, that you can easily drain resources and easily drain funds from the protocol. So then there are competence issues that when you try use canceled or you can only create very proof.
00:10:46.596 - 00:11:37.688, Speaker B: You can go to some of the station. So in a regular circuit it would be the same as you trying to prove that the hash of an empty string is this value and not being able to just because for some reason something is failing in the circuit. And this particular use case, maybe it's an edge case, was not thought of by the developers. And the last issue, which is an issue to a project like ours, but not to all the ZT projects, is the issue of zero knowledge. So if you want to preserve privacy, we actually need zero knowledge in our system. Which means that when you create a proof that you only submit information about the fact that the proof is correct. So the proof itself reveals only that the proof was correct.
00:11:37.688 - 00:12:26.570, Speaker B: So this would be like somebody tracking all your movement for the underground or somebody logging the secret you were using for the hash. So how do you deal with all of these security issues both in ZK and in regular applications? Well, one of the things you could do is unit test and obviously it's just healthy hygiene. I think all of the projects are using unit test these days. It's just completely necessary to detect the shallows of bus. Without this you can't go any further. The next stage are end to end tests. It is a mark of a healthy development culture in the company.
00:12:26.570 - 00:13:27.260, Speaker B: It helps detect problems with complex interactions at a very early stage in the development of an application. One of the problems with end to end interactions that they are not scalable and it is very hard to cover all the use cases that various users would probably trigger. So it is just great to see that components are working together the way they were intended to, but it is not a very expensive testing. The next thing you can do, itera audits. We've done quite a lot of these. One of the major benefits from them, apart from increasing the security of your solution, is that you also raise the level of your team. Because people start interacting with new parts of the code base they haven't been accustomed to, they explore new stuff.
00:13:27.260 - 00:15:03.108, Speaker B: It's always nice to have redundancy in the skills of your team, so that if, for example, one member of a team decides to leave you, there's always somebody in place who knows a particular critical component. One issue with internal audits is that they consume enormous resources because basically your team has to stop developing at the time you can't audit something that is under active development, and just reading the code is not a very interesting process, so it is quite slow. Also one of the issues is that you have to also one of the issues is that rereading the same part of the code base again and again produces diminishing returns with each new iteration, especially if you're working on components that are constantly being developed and updated. External audits are actually worse most of the time because for an external audit to be efficient enough, your project requires very decent documentation so that you can get the auditors up to speed quickly. Complexity and novelty of your project decreases efficiency for the simple reason that the auditors will have probably not seen this particular system used anywhere else. It's a very complex system. Maybe they have seen some components, but not the whole structure.
00:15:03.108 - 00:16:07.490, Speaker B: It is very pricey to reuse. And yeah, once again, does work well with active development, because the changes that you've made to the code base after, for example, six months may change the whole, may have changed the code base so much that the whole previous audit would have left no profit for you at all. And also one of the issues with audits in general is that they work really well. When there are repeatable patterns in various projects. For example, let's say various projects are writing signature code for ECDSA, then internal auditors can come and say, oh yeah, I'm accustomed to distributive, I know what kind of stuff happens there, what kind of problems and issues can arise? Let me look. I'll find the same problems here. If you are doing something completely novel, or if you are composing very new ideas, it means that the auditor actually has to learn what you are doing.
00:16:07.490 - 00:16:58.640, Speaker B: Obviously, there are some issues. So, as we can see, if we accumulate all of these four standard mechanisms together, we won't have all of the code base covered and we won't get rid of all the bugs anyway. So some of the issues are that audits are hard to reproduce, they drain resources. Testing usually tends to be very shallow, it doesn't cover tick bugs. So what can we do? Two of the deeper techniques that are used with Ski project nowadays are parting and formal verification. So one of the techniques that we're using is parting. You can think about it.
00:16:58.640 - 00:18:33.192, Speaker B: The one step forward from drafting Derry is that a program explores your program, your build system, your program in such a way that it automatically finds new and interesting inputs that would change the behavior of your program. So where testing is just randomly throwing data at a function that might have issues with padding is that the program actively tracks which parts of the program are being touched by a particular input. So which parts of the program light up and then it remembers those particular inputs and tries to mutate them so that you uncover deeper and deeper parts of the program. It actually proved quite efficient in our case. It's great for testing composable primitives, especially if we're talking about in circuit primitives where the ide's constraints are dependent on how you compose those primitives because then you can track the composition of the circuit and use it as a metric for the father to explore deeper. It is not as good for fixed circuits because it has less information. Working home verification to me works a bit like magic.
00:18:33.192 - 00:19:21.260, Speaker B: The problem is sometimes it can refuse to answer you. It's one of the few methods that can detect soundless issues. There is some tooling like Barridizing stickers for example, that can be used as a reference or using Circum, you can use it directly. The problem is that modern provers have either effective logic or finite field logic and it doesn't really mix very well. And a lot of the time we are trying to approximate binary logic on top of finite fields, which tends to have been efficient. And if your project is using Lookups, then it's basically uncharted territory. It is very hard to use Lookups with finite field theories.
00:19:21.260 - 00:20:30.596, Speaker B: With finite field theorem solvers just because you have to in COVID gate with like hundreds of thousands of rules. I'll breeze through additional parts of the project other than decay. Other parts of the project are the infrastructure. So here you can obviously one of the issues are architecture issues with this it is probably best to go to professionals just because there are several firms on the market that actually deal with this kind of stuff. They can simulate the protocol, they can understand what the issues are and then there are the implementation bugs. So what do we do? Yes, we document religiously, we ask auditors to simulate the protocol and we do have a definite fuzzing during the development lifecycle. So to get rid of as many bugs as possible, we also have to think about the web application.
00:20:30.596 - 00:21:26.256, Speaker B: Unfortunately, even for more than web three projects, there are still considerations in the web world. So not everything. For example, broken authorization is not as crucial most of the time, but several wishes and Novascular trends still can plague your application. So this is still something you have to consider. Once again, it is probably best to go to professionals for this and not try to understand the security of web applications by yourself and your team, just because it is a very separate area of cybersecurity. So just last thing is CI CD and processes. So some of the issues that all projects are outdated components, sometimes weird stuff is found in those, maybe they're weird bugs.
00:21:26.256 - 00:22:18.580, Speaker B: So you have to update them regularly, but don't make them automatic because sometimes there are supply chain attacks. Let's say somebody forgot about their GitHub account or their GitHub account got hacked. There's a new shiny package, your application automatically updated to the latest version and now your users are experiencing an attack just because you've imported this package. Then there are standard security misconfigurations in the CI CD. So you have to be careful how you use secrets. For example. So in here you can consult with professionals and actually traditional auditing teams are quite good at explaining what to do and what not to do and engaging with and you can easily engage them.
00:22:18.580 - 00:23:12.564, Speaker B: And yeah, not Korean job candidates, turns out. Also Ethereum had this, we have this. So you always have to delineate the security in your organization. So how should you stop worrying about security from the start? It is important to assign areas of responsibility in your organization. So somebody has to be responsible for the web application, somebody has to be responsible for the security of the proving system, somebody has to be responsible for the processes. Introduce a process for documenting the security considerations for build components. So once you've built something as a top of concept, just write a few lines in the doc about what you are worried about how you should be securing this in the future just so that you start the process of thinking about security of that component.
00:23:12.564 - 00:24:09.812, Speaker B: If even you are just starting fixing regarding components as a triggered metric. So, let's say we have several primitives in our code base which we have to change quite often, which means that, well, probably there are bugs in them at one point to other, we constantly change stuff. So it would be nice to have some more extensive testing techniques such as body for them. So if you have components such as that in your system, it would be great to look at that. Establish growth and maturity triggers for organizations. So, for example, if there are 40 people in the organization now, maybe there's a point into the cabinet, efficient exercise just to see how good you are against North Korean candidates and consult with professionals on non decacious. There's no point trying to do your own security of web applications.
00:24:09.812 - 00:24:44.070, Speaker B: You are probably not the best at it. Deal with professionals. So security is not just a pain. Security also helps you reduce resource waste. For example, once again, if you are working with a particular primitive, particular part of your code base that keeps breaking quite a lot, there are issues. Improving security and improving testing for it can help you reduce resource waste in the long run, just because you don't have to keep going back to fixing it. Now you have a more mature process.
00:24:44.070 - 00:25:31.540, Speaker B: Being open about this and showing others how to do this also brings the other view to your organization. Because you show that your processes are mature, you're showing that you care about code base. This is not just a one day project, so it becomes a talent magnet. And in a field where protocols are broken almost every day, having security in general and improving the security of your project is obviously a competitive advantage. Sometimes you just need to supply the final takeaway. The security of ZK projects is not just the security of ZK proven systems, it's also traditional security. You have to think about other parts.
00:25:31.540 - 00:26:14.000, Speaker B: Somebody has to be responsible for security, even in a small organization. One of the simple reason is if you get hacked, even if you're a small startup, and there are always chances that this can happen, somebody has to be responsible for picking up the phone, figuring out what to call, figuring out what to do. You shouldn't be scrambling to find the one responsible for that. And security is a pain, but it can really help you. It can be a benefit for your organization. So it shouldn't be something left until the end, up until you've almost built everything. Thank you for your attention.
00:26:15.220 - 00:27:03.570, Speaker A: Thank you, Kenti. And I guess just on the questions that I had myself was when you were talking about using fuzzing for securities, one thing that kind of got me curious was how widely used Fuzzing right now for a lot of ZK applications? And also does Fuzzing necessarily, let's say, cover a lot of the soundness aspects of the securities that the formal verifications already covers? Or is that something that I guess fuzzing would not be able to achieve? I guess more in general, what's the part that fuzzing can cover and what's the part that fuzzing cannot cover?
00:27:05.800 - 00:28:21.130, Speaker B: So to answer the first, how widely is Parsing used? I think at the time when I started looking at it, puzzing was used in very few projects and most of the time only rudimentary. So for example, there was a fixed circuit and Python was used to change inputs to that circuit. And this would provide a very limited use of the Python because Python excels when stuff is changing inside the program and it's fixed. Obviously there's very little to but yeah, after that I heard that, for example, there's a company, Parsing Labs, and they're also focusing on doing Parsing for their best project. So they're thinking about security of the key from the Parsing perspective. So maybe right now it is a bit better because there's somebody focusing on it as an external audit. So then about soundness with fatim? Well, I managed to find some soundness issue once with fatigue, it was more by chance.
00:28:21.130 - 00:29:15.150, Speaker B: So it was kind of like some weird stuff happened and it led to completeness and soundness issues. And the completeness issue showed that there was a soundness issue. But no, fuzzing by itself can't really find soundness because unfortunately, in circuits it's very hard to find a proximity metric. So basically you could try and guide fuzzing towards finding a solution that is inappropriate, that shouldn't be your circuit description but still adheres to the Arithmetization. But the problem is, since we're operating in finite fields, there's no proximity between values. I don't know how one would do that. Maybe somebody finds a solution to that.
00:29:16.080 - 00:29:42.036, Speaker A: Got you. I guess in a sense you sort of also foresee buzing is great for just testing out a lot of details and making sure that you can try to cover some edge cases in a more sort of broader programming senses. But you still do sort of see a lot of formal verification starts to be quite necessary companions of fuzzing in.
00:29:42.058 - 00:30:30.630, Speaker B: General, formal verification and maybe some static analysis or intense dynamic analysis for particular properties. Maybe for example, you can look at how the values change throughout your witness when you randomize the inputs. And that can also become a security metric and that could sometimes uncover soundless issues. But yeah, plotting unfortunately is just testing on steroids and it also helps remove programmer biases. So whether testing is I'm just testing what I imagine the circuit could do. buzing is, yeah, I don't care, I'll just push everything.
00:30:31.480 - 00:30:42.600, Speaker A: Do you ever foresee a future where perhaps we may have ZK specific fuzzing where we can, let's say, cater for proximity testing, et cetera?
00:30:44.860 - 00:31:52.040, Speaker B: It is very hard for me to imagine because just the proximity testing by itself the proximity testing by itself is a very it's fundamentally it simply doesn't exist in the finite field. So and we're using finite field and circuit. So that's the core issue. Maybe if we use something, maybe if buzing was used, for example, with NTK DSL, where you have a very strong correlation between the original language tokens and the circuit, then you could kind of do sequential generation and you could try to do proximity step by step, but I assume that it would be very resource intensive.
00:31:52.700 - 00:32:06.990, Speaker A: Got you. Gotcha. I see. Okay. Thank you very much inokenti for the great talk about security today and again yes, thank you very much for the time for today and.
