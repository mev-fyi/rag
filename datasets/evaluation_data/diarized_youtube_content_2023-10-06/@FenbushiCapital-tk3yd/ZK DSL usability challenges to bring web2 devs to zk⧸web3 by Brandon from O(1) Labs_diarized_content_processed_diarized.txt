00:00:00.410 - 00:00:00.960, Speaker A: You.
00:00:02.930 - 00:00:58.986, Speaker B: So we have our next guest here. We have Brandon from one labs and just a little background on one labs. So they have incubated Mina protocol, which is the succinct bridge that we all know, hopefully. And then one labs have also developed a lot of primitive in the ZK space, including likes of Snarky js and so forth. So they are definitely one of the powerhouses, also building a lot of the proof schemes and innovating on top of that in the space. So please welcome Brandon, and we'll have the stage for you. All yours.
00:00:58.986 - 00:01:01.054, Speaker B: So please take it over from here.
00:01:01.252 - 00:01:22.870, Speaker A: Thank you. Okay, let's see if I can share my screen successfully here. Okay, do you see my mouse? Great. I'm going to start. Okay. So, hi. Yeah, thank you for the introduction.
00:01:22.870 - 00:02:21.610, Speaker A: I'm the CTO and founding engineer of one labs, and as we heard, we build what was called Snarky JS. Until yesterday, we just renamed to one js and also incubated the Mina protocol and continued to work on it and other ZK tools. And we have a proof system called Kimchi and a recursive layer called pickles and lots of various things in the ZK space. For the purposes of this talk, I guess I should say the title is ZKDSL usability challenges. So we are going to talk about those things. And so the context under which we're talking is within a ZK DSL, such as on JS. So what is this thing? It is a tool for building private applications.
00:02:21.610 - 00:03:12.810, Speaker A: So it's both a tool that you can use to write circuits directly against the, against the Kimchi proof system and with recursive layer. And it's a tool upon which you can build client side ZK applications that use the Mina protocol layer as a sort of state coordination layer and manipulate the blockchain. Okay, so it's a tool. It's also a ZK DSL on top of ZK snarks. And when building it, when designing it, as we continue to iterate on it, there's lots of interesting usability challenges that arise. So I'm going to talk about that today. Okay, so a ZK snark.
00:03:12.810 - 00:04:07.306, Speaker A: A few years ago, this was a very important slide, or there was a series of slides where you have to explain to people what ZK snarks were. These days, at least, this room probably has a good understanding. But just in a sentence, a ZK snark allows us to argue that we know a thing to a counterparty without that counterparty learning about the thing and they can verify that we really knew the thing very efficiently in space and time. Okay, so what is the thing? Right. The statements that we're arguing, I like to use this particular sort of mental model. I mean, in different contexts, we use different mental models. But.
00:04:07.306 - 00:05:04.640, Speaker A: But this is one such way to reason about these statements. So, like, there exists some data, some private, some public, such that a bunch of predicates hold on the data. That's sort of one way to think about it. If we think at runtime. How are these statements represented in the kinds of proof systems that most folks are building on top of today? It boils down to representing that as a series of constraints on top of some kind of constraint system, like r one cs or some plonkish system. And the fact that I just showed you two such ways to represent things, and there's a lot of different ways. This creates a question as we're designing a DSL, at what level or levels should we be targeting and what are the trade offs? So I guess here's one way to sort of lay it out.
00:05:04.640 - 00:06:01.934, Speaker A: You could just directly manipulate constraints against the lowest level proof system. And sort of one small jump from that is basically what arcworks and halo two, the kinds of interfaces that those systems provide. And some people build not just frameworks for others to build applications, but actually the applications themselves. On this layer, it's great. You're close to the metal, you can poke at things and do things, and there's nothing kind of in your way. If we go a little bit higher, this is where I would put circom. So circom, again, it's fairly low level in the sense that you're really looking at constraints all the time, but you can express them in a more concise way.
00:06:01.934 - 00:07:26.694, Speaker A: You can package things up nicely and sort of, there's language affordances for doing things with ZK circuits effectively, for describing your constraints. If we go another layer up, this is where o one JS sits and where other tools like noir sit, where we're starting to get something that kind of feels familiar to software developers who write software for Turing machines. So there's functions, there's types. If we provide a bijection between field elements, which is sort of the native primitive of these systems, and some complex structure, then we can just reason about the more interesting structure that maps our domain, and the system will automatically convert it to the field elements for us and a bunch of other nice affordances. But fundamentally, we're still controlling the actual thing that gets turned into the snark. Whereas if you go sort of the next level up, you're instead building a ZKVM in one of these other layers. And then the software that folks write, the applications that people write, get run on the VM.
00:07:26.694 - 00:08:37.166, Speaker A: So you're so far away from the actual runtime. And it's great because in that world, the DSL developer, the language developer, has so much control over the kinds of things that the developers can do or that the developers, the kinds of interfaces that are exposed to developers. But in contrast, developers have less power to go and poke things at the underlying internals. So this is kind of the tension I kind of got ahead of myself. But as I was saying, the more indirect, the more flexibility the DSL developer has and the less power that the end user has. But it's easier for end users to jump in and get started and keep a lot of context in their head. And on the other side, the deeper you are, the more power that the user has, but the more complicated and there's sort of more complexity that has to be floating around in developers heads and you need different skills.
00:08:37.166 - 00:10:26.338, Speaker A: So just to highlight this, if we look at recursion, recursive proofs, this is a diagram taken from the halo two book. There's great documentation on how to create recursive proofs with halo two, and if you have the right skills and you spend enough time, you can do it. And building such a system at this layer gives you a lot of flexibility on the kinds of around performance throughput latency, like the sort of desired, well anyway, you can tune a lot of things. Well, if you think about it though, for developers or development team that wants to focus on building a product that users can use to solve a problem that's sort of more directly, I don't know, a social application or a defi application or whatever, maybe that team doesn't want to have to think about all these things. So at the complete other side of the scale, true recursion at the ZKVM layer, it's totally unexplored actually, as far as I know. So I'm not just talking about folding instructions, but actually recursively verifying ZK proofs of other zkvms within yourself. I think the way that this would have to work is it would involve two different proof systems, at least, at least two, because the trade offs that you need to get zkvms to work are different from the trade offs you need to get recursion to work.
00:10:26.338 - 00:11:05.470, Speaker A: And anyway, there's a lot of infrastructure to build and then there would be a lot of compute required to make everything fit together. But if someone were to spend time building such a system, it would be interesting, I guess. So there's kind of an open, interesting system. But anyway, let's look at something that actually exists at the one JS level. This is a snippet of one js. Recursive proofs are represented by recursive functions. And that's, I think, a good abstraction.
00:11:05.470 - 00:11:57.170, Speaker A: The power of recursive proofs is given to developers so developers can build blockchains that incrementally grow forever. That's what Mina is. You can create a tree of proofs in parallel, or you can kind of use a tree of proofs to incrementally update some fact as time moves forward. Or you could make a multiplayer game with different players creating proofs and recursively verifying each other even though they don't trust each other. There's sort of lots of interesting things that you can do, but only if you expose this tool to people. There's this tension. I guess the downside here is we've tuned recursion in a specific way and that isn't as exposed.
00:11:57.170 - 00:12:24.490, Speaker A: You'd have to dig really deep to change those defaults. But anyway, so whatever, I'm belaboring the point. So anyway, this is where OMJs is in that space. But there's another sort of interesting open challenge. This is the theme of this event. Yeah, like talking about challenges. There's obviously a lot of benefits to zkvms.
00:12:24.490 - 00:12:30.282, Speaker A: Oh, yeah, go ahead. You have a question, or was that a miss?
00:12:30.336 - 00:12:33.694, Speaker B: Oh, sorry, I misclicked. I was going to thumbs up.
00:12:33.892 - 00:13:21.710, Speaker A: Okay, great. Zkvms are really useful, especially when they target runtimes that traditional software can compile down to. And actually at o one labs we've created a MIPS ZKBM. I guess it's in between a prototype and something that's real at this point. And it's being further developed as part of an Opstack RFP. We want to take that system when it's ready and integrate it with on JS in some way. And it's an interesting problem, like how do you make these things talk to each other seamlessly? So anyway, I'll just throw that into the ether.
00:13:21.710 - 00:14:10.486, Speaker A: That's sort of one axis of design space that we've talked about and we can think about another one. So the DSL structure or. I don't know, I struggled with the word for this. But what is the class of language that you are going to pick, and I'll sort of break that down more clearly. So if you're making a ZkvM, you can choose to target a real machine, like I said. And then the surface language that developers interact with is actually like a programming language that people are familiar with, down to the sort of details of how it runs. So we're doing that with ZK mips.
00:14:10.486 - 00:15:10.266, Speaker A: Risk Zero is doing it with RISC five. A bunch of teams are experimenting with ZK webassembly, but if you're somewhere lower in that stack that I talked about earlier, then you'll need a new language of some kind or domain specific language. So you can break down dsls into two classes, external dsls, which are ones that are a new language that has its own syntax and semantics and runtime, or an embedded DSL, which is one that lives inside of a host language and inherits the features of that host. So I'll just give a quick example. HTML is an external DSL. It's its own language for describing the content of web pages, and it can be used for other things. An embedded DSL, in contrast, for example, is jquery.
00:15:10.266 - 00:16:09.042, Speaker A: So maybe I'm showing my age by using this as an example, but jquery used to be a very popular embedded DSL for manipulating web uis, and it's embedded inside of JavaScript. Okay, so we understand now the difference between external and embedded dsls. Now I have a very strong opinion about this, and I've had this opinion for a very long time, way before I was working in this space or thinking about a Zk DSL. And I'm just sorry, but I'm going to rant about it. It's really fun to build new programming languages and I love it. I love learning about programming languages, and I love studying programming language theory, and I love studying how programming language theory applies to engineering. It's fun, it's great.
00:16:09.042 - 00:17:08.390, Speaker A: So as a language author, I'd prefer to build a standalone external DSL. But even I, who's not a normal, not an application anyway, I have this background that is more abnormal, whatever. Even with this background, I struggle to imagine as a developer trying to build an application when I would prefer an external DSL, unless it had decades and decades of personal engineering, years of effort. It's crazy. I don't know. If you're a ZkDSL author and you are designing a new system, you're immediately putting yourself years behind by choosing to build one of these external dsls. The language itself is limited in scope by design, that's what the domain specific part means.
00:17:08.390 - 00:17:44.430, Speaker A: And so you have a standalone DSL. Even if you did a perfect job, the user would be limited in sort of what they can do. And in practice, because it takes so many years to build a system that's really nice and easy to use, you're just going to be behind. And so even things that you want to work, they won't quite work. And the tools around the language need to be rebuilt from scratch. Editor support, package management, build debug tools, all these things now. Yeah, to some extent you need to build these things in both cases, but at least you can bootstrap off of the host.
00:17:44.430 - 00:18:22.160, Speaker A: And that's people who like using new programming languages, application developers, or even people who like programming languages who are putting on their hats of trying to build an application product. They don't want to learn a new language, especially if they're trying to build and ship a product. And they definitely don't want to be stuck with some broken tooling if it can be avoided. And then here's the thing, what is even the benefit? What do you get if statements are slightly cleaner? It's insane. It's insane. It blows my mind. So this is true always.
00:18:22.160 - 00:18:53.160, Speaker A: It's an opinion I have, but it's really objective. It's a fact, but it's true for everything. And ZKDSL is a DSL, so therefore it's true for ZKDSL. So I don't know, it's not really a choice like you should embed it. It's really nonsensical to not do that. I know there's lots of folks who haven't done that, but I really strongly disagree with you, so we can argue about it later. Okay.
00:18:53.160 - 00:20:20.894, Speaker A: We want to embed our domain specific language. Where do we embed it? I guess the question to ask here is, who are you targeting? Who do you want your users to be? What do you want those developers to do with your tools? So if we want to build a ZKDSL for application developers to build applications for users, and if you want to reach the most application developers, you need to target web developers. And if you're targeting web developers, then you need to embed inside typescript or JavaScript. And not only that, if you need your developers, not just the developers to use those tools, but the developers who are using your tools in order for them to build products that users want to use, then you need to have your runtime support, web browsers, you could be using ZK for performance or succinctness or something. But if you're using the privacy part, right, like if you have a private application, then at least part of the computation needs to run client side. Otherwise you don't have privacy, you're pushing information somewhere. And so that part has to run on the user's machine.
00:20:20.894 - 00:21:03.122, Speaker A: And for desktop users, people don't want to download things anymore, they just want to use web browsers. So it has to work in a web browser, maybe on mobile. There's an argument, we can talk about it later if it matters. But yeah, it's like web, web all the way. It's the thing that makes sense if you want to build a tool that is for application developers to build applications for end users. Okay, so now I swear there's going to be some open challenges, but you know, you had to work your way up. Okay, so I have no concept of time.
00:21:03.122 - 00:22:03.806, Speaker A: I'm okay in time. Okay, I just looked at the clock. Now within your language context, assuming you're somewhere on the stack above direct constraints, you have to choose where you abstract, what you abstract, how you abstract, when you abstract, and there's 1000 examples of this, I'm just going to pick a few quickly because obviously there's not enough time to really go super deep. So I'm going to jump in. Okay. One category of choice that you can make is around nomenclature. So one interesting change that we made in the last few months was moving from circuit, which describes at runtime or the kind of mathematical abstraction that is underlying the system that we're describing.
00:22:03.806 - 00:23:05.880, Speaker A: We changed from circuit to provable because provable, a provable block of logic, it describes that the logic is to be proven. So what this does is there is a trade off. For existing developers who are comfortable with ZK and who are learning about ZK, provable communicates less information than circuit. But for people who are new to the tool or new to ZK, provable sort of describes the logic in a more approachable way, I think. And there's always detailed documentation that people could dig into to understand that in the current sort of back end, this means building a circuit and building up constraints in a constraint system. That's one example. I'm just going to quickly talk about this one.
00:23:05.880 - 00:24:15.178, Speaker A: Okay. At the lowest level, there's a distinction between a constraint variable and a constant when you're building these ck circuits. And that distinction is important, but it's confusing, I guess, in the general sense. There's this idea, like you can make something more magical if you hide it, and more magical things are easier for folks to onboard to a tool. But then as those people and as others become experts, it becomes something that is frustrating and annoying for people. Actually this is an example. So in this case what we've done is for example for field elements, there's one field representation from the user interface, the developer interface that both describes constants and variables.
00:24:15.178 - 00:25:18.322, Speaker A: And the system tries to figure out what you want automatically and actually that is causing problems for people. This is an example of something that might be too magical and it's something that we're thinking about revisiting and maybe removing some magic. So there's kind of, I guess this open challenge of how much do you make something magic? Because the more magical. Well, anyway, I just said, and then sort of another category, and this is the last example, is this action reducer system that we have. I'll do a quick diversion to explain this. So there's this thing called the elm architecture, which it's part of the ELm programming language and it's from a while ago, but it's a mechanism for representing a state machine and a system of concurrent interrupt updates to that system. So like button presses, network events are coming in and all these things.
00:25:18.322 - 00:25:56.366, Speaker A: So it's useful for user applications and actually react. The react ecosystem adopted this through first redux and then through the use reducer hooks. I don't know. It's a great system for dealing with state complexity in uis. What's interesting is if it's in react, then millions of people know how to use it. Because when I googled how many react developers there were, it said 29 million on Google. So millions of people are familiar with this.
00:25:56.366 - 00:27:02.238, Speaker A: Okay. Even if you have something that feels like a different problem. So for example, when you are imagine you're using Mina or some other blockchain system as a sort of global state layer. It's a state machine and you want to poke that state machine on Mina protocol, you build ZK applications that run client side to move the system forward in some interesting way to run your application. But that means what can happen is two users can interact either with the same smart contract or different smart contracts, but touch the same state in such a way that essentially you have a race condition. There's a concurrency issue and it's kind of similar to if there's button presses on a web page and networking events coming in at the same time. And so you can resolve these concurrency issues by decoupling.
00:27:02.238 - 00:28:13.340, Speaker A: I didn't explain this earlier, but essentially the solution and what battle architecture does and redux and all these things, you dispatch actions and you can do that concurrently. So these two concurrent systems sort of declare what they want to do and then later some system resolves those actions all at once against the state machine, and then you can do that sort of one at a time. So once you make that realization, it means you can implement something that looks like use reducer. And that means that the millions of react developers, the millions of people who have used react, as soon as they touch this, they need to solve this problem in their applications. They know how to use this API. So this is something that I'm really happy about and usually it doesn't quite work as this perfectly, but the idea is it's good to design APIs as close as possible to ones that developers already know, the developers who you're trying to target, the ones that they already know. And a lot of times you have to move things around and shape things to make that happen.
00:28:13.340 - 00:28:24.640, Speaker A: But yeah, I guess those are the kinds of axes of usability that I thought about when I was creating this talk anyway, so yeah, thank you.
00:28:25.810 - 00:29:11.950, Speaker B: Thank you, Brandon. That was a very interesting talk and I think you had some hot takes and interesting takes here and there, so that was great. And I actually do have quite a few questions I wanted to also go through. So yeah, let's dive into some questions. Well, first of all, I'm going to just pick it off from some audiences who dropped some questions here. So one of the questions that I have here is that do you see specific usability challenges that apply more for web two devs coming to ZK for the first time versus web three devs coming to ZK for the first time versus devs who are already familiar with ZK. Like those usability challenges for those audience, for those different devs?
00:29:12.370 - 00:30:43.286, Speaker A: Yeah, I think the audience is something that you have to be cognizant of. Anytime you make any decision you're prioritizing, well, it's likely that certain audiences will have different desires and skills and expertise and so you're making trade offs, I would say. I guess if we think through each of those categories for web two developers and web three developers, the fact that the, the system is embedded in typescript is a real help to make things better. The APIs like the one I just showed for actions and reducers, making it feel like react. Then for developers who are already familiar with ZK, you want to make sure that there's ways to discover how the system actually works so that they can map it to a mental model that they're familiar with, and I'll just give one example, like the way that one JS is structured, everything is built up sort of transparently. On top of this extremely low level interface of describing constraints. We have some library code that's in Rust and Ocaml that's compiled to javascript and typescript.
00:30:43.286 - 00:31:18.418, Speaker A: But there's also a lot in typescript, and we're moving more and more of it to typescript. But you can actually go in and inspect how things are implemented and see it and see that, oh, this if expression is actually doing a boolean constraint of the boolean times the thing plus one, minus the boolean times the thing. And the ability to go deep lets you optimize things when you need to, when the sort of auto generated versions of things are too slow. Yeah, that's how I think about it.
00:31:18.584 - 00:31:55.730, Speaker B: Gotcha. Also, one thing I was kind of interested to touch upon was the fact that when you mentioned about the current ZKVM does not have a recursion, and that actually did make me think that when I was thinking about continuation. You could argue that continuation is not a recursion, it's just splitting of the workload. So yeah, it is true that ZKBM wouldn't have, so far doesn't have recursion, but do you think that in the future, in what way do you think that recursion would exist for those zkbms?
00:31:57.190 - 00:33:43.742, Speaker A: That's something that one JS will get to at some point, maybe another, maybe another project sort of tries and experiments before we get there. But yeah, I think ultimately at the developer interface you want to. The ideal design, I think is still like recursive functions, recursive functions mapping to recursive proofs. Even in a ZKVM context, you should have some notion at your software level of a function. And then if there's some way that's not too different from a function call that you can represent sort of a recursive proof request or recursive verification request, I think that is a very natural interface. And then there needs to be facilities for serializing these things and sending them over the wire, because that's when you unlock the interesting abilities of the system. If you think about what is the difference? And I'll tell you my answer, but the difference between the kind of recursion, the Nova style folding or continuations, or this kind of recursion where we're doing a bunch of things altogether with recursive proofs, you can do that so that part of it is solved.
00:33:43.742 - 00:35:00.986, Speaker A: The ability to sort of run extra work, I guess, but at least in Nova, because I'm sort of more familiar with that, the prover has to have all of those chunks of work all at once to create the proof. So what that means is only one trusted party can do all of the work, and that immediately it removes a bunch of use cases, a bunch of kinds of applications that people can build. You can't build Mina protocol. So the way Mina works is there's a proof that represents the blockchain that proves the whole history of the blockchain, and different people, different parties consume that proof and extend it depending on who wins, whoever gets elected to make the next block. So you couldn't do that with that kind of folding style Persian. I see there's this kind of interesting space where our team is going to be helping other teams build these kinds of things. More coming soon, and we're going to build some more examples.
00:35:00.986 - 00:35:39.462, Speaker A: But you can build these multiplayer applications where games and applications, but I'll just use a game, for example, where each player takes a turn and makes a proof and they pass it to their neighbor and then they make the proof. And you can do this kind of state machine with multiple parties where you don't trust each other and then settle on chain at the end, for example. That kind of thing is also impossible. Anyway, I could keep going, but. Yeah. So you lose some power. I guess I'm trying to motivate.
00:35:39.462 - 00:35:44.970, Speaker A: It is interesting to explore this combination.
00:35:45.310 - 00:35:47.338, Speaker B: Yeah, it is definitely very interesting.
00:35:47.504 - 00:35:47.978, Speaker A: Yeah.
00:35:48.064 - 00:36:51.630, Speaker B: I mean, on one hand, you're sort of like providing a proof that is maybe a bit more heavy on the client side, but also enables new ways to interact with proofs, in a sense that, as you mentioned, some games could be passing around proofs and then recursively proves that over and over times across different untrusted entities. Right. But also at the same time, I think you raised a very interesting point around how a lot of the voting schemes are still very much relying on a centralized provers for the instance of generating many instances of combined witnesses over and over again, as you have. And that actually does raise also another interesting question of whether this witness generations, and also the instance, I guess the actual voting processes itself could be potentially even distributed across different untrusted parties. And obviously that one is still very much. I don't even know if that's possible.
00:36:51.700 - 00:38:12.442, Speaker A: But my understanding the protocol is incompatible. Like the Nova protocol, the Nova family of protocols, it's incompatible with this, with having untrusted witness a new, something new would have to be invented. But the thing is, you can mix these by mixing proof systems together, and that's something I'm really excited about. And I think we're going to see more, you're going to see more from o one labs, but I think that you'll see more of this over time, because you can have your proof system with Nova style folding, and it's really good at this kind of computation crunching. Right. And then if you can recursively verify a foreign proof system that's good at recursive proofs in that system, then you can just use both and vice versa. So, doing these foreign proof system verifications, that step is usually quite expensive, but I think there's a lot of use cases where you do a bunch of things over in this world, you do a bunch of things over in this world, and you can kind of combine them together.
00:38:12.576 - 00:38:56.130, Speaker B: Right. So, basically, trying to compose the proofs together for different use cases. Got you, I guess. One last thing I wanted to touch upon. We're running a bit close short on time, but I remember you mentioned about sort of changing the terms from circuit to provable. And to me, that intuitively kind of sounded more like, basically you have something that is very low level, that's maybe interacting with a bunch of different arithmetic gates, let's say. But now you're kind of abstracting that part away and say, okay, this is what I want to prove, and this is all you need to kind of put down in the code, and I don't have to worry about all the details around the gates and whatnot.
00:38:56.130 - 00:38:59.706, Speaker B: I presume that's kind of like, I.
00:38:59.728 - 00:40:00.540, Speaker A: Regret not having a code sample here that would have made more sense. But, yeah, in one js, you can go all the way down to the metal and manipulate constraints. But typically, when you're looking at a chunk of logic, it's abstracted so much that you're looking at some piece of code that, I don't know, computes consensus logic for Amina block, for example. And it looks like that the type of that computation is still a circuit, or it was a circuit, but it's so far away from those details. I guess if you trace every function call, eventually you'll find. You'll find constraints, but, yeah, like, instead sort of thinking it as, oh, here's some logic that is provable. Like, I can compose it with other provable pieces of logic and then call, prove, and I get back a.
00:40:00.540 - 00:40:04.238, Speaker A: That's. That's kind of the idea.
00:40:04.404 - 00:40:44.918, Speaker B: Gotcha. So, yeah, thank you very much, Brandon, for the amazing talk and a lot of the, I guess, hot takes today. And thank you that the audience here would also have some thoughts and some takeaways and potentially new innovations out of the talk from what Brandon has given today. And also make sure to follow Brandon on Twitter and also one labs looking forward to seeing all of the interesting ZK DSL and embedded DSL that will be coming out of their announcements in due time as well.
00:40:45.084 - 00:40:56.974, Speaker A: And you can download it and play with it and build applications. Build applications sort of in isolation in like web two world or deploy them on Mina protocol. Exactly. Thank you so much.
00:40:57.092 - 00:40:58.170, Speaker B: Thank you very much, Brandon.
