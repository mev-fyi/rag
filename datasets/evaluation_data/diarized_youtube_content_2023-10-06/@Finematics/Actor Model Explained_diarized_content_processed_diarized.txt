00:00:00.410 - 00:00:34.246, Speaker A: It. What is the actor model? It's a conceptual model of concurrent computation originated in 1973. In the actor model, an actor is a fundamental unit of computation. Everything is an actor. The only allowed operations for an actor are to create another actor to send a message or to designate how to handle the next message. First two operations are quite easy to understand. Let's focus on the last one.
00:00:34.246 - 00:01:22.338, Speaker A: An actor can hold its own private state and it can decide how to process the next message based on that state. Let's imagine an actor that stores a total balance of our account. If our actor receives a message with a new transaction, it updates its state by adding the new amount to the already calculated total balance. Which means that for the next message, the state of the actor will be different. Actors are lightweight and it's easy to create thousands or even millions of them, as they require fewer resources than threads. Now let's have a look at the actors in more details. Actors are isolated from each other and they do not share memory.
00:01:22.338 - 00:02:03.490, Speaker A: They have a state, but the only way to change it is by receiving a message. Every actor has its own mailbox, which is similar to a message queue. Messages are stored in actors mailboxes until they are processed. Actors, after created, are waiting for messages to arrive. Actors can communicate with each other only through messages. Messages are sent to actors mailboxes and processed in FIFA order. Messages are simple immutable data structures that can be easily sent over the network.
00:02:03.490 - 00:02:48.638, Speaker A: Conceptually, an actor can handle only one message at a time. Actors are decoupled, they work asynchronously and they don't need to wait for a response from another actor. Actors have addresses, so it's possible for an actor to send a message to another actor by knowing its address. An actor can only communicate with actors whose addresses it has. An actor has addresses of the actors it has itself created, and it can obtain other addresses from a message it receives. One actor can have many addresses. We need to remember that address is not equal to identity.
00:02:48.638 - 00:03:31.706, Speaker A: So it doesn't mean that two actors with the same identity have the same address. Actors can run locally or remotely on another machine. It's completely transparent for the system, as actors communicate through addresses which can be local or remote. Now let's talk about default tolerance. In the actor model, actors can supervise other actors. An actor can supervise the actors it creates and can decide what to do in case of failure. A supervisor can, for example, restart a supervised actor or redirect messages to another actor.
00:03:31.706 - 00:04:15.786, Speaker A: It leads us to selfhealing systems. Let's look at the pros and cons of the actor model. Pros, easy to scale, fault tolerance, geographical distribution. And we can avoid a lot of concurrency issues by not sharing state cons. Actors are susceptible to deadlocks and overflowing mailboxes. We need to remember that the Actor Model is only a conceptual model, and a lot of properties of your system depends on the chosen implementation. The best known implementations of the actor model are Akka and Elixir.
00:04:15.786 - 00:04:30.700, Speaker A: If you want to learn more about the Actor Model, please check the links in the description box below and also visit my website phinematics.com. If you like the video, please hit the like button and subscribe to my channel. Thanks for watching.
