00:00:04.410 - 00:00:52.458, Speaker A: All right, so once upon a time there was a timing attack on OpenSSL found by two very famous cryptographers, Bramley and Bonnet. So their timing attacks was practical, as they said. And eight years after two others, cryptographers found another attack on OpenSSL on a different part. And this is the paper I tried to reproduce. So my paper is this one and it's like a continuity of the previous paper. So this is a timing attack and a latice attack. The timing attack didn't work that well, but the Latice attack works.
00:00:52.458 - 00:01:55.922, Speaker A: So I think it's still cool to talk about that. So I know you guys know about OpenSSL and TLS and stuff like that, but I'm just going to explain that. So when you want to connect on a website and you don't want anybody to be able to see all what you're saying to the website, your passwords and everything, what you're going to do is that you're going to use HTTPs to connect to the website and that use SSL or what we call today TLS. And if you're a webmaster or you want to have a protocol that works over Internet and you want to protect that instead of learning about security and cryptography and all of that stuff, what you do usually is that you use a library. So OpenSSL is a library for that, for TLS, and it's a bunch of developers and implementers that did all the hard work for you. So you don't have to worry about anything when you use that kind of thing. So that's why it's pretty cool to attack that thing because a lot of people just use it.
00:01:55.922 - 00:02:43.330, Speaker A: And if you find an attack on that, a lot of websites or protocols are vulnerable. So this is an attack on the signature of OpenSL server, particularly on the ECDSA signature. So ECDSA is a signature that comes from the DSA signature, DSA as digital signature algorithm. So it's basically the same thing. If you know DSA, ECDSA is pretty easy to understand because it's same thing, but in the LT curves. So when you want to sign something, you want to sign a message, for example, what you do is that you're going to generate two numbers, R and S. So signature over a message is just two numbers rns.
00:02:43.330 - 00:03:35.090, Speaker A: And so to generate those two number rns, what you need is the message, of course, because you're signing a message, you need a private key because the signature is a private key, public key thing where you sign with a private key and people who have your public key can verify your signature. So of course you have to use your private key and you have to use announce. So announce means a number once. So that's a number that you have to use only once per signature. And that's why we also call it an FML key because it has to be secret. So in a signature, when you compute a signature, your private key secret, and the nouns are the FML key secret. And every time you're going to generate signature of a message, you're going to generate a new nouns.
00:03:35.090 - 00:04:39.666, Speaker A: So here it's pretty easy to see that if you know the nouns, if by any means you can recover the nouns by any kind of attack, then you can just revert the equation, the second one and you can find the private key. So knowing the nouns is bad because you can find a private key and then you can sign anything. But worse than that, if you reuse the nonce even twice. So that's what the PS three people learn. There was a team of researchers that reverse engineered the PS three and found that when they were signing stuff with ECSA, when they were generating the FML keys, they were actually generating the same number every time. So that's bad because if you look at the equation, you can take a piece of paper and a pen and you can see pretty easily that knowing just two nouns allows you to find a private key. You have to be careful with those private parts of your signature.
00:04:39.666 - 00:04:55.482, Speaker A: Do you have questions later or. No, you can ask now. So if you say that ECGSA and Sony was constant, but you need two different ones to get the key. So with two different signatures, the nouns was the same. Yeah. So you need two different signatures on two different nouns. Right.
00:04:55.482 - 00:05:44.214, Speaker A: They use the same nouns on two different signatures. Well, you can do that also with like a bunch of signatures, but you only need two signatures with the same nouns. What about signing the same message twice? If you sign the same message twice, I don't think it's going to matter that much. All right. It shouldn't matter that much as long as you use. All right, so you have a lot of side channel attacks, like acoustic or vibration, power consumption, I guess you know a lot of them already. So what kind of side channel attack can we do on a remote target? So timing attacks are one of the only side channel attack that we can do on a remote target.
00:05:44.214 - 00:06:26.726, Speaker A: And that's why we're doing a timing attack on this openssl server. So when you want to do a timing attack, usually you want to. Or a side channel attack in general, usually you want to try to leak some information about an operation that involves private parts of your cryptographic primitive. So here we could attack the private key or we could attack the nons, and this is an attack on the nons. So I'm going to explain that. So here what you have is that you take the nons and you multiply it by the public points, which is part of your public key. And this is how you compute the number r.
00:06:26.726 - 00:07:01.282, Speaker A: And this is what we want to focus on. So we're going to see if that multiplication of the key with the public key can leak some information. So this is the code in Openssl. That's how they do the scalar multiplication with the nouns and the public key. So usually when you want to protect against timing attack, you're going to use a constant time algorithm. So you can see a constant time algorithm at the bottom. But the problem here is that there is a problem here.
00:07:01.282 - 00:07:32.826, Speaker A: And can you see the problem very quickly? So the constant time is fine. The while loop. Yeah. So the while loop good. Is actually an optimization to find the most significant bits of your nonce. And because of this, you're going to compute a constant time scalar multiplication on an optimized value. So if the nonce is smaller, is small, it's going to take a short time to compute the signature.
00:07:32.826 - 00:08:10.710, Speaker A: If the non is bigger, if it has more significant bits, the time opens cell will take to compute the signature will take more time. Yeah, that's the part. So that allows us to get the size in theory. So what I did is I modified an OpenSSL server, and I modified it so I could time how long it would take to take a signature to sign something. And I signed a bunch of stuff. So that was like 10,000 signatures. So you can see every point is a signature.
00:08:10.710 - 00:08:54.614, Speaker A: And on the left side those are the points, the signatures that took less time to compute. And on the right side those are the signatures that took more time to compute. And I also modified openssl to log the bit size of the nonsense so that I can sort all those points. So this is the same graph, except that I sorted on the y axis by bit size. So on the top you can see the signatures that were generated with longer FML keys. And on the bottom part you can see signatures that were generated by smaller nouns. What is the x axis here? So this is supposed to be the time.
00:08:54.614 - 00:09:44.550, Speaker A: This is actually the cpu cycles, the number of cpu cycles in split. So yeah, this is when the signature is here, it's the plus time to compute, and those are the ones which have smaller nouns. So it's pretty clear here that you have a tiny attack that leaks. Well, not a tiny attack yet, but you have a leak of the size of the nonsense. Because if you take the smallest, if you look at the time and you take the set of the fastest signatures, you will find smallest nonsense. All right, the y axis is the y axis and the x axis is the time. Right? Does that make sense? Take longer to generate.
00:09:44.550 - 00:10:18.994, Speaker A: Not to generate, but to do the multiplication. If the nonsense is bigger. So the top signatures have nonsense that are bigger, they're more on the right. Why is it so spread out? Because this is like kind of noise. I guess if you were more precise in your timings, it wouldn't be as predominant. But there are a lot of things that involve a response from a server, but, yeah, would be helpful. And make an arrow bar or something.
00:10:18.994 - 00:10:52.350, Speaker A: Yeah. All right, I have a frequency plot, but I'm not showing that here. Maybe I shouldn't. All right, so we've leaked the size of the nonsense. So can we do an attack on that? Because if we leaked the bits of the nonsense, that would be a win. But the size. Well, there was an attack in 2001 by Hugh Graham and smart, two brilliant cryptographers as well, that found that if you know a few most significant bits of a bunch of signatures nonsense, then you can recover the nonsense.
00:10:52.350 - 00:11:41.760, Speaker A: And if you can recover the nonsense, you can recover the private key. So I explained that later. First, let me explain how to get all this timing information from a client from a remote target. So this is going to be very easy again, when you're a client and you want to browse the Internet and connect to Google through HTTPs, what you're going to do is you do a handshake because you want to compute a shared key so you can encrypt your communications later on. So the first person that sends the first packet is called the clients, and the first person that receives the packet is called the server. That's why you know, who's a client, who's the server, and the first packet you're going to send to do a handshake is going to be a client. Hello.
00:11:41.760 - 00:12:14.274, Speaker A: So a client, hello. Looks like that. Just a few bytes that says this is a handshake, a few bytes that says, this is TLS version 1.0, and a bunch of bytes that say, I would like to do the handshake with do's algorithm. I would like to encrypt the communications with do's algorithm. With AES or other ciphers and the server is going to answer with three packets. A server hello that kind of looks like the same a server certificate, that is the certificate of the server.
00:12:14.274 - 00:12:52.334, Speaker A: So that's how you can authenticate Google. For example, you can make sure that Google is Google and also a server hellodown which is just a few bytes to say I'm done, you can continue and it goes on and on. So a TLS handshake is usually a two round trip protocol. It takes two round trips to compute a shared key so the rest of the messages doesn't matter that much. So we want a signature in there so that we can do our attack. We want the server to compute a signature with ECDSA. So what we can do is request a different kind of handshake.
00:12:52.334 - 00:14:11.450, Speaker A: We can request an ephemeral handshake. And an ephemeral handshake allows us to have perfect forward secrecy that we call PFS. So instead of using the server's public key to compute the shared key that we're going to use later, we can ask the server to use ephemeral public key every time for every session we create so that if someone records the conversations over the client and the server and later on crack the key of the server, you wouldn't be able to decrypt everything because nothing is saved when you do an ephemeral public key. So when you ask for an FML handshake you're going to do kind of a different client hello and the server is going to answer with an extra packet that is the server key exchange and that extra packet. So I have a view of wireshark of that extra packet. So that's the server key exchange and you have a signature there. So that extra packet is basically his FML public key and the algorithm he wants to use to do the FML exchange usually defilamen or elliptic curve defilamen.
00:14:11.450 - 00:14:54.102, Speaker A: All right, so what is the signature over? We can look at the RFC 4492. So rfcs are requests for comments. There are documents you can find on Internet that specifies how some protocols work, like Tls. So that's where you want to look at when you want to know what's the signature on. And here you can see that the signature is on the client hello random, which is a random value that you send the client hello your server hello random which is kind of the same thing. And the server public key, ephemeral public key. So it doesn't really matter when it signs, but what matters is that we have all the information that it signs.
00:14:54.102 - 00:15:55.120, Speaker A: So in the equations we have to do the attack, we know what the message is, we know what the signature is, we know everything. Interestingly, it doesn't sign the algorithm it uses to do the FML handshake. And that was the reason for a lot of long series of attack. And most recently freak and log jam were because of that, because it doesn't sign the algorithm it's going to use for DFML and check. All right, so the timing attack. So I handcrafted my client hill, and I just send that to a server which was on the same network, and I just send that like a bunch of time, like 10 00, 10,000 times to collect some signatures. And I would time from the clients the round trip from when I sent that client hello packets and when I received the packets where the signature is.
00:15:55.120 - 00:16:27.938, Speaker A: So we have to do a round trip timing because it's impossible to time exactly the time the server takes to compute the signature. We have to time the overall processing time of the server. We have to time the propagation time. So that's how much time the packets goes from the client to the server and vice versa. And there is also jitter, which is the noise of the network of your machine, et cetera. So my first results were pretty bad. So that's the same graph as earlier.
00:16:27.938 - 00:17:08.520, Speaker A: And it's pretty clear that you have no correlation between the size of the nonsense on the y axis and the time it takes to the openssel server to answer. So that was pretty disappointing. And I guess from here you have three solutions. You can try to get closer to the target, which I already am, because there is just a switch, I think, in between us, if it's a real remote target. I guess if you do a physical pen test, you can find the server room and just plug into the server. Or if you're the NSA, you can try to get as close the server as possible. I don't know.
00:17:08.520 - 00:17:40.254, Speaker A: You can also increase the number of samples you're collecting to get rid of the jitter. More samples hopefully will get better results. Or you can optimize your machine to remove the machine jitter. So I did both. I did increase the samples I was taking. I took 10 million signatures, took me 20 hours to collect that. So it's not very practical and it kind of gets better and better.
00:17:40.254 - 00:18:25.530, Speaker A: I get like way better results, but still not very conclusive. And I used a lot of different optimization on my machine to be able to get that. Also like disabling frequency scaling, only using one cpu to do that. Disabling interruptions, et cetera. There is also a very interesting way that I didn't really research in that would take a special network card to do the timestamp on the network card. So instead of doing the timestamping on your program, your network card would time the time it takes for the packet to leave and come back. So that would be more precise.
00:18:25.530 - 00:18:37.570, Speaker A: So if you guys want to help on that, you can send me a mail. But I'm still searching on how to improve that. Yeah, tcp timestamping.
00:18:37.910 - 00:18:41.246, Speaker B: What about hardware timestamp?
00:18:41.278 - 00:18:53.206, Speaker A: Hardware timestamps, right. So what Paul McDonald does is hardware timestamping. And that's actually doing that with your NIC, the network. So that's what I think might work way better.
00:18:53.308 - 00:19:05.980, Speaker B: Might help also, I guess maybe if you're looking for more realistic scenarios, people say for an Amazon and you're in the same instance as your target, you just buy an instance there.
00:19:07.230 - 00:19:28.766, Speaker A: I've heard that that works. They have like cross game attacks. Yeah, they have different kind of attack that are cross vm attack. If you're on the same machine as the other, you can like on shared libraries, you can see when they access some functions, stuff like that. But that's different kind of attacks.
00:19:28.798 - 00:19:34.446, Speaker B: Yeah, but you're also closer, you're maybe on the same network. That way you can reduce jitter.
00:19:34.478 - 00:19:34.626, Speaker A: Right.
00:19:34.648 - 00:19:37.314, Speaker B: If you're targeting an EC two instance, you just buy yourself off.
00:19:37.352 - 00:19:38.840, Speaker A: Yeah, I guess that would be a good idea.
00:19:39.210 - 00:19:40.486, Speaker B: I've heard that that might work.
00:19:40.508 - 00:20:19.710, Speaker A: I don't know if it actually works. All right, I'm going to explain how to do. So now that we know how to do the technique attack, not really, but kind of works, we can try to understand how to do the offline attack. So the part where we have the signatures, we know that those signatures are made with short nounces and we want to recover those nounces to recover the private key. But first I have to introduce you to lattices. Going to be very brief. So a Vector space is a space created from vectors.
00:20:19.710 - 00:20:58.238, Speaker A: So here on the left you have a basis, which is two vectors, and those span a vector space if you take all the linear combinations of those two vectors. So for example, you can take the first vector times 1.75, add it to the second vector times -300 and you get a new vector that's still in the vector space. And you take all those combinations and that creates a vector space. So now imagine that you can only multiply your vectors by integers. One, two, three, minus one, minus 20. What you get is not a continuous space like that.
00:20:58.238 - 00:21:29.522, Speaker A: What you get is a discrete space made only with points in space. And this is a latice. So if you didn't know what was a latice before, well, it's pretty simple. That's just a latice. Latice are interesting because they have several problems. One of the most famous one is called the shortest vector problem and shortest SVP. And in the SVP problem, you have a latice and you have to find the shortest vector in that latice.
00:21:29.522 - 00:22:20.940, Speaker A: So here it's pretty simple, it's right here. But if you take a bigger lattice and if you add dimensions to that latice, it becomes a problem very quickly, and it's known to be, well, it's thought to be a hard problem. Another hard problem is the closest vector problem, or CVP. You have a latice in red, and you also have a vector in blue that is not part of the lattice, and you have to find the shortest vector from the lattice to that non latice vector. So, same here, pretty simple, it's here. But if you add vectors in your lattice, if you have a bigger basis and if you have more dimensions, it becomes a problem pretty quickly. So to solve the first problem, the SVP, there is an algorithm that was invented by three persons whose last name start with l and it's called Ll.
00:22:20.940 - 00:23:06.534, Speaker A: And what it does is that you give it a random basis. So on the left you have a latice spanned by these two vectors, and you give that basis of two vectors to ll. And what ll finds is a shorter basis, so you can have different bases that span the same lattice, and what it finds is a shorter one. And hopefully in the shorter vectors that span the same lattice, one will be the shortest vector. It's not an algorithm to solve the problem, it's more to approximate a solution, so it doesn't work all the time. You can actually attack RSA with dots with LL. I did a video to explain that.
00:23:06.534 - 00:23:48.094, Speaker A: It's on my blog. So if you're interested to solve or to approximate a solution to the second problem, the closest vector problem, you have Babai, who has made two algorithms, and I'm just going to explain the first one because it's pretty simple. So imagine you have your non lattice vector here, and the basis of your lattice are those two vectors. What you can do is that you can write this non lattice vector as a combination of those two vectors. So you can say this is the first vector times 3.4, plus the dome vector times 2.3, which you cannot do in the lattice because you have to use integers.
00:23:48.094 - 00:24:04.650, Speaker A: And when you have these coefficients 3.4 and 2.3, you can just run them. So 3.4 becomes three and 2.3 becomes two. And hopefully you find a vector that is in the lattice that is the closest to that non lattice vector.
00:24:04.650 - 00:24:59.174, Speaker A: All right, it's not very important how to solve this algorithm, but just know that we have algorithms that are kind of efficient to solve those problems. So remember, I have a bunch of signatures that are generated with small nonsense and I'm trying to find those nonsense. And I want to reduce the problem of finding those nonsense from a bunch of signatures with small nonsense to finding a solution to the CBP, the closest vector problem. So I'm going to show you how to do that. So every signature is two numbers rns, right? I'm going to show you the equations. And in rns we just download the private key d and the nonsense k, and the private key d is going to be the same one every time. And the nonsense are going to be different for every signatures.
00:24:59.174 - 00:25:39.130, Speaker A: Remember, we cannot sign with the same nons, different messages. So look at the second part of the equation that I rewrote. I just put everything on the left, same thing. So what we want to get rid of is the signet, the private key d, that is the same in every equation. But since it's an attack on the nonsense, we want to get rid of that. So what we can do is that we have a system of equation, right? We have a bunch of signatures. So we have a bunch of equations like that, and we're going to just take one of them and subtract it to the others, just like you do when you want to solve a system to get rid of the private key in the other equations.
00:25:39.130 - 00:26:13.170, Speaker A: So I simplified, but all the other equations will kind of look like that. So the only unknowns are the nonsense. You don't have the private key anymore. So you can rewrite that as. So this is our system, all the k are the nonsense we're trying to find. K, zero doesn't have an equation because this is the equation we use to remove the private key from the others, right? And in all the other equations, we only have one unknown. Dude, are the nonsense.
00:26:13.170 - 00:26:45.502, Speaker A: And I can write this system of equation with vectors and matrices, exactly the same thing. But this allows me to notice one thing. So those two vectors we don't know, right? And this vector is the non vector. So those are the nonsense we're trying to find, what we can notice is that this nonce vector is short. It's a short vector because the nonsense we have are short. That's what we have. Right.
00:26:45.502 - 00:27:16.470, Speaker A: We know that they are short. And here we can say that this matrix is the basis for lattice. Let's say that the columns of that matrix are the vectors of a basis for lattice. We can say that also doesn't really matter. But if we say that, then this construction of a matrix times a vector is actually a vector of this latice. That's what it means. So here we have a vector of this latice, and we don't know this vector.
00:27:16.470 - 00:28:01.510, Speaker A: Here we know this vector, but it's not part of that latice. And here we are looking for that vector, but we know it's short. So what we have is a difference between two vectors that is short, and those two vectors are a vector that we know that it's not in the lattice, and a vector that we don't know that is in the lattice. Does it make sense? So here what you have to find is a vector in the lattice that is very close to that non lattice vector. They're very close because the difference is small. I don't know if it makes sense, but the b vector is the one with the not in the lattice vector, right? This is from the equations, sorry, something. So, difference is small, one vector in the lattice.
00:28:01.510 - 00:28:32.000, Speaker A: That's why you can use the closest vector problem. And so you just use Baba's algorithm and you can solve that and you get all the nouns, and then you recover the private key. So I'm going to show you how that works really quickly. Or not. Maybe not. Yeah, that's a video. Yeah, sometimes I can play.
00:28:32.000 - 00:29:17.550, Speaker A: You can play videos in keynotes, usually. Okay. It makes the keynote have pretty big, but yeah, that's lagging. All right, so this is the server, and this is the client, and this is the offline attack. So I run the client to get a bunch of signatures, I think 10,000 of signatures. And I also log stuff on the server because it's easier to log with openssl. If I modified openssl, I can get the signatures, the size of the nonsense, the message to the signature on the private key to verify the attack works.
00:29:17.550 - 00:29:53.556, Speaker A: So I did all of that thing from the server, but you're not supposed to do that. You're supposed to find out yourself by parsing the packets. And then I'm going to display some statistics, and then I'm going to download that from the offline attack. To do the lattice attack. So, yeah, maybe I should make that shorter. How many bits is the smallest nonce in practice? So what I found is that I needed to know at least six bits. So at least six bits were set to zero, the most significant bits.
00:29:53.556 - 00:30:23.104, Speaker A: And with that, I needed 70, something like that. And if I knew seven bits, if seven bits were set to zero, I just needed like 40 signatures to do the attack. So when you say small nonsense, you mean small values for the non. So the bit size is shorter than the max bit size. Always going to be the same. It's always 120, but it's not that big. It's a small value for that.
00:30:23.104 - 00:30:57.866, Speaker A: Well, it's not going to be the maximum bit size. It can be, but, like, a few bits will be set to zero first right now. So here, I do the last attack here. I know six bits here. I said to my program, and I need only 60 signatures, and I do the last attack right here. Once you figure out the command. Right, I can give you a second to cut this video if you'd like to remove.
00:30:57.866 - 00:31:20.230, Speaker A: That's okay. So, that's my lattice and that's my private key. So that's super fast. As soon as I get the signatures, I get the private key. That's really cool. So is that like a 60 dimensional lattice then? Yeah, 61. That's the Latice dimension, right? That's the latice dimension.
00:31:20.230 - 00:31:51.642, Speaker A: So, back to my talk. So, that's over. But if you take something from my talk, I guess timing attacks are everywhere. That means that it's easy to introduce a timing vulnerability in your product. Like, as we've seen, there was a constant time algorithm, so that was supposed to be like super safe. And just a small while loop made it broken. Kind of small amount of info might break your crypto.
00:31:51.642 - 00:32:36.366, Speaker A: So, just by knowing the size, the size of the nonsense, just by knowing that a few bits are set to zero, we can recover the private key. So even that small amount of information over the nonsense allow us to do the attack. And finally, remote timing attacks are hard. Well, I spent a bunch of time researching that, so if you think I'm legit, you can say that they're kind of hard. So it's not that easy to do the timing attack. If you want to try the timing attack, you have a repo. I put everything on GitHub, and you have everything to set up your clients and everything to set up the server and the offline attack.
00:32:36.366 - 00:32:53.130, Speaker A: So you can try yourself. If you get better results, you should talk to me after. And if you want to know more about crypto, check my blog. Cool. All right. Any questions? Bye.
