00:00:01.370 - 00:01:06.542, Speaker A: Hey guys. David, again, I've explained proof compositions and recursion in previous videos, but I've sort of shied away from implementation details, or not implementation, but details of the protocol. And I kind of want to dig into one of them. Probably one of the most interesting or the most annoying or challenging, which is that the proofs that we sometimes create are in a specific field or a specific the data is in some field, but our circuit is in a different field. And so what do I mean by that? Well, in plunk, when you have witness and coefficients like the selector polynomials, and when you form these polynomials, they have coefficients in a field like you use field elements, maybe we can call that the circuit field. Circuit field. But when you create a proof, you will commit to these polynomials.
00:01:06.542 - 00:02:10.246, Speaker A: And the way you commit to these polynomials is by doing scalar multiplication of elliptic curve points which are in a different field. So plonk use KZG, and I've talked about that polynomial commitment scheme in my plank series of videos, and kimchi uses kimchi is the proof system used in Mina, which is a plonkish proof system, uses inner product arguments. Polynomial commitment scheme, which I've never talked about. Maybe I'll do a video on that if there is enough interest. But basically in both of these schemes to create a proof, you end up like doing scalar multiplication of elliptic curve points. And the scalars here are usually the polynomials that you're dealing with. And the point are some points on an elliptic curve that's usually on some field.
00:02:10.246 - 00:02:44.880, Speaker A: Let's call that FP. And so now I've sort of outlined the fact that there's two different field, and maybe I can dig little bit deeper to explain why there are different fields. If you already know elliptic curves, you probably already know that. Then if you don't know too much about elliptic curves, I'm not going to dig too much into elliptic curves. I'm going to keep that as a black box. But I'll just explain enough so that you understand why there are two fields. So LFT curves are just points.
00:02:44.880 - 00:04:03.020, Speaker A: If we instantiate an NFT curve with some curve equation, we end up having a bunch of points, p one, p two, et cetera, a lot of them, because we want some security. And all of these points are coordinates, good old coordinates, x and y. And these values, these coordinates are in this field, Fp, that I just described. But all of these points form the elliptic curve, right? That's all of these points. And when you do arithmetic in the scatters of these points, you are doing arithmetic in FLQ. And so for example, if you know that if you multiply any point q times, you'll get the point at infinity. If you do any number plus q, so that's the order of our t curve, then you'll get back a times p.
00:04:03.020 - 00:05:08.094, Speaker A: So we have sort of these rules where everything works modulo q, and so we're in a field q, and so that's what we called the base field, or maybe you can call that the proof field, but it's really called the base field. So these are the difference. We have the circuit field and the base field. And so once we go back to our scheme, imagine we have a prover, and that prover is instantiated over some elliptic curve. Let's call that our elliptic curve e one. I don't know, our circuits is over the scatter field, right? But our proof, the proof we create is over this base field. And so if we want to do recursion, we want to implement a verifier circuit inside that circuit here that can verify a proof that looks like that.
00:05:08.094 - 00:06:45.582, Speaker A: We can't really do that efficiently because we need to act and operate on epturve points that have coordinates that are not in our scalar field, but in our base field. So that means we will have to add points together, we'll have to scale points, and all of that is easily done if you can implement your circuit in this field. But since our circuit is in a different field, it doesn't work well. Okay, the secret here is that you can find another curve, another curve, let's call the curve e two that has a base field and a scalar field. Okay, so every curves have that, such that, such that the scalar field of this new curve is equal to the, what did I do? Is equal to, I don't know what I'm doing anymore, is equal to the base field of the previous curve. And so now we have this prover in e two, and now our circuit is written over this field that looks exactly, this color field that looks exactly like our proof, and so we can verify it. And what will produce is a proof, let's call that proof two.
00:06:45.582 - 00:07:47.460, Speaker A: This one was proof one and proof two this time is in some other base field. And so we successfully verified one proof in a circuit, but we've only done that once. Now we have some sort of similar problem, except that we're yet in another field and so we have to yet find another elliptic curve for that. So we have one level of recursion. So there's actually a very simple way to solve that. And the solution is that we find a curve, e two, that has a base field that's exactly the same as our circuit field previously. And so basically, the proof we created here can be verified efficiently by that circuit of this curve here.
00:07:47.460 - 00:08:31.130, Speaker A: Because again, this is in, what did I call it? I called that FP. The circuit is in FP, and the proof that we produced were in FQ. And this circuit is in FQ. So we're kind of alternating between two curves. And so the zcash team has invented a pair of elliptic curves called the pasta curves, and one is called palace and the other one is called vesta. They are two curves with prime orders. So you can't really use KZG because KZG is for pairing.
00:08:31.130 - 00:09:22.630, Speaker A: But you can use something like IPA that works with prime order curves, that doesn't use pairings as your polynomial commitment scheme. And palace has the scalar field of palace is FQ, and the base field of palace is FP. And usually I remember it because p is like pass. And so the other way around in Vesta, you have a scar field, FP, and the base field is FQ. Right? So that's the trick. That's the trick I wanted to talk about in this video. Usually this is referred to as cycles of curves.
00:09:22.630 - 00:10:11.630, Speaker A: And this one is, I believe we call that a two cycle because it's a loop that only involves two curves, but you could have a bigger loop or something like that. Cool. So, last thing I want to mention is that this thing that I just explained is used in the paper, BCTV 14. I can't remember exactly the names. I'm not sure if you can google that. I'll post a link to that paper in the comment. That's a very well written paper that explains how to do recursion using cycles of curves.
00:10:11.630 - 00:10:47.080, Speaker A: And so that's what was explained in this paper. But what's interesting as well is that earlier in this series of videos, I've talked about Nova and Sangria. And so even though Nova is a pre proof recursion scheme, they also make use of different cycle of curves, because you have exactly the same issues in the verifier circuit. You need to implement this folding scheme. And you're acting on commitments of polynomials. And these commitments are in a different field because they're elliptic curve points. And so you end up cycling between these two curves as well.
00:10:47.080 - 00:11:00.490, Speaker A: Okay, I'm going to stop now. Let's make this video short. In the next video, I'll be talking about more implementation details that arise when you have to do these kind of recursive circuits. Bye.
