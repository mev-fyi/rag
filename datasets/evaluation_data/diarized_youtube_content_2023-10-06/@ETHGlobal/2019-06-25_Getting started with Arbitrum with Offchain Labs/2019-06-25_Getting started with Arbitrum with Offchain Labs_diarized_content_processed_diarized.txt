00:00:00.330 - 00:00:17.198, Speaker A: All right. So we're not going to do PowerPoint because we can't change what we talk about. We can't respond to what you say with PowerPoint. So I'm going to go old school and just write on the whiteboard. Off Chain labs is the place. Yep. Right, okay.
00:00:17.198 - 00:01:17.860, Speaker A: So we are Off Chain Labs is a company that got started really in earnest in January. And so we're relatively new. This is the first event that we have sponsored and we are, we think, a couple weeks away from our first Alpha release of our product. So we have a bunch of folks here, some of you have been down to our table, but William, one of our developers, is here, here in the room. Okay, so basically the value proposition in Arbitrum is the value proposition is scalability, privacy, security, and interoperation with Ethereum. So that probably sounds like a bunch of things you've heard before. Right.
00:01:17.860 - 00:02:19.190, Speaker A: But let me talk a little bit about sort of what this looks like from a product point of view. And in particular, I sort of want to run through what you would do to take an existing DAP that you have and get it to run on Arbitrum. And in doing that, we'll sort of talk about what are the parts of the system and sort of how they work. So the first step of porting your DAP is you're going to write the thing and you write it in solidity with say, let's say a web3 front end. Right? So familiar technologies basically for developing them. And you can take an existing DAP that's already developed to run on Ethereum and run it and deploy it on Arbitrum. So the next step is to compile.
00:02:19.190 - 00:03:33.346, Speaker A: So we provide a compiler and it's integrated with Truffle. So if you want to use Truffle, you just say Truffle, migrate, network Arbitrum and the rest just happens. So what this does underneath is you're going to take your Solidity code, which you've developed, and it's going to get compiled into an Arbitrum executable. And the way that works internally is essentially we use the standard compiler to compile into Ethereum virtual machine code and then we translate that and link it together to make a single Arbitrum executable which encompasses a bunch of contracts. Right? So adapt that you write consists of a bunch of contracts. You compile all those together into one Arbitrum executable. So this produces an Arbitrum executable file as its only, as I said, the only change if you're using Truffle to manage this process, the only change is a different command line.
00:03:33.346 - 00:04:38.174, Speaker A: Switch to Truffle to make it happen. Okay? Now if you're going to deploy on Arbitrum, the Arbitrum model runs your contracts offline off chain and your contracts are managed or monitored by a set of validators. So you choose the validators for your contract. So this is actually an important aspect of the design. There's not a single set of validators that everybody uses you get to choose your own Validators when you deploy an Arbitrum executable, when you start it up, you choose your Validators. So you choose your validators. So and we provide reference code to do this, which runs as a docker container so you can read our code.
00:04:38.174 - 00:06:07.586, Speaker A: You can satisfy yourself that the implementation of Validators that we provide is secure and so on. But once you're happy with that, your build process will just make a docker image, which you can then using our deploy script, just launch and the Validators will run. Okay? And because it uses docker, it's going to be relatively easy to manage that and launch it from wherever you are validators run off chain. And we provide what we call the Any Trust Guarantee, which means that as long as at least one of your Validators is honest, then your contract will execute correctly. One honest Validator implies correct execution, right? So this is what allows you to have a strong degree of trust in the execution of your contract while almost everything happens off chain. So one of the questions we often get is how do you choose your Validators? And the answer is you could do whatever you want based on this guarantee. But let me give you some examples.
00:06:07.586 - 00:07:30.370, Speaker A: So if you have a contract that has a small sort of fixed set of participants, then you could just name all of those participants as Validators. So if you and I are playing a game of chess as a contract, we would just name the two of us as the Validators, right? Now each of us knows that at least one Validator is honest and will stick up for our own interests, right? I know that there's an honest Validator because I am a Validator, and same with you. So for a two person contract or a three person contract, something like that, or even any small number of participants, just making each participant a validator is perfectly good. And each participant can then enforce correct execution of the contract in order to protect their own interests. If you have a larger, more open type of contract with a lot of participants, then you need to choose a set of Validators which is large enough and diverse enough so that all of your users will trust at least one of them. And this is going to be context dependent. But because of the Any Trust guarantee, if you have, say, a couple dozen Validators who are chosen in a thoughtful way from the community, then your users ought to be able to trust that at least one of them that those validators will not all collude in order to corrupt the contract.
00:07:30.370 - 00:08:28.660, Speaker A: All right? So that's the security guarantee and you have to choose your Validators when you launch. But the design of Arbitrum, the protocol and so on, gives you this Any Trust Guarantee. Okay? So you've written your contract in solidity, you've compiled it, you've chosen your Validators, you're going to then deploy your DAP. So what does that amount to? That amounts to starting up your Validators, if they're not already running, and then doing a call on the Ethereum chain to launch your contract as a running Arbitrum virtual machine. So your Validators get started and there's a deploy script. You can just run one command line to launch all of your Validators. If you're testing, it just starts up an appropriate set of docker containers and make sure they can find each other and so on.
00:08:28.660 - 00:09:47.972, Speaker A: And then it gives the code the initial state of your contract to those Validators and those Validators will then execute your contract going forward. Okay? So the validators will run your DAP. Once you do the deploy, once the thing is deployed and running, you then can launch the front end or front ends in a browser. You can use unmodified web3 front ends for this. And we provide a provider which is the glue to connect that front end to the Arbitrum infrastructure. So what that means is that when your front end wants to do an RPC to call to the contract, that RPC gets directed to the Arbitrum infrastructure, which sees that it's delivered in the appropriate way to the running contract to the correct running contract on the Arbitrum platform. What you then get back what will come back to your front end is a statement signed mutually by the Validators that gives the result of that execution.
00:09:47.972 - 00:10:36.452, Speaker A: So it looks like a call in the same way as a call to an Ethereum contract that the front end RPCs to, as far as it knows, it RPCs to the contract and gets back a result which is cryptographically signed by the Validators. Okay? That is basically the process. There's only one more piece of the technology that I haven't mentioned yet. I've mentioned two of the major components of Arbitrum, I've mentioned the compiler and I've mentioned the Validators. The third piece is what we call the ETH Bridge. And this is as low as I'm going to go on the whiteboard. The ETH Bridge is the third major component.
00:10:36.452 - 00:11:53.408, Speaker A: And what this is, is it's an Ethereum contract or set of contracts. It's an Ethereum DAP that runs on chain. And it is, as the name would suggest, is the bridge between Ethereum Land and Arbitrum land. So what does it do? It manages the deployment or launching of contracts on Arbitrum. It passes calls and back and forth between Arbitrum land and Ethereum land and it allows you to transfer funds that is either Ether or any other ERC 20 or 721 token from Ethereum Land to an Arbitrum contract and then the Arbitrum contract to make payments that will go back to parties that are on the Ethereum blockchain. The other thing that the ETH Bridge does is it referees any disputes that happen among the Validators. So it makes sure that anytime the Validators want to write something to the main chain, which they don't do all that often, but they do do sometimes it makes sure that those are valid and if there's a dispute among the validators, it will referee that.
00:11:53.408 - 00:12:32.380, Speaker A: So you had a question? No, this is fine, actually I'm basically done with the here's the parts and how it works. So let's go to Q and A. Yeah, basically we were saying that a validator operates on intent. It's not a minor in the sense that it's not doing the operation of mining. A validator is not part. The validator doesn't work for the Arbitrum system, it works for a particular contract or DAP. Right? And there are two ways that validators are motivated.
00:12:32.380 - 00:13:26.172, Speaker A: Some validators are motivated because they are participants in a contract and they have an intrinsic motivation to want it to happen. If you and I are playing chess for money or for a gold star token, that we have enough incentive ourselves to act as validators. But sometimes validators are paid and there's a mechanism for doing that that you can arrange to launch a contract in such a way that the validators get a guarantee that they will be paid a certain amount per block time for doing the work of validation. Right? So those are the two models, either intrinsic motivation or else payment. One thing about the protocol is that when a validator misbehaves that will be provable to other parties later. And so what that means is that validators do have a reputation to worry about as well. That's part of the mix.
00:13:26.172 - 00:15:00.460, Speaker A: But we believe that they'll be motivated either because they're participants or by payment. Okay, so let me talk a little bit about how it works to make this possible and what happens on chain and what happens off chain. Right? So the state of a contract is managed and sort of is managed and tracked by validators when they run this eraser is terrible. Okay? So each validator of a contract has a copy of that contract's code and state. You can think of it we refer to the contracts that are running as VMs virtual machines because that's fundamentally what it is, right? And so each of the validators has a full copy of the VM state. And when things are going as they should normally each validator has a replica of the VM state and those replicas will be in sync. So when the validators agree unanimously on what the VM will do next, then they all jointly sign a statement that says what the VM has done, that it's received certain messages, that its state has changed and that it has taken certain actions, meaning emitting events or making payments.
00:15:00.460 - 00:16:01.810, Speaker A: And if the validators all unanimous of a VM all unanimously sign a statement like that, then that statement is accepted by the system. So remember the any trust guarantee, right, you need at least one honest validator. And if all the validators agree, then the honest one must have been part of the agreement, right? So that's consistent. And you can have a series of these that operate sort of state channel style off chain. And then only at the end of the sequence of these do you go to chain once. And what goes to chain at the end is a very small cryptographic hash of the state of the VM. The entire state of the VM is arranged in a kind of merkel tree and so that there's a single cryptographic hash that summarizes the complete state of the VM along with information about the messages that it received and the actions that it took, which is emitting events and payments as well as the results of any calls that were made to it.
00:16:01.810 - 00:16:44.640, Speaker A: All right? So that's kind of the normal mode and that's what Validators are incentivized to do. You can operate off chain for an entire sort of state channel style in that setting. But the thing that mostly differentiates come on in. Hey, no worries. The thing that mostly differentiates arbitram from some similar products is the way we deal with situations where a Validator is unavailable or where the Validators disagree about what a VM will do. And that's where a lot of the novelty in our design is. So let me talk a little bit about how that works.
00:16:44.640 - 00:17:36.256, Speaker A: Right? So sort of classic basic state channel technology is able to do unanimous progress, as I described just sort of a minute ago. But where it breaks down is where you don't have everyone on all of the participants or what we call validators online and in operating. And so there's two situations that can happen. Situation number one is one of the Validators goes offline or becomes unavailable, then you no longer have unanimity. Right? And the way that we operate in that case is that any one of the Validators can make what we call a disputable assertion about what the VM will do. That's a statement that they make on chain with a stake behind it, claiming that the VM will do a certain thing. Then there's a time window in which any other Validator can dispute that.
00:17:36.256 - 00:18:36.772, Speaker A: If nobody disputes it within the time window, then the system accepts it and you move on, right? So if the problem is just that some Validator is offline, then you can make progress via these disputable assertions. And that means that you have to have a small assertion on chain every time the VM is going to make progress, but it's just a cryptographic hash of the new state of the VM plus any actions that it takes, right? So that's how you deal with unavailability. But then, of course, the other case is, what if a Validator is malicious or makes an error and makes a false claim about what's going to happen? So the scenario there is you haven't reached unanimous agreement with full participation. So you have one of these disputable assertions that's put on chain by one validator, then some other validator challenges. It within the time window. Right now, you have to have dispute resolution. And this is a place, again, where we have an approach that we think is superior to what other people do.
00:18:36.772 - 00:19:07.528, Speaker A: This is the case which is the hardest to handle in a scalable and performant way. All right, so here's the way this works. The dispute resolution, the way you can think about it is it's a kind of game between two parties. One party is an assertor who's made a claim about what a VM will do. The other party is a challenger who says that claim is wrong. And this dispute game is refereed by the ETH Bridge, which is an on chain contract. And the dispute resolution happens in two phases.
00:19:07.528 - 00:19:55.390, Speaker A: The first phase is a Bisection phase. And if you're familiar with TrueBit, there's a lot of similarities to one aspect of Truebit's design here. So some validators made a claim that says that if you start with this state hash H Zero, that you can execute N steps of execution and the result is state hash H One. This is the claim. Somebody else says that's wrong. So now the original asserter has to break their assertion in half. So they make one assertion that says that in N over two steps, you go to H sub one half, and then in an additional N over two steps, you go from H sub one half to H sub one.
00:19:55.390 - 00:20:40.990, Speaker A: Right? And so the assertor breaks their assertion in half. And the on chain ETH Bridge just needs to verify that these two things, if you stick them together, are equivalent to this. That the steps add up, that the end hash of this first sub assertion is the same as the beginning hash of the second one. And in addition, that all the actions that were taken here are divided into two pieces, right? So that's pretty easy to verify. Now, the challenger has to pick one of these two halves to challenge. And once you've done that, that's one round of Bisection and you've cut the size of the dispute in half, right? You keep doing that a logarithmic number of times and it's not really Bisection. It's like five way section or something.
00:20:40.990 - 00:21:46.320, Speaker A: It's a more efficient way. But fundamentally it's this recursive subdivision, right? And you keep doing this until you have a disagreement about one step of execution. So you have a hash here and you have a hash some other hash later, and there's a single step of execution and the dispute is about that. Now, at this point, the assertor needs to put right on chain a one step proof. That is a proof that if you are in a machine state that hashes to this, you can execute one instruction to get to a machine state that hashes to that. And this is where the other really significant set of innovations in Arbitrum comes in in that we've designed our virtual machine architecture in a way that allows this proof to be very small and very fast to check. So no matter how big your virtual machine is, no matter how big the code is or how much data you have, these proofs are a couple hundred bytes and they're checkable in order of 100,000 gas on ethereum.
00:21:46.320 - 00:22:53.568, Speaker A: Yes, it's a proof that if you start in a virtual machine state that hashes to this that you can execute one step of execution, one opcode of execution and the result will be a state that hashes to that. Right? So this is the assertion and also there's optionally a single action that might have been taken. You might have emitted an event or you might have sent a message in here. And so that would also be part of the assertion. Right? And so the proof is information sufficient to allow the ETH bridge to verify that this assertion is in fact true. And so it's not obvious that it's possible to do this, but we figured out how to make this proof extremely small and fast to check. So the combination of this bisection, which narrows down the dispute efficiently and this very efficient one step proof and verification allows us to resolve disputes very efficiently.
00:22:53.568 - 00:23:50.200, Speaker A: So at the end of the dispute, either the assertor or challenger has won the contest and someone else has lost the loser will forfeit their stake, half of their stake goes to the winner and the other half gets burned. And that gives the participants a strong disincentive to either make false assertions or to make false challenges. It gives people a strong incentive to fight this game and win if they're right, because they'll get half the other party's stake. And by burning half the stake we make sure that the assertor and challenger are not in cahoots to cook up a fake dispute because they'll collectively lose half a stake by doing that. And so that's the incentive structure that disincentivizes disputes. But even if there are disputes, we can resolve them fairly efficiently and move on. Those disputes don't necessarily have to be malicious.
00:23:50.200 - 00:24:32.950, Speaker A: It would either be malice or it would be a bug. Those are the only scenarios in which this can happen. The execution again, this gets into the weeds a little bit, but the execution of arbitram assertions are, let's see, the execution of a code within a particular assertion is deterministic. And so there is one correct answer about what the state would be after n steps. Given information that's put in the assertion and that gets into the weeds a little bit, we can talk offline about how we ensure that. But there is one right answer. And so if there's a dispute, someone is wrong and they're either maliciously wrong or they have a bug in their code.
00:24:32.950 - 00:25:00.776, Speaker A: Sorry, if both people are wrong, someone will. So strictly speaking, this protocol identifies one liar and that liar is punished if both people are lying. If you're lying and the other person is also lying, you might get lucky and actually win the game, but you're deterred from doing that. Right. And it's negative sum for the players. That's right. We don't try to identify everyone who is lying.
00:25:00.776 - 00:25:20.820, Speaker A: That would be much more expensive. Yes. Thank you. Can you maybe talk a little bit about storage and data? Yeah. The storage is going to be on the validators. Yes, that's right. The storage is on the validators.
00:25:20.820 - 00:26:07.932, Speaker A: Now, in addition to validators, there is another status that we call Observers. Observers get to see what's happening inside the VM, but they don't participate in ensuring correctness. So other parties can be Observers, and so they will know what's inside what the VM's storage and memory are. So they'll have a full copy of it. So it's replicated across all of the Validators and the Observers. Yeah. So a full hash of the VM state is stored, is committed to by the Validators.
00:26:07.932 - 00:26:49.840, Speaker A: And so the Validators have committed to what the state is. And you can have an out of band protocol with them to challenge them to say show me, prove to me that memory, location, number, such and such has this value. And they can present a merkel proof that builds off this route to show you that. Or they can just tell you the full state of the VM, including all the storage and the code and everything, and then you can merkel hash it yourself and verify so they can prove to you. And you can demand that. But there's nothing within the protocol that forces them to give you that proof. When you ask the observers.
00:26:49.840 - 00:27:39.260, Speaker A: Right. So really the reason you would be an observer is you want to be able to look into the state efficiently. In principle, you could always just ask a validator, and a friendly Validator would answer any question you had about the internal state of the VM, but it might be more efficient for you to be an observer. So, for example, you can make non mutating calls if you're an observer, you can execute non mutating calls on the on a solidity VM, because that doesn't need to go to chain. We're going to lose the room right now. I would be happy to just answer questions out here for as long as you guys want, but we are being kicked out because we've reached the end of our time. So thanks for your attention.
00:27:39.260 - 00:28:07.750, Speaker A: Just point you to offchainlabs.com and invite you to follow us and to watch for our alpha release, which we think is a couple of weeks away. Thanks. Sorry. So the alpha will be designed for testing on a local net. Local test net? That's the next thing. Yeah.
00:28:07.750 - 00:28:25.230, Speaker A: So we're going to go through the usual steps. First an alpha that you can run on a local test net, then a beta that you can run on the ethereum test net and then a release that runs out in the real world. Thanks.
