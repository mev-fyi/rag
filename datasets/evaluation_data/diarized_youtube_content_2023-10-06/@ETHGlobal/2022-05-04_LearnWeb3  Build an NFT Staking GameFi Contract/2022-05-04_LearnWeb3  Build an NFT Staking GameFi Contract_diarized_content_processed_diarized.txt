00:00:10.470 - 00:00:44.896, Speaker A: For those of you who are just joining, we're just waiting a couple of seconds for the stream to go live before we get started. Awesome. Hey, everyone. Thanks for coming to our first day of Hack Money workshops. We have hardik from learnweb. Doing a workshop on build an NFT staking GameFi contract. Questions go in the zoom chat and Hardik will answer them as they come in.
00:00:44.896 - 00:00:48.400, Speaker A: And then with that being said, I'll pass the mic along to Hardik.
00:00:50.120 - 00:01:02.708, Speaker B: Perfect. Thank you, Anna. Welcome, everyone. So today we're going to be building GameFi contract. As she said. Let's just start. So a little bit about me real quick.
00:01:02.708 - 00:01:22.510, Speaker B: Hi. My name is Hardik. I have no legal first name and somebody asked me this last time, but I also have no legal middle name. It's a single name. I'm the co founder of Learn Web Three. Dow huge decentralized identity. Maxi has spent most of my life in that field in Web Three.
00:01:22.510 - 00:02:17.704, Speaker B: I currently work at three box labs as the team behind ceramic network and previously used to work at dapper building flow blockchain and dapper wallet. So today I'm going to try to divide it into roughly three sections. We're going to spend like a couple of minutes understanding what we're building, spend most of the time actually coding it out. And then I want to leave some buffer room at the end for Q A and discussing certain things. Before we proceed. Somebody has a question in chat. So I'm sorry if I butchered this name, but Jose Ramon asks, is this workshop in one of the existing Learn Web Three tracks? The answer is no, this is actually not part of our tracks, but it will end up being on Learn Web Three's YouTube eventually.
00:02:17.704 - 00:02:47.450, Speaker B: So you can watch the recording there on E global's YouTube and also on our YouTube. And yes, Marco, it will be recorded and available. Perfect. So what is NFT staking? It's kind of a new trend in this space. We've seen Apecoin Banana Coin. Milk coin, like apecoin, obviously from the board apes ecosystem. Banana coin from Cyber Kongs, who were one of the first people to get this thing going.
00:02:47.450 - 00:03:45.980, Speaker B: Milk coin from CoolCats. And it's basically an attempt at merging the NFT ecosystem with the DFI ecosystem. And the main use case is you can provide exposure to your ecosystem beyond your 510K NFT holders. And this allows you to also you can integrate the CRC 20 token into future projects and whatnot the possibilities are really endless. Right? You can keep building utility for this token. You can kind of incentivize your long term NFT holders by having them stake their NFT and give out the token mint future things using only the ERC 20 token. So Creeps was a project that minted out a few months ago and the follow on mints, they did, like, future generations of their project and sort of side projects.
00:03:45.980 - 00:05:30.812, Speaker B: They only allowed minting in their token so you couldn't mint with ease and the only way to get their token was basically be staking or buy it off of secondary. Essentially it allows users to kind of borrow against these tokens and again provide exposure beyond the ten K NFTs so sora is asking so it's basically an ERC 20 and an ERC 721 how is this different from an ERC 1155? Well, it's different because we're not combining the two per se like an ERC 1155 would. What we're saying is you have an NFT collection that you already launched and it's sold out, and you have a bunch of holders, and you want to introduce a token in the ecosystem to kind of give people more exposure to your ecosystem without needing to buy a complete NFT like board. Ape, for example. Right? Board Ape costs over 100 e and you can't expect everyone to be able to afford that. So currently the cheapest way to get exposure to the Board Ape ecosystem is through Apecoin right? That's what we're trying to do and the apecoin like apart from the initial AirDrop the way you get it is people with apes can stake their apes to get apecoin and then sell it on secondary so that's what we're kind of going for here. So looks like I forgot to change the title of this slide but this should be building a GameFi contract but roughly what we're going to be doing is so we are limited on time.
00:05:30.812 - 00:06:25.148, Speaker B: So I have some things I've already kind of pre built and some things that we're going to do live right? So we have an NFT collection we're not going to be building this live. I have the code for it already and I'll give it to you in a second today live we're going to be building out the Staking contract mainly and the idea is any NFT holder can kind of stake one or multiple NFTs in the contract they're going to be earning a yield of 1000 tokens a day. It's pretty basic all NFTs earn the same yield. They can unstake at any time and they can claim their tokens that they've accumulated at that point at any time. So let's get started. So if you guys are going to be coding along, I want you to kind of go to this link, GitHub.com. I'm going to post it on Chat as well, by the way.
00:06:25.148 - 00:07:18.712, Speaker B: So, GitHub.com, learnweb three dowhackthemoneyworkshop and when you clone this repo, you will find it's a hard hat project that uses TypeScript. And I created like, some boilerplate files and a few basic scripts. I will go over them right now so let's actually just switch to Vs code and let's kind of take a look at what's already here before we proceed further. Perfect. So the first thing is there is an NFT contract it's called NFT Sol. It's a super simple ERC 71 721 nothing fancy at all just for the sake of the tutorial.
00:07:18.712 - 00:08:04.030, Speaker B: All it does is it inherits from ERC 721. It has a certain number of max NFTs and anybody can come and mint it for free. No limitations at all. Obviously if you're doing this for a real project or NFT contract is probably more complicated than that, but it doesn't matter. As long as it's an ERC 721, it doesn't matter. This is just for demonstration. The second contract I kind of have here is the NFT staker and this is completely and because we're going to be coding this live today and there's nothing else in this contract right now except just the imports we're going to be using and the basic declaration of the contract itself.
00:08:04.030 - 00:08:57.310, Speaker B: Other than that, there is a deployment script. We can come back to this, but basically there's a deployment script to deploy both of these contracts. And I created a few different Hard Hat tasks that are going to come in useful later on. If you're not familiar with Hard Hat tasks, they're basically a way to kind of do things in the console, in the terminal with Hard Hat, like calling smart contract functions and whatnot or doing something on the ethereum network. So we're going to use this for testing and I'm going to demonstrate that the contract actually works. And I'm not scamming you guys here after we are done writing this, but we can get into these more later. If you're absolutely new to Hard Hat tasks, the Hard Hat documentation provides a very good overview of this.
00:08:57.310 - 00:09:42.124, Speaker B: We will likely not have enough time to go super deep into how exactly these tasks are working, but feel free to go through this code. There's not too many. There's only like five or six and they're pretty straightforward. All right, let's get started with the actual code. So NFT staker. So let's try to think about what do we need? What do we need to build an NFT Staking contract? Right? People think it's some sort of like so Huxwell is asking the private key is in N example, this is not a real private key. If you look at it, it's just ABC, one two, three.
00:09:42.124 - 00:10:29.660, Speaker B: ABC, one two, three. ABC one two, three. It's just like the default one that Hardhat generates for you when you set up a new project. Don't worry, I'm not leaking my main net funds to you all. All right, so what do we need for NFP staker? Well, obviously we need a way for people to stake one or more NFPs and then every 24 hours they should be getting 1000 tokens. And this should be also like prorated, right? So if somebody only stakes for half a day or like 1 hour, you shouldn't just get zero. You should still get like a fraction of the 1000 tokens.
00:10:29.660 - 00:11:55.210, Speaker B: You want me to zoom in? For sure. Let me know if that is okay. Perfect. So, yeah, we need a way for people to stake one or more NFTs every 24 hours they're going to be getting 1000 tokens. This should be prorated for smaller times and then we need a way for people to unstake and we need a way for people to claim those tokens. Right? So what kind of interactions is the contract going to need? We will kind of figure it out as we go but there are some things that we obviously need so we know that we are going to somehow need to talk to the NFT contract kind of to do things like transferring NFTs in and out. So we probably will want to keep a variable for that somewhere and then we probably want to keep track of every user stake, how many NFTs they've staked, what are the token IDs of those NFTs? How much tokens have they accumulated over time? So we could probably go with something like a struct for a staker and yeah rest will figure out as we go.
00:11:55.210 - 00:13:24.916, Speaker B: So for these two things I'm just going to define them right now. So we import if you notice we imported the interface for ERC 721 so I can just do IRC 721 NFT contract and this is going to be pointing to our NFT contract and let's define the staker struct. What do we need here? We need to track how much yield are they earning? Right? So per yield is like if you have one NFT staked you're getting 1000 tokens every 24 hours. But if you have two NFDS staked you're getting 2000 tokens every 24 hours and five is 5000 tokens every time so on. So what is their current yield? Carl is asking in Chat so what are these staked NFDS used for in a Dex? The staked tokens are used for liquidity so in this case they're not used for like we're not trying to build a Dex, right? We're trying to build a way to sort of extend the utility of your ecosystem and kind of give more people exposure to your ecosystem. It's very similar to again like board apes doing apecoin or milk token from cool cats and so on. They're not necessarily trying to build a Dex so you can take apecoin and put that on a Dex if you want.
00:13:24.916 - 00:14:34.748, Speaker B: But the way to get apecoin is by staking your apes in the ape staking contract and it oftentimes it provides a way to get into the ecosystem without needing to committing to buy a full NFT. And then you can build your own utility around these tokens right? Like minting future things with these tokens possibilities are endless. Build utility around these tokens any way you want through Minting, through Dow voting you can set up a Dow where these tokens are required for governance voting or whatever. Yeah anyway so we need to track X number of tokens every 24 hours. So like how much are they earning every 24 hours? Then we're going to track their rewards. So how many tokens have they accumulated but not claimed so far. Right.
00:14:34.748 - 00:15:21.512, Speaker B: And then we're going to keep a track of last checkpoint. So this is kind of like when was the last time rewards were calculated on chain? And we'll figure out why this is important shortly. But we basically want to keep a timestamp of when did we last do any on chain calculations for the rewards. And then lastly, we'll just keep track of which NFTs did they stake. So this would just be a UN array of token IDs. Perfect. So now we have a staker struct and we need a way to map every user to this.
00:15:21.512 - 00:16:14.000, Speaker B: So map an address to a staker and call it Stakers. Right? And let's also define some constants while we're at it. So let's say event constant seconds per day is 24 hours into 60 minutes each into 60 seconds each. Right. Solidity represents timestamps in seconds, not in milliseconds, so you have to be mindful about that. And then base yield rate. How many tokens are they getting every 24 hours? So they'll be getting like 1000 tokens and we say ether to convert it to the 18 decimals representation.
00:16:14.000 - 00:16:47.670, Speaker B: But this actually means 1000 tokens. Or you could just do like 1000 into ten to the power 18 if you wanted to. I just think ether makes it look a little bit cleaner. Okay. All right, let's get started. And if we need anything else, we'll kind of figure it out as we go so you kind of understand the thought process of where it's coming from. And I'm not just doing random stuff because I have the code open in front of me.
00:16:47.670 - 00:17:28.530, Speaker B: All right, so let's start off with the constructor. Well, first things first. This is an ERC 20 contract because we are going to be sort of minting new tokens, right? So we need to be able to call the ERC 20 constructor. And the ERC 20 constructor takes two things, a name and a symbol. So we do need a name and a symbol coming in from our constructor as well so that we can pass it on. That's one thing. And secondly, we need an address to the NFT contract so that we can call functions on it.
00:17:28.530 - 00:18:04.648, Speaker B: So I'm going to take that address here as well. And in our constructor I'm just going to say NFC contract equals IRC 721 contract. All right, fairly straightforward, nothing special. Just constructs an ERC 20 and then creates a pointer to the NFT contract. This one cool. Now, I mentioned we need basically three functions really to get this going. So we need a stake.
00:18:04.648 - 00:18:51.660, Speaker B: I'm just going to declare them and then we can figure out what to do with them. So we need a stake function. It needs to be public, we need an unstake function. It also needs to be public and we need a claim function which also needs to be public. Right? So in Staking I mentioned that we can stake one or more NFTs in the same transaction. So what we want from the user is we are going to ask them for which token IDs they want to stake. Right? So it could be one, it could be ten, however many they want and we can do something with these token IDs.
00:18:51.660 - 00:19:48.930, Speaker B: So let's think about what it means to start staking. Right? So first things first, anything related to this. We probably want to check values or write values in the struct. So I'm going to say staker storage, user is stakers message sender. All right, let's load up their struct from storage and I'll keep a local variable to keep track of their current yield because this is going to be modified because if they're staking more tokens, their yield is going to update. And then let's loop over all the token IDs they sent us and do some checks on them like making sure that they are the owner of those tokens and whatnot. So view four into 56, I equals zero, I less than length and I plus plus.
00:19:48.930 - 00:20:49.910, Speaker B: Right? So first thing we need to ensure that they actually own that NFT before they can stake it. So we're going to require on the NFT contract, owner of every, ERC, 20, sorry, ERC, 721 contract has this function called owner of that just returns the owner of a token ID. So we need to require that the owner of this token ID sorry, new keyboard, getting used to it. Owner of this token ID is actually just message sender and nobody else. Otherwise we give an error saying not owned and then if they do own it, then that's pretty much it. We don't need to do anything else, anything other special. What we can do is we can transfer the NFT from their account to our account.
00:20:49.910 - 00:22:21.650, Speaker B: Note that this does mean they need to approve our contract beforehand, but more on that. Yeah, so we transfer the NFT out from their account to this contract and then one thing we actually want to do is we want to keep track of the original NFT owners, right? So after somebody stakes it, if you call the owner of function it's going to say that this contract is the owner of that NFT. And that's not super great because we want an easy way to check when unstaking, for example, who the original owner of someone was, some NFT was. So I'm going to add a second mapping over here that's going to go from UN 256 to addresses. And this is just going to store token owners, right, so token ID to address. So once we transfer the NFT from their wallet into our contract, you can update token owners to say that the original token owner for this token ID is actually message sender so we can come back to them later on. And assuming all of this is fine, we can update their yield and increase it by our base yield rate, which is a thousand tokens every 24 hours.
00:22:21.650 - 00:23:27.856, Speaker B: And lastly, I'm going to update the staker struct to include this token ID as part of the Staked NFPs array. Perfect. Awesome. Cool. So we go in a loop, we do a bunch of things. We transfer out all the NFTs into the contract, we update the token owners list, we update their yield, and we push the token ID into the staked NFTs list. What now? So we need a way to kind of tell the contract like, hey, actually let's think about this, right? So I mentioned earlier we have a variable called rewards where we're going to keep track of how many tokens have they already accumulated, right? And also a last checkpoint about when was the last time rewards were calculated on chain.
00:23:27.856 - 00:24:49.820, Speaker B: So why do we need this? Right? So as you might know, like in Solidity, UN have a default value of zero. So when we first start off, when we first create this struct, if it's a new user, both of these values are going to start off at zero, right? And Solidity also doesn't have a way to kind of do things on its own. Contracts cannot just randomly start firing transactions or start firing functions, right? Somebody needs to execute a transaction from the external world and pay gas for it. So calculating rewards on chain, you can only do it in very certain situations, typically front end. Like if you go to a staking pool today and they have this number updating live super fast on the front end, that's not happening on chain, that's just happening on the front end. But on chain calculations, you need somebody to trigger it. You need somebody to pay the gas to do the math and update those values, right? So instead of kind of making explicit functions like, hey, calculate my rewards again, what we can do is every time the user interacts with the contract.
00:24:49.820 - 00:25:50.050, Speaker B: So if they're staking, if they're unstaking, those are really the only two core functions. So every time they do that, we just calculate the rewards again just as part of that transaction. I hope that made sense, why we want to do that. So I'm going to create like a function, I will keep it empty for now, call it accumulate, and we will fill this out later. We will think about what the actual calculation needs to be. But for now, what I'm just going to say is after staking, we accumulate any of the rewards they got. Oh, actually this is another great point, right? So imagine you'd had one NFT staked for the longest time, like five days, and then you come in and you stake a second one.
00:25:50.050 - 00:27:17.664, Speaker B: At this point we need to do an on chain calculation because we need to say that in the last five days you got 5000 tokens. Because from this point on, your yield is going to be calculated based on the stake of two NFDS, not one NFT anymore. And if we don't do that calculation right now, future calculations might be messed up because we don't know how much time was there only one NFT and how much time were there two NFTs. So before we actually finish the staking function and increase the user's yield, we need to accumulate the rewards and then we say, okay, so their yield is now updated to this new yield that we've been adding to the entire time and that's when the function actually finishes. So if you had one staked, let's say you staked one early on and then for five days later you come around, you stake a second one. So we accumulate all your rewards for the one you had in the last five days and then update your yield for the future for whenever you calculate your rewards again and accumulate is just going to kind of play around with two values, right? It's going to play around with rewards and last checkpoint. So we can actually kind of do it right now.
00:27:17.664 - 00:28:12.690, Speaker B: Last checkpoint is let's load up. The last checkpoint is just going to get updated to current block timestamp and rewards are going to be calculated based on a formula. And it's a pretty simple formula, but I'm going to create a helper function for it just to keep it a little bit cleaner. So getrewards error staker. This can just be a view function and what we need here is name this user. Okay, so we load up the staker in memory. Now there's a couple of things.
00:28:12.690 - 00:29:01.888, Speaker B: First of all, there's an edge case here where if user last checkpoint is equal to zero, we actually want to return zero. And guess why that is? Does anybody know why this is? I'm going to move on to writing the rest of the code. Try to answer me in chat. If nobody answers, I'll explain why we need this edge case over here. Otherwise the normal formula for this is basically we calculate how much time has been spent so far, like in seconds. We multiply it by how much yield the user makes in 24 hours and then divide it by the number of seconds in 24 hours. This might make more sense if I write it.
00:29:01.888 - 00:29:59.940, Speaker B: So we take block timestamp and we do block the timestamp minus user last checkpoint, right? So this will give you how much time has passed since the last time rewards were calculated and we multiply it by user current yield. And current yield is based on how many tokens they earn every 24 hours. But it's not necessary that 24 hours have already passed, or maybe like more than 24 hours have passed actually. It's not always an exact multiple. So we take this and then we divide it by the number of seconds per day. And this basically you can think of like this divided by this as the yield per second and you're multiplying it by how many seconds have passed since the last calculation. Okay, so we have a few different answers for last checkpoint.
00:29:59.940 - 00:30:50.640, Speaker B: Yeah, pretty much all of you are basically right. So yeah, the last checkpoint is zero. We don't want to return anything because there's like block timestamp minus last checkpoint will be like a huge number. And this just basically means that they're staking something for the very first time, because the only time this is true is when they literally just come in and stake the first token and accumulate gets called the very first time. So we want to return zero to prevent them from becoming an overnight whale. Other than that, this is the general formula for accumulation. So yield per second multiplied by the number of seconds that have passed and in accumulate, we just update their current rewards.
00:30:50.640 - 00:31:16.670, Speaker B: We add these many awards to their account, basically. Perfect. Cool. So that's actually all we have for Staking. Let me just do one final quick recap and then I'm going to try to rush through a little bit through unstake. We're about 30 minutes into the talk. I want to wrap this up in the next 1520 minutes, hopefully, and leave some time for questions.
00:31:16.670 - 00:32:16.930, Speaker B: So, yeah, what happens in Staking? Load the user storage, keep a local copy of their yield. I mean, you could replace this by just doing user curric. Actually, no, you can't do that because you want to accumulate and also, like, reading and writing from storage variables is expensive in solidity. So it's better if you have a local copy of the variable if you're updating something in a loop and then just update the storage variable later on outside the loop. But anyway, I'm beside the point. We have how much yield are they currently earning? We loop over all the tokens they want to stake. If they are the owner of all those tokens, we take all those NFTs into our contract, update our token owners list, update their yield, add that token ID to the list of NFDS they staked, accumulate any rewards from the past, and then update the yield they're going to be earning from now on.
00:32:16.930 - 00:33:02.808, Speaker B: Perfect. unstake is actually going to end up looking decently similar to Staking. Sorry, new keyboard problems. I bought a much smaller keyboard than I previously had, so I keep hitting buttons on accident because I'm not used to this size, but I'm trying. Okay, so unstake as well. They could be unstaking one token, more than one token. So you're going to take an array, right? I'm going to load up these staker struct from storage for easier access and similarly going to keep track of how much yield are they currently earning in a local copy.
00:33:02.808 - 00:33:44.810, Speaker B: And again, we're going to loop over all the token IDs they mentioned. So for you, I equals zero, I is less than length I plus plus. I guess you should calculate rewards first and then update last checkpoint it shouldn't make a difference. Oh, sorry, you're right. You're absolutely right. My bad. Yes.
00:33:44.810 - 00:34:17.108, Speaker B: If I updated last checkpoint before calculating rewards, this would just turn out to be zero. Nice cat. Sorry, that was absolutely my bad. Thank you. Thank you for catching that, Nilesh. Anyway, so we loop over the tokens. Gotham is asking, wouldn't that be a waste of gas? I'm not 100% sure what you're referring to here, but happy to answer if you could expand on that a little bit more.
00:34:17.108 - 00:35:07.664, Speaker B: But yeah. So unstake we're going to loop over the tokens they wish to unstake. Right? First of all, we need to make sure that they were like the original owner of this token. So if we do have this token ID in our contract, we should have the original owner for it in Token owners array and otherwise we give not original owner. Right? And actually, just to be safe, we can also add another second check thing in case you miss this line. But I don't think this is super important because you will see why. But we can check if Token ID is the owner of the NFP currently.
00:35:07.664 - 00:36:02.712, Speaker B: Must be our smart contract and nobody else. Maybe, maybe if your smart contract further sends the NFTs out to somebody else for some reason you can only unstake if the contract still actually has it. So we check that the NFT is actually staked and that the person asking to unstake was the actual original owner. Right, and since we're doing this in a loop, we'll say if user current yield is not equal to zero, yet this should be if yield is not equal to zero. Sorry. And in that case, we do yield minus equals base yield rate. So for every token you unstake, you get like 1000 tokens less every 24 hours.
00:36:02.712 - 00:37:08.680, Speaker B: Right? And then we actually need to do something a little bit actually, you know what, I'm thinking we could actually save a lot of gas on this. I don't know what I was thinking when I made this. Sorry it was late. We actually don't need to keep track of every single Token ID that they're staking. There is no real point to doing that and it's just a waste of gas in storage now that I look at it with the first set of eyes. Okay, so for every token they unstake, we reduce their yield and then really the only thing we need to do is send the NFT back to them. So NFT contract safe, transfer from this smart contract over to message sender's address over to Token ID and like Token ID's eye.
00:37:08.680 - 00:37:43.444, Speaker B: And once again, before we actually update their yield in the struct, we will accumulate any rewards they might have gotten up until this point. So do an onchain calculation again and then update user curryield equals yield. All right, perfect. So it doesn't make sense. So let's do a quick recap. We load the struct from. Storage, create a local copy of how much yield are they earning.
00:37:43.444 - 00:39:12.432, Speaker B: Right now we loop over all the token IDs they want to unstake, ensure that they were the original owner of that token ID and ensure that our contract actually owns that token ID. Right? And at this point we should actually also be updating token owners token ID to just be equal to address zero because they might sell the NFT and then come back later on and then do some weird stuff. Okay, let's just do that and actually we just delete it or delete it, reset it to zeros anyway. So update the owners, remove their ownership from the token owners mapping, update our local copy of the yield. So for every NFT they unstake, we reduce their yield by 1000 tokens and then transfer the NFT out from our contract to their address and before updating their yield in storage, we accumulate any rewards they've gotten up until that point and then we are done with the unstaking function. Perfect. And the last one is actually the simplest claim is super simple claim.
00:39:12.432 - 00:40:31.528, Speaker B: All we really need to do in claim is that we figure out how many rewards have they currently earned. Right? So they have some rewards that we calculated at some point in the past, but before they claim we're going to accumulate the rewards once more to make sure we are using the latest values. So we accumulate the rewards and then we just need to mint them. We mint some tokens, ERC 20 tokens to message sender worth user rewards and then we update user rewards equals zero. You can mark this as a non reentrant just to prevent from reentrancy attacks over here. Actually, if the user receiving this token is like a contract they could do some funky stuff with it maybe? Um, yeah, should be, but for right now we're not gonna do any reintroducing going on here. Okay? So yeah, it's just super simple right? We accumulate the rewards, we mint that many tokens to message out sender and we update the rewards.
00:40:31.528 - 00:42:00.952, Speaker B: Okay? So Jose Ramon is asking a very good question. What about the well known warning for not using block timestamp for time calculations? Is this staking formula used in production? So the reason people tell you not to use block timestamp is actually not that it's completely bad, right? Like miners have the power to kind of change it a little bit if it benefits them a decent amount. Right? Because when miners propose a block they can kind of update the timestamp to be like a couple of minutes ahead or a couple of minutes before than it actually was. If doing that somehow is incentivizing them because some contract is trying to use that value to do something. So typically block timestamp is something that we don't worry about, we don't use or we don't recommend if we're trying to do calculations within short time frames and also if it's like short time frames, but large incentives to kind of try to cheat that. In this case, if you bump up like block timestamp, a couple of minutes up or down, it's barely going to make a difference to how many tokens you're earning. Just because you're not really earning that many tokens every second and having a couple of minutes up or down, it doesn't really change that much.
00:42:00.952 - 00:43:00.510, Speaker B: And miners would typically not care about earning, for example, five more eight coin than they would have if they hadn't done that. So in this case it's usually fine. There are sort of NFD staking contracts in production on mainnet right now that do use this formula or like similar formulas. So in this case it should be fine. Don't worry about it too much. Huxwell is asking why are we using a memory variable? Okay, so Huxley is asking why are we using a memory variable here but a storage variable here? Well, this is because sorry, somebody talking. I can't hear you.
00:43:00.510 - 00:43:29.284, Speaker B: Okay, the getrewards function looks kind of sus. You can impersonate another address and get the rewards. Well, this is a view function. This is not doing anything. This is just calculating the rewards for a certain address. It's not like responsible for sending you any tokens. It's not responsible for updating any storage values or anything like that.
00:43:29.284 - 00:44:01.856, Speaker B: It's just calculating how many rewards a person has gathered. And it's just a view function. The actual accumulation only happens in stake, unstake and claim, in which case you only call, accumulate and get rewards for the person calling those functions itself. So it should be okay. Huxle, it looks like somebody answered your question. Storage versus memory can be a confusing topic, I understand. Probably don't have enough time to go super deep into it.
00:44:01.856 - 00:45:05.300, Speaker B: But since we're not trying to change any variables persistently, we don't need to use storage. Storage is more expensive. Yes, Louis, you're right. I did mention that we probably want to use a reentrancy guard here, actually. But then I was just thinking about ERC 20 Contracts not really having a kind of like a hook to notify recipients when they receive the token, so there is no function being called when they receive the ERC 20 token. Reentrancy is very common if you're sending east, because then the contract can just implement a fallback function, or if you're even sending NFTs, they can implement the on 721 received hook. But in ERC 20s there's no such hook, so it shouldn't matter.
00:45:05.300 - 00:46:00.850, Speaker B: But you could apply a reentrancy modifier here if you wanted to, just to be safe. But to my knowledge, I don't think there is a hook for ERC 20 transfer Security. I forget where it used to be located. Contracts. Security reentrancy guard. Okay, open Zeppelin contracts Security Reentrancy Guard and then we can apply non reentrant to claim. Okay, leonard is asking, can you come back on the top of the So Oops it is the name.
00:46:00.850 - 00:46:27.656, Speaker B: It spell it wrong. Yes. Okay, so what ID? The receiver contract is ERC 710 seven. It will also implement ERC 20. No, that is fine. That's not what I'm saying. It can implement, ERC, 20.
00:46:27.656 - 00:46:40.880, Speaker B: That is fine. I'm just saying there is no ERC 20 doesn't have a hook that gets called when you transfer something. So if I'm sending you or a contract, an ERC 20 token.
00:47:17.270 - 00:48:30.310, Speaker A: Hi. So it looks like Hardik's Internet went out for a second. We're just going to wait a couple of seconds for him to come back online. Thanks, everyone, for your patience. So we're just going to wait a couple moments for Hardik to rejoin as his Internet comes back.
00:50:45.890 - 00:51:04.402, Speaker B: Hey, guys, I'm back. So sorry about this. Live demo issues. Did not expect this to happen, but my Internet just died and I had to rejoin. Can you guys see my screen? Somebody let me know if you see my screen.
00:51:04.536 - 00:51:05.634, Speaker A: Looks great.
00:51:05.832 - 00:51:46.926, Speaker B: Perfect. Thank you. Sorry about this, guys. So, yeah, I forgot what we were talking about, but yeah, I think I was saying that ERC 20 doesn't have a transfer hook, so it should be fine. I mean, worst case scenario, we did add the non reentrant modifier, so in case the implementation gets updated to have a transfer hook, then this will stop reentrancy anyway. But yeah, we have like ten minutes left in the demo. I kind of want to quickly start showing that this actually works while we also answer questions on zoom.
00:51:46.926 - 00:52:18.944, Speaker B: So let's compile these contracts and hopefully they compile. We're going to be doing all testing on a local Hard Hat node just to keep things fast and smooth. Perfect. So they compiled and what I'm going to do is I'm going to start up a local Hard Hat node. NPX hard hat node. This is a local test environment. Perfect.
00:52:18.944 - 00:52:55.608, Speaker B: There we go. I'm going to open another tab here bit. Okay, let's go. Perfect. So I wrote a bunch of tasks, as I showed you earlier. So essentially, I have some commands that I pre configured to be able to demo to you. So one of them, it's free mint free NFT, which we can use to mint a free NFT from the NFT contract.
00:52:55.608 - 00:53:41.480, Speaker B: And then we have a couple of helpers to get your NFT balance, get your Token balance. We have one to set an approval. So since we're transferring tokens in and out sorry, transferring NFTs in and out of the staker contract, you need to provide approval over your NFTs to the staker contract so they can move NFTs from your account. And then we just have three more functions for Stake unstake and claim they don't do anything special. They just really just call those functions with arguments that provide. So I'm going to be using these to kind of show it to you how it works. All right, so before we do any of this, let's deploy our contracts to the local network.
00:53:41.480 - 00:54:22.200, Speaker B: I'm going to run the deployment script. It's going to first deploy the NFT collection and then it's going to deploy the Staking contract. All right, so keep a note of these two addresses. If you're following it live, it may be different on your right. So first things first, we want to mint a free NFT so we have something we can stake and unstake. I'm going to run this task successfully minted an NFT. And all this time we can look at the Hard hat node that transactions are being called and blocks are being mined on our local node.
00:54:22.200 - 00:54:56.950, Speaker B: We can check that we actually got it by doing get NFT balance. And this should say that I have one. Yes, I have one NFTs. And when starting out, I don't have any tokens. I don't have any tokens I've earned from Staking because I haven't staked anything yet. So I own zero staked nifty Tokens. So before I start Staking, I need to set approval on the Staking contract to transfer my NFTs in and out.
00:54:56.950 - 00:55:43.100, Speaker B: Sorry, actually just in really, I guess. And now let's mint a couple more free NFTs so we can experiment with Staking multiple, removing one, removing multiple, and so on. All right, so I'm going to stake one token to start off with. So this hard ad task takes in a list of token IDs which are comma separated. So I can do like one, two, three, and so on. I'm just going to stake one token for now. It'll be token ID one the way the NFT contract is implemented and transfer to a non implementer.
00:55:43.100 - 00:56:26.064, Speaker B: Oh, of course. I need to add on ERC 721 received to our Staking contract to let our Nifty contract know that we are safe to receive 721 tokens. I'm just going to copy it because this is nothing special. Actually, if you're not familiar with this, it's just a magic value function. It returns a very specific set of four bytes, which lets ERC 721 contracts know that it is safe to send 721 tokens to the smart contract. But unfortunately, it does mean we're going to have to redeploy our contracts and start from the top. I forgot to add that.
00:56:26.064 - 00:57:06.130, Speaker B: Okay, so let's deploy again. NPX hard Hat run deploy localhost. All right, our node is running perfect compiled and it deployed. All right, I'm going to mint a couple of NFPs again. Mint one, mint two. All right. And so let's try to stake token ID one.
00:57:06.130 - 00:57:41.000, Speaker B: And oh, this time I did not give approval. Set approval for all. First it said transfer caller is not approved. So makes sense. Now let's try to stake token 81. Perfect. So we staked one and we're earning rewards, like as we speak, right? So because the rewards get prorated every second, I'm earning like a minuscule amount of tokens.
00:57:41.000 - 00:58:32.776, Speaker B: And let's try to unstake this token back. And this should stop our rewards from accumulating and we'll claim those rewards and we'll stake two tokens back again. So let's do a claim. So before this, I had zero staked NFT tokens in my wallet. Once I claim it and I do Npxr get token balance, I should have like a non zero amount, right? And it's going to be represented in way. So this is represented in like 18 decimal places. So it's actually like a much like if you convert it to pure token representation, it's like much smaller than 1000 tokens.
00:58:32.776 - 00:59:20.758, Speaker B: This is represented in 18 decimal places. So divide this by ten to the power of 18. And if I get my NFT balance now, you'll see I have both the NFTs on me because I unstaked everything. Now this time let's take both of them together. Let's take token ID One and token ID two and we'll let it accumulate some rewards for a little bit. We can check our NFT balance to see that we have zero NFDS right now because they got transferred to the Staking contract. And instead of unstaking both, let's just unstake one of them.
00:59:20.758 - 01:00:14.320, Speaker B: Let's just unstake token ID two. We're like right on dot, right on dot of the time, all right, and claim some more tokens. And we should have a slightly higher token balance than we previously did. Yeah, so we had two tokens and we roughly let them in for the same amount of time, like a few seconds, 15, 20 seconds maybe each. But this time we had two tokens accumulating rewards. So we got like three something and we added like six something to it because we doubled the stake, ended up with nine something. We try to convert this actually, I'm going to go to Econverter.com
01:00:14.320 - 01:00:50.214, Speaker B: go here, put it in as way. So we have less than one token so far, really, which makes sense. We have like zero point 98 tokens in the amount of time we've been staked. But yeah, that's basically it. We're right on time. So I'm going to basically stop here if you're interested in looking at this code. The full code is also available at if you go into the repo hack, the money workshop, there's two branches over here.
01:00:50.214 - 01:01:29.842, Speaker B: There's the main branch that I pointed you guys to earlier, which has the starter code, but there is a second branch completed which has the full code in case you guys want to take a look at it or work with it in the hackathon. Build a GameFly project in the hackathon. But yeah, thank you everyone for coming and I really appreciate having you guys here. Q and A, we did that. If you want more of these tutorials, I run learn Web Three so you can join 25,000 other builders for free. It's a completely free course if you're looking to get into web Three and start building. And I wish you guys the best of luck in your hackathon.
01:01:29.842 - 01:01:31.800, Speaker B: And Anna. Over to you.
01:01:32.330 - 01:01:46.230, Speaker A: Awesome. Thank you so much. Hardik, that was super interesting. Really engaging. I'm sure everyone loved it. So thank you so much for your time, for doing this workshop with everyone. Yeah.
01:01:46.230 - 01:02:05.280, Speaker A: For the rest of you, we have some couple more workshops today we have of Teller and badger dow. So hope to see your faces there as well. And otherwise, we'll see you at workshops tomorrow and the kickoff on Friday. With that being said, have a great rest of your day. Evening, morning, wherever you are.
01:02:06.930 - 01:02:08.720, Speaker B: Sorry about the Internet issues.
01:02:09.090 - 01:02:11.040, Speaker A: No worries. All worked out.
01:02:13.090 - 01:02:13.660, Speaker B: See you guys.
