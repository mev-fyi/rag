00:00:07.770 - 00:00:37.794, Speaker A: All right, thanks guys. Thanks everyone for coming. I'm York. I'm part of the engineering team at Hyperlin. And today we're going to talk about permissionless interoperability and what that means. If you have questions afterward or if you want help with integrating hyperlane in the hackathon, definitely come up to our booth or you can ask any questions at the end. So just to start today's session, I think we need some definitions of the title slide.
00:00:37.794 - 00:01:27.990, Speaker A: So permissionless, I think a lot of people throw that term around. It's kind of like at this point used for marketing. But generally the word permissionless means that a protocol is accessible to anyone. There's no kind of discrimination or censorship for specific classes of users to access a protocol. And Interoperability, I think our definition that we can use today is composability for applications that are on different infrastructure layers. And so the Internet is highly interoperable because we have all these shared protocols that are quite permissionless. We have Http, TCP et cetera.
00:01:27.990 - 00:02:31.654, Speaker A: And in Web Three, we're just starting to establish kind of these shared standards that allow applications to communicate with each other. But the problem we see today is like the crypto space is facing this scalability problem and people have kind of identified this as the barrier to adoption for the next billion users. And there's all these great teams at hackathons like this building out these new scalability solutions to onboard that next set of billion users. But the problem is we're ending up with these kind of highly divergent infrastructure layers that don't actually use shared protocols to communicate with each other. And that leads to a big problem, I think. If you look at the evolution of crypto, we've continued to diverge with respect to what protocols we use. I think maybe the first decade was just bitcoin payments.
00:02:31.654 - 00:03:22.090, Speaker A: It's like a very simple application. And then we kind of evolved to these smart contract VMs and that got a little more complicated. And we saw Ethereum and Nier and Solana all popping up with different protocols. And then some people got excited about app chains because there's different scaling properties that you can have if you don't opt into this monolithic infrastructure layer like Ethereum or recently we're seeing Ethereum kind of coalesce around the roll up scaling roadmap. I think Vitalik had like a seminal blog post about that. Arbitrum and optimism now do more daily activity than Ethereum L One. And these protocols also kind of have their own new standards.
00:03:22.090 - 00:03:55.206, Speaker A: There's these new DA layers that are in service to those roll ups. So we have ethereum 4844 EIP. That kind of changes the cost structure for posting call data to L One. We also see Celestia new modular DA that maybe app chains can post call data to. Again, a lot of different kind of diverging protocols. Maybe in the future we'll see some sort of like Plasma or Sharding solution. I think there are probably some teams here working on that.
00:03:55.206 - 00:04:45.640, Speaker A: I don't know what happened to my slides. Oh, there we go. But yeah, this is a problem. On the flip side, looking at this from an application perspective, we're seeing a lot of DApps actually adopt these new infrastructure layers, which is like super exciting. So actually, just like a couple of days ago, Zora, which is like this big kind of NFT social Fiend and Explorer application that is one of the most popular applications on Ethereum, announced that they're going to be rolling out their own layer two using the optimism op stack. I think you guys have probably heard of like Coinbase's efforts to work on their own L2. They launched Base Testnet a couple, I think, like maybe a month or two ago.
00:04:45.640 - 00:05:56.090, Speaker A: If you look at this website, l Two Beat, you can see kind of the evolution of activity over time across these different infrastructure layers. And what you'll see is that actually a majority of activity has migrated to l Two S. And so we need a way for these applications to communicate with each other. And the problem today is we have a highly fragmented market, so we have Arbitrum optimism. Kind of the two main leaders, I would say ZK Sync, it's like the fast follower. They launched the first Validium, so people are super excited about that. And as an application developer, when you're choosing what roll up to deploy your application on, it's a really hard choice because you have to think about what's the security story of this specific roll up? What does the current ecosystem look like? Is there enough liquidity? Are my users going to be stuck here if the platform decides to change their terms of service? Or maybe they're going to censor users based on like OFAC or something like that? It's a really tough choice.
00:05:56.090 - 00:06:53.326, Speaker A: There's all these different interfaces for interacting with these things. So for example, Arbitrum, Optimism, ZKsync all have different smart contract interfaces for handling deposits and withdrawals from L One to l Two. Moving assets between different L2 S. There's kind of also highly fragmented like bridge solutions, so depending on what applications are where there's different bridges available. And then more recently, we're seeing these kind of general message passing protocols to move arbitrary information between L2 S. Pop up hyperlain is an example of this, but again, there's just like all these things to account for. And as an application developer, you have to kind of know about all these interfaces and you have to custom integrate every single one of these new roll ups, new infrastructure layers.
00:06:53.326 - 00:07:23.130, Speaker A: And that's just like a really bad place for us to be in. Actually, just this week, Vitalik posted about this. So like super topical. Vitalik's, like, all in on roll ups being the layer that applications should build for. And he wrote a blog post about kind of what the solution space looks like for interoperability between L two S. And I highly recommend this post. I don't know what's going on with the connection here.
00:07:23.130 - 00:08:35.810, Speaker A: Yeah, I highly recommend this post, as well as the three transitions post, which talks about kind of this evolution of scaling solutions and how we can actually get users to adopt these things in a way that's Internet scale. But yeah, what's the solution to this problem of fragmentation? At Hyperlink, we think it's modularity. You may have heard the term modular blockchains. It's also a heavily used marketing term at this point. But the main idea is you want to separate the interfaces which are exposed to applications from the actual underlying transport layer stuff. So if we have all these roll ups that have different kind of security properties, I think the three kind of examples we can work with in our head are like Arbitrum, Optimism, and ZKsync. All of these roll ups have very different kind of security stories, like when you can view them as settled, what the finality looks like, can you use soft confirmations, et cetera.
00:08:35.810 - 00:09:31.650, Speaker A: And as an application developer, you shouldn't have to think about that or custom integrate that. So instead we can have this universal interface that looks like a message passing interface. And under the hood, depending on the path that we're taking, we can actually leverage different underlying transport layers. But the application developer shouldn't have to necessarily understand that. There should just be kind of like a community governed set of standards for like, okay, if we're going from L one to Optimism, we're going to use this specific transport layer, which is like the optimism bridge to collateralize my deposit. But again, the application developer shouldn't need this crazy switch case statement of if this network do this specific function call. So that's where Hyperlane comes in.
00:09:31.650 - 00:11:27.720, Speaker A: Hyperlane is this kind of like universal interface that tries to abstract all these different bridging interfaces through what we call this general message passing interface. So as an application developer, all you need to understand is this dispatch interface and this handle interface. So I can walk through kind of the lifecycle here, but your smart contracts or your EOA for that matter, can call into this interface called dispatch, which basically specifies the destination blockchain via like, a chain ID, a recipient address on that destination chain and just like an arbitrary body of bytes, raw bytes. And behind the scenes, our protocol will handle the transport layer stuff and then on the destination chain, basically the handle function will be called on the recipient that you specified and that will also provide the origin chain sending address on that origin chain and the body that that sender sent. And now obviously as an application developer, you want kind of strong guarantees around the content and kind of like validity of messages that you're receiving or messages that you're sending that they're actually going to get delivered. I'm happy to kind of talk about the different guarantees that we have for different pathways. But generally, because this is a hackathon, I think it's better to sometimes avoid those nuanced discussions of what the security trade offs are and just try and build something which is useful or demonstrates a new use case.
00:11:27.720 - 00:13:02.146, Speaker A: But yeah, the idea again with modular interoperability is as an application developer we actually have this interface where we allow you to configure your security preferences and your risk tolerances. So we have this interchange security module interface that as a message recipient, you actually just configure as an address if you opt into this configuration layer. And the idea is when you're receiving a message, our protocol will ask you, hey, what is your security module mechanism of choice? We provide a bunch of off the shelf components that you can kind of select from and compose for the various channels. So like optimism, canonical bridge or using wormhole or whatever it is, our protocol will ask your application what security module you've configured for this specific origin and sender and body. You can actually have control flow on the message body which actually changes the security requirements. And so an analogy there is like wire limits in traditional finance. Like if you're just transferring $10 across two chains, you might not care so much about the guarantees that you have in your application and you might not want to pass those costs on to your user.
00:13:02.146 - 00:14:35.578, Speaker A: But if it's like a million dollar transfer or if it's like some sort of governance action, then you might want to really ramp up the verification requirements. Modules that just generally yeah, sometimes it's which bridge do you want to take? We think that bridge is like a loaded term. So there's also different flavors of security. You can opt into economic security versus reputational security or you can have certain I don't know why this keeps dying. So for example, our default security mode for a lot of pathways is this economic security mode where we have a set of validators who are staking on the origin chain and they're producing these attestations of messages which are being sent from that chain. And as a recipient of messages from that chain, you can say, I want to leverage this economic security which gives you a discrete cost to attack the system and kind of it gives you a lower bound of like, hey, up to this, or I guess an upper bound up to this economic value on this specific message. I have kind of strong economic guarantees that this message was actually sent from this chain because otherwise the validators will be slashed.
00:14:35.578 - 00:15:44.902, Speaker A: It's kind of economically irrational and so that's like one type of guarantee you could look for. Alternatively, you could have these sorts of like yeah, like if you're using a canonical bridge, you have this fraud proof system where you can always kind of do forced inclusion or those sorts of things. But yeah, economic security is not the only mode we can do, like, an optimistic security model, which is like a very different trade off. And it's actually like, you can think about it as operating over the same bridge or the same tunnel, but just like, the security constraints that you're imposing on that bridge actually look very different. Yeah, not sure, but where the validator? So right now right now it's like a whitelist, but we're really soon hoping to transition to a fully permissionless validator model where you can put up any staked asset. It actually doesn't matter what asset it is on the origin chain. And you're basically just, like, producing Attestations.
00:15:44.902 - 00:16:45.040, Speaker A: It's kind of super easy to run because there's no consensus and the validators are not networked with each other. They're just producing Attestations on messages that are being sent outbound. Just need, like, an RPC connection to a chain. Depends on the chain. We have all the information in our docs if you want to check it out. The last thing I want to highlight is this modular security paradigm allows you as an application developer to eliminate this scary choice of being locked into a specific bridge or a specific security model or pathway for your users because you can configure this. And so in future, if some sort of ZK lite client becomes available for some pathway, you can just configure that later on.
00:16:45.040 - 00:17:45.726, Speaker A: And this is kind of like a way for you to again separate the application layer from the transport layer. And we think this is really important for just, like, application developers, when they're reacting to kind of the evolution of all this infrastructure, they shouldn't impose those things on their user. They shouldn't have to tell their entire user base, hey, we're actually migrating bridges, so you got to go and unbridge and then Rebridge and then migrate to our new version. That's crazy. So this is just, like, kind of the model that we think is better and is really a framework for how to think about interoperability. We obviously have specific opinions about what the default security modes should be. And if you don't as an application developer, if you don't specify your own preferences, you will kind of by default, be opted into our preferences.
00:17:45.726 - 00:18:22.730, Speaker A: But, yeah, that's the modular framework. The last thing I want to highlight about this modular security paradigm with hyperlane is you can deploy hyperlane anywhere. So we have a guide right now in our docs that walks you through all the steps. Right now, it's only available for EVM networks, but we have several other environments that are pretty much like production ready. We're running on testnet on Solana. We have a fuel VM implementation. We're working on a Cosmos SDK module.
00:18:22.730 - 00:19:41.110, Speaker A: So really we want to make this protocol and this framework available everywhere so that you, as an application developer, not only do you not have to choose a specific bridge, you don't even have to choose a specific execution environment. If you're worried that later Solana might become might eat up all the DeFi market share or something. Hyperlane allows you to easily have your application exist across all these execution environments. And maybe in kind of the near future, your users don't even know which environment they're running on because they just have this single interface into your application and you decide where it makes the most sense for them to get routed to. But yeah, the specific kind of thing I want to highlight here is now if you want to spin up your own roll up, which is kind of, I think, like you saw earlier, something that a lot of people are thinking about. There's this kind of traditional problem of like, okay, you've spun up your roll up, but it doesn't do anything because it's not connected to anything. There's no bridges operating to it, there's no liquidity, et cetera.
00:19:41.110 - 00:20:51.120, Speaker A: And in the past, if you wanted to make those connections to existing ecosystems, you have to go out and you have to talk to organizations and kind of do BD and establish trust and ensure that the bridge that you're getting to come to your ecosystem isn't risky for your users and isn't going to just rug you or something. And now that you can deploy hyperlane and you can configure your own security, you don't have to do any of that. You can start as a new roll up. You can operate your own deployment of hyperlane. And as you scale up and as you kind of progressively decentralize, you can continue to configure the transport layer with stronger and stronger security guarantees for your users. But to start out, it doesn't really make sense for you to impose those requirements before you launch your roll up. You don't want to require that there's a full light client implementation across a bunch of different clients or something.
00:20:51.120 - 00:22:12.742, Speaker A: You just want to be able to launch your application, test it. Iterate yeah, we think this is like a big, yeah, do your deed, but semast actually get that's a great question. So that's probably one of the biggest things that you need to understand when you are kind of building for this MultiChain future is the introduction of asynchrony and execution across many chains definitely introduces a lot of complexity. And one of those complexities is we don't have strong guarantees of transaction inclusion at least today. So unfortunately, the way our protocol works is you pay a fee on the origin chain, which covers the gas costs on the destination chain of transaction inclusion. But if that destination chain's validator set is deciding to be mean or whatever, they can just censor you and then your hyperlane message won't get processed in future. We have ideas about basically building hyperlane messages into the block proposer auctions themselves.
00:22:12.742 - 00:23:50.120, Speaker A: So we could have block proposers like potentially an eigen layer set being aware of hyperlink messages that want to be included for a specific block and we can have a more sophisticated fee market for message inclusion, but right now it just falls back to basically transaction inclusion, which is not something we have guarantees about today. So even as a user on a single chain, when you attach a fee to your transaction, you don't have guarantees that it'll actually get mined. Just kind of like an assumption we make based on the market dynamics. Yeah, when you can cancel the transaction from the user data cancellation, that's a good question. So we don't have a native concept of cancellation or timeouts or ordering or anything like that. The core protocol is kind of very unappinionated in that respect. But there are middlewares that you can opt into which can kind of introduce basically timeouts or cancellation semantics to messages, with the trade off being that you lose out on some composability because now applications need to understand that, hey, there's this header attached to messages which defines some timeout or whatever.
00:23:50.120 - 00:25:34.800, Speaker A: But yeah, that's a great question and something we honestly, I think, should think more about. So just to give a few examples of kind of like the developer primitives and tools that are available on top of this protocol for you guys to use that are maybe less intimidating than just this raw bytes pipe between chains, we have this warp route subtraction which should be familiar. It's like similar to traditional token bridging where you can basically just connect either canonical token or native token to a bunch of synthetics on a bunch of chains. Again, the kind of modularity of hyperlane allows you to evolve and configure the security of this warp route. So you could just as an example, which we've talked to with a lot of customers or like a lot of customers, are excited about this specific example of having application specific security. So if you're transferring on a warp route more than, let's say, 25% or 50% of all of the circulating supply on that chain, you might want some administrator in your application to actually function as a notary or veto or something, just to ensure that your application didn't get rugged by some bridge. And with the interchange security modules, you can totally do that really easily.
00:25:34.800 - 00:26:40.500, Speaker A: So you can have these different safety modes. We just actually sent the first token transfer between the Solana DevNet that I mentioned earlier and the EVM, so that's maybe something you can play around with this weekend. We also, like I said, have been expanding to other ecosystems. So if you guys are interested in kind of some of those longer tail ecosystems, definitely be happy to chat. But yeah, this is just one abstraction. We also have this concept of Interchange Accounts and Interchange queries, which again is like an API that as a developer you can use kind of simplifies some of this, like, cross chain control flow. So interchange accounts are basically a way for you to have a contract on one chain own assets or do actions atomically on another chain.
00:26:40.500 - 00:27:39.204, Speaker A: So, basically, if you're familiar with the concept of, like, a smart contract wallet, this is like smart contract wallet for your contract on another chain. Basically, your contract on the origin chain can send calls to be proxied by its interchain account on some other chain, and you can send assets to your interchain account. We think this is pretty useful, especially for Dows. If you want to give ownership to some Dow that exists on another chain, you can just do that counterfactually without the Dow even opting into it. You can just be like, hey, dao, I'm giving you this permission to your interchain account. Come and take me, or whatever. And so, yeah, this is kind of a powerful primitive for just managing assets on different chains.
00:27:39.204 - 00:28:39.244, Speaker A: You can do some sort of multi chain portfolio management type thing without actually bridging those assets, which is sometimes risky. And then the Interchange Queries API allows you to basically make cross chain view calls so you can go query a contract's function on some other chain. Some examples of using this have been, like, looking up ENS ownership or NFT ownership on Ethereum because there's a lot of, I guess, network effects on Ethereum l one. But people want to migrate their application ecosystems to other chains. So this is a way for you to kind of have remote views into other chains, state and networks. And that's it. I guess I'm almost at time.
00:28:39.244 - 00:29:04.044, Speaker A: Anyway, I can't really do the demo because my WiFi has been really struggling. But I would love you for you guys to check out our docs. We have a message. Explorer with an API. We have $10,000 in prizes this weekend. So big opportunity. If you just want to use one of these APIs, you could deploy hyperlane to one of these new chains.
00:29:04.044 - 00:29:27.930, Speaker A: You could try deploying hyperlane to Zora or Base or one of these new roll ups and have your application do something cool with that. I think we're also looking for people to use warp routes if you use one of these APIs interchange accounts, interchange queries, I'm sure that would qualify. Yeah, that's it. Thanks for coming.
