00:00:00.090 - 00:00:29.000, Speaker A: Workshop titled integrating Any Off Chain Data into Your Smart Contracts With Chainlink. Joining us today is Patrick Collins, developer advocate at Chainlink Labs, who will be taking us through the session. Just a quick reminder to everybody to stake their spot for ETH Online. If you're having any issues, don't hesitate to reach out to myself or anyone else on the ETH Global team. And with that, I'm going to pass it over to Patrick to introduce themselves and get the session started.
00:00:29.450 - 00:00:46.966, Speaker B: Awesome. Thank you so much for having me. Excited to be here. Let me go ahead and share my screen so we can get started. All right, cool. So, yeah, so thank you, everybody for being here. Really excited to be part of the ETH Online hackathon.
00:00:46.966 - 00:01:43.646, Speaker B: Really excited to be presenting and showing you a lot of the different things that you can do with chainlink and in your smart contracts. So before I go into anything, I just wanted to say we are really at kind of this doorstep right now, right? We have this exciting, incredible opportunity in front of us where the world of smart contracts are literally teetering on the brink of becoming this mainstream adoption. We've seen all this adoption from DeFi, we've seen all this adoption of blockchain technologies, and it's really going to be up to us to kind of push it into that next step, to push it into the next phase. And history will show who the pioneers are who push us into this fourth Industrial revolution. So it's not going to happen without projects and without events like this hackathon. So just really excited for everyone to be here, really excited to see what everyone's going to build. And yeah, with that, let's jump right into it.
00:01:43.646 - 00:02:32.218, Speaker B: So connecting your smart contracts to off chain data, APIs and traditional payments next. And we also have five prizes of $1,000 paid in link to the projects that use chainlink in the most interesting ways. And we'll go over what that actually means and what that's involved with right now. So in this presentation, we're going to talk about chainlink. We're going to go over the smart contract connectivity problem, how chainlink already supports the growth of the DeFi ecosystem, a lot of the untapped potential in the places that people haven't been building it, and we don't see mainstream adoption that's out there for us right now. And then we'll go over the tools and resources you have to build some of these smart contracts that are connected universally. We'll go over remix.
00:02:32.218 - 00:03:58.070, Speaker B: We'll also do a Truffle demo and we'll check out the price feeds and also being able to access any API. So with that, let's jump into it. As I was saying before, in order to really understand chainlink, we must first understand that smart contracts can't connect to external data or any off chain resource on their own, right? This is a huge limiting factor for smart contract adoption because it means the only thing that we can really do is token swaps, right? Now, this is nice, but it doesn't allow us to have these smart contracts to do these more interesting agreements and be this superior form of agreement because we don't have enough data. One of the main questions that gets asked is, okay, well, why can't blockchain just make an API call like every other programming language has an API call? And the answer to this is actually really important, really important to understanding the fundamentals of how blockchain works. So the blockchain is a deterministic system, right? Smart contracts run on these deterministic systems. And this is really important because every node needs to be able to validate what every other node is putting on Chain. So if we have a system where the validation process comes from APIs, one node is going to say, hey, the API returned seven, another node is going to say, the API returned eight.
00:03:58.070 - 00:04:47.490, Speaker B: Even if the API, well, that could happen if the API was changed half a second later, if it was hacked, depreciated, whatever. It's going to be basically nearly impossible to have this consensus, right? The blockchain is designed so that if you replayed it from the genesis block at zero all the way through, you're going to end up in the exact same state as you did if you replayed it at any time. So you always want to end up in the exact same state. So the deterministic system is really, really important. And so blockchains can't themselves make these API calls because of that. So to interact with the outside worlds, we need to use what's called an Oracle. So any device that interacts with the off chain world to provide data to smart contracts is called an Oracle.
00:04:47.490 - 00:05:26.740, Speaker B: They report that data on Chain so the blockchain can stay deterministic. And they do this in an external transaction. So the Oracle makes the external transaction, posts that data on chain. And now you have your data on chain to do whatever you want, your smart contract, which is really exciting. And this is actually where Chainlink comes in. So there are thousands of APIs out there that are already providing data that people need for their applications. So Chainlink makes it really easy to enable this connectivity between those APIs and your smart contracts, even if they require any authentication or passwords or any other bit to get them to actually work.
00:05:26.740 - 00:05:57.294, Speaker B: So that you can have these decentralized applications powered by the same reliable APIs that the rest of the world and current web applications are using today. And a single chainlink Oracle is also called a chainlink node. I'll be using that a little interchangeably here. An additional piece here is that a lot of users today still don't understand blockchain. And sending payments in cryptocurrencies isn't universally accepted. Yet. When a smart contract has executed, people need the ability to get paid in the currency that they want.
00:05:57.294 - 00:06:51.230, Speaker B: And chainlink makes it really easy for off chain payments to take place based off of on chain interactions. This also works for any cross chain communication and sending payments to other chains. So Chainlink uses something called external adapters and if we have time, we'll go into those a little bit too. And they use these external adapters to enable this connectivity to any resource. External adapters are basically the customizable functionality, the customizable piece of chainlink nodes that says if you're looking for some very specific data or you want to do some specific computation, you can just hook in an external adapter that can do pretty much whatever you want, right? So it can access APIs that require authentication. It can do some off chain computation for your smart contract. It's really the piece that makes the customizability of your smart contracts unlimited.
00:06:51.230 - 00:07:53.182, Speaker B: And basically the way that it works is it's a wrapper around APIs or the most popular way to do it is a wrapper around an API and it'll call that other API and then you can add any customized features to that as you like. And the great thing about external adapters too is they can be written in any language, so you don't need to know anything about solidity or even ethereum to get them to work. Now here's where we turn up the heat a little bit more. So a centralized Oracle or a centralized data point becomes a single point of failure for your entire smart contract. And this is actually why we create decentralized Oracles and decentralized networks. If you have your data rely on a single point of failure, your smart contract is now kind of no better than a regular traditional agreement, right? The reason that these smart contracts are so interesting is we can make them decentralized. Well, there's a couple other reasons, but that's one of the big reasons.
00:07:53.182 - 00:08:41.134, Speaker B: And if we add this centralized data point or this centralized Oracle, now we have to trust that they're going to do the right thing. And you basically remove any and all decentrality your smart contract has. So it's not that much better than a traditional or regular contract. So we need to avoid this at all costs and have a network of decentralized Oracles. And this is an important piece to dwell on too, because saying a chainlink node by itself is decentralized is sort of like calling a single tree a forest, right? That doesn't really make that much sense. One single entity doesn't make up the whole to make applications that are truly never need to rely on one entity, be it a company, landlord, government, or anything of the sort. We need this network of chainlink nodes or this network of chainlink Oracles.
00:08:41.134 - 00:09:13.306, Speaker B: And the reason why I'm stressing this so much is it's not some hypothetical situation. We've seen attacks that have lost projects, a lot of money and a lot of livelihood, and a lot of tears shed over some of these hacks. The Oracles that they were using were even malicious. They were just hijacked or flash crashed and they lost. And smart contracts, they don't care. They just execute whenever the data says execute, whenever the code says execute. And that's one of the beautiful things about smart contracts.
00:09:13.306 - 00:10:09.440, Speaker B: But that's also why it's so crucial to have data from a reliable, decentralized network, like a chainlink network. So chainlink is designed to be this modular infrastructure though. So you can build your own networks and you can build your own customization to do whatever you want. You can build your own decentralized networks to use to connect your smart contracts to any API. You can select as many Oracles or Chainlink nodes as you like and use as many data sources as you like in order to trigger the execution of your smart contracts. And then again, because the external adapters are so flexible and you can make them do whatever you want, one of the big benefits is you can use them to build these off chain payments to occur based off the execution of a smart contract. So for example, if the result of a smart contract says that Bob needs to be paid $100, you can use a chainlink external adapter to send that transaction as well.
00:10:09.440 - 00:11:27.640, Speaker B: Now, to get started with DFI, the chainlink project has actually already gone ahead and found many of the best blockchain node operators on the planet and combined their prowess to build what's called price feeds. These are decentralized on chain reference points that can be considered source of truth for various currency pairs, like the price of ETH in terms of USD for example. So here's a little visualization of exactly what that looks like. You can see surrounding this price in the middle being 196 there, that's the aggregate of all these nodes individually grabbing data off chain, reporting it on chain and then on chain, that data being aggregated to this decentralized value. So now you have this decentralized price feed and you know that your smart contract is going to be reliable and secure because you have this provably, powerful decentralized price feed. And even if it relies on the same fundamental concepts that makes blockchain work, right, if a couple of the nodes go down, nobody cares because it's this decentralized network making it much harder to hack, much harder to attack, and much more robust. And again, if you want to make your own network, you absolutely can.
00:11:27.640 - 00:12:24.422, Speaker B: So these price feeds though, are being used by a ton of the top projects in the DeFi world. And their proven safety, reliability and power of these applications is a testament to the power of these chainlink price feeds, right? We've seen across all of know synthetics assets, lending and borrowing, trading, asset management, we've seen a ton of adoption because of how powerful and how reliable that they are. Right now, I think it's actually 35 price feeds are now live. I could be wrong. And many of these D Five products are using price feeds for securing their critical infrastructures. And so here's kind of a snapshot of DeFi Pulse a couple of weeks ago, and DeFi Pulse changes so quickly. But DeFi Pulse is a website where you can see how much in assets under management is locked into different platforms.
00:12:24.422 - 00:13:06.310, Speaker B: And so here was a snapshot of the top five and three of them ave, Synthetics and Yearn Finance are using chain link price feeds to secure their platforms. And if you look, you can see locked USD Ave 1.5 billion, synthetics 859,000,000, year no finance 820,000,000. There's literally billions of dollars being secured by chain link price feed. So this is just a testament to how powerful they are and how much adoption that they're seeing. So we're seeing more and more of these D Five projects using the price feed because they're so powerful, because they're so reliable, and because they're so easy to integrate as well. We'll see that in a bit.
00:13:06.310 - 00:13:49.794, Speaker B: So here's just another snapshot of some of these projects. Synthetics, actually it's bumped up to 900 million, loop ring 20 million, set protocol 20 million, ave 1.5 billion. And they might even be more now. So just a testament to how powerful these price feeds are. So in addition to being able to access any API, grab these decentralized network of price feeds, chainlink also has this method for getting reliable provably random numbers. And until now, getting random numbers on Chain has been actually an issue since the conventional way to get a random number, you have to rely on the ETH miners for a random hash or some type of centralized API that can be hacked.
00:13:49.794 - 00:14:46.626, Speaker B: Miners actually, when they produce a block, they have the choice of whether or not they want to produce a block. And if your random number is dependent on their block hash, if you're doing like a lottery or something, and their block hash would result in them not winning the lottery, they are now highly incentivized to not publish that block. So you've now created this unfair system where the miners actually can control who wins these random numbers that you're making. So you absolutely do not want to have your production systems depend on the block hash for your random numbers. So Chainlink actually has a decentralized provably random system for getting these random numbers, and the service on these has barely been scratched. We're seeing more and more people looking to use these chain link VRFs. At the last chain link hackathon we saw about twelve projects implement these chain link VRFs because they're so easy to use and they're so powerful.
00:14:46.626 - 00:15:30.934, Speaker B: And it's fantastic to have your projects have provably verifiably random numbers, which is fantastic. So we're seeing more and more adoption here as well. Just one note, the chainlink VRF is on its final round of the security audit. So at the moment the Docs only have the testnet versions but you can stay up to date by going to the developer communications piece and we'll get to that in just a second. It looks like there's a chat feature here. I'm actually going to stop in a minute and look at questions. So anyways, this brings me to our next point.
00:15:30.934 - 00:15:53.966, Speaker B: We have a blog that goes over a list of ideas to power your smart contract. So if you're at this hackathon and you're racking your brain, you haven't been able to brainstorm anything yet. I think there was a brainstorming session yesterday. And if you're looking for some other ideas, definitely check out this blog. It's got some great pieces for you to look at, but I'll just kind of quickly rip through some of my favorite ones. DFI. Decentralized finance is huge.
00:15:53.966 - 00:16:12.174, Speaker B: The market is massive, right? So right now DFI is what, $10 billion. It changes every day. I can't keep track. But traditional finance, I think it's 100 trillion. These are also some massive numbers. Asset or hedge funds in general have a market cap of about 3.2 trillion.
00:16:12.174 - 00:17:08.600, Speaker B: So there's a ton of space, there's a ton of markets we made up here to help people build and lock their assets in this decentralized finance platform where they don't have to rely on these centralized traditional financial institutions. So DeFi is huge. Fantasy sports or any type of gaming VRF makes a lot of this gaming stuff really easy. And accessing sports data off chain is really easy because you can access any API. And both of these examples are still way cheaper on chain because you don't have to pay these massive fees with a ton of overhead to run these projects. Tokenized assets, you can split up your car plots of land, shares of stock, making it really easy to keep track of who owns what without having to deal with any of the paperwork. And since your data is coming from decentralized Oracles, you know that nobody can actually mess it up.
00:17:08.600 - 00:18:05.430, Speaker B: And then the last one here is insurance. We're seeing more and more projects looking to tackle this in different ways in really, really creative ways. And this one to me is kind of one of the magical pieces that really show us how powerful smart contracts are. Let's say your crops are all messed up due to the weather and your insurance doesn't want to pay out because of some preexisting condition or some loophole that they find right in these traditional agreements, they're incentivized to find these loopholes and they're incentivized to figure out ways to not pay out. But with a decentralized smart contract, since they don't own the agreement, they don't have a choice. The code automatically executes and they have to pay out. So to me, this is one of the most powerful examples of why smart contracts and why chainlink is so powerful.
00:18:05.430 - 00:19:08.914, Speaker B: Because with these decentralized smart contracts, you don't have to trust that the insurance company is going to do the correct thing, because the correct thing is infrastructural with chainlink. So I hope that inspired us to kind of start thinking a lot about the different pieces that chainlink has and that smart contract has and get you really excited for this hackathon. Because honestly, these are the stomping grounds of innovation, these are the stomping grounds of creativity and pioneering this fourth industrial revolution here. So with that, I will jump into some of the questions here and then we're going to go into the technical demo of using chainlink and how to use chainlink and get that data, get that crucial decentralized data into your smart contract. So let me just look through these questions right here real quick. It how is that determined? I need a little bit more flesh that question out a little bit. The insurance payout.
00:19:08.914 - 00:19:57.020, Speaker B: Oh, so that would be depending on, honestly, whatever the contract says. So the question is, how is the insurance payout determined? And the answer is, well, it depends on how you write the smart contract. That's really it. So if your data says, hey, if the weather strikes twice, or if it's super rainy over 30 days, or it's super hot where there's not rainy, or whatever your insurance policy is, pay Farmer John $1,000, you would be the one to figure that out. And then your smart contract would get data from the decentralized network of chainlink Oracles. It would get that weather data into the insurance contract. So to answer your question, it's whatever your policy is, whatever you decide your policy to be.
00:19:57.020 - 00:20:10.000, Speaker B: Is this aggregation similar to what is done in Coin Market Cap? I'm not sure what Coin Market cap is doing. And that looks like that's the questions for now.
00:20:10.450 - 00:20:27.800, Speaker A: I have one question from YouTube that I'm just going to quickly post in the chat and I can read out for you. You mentioned data coming from decentralized Oracles serving many purposes and from many domains. Besides price feeds, what other types of feeds are available?
00:20:30.490 - 00:20:53.310, Speaker B: Good question. So right now, price feeds are the most popular ones and they're the ones that are mainly in here. You can create a price feed for any type of data though. Like for example, weather data. You could absolutely create a price feed for weather data. There is a couple of non price feed ones, although they're still price feed. There's like fast gas.
00:20:53.310 - 00:21:44.382, Speaker B: This is like the current fast gas speed for ethereum. I think right now most of them are price feeds, but you could create your own price feed for literally any type of data, create your own network of any type of data as well. Something important to note too, going production with centralized Oracles absolutely never do. However, for just developing, if you just want to work with one Oracle, one API, that's more than fine. Just to get your minimum viable product up to speed, just to get your project working, that's more than fine. But for going main net and for going live, you absolutely don't want to do that, but good question. All right, cool.
00:21:44.382 - 00:22:31.814, Speaker B: And with that, I'm going to unless there's one other question. Can connectors be developed? Like connectors to databases? I'm not sure I fully understand the question if we're talking about connecting be developed connectors to data. I mean, if the question here is can you connect a smart contract to a database? The answer is absolutely the external adapters. Oh, okay, perfect. Yeah, the answer is absolutely. APIs are the way the traditional web works to connect things, to connect your back end to your front end, to connect any piece of software with another external piece. If you make an API for your database, you can just pop that in your smart contract.
00:22:31.814 - 00:23:04.934, Speaker B: If it's a little bit more intense, you can just write a quick external adapter to wrap around. We have a ton of blogs and docs on making those as well. So, yes, you can absolutely connect your smart contract to a database. Good question. All right, cool. And with that, we're actually going to jump into an example here. So I want to start with the docs because the docs is really like I mean, when I'm building chainlink smart contracts, it's really where I live because it's really easy just to go into the docs and grab everything you need.
00:23:04.934 - 00:23:56.582, Speaker B: So if we want to see how these price feeds work, you can go to the introduction to Price Feeds part, read a little bit more about it here. But we can go into this get latest price feeds and then we have our code for like Truffle or build alert right here. And then we also have this link that allows us to pop right into Remix. So for those of you who are familiar and I have it super zoomed in, which is probably good for those who are familiar with Remix, it's a web IDE allowing us to grab, deploy and see visually how a lot of these smart contracts can work. So me clicking that link just popped this one in. I have a bunch of other stuff because I've been playing around in Remix for a little bit. But yeah, pressing this button pops up Remix here and it has all of the code for a smart contract right here.
00:23:56.582 - 00:24:28.734, Speaker B: So there's some comments to help you kind of figure it out. But basically what it's doing is it imports this aggregator interface sol from the chain link GitHub. And just an important thing to note if you're working with Truffle or Buildler, you can't import through GitHub itself. You got to use this kind of NPM package syntax. But it works for Remix, though. But anyway, so we have our contract, we're calling it Price consumer v three. We create this instance of the aggregator v interface.
00:24:28.734 - 00:25:00.060, Speaker B: We call it price feed. We grab the address of the aggregator v interface. This is the address of your price feed. And you can find this as well in this price feed contracts right here. You hit that, we can see all the different price feeds, addresses for all the different networks. So we're going to be working on COVID and we're going to look for East USD. And it even pre populates with this, unless we're looking at something else.
00:25:00.060 - 00:25:31.394, Speaker B: ETH USD. Did I grab the right one? Whoopsie. I had the right one in here originally. Nice. So ETH USD and what we do is we get the latest price and it's just a view function, right. So you don't even have to make a transaction to do this. View functions are just looking at the data, looking at data in a smart contract.
00:25:31.394 - 00:25:50.262, Speaker B: So and it returns this tuple. We're interested in the price. So we're going to return the price and we're going to set oh yeah. And since this is a view function, it'll pop up right below. So we compile it. We're going to switch to injector web3. MetaMask is going to pop up.
00:25:50.262 - 00:26:18.422, Speaker B: Can you guys see that? This is my fake account. What is my fake password? I did it right. Okay, so MetaMask is going to pop up. We deploy it. Great. We can see can you guys see when MetaMask pops up or no? Does that show up in a different window? Might show up in a different window, that's fine. But we can see the transaction here.
00:26:18.422 - 00:26:51.274, Speaker B: The transaction is successful. And again, this is looking at that feeds chain link. So this is going to look at this ETH USD price feed. And again, you can check this page out too. It has a ton of interesting data, like the deviation thresholds, how often they're updated, and the individual responses from the individual nodes, which are really cool. And you can click on them and learn more about them there as well. We're back in remix.
00:26:51.274 - 00:27:13.414, Speaker B: So here is our contract. And yeah, as we can see, it's just a view function. We click it, we see the price. ETH USD here. Why is the number so massive, you might ask? It's because decimals don't work great in solidity blockchains. Don't work with decimals here. So we can see the price of ethereum is $357.
00:27:13.414 - 00:27:36.560, Speaker B: How am I doing in time? I'm doing really well. Okay, great. Any questions about price fees? And yeah, it's literally that easy. Like any address that you want, you swap it out here and then you grab the get latest price function and you're welcome to work with it there. Yes, it pops up. Oh, awesome. Thank you.
00:27:36.560 - 00:28:19.340, Speaker B: Any other questions here's? Easy to implement. Truffle brings it up with methods. Yeah, Truffle. I will be doing a Truffle demo in a little bit. How are new nodes added to a price feed? You can check out the docs to learn a little bit more about that as well. And you can also build your own price feeds so you can do whatever you want to do. Cool.
00:28:19.340 - 00:29:07.494, Speaker B: So let's move on to accessing any API. And then again, if you want to learn anything about randomness, everything is right here. To learn about randomness, let's do access any API. So this is going to be the code where you can put in any API. For example, this one, this is just a crypto compare API call, which oh, did they change? Oh, right. We changed this to get a ton of data from here, right? So you can get the volume, get the price, whatever you want. And we're actually going to be looking at the volume of ETH USD, so we're going to call that API.
00:29:07.494 - 00:29:25.986, Speaker B: Let's look at it in remix. Let's leave this one. I probably didn't need to API consumer. Yep. So here's the code. And let me even try to stretch it out a little bit here so we can see a little bit more. And it's the same format just with one extra piece.
00:29:25.986 - 00:30:04.350, Speaker B: So we're importing our chain link client. Our main contract is inheriting chainlink client. We have some global variables here, and I'm actually going to skip the constructor for now. But let's talk about this request volume data method here. So the first thing that we need to do to make a chain link request and this is actually exactly what the price feeds are doing, just with multiple API calls. So this is kind of breaking down the price feeds a little bit here. This is how you can call any API.
00:30:04.350 - 00:30:49.734, Speaker B: And then if you wanted to build your own price feed, for example, you would just do this multiple times and then aggregate it on chain. So first thing we need to do is build this chainlink request object, right? And so in this chainlink request object, we call this build chainlink request function. And then you can see in this function, we're actually not adding any parameters. When you're doing a production project with a lot of these different Oracles, it's usually good to add like job ID. What is job ID? Bytes 32. Bytes 32. Job ID oops address Oracle, maybe string memory, URL, et cetera.
00:30:49.734 - 00:31:34.662, Speaker B: So you can call this for many Oracles and many different URLs and different paths and stuff. So you can call this many times without having to write a new function per node. But yeah, so we build this chainlink request object, and we just pass it the job ID, which I'll talk about in a second, the address that we want to get the data to come back to, which is this smart contract. And then we define the fulfillment function, which is actually defined down low. So what we're doing here is we're saying, okay, this is the job ID that I want. This is the smart contract that I want to return to. So we're actually choosing specific Oracles.
00:31:34.662 - 00:32:18.694, Speaker B: And then even below, when we send it, send chainlink requests, we choose the. Oracle that we want to send it to. So when we make these calls, we're actually choosing the Oracles and we're choosing the jobs associated with them. So the question then becomes, okay, well, how do I choose jobs? How do I choose Oracles? You use what's called a node listing service. Something like Market Link is an example of that. You can look for like a get job that returns a get UN 256 for jobs. We see a whole bunch of jobs here, right? So this is on main net.
00:32:18.694 - 00:33:10.070, Speaker B: We would probably want to go to COVID. But these are all jobs. These are all jobs from different Oracles that actually return a uint 256, return a U in 256. And we can learn more about them and we can grab like, their job ID and the it's a little below here and the Oracle address. And that's the way we specify this job, right? So if you want to grab, if you want to get like a boolean, there's different jobs that do that. Or if you want to get like bytes 32 or you want to do a post. What if I just do post? You can get lost in here a little bit looking at all the different types of data that these return.
00:33:10.070 - 00:33:48.694, Speaker B: Now, these are some of the more generic ones, but we can look at some more interesting ones. So this is a job that returns data from Alpha Vantage. This is a job that returns data from a Stormglass API. So you can kind of browse through this and see not only are these generic ones, but there are these more interesting ones like this best Liquidity pool. And if you want to build your own adapter, build your own job, you can absolutely add it in here yourself. And we can see if we go through adapters, these are these customizable functions that people have actually built and added it here on Market Link and you can kind of browse through. Oh, this is really cool.
00:33:48.694 - 00:34:11.054, Speaker B: I think this one must be new. This is a really powerful JavaScript Python cryptocurrency exchange package. That's really cool. But yeah, so IOST external adapter. Oh, that's fantastic. So there's more and more of these being added to do all these customizable functions. But yeah, so you grab one of those.
00:34:11.054 - 00:34:32.274, Speaker B: I got lost a little bit. You grab one of those, you grab its job ID and you put it in here. And again, the job ID is going to be associated with the type of data that it returns. You say, this is the smart contract, I want the data to be returned to. And this is the fulfillment function. The fulfillment function. The fulfillment function describes what to do once you have that data.
00:34:32.274 - 00:35:18.914, Speaker B: So we're not going to do anything interesting here in our fulfillment function. This is kind of the boilerplate for what they're going to look like. We're just going to set our volume variable to the volume that we get from our request. So we're not going to do anything really interesting here, but you can put in there whatever you want to say, hey, once I get the data back, here's what I would like to do. So anyways, once you create your request, then what you're going to do is you're going to start adding your adapters. And this is also where you could add your external adapter. These are the pieces where it says, okay, once we kick off and we get this data, here's what I would like you to do with it.
00:35:18.914 - 00:36:07.860, Speaker B: So this job ID that we've specified up here. Oh yeah, we already specified an Oracle and a Job ID here. This job ID that we specified, it's just a really simple Http get request. That's what this job ID is going to do. However, the parameters are left open for us to input the URL and everything that we want. So we do this request add, we add the Get adapter, the Http get adapter, and then we add the URL string here. And then again, if you want to learn about more adapters, which ones you can use and how to use them down here, we can go to adapters and all the information is here with examples on how to build them, how to use them.
00:36:07.860 - 00:36:41.854, Speaker B: Everything you need to know is in there. So we're going to add that adapter in here. Then we're going to add the path. So the path is just the and then actually is that API call? Yes, it is. So the path is going to be the JSON key path to get to the value that you want, right? So we don't want to grab this huge, massive piece of data in our smart contract. It's going to cost a lot of gas and it's a really big object. So we only want this Raw ETH USD volume, 24 hours.
00:36:41.854 - 00:37:06.562, Speaker B: So if we go in here, the first key is Raw ETH USD volume volume 24 hours. So we're looking to get this value here. So that's what path does. It gets the path in the JSON object. And then we are going to multiply as well by this times amount. And there's an adapter for multiplying. It's called times.
00:37:06.562 - 00:37:35.694, Speaker B: So we're going to multiply it by this big number. And again, the reason for this is because decimals don't work so great and we want to shift this decimal over. Then we send the chain link request and this is where we actually input the Oracle address that we want to use. We add the request and we add the link fee. This is like the Oracle gas fee. You can find that also on market link for most of them. Right now, it's 0.1
00:37:35.694 - 00:38:20.186, Speaker B: link for the Oracle gas, for the chain link gas fee. So we send it, then it comes back and fill. Let's actually go compile this and let's make a call. Again, this is on the COVID network here. So injector web3 deploy, deploying this contract here. We'll give it just a second to finish populating and it looks like it's here. So now I'm going to intentionally do something to get an error because in the beginning you'll probably run in this error a lot.
00:38:20.186 - 00:38:47.314, Speaker B: So I'm going to request the volume and we're going to see this gas estimation failed. The reason for this, again, is because we need the chain link gas. We need the Oracle gas added to our smart contract. So we actually have to fund it with link. So we copied the paste excuse me, we copied the address there and let's just send it three for overkill. So we're sending our smart contract three link. We're funding it with Link so it can interact with these chain link Oracles.
00:38:47.314 - 00:39:24.190, Speaker B: It can interact with these off chain Oracles. So we funded it with Link. Now when we call this request volume data, which again is the function right here, now it's actually going to pop up because it's requested, because it's funded with Link, we can actually confirm and this is going to kick off our request to that smart contract. So this is the smart contract here. We can see it's funded with Link. We can see this is the contract creation 1 minute ago. And we just sent this request.
00:39:24.190 - 00:40:12.522, Speaker B: And this is Ether scan, by the way. This is a popular block Explorer for those of you who are new, and it looks like it just about finished. So something important note. If we hit this, never mind, it already responded. But when you hit it, when you hit this volume button and when you kick off this request volume data function, you won't actually get an immediate response. And the reason for that is, when we make this request, we actually are emitting an event on chain that the Oracle that we specified is looking for. So the Oracle sees this event, grabs the parameters of what you're looking for, goes and grabs the API itself, and then in an external transaction posts that data back on chain.
00:40:12.522 - 00:41:02.240, Speaker B: So it actually has a second transaction that the chain link Oracle itself does to give you that. So it looks like it went really fast here, but we can see that volume data here. And again it's multiplied to push over the decimals. Those are the main features. Two of the big features, those price seeds access any API, you'll see that the chainlink VRF has the same request and receive structure where you send a request to get the random number, then you receive the random number from the Oracle responding. So I'm going to pause for a second to look at some questions in the chat and then yeah, Emily, I'm not on YouTube right now. If there's a couple of YouTube questions, I'm more than happy to answer some of those.
00:41:02.240 - 00:41:44.974, Speaker B: So, from Derek, can we add our ERC 20 and create a link to market. I'm not sure what this question means. You can absolutely create your own ERC 20s. Yeah, you can absolutely do that. If you want to flush that question out and ask again, happy to answer it here. Will you show how we do a bridge to banks and Visa to pay starting from internal amounts of tokens or cryptos? So I won't go over that, but if you look, we have a number of these external adapter blog, chain link, and then if we Google, it should be the first time pops up. Yeah.
00:41:44.974 - 00:42:15.362, Speaker B: We even have a video on doing it. But external adapters are going to be what you're looking for here, and this is going to be that easy functionality to interact with your bank or your Visa or there's a PayPal, external adapter, whatever you want to do. These payments starting from internal amounts of tokens or cryptos. Yeah. So external adapters are what you're going to look at to do what I think you're trying to do there. Question from YouTube. Did I see that correctly? Use continuations in solidity.
00:42:15.362 - 00:42:56.958, Speaker B: That means you have Asynchronous control flow. Yeah, actually, pretty much. As far as the control flow terminology, I'm not exactly 100% on it, but yeah. So you can think of this as an Asynchronous architecture because we make that call and you can almost think of almost I'm using this very loosely. You can almost think of this fulfill function as, like an await, right? Like super, super loosely, because we need to wait for the Oracle to make the external transaction back. So every single transaction on the Ethereum chain is done synchronously in ETH 1.0 and E 2.0,
00:42:56.958 - 00:43:20.474, Speaker B: this will change. Everything is done synchronously. However, we can do it asynchronously by sending these requests off chain. So that is a great question. You did see that correctly. And yes, this is an example of, like, an Asynchronous control flow. Do contracts need to hold link in order to request jobs from the Oracles or can the feed be paid in ink? Nice.
00:43:20.474 - 00:43:27.870, Speaker B: That answered the question. Yeah. So it's link. Thanks for the link to the banks. Yep, absolutely. So, yeah. So those are really good questions.
00:43:27.870 - 00:44:39.160, Speaker B: So you saw on the price feed that that one didn't actually need to get funded with link. And again, the reason for this is because those contracts, they already made the request. Somebody else made the request already, and it's just on chain for you to see. So you can think of the price feeds almost as just this volume button right here, right, without you having to make the request yourself. What happens if there is an error on the Oracle and the fulfill is never called back? Well, that is a fantastic question. What happens if there is an error on the Oracle? I kind of want somebody else to answer because I feel like hopefully at this point, I have drilled a concept about the importance of something. So what happens if everyone's brave enough to venture and answer here? How do we protect ourselves against Oracles not responding? How do we protect ourselves against Oracles giving bad data or inaccurate data or no data? What do we do?
00:44:43.370 - 00:44:47.000, Speaker A: I'm looking to unmute yourself and answer the question.
00:44:48.010 - 00:44:49.000, Speaker B: What's that?
00:44:50.490 - 00:44:57.530, Speaker A: What was just I was just saying the hackers can also unmute themselves and answer if they feel comfortable.
00:44:58.110 - 00:45:28.834, Speaker B: Well, Andre actually got it here yeah. By using multiple oracles. So that's exactly right, Andre. Yeah. Thank you for posting. Decentrality is going to be the answer to a lot of these questions, right? The reason that blockchain works is decentralized nodes, right? And it's the same thing for chainlink. If one or five of these go down or eleven of them go down, or excuse me, ten of them go down, nobody cares.
00:45:28.834 - 00:46:12.194, Speaker B: It's fine. Well, okay. People care. And you're probably going to want to use different nodes moving forward, but the network will continue strong and securely. So this is why when you're developing, using one node is fine, but in a production environment, you absolutely do not want to use one node for that exact reason. What happens if there's an error on the Oracle? So, really good question. Any other questions before I move to the Truffle example? All right, cool.
00:46:12.194 - 00:46:32.490, Speaker B: I'm going to move on. These are good questions so far, team. Keep it up. Really excited to see what you guys build. Sounds like you guys are really getting it here. So let me switch screens. So Remix is a great tool for kind of easily seeing contracts visually.
00:46:32.490 - 00:47:24.890, Speaker B: However, when it comes to testing and maybe having your development environment a little bit more similar, there's a lot of really popular tools that you can use, like Truffle, like buildler to do it in like a Vs code or whatever text editor that you want. So Truffle is a really popular one. You can install it with I think it's NPM install. I think it's this. I'm not going to do it because I've already installed it. But once you have it installed, you can absolutely add actually, let me flip back over to the docs real quick. Switch back? Yeah, you can add these smart contract pieces with NPM or Yarn.
00:47:24.890 - 00:48:16.490, Speaker B: And then what we're going to do actually is we're going to build our own is we're going to pull a smart contract kit box, which is a Truffle box, which is a really easy way to start up a project using Truffle. So it has just a lot of boilerplate code. And we do that with Truffle unbox smart contract kitbox. And what this will do is it'll download and install. It'll download all this kind of boilerplate code into our development environment here. So we're just going to give it a second, and while it actually populates here, we're going to flip back and we can even go. And this is an open source box.
00:48:16.490 - 00:48:43.454, Speaker B: So if anybody wants to look at this or make a PR or update it to something else, all the code is right here. The docs are here. The README is here. All the commands that we're going to run are here. There's also a blog on this, so we absolutely can do all that. Let's flip back now to run this. And I'm just going to do this in another terminal while that still unboxes.
00:48:43.454 - 00:49:45.410, Speaker B: There are two environment variables that we need in order to make this work. We need mnemonic and we need RPC URL. So your mnemonic is going to be the mnemonic phrase of your wallet. So this is going to be you can put it in like a bash profile or something, but you can also do export mnemonic equals blah blah blah blah blah blah, whatever, right? And that's going to be how our smart contracts know to deploy from those addresses. And then the RPC URL is going to be your ethereum node that you connect with. You can find these from Infura or other node operating services really easily. And this will be just like WW dot HTPs WW dot infura coven or whatever testnet you're going to be on IO, blah, blah, blah, blah blah.
00:49:45.410 - 00:50:09.726, Speaker B: So you can find those on Infuria. You're going to export both of those. You're going to set those as your environment variables so that your code can actually work. Great. Our stuff is unboxed. Looks like the code feature is a little weird here. Oh, wait.
00:50:09.726 - 00:50:41.946, Speaker B: Oh no, it's already open. Okay, got it. We have all this boilerplate unpacked into here. So we have a really simple contract in here. This is where all our contracts are going to be. This is doing the exact same thing that Remix is doing, just a little bit more in depth. So instead of calling that volume data, we just have this crate request two, which actually just has all the parameters, or a whole bunch of parameters in here that we can call.
00:50:41.946 - 00:51:16.242, Speaker B: So this one's a lot more customizable, but it's doing the same thing. It's making the request here, it's adding the adapters here and then it's sending the chain link request. And then again we have a fulfill function below. So it just has all the same boilerplate pieces, just a little bit more in depth. Migrations is going to be how to actually deploy. And anytime you add a new contract, you got to define how you want to deploy it. This makes it really nice because especially when you have a lot of smart contracts that you want to deploy, you can define everything here.
00:51:16.242 - 00:51:49.294, Speaker B: Node modules or node modules. Some interesting helper scripts. Let's actually look at a simpler one for now. Like for example, read data. So this is going to be an easy way to read the data off of your contract and then some other some testing which is really important and the README, et cetera. So to compile these contracts, because this is really what we care about, we can run Truffle compile and it all gets compiled. And the version that we're going to use is 0.6.6,
00:51:49.294 - 00:52:16.994, Speaker B: which is in this Truffle config here. And this is where you're going to define the different networks that you want to use. And I have nine minutes left. Okay, cool. This is actually where it's grabbing the Mnemonic and the RPC URL from your environment variable. So now we can do some more interesting things. So we can migrate them or deploy them with this Truffle migrate command.
00:52:16.994 - 00:52:53.330, Speaker B: But we also want to choose the network. It actually defaults to our dev environment, which is like a local ganache. We actually want to run it on Coven. My RPC URL right now is pointing to a Coven network. So I'm going to do truffle, migrate, network, live. It's actually going to migrate this. It's going to deploy this contract on chain, and we can see the transaction hash the account, which is my test account here, and then the contract address of this newly deployed smart contract.
00:52:53.330 - 00:53:26.430, Speaker B: So it's actually deploying two. It's deploying this migrations contract that we need, but it's also deploying my contract, which is the interesting one that makes this API call. Cool. So once it's deployed, we need to kind of follow that same procedure we followed in Remix. So we actually have some helper. Scripts, fund read request to do all this for us. If you want, you can go on like Etherscan, grab the address or pop up grab the address going to Truffle console, which you can learn more about that in Truffle docs.
00:53:26.430 - 00:54:09.050, Speaker B: But yeah, so we want to fund it. And I'm actually going to adjust this, be a little bit more liberal if we want to make more calls to, let's just say three link so we can run these scripts with this command, Truffle exec. This is saying, hey, execute these commands through Truffle. We're going to do Scripts fundcontract JS, and then we're going to do Network Live. And so this is going to be the same thing. So we're going to be funding our contract with three link here. And we can even see go to Etherscan.
00:54:09.050 - 00:54:33.246, Speaker B: Let me switch to ether scan. Coven. We put our contract in here. We can see it was just created a minute ago through Truffle. We just funded it. So it should let's find our hash. Yeah, it's funded now.
00:54:33.246 - 00:55:15.698, Speaker B: It should be funded with three link, which so perfect. And we can flip back over here. Clear now is request data. And this one's where all these parameters are actually lying. I'm going to show you again by flipping back to here real quick. We want to make a get request on Coven so we could go on market link search, know Get request. Let's just grab this Oracle and you can't see it.
00:55:15.698 - 00:56:09.038, Speaker B: But I'm popping these addresses into my Vs code, the Job ID and we're going to share back over here to the Vs code. So I just added the Oracle address and the job ID. In here we have the URL that we want to use, the fee that we're going to pay the node, the path, the time. So this is literally the exact same pieces that we saw in Remix. And then we call me with this code right here. So believe I saved that. So now I can do Truffle exec scripts and then hopefully I copy pasted the Oracle address correctly scripts request data network live and now we're creating a request on this contract.
00:56:09.038 - 00:57:25.594, Speaker B: It's the exact same thing as Remix. So believe this is the hash here and it is and we can see Ether scan is populating this request so it's been successful and again if we try to read from it right away, it won't actually be able to because we need to give it a second for the chanic node to actually respond. Now we're back here and we can do this read contract, which is probably the simplest one, shuffle, exec, read contract, network live and hopefully I'm not doing this too quickly, but we should get the response here and yes, we get the response 357.32, which again we multiplied by 100. So the decimal place is two parts over. So that's how you can work with Chainlink and Truffle. An easy way to get started if you're looking for other places to how other people are doing it.
00:57:25.594 - 00:58:13.062, Speaker B: We have a ton of blogs that show you how to build some of these things and each of them have the repos in here with all the code that you can fork. You can do whatever you want. The blogs development page is a great place to grab coding, tutorials and other projects. And if you look into the chainlink docs you can even see example projects from winning hackathons. You can go into their GitHub, you can see kind of all the code that they made. If you're looking for some more inspiration on how to use chainlink and how other projects use chainlink and how some winning projects use chainlink. So the Chainlink hackathon projects will go in here very shortly, releasing that on Friday.
00:58:13.062 - 00:58:29.280, Speaker B: But yeah, that's going to be pretty much it for the tutorial here and for the getting started to using chainlink. I know we only have a couple of minutes left but happy to take any other questions.
00:58:43.830 - 00:59:17.390, Speaker A: Feel free to unmute yourselves if you have any questions for Patrick. Otherwise you can also reach out to him in the chain link sponsor discord channel with questions and queries on anything. Okay, cool. Thanks so much Patrick, that was really great. And thank you everybody for joining. As I mentioned, you can reach the chainlink team in the discord and yeah, we are really excited to kick off ETH Online this Friday.
00:59:18.050 - 00:59:31.420, Speaker B: Awesome. Thank you so much for having me. Emily and thank you, everybody. And, like, you know, we're in the discord, so if you have questions, feel free to jump in there and really excited to see what you guys build. Cool.
