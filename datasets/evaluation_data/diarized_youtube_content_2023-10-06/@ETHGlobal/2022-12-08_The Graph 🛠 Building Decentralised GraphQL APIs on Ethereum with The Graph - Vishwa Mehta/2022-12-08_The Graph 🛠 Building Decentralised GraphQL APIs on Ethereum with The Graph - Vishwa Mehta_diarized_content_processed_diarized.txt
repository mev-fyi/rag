00:00:06.170 - 00:00:42.042, Speaker A: You folks are so patient. I'm super grateful for patient audience always because, like, you never know what goes wrong with like, demos and the demo gods are not happy with me, like, ever. So I think that's what happened today. But we're going to make do with what we have. Super excited to be presenting here in my home country. Global hackathons have always been super close to my heart because I started in the beginning of this year in a new space with my passion for GraphQL. And I think that's what I'm bringing to the table for you folks today.
00:00:42.042 - 00:01:08.370, Speaker A: So we're going to be learning how to build decentralized GraphQL APIs using the graph. So a quick show of hands before I give my introduction or go into the specifics of it. How many people here know GraphQL or have heard about GraphQL? That's a good number. I'm impressed. How many people know about the graph. Awesome. We could work with awesome.
00:01:08.370 - 00:02:07.542, Speaker A: Awesome. So today we're going to be learning how to build a Zora NFT Smart contract, an API for the Zora NFT Smart contract using the graph. But before we jump into that hi, I am Vish, short for Vishwamehta, and I am a developer relations engineer at the Graph Foundation. And this is what I do. I am super passionate about developer education. And right from the start, right from my university days, I've always been really excited about talks and giving workshops, making sure that any content format that I can contribute to is helpful for developers so that I can help them become successful with the tools and the frameworks that they're using. So that brings me here again, if you have any questions by the end of this workshop presentation, talk, whatever, feel free to reach out to me on Twitter at Vishwametha 30.
00:02:07.542 - 00:02:47.614, Speaker A: And with that, we jump right into it. No, doesn't want to move. Okay, so let's talk about what the graph is. Let's start with right from the beginning. So the graph is a protocol, an indexing and querying protocol for web3, for networks like Ethereum, IPFS and so much more. But that's a lot of jargon web3, decentralization GraphQL, the graph indexing querying. So I get a lot of questions around where it fits into the stack.
00:02:47.614 - 00:03:42.562, Speaker A: So let's look at the stack. You folks are here at a hackathon, right? So you will be building projects, you will be building DApps. So let's kind of like picturize where the graph fits into your DAP stack, right? Your web development stack. So I really love this diagram because it shows the UI layer, the subgraph indexing layer, and there is the contracts, which is your data layer. So the graph as an indexing layer sits right between your front end, which is your UI, and your back end, which is basically all of the data that is coming from smart contracts on the blockchain, right? And with that, subgraphs are becoming a de facto standard of how you query data that is being indexed by the graph protocol from the blockchain. And that's why we say that the graph is now a default part of the Web Three stack. Awesome.
00:03:42.562 - 00:04:49.770, Speaker A: Moving forward, let's talk about the data scenario here. I often get the question like, where does the graph come into picture? We saw where it fits into the stack, but we haven't yet talked about why exactly the graph, right? Why should you be using the graph, how it is going to be helping you in your journey? So I think I need to begin from the data bottleneck that we have in this data driven world of ours. Nothing is possible without accessible data, right? And especially with blockchain data, if you're building decentralized applications, you want to make sure that your UI has a very robust experience for your users. You're bringing very fast and performant and efficient UI UX to your clients. And for that, we need index data. So that is point number one. Point number two is that blockchain has can anyone guess how many blocks so far Ethereum has the block count? Any guesses? Wild guesses.
00:04:49.770 - 00:05:26.210, Speaker A: That's an accurate one. It keeps changing. And yeah, I think the number that I saw right now is like 16 million. So it's in the same ballpark, but it just keeps on increasing. And every block has thousands of transactions. Again, it just keeps on increasing by the hour, by the day. So what I'm trying to say is, if you want to build a DAP using blockchain data, which is increasing, like day by day, it becomes increasingly difficult to index that kind of heterogeneous data which is out there on the blockchain.
00:05:26.210 - 00:06:04.190, Speaker A: It is DeFi data. It is NFT data. Dows governance. Whatnot? So what if you want like a very specific piece of data, right? Do you start indexing the entire blockchain? Do you start indexing all of Ethereum? No. So that's why we need organized data which is well suited for your Web Three applications, your decentralized applications. And as a solution, developers have been building proprietary indexing servers so far. Now, let's jump into why we don't want to do that is because it is error prone.
00:06:04.190 - 00:06:39.980, Speaker A: It is a lot of complex code that you will need to write. But three main points. The first one is that if you're building a proprietary indexing server, it is a centralized point of failure, which defies the ethos of Web Three, which is decentralization. It just goes against why all of us are here hacking and learning at this hackathon, right? So that's point number one. The second is that it's a single point of failure. So if the indexing server goes down, everything goes down. You don't want to do that.
00:06:39.980 - 00:07:32.030, Speaker A: And the third, but again, most important point is that it's a lot of infrastructure to manage. It is a lot of investment of hardware and engineering and monetary resources in running that one indexing server all by yourself, whether you're a team or an individual engineer. Now that is where the Graph enters the scenario. And that's why we say that the Graph is in. It gives you a global open API. But it's not just an API, it's a decentralized, transparent and open network of participants like subgraph developers, indexers, curators and delegators. And it is making sure that you can index your blockchain data efficiently, but also can do it in a more decentralized manner.
00:07:32.030 - 00:08:47.906, Speaker A: And of course, it's built on top of GraphQL, so it brings the benefits of GraphQL to your table. If you want to learn more about GraphQL, I think it's a pretty nifty thing for front end developers and it has been a game changer in the data accessibility landscape. So basically, using GraphQL, the Graph has built a unified data access layer for blockchain. So no matter which data is coming from which smart contract, it is woven into your subgraph, which is basically like a single endpoint that you just query every time you want your data from the blockchain to your application. And the Graph has been powering DeFi applications, not just DeFi applications, but this has been like one vigorous use case and also a really exciting one. So it has been querying on chain data like trades and exchange volumes, total borrowed, supplied, stake yield, farming, total value locked and so much more. So all of these cute little icons that you see, these are like projects that have been powered by the Graph DeFi projects.
00:08:47.906 - 00:09:24.850, Speaker A: And if you talk about some of the other leading projects in, let's say, websites is CoinMarketCap. CoinGecko, if you've heard about it, then there's like NFTs and DAOs. So Juicebox, Dao, there's foundation in the world of DeFi, I'm sure you've heard about it, it's uniswap. And then there's synthetics. All of them are powered by subgraph data through the Graph. And we have a hosted service that we started with about four years ago. So for four years it has been supporting subgraphs and subgraph developers.
00:09:24.850 - 00:10:28.100, Speaker A: But it was a way to start with our initial idea so that we can make sure that we achieve product market fit. We have tested it out before we go live with the decentralized network and we have had the time to get good feedback from our developers. So we started with the hosted service which was run by one of our core dev teams, our original core dev team, Edge and Node. But from that now we're moving away by sunsetting, the hosted service, because we want to make sure that we can find a solution which is more scalable and more sustainable and also fits into the Web Three mission, which is a decentralized network of the Graph. And so we've successfully migrated 350 plus DApps and they've been paying queries for GRT in GRT on the network. So 39 plus. I think the count is a little bit higher now.
00:10:28.100 - 00:11:26.770, Speaker A: All of these chains, amazing chains that you see and you've probably worked with, built on, are supported by our hosted service. And with that I think we've discussed the graph a lot. We've talked about what subgraphs are and we've talked about why it makes sense for you as a developer who's building DApps to absolutely use the graph in your stack. So let's see some code. Now, I typically do like a live demo of this, like a live coding session, so that I can take you through the entire process of how to use the subgraph studio, how to get started by initializing your subgraph. Scaffolding it, designing it as per your use case, as per the data that you want, and then finally deploying it. But just to make sure that we're right on time and also to make sure that nothing breaks because of the WiFi.
00:11:26.770 - 00:12:17.842, Speaker A: I'm just going to run you through the code here if you see the subgraph. So this hasn't loaded yet, but basically if you want to get started, you just need to go ahead and go to the subgraph studio on the graph.com website and create a subgraph. So I'm just going to show you like a nice little screenshot of it. So this is something that you will be seeing. The prerequisite here would be that you will need Node JS installed on your machine to make sure that you can install the graph CLI and then that you also have a MetaMask wallet using which you can sign into the subgraph studio. And you go ahead and first create a subgraph slug.
00:12:17.842 - 00:13:07.838, Speaker A: Basically just create a subgraph on your dashboard. The next thing you see will be this kind of like a dashboard for your subgraph with some documentation, really helpful documentation on the side. And now I'm going to run you through the kind of commands that we need. The first one is the NPM install command for the graph protocol CLI. So this is just a one time thing. Once you've installed the graph CLI, it's going to give you some really cool utility commands that you can use to scaffold and design and deploy your subgraph. For that you can either use Node JS or you can Node NPM or you can use Yarn when you're done with like, we want to initialize our subgraph.
00:13:07.838 - 00:13:48.520, Speaker A: So the graph init command is one of those commands given by the graph CLI that you see here and it basically scaffolds your subgraph. It gives you some boilerplate code to get started with. And let's go ahead and see what kind of boilerplate code it has given us. And this is frozen. Ah, think I'm just gonna give it a second, I guess. Yes, we got it. Awesome.
00:13:48.520 - 00:14:50.218, Speaker A: So once you've initialized the graph your subgraph, this is what you're going to be seeing basically. And I think it's a pretty cool folder structure right here because it's super clean. You see it and you know that there are three main files that we want to be looking at. The first one is the subgraph YAML file, which is your typical configuration file that describes your subgraph like which kind of network you're working with, the name of the token that you're working with and your data source that you want to pull in as a smart contract from the blockchain. So that is basically this right here that you want to enter. And this is basically the smart contract address of the Zora NFT smart contract that you can get from the Zora documentation and just want to call out. One really useful information is that you would also want to define a start block is because you don't want to start indexing from the genesis block.
00:14:50.218 - 00:15:34.038, Speaker A: If you know which block you want to start indexing from, just go ahead and pop in the start block ID. Here the address. And then there are a couple of entities here. So entities, I will go more deeper into this when I talk about the Schema GraphQL file. But just as a quick overview, entities are basically all of the fields of data that you want your subgraph to query from the smart contract. So for example, there's the Zora NFT smart contract, right? So here we're defining two types of entities, which is like token. The first one is Token, which is all of the NFT data and the second one is user, which is the user metadata.
00:15:34.038 - 00:16:40.318, Speaker A: And I think it's going to start making more sense once you see the Schema GraphQL file. But before we move on to that one last thing here in the subgraph YAML file that you would want to define is the event handlers. So every smart contract will have events that it emits every time you start indexing it and you want your subgraph to listen to those events to make sure that there is some kind of business logic that is implemented when you listen to those events. And then when the business logic is implemented, your local code and the events is being mapped and you can query all of that data from the events to your client. So here we will be dealing with two kinds of events, basic events from the Zora NFT smart contract which is token Uri updated. So every time the Uri of your NFT is updated, this event will be emitted and we want our subgraph to listen using mappings to make sure that we can query that data. And the second one is the transferred event.
00:16:40.318 - 00:17:44.654, Speaker A: So there are two scenarios here. Either a new NFT would be minted and in that case this event will be emitted, but it could also be an existing NFT whose ownership is being transferred from one owner to a new one. And with that we can move on to the Schema GraphQL file. I know we're moving fast here, but you can always come back to me with questions. I'm just trying to make sure that I can give you a good overview of the folder structure of the subgraph, but everything else that you see right now is super specific to what kind of subgraph you are defining. Is it like an NFT API? Is it for your DeFi use case? Is it for governance, et cetera? So the Schema GraphQL file you see right now is basically a GraphQL file. If you work with GraphQL at all, you can understand what this does is that you're telling your subgraph what kind of data it wants to query.
00:17:44.654 - 00:18:39.942, Speaker A: It needs to query from the blockchain. So I want all of the NFT data and the corresponding user metadata. So that's why I'm defining using at entity directive, I'm defining two types, which is token and user. So for all of the token data and the user metadata, I'm defining these two types. And the at entity directive is a basic GraphQL directive that lets you define types with top level fields for all of the data that you want your GraphQL API to query and give a response of. So it comes with all of the other fields, like if the token has an ID, a created at timestamp metadata and Content Uri, et cetera. And then the corresponding creators and users of the NFT are then being stored as using the User object type here.
00:18:39.942 - 00:19:45.798, Speaker A: So there can be a simple type in GraphQL and there can be an object type, which is basically the user type that we've defined here, which can then further have its own sub level fields that you can query. So for the user metadata, we want to be querying all of the tokens that are being owned by an owner and all of the tokens that are being created by a creator, all of the tokens that are being minted, right? So those are the two relations that we're defining as part of the user entity, the user type that you want to query using your subgraph. And we're doing that again with another really cool, really nifty directive, the GraphQL directive, which is add derived from directive. Now basically, instead of this directive, you can use alternatively you can create an array of all of these creators and owners. But this is something that's a bit more performant. That's why we're using it here. And once you've done that, you want to move to the Mapping TS file.
00:19:45.798 - 00:21:06.246, Speaker A: So basically what the Mapping TS file is, it's a file where you define all of the business logic that you want to run once your subgraph has started using like querying all of the index data and the smart contract is emitting the data. So you want to map the events that are being emitted by the smart contract to some kind of locally defined functions, or let's say like event handlers basically. So you want to handle those events that are being emitted. And the cool part of the Graph CLI is that it comes with TypeScript support out of the box. So it gives you really cool TypeScript library that gives you some helper functions that you can import while writing your mapping TS file to make sure that you're writing your event handler as well and easily. So to be able to do that, there's another command which is called the Graph code gen command. It's basically just you just enter Graph code gen, you run it and it will give you like the out of the box TypeScript library that there is.
00:21:06.246 - 00:22:27.038, Speaker A: It will generate all of the helper functions and that you can go ahead and import here in the mapping TS file. And once you've done that, so if you can see here in the generated folder the functions that it has generated for us to import, there are basically two types of functions. The first one that you see, Token, is something so you can only read data from the smart contract from the blockchain, but you can both read and write data to the graph node, which is like a local storage. So the generated schema file is basically giving you all of the functions that you need to interact with your graph node, which is basically reading and writing data onto it because you also want to save data that you have gotten from the smart contract. And then the Token one is the generated file that gives you functions that will help you interact with your smart contract like read data from the smart contract. And finally, we have defined here the two event handlers for the two events that we were dealing with here in our subgraph. It's basically handle transfer event and the Handle Token Uri updated event.
00:22:27.038 - 00:23:42.614, Speaker A: So any events that you're dealing with, you would want to write an event handler so that you can perform some kind of business logic in your subgraph once you start listening to those events. This is basically like assembly script. So anyone who's used JavaScript or TypeScript, this should be very familiar kind of syntax for you. And just to stay within timing, I wouldn't go deeper into what this exact code does, but basically I've already defined what each of those events meant. And so we're making sure that every time the event happens and there's an updated piece of information, we're saving it to the graph node, we're retrieving it from the smart contract and we're saving it to the graph node so that we can query it via our subgraph later. And once we've done that, I think we're super close to the end of it, which is that you have initialized your graph, your subgraph, you have defined it based on the smart contract that you want to be using and the kind of data, the kind of events that you want to deal with. And the final piece here would be to deploy let's see if it's not happening.
00:23:42.614 - 00:24:41.820, Speaker A: So the final piece here would be to deploy your subgraph so we have another command here that lastly you would want to run is the Graph Deploy command. And if you go to the graph documentation, you should be able to see the Graph Deploy command. So you authenticate your subgraph finally, and then using your API access key, and then you deploy the subgraph. Let's see if we can move this tab. It's getting a little stuck here and there, but while that happens so sorry about that. While that happens, I think we've concluded our code walkthrough of how to initialize a subgraph, how to define it and deploy it. And once it has been deployed in your subgraph dashboard, you should be able to see that the subgraph is now it just went off cool.
00:24:41.820 - 00:25:34.152, Speaker A: You will be able to see that the subgraph has now been deployed. And there is like a really cool GraphQL playground that you can see where you can run some sample queries and you can test out whether your subgraph is working or not. And I think I lost my presentation. Never mind. Once you've deployed your subgraph, you should be able to test out the sample queries in your GraphQL playground. So come by the booth, I might be able to show you the actual live demo. So if this is interesting to you, test out subgraphs.
00:25:34.152 - 00:26:39.672, Speaker A: We are giving away cheat sheets at our booth, and I think Simone has already done that here as well. So the cheat sheet is basically a good 101 of how to use subgraphs, what kind of commands you need to learn to basically initialize, create and deploy a subgraph. And so if you're hacking at this hackathon, if you're building a DAP, the main takeaway here from this talk workshop is that subgraphs are a really cool way to efficiently access data from the blockchain. And it's a really cool, decentralized GraphQL API that you could be building for your DAP as long as you're dealing with on chain data. So basically, there's no programming language barrier, it's language agnostic. So whether you're using Python on your front end, you're using JavaScript, any kind of like react framework, view framework, subgraphs are still relevant. The graph is still relevant and it is also network agnostic.
00:26:39.672 - 00:27:00.710, Speaker A: So if you're using the hosted service, as I said, we're live on 39 plus chains, so it also doesn't depend on what kind of network you're using. And with that, I will conclude my talk and thank you so much for being such a patient audience. Thank you.
