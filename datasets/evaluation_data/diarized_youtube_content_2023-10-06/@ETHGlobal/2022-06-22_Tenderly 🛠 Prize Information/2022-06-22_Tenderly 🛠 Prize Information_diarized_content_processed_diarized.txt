00:00:07.050 - 00:00:30.306, Speaker A: Hi, everyone. My name is Bogdan. I'm the co founder and CTO of Tenderly. And today I'm going to present you the two of our bounties for ETH, New York. So what is tenderly First, Tenderly is a holistic developer platform catering towards blockchain developers. Now of course, that doesn't mean anything to anyone. So how you can think of Tenderly is if you have three stages of development, local development, once you deploy it to production, and finally something we call after production.
00:00:30.306 - 00:00:59.306, Speaker A: tendrily has a tool or service to help you there to be more productive or not to have to reinvent the wheel. So while working locally, you have a debugger and profiler. I like to joke around. That's basically what you expect from a programming language in 2004. That's what tendrily caters there in the local environment. Now, once you deploy to production, we have monitoring and alerting services, so basically receiving real time notifications when something of interest happens on or off chain. And then finally, the third thing that we have is the one that we call after production.
00:00:59.306 - 00:01:34.934, Speaker A: And it is something that we will focus on for this particular bounty. Now, what do I mean by this? How tenderly works. In the background is we have our own custom virtual machine. And everything that we execute in that virtual machine is supported across all network that we support 20 something right now. So one of our most used features right now is something called the simulator. So a simulator basically gives you a way to do these what if scenarios. Like what would happen if I send a transaction now, or if I change this historical transaction, what will happen? What would have actually happened? And then finally, the second part and I'll demo all of these things, no worries, is web3 actions.
00:01:34.934 - 00:01:52.160, Speaker A: You can think of them like AWS Lambda only catering towards blockchain developers. So basically, you say what you care about, you subscribe to a particular topic on chain or whatever you care about, and we run a piece of code in a serverless way for you. So now, better than telling you all of this, let me actually show you.
00:01:53.170 - 00:02:29.014, Speaker B: Okay, so here I'm inside of the Tenderly dashboard. So just to show you things, I've added the Dai Smart contract into my project so we can play around with it a bit. So when you come to the transaction screen, you're greeted with the list of all of the transactions toward this contract. Now, this isn't relevant for the bounty itself, but I'm going to use on chain transactions to show you how the simulator works. So generally, what angularly gives you when you open up a transaction is basic transaction information, tokens transferred and everything else around that. But what's actually useful is something we call the transaction overview or the full trace. So this is actually fully searchable and you will be able to access this via the API.
00:02:29.014 - 00:02:56.482, Speaker B: So I can do for example, give me all calls that happen in this particular transaction or anything of that nature. I can actually go into each one of these steps in the debugger itself. And then we have input, output variables, decoded, and all of these things are readily available. You can also, for example, I can evaluate this particular thing numerator. And then we can see the expected result over here. Just give it a second. So here we go.
00:02:56.482 - 00:03:28.186, Speaker B: This is the value of the numerator variable. We also have access to all of the state changes in the transaction. It even supports complex mappings events and then guest profiler information as well. Now, one of the two bounties is using the best use of the simulator API to achieve something in web3. So this was an onchain transaction, but let's see how we can change on chain transactions with the simulator. So here I have opened up a transaction that happened quite a few days ago, two days ago. And this is a failed dye transaction.
00:03:28.186 - 00:04:00.150, Speaker B: So as we can see, someone didn't have enough die to transfer. So I can actually change this transaction to pass in two different ways. So I'm going to click on the resimulate button. I'm going to go to edit contract source. And one of the things that the simulator gives you, things to do is basically you can go here and I can change the source code and you can see what would have happened if the source code was different. So the transaction now will actually fail at a different part, of course. But if we go into the debugger, we can see that line 124, here we go, is actually commented out.
00:04:00.150 - 00:04:21.690, Speaker B: So again, you'll be able to do this via the API. Another way I could have made this transaction pass. Let's go to the original on chain transaction here. Go to the debugger. We can see that the source address is this one. So what we can do to make this transaction pass is we can override how much die this particular person has. So I can go to resimulate.
00:04:21.690 - 00:04:45.590, Speaker B: I can go to state overrides over here, add the state override. I'm going to pick die and then let's override the balance, soft mapping. Paste in the address that we got and add I really hope this is enough. If we click on simulate transaction, still not enough balance. Okay, let's go back resimulate. Let's do the same thing again. So add state override die.
00:04:45.590 - 00:05:08.270, Speaker B: Let's do the balance off again. Paste this in. I think this is enough. Zeros. It might be too much, actually. There we go. So this particular transaction passed because if we see the state overrides tab here, we overrode this storage slot to something else, which was the die that we had here.
00:05:08.270 - 00:05:41.186, Speaker B: We can see the state chains correctly and we can see that the transfer event was there. So if we actually go to our documentation website, just give me a second for it to load. Here we go. So if we go here, there is a section on simulations and forks. So you have all of the things that I did here through the UI. You have a video explaining it as well, and you have pictures and text explaining how to use it. But the thing that matters for this particular bounty is the simulation API.
00:05:41.186 - 00:06:03.690, Speaker B: So you have all of the ways you can use this. So you can simulate one of transactions. You can also chain multiple simulations together. That is something we call ten, really forks. So you can fork any production network that we support and manipulate it any way you want. And a great starting point is here the integration guides. So here we have 1234 examples with code to get you started with this bounty.
