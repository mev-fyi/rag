00:00:06.170 - 00:00:24.400, Speaker A: Hey, everyone. Good morning, good afternoon, good evening. Depending on where you are, we have Matthew here from Ceramic doing a workshop on composable data using ceramic. Questions will go into the zoom chat if you have any, and Matthew will answer them all at the end. And with that being said, let's get started.
00:00:25.210 - 00:00:49.020, Speaker B: Hi, good morning, good evening, good afternoon, wherever you might be. I'm Matthew, and we're going to talk about composable data using ceramic. Hopefully you can see my wonderful screen. According to the test, it worked. So if it's still working, then we're in business. Some of you may have heard of ceramic before, some of you may not. And that's okay.
00:00:49.020 - 00:01:45.566, Speaker B: We're going through a lot of changes right now, so this isn't going to be a code based demo, but the good news is we're going through a lot of changes right now, and there's plenty of code based demos to come, and it's going to make using our stack so much easier in the future. So I'm excited to kind of talk about that a little bit at the end and a little bit throughout. So who are we? If you're new to our project, we have a team that's built from extensive enterprise level Web Two folks, as well as pioneering Web Three people that have written core Web Three standards specifically around like, identity solutions and things like that. All of us have come together to work on sovereign data and getting data back into the hands of the users rather than with these big companies and stuff. So that's what our passion is. And we come with a lot of experience to the table here. So pretty solid team working on this.
00:01:45.566 - 00:02:25.020, Speaker B: The big question, if you're new, is what is ceramic? And it's easy to kind of break this down into one sentence, which is decentralized network for composable data. But that leaves a lot of ambiguity. So I like to tear this apart into two sections. First we have the decentralized network, and then we have the composable data. But it's easier to talk about them if we switch them. I think everybody understands the data a little easier. So we're going to start by talking about composable data, and then we'll go into talking about what we mean by the decentralized network and how our network might differ from an ethereum blockchain or what you're used to.
00:02:25.020 - 00:03:07.590, Speaker B: So the easiest way to dive into composable data in my head is to take you through this user's journey. We've probably all been here way too many times where you're going to sign up for a Web Two service. So I have Twitter's example instagram and Facebook pulled up right now. You might notice some similarities in these forms. Like, for example, Twitter asks for your name and phone number, and then I'm pretty sure Facebook is asking for your name and either a phone number or an email. But a lot of these fields become the same thing, and we can see that. Here where we're repeating this data entry every time we go to sign up for one of these new Web Two services that we want to join.
00:03:07.590 - 00:03:55.606, Speaker B: There's a lot of problems with this. One is your time is being taken up because you're filling out the same information over and over and over again. And sure, you might have that stored in a browser, but what's the browser doing with your auto fill form data? I don't think I know. I don't know how many people know exactly what that browser is doing on the back end. And that leads us to the second problem, is once we fill this in, we're kind of giving that to the service itself. So we're saying, hey, I gave you my name, I gave you my phone number, I gave you my email, I gave you all this information about me, even the people that are in my social circle or whatever it might be, and you're going to go store that away on your own application specific database. Now, once that happens, I now have to trust you.
00:03:55.606 - 00:04:56.406, Speaker B: I have to trust that you're going to do the right things with my data, that your database isn't going to be breached and my data isn't going to be compromised. I have to also trust that when I ask to see my data, like, for example, I want to see my friends list that you're actually showing me the data as I entered it, not as you altered it. And that brings us to the third problem, is as a developer, you're often building a one off API integration through one of these services. And that's fine. They're usually well documented. But what happens when one of these services decides to close off their API? Now, you can no longer access your data in the way that your application might need to, because you no longer have access to what's living on their database. All of these three problems lead to the same big theme, which is you have no agency over the data that you're putting into Web Two apps.
00:04:56.406 - 00:05:33.378, Speaker B: And I don't think this is news to anybody, but this is what we're aiming to solve with composable data. So let's look at how Ceramic approaches this. Instead of asking you to fill in your name, your birthday, your phone number, ten different times, we give you the ability to create a data object. At this stage, we're calling them data models. In just a couple of weeks, we're going to be calling them composites. And I'm going to talk about both a little bit because data models are not going away. You're still going to be able to use data models.
00:05:33.378 - 00:06:35.354, Speaker B: Composites are a little easier to use, so data models rely on JSON, schemas and arrest API. Composites are going to be more of the GraphQL query system. So you could plug in any GraphQL client and create and query data composites so it's one of the improvements that we're making over this. They both kind of point back to the same thing and that's you define the data one time in one location and then all these other applications can just globally read from that data. So, for example, a developer would sit down and say, hey, my application needs data that has this kind of schema to it. Let me go ahead and create a model for that or a composite for that. And now if the second project, Web Three app decides that data is valuable to them, they can just read from that and the user gets the ability to update that wherever they want.
00:06:35.354 - 00:07:19.478, Speaker B: So our user sits down and says, oh, here's a schema for me that holds my profile. Let me just fill this in. And now every single application that leverages that profile can read from it. So this makes it to where we have to fill stuff out one time. It's also tied into your identity a little bit, so you have the ability to change it, to delete it, to update it, to whatever you want to do with it. And it's 100% up to you, the user and these applications can just access it because it's also important to point out this is globally readable, so you don't want to store something like a payment information without an encryption. Ceramic doesn't do encryption on its own at the moment.
00:07:19.478 - 00:07:58.658, Speaker B: And we're actually relying on other protocols like Lip protocol, for you to do the encryption on your own and you could store it that way. But we don't recommend storing super sensitive things at the moment. We can dive into this composability piece a little deeper. So if we think about that basic profile data model or composite actually on the network, it's a ceramic stream. And streams are just what we call the data itself. It's not like streaming data that you might be used to if you're using some sort of like big data solution or something like that. We're just calling streams the objects.
00:07:58.658 - 00:08:43.346, Speaker B: If you're familiar with MongoDB, you're probably used to what a ceramic stream looks like. Our most common stream type happens to be very similar to a MongoDB document. It's called a tile document. For now, our new common stream type is going to be called a model instance document. Most likely we're still kind of working on naming, so it's important to know we filled out that basic profile cool. It gets stored as a stream on the ceramic network and a stream is just a list of commits. So we're not actually storing the data itself, we're storing the changes to the data that get made and then we can kind of reduce them down and show you the aggregate view of that data.
00:08:43.346 - 00:09:22.570, Speaker B: So when you go to change something, let's say I change my name, I'm only changing that name field. And what's happening is just like when you use git. We're just tracking the commit for that. Each commit is an IPLD object and it has its content Identifier and that's how we access that commit. And then stream types. I've said stream type is like a tile document and I even said like model instance document. Stream types are just these bigger kind of object or bigger definitions for how and what we can do to a particular stream.
00:09:22.570 - 00:10:26.450, Speaker B: So maybe some streams aren't that mutable and that's where the logic lives is in the type of stream, whereas other streams might be highly mutable, so they have different logic that comes with them and so we identify them as different stream types. You as a developer, you're going to identify it as a different stream type when you code it out too. And then these streams get anchored to a blockchain, but they don't at the same time, the streams themselves never make it down to the chain. It's all the commit IDs and the IPLD information that gets written down to blockchain there. So it is something that we can look at and say, hey, here's proof that the data is what it is. We can't argue the fact that this has commits that do get anchored down to chain, but we're not storing the data down there just to make it kind of quick to do our read and writes. So that's kind of the gist behind a stream type and that might seem a little worrisome if it's globally readable.
00:10:26.450 - 00:11:21.622, Speaker B: Well, how do we make sure that it's going to be accurate? Yes, we have the blockchain, but how do I stop somebody from coming and changing my data? And we do that through authentication, which you might have guessed by this slide. Currently we have three major authentication methods. If you've been using Ceramic, you've probably used the three ID package that we have. This is like an in browser iframe thing that pops up and asks you to connect your three ID to your MetaMask wallet or whatever wallet you choose. That is the most common one that we use and it leverages the tile document stream type on the back end, which is again a stream that we can change it's mutable. The second most common way to authenticate is to use key did. And a lot of times this is build time.
00:11:21.622 - 00:12:15.650, Speaker B: So you can kind of separate these in your head with three ID being runtime and then sorry, the chat just threw me off. With three ID being runtime and key ID being build time. So as a developer, you might sit down and say, hey, I need to define the schema or the data object itself. I'm going to do that with a developer ID that I have, but it's not limited to that. Let's pretend that you create a service that's kind of like an autonomous service and it chooses to store its data on Ceramic. It's not going to have a wallet to interact with so you could then give a key did to a service and have it interact with the ceramic network. The newer and nicer way that we've built things out are to eventually replace three ID with Cacao, which is chain agnostic capabilities, objects.
00:12:15.650 - 00:13:05.046, Speaker B: It's the more preferred way of doing it. Right now we're leveraging the sign in with Ethereum ASPEC to allow this to happen. But basically what we get is sessions out of this so a user can log into the app. They say, hey, connect my wallet. And then we're kind of giving the application permission to act on behalf of us for a set session time and from there until the session times out, right, the application can do a bunch of stuff on behalf of the user. What this does is it eliminates you having to sign every single message every single time you try to do the smallest thing on the network. All right, so the big picture of this is if we look at our developer, our person in purple here, they're going to get a did.
00:13:05.046 - 00:13:49.560, Speaker B: It's probably that key did and that's where they build the definition and the schema. From there, our users, our yellow and our green person there, they're probably using like three ID connect or sign in with Ethereum or sign in with X. We're currently working on specs to expand that. And when they log into your app, they're creating data that matches that schema and writing it as an individual record. That record stays with their Identifier. You'll see here that user two can't change anything from user one. It's not writable because in order to write or update data, you have to use the same did, which is decentralized Identifier in order to do that so that identifier becomes the controller for the data.
00:13:49.560 - 00:14:33.730, Speaker B: The only time that that could maybe not be true is if you're using something like Cacao and you're letting the application act on your behalf. And even in that scenario, it still is using a hash of your did in order to perform actions. So each data stream, like we talked about earlier, stream of data, not streaming data, but data stream, ceramic data stream, has to have a controller and that controller ends up being a did. Cool. What we get out of this is user agency. You have full control over your data. It is tied to your decentralized Identifier.
00:14:33.730 - 00:15:23.282, Speaker B: Nobody else can write to or control that data. However, it is globally readable, right? So unless you encrypt it and then understand how to decrypt it, once it gets to your application, it's globally readable. The big deal with that is if you start making or start storing a bunch of data that's very encrypted, then you're limiting other web3 applications from leveraging the fact that they don't have to build out an entire social profile schema. There's already a social profile schema. You could just call that into your application and get that user's information. So be careful with what you encrypt, I guess is really where I'm at. Like if you're building some sort of financial application and you want to encrypt transactions or whatever, that makes sense.
00:15:23.282 - 00:16:04.174, Speaker B: But if you're adding layers of encryption to data, that makes sense to be public, you're making it really hard for other applications to use the data schemas that you come up with. We won't be able to use your composites, we won't be able to use your data models. And that completely defeats the purpose of the composable data. Composable data is all these hundreds of apps can just read from one type of composite or one type of data model or many of them to compose what that view is for the user. So be careful if you're going to go down that encryption avenue that covers the data part. Hopefully I'm not frozen. Okay, cool.
00:16:04.174 - 00:16:37.670, Speaker B: Not frozen. Let's jump into the network. There's always a lot of questions and fun that come from the network. So we're probably all pretty familiar with the traditional blockchain, right? We get this single global execution environment. And what that does is it communicates this state out to all these different nodes. And this is also why sometimes these things are slow, right, is we have like one entry point to get the current state of things and we aim to solve that by providing ceramic nodes. So the nodes back here are not ceramic nodes.
00:16:37.670 - 00:16:59.746, Speaker B: Ceramic nodes are something different. That was just like, hey, we're running different nodes that plug into the blockchain. A ceramic node is a small piece of software that you run. You could run it on a laptop locally. You could deploy it in a cloud if you want to put it over there, wherever. It doesn't take a whole lot to use. We actually provide nodes for you to get up and started with.
00:16:59.746 - 00:17:27.850, Speaker B: We have a developer testnet. We encourage you to use it. You guys can discover each other's stuff if you're using testnet. But ultimately a node provides a single individual execution environment. So unlike a traditional blockchain, there is no giant global ledger. Every single node is responsible for validating transactions that it knows about, for the streams it knows about. This allows us to say, oh, things are getting a little slow.
00:17:27.850 - 00:18:13.162, Speaker B: Plug in a new node, we can scale horizontally for this and that allows us to increase the number of streams and stream transactions that each node can look at. At any given time, these nodes take an offline first approach. So the way that works is a node cares about what it cares about. So if I'm building an app and I say, hey, I'm going to run a node or I'm going to put this on testnet or whatever, those nodes are going to say, there's a new app, there's a new stream type out there, or a tile document or whatever, there's a new data stream. Let me make sure, I care about that thing. And now that it cares about it, it begins running that individual execution environment. And if node B comes along and it doesn't know about that, that's okay.
00:18:13.162 - 00:19:01.414, Speaker B: It doesn't need to, but it could, if the developer needed it to communicate over to that other node and then actually care about it and start worrying about checking the commits and doing the offline first approach stuff, validating those transactions. So what this means is, let's say you're on an airplane. Some of us fly on occasion and we're doing some development work and you're running a node locally. That's fine. And when you land though, you want to reconnect that node to the bigger network and then boom, it can replicate over, so you can work offline. And when your node comes back online, it will then populate the rest of the nodes that care about it, your streams. And with the current data, with the current state, this works because of this global namespace.
00:19:01.414 - 00:19:26.034, Speaker B: So all nodes kind of live within a global namespace. And this allows them to reference other stream types even if they're not specifically pinning is what we call it. Pinning that stream to their node themselves. Right, I see a question about best fit application. I'll answer that at the end. That's a super good question. We're almost at the end of this here.
00:19:26.034 - 00:20:02.262, Speaker B: So more things about nodes is this is what they're responsible for and these are the characteristics, right? Every node cares about its own storage. It cares about tracking its own commit log backup. That stream state storage is that pinning thing that I talked about that's saying, I'm a node and I'm going to care about this stream or these mini streams. One node can care about thousands of streams, or one node can care about one stream. So they're responsible for their own commit log storage. This gives us that offline approach. They're responsible for persistent connectors.
00:20:02.262 - 00:20:28.594, Speaker B: This is something that we're working on. It's on our roadmap, which I'll show you at the end. It's on our roadmap. This would allow you to say, hey, I need to backup the data on my node. How do I do that? Well, you can plug in many solutions, whether that's some sort of file coin solution or Rweave solution or whatever it might be. This is something we're working on to give developers their choice. Instead of saying, you have to use this one specific solution.
00:20:28.594 - 00:21:08.254, Speaker B: So nodes are also responsible for responding to queries like, hey, I don't have this stream. Can you find this stream type for me? And those are the big pieces. In order to answer those queries we broadcast. Right? The node is responsible for broadcasting changes and commits and other transaction stuff to the other nodes. The last thing that's not really like a responsibility, but it's more of a characteristic, is that nodes can exist on multiple networks. And you're going to need to make sure that if a node is on testnet and you're trying to read something from mainnet, you can't do that. Those nodes can't communicate.
00:21:08.254 - 00:21:33.722, Speaker B: They're on different networks, right? So if you're having a hard time getting data to and from your node or from another node, chances are you're on the wrong network. So there's a couple of major networks. The first one is a local node. Easiest thing to get up and running really quick. Well, second easiest, you just NPM install the ceramic package, run it, and now you can do your local development. The actual easiest thing to use is testnet. You just enter a URL and you're good to go.
00:21:33.722 - 00:21:56.918, Speaker B: You don't have to install anything. Then we have our development network where we test our new features. Highly unstable. Don't recommend using that one. And then Mainnet, which we do have a process of getting on mainnet. We'd like to see a project a lot more mature before we do move it over to mainnet. So if you were going to start today, what should you do? Well, you should create a node, or you should just use the testnet node.
00:21:56.918 - 00:22:15.910, Speaker B: Sorry, don't create a node. Use testnet. Right? That's where all the other applications are building. That's where you're going to be able to get the access to their data. So the read only data, remember? So to get started, we have three things to help you. I'm going to speed through this because these are good questions and I want to make sure we get to them. First one is self ID.
00:22:15.910 - 00:22:44.750, Speaker B: This is a high level abstraction. If you're a react developer, you're probably really going to love self ID. There's a ton of react hooks that will make managing data on ceramics super easy. Glaze is a little lower on the stack, but it gives you more development control. If you want to create a schema or a data model or composite, you're going to end up using Glaze to do that. And then ceramic is the lowest level of this. This is like, hey, I'm running a node, or I'm interacting with the protocol at a much, much lower level.
00:22:44.750 - 00:23:21.354, Speaker B: Most of the time, you're probably not going to be digging into the ceramic stuff unless you're doing something super unique. But it is out there. We can kind of see there's a raw Http client in that ceramic package. If you want to manage tile documents or other stream types directly, you would use that ceramic package. But the did data store from Glaze makes managing those stream types 100 times easier, and it helps us use the composability a little easier as well. And then self ID pulls it up. That's where that three ID connect stuff is, and really a lot of our react stuff.
00:23:21.354 - 00:23:48.920, Speaker B: So if you don't really need a lot of control and you're doing a lot of read only stuff, you probably want to want to hang out in that self ID area. If you're doing that read write stuff, you're going to want to be in the Glaze area. And if you're doing something super low level, you're going to end up over on the ceramic side. All of this is kind of documented. As you might have guessed, we do have our documentation. A major, major thing is the roadmap. This is a new thing for us.
00:23:48.920 - 00:24:28.420, Speaker B: You can find this on our Community Discord. So if you join our Community Discord, you'll be able to click this link and you'll see the roadmap so you could see exactly what we're working on. It's public facing, nothing's hidden. And your input helps steer that roadmap to some degree. So don't hesitate to end up there. And then the last call out here is if you do want to get started with this basic profile and maybe building yours and then getting ready to go and have that populate in different applications. This profile app, self ID, you can go there, connect your wallet and create your profile and then you can kind of play with that as you do some development along the way.
00:24:28.420 - 00:24:41.110, Speaker B: Last little piece. I'll leave this here for a second just in case some of you guys want to scan this. There's also a link here to our website. We are hiring. Positions change all the time. Feel free to apply. We'd love to have you join the team.
00:24:41.110 - 00:25:15.470, Speaker B: You're obviously here, so you're enthused. And that's the number one thing we look for is enthusiasm, specifically around sovereign data. So I'll leave that for just two more seconds while I answer these questions. I'm going to scroll up here. Where do we store data if not on the blockchain? Yeah, data gets stored directly on the node. I think that was asked before we got to the node responsibilities thing. Every node stores its stream state, so that's where the data is with some of the changes that are coming into play.
00:25:15.470 - 00:25:59.438, Speaker B: Like one of them is indexing, which is going to be out here pretty soon. The node is now also going to run a small database to keep track of the indexing stuff. But the data itself does get stored on the node and it is stored all through IPFS. That's a correct answer there, right? So we sit on top of IPFS, IPFS is here, and then everything that IPFS sits on top of can be any user defined storage. Can you read data from another? Yes, yes, and yes. You could make your own user defined storage. Whatever your object needs to look like for your application to work, you can stuff pretty much anything in there.
00:25:59.438 - 00:26:40.202, Speaker B: There are some limitations. If you're storing video, it's not going to work well. Right? So like, large pieces of binary data don't fit really well. But lots of if you could see it over like a rest payload or a GraphQL kind of payload, then that's the type of data that we're really supporting more than any other type. Let's see. Can we read data from another did? Absolutely, if you know the did right. One of the ways that this has been handled in the past, which we're hoping to solve with Composites in this indexing service that's coming out, is applications would use three ID.
00:26:40.202 - 00:27:21.386, Speaker B: You sign in, you do all your stuff, and then they ran their own indexer that kept track of DIDs so that they could re reference data as they needed to. Orbis is a good example of this. Orbis is one of the most fully fleshed out applications we have that uses Ceramic. It's a Twitter clone. So all the posts and things like that and what you've written are all tied to a did. And then they do have a small indexer, so you can read data from another did if you have it. The bigger problem is, if you have the did, then what stops you from writing data? So there's a better way to do it.
00:27:21.386 - 00:27:54.434, Speaker B: You wouldn't really keep track of the did directly. Right? So there's that. Each stream gets a Stream ID and you can read data from any stream as long as you have its Stream ID. So that's the safer way to do it would be to say, hey, I have an app. Did is doing all the controlling great. I'm running an indexer, or I have some sort of index service that's available to me, which ours will be soon. And I can keep track of stream IDs so I can globally read everything because I have the stream ID.
00:27:54.434 - 00:28:20.374, Speaker B: And that's a read only thing. You can read it if it's not encrypted? Yes, it's globally readable. You just can't write or update. Exactly. You need a did to write or update. Is there any way to encrypt and decrypt data documents stored on Ceramic? We recommend lit protocol for right now. That's been the most commonly used encryption layer for this best fit applications for Ceramic.
00:28:20.374 - 00:29:07.194, Speaker B: We're really focused right now on things like social. We think that data makes a lot of sense because of how it's typically shaped. So social applications, Credential based applications, like some sort not, well, maybe create I don't want to tell you what to build, but like reputation and verified Credential type applications are helpful. We just did a major integration with Gitcoin, their Passport feature. They're leveraging Ceramic quite a bit, so things along those lines, not necessarily financial transactions. If you're building a financial app, it could go either way. Like, we've seen an integration with Superfluid using Ceramic, but what they are storing is more of an address book.
00:29:07.194 - 00:29:43.670, Speaker B: So that's more of like the social side of a financial application. Is there gas fees for did transactions? If you're using Testnet right now, the answer to that is no, there will not be gas fees at the moment on Testnet. I don't know what the long term plans are for that right now. Even. If you're on main net, I'm pretty sure we're the ones covering the gas as it comes to that. Any timeline for Ocaps look at the roadmap would be the number one place I could point you. As engineering changes their priorities, that probably changes.
00:29:43.670 - 00:30:23.282, Speaker B: So if that's not on there, we'd love to have you raise a concern on the community discord so we can get it on there. If data is stored on IPFS, who's paying for the pinning filecoin? Again, we're taking care of all the transaction fees at the moment, especially on testnet if you're doing it local. If you have a local node, then your local node also comes with IPFS. So it's all just local and it's not wholly discoverable like it would be on testnet. Data storage. Can those be pointed towards storage like S Three Rweave or not IPFS? Not at the moment. Again.
00:30:23.282 - 00:30:46.182, Speaker B: That's a coming soon feature. If you remember, we looked at I don't know if I read the question loud enough. It was data storage of nodes and can they be pointed to our Weaver S Three? That's an upcoming feature that was in our thing. So I'm guessing this was asked prior. Who do we reach out after the hackathon if we want to talk to someone and how you can use ceramic. Me. Hi, I'm Matt.
00:30:46.182 - 00:31:12.930, Speaker B: You can reach out to me on Discord in the ceramic discord server. Honestly, the whole team is there, but you can reach out to me. I'm more than happy to help you. We also have a forum and if you start asking a lot of super technical questions, I'll probably point you over there. It's just a longer lived, easier thing for us to track, so feel free to reach out to me. I'm more than happy to circle back and help you. I've answered pinning.
00:31:12.930 - 00:31:48.734, Speaker B: As an app developer, how do I discover the stream IDs use? That is a struggle that we are currently dealing with, and that's some of the indexing that we have planned for the very near future. Check that roadmap. You'll see how near it is. It's right around the corner. This has been a long term thing that we've tried to solve is how do I discover those stream IDs? The answer is that's what that small database is going to come along and help with. Hopefully other applications have built in their small indexing service to keep track of stream IDs. That's one way you could do it for now.
00:31:48.734 - 00:32:14.600, Speaker B: Check the roadmap though. That's a big point that we care about deeply that is coming to light. Self ID is a little bit not easy for me. Is there other did services based on ceramic? If you're struggling with self ID, I feel your pain. When I build stuff using ceramic, I don't typically point to self ID directly. I like using the Glaze set of things. Check out the did data store.
00:32:14.600 - 00:32:52.500, Speaker B: I think you're going to find it a whole lot easier to use from the did perspective. Plus, very recently, I'd say within the last three to four weeks, we have fully released the sign in with ethereum part of the Glaze stack, which makes not using Self ID and not using three ID that pain point kind of they go away. It's a whole lot easier to use the sign in with ethereum flow and then the Glaze suite. Sorry, I keep saying did in my head, the Glaze suite. So I feel your pain. Try that and reach out to me on Discord. I'm more than happy to help you get that up and running.
00:32:52.500 - 00:33:07.158, Speaker B: Would like to discuss on building an Instagram s. Yeah, we'd love to discuss that too. Again, join our community forum. I'll put that up one more time here for you. Join the forum. Please bring those discussions over there. We would love to have these talks with you.
00:33:07.158 - 00:33:36.542, Speaker B: We do have an entire partnership person manager, business partnership manager that will take care of those type of relationships. I can get you in touch with her. She's awesome, does a wonderful job. You just got to reach out to me on Discord and I'd be more than happy to take a look at your project and make that connection for you. Would you recommend start with Glaze? I recommend look at everything. Look at everything and see what you find easiest. I find glaze easiest.
00:33:36.542 - 00:34:01.260, Speaker B: There are plenty of apps that use Self ID. I come from a different type of programming background, so the Self ID stuff is a little bit too high level for me. I like to have a little bit more control and not have so many opinions in there. And Self ID is the most opinionated piece. So check out the Glaze stuff. Again, reach out to us in the forum. These are great conversations that we can go deeper in over there.
00:34:01.260 - 00:34:03.420, Speaker B: I think we're a little over.
00:34:06.590 - 00:34:33.262, Speaker A: Um, yeah, so we are at time. I know there's one more question in the chat, but feel free to ask that in the Sponsor Ceramic Discord Channel. Matthew and the rest of the Ceramic team will be available and we'll be more than willing to answer that. But with that being said, thank you so much, Matthew, for taking the time to do this workshop for Hack FS. Super useful. I think a lot of people are really interested in ceramic, which is really great. Yeah.
00:34:33.262 - 00:34:57.526, Speaker A: So once again, everyone is available on the Sponsor Ceramic Discord Channel, so feel free to reach out there. Also, Matthew did put up all of the other ways to contact the team if you want to. Yeah, and thanks to the rest of you for tuning into this workshop. We do have another one after this one, so hope to see all of you there as well. Have a great rest of your day or evening or morning, depending on where you are.
00:34:57.628 - 00:34:58.020, Speaker B: Thanks everyone.
