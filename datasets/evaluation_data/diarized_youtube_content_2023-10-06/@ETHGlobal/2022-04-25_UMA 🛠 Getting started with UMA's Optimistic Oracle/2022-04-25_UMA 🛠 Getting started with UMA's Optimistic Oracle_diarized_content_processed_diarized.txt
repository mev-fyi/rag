00:00:08.010 - 00:00:24.480, Speaker A: How's it sound? You good? Cool. All right. Hello everyone. My name is Chandler. I'm really excited to be here today talking about how to get started with the Optimistic Oracle. I am from the Uma team. Just a quick intro to the idea.
00:00:24.480 - 00:01:09.490, Speaker A: When putting together this presentation, I'm limited by 20 to 30 minutes. This was originally meant to be at least half an hour more. So a lot of the details in here are going to be very high level, very quick overview. If you need more details, please find me on the floor. Reach out to me on Telegram and Discord. We at the Uma team are really here to support you and make sure that you can integrate with the Optimistic Oracle in the quickest and the most efficient way. All right, the outcome from what you are going to get from this workshop is a quick overview of what the Optimistic Oracle is, how does the Oracle work at a mechanical level and a demo of the Oracle request.
00:01:09.490 - 00:01:48.702, Speaker A: And then also just some insights at what other teams are using the Oracle for. This will give you a nice introduction onto some brainstorming, ideas and what you can play around with. And then at the end of the session, if you are interested in hearing more about what we're interested in building, like our ideas bank, feel free to come and bother me about that. So what is an oracle? Oracles are a key part of the blockchain infrastructure that allows external data to talk with on chain environments. That's a really important thing for how this space works. And we see kind of two distinctive types of Oracles emerging. One is the one that we all know.
00:01:48.702 - 00:02:48.580, Speaker A: These are price feeds. Data gets brought on chain in a way kind of periodically and deterministically and that process is really easy to work with. This has basically been the way that most Oracles work right now and has been the powerhouse of how DeFi has grown. One of the things that we want to try and create a narrative around is this idea of a optimistic Oracle, where the creation of different types of methodologies on bringing data on chain allows for a lot more long tail types of data. I'll get into a little bit more about what that is, but it basically has the same essence of being able to bring any verifiable state in the world on chain. It is a lot more flexible and can adapt. We kind of go through that process on how does a request come on chain in a way that everyone can trust.
00:02:48.580 - 00:03:43.678, Speaker A: And the other part of it is it adds some sort of recourse. Most of the price feeds that we work with today, you take the price or you leave it. And if there is any sort of like tampering, data breach, hack, manipulation of the price, gas gets too expensive and you can't get any request on chain. Most of these contracts that rely on these will execute irrelevant. So what we're looking at wanting to try and talk about a bit more, is that these optimistic style Oracles by their nature, allow people to have some recourse or dispute an outcome that doesn't fit the intention of how the contract or the particular product that you're building was designed to be used. So a little bit more technical, a little bit more in depth. But what does an optimistic Oracle look like? I like to describe it as very similar to an optimistic roll up, but just for the data layer instead of the actual consensus layer.
00:03:43.678 - 00:04:23.390, Speaker A: And this process works by you as a requester, wants to request some data, and someone will propose that just like in an optimistic rollup, you propose a series of transactions. You wait a small period of time for people to check that these transactions are valid using some sort of fraud proof. And at some point in time you can kind of assume them to be true. That process at a very high level works the same with our optimistic Oracle. So there are a couple actors, there's a requester, there's a proposer, there's a disputer. And in this case, we have a requester who will ask a question. This question is normally what we call a price request or Oracle request.
00:04:23.390 - 00:05:16.914, Speaker A: And we'll say, I'm willing to pay someone a certain amount of money, a bond to be able to bring that data on chain. This bond is what we use to incentivize a proposer to put that price on chain. And this proposal really is what the proposer believes is the right outcome and the right price for that particular outcome. This proposal is what we would go through, what we call like a liveness period. This liveness period is really for a bunch of other decentralized parties in our network to say, is this proposal actually valid or not? Or if it's not, can we dispute it? If it's correct, no one disputes it. It's assumed to be true. But there is this dispute process where you as a person can say, I don't think that that is true, and we will dispute that a little bit more later down the line.
00:05:16.914 - 00:06:06.850, Speaker A: We'll talk about how the DVM works. The DVM is the arbitrator of any disputes. How does this process of us actually resolving a dispute, how does that work? And what do we do about making sure that even in a case of a dispute, that prices and resolutions of data outcomes can be verified on chain? So part of that process is also just to get you, as developers, a quick demo on how to get started, right, how to actually call these functions. So we're going to go through an example, and this example is going to be a fairly simple one, right? So to set the scene, first things first, you got to clone the monorepo. At, uma project. You can find that on our GitHub. Do the initial commands.
00:06:06.850 - 00:06:26.546, Speaker A: You just make sure that you get everything set up. Just a small note, make sure you're using node version 14.14 and above. That's been a common mistake that we've seen. So you've cloned the repo. You've gone through the quick start guide. This tutorial is also linked to our doc.
00:06:26.546 - 00:06:55.602, Speaker A: So this is the exact tutorial we'll use. I've changed the questions up a bit, but you'll get a flavor of what we're trying to do here. So I'm going to ask the Oracle a question. This question is going to be formed at a very high level in terms of the question is going to resolve to a point where you can answer yes or no. And if you don't know, there's an option for I don't know. So this is what we call our yes and no Identifier. I'll get into what an Identifier is in a little while, but basically we're going to ask this article any kind of question.
00:06:55.602 - 00:07:33.014, Speaker A: That the way the question is asked will make sure that anyone can resolve that in a yes or no fashion. So question that we're going to ask is, did Eat Amsterdam start on the 22 April? If it didn't, you're going to answer no. If it did, you can answer yes. You can also answer I don't know. So the first thing that we want to do is let's get a contract to actually interact with this Optimistic Oracle. So in this demo, we're using our long short pair token contract. But you can kind of in your own product space, think of this contract as the contract that's going to call the Optimistic Oracle.
00:07:33.014 - 00:07:58.360, Speaker A: So the first things first, I am going to just run a little bit of a script. When you see the demo, you'll see that each of these scripts are laid out in detail. But first things first, let's just deploy a contract. This is going to deploy an LSP contract. And this is the contract that's going to call the Optimistic Oracle for a request. You can see it's going to go through a it's going to deploy, it's going to set up itself up some parameters. This part's not so important.
00:07:58.360 - 00:08:51.000, Speaker A: Just think of this as some arbitrary contract that is going to basically resolve the outcome of a yes or no question. So we've got a contract. The next step I want to do is just mint some tokens. Most of the time projects use tokens. So we're just going to mint a couple of tokens so that there is some sort of value attached to each of these price requests or this resolution requests. So what I'm doing here is I'm going to mint one token that is going to pay out one dollars if I answered right or yes, and pay out zero if I answered wrong. So basically what's going to happen is we're going to decide, does the resolution of this product actually resolve to a point where you can build something out with it and transfer value from one token to another.
00:08:51.000 - 00:09:06.214, Speaker A: Works really well in prediction markets. This is actually something that we use at Uma as well, which we'll get into a little bit later as well. But, yeah, this is basically a prediction market outcome. So I've deployed. I've minted. Now some time goes on. We want to resolve this contract.
00:09:06.214 - 00:09:55.962, Speaker A: We want to figure out, did this actually happen? So the deploy the Mint, I am going to request the price. That first step is, hey, Oracle, can you resolve this price? So this script will take you through the request element. You can see in the actual script here some of the details around what goes into a request. This is the demo request. There are important elements to this that are in the documentation. But really what you're asking for here is you have called the Optimistic Oracle and you are requesting for a price, right? So if we look at what that means in the real world, we have a UI where you can see a list of all previous past requests. You can see I've done some testing here around a couple other ones.
00:09:55.962 - 00:10:23.138, Speaker A: You can see there's another one here who will win seattle Mariners versus Texas Rangers. I don't watch American sports. I'm not exactly sure what that is. But somebody could answer that question. And you can see the status of where these contracts are. So some of them have been settled, some have proposed some prices, and there's been a request. This request looks particularly interesting because this is the actual request that I just made in the terminal a little while ago.
00:10:23.138 - 00:10:58.444, Speaker A: And you can see some of the details around this request kind of this is some testing, some more wait, hold on. Let's go one more time. Click my wallet. Just let it load up. So this is what a request will look like. Each request can have a series of data points in them. Those data points can be the request timestamp the Identifier that you're using, as well as some sort of ancillary data.
00:10:58.444 - 00:11:41.320, Speaker A: And this ancillary data is kind of important because that's how you package the question, right? Each request will be packaged in such a way that if you're using this Identifier in that ancillary data, you can ask the question. So think about it as each time you do a request, you can ask a different question each time. So it's a generalized way of asking a yes or no type question. If the question is badly formed, you can also answer I don't know. You can also answer yes or no if it is well formed. And I think this one's fairly straightforward to kind of wrap your head around the idea that a question that resolves in yes or no just kind of really is a binary outcome. So that was the request I made not too long ago.
00:11:41.320 - 00:12:17.364, Speaker A: I want to be able to submit a proposal, right? I want to answer this question. So it's telling me here. Did Eat Amsterdam start on the 22 April zero p one or outcome one is zero. Outcome two is one and outcome three, 0.5, where one corresponds to yes, two corresponds to no, and zero five is I don't know. So let's kind of figure out the answer to this one just by a show of hand in the crowd. Did ETH Amsterdam start on the 22 April? What would we say? We'd say yes.
00:12:17.364 - 00:12:45.256, Speaker A: Right, okay. So we're going to submit a proposal, and I'm going to in this case, it can be anyone in your network. You can request a price and propose your own price. You can also request that any sort of third party, decentralized entity can actually request this price. And there are two important parts to note here. They're currently set to zero, but there is a proposer award and a proposer bond. Each proposer reward is for the requester.
00:12:45.256 - 00:13:29.484, Speaker A: They're willing to give some sort of value to you as a proposer to say, I would like this piece of information. I will give X amount of reward to that person for that. The proposer bond is the proposer who will say, I'm willing to stake I'm required to stake this amount of money to be able to actually resolve this request. And you can kind of think of it if the question is as simple as ETH Amsterdam. Everyone kind of knows that low risk market, no real need for too many rewards. If you have a really high risk market, the game theory around rewards bonds and proposal bonds and disputed bonds becomes quite important. So kind of think of that as a parameter when you're designing your market.
00:13:29.484 - 00:14:11.512, Speaker A: So I'm going to submit a proposal and sign this off, and we'll see. By the way, this is all on covan. So there are some distinctions on how this works on mainnet, but I have now submitted this proposal, and it's going to load up. And you can see that's the transaction right. So we spoke about the idea of proposing a data point and deciding if it's right or wrong. What you can see here is that the status of this actual request has gone from proposed sorry, from requested to proposed. Anyone here now in the audience can look at that and say, okay, I have a certain period of time to disagree with that.
00:14:11.512 - 00:14:38.492, Speaker A: If I disagree with that, I think we don't disagree with it. So we're not going to go through that dispute process. But if I did, I can go ahead and dispute this. We can do this automatically through some bot infrastructure or in kind of these more nuanced type markets like this. You can do it manually. And you can see the custom liveness period that I set for this particular transaction is two minutes. So I've basically got two minutes to talk till this market resolves.
00:14:38.492 - 00:15:48.824, Speaker A: And if I can convince you all not to log on to this contract and dispute me, this basically will resolve by itself. If there is a dispute in that time period, we will actually escalate that to the data verification machine. That data verification machine is a token weighted voting system that is a kind of implementation of Vitalik's shelling point theory, where the kind of source of truth people will aggregate to actually voting towards that. And so the dispute and resolve kind of process happens with the token weighted voting system, and that process is a little bit slower. So this liveness period really is just the slowest way that these markets can sorry, the quickest way that these markets can resolve. And if in the event of a dispute, it's a hold on, let's go and make sure that this outcome is correct and the DVM arbitrates that dispute. The important part here to actually remember is that the proposer bond and that disputer bond comes into play in the event of a dispute, if I propose something, I get my bond back.
00:15:48.824 - 00:16:40.600, Speaker A: If no one disputes me, meaning I, as the proposer, did something correct and no one was willing to dispute me on that. If I am disputed, that disputer has to put an equal bond for that dispute. And whoever wins the resolution, if the proposer was correct, they win both the proposer bond back, the reward and the disputer reward the disputer bond and the vice versa if the other happens. So it really is a game of staking, putting your money where your mouth is to say, I believe that this is correct, or I believe that this person's done it incorrectly. So we've got 10 seconds left. And that's basically what the liveness period will run out. And you'll see, this transaction will go from proposed to resolved and settled.
00:16:40.600 - 00:17:12.068, Speaker A: So I'm sure I'll have to reload the page. Yeah, it's settled. Right. And so the outcome of these tokens is that anyone who held a yes token, that person now is one dollars richer because the outcome resolved. Yes. Now, if you're thinking about how your development projects would work, is we define this yes or no element as just simply a question. Right.
00:17:12.068 - 00:17:31.412, Speaker A: What's actually kind of important to realize in this process is that that yes or no question was just a way to formulate a question to the Oracle. There are many other ways to do that. We also answer that question. You can do that. There's a script to do that. You can do it on our UI. You can do it directly on Covan sorry, directly on Etherscan.
00:17:31.412 - 00:18:44.656, Speaker A: And then once we proposed that, we waited for some time, we then accepted the information as correct because no one wanted to dispute that. And that's kind of the resolution process on how, uma's, optimistic Oracle works. And that's really important for you to realize when you're asking a question, it's ask a question. Somebody gives you an answer, you let some period of time pass before you accept it as true. So that liveness period, when deciding on how to handle what comes about after you make an Oracle request, is kind of important to take into consideration when you're designing your products on um. So what do you need to know about asking questions to the Oracle? And I think the one that kind of comes to mind for me personally is how do we define what the question should be, how we're going to arrive at some sort of truth? And in our example, we used a yes no question where we laid out a methodology which we call an UMIP, or an Uma improvement proposal, where this defines the source of truth. And the source of truth is for us to say we're going to follow this methodology, and you can use this identifier if you follow that methodology in the yes no question.
00:18:44.656 - 00:19:22.572, Speaker A: We simply said, ask a question in the form of yes or no. It'll resolve to yes if the outcome is yes and no if the outcome is no. And if you formulate a poor question when the answer is unresolvable, we'll get you an unresolvable state. That's the methodology at a very high level. I'll show you an example of what that looks like in a second. But you as a developer can actually define what that is. You can maybe ask some other types of question is what days of the year are sunny? And then you use Yahoo historical weather you can use on chain data if you'd like.
00:19:22.572 - 00:20:04.756, Speaker A: Say, what's the TVL of a certain project? And we're going to use DeFi llama as that source of truth. What is some other type of metric that is arbitrary for kind of a price feed to want to create and push on chain? You want to just be able to say, all right, we're just going to look at this series of actions on chain and we'll kind of just use that as a resolution process. And I'll go through what other teams are doing in a bit. But the UMIP, or in this case is the methodology of arriving at the outcome. It's the document that people will use to arrive to that shelling point for your use cases. If you're building on testnet, don't worry too much about actually creating this. UMAP.
00:20:04.756 - 00:20:36.592, Speaker A: It's really just for Mainet. We'll simulate a lot of the answers and how to go about actually resolving your own price proposals when you're working on testnet. That liveness period is quite customizable, so I set it for three minutes. For the sake of this demo, we usually set it for 2 hours. You can set it for a couple of days. That I think is just something important for you as hackers to realize that just play around with that liveness period and you can kind of work with that a little bit more. And the other one is that this is decentralized resolution.
00:20:36.592 - 00:21:46.872, Speaker A: The requester, the proposer and the disputer all don't have to be the same person specifically with the proposer and the requester. And that decentralized resolution has a game that incentivizes everyone to arrive at the right price. If you're looking at a price proposal, and it seems wrong to you, it's basically free money for anyone that wants to dispute and you know, as a proposal that if you put something down wrong, somebody's looking at your proposal ready to dispute you. So things that are currently been built on this sort of kind of Oracle system is we have something a lot of the prediction markets from Polymarket actually all of them, are being resolved with, uma, at the moment, DeFi insurance platforms where the outcome based on the on chain insurance contract needs some sort of check to see. Did this outcome happen? Sometimes it can be off chain data or off chain events that trigger an insurance breach, and you can use our Oracle to work with that. Optimistic governance is quite interesting. Optimistic Governance is simply community votes on an outcome.
00:21:46.872 - 00:22:22.836, Speaker A: You need someone to basically implement that. And so you can write these governance processes to be a lot more efficient than the traditional snapshot. Somebody has to execute it. You can create decentralized ways of doing that using Optimistic Governance. We've recently just put in a module called the Zodiac Module that kind of does this, and it's the first use case that we're looking forward to developers building on at a later time. Rewards is a service, basically action reaction. In most of the time, rewards that you get is you do something for a protocol, they reward you in somewhere, right? You do an action, they give you a reward.
00:22:22.836 - 00:22:53.932, Speaker A: How can you create systems where that action triggers some sort of event, whether it doesn't have to be on chain, it can be off chain. KPI Options is an example of that. It's probably, Uma's most famously used product at the moment. It's a really tokenized incentive mechanism for communities. And then you can also build synthetic asset markets, right? Synthetic assets are just derivatives. Derivatives don't need to be priced every five minutes. You really just need to price a synthetic asset at the time of expiry.
00:22:53.932 - 00:23:58.976, Speaker A: So it really works well for these sorts of use cases. Some of the teams I mentioned, Polymarket, the insurance protocol that we are working with right now, sherlock. The other one that I haven't quite mentioned a lot is across is an L2 to L One relay. And the question that it's asking is, is the relay valid? Did this action on l two happen? If yes, let me do something on L One. What is that thing that happens on L One? That thing that happens on L One is I as a user, get my funds immediately, and so you don't have to wait the seven day roll up time for the optimistic roll up to resolve. And what we're saying here with across is I'll front someone the money take on the seven day risk and give the user their funds now and I'll charge a small fee for that and that risk allows people to relay out of L2 really quickly while some liquidity providers take that seven day risk. It's a really efficient protocol.
00:23:58.976 - 00:25:02.090, Speaker A: I'd highly recommend if you're using L two S, give that a try. Synthetic tokens fox. What was the price of a Fox token? We created a fundraising contract, the LSP contract that we're using for the demo. We also use that to create a success token for Fox where they basically use that to hand a tokenized payout function to their investors that if the Fox token rallied while the investor was part of the fundraising round or the vesting schedule, that the investor would get more tokens, a way to tokenize that incentive. And so really aligned the incentives between investor and the shapeshift dao quite nicely. And another one is what was Boba's TVL? Right? You can create a KPI option that pays out double the amount of rewards if Boba's TVL triples or quadruples in that period of time. And all of these are actually real life use cases that we have articles talking about.
00:25:02.090 - 00:25:40.340, Speaker A: Another plug here is we're growing our team's looking for a lot of talent. You can apply for any position and we'd welcome anyone to kind of join our team. We're super global decentralized, looking for just really smart people to come on board. These roles that we have here are like our most pressing ones. So highly recommend if you have skills in that area to take a look. One of the things that is quite interesting to talk about here is that we're not necessarily wanting to poach from anyone or if you want your own project, that's perfectly fine. We're willing to support you in any way.
00:25:40.340 - 00:26:30.032, Speaker A: But what I would recommend is that if you have a friend that you think might enjoy a bit of time working for a protocol like uma, we pay out a pretty decent referral program. So you can be sitting here, you have a friend that wants to come into the DeFi space, pass him our way and you could get paid to do that. So, yeah, just have a look at this and it kind of details the QR code takes you to an article that explains our referral program written by our very own Melissa. And yeah, if you want to stay in touch, reach out to me on Twitter. You can visit umaproject.org, and then for the hackathon specifically you can reach out to me on Telegram at chandadk or just use the ETHGlobal discord and tag me and I'll be more than happy to help you with any of your support queries. Cool.
00:26:30.032 - 00:27:39.510, Speaker A: Any questions, guys? Would it be possible to predict something that's constantly changing? For example, if you had a YouTube video number of views that a value activity goes up and down. Would it be possible to implement something like that using Oracle? Yeah. So each request is tied to a time, so prices also change all the time. Right. So how do you find out what the price was at a particular point in time? Each of the requests that come through are time boxed. And so you'd say, what were the YouTube views at that point in time? Right. Now, I'm not sure if you can really look at historical views on YouTube videos, but let's say, for example, you can, and you know that at 03:00 on Tuesday, this video had 10,000 views, but then at 04:00 on Tuesday at 12,000, your request would specifically ask for the timestamp at a point in time.
00:27:39.510 - 00:28:22.704, Speaker A: Yeah, indeed. And I think unless you're like an actual YouTube, I stand under correction because I don't actually know this, but I think only the YouTube channel owner can view the historical data. Right, yeah. And so that's actually a limitation that's worthwhile exploring here, is that if this data, because it's decentralized participation, anyone that wants to partake in it needs to be able to verify the information themselves. So it's like somewhat publicly verifiable. Right. So to ask a question like the YouTube views, depending on if that works, if you can get that data, it's perfectly viable.
00:28:22.704 - 00:28:55.150, Speaker A: If you can't, it doesn't really work. But what you can maybe say is, let's take prices from the top five DeFi assets, bundle them together, and then create some sort of price index and do some calculations on that. Right. So that's something that's possible because you can easily get historical prices from multiple sources. Right. But yeah, it's a good way of thinking of off chain data and how you can bring that on chain. Cool.
00:28:55.150 - 00:29:16.080, Speaker A: All right, thank you. It's.
