00:00:07.530 - 00:00:18.160, Speaker A: Hello, everyone, and welcome to the SuperHack World Calling Workshop global proof of personhood. Joining us today is Ian Dillick, who will be taking us through the session. And with that, I will pass over to Ian to get the session started.
00:00:20.210 - 00:00:38.280, Speaker B: Hi, everyone. Thanks for the introduction. Rory. I'm Ian. I also go by Penrin on online. I do developer relations at WorldCoin. So in this workshop, I'll go through what World ID is, why WorldCoin created it, what you can do with World ID, and how to integrate World ID.
00:00:38.280 - 00:01:48.382, Speaker B: So World ID really helps solve this one big question how do you know who or what is a real and unique person? Right? WorldCoin started out as a project that wanted to help introduce everyone in the world to this digital economy by giving them a little bit of cryptocurrency, and doing that is really tough. You have to know that someone's a real human and that they're only getting their share once. For that, we've built World ID, which recently became publicly available, still in beta, but there's no waitlist anymore. And I'll walk you through a little bit of how we got to where we are. We design World ID to be private, inclusive, and robust. We never ask your name, your email, anything like that with World ID, for it to be inclusive, right, we want to have as many people as possible be able to participate in this global identity solution, and we want it to be robust, making sure that each person can only get a single account. We looked at a lot of different ways to do this, right? A really weak end of the spectrum is using an email or phone number to verify someone.
00:01:48.382 - 00:02:35.630, Speaker B: But having multiple emails and multiple phones is super easy, so it's not robust in that sense. We looked at doing KYC on official government IDs, but that's not inclusive enough. Less than half of the world has a digitally verifiable government ID. We looked at web of trust systems, but they don't scale super well to the scale of all of humanity. Every hop away from that initial trusted set you are reduces the amount of trust you actually have in that web of trust. So we settled on biometrics, which initially sounds a little scary, but we do it in a privacy preserving way. When it comes to the biometrics we used, we looked at fingerprints, palm scans, face scans, but none of those actually had enough entropy to scale to all of humanity.
00:02:35.630 - 00:03:16.410, Speaker B: Face ID and touch ID on your phone can distinguish about one in 30 million people, which is fine when you're trying to make sure that the person in front of the device now is the same as the person who was in front of the device at sign up, right? That one to one matching. But for us, we're checking to make sure that you're unique from everyone else who's ever signed up. This one to N matching requires a much higher level of entropy. And for us, fingerprints, face scans, et cetera, just wouldn't scale to the level that we need. We also looked at DNA, which is really invasive. It's impossible to do that in a privacy preserving way that doesn't tell you a lot about a person. So we settled on iris scans.
00:03:16.410 - 00:03:54.434, Speaker B: The irises have a huge amount of entropy. Even identical twins have very different irises, but also something that can be done in a fairly privacy preserving manner, right? Your attention is required, whereas with face scan, that's something that can be done much more passively. If someone tries to scan your irises and you don't want to, you can close your eyes. So it's something that really leads a lot of what we're looking for when it comes to doing those iris scans. We looked at phone sensors and off the shelf hardware, but neither of those met our requirements. Phone sensors just don't have good enough cameras. Off the shelf hardware is really expensive.
00:03:54.434 - 00:04:27.374, Speaker B: It's difficult to scale. And for us, that meant that we ended up building custom hardware. That custom hardware is the Orb. The Orb has been in development since early 2020 and has gone through multiple different revisions. And what the Orb does is it makes sure that you're a real human, right? You're not a cat or a dog. You're not a photo of a human. It takes photos of your irises and calculates an iris code on the device so that those photos never need to be stored anywhere, and then checks to make sure that iris code is unique.
00:04:27.374 - 00:05:06.014, Speaker B: And at that point, it verifies your World ID. Your World ID is this self custodial identity on your mobile device. It gets verified with different proof of personhood credentials to verify that you're a unique human. World ID is this Global Digital Identity Protocol, somewhat like an Internet passport, and those credentials are somewhat like stamps in that passport. And the two we support right now are the Orb biometric verification as well as verifying with a phone number in World app. So two separate ends of the spectrum there in terms of how strong that proof of personhood is. World ID is privacy first.
00:05:06.014 - 00:05:35.238, Speaker B: As I said, we never collect personal information like your email or your name. It's decentralizing, progressively, and it's open source. All of our smart contracts and everything is available on GitHub today. There's lots of different use cases for World ID. Voting is a great example. You want to make sure that a vote is coming from a unique human, but that each human only gets to vote once. For social media, you want to know that this profile is a real person and not a bot customer.
00:05:35.238 - 00:06:18.680, Speaker B: Incentives are one that I find really fun, because you can give a bigger discount if you have a stronger proof of personhood and know with higher certainty that that person's only going to get that one time sign up discount once, right? I signed up for Netflix with a new email to get that two week free trial multiple times. But World ID can help prevent things like that. We've also designed World ID to be super easy to integrate on a wide variety of platforms. You can use it on the web, on mobile, and on chain. And there's two main ways to integrate World ID sign in with WorldCoin and Anonymous Actions. So let's start with sign in with WorldCoin. Let's see how it works.
00:06:18.680 - 00:07:04.350, Speaker B: So we actually use sign in with WorldCoin to sign to our developer portal here. If I click Login, it takes me to sign in with WorldCoin page. I can scan this QR code either from directly within World app by pressing this button in the top left, or I can just scan it with my phone's QR scanner and it will automatically open up the app. Once it scans, it tells me in the app that I'm trying to sign into the WorldCoin developer portal. I tap verify with World ID and oh, the sign in didn't work. That's unfortunate. Let's try that again and I go through this whole flow again.
00:07:04.350 - 00:07:30.180, Speaker B: That should take me back to the app. Something's broken on our developer portal. That's not great. I'll make sure we get that fixed afterwards. But with siding with WorldCoin, there's a bunch of different ways to actually integrate it into your app. We have an integration with Auth Zero. You can use nextauth JS you can use our OIDC, well known file with a custom authentication engine.
00:07:30.180 - 00:08:12.336, Speaker B: You can build out your own custom OpenID connect flows for really custom use cases. But I'll walk through how you can integrate it with Nextauth JS. This is the configuration for Nextauth JS, where we add WorldCoin as a sign in provider, and we actually just provide this OpenID, well known file from ID Worldcoin.org. We give it the client ID and the client secret for an app that you create in our developer portal. And then we map the information from the profile returned by worldID to Nextauth. And that's all you have to do. Everything else with Nextauth is completely normal.
00:08:12.336 - 00:08:55.008, Speaker B: We also have a template repository available for integrating Next Auth using World ID. And now let's get into anonymous actions. This is a bit more powerful of an integration, it's a bit more customizable. And what most of you in this hackathon will probably be using Anonymous Actions verify that your user is a unique human doing something once, or if you'd like, some limited number of times. You can set that number to be whatever you'd like and optionally with a specific signal. That signal is a message that is integrated into this zero knowledge proof from World ID. It's also optional, but for voting right, that signal can be who you're voting for.
00:08:55.008 - 00:09:28.984, Speaker B: Or if someone's claiming an AirDrop, this can be the wallet address that they're claiming that to. And given that things aren't working. I'll skip a demo for right now just to save myself any further mistakes there but to integrate anonymous actions. It all starts with Idkit, our front end library. The single component that you put in your JavaScript or react front end. There's a couple of different parameters you pass to it. First one is the name of the action a user is performing.
00:09:28.984 - 00:10:36.320, Speaker B: You also have to give it the app ID. Both of those things you configure in our developer portal. There's the on success callback function which is called after the Idkit widget is closed. This is where you can pass the proof returned from Idkit to a call to a function on chain or that can be changing the state in your front end to show the user is verified. Handle verify is a second optional callback function that's mostly useful for when you're using anonymous actions off chain and verifying proofs. With our API, that handleverify function is called immediately after that proof is returned and the widget shows a loading state. Any errors thrown in the handle verify function will be displayed to the user through the widget, which is nice, provides a good way to show an error state, show a user what's gone wrong, say they've verified for an action before or they don't have the required Credential.
00:10:36.320 - 00:11:16.350, Speaker B: In a very pretty way. The Credential types will default to Credentialtype orb. This is also TypeScript if you're using regular JavaScript you would just pass the string orb and or the string phone. And this just shows which verification methods you want to require. Or I should say, which verification methods you want to accept. This example would accept someone who is either phone or or verified. And then finally you have a child component, in this case just a button that allows the user to click and open up the widget and begin the verification process.
00:11:16.350 - 00:12:08.060, Speaker B: This is the proof returned from Idkit. It's also passed as an input to both the on success and handle verify functions. And in here we have the merkel root, the root of the merkel tree, again, which you verify this proof. These merkel roots on chain are essentially the list of identities that have been verified. This nullifier hash is a unique identifier of this user in the context of this action and app. So for a user who tries to perform the same action twice, they will have the same nullifier hash, which is how you can tell that they're trying to perform that action twice. But when a user tries to perform a different action, they'll have a completely different nullifier hash, which is how we keep this privacy preserving and prevent different actions from being correlated back to the same user.
00:12:08.060 - 00:12:43.112, Speaker B: This proof is a very long hexadecimal string. This is the actual proof. And then you get the Credential type that that user has been verified. This returns the highest Credential type. So if they're orb verified, it will return orb, they're only phone verified, it will return phone and if they're verified with both it will also return orb. So we have this proof, but we're not done yet, we have to verify that proof, right? Your user can always manipulate data in your app's front end. So with this proof, there's two ways to verify it.
00:12:43.112 - 00:13:22.788, Speaker B: You can verify it with our API, or you can verify that proof on chain. So to verify it with our API, first you would pass that proof to your app's backend. If you're using Next JS, this is quite simple and we also have a template repository available that shows how you can handle this. And then once you have that proof in your back end, you make a request to Developer Worldcoin.org API v. One. Verifyyourappsid from the developer portal the body of that will include the app ID.
00:13:22.788 - 00:14:37.980, Speaker B: Or, I'm sorry, the app ID is already in the URL. That will include the action name, the merkel root nullifier hash proof the signal if you're using that. Otherwise you should just set the signal as an empty string. And then our back end handles all of the math to verify that proof, everything like that. And we'll respond either with a 200 status code if that's successful, or we'll respond with a 400 code and a brief description of what the error actually is, whether that's that the user has already performed this action, if the user doesn't actually have that credential that they gave to your app's front end. But if you get this 200 response, after the response gets sent, you should then for example set the user is verified in your database, right? Any actions that you want to have occur when you know for sure that that user is actually verified, could happen in your back end again, because in the front end the user can always manipulate that data. If you wanted to verify on chain, we also have template repositories that highlight the on chain verification.
00:14:37.980 - 00:15:20.220, Speaker B: And in the constructor for your smart contract, there's a few things you'll need to set. So the world ID here is the address of the world ID router against which you want to validate. You can find those up to date addresses at docs worldcoin.org reference addressbook, or you can just go to our docs and you'll see it in the navigation on the sidebar. Your app ID and action ID as well combine to form this external nullifier. That is again that scope of uniqueness for these proofs. This is just what SEMA for the zero knowledge proof system that we are built on top of uses.
00:15:20.220 - 00:16:23.744, Speaker B: And for us, if you only have one action that the user is performing in your smart contract, you can set this external nullifier in the constructor. Otherwise you can ask into your function, call the action name and then compute this external nullifier before submitting the proof to our smart contract and then the actual function that your users would call to verify this proof and perform an action can look something like this you'd pass in a signal. In this example we're using a wallet address. Let's say that we are having the user claim an AirDrop pass in the root of the merkel tree, the nullifier hash and the proof. And in this example we make sure the user can only do this once. Because we have a list of nullifier hashes that we've seen before. The first thing we do is check if that nullifier hash is in this list of users that have already performed this action and if so, we revert, otherwise we move on.
00:16:23.744 - 00:17:07.660, Speaker B: We call the verify proof function on the World ID router contract. We pass in the root the Group ID. So the Group ID is one for orb verified users and zero for phone verified users. Generally we don't recommend having phone verifications enabled on chain, so you can also hard code that to one in your constructor. You have to encode and hash the signal so we have a hash to field helper function. Again, you can see that in our template repository that handles hashing things properly using KCAC 256, which is what SEMA four requires. And then additionally the nullifier hash, the external nullifier and the proof.
00:17:07.660 - 00:17:52.510, Speaker B: If this proof verifies properly, this will just continue, if it doesn't, this will revert. So if this doesn't revert, then we can move on. Add that nullifier hash to the list of nullifier hashes that we've seen just to make sure that this user doesn't get to perform this action again. And then once all that's done, this is where you would add in your logic to issue that AirDrop to that user. In SuperHack we have 20K worth of prizes. So five k to best overall, 2500 to the best governance app, the most creative use case, the best AI related use case and the best sign in with WorldCoin app. We have three $1,000 prizes for honorable mentions and I made a typo here.
00:17:52.510 - 00:18:27.850, Speaker B: We have a $2,000 prize pool split among all submissions that properly integrate World ID and don't receive a different prize. If any of these prizes end up not being rewarded, the funds are added to the prize pool. And we have a notion page with lots of different resources. For all of you hackers, you can go to worldcoin.org slash SuperHack that will redirect you to that page. I believe it's also in the WorldCoin section of the SuperHack dashboard. And yeah, now I'm happy to answer any questions that anyone may have.
00:18:28.780 - 00:18:59.070, Speaker A: Awesome. Cheers. Thanks Ian. Yeah. If anybody has any questions, please feel free to take yourself off mute or ask in the chat. And if there are no questions, then of course oh, there was one. Is there any update on on chain verification?
00:19:00.050 - 00:19:16.580, Speaker B: Yes. So the on chain verification has been having issues. We think we've identified what the issue is and the team's working on it and I will make sure to update everyone in the partner world coin channel of the ETH Global Discord. Thanks for checking in on that by the way.
00:19:17.690 - 00:19:27.030, Speaker A: I was going to ask that too, but I thought maybe somebody else might ask it. Let's see curious about the client side configs that we have to remove.
00:19:29.690 - 00:19:38.970, Speaker B: Remove from what exactly? And I guess if you want to are they able to unmute themselves and ask directly or are they limited to chat?
00:19:39.470 - 00:19:41.900, Speaker A: Yeah, they should be able to unmute yourself themselves.
00:19:43.550 - 00:19:45.354, Speaker C: Hello, do you guys hear me?
00:19:45.392 - 00:19:48.142, Speaker B: Hi. Yes, hi.
00:19:48.196 - 00:20:18.550, Speaker C: Good question. I was each Waterloo and my team submission. I really didn't have the chance to speak to you after the submissions, but one of my team members mentioned that in order to properly integrate Worldscoin SDK we had to remove something from a front end or wasn't too sure about what he said, but I thought maybe you have an idea or you can leave me there. Essentially I think it's when you do like verification on the phone on the client.
00:20:20.510 - 00:21:03.140, Speaker B: I'm not sure exactly what this is. It may have been like if you all were sending the API verification request from your front end rather than from your back end, that may have been what it was. Without knowing exactly what project and looking back at the code, I'm not able to respond super directly. But you do have to send that API verification request from your back end because otherwise if it's only from the front end to our API back to your front end, the user can again manipulate that response from our API to make it appear that they're verified even though they're not.
00:21:04.230 - 00:21:06.770, Speaker C: Awesome. Yeah, I think that answers it.
00:21:06.840 - 00:21:55.530, Speaker B: Thank you, Annette. It a security considerations. Yeah. So when using World ID on chain from the World ID side, there's very little information actually passed. I guess the only thing in terms of like a privacy concern that I would consider is that when a user performs different actions that nullifier hash is different, but other information associated with that like the signal right. Their address. In the example that I used, the signal is public.
00:21:55.530 - 00:22:48.890, Speaker B: So if you have a user trying to verify for two different actions and they use the same wallet to perform that, then those two actions would be correlated to the same user. So making sure that's communicated to the user clearly is something that I think is important to do. But the World ID proofs themselves without some other information the users provide can't be correlated to each other and are completely anonymous. We completely separate World ID from the wallet. Within World app, the wallet isn't accessible through the SDK or anything like that. Actually the World app wallet isn't even something that users can connect to DApps at the moment. So for web three development as well, you would need to have users connect a wallet through MetaMask or Wallet Connect or some other method that many DApps use today.
00:22:48.890 - 00:23:00.930, Speaker B: Any other questions?
00:23:13.560 - 00:23:26.200, Speaker A: Yeah, I go in and read this for the recording as well. We were trying to get events every time a group is added in Gorely testnet, but the implementation in Gorely for the World ID smart contract doesn't emit events. Is this the right implementation?
00:23:27.840 - 00:24:56.100, Speaker B: So, Andres, there aren't going to be new groups added, and the information in the World ID implementation that the router routes these things to, it only receives the root of the Merkel Tree bridged from Ethereum Mainnet or for testnets, from Ethereum Gurley. And with those, that merkel tree is essentially a list of the public keys of the World ID identities. But that information isn't useful for anything. The only time that that public key of that identity is revealed is when the user signs up. Everything else is a zero knowledge proof, like every World ID verification is a zero knowledge proof of testing that they are one of the identities within this oracle tree without revealing which one. So, given that monitoring the events on the World ID implementation for new identities being added or anything like that won't actually provide you any valuable information, unfortunately. And if you have any more questions about that, we can chat in the partner WorldCoin channel of the Global Discord.
00:25:04.090 - 00:25:38.670, Speaker A: Anybody else have any other questions? And if not, okay, we can just maybe end it early. Thank you, Ian, for the great workshop, and thank you all for attending. As a reminder, we have the project feedback session in about half an hour, so stay tuned for that and get some feedback from mentors and partners on your current sales of your projects. So cheers. Thanks, Ian. Thanks, everybody, for attending.
00:25:39.250 - 00:25:40.506, Speaker B: Thank you. Bye.
