00:00:00.170 - 00:00:38.434, Speaker A: Shop on how to deploy an app onto our network. I guess I'll start off a little bit about Alio. Alio is a ZK layer, one project. Our main goal is making developing ZK apps easy, abstracting away a lot of the complicated math and cryptography that's required to understand circuits and things of that nature. So we're going to jump pretty much right into the workshop, usually of a bunch of slides and kind of talk a little bit about our programming language instead. I don't have time for that today, so instead I'm going to point you to the docs. So I would recommend checking out Alio.org.
00:00:38.434 - 00:01:16.820, Speaker A: But more importantly, if you're hacking with Alio this week, developer Alio.org. This is kind of all of our documentation, the home of everything. This is where you'll be able to answer your own questions. Also recommend checking out our Discord, which you can find links to from the main site Alio.org. If you scroll down, you'll find links to Discord, Twitter, YouTube, et cetera. There's a large community of over 200,000 people building on Alio that you can check out. Shout out to Eugene, who is very helpful in managing that community.
00:01:16.820 - 00:01:48.878, Speaker A: So with that, we're just going to jump right into it. If you want to follow along, you can also you could just watch me and follow along and do this on your own time afterwards. We do have $100 incentive if you successfully deploy an app. So that's like a quick way to earn $100, walk away from the hackathon a winner, even if you don't win any other bounty. So I'm just going to run through this. It's super easy. The nice thing is, regardless of how complex your app is, deployment doesn't really change.
00:01:48.878 - 00:02:05.922, Speaker A: So once you kind of have this down, you won't ever have to learn how to do it again. There's some software you have to install. Git. Of course. Rust. The whole stack that we use is open source, and it's all built on Rust. Highly recommend.
00:02:05.922 - 00:02:53.614, Speaker A: If you're a Rust developer, you go check it out, contribute, et cetera. So then the most important things you have to stall here are our Leo programming language, which is a high level language that looks a little bit like TypeScript or Rust, and it compiles ultimately down into ZK circuits. If you're curious about that, you can read the docs or come and find me after this talk, and we can talk a little bit more about that. You also want to install Snark OS. There's some instructions on how to do that. If you're on a Windows machine, please go check out this FAQ, and I have some instructions. You need to install LLVM and some other prerequisites in order to get that installation to work, and it can be kind of a pain if you're on Mac.
00:02:53.614 - 00:03:11.530, Speaker A: Don't worry about it. Everything will work smoothly, I promise. I would also recommend you install the Leo wallet. It looks a little something like this. It's a chrome extension. You'll be using it in the tutorial. And it's also the easiest way to interact with your account and records on chain.
00:03:11.530 - 00:03:44.340, Speaker A: So let's get into it. I'm going to be using Vs code for everything that I do today. You can use whatever editor you want. We have Leo plugins for most of the major editors out there, including Sublime, IntelliJ, Vs code, et cetera. All right, so I have the Repo cloned here. You'll see a file structure that looks a little something like this. Just going to make this bigger for you guys.
00:03:44.340 - 00:04:11.130, Speaker A: This is the private key to my workshop wallet. If you want to steal my tokens, be my guest. We are in Testnet right now. We are looking to launch Mainnet sometime in December. So definitely look out for that. In the meantime, check out the network, deploy an app, try to build something. We encourage anybody building stuff who's interested in doing ZK.
00:04:11.130 - 00:04:47.730, Speaker A: So first and foremost, I'll introduce Leo. Normally I'd spend quite a bit of time talking about our programming language before getting into this demo, but I don't have time for that today. So I'm just going to jump right into it. This probably looks pretty familiar to you. Like I said, if you've used TypeScript, if you've used Rust, this is a function type called a transition. One important thing to note about Alio and kind of one of the reasons why we decided to go with a layer one, instead of building an EVM based layer. Two is we have a different infrastructure setup than most of the EVM.
00:04:47.730 - 00:05:23.890, Speaker A: Primarily there's two infrastructure players. We have Validators, which validate things like you're probably used to, but we also have another infrastructure layer called Approver. And the main goal of Provers is to execute transactions off chain, roll them up into a proof, and submit them to Validators. What this enables is quite a few useful things. One is that we have fixed gas prices so you're not paying a congestion fee in order to fight for block space. That's not something that exists in our paradigm. So a read always costs what a read costs, and a write always costs what a write costs.
00:05:23.890 - 00:06:14.162, Speaker A: Also, because of this, we have privacy by default. So you actually have to explicitly mark a variable as public. And so transition functions primarily, the main point there is anything in a transition function is going to be executed by Approver. There's also another function type that I can show you. I'm going to jump into the playground here and we're going to show you a token example real quick just to show off a finalized function. So if you're doing public things, finalized functions are executed by Validators and that is the way to handle public state. Typically you'd use a mapping, mappings work like any other hash, map or similar data structures that you might be used to.
00:06:14.162 - 00:06:55.786, Speaker A: The key difference here is that mappings are on Chain State. So you can use those to look up anything that you want to be public. And anything that is not public, you would deal with a record type records, have an owner they're encrypted and they can only be decrypted by whatever private key has encrypted them on Chain. I highly recommend checking out the playground if you want to see some more complete examples than what I'll be able to get through today. That's at play. Leo lang.org And you can also find this information on the main website as well by going Alio.org.
00:06:55.786 - 00:07:35.130, Speaker A: And if you go to Build, there's links to all of the stuff that I'm mentioning as well as our grants program, which is something that my team runs. If you're interested in building and getting a grant to build, definitely come talk to me and we can talk about your idea. So with that, back to the workshop. How do we deploy an app on the network? So first we've installed all of our software. We need to create a new wallet. Two ways to do that, there's a CLI that you can use to do that or you can use the Leo Wallet extension like I showed you here. You'll follow a typical seed phrase setup process and you'll have a wallet.
00:07:35.130 - 00:08:07.880, Speaker A: And then you can use our faucet to get some tokens. The faucet will prompt you with a QR code. You scan it, you send a text to our faucet bot and it'll send you some tokens if you don't have a US phone number. Currently we're using Twilio, which is pretty limited as far as what countries that they've implemented. Just come and find me and I'll get you some tokens so you can follow along with the demo. So jumping back into it, first thing we're going to do is initialize our project. So we can do that by running Leo New.
00:08:07.880 - 00:08:17.610, Speaker A: And in this case, we have this weird random string here so that our project name is Unique. The global package manager requires a unique project.
00:08:17.680 - 00:08:18.010, Speaker B: ID.
00:08:18.080 - 00:08:50.886, Speaker A: So this is just a way for me to increase the likelihood that we have. So I'm going to go Leo New. I'm just going to paste this in here, have a new project. Cool. You'll see, our directory looks like this and then we can write our program. I've provided a very basic token example here. You can just copy paste this and check it out.
00:08:50.886 - 00:09:32.286, Speaker A: Like I said, check out the examples for more complicated code or for more syntax examples and kind of more of the language features. We're really just focused on how to deploy today. So I'm just going to go ahead and open up that new directory that I just created because I personally prefer working in Vs code. And we have three different types of files here that are important. One is our main file. So this is kind of the Hello World app for Alio. We can build it, and it'll output an intermediate representation called alio.
00:09:32.286 - 00:10:11.520, Speaker A: This looks like any assembly language that you've probably seen. The reason why this exists is because we're not executing on an X 86 execution environment or even an EVM execution environment. We're compiling down into circuits, which is kind of a new execution paradigm. So in order to abstract all of that complicated detail away, we've had to completely build language from scratch. You've probably heard of other projects like Noir or Aztec or Circom is another example of this kind of thing. So let's take our token example, and we're going to paste it into here. I'm going to build it.
00:10:11.520 - 00:10:51.790, Speaker A: Looks like we have an error, right? So the last file that I did not talk about is an input file in a ZK circuit. They're deterministic. And so you actually need to in order to build your circuit, you need to have your input. And with that, the way that we currently provide inputs to programs, at least locally, is with this input file. And so I have an example of this input file here that you can copy, and then we should be able to build our program. Looks like I'm missing a semicolon, or I have an extra one. Cool.
00:10:51.790 - 00:11:32.870, Speaker A: So now if we went back to our instructions, we can see that our two functions that we just defined are here. We have a Mint function, which is fairly straightforward. We take this token record and we return it, which will, if we run it, Leo, run Mint, we'll see that it outputs on chain. This would be encrypted because I'm running everything locally with my own private key. Of course, I can see what's going on here. And so if we wanted to transfer a token to another address, one important thing to note about Alio is that we don't work on the account model. You might have heard of UTXO.
00:11:32.870 - 00:12:10.760, Speaker A: We have a model that's more similar to UTXO called the record model. And so in order to execute a transaction, you need to spend a record, which means you need to input a record to a transaction, which would typically output a record as well. There is also a default record type on the network that I will show you in a few minutes once we get to the deploy example. So we want to run transfer. We want to simulate transferring from the tokens. We just minted this record to another wallet. And so I'm going to take this token record that we just output in the console and paste it in here.
00:12:10.760 - 00:12:45.666, Speaker A: We have to remove these suffixes. That's just kind of an annoyance right now. It's not an important detail. And so with that, we can run a transfer function. And if we look at our transfer function before we run it, you'll see we actually output a tuple of records, right? So we calculate the new balance. We create a record for the recipient and the transfer amount that we're interested in. And we also need to make a new record because we're spending the existing one that the sender is providing where the tokens are.
00:12:45.666 - 00:13:23.706, Speaker A: So if we run this, we'll see we have an output. Our program works. We've transferred ten tokens to this address, and the original sender now only has 90 tokens. So that was this part here, build and test. Just kind of an example to show you how you can run and build and work on programs. So I mentioned the record, right? If we want to submit a deploy transaction, we need to pay for it, and we need to spend a record to do that. One easy way to get a record is to go into your Leo wallet and check out your most recent activity.
00:13:23.706 - 00:13:59.626, Speaker A: So this is a transaction that I made a couple of weeks ago to put some credits into this wallet. We jump into the output of this transition, and one important thing to note is that this is completely encrypted. You see the ciphertext here. If you are some other user, you can't see what happened in this transaction. But because I own this record, I can connect my wallet, I can decrypt it, and I can get the record plain text. And this is what I'm going to be using to tell the deploy program. What record am I talking about? Let me make this bigger for you guys.
00:13:59.626 - 00:14:50.780, Speaker A: What record am I talking about? How many credits are in this record to be spent and announce as well? So I'm going to create a deploy Sh file just to keep things nice and repeatable. So I'm going to copy this long command, which this is a deploy command here. Snark OS is a utility that you'll install following through this workshop and provides a bunch of CLI utilities to interact with the chain as well. If you want to run a node or approver, you'd use Snark OS to do that. So we're going to grab that private key that I said you can steal from earlier. I'm going to paste that in here. I'm going to take my project name, which is going to be my package name on chain, and we're going to run this.
00:14:50.780 - 00:15:30.640, Speaker A: And I forgot something. So that record that I mentioned was super important. I forgot that. So let's go and grab that real quick. So we'll run this deployment. I'm fairly confident that it'll go through successfully, and then we could check out our program in Explorer once we have our transition ID. Oh, input record must belong to signer.
00:15:30.640 - 00:16:08.350, Speaker A: Usually this happens this error message is not super descriptive. Usually this happens when the private key is not the same as the one that we're trying to send. So let's get this private key real quick and just double verify it was wrong. And so now that our private key is correct, you saw here that if you tried to spend a record that wasn't yours. It just doesn't work. You can't decrypt it so you can't use it. 1 second.
00:16:08.350 - 00:16:33.468, Speaker A: I'm going to leave some time for questions at the end. Yeah, we'll be done in about a minute, once this finishes. Thanks. There's a couple of explorers out there. This is one, it's open source. This very wonderful community contributor named Haruka. Big shout out to him.
00:16:33.468 - 00:17:09.000, Speaker A: Just built this on his own. We tried to give him money, he didn't want any, so yeah, guy's kind of awesome. There's another one out there called Alio. One, two, three, IO. It's a little newer, it's a little fancier like it has kind of a prettier UI. They both have some differences in features. So if we go back to our deployment, you'll see it was successful, we can take this transaction ID and check it out on the Explorer and we'll see our program here was successfully deployed and actually we can jump into our program and see our source code on chain.
00:17:09.000 - 00:17:31.870, Speaker A: So we just privately deployed an app that implements a very basic private token with private minting and private transfers, all in 17 minutes or so. And so that's it for the workshop. Super quick, super fast. Please come to me with any questions. I'm going to take some questions that we have time for and then I'll be available afterwards for one on one.
00:17:35.520 - 00:17:36.270, Speaker B: For.
00:17:50.280 - 00:18:29.988, Speaker A: There'S a bunch of APIs available as well as command line utilities and a JavaScript SDK. You'll find more information about that on the docs and if you check out our GitHub repositories. So one thing I do want to point out is that if you follow through with this workshop and you successfully deploy, you can submit and check out this QR code here, which I'm working on sending to everyone. You can earn $100 just for deploying this very simple program. As you saw, it took me about ten minutes. So probably the fastest $100 you'll earn this weekend. We have another question, I think.
00:18:29.988 - 00:19:09.624, Speaker A: Yeah, so we do do that. Yeah. So the question was about detecting arithmetic. underflows and overflows is quite difficult in a ZK circuit environment. And he asked, how are we doing that? My answer might not be the one you're looking for. I actually don't know the exact details. I know that we do do that because I've written a program that has the capability for an overflow and so I think it's actually checked at the compiler level.
00:19:09.624 - 00:20:12.726, Speaker A: If there's any code that can result in an overflow or underflow, you can't compile the program at all. That's my current understanding. When you try to execute it with a certain set of inputs, it'll warn you, correct? That's how it works. Currently the language is under development, of course, so if that's something that you feel is a bad developer experience, I'd highly recommend submitting an issue or creating a discussion in the community. All so the proving system we're using is based off of Marlin. It's a snark based system. I don't have time to answer this exact question, but you can find more information in the docs.
00:20:12.726 - 00:20:25.760, Speaker A: That's where I'd point you first. And I can also connect you with people who know a little bit more about the deep internals of the cryptography if you're interested. Cool. Well, thank you very much everybody. Really appreciate your time.
00:22:18.990 - 00:22:47.026, Speaker C: Can you all hear me? Awesome. My name is Julian Junistu. I'm the CEO and founder at unlock protocol. And today I'm going to show you, I mean make a quick introduction of what unlock is and then if we have enough time, we'll do a live coding session. Usually go very fast, but I'll point to the GitHub as well, so you can use this. So first quick agenda, unlock protocol overview. Then we'll jump into some dev tools, all of our ecosystem of tools.
00:22:47.026 - 00:23:16.746, Speaker C: Then how to add unlock to a front end use case. And again, that's the live coding session. Then more about smart contracts, about hooks, about UI, and finally a bunch of links that you can use for your hacks tonight, tomorrow, and obviously, hopefully you'll win the hackathon on Sunday. Somebody is very kindly distributing a little liftlet with QR codes on this with links to the docs, et cetera. So please use that. My name is Julian. I am the cu and founder at unlock protocol.
00:23:16.746 - 00:23:40.274, Speaker C: I am French. Prior to unlock, I was the founder of a company called Superfeeder, which was sold to medium, the blogging platform. I still think people know what medium is. In 2016, I'm a big open source fan. I worked with WD three C World Wide Web Consortium. People don't know what it is usually in that space, but that's basically people that actually normalize or write the spec of how the internet should work. It's fun, but it's annoying.
00:23:40.274 - 00:24:07.520, Speaker C: And I'm also a member of the graph Council, which is their kind of dow governance thing. You can find me as Julian 51 on all of the things. Yes, all of the prior 50s were taken. Or use my blog@uvrabwat.com, which is token gated by the way. And if you get a membership to read some of my posts, it's $5 a month, a year, cheap. Let me know and then I'll pay coffee when we meet in person.
00:24:07.520 - 00:24:52.734, Speaker C: What is unlock protocol? Unlock Protocol is a protocol for memberships. Simply speaking, it's a system to create membership and sell access NFTs in minutes within your apps, within your content, et cetera, et cetera. It is used for memberships, like a gym membership, a club membership is used for subscription, like your Netflix account could be, should be, will eventually be. An NFT can be used for ticketing. A ticket to a conference, a ticket to an event is an NFT that gives you access to physical space. It's used for what we call token gating, and that's what we'll see in a couple minutes. But also for things like certification, your degrees, your driving license should be NFTs that have an expiration date, or maybe not actually your diploma is forever, but your driving license expires every five years.
00:24:52.734 - 00:25:30.170, Speaker C: I think in the US I should know this because I have one, but also it can be used for gaming. So for example, you can unlock a certain level that you can access for a day, a week, a month, et cetera, et cetera. It is obviously fully open source. So all of the code that we've ever written at Unlock is open and ready for your inspection. I guess it's also community governed. We have a dow with people that are participating and contributing new code, new updates every day at this point, a bunch of apps, a bunch of libraries and a bunch of DevTools and then we'll go into that in a couple of minutes. We have a pretty diverse team of people.
00:25:30.170 - 00:25:56.834, Speaker C: Again me, but also people from Facebook, OOH, the evil people from GoDaddy and a bunch of other organizations. So wait, I talked about NFT membership. Any NFT could work. Well no, because most NFTs were not built to be memberships. They are built to be collectibles. And so for example, they're perpetual if you're a business and you sell regular NFTs to make revenue. Well I've got some good news.
00:25:56.834 - 00:26:32.222, Speaker C: You're going to make some money maybe on the first couple of days, but then you will never ever sell more NFTs. You can hope on royalties, but as we hopefully by now all know, royalties are a lie. They actually are not enforceable. So there is no way your business can make money on an ongoing recurring way. Well that's why we've created kind of a new kind of NFTs, their ERC 721 that have an expiration date to allow to have kind of time bound NFTs. So NFTs that are valid only for a certain time, that allows you to do for example, recurring revenue where you can say, okay, the NFTs expire every month unless the user, the owner of the NFT pays a bit more every month. And again, Netflix account, that's how they work.
00:26:32.222 - 00:27:05.606, Speaker C: Basically you pay every month. I think now it's almost $15, but you pay $10 a month for it to be renewed and extended for another month. And when you stop paying, well, the account actually expires. It is also Unlock has been built so that it can support multiple payment mechanism, obviously crypto payments. So native currencies on all of the chain that we're deployed on at this point it's on twelve different EVM networks. We'll talk about this in a couple of minutes. But also you can use any ERC 20 token so you can say hey, I actually don't want to be paid in Matic or in ETH because these are fluctuating currencies.
00:27:05.606 - 00:27:49.894, Speaker C: I'd rather be paid in USDC, in Dai, in Euroc, in any ERC 20. That is absolutely possible. It has a mechanism to do on chain verification. That's the normal NFT verification, but also off chain, where we have a mechanism for owners of NFT to sign it and provide that signature in the form of a QR code, for example, that anyone can scan to verify that indeed the owner of the NFT signed and still owns the NFT. They can be made transferable or non transferable, as we call them, soul bound in that space. But I think more importantly, they can also be programmatically transferable. So maybe allow transfers if the user does something or unless something else is true.
00:27:49.894 - 00:28:28.894, Speaker C: And obviously we go from a model where all of the NFT contracts are immutable, they're put out there, and if there's any issue in them, well, too bad, they're there forever, to something that becomes programmable or upgradable in a way that allows developers like yourself change the behavior of the contract. So you might say, okay, at first I will not allow refunds, but maybe after a couple of years I will allow refunds. And it is possible to keep the same contract without having to remint everything and say, hey, these NFTs, initially they were not refundable, now they are refundable. So far so good. So unlock. I was just alluding to this a couple of seconds updatable. You can change all of the properties of the membership contract.
00:28:28.894 - 00:29:02.350, Speaker C: So including the price, including the duration, you go from maybe a month long membership to something that is a quarterly based membership. You can change the price from something that is like $5 a month to $7 a month Netflix. You can go from a limited supply to a larger supply. You can go from having only one manager for the contract to multiple managers, which could be apps that can change how these memberships work, et cetera, et cetera. They're also, as I said, upgradable. So the protocol itself is on, I think, version eleven. I should know this as well, but we're just about to move to a new version.
00:29:02.350 - 00:29:50.874, Speaker C: And that means that when the protocol has new features, maybe support for things that it didn't have earlier, you can decide to opt in for these new features of the protocol. You cannot upgrade to a random version, otherwise it doesn't become standard anymore. You can only upgrade to version that have been community approved by the Dao. And finally, and maybe this is one of the interesting part for you guys, the smart contract themselves are programmable through the concept of hooks. So you can change how the contract behaves based on some custom logic. So for example, one thing that people always ask is like, hey, can I do something where maybe the price of the NFTs change based on how many have been sold? And you can actually absolutely do that with the hooks. So you can have a system where maybe the price at first is one USDC, and then every time somebody buys, you double that.
00:29:50.874 - 00:30:34.874, Speaker C: And so obviously that's going to get very expensive very quickly in a programmatic way. So you don't actually have to go manually poke the contract to change the contract. Somebody buys, price goes up, somebody buys, price goes up, et cetera, et cetera. Key Use Cases event Ticketing so there's been a ton of events that have used unlock for ticketing, including actually some East Global hackathon a few years back, recurring subscriptions or actually EBCC as well. If you guys were in Paris, I know East Mexico, East Vietnam happening in next couple of weeks are using unlock for ticketing. You can do recurring subscription. I mentioned Netflix, but there is many at this point I'd say a good 20 different website that are using unlock for monetizing blogs or video content in a recurring way.
00:30:34.874 - 00:31:03.138, Speaker C: So you pay every month and your NFT gets extended and you can keep access. Time based membership. We have seen a few Dows use unlock for this where they have a seasonal approach. We say okay, these membership are valid for three months, at the end of the three months they expire and they're not automatically renewed. But that's kind of seasons to make sure that the Dao has active memberships. We have certification and credentials. So we have a company that is using unlock to recertify its financial advisors every year.
00:31:03.138 - 00:31:47.170, Speaker C: So basically they give them an NFT that they cannot transfer. Obviously they give them an NFT that shows that they've been certified and at the end of the year it expires unless the person who was certified actually recertifies by going through some online presentation, et cetera, used for gaming as well. There has been a couple of games that have used unlock for different things. So either unlocking levels or unlocking different capabilities for their players used also for loyalty. We have a platform called Chasm, I don't know if you guys have heard it, but they're building kind of loyalty program like your Starbucks kind of loyalty thing on top of unlock. And that's another example, attendance NFTs, sometimes called Poaps. People used unlock for this.
00:31:47.170 - 00:32:30.942, Speaker C: And also my least favorite category, the digital collectibles, the PFPs and all of the NFT crap that hopefully is on the way out at this point. Let's go a bit deeper into a specific use case. So event ticketing, I mentioned a few conferences. What's interesting here is like 100% of the crypto payment goes to the organizers which is pretty cool. It is end to end tickets. So you're actually not buying through a platform, you're actually buying through the smart contract as an attendee and then the organizers of the conference can decide whether they want to allow people to resell their tickets or not, which I think is pretty powerful. But you can also create and for me that's the power of blockchain interoperable experiences beyond just the event itself.
00:32:30.942 - 00:33:00.118, Speaker C: So you can say hey, maybe before the conference anybody was bought a ticket, they have an NFT. Well. You know what, I'm going to use Snapshot. You guys are familiar with Snapshot, yes? No? Snapshot is a voting system. Snapshot.org, pretty cool thing off chain voting but you can make it so that only people that have a ticket to the conference can vote on what is going to be the food or who's going to be the main speaker, which I think is cool. You can also create maybe token gated channels on Warpcast Forecaster.
00:33:00.118 - 00:33:39.810, Speaker C: People know Warp Forecaster maybe know about social networks and only participants, only attendees of the conference are able to participate. Which I think is another cool example of how this membership goes beyond just hey, you only have a ticket to go attend the thing. Now you have an NFT that gives you access to many different things across the web. Sorry for hitting the mic here. Tickets act as a membership and card to connect with the community of people that have the same obviously NFTs in their wallets. Example a couple of weeks ago, dapcon in Berlin actually that was last weekend, feels like forever. Nearly a thousand attendees all using unlock for ticketing.
00:33:39.810 - 00:34:20.494, Speaker C: I'll spare you some of the details but yeah, basically if you buy the NFT you get a QR code as well which you can show to the organizers and prove that you have a ticket. Also people got swag through the NFT which is really cool. Like the sponsors were able to AirDrop other NFTs and a bunch of other things to the attendees of the conference and knowing that they're only the attendees of the conference because they had the NFT that proved that they had a ticket. Another key use case of the protocol is subscription. So token able and experiences. I mentioned my blog a couple of minutes ago but again there's about a 20 different website that you do that at this point. And what's really interesting is for these businesses it creates ongoing recurring revenue.
00:34:20.494 - 00:34:59.322, Speaker C: So think of like a patreon or a substac like model where as a creator instead of selling one off things and then hope that I'm going to be able to sell more and more of these. I can just tell my fans, hey, you guys are interested in following my content. Why do don't you pay every week, every month, every day to get some of that content? We support, as I said, both crypto and credit card. We have an integration with Stripe as well as an integration with Cross Mint which make this really easy. So direct relationship between the creators and the members. No way somebody can say hey, your content is not good enough or your content is too adults for my platform, I'll kick you out. No middlemen and that applies to content, to software.
00:34:59.322 - 00:35:33.718, Speaker C: Think of like inapp purchase. I'm sure you all have mobile phones you might have in app purchases in this. Well, they're currently records in a database either at Apple's or Google servers. You can make them NFTs and say, hey, if the user has an NFT in their wallet, I'll show them dark mode or whatever is the feature that I want to token gate or not inside of my app. So really kind of creating kind of permissionless app stores is a really cool idea here. Any question? No, so far so good. An example here we have a community member.
00:35:33.718 - 00:36:06.866, Speaker C: I mentioned one of these 20 guys, but actually don't know if they're guys DFI robots. They're providing trading tips via their Telegram bots and you cannot access the Telegram groups unless you have one of their NFDS. They're fairly expensive NFDS, I think like something like $200 a month or something like this. Actually $100.03 days and then $200 a month. But that's a cool example of using unlock for that. I have three more minutes, so it's going to be really short time membership.
00:36:06.866 - 00:36:19.100, Speaker C: Let's skip that example. Cabin. Dao people know cabin. Cabin is kind of a club for people that are cool and want to hang out together in the forest. They're using unlock for memberships. Definitely very cool. Use case here.
00:36:19.100 - 00:36:49.202, Speaker C: Going back to the key Use Cases ecosystem and tooling. So we have a dashboard, obviously a front end where you can use to deploy, inspect your contract, do a bunch of things. This is completely optional, obviously. The front end itself is just a front end. You can replace with your Block Explorer of choice or an application that you build yourself. You can use that to change the characteristics of your block, of your block of your contract, as well as do some things like AirDrop membership and others. I would definitely invite you to check that out if you get started.
00:36:49.202 - 00:37:26.990, Speaker C: It's the easiest way. We also have a Checkout UI, which is an easy way for people who don't want to build kind of the whole checkout flow, say hey, all right, cool, I want to enable credit card, I just check a bunch of boxes and then users are going through that checkout UI. And as I said, we support multiple types of payment. We also have Developer Tooling, so subgraphs, hopefully you guys are familiar with subgraphs, but it's basically a way to aggregate a bunch of information coming from chains. We have a JavaScript library called Unlock JS. We have a Paywall, which is actually that Checkout UI that I just described, as well as hooks at the contract level. So we also have web hooks, but these are smart contract hooks that allow you to alter how the contracts behave.
00:37:26.990 - 00:37:44.710, Speaker C: Multiple types of integration. Anything that works with Neos 721, which is one of these two NFT specification, will work great with unlock. So framework like ethers. Third web three, JS wagme. You name them. VM I think is the new hot thing. You can just use unlock there.
00:37:44.710 - 00:38:22.846, Speaker C: We also have integration with platforms like Magic, like Privy, like Stripe, Superfluid. I mentioned all of these again, feel free to ping us on Discord to get more typical protocol ecosystem thing. I'm not going to have time to show you the live coding, but I'll share the link in our Discord. Basically it's a random blog that you can read content on and really with less than 50 lines of code, you can create a token gate that basically requires users to connect their wallets, prove that they have an NFT. If they do, they can read the content. If they don't, they're prompted to purchase one of these so they can read this. Again, pretty basic.
00:38:22.846 - 00:38:58.426, Speaker C: And the unlock specific part here is I'd say five lines. Everything else is like normal wagme and web three or sorry, Ethers JavaScript that allows you to add the blockchain to your web app. There's a YouTube video as well, so if you're not tired of hearing me, you can actually watch me do that demo live. I've done it on multiple hackathons. Oops, sorry. Don't play, don't play. We also have a quick way to do token gating on the back end so your Rails Django, whatever node JS application can do token gating on the back end.
00:38:58.426 - 00:39:16.130, Speaker C: So no need for you to just do front end token gating. The mechanism is pretty much the same. Ask the user to connect the wallet, ask them to sign a message, verify the signature of the message on the backend. Check whether the signer of the message has an NFT. If they do, great, you serve their content. If they don't, nope, you don't serve their content. That's really, really basic.
00:39:16.130 - 00:39:52.618, Speaker C: We also have a mechanism to create a bonding curve. The thing that I described earlier where the price of the NFTs go up every time somebody purchased one. You can also make cool stuff where price goes down if nobody has purchased in a while, et cetera, et cetera. We have multiple types of hooks that can be called and can be used to again change the behavior of the app. One really fun one is the on token uri hook. It's a way to kind of change the metadata that the NFT is serving or the NFT contract is serving when somebody is querying it. So you can make these dynamic NFTs that basically look different based on the hour of the day, et cetera.
00:39:52.618 - 00:40:36.374, Speaker C: I just got a stop sign, so I'm going to just move on quickly to the last slide. Oh, actually if you want to add unlock membership to your so if you want to add monetization to your app this weekend, definitely use unlock. You should do that and think about how to make money. You'll also maybe win a prize and you can scan that QR code to get to our YouTube page where there's a ton of me and a bunch of other people as well. If you are interested in hacking on top of unlock, we also have a booth, so please stop by. There another QR code and they're all on the papers that we just distributed as well. And we're available on Discord.
00:40:36.374 - 00:40:46.540, Speaker C: This time is not on the paper. So please scan that one if you just need to take one picture. All right, thank you very much, everyone.
00:40:47.390 - 00:41:55.020, Speaker A: Thank it.
00:42:52.940 - 00:43:00.670, Speaker B: Know how to use the wire internet? Never mind, it's fine. Let me see the thing.
00:43:05.760 - 00:43:06.510, Speaker A: Okay.
00:43:07.200 - 00:43:07.950, Speaker C: Yeah.
00:43:09.680 - 00:43:10.430, Speaker D: Okay.
00:43:12.320 - 00:43:36.150, Speaker B: So let me start here. Ready? Can you hear me? Yeah. Hello everyone. My name is Boris Polania. I work for near Devop. We're basically near the developer Dao, and I will talk about today, about the boss. So let's talk a little about that.
00:43:36.150 - 00:44:29.430, Speaker B: The blockchain operating system is basically a common layer for browsing and discovery web experiences, right? What this means is this is a decentralized front end platform. It's like instead of deploying to Versaille or whatever, you just deploy here. It's 100% decentralized. So you cannot be censored, you cannot be taken down and is based on react components. And that's basically what the boss actually does. So I will show a little the technology stack here. So the Boss is like the base layer and you can use any blockchain on the back end.
00:44:29.430 - 00:45:13.232, Speaker B: It doesn't have to be near. You can connect to Ethereum or any EVM compatible that can be called through either JS. And then you can have the data platform, the discovery platform, and your components that you develop, they sit on top. So what is a component? Basically, these are small applications and you develop and react like and once you develop, you just deploy it to Boss, and the boss do the composing. So you can basically put it available on the network. There are so many dev tools. We have the Ides, we have the open source, we have the documentation.
00:45:13.232 - 00:45:43.560, Speaker B: And that's where I'm heading now. So let me see. Oh, let's talk a little about the hackathon. We have a $10,000 bounties, $10,000 in bounties. We have one first place of one, two second places of two, and three second places, third places of one. The only thing you need to do is to deploy a component in Boss. The back end doesn't have to be near, just the component has to be deployed on Boss.
00:45:43.560 - 00:45:57.700, Speaker B: I will show a couple of samples later of components deploy on Boss with the back end, on near, with the near as Smart contracts, or with components based on deploy in other blockchains in Ethereum.
00:45:58.200 - 00:45:58.660, Speaker A: Okay?
00:45:58.730 - 00:46:52.672, Speaker B: So first I will give you a general architecture of how a Boss application works. So the main component is the website. And then you will have multiple components, right? In this specific image, the text box is called the components widget, the time ago widget, the command everything is a widget, right? So that's how you create your website on your front end, on Boss, I will go a little more, so I will show you a little more. The basic widgets we have created some widgets so you can easily use for everyone. So the basic widget, this one is easy to see. As you see, it's just declaring some variables. This is running on, boss.
00:46:52.672 - 00:47:28.956, Speaker B: What you're seeing here, this is running on Boss, right? So you just create some variables and then you call it the same way you will call Information or in React, right? So if we change the Anna for Boris, it will update automatically. So this is the kind of widgets you can develop. This is very basic. I will show later. Everything that is deployed in Boss is open source and can be forked. So these are just the basic we created when we developed the documentation. So we have an image of loader.
00:47:28.956 - 00:47:57.716, Speaker B: We have one that manages markdown overlays. Let me show you how the overlays. So basically this standard overlays. So you will see more. But these are the basic ones. But I don't have much time, so I want to go to the basic. How do you actually deploy component in Boss? Right? So you will let me see in the documentation, you will see if you want to get the links.
00:47:57.716 - 00:48:21.404, Speaker B: You will get the links to the online Ides or the local Ides. So we have online IDs. Let me remove this. So this is basically you can code your component on the left side and then you can see the preview of what you're doing. It's very easy, very standard. So that's it. And when you're ready, you just go ahead and publish.
00:48:21.404 - 00:48:39.510, Speaker B: You click here and publish. It will show you the transaction. You will save data. Since I didn't change data, it won't ask for gas. But if I were to change, I'll show you later. It will ask for gas. For gas, as you know, near is a layer one.
00:48:39.510 - 00:49:14.332, Speaker B: It's very low gas, very fast. So it will cost way less than a cent to deploy. It depends on the size. But many of the basic components you will do at the beginning will be very low gas. But you can also use your local IDE, right? You can use Visual Studio or you can for example use, I don't know cursor. So let me show you how. You just need to install the plugin.
00:49:14.332 - 00:50:02.272, Speaker B: You just find it and it's there either in Course or in Vs. And you just create a new global New York JSX. You put it there. Let's take some basic Boss, some basic code here. So we start somewhere, put it here and then let's ask the Chat GPT to, I don't know, add a drop down drop down, drop down menu. We wait for it and then you just wait for it. Sorry about that.
00:50:02.272 - 00:50:24.916, Speaker B: So you just copy paste it or whatever you want to do. Or you can cut it yourself, whatever. So you put it here, you save it and you publish it. You can cancel. You can see the preview here in the same you will see it here and then you just go ahead and publish the component here. It's a new component. It will ask for gas.
00:50:24.916 - 00:51:02.224, Speaker B: So you will have to have a near wallet or my near wallet. They are very easy to set up, standard wallets, nothing crazy there. Sorry. I'm assuming you know some basic crypto. So once it's approved it will tell me here that it's ready and then I will just go ahead and find my global. This is New York, come on, what's the name? Eat Global.
00:51:02.272 - 00:51:02.870, Speaker A: What?
00:51:05.720 - 00:51:28.990, Speaker B: Can I see it? I lost it, I don't know what happened. Oh, it's in the other one so it's called Eat Global new York City. Anyway, see? So let's hear New York City to find it. I cannot find probably it's a little slow, the internet but it should be published and then you will be able to see it.
00:51:29.440 - 00:51:30.190, Speaker A: So.
00:51:37.380 - 00:52:29.282, Speaker B: Try to see what? In case the internet is a little slow. Let's try it again. Okay, so let's try it's notable never mind, it's a little slow but then here you will find it and you will see it. This is the one I use for the workshop. It's a little those. So it will show here and you will be able to see the source and you will see it live here. So basically that's how you deploy a component into Boss.
00:52:29.282 - 00:52:52.700, Speaker B: So basically you can do it on the online ID, you can do it on your BS based IDE and then you just publish it. That's basically what we are asking for the submission, right? You deploy a Boss component and oh, that's another part. So then there's two ways you can do this.
00:52:56.670 - 00:52:58.570, Speaker E: If you are here.
00:52:58.720 - 00:53:36.486, Speaker B: So you can interact with near smart contracts here for example, or you can interact with other non Ethereum smart contract, right? So for that you can basically use Ether. Yes. And then you set up your network. It has to be EVM compatible. So you basically set up the Ether? Yes. And you just call it the same way you will use their Ethergs in react. So this is the one that connects to Lido.
00:53:36.486 - 00:54:00.562, Speaker B: As you see, it's a standard. Then you just call the Ethergs, you set the network, you get your approvers, it's the same thing. So just use as Ethergs was working there. So you just don't need to add anything else. Just use either JS to connect the smart contracts. Or you can see this is a basic component. You will see it here.
00:54:00.562 - 00:54:48.580, Speaker B: You just call either it's pre installed, you don't need to import it or anything else. And then you can set up the network. If you don't want to use Ethereum, you want to use other EVM compatible, you just change the network and ID and whatever you need and you just conclude smart contracts in another network. Or you can use near smart contracts will be better, simple, faster. But you are not tied to use it on near smart contract. Talking with near smart contract in Rust is beyond the scope of this one, but this presentation. But if you stop by and you're new to smart contracts in near, just come and we can help you with that.
00:54:48.580 - 00:55:27.258, Speaker B: And then if you have owner backend, you don't want to do the backend, I don't know, in any blockchain it's still valid, right? What we're asking for the hackathon is to have the front end working on Boss. If you go to the applications page, you will see many components. Every single component can be forked. So you can reuse the code. You can see the examples. For example, one inch has a component running on Boss when you can do the swap. So this is a one inch component.
00:55:27.258 - 00:56:13.258, Speaker B: You can easily get the fork it and use the code as you need it. Or you can go through all the long list of components that we have. You see here, there are many components here that you can just check what other people are doing and reuse them as you wish. So that's the basic idea. That's what we want for the hackathon. We are there if you need some support in deploying Boss, just let us know. If you need guest money, if you need some near to start deploying, just ping me on Twitter and we send you a code.
00:56:13.258 - 00:56:54.202, Speaker B: You will give you more than enough because Boss is mostly Mainet, so you can use a facet. You need some actual near. So ping me and we'll send you some near so you have enough to be able to code during the hackathon. And as I mentioned before, there are $10,000 in prices. Yeah, stop by and beyond that. Having your front end deploy in a decentralized platform is what this is all about, right? Like real decentralization, not having to rely on centralized entities. I think you should give it a look.
00:56:54.202 - 00:57:27.458, Speaker B: This is working and people so far you will see there are many, many components and a lot of projects and jumping into this because they have the benefits of not having to relay. And at the end, even cost wise, you will see it's more convenient than the centralized option. So, yeah, give it a try. We are on the booth. We can do any technical support you need. Help you with the first component, help you with the near you need to deploy, whatever you need. Yeah, that's it.
00:57:27.458 - 00:57:34.850, Speaker B: I leave this here in case you need it. And yeah, I hope to see you there. You can get some swack too, and yeah, see you there.
00:57:34.920 - 00:57:35.780, Speaker C: Thank you.
00:57:39.630 - 01:00:22.340, Speaker A: That's Sam. SA it.
01:00:33.750 - 01:00:49.384, Speaker E: Let me pull up this thing. Okay. I am live. Presenter view. Okay, perfect. Test one. Okay, it works.
01:00:49.384 - 01:01:17.766, Speaker E: All right, nice. All right, cool. Is it? This is a presenter view, but it's not isn't this supposed to be hidden? How does this work? Supposed to be hidden, I thought. Right, but it's not hidden. Damn. Hold on, let me see. Oh, man.
01:01:17.766 - 01:01:35.210, Speaker E: How does this work? I guess I have no other option, I have to pull it up. Hold on. Do you know how this works? This is supposed to be hidden, right? I thought it was supposed to only show.
01:01:44.260 - 01:02:36.720, Speaker A: Sam.
01:02:39.100 - 01:03:28.500, Speaker E: Hey, what's up, everyone? I'm sorry, I thought the presenter view would work. It doesn't, but it's okay, you know, I'm going to keep it like this and I'll just read from what I got to do, but yeah, it's a pleasure. I'm glad everyone's here. So my name is Daniel, I'm from a company called unlimited. So Unlimit is an OG payment company, right? So Unlimited started in 2009 and it started off in the payment space, right? And then they expanded off into different sectors like banking as a service. So in nine, in the early 2010s, when your ecom is blowing up, when all the online payment gateways are blowing up, unlimited was actually powering a lot of them, and within LATM, within APAC, within Europe. So we have a huge presence globally.
01:03:28.500 - 01:04:24.920, Speaker E: So we do card acquiring, so we accept debit and credit card payments and a bunch of currencies. We have a bunch of payment methods, alternative payment methods, also your classic Apple pay cards, banking, Rails, we do card issuing and yeah, we also have a full stack Bass solution. So this is just an example of what I was talking about. We have over 150 countries, many languages, bunch of payment methods, and Unlimit started this division of Unlimit crypto within the past year and a half. So the idea was to take all over the Rails that have been built over the past 15 years and apply them to the crypto game, the Crypto world. So this is the question, right? Why does this matter on and off? Why is this important? Right, so I had this as an example. I'm sure a lot of guys know this guy.
01:04:24.920 - 01:05:17.444, Speaker E: This is the Bitcoin pizza guy from 2010. The guy made the first payments, probably one of the first use cases of crypto, which is he bought a pizza with Bitcoin. Right, so how has this evolved since then? Right? Like when it comes to buying the dream to buy a cup of coffee with crypto or to buy whatever you want with crypto, the first step, obviously you have to on ramp. So that's where we come in, right? So let me start off. When you go to a store and you use your debit or credit card to buy something, the question is what happens? Why is unlimited different? How are we different? What happens? You have to understand the exact flow and I'll go through that real quick. Right, so use the card holder. You're going to use a card given by your bank and the bank is the issuer.
01:05:17.444 - 01:05:47.564, Speaker E: And the issuers oftentimes are called principal members within networks such as Visa, or Mastercard. I'll get to that in the next slide. So then after that, the cardholder goes to the merchant. The merchant accepts your card payment through a point of sale system and the store has a bank relationship with an acquirer. This ensures that they can accept the card and the payments. So in this sense, Unlimit is an acquirer. So we are the acquirer in that flow.
01:05:47.564 - 01:06:37.344, Speaker E: And then the point of sale system is going to connect to a processor, which is like your fizzes or your squares. And the processor's role remains as the mediator that ensures the conversation between the store, the network and your bank go through. And then the processor informs the acquirer about the transaction details. The acquirer facilitates that transaction by connecting to the network and asks the card and the network, is there enough funds on here? And then Visa or whatever card network speaks to the bank with those details and the bank, which is the issuer, they check if there's enough money and they send back a message saying either approve or decline. And then the processor transmits that message back. And if it's approved, it's approved. The money moves and goes to the place it has to go.
01:06:37.344 - 01:07:15.052, Speaker E: So as you see here, just simple swiping your card and like buying something. There's a bunch of players, there's a bunch of routes that your order has to go through. So with that being said, the question is, why do we need another on or off ramp? Why does this matter? So before my time at Unlimited, I've been working in the on off ramp space for a few years now. I was at a company called Wire, and Wire was one of the biggest on or off ramp players in the game. Similar to Wire, you have a bunch of different people, like MoonPay Transact, a bunch of different people. The question is, how are we different? Pretty much what I described to you. Because we own the entire stack.
01:07:15.052 - 01:07:30.630, Speaker E: We are the processor, we are the acquirer, we do the settlements. So we own the entire stack of when you put your card in to want to buy crypto, we own that stack. Meaning, what does that mean? It means fees are not being taken off by.
01:07:33.160 - 01:07:33.956, Speaker A: I'll be right back.
01:07:33.978 - 01:07:34.710, Speaker E: I'm sorry.
01:07:47.740 - 01:07:48.200, Speaker F: Okay.
01:07:48.270 - 01:08:17.280, Speaker E: Yeah. So that means essentially when you're a card loader you want to buy something goes to that flow. You're not going through your stripes. Your world pays your stripes and your world pays. No longer are they taking bips and fees, exposing you to FX spreads. Essentially, when you go through us, you have the entire stack in your pocket. So when you go on an aggregator, like if you go on onramper right now, you'll see we're essentially like the default provider for a lot of pairs because of what I just explained.
01:08:17.280 - 01:09:11.620, Speaker E: Because we own the entire stack, we essentially minimize the fees for the user's end. So as I was talking about, we are a principal member of different networks like the Visa and Mastercard. So the question is, what does that mean? So you have your Morgan's, a lot of the banks, they're also principal members. That gives you the ability to issue and do merchant acquiring. So in order to actually do that, a lot of the competitors, they have to do it in a hacky way, right? You have to get a sponsor, you have to pay fees to essentially tap into the same network we're already tapped in. So we're essentially avoiding fees on that end. And then obviously you have the processing, the acquiring, the settlement, there are fees being taken off at every route, but we essentially are able to bypass that because we own the entire stack.
01:09:11.620 - 01:10:01.008, Speaker E: So the question is, so what? Right, okay, so what does that mean? That means now that you want to go and buy this coffee, up until now, because you had ridiculous fees spreads, I mean, you're exposed to counterparty risk as well. So if any of these other on and off ramps, they do fraud, they have chargebacks all of a sudden now their partners, or now that on and off ramp, they have to pay 50, 60, $70,000 a month. They're exposed to higher fees because they've done chargebacks, right. The counterparty risk is there. That also gets passed on to you for the sake of this hackathon. Why does it matter? Because now you have the ability with the lowest fees possible. No longer are you spending $100 to get $90 of crypto.
01:10:01.008 - 01:10:40.956, Speaker E: That essentially we're minimizing that as much as possible. So why does this matter? And this is where we come to the hackathon. So now that you understand essentially the premise of the technology is not we're not building rockets. I think the important part is what I just described. It's just the why? Why does this even matter? But let's go into the actual hackathon. So we have account abstraction 101, right? So these are a bunch of different projects that are building in the account abstraction space right now, right? So actually we're working with zero dev, which is they provide the infrastructure for a lot of account abstraction wallets and a lot of the functionalities. But there's a bunch of other players.
01:10:40.956 - 01:11:06.968, Speaker E: I'll actually share this slide and all the different players after this within either like a Telegram group, which you can have my Telegram at the end, or within the actual ETHGlobal Discord group. So here's a couple of providers. I'll share that later. So the question is, what is account abstraction? Right? You've heard it a million times. What does it mean? Right. It's very simple. Right.
01:11:06.968 - 01:11:50.740, Speaker E: So account abstraction is just having smart contract wallet functionality, right? The ability for smart contracts to send and verify transactions instead of EOAS, like your MetaMask wallet, which can't do that. Smart contracts powered by account abstraction can be programmed with custom validation, logic. So essentially, your wallet now becomes its own DAP. What does that even mean? So let me keep going. So with account abstraction, there are many functionalities that you can plug in. So you have here a couple. So you have gas sponsoring, you can pay for your users gas fees and either really any ERC, 20 token or ETH.
01:11:50.740 - 01:12:21.804, Speaker E: But the ability to pay in really any token is a big thing here. Batching bundling multiple transactions, providing the idea of session keys, right? So using a login method, you now have a temporary session key, which is essentially your private key. So that's a new concept. You have social recovery. So if you lose access to your account, you can essentially have a backup. So you have upgradable validation rules. You can upgrade SkMar contracts, as I said, the gas fees and different tokens.
01:12:21.804 - 01:13:28.672, Speaker E: And with the ability to have different plugins, essentially you can pretty much create anything into these wallets. So the idea is, what is the idea behind this hackathon, right? So the idea behind this hackathon is, okay, you have unlimits on ramps. Now, combining that with the idea that you can build any logic within a wallet, what can you do? What does that mean? Imagine on ramping into an account abstraction wallet. That wallet has logic written in it saying, hey, when ETH lands in this wallet, route that to an NFT marketplace, buy this NFT and send it back to this wallet, right? So before this, users had to go in and do everything. They had to go in Google in an NFT market, figure out gas, figure out how to connect their wallet, figure out how to buy this NFT with this. Essentially where we're going now in the space account abstraction, your wallet can be its own DAP. No longer do you really need to do anything and go anywhere.
01:13:28.672 - 01:14:21.732, Speaker E: You can essentially execute logic to do whatever you want within this wallet. So here's some ideas that you could do. There's just some that I thought about, but you really can do anything, right? So you have the ability to schedule transactions like recurring subscriptions, automatically claim rewards for mining or staking buying NFTs, as I talked about working, if you're doing something related to potentially getting liquidated, you can create logic saying, hey, if I ever reach a certain threshold, fund my account. Right? So this can all happen in the back. You're not actively doing anything. It's just pre coded in into the wallets, right? So what does this mean? It's up to you. It's up to you guys to figure out what it means, right? The ability to have your own DAP in your own wallet.
01:14:21.732 - 01:14:51.104, Speaker E: Essentially your wallet now becomes curve. It becomes an NFT marketplace. It becomes anything you can really imagine it to be. So here is the actual resources to get this going, right? So I'll pull up this right here and I'm going to share this. I'm going to share these resources within the Telegram group or the discord. So let me go here. So we pulled it up, refresh that.
01:14:51.104 - 01:15:24.392, Speaker E: So this repo essentially you can clone it and it brings this up. And I made this, obviously I'm going to share it with you guys so you can build on top of it if you like. So essentially you come in, we have all these different login methods you can use. One, come in here. You now have automatically a wallet address spun up for you. This wallet, you can essentially add any logic, anything you want within it that can execute in the web, three world, whatever you can imagine it to be. And I have these two examples as what you could do.
01:15:24.392 - 01:16:02.724, Speaker E: So we partnered with Zero dev as I talked about. We have them in our Telegram group if you ever need to chat or have a question about how it works. But really you can use any account distraction platform you want. But we have Zerodev already, so it makes it easier for you guys. But these are some functionalities. You can pay for the gas bundle transactions. And we have our Onramp, which is essentially an SDK, which pulls up our Onramp in different modes, right? So you have overlay Embed, you can go to Hosted, pulls it up in a different thing in a different window.
01:16:02.724 - 01:16:38.884, Speaker E: We have our API endpoints. You can actually even get the widget through an endpoint which returns back a URL. And we have our configuration endpoint. So this configuration endpoint shows essentially everything when it comes to the countries that are enabled, the payment methods, the networks, each token is on or coin is on the payment methods that are applicable to each jurisdiction. So essentially this will be the map of how everything, the possibilities of how things can link up. We also have the get quotes endpoint. You can get the quotes, get your orders that have already happened and get a single order.
01:16:38.884 - 01:16:59.064, Speaker E: So five endpoints, right? And then SDK. So it's nothing crazy happening here, right? I think the interesting part is going to be combining this with the actual, obviously the AA wallets. And I will share this with you. I will share this with everyone. You can clone it, do whatever you want with it. I have some more examples. I'll share this as well.
01:16:59.064 - 01:17:26.064, Speaker E: So we have this for example. So this is going to be service son of okay, let me pull up something. So you have essentially the SDK. You can essentially do whatever you want in here, customize it, add any parameter you want. You'll see a change within the actual SDK. We have that. And then we have the API docs as well.
01:17:26.064 - 01:17:45.600, Speaker E: Of course we have the API docs. We even provide you zero dev's website. You can make an account there, it's self serve. You can just spin up a test account and just pretty much plug it into the demo app. And build whatever you want with it. So, yeah, here are my telegram and discord names. You can send me a message.
01:17:45.600 - 01:18:01.310, Speaker E: I'm going to be out in the back. I have a table out in the back. If you want to come and ask me anything at all, go for it. We'll add you to the groups. We'll give you all the resources you need to get this going. And yeah, that's pretty much it right there.
01:18:02.480 - 01:18:02.844, Speaker B: Yeah.
01:18:02.882 - 01:18:27.348, Speaker E: Let me know if you guys have any questions, any questions at all. I'm willing to take questions right now if you have any thoughts, ideas, concerns. Yeah, what's up, man? Yeah, exactly. You can choose your AA solution. I just did zero dev because we've already built stuff with them. It's easy. We have the resources to help us.
01:18:27.348 - 01:18:40.530, Speaker E: But if you want to go, if you know something else yeah, I'm agnostic to whatever you want to choose. Yeah. And yeah, cool. I appreciate it, guys.
01:21:07.960 - 01:21:08.950, Speaker G: Hi everybody.
01:21:09.400 - 01:21:11.716, Speaker F: Can everyone hear me okay, cool.
01:21:11.818 - 01:21:12.084, Speaker D: Hi.
01:21:12.122 - 01:21:33.592, Speaker F: My name is Marcus Rain. I work for Edge and Node. I'm Developer Relations and Success. And I'm working on building the graph. So thank you so much for arriving at this presentation where we are going to be going through querying web three data with the graph. Right away. Let's go ahead and go to the important part.
01:21:33.592 - 01:22:02.436, Speaker F: If you are hacking and you are planning to build with the graph, this is the QR code that you should scan. This provides you with hacker technical support where you could reach out to us on our telegram. There's also going to be quick start videos, documentation, lots of links to get you started. Also, the slides of this presentation and the repo associated with this presentation will be in this QR code. So once I see all phones down, I'll be going on. Okay. Oh, phone up.
01:22:02.436 - 01:22:34.072, Speaker F: Also, every month I write a graph builders newsletter for builders like you for any updates that are in the ecosystem. There we go, another phone up. Okay, phone up. Okay, phones are down. All right, so if you are hacking and planning to build with the graph, these are the bounties available. And if you want to pay attention to the second category, the best use of existing subgraph or substream that's if you simply have a query sent to the Graph ecosystem and actually use that in your DAP. And that's what we're focusing on in this presentation, just sending a query.
01:22:34.072 - 01:22:57.444, Speaker F: We're not actually going to be building a subgraph. So let's get into it. The graph network. What is the graph network? The Graph Network is decentralized indexing and querying. There's 250 plus indexers worldwide that are organizing and providing your data. And there's seven chains on the Graph network with over 1000 subgraphs, which means over 1000 endpoints for you to all query. It's pretty cool.
01:22:57.444 - 01:23:24.040, Speaker F: We could all use this and build already today. And really quickly, what is a subgraph. Well, a subgraph, if you look at this is pretty much this you get disorganized data and that's on the blockchain. And then from there a subgraph will organize that data. And then from there you have nice buckets at the bottom that we can query and actually provide data to our DApps. It has an API endpoint that we're able to use. When you build a subgraph, you actually build it in subgraph Studio.
01:23:24.040 - 01:24:09.772, Speaker F: And then when you have that subgraph built and we have it going on, it starts centralized. And when we iterate and build it and build it and build it, we then publish it to the graph network and then it becomes decentralized. So that's just important to know. Every subgraph that you find in this Graph Explorer that we'll go through in a second will be decentralized on all of those indexers around the world who are indexing that subgraph and why might we go on the graph network and actually publish our subgraph? The subgraph will have increased uptime speed and redundancy and these network subgraphs exist in a marketplace. When we publish our subgraphs to the marketplace, we have our subgraphs being competitive. It's actually tokenomic incentivization going on in there with the GRT utility token. So the indexers are incentivized to work harder for you.
01:24:09.772 - 01:24:25.404, Speaker F: All right, that's really important as a builder to know that when you see a subgraph in the Explorer, that is one that's a competitive marketplace subgraph. Okay, let's keep on going. Let's take a look really quickly at the Graph Explorer. Here. We can see this is the marketplace.
01:24:25.452 - 01:24:26.464, Speaker D: This is a little GIF of it.
01:24:26.502 - 01:24:54.060, Speaker F: And you can go through, we can all go through and check it out and see right there, there is the endpoint and that's the query URL. We'll go through this in a little bit with some actually exploring the Graph Explorer. Let's shift a little bit after that high level overview into something that is more what we are trying to do today, which is querying. All right, we actually want to get some answers. So it's not the answer that enlightens, but the question. And that is really important. We want to ask some good questions.
01:24:54.060 - 01:25:23.044, Speaker F: We want to get some good questions from our web three world. And let's go into that process right now. Okay, the steps to query a subgraph. First we have to set up an API key. We have to set up that API key to access the graph network and actually send out queries. The next thing we need to find and assess a subgraph on the Graph Explorer, which is exploring the graph network. Number three, we then design queries in the subgraphs playground that we are interested in.
01:25:23.044 - 01:25:28.756, Speaker F: And then number four, we integrate the query that we like with our DAP and we can just send it out and get to work building.
01:25:28.858 - 01:25:29.424, Speaker C: Okay?
01:25:29.562 - 01:26:00.656, Speaker F: So first things first. Let's go ahead and set up an API key we'll go to the Graph.com and we'll go up to Products and Subgraph Studio, and we'll go to the top and we'll go to Keys. And really quickly, I want to preview. We are excited. And always it's really exciting to see that we're going to be putting in subscriptions for queries. So you'll have a set rate per month, if that's something that interests you.
01:26:00.656 - 01:26:20.184, Speaker F: That's not what we're doing today, but that's a little preview. I'll talk about that a little bit later. But these are our API keys. When we set up an API key for the first time, we actually get 1000 free queries. So if any of us are setting up API keys today, you'll get 1000 free queries. And this is mine that I've built for myself. And this is also a query key that was created for everyone here.
01:26:20.184 - 01:26:44.364, Speaker F: So if anyone here runs out of their 1000 free queries, go ahead and reach out to us on Telegram or find us at the booth and we'll get you this query key right here and you'll be able to keep on building. Okay? That's really important. We don't want you guys to stop building. The query key is right there. So to just create an API key, just go right here, live demo key. And from there, that is it. We have our query key and we're able the API key.
01:26:44.364 - 01:27:26.664, Speaker F: And from there, we're actually able to fill that up with the billing balance and then continue on with building. Okay, so now that we have our API key, we have 1000 free queries and also a free API key that's able to be used. Let's move on to the next step. Okay, number two, we want to find and assess a subgraph on the Graph Explorer. All right? So let's dive in to really what that might look like. How do we find the subgraph? How do we assess it? What does that actually mean? Well, we can go through a few steps here. And the easiest way to assess if a subgraph is of high quality, because remember, it's in a marketplace, is if it is a Masari standard subgraph.
01:27:26.664 - 01:27:57.172, Speaker F: If you see if we all see a Masari standard subgraph, that subgraph has been built by the Masari team and that has a standardized schema and a actual standardized way that we can interact with it. And that's quite powerful. Let's go through really quickly their website that shows a really nice list of Masari subgraphs. And also we can see that in the Graph Explorer, but this is through Masari. Each of these, these are bridge subgraphs that we can access blockchain data, and they all are standardized together. The derivatives subgraphs, these have their own standard. The derivatives here have their own standard.
01:27:57.172 - 01:28:27.180, Speaker F: The exchanges, these have their own standard. And soon, later in the presentation, I'll show you why this is so powerful. Just know that subgraphs XYZ is a helpful place to see all the masari subgraphs in one location, and then from there you can be able to use that power, and I'll show you how that is empowered. Very soon, let's go back and say, let's say we see a subgraph on the Graph Explorer and it's not a Masari standard subgraph. Well, we got to get a little bit more. We have to know the actual protocol a little bit better. We have to understand what's going on.
01:28:27.180 - 01:28:55.972, Speaker F: And there's three things that we could look at to understand if a subgraph is of higher quality or moderate quality or lower quality, because all these subgraphs are permissionless, anyone could publish these. We need to assess if it's helpful in the marketplace. So let's go through and find and assess a subgraph in the Graph Explorer together. Right now. Let's go to Graph.com Explorer. Okay, so here is the graph explorer.
01:28:55.972 - 01:29:47.668, Speaker F: And right at the beginning we see there's 932 subgraphs, 932 endpoints, 932 locations where we can access data through the blockchain. And we have even more on Arbitrum One and really quick differentiation. These are subgraphs indexed by indexers who are incentivized by the GRT utility token on Ethereum. The Graph protocol is on its process of migrating over to Arbitram One to take advantage of L Two, all the advantages of L Two. And so right now we see 376 subgraphs that have migrated from Ethereum and are currently being indexed on Arbitrum One. And just so you know, if you are going through this, this is going to help you identify these different batches of subgraphs. So let's go ahead and go to Ethereum and we will see a let's go to a crypto punk subgraph.
01:29:47.668 - 01:30:27.472, Speaker F: And I want to be very specific here. I want to look at one community of NFTs, and from there we can start to dive into a little bit more detail. So right away we see this is organized in a way where curation signal is quite important, and that's important to understand where the ones with the highest curation signal have the most GRT tokenomic incentives going on to reward those that participate with this subgraph. And that goes into a little bit of the tokenomics. I'm not going to go too deep into that because you all are builders. We're all builders. It's more important just to know the ones with the most signal, also known as curation, typically are the most valuable subgraphs and have the most proven quality in this ecosystem.
01:30:27.472 - 01:30:42.648, Speaker F: So right now, this is the one that we're staying and that's the curation. That's the signal. That's the one that we want to take a look at. So let's dive in there and let's move on. So how do we assess this Subgraph's quality? Let's keep on going. This subgraph is actually finished indexing. That's awesome because indexing takes time.
01:30:42.648 - 01:31:08.976, Speaker F: This is already complete, so we're getting fresh data at the chain head, which is great. Let's keep on going. All right, let's say all right, the next thing that we want to look at. First we want to look at the curation, then we want to look at the documentation. And any good subgraph is going to have its actual code available to the public. And we can see right here, this developer, it's Jerry Ocolo, has provided his documentation right there. So let's take a look at what he has done.
01:31:08.976 - 01:31:36.016, Speaker F: Let's see if there is quality documentation. We can see awesome. There is quality documentation. We know what's going on with the subgraph because this is permissionless, it's important that we can investigate. All right, what's going on with this? Is this gathering the data? How is this organizing the data? That's really what we like. Okay, the last thing on that previous slide was comments. So it's curation, it's documentation and the comments, specifically the comments in schema GraphQL.
01:31:36.016 - 01:32:12.084, Speaker F: Now, why are comments important in this location? That'll come up in a little bit when you're playing around the playground. But just, I want you to see here that Jerry has been kind and put in comments here. And why might that be powerful? Well, we'll see when we're in the playground why that might be powerful in a little bit. But if you are diving into a subgraph and we're able to see comments in this location, that helps us as builders really get building really quickly because this developer has taken the time and kindness to really make our querying experience much more effective. Okay, so curation the documentation and the comments in schema GraphQL of the subgraph.
01:32:12.132 - 01:32:12.728, Speaker A: Okay?
01:32:12.894 - 01:32:49.004, Speaker F: Now, I think personally, this subgraph is pretty good. It's a pretty dang good subgraph. We're able to say, all right, we've got some good curation on there, we've got some documentation and also has comments. The next step let's go back to here would be to begin to design some GraphQL queries. We've found the endpoint we want. We've found the actual subgraph that we think has the information that we want because it's gathering and organizing it in a very nice way. The GraphQL queries are important because we have to start designing these little queries to say what data are we getting and is it the actual data we need for our DAP.
01:32:49.004 - 01:33:12.116, Speaker F: So the few features that the playground has, there's many. But we'll just go over the filtering, some logical operators, we could save some queries. And there's many, many more features that are available in the graph.com docs. And you can see how it has those features in there. So let's think of some queries and just demonstrate how we might go through some investigation of this subgraph. So here's some example queries.
01:33:12.116 - 01:33:41.004, Speaker F: And we'll start simple. First ten transfers in cryptopunk's history. Let's go ahead and dive into that one the first ten of all times. So we'll be here and we'll go to the playground, it automatically populates with the query and it has accounts and it has punks, but we don't want the account entity. We don't want the punks entities, remember, we want to look at the transfers. And that's really how the Schema is organized. With every subgraph, it creates these buckets, also known as these entities in the Schema GraphQL.
01:33:41.004 - 01:34:05.080, Speaker F: And these are the entities that we can begin to query. And we're looking for the transfer entity right here, and we have a single transfer if we want to see that. But we could also look at many transfers, and we want to actually take a look at many of them. So we'll click on that, and that little arrow that brings it down is allowing us to say, all right, let's look at transfers, and we'll click the first, okay, ten. Very nice. We could look at 15 or 20 or 100, whatever we want. And then we also want to look at the first ten.
01:34:05.080 - 01:34:43.540, Speaker F: So we'll say, all right, we got to look at the timestamp. That's going to be important because it's timestamp. And then we also want the ID. And just to understand the ID a little bit, we could hover our mouse over different locations and the timestamp, and we'll see that in just a little bit why that might be powerful coming up, why that might be powerful when we're looking at more complex information, that hovering is quite powerful. So let's go ahead and say, all right, we want to order this by the timestamp here, and we want the order direction. Okay, very nice. We've created a little query and bam, we've got this back, and now it's ascending from the beginning timestamp, and it's going up and up and up, and we have the IDs right there.
01:34:43.540 - 01:35:11.472, Speaker F: So already we have a valuable query that we can then bring into our actual DAP. And then from there, we can keep on playing around. We can play around and play around, find different bits of information that we like and go from there. What's the next question that we might want to answer? Okay, what's the total value of all sales, the total supply and the number of sales on the crypto punks contracts? All right, so that's a little bit more detailed. Can we actually get that information? Has Jerry done the work at actually doing some compute on the subgraph and then providing us that data?
01:35:11.526 - 01:35:12.496, Speaker B: Let's go see.
01:35:12.678 - 01:35:41.672, Speaker F: We'll go here and we want to look at we don't want transfers, we want contracts. And we'll get whatever's there. And here we can see the total amount traded. And if we hover our mouse over the actual location, we can see the comment pop right up here. This is where the comment comes through. So if the developer has done a nice job putting a comment in there, we're able to see exactly what this means when we query this property, because sometimes properties can be a little bit vague. And just by putting that in there, we know exactly what that means.
01:35:41.672 - 01:36:04.636, Speaker F: This number right here. What is total sales? We just are able to hover our mouse over. Thank you, Jerry, for putting those comments in. That is awesome because we're able to understand this better and get building. Let's keep on going with this journey here. This is a comparison of two masari standard subgraphs. Remember those masari standard subgraphs I was talking to you about? These are both under the same category.
01:36:04.636 - 01:36:37.150, Speaker F: They're both standard subgraphs that we can query. And we could send the exact same query to any masari standardized subgraphs that are under the same category. And that's really powerful because let's say we have five or six different subgraphs, each going into their own different protocol calls. And then from there, we just want to send one query to all of them. All right, using Graph Client, which I'll talk about in a little bit, we can do that. So I'll just demonstrate this query here, find the TVL for August 20, 2023. We can look at the Curve finance Ethereum subgraph and then send that out.
01:36:37.150 - 01:37:12.372, Speaker F: We get that information right back. And then also we're able to send the exact same query because this is a standard subgraph, it's a masari standard subgraph here. And to get that exact same information back, because the schema is standardized, that's going to help you get information from many different protocols all at once, all to one location through Graph Client. That's a really powerful all right. And that's through subgraphs XYZ. Remember, go through there and see the different categories for the standardization. If you want some homework, here's some homework, and that's going to be fun for you.
01:37:12.372 - 01:37:45.328, Speaker F: If there was to be one QR code for everyone to scan to integrate queries into their DAP right away, it would be this one. This is the repo that I created for everyone here that gives demos of a vanilla JavaScript and Python query, an Apollo query, a Graph Client query. Graph Client was created by the team that's building many teams that are building the graph. That allows for one query to be sent out to multiple subgraphs all at once, which is really cool. There's auto pagination in there, so we could have lots of responses. Really cool. And then finally, at the bottom here, there's two things I want to pay attention to.
01:37:45.328 - 01:37:48.592, Speaker F: Once I see phones down, I'll move on. Phones up.
01:37:48.646 - 01:37:49.008, Speaker C: Good.
01:37:49.094 - 01:38:13.464, Speaker F: Yes, I see it. Thank you. Two minutes, quick. All right, phones are down. Who here likes machine learning? I think it's super cool. If you are interested in diving into machine learning, this is an amazing library that connects directly to subgraphs and is written in Python. So we can go ahead and start going into machine learning data science right away without having to go and do anything else.
01:38:13.464 - 01:38:21.756, Speaker F: Just use this library and it connects right to a subgraph and you send queries right from there. Super cool. And then also, if anyone here likes dashboards that are no code.
01:38:21.858 - 01:38:22.536, Speaker E: This is DAP.
01:38:22.568 - 01:38:36.530, Speaker F: Looker. It's awesome. It's built on top of subgraphs and substreams. And from there, you could literally drag and drop these into your DAP and have these analytics right there. And you don't really have to do any front end design. It just literally drag and drop, and that's it. It's really, really nice.
01:38:36.530 - 01:38:52.612, Speaker F: It's really good. So, yeah, playgrounds and DAP. Looker. One final thing. Billing subscription, that's a new thing. If anyone here is querying the subgraph a lot and want standard monthly rates, this is a subscription, so it's a flat rate. You don't have to worry about big spikes and big drops.
01:38:52.612 - 01:39:10.110, Speaker F: This is something that's rolling out. We're in beta right now. If you have any questions about this, reach out to us on telegram or meet us at the booth. We can get you signed up and you can actually use that. So, some takeaways we love decentralized indexing. There's a thousand subgraphs and the endpoints ready for everyone here to query and then go ahead and play in the playground. Thank you very much.
01:39:10.110 - 01:39:19.010, Speaker F: And if anyone wants to scan this and tweet that's the lifeblood of crypto, so it does help.
01:39:19.780 - 01:40:06.370, Speaker E: All right, it.
01:40:30.620 - 01:40:31.370, Speaker A: It.
01:41:19.200 - 01:42:03.692, Speaker D: Hey, folks, I'll just let everyone quickly settle down. I hope you're enjoying your first day of ETH global hacker house. We are really short in time. This is a 20 minutes presentation. I want to make sure this is short and sweet and useful for everyone who's here. So, by a show of hands, I just love to know who here has written a Cairo program? Okay, so not very many people, but I'm extremely happy to see those who have. And how many people here have made a transaction or used StarkNet layer two in the past? Okay, so, still the minority in the room.
01:42:03.692 - 01:42:43.096, Speaker D: Finally, how many of you know what an ethereum scaling or layer two solution is? Okay, great. So we can skip past all of that. Just sort of begin by telling you a little bit about myself. I am the developer relations engineer for StarkNet Foundation in the US. I'm not very far apart from some of you in age. I just graduated college last year with four years of research in DeFi and game theory. And if you want to connect with me or get to know anything about me, feel free to hit that link tree up.
01:42:43.096 - 01:43:16.904, Speaker D: And bonus points for anyone who understands the joke and the name over there. So, I have a few talking points today we like to say on StarkNet. You comfort the ZK and you stay for the AA. So the guiding point for today's talk will be AA account abstraction, but we'll be going over generally what we're up to at StarkNet. So feel free to let me know when these slides are sort of redundant or you already know what I'm talking about. So we can just sort of brush past them, blockchain accounts.
01:43:17.052 - 01:43:17.412, Speaker G: People.
01:43:17.466 - 01:44:14.516, Speaker D: Familiar with the concept. Generally, the blockchain account is basically composed of three things address keys and business logic, or some software that's deployed on chain and then some metadata. Now, the whole idea of account abstraction, for those of you who haven't heard this phrase before, is unlike ethereum, where these three things come bundled in a package, you're able to separate your addresses and keys from the business. Logic and data and actually write your own accounts as smart contracts and associate them with a certain address or a certain set of keys. And that allows you to create heavily customized accounts. So I hope everyone's familiar with the idea so far. Sort of a quick slide I borrowed from the Ethereum Foundation's website that shows how your address maps to the data that I was talking about.
01:44:14.516 - 01:45:01.680, Speaker D: Sometimes it's also called metadata or state data. A lot of the code that you guys are going to be deploying as smart contracts are going to be mapped to your account address through the code hash. And let's talk about StarkNet. Since this was really the minority in the room, people weren't so familiar with StarkNet. StarkNet is a layer two solution that uses Stark proofs, which are a form of validity proofs, to accelerate Ethereum. We do so by essentially executing, by validating and executing programmatic logic on a layer two blockchain. It's just a blockchain and then processing those transactions, bundling them into a hash and reporting them to Ethereum layer one for them to be included in Ethereum's blocks.
01:45:01.680 - 01:45:48.344, Speaker D: And we provide Ethereum with a mathematical proof that all of these transactions were validated correctly. So has anyone here ever heard about the blockchain? Trilemma? Right. It's scaling, decentralization and security. Essentially, Ethereum as a layer one blockchain. A final settlement layer focuses on decentralization and security, and we pick it up when it comes to scaling and borrow Ethereum security guarantees in a mathematical sense in order to do so. There are several constructions of validity proofs out there. There are different roll ups that are operating on Starks, Narcs, Blancs, etc.
01:45:48.344 - 01:46:57.512, Speaker D: Though there seems to be now a narrative in favor of Starks. Basically, Starks are a form of validity proofs which use lean cryptographic primitives, allowing the proof generation cycle to be extremely fast and for it to be theoretically post quantum secure. However, this does imply that the proof is a little bit bigger and clunkier and takes a longer time to verify. But at StarkNet, we have optimized the proving process to a point where that's significantly reduced concern for us. So, just as a visualization, you can think of all of these validators as Ethereum validators running the full Ethereum client, StarkNet processing a bunch of transactions, creating a proof that the validation was done correctly, and allowing all of these validators to be sure that this is actually done correctly without having to commit large computational or storage resources to that. So, so far, I hope you're all on the same page, I'll quickly go over Cairo. I think only two or three people here have worked with Cairo in the past.
01:46:57.512 - 01:48:21.824, Speaker D: So Cairo stands for CPU of arithmetic intermediate representation. If you're not familiar with that, you don't necessarily need to be ZK, and proof systems can sound a bit sort of technically intimidating. I'm not a PhD myself, but I've learned that you don't really need to know those mathematical details to build some really cool programs. Has anyone here ever written a ZK proof or tried to do that in the? So if you use any of sort of the more playground like libraries like Circom or Socrates or Remix, you'll notice that you have to express your programmatic logic as a circuit in order to write a proof. And that's quite a shift from the traditional paradigm of just writing a computer program that works on a von Neumann CPU architecture and uses a Ram memory model. So at StarkNet, what we do is essentially we've created an intermediate layer, a VM, that allows you to write expressive smart contracts and software in general in a Rust like programming language. And then we constrain and arithmetize and basically turn your computer program into a provable program and generate the proof automatically by construction of the system so you don't have to think about building a circuit from scratch.
01:48:21.824 - 01:49:21.000, Speaker D: So it's sort of an old computer programming experience translated quite seamlessly into ZK scaling land. Very importantly, we have a Stark Verifier that's implemented as a smart contract on Ethereum, so all of your Cairo code can be verified on Ethereum. So just want to quickly help you guys visualize the naive way of verifying each transaction. Using, if you didn't have a proof system, would be that you had to rerun each transaction on each node in order to verify what's going on in the layer two. That would be order of N, whereas with proof systems, it's polylogarithmic. And as you can see, as the number of transactions in a block increases, the difference in time and resources is, well, stark, to say the least. No one got that joke.
01:49:21.000 - 01:49:55.920, Speaker D: So, yeah, finally, let's get down to account abstraction. I do want to be clear. Account abstraction is not necessarily something that only StarkNet is working on. There is a big push to bring account abstraction to Ethereum. We've already spoken about what it implies. It implies separating the addresses and the signing keys from the programmatic logic of an account and allowing people to express their own accounts on Ethereum. As many of you know, the block that you get of three things is called an externally owned account.
01:49:55.920 - 01:50:24.508, Speaker D: It's different from a smart contract, and it's supported at the EVM execution level. Now, there are some great things about having EOAS. They've been around for a long time. So developer tooling around EOAS and integrations are very mature. You have products that have hit billions of dollars of market capital already, like hardware wallets and browser extensions that are quite good to use. I use them myself. But there are some limitations as well.
01:50:24.508 - 01:51:30.060, Speaker D: First of all, an EOA is not a smart contract, which means that you can't express programmatic logic on it. So, for instance, if you want to use something like a multiparty signing scheme, you have to go through a third party like Gnosis, Safe, et cetera, et cetera. Whereas you could, if an EOA was just another contract, express that functionality in your own code. Some arguments also indicate that EOAS create a bad user experience, because this is just sort of a tale and I'm not paid by Braavos, but I'll be taking you through in just a couple of minutes. The Bravos I see there's a story for Bravos, which is a commonly used smart contract wallet on StarkNet. Basically, Bravos, because it uses abstract accounts, was able to create a three factor authentication for their wallet user experience. So you can sign your transactions by simply clicking Button, which is the familiar UX.
01:51:30.060 - 01:52:46.372, Speaker D: You can also sign transactions with Face ID and you can perform social recovery very efficiently on keys. And there was a crypto influencer in our ecosystem who accidentally revealed their private keys on a twitch livestream some time back, and their Ethereum keys, which were exposed unfortunately led to their fans taking away most of their funds from their accounts. But since the Braavos account was settled on two FA and they needed to sign with the facial identification, the only wallet that people were not able to exploit despite knowing the private key, was the Braavos wallet. And then finally, one of the benefits of account abstraction, which is extremely cool to me, and I will run through this slide. Too many slides to run through. But account abstraction allows you to essentially convert your phone doesn't matter if you have an Apple or an iPhone or a Google phone into a hardware wallet by simply implementing the Secure Execution Environments signature scheme in Cairo. So, yeah, that's sort of the TLDR that I could do in ten minutes about account abstraction.
01:52:46.372 - 01:53:38.936, Speaker D: There are some other benefits, such as creating gasless or seamless user experiences for people using adapts, because you can create something like a Paymaster that pays gas fees as meta transactions. AA on StarkNet supports multi call functionality and so on and so forth. The salient differences between AA on StarkNet and Ethereum is that on StarkNet, AA is supported at the protocol level because it was a concern that we addressed from day one. We have sophisticated developer tooling around AA, and I'll be sharing that with you in just a second. So you can use that in your projects with the hackathon. And we essentially are able to also provide fee delegation for DApps, just the way Ethereum does. So, yeah, this is what I was talking about.
01:53:38.936 - 01:54:37.736, Speaker D: You're able to use the secure enclave that's what the secure execution environment on an Apple phone is called and basically turn that into a hardware wallet purely because of the power of account abstraction. So I understand that I'm short in time, so there's a great, great talk about account abstraction that you can listen to, if time allows, at this QR code. I highly recommend it. And yeah, now, how many of you have a Braavos wallet on your Chrome browsers? So I'll get to this in just a second. First of all, I want to give some direction to the builders over here who might be interested in building something using StarkNet over the next couple of days. First of all, if you're interested, resources are quite concisely bundled in the StarkNet book, which can also lead you to our docs. Everyone here is an experienced hacker.
01:54:37.736 - 01:55:37.752, Speaker D: You're all meat eaters, so I'm not going to hammer this down too much. If you want some extra help, though, medium blogs are a good place to look at. There are two directions that I'd like to encourage people to consider over the next two days. The first is zero knowledge or verifiable machine learning DApps, which can be implemented quite easily using the Giza ZK AI tooling. You're basically able to create machine learning models in familiar frameworks like Jupyter notebooks and Python, and then transpile those into chiro bytecode and verify them on StarkNet very efficiently. Actually, if you follow that QR code, you can take a look at how you can implement a neural network that can differentiate between different texts in less than ten minutes. And then if you're interested in on chain gaming, the hottest narrative or one of the hottest narratives in the StarkNet ecosystem right now is the Dojo Gaming SDK.
01:55:37.752 - 01:56:39.152, Speaker D: And some really, really cool games have been coming up using Dojo SDK over the past couple of months. Actually, if you think you can pull it off, I would even consider combining these ideas and creating games which use an artificial intelligence agent in a gaming experience, like chess game or something like that. It's possible those QR codes will lead you to some sample projects that you can consider. So, yeah, as I understand, we have four minutes left, and so I will not get into the coding right now, but if you quickly scan this QR code, it will lead you to well, I'm already at Chrome. It will lead you to an article. I would just recommend following this article. It will take you no more than ten or 15 minutes, and it will help you set up your local developer environment for Cairo.
01:56:39.152 - 01:57:18.076, Speaker D: Setting up local developer environment for Cairo is as simple as typing two lines in your command line interface. All you need to do is set up a command line tool called Storkli and a package manager called Scarb, and that is it. And then you can follow this to essentially create. So I created a wallet for the express purpose of this demo. This is braavos. It's a pretty useful mobile wallet as well, but you can create a wallet with some testnet ETH in there. I recommend using StarkNet gurley.
01:57:18.076 - 01:57:51.688, Speaker D: Gurley two. These are our two test networks. Just set this account up. You're able to seamlessly integrate it with your CLI. You're able to define your own account as you want. If you want to use RPC calls, highly recommend using Alchemy. It's extremely easy to just create a new app and set mean, it doesn't matter if you do either one of those, but you can create your RPC node over here.
01:57:51.688 - 01:58:32.040, Speaker D: This is where you can download Braavos. And then finally, I want to make you familiar with a block explorer that I highly recommend called Stork Scan. Basically, yeah, I'm sure all of you know how block explorers work, but you can get some pretty decent insights just by playing around with this. So, yeah, the instructions are quite clear over here. My team and I will be walking around. You can locate us by virtue of either starquare shirts or ID cards and just stop us, ask us questions. More than happy to help you in your projects.
01:58:32.040 - 01:58:49.260, Speaker D: As I said, highly, highly recommend taking a look at the Giza Zkai framework and dojo gaming SDK. So, yeah, I have 1 minute left. If anyone wants to quickly ask a question, we can call it an afternoon.
01:58:50.080 - 01:58:50.830, Speaker A: Yeah.
01:58:55.230 - 01:59:20.130, Speaker D: So Warp is so before we had Cairo, as we have it today, we had an older version, which was a little bit more like Python. Not quite, but a bit like it. And it was a little bit harder to use. And so we created a transpiler from Solidity to Cairo. But now you're able to write Cairo programs in pretty much a rust identical framework. So warp is no longer required.
01:59:20.550 - 01:59:21.300, Speaker C: Yeah?
01:59:22.790 - 01:59:23.940, Speaker D: Anything else?
01:59:24.870 - 01:59:25.426, Speaker G: Awesome.
01:59:25.528 - 01:59:25.890, Speaker B: Okay.
01:59:25.960 - 01:59:32.500, Speaker D: I believe we are right on time, then. I'll stop sharing, but thank you so much for hearing me out.
01:59:33.150 - 01:59:59.220, Speaker A: It's SA.
02:01:05.610 - 02:01:29.134, Speaker G: All right, so you all for coming to my talk. My name is Rahat. I'm going to give you an Intro to Modules using the Biconomy SDK. So really quickly, my name is Rahat, head of Devrel at Biconomy, formerly been a frontend engineer, founder, hip hop artist. I've retired. I no longer do freestyles. I'm sorry, but you can follow me on a couple different places.
02:01:29.134 - 02:02:01.530, Speaker G: Twitter on Rahat codes, rahat lens on lens. If you need a primer on account abstraction, I did do an Intro to Account Abstraction at ETH Paris. You can see a replay of that on this link. So if you're new to account abstraction in general, you can check that out. This is not an introduction course to account abstraction. This is going a little bit deeper into a newer feature that we just recently released. So I will give you just, like, a small kind of overview.
02:02:01.530 - 02:02:07.578, Speaker G: But if you want to go deeper into what account of stretching is, highly recommend checking out this video and some of the resources.
02:02:07.674 - 02:02:08.320, Speaker B: Yes.
02:02:15.300 - 02:02:20.400, Speaker G: Okay. It's not showing my slides.
02:02:32.120 - 02:02:36.680, Speaker C: Go to your system preferences displays.
02:02:40.170 - 02:02:41.110, Speaker D: Mirror.
02:02:54.720 - 02:02:55.470, Speaker A: Cool.
02:03:03.790 - 02:03:35.582, Speaker G: All right, cool. So this is the QR code. If you want to go through that introduction to account abstraction, highly recommend going through this. It'll give you an overview, what account abstraction is, and just like a general introduction to our SDK. So really quickly though, I will go over some of the details in that video. So the Biconomy SDK allows you to tap into the full stack of account abstraction. So we give you Paymasters bundlers as well as packages to create your own smart accounts.
02:03:35.582 - 02:04:22.434, Speaker G: So the Smart Account package helps you to deploy your own smart accounts as well as create user operations that eventually get executed as transactions. Our Paymaster package, you use one URL and you can switch between doing gasless transactions as well as doing ERC 20 token payments for gas. So we're really focused on the developer experience. You just use one URL, switch the mode, and you're good to go. Bundler package you can use our Bundlers. We have bundlers available on several different chains to actually send your user operations to the entry point contracts on every chain that we're deployed on. So now we're introducing the Smart Account platform, which is our focus for this hackathon, as well as some of the different prizes that we have available for you.
02:04:22.434 - 02:05:20.520, Speaker G: So the Smart Account platform is built around extending our smart accounts to allow you to create and use different modules. So some of the modules that we have available for you today that you can start using allows you to do a few things. We have a regular ECDSA module which just relies on an EOA to sign and verify your messages, similar to the experience that we've had with our previous offering, with our previous version. But going a step further, we now also have a multi chain validation module which acts the same way as the ECDSA module. You use an EOA to sign for your transactions, but using that EOA and one signature, you can interact on multiple chains, all with one signer. So you don't have to have your user switch between different networks. You can just interact seamlessly across chains and completely abstract away the need for your user to even think about what network they're even using.
02:05:20.520 - 02:05:56.802, Speaker G: We have session key managers, which is going to be the focus for today's workshop. This enables the use of sessions and session validation modules for your DApps. So think of it this way. You sign once and then you start doing transactions, and you don't have to keep signing over and over again. You unlock actual fluid web Two experiences where you can do things like working on Web Three. Social sign once. You don't ever have to like if you think about if you've ever used Lens Protocol, you don't have to sign every single time that you like something or comment or post.
02:05:56.802 - 02:06:16.310, Speaker G: It's a similar experience to this. So like I said, today's focus is on session key modules. Let's dive into a quick demo and some code. So here's the demo. First, hit this connect web three button. MetaMask will pop up. I'm going to connect.
02:06:16.310 - 02:06:42.808, Speaker G: Cool. I've connected. And although my address ends in BDFD, you'll see that the smart account address is different. This smart account was deployed using my EOA as the signer. So this is showcasing the ECDSA wallet. Here the ECDSA module. I'm going to hit this create session button in the background.
02:06:42.808 - 02:06:57.372, Speaker G: A session will be created. I just sign once. So this is what I meant before. I sign once, right. Every single other transaction that I do in this demo, I will not have to sign again. So it's creating a session for me in the background, letting that kind of go. Cool.
02:06:57.372 - 02:07:30.590, Speaker G: Success session was created. Now in this demo, I'm simply just going to hit this transfer one USDC button. What's going to happen is I've already preloaded my smart account with some testmatic as well as some test USDC. And I'm going to send USDC back to this account. So just to show you, right now there is 29 USDC on this smart account. I hit transfer one USDC in the background. It's happening.
02:07:30.590 - 02:07:52.788, Speaker G: No metamass pop up, right? Nothing that I have to sign. It's just a nice little seamless experience. I'm just waiting for it to kind of go through in the background. Cool. I get my actual transaction happening here. But before we look at the transaction, you'll see that my USDC balance went up to 30. Didn't have to sign, didn't have to do anything.
02:07:52.788 - 02:08:39.168, Speaker G: This is an actual like think about this as like an actual experience of how a Web two user would use Venmo, right? You're sending some funds to another user, but you're not signing every single time. You're not approving it every single time. Now you can actually unlock these experiences on chain. So this is a transaction that just went through about 12 seconds ago, sending one USDC from this account to the other one, all on the Polygon Mumbai chain. We're on major, pretty much almost all major EVM chains. If you want to look at our bounties, as well as some of the chains that are available here, we're available on polygon, we're available on base. We're available on Linear as well as Arbitrum.
02:08:39.168 - 02:08:45.700, Speaker G: So if you're hacking on any of those chains for the hackathon, you're able to use our SDK.
02:08:46.680 - 02:08:47.284, Speaker B: Cool.
02:08:47.402 - 02:09:33.220, Speaker G: So that's very basic example, right? Just kind of like what's possible. Let's see how that actually works. I'm going to go over to our documentation and show you an implementation of the session key validation module smart contract that actually allows this to happen. So you can actually use this as an example to build your own session key validation modules. But in this instance, this is an ERC 20 session validation module, which takes a few different permissions for you to look at for the little demo that I just did. One, it's going to take some information for the session key itself. This session key is going to have four different arguments in it and I'll kind of go over those later.
02:09:33.220 - 02:10:19.412, Speaker G: It's going to take a token. In this case, I sent USDC. So the USDC token address, it's going to take a recipient. In my case, I hard coded the recipient only to be my other EOA. You can obviously change this logic, but this makes it so that within the session I can only transfer ERC, 20 tokens to that specific account. So here we're looking at the different permissions of what's actually allowed in the session. And then there's just a max amount that I cannot cross over during any of these sessions, right? So this is just doing all of the checks, making sure that the token that is supplied in the argument matches the token in the session key, which would be the USDC that I used.
02:10:19.412 - 02:11:01.712, Speaker G: This is also requiring that the call value equals zero. If you want to do your own kind of like session key validation module, let's say you're minting an NFT that needs some value. You would remove like a line like this and just make sure there's a certain value attached to it. So this is just like a base for what you can use to actually build your own modules. Next is just checking if the recipient is actually the same as the one that's specified in the session. Again, I can only send to that one recipient and making sure that the max amount is not exceeded. This specific function here and this specific function here, they do more or less the same thing.
02:11:01.712 - 02:11:42.328, Speaker G: This function is called from our session validation manager. The manager essentially you supply it a deployed smart contract. In this case, we deploy this contract for you so you can start doing the transfers yourself. But if you wanted to use your own contract, build it on top of this, deploy it, just switch the contract address. You have a session validation module that you can use with our SDK. So this is called specifically by the session key manager. And if you're doing something like batching sessions together, we have another batch session router which allows you to batch multiple different types of sessions.
02:11:42.328 - 02:12:28.824, Speaker G: This is the function that's called in that case, if you want the base kind of like how to build, we have the actual contracts that are linked here. So you can use the interface and follow the example here to build your own modules, deploy it and use it on our SDK. How do you actually use it? So to actually use it in an application, it first thing you want to do is set up your Biconomy Smart account. In this case, I'm using the Biconomy Smart account v two. That's our latest version of the Smart account itself. You create an instance of your bundler. You can grab your bundler straight from the dashboard for testnets.
02:12:28.824 - 02:13:07.400, Speaker G: You can actually just use variations of this link and just change the chain ID. Also, from your Biconomy dashboard, you can grab a URL for your paymaster. And I recommend using your own URL because none of your transactions will work on this URL. But cool. This is just like a connect button just to connect to the actual MetaMask wallet. Nothing fancy here. I'm just doing an Ethers request for request accounts, and then I'm using our ECDSA ownership validation module to create the signer that's going to control the Smart account.
02:13:07.400 - 02:13:44.676, Speaker G: So that's this step here, essentially passing the signer that I get from MetaMask over to the ownership module here. The cool thing about this is we're signer Agnostic. This is one way of me creating a signer, a simple way through Ethersjs. However, you can use any type of authentication system that you want. Another sponsor here is Privy. If you wanted to use Privy to create a signer, you can actually use their SDK, create a signer, pass it to us. Now you have a Biconomy Smart account created by the signer from a Privy account.
02:13:44.676 - 02:14:01.690, Speaker G: And this is the same. If you want to do something like Wallet Connect, you want to use Wallet Connect to Connect, get your signer. You can do that too. This is just a basic example. This is not the only way to create the signer. You can create the signer in any way you want. As long as you pass the signer to the address, you're good to go.
02:14:01.690 - 02:14:48.810, Speaker G: Last thing here we create the account. These are just the different validation modules and everything you need on the creating the session side of things where you actually create your session. One thing that I mentioned before is you're essentially using a deployed Smart contract, right? That's the smart contract that we went through before. Replace this with any smart contract that you want, that you've built on top of that for your specific use case, right? So if you want to add more permissions, more granular activity onto your module, you can do. So you want to replace it with like an ERC 721 module? Go ahead, whatever you want. All you got to do is just replace this address.
02:14:52.480 - 02:14:53.230, Speaker A: Cool.
02:14:54.000 - 02:15:24.530, Speaker G: In terms of the actual transfer itself, again, we're making sure that we're using that ERC 20 module. We're making sure that we use the Session key manager module. This is all just copy and pastable things from our documentation. This repo is available on GitHub. There is a step by step how to recreate this exact project on our documentation as well. Just for the interest of time, I can't go through every single detail, but here I'm transferring the funds to a specific.
