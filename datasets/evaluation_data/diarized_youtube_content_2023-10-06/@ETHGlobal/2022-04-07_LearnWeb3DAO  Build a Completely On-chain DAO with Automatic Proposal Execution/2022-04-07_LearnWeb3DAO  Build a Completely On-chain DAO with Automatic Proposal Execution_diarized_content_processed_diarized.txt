00:00:00.090 - 00:00:32.210, Speaker A: Next, we have Hardik here from Learn Web Three Dow and who's going to do a workshop on build a completely on chain Dow with automatic proposal execution. Questions will go into the zoom chat, so if you have any questions, definitely feel free to send it in there. And Hardik will answer them all at the end of the workshop. The workshop is an hour long and it also is recorded and streamed live to YouTube for you to refer back to at any time after the workshop ends. And with that being said, I'll pass the mic off to Hardik.
00:00:32.370 - 00:00:51.310, Speaker B: Perfect. Thank you, Anna. Hey, everyone. So we're going to learn how to build an on chain Dao with automatic proposal execution. And actually, what does all that mean? So, a little bit about me. I'm Hardik. Fun fact, I have no first name legally.
00:00:51.310 - 00:01:24.360, Speaker B: I'm the co founder of Learn Web Three dow. Huge, decentralized identity. Maxi. I currently work at three Box Labs, the creators of Ceramic Network and X Dapper. So today we're going to spend some time, roughly in three sections. So I'm going to do about five minutes on trying to explain why we're doing what we're doing, spend most of the time actually coding out the contracts. And then I want to hopefully leave ten to 15 minutes for questions and answers at the end.
00:01:24.360 - 00:02:09.590, Speaker B: So what is a Dow? I imagine a lot of people, it might be your first hackathon. So just to give you a quick overview, adao is a decentralized autonomous organization. Essentially, they are community led entities that have no central authorities. And ideally, they're supposed to be like fully autonomous, fully transparent. But it's not exactly the reality we live in today. And the reason for that is MakerDAO and Molok are two very prevalent examples of on chain DAOs, where proposals happen on chain, voting happens on chain. Everything is on the ethereum blockchain for you to look at.
00:02:09.590 - 00:02:56.146, Speaker B: But mostly all other Dows are off chain, right? And this means that tools like Snapshot or Tally, you go there and you vote on snapshot instead of on chain. And what this ends up doing is off chain DAOs have some pros. I'm not saying they're bad. There are pros, right? You can get voting without gas, so you don't have to pay gas just to vote on a proposal. So potentially you get more voters if you have an off chain Dow. And it's also very easy to take part in them, right? You just open snapshot, you connect your wallet, and then it's a single interface for like, 100 different Dows. The cons are off chain.
00:02:56.146 - 00:03:51.394, Speaker B: Voting does mean that proposals don't automatically get executed even if they pass. So you have to rely on the project team with a multisig wallet maybe to actually execute the proposal after it has passed. And recently, there have been a couple of cases as of late where a proposal which passed on snapshot didn't actually get executed because the team didn't like it. Even if they actually did pass on snapshot and it's off chain, you need someone, you need the team or the multisig to execute it, so you can't really do anything. And that goes against the ideal vision for what a Dow is supposed to be. So on chain Dows also come with their pros and cons, right? They're not a silver bullet. So you don't need trust, you don't need to trust a team to execute the proposals.
00:03:51.394 - 00:04:36.930, Speaker B: And everything is verifiable and transparent on chain, which is arguably better than on IPFS. But the cons are it costs Gas to do votes and general purpose dow where proposals can end up executing arbitrary transactions, requires some specialized interfaces on the development side to properly construct those proposals in an easy to use way. So today we are going to build an on chain Dao. I know it's going to cost Gas to vote, but we're going to focus on the trust problem and it's going to be a relatively simple Dao. So we have an NFT collection. We'll call it crypto. Devs NFT.
00:04:36.930 - 00:05:11.454, Speaker B: We'll create the crypto. Devs dao. And the way it will work is every person who owns the NFT can choose to be a member in the Dao. And the Dao has some ETH that it controls and then it can buy and sell other NFTs from a secondary marketplace. So something like OpenSea so members can create proposals. Hey, I want to buy this or I want to buy that, and the Dao is doing the purchase. So voting happens and the dow either does a purchase or it sells something.
00:05:11.454 - 00:05:50.022, Speaker B: And the idea is to maximize profit, right? So specifically for this tutorial, we don't have enough time to do every single thing here. So what I want you to do if you're following this live, here's a GitHub link. So go to GitHub.com, learnweb3 dowdowhacksworkshop. So there's a GitHub link where I have set up some boilerplate code. So the NFT code is already there. Actually, I'm going to walk you through it right now, but yeah, clone this repo if you're following along.
00:05:50.022 - 00:06:22.402, Speaker B: If we're going to do this later, feel free to pause here and get started. So let's switch over to Vs code. So I have the repo cloned and let's just quickly take a look at what's all in there. So in the Contracts folder, this is a hard hat repo. In the Contracts folder there are three contracts. So the first is a super simple NFT collection. It just inherits ERC, 721 from Open Zeppelin.
00:06:22.402 - 00:07:04.174, Speaker B: And you can set some max number of NFTs that can be in circulation and you can just mint as many as you want for free, right? If it was a real NFT collection, there'd be like more complex logic here. But for the purposes of this demo, this will work. Very simple NFT contract and then we kind of have a fake NFT marketplace. I've added a bunch of comments. So if you're following along or doing this after the doing this with the recorded video, you can go through it and kind of understand what's going on. But integrating with OpenSea can take a while. Plus, we're also going to test this locally.
00:07:04.174 - 00:07:41.134, Speaker B: So the fake NFT marketplace is like a simple sort of dummy secondary marketplace for NFTs where you can buy any NFT you want for 0.1 E and sell any NFT you want for two e. So you're always going to be in profit. Great job. And then we have a few functions, like a function to purchase, function to sell, and a function to check if something is available for sale. Along with all of this, I have set up some boilerplate code that we will be using. We will not have time to do this live.
00:07:41.134 - 00:08:40.770, Speaker B: So there is a deployment script with hard hat that is going to deploy your NFT contract, deploy the marketplace contract, and then deploy the Dow contract. We are about to code right now. And lastly, I created a bunch of tasks. So if you aren't familiar with hardhat tasks, tasks are essentially like commands you can run on your terminal to do all sorts of cool things with hard hat. In this case, we are going to call smart contract functions on our contracts through the terminal. So there's a decent amount of documentation here to understand what's going on. Also, if you just do NPX hardhat help if you just do NPX hardhat help in your terminal, it will give you a list of all the tasks that exist and what they're used for.
00:08:40.770 - 00:09:15.920, Speaker B: So we are not going to code any of this life. This is all part of the boilerplate. What we are going to code is the actual Dow contract. So the Dow contract is pretty empty, absolutely empty. The only thing this file has, it has a couple of interfaces. So an interface is a way to kind of talk to a different smart contract. So we have an interface for the NFT marketplace and we have an interface for the crypto devs NFT collection and we are going to use some functions from there.
00:09:15.920 - 00:09:56.940, Speaker B: So let's get started. What do we actually need? So for the dao. The first thing we kind of need is, well, we need a way for people to become a member of the Dao. And simultaneously, we need a way for people to leave the Dow. And then we want something to create a proposal in the Dao. And then vote yes or no on a given proposal and something to execute a proposal. Right.
00:09:56.940 - 00:10:42.282, Speaker B: So we're kind of going to go step by step. Let's start off with the first thing. So first of all, we need to kind of get access to the other two smart contracts to check membership and things like that. I'm going to instantiate a couple of I'm going to instantiate the NFTs sorry, the interfaces. So we'll have a fake NFT Marketplace interface and we'll have a cryptodefs NFT interface. And I'm just going to initialize them in a constructor. So we'll have a constructor that will take a couple of addresses which are for these.
00:10:42.282 - 00:11:33.930, Speaker B: So address NFT contract and address Marketplace contract. And we will mark this as payable just so when we are deploying the contract, we can fund it with some ease. And all this is going to do is just set up crypto devs NFT equals Icryptodevs NFT at the NFT contract and NFT Marketplace equals I fake NFT Marketplace Marketplace contract. So this just sets up these two contracts so we can call functions on them later. And these are the addresses we're going to be calling the functions. So we have a couple of kind of objects in this code, right? We have members and members need some information attached with them. We have proposals.
00:11:33.930 - 00:12:10.870, Speaker B: Then each proposal can either be a proposal to buy an NFT or a proposal to sell an NFT. And lastly, each vote can either be a yes vote or a no vote. So I'm just going to set up some data structures to kind of group all of this information together. So let's do a proposal type enum first. So a proposal can either be buy or sell. And then similarly, a vote can either be yay or nay. So a yes vote or a no vote.
00:12:10.870 - 00:12:57.030, Speaker B: Then for each proposal, we're going to create a struct for proposals. There's a few different things we want to track, right? First thing we want to track is the NFT Token ID, the token to buy or sell from the fake marketplace. What is this proposal for? Then we will keep a deadline. So how long does voting go on? Right? It's like a timestamp. And then we want to track the number of yes votes. We want to track the number of no votes. We want to track whether or not this proposal has already been executed.
00:12:57.030 - 00:14:02.310, Speaker B: And finally, well, we want to track the type of this proposal. So is this to buy the NFT Token ID or is this to sell the NFT Token ID? And then lastly, we just want a mapping of everyone who has voted on this proposal. So you cannot vote multiple times. So we'll just keep track of that in a address to Boolean voters mapping. So we'll set this to true after somebody has voted. And how are we going to kind of actually let's start by defining the member struct, right? So what does a member need? Well, we probably want to keep track of the time they joined the Dow, they became a member, but how do we decide how much voting power someone has? Right? So in this example, this is relatively simple. So what we're going to ask them to do is imagine I have like five crypto dev NFTs.
00:14:02.310 - 00:15:01.870, Speaker B: What I can do, I'll just send two of mine to the Dow, right? And that will act as my membership in the Dao. So now I have two votes because I locked up two of my NFTs and as long as they're locked up, I'm a member and I can quit at any point and take my NFTs back and take my share of the profit back, whatever the Dow made. So let's just keep track of all the locked up NFTs. So this is essentially an array of token IDs for the crypto devs NFT that are locked up by this member. All right? And lastly, a few more things. So we need a way to keep track of all the proposals, right? So we'll have a mapping from ID to proposal. So this is all the proposals that currently exist proposal ID to proposal.
00:15:01.870 - 00:15:58.094, Speaker B: And then we will map members so for each address what is their member information, and this is all the members of the Dao. And then we will keep track, lastly, of the total number of proposals that have been created in the Dao and the total voting power of this Dow, which is basically how many NFTs are locked up across all members. All right, so lot of structures created. Let's actually start by writing some actual functions. All right, so let's see. Oh, let me just do one more thing. So we'll add a modifier called member only because most of our functions should only be called by members.
00:15:58.094 - 00:16:49.710, Speaker B: And we can just do a require that members message sender. So the person calling the transaction must have at least one NFT locked up. Otherwise you revert with not a member and then you run the rest of the code. All right, so let's start off by I'm going to leave the membership portion to the end because that is a we're going to do something fancy with it and I guess simultaneously we'll do the quit part at the end. Let's start off by having some code to create a proposal in the Dao. All right, so function create proposal. What do we need? We really need two things from the user.
00:16:49.710 - 00:17:51.422, Speaker B: We need the NFT Token ID that the proposal is for and we need a proposal type. Is this to buy it from the marketplace or is it to sell it on the marketplace? So we'll take in two arguments for Token ID and a proposal type. Proposal type. And this will be an external function and member only. And it will return the newly created ID of the ID of the newly created proposal. So we have to check a couple of things, right? If the proposal type is to buy something, we have to make sure it's actually for sale. So we can require on the NFT marketplace that sorry, my autocomplete is being weird, but we can require on the NFT marketplace that this Token ID is actually available for sale.
00:17:51.422 - 00:18:44.754, Speaker B: Otherwise we throw an error NFT not for sale. So this proposal is kind of useless. Otherwise, if it's a proposal to sell something, we need to make sure that we are the owner of it. Like the Dow must have that NFT before it can go sell it. So we can check the owner of this Token ID must be equal to this contract's address, otherwise not owned, throw with an error. So we've done that. So now to actually create a proposal so when we start off, the NUM proposals will be at zero, right? That's the default value of UN since solidity and the mapping, this will be empty, right? No proposals have been created yet, so let's just assign zero as like the first ID.
00:18:44.754 - 00:19:47.160, Speaker B: So let's load up the proposal struct at Numproposals, which when you call it for the first time will be zero. And then you set some values, you set all the values that we care about. So NFT, Token ID is for token ID and deadline will automatically set the voting deadline for purposes of the demo to only two minutes from the creation time. In real life, this would probably be like multiple days or multiple weeks at least and then we set the type of the proposal, which will be whatever the person passed in and then we increment the number of proposals to make sure the next one gets executed, gets created properly. And lastly, we have to return the proposal ID of the one we just created, right? So we just incremented it for the next one. So the one we just created will be NUM proposals minus one. So we return this ID.
00:19:47.160 - 00:20:34.150, Speaker B: So basically all we're really doing is creating a struct and storing it in the mapping which has some information about the proposal. Then the second thing, once you have a proposal, you want to be able to vote on a proposal. So we create a function vote on proposal UN 256 oops I'm sorry, I'm just checking chat. I should have posted the link here before. Sorry about that. There's the GitHub link in the zoom chat now, so vote on proposal. For that we need a proposal ID, right? And we need to know what kind of vote it is.
00:20:34.150 - 00:21:59.234, Speaker B: Is it a yes vote or is it a no vote? And this will also be an external member only function and we want to check for a few different things here. We want to check the proposal is currently active, which means the deadline hasn't passed yet and we want to check that the person voting hasn't already voted in the past, right? So we load up the proposal from our mapping. So this proposal ID and then we check a couple of things. So first we check that the proposal deadline must be greater than the current block timestamp, otherwise it's an inactive proposal. And we want to also check that the voters so if you remember, the proposal struct had a mapping of voters to booleans. So this address must not have already voted, otherwise we throw with an error already voted. Now that we've done this, we can safely say so we'll mark this address as having voted now, right? And then we'll check the voting power this person has.
00:21:59.234 - 00:22:41.360, Speaker B: So if I have two NFTs locked up in the Dow, I have two votes. That is my voting power. So my voting power is basically equal to my membership struct the number of locked up NFTs I have. So the length of the locked up NFTs array. And lastly, depending on if my vote was a Yay vote, then I increment the proposal yay votes by my voting power. Voting power. Otherwise I increment the nay votes by my voting power.
00:22:41.360 - 00:24:29.342, Speaker B: Right? So we load a proposal, we check that it's active, we check that you haven't already voted, we mark you as having voted now and then we increment either yes votes or no votes, depending on your voting power and what you voted for. Right? So the flow is kind of like somebody creates a proposal, other people come and vote and then eventually the deadline will hit the deadline and the proposal is no longer active. So we need a way for someone to execute a proposal, right? And the difference here is while you still need someone to execute the proposal, you still need someone to make that transaction. Any of the members can do it, first of all, and the owner, like I specifically, if I deploy this contract, I can't stop it, right, unlike like snapshot or something if I was yeah. So for example, if I was on Snapshot, I could stop a proposal from actually being executed by just not executing it. But here, any member can call it and if the proposal has passed, we will automatically do the required function calls and anyone can do it and I don't have any power over them. So to execute a proposal, all we need is a proposal ID and any member can call it whenever they want, right? So similarly, we load the proposal from our mapping and this time we check the opposite.
00:24:29.342 - 00:25:17.730, Speaker B: So we check that the proposal's deadline has passed, it's over now and it's no longer under voting. So it must be less than or equal to current block timestamp. Otherwise we give an error that this is an active proposal and we must ensure that the proposal has not already been executed. Right, cool. Once we do this, we can mark the proposal executed as true. We're going to check a few different so we're going to use a very simple sort of 51% quorum. If more people voted yes, then people voted no, we'll just pass the proposal.
00:25:17.730 - 00:26:32.810, Speaker B: You might want to do in the real life, you might want to do a little more complicated sort of quorum techniques where you must require a certain number of members must have voted and maybe it's like 66% instead of 51%, but I'm just going to do something very simple. All I will check for is if proposal yes votes is greater than proposal nay votes, then we'll do stuff with it. Now, depending on what the proposal was, either you're buying something or you're selling something, right? So if the proposal was of a type to buy an NFT from the marketplace, then we call a certain function on the marketplace, else we call a different function on the marketplace. So if you are buying something, we can get the purchase price of that NFT by doing like NFT purchase price. Really? This is just reading this value. If you're actually integrating with OpenSea, for example, this will be different for every NFT, of course. But we're keeping it simple.
00:26:32.810 - 00:27:04.318, Speaker B: It's just a mock. So we get the purchase price. So this is how much ETH we have to send. And we must make sure that the contract actually has this much ETH to send it, right? So it must have at least greater than or equal to this much ETH to buy it. Otherwise you just don't have enough funds. And if you do that, then we can just do NFT marketplace purchase and we'll send it some ease. So we'll send it the purchase price worth of ease.
00:27:04.318 - 00:27:57.478, Speaker B: And the purchase function needs a Token ID that you want to buy. So that token ID is proposal NFT. Token ID that we saved when we created the proposal. So this is what happens. If the proposal was to buy an NFT, any member can call this function and it'll just automatically buy it from the marketplace, right? If it was a proposal to sell, then we need to make sure that we are oops, I don't think I added that here, actually. So in the fake NFT marketplace oh yes, this is an oversight. So the fake NFT marketplace should actually have a function called owner of.
00:27:57.478 - 00:28:49.778, Speaker B: And I did this when I was completing the tutorial yesterday. Let me just add that function real quick. So the marketplace, we're going to add a quick function which, given a Token ID, returns the current owner of that Token ID, right? And when you are looking to sell something, we need to ensure that well, we actually did ensure that the Dao owns that NFT because we check it when we created the proposal. So the Dao must own that NFT. So now we can just do NFT marketplace sell. And we will sell needs a Token ID as well. And this will send us some ETH in exchange for our token.
00:28:49.778 - 00:29:32.500, Speaker B: So proposal. NFT token? ID. Right? Cool. So this is it for the execute proposal function. Let's take a quick walk through it again. So once a proposal's deadline has passed, any member of the Dow can choose to call this function, right? And what it will do is, if the proposal passed, if the number of yes votes was more than the number of no votes, depending on whether it was a buy proposal or a sell proposal, we execute the required commands to buy or sell the NFT from the marketplace. Right? Makes sense.
00:29:32.500 - 00:30:13.554, Speaker B: Cool. Now let's talk about becoming a member. This is a little interesting, right? So there are two ways you could do this. Either you first ask the user if you guys are familiar with the approval flow in ERC Twenty S and ERC 721. You first need to get the user to approve your contract to transfer NFTs from their account. And then maybe you have a function called Join Dao or whatever. That then transfers the NFT into its own account.
00:30:13.554 - 00:31:12.530, Speaker B: Right? That's one way to do it. I don't like it because it requires two transactions. We can actually do something a little better, which is let's take a look at what actually happens in ERC 721, right? So this is our NFT contract. And if you go a little further down into ERC 721, you will see there exists a function called Safe Transfer From. Right? And what Safe Transfer From will do is if you're sending to a contract, if you're sending to a contract, it will check that the contract is actually capable of receiving an NFT. Right. Because if you're sending to a contract that doesn't know how to deal with ERC 721 NFTs, that NFT is lost forever.
00:31:12.530 - 00:32:12.370, Speaker B: And the way we do this, the way we actually check for this is it's just magical. It's literally just magical. So we shall have a function that is called so we will need to create a function called On ERC 721 Received in our contract which wants to accept ERC 721. And as long as this function returns a specific magic value. Okay, I know it's weird, but this function needs to return a very specific set of four bytes. And the idea is, if the developer of the contract went through the trouble of creating this function, making it return the exact four bytes, then they probably have some way to deal with ERC 720 Ones. This is not a guarantee.
00:32:12.370 - 00:33:01.286, Speaker B: You could very well implement this function but not have a way to do anything with 720 ones, and then that NFD is still lost forever. But that is kind of the trust assumption when 721 uses Safe Transfer from. So all it's going to do is it's going to check if you're transferring your NFT to a contract. It's going to call this On ERC 721 Received function, and it's going to check that it returned four bytes that match this magic value. Otherwise it's going to fail the transaction saying this contract is not set up to deal with NFTs. Now, why am I talking about this? I'm talking about this because we can actually do some cool stuff with this. We're going to implement this function and we are going to return the magic value.
00:33:01.286 - 00:33:49.510, Speaker B: But as part of that, we're also going to make that person a member of the Dao so they don't need to do anything special. They don't need to call a function to join the Dao. They just transfer the NFT to the Dao contract and they automatically become a member of the Dao. All right, the way you do this is Open Zeppelin has an interface we want to use. So open zeppelin contract token, ERC, 721. And they have an interface called IERC 721 receiver sol, which is what we were just looking at right now, this thing. And we want our dow to implement this interface.
00:33:49.510 - 00:34:33.490, Speaker B: So cryptodevs dow is a 721 receiver and then we can have that function. So we're going to create a function that will be called by safe transfer from. So when a user transfers the cryptodes NFT to this address, this function will be called by the NFT contract. And it takes four parameters. It takes an operator address, it takes a from address, it takes a Token ID, the one that was transferred, and it takes some bytes data that we don't care about right now. We actually also don't care about the operator. So you can just remove the variable name so it doesn't give you unused variable warnings.
00:34:33.490 - 00:35:12.480, Speaker B: And we will override this function from the interface and it does still need to return those four magic values for it to succeed. So the way you get those four magic values, it's the selector of this function. If you don't know what a selector is, it's like the first four bytes of the hash of this function signature. You can read more about it in the Ethereum documentations. So that is the magic four bytes we need to return. But other than that, our cool stuff. So the first thing we need to do is, since this is a public function, we don't want anyone to just call it.
00:35:12.480 - 00:36:42.846, Speaker B: You don't want someone to just go to Etherscan and call this function and pretend like they're a member of the Dao. So we do want to check that the token you're claiming you sort of sent this NFT for is coming from is like part of this dow now, right? So you actually did transfer that NFT out, right? Sorry, not an underscore over there, right? And then you also want to track that you're not just calling it like somebody isn't just calling it for a second time, right? If I transfer Token ID zero and I become a member, token ID zero is now owned by this contract, right? But then if you go to Etherscan and call this function with Token ID zero, this require statement will pass because it's going to be like, oh, yes, I own Token ID zero. But it needs to kind of know that it is coming from like it is a new transfer. Right. We're just going to create a quick mapping. So mapping of UN 256 to Boolean. And this is just going to track whether a certain Token ID has already been locked up.
00:36:42.846 - 00:37:49.860, Speaker B: Or not, right? So we check that this contract is the address, sorry, this address is now the owner of the NFT that was transferred and we also need to check that token locked up for this token ID is currently false. So this is being transferred for the first time, otherwise already member or not really already member, but already used for membership, I guess. And then what we're going to do is we're just going to load the member, load the member from storage. So we have the prom address of the person who sent this NFT out. And then we check that if member locked up NFTs, length is zero. So if this is the first time they're becoming a member, we set their joined at timestamp to the current timestamp and this is going to be important. We'll get to that.
00:37:49.860 - 00:38:20.140, Speaker B: And then we are going to increase the total voting power this contract has. So the total number of locked up NFTs this contract has by one. And we are going to add this token ID to their locked up NFTs. All right. And then we're just going to return the magic four bytes. Beautiful. Cool.
00:38:20.140 - 00:39:14.234, Speaker B: And now for the last main function which is quit. How do you quit the Dow? And we're going to hurry through this a little bit. We're running out of time. So we'll have a function quit and any member can call it, right? And what it's going to do is going to load up the member from the mapping and it is going to check and this is where the join date comes in handy. We are going to check that the member, you must have been a member of the Dow for like a minimum period of time before you leave. So for purposes of this demo, I'm going to set it to five minutes, but you can set it to something different. And this is done so that somebody doesn't just join the Dow, doesn't do anything and just quits and walks away with, I don't know, some share of the profit.
00:39:14.234 - 00:40:47.850, Speaker B: Because we are quoting a very simple contract where we don't check their activity. So their share of the profit will be equivalent to basically their voting power divided by the current voting power multiplied by however much ETH is owned by the Dow at the moment. Right? So basically the balance of the Dow multiplied by what was the voting power of this specific member, which is how many NFTs they locked up, divided by the total voting power of the contract. And then we can update the total voting power to get rid of however much votes they had and we can send them their money, we can send message, sender their share and then we can send them all their NFTs back. So we loop over locked up NFTs and we transfer them all out. So on the crypto design Ft contract we call save transfer from and it goes from us to message sender to that specific token ID, and we don't care about data. And then we remove them from the members list so they're no longer a member after they quit.
00:40:47.850 - 00:41:28.630, Speaker B: All right, that's it. For all the functions, the only couple of things I do want to add is I want to add a receive and callback function so people can just send ETH to the Dow and help fund the treasury if they want to. You don't have to do this, but for testing, it's nice, because if your Dow runs out of money, you can just send it some more money. So these functions, they just act as, like, gadget. All. Let me grab your ETH kind of functions. All right, we've basically completed the Dow contract.
00:41:28.630 - 00:41:59.250, Speaker B: I'm going to start showing this off, and I'm going to use the hard hat tasks that I created to kind of walk you through the flow and see it actually working. Right. So let me open up my terminal. I hope you can read this. The first thing we want to do, I created a deployment script, but we need a local hard Hat node for it to work. So on first tab, I'm just going to start a local hard Hat node. You do that by typing NPX hardhat node.
00:41:59.250 - 00:42:34.880, Speaker B: And I will open a different tab in my terminal, zoom in a little bit, fix the size. And this should be somewhere in so I have my local hard Hat node running over here. Right. What I'm going to do, I'm going to deploy these contracts to deploy these Oops. This is not supposed to say robsten. Sorry. I need to fix the package JSON real quick.
00:42:34.880 - 00:43:06.760, Speaker B: The script should be running on localhost, not on Robston. All right. NPM run deploy. Going to deploy on the local hard Hat node we have, and it's going to deploy all the three contracts, right? The NFT contract, the marketplace contract, and the Dow contract. And we're going to keep track oops parse ether 0.5. Where is this error? Oh, right. Makes sense.
00:43:06.760 - 00:43:54.290, Speaker B: I messed that up. Give me 1 second. I am on my second monitor, so just 1 second. It all right. Marketplace deploy demos always go like this. I am fixing this on my other monitor. I missed having a constructor.
00:43:54.290 - 00:44:17.918, Speaker B: I need a payable constructor in the marketplace. So the marketplace has some funds for when we sell it NFTs, and I missed adding that. Once we have that, I just do NPM run deploy again. Sorry about that. Cool. All right, we're at 1245. I have 15 more minutes.
00:44:17.918 - 00:44:38.920, Speaker B: I'm going to try to wrap up the demo in five. Leave ten minutes for questions. All right, compiled. All right, there we go. So the NFT contract has been deployed to this address. Marketplace has been deployed to this address, and crypto devs dow to this address. I am going to keep track of these three things.
00:44:38.920 - 00:45:26.462, Speaker B: So I just copy pasted all these addresses on my Vs code. And let's start off so we have a bunch of hard hat tasks, right? First thing we want to do, let me just show you that they work. So one of the commands is getting my ETH balance. So this is the ETH balance of my account and on a local node, it's probably like almost 10,000 ETH minus some gas. I paid for these deployments and my NFT balance from the crypto devs NFT contract. So I will give it the NFT contract address as a parameter along with the local host network. And I should currently have zero NFTs.
00:45:26.462 - 00:46:07.470, Speaker B: I don't have any crypto NFTs right now. So the first thing we want to do is we want to actually get some NFTs, right? So we're going to do NPX hard hat, mint free NFT, give it the NFT contract and the local host network. These are all tasks that are in the boilerplate. You can look at them. All they are doing is calling the respective functions on the contracts just to make it a little easier to test our things without going through Etherscan or deploying to a testnet, which was behaving very slow yesterday. Etherscan was going down yesterday when I was building this tutorial. But okay, we minted two NFTs.
00:46:07.470 - 00:46:37.770, Speaker B: And if I get my balance now, it should say I have two crypto dev NFTs. Perfect. All right. And what I'm going to try to do, I'm going to try to create a proposal in the Dao. And this will fail because I'm not yet a member of the Dow because I didn't send it my NFTs. But if I try to create it, we should see the error that I am not a member. Yes.
00:46:37.770 - 00:47:02.420, Speaker B: Reverted with error, not a member. So what I'm going to do, I'm going to transfer over my NFTs to the dow. So send NFT to Dow. I have all the addresses and stuff filled in. So I have two tokens token ID one and token ID two. I'm going to send both of them. So I send over the first one.
00:47:02.420 - 00:47:30.646, Speaker B: And you can see in your local hard hat node, like as these transactions are happening, all the functions that are being called. So I sent over token ID one. I'm going to send over Token ID two. And I should have a voting power of two votes. All right, perfect. And if I get my own NFT balance now, it should be zero. We're very close to the time load.
00:47:30.646 - 00:48:09.050, Speaker B: I'm going to rush through the last part. You can run it on your own. I have zero NFTs now. The dow has my NFTs. I am going to create a proposal to buy some NFT with a Token ID of ten from the fake marketplace, right? And we'll have two minutes to vote on this. So we create the proposal to buy and I am a member now because I sent it my NFTs, it successfully created the buy proposal, and I'm going to get proposal. Let's see what it created.
00:48:09.050 - 00:48:40.230, Speaker B: All right, so I have until 1251 to vote on it. It's not yet executed. Zero yes votes zero no vote so far. And this is to purchase Token ID Ten from the marketplace. I'm going to do vote yes on proposal. Proposal ID zero. And since I have two NFDS locked up, it should give me two votes.
00:48:40.230 - 00:48:59.900, Speaker B: So I get the proposal again. Let's see. Perfect. You see, there are two yes votes now. All right. And I have about two minutes left for this. Still perfect.
00:48:59.900 - 00:49:41.290, Speaker B: So essentially, once this timer ends, once the deadline of this passes, what I can do is I can do execute proposal for Proposal IDT row. This will currently fail because the deadline hasn't passed yet. There you go. So it says active proposal, but I can execute it. It will make the marketplace transaction, and the Dow should have less ETH than it started off with. I don't think I showed this to you, but in the deployment script, when we deploy the Dow, I initially fund it with 0.5 E from my test account so it can have some money to buy and sell NFTs.
00:49:41.290 - 00:50:19.314, Speaker B: So it's going to have less than proposal is executed. All right, so it's 1251. Let's see how long we're on the seconds. And all right, there we go. So successfully executed proposal zero. Right? And now if we check the Dow East balance, it should be like 49, because each NFT costs one. And we have an NFT we bought from a different marketplace.
00:50:19.314 - 00:50:38.030, Speaker B: Right. And then you can do kind of similar things. I'm not going to go through all of them just in respect of time. But you can create a proposal to sell the NFT back at a later point. Maybe the price has gone up. So you want to sell back oops not Token ID zero token ID ten. That's what we bought.
00:50:38.030 - 00:51:21.242, Speaker B: And yeah, you can create the sell proposal, vote on it. Anyone can come and execute it. The Dow would have made some profit by that point. And then once you're ready to leave, I'm going to show you what my current ETH and NFT balances are. So currently, I have zero crypto dev NFTs, and I have a very specific ETH balance, like 9999 something oops get ETH balance. I have zero crypto dev NFTs at the moment and 9999 point super long string east. Right.
00:51:21.242 - 00:51:51.480, Speaker B: But if I do quit, say I quit the Dow, I'm done. I'm going to get back, like, some share of the profit. And this is actually oh, see? Yeah. I haven't matched my minimum membership period, which is five minutes. We'll come back to this, but yeah. Any questions? I want to pause here for some questions while we wait for this deadline to exceed. And I also want to thank everyone who came.
00:51:51.480 - 00:52:29.730, Speaker B: So end of presentation. Any questions, please post them in Zoom chat. I'm looking at it right now and I hope you enjoyed this tutorial. If you want more, if you're starting out in Web Three, you want to learn from A to Z, join Learn Web Three. It's a completely free, dev focused education platform and you'll be building alongside 25,000 other people. So I hope to see you there. Happy to answer any questions there as well after the workshop is over, but yeah, I'm going to scroll up to see if there were any questions I missed earlier.
00:52:29.730 - 00:53:04.480, Speaker B: So Christian asked, do we need to check we own the NFT again when executing the proposal before we sell? You could do that. I think it would be fine to do that, but also I just didn't do it for simplicity. I think it was partly an oversight. It was 03:00 a.m When I was writing this. You could add that just to be safe, but either way, the marketplace will fail that transaction anyway. If you don't own the NFT, you're trying to sell, so it has the same effect.
00:53:04.480 - 00:54:04.640, Speaker B: And Mohammed asks, I have one question. In the execute proposal function, why not use an internal function that automatically executes when a deadline is reached instead of an external member only function? So the reason we do that is because how do you know the deadline has reached? Right? Let's say I voted on something and I was the last voter on that proposal. 2 hours later, the deadline has crossed. Somebody at some point needs to make a transaction where it will perform the check. Oh, the deadline has passed, so let me go ahead and execute it now. An alternative to this, if you want to be fancy, you can use chain link keepers and automate this process a little bit so chain link keepers can keep track of all the proposals who deadlines have passed and then execute them automatically. So that's one way.
00:54:04.640 - 00:54:59.700, Speaker B: Cool. VG asks can you commit and push the code you have written? So it's all already on GitHub, actually. So if you go on the Dow hacks workshop I asked you to clone from Main, but if you actually check, there is a second branch on GitHub called Completed, which is all the code I just showed you, pretty much. And this is like everything we just wrote on the completed branch. So you can take a look at it. If you're going to be referencing this later during the hackathon, what is the best way to reach me if you have questions? Discord, probably. So if you I'm super active on the Learn Web Three discord, that's easy way to reach me? Actually, yeah, that's probably the best way.
00:54:59.700 - 00:56:01.080, Speaker B: Luis asks how would you integrate Superfluid to this example to stream out the profits to the members? Intuitively, I feel like Superfluid should be able to do this somehow. I have not personally worked with Superfluid or used it, unfortunately. So I don't have a better answer for you there. I'm sorry. When you say automated tasks or functions via chainlink for a Dao, do you have any ideas of what that could mean? So Chainlink has this thing called chainlink keepers. They just came out with this, and it's essentially a way to kind of automate some transaction calls. So the keepers will check some state on your contract or try to meet some condition, and if the condition is met, they are going to perform the contract call automatically for you in a decentralized way.
00:56:01.080 - 00:56:41.266, Speaker B: So things like maybe you want to execute the proposal automatically the second the deadline passes. You can technically use the Keeper network for this. So the Keeper network can check, oh, has this passed yet? Has this passed yet? Oh, it's passed now. So let me just execute it. And the Keeper network can do this in a decentralized way. And you fund this by having some chainlink tokens locked up on your sort of chain link I don't know what they call it to pay for this upkeep. Yes, it is like on chain cron jobs, basically.
00:56:41.266 - 00:57:09.558, Speaker B: That's right. Except you need to pay with chainlink tokens. Great. And then right before we wrap up, the time should have passed now. So I'm just going to quit the Dow and show you that it actually works. So all right, so it successfully quit the Dow. Now, if you check, I previously owned Zero Crypto.
00:57:09.558 - 00:57:35.650, Speaker B: Dev NFTs. Right. Because they were locked up in the Dow. If I do get NFT balance again, it should show me two. I should have gotten both my NFTs back. There we go. And if I look at my ETH balance now, I should have gotten why did I write NFT NPX hard hat get east balance.
00:57:35.650 - 00:57:54.140, Speaker B: And I should have just slightly more than the last one. So previously I had nine nine nine 9.89 whatever, and now I have nine nine 9.94 whatever. So I made some money. I was the only member. So I got 100% of the Dow treasury back.
00:57:54.140 - 00:58:18.546, Speaker B: And that's also kind of the reason why you want a minimum membership here. You don't want people to just join and instantly leave and walk away with, like, a share. You can do some more advanced logic there, but we had to be respectful of the time. Amazing. I think we're at time. Hit me up on discord. If you have any further questions.
00:58:18.546 - 00:58:28.440, Speaker B: I'll be active in the LW three discord. And thank you. Thank you, everyone, for joining. Thank you so much. Anna, on to you.
00:58:29.050 - 00:59:03.530, Speaker A: Thank you so much, Hardik, for that workshop. It was super informative. I know everyone really enjoyed it. You got a lot of good feedback. So, yeah, really, thank you for taking the time to do this for Dow hacks. And Hardik, I also added you to the Dow Hacks Discord so you can interact with any of the Dow hacks hackers there as well. And that goes for the rest of you, not only can you join the Learn Web three Dow Discord, but also you can also interact with Hardik on the East Global Discord.
00:59:03.690 - 00:59:08.810, Speaker B: Yes, perfect. I will be checking that for at least all of today and tomorrow.
00:59:08.970 - 00:59:27.350, Speaker A: Nice. Awesome. And with that being said, we have a couple more workshops today. Our next workshop is in half an hour with IPFS. So looking forward to seeing you all there as well and I hope you all have a great weekend and can't wait to see your projects.
00:59:29.130 - 00:59:35.362, Speaker B: See you guys. All the best for the hackathon everyone have fun building. Bye.
