00:00:00.410 - 00:00:38.434, Speaker A: Hey everybody, thanks for coming. I want to talk about Arbitrum and the tagline here is off chain contracts with on chain security. Let me start by talking about what we mean when we say that. When we say off chain contracts, what we mean is that Arbitrum lets you take your solidity contract or other EVM contract and move the storage and computation of your contract contract off chain. That stuff never goes to chain. And by doing that we can make the execution of your contract faster and cheaper. We can improve scalability by a substantial factor and we can eliminate the gas limit.
00:00:38.434 - 00:01:32.518, Speaker A: There's now no limit on how much storage or computation your contract can have beyond the limits of the nodes that are running it as native code. So that's off chain contracts, everybody likes to have this stuff, but usually you have to make sacrifices in order to get this. We also provide at the same time on chain security. And what we mean by that is that execution is trustless that if you're a participant in a contract, you acting by yourself can ensure that that contract will execute correctly no matter what anybody else does. And the security of all of this is anchored by an on chain contract that runs on ethereum that provides a sort of trust anchor for the whole Arbitrum system. I'm going to talk a little bit more in a bunch more detail about how we do that and about what the implications are for developers. But this is the basic value proposition.
00:01:32.518 - 00:02:14.898, Speaker A: You sort of get the best of both worlds of being off chain and on chain. Okay, so this leads to a technology stack, the Arbitrum stack which is unusually flexible as layer two systems go. And we have three different use cases or modes of use for what is a single underlying technology. We call these Arbitrum channels, arbitram side chains and Arbitrum roll up. And I'll talk about what these are and how they are related. So you can think of them as separate products, but we actually tend to think of them just as three different ways of using what is a single technology. Okay, so I want to start by talking about closed world contracts.
00:02:14.898 - 00:02:52.754, Speaker A: So what I mean by that is imagine you have a contract that has a fixed set of parties, maybe not too large a set, a fixed, relatively small set of parties who are the only people who will ever care about that contract. And its correctness. Maybe they're playing a game, maybe it's some kind of financial contract with a small fixed number of parties. I want to talk first about this type of contract and then I'll come back later and talk about open world contracts. Okay? So for closed world contracts, one of the standard approaches is state channels. And state channels have a bunch of advantages, but also some disadvantages that I'll talk about in a minute. So state channels are the standard way of doing this.
00:02:52.754 - 00:03:37.986, Speaker A: You have a fixed set of end participants. If those end participants can unanimously agree about what the contract should do, then you're good to go. Anything that they all unanimously agree on, the system might as well accept as correct. And you only need to go on chain to resort to any kind of an on chain activity if there's some kind of a disagreement or dispute or if one of those parties becomes unavailable. This is standard State Channel technology that has been out there for a while. Okay? Now, if there's a dispute, the typical thing to do in a State Channel system is to say that there's an on chain contract which gets initialized with the most recent state that was unanimously agreed by all of the parties off chain. So off chain, you can imagine they evolved the contract up to some point.
00:03:37.986 - 00:04:14.634, Speaker A: Now they can't agree anymore. Now you tell this on chain contract where you were, and the on chain contract is going to continue going from there. Either the on chain contract will wrap up the execution of this contract and pay out any assets that it held, sort of shut down the contract early, if you will, or the onchain contract needs to be able to run that logical contract to completion on chain. Right, this is all, again, standard State Channel stuff. So there's a bunch of limitations of that model. It's good when it works, but there are four main limitations. One is it's fragile.
00:04:14.634 - 00:05:07.738, Speaker A: If one party goes offline, I'm not even talking about malice. If a party just becomes unavailable, then fast progress halts, and you have to move on chain because state channels in the standard configuration can't distinguish between a node being unavailable and being malicious, it has to treat those as the same. The second limitation is they're computationally limited because you always need to be able to fall back to onchain execution. You can't put anything into a State Channel that you couldn't do on chain if you needed to. And that means if you want to do a computation that will use more than the global gas limit, or if you have a contract that has a lot of storage, more storage than you're willing to pay for on Chain, then you can't run that contract in a state channel. Because if you have to go to Chain, you'll be out of luck. Okay? Limitation number three of standard state channels is there's no guaranteed privacy.
00:05:07.738 - 00:05:51.510, Speaker A: Although you can have privacy while you're executing off chain because only the participants need to know what the contract is doing. If you're going to move on Chain, the whole state of the contract, all of its code, all of its data, all of its execution from then on has to be public. And so although you start out in a private state, you can't guarantee privacy. If anything goes wrong, your privacy is blown completely. And then finally number four is most state channel systems force you to develop your app or your DAP in a contract. In a non standard programming model, you have to code for this state transition paradigm, which is not really natural and it's not the way most people either have or want to develop their apps. So those are all limitations of standard state channel models.
00:05:51.510 - 00:06:41.658, Speaker A: So they're great when they work when in the optimistic case if you never have to fall back to onchain. But they have some pretty significant limitations. So Arbitrum channels, which is the first mode of using our Arbitrum technology, solves all four of those issues. First, that we still make progress even when all of the parties are not available and unanimous, we can resolve disputes between the parties about what a contract will do without having to move everything in the world on chain. We have a special fast dispute resolution protocol so that computation and storage don't have to move on chain and therefore are never subject to the global gas limit. We guarantee privacy even in the presence of a dispute. So again, because we don't need to move everything on chain, if there's a dispute, you still get privacy and there's no need to explicitly define state transitions.
00:06:41.658 - 00:07:27.882, Speaker A: You compile your existing solidity contracts to run directly on Arbitrum. So no change in programming model. Okay, so how does it work? Let me sketch briefly how this part works. And basically one way of thinking about how this works is that in the optimistic case, in the case where all of the parties are agreeing and cooperating and available, this works just like state channels. All of the participants in the contract will get together, they will agree on what the contract will do, they will jointly sign the statement of what the contract will do and the system will accept it and you're good to go. The only thing that ever gets written to chain is a cryptographic hash of the state of your contract along with any actions it takes, like payments that it makes. So that's the easy case.
00:07:27.882 - 00:08:38.530, Speaker A: But otherwise, if for some reason a node becomes malicious or participant becomes unavailable, instead of falling back to on chain, we fall back to Arbitrum roll up mode, which is another mode of execution, much more efficient than fully on chain, which I'm going to talk about later. So the keys that make this work and be efficient and much better than state channels are, first of all, this Arbitrum roll up mode and I'll ask you to wait for a few minutes until I talk about that. And second, the ability to switch back and forth if somebody becomes unavailable, your contract will seamlessly switch into the roll up mode, execute in roll up mode for a while, and then once the unavailability is gone, the contract will seamlessly switch back into off chain unanimous mode. So it's the ability to switch back and forth between a fully unanimous, fully off chain mode and a mostly off chain roll up mode. And to be able to do that in a way that's seamless and that the programmer developer doesn't need to worry about, that is another part of the secret sauce here. You never need to move your storage or computation to chain. Okay, let me move on and talk about open world contracts now.
00:08:38.530 - 00:09:24.070, Speaker A: So instead of having a fixed set of participants who are the only people in the universe who care about the contract, now a contract is open, anybody can come along and join, participate, interact with it. Anyone in the world might, in principle care about what this contract is going to do. Okay? So one of the ways of doing this is one of the ways of handling this traditionally is using a side chain. And there's a bunch of different approaches to this. You can use permissionless consensus system like a proof of work or proof of stake based sidechain. You can have Permissioned consensus based on something like a BFT Byzantine fault Tolerant Consensus protocol. But all of these introduce new significant security risks.
00:09:24.070 - 00:10:17.474, Speaker A: For example, if you're using a BFT based side chain, then you have to assume that more than two thirds of the validators of your side chain are honest. And that's not the sort of level of trust that you would like to have in a blockchain application. Okay? But if you like, you can actually use state channels as a consensus mechanism, right? In a side chain, there's a set of validators who are the validators of the side chain and those are the people who are jointly responsible for keeping track of and advancing the state of the side chain. You could have those people interact via a state channel. If you did that with the traditional state channel, it wouldn't be ideal. But let's stick with it for a minute. The idea is the validators participate in a state channel and they rely on all of the other validators to execute correctly to advance on that state channel.
00:10:17.474 - 00:11:05.890, Speaker A: Now, if you use a traditional state channel to do this, you're not going to do very well because you will eventually have to fall back to on chain execution and all of the problems that come from that. But if you're using an Arbitrum channel instead as the coordination means for the validators of a channel of a side chain, I'm sorry, then you get all of the benefits of Arbitrum channels. In particular, you get what we call the any trust model. And what this means is your side chain has a set of validators. And as long as even one of those validators is honest and available, we will guarantee that your side chain will execute correctly, that every contract on it will execute correctly. You don't need to assume that it's majority honest or two thirds honest. It's any one honest.
00:11:05.890 - 00:11:17.474, Speaker A: If you have 50 validators and 49 are malicious and one is honest, the chain will still execute correctly. So that's a very strong guarantee. It's the strongest guarantee you could ask for. Yes.
00:11:17.592 - 00:11:22.146, Speaker B: Are these validators fixed permissions or is this like an open enrollment?
00:11:22.338 - 00:11:26.514, Speaker A: So right now when I'm talking about side chains, this is permissioned.
00:11:26.642 - 00:11:26.886, Speaker B: Yes.
00:11:26.908 - 00:12:42.318, Speaker A: So you have a permissioned set of validators and they're going to monitor a chain or a contract, right? And so what this Arbitrum technology lets you do is run a permission sidechain like that with this any trust model and to be able to do it efficiently while keeping stuff off chain. And basically the way you do this is you take that previous Arbitrum channels technology I talked about and you have the validators of your side chain. Just use that, it's literally the same code. Okay? So if you were to use standard state channels they would not be so great, they would break if you went offline, disputes would stop, halt fast progress and all that. But if you use Arbitrum channels as I said, these problems go away and you get this any trust model and never have to go on chain I want to talk now about. So this is Arbitrum side chains, right? So the Arbitrum state channels as a consensus mechanism and you get this any trust guarantee. Okay, but now what about trustlessness? This sort of relates to your question, right? That Arbitrum side chains, you need at least one validator to be trusted in order.
00:12:42.318 - 00:13:38.114, Speaker A: So that means for example, that the validators can't all be anonymous as an example because it's hard to trust people if you don't know who they are. So some applications require trustlessness and they also require the ability of participants or even validators to remain anonymous, auger being an example. So for that model we have yet the third model of execution that we call Arbitrarium rollup. So this is like a sidechain, except it is not permissioned. That is anybody can act as a validator. And so this means that if you are a participant or even a person who cares about a particular contract, you can make sure all by yourself that it will execute correctly. So basically, right, it's like a side chain but anybody can validate and so it's trustless assuming that the people who care actually step up and do validation or if you like, if you prefer not to be a validator yourself, you can always pay someone to do it for you.
00:13:38.114 - 00:14:33.166, Speaker A: So execution and storage are off chain and as in other roll up models, the call data that goes along with calls to a contract is posted as call data on chain. So the downsides of this compared to the other models are you give up the privacy guarantee because these contracts are big and open. If anybody can validate, then anybody needs to be able to see what's in the contract and you give up instant finality, which is a property that the other models can give you when they're operating in the anonymous mode. But the result is that any contract can get better scaling than you can get with other models. Okay, so how does this work? The key idea in Arbitrum roll up is what we call a disputable assertion. And so the idea is something like this. So imagine that one validator makes a claim.
00:14:33.166 - 00:15:26.530, Speaker A: So on chain we have recorded the cryptographic hash of the state of a particular contract. And this validator claims that starting in the current state, that the contract can execute N instructions and the result will be this state hash and that along the way, the contract will make some payments and will send certain messages. When this is posted on chain, it goes into a pending state and a time window is open, during which other validators really in this open mode, anybody can step up and challenge that and say that it's wrong. The person who makes this assertion has to put down a deposit, which they risk losing if they're wrong. Okay? If nobody issues a challenge during the challenge period, then this assertion will be confirmed and the state of the contract will be advanced. And so this will now be the new state. Hash of the contract and cryptographic hashes of the state are all that are recorded on chain.
00:15:26.530 - 00:16:18.418, Speaker A: If on the other hand, there is a challenge, if now this assertion is put on chain and somebody challenges it, let's say Alice puts it on chain and Bob challenges it, he says, no, that's wrong. Now, there is an on chain dispute resolution protocol which is able to determine whether Alice is wrong or Bob is wrong efficiently. And this goes in two steps. The first step is logically a sort of Bisection protocol where Alice is responsible for taking her initial N step assertion and breaking it into two N over two step assertions which together add up to form the initial one. So if Alice was wrong in her big assertion, then at least one of these two needs to be wrong. And Bob's now on the hook to say which one he thinks is wrong. So Bob chooses in this example to point to the second one is wrong.
00:16:18.418 - 00:16:55.518, Speaker A: So notice the on chain component just needed to make sure that these sub assertions were each half is large and that the end state of the first one was the same as the beginning state of the second one. And then also that Bob actually issued a challenge in a timely way. So that's very cheap to verify on chain. Now we've cut the size of the dispute in half and you can probably guess what happens next. They keep doing it. Alice Bisects again, Bob challenges again and so on until you get down to Alice making an assertion about one step of execution, which Bob has challenged. So this one step of execution might be like a single ad instruction.
00:16:55.518 - 00:17:34.922, Speaker A: So very easy and small. Now, Alice, the assertor has to offer on chain a one step proof. That is basically just enough information that allows us the simple on chain contract to verify that, starting in this state hash. If you execute one instruction, you get to that state hash. So this one step proof is because of the way we've designed our system, just a few hundred bytes in size and it can be verified on chain with about 90,000 Ethereum gas. So very cheap arbitram one step proofs are constant size independent of contract complexity, independent of the amount of storage in your contract. They don't require fancy cryptography.
00:17:34.922 - 00:17:55.278, Speaker A: There's no zero knowledge proof going on here. This is just hashes and signatures. Okay, so we have this slide that sort of summarizes the use cases. They have their different pros and cons depending on what you want. You'll want to be in one or another of these use cases. But it's a single technology that covers them all. Okay, how does this work? It's built on top of Ethereum.
00:17:55.278 - 00:18:44.690, Speaker A: We have a compiler that takes your solidity code or EVM code and compiles it to run on our AVM architecture. We offer plugins for your front end development for web3, Ethers and Go Ethereum. If you use those plugins, it's just in the case of web3 and Ethers, a single line of initialization code that you need to add to your JavaScript front end and you're good to go. These virtual machines that are running on Arbitrum can send and receive Ether or any ERC, 20 or 721 token with regular Ethereum users or regular Ethereum contracts. And our code is available here. And we have a $1,500 API prize here at East Waterloo. Okay, so that's a quick summary.
00:18:44.690 - 00:18:52.246, Speaker A: Happy to take questions in the remaining time. Sorry.
00:18:52.348 - 00:18:58.680, Speaker B: Yes. I think I can understand why only one candidate is honest.
00:19:03.150 - 00:19:56.550, Speaker A: So here's one way of thinking about it. Many other systems are designed to rely on getting to consensus, meaning agreement. So that's kind of like a form of voting, right? So with voting you need to have something like a majority or plurality or two third or supermajority requirement. Whereas with Arbitrum, we're not trying to figure out which answer is most popular, we're trying to figure out which one is right. So if there's any dispute, there is this trusted on chain component which is going to figure out not who got more votes, but who was actually right. And because the on chain component determines truth rather than popularity, if even one person raises their hand in favor of the truth, they will be able to win any disputes against everybody else and they'll be able to make that correct outcome be the one that gets accepted.
00:19:56.630 - 00:19:58.938, Speaker B: What do you put that node to? Get happy.
00:19:59.104 - 00:20:42.822, Speaker A: So if there is no honest node, then you are in trouble if there's no honest validator. So in the roll up mode, anybody can be a Validator. So you can be a Validator. Right. It is true that we give you if all of the parties participating in a contract are dishonest, then we are not going to be able to guarantee what that contract will do. In the channels mode, that kind of doesn't matter, right? If Alice and Bob are playing chess and they decide that they mutually want to agree, allow Bob to make an illegal chess know, the rest of the world doesn't really care. In the roll up mode, anyone is able to stand up for their own rights.
00:20:42.822 - 00:21:26.530, Speaker A: So it's only in that sort of in between mode, the side chain mode, where there's a fixed set of Validators, where if every single one of them is dishonest and they're all colluding, they can do what they want. But again, in any kind of a side chain based model, you have this issue that there's a fixed set of Validators. In other models, if a third of them are dishonest, or if half of them are dishonest, you're in trouble. In Arbitrum, it's only if every single one is dishonest. And that's, we think, the strongest guarantee you can get in a side chain based model. Yes, in that case, when you're in that so of these three use cases, when you're in the side chain mode, there's a fixed set of Validators. So that is permissioned.
00:21:26.530 - 00:21:48.282, Speaker A: And so you have to rely on at least one of those Validators, to be honest. But in the other modes, either channel where everyone who's participating in the contract is a validator, or roll up, where anybody can participate in the protocol, in both of those cases, it's trustless, because if you're a participant in the protocol, then you by yourself can force correct execution.
00:21:48.426 - 00:21:48.734, Speaker B: Right?
00:21:48.772 - 00:21:55.278, Speaker A: That's what trustless means. How can we provide?
00:21:55.444 - 00:21:55.726, Speaker B: Right.
00:21:55.748 - 00:22:19.560, Speaker A: So here, participants, only the participants need to know what the contract is doing, but the rest of the world doesn't. In the case of a side chain, all the Validators need to know. And in roll up, it's an inherently public model. If anybody can act as a Validator, then anybody needs to be able to know everything about what's going on. So we don't think it's possible to provide privacy in this kind of roll up model.
00:22:20.890 - 00:22:22.760, Speaker B: Okay? Makes sense. Great.
00:22:23.290 - 00:22:46.060, Speaker A: Any other questions? All right, we have a channel on the conference discord. We have a table. We've seen many of your faces there, but for those of you who haven't come by, come on by and we're happy to talk more. If you want to look at our code, it is right here. It's on GitHub at the URL that you might.
