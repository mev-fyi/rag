00:00:08.090 - 00:00:31.186, Speaker A: All right. Hello. Hello. My name is Kelvin. I work on optimism, which, if you don't know, is a layer two on Ethereum, one of the cool ones. And I'm going to spend this is going to be kind of a different talk than normal. I'm going to spend one minutes showing you how to deploy to optimism, and then 29 minutes looking at cool, solidity EVM tricks.
00:00:31.186 - 00:00:58.986, Speaker A: This is not all of the EVM tricks, because there are so many of them, but these are the cool ones. So here we go. All right, so back last year, optimism was really hard to deploy to. It was really annoying. You used to have used this thing called the OVM, and you had to compile your contracts with a special OVM compiler, and it was a whole mess. So we rebuilt the thing and made it easy so you don't have to do that now. It's just like deploying to any other network.
00:00:58.986 - 00:01:27.234, Speaker A: So I'm not going to actually deploy, but I will show you how to do it. If you want to do it through remix. If you really want to do this through remix, I guess you can use some tool to get connected to the optimism network in whatever your wallet is. I built this simple website called Chainid Link that you can use to connect to a bunch of different networks. So you can try that or chainlist.org, blah, blah, blah. Right? Get connected to optimism, change your network, go there, write a contract, deploy.
00:01:27.234 - 00:01:59.554, Speaker A: That's it. You don't have to do anything special. It's just like deploying to Ethereum. Or you pick a different network. Right? Easy. Same deal with hard hat, right? All you do is you set up a hard hat project and you add optimism to your hard hat config, and then you write a contract and you deploy with network optimism. How do you add optimism to your hard hat config? Well, here's the details of if you go to community optimism IO, it'll tell you how to do all of that.
00:01:59.554 - 00:02:22.342, Speaker A: It'll tell you what endpoints you can use. It's just like adding any other network to your hard hat config. It's really easy. And if you go to Dev Docs, where are we using your favorite tools? There's a whole page on how to do this. Let me zoom in a little bit. There you go. Here's an example of how you can add it to your hard hat config.
00:02:22.342 - 00:02:35.546, Speaker A: Just add the URL. It's just like ethereum. Great. Fantastic. Okay. Same deal with Truffle. So that same page, community optimism IO, it just tells you how to add it to your Truffle config.
00:02:35.546 - 00:03:09.638, Speaker A: It's really easy. You just write a contract, then deploy with network optimism, just like you would do if you were deploying to Polygon or if you're deploying to Testnet or whatever. You just specify a new network. And that's because we did a lot of work to make sure that it was fully what we call EVM equivalent. So it just runs geth under the hood and that's pretty cool. Same deal with Brownie, except you don't even have to add optimism to your config for Brownie, you just do network optimism and it's built into Brownie, which is very cool. Thank you, Brownie.
00:03:09.638 - 00:03:30.394, Speaker A: That's basically it. That was longer than a minute, so too bad. All right, now the fun part of the workshop, EVM tips and tricks. A lot of them you will not want to use in production, but it's still fine. All right, so Invalid, let's start there. Number ten. We'll do a top ten, Invalid.
00:03:30.394 - 00:04:04.966, Speaker A: Invalid is a really cool Opcode because it just reverts, sort of it does not actually revert. It triggers what we call a non EVM error. Non revert EVM error. And what this means is that there's a class of errors that are not reverts that will cause your call to end and you will lose all of the available gas. So an example of this is like a stack underflow. Let's say you try to pop a variable off the stack and there's nothing there, you're going to get an error like this. Invalid is really cool because originally people just started using this Opcode.
00:04:04.966 - 00:04:36.330, Speaker A: They just picked it and they started using it. And it wasn't defined as an EIP, it was kind of defined by social consensus. And then in EIP 141, they set it aside it as an official Opcode called Invalid, and it is the most efficient way to burn all of the gas that's available in a given call frame. So if you ever need to burn gas really quickly without actually doing work, you just trigger this Opcode and all of your gas will disappear immediately. Very efficient. Okay, call code, callcode. I want to see someone actually find a use for callcode.
00:04:36.330 - 00:05:11.082, Speaker A: Callcode is basically really useless. It's like the original version of delegate call, except they got it wrong. Delegate call, if you aren't familiar, is really useful for proxies. And what it does is it allows you to run the code of another contract, but you still maintain the message sender and the value and all that stuff. So it allows you to do a proxy call. Code was really useless because it would call the code of another contract, but it would also change the message sender to be the address of the contract doing the calling. And so it never actually worked as a proxy.
00:05:11.082 - 00:05:42.570, Speaker A: I don't know if anyone actually uses call code, but if you do, tell me because I don't understand why you would use it. So that's just out there. Yes. Why would you want to burn all the gas in the call? That's a really interesting well, optimism actually has one use case for this. I don't know if it's the only use case, but it is one where as a trick, because message value is really annoying. And if you mark something as payable in solidity and then you want to call another function. You want to pass along value.
00:05:42.570 - 00:06:36.780, Speaker A: That other function has to be marked payable too. And so one example of why you might want to do this is that what optimism does is when you send a message from Ethereum to optimism, you have to pay for that message somehow and you could make it payable. But now app developers, whenever they want to pay for a message, have to make this whole chain of functions payable. It just looks really weird. And your users have to send value with a transaction which they're not used to doing. And so the trick was, well, why don't we just burn a bunch of gas on l one? And we wanted to do this in a way that wouldn't actually put a pressure on nodes because if you're actually doing work, you're putting pressure on nodes. So we can just burn the gas really efficiently by just starting a new we do a call and then we just trigger the invalid op code and then all the gas is gone and it's sort of how you pay for it is by burning gas, if that makes sense.
00:06:36.780 - 00:07:20.170, Speaker A: All right, the identity precompile ethereum has a bunch of pre compiles. They're pretty cool. The identity precompile is probably the weirdest one. It's located at zero x blah blah blah four. And all it does is it returns whatever you give it. So if you give it some call data, it's going to return that call data to you, which sounds really useless and mostly is really useless, but it is useful in certain cases. If you want to gas golf for copying lots of memory at a certain threshold, just doing straight up memory copying by taking reading a word of memory and then rewriting, it gets to be expensive.
00:07:20.170 - 00:07:46.838, Speaker A: So it's easier to just do a call and insert all of this call data and then say, I want it to be returned over here instead and it's cheaper. So fun. If you want a gas golf, generally not that useful otherwise. Although it is also the source of various geth bugs. So risky. Pre compile. Okay, solidity tricks.
00:07:46.838 - 00:08:14.266, Speaker A: These are kind of mixed EVM and solidity tricks. I feel like I'm going a bit fast here so I got to slow it down a little bit. Solidity exposes contract type information. If you aren't aware of this, you can use this type and then my contract and it gives you meta information. So it gives you stuff like the name of the contract, the creation code, the runtime code and the interface ID. All of these things are pretty useful. The name maybe not so much.
00:08:14.266 - 00:09:03.930, Speaker A: Although I could see use cases for it where let's say you want to do like a let's see what's a good example you could do something like I don't know what you would do. Do some version string, return some version string and it involves the name of the contract. I don't know, whatever. The creation code though is really useful. If you want to, let's say, make instances of a contract, you can basically get access to the creation code instead of running, you know, new contract, you can do like a low level create and there's sort of useful cases for why you might want to do that. Yes, sorry. So I will actually talk about this a little bit later.
00:09:03.930 - 00:10:24.686, Speaker A: But in Ethereum when you create a contract, you have two sort of types of code. There's the creation code and the runtime code. And what happens is or what happened was that Ethereum really wanted constructors and so what they decided to be able to have constructors was when you call the create opcode, you pass it some EVM bytecode and that EVM bytecode actually executes and whatever that EVM bytecode returns becomes the code of the contract that you have created. So every contract has these two pieces, the creation code and the runtime code. And so the creation code runs when the contract is being created and it's expected to return the runtime code. And this is of course really useful for Constructors because it means that in the creation code you can do stuff like set a bunch of storage to initialize the contract and then once you're done, you can return the code and the contract has done some work in the initialization step. And then the Interface ID is really useful if you've ever used EIP one six five, which is this supports Interface thing where you can query a function and the function will tell you what interfaces a certain contract supports.
00:10:24.686 - 00:11:20.866, Speaker A: You can just really simply return type myContract Interface ID and that's a very easy way. Instead of having to do this like whole XOR of different stuff, it does this for you. So very useful. Saves you a couple of lines of code. All right, another one that not a lot of people know about, but it's pretty cool. Solidity has function types so you can actually pass references of functions into other functions which allows you to do things like Map, right? So this is one of the examples from the Solidity docs where you can let's say you want to define a Map function and it takes an array as the first parameter, an array of uns and it takes a function that takes a UN and returns a uint. And what Map is going to do here you can see it's going to create a results array and then it's going to loop over the input array.
00:11:20.866 - 00:12:10.230, Speaker A: And then you can see here it's applying the function to each input value to generate the outputs. So this is pretty cool. You can do this for a lot of interesting things where you just want to save some code or save some lines of code by just passing functions around. It can be a little finicky sometimes with typings and external and public. I don't know if this has been fixed in more recent versions of Solidity, but when this first came out, it was a little finicky, but should mostly work and a cool way to do a little bit of this meta programming. Okay, related to this, Solidity recently introduced this thing called Abi encode call. So if you have been writing Solidity for a while, you probably know.
00:12:10.230 - 00:12:55.726, Speaker A: Yes, I believe so. Yeah, probably try. It should work. Yeah, probably. I mean, if it doesn't work, we'll find out Solidity. Okay, so people are probably familiar with the classic abi encode and Abi encode pact, but Solidity also has these cool things, abi encode with signature and Abi encode with selector, which is really good for encoding function calls to other contracts. And relatively recently, the problem with these with encode with selector and encode with signature was that it wasn't type checked.
00:12:55.726 - 00:13:43.282, Speaker A: So you didn't actually know if you were properly encoding the call to the target contract until you started testing. Presumably you write tests that show you whether you're properly encoding this or not, and you get some sort of error when you run your tests. But recently, Solidity introduced Abi encodecall where you pass myContract my function selector as the first parameter parameter and you pass the params here. And in Solidity will actually compile this type check. It make sure that you are properly encoding your calls to the other contracts. So this is a great way to make sure that you are encoding things correctly and save yourself the headache of having to write a bunch of tests and only finding out later that you messed something up. Cool.
00:13:43.282 - 00:14:14.606, Speaker A: And that takes advantage, of course, of the fact that you can pass in function references. Well, in this case, I guess it's using the selector, but whatever. Same idea. All right, this one is something that not a lot of people know. You cannot deploy contracts that have bytecodes starting with zero x EF or actually just zero x EF, which implies zero x EF, but really it's just zero x EF. You're not allowed to do this. Try it.
00:14:14.606 - 00:15:07.802, Speaker A: Try deploying a smart contract to Ethereum where the bytecode of the smart contract is zero x EF. You can't do it. And that's because of this thing called the Ethereum object format, which was starting to be introduced, which is I'll talk about when it was introduced. And the Ethereum object format was initially trying to solve this problem of right now, code and data in smart contracts are the same thing. And this is how you get these weird things. Like, technically, the constructor is something that you can jump to and execute. Or technically, the hash at the end of the smart contract that Solidity appends is code that you can jump to, and you can run that code and you can use it to do cool, capture the flag things or whatever puzzles.
00:15:07.802 - 00:16:29.430, Speaker A: But this actually creates problems in the EVM because the EVM has to look for every single every time you do a jump in the EVM, it has to figure out is this somewhere I'm legally allowed to jump to in your code? And in order to do that, you have to check is the thing that I'm jumping to a jump desk opcode and there's all these different things. But basically we can eliminate a lot of this analysis by explicitly separating code and data. But you can use this ethereum object format to do a lot more interesting things. But of course we don't have this right now, so how do we make sure that we will have it in the future? We define some prefix and we block people from deploying contracts with that prefix. And then in the future we'll allow people to deploy that contracts with that prefix. Again with the assumption that the EVM reads that prefix and it says, okay, I know that if it starts with EF something, this is an ethereum object format compatible smart contract and I know that it's going to have the following format and I'll talk a little bit about what you can do with that. How is this possible? So what happened was in the London hard fork EIP 35 41, it was announced that all contracts starting with zero XEF would be blocked.
00:16:29.430 - 00:17:13.654, Speaker A: So of course people started deploying contracts that started with zero XEF. And then what people did was they just looked on chain and they figured out, well, sure they deployed something that started with zero X EF, but they didn't deploy anything that started with zero X EF. So we'll just pick that instead and you can't deploy any new ones. So good enough, it has the potential to be really cool. So the EOF ethereum object format contracts would start with zero X EF and then a version byte and that version byte tells the EF how it's supposed to parse the contract. So one example here is that it says, let's say this is a version zero contract. We'll say that there is a specific area here defined as the length of the to tell you the length of the code.
00:17:13.654 - 00:17:50.578, Speaker A: Then you have the code and then you have the length of the data and then you have the data or something like that. And you can also use this same trick to deprecate opcodes. So you can say, let's say that nobody is allowed to deploy any more version zero contracts and in version one you are not allowed to deploy a contract that includes some opcode that we don't want people using anymore because we hate it. So we can do this really interesting stuff. So not technically out yet, but will be and will be really cool. Create two. Okay, so this is something that you might already know.
00:17:50.578 - 00:18:32.822, Speaker A: Create two is really useful. If you don't know it, you should be using it more often. If you do know this great. If you don't, you should. The original create Opcode, as it says here, generates addresses based on the creator address and the creator's nonce, but create two generates addresses based on the creator's address, the contract code and the salt, which means that they're basically deterministic and it doesn't depend what chain you're on. You can deploy the same contract to every single chain, which is really important, especially in the MultiChain world. You don't want a situation where two contracts can exist on different networks at the same address, but have different code that can be damaging.
00:18:32.822 - 00:18:57.554, Speaker A: So use it generally more secure, be a little careful, whatever. Fine. I'm going to skip that. Self destruct is extremely sus, but it has some cool stuff. So self destruct will delete a contract from the state try and it will transfer its balance to the beneficiary. Very cool. Very cool Opcode.
00:18:57.554 - 00:19:58.410, Speaker A: A lot of people hate it and it's created a lot of bugs for people, but whatever. So a contract is sus, or self destruct is sus, because a contract that uses self destruct can delete itself and then it can be recreated at the same address with completely different code, which is kind of a cool way to do upgradable smart contracts. And I think some people have done this before, it's a little terrifying. And there's definitely been situations where block explorers don't work or you end up with a parody situation where somebody just hits the kill button or whatever and you can't do anything about it. So be very careful with that. And then self destruct is the only way to send ETH to another address without triggering its code, which can be very useful if, let's say, a contract has code in it that says, when I receive ETH, revert immediately. So if you want to forcibly send ETH to somebody and they can't do anything about it, just use self destruct.
00:19:58.410 - 00:20:32.440, Speaker A: So remember that if you're auditing a contract, make sure that you don't make assumptions about a contract not being able to receive ETH, because you will be able to receive ETH no matter what. And it's also the only way to permanently delete ETH from the supply. So yes, of course you can send ETH to a burn address, like the zero address, but it's still technically in the supply even though it's not accessible. Self destruct is the only way. If you self destruct to yourself, it's the only way to delete ETH from the supply permanently. It just gets poof, it's gone. Right? All right.
00:20:32.440 - 00:21:00.974, Speaker A: Yeah. Self destruct just does it in the code for self destruct. It basically when you trigger the opcode, it will just increase the balance of the recipient and it won't actually trigger a call to the recipient. So it's the only way to do it. I'll have to run through these because I'm actually getting quite tight here. Block hash is the ultimate oracle that nobody uses. I wish more people did it's really, really cool.
00:21:00.974 - 00:21:21.750, Speaker A: Block hash obviously contains information about the entire ethereum blockchain. It's a blockchain. So the block hash contains information about the current block, but it also contains the previous block hash, which means you have a chain all the way back to block zero. And using merkel, patricia, try proofs. You can access literally anything in the ethereum. Try not enough people do this. It's really cool.
00:21:21.750 - 00:21:38.326, Speaker A: Optimism has built a library for verifying merkel. Patricia, try proofs. So you can do this on chain. You can read the storage of other accounts. You can read event logs. You can do whatever, right? Everyone says like, well, contracts can't access events. No, they totally can access events.
00:21:38.326 - 00:21:59.666, Speaker A: You just need to do a merkel. Try proof. It's expensive, but you can. And there's a lot of reasons why people didn't want people to access this stuff. But anyway, you can access it. It's the ultimate oracle and no one uses it. And I bet you could build a really sick hackathon project by just doing some unexpected thing by reading information from the ethereum state.
00:21:59.666 - 00:22:32.010, Speaker A: Like, you can literally just go and read the storage of any other contract. You normally cannot do that. Block hash only goes back 256 blocks, but you can always walk backwards by doing proofs. So you say, well, I'll prove about the current block, and then I'll show you the contents of the previous block hash. And I'll just repeat this because the previous block hash contains the block hash before that, and you just go in this chain backwards. And Optimism really wants to build a block hash oracle. So we would kind of have a chain of block hashes into eternity.
00:22:32.010 - 00:23:18.298, Speaker A: So if you're interested in working on that as a hackathon project, it would be really cool, kind of like a collaborative way for the entire theorem community to store every block hash so that we have access to it, not just for the last 256 blocks, but for every single block. Requires a lot of proofs, but I'm sure as a community, we can do it together. And great. So create this is number one. This is probably the coolest one that people don't really think about. When I talked earlier about contract creation, I said that create, executes init code this initialization code creation code, and whatever that code returns becomes the contract code. And the secret thing in here is that create executes the init code.
00:23:18.298 - 00:23:52.178, Speaker A: So create, executes arbitrary EVM bytecode. You can literally just pass whatever you want, right? I don't actually have to create a contract. I can pass push one, push one, add as the instructions, as the init code. And what it's going to do is it's going to push one to the stack. It's going to push one to the stack, it's going to add the two, and then it's going to have two, the value two on the stack. And then I don't know, then it just stops and it doesn't do anything. But what you can do is you can execute arbitrary bytecode.
00:23:52.178 - 00:24:25.146, Speaker A: You can do whatever you want. You don't actually have to create a contract. You can do math or whatever. You can basically have, like, user provided scripts that you run and you can kind of do whatever you want. So you can make a simple scripting language where let's see, what did I yeah, okay, so here's an example, right? Let's say you want to do, like, a scripting language that doesn't actually change state. You can do something like put all the inputs in call data, run, create with the user script as NIT code. So it just runs these EVM opcodes.
00:24:25.146 - 00:25:36.214, Speaker A: Then the user script reads the call data, so it reads the inputs, and then the user script is going to revert so it doesn't actually change anything and you read the result from the return data. The other reason to revert here is that, like I said, this is still a contract creation. And if you return, then it actually goes and creates a contract with whatever is in the return data. But the EVM has a quirk where if you revert, then whatever you return, instead of being created as a contract, just gets put into the return data buffer so you can read it. So optimism almost did this. I was too scared to put it into production, but I built it where we had this whole system of these contracts that would drip ETH to other contracts. And originally I wrote this whole system where I wrote this whole system where we could provide these small EVM bytecode scripts and the EVM bytecode scripts, they would get created and they would have to do a bunch of work, and they would have to either return or, I guess, revert with a zero or a one.
00:25:36.214 - 00:26:04.482, Speaker A: And if it was a one, that meant that I could go ahead and do whatever I wanted to do. Or if it was a zero, that meant, don't do this. It didn't work. Revert, whatever. So, yeah, I think there's a lot of fun stuff you can do with this and nobody really does it, which means that I think you would look cool if you did it. Was that 29 minutes just about interesting. Okay, I was not expecting to get this far.
00:26:04.482 - 00:26:28.854, Speaker A: Okay. No, that was 29 minutes. One bonus trick. One bonus trick. You can actually in solidity if you drop into assembly in the constructor, you can use the return instruction in the constructor to return whatever you want. And that returned bytecode becomes the code of the contract. So if you wanted to, I don't know, return I don't know what you could return.
00:26:28.854 - 00:26:52.362, Speaker A: You can return whatever you want and that becomes the code of the constructor. And so you can do some really deranged things, like in the constructor, read the code, replace the code with other stuff to be able to use opcodes that Solidity won't let you use and then return, and you do just all this hacky stuff that you should never do in production. Great. Okay, that's exactly 30 minutes. Perfect. Optimism is hiring, as always. Optimism.
00:26:52.362 - 00:27:04.860, Speaker A: Op labs or just come hack. I'll be downstairs hacking on some deranged solidity. Cool. If you have more questions, we can talk afterwards. All right. Thank.
