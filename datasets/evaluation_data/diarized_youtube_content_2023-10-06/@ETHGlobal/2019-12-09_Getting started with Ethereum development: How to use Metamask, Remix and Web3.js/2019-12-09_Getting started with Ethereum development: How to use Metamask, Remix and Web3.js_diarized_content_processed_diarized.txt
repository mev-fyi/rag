00:00:01.770 - 00:00:44.780, Speaker A: So all right, as you guys come in, if you could come towards the front. We're going to do some interactive coding throughout this presentation. So it'll be easier for me to hear you guys. If you're closer and if you have your laptops, if you could grab those, you can see in the ETH Waterloo discord in the general channel channel. I posted a link to the slides that I'll be using, and you guys can follow along as I go through the slides because there's going to be links to specific coding exercises throughout this. I'm going to be just driving through these coding exercises and asking you guys for answers. But I think it'd be helpful for you guys to follow along on your computers as well.
00:00:44.780 - 00:01:19.094, Speaker A: So I guess before we jump in, I just want to say welcome to ETH Waterloo. This is super exciting. I actually came to ETH Waterloo two years ago. That was when I really first this is like my first experience with the Ethereum community. I'm from Detroit, Michigan. My name is Josh Kreitz and I'm with Consensus Academy. I actually came to ETH Waterloo two years ago and I met a lot of people from the Consensus team.
00:01:19.094 - 00:01:56.642, Speaker A: I joined Consensus Academy shortly thereafter at the beginning of 2018. And ETH Waterloo two years ago was an amazing experience. It felt like Ethereum was super new, like we're building new technology. And in a lot of ways we've made a lot of progress. But at the same time, it still feels like this is very new technology. We're still building global infrastructure here. So as much progress as we've made as the Ethereum community, still very new, still exciting space in this talk.
00:01:56.642 - 00:02:48.782, Speaker A: I just want to get new developers, or even like experienced Ethereum developers, just do a refresher on some basic tools on how to get started developing Ethereum DApps throughout this workshop. We're not going to need to. Well, the only piece of software we'll have to install is MetaMask and basically the rest, we can just start writing smart contracts using Remix right in our browser. And we can connect to Web three JS, the JavaScript library to connect to Ethereum and smart contracts just right in our browser without installing any software. So I just want to show how to do that. I'm going to give a little bit of an overview, some context around. I'll just start going through the slides.
00:02:48.782 - 00:04:08.940, Speaker A: I think that'll be the best way to go. And for people coming in, if you don't have access to the discord, you can find these slides@tinyurl.com biddlewaterloo so that URL will direct you to these slides. And I have a lot of URLs in here, so you guys can follow along as I go. But yeah, to start the agenda for this, I'm going to go through Remix and how we can start writing smart contracts on Solidity or in Solidity and deploying them onto any Ethereum blockchain, whether that's the main net a testnet or just a development chain? Installing MetaMask and using MetaMask to connect to the main net and testnets through Remix and then using Remix to compile, deploy and test your contracts. And then from there, once we have contracts deployed onto an Ethereum network, we'll go over how to use Web Three JS to interface with contracts. And Web Three JS is a very common JavaScript library for injecting into Wet, like traditional web interfaces to handle accounts, connect to deployed contracts, sending transactions, and reading contract state.
00:04:08.940 - 00:04:42.082, Speaker A: And to reiterate, this is a workshop. It's not just a presentation, it's interactive. And I will be calling on you guys to help me write smart contracts and go through Web Three JS as I do kind of framing this talk. The mindset I'm bringing here is bringing the idea of just in time learning. There's a lot to learn about Ethereum. It's a very unique development environment. We have unique constraints when we're developing on Ethereum.
00:04:42.082 - 00:05:30.374, Speaker A: It's different than the traditional Web Two space. And I'm not going to cover the entire context of Ethereum and all the constraints that you'll face as developers working on Ethereum. What I want to do here is give you a set of skills to complete a project by the end of the weekend. And that can be anything. I just want you to be able to write a smart contract, deploy it onto an Ethereum testnet and then connect to it, read the contract state and send transactions to it and allow anybody else to interact with it as well. So that's going to leave a lot out of the understanding. But I think just giving you the skills to get started, it makes for a much more rewarding weekend because you'll actually have something to show for it by the end.
00:05:30.374 - 00:06:20.358, Speaker A: So to do that, we're going to get started building ASAP. We're going to start writing code right here, right now, and we're going to do this together. We're going to encounter problems along the way. We're going to see how smart contracts aren't working, and then we're going to figure out why they're not working and basically tackle these problems, solve these problems as we encounter them, as opposed to developing an entire framework of how Ethereum works and coding. After we get a solid mental model of how Ethereum works, I'll give you some skills to start writing contracts and building interfaces for them. But you're going to be encountering these problems throughout the weekend. And I'm available.
00:06:20.358 - 00:07:22.010, Speaker A: I'll be here all weekend. So as you run into problems, come find me and I'd be happy to help. Also, I don't have a team right now, so if you guys have a team or you have an idea, I'd love to team up and hack. So, yeah, I think it's helpful to provide a little bit of a framework before we just dive into code because, like I said, Ethereum is a very unique development environment. So just answering a few questions about writing smart contracts for Ethereum. Writing Smart Contracts in Solidity the first question, what are smart contracts? Smart contracts are just programs that run on Ethereum. They provide a number of benefits over traditional web two applications or just web two programs because they're always available and they're uncensorable.
00:07:22.010 - 00:08:11.130, Speaker A: These provide a unique set of advantages such as building currencies on top of these building tokens that have real value and can maintain real value. So that's one of the main value propositions of even writing smart contracts. And to write them, we're going to be using a programming language called Solidity. The two most popular programming languages for Ethereum right now are Solidity and Viper. Solidity is by far the most popular and has the most robust tooling. So that's what most smart contracts are written in. And these smart contract programming languages are specific to Ethereum.
00:08:11.130 - 00:09:03.450, Speaker A: Ethereum. Runs specific code called Ethereum bytecode. It's similar to Java in the sense that there's a Java virtual machine. Java programs compile down to Java bytecode and then Java bytecode is what actually runs on the Java virtual machine. The same kind of thing happens on Ethereum, but instead of with Java, bytecode is running just on whatever computer is running the Java virtual machine. With the Ethereum virtual machine, this Ethereum bytecode is running on this distributed computer, this global distributed computer. So that's a long way of saying we need a specific programming language to write this specific Ethereum bytecode and that's why we have Solidity.
00:09:03.450 - 00:09:54.262, Speaker A: So let's just jump right into writing some Solidity. To write Solidity, we are going to be using this in browser development environment called Remix. Yeah, I'm just going to go over some of the features of Remix because you can do almost everything. You need to write smart contracts and deploy them onto the network right from this interface, which is super powerful because you actually don't need to install any software. You just go to remix ethereum.org? And this is the landing page. You can select different environments.
00:09:54.262 - 00:10:42.540, Speaker A: You can select Solidity as your environment, Viper and clicking these buttons. Like if I click Solidity, it's just going to load a specific set of plugins on the left side. And these Remix plugins are specific for like I have a Solidity compiler here, so it'll compile my Solidity contracts. I also have a deployer so I can deploy contracts and send transactions to my deployed contracts. I also have analysis tools. If I select Viper, it's going to give me an additional compiler. Because Viper is a different programming language, so the compiling rules are slightly different, the syntax of the language is slightly different.
00:10:42.540 - 00:11:28.410, Speaker A: Yeah. So you'll also see down here at the bottom, there's a console. This will come in handy when we're actually deploying contracts and sending transactions. We'll be able to inspect details about what's going on down here and just jumping over to the left side of the screen again. I have this File Explorer that has these are all the contracts that I actually have saved in my remix. This just saves my contracts in local storage in the browser. So going into like logging into my other computers, obviously I won't see these contracts, but any contract that I work on, it's automatically saved in the browser, which is really handy.
00:11:28.410 - 00:12:28.700, Speaker A: You can connect to GitHub Gist, you can connect to your local file system. Those are additional plugins you can get going to the Solidity compiler. You can select different compiler versions. I'll talk more about this as we actually get into writing Solidity contracts because we're going to be specifying these compiler versions right in the Solidity files. Different compiler versions will behave slightly differently, compile the same code into slightly different bytecode, depending on what's different about the compiler. If you're on a slower laptop, you might want to uncheck autocompile, especially if you have a lot of contracts because this can take a long time and every time you edit anything in the editor, it will try and recompile. So this is what a contract looks like.
00:12:28.700 - 00:13:38.450, Speaker A: Making any edit to this file will cause it to recompile. So check this box as necessary. Yeah, and then basically once we have a contract compiled, the contract deployer and Transaction Runner makes this contract available to deploy onto whatever network I have. I'll get into more detail about this shortly with an actual example. Any questions about this so far? And if you guys have any questions as I'm going through any of this stuff, just feel free to raise your hand because we've got this room for 2 hours. This presentation is not going to take 2 hours, so interruptions are welcome. All right, so if you guys are in the presentation, this link will actually open remix.
00:13:38.450 - 00:14:23.198, Speaker A: I'm going to close this one. We'll open remix with a specific GitHub Gist available to it in the File Explorer called Simple Storage. For those of you that came in a little bit late, you can access this presentation@tinyurl.com biddlewaterloo and then you can access all of these URLs. This link will load remix with a specific simple storage contract already loaded. It's available in the gist. Are you guys able to see that on your computers? Okay, cool.
00:14:23.198 - 00:15:05.390, Speaker A: So I'm just going to go through this simple contract and highlight some key parts about a solidity file. You'll notice that the first line is a pragma solidity statement and it's actually saying greater than or equal to 0.4.0 or less than 0.7.0. This is the compiler specification. So this is saying that any compiler version between these numbers is going to be valid and the compiler will throw an error if it's outside of this range. This is important because syntax actually changes quite a bit between compiler versions. So you don't want to make assumptions about how your compiler is going to behave.
00:15:05.390 - 00:15:55.786, Speaker A: This is required. And something to note about remix I have autocompile selected. So as I edit this file, it's going to try and autocompile and Remix will throw errors like this when it can't compile, which is super handy. It will also tell you exactly what's going wrong if you mouse over the X. In this case, I just don't have the line ending in a semicolon. But yeah, this is a comment. It's just like JavaScript where you can do two slashes or a slash star to do code comments right in your Solidity file.
00:15:55.786 - 00:17:22.940, Speaker A: So this is just a note that I have an instance of this exact contract deployed onto the Rinkabee test network at this address. But yeah, this is just demonstrating what a comment looks like. And then I have a contract here defined as simple storage. Yeah, Solidity, or just like Ethereum development, is similar to object oriented programming in the sense that we can think of contracts on the Ethereum blockchain as like we can call it contract oriented programming where instead of objects living in a global space, we have contracts living in the global Ethereum space. So here I'm just defining a contract called simple storage. And yes, the difference I think the differences between objects and contracts might become more clear as we go through how contracts are defined and then how they actually behave on Ethereum. So let's talk about that more at the end of this and yeah, just bring that question up again and maybe we can all answer it.
00:17:22.940 - 00:18:22.030, Speaker A: So, yeah, typically in a Solidity contract file, we will declare storage variables in the top of a contract. So that brings up the idea of there's multiple types of memory in Ethereum. In contracts we have storage variables. So in this case we have a variable called stored data. And that's going to be persistent across that's basically going to be data that lives on chain. The stored data variable will always be accessible for people to read and in this case update since we have a function that allows users to update the function. But this data is persistent on chain.
00:18:22.030 - 00:19:05.622, Speaker A: That's a key point about storage variables. This is the only storage variable for this contract and it's of type unsigned integer. We define the type using the UN syntax here before the variable name. There are many more types for Solidity. We'll get into those more in future contracts. In the next contract that we'll be coding. Solidity is a statically typed language.
00:19:05.622 - 00:20:26.590, Speaker A: So that means we have to basically define the type of all the variables as we declare them. So as we go into like line nine here, we're defining an event for this contract called storage update. An event is a specific thing in Solidity or just in Ethereum where there's essentially a log of data associated with transactions. And declaring this storage update event will allow us to write information to the logs when a transaction occurs that calls this event. So foreshadowing this thing in line 13. As I mentioned, Solidity is a statically typed language. So for all the data that we want to associate with this event, we have to declare the type and the variable names.
00:20:26.590 - 00:21:25.794, Speaker A: Why do you need to log stuff? It's handy to log stuff because it makes it easy to basically read when actions happen on chain. So when we get into using web3 JS, you can actually subscribe to the logs on chain. So you can basically say, I want to look at this contract to see if this event ever happens. When those events happen, you'll basically get a notification that it happens in the JavaScript library. So it's extremely handy for building interfaces because, for instance, in this set function, we can emit an event called storage update. And if we have our JavaScript library watching for this storage update event, we'll automatically get a notification. When that happens.
00:21:25.794 - 00:22:36.042, Speaker A: We won't have to be constantly querying the blockchain to see what the current storage data value is. We'll just be notified whenever it changes. So it's a good heuristic to basically log an event every time the state of your contract changes. So like, the front end of an application can just be watching all of the events on a contract and it should be able to determine what the state of the contract is without having to read any of the state variables directly. It can just listen for events and whenever events are triggered, it can update its state or its representation of the state. We've declared this event and this simple storage contract just has two functions. It essentially has a set function and a get function.
00:22:36.042 - 00:23:37.438, Speaker A: Just a getter and a setter. This set function takes one unsigned integer variable x, and it's just going to set that to the store data storage variable and then it's going to emit the storage update event with the new value and then also the address of the account that called the transaction. Yes, that's an excellent question. I actually have a link to that in the next contract that we'll be looking at. But the main ones that we'll be using are message sender and message value. Message sender will give you the account of the essentially it gives you the account of whoever sent the transaction. Sometimes that's a contract.
00:23:37.438 - 00:24:51.594, Speaker A: Sometimes that's an account owned by a person that gets a bit into the weeds about how there's different types of accounts on Ethereum. I guess we can just go into that now. Essentially, if you guys are familiar with MetaMask, we have accounts here where they're called externally owned accounts, where these are accounts that are associated with private keys and we think of them as owned by people. These are accounts that people sign up for and people create. There are also contract accounts. So if I deploy this contract onto the network, this contract account, it won't have a private key associated with it that's created, but it will have an address, it will have an account balance, and it will have associated data. So just by looking at the account addresses, you can't actually determine if an account is an externally owned account or a contract account.
00:24:51.594 - 00:25:25.460, Speaker A: But if there's associated code, you can tell that it's a contract account. Um, yeah, I just want to note also that this set function is marked public. This means that anybody can call this function. It's not restricted in any way. So it's callable by other contracts, it's callable by any externally owned account. And then there's just a getter function. And all this function does is return the stored data value.
00:25:25.460 - 00:26:43.370, Speaker A: So it's just going to read the stored data value and yeah, that's a quick intro to a simple storage contract in Solidity. Any questions there? Yes, exactly. So a transaction is a function call or a function call requires a transaction. Transactions on Ethereum can be simple value transfers where you're literally just updating balances in different accounts, but they can also have data associated with them. And if you send a transaction to a contract and have associated data, that contract will read that associated data and interpret it in a certain way. Using that associated data, it will determine which function you actually want to call. It will read the input variables based on how the contract is defined, the types of the inputs.
00:26:43.370 - 00:28:16.074, Speaker A: And yeah, we'll get a bit more into that when we're going into web3 JS, because that handles a lot of the it abstracts away a lot of the complexity around formatting the transactions when you're calling contracts or sending value to other accounts. This contract, yes. So if I send value to this contract or if I update any of the information in this contract, there's actually code that's associated with this contract. With each account, there is a balance, there's associated storage. If it's a contract account, either the balance is updated. If it's just updating the Ether balance, like if you're sending an Ether transaction to it, if you're not sending any Ether but you're just sending information in transaction data and you're updating the store data value, it's just going to change the code that's associated with the contract account. Does that make sense? Cooling.
00:28:16.074 - 00:29:03.590, Speaker A: All right, so I'm going to jump into our next example. This is going to be a more interactive example where we're actually going to code through this simple bank contract. I know a lot of you guys are brand new to Solidity and Ethereum. I'm going to call out questions as we go through this. So if some of you are more familiar, I'd appreciate if you shout out the answers as you know them. But all of the answers can be found in this link here. Just the solidity documentation.
00:29:03.590 - 00:30:07.370, Speaker A: You guys will probably be referencing this documentation a lot throughout the weekend. This is really like the source of truth in terms of how to understand Solidity and as you run into problems, this reference will be invaluable. In this example, I just want to basically create a simple bank. This simple bank contract is going to just have variables that store users user balances, the user status, whether they're enrolled in the bank or not. There's going to be an owner of this contract. There's going to be several events that are emitted as the users enroll and make deposits. And then there's just four functions, I think, that allow users to enroll deposit funds and withdraw their funds.
00:30:07.370 - 00:31:13.962, Speaker A: So by going through this example, we'll learn some more types in Solidity and we'll also get more of a feel about what it looks like to write Solidity. We can see we just have a contract definition in line eleven for the simple bank contract. And at the top we're going to declare our state variables. These are going to be the persistent variables that persist for the life of the contract. One of these variables is just the balances of the users. I don't know if you guys are familiar with mapping types, but essentially a mapping type is a key value. It's not a list, it's just a reference where we have specific keys associated with specific values.
00:31:13.962 - 00:32:26.802, Speaker A: So in this case, we have a mapping of balances. In this mapping we're going to store addresses of users and with each address we're going to have one unsigned integer corresponding to a balance. So this balances mapping can be any size. It initializes to having essentially just an empty mapping where every address is just associated with a zero balance. And in the comment we actually want to, we're actually able to hide the balances in this mapping from any other smart contract. So by making this variable private, we can prevent any other smart contracts from looking up the balance of any of the users in this contract. So we can prevent other contracts from looking up balances.
00:32:26.802 - 00:33:38.990, Speaker A: But because the ethereum chain is public and accessible by anybody, just by the nature of the system, any user can look up the balance of any user. But using this private keyword, we can prevent other contracts from looking up balances. So a key thing to note here is that this private keyword does not prevent anybody from actually reading the balances. It only prevents other contracts from reading balances. In contrast with this enrolled mapping, we want other contracts to be able to look up if users are enrolled in this contract. So we can make this mapping public. Any state variable or any storage variable defined in a solidity contract marked public will have a getter function automatically generated for that state variable.
00:33:38.990 - 00:35:08.540, Speaker A: So even though I don't have a getter function defined for this enrolled mapping, by marking it public, the compiler will automatically create a getter variable for it. And likewise with the owner address, we're going to make it public so that anybody can look up who the owner of the simple bank contract is this is another basic type in Solidity, the address type. The address type has multiple methods associated with it. So whenever you have an address type, you can actually look up the balance of the account associated of that account. So owner balance now becomes a method that's callable in my contract. Also we can call transfer. We can send ether and make calls, function calls to accounts or just to variables that are of the address type.
00:35:08.540 - 00:36:20.372, Speaker A: So we'll see what that looks like farther down when we're defining our withdraw function. So let's define a few events that we will want to log as we're going through this contract. So we're going to have an event called Log enrolled. And this event is going to take one input and it's going to take an input called Account Address. And this is actually an address type. So yeah, we're going to have another event called Log Deposit made that will actually emit this event when a user makes a deposit. And we're going to want to basically know who made the deposit and the amount of the deposit.
00:36:20.372 - 00:37:43.570, Speaker A: So when we're defining this event, we're going to have an address called Account Address. And the associated amount will be an unsigned integer and we'll call it Amount. And let's create one more event called Log Withdrawal. And we're going to have three arguments for this event because we're going to want to know basically who's requesting the withdrawal, how much they're requesting, and then the new balance of that account. So we'll create an event called Log Withdrawal. We'll have the account address, we'll have an unsigned integer which is the withdrawal amount, and we'll have another unsigned integer which is the new balance. So these are the three events that we're going to have associated with the three ways that users can update the contract.
00:37:43.570 - 00:39:42.390, Speaker A: So now that we have our state variables defined and we have our events defined, we can go into the function section here's based on your question from earlier about the globally available variables. Here's the reference in the Solidity documentation and here's the list of all of the special variables in Solidity. So all of these things when you call like message sender in Solidity, it's going to give you the sender of the current message, whether that's the transaction initiated by the externally owned account or that might be another smart contract that's calling the current smart contract if you have multiple contracts that are interacting. And as I mentioned, message value is another commonly used special variable which is the amount of value that's actually sent along with the transaction, we also have so special variables associated with time. Like this now variable will actually give you the timestamp of the block of the current transaction. As I mentioned, we'll gloss over these for now and as you encounter these, as you're writing Solidity, we can explore how they work in more detail. But back to the simple bank contract.
00:39:42.390 - 00:40:39.450, Speaker A: We have this special function in all solidity contracts. It's just called constructor and this is a function that will execute when the contract is deployed. So whatever code we add here will be executed upon contract deployment. So it's quite common when you have a contract that has a specified account owner, as we do in this, to set the owner of the contract to well, whoever you want the owner to be. Often that is the sender of the contract. So in this case we'll just set owner to message sender. So when this contract is deployed the owner will become the account that is sending or that is deploying the contract.
00:40:39.450 - 00:41:55.330, Speaker A: Every contract also has a fallback function. Well you should define a fallback function for every contract. To define the fallback function you essentially have an unnamed function and this function will be called if someone sends a transaction or attempts to call a function on the contract that doesn't actually exist, this fallback function will be executed. So as mentioned here, this function is called if all other functions don't match or this contract is sent an ether transaction with no data associated with it. So this specific fallback function we are just calling Revert. Revert is a special code that just basically halts a transaction and causes it to not work. It throws an error and it's not an accepted valid transaction.
00:41:55.330 - 00:42:58.960, Speaker A: This prevents people from accidentally sending ether to the contract. It basically forces people to interact with the contract in ways that you intend that you designed. If you don't revert with a fallback function you can have the contract accept user funds, you can really have it do whatever you want but it is common to just cause it to revert. So people only interact with your contract in intended ways. So we have this function here, this function signature called Get Balance. This is a public function. It's going to return an unsigned integer and based on the comments here you can see the purpose is just to get the balance of a specific user.
00:42:58.960 - 00:43:52.980, Speaker A: So to define this we just need one line. We can return the balance of the sender of the transaction. I think I missed a so that will look up the in the balance as mapping. It's going to look up the address of the sender and just return that value. So any user can just look up what their current balance is. By calling this Get Balance function remax is giving us an error here or it's a warning. It's telling us that the function state Mutability can be restricted to view.
00:43:52.980 - 00:45:18.034, Speaker A: Defining a function with the view keyword means that this function is only reading the state of the contract, it's not actually doing any updates to the contract. And because we're only reading the contract state it doesn't require a transaction, it doesn't require an update to the contract, it doesn't require any change to the. Blockchain. We're literally just reading data off of the blockchain. So this is a free function to execute. We'll get more into what free versus not free transactions are about, but essentially transactions cost money to execute because it's a way to prevent spam and basically protect against the halting problem when you're running a globally distributed computer. The key thing here is when you define a function called view, it's only reading blockchain state.
00:45:18.034 - 00:46:13.380, Speaker A: It's not sending a transaction. And these are free to execute. So getting into our functions that actually do cost to execute, our first one will just enroll a customer within the bank. We're going to mark this public because we want anybody to be able to join our bank. And we're just going to update the enrolled mapping for the message sender to True. If we go back up and check our enrolled mapping, it's a mapping from addresses to Booleans. So we're associating a true or false value with each account.
00:46:13.380 - 00:47:00.686, Speaker A: By default, they're all false. If you look up any account in this mapping, right after the contract is deployed, they'll all be false. So as users enroll in this contract, we will update their enrolled status to True and we're going to emit the associated event. So we'll just log enrolled and checking on what the event emits. Okay. It just emits the account address so we can just emit the message sender. And it actually has a return value of a Boolean.
00:47:00.686 - 00:47:52.900, Speaker A: And it's not uncommon for solidity functions to just return true when they successfully execute. So you might see that on some other contracts if you're looking those up online. Yeah. Any questions? Yes. How did I define the default state? So you mean like why are they all false? To start, that's just the way that Ethereum works. Essentially any state variable that's declared but not defined. So we don't actually have this set to anything, right? It's just declared that it is a variable by default.
00:47:52.900 - 00:48:37.490, Speaker A: If the EVM, the Ethereum virtual machine is going through and looking up the state of any address, it's just going to default to false. So if it's not there, it just says, oh, it's false. For example, let's just say we have an unsigned integer called x and we just leave it like that. Defined like that, this is going to be zero. You can actually look up the value of x here and it's going to default to zero. So all state variables default to have a default initialization value even if you don't set them. Booleans default to false integers, default to zero addresses default to zero.
00:48:37.490 - 00:49:45.254, Speaker A: Just a string of zeros arrays default to just empty arrays. So, good question. Um, so, yeah, the next function, we're just going to declare the deposit function and we just want users to be able to deposit Ether into the bank. We want the user's balance to be updated. We want to make sure that the user is actually enrolled before they can make deposits and we want to emit the appropriate event when a deposit is made and then we'll just return the balance of the user from the function when it's done. So first thing we're going to do whenever we have conditions that need to be met when a function is called in this case we want to make sure that a user is enrolled. We actually want to do that at the beginning of the function.
00:49:45.254 - 00:51:35.430, Speaker A: So to check conditions in solidity we can use this specific require statement and then the first thing it's going to take is a condition so we can say we want to require that the enrolled status of the message sender that's actually equals to true. So this condition is going to be evaluated and if it's true it will proceed if the condition is not true. So if the sender is not actually enrolled in this bank the transaction will revert, it won't continue executing and the transaction will fail. We can actually send a second parameter to this require statement which is just going to be the error statement that is logged when the transaction fails. So we can say something like sender should be enrolled and this is helpful for also figuring out where your transactions are failing. I mean you could have four or five require statements at the beginning of a function and adding these strings about which require statement is actually failing is really helpful for determining where the state of your contract is not aligned with your assumptions. So after we check that the sender is actually enrolled we want to add the amount to their balance.
00:51:35.430 - 00:52:30.426, Speaker A: So we're going to look up their balance in the balances mapping and we can just add the message value that they sent along with the transaction. So remember in the special variable, special global variable message value is just the amount of way. Way is a subunit of Ether. Ten to the 18 way is equal to one Ether. So it's a very small amount but it's the smallest amount of value measurable in Ethereum. So that's the smallest unit of account. Once we update their balance we are going to omit the appropriate event.
00:52:30.426 - 00:53:22.298, Speaker A: So we'll log deposit made, I think we log the message sender, we're going to log the account and then also the value of their deposit. We're getting a couple of errors. Let's see what that is. We're getting an error saying message value can only be used in payable public functions. So we have not defined this function as payable which we need to do for this to work payable. Declaring a function payable just means that it will be able to handle message value. This is a protection to basically ensure that only functions that should be accepting Ether that should be accepting value transactions will be.
00:53:22.298 - 00:55:00.792, Speaker A: So you as the programmer have to explicitly state that this function should be handling Ether and then when this contract accepts a transaction with associated value. The balance of the contract is actually incremented by the amount that it's sent. So there's not actually a value amount associated with each user in this contract. There's just one global balance associated with the contract. But in this balances mapping we're keeping track of the amount that each user actually deposits. So once we log the deposit event, we're just going to return the balance of the sender of the transaction and then we only have one function left to implement in this contract we want users to be able to withdraw their deposits. This function is going to take one parameter, the withdrawal amount defined in way and to allow users to withdraw their funds.
00:55:00.792 - 00:57:07.740, Speaker A: We actually want to do a check here to make sure that they've deposited enough ether to be able to withdraw the amount they're requesting. So to do that we're going to set the condition here where we look up what their balance is in the balances mapping and we're going to make sure that is greater than or equal to the withdrawal amount and if they fail that check, we can say they don't have enough funds to make that withdrawal. After we do the check we want to update the global balances mapping of the withdrawal amount. So when they actually withdraw their funds, we track that in the balances mapping because as I said, the balance of the contract is going to be holding the funds of everybody that deposits and where we're actually keeping track of each user, each user's balance is in this balances mapping. So we need to update there and then we actually need to send the person doing the withdrawal request we need to send that value from the contract to their account. So to do that we have this message sender as of address type. So on variables of address type we have a method called transfer and it takes one argument which is the amount to send.
00:57:07.740 - 00:58:33.840, Speaker A: So to actually send funds from this contract to a user we just call message sender transfer with the amount. Once we transfer that amount, we're going to emit the withdrawal event, the log withdrawal and let's see what it takes the account address, the withdrawal amount and the new balance. So we'll log the sender, we'll log the withdrawal amount and the new balance and we're going to return we return the user's new balance as well. It all right. So we have a simple bank contract coded and it looks like it compiles any. Yep. What do I have to there is a way that we can look up the balance.
00:58:33.840 - 00:59:39.696, Speaker A: Let me see. If we define a balance here, this is going to create a getter for the balance and as we will move on to deploy this contract and we'll actually inspect the balance as we send it value. So now that we have this contract that compiles correctly we can look up details in the compilation plugin in Remix. But we're just going to jump over to the deploy and run transactions. I want to highlight that. In this tab we have an environment drop down where we can select the JavaScript VM or injected web3. JavaScript VM is essentially a blockchain simulator that's going to be running right in your browser.
00:59:39.696 - 01:00:09.570, Speaker A: So it's like a local version of Ethereum that follows the same rules. It's just running right in your browser. So it has the same opcodes, it follows the same rules. Everything works functionally the same. But it's really easy for testing and experimenting with contracts because transactions are instant. You don't have to use real value. You don't have to wait for processing times or anything.
01:00:09.570 - 01:00:53.164, Speaker A: This JavaScript VM comes with five accounts that are all pre funded with Ether. So you can send value right off the bat. And yeah, we'll just deploy this simple bank contract. You'll see it popped up down here in Deployed Contracts. I have a simple bank deployed contract instance down here which has an address you can see. It starts with six, nine, two ends with B, three A. Clicking this clipboard here will copy that address if I need to paste it somewhere else.
01:00:53.164 - 01:01:21.910, Speaker A: But in this interface, I have all of the functions that I defined in my contract. So I have my fallback function, my deposit function. These are both marked with red buttons because they're Payable. I have Enroll and Withdraw, which are yellow because they are standard transactions. And then these blue buttons are Getter functions. So they're just reading Contract state. The ones that take input just have input fields right here.
01:01:21.910 - 01:02:28.670, Speaker A: One thing I want to mention is this output down here. This console will basically show you the status of your transactions that you're executing in this left panel here. So clicking the drop down, you can see the status, you can see transaction hash. You can see the contract address, gas costs, which are just the value that's required to send along with transactions to prevent spamming the network and any other associated information with the transaction. So I'm going to clear this and I'm going to try and deposit some money to this contract from this first default account. First I'm going to just check I'm calling to see who the owner is. I'm getting this return CA 35.
01:02:28.670 - 01:03:07.448, Speaker A: That's the contract that I have or the this is the account that I currently have selected and this account was set as the owner in the constructor that we defined. So I can look at the balance of the owner. It's zero. I haven't deposited anything. I can check the enrolled status. Clicking this clipboard here will copy the account address, current account address. I can check the enrolled status of this account.
01:03:07.448 - 01:03:42.858, Speaker A: It's returning false because I haven't enrolled yet. I can check the balance and the balance is also zero. If I try and deposit some funds to this contract, I'm going to just try and deposit twelve way. You can see that this transaction actually fails. There's a revert here and we can see that there's a reason provided by the contract. The sender should be enrolled. That's the require statement that we defined in the deposit function.
01:03:42.858 - 01:04:20.960, Speaker A: So first I'll enroll this account in the contract. I can see it was successful. It's returning decoded output is true. There's also the event information that we're logging here. The event is called Log Enrolled. I can see there's an account address CA 35, which is the account that we are transacting from right now. So now that this account is enrolled in the contract, let's try and try and deposit twelve way again.
01:04:20.960 - 01:05:44.776, Speaker A: Um, this transaction was successful. You can see the output there. So now if I look at the balance of this account, it's actually twelve. And just to check that I can withdraw less value than I deposited, this transaction was successful and my new balance of this account is one. So using the JavaScript VM is a fast, easy way to experiment with your contracts and just do some manual testing to see if they're behaving as you expect. Also, if your contracts aren't behaving as you expect, it's a great way to just edit things, inspect contract state, and yeah, you're provided with this interface that's much easier to interact with your contract than some other development environments. I want to bring up MetaMask.
01:05:44.776 - 01:06:40.608, Speaker A: At this point, you can connect Remix directly to MetaMask by selecting injected web3 as your environment. What this does is so MetaMask injects an object into your browser which is connected to the Ethereum network. In this case, I have an account with the first three characters seven, D, six, and I'm connected to the Rinkabee test network. I can change to the main Ethereum network or other test networks or local development networks if I have those set up. I'm going to leave it on Rinkabee for now, but Remix will detect which network I'm on. It says that I'm on the Rinkabee network right now and it has the associated MetaMask account with my ether balance. I have 1.2
01:06:40.608 - 01:07:28.984, Speaker A: ether in this account which corresponds with MetaMask. So I can actually deploy contracts to various networks using the injected web3 right now. So if I want to deploy this simple bank contract to the Rinkabee test network, I can just click Deploy. MetaMask is going to pop up, asking me to do a contract deployment. It's going to give me gas estimates and I'm just going to confirm this. And MetaMask is going to send this to the test network and actually deploy it onto the testnet. So this is going to take several seconds to actually be mined and included in the testnet blockchain.
01:07:28.984 - 01:08:18.520, Speaker A: But once it is, it's going to pop up just like it does in the JavaScript VM. And it's giving me the address at which you can now see this simple bank contract. So you guys can actually go to the Rinkabee Ether Scan, Block Explorer and you guys can see this deployed contract that I just deployed. So I don't know if you guys are familiar with Etherscan. Block Explorers allow you to just basically look at all contracts, all transactions, the balances of every account. It basically allows you to look at the details of everything that's going on on the blockchain. So there's just regular etherscan.
01:08:18.520 - 01:09:05.496, Speaker A: IO will show you the Ethereum main net and then there's an Ether scan for each test network as well. So now that you guys know that this contract is deployed at this address, you can start interacting with it. You can enroll in mysimple bank. You can make deposits, you can make withdrawals. But to do so, you will need an Ether balance in your account on the Rinkabee test network. Again, paying for transactions on any Ethereum network is required to prevent spamming the network, essentially. So I have links to ways to get testnet Ether in my slides.
01:09:05.496 - 01:10:20.800, Speaker A: But if you just Google Rinkabee Ethereum Faucet, the first hit should be a link to get testnet Ether to start sending transactions. So with that, I think that's everything I want to cover in terms of coding smart contracts in Solidity using Remix. Are there any questions about using Remix right now? Cool. The difference between Require and assert. So Require is a check typically used as a check to verify, like, user input to a function. And it's a condition that may or may not be true when the transaction gets to this point. Assert statements are typically understood to they should never actually happen.
01:10:20.800 - 01:11:38.522, Speaker A: They're similar in the sense that assert statements, if they fail, the transaction will fail, it won't be processed, and state will be reverted to what it was before the transaction. But, yeah, it's more like a check to basically say that your contract should never get into a situation where an assert statement fails. So you're kind of coding in assumptions about how your code works or expectations about how your code works. Whereas with this Require statement I'm not saying I expect I don't necessarily expect the message sender balance to be greater than the withdraw amount it should be for this function to execute. But it's totally possible that somebody calls this withdraw function who doesn't have sufficient funds to withdraw as much as they're requesting. Does that make sense? Cool. All right, so I have one more exercise called the supply chain exercise in my slides.
01:11:38.522 - 01:12:36.530, Speaker A: I'm not going to go over it here, but I'm going to leave it to you guys to go over that. If you would like. If you go over that and you have questions about it, feel free to reach out to me. But, yeah, this is I think we covered everything here. One goal I have for you guys is to deploy some contracts to the testnet by the end of the weekend. So connecting your Remix to MetaMask, connecting that to the testnet, and having testnet Ether to actually deploy a transaction and as I mentioned throughout, blockchain interactions cost something to avoid spam and address the halting problem in Ethereum, that's called gas. You have to pay for gas with Ether to basically update the state of the blockchain, whether that's deploying a contract or updating the state of any contract.
01:12:36.530 - 01:13:28.240, Speaker A: And there's a link to the Rinkabee Testnet Faucet here in the slide. There's several other testnets on Ethereum called there's one called Robston, there's another called Covan, there's another called Gurley. And yeah, they're all good to use. They have slightly different they process transactions at slightly different speeds. But yeah, my brokerage was gone. Your contract was gone. Hmm.
01:13:28.240 - 01:14:12.200, Speaker A: I'm sorry to hear that. I don't know why it didn't save. So you switched networks in MetaMask and then the page reloaded and your progress didn't save. Okay, I guess that's a good warning to everybody. If you're developing contracts in Remix, be wary of switching networks and not having the state of your contracts saved. It's automatic, as far as I know. I don't think there's a save button anywhere.
01:14:12.200 - 01:15:27.520, Speaker A: If anybody else knows otherwise, please let me know. But yeah, um, yeah, I guess that's a good point. Especially since if you're using Remix as your only development environment, it feels risky to just have your only progress in a window that may not be saving your code. So just save frequently. I guess it's so we deployed our contracts, and I just want to mention some additional considerations that we have not covered in this presentation so far. Since we are just focusing on getting skills necessary to write contracts, deploy them and interact with them, we're skipping a lot of important details about Ethereum development. I have links to more information in this slide, but the quick overview is we're not going over any design patterns of how to develop contracts.
01:15:27.520 - 01:16:22.224, Speaker A: Solidity has been around for a few years and people have come up with good design patterns on ways you should do certain things, including destroying contracts that aren't no longer being used. So they're removed from the blockchain coding factory contracts, which are essentially contracts that deploy contracts themselves, which is an interesting pattern. And there's a lot of patterns around handling user funds so you don't accidentally lock them or lose them. There's also a lot of best practices that we're not covering in terms of maybe using Vs code or another editor that isn't remixed. So you don't lose your progress as you go. Also setting up testing environments. You guys may have heard of the Truffle development environment that has testing built into it.
01:16:22.224 - 01:17:05.416, Speaker A: We don't really have great testing. And Remix, there is this testing Solidity unit testing plugin, but you actually have to write your tests in Solidity as you're going through, which presents some unique challenges. It's often a lot easier to just write them in JavaScript using a tool like Truffle or Waffle. So testing is definitely key to creating good projects. There have been a lot of attacks on Ethereum over the past few years. Those are well documented and we have not touched on any of them so far. And there's a large suite of security tools.
01:17:05.416 - 01:18:05.280, Speaker A: Just a couple are Mythx and slither. So you can just run static analyzers on your code and they'll highlight some vulnerabilities. Won't catch everything, but it's definitely better to run your code through these security tools than not. So we touched on how you can interact with your contracts using Remix. I guess before I actually, let me jump back to the simple storage contract. So I want to show you guys how to connect Remix to a contract that's already deployed. So, as I mentioned in the simple storage contract, we have this contract defined at this address on the Rinkabee testnet.
01:18:05.280 - 01:19:20.570, Speaker A: We can actually connect to this already deployed contract using Remix using our Deploy and Run Transactions plugin. Since we have the simple storage contract loaded here, we can basically tell Remix that we know. Well, first we're going to select injected Web Three so we have it connected to Rinkabee and we can say, I know there's an instance of this simple storage contract at this address provided. And it's going to give me an instance of this simple storage contract at the address that I put in. So you can look up any deployed contract on any network and just if you have the code, the solidity code and the address, you can create an instance and then start interacting with this contract on the testnet. So this is a nice easy interface from a developer perspective. To read contract state, let's actually see what the contract so the contract currently has a stored data value of 42.
01:19:20.570 - 01:20:06.570, Speaker A: I can update that to Five and send it to the network. I can see the transaction processing. This is the actual instance of the simple storage contract, has the contract definition here. I can see the transaction history. I can see I've actually been interacting with this contract quite a bit, doing testing, and I have this transaction history on the testnet and it just processed another 120 seconds ago with that update. So checking it again. Yes, it's updated to five.
01:20:06.570 - 01:20:57.556, Speaker A: So this is a cool way to interact with contracts on the testnet or main net, but it's not very user friendly. You're not going to get people to load contracts into Remix to do any interaction. So to basically handle that, we have the Web Three JS library. To explore how that works, I have this exercise that I put together. It's going to go through using Web Three JS right in the browser. It has some transactions pre programmed in this lesson. So when you open this page, MetaMask will prompt you to send some transactions.
01:20:57.556 - 01:22:05.212, Speaker A: But we'll rerun these as we go through the lesson. So essentially, Web Three JS just abstracts away a lot of the complexity of dealing with contracts and sending value around Ethereum. And since it's a JavaScript library, you can just import web3 JS right into your front end of your application and have it talk to MetaMask to read contract state from the blockchain and also send new transactions. So, yeah, this is kind of a wall of text right now. This link is available in the slide, so you can go through it at your own pace. But I want to highlight, um, yeah, a few things. First thing is that the first time you're accessing this page, MetaMask is not actually going to inject your information right off the bat.
01:22:05.212 - 01:22:55.790, Speaker A: You actually have to ask MetaMask, like the developers have to ask MetaMask to access the accounts. To do that, you can just run this function Ethereum Enable. You can run that right in your front end application. You can run it here or in the browser console, but MetaMask will keep it will remember every site that you grant access to. It didn't ask me to provide access to this site because I've already authorized observablehq.com for MetaMask to inject the account information. So if you're having trouble accessing any accounts from MetaMask, you might need to run this Ethereum Enable function.
01:22:55.790 - 01:24:01.190, Speaker A: Also, something to note is there are multiple versions of web Three JS which is kind of kind of frustrating. The latest stable version of web3 JS is zero two x, and this is the version that's automatically injected by MetaMask. So if you inspect the Web Three object in your browser console when you have MetaMask installed, you'll see this Web Three JS version. But the latest version in development is one. X. So in this example, specifically, I'm getting web Three JS version one 20 from the JavaScript JS deliver CDN. And then I'm just saving the JavaScript library in this web Three JS variable here.
01:24:01.190 - 01:24:54.784, Speaker A: And then to connect the library that I just got to MetaMask, I'm just calling this function new Web Three JS at the Web Three current provider. Web Three is the object that's injected by MetaMask, and I'm just calling this Web Three JS to avoid any naming conflicts in this exercise. Usually it's just called web3. You'll just say web3 is a new instance of web Three using the MetaMask provider. Something I really like about this exercise is you can actually inspect the results of these functions as we go through. So you can actually see that Web Three JS is now an object available. The current provider is the MetaMask in page provider.
01:24:54.784 - 01:25:26.690, Speaker A: There's a selected address with this value, which is the account here that I have. The network version is four. The chain ID is four as well. This chain ID corresponds to the Rinkabee network. The Rinkabee network is chain ID four. I think Robston is chain ID three. Covan might be five, but Mainet is a one.
01:25:26.690 - 01:26:23.712, Speaker A: But yeah, in this web3 JS object Now I can see the version I'm using version one 20. And I have a whole bunch of methods in this ETH property associated with blockchain information like accounts, the network I have, the provider specified. I have a contract function. This is the entire library right here. So there's a lot of functions there. And we'll be using these functions in the Web Three JS library to inspect what's going on on the Rinkabee network through the rest of the exercise. So just as an example, I'm defining a transaction object here, and I'm just defining a few things.
01:26:23.712 - 01:27:22.990, Speaker A: I'm going to say I want it to come from the injected account. So that's going to be my Web Three JS selected address in the given provider I'm going to send it to. It's currently at the same account. But let's say I go over to this account. I don't know why it's not copying. Oh, that is the correct one. All right, so now that I have so if I refresh the page so it detects the new account, I'm going to reject these transactions.
01:27:22.990 - 01:28:07.360, Speaker A: I can see that the two account is my actually account number two from account is my current account. And I actually have a gas price set. So I can run this transaction by just calling the Web Three library ETH send transaction. And this will try and send a transaction to the network. So running this cell will prompt MetaMask to actually send a transaction with an ether value of zero one, which is what I specified here in the value. So let me actually send that and we'll see it. It's going from my first account to my second account.
01:28:07.360 - 01:28:56.670, Speaker A: I'll just confirm both of these. So it's going to send 0.2. And so including this JavaScript in any front end application in a browser will do a similar action. It will ask MetaMask for the user to approve anything that you provide in this. So I can even change this to this could be a user input field where I basically ask the user how much ether they want to send. If I update this cell and run it, it's going to ask me, oh, now I want to send do I want to send zero point 51 ETH to this account too? Sure. And I can see these balances are being updated.
01:28:56.670 - 01:29:34.810, Speaker A: So simple value transfers are pretty easy. Since we're using the Rinkabee test network, we don't have to worry about non mismatch errors as much. This is something you might encounter if you're using a local development blockchain like Ganache. Ganache can cause problems because you're changing your network ID so frequently. Basically, every time you start it, there's a new development blockchain. The accounts have a specific sequence of there's a sequence of transactions. I mean, it starts at zero, goes up incrementally.
01:29:34.810 - 01:30:21.740, Speaker A: Let's say you're developing on a test blockchain and you send 500 transactions. On your test blockchain, you start a new one. MetaMask is going to remember that you're at transaction 501, but on a new chain it has to start back at zero. So sometimes if you encounter non mismatch errors, that's just what's happening. You can reset that counter in MetaMask by just going to Settings Advanced and you can reset the account, which basically MetaMask will just query your development blockchain to get that latest information. It's going to clear the cache basically is what happens. That happens.
01:30:21.740 - 01:31:10.194, Speaker A: Like I said, it's not going to happen on testnets as much, but using development blockchains it will. And you can also just read account information using the Web Three JS library. So I can say Web Three JS get balance, get the balance of the current address. This is around 1.2 ETH, I think, but I sent about half an ETH to my account too, so this should update to about half as much. And yeah, looks like a bunch of my ETH went to my other account, so the balance is updated. That's all fine and good, just like sending value from accounts to other accounts.
01:31:10.194 - 01:31:58.870, Speaker A: But that's not the most interesting thing about Ethereum. Interacting with smart contracts is really what we want to do. That's the end goal. So in this example, I'm going to show you how to connect just like we connected Remix to our simple storage contract here on the Rinkabee network. At this address, I'm going to show you how to do that using the Web Three JS library. So I have the simple storage address, the same one defined before right here. And then I have the Abi, which is the specification that lets the library know how to interact with the contract.
01:31:58.870 - 01:32:58.598, Speaker A: In Remix, this is generated automatically because Remix has access to the source code of the contract. So this Abi is actually generated automatically when the contract is compiled. If I go to the compiler details, I can see the Abi information here. This is all handled automatically by Remix. But since Web Three JS in this instance does not have access to the contract source code and that's not published on chain anywhere, we have to provide that information to the Web Three JS library. So the library knows how to interact with the contract at this address. So I have this published on GitHub and basically to create the contract instance, we're creating a contract instance in Web Three JS.
01:32:58.598 - 01:33:44.860, Speaker A: We're not creating a new contract on chain in Web Three JS. We're saying we have this contract at this address and we want to basically create a new contract object with that. So we can just do that by saying I have a simple storage is going to equal a new Web Threejs ETH contract with the Abi and the address and it's going to return this object to me. That allows me to interact with the deployed contract. We can see this contract object is connected to MetaMask. It's got some options. This is the Abi and the address.
01:33:44.860 - 01:34:40.666, Speaker A: And the most interesting things that we want to pay attention to are the methods which we can see here. We have the Set method and the Get method. They're both functions. And we also have events. We have one event called Storage Update, which corresponds to with what we looked at earlier. So to interact with this deployed instance, we just need to call Simplestorage Methods, Set and Get and it will send transactions to Rinkobe testnet and we'll be able to read those updates. So as I updated this contract in Remix, you guys remember I updated it to five with the Remix interface connecting to it through this exercise, I can see that the current value is five.
01:34:40.666 - 01:35:28.698, Speaker A: I just called Simplestorage Methods Get Call, which just specifies that I'm just reading the contract. I'm not actually sending a transaction to it. But yeah, just letting me know that the current state of the stored data value is five. And then to update the contract, I have the contract object I want to set it to. Let's set it back to 42. So I just call Simple Storage Methods Set with the value that I want to set it to, and then send to specify that I'm sending a transaction and not just reading the contract state. And I want to send it from the current MetaMask account.
01:35:28.698 - 01:36:18.846, Speaker A: So I'm just setting it to the selected address. So if I run this cell, MetaMask is actually asking me to run the Set function and I'm going to confirm that. And this is sending it to the Rinkabee testnet. And once it processes, we'll be able to see that it updated. So we can actually see that this transaction object in this exercise changed. It lets us know the block hash, the block number. It gives us information about the transaction, transaction hash events associated with it.
01:36:18.846 - 01:37:03.630, Speaker A: So when the transaction is successfully processed on the network, it returns this information. This is done with JavaScript promises, if you guys are familiar. If not, there's links to how JavaScript promises work in this exercise. And you can read more about how to work with Asynchronous functions in JavaScript. But now running the cell to read the contract again, I can see that it's actually updated to 42. If I go back to Remix and look at the state of the contract and Remix also see that it's pointing to the same place. One last thing I want to show about contract events.
01:37:03.630 - 01:38:23.698, Speaker A: We're logging an event whenever this contract is set, whenever the stored data value is set. So to subscribe to a contract or to subscribe to events in a contract, I just call Simplesttorage Events the event name and then it takes a callback function. So in this case, I am actually just logging this event to the browser console whenever an event is triggered. So I think this is actually, this is the set event. Let me just send another transaction and we'll be able to see another event get logged. But a common way to use these events in application front ends is to when a page loads, you set up all the event listeners that you want to pay attention to on your contract. So then as these hooks get called, you can update the UI for the user without them having to reload the page and they'll see all of the updates instantly.
01:38:23.698 - 01:39:15.222, Speaker A: So you can see that this event actually just logged in the console, and I can see the address of the contract transaction hash transaction information. I can see the values that we actually wanted returned, we can see the account that is updating it as well as the new value. So these events are not as useful for sharing information on the blockchain, but in terms of building quality user interfaces, events are super helpful. Yeah, that's it for the web. Three JS. Exercise. Again, documentation on Web Three JS is going to be your best friend.
01:39:15.222 - 01:39:59.282, Speaker A: As you're going through this and trying to understand how all of these methods and these functions work, let me just see what I'm missing. Additional developer tools. Like I said, we're just building some necessary skills to be able to build something this weekend. So that's just writing contracts and being able to interact with them. But there's a full suite of tools made available for developers and some of these are listed here with additional information. Ganache, I mentioned a few times, just allows you to run a development blockchain. It's similar to the JavaScript VM and Remix, but it's not running in your browser, it's just running on your local machine.
01:39:59.282 - 01:40:32.640, Speaker A: So it's not dependent on your browser. And it can be persistent across multiple browser instances and stuff. It's not just stuck in one window. The Truffle development environment, it's a more fully fleshed out framework for developing smart contracts. Like I mentioned earlier, it includes testing. JavaScript testing is super helpful. It also includes a version of Ganache so you can actually run development blockchains right in Truffle as well.
01:40:32.640 - 01:41:13.630, Speaker A: Infura is another great tool which is Infura allows you to connect to the Ethereum network without having to run your own Ethereum node. That's how MetaMask actually connects to all of the networks that it does. It just makes API calls to infura. So Infuria just has an API service that allows you to read contract states and send transactions. Ethereum.org slash Developers is a great page with a huge list of developer tools that's constantly being updated. So I check that frequently.
01:41:13.630 - 01:42:02.300, Speaker A: OpenZeppelin has an awesome set of contracts that's already they've written and they've been security audited. They're super useful if you're interested in developing anything with Tokens or crowd sales, or having role based access control on your contracts. They have contracts that you can just import into yours that already handle this behavior. All of these underlined items are links, so you guys can access them through this deck. And for those of you that came in later, you can access this deck at Waterloo Consensus also has a huge list of developer tools. There's a lot of overlap there with the Ethereum.org site.
01:42:02.300 - 01:42:50.970, Speaker A: IPFS is not an Ethereum project, but it is distributed data storage. So storing data on Ethereum is very expensive. It's very expensive. It's cost prohibitive. So a common solution for storing large data sets or references is to store it on IPFS and just include hash pointers in smart contracts to locations on IPFS. We can talk more about that later if you guys are interested in a data solution. And then, as I mentioned, we looked at today, etherscan is a block explorer that I use extensively for just looking at testnets and exploring contracts.
01:42:50.970 - 01:44:15.280, Speaker A: I have a few more links here to a lot of the documentation that I referenced and yeah, that's it for me. Do you guys have any questions before we wrap up? Yeah. How can you reduce the gas cost? There are some optimization techniques that we can talk about later, but essentially there are tricks in terms of so the most expensive operations are storing data on Ethereum and then reading and updating data, like in storage variables. So basically, if you can reduce that, that's a great way to reduce gas costs. Just reducing execution wherever possible, or like making execution, I want to say, breaking it up into smaller chunks and distributing it among users. So it's not just like one person or like, one account doing best transactions for a lot of people. I do have some optimization exercises that I have for the course that I'm willing to share and, yeah, just things to keep in mind as you're developing.
01:44:15.280 - 01:44:45.000, Speaker A: Cool. Any other questions? All right, well, thank you for coming. Thanks for paying attention. Thanks for sticking around. And again, I'll be around all weekend. Let me know if you guys have any questions or if you have any ideas. I love brainstorming on topics for projects and just thinking through these problems.
01:44:45.000 - 01:44:46.150, Speaker A: So thanks, guys.
