00:00:05.160 - 00:00:40.404, Speaker A: You. Hello everybody. My name is Hoyan and I work for Coinbase Commerce. Today we're going to talk about how we implemented ERC 20 payment acceptance at our platform. So this is kind of like the overall agenda of the talk. First, we're going to talk a little bit about how crypto payment processors work, why they're important, what kind of role they serve. We're going to talk a little bit about ERC 20 Forwarding and why it is important and how we solve this.
00:00:40.404 - 00:01:19.312, Speaker A: And then we're going to go on and focus a little bit on phase two and minimum proxy contracts. These are relatively new additions to the Ethereum virtual machines that we've used. And we thought that we think that they are very cool and I think that they can be applied into a wide variety of use cases that go way beyond payment processing. So what is coinbase? Commerce. Well, we try to be the easiest way to accept crypto. We come with batteries included, meaning that we want to make it super easy for developers. And just like merchants have cryptocurrencies, we started that two years ago.
00:01:19.312 - 00:02:11.228, Speaker A: And since then we've developed a lot of integrations with third party websites like Shopify WooCommerce. We have a number of SDKs that developers can use. We have APIs, we send web notifications and a bunch of other stuff that you might need. What makes our products interesting, from philosophy as well as from both from philosophy as well as from engineering, is that we are hosted, but not portfolio hosted, meaning that you don't need to run any software on your own to use our product. You just sign up on our website and initially we handle everything for you. But we are non custodial, meaning that Coinbase Commerce never has access to your private keys. All the transactions are completely peer to peer and everything that happens is in a truly kind of a distributed manner.
00:02:11.228 - 00:02:34.864, Speaker A: We cannot cease funds, we cannot stop anything. Everything is between the merchant and the customer. When we started. We started with supporting bitcoin ethereum Litecoin and bitcoin cash. And since then we supported USDC. And this talk essentially explains what things we needed to do and how we approached that in QSDC. USDC is stablecoin developed by Coinbase.
00:02:34.864 - 00:03:05.540, Speaker A: It's implemented as an ERC 20 token. So everything that is here basically can be applied to any other ERC 20 token. So that's pretty much like what payment processors do. They kind of accept payments on behalf of the merchants. They handle all this thing stuff and let's kind of dive into what actually happens when a payment occurs. So let's meet Carol, the customer and Met, the merchant. And let's say that Matt wants to sell some banana to Carol.
00:03:05.540 - 00:04:04.390, Speaker A: There are many ways that kind of like this interaction can happen. In the very, very simplest case, you can imagine that Carol just sends some entry to Matt's account and Matt will just give the banana and that's the end of the story. This thing works in real life but unfortunately it breaks whenever you have anything kind of more scalable because if soon enough you get into an issue of like, you don't know who paid for this particular banana. If Matt shared his only address to everybody, then it would be impossible for him to know. He might need to ask for proof from Terrell either by the transaction hash or something else that transaction occurred. But this thing becomes very hard and very cumbersome super quickly. And especially if you think that most of the customers that we have today, they come from exchanges and they don't really have any good way of providing any additional data.
00:04:04.390 - 00:04:55.770, Speaker A: Kind of just like testing simply information does not work. Some of our competitors develop payment protocols that are very cool and they solve this issue by making like an RPC call between your kind of private wallet and essentially the merchant server. But this again excludes a lot of people that use exchanges and we want to make our products to be the easiest and simplest use by everybody. So our solution essentially includes this widget. This widget here has like two important numbers. The first one is just like the amount that you need to pay for this particular transaction. And the second one is the more important one is like that address that is like a unique, determined address for this particular charge that has never been kind of like, that has never existed on the blockchain before.
00:04:55.770 - 00:05:35.300, Speaker A: And it's very important that all of these addresses are unique because we can definitely know that this address is completely associated with Carol's purchase. If funds land on that address, we know that it must have been Carol that paid for those. So kind of like in a little bit more visual way, like when Carol wants to buy the bananas, we generate a new address for this interaction. Direct banana. She sends some ether to that address and while doing so, she pays some transaction fees. At this point, the interaction is done. Like Coinbase Commerce will send all the appropriate notifications.
00:05:35.300 - 00:06:17.024, Speaker A: Matt the merchant received those funds but Matt would kind of like to use the funds. He would like to spend them somehow. And the way that he does that thing is that he signs some transaction originating from that intermediate address that he controls and he pays fees for that. This thing works very well for ethereum. But there is like slight issue that we're going to get to about ERC, 20. We hold kind of like these intermediary steps where we generate these new addresses like forwarding because we're introducing this kind of hop that needs to be forwarded. And for years of 20 tokens we would have the same thing.
00:06:17.024 - 00:06:59.772, Speaker A: We have the unique address for this particular instance, carol and some USDC tokens. She paid transaction fees in inter and this also works out well. This is kind of like how everything works. But when Matt wants to withdraw the USDC tokens there we get to an issue. We need to pay fees in Ethereum because in Ethereum, the way that these transactions work is that the intermediary address, like this address Banana, needs to contain it to cover for the transaction fees. But because this is like a newly generated address that does not contain anything, it's essentially impossible. This does not work.
00:06:59.772 - 00:07:44.460, Speaker A: And there are a couple of ways to kind of go around this thing. And the very simplest thing is that, well, maybe we don't really need this intermediary thing and maybe just like Carol can call the approved Chrome function and that's also our issues. But then again, Carol cannot use any exchange or any kind of simple wallet. This requires specific web3 compatible wallet for that kind of transaction or that was just like a non starter for us. Another thing is that maybe Matt can just deposit a little bit of it at that intermediary agent that would be used to cover for the transaction fee. But this also becomes super tricky to implement super fast because the transaction cost is variable. We don't know the actual gas amount that will need to be spent as well as the gas price.
00:07:44.460 - 00:08:39.296, Speaker A: In is subject to essentially market conditions. So it's like super hard to figure that out. Are you going to be wrapping up soon? We just started. So that kind of puts us in this tricky situation where on one side we need these address based systems, but we kind of also need Ether on those addresses that we cannot find. Thankfully, Ethereum lets us create contracts and we can use smart contracts to solve this thing. This is like a ten line or so smart contract that is essentially the base of our solution of how we do that thing. When we initialize this forwarder contract, we get like a destination that's like the merchant's final destination that they want us fund sent to.
00:08:39.296 - 00:09:25.292, Speaker A: And the only thing that this contract can do, it has just like single function flush tokens that can be called by anybody. And whenever that function is called, whenever that function is called, the funds automatically get transferred from this intermediary address to the final destination. Something to be kind of noted that we'll get back a little bit later is that this flash tokens function is completely open to anybody. There is no guard by owner only or anything like that. It's freely available to everybody to go. So if we kind of go back to our diagram now we have Carol that wants to buy the bananas, has a unique address. But now it's not like just like a simple address.
00:09:25.292 - 00:10:12.430, Speaker A: It's like a smart contract that's initialized with Matt's final destination. She sends the USDC tokens to that address. And whenever Matt wants to withdraw the funds, instead of him sending some Ether, anybody in the world, whether it's him whether it's Coinbase, whether it's like any other third party call this flash function and whenever this flash function gets called, the USBC automatically gets transferred to max address. And I do hope that at this point you can kind of see how these forwarders solve our problem. We could essentially deploy a bunch of these forwarders whenever somebody pays. We could call the flash function and essentially the funds would go wherever they need to go. So this is all good.
00:10:12.430 - 00:11:01.180, Speaker A: The good things about this solution is that it's like address based. So anybody could pay from whether they have a mobile wallet, whether they have web3 compatible or they are just using an Exchange. It's completely noncustodial because anybody can access this contract and nobody could prevent the fund reaching their final destination and we don't really need any in the account itself to handle these payments, which is all pretty good. The bad thing about this contract is that it's a lot of repetitive. It's very hard to deploy because the way that what we've described so far, we would need to deploy this pool of contracts beforehand. We don't know how many we need to deploy. They are all costly.
00:11:01.180 - 00:12:03.612, Speaker A: It's all expensive to manage. So if you try to kind of deploy this thing at scale in real life, it's becoming very supermassive. So what are we going to focus on for the rest of this talk is kind of like the patterns and strategies that we've used to kind of mitigate the bad side. And all of those things are something that I think is very readily applicable to a lot of other situations. Any situation that these kind of simple repetitive things that you need to do, that you need to kind of do them on a per session or per user or something based could benefit from these. Patricks the first thing that people can do to kind of mitigate the cost and the complexity of this thing is to use a factory. A factory is essentially a singleton contract that deploys one that contains the logic of the contract and knows how to generate new contracts.
00:12:03.612 - 00:12:48.968, Speaker A: So this is like the forwarder factory over here. We just have a mini forwarder function that can deploy a new forwarder. Once we have this factory on the blockchain, we go from something. This is like over here we are seeing the raw transaction that essentially deploys a forwarder. So the code over here contains all the logic of how the forwarder is being initialized. What does it mean to flush all of those things? That's like a lot of logic. Compare that thing with these couple of lines down there that only contain essentially this thing says like hey, I have this single tone factory on the blockchain.
00:12:48.968 - 00:13:35.390, Speaker A: Call it and call the init function. Both of these functions perform the same logic. At the end of the day, either one of them will end up with a new forwarder being deployed on the blockchain and they are kind of like indistinguishable functionally speaking from one another. But essentially the EVM rewards us for using less space. In the first case we have 1.7 KB weight of the transaction and we use like four hundred and forty k of gas and we reduce that to less than 200 bytes of data with 240,000 units of gas. So this is a pretty significant saving that kind of like it's good but we still have problems with it.
00:13:35.390 - 00:14:39.232, Speaker A: How many of you know how essentially addresses are calculated in the Ethereum blockchain? It's like a little bit of a mess but pretty much we have the original way that when you deploy an address essentially you take some hashing function of the parent address and like a number known as non. The non is like an ever increasing counter associated with the parent account of how many transactions have originated from that z. And this essentially means that there is like a global state, serializable state of kind of accounts of transactions going from here. And it's very hard to build production systems that depend on nons. It's very easy to get something wrong. It's very easy to create a transaction with something that's invalid there that has tool off. I guess that makes the whole kind of like it makes depending on future addresses like very hard.
00:14:39.232 - 00:15:42.550, Speaker A: But thankfully with the latest Ethereum fork that happened like earlier this year we have something that's called Trace Two. And Trace Two removes this essentially implicit global dependency on the nons for something that's very explicit. Now we pass in a salt that is kind of like determined by the developer and also here is the code but that's slightly less important. What this means in kind of like real life, in very kind of like technical terms these are the changes that we need to do to start using Create suit. So you can see that in the first line you cannot really see but in the first line we are passing an explicit soul parameter. Before that its function was performed by the implicit nodes. And then the other two changes is that instead of create we use Create suit and instead of the implicit node that was not passed, now we pass the soul to the Create suit function.
00:15:42.550 - 00:17:00.500, Speaker A: This is a huge win in terms of operational reliability and just kind of like security and having some trust in the code is doing the right things is because right now, we, as the users of this factory, can know where these forwarders will be deployed, without really knowing the state of the blockchain, without really knowing how many contracts have been deployed from this factory, without having to have any guards on this thing. This allows us to essentially simulate a lot of this essentially gives us a possibility that we can calculate these addresses, forwarding addresses priority without deploying them to the blockchain. We can show them to the final customers to the people like Carol. Carol can pay to that address and only after she has paid, we can then deploy the contract and we are certain that they'll be deployed at the right address. We are certain that nothing bad can happen with that. So it's a huge win for any kind of DF developer or hardware wallets or something that does not need to constantly interact with the blockchain and know its fake.
00:17:00.600 - 00:17:02.992, Speaker B: And if she never pays, you never have to deploy the country.
00:17:03.046 - 00:18:18.680, Speaker A: Yes, and also there is like a very security whenever you interact with these things, you want to have a symmetry between how much it costs for an attacker to essentially deplete your funds or deplete the merchant funds and how much you can kind of like you need to spend. So this one aligns those two things well together because if you need to eagerly deploy contracts on the blockchain, then it's very easy for somebody to just deplete the merchant's fund by creating thousands of contracts and never paying any one of them. But with this scenario, they need to incur cost on their own. They need to first pay something on the blockchain before it's actually used. So it's like very good stuff. The other thing that we've done to make this thing a reality and to make this thing usable as kind of like protection scale is we use what's called minimal proxy contract, which is like a very cool feature that allows to go from a transaction of this size to transaction that goes of that size. What we see in the code below is like a huge, huge redaction both like in bytes as well as like in gas.
00:18:18.680 - 00:19:21.724, Speaker A: And essentially the transaction below deploys a contract that you can think of like a theme link to any other contract on the blockchain. So the transaction below, I don't expect you to understand or to read this thing, but this is like everything that he does is he deploys new contracts that gets initialized with a single address. And any call to these very small tiny proxy contracts would get kind of relayed and executed by the other one. This is probably the smallest contract that can exist on the blockchain because it just kind of says like hey, I was told with something, I don't know what it is, but I do know that my parents can answer this question. So we use these things to essentially come up to this topology of our contract. So this is like how our system works today in production we have like a single forwarder factory that knows how to produce this thing. It has like a fixed address.
00:19:21.724 - 00:20:04.436, Speaker A: It's a single one that we've deployed once, then we can forget about it. And whenever a merchant comes, we deploy a forwarder with their final destination. And from that point onwards, for any interaction with any of their customers, with any terrors out there, we calculate a clone address, whenever Claire would deploy, would face one of those addresses only then we go and we actually deploy that clone. And that clone doesn't know anything. It just says, hey, I don't know about anything, but I know that my forwarding parent knows about it. This would just essentially the first implementation of the forwarder. The forwarder knows that, yeah, I just need to send the fund to destination.
00:20:04.436 - 00:20:37.940, Speaker A: And that's kind of how it goes and how it goes overall. What we've done here is that we developed these smart contracts that are easy to use for anybody, regardless. They don't require web3 support. They're noncustodial. Right now we manage all of these contract deployments, but that's not like any strict requirement. The Merchant can themselves hold this contract. They're completely open.
00:20:37.940 - 00:21:25.510, Speaker A: Anybody could hold this contract to flash the funds. And we've sold a repetition problem like what we deploy is super minimal. It's very reliably to kind of compute these addresses. We can be certain that we cannot have any bugs in terms of non calculation or non management. And they are relatively cheap to deploy, especially if you consider that we can reuse this contract. So once we don't do this thing today, but I'm pretty sure that we will, once this thing becomes like a bottleneck, we could reuse the contract that we have. And from that point onwards it becomes like as cheap as just kind of like calling the transfer function virtually free.
00:21:25.510 - 00:21:41.000, Speaker A: So that's pretty much everything about what we had. We can kind of have questions, if you guys want, about any of this stuff. Yes.
00:21:41.150 - 00:21:53.308, Speaker B: When you create the flush contract and it forwards, where are the address that you're flushing it to? What is the address that it flushes to? Where is that?
00:21:53.394 - 00:22:32.490, Speaker A: So you can think that that's like the Merchant's final destination. Right now we deposit to kind of like the Merchants default ethereum address based on their kind of like 32 seed, so that they could kind of import their seed from any other third party wallet and see all of their balance. But you could imagine that that destination can be like a setting determined somewhere in the dashboard, in the settings. It can be an exchange or something, so the funds will automatically go there.
00:22:33.740 - 00:22:35.370, Speaker B: Is that currently a thing?
00:22:35.900 - 00:23:04.230, Speaker A: It's not currently a thing primarily from UX perspective because if you put your kind of exchange address there, it would be very hard to kind of tell you what's your balance of how much money you've received, what does it mean to withdraw those funds. It gets very tricky, very fast from UX perspectives and product perspectives. But technically there is nothing preventing that thing from happening.
00:23:08.990 - 00:23:13.574, Speaker B: Have you thought about self destructing the contract after you forward the gas?
00:23:13.702 - 00:23:19.646, Speaker A: Yes. So self destructing the contract will reduce by, I think, fifteen K the gas cost.
00:23:19.748 - 00:23:20.400, Speaker B: Okay.
00:23:21.170 - 00:23:24.366, Speaker A: And that statement is something and with.
00:23:24.388 - 00:23:30.640, Speaker B: Create too, you can actually recreate the contract at that address if you need to. Again, that's true.
00:23:31.330 - 00:24:22.402, Speaker A: Something that's a little bit tricky with creates too, and especially with minimal proxy contract is that there is like a weird dependency on if you want to make this thing completely open, if you want to make this theme kind of like very simple to use, it gets very tricky very fast. It's not enough cost benefit, like the money that you get back. Yeah, but it's only 15K gas. That's nice. Yeah, that's like one reason. The other reason is that I do think that we will get to a point where we can have this pool of addresses that have been paid to. And because these are kind of like one time things, like, you know, like if a customer pays to the merchant, we need to monitor that address for a while, for like a week, just like to make sure that somebody doesn't pay something twice or something similar.
00:24:22.402 - 00:24:36.838, Speaker A: But after that, we can reuse that address for like another interaction. And in that case that if you.
00:24:36.844 - 00:24:49.500, Speaker B: Can do USDC, I mean, you can do pretty much any ERC 20. Yeah, the UI just not there yet, but right now it's limited. Or is there only going to be things that you guys list?
00:24:52.270 - 00:25:07.214, Speaker A: Technically, on the technical side, we could support any ERC 20 token. There is literally no limitation. It's like adding one line of code somewhere to say, monitor this token. It's like a product question at this point.
00:25:07.252 - 00:25:20.366, Speaker B: It's definitely partly UX. I think it's partly also just adoption of the UX 20 tokens that we would add. I think there's still a little bit of a gap on users using adopting.
00:25:20.398 - 00:25:21.666, Speaker A: This technology because they still need to.
00:25:21.688 - 00:25:45.770, Speaker B: Have deep to be able to then pay with it. So just generally has that hurdle. But if you start seeing more adoption of just general USDC or other USD 20 tokens, then we prioritize that anymore. I think this is a really good UI. If it could just fund Dows for me to just make users more comfortable making that transaction.
00:25:46.670 - 00:26:16.140, Speaker A: And at the end of the day, you're more than free to use the contracts. And if you end up the destination being the Dow contract, it'll automatically get flushed and you know who paid for what. You can have that. You you cannot do that thing from the product itself. But you're more than welcome to use the contract. Do that on your own. Yeah, I mean, I guess we're running a little bit late on time, so don't have any questions, but we can do.
