00:00:01.370 - 00:00:15.440, Speaker A: I think you've already made the intro, but we have Bartek coming on to talk about withdrawal schemes from Optimistic Roll Ups. So, Vartek, you are already here, and I'll ask you to turn on your video and kick us off with the talk.
00:00:18.930 - 00:01:34.030, Speaker B: All right, thank you very much and welcome, everybody. Let me just share the screen. So good. Okay, so let's just talk for the next 20 minutes about how we can actually enable fast withdrawals for the Optimistic Roll Ups. As you probably know, for the Optimistic Roll Ups, there's this big concern regarding the time that it actually takes to withdraw your funds. And this is one of the main concerns or critiques of this kind of a technique. And I'd like to actually dive a little bit deeper so that you have all really good understanding, like what exactly is preventing users from withdrawing in a short time frame, and how can we actually alleviate this problem and what are the proposed techniques and solutions to this? So, a little disclaimer.
00:01:34.030 - 00:02:12.798, Speaker B: Whenever I talk about a L2, I actually mean a roll up, which is like a thing that you build on top of l One and not a side chain. A little bit confused why some people, including Ethereum Foundation, they kind of call all the scalability techniques layer Two. But just to simplify, for me, l Two is something that you build on top of L One. It actually uses the security of L One. So a very quick summary. I mean, you probably must have heard already about the optimism, and we've had some great talks. And yesterday there was a fantastic workshop from Ben and Calvin from Optimism team.
00:02:12.798 - 00:03:06.400, Speaker B: I have to admit that they got the picture wrong, because the L One should be at the bottom and you build above L One, you build L2. So L2 should be on the top. They got it backwards. But other than that, let's have a look quickly what happens when the end user submits a transaction to l Two? So there's the sequencer, which is like a mining node on L2. And the end user, when they submit a transaction, L2, it gets bundled with a lot of other transactions, and the whole bundle is actually included in L One. It's sent simply to a smart contract on L One, which is called OVM for Optimistic Virtual Machine Canalical transaction chain. And you can see here in yellow that this is actually stored on L2, this transaction information.
00:03:06.400 - 00:04:06.450, Speaker B: Now, after a while, the sequencer also appends what's called a state batch, which is literally a new state route for the whole bundle. So it says to us that if you were to execute all these transactions in a bundle, you'll end up with a state tree with that root. And anybody can check if this is indeed correct, right? So when the sequencer sends the state to l One, it doesn't send the full state because there will be like a massive amount of data. It only sends the other state root. And as you can see, this is pretty cryptic and we can kind of trust the sequencer that the state root is indeed correct. And this is, by the way, no different from l One. If you look at the ether scan of any block, you'll see that there's also a state route of all the transactions, like here, 271 transactions included in this block.
00:04:06.450 - 00:04:43.962, Speaker B: And we have to kind of assume that this is correct. There's this cool crypto economic game played between ethereum nodes. It just does not make sense for the nodes to publish not the correct state route. However, there is no proof, right? There is no, like a zero knowledge proof or anything like that in the ethereum l One chain. So this state route, this is for l One, and this is a very similar technique that's used by the optimistic roll ups. They just publish a state route of the l Two. So what happens after one week? After one week, actually, this state updates.
00:04:43.962 - 00:05:59.110, Speaker B: It's just assumed to be correct. That means that since nobody was challenging the state route, the whole chain and the whole construction is assumed to work normally. And we kind of trust that this may never be changed. However, if during this week somebody made a valid claim that this state was actually wrong, then we delete it, right? So there's kind of a reorg happening here on l One and of course, on l Two as well. But it's important to note that the reorg only is happening at the state level here, but the original transaction is still here. And this is why we call it a canonical, right? Once this transaction is submitted to a chain to l One, that cannot be deleted by anybody, because it's just baked into l One, and there's no way, and this is guaranteed by a smart contract on l One that this can never get deleted. So the key insight from all this, really, to enable fast withdrawals and all sorts of other cool features that you can build on top of optimism, is that once the transaction is submitted, it can never be deleted from the canonical chain.
00:05:59.110 - 00:06:57.670, Speaker B: And whenever we see this transaction here, we can actually compute the state ourselves, right? We don't have to wait for the sequencer. I mean, anybody running full node over l Two can look up at this transaction, can actually read the canonical transaction chain straight from l One, and they can compute the correct state for themselves, very much like you would be doing running the full node on l One. So if you look up this transaction, you can check yourself whether this transaction will actually succeed. And if this is actually initiating a withdrawal transaction, you can actually see whether that will succeed or not, and whether the dai should be sent to the user or you may get a revert, right? Like an insufficient balance or whatever. I mean, there can be a lot of reasons why this transaction can revert. But again, you can check it yourself. You don't have to wait for the sequence.
00:06:57.670 - 00:07:53.302, Speaker B: This is the clue for how you would like to approach the fast withdrawal scheme. So to go into a little bit more details, there's this mechanism in Optimism roll up that allows you to send messages from l One to l Two and vice versa. They do it by having two different contracts, one on L One, one on L2, and this guy on L One that allows you to send a message to this contract. And this message will get relayed to l Two and vice versa. If you send the message to l Two, it will get relayed all the way back to l One. And let's see exactly how it happens using the actual bridge, ERC, 20 bridge as an example. So we deploy two additional smart contracts.
00:07:53.302 - 00:08:21.282, Speaker B: So these are ours, not from optimism, right? On l One, we've got the L One part of the bridge. On l two. We've got the l two part of the bridge. And the user on l One would initiate the positive. They would simply send a die to this smart contract to this part of the bridge. This will actually lock this die inside the smart contract. It will invoke a method called Send message.
00:08:21.282 - 00:09:08.370, Speaker B: And this takes two arguments, like the destination and the payload. So in this case, we want to send the message to the other side of the bridge, right? And the way it works, it actually inserts this transaction directly into the canonical transaction chain. It's kind of like almost like a backdoor, if you like. And you can use this backdoor for your transactions as well, if you feel that the sequencer is like censoring you or whatever. But this vector is extremely important in the whole construction. So this vector is actually used by the cross domain messenger. And once it's included now this is canonical, right? This is as good as any transaction that was inserted by the sequencer inside the batch.
00:09:08.370 - 00:09:39.398, Speaker B: Because of that, now sequencer has no choice. It has to execute this transaction because if it skipped, the state would be challenged, right? So now this is very canonical. So the sequencer has to execute it. And execution is very simple. It's just passing the data payload to whatever destination. So in our case, it was to the die bridge and the method was complete deposit. The payload was 100.
00:09:39.398 - 00:10:09.240, Speaker B: This actually informs the die bridge to mint the equivalent of die, the equivalent token for die on l Two. And of course, this token will be sent to the user right on the l Two account. And I think it's important to note that this construction is 100%. Permissionless like this bridge does not introduce any additional trust assumption. There is no operator. There is no multisig. There is like nothing, right? I mean, this just works and it will always work.
00:10:09.240 - 00:11:06.470, Speaker B: So let's have a look how it works the other way. It's a little bit more complicated. We initiate withdrawal on the L2 bridge. It actually burns the tokens on L2 and sends the message the other way, right? Sending the message the other way. This guy, the L2 cross domain messenger, they have to simply put this information into its state tree that's the state on L2 and that's it. They don't need to even issue any event or nothing like that. It's enough to simply update the state because this initiate withdrawal that will be eventually put into this initiate withdrawal, this update transaction batch, right? So this initiate withdrawal will end up in the canonical transaction chain.
00:11:06.470 - 00:12:31.314, Speaker B: Then the state, including this little message here, will be appended to l One. And now, because we are not sure if this is correct, now we have to wait, right? We have to wait through the fraud proof window. And once that passes, anybody can actually pick it up and can relay this message to the cross domain messenger, right? There's this little check inside this smart contract. It actually checks whether the fraud proof window elapsed. And if this is so, it actually assumes that the state is correct, the actual initiate withdrawal can be passed. It's easy to imagine what happens next. This method is invoked on the die bridge and eventually the die is sent to the user, right? So how do we actually deal with this one week delay? And by the way, the frequently asked question is what if the state hash submitted to l One is actually incorrect and nobody submits the fraud proof? Right? What happens then? And the answer is that the security assumption of the whole construction is broken, right? So if that happens, we would need to basically shut the whole roll up and start all over.
00:12:31.314 - 00:13:51.454, Speaker B: And to make this construction fully secure, we have to make sure that this section never happens. So if the state is wrong, somebody has to be incentivized to actually submit the correct state right to submit the fraud proof. All right, so let's have a look at how we can approach the fast withdrawals from the very simple schemes to schemes that are somewhat more complicated. Well, like I said before, anybody can look up this transaction as soon as this is actually put into the economical transaction chain. And they can validate this transaction by simply executing it and looking up the actual state. So because anyone can check if this will succeed or fail, we can introduce this little guy here that we will call a liquidity provider and they can assist the end user. How would they do that? So imagine that the end user does not want to wait for one week, right? They have initiated withdrawal, they can see this transaction on chain and now they have to wait, right? So the liquidity provider can come to the game.
00:13:51.454 - 00:15:04.798, Speaker B: They can validate this transaction themselves without the waiting for the sequencer, and they can offer this user the Dai or the token that will be withdrawn eventually after one week. And if they have this die right now, they can actually give this user that die and claim the original user's die in a week, right? And note that because this can never get deleted, it doesn't really matter whether this new state update from the sequencer is actually correct or not. It's completely irrelevant if I can validate myself the initiate withdrawal, and if I don't make a mistake doing so, I can be 100% certain that after a week, the die will be actually released, right? So if we can find a way to make sure that this die released to me, I can make this swap. And this is called the liquidity provider enabled fast withdrawal. It's very simple to actually implement. However, it's got a couple of drawbacks. Well, first of all, it can be quite expensive for low liquidity tokens.
00:15:04.798 - 00:15:59.106, Speaker B: Also, the big withdrawals may lead to liquidity crunch because maybe there's actually more tokens on L2 than on L One. And if that's the case, and if somebody wanted to suddenly remove all the liquidity, there may be simply not enough liquidity on L One to assist such a huge withdrawal. And also, that probably wouldn't work at all for NFTs because these are unique, right? So unless user is withdrawing an NFT to sell it immediately, this scheme wouldn't actually work. However, for a lot of use cases, that could be actually quite good. How can we do better? Well, now we're going to the Maker Protocol. Maker protocol actually can provide virtually unlimited liquidity. Maker Protocol can mint Dai using whatever is available as a collateral.
00:15:59.106 - 00:16:56.254, Speaker B: It's up to the governance of the maker protocol, but it can actually serve as a cheap liquidity provider. The intuition would be to simply mint Dai for one week and give that Dai to the end user. And after one week, since we can validate this initiate withdrawal transaction ourselves, this is almost like a risk free loan, right? So it would be very similar to the Fleshment, but for the duration of the fraud proof window, not of one transaction like a normal flash loans or Fleshments, but for the duration of the whole week, we will mint Dai. And after one week, the Dai will be returned and it will be burned. And we can go one step further. We can actually remove the liquidity provider, and we can do everything in a smart contract by using Oracles. And it just happens that the maker protocol has an Oracle network.
00:16:56.254 - 00:17:52.026, Speaker B: And that Oracle network can be quite naturally extended to do the validation of this canonical transaction chain. And if that's done like this, we can imagine that perhaps the bridge itself can simply ask the oracle whether the withdrawal will succeed. And if the Oracle says yes, then it will simply release the die. Right? So that looks very simple. It does not introduce any additional trust assumptions except for the Oracles themselves. But this is actually important that this scheme is actually dangerous because if the Oracle fails, then this architecture can actually lead to a double spend. And I don't have much time to explain why this is the case, but I leave it to all interested viewers to think a little bit about it.
00:17:52.026 - 00:19:15.394, Speaker B: But let's try to improve on this. So now instead of just releasing the Dai, we actually print or mint Dai in a megavault, right? So the way now it would potentially work is that the user who would be trying to mint Dai, now they would actually ask the bridge to do the fast withdrawal and the bridge would ask the mechavault to mint Dai. And again the maker vault will ask the Oracle whether the withdrawal will succeed if the Oracle confirms that this Dai is actually minted. Right? So there will be some debt here recorded, the original Dai still stays at the vault, but the Dai, the freshly minted Dai can be released all the way to the user, right? And after a week the die will be released. Now of course not to the user, but to the vault and it will erase the debt. Right? So that would work. And the interesting feature of the design is that now if the Oracle fails, then the maker will have to cover the loss.
00:19:15.394 - 00:20:11.254, Speaker B: Right? And interestingly enough, this is not any extra additional security assumption because the way the maker protocol works today is that it actually relies on the Oracle networks. And the Oracle failure, the potential Oracle failure is covered by the various mechanisms inside the maker protocol, right? So we're actually piggybacking on the whole maker infrastructure to that. And the good thing is that such potential failure of the Oracle network, that does not affect Dai users, it will affect MKR holders. And this is literally what the MKR token is for. The only downside of this particular design is that it's not particularly flexible because the user to make a fast withdrawal, they have to go to the maker vault every single time. That's actually gas consuming. So let's improve on that.
00:20:11.254 - 00:21:32.130, Speaker B: How about we actually tokenize the withdrawal claim, right? So instead of sort of going to the bridge and going to the vault, the user may go to additional component which we will call FDAI minter. F stands for a forward Dai. And this represents a tokenized withdrawal claim, think NFT which says I have initiated withdrawal and I will get this amount of die in a week from the deposit contract. Right? So we will use this as a collateral potentially, but we don't have to, we can actually swap it with somebody else, right? And here the liquidity provider may be back in business we can create sophisticated swap market, we can create some additional secondary liquidity solutions around it and the users can maybe, perhaps even bundle these tokenized withdrawal claims and use them as a collateral to mint, like a mint die in bulk if you like. Right. And hence the gas fees will not be such a big problem here. So this is probably the most sophisticated type of structure and construction.
00:21:32.130 - 00:22:13.450, Speaker B: But as you've seen, I mean, we can iterate, we can build different type of bridges. And the last point that I wanted to make is that given the fact that different type of bridges now you have to sort of realize that users will be able to actually use many of them with different mechanisms. For example, they can use the die bridge with our fast withdrawal scheme, but they can perhaps use some other type of bridge, like a multitoken bridge. And this will also create die on L2. Right. However, these are not the same Dai. They won't be fungible directly.
00:22:13.450 - 00:23:21.762, Speaker B: I mean, you can easily swap them one to one. However, they can't be like mixed and matched because you cannot go through one bridge and exit through another bridge. Right? So I think it's important for the community to realize that there must be some sort of a social consensus on what is the actual Dai token on each of the layer tools. And I guess from the user perspective, you wouldn't want to end up in a situation where there are a lot of different competing die implementations, right? So main takeaways message passing from L2 to L One is an Oracle problem and Maker already has an Oracle network and Dai security actually relies on them so we can easily leverage this construction. Maker also has no liquidity constraints at all for Dai, so there will be no problem of liquidity crunch. And also this scheme can be used to provide Dai liquidity to support fast withdrawals for other tokens as well. It's a little bit different, but it definitely can be used.
00:23:21.762 - 00:23:59.550, Speaker B: And we're really happy to talk with other projects on how we can achieve that. And also the last note, we need social consensus around the issue of what constitutes the real token on O Two. So thank you very much and I hope I made everything quite clear. And if you've got any questions, I don't know if you've got time for them or not, but that's the end of my presentation.
00:24:01.750 - 00:24:42.970, Speaker C: Awesome. Thank you so much, Bartek. And I guess as a bear market story I can share. I don't know how many viewers realize, but MakerDAO basically started DeFi when Dai launched about three years ago. That was the first decentralized product, CDP Vault. And what's really exciting now about Maker building this bridge and working on roll ups is the original vision of Maker and Know being accessible to lower income communities or just anyone who may have not had access to the banking system. So really excited to hear Maker focusing on that and making it affordable, basically, to do transactions with Maker.
00:24:42.970 - 00:24:46.360, Speaker C: Awesome. So.
