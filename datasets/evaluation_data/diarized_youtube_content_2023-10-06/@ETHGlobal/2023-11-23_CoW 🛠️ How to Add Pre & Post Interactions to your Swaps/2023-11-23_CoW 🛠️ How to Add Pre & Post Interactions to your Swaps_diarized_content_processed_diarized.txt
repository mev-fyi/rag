00:00:07.050 - 00:00:59.040, Speaker A: Hello everyone. Welcome to our Cow Protocol workshop for this hackathon and we are going to talk about a feature that we launched recently, cow Protocol hooks which allow you to upgrade the intent expression language of your Cow Protocol order us beyond just swap intents. There's also another project or another type of feature that we are sponsoring which is programmatic orders. I won't have time to go into that into detail, but I'd have a link at the end and you're welcome to stop by our booth and we can explain you everything about programmatic orders as well. Maybe just quick show of hands so I know how much I should spend on kind of the intro part versus the demo part. Who here is not familiar with Kauswa or doesn't really know what it's doing? No one? Everyone knows. Okay, sorry, should I speak in this? Okay.
00:00:59.040 - 00:01:35.350, Speaker A: So I can keep it very short, maybe just for the recording. So kauswab kind of invent. Well, invented as a strong word, but kind of pioneered. Intense, I would say, in the dex aggregator space back in the days, let's say 2019. 2018 the way that trading would happen on chain. Is people would sign a specific ethereum transaction saying concretely, I want to go to this uniswap pool and swap this asset for that asset and hand that directly to the miner, which exposed them to revert risk. They wouldn't get best execution because the price would change maybe to a different venue.
00:01:35.350 - 00:02:48.814, Speaker A: While they were waiting for their transaction to get mined, they would pay failed gas cost. And the overall experience was quite harsh if we think that we want to get blockchain into the hands of retail users and people that are not trading experts. So Cow Protocol kind of reshaped that trading model by making users just sign abstract messages, limit orders if you will, in its most basic form and handing that over to a third party network that we call solver network which compete for executing the user order at the best possible price. Solvers can protect the user much better from price swings and also mev than the average retail user can. It means that the retail user doesn't need to pay their network fee in the native token, they can just pay in the cell token. And the other thing that this kind of intent based system allows is for batching multiple trade intents together. So instead of just matching every user individually one trade per transaction cowswap allows for the solver to combine different trade intents and settle them in one atomic transaction.
00:02:48.814 - 00:04:05.686, Speaker A: And this has the nice advantage of allowing to pay to basically execute traders peer to peer. So if you are buying Ether and I'm selling Ether, then instead of going to uniswap paying 0.3 basis points of LP fee and potential price impact, we can just meet in the middle and trade at the spot price. There are some other advantages of badger auctions which kind of fundamentally lower the amount of mev that we expose in the system because we can add constraints to the solution, such as every token should just have one price within a batch or within a block. And then there is no more opportunity, for example, a block builder or some other entity to buy an asset low and sell the asset high atomically within the same block. So we really fundamentally reduce the amount of mev that we expose beyond just maybe what a clumsy user might expose when they set too large slippage tolerance. But okay, well, the last point here actually is that cow protocol is not just executing batch auctions on individual token pairs, but instead we aggregate all intents that come into the system across all possible token pairs, which allows us to find these coincidence of wants or peer to peer trades also in multiple dimensions.
00:04:05.686 - 00:05:03.310, Speaker A: That gives rise to what we call ring trades and helps generally to re aggregate the fragmented liquidity space that we see on chain. Today, if you look at ETH staking derivatives, if you look at Stablecoins, you can find multiple different tokens which are basically trying to represent the same underlying asset and you'll have different fragmented markets for those. And by virtue of having these multidimensional batch auctions, we can actually re aggregate that space and give structural price improvements and make the market more efficient. But okay, that was just basic. What is the idea behind Cowswap? Now, let's talk about the feature we recently launched, cow hooks for this. Let's just revisit quickly how the lifecycle of a cow order is in the old system where we didn't have or where hooks were not yet activated. And then we see how it changes when the user actually specifies some hooks.
00:05:03.310 - 00:05:50.630, Speaker A: Here, for simplicity, we're just looking at a single order batch. So there's no coincidence of once. And we basically have a solver that initiates the settlement transaction by calling into our settlement contract. The settlement contract then validates the user's intent, making sure that they actually wanted to make the trade that the solver is claiming to execute on their behalf. As a second step, we transfer the sell tokens from the trader into the settlement contract just so that we have something to work with. Basically, we can convert the sell tokens into the buy tokens. The solver, together with the user intent, also submits a recipe, if you want to call it like that, how to execute the swap intent on chain using the best on chain liquidity.
00:05:50.630 - 00:06:39.206, Speaker A: If there were multiple orders in the batch, they could also find coincidence of once or they could use their own private liquidity. So as a third step, the settlement contract executes that recipe, we call them interactions. And then as a last step, we transfer out the buy tokens and the trader can kind of go home with their proceeds. Now, when we hook this cow order, basically we have now a hooked cow order. There's one step before everything we saw so far, and one step after we saw everything so far. So before we validate the signature, we basically execute all the prehooks of the orders that are in the batch. And prehooks are just arbitrary contract calls that can be specified by the trader that is making the swap.
00:06:39.206 - 00:07:20.642, Speaker A: And so as a prehook, you could imagine anything that prepares your swap, anything that you need to do for your swap to be valid. It could be pulling in some funds, maybe from an LP position where you have your token staked. It could be you set an allowance just in time. You could potentially even instantiate a contract in a prehook that is needed for whatever reason, to execute the trade. We then go through the entire process so everything is executed. And at the end, the trader has the option to specify a set of post hooks that they want to execute in order to clean up after themselves in a post hook. You could, for instance, send your tokens to another contract and have those bridged over.
00:07:20.642 - 00:08:05.494, Speaker A: You could restake the asset if you wanted to. If you had bought an LP position, you could restake that LP position or anything else you want to do kind of after your trade is executed. Just one more kind of diagram over how just the kind of control flow goes for these hook executions, because that's a question we get quite often. The TX origin of the settlement contract is the solver who calls into our settlement contract. That contract itself holds allowances and fees and a bunch of other balances. So it's not safe to let the user kind of execute arbitrary calls from within that settlement contract. The user could, for instance, then take funds out.
00:08:05.494 - 00:08:56.754, Speaker A: Solvers are allowed to do interactions within that context because they're heavily bonded, but we don't want our traders to require heavy bonds. And so what we do instead is we call into a trampoline contract, like a neutral unprivileged context, which then calls into the target that the user specifies. And so, just for you to know, if you build a hook, your message sender will be basically a glorified multi send library. But it's kind of an unprivileged and shared context across all hooks, so you shouldn't really put too much faith in it. The hook also specifies a gas limit and then of course, the call data. So really, basically you can call into any contract and do anything as part of your pre and post hooks. You can also have multiple pre hooks and multiple post hooks.
00:08:56.754 - 00:09:45.042, Speaker A: That's important. And we'll go through a live demo in a minute, but just kind of very high level. How do we specify these pre and post hooks? They're actually just metadata that is uploaded to IPFS. If you have signed a Cowswap order in the past using MetaMask, for instance, you might have come across this app data hash here, and it just looks like random gibberish data. But what it actually is is a pointer to an IPFS hosted file where you can find a JSON that gives you more metadata about this order. And so for hooks, we basically just extended this JSON and said, okay, the user can specify a list of pre hooks and a list of post hooks upload that metadata file to IPFS. And of course, if you do that on a UI, that will be all abstracted away from the user.
00:09:45.042 - 00:10:36.694, Speaker A: And then basically, we just put that hash on the order that we send into the system. So now let's go through a live example. We also have a really nice video and step by step tutorial on our documentation page with the code that I'll be using to make it very easy to follow along. The example even has a post hook for now, because of time constraints, we'll just look into prehooks. So, yeah, check that out afterwards if you want to kind of reproduce what we're doing. The use case that I'm going to look at is we're going to have an account on Gnosis chain which has received one USDC, but which was a fresh account that has never been seeded with any native token. So it's literally a completely empty account.
00:10:36.694 - 00:11:27.442, Speaker A: It doesn't have any gas money. So it would be hard in the previous systems, it's quite hard to do anything with this account until you maybe fund it with some native token from an exchange or some other wallet, which would then link the two wallets together. So it's kind of maybe for privacy reasons, you've received one USDC from whatever source, and now you would like to actually swap that token without linking that account to any other account. And we can do this because USDC implements a feature called well, swaps are already gasless. We said that earlier. Like, swaps are just signed messages. The one step that we normally need when you trade on cowswap is you need to set an allowance for the token that you want to trade so that the settlement contracts can use the token on your behalf.
00:11:27.442 - 00:12:23.130, Speaker A: For that, you usually need gas. So before, if you received some token in your account, you needed to seed it. But because USDC implements ERC 20 permit, we can now actually use a post hook to give an allowance to the settlement contract via this off chain permit signature and make this account swap the underlying USDC without needing any native token. And so for this, I've taken the code from the example and kind of simplified it a little bit, made it work natively on Gnosis Chain because Mainet has become quite expensive lately. But basically what we do here is we instantiate some contracts that we need for the cow protocol settlement contract, the contract that eventually needs the allowance. The token that we want to buy will be cow. The token that we want to sell will be USDC.
00:12:23.130 - 00:13:19.802, Speaker A: And then we just create our order basically selling USDC for cow, sending the proceeds into the wallet that we're working with. So the wallet that I just showed you. And the important part here is that we now need to encode the permit call that we want to attach as a prehook. ERP 1220 612 defines kind of the arguments that permittable tokens take, and those are specified here. So we allow the vault relayer to use the exact sell amount so one USDC on behalf of our user and we make that permit signature kind of not expire so it can be used for you could put an expiry date on there. But in this example, the permit doesn't expire. We then encode the permit signature into call data.
00:13:19.802 - 00:13:53.906, Speaker A: This is what happens here. And then basically specify our hook. The target contract will be USDC, which takes the permit signature and basically sets the approval for our vault relayer contract. The call data is the permit call that we've just created here. And then we estimate how much gas will be needed and specify that as a gas limit for this prehook. We then create our app data. As I showed you before, the app data is just a JSON where we now have metadata with a Hooks field and then the encoded pre hook.
00:13:53.906 - 00:14:53.510, Speaker A: And we then go to our API and get a quote for our order. It's important to note that this gas limit needs to be specified and needs to be accurately reflected, because the quote will compute how much gas does your hook need and put the network fee that the solver will incur for executing the hook as an extra fee on your order. So if you just put a very large number in there, then the fee that your user might have to pay as a network fee might become very high. We receive the quote and then we sign the order that we received and we place it on our API. So I know this was quite quick. I recommend checking out the tutorial and reading the code step by step. I think we can run this example here so we can see that the account on Gnosis chain is encoding this specific permit hook.
00:14:53.510 - 00:15:38.332, Speaker A: It is then receiving a quote from our API and it's then placing this order in our API. So now if we go and check out this order, we can see that it is found in our back end. It is not yet settled, will take maybe 30 seconds or a minute for it to settle. But once it does, once it does, we'll see that it has converted the USDC into cow without requiring any gas. Here we go. We've lost $0.03 in price impact or in LP fees on this trade.
00:15:38.332 - 00:16:57.816, Speaker A: But basically what we see now is that the contract no longer holds USDC, but instead holds cow. If we go and inspect that settlement we can also see what is happening under the hood. I'm using tenderly to simulate or to kind of analyze the trace of what was going on in this transaction. And basically what we see here is that before the signature was recovered here in this line, we actually executed some interactions before and those are the pre interactions or pre hooks. And here we will be able to see that we're calling basically permit might not be the contract I think is not verified on Osis chain, but here you can see it's a permittable token that some message selector is called on and that's actually the permit message that is being called before the signature verification and before the transfers from the user address. So this is so much for the live demo. I have only four minutes left, I think, on the slide deck.
00:16:57.816 - 00:17:38.724, Speaker A: I have just a few more ideas on what you could build with hooks. So we just walked over the permit and some other ideas are yeah, you could unstake LP tokens just in time to sell them. You could deploy a safe. And so you'd really have like a stealth contract that has some tokens and then just in time deploys a safe, which could even be a programmatic order. So not a standard limit order, but maybe a stop loss or good after time or TWAP order, something more complex. And then for post hooks, it would be nice to look at generalized bridge solutions. We have an example for Bridging to Gnosis chain and the polygon team also worked on an example for Bridging to polygon.
00:17:38.724 - 00:18:04.992, Speaker A: But maybe we can actually find a solution that bridges to any other chain as opposed hook. You could restate your LP tokens and the ideas are endless. You can really connect your swaps with anything you want to do before and after you trade. And with that, the godshots I will not go through. But let me just end here. These are the references for our docs. We have our old docs version one, which are a little bit hard to read maybe.
00:18:04.992 - 00:18:29.800, Speaker A: And we're redoing them as a version two, which can be found at beta docs cow phi for those who would like to have feedback. So please come to our booth if anything is unclear. We are still actively working on them. We have a lot of engineers on the ground that are happy to sit with you and work together with you on something. We also have documentation about the other bounty. We have programmatic orders. And then here's again the QR code for the tutorial on hooks.
00:18:29.800 - 00:19:55.030, Speaker A: And now I have like three minutes for questions. Ben, could you just briefly describe the difference? Yeah. So programmatic orders is not doing anything before or after an order. To me, hooks extend the intent, expression, language of cowswap to allow you to do more things before and after you trade, whereas programmatic orders allow you to be more dynamic or programmatic in a way about what the order the actual swap you're trying to do wants. So in the traditional system every swap is a limit order. So I really have to say sell this token for this token at this price with a programmatic order I can now let the solver or any other entity propose a concrete swap to me and all that my smart contract needs to decide is do I want this swap yes or no? So instead of making a concrete swap proposal I just need basically an acceptance function, an acceptance oracle that says given this trade, do I like it or not? And so this upgrades what type of swap you want to do, the intent, expression, language for what type of swap you want to do whereas hooks allow you to do anything before and after. So it's kind of the actions, the action space is expanded, can they combine? Yes, very much.
00:19:55.030 - 00:20:57.716, Speaker A: Any other questions? Yeah, testnet suggestion is I mean we are on Gurley and so Gurley would work. We are trying to get on Sepolia but it's not live yet. I personally like to test on Gnosis chain because with $1, you can basically test for the entire week. And it works quite well because your pools have more liquidity, there's more protocols, and it's less maybe unexpected behavior. Whereas on Girly, I sometimes feel things that's just play money, so it's hard to find, like, deep liquidity and other things. Yeah, it's very cheap to test on Gnosis but yeah, girly ognosis is what I would suggest. I think Gnosis also has Bounties so maybe you can combine some Bounties if you test on I missed Paul at the beginning but the Ferret in your example would like to specific to SDC is not like so it depends actually on your chain.
00:20:57.716 - 00:21:31.330, Speaker A: So interesting on Gnosis chain all bridge tokens implement permit if I understand correctly on Ethereum Mainet it's just I would say the more modern tokens but I think any token that has been launched recently supports it or if they don't then it's kind of clowny but yeah, it's only a subset of ERC 20. That's correct. Cool. If you have more questions, we have our booth in the main hall on the right. We have a lot of, as I said, engineers on the ground to help you hack and I'd love to see what you're building. Thank you very much.
