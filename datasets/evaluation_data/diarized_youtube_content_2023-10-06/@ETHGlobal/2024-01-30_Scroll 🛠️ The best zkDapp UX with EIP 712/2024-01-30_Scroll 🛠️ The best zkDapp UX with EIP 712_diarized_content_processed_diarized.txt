00:00:00.250 - 00:00:00.894, Speaker A: You.
00:00:01.092 - 00:00:01.950, Speaker B: Hello, everybody.
00:00:02.020 - 00:00:05.920, Speaker A: Welcome. Hello.
00:00:26.160 - 00:00:38.270, Speaker B: Everyone, and welcome to the Circuit breaker scroll workshop. The best ZK Dap Ux with Eip seven one, two. Joining us today is Ahmed Castro, who will be taking us through the session. And with that I'll pass over to Ahmed to get the session started.
00:00:39.440 - 00:01:36.692, Speaker A: Thank you. Yeah, everyone, thank you for being here. Yeah, so we're going to cover this topic that I think is super relevant to bring the next wave of users into privacy. And yeah, we will cover a variety of topics. Like for us developers, what is the challenge to building apps that offer good experience, that users don't feel lost, that doesn't require them to do some extra assigning seamless experience? So what are the challenges? But we're going to talk about what are the solutions that we have available at the moment. Also, we have paint a general view of the architecture that is needed to build something like this. And we're also going to go through a live demo.
00:01:36.692 - 00:02:42.612, Speaker A: We're going to experience from the user perspective how it is to use CKDAP with privacy and good user experience. And we'll also go to look to the most important part of the code, the code that you will need to focus more as a developer. And we'll finish with talking about some caveats, some things that we have to take into consideration while building our Dapps and also with some recommendations from my part. And so let's start by the challenges. What are the challenges? What is the hardest part for us developers when we're building privacy? Dapps. So one is proving time. So when you do every action, you will usually take a lot of time to prove.
00:02:42.612 - 00:03:30.008, Speaker A: And there are some alternatives to this, but the proving time is even longer if you're using stuff like ketchup or easy recover. And what is ketchup and easy recover? And it's like the signature and hashing functions that Ethereum uses. So if you're building an application compatible with Ethereum or any EVM chain, you will usually need to use these functions. And they are extremely hard to prove. But now it's possible. But yeah, it's still a problem. The second problem that we usually face is how do we preserve anonymity in a public by default platform.
00:03:30.008 - 00:04:32.156, Speaker A: So blockchain is public by default. You can see like every transaction, you can see every NFT mint, any swap, any contract deployment. How do we preserve anonymity and how do we operate in a public blockchain? How do we operate with private that data? So yeah, that's the second challenge. And the third challenge is how do we offer easy process to our users? Like if you may have tried for example tornado cache in the past, you have to store these notes. If you have used like Aztec Connect, which is now deprecated. But if you use it, you may be familiar with signing a message that is just like a hash, and then you sign another message and you don't know what is it, and then you sign another message and you don't know what is it too. So that can be a bit frustrating for the user, just doing stuff that they actually don't know what they are.
00:04:32.156 - 00:05:56.504, Speaker A: So solutions for this one is just keep updated and just be open to try different tools. Be open to update and upgrade your libraries constantly because it's really impressing how researchers and tool developers are keeping up and just making proof time slower, not slower, faster, sorry. And how we have new libraries and tools optimized very often. So just keep everything updated and keep learning because there's always new stuff coming. Also in second part, in order to keep the preserved anonymity in a public chain, we have some tool belts that we have to learn what they are as a developers. And those tool belts, the two most important one that if you are new into CK development that I would recommend to you to learn and understand it and use them and get familiarized with, are nullifiers and relayers. And what are they? Nullifier is a mechanism that prevents double spending in private data.
00:05:56.504 - 00:06:52.804, Speaker A: So imagine that you have a private voting system. It prevents you to double vote if you have a defi application, and it prevents you from double on stake if it's an unstake privacy platform. For example, in this workshop we're going to be building a comment like anonymous chatboard, so it will allow moderation. For example, you can only send a message, one every minute or hour or day. And this is why nullifiers are important. And relayers. Relayers are important because it sounds like a very complex subject, relayers.
00:06:52.804 - 00:07:57.724, Speaker A: But in simple terms, relayers are that you can send a message to. You can send transactions through metamask just by sending it, for example a swap or a token transfer or whatever. But alternatively, and this is like in the realm of account abstraction, it's not like account abstraction itself, but it's very near that topic. You can also sign a transaction, so whoever else can put the transactions on chain on your behalf. So no one can sign a transaction for you, no one can impersonate you, but someone can send a transaction will be helped. And this is important in CK, because what if you are doing like an anonymous protocol. But you send a transaction on chain, you don't want that because at that point you will be exposed, you will be docs, everyone will know who you are.
00:07:57.724 - 00:09:09.904, Speaker A: So you send to a relayer service and that service will send a transaction on chain for you. So these are the two most important tools under your CKDAP developer belt. And the third one is using your Ethereum wallet to sign transactions. So alternatively you can use another like an external secret key external to your Ethereum wallet. But it's a bad user experience because you already have your Ethereum wallet and you already use it for every day and you sign transaction for it, you already have it and it's really hard for user not to lose their mnemonic like twelve phrases mnemonic private key and we don't want to ask them to have another one just to use CK. So ideally you want users to use their Ethereum wallet and even better if they use EIP 712, which we're going to talk later here in this workshop. And on scroll.
00:09:09.904 - 00:10:16.452, Speaker A: Like why on scroll? Well, we have already some scroll videos here done with it global so you can learn more about the technology. Why is it cheaper, faster, and why is it safer, why also the community and the development is very tight with Ethereum and proven scaling explorations. And one extra thing that I would like to make an emphasis here specifically for this hackathon is that on scroll we have tested different dsls, which are the language that you use for creating CK. Daps for creating circuits, we call them. We're going to take a look at that in a moment. So we have tested the most used circuits which are circum noir, Socrates. And since scroll has good pre compiled support, you can deploy it using these dsls.
00:10:16.452 - 00:11:47.990, Speaker A: And usually, like most dapps, using most tools that use CK, you can deploy it on scroll because scroll, unlike other ckvms, have support for the most critical part for CK, the most critical like pre compiled. So yeah, it makes a good developer experience and also the community, as I mentioned, which you can find out more in the it global resources. Now I would like to just go ahead and talk about the architecture. Like if you're a CK developer, CK dub developer, if you already know solidity, maybe if you come from web two and you want to get into CK, what knowledge is translated from what you already know and what new stuff you will need to learn and where it's going to be like the heavy bulk of your work. So usually you will have a front end you can use either, I don't know angular web, three aas. In this example, we're going to use vteas, but you can use whatever front end framework that you want and you will have your inputs and maybe you'll have a bottom. Then when you click in this case, we're going to send some comments on an anonymous part.
00:11:47.990 - 00:12:39.480, Speaker A: That's the demo that we're going to do here. So from the front end you grab from the user a comment, and that comment, you are going to pass it to your wallet. And that wallet, so your metamask or whatever wallet that you're using is going to pop up and it will ask you for a signature. And that signature, you're going to pass it to a circuit. This is the new part. So maybe until that part, you may be familiar with this, but the new part here is the circuit. So in this workshop we're going to use noir, but you can also use Socrates or circum.
00:12:39.480 - 00:13:56.816, Speaker A: And the circuit is going to generate a proof. And the cool thing about the circuit is that from here on, after the circuit, the proof can be public, the proof can be public and it contains like private information, but it can be shared publicly. So that proof then is going to be passed to a relayer, because we don't want to expose or user, we want a third party to send a transaction on chain on our behalf. And that relayer is going to pass together with the proof, it's going to generate a transaction and that's going to go, of course that's going to go on chain. So as a developer, what part of these are going to be developed by us? So you are going to need to develop a front end that is an important part of the front end. And the new thing is that it has to have maybe just to throw some fancy word wasm support. So you don't need to code it.
00:13:56.816 - 00:15:06.852, Speaker A: You can use an array existing library, but you will need to use to tapping into the browser assembly code to be able to generate a proof on the browser. Because generating a proof is very resource intensive and you want to do it from your browser because you don't want to expose information to a third party, to a server, you don't want to go to an API most of the time to generate a proof for you sometimes, but for privacy app, you don't want that because you want to keep it private. So you will need to generate a proof inside your browser using WASm. The other part that you will need to focus on is of course the circuit. So the circuit is going to be reading in a, if you're not familiar with circuits, which is something super new. The interface, it's a bit similar to code, but the idea behind the circuit creating circuits is a bit different. And the other part that you may want to work on is a relayer.
00:15:06.852 - 00:16:00.280, Speaker A: So the relayer is the one that's going to send the transactions on chain. And the one that we're going to demo here is very naive. It's going to relay any transaction that makes sense. And the thing is that if you are doing, for example, a deFi application with relayers or a voting system, the relayer is going to send a transaction on chain. So the relayer is the one that pays the transaction on chain. So if you're doing like a large scale protocol and that is permissionless and open, you will need to find ways of incentivizing the relayer. So maybe the proof is passed to the relay, but when the proof is post on chain, the relayer may get a reward or something.
00:16:00.280 - 00:17:21.676, Speaker A: So there is some tokenomics here that you also usually have to think about depending on the DAP that you want to build. So yeah, this is like the general architecture and the lifecycle of a transaction, from your input in your front end to on chain and the things that will enable good user experience here is of course here a good signing method with, for example, EAP 712 and a relayer that will help you, like keeping you anonymous. That's the general architecture. Also, if you have any questions, feel free to drop it here in the chat. And we can take a look at them later on after we check out the demo. So the demo, we're going to do a Ck chat, this workshop, and we are going to do it with an anonymity set. So what does this mean? So we have a chat that only a certain amount of people can participate, a certain amount of ethereum addresses can participate, but when someone posts a comment, you know he's one of the anonymity sets.
00:17:21.676 - 00:18:08.540, Speaker A: He's one of a group. He's one of the group, but you don't know which one it is. So that's the Ck part. That's the part that we're going to anonymize and the total stack that we're going to use, which is interchangeable. The idea that I want you to get from this workshop is that you can put pieces differently, but in general you will need one of each in this stack. So you're going to need a circuit. In this case, we're going to use noir, but you can interchange it with circum or you can interchange it with maybe halo two, or also socrates.
00:18:08.540 - 00:19:32.604, Speaker A: We're going to use noir because I feel it has a super good developer experience and also it has ketchup and ECDSA support, which as I mentioned before, is a challenge and it's already implemented on Mar, and we're going to use a solidity verifier. So if you're a solidity developer, or if you have already developed smart contract and launch smart contracts, you may be familiar with this part. We're going to build a very naive node, JS relayer, and we are going to use a front end, we're going to use a WaSp prooper, we're going to use the noir library for generating proofs on the browser. We're going to use vtas, but feel free to use next as or angular or wherever you are familiarized with. And actually, I have something to confess here, that we are not going to use the EAP 712 signature, but for a good reason. We're going to do something even better. What we're going to do is that here in this QR code, there is a section about workshops and you have two links, one with the EAP 712.
00:19:32.604 - 00:20:34.384, Speaker A: If you want to take a look at how EAP 712 can be implemented using CK to offer like a cool user experience, we're going to see some screenshot about it too here. But instead we are not going to use EAP 712 because it's not compatible with the anonymity set. And the anonymity set, I think is more important than the EAP 712. But still, we're going to use a very similar to AP 712 interface, which is understandable for the user. And also at the end of this workshop, I will also make a few recommendations on what the alternatives are looking in the future for, because there's new technology coming around, signatures, and the AP 712 may get deprecated soon. And yeah, I will explain why. Okay, so now let's go into the demo prepare here.
00:20:34.384 - 00:21:21.390, Speaker A: I'm going to first run it and then we're going to look a bit to the code to see what's happening here. So here I have some comments, I have some comments and I can post a new comment and when I post it. So I already added some of my wallets from here to an anonymity set to a group. Okay? Only these particular wallets can post a message. But when I post it, no one will be able to know which one was it. So I'm going to post a message right here. When I click send, metamax pops up and will ask me to sign a message.
00:21:21.390 - 00:22:22.396, Speaker A: The important part to see here is that we are not sending transaction directly on chain, right? Because if we send it directly on chain we will get docs, we will expose our identity. Instead we are just signing a message. And then on my computer this is going to take maybe a minute or two. Also my computer is not very fast, but it's going to generate a proof on the browser and it's going to anonymize me generate approve on the browser and then it's going to send the proof to a relayer that I am already running here. So here I have a relayer that is waiting for transactions, you see some transactions that I already did. So I'm going to put some spacer here to check when the transaction is relayed. So a new transaction is going to be relayed to this relayer and it's going to be sent on chain.
00:22:22.396 - 00:23:10.480, Speaker A: So this is like a normal web two application that runs on the back end. Okay, so what I mentioned before is that the code that you as a developer will usually want to write is on the circuit, the solidity verifier and the relayer. So let's take a quick look at each of them. So the circuit, and sorry because I don't have the proper syntax highlighter here, but this is the circuit. So the circuit you can think about only like making checks and only making assertions. It just checks that something happened that's a secret. It's just like if statements.
00:23:10.480 - 00:23:55.776, Speaker A: And it's not like store or stuff like that, it's only like checking stuff. So here, what are we checking? First? We're checking if the message that was signed, like the comment that I signed is correct. It's from the user that I'm saying it is from. So I'm checking the signature. Then from the signature I get the theorem address. And finally I check if the theorem address is part of the list, but the list, just to make it more gas friendly, like just to save some gas and also make it more ck friendly. So generating a proof, it's easier and takes less time.
00:23:55.776 - 00:24:30.250, Speaker A: We're putting it on a Merkel tree. But the mercury is just a list of whitelisted users that can comment. So yeah, this is the circuit part. You just make assertions. As you can see, you make assertions here and only if only the assertions are satisfied, only if all the assertions are checked, you will get a proof. And that proof you will send it later to a smart contract. So you send the proof to a smart contract here.
00:24:30.250 - 00:25:06.936, Speaker A: Here is a smart contract that I have two smart contracts. The first one, this one is generated by the DSL. This, I didn't write out this code. You just go through a command and you generate the circuit. And then you will deploy this contract. And then from another contract you will reference this verify function provided by the first contract that you deployed. And you can add more code on top of it.
00:25:06.936 - 00:25:56.020, Speaker A: The code for this example is very simple. So first you just verify the proof that you were sent and then you add your extra logic in here, we're just storing comments in a mapping, this mapping. But you can use other logic, like for example defi, stuff like staking or the voting. And the example that we talked about just now. You can use different logic on solidity and something. If you are a solidity developer you already used to, you just have this new tool, this verify function that will help you add in these anonymity checks. And the third part that it's important is the relayer.
00:25:56.020 - 00:26:32.544, Speaker A: And the relayer actually is very dumb. You just receive some message and then just post it on chain. You can grab an RPC URL, just put it here and just ask them to send a transaction on your behalf. You just receive a signed transaction and you just post it on chain. Ethereum is equipped to do this. So it's just like very silly relayer, just send a transaction, he will send it for you to the specific contract and yeah, that's it. Other than that, you will also need to write some front end.
00:26:32.544 - 00:27:09.390, Speaker A: And during the front end you will need to ask the user for signatures and also dealing with macro trees which will be posted publicly. And for all of this, I have in the readme of this repo all the steps so you can replicate it yourself. So you will need to first generate the solidity verifier that I mentioned. So you will need to start noir. I'm going to put it like this, okay. So first you will need to install noir here. I put the commands on Linux and on Mac here.
00:27:09.390 - 00:28:00.964, Speaker A: Then you will need to generate the solidity verifier, you need to deploy it. And then you will need to generate the marker route, which by the way, usually you will usually need a new easier to use library to generate marker trees. But this is not yet developed by noir, yet by aztec. So I'm going to leave you this mechanic, which is not the best, but you can use it too. So you will generate this Merkel tree, which is the anonymity set, then you deploy the verified contract, then here how you launch the relayer and how you launch the web app, and at this point you can start interacting with it. So here, as you can see, the proof was generated. So this message should be now on the smart contract.
00:28:00.964 - 00:28:43.244, Speaker A: And here you go, it's now publicly on the smart contract. So yeah, just feel free to play around with this. If it's your first time doing CK stuff, just remember there are different types, different ways of achieving this. And yeah, I think it's a good time to experiment and have some great ideas of offering privacy. And scroll, I think is a good place to offer this privacy feature on top of this scalability feature. That is what scroll offer. A couple of things to keep an eye out.
00:28:43.244 - 00:29:49.440, Speaker A: One is that just keep an eye out for the new improvements, improving recursion, folding. There's always like new research coming and CK is getting improved in a very fast pace. And the second thing is that this example has one thing that is not very nullify friendly. So for example, we're doing a comment dap, so you won't be able to moderate it. So you will need something like plume, which I will recommend to investigate. With that, you will need some update, but it will need an update from metamask or install a metamask snap, which is already available to apply nullifiers to what we're doing, which I feel it's a friction. So asking users to install a specific metamask nap is a point of friction still.
00:29:49.440 - 00:30:28.430, Speaker A: But I invite you to learn more about plume and why it's important to use it for having nullifiers so people don't double spend, basically. So yeah, that's the talk. Thanks everyone for listening. And yeah, if you have any question, let me know. And feel free to join the telegram group, the scroll telegram group, where you will be able to get some sepolia it on scroll, and also ask us any questions regarding scroll or regarding whatever you're building. Thanks everyone.
00:30:29.680 - 00:30:42.400, Speaker B: Cheers. Thank you, Ahmed. There actually are quite a few questions, if you've got some time maybe to quickly go through them. I can read through them. Spider asked, how are we going to verify proof in architecture?
00:30:43.320 - 00:32:01.790, Speaker A: How do you verify proof? Yeah, good question. When you write a circuit in noir on your front end, as you can see here, I refresh it. But when you pass your signature to the circuit, the circuit will produce a proof, and that proof is going to be a parameter from your smart contract. So this proof is passed to the relayer, and the relayer is going to pass it on chain. And what I mean by passing it on chain is that it's going to call this function. So the smart contract, this verifier smart contract is something that I wrote, but I added the verify function and the verify function here, send proof function, receive as parameter the proof, and this function will revert if the proof is incorrect. So yeah, basically one mental model that I think would be nice to have here is that as a developers, we are used to something like this.
00:32:01.790 - 00:32:53.416, Speaker A: We have parameter a, and then we have parameter x, parameter y, and then we have parameter c. So yeah, a good friend of mine showed me this mental model that helped me a lot. So you have a function, sorry. You have x, y and seed and you have a function. So we are used to pass parameter one, parameter two, and then you will get a computation and a result. But when you're working with CK, it's a bit different. You have x, y and even the result seed.
00:32:53.416 - 00:33:49.000, Speaker A: And then you pass this to a prover and you pass this to approver and you get a proof. So yeah, it's just like a different mental model. Maybe at the beginning it may feel like super weird, but the thing that you need to take into account is that the circuit, when you pass, in this case, when you pass your signature or any parameter to the circuit, the circuit is going to give a proof to you and the proof is going to be a parameter to your smart contract. And you're going to verify the proof on your smart contract. Because of course we trust Ethereum, because it's decentralized, it's secure. So he is the perfect place to verify something. So we pass the proof to Ethereum, and Ethereum itself, it verifies.
00:33:49.000 - 00:33:51.490, Speaker A: Yeah, I don't know if that answers the question.
00:33:54.100 - 00:33:58.160, Speaker B: And another question was, is there an SDK to build the relayers?
00:33:59.860 - 00:34:44.056, Speaker A: Yeah, I haven't seen any. I think it will be actually a nice product to hack on. Yeah, an SDK for the race sounds super good. Some things to take into consideration is that there is a wide diversity of possibilities when making a relayer. You can have a very centralized one, you have an incentivized one. And how are you going to incentivize it? Is it going to be by taking turns or is it going to be by the one that will do it with the less amount of rewards? I think there is a lot of place here for innovation. Yeah, but I haven't seen like an SDK for relays.
00:34:44.056 - 00:34:46.130, Speaker A: It's something that sounds like super interesting.
00:34:47.700 - 00:34:57.140, Speaker B: Nice. There you go, people. You got a potential project I need to work on. Why do we need to sign the message if the proof is done locally?
00:34:58.200 - 00:36:01.000, Speaker A: Oh, that's a really good question. You need to sign a message because. Yeah, I didn't mention this, but an alternative, actually, technically, you don't need to sign the message, but you need to prove that you are yourself to the circuit and in a way that only you can prove it. So the first thing that may pop into your mind is, instead of using a signature, you can use your private key. What if you pass your private key to the circuit, and then that way you prove to the circuit that it's you? But the result of the proof doesn't expose your private key, it will keep it private. That schema will work fine, but for security reasons, as you may have expected it, the wallet doesn't allow developers to access the private key. So Metamask is not able for us developers to access the private key on metamask.
00:36:01.000 - 00:36:32.208, Speaker A: Neither the mnemonic, neither the private key. And I think that's fine. That's fine, because if that was possible, more phishing attack, and worse, phishing attack may occur. So the workaround that we find is, okay, we sign a message and we pass a signature. That way we can prove that it's us, but without revealing our private key. So it's security reasons. Actually, technically, we could just send our private keys instead of a signature, but.
00:36:32.208 - 00:36:35.990, Speaker A: Yeah, really good question. Something that I didn't mention that I feel is very important.
00:36:37.560 - 00:36:43.860, Speaker B: Nice. Then how did you generate plank, underscore VK soul?
00:36:44.600 - 00:37:13.084, Speaker A: Okay. It will be different for each. So for. So circum noir, which is the one that we're using. Halo two. Socrates. Each DSL, which this is what we use to build circuits.
00:37:13.084 - 00:37:57.070, Speaker A: Each DSL has a command that will generate it for you. So in the noir uses the Nargo command. It's like the noir command, so it has the cologne verifier. So as you can see here, just to test it out, I'm going to delete this. So here, I just run this command, and this will generate. Well, I have a couple of warning here, but this is from a library that I'm using, and this is going to generate the circuit for me. So I think it's very cool because you don't write it yourself.
00:37:57.070 - 00:38:18.390, Speaker A: It's the DSL or the CK framework that you're using that's going to write a solidity contract for you. I think it's very interesting. Yeah, here you go. It was generated. So whatever DSL or circuit library that you're using it will have some sort of command to generate it for you. Yeah, good question.
00:38:20.200 - 00:38:25.990, Speaker B: Nice. How does the contract verify the proof? I'm not sure if you answered this already.
00:38:27.820 - 00:38:46.510, Speaker A: Yeah, in the demo, you can go here and just to clarify, you first launch this and then you interact with this. Just here in this line of code, you interact with the contract that the DSL gave it to you.
00:38:48.400 - 00:38:54.080, Speaker B: And if we are signing the transaction to not reveal our identity, who's going to pay for the transaction?
00:38:54.500 - 00:39:43.936, Speaker A: Yeah, that's the ruler. The ruler is going to pay for a transaction. That's why there is a lot of tinkering to be made there. Like how are we going to incentivize, for example, if you are doing, for example, a small voting in your community, for example, and just for example, just with your neighborhood, with neighbors to for example, decide on which color are you going to paint the traffic sign, for example. I think it's fine, someone can sponsor the transaction. But what if you're doing like an open source project? You need to think about incentives and other projects that uses relayers. But it's not ck that.
00:39:43.936 - 00:40:15.530, Speaker A: I think it's worth getting inspired on and learn from it. It's for example, cowswap. Cowswap uses relayers. So you just sign transaction and someone's going to make a swap for you, but someone else, the relayer is going to execute it, he's going to pay the gas. So you have to reward him somehow. So I think there is a lot of lessons to be learned. Not lesson, but just to learn.
00:40:15.530 - 00:40:29.150, Speaker A: It's a good example. Like Kaosap is a good example. But yeah, that part can get quite complex. I think it's a very interesting topic. Yeah.
00:40:31.940 - 00:40:35.836, Speaker B: Somebody said the demo is very fast for me. Are there any step by step tutorials.
00:40:35.868 - 00:41:34.272, Speaker A: For beginners I like? Do you have a few? A few ones. What is a good way to point? Yeah, actually there is not a lot at this moment, but the two places that I would recommend is if you are so noir documentation is a good place to start. The documentation itself, I think it's good also Socrates. Socrates has good and comprehensive documentation for developers. For developers like both noir and Socrates has very good official documentation. You can start learning by there. And if you know Spanish, there is a layer two in Espanol, Twitter and YouTube channel that we did some collaboration.
00:41:34.272 - 00:42:08.670, Speaker A: We did like a five week workshops. But yeah, it's on Spanish. But yeah, if not Socrates, if you're totally new with Tusike, I would recommend first starting with Socrates and then trying out noir. But yeah, I would recommend trying different dsls, but yeah, starting either with socrates or noir. Unfortunately, I can point to any beginner friendly workshop because everything is very new at this point.
00:42:10.400 - 00:42:18.960, Speaker B: And so are the Merkel trees different? Depends on the contracts. Not sure if I understood the question, but maybe, you know.
00:42:19.110 - 00:42:50.808, Speaker A: Yeah, so the Merkel tree is your whitelist. You can look at the mercury like a whitelist. So you have the list of the tree, which is every whitelisted commenter in the example or voter. Another example. So every leaf is a whitelisted person. You can play around with it, you can do different things. For example, you can have one mercury.
00:42:50.808 - 00:43:48.904, Speaker A: For example, you can have a mercury of NFT holders and only NFT holders can vote. So you can have this NFT, and if you're a holder, you can vote, for example. And that's going to be only one mercury. But you can also think, for example, you can have, like in our comment tab, we can have different forums and each forum has a different Merkel tree of people that can comment on discord. You have different chat rooms and each one will have different Merkel routes. Or two dapps can use the same Merkel route because they whitelist and they can do two different things. So yeah, you can play around with it and you can just think about it as an alternative that is more efficient than using mapping of whitelist.
00:43:48.904 - 00:44:02.908, Speaker A: But that's it. It sounds a little bit fancy just because we're using this mercury root and we're using these hashing functions. But at the end of the day, it's just a whitelist here. Okay.
00:44:03.094 - 00:44:15.350, Speaker B: And somebody asked about the repo URL, but I think that was shared. Is it GitHub.com torupon DC recover inclusion proof okay, somebody shared that?
00:44:15.900 - 00:45:02.790, Speaker A: Yeah, that's it. And also you can also check this QR with our cheat sheet. So here you can look in there in the workshop repository sections, you can look for both repos. Also if you want to take a look at the other one, the EAP 712 one, which also I think is very interesting. Also we have different integration with other hackathon projects here. Like we have interaction with Anon, Hadar and Noir. So you can get started and see what you can build together in the project.
00:45:02.790 - 00:45:09.690, Speaker A: I think it can help you to get started also with other tools that scroll has.
00:45:11.100 - 00:45:17.370, Speaker B: And there was a question too about the telegram address. The scroll, telegram. Can you share that? Is that there as well?
00:45:17.740 - 00:45:19.444, Speaker A: Yeah, here is the telegram.
00:45:19.492 - 00:45:23.756, Speaker B: There you go. And just a few more questions. Are you still good for time?
00:45:23.938 - 00:45:26.510, Speaker A: No, it's good to have.
00:45:27.680 - 00:45:30.270, Speaker B: Can the circuit be written in circum? Will it be?
00:45:35.360 - 00:46:22.800, Speaker A: So the important parts that we are doing here, we are doing Merkel membership, proving. That's one thing. How do I prove that I'm part of this Merkel tree? That is something that is totally doable with circum. And we're also doing easy recover. So basically, from a signature, you get your Ethereum address. You need to use a couple of catch ups to do that, which is hard to prove. So, yeah, it's also doable with circum, but circum works a little bit differently because on, so it's just different developer experiences.
00:46:22.800 - 00:47:00.072, Speaker A: Aztec is like, okay, you already have all these libraries. You just go for it. And on circum, it's like you will install this library from here, for example, this microchip inclusion from here, and then you will install this other library from there, like the EC recorder from there, and you will make your product that way. But yeah, this is totally doable. Now, I haven't heard of something like you can. I think transpile would be the right word. Like convert your code from Noir into circum.
00:47:00.072 - 00:47:52.084, Speaker A: I don't know. How possible would that be? Yeah, something interesting. It would be something like similar to converted call from, for example, solidity to viper. A little bit more complex, of course, but something like possible. But yeah, usually what you will want to do is just use one specific stack, because then after you write your circle, your circuit, you will need to generate the proof using the same library that you use to build the circuit. So it's a bit combined there. So using multiple things at the same time sounds hard, but remember that depending on the back end.
00:47:52.084 - 00:48:33.290, Speaker A: Well, in Ck world, they call back end like the cryptographic primitive they're using back, like the snark stuff, like the matte stuff they're using in the backend. One thing that comes into my mind is that it will be nice to have the same project built on circum and on noir and on Socrates, and then compare them to see which one performs better. And by performs better, I mean which one makes the proof faster and smaller. I've heard a bit about people wanting to do stuff like this, but, yeah, I never seen it. That's something else that sounds interesting.
00:48:36.700 - 00:48:43.950, Speaker B: I think. Second to last question, what is compute Merkel tree here? Just a loop going through list. Maybe you covered this already.
00:48:45.040 - 00:48:51.028, Speaker A: Compute merkel tree. Oh, okay, so it's here, right? Compute merkle tree.
00:48:51.064 - 00:48:51.408, Speaker B: Yeah.
00:48:51.494 - 00:50:18.536, Speaker A: So basically what we're doing here is that, you know that on a mercury, for example, you have a, you have a, then you have b, then you have c and then D. You generate the merkel root by hashing a with b, c with D, and then the two hashes with the root. So let's say that this is the root r and this is, I don't know, whatever, ab and this is CD. Okay, so you hash a with b and you get this, you hash c with D and you get this and then you have this both and you get r. So for example, if you want to prove that you are member of this mercury, for example, if you are b, what do you need to prove that you're part of the mercury? You only need b and you only need a and you only need c. That's the only thing that you need. Why? Because if you have a, you hash it with you and you get Ab and then you hash it with this and you get r.
00:50:18.536 - 00:50:25.900, Speaker A: So you don't need c and D and you don't need Ab to prove that you're part of this tree. If you already know the root.
00:50:29.120 - 00:50:29.436, Speaker B: To.
00:50:29.458 - 00:51:06.228, Speaker A: Answer the question here, what does compute mercury root does. It passes the leaf as parameter, in this case b, and then the index. Okay, I am the index one as in 0123. And then you pass the hash path. So I pass A and CD. And that's the only information that you need. You need to know who you are, where you're located, and all the other nodes, the minimal amount of nodes that you need to reconstruct the Merkel route.
00:51:06.228 - 00:51:31.164, Speaker A: And yeah, that will generate merkel root. It will give you the root and that root has to be matching with the root that you provided. And where is that root stored? And this is very important. The root is stored in the smart contract. It's immutable. Actually, you can put here mutable. This is immutable.
00:51:31.164 - 00:51:58.212, Speaker A: So this is in smart contract and this is going to be there and it's going to be checked with the merkel root that you pass as parameters. So you prove your membership to this merkel root to this Merkel tree. And the root is passed to the contract and the contract checked. Okay, you prove membership to this tree. Is this the tree that I have stored on my contract? Yes. Okay. So everything is okay.
00:51:58.212 - 00:52:27.620, Speaker A: So that's the process and that's why we need here to pass this function with, basically we pass all the information we need to reconstruct the tree, the minimal part of the tree, just to get the root. So basically in summary compute merko root returns the root by providing the minimum amount of information required.
00:52:30.280 - 00:52:36.340, Speaker B: Okay, and last question. What benefit does the relayer get if he is paying for our transaction?
00:52:37.020 - 00:53:34.760, Speaker A: Yeah, in this example, he's not getting any benefits. So, yeah, here is just a sponsor that he's acting in good faith. And in this particular example, it's not too bad because we have a limited set of participants. Well, actually, yeah, it can get a little bit bad, because the thing is that the more you open the relayer, you have to protect him against two things. One, how do you incentivize him, and also how you make him not to get denial of service. Many people are sending requests because this is an open API, so you need to protect him against that too. So, yeah, relayer needs to be incentivized.
00:53:34.760 - 00:54:33.550, Speaker A: This is just like a very dummy example, just relaying everything but injured project. You normally will want a way to incentivize, also to decentralize him. And how do you make sure that there is an incentive, so you or anyone else can relay the transactions, and that way a transaction doesn't get censored. That's important too. And I love that we have a lot of thinking about the relayer, and it's also some place where we can put our web two knowledge into work to combine it with web3 to have something very robust and useful. Yeah, very good questions.
00:54:35.920 - 00:54:36.476, Speaker B: Awesome.
00:54:36.578 - 00:54:36.892, Speaker A: Cool.
00:54:36.946 - 00:55:06.192, Speaker B: Well, yeah, thanks for going over time a good amount, but there was just a lot of questions. So thank you for taking the time to answer all these, and thank you, everybody, for asking the questions as well. We got to wrap it up. So, for fun, if you want to ask that question in the telegram, that'd probably be the best way to get the response from Ahmed and the team. But, yeah, again, thank you all for the great workshop. Ahmed, thank you. Thank you for the great workshop.
00:55:06.192 - 00:55:07.910, Speaker B: And happy hacking, everybody.
00:55:08.360 - 00:55:13.430, Speaker A: Happy hacking, everyone. Thanks for being here. Yeah, thanks, Claude, for inviting us.
00:55:14.200 - 00:55:14.960, Speaker B: See ya. Bye.
