00:00:22.830 - 00:00:23.380, Speaker A: You.
00:00:25.350 - 00:00:38.740, Speaker B: Hello and welcome everyone, to the Learn Web Three dow workshop blazing fast smart contract development using Foundry. Joining us today is Hardik, who will be talking us through this session. And with that, I'll pass it over to Hardhik to get the session started.
00:00:39.270 - 00:00:48.700, Speaker C: Absolutely. Thank you, Rory. I'm just going to share my screen and to confirm you all can still see it.
00:00:49.550 - 00:00:56.540, Speaker A: We'll get started. Rory, can you see it?
00:00:56.910 - 00:00:59.578, Speaker B: Yeah, we can see it. Okay, you want to get full screen?
00:00:59.744 - 00:01:01.338, Speaker C: Yeah, perfect.
00:01:01.504 - 00:01:03.500, Speaker A: Cool. Hey guys. Hello everyone.
00:01:04.270 - 00:01:35.906, Speaker C: It's been a while since I've done an ETH global workshop. So really hyped to come back and you're to going be seeing a lot more of me around 2023 workshops. But today we are talking about smart contract development and testing using Foundry. So a little bit about me. My name is Tarzik. I have no first name legally. I'm the co founder at Learn Web Three and an education and did maximalist for this talk or workshop.
00:01:35.906 - 00:01:52.346, Speaker C: I'm going to be keeping an eye on chat. So I have chat open over here. If anybody has any questions, you can put it in chat. I'll answer sort of as I go along. As happens, feel free to pause me at any time. And yeah, try to keep this conversational.
00:01:52.458 - 00:01:54.080, Speaker A: If you have any questions.
00:01:55.250 - 00:02:43.934, Speaker C: So what is foundry? Right, so Foundry is a solidity based smart contract development environment that kind of falls into the same category of tools as like hard hat or Truffle or APWorks, which you might have used before. The main difference is that everything you do in Foundry is done in solidity. So you're writing tests in solidity. You're writing your deployment scripts and all of that in Solidity. Everything you're doing is in Solidity. Unlike for example, hard hat or Truffle where you have to do stuff in JavaScript or in APWorks or Brownie and similar, you have to do stuff in Python. Everything on Foundry is done in Solidity, and we'll see there are certain advantages to doing that.
00:02:43.934 - 00:03:35.774, Speaker C: There's actually a very good case for doing all of this stuff in Solidity as it avoids kind of that one level of abstraction that, oh, you now also need to have an understanding of JavaScript. You also need to have an understanding of how JavaScript test suites work. You also need to understand how to convert U into 256 to a big number and then back and forth and it's just really annoying. So doing everything in Solidity very helpful. That's one of the key differences. You might want to consider using Foundry for that if you're relatively newer, if you're kind of starting out, you don't have past experience in JavaScript or Python and you're learning solidity, foundry might be a better fit for you. So you can just focus on sort of solidity based stuff all around.
00:03:35.774 - 00:04:23.994, Speaker C: The second thing is, and this is actually also a pretty big deal, foundry is very fast as much as eight times faster as some of the alternatives. The reason for this is Foundry was built from the ground up. It's written in rust, first of all. And everything that Foundry uses internally was built from the ground up to sort of support this project. It's not really relying on external things as much compared to something like Hard Hat, where first of all, it's JavaScript. Then it's using the Solidity JavaScript compiler and then it's using Ethers JS. Overall, it's relatively much slower than Foundry is now for this hackathon.
00:04:23.994 - 00:05:18.560, Speaker C: If you're just starting out again, maybe this doesn't matter as much to you right now because if you have a simple project with maybe one or two solidity files, the time difference between Hard Hat and Foundry is going to be pretty negligible. And you might not notice major time differences. But as you start working on bigger projects, this time difference becomes very noticeable to the point of the SolMate Library, which is pretty famous. The SolMate Library takes 6 seconds to get compiled and be set up using Foundry, it can take up to like 45 seconds on DAP tools and even a couple of minutes if you're using Hard Hat. And that really adds up over time. So as you're trying to fix a bug, 5 seconds versus two minutes for compilation really adds up a lot. So it's pretty fast.
00:05:18.560 - 00:06:22.142, Speaker C: It's up there. So generally Foundry is kind of broken into three specific segments and we're going to take a look at a couple of them today. So there's forge, there's cast and there's anvil So Forge is the main sort of the compilation tool, the CLI, where you kind of do everything related to running, like creating a new Foundry project, compiling your contracts, running tests, all of that stuff happens with Forge. Cast is a CLI tool to sort of send transactions to the Ethereum network and so on. So you can call functions on your smart contract on any network using Cast. So it's kind of like a terminal based way to call functions and stuff on Ethereum. And Anvil is a local ethereum node that you can run for development and testing purposes.
00:06:22.142 - 00:07:02.494, Speaker C: It's kind of like hard hat Node or Truffles Ganache? So it's just a local EVM implementation that just is really fast. You can run your tests against it. You can fork a network and run it on Anvil and so on and so forth. We're mostly going to be focused on Forge today, and I'll try to take you through as much as I can about Foundry and why you should care. So let's just jump into it. We should just start writing code. So the first thing you want to do is, if you haven't already installed Foundry, if you don't already have Foundry on your machine, what you want to do is actually let me just pull.
00:07:02.532 - 00:07:04.990, Speaker A: Up the page for it because that will be easier.
00:07:05.490 - 00:07:07.346, Speaker C: There is a kernel command you have.
00:07:07.368 - 00:07:09.506, Speaker A: To run, but I will send it.
00:07:09.528 - 00:07:10.834, Speaker C: In chat, and I will also open.
00:07:10.872 - 00:07:12.740, Speaker A: The page so you can find it yourself.
00:07:13.350 - 00:07:53.570, Speaker C: But basically, yeah, if you already haven't installed Foundry, I'm on a macOS. So you just have to run this command. You need to download the Foundry up binary from Paradigm. And once you've installed Foundry Up, that is the sort of package manager for Foundry. It's kind of like the tool you use to keep Foundry up to date and install it and all of that stuff. So I already have Foundry up on my machine. And once you've downloaded it, you just type Foundry up, and it will install the latest version of Foundry, which basically means the latest version of forged cast and anvil on your machines.
00:07:53.910 - 00:07:54.610, Speaker A: Right?
00:07:54.760 - 00:08:13.894, Speaker C: So once this is all done, we will start by creating a new project. So create an empty directory. I'll call it foundry tutorial. Foundry Tutorial. And what you want to do is just type forge in it, and this.
00:08:13.932 - 00:08:20.006, Speaker A: Will forge oh, I am in the wrong folder.
00:08:20.198 - 00:08:34.814, Speaker C: Yeah, CD into the folder you create and then type forge in it. And this will set up a new Foundry project in that folder. And now let's just open this up in Vs code to see what it looks like.
00:08:34.852 - 00:08:37.920, Speaker A: And what do we have over here?
00:08:38.690 - 00:09:23.774, Speaker C: So we start off, it gives us a simple solidity contract to get started, right? We have a counter contract that just has a number. You can set that number, or you can increment that number over time. So the way things work in Foundry, as I said, everything is solidity, right? So you write your contracts in Solidity, but then you write your tests in Solidity. This is a test for that contract. And then you also write your scripts in Solidity. This is where you might want to deploy your contract to an actual network and so on. Other than that, what we have is we have a Lint folder, which comes with the Forge Standard Library installed, and we'll get into what that means.
00:09:23.812 - 00:09:25.598, Speaker A: But this is really cool stuff.
00:09:25.764 - 00:10:00.194, Speaker C: But just to get you familiar with the basic commands, the very basic commands that you must know are forge build. So once you have the project, you run Forge Build. This will compile all your Solidity files, and it says, okay, compiler run successful. And at this point, you will have an out folder that comes with the abis of all your contracts. So most of these contracts currently come from the Standard Library, but your contract counter. This is the abi for counter solve.
00:10:00.242 - 00:10:01.814, Speaker A: It comes from forge build.
00:10:02.012 - 00:10:38.946, Speaker C: Once you've built it, the another basic command you need to know is forge test. And forge tests, as the name suggests, runs the tests against your contract, runs the tests that you wrote. And the cool thing about this is it actually gives you the gas cost required to run each one of your tests. Since your tests are written in solidity and you're calling other solidity functions, it can tell you the gas cost for that test. And in fact, if you do fuzz testing, which we'll get into, it also gives you the average gas price and the average gas cost and the median.
00:10:38.978 - 00:10:41.126, Speaker A: Gas cost required to run that test.
00:10:41.308 - 00:10:46.406, Speaker C: So forge, build and forge test. Two basic commands you must know.
00:10:46.508 - 00:10:47.160, Speaker A: Okay.
00:10:49.630 - 00:11:28.902, Speaker C: So this contract obviously is super simple, but we'll get into a couple of neat Foundry features that will show you kind of why it's so cool. So we'll start off by creating a new contract. First of all, we'll create a new contract. Let's call it Mirror Soul. And this is going to be an extremely simple contract. I'll just copy paste this. This is going to be an extremely simple contract, which all it does, it has a function called Mirror, which takes in a number X, and then it returns the same number back, unless that number is 50.
00:11:28.902 - 00:11:57.118, Speaker C: If X is 50, then it returns 42. But otherwise, it just returns X back. So 99% of the cases, it will just return the same number back. But then there's this one sort of edge case where it will return 42. So what we want to do is we'll create a test file. For this, we'll create a test file. And the convention with Foundry is your test files are named Contract T Sol.
00:11:57.118 - 00:12:32.294, Speaker C: So the contract name is Mirror. So this will be mirror T sol. Once we have this test file, we write the tests as a regular, solidity contract. And I will copy paste this because I already have it. But we'll walk through this ourselves. So what's happening over here? So, first of all, we import the testing framework, quote unquote, from the Ford Standard Library. And the Ford Standard Library comes from this lib folder over here, right? You can look at the tester sol file that we're importing.
00:12:32.294 - 00:13:07.426, Speaker C: It basically imports a bunch of other files and re exports it. But it allows us to write tests and solidity. And then we import the actual contract that we're testing, which is Mirror sol. With that, we declare a new contract. Mirror test is Test, and then we have a function called Setup. So every test will have a function called Setup, which initially sort of sets up the testing environment. Specifically, in this case, it deploys a new version of the mirror contract and saves it as a state variable.
00:13:07.426 - 00:13:44.222, Speaker C: So you can call functions on the same contract over and over in your following tests. Then we have two test functions over here. Again, the convention in Foundry actually, I think this is enforced is your test functions must begin with the term Test. So you cannot have a function named simple. Over here, you have to name it like Test Simple or Test XYZ. So you have a super simple test called Test Simple. And we're like okay, assert equals mirror, mirror, five and five.
00:13:44.276 - 00:13:45.818, Speaker A: So this is just checking. Okay.
00:13:45.924 - 00:14:18.566, Speaker C: If I call the mirror function with x equals five, it should return me five and it should be equal. And if it's not equal, the test will fail. So the assert equal nice helper function comes built into the testing standard library. And it's pretty basic test over here. This one is more interesting. So Foundry has support for what's called Fuzz testing. And what Fuzz testing basically means is it can sort of so in this case, we're setting x equals five ourselves.
00:14:18.566 - 00:14:24.400, Speaker C: We're setting x equals five manually. But in the Fuzzing test, you'll see.
00:14:25.010 - 00:14:26.480, Speaker A: Did somebody say something?
00:14:28.370 - 00:14:38.820, Speaker C: So in the Fuzzing test, we take x as an argument and then we just pass that argument forward. Can I send Mirror Sol?
00:14:40.070 - 00:14:44.740, Speaker A: Sure. I don't know if I should put it in chat, but there you go.
00:14:47.190 - 00:15:24.078, Speaker C: In the first test, we take an argument and we pass that argument. So we're not testing for a specific value of x, but what Fuzz testing does. And this is a more general concept than just Foundry. This is more general sort of computer science related stuff. But Fuz testing basically means that the tester itself, the testing framework itself will try to find random inputs to your function. It will try to find random inputs to your function, and it will try all of them out. And if it fails at any one input, it will let you know.
00:15:24.078 - 00:16:04.762, Speaker C: So in this case, it will try out different values of x and it will assert equals on all of those values of x. And if it fails at some point it will let you know. So you might have guessed what's going to happen over here if we run this test. What we are going to do is let's go back to our terminal and type forge test. And it may not detect it the first time because it's not running as many times right now. So by default, that's a good question in the chat relief, by default, Foundry tests 256 values randomly. So it runs for 256 times randomly.
00:16:04.762 - 00:16:49.906, Speaker C: And currently that's not enough to find the obvious issue in our code. And it depends on your sort of tolerance. So first testing is not 100% guarantee. You can't have it run like all infinite values. You need to set some sort of limit and to do that in this case so Foundry comes with a Foundry TOML file. This is sort of the configuration file. If you've used hard hat before, it's kind of like the hard hat config JS file where you can set different configuration values for Foundry and specifically for Fuzz testing, what you can do is add a Fuzz parameter and set Foundry underscore, Fuzz underscore runs.
00:16:49.906 - 00:16:59.834, Speaker C: And I'll set it to say, 1000 random runs, right? And if I run force test again, it's still passing.
00:16:59.962 - 00:17:00.798, Speaker A: There we go.
00:17:00.884 - 00:17:33.258, Speaker C: It tests with random values every time. So increase the number of runs even more if you wanted to test even more values. But in this case you can see it says test fuzz failed with the argument 50, right? So we didn't tell it to run x equals 50. It just randomly failed with the argument 50. So it was testing for random values. And this fuss testing is very useful. And this is obviously a very simplified example.
00:17:33.258 - 00:18:24.490, Speaker C: Looking at this code, you can clearly tell the mirror function isn't behaving as it should. But typically these bugs aren't this easy to find. You can imagine some sort of complicated D five protocol with 100 validity files all across the project, all sort of importing each other and inheriting from each other and having all the fancy stuff around there. And sometimes it's easy to skip out on certain edge cases. Oh, a multiplication is going wrong somewhere, or there's some dangling if condition that's going to given a certain input, it's going to do something that's not expected of it. So sometimes manual testing fails to patch certain types of bugs that Fuzz testing can help you to catch. And it's really useful that Foundry comes with Fuzz testing as a built in feature.
00:18:24.490 - 00:19:10.970, Speaker C: And all you have to do is just take an argument, take an argument in your tests and pass that argument forward and it will automatically generate random values for those arguments. That's all you need to do. Can you define a range for those numbers? If you had to define a specific range, you're probably better off just using a regular test function instead because you know a min and max value for it. If it's a really large maximum value, I think there's probably a way I'm going to have to look in the config for it. But I do not know that off the top of my head right now, unfortunately. Okay, great question though. So that's for fuz testing.
00:19:10.970 - 00:19:51.814, Speaker C: Now what else? I want to show you one more cool thing about Foundry. So let's go ahead and create another new contract and we'll call this one cheat codes. Solve and cheat codes are really cool. So we'll create a super simple contract. Again, we have this contract called cheat codes which stores a number and a last timestamp. And it has one function called set number which takes in a parameter new number. And it just requires that the current block timestamp is greater than the last timestamp plus 120.
00:19:51.814 - 00:20:52.940, Speaker C: So this basically means that set number is being called at least two minutes after last timestamp. So because blocked up timestamp returns the timestamp in seconds. So we're saying that the current timestamp is greater than the last timestamp plus 120 seconds two minutes. And then if that is true, then we update number equals new number and we set last timestamp equals lots of timestamp. Okay, again, a simplified example, but you can think of things like the compound governance mechanism or like time lock related things where certain functions can only be called in certain time intervals. Very useful feature to have generally on a smart contract, but can be a pain in the ass when you're testing for it. How do you test for it? You don't want your tests to wait for two minutes just because your function cannot be called again until two minutes.
00:20:52.940 - 00:21:27.890, Speaker C: Ideally, you want to do some sort of happy things around there and make it believe that two minutes have passed. And this is where cheat codes come in. So we'll create a test for this. We'll call this cheat codes P sol, and cheat codes P sol. What we're going to do actually, let me type this out. So I'll set up the basic boilerplate structure for it. Same as before, contract cheat codes test as test imports the standard testing library and imports the cheat code solidity file.
00:21:27.890 - 00:22:17.650, Speaker C: So we'll take a reference to the cheat code smart contract. And in our setup function, we'll just deploy the cheat code smart contract. And what we will also do actually this is fine for now. So we'll deploy the sheet code smart contract. Now, when this is deployed, when this is just deployed initially, last timestamp equals zero, right? That's a default value for a unit in solidity. This is equals to zero. One thing you have to note is when tests are being run, they're being run in sort of a simulated EVM environment, right? And initially when your tests start running, your block timestamp is also equal to zero.
00:22:17.650 - 00:22:27.000, Speaker C: They're not connected to a real network. It's equal to zero initially. So in that case, if we just try calling set number right now.
00:22:29.210 - 00:22:29.574, Speaker A: Can.
00:22:29.612 - 00:22:31.394, Speaker C: Somebody tell me what are cheat codes?
00:22:31.442 - 00:22:34.122, Speaker A: Yeah, we're getting to it. We're getting to it.
00:22:34.176 - 00:23:14.162, Speaker C: So right now, cheat codes is just the name of this contract. And I'm going to get into what Foundry cheat codes actually are. So if we have a test, something like test set number, and we just do cheat set number five right now, this test will fail. And why will this test fail? Because when the test starts running, block timestamp is going to be zero. And zero is not greater than zero plus 120 initially. So this test right now, as it is, will fail.
00:23:14.306 - 00:23:16.486, Speaker A: And we can see that if I.
00:23:16.508 - 00:23:30.434, Speaker C: Just do forge test once more. This is the mirror test, but cheat code test over here, test set number failed with the reason error.
00:23:30.582 - 00:23:35.166, Speaker A: Right? And that is the reason in the.
00:23:35.188 - 00:24:02.626, Speaker C: Required statement over here. So currently this test is failing because zero is not greater than zero plus 122. Things to note. First thing, you can actually create failing tests in Foundry. So you can expect a certain test to fail, and that is okay. So the way to do that is to change the name from test set number to test fail set number. So this will tell Foundry we want this test to fail.
00:24:02.626 - 00:24:07.382, Speaker C: And that's expected behavior. So now if I run Foundry test.
00:24:07.436 - 00:24:11.126, Speaker A: Once more, now, if I run Foundry.
00:24:11.158 - 00:24:45.066, Speaker C: Test once more, you'll see everything passed, everything is good. It expected that test to fail, and that's perfectly fine. But now what if we want to call the set number function once again? So create another test, set number Blick, and we do a set number again. And this runs into the same problem. Block timestamp hasn't moved forward by two minutes. This is where Foundry cheat codes come in. So Foundry has a bunch of cheat codes.
00:24:45.066 - 00:25:10.102, Speaker C: They're basically things that allow you to alter the state of your execution environment. They allow you to change things in the EVM or how the contract is behaving. So that's why it's called a cheat code. These things do not work on a real ethereum network. They only work within the Foundry sort of environment. And they're meant to make your testing easier and faster.
00:25:10.166 - 00:25:10.780, Speaker A: Right.
00:25:11.330 - 00:26:01.340, Speaker C: Specifically in this case, what we want to do is there is a cheat code called and cheat codes, by the way, are called virting, like VM cheat code name. So VM is something that's built into the standard library for forge. And it's kind of like the virtual machine, the EVM. And you're making direct sheet code calls to it. So you say VM warp 150, let's say. And the warp sheet code, what this does, warp sheet code increases block timestamp by whatever value you tell it to. So when we do VM warp 150, it's going to move block timestamp to 150 and then call the set number function so our tests will immediately pass.
00:26:01.340 - 00:26:26.340, Speaker C: And on a real ethereum network, it's the same thing as actually waiting for two minutes to go by. And you can see this time, nothing failed this time. Cheat codes. Both of the tests passed over here. This is not the only cheat code that Foundry has available to you. There are actually a bunch of cheat codes that are really cool. Let me show you the list.
00:26:26.340 - 00:26:46.540, Speaker C: And there are a bunch of cheat codes. We don't have time to go through all of them, but warp is one of the first ones you see here. Sets the block timestamp to whatever you want it to. You can change the block difficulty. You can change the block number. You can change the block coinbase. You can change a whole bunch of things.
00:26:46.540 - 00:27:41.114, Speaker C: My favorite one has to be Prank, where you can behave as a different address even if you don't have the private key for it. It's really useful in cases of things. Like if you're testing something against an ave flash loan and you need money to pay back the flash loan. I just prank as some whale somewhere and just take 10 million die from them and do the alloy flash loan thing. Prank is pretty cool, but they have a bunch of cheap codes you can use and change a lot about the EVM within your testing environment, which makes things easier. Last thing before we head off we're almost at time is a common question is how do we use all these other libraries we're familiar with. I want to use Open Zeppelin contracts, I want to use Solate, I want to do all these things.
00:27:41.114 - 00:28:11.334, Speaker C: Open Zeppelin contracts by default were designed for hard hat. They weren't designed for Foundry, but Foundry supports them through you have to do something called remappings. And let's say you wanted to create an NFT collection. So what you do is you type, forge, install OpenZeppelin contracts, which is their GitHub repo, their GitHub organization GitHub repo. And what this is going to do.
00:28:11.452 - 00:28:13.398, Speaker A: Well, it's going to download, it's going.
00:28:13.404 - 00:28:23.450, Speaker C: To get cloned the repo into your project. And specifically it's going to put it in the Lid folder next to the Ford Standard Library.
00:28:24.350 - 00:28:27.386, Speaker A: If you notice over here, you know.
00:28:27.408 - 00:28:43.060, Speaker C: How we are able to do import for Standard Library test sole. So basically you can import things from your Lib folder, including Open Zeppelin contracts, and you can also change how these imports work.
00:28:44.870 - 00:28:45.970, Speaker A: Let me just show you.
00:28:46.040 - 00:29:30.800, Speaker C: So Forge comes with this thing called remappings. By default, it has support for three remappings, which is the forge, Standard Library, Open Zeppelin contracts, and DS test. So what this basically means is typically if you have a contract over here, let's say counter sol, and if I had to import from the Lib folder, it would typically look something like this. I'm in the SRC directory. So I go back, I go into Lib, I go into Open Zeppelin contracts, and then yada, yada yada, whatever I do. This isn't very clean, doesn't look nice. remappings allows you to kind of remap those paths so your imports can look clean.
00:29:30.800 - 00:30:03.174, Speaker C: It comes with the OpenZeppelin contracts Remap built in. So instead of typing Lib OpenZeppelin contracts, I can just do import OpenZeppelin contracts, whatever. So if I have NFP soul over here, I can just import it like that, import openzeplin contract, yada yada yada. And Forge will figure out because of remappings that it's supposed to grab it from Lib OpenZeppelin contracts and whatever.
00:30:03.372 - 00:30:04.762, Speaker A: And we can see this.
00:30:04.896 - 00:30:08.540, Speaker C: If I do Forge build, it should build without any issues.
00:30:09.070 - 00:30:10.134, Speaker A: There we go.
00:30:10.272 - 00:31:07.566, Speaker C: You can also have custom remappings. So if you take this remappings and you output it to a file called remappings. TXT, you can now create your own remappings. For example, for a library that's not supported by default. Like if you're cloning the Ave repo or the Uniswap repo or whatever, you can create your own remappings for it over here. But as an example, let's say I want to create a Remapping called ERC 721, which equals to Lib openzeppelincontractstokenerc 721. With this Remapping, I can change my import to just be ERC 721, ERC 721 sol, because it takes me directly into that specific folder where I need to go.
00:31:07.566 - 00:31:16.862, Speaker C: And now again, if I move forward build oops fail to resolve file. Something went wrong. Found a tutorial.
00:31:16.926 - 00:31:17.570, Speaker A: Lib.
00:31:22.310 - 00:31:25.170, Speaker C: Year 6721 equals lib.
00:31:25.510 - 00:31:27.570, Speaker A: I messed something up over here.
00:31:27.720 - 00:31:31.400, Speaker C: Open ziplin contracts oops. Oh yeah, it needs to be open.
00:31:37.050 - 00:31:39.638, Speaker A: Now. If I do a force build, you'll.
00:31:39.654 - 00:32:03.454, Speaker C: See it works perfectly fine. So yeah, that is all I wanted to cover about Foundry today. Bunch of cool stuff. We covered fuz testing, we covered cheat codes, remappings and imports. It's obviously pretty fast. My compiles have been taking less than 1 second to finish on Hard hat. This would generally take decently longer.
00:32:03.454 - 00:32:08.260, Speaker C: And yeah, I'll take a look at chat now for any other questions.
00:32:09.030 - 00:32:17.990, Speaker A: Oops. I did not mean to stop sharing my screen. I just meant to close Vs code. So let's go back to the slide deck.
00:32:19.450 - 00:32:22.360, Speaker C: And there we go.
00:32:24.650 - 00:32:35.594, Speaker A: Cool. So yeah, guys. What? Yeah, so that is that.
00:32:35.712 - 00:32:37.290, Speaker C: Thank you for listening.
00:32:38.510 - 00:32:40.010, Speaker A: Take a look at a chat.
00:32:40.510 - 00:33:12.454, Speaker C: Yeah, if you want to learn more about building in Web Three general just learning about Web Three in general, hit us up at learn web three at learnweb three IO. Or you can find us on Twitter and Discord. We're always there if you have any questions. Says remapping raises some errors. It did not find the file. You have to create a remappings TXT file in the root of your project. You can either do that manually or you can run forge remapping TXT to.
00:33:12.492 - 00:33:14.600, Speaker A: Input it directly over there.
00:33:15.050 - 00:33:56.806, Speaker C: I do not use emacs. I am a Vs code pleb I don't know. For a complete beginner between Hardhut and Foundry, it kind of depends on your background. If you already know JavaScript and you're just getting started in the space and you're only making small projects, hardat is probably easier because you already have that knowledge. But there will come a point in larger projects where Hardat starts getting a little bit annoying. And changing between data types for solidity and JavaScript can get a little bit tedious. You have to constantly convert data types back and forth, at which point doing Foundry would be better.
00:33:56.806 - 00:34:14.842, Speaker C: However, there's nothing stopping you from just starting off with Foundry. At most you'll learn some even more solidity. With that point, your install fails. Are you on Windows or Linux or macOS? What error are you getting?
00:34:14.976 - 00:34:16.300, Speaker A: I'm not sure.
00:34:18.590 - 00:34:29.966, Speaker C: Can we expect a defined reason on the test fail? So actually what you can do is you can log things. I did not show that, but let.
00:34:29.988 - 00:34:30.702, Speaker A: Me bring that up.
00:34:30.756 - 00:34:37.010, Speaker C: So when you're creating test files.
00:34:39.830 - 00:34:40.146, Speaker A: They.
00:34:40.168 - 00:35:15.390, Speaker C: Have a bunch of logging helpers in the standard library. So you can do stuff like log underscore UN or log underscore string or log underscore address, whatever it may be. And if you run it, you need to run it with a verbose mode. So if you just do like forged test, these logs will not show. But if you. Do like forged test v with verbose output. It will show you all these logs regarding defining specific reasons, specifically for asserts.
00:35:15.390 - 00:35:33.102, Speaker C: What you can do over there is if you look at all the different assert helpers that exist I showed you assert equals. There's a bunch of other ones, but you can optionally provide a string.
00:35:33.246 - 00:35:34.434, Speaker A: I don't know if this is very.
00:35:34.472 - 00:35:44.102, Speaker C: Readable, but you can optionally provide a string with the two arguments for assert equals or any of the other asserts, which will be the error that shows.
00:35:44.156 - 00:35:50.522, Speaker A: Up if an issue happens. Yes, boundary was written in Rust top.
00:35:50.576 - 00:36:01.600, Speaker C: Three vs. Code solidity Developer extensions. I think I just use one, really, which I believe is just visual solidity developer. I believe that's what it's called.
00:36:01.970 - 00:36:03.006, Speaker A: This one.
00:36:03.188 - 00:36:11.114, Speaker C: That's pretty much the only thing I use. I used to use some of the hard hat extensions, but this one covers.
00:36:11.162 - 00:36:19.220, Speaker A: Most of what I need, typically. Um, cool.
00:36:20.310 - 00:36:22.562, Speaker C: Sounds like that's pretty much all the questions.
00:36:22.616 - 00:36:25.170, Speaker A: I don't know if I missed anything, but yeah.
00:36:25.240 - 00:36:34.866, Speaker C: Thanks, everyone. We're overtime. Rory, I'll give it back to you. And, yeah, check us out at learn. Web three, and if you have any questions, reach out.
00:36:34.888 - 00:36:37.010, Speaker A: We'll get back to you. Cheers.
00:36:37.550 - 00:36:43.720, Speaker B: Cheers. Thanks so much for joining us today. Great presentation. And, yeah, as hardly said, reach out if you have any questions.
