00:00:15.610 - 00:00:46.810, Speaker A: Awesome. Well, thank you everyone for joining us today. Joined by session from Biconomy, I will let him give a quick intro. As I said in the chat, you are more than welcome to post your questions throughout the event. If they come up, I will funnel them to him and we'll do things in a little bit more of a personal me. If you have any questions afterwards, feel free to put them in discord and continue the conversation there in the Biconomy Sponsor channel. But without further ado, Sachin, if you'd like to begin, Floor is all yours.
00:00:47.550 - 00:02:05.906, Speaker B: Thanks, Luke. Hey everyone, this side Sachin here. So I'm the CTO and co founder at Biconomy and today I'll be speaking about Biconomy, what it does, and we have few products that I'll be walking you through giving you some demos and how you can actually use those products into your projects and make a superlative user experience in your application. So, talking just very briefly, talking about Pyconomy, it's a transaction infrastructure platform, very focused towards the developers. So the infrastructure which we have is majorly to be used by the web3 developers to improve the user experience in their application. So what Bycony does is we have some SDKs and APIs exposed which developers can use. And using Biconi, you can abstract away all the blockchain transaction complexities in your application and let your users use your application built on blockchain in a pretty seamless and in a very easy way to say.
00:02:05.906 - 00:03:33.226, Speaker B: So, to start with, Biconomy has right now three products for the developers in order to improve the user experience at the blockchain transaction level. One is a gasless product. So this product allow DAP developers to enable gasless transactions in their application. So, Biconomy is supporting a number of blockchains right now, including Ethereum, Polygon, XTI, Binance, Smart chain and all of their testnets. Just now we went live with Moonbeam also on the Polkadot ecosystem and arbitram optimism are something which we are going to support soon. So if you are building on any of these blockchains, you can use Pyconomy to enable these user experience on your application. So, in terms of gasless transaction, so this is a case where your users does not pay the gas fees for doing transactions on the blockchain, but the DAP developers, they subsidize those costs on behalf of their users.
00:03:33.226 - 00:04:45.666, Speaker B: So eventually DAP developers are the one who are paying the gas fees and users get to use the application in a very frictionless way. They don't need to worry about storing the native currency of the blockchain in their wallet, for example. So usually this product is used on the blockchains where gas fees is very low, where it's very practical for the DAP developers to sponsor the fees on Ethereum. Of course, it doesn't make sense for all the developers to sponsor the Ethereum gas fees and for such kind of blockchains where the gas fees is quite high, we have another product called Forward. Forward actually allows you to pay the gas fees not in native currency but in ERC 20 token. And we are supporting the stable coins to make it easy to for the bookkeeping of how much gas you have paid for a particular DAP or on an application. So it's easy to record all of these if you are paying in stable coins.
00:04:45.666 - 00:05:41.814, Speaker B: And Biconomy behind the scenes is actually taking care of paying for those transaction in the native currency and getting back those gas fees from the user itself in the ERC 20 tokens. So in this product, DAP developers does not need to bear any cost, it's the end user who are directly paying the fees. But in ERC 20 Tokens and another product which we have is called Hyphen. It's about transferring your funds across different chains. Right now we support ethereum and polygon. If you want to transfer your USDC, USDT or Ether, you can use Hyphen to instantly transfer your funds across these two blockchains and new blockchains will be coming soon. So yeah, these are the three products you can use.
00:05:41.814 - 00:06:26.790, Speaker B: I will walk you through them one by one. Mainly the gasless and the Hyphen. So let's start with the gasless one. So, to enable gasless transactions in your application, there are some prerequisite that needs to be done. First thing is your smart contract on the chain needs to be metatransaction compatible. And there are many ways in order to make your smart contract metatransaction compatible. And even there are some smart contract that exists also in Ethereum today.
00:06:26.790 - 00:07:26.938, Speaker B: For example, if you take an example of Dai or USDC Token smart contract, they do support permit functions, which actually is a case of metatransaction where user is providing his signature and anyone can actually submit that transaction on chain and they will be able to provide that permit without spending any gas fees at all. So whoever is submitting, they are of course paying the gas fees. So this sort of functionality can be enabled in any smart contract. And I'll tell you how you can do it. There are two major ways using which you can implement. This one is a custom implementation. In the custom implementation you write all the logic of enabling native meta transaction within your smart contract itself.
00:07:26.938 - 00:08:25.790, Speaker B: So it's a standalone smart contract with all the functionality written in the smart contract itself. But we recommend, if you are building new contracts, we recommend you to go for this standard implementation. It has its own EIP and telling you how you can actually enable the smart contract. And it's a standard which most application use. So I will explain more about this standard. So if you just take example of a meta transaction, how it works, usually user who is actually doing the transaction, instead of sending the transaction directly to the blockchain, they provide a signature. They provide a signature from their wallet and then that signature is passed on to a relayer.
00:08:25.790 - 00:09:46.246, Speaker B: And then relayer is the one who will actually craft a blockchain transaction using that signature and they will sign that transaction. That relay will sign the transaction and send to the blockchain and on the blockchain using that user signature, some signature verification will happen just to make sure that no one should be able to submit any information on the behalf of the end user. So that's why that signature is very important here and replay attack mechanism are implemented on chain. That happens and then eventually whatever smart contract you are calling, that is called. And if your smart contract is not metatransaction compatible, then there will be a problem if someone else is sending the transaction on the smart contract. Message sender would be the relays address and that would fail the purpose of the transaction. So when we say you enable metatransaction support by that we mean you get rid of dependencies on some fields like message sender, message value and message sender and message value.
00:09:46.246 - 00:10:55.658, Speaker B: So if your smart contract is not depending on these fields then your smart contract is metatransaction compatible, right? And how you do it, let me just go straight to this EIP 2771 implementation. So implementing this EIP is very straightforward. This is your smart contract you inherit a base relay recipient smart contract you can use openjsn implementation also and there is also open Zeppelin implementation and you can just search EIP 2771 open Zeppelin smart contracts so you can just inherit those smart contracts. So after inheriting you will be asked to override some functions, in this case you will be asked to override this version recipient. It's just a normal function for the versioning purpose. You can just return any version over here. This does not depend on any logic in your smart contract.
00:10:55.658 - 00:12:01.086, Speaker B: And the main thing is this trusted forwarder smart contract. So there will be a trusted forwarder field which you need to set in your smart contract while inheriting this smart contract. And these trusted forwarders are standard smart contract that have already been deployed these supported blockchains. So if you are using Biconomy, you can just go to the contract addresses and go to the EIP two seven seven section, you can see different blockchains are there and you can see Biconomy forwarder smart contract address. So here you will find those trusted forwarder addresses over here and once you initialize this field, you are done. Like the part on the smart contract is done. And if you see the flow, like how the meta transaction flows in this case, on the client side user will sign a message if he wants to initiate a transaction.
00:12:01.086 - 00:13:16.022, Speaker B: That message is sent to byconmy relayers. And then here, one of the relayers is chosen and it will send the transaction to the blockchain, but it will not send the transaction directly to your DAP. It will send it to a trusted forwarder. And then here signature verification happens replay attack protection mechanism is implemented and then eventually whatever address trusted forwarder will get from the signatures, that address will be appended in the call data and then whatever smart contract you were intended to call that will be called. Your business logic will be executed, your transaction is executed and the message sender which earlier we were using. Yeah, one thing I think I skipped on the smart contract after setting the trusted forwarder as I earlier mentioned, you have to get rid of this message sender dependency. So what you will do is wherever you are using this, you will just replace it with this method.
00:13:16.022 - 00:14:12.314, Speaker B: And this method you will find inside this base relay recipient contract. And whenever this method is invoked, the actual user address is returned. So even if any relayer is actually sending the transaction, in case of merit transaction flow, this method will return the address of the user itself who has actually signed that message and sent to the relayer. So that way we are keeping the actual user address in the business logic and the transaction is executed. Relayer pays the gas fees, user also does not pay any gas fees and their transaction is also executed. So this is the flow. So far we have covered all the changes you need to do on the smart contract level once they are done.
00:14:12.314 - 00:14:54.486, Speaker B: Now it's time to do the client side implementation how you will take those signatures from the user and pass on to the biconry relayer infrastructure. So in order to make it easy, we have SDK which we call MexA SDK that allows you to easily integrate this on your client side code. And we do have a dashboard where you can register your application. You will get an API key. I will quickly walk you through the dashboard flow. Also this is a dashboard, very simple dashboard. Just log in with your Credential.
00:14:54.486 - 00:15:32.934, Speaker B: If you are just register with your email and verify your email, log in with your Credential and here you can see this list of applications you would be creating. So in order to create adapt, just go to register, select any network. So these are the network which we support. Right now, Ethereum Mainnet is not open to everyone. So if you are building a DAP on the Ethereum Main net, you can just contact us and we'll enable this access on your email ID. Just give any name, select the network. You will be having something like this.
00:15:32.934 - 00:16:00.362, Speaker B: And if I want to open, let's say let me open this DAP, you will just click view DAP. Here you will see all the details related to your application. You will see one API key. This will be used on the client side when you will use the SDK. And on the smart contract section you will have a add contract button. Just go here, type any name you want. This is just for the display purpose.
00:16:00.362 - 00:17:00.180, Speaker B: Give the address of your smart Contract give the Abi and here you need to select what type of metatransaction you are implementing. If you have enabled the custom approach, do this but in case of EIP 2771 you need to select the trusted forwarder over here and then you click Add. Your Smart Contract will appear here and then go to manage API section. This is the part where now you are moving to the Smart Contract method level like Smart Contract is added. Now you will tell the Biconomy that this is a method on which I want to enable my meta transactions. So let's say all the Smart Contract will appear here and all your methods will appear here and you can select any of the method. Just make sure whatever method you are selecting the native meritransaction support is enabled on the Smart Contract level, right? Otherwise it won't work.
00:17:00.180 - 00:17:55.870, Speaker B: So yeah, that method you can select, just give it like any name add, you can select multiple methods over here and once you are happy with all the methods you can just click Save and your methods will reflect here. Don't worry about this API ID at all like SDK internally takes care of. Yeah, so this is all the things which you need to do on the dashboard. Just log in, create an application, upload Smart Contract and select the methods on which you want to enable gasless transaction. Pretty easy, right? Or there are other customization which you can do. There are some metatransaction limits you can set. For example, this is a DAP on ethereum.
00:17:55.870 - 00:19:04.934, Speaker B: And if I want to put a limit on the DAP level, for example, I just want to spend only one ether from my side to be spent on these gaslage transaction. Across whole DAP whatever user are using my application. I just want to put a limit on the usage that I can do and that usage can be with the duration. Like every day I want to spend one ether, or every seven days I want to spend one ether at the DAP level or I can say let me sponsor only 100 meta transactions on my DAP every day. So these sort of settings you can also enable at the DAP level you can do per API level. Per API means per Smart Contract method level and as well as you can enable it at the user level. So you want to say for each user I want to sponsor 100 meta transactions every four days, right? These sort of customization you can do over here and let's go back to the documentation.
00:19:04.934 - 00:19:51.618, Speaker B: Now we'll talk about the SDK part. Luke, let me know if there are any questions in between. So yeah, SDK is JavaScript based implementation you can use on the client side. If your application is not based on the JavaScript platform, maybe you are building a mobile application. In those scenarios you can use the APIs directly. I'll come to it later but let me go through the SDK first. So consider Biconomy SDK as a wrapper around Web Three, around the provider object which you get from your wallets.
00:19:51.618 - 00:20:33.122, Speaker B: So it's a wrapper around a Web Three provider and in order to use it, just install it via NPM. In order to initialize it, just import it and create a new instance of Biconomy. These are the parameters which you need to pass. So this is the Web Three provider object which you will get from your wallet. So if you are using let's say MetaMask, this will be window Ethereum. And similarly if you are using any other wallet, every wallet will provide you a provider object. Just pass it over here, API key I mentioned you will get on the dashboard.
00:20:33.122 - 00:21:03.422, Speaker B: This is the API key which you will set and you can mention Debug True to print the debug logs in the console while developing. And when you are initializing this Web Three library, instead of passing this Web Three provider, just pass the Biconomy object. So as I mentioned, it's a wrapper around the Web Three provider. So you can use it the way you use the Web Three provider in your application. We support Web Three. We support ethers. JS also.
00:21:03.422 - 00:22:15.400, Speaker B: So any of the library you can use Biconomy initialization is the same in both the case. Once you have created an instance of Biconomy and an instance of Web Three library, then you need to listen for this Pycony ready event. Once this event is received, that means Pyconmy SDK is initialized fully and you are ready to write all your DAP initialization code and you can do whatever you want to do after this. Now the initialization part is done. Now how will you initiate your transactions from the client side? So the good thing is there is no change in the way you are calling your smart contract methods from the client side. It will still remain the same. You will create your contract from your Web Three or if you are using Ethers, just create a contract instance and the way you initiate a transaction from the client side, you can do it in the same way.
00:22:15.400 - 00:22:56.514, Speaker B: There are some snippets over here using Web Three. If you want to use EIP seven one two signature, there are these combination, you can see the code Snippet over here and if you want to see the full example code, there is a repository over here. You can just go to the GitHub and see all the working code over here. And there is literally no change in the way you are calling your smart contract method. It's pretty same. You call the contract method, you will get a transaction object, you listen for its transaction hash and confirmation. Everything remains the same.
00:22:56.514 - 00:23:42.334, Speaker B: So internally like SDK handles all the things like for example if you are initiating a transaction, we need a user signature, right? So you don't see any signature like any code related to taking signature because everything is inside the SDK, it will take care of getting the signature from the user. I'll quickly show you a demo code. So, let me go through this repository. So this is the same repository which you will go from here. Metadransaction standard. It will have a playground branch. Just make sure you are on the playground branch and there is an example and react UI folder.
00:23:42.334 - 00:24:14.250, Speaker B: This is where you will find the UI code. And just do this. So, this repository has all the different combination you can think of using a web3 library combination. And then the metatransaction approach. Whether you are using custom approach or EIP 2771 approach and then the signature combination, you can ask for personal signature. You can ask for EIP seven one two type signatures. So this is initialized.
00:24:14.250 - 00:24:43.618, Speaker B: Let me just try to do a transaction over here. All this application, all these tabs are on coven network by the way, on this branch. So, let me see the logs also here. Okay. So let's say I am writing this code. This is a very simple smart contract. I am just writing this code on the smart contract using Meta transactions.
00:24:43.618 - 00:25:13.242, Speaker B: So, I don't need to pay any gas fees for submitting this transaction. So when I click submit, my connected wallet asks me for a signature. So this I provide the signature. Now the transaction is being handled by the MexA SDK. It has routed the transaction to Bicon mirror layers and they have sent the transaction to the blockchain. And I'll get the transaction hash. I'll listen for the confirmation and the transaction would confirm on the blockchain.
00:25:13.242 - 00:25:49.782, Speaker B: So, if you see it is already confirmed, it's on the coven network. And if we see the transaction hash, let me see it over here, explorer is still waiting to show the confirmed UI. But if you see the from address over here, this 4455 is not the address which I have in my wallet. Like it's. Seven F, three B, right. So this is the case of Metatransaction. Even though I sent this transaction, this is one of the Biconry relayers who has sent the transaction and paid this amount of transaction fee.
00:25:49.782 - 00:26:08.722, Speaker B: The transaction is executed on the smart contract. And you can see the quote is actually reflected over here. So everything is done. I didn't need to pay any any gas. So, this is the case of Meta transaction. This is the custom approach. By the way which I showed you.
00:26:08.722 - 00:26:38.714, Speaker B: Let me show you one EIP 2771 approach. You can just click on any combination here. Let it initialize. Yeah. So here, this is another smart contract. Here, let me write another quote over here. So earlier which you saw the message, this message is actually different.
00:26:38.714 - 00:27:29.802, Speaker B: So as I mentioned in EIP 2771, the signature verification is actually done by the trusted forwarder smart contract. And if you see this is the Biconomy forwarder smart contract where the signature will be going and this is a signature which I will be signing and I sign this and again transaction is handled by the SDK relate to Biconomy relayers. They will send the transaction to the blockchain and return the transaction hash. And on the application I'll just wait for the confirmation. Again this Metatransaction has gone through. If you see again, this is like another new relayer is chosen by Biconomy and this transaction went through this relayer this time. But the logic remains the same.
00:27:29.802 - 00:28:18.570, Speaker B: On the smart contract, whatever I am intended to do, this is executed. I didn't have to pay any gas fees because this relates in the transaction. Now the main thing which I wanted to focus here is this is a smart contract where the transaction went. Now this is not my DAP smart contract address, this is a trusted forwarder smart contract. And if you see the internal transaction, there is another internal transaction that went to this smart contract. Now this is my DAP where my DAP is actually hosted. So in case of EIP 2771 there will not be any direct transaction on my smart contract.
00:28:18.570 - 00:29:04.998, Speaker B: All the transaction which you will find in the internal transactions, this is 1 minute ago. And here you can find all the Meta transaction this way. So yeah, this was the demo and how you can actually enable gaslash transactions in your application. You have to go through the dashboard, you have to integrate SDK on the client side and on the smart contract. Just make sure your contract is metatransaction compatible using EIP 2771 standard. So this was the gasless product. Any doubts? Let me see the chat.
00:29:05.094 - 00:29:18.510, Speaker A: If got some quick questions, I didn't want to interrupt your flow there. We have a few questions. Should DAPs pay an initial fee to enable smart contract to use gasless transactions?
00:29:20.050 - 00:30:24.210, Speaker B: So if you're using Biconomy right now on some blockchains, you have to pre fund the gas to byconomy and then Biconomy will take care of spending the gas fees for your DAP transactions using our relayers. On some blockchains we are actually sponsoring the fees on behalf of you because it's not very much like for example on polygon, the gas fees is very low. So if you are just getting started, you can use Biconomy on polygon, even on polygon mainnet and we will not charge you any gas fees. We will sponsor the gas fees for initial two or three months and you can just test it out if everything you like it. And then after that you can just pre fund some gas fees for your application and then we'll take care of using those funds to pay the gas fees for your transactions.
00:30:27.030 - 00:30:41.910, Speaker A: Right on. I hope that answers the question. Feel free to come off mute if you'd like to ask a follow up. We have another question in the chat. Any information on integration of gasl's transactions with money streaming using superfluid?
00:30:45.710 - 00:31:17.440, Speaker B: I don't have any code snippet or any example regarding that integration, but it can work with any smart contract that has metatransaction support, be it fluid smart contracts or any smart contract. Just make sure there is a metatransaction support on the smart contract level and you can use Pyconmy to do the gasless transaction over there. Excellent.
00:31:17.520 - 00:31:39.740, Speaker A: Well, if anyone has any further questions, feel free to again hop off mute and go ahead and ask while you have a minute. We'll hold on for just a second if there's any further questions, but if that helps everybody and we're all good to go. I think we can wrap our session right here. Session, thank you so much for presenting.
00:31:40.480 - 00:31:44.030, Speaker B: No, I have more to present.
00:31:44.800 - 00:32:13.272, Speaker A: It's great having you. It's great having the Biconomy team here again. We're really excited to have you guys back and this is really cool stuff. I'm really excited to see what the hackers build with during the event. As we stated earlier, if you have any questions you didn't think of or if you didn't want to ask right now, feel free to drop them in the chat in discord in the Biconomy sponsor channel. That will be a great way to gain the resources you need. Sechin will probably be there himself helping throughout the event.
00:32:13.272 - 00:32:16.040, Speaker A: So if you're building with Biconomy, look no further.
00:32:17.100 - 00:32:18.484, Speaker B: Do we have more time, Luke?
00:32:18.532 - 00:32:21.908, Speaker A: Because no rush, no rush.
00:32:22.084 - 00:32:23.396, Speaker B: Okay, take a few more minutes.
00:32:23.438 - 00:32:24.524, Speaker A: Go for it.
00:32:24.722 - 00:33:20.620, Speaker B: Yeah. So I want to cover this product also here in this workshop. As I earlier mentioned, this is a product you can use to enable instant and cheap transaction across Ethereum and Polygon. So this is like we have in terms of Hyphen. We have also made an user interface where anyone, a normal user can come over here and use the Hyphen product, move their funds across Ethereum and Polygon. First I'll show you this demo and then I'll walk you through this documentation and about how you can actually integrate this product in your application. So you can actually build use case, different use case using Hyphen SDK.
00:33:20.620 - 00:33:55.320, Speaker B: So this is the user interface. I want to transfer my Ether. So these are the supported tokens. I just want to move my ether from ethereum to Polygon very quickly. For example, now there are existing bridges, like official bridge which Polygon has made between Ethereum and Polygon. If you want to move your ether via that bridge, you can do that. But from Ethereum to Polygon it will take you like ten minutes to move your funds.
00:33:55.320 - 00:34:36.768, Speaker B: And while from polygon back to Ethereum, it will take you 45 minutes or even like 1 hour for you to move your funds. But if you are using Hyphen, this all can happen instantly. If you see, if I want to, let's say, move 0.1 ether from ethereum to Polygon, there is some liquidity provider fee. This is like 0.1% of the amount that is being transferred, there is a transaction fee associated to it. So the flow would be like this, where you will deposit this ethereum on a liquidity pool manager smart contract on Ethereum.
00:34:36.768 - 00:35:14.224, Speaker B: And there are some executor nodes which Pycony is running, who are constantly monitoring these deposit transactions. Once they see this, there is another liquidity pool contract on polygon. They will just initiate a transaction from that pool to release whatever amount you want to transfer. Now, of course, the transaction which this executor will be doing on Polygon will have some transaction fees associated to it. So this is that transaction fee. And this is zero. Because we are sponsoring all the transaction on polygon because the gas fee is very low.
00:35:14.224 - 00:35:38.932, Speaker B: So we can do that. So that's why you will just have to pay this 0.1% fee for the liquidity providers and you will get this much amount of ether on the polygon. So let me try to do this transfer now. I'll do a transaction on Ethereum. In order to deposit this asset on liquidity pool manager. Let me check the gas prices.
00:35:38.932 - 00:36:18.740, Speaker B: What are the gas prices? And accordingly, I will just send this transaction. Let me choose this and let me send this transaction on ethereum. So if you see the transaction is broadcasted, it's pending. It has confirmed on the blockchain. Now let's wait for the transaction to happen on polygon. Now, off chain executors must be listening to this transaction and they must have initiated a transaction on polygon. And where I will get my Ether instantly on polygon.
00:36:18.740 - 00:36:41.352, Speaker B: So, okay, the transaction is already done. If I want to see, I can see it on the Polygon explorer. This was done like 20 seconds ago. And I can confirm my wallet address also seven F, three B. So this is my wallet address. And I have been transferred this much amount of ether. So this happens like instantly.
00:36:41.352 - 00:37:20.596, Speaker B: I didn't have to wait ten minutes or even 1 hour. If you see the details, it happened like within 6 seconds from Ethereum to polygon. So if I want to move funds across different chains very quickly, you can actually use Hyphen to do that. And this is the transaction fee that was involved with this transaction. So there was nothing charged about this transaction from the end user. This is something Biconomy is sponsoring because it's pretty low, right? So yeah, this is the transaction. If you want to move from, let's say, polygon to Ethereum.
00:37:20.596 - 00:38:20.024, Speaker B: And if you, let's say, want to move this much amount again. Now there will be some transaction fee associated because executors will need to do a transaction on ethereum blockchain and they will have to pay the transaction fee. So since Ethereum is not very cheap in terms of transaction fee, so that's why this is the amount which Hyphen has guessed that this would be the transaction fee that executors will need to pay. So going from polygon to Ethereum, this is. The fee also to be deducted from the amount you are transferring and then you will get the remaining amount on the Ethereum. So now let's come back to the documentation on how you can actually enable this sort of user interface within your application. Also the code for this UI is actually open source.
00:38:20.024 - 00:38:59.572, Speaker B: So if you want to check the implementation, you can just go to the Bicone repository and the name is right now insta exit demo. I should probably change the name, but yeah, this is the repository for this user interface which you are seeing here. So you just want to refer the code. You can go to this repository. I'll quickly walk you through how it works. How you can use the SDK SDK to enable this. So as I mentioned, just there are two liquidity pool smart contract on each chain and then there are executor nodes.
00:38:59.572 - 00:40:12.736, Speaker B: They have like watchtower to monitor these deposits transaction which users are doing. And based on that, there are some executors who will initiate these cross chain transactions across these blockchain. So from an end user point of view, you do not need to know what's happening behind the scenes. As you saw on the UI, everything is pretty seamless. And talking about the SDK like how you can actually use this as I told you about the MexA SDK where the gaslash transactions were done, where the user sign a signature, send the transaction to bicon mirror layer and then they will send the transaction to the blockchain, right? So in this case, this does not happen that way. You do not need to send any transaction to any relayer, but you can just directly call the deposit method of the liquidity pool manager smart contracts by yourself. Also, even if you just want to test it out, let me show you interacted with this is the address.
00:40:12.736 - 00:41:10.420, Speaker B: You can see the same address on Ethereum. This is a liquidity pool manager. If you just want to do a cross chain transfer, just you can interact with this smart contract and you can just directly call deposit ERC 20 method if you are moving ERC 20 tokens and deposit native if you want to transfer ether because ether is a native currency on ethereum, so you can just directly call these methods. The executor will still be listening to these incoming transactions and they will complete your crosschain transfers. So even if without using SDK, you can check out these cross chain transfer by yourself. But in order to make it very easy to do the integration to interact with these smart contracts and then also you want to check the status of your transactions when the transaction is done on the other side of the chain. So in order to ease all of these operations, we have built a Hyphen SDK.
00:41:10.420 - 00:41:56.876, Speaker B: You can install it the same way you use MexA SDK. Just install it, import it and then initialize it again using a provider object you will get from your wallet. And then there are these other extra options you can actually pass environment if you are doing it on the test network. So Go Early and Mumbai are the test networks for ethereum and polygon. You can mention the network here. And there is some optional callback method whenever the crosschain transfer is completed SDK will actually call this method. Callback and you will get to know that your transaction is actually completed.
00:41:56.876 - 00:42:21.770, Speaker B: So this is the way you can opt for the confirmation, for the status updates of your crosschain transactions. And once you initialize it, you can just call in it to initialize the SDK. You can use a weight over here. This is an improvement over the Mexico SDK, where there were some callbacks. But yeah, here there are no callbacks. You can just use a weight. Over here.
00:42:21.770 - 00:43:19.164, Speaker B: And in order to before you do a transaction, of course, if you are trying to deposit some, ERC, 20 token in a smart contract, you need to give approval also to that smart contract. So there are some pre deposit checks you can actually do using the Hyphen SDK. So you can just call Hyphen pre deposit status, pass the token address you want to transfer amount from chain ID to chain ID, user address and SDK. Will actually do these checks for you. Whether everything is okay to proceed or if allowance is not given for that particular token, then you will get to know that I need to first give one approval to the liquidity. Pool manager smart contract. And it will also check these from chain ID to chain ID whether they are supported by Biconomy or not.
00:43:19.164 - 00:43:57.464, Speaker B: So you will get errors like unsupported network. It will also check whether there is enough. Liquidity on the destination chain for your transactions to be fulfilled. So if there is no liquidity on the other side of the chain, it will warn you before you do this deposit transaction and these sort of error handling. You can actually do before you actually call the deposit method. And once everything is okay, once you get the response code okay, you can actually proceed to do the deposit transaction. And again, as I mentioned, either you can directly interact with this or from the code.
00:43:57.464 - 00:44:24.716, Speaker B: If you want to do it, you can just call the deposit method of the Hyphen sender address, receiver address and by the way, these two can be different on the receiving. Side. You can have these tokens in a different wallet altogether. So maybe you want to move from polygon to your Binance wallet, for example. So you can just put your know application address in the receiver. Or you deposit. On polygon.
00:44:24.716 - 00:45:08.220, Speaker B: You will get it on your binance application that's also you can do token address, deposit contract address will be the liquidity pool manager address and this is the address. And this is same address is deployed on polygon also, so it's easy for you to use. These addresses amount from chain ID to chain ID. This is an optional flag. You can also use Biconomy gas less transaction in Hyphen also. Again, if you want to make this deposit also gasless for the end user. So on polygon, actually you can do this.
00:45:08.220 - 00:45:34.376, Speaker B: So in order to make it easy, you can actually use Biconomy over here. I will not go too much into Biconomy integration in Hyphen. It will be too much. But you can actually go through the documentation over here. How? You can use Biconomy also to enable gasless transaction in Hyphen deposit methods also. So yeah, I mean this is the final thing which you need to do. Once you have called the deposit method, your part is done.
00:45:34.376 - 00:47:14.856, Speaker B: Now you will just need to wait for its confirmation. Wait for Hyphen executors to complete your cross chain transfers and wait for the transaction confirmation on the destination chain. Now, next part is how will you get to know when the transaction is initiated on the other side of the chain or what is that status? So either you can just go to these helper methods, either you can pass this callback method in the constructor itself or if you don't want to do this you can also call this Hyphen SDK method check deposit status, pass the deposit hash and the from chain ID where you have done the deposit transaction. It will tell you whether the cross chain transfer has been initiated or not, if it is initiated, whether it is still in processing state or whether the transfer is actually processed. So you will get to know the status of your transaction using this method also so you can either periodically check this in your application or if you don't want to check this periodically, you can opt for this callback method. Hyphen SDK will actually check this internally for you on a periodic basis. So yeah, this way you can actually integrate Hyphen in your application also like within the application you can actually give this experience of cross chain transfers using Hyphen and maybe you want to enable more use cases on top of it.
00:47:14.856 - 00:48:36.210, Speaker B: Maybe you want to make your own smart contracts on top of Hyphen Liquidity Pool Manager to enable swaps. Like if you want to transfer ether here and you want to receive USDC on the destination chain you can actually build these use cases on top of Hyphen by building those custom smart contracts by your own that works on top of the liquidity pool manager smart contracts. And maybe swaps can be implemented using Hyphen SDK. Or I think we have published some bounties but it will be good if you can make let's say a widget for the Hyphen where a plug and play widget would be there using this maxdk internally and you can just plug and play in any application where some standard interface like this maybe or another interface will come up and everything will happen like this. And integration would be easy for any application to just drop this widget in their page and enable this communication within that application only. So these sort of use cases you can build using Hyphen. And that's all from my side.
00:48:37.540 - 00:49:03.976, Speaker A: Thank you. Thank you for that. I'm really excited. I apologize. We do need to get moving to the next session, but thank you for showing us through the Hyphen app and really excited for people to implement that in their hacks. Again, connect with Session in Discord and the rest of Economy team. I know we were pretty close there, but I think there's probably a little bit more information he can impart on you.
00:49:03.976 - 00:49:09.630, Speaker A: But is that okay with you? I mean, is there a good place to connect with you if they have further questions?
00:49:10.240 - 00:49:22.560, Speaker B: Yeah, you can reach out to Discord. We have the Sponsor channel also, but you can also reach out to Biconomy's Discord channel also. So any channel is telegram discord.
00:49:23.300 - 00:49:30.700, Speaker A: Excellent. Excellent. Well, thank you so much. I apologize we're short on time here, but thank you so much for presenting. It's been really incredible.
00:49:30.860 - 00:49:38.130, Speaker B: Yeah, thanks, Luke, for allowing me to present here. And yeah, looking forward to some great hacks over here. Thanks.
00:49:38.500 - 00:49:44.630, Speaker A: Going to be a fun month. All right, we're going to be closing this stream here. Our next session in ten minutes. So we're going to run.
